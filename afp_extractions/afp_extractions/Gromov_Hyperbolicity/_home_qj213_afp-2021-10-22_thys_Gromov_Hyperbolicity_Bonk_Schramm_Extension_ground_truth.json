{"file_name": "/home/qj213/afp-2021-10-22/thys/Gromov_Hyperbolicity/Bonk_Schramm_Extension.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Gromov_Hyperbolicity", "problem_names": ["lemma wo_aux_exists:\n  \"Card_order wo_aux \\<and> \\<not>finite (Field wo_aux) \\<and> regularCard wo_aux \\<and> |UNIV::'a Bonk_Schramm_extension_unfolded set| <o wo_aux\"", "lemma map_aux_AboveS_not_empty:\n  assumes \"map_aux`S \\<subseteq> Field wo_aux\"\n  shows \"wo_aux.AboveS (map_aux`S) \\<noteq> {}\"", "lemma map_aux_in_Field:\n  \"map_aux x \\<in> Field wo_aux\"", "lemma middle_rel_a:\n  \"(map_aux a, map_aux (middle a b)) \\<in> wo_aux - Id\"", "lemma middle_rel_b:\n  \"(map_aux b, map_aux (middle a b)) \\<in> wo_aux - Id\"", "lemma cauchy_rel:\n  \"(map_aux (u n), map_aux (would_be_Cauchy u)) \\<in> wo_aux - Id\"", "lemma Bonk_Schramm_extension_unfolded_wo_props:\n  \"well_order_on UNIV Bonk_Schramm_extension_unfolded_wo\"\n  \"\\<forall>x \\<in> range basepoint. \\<forall>y \\<in> - range basepoint. (x, y) \\<in> Bonk_Schramm_extension_unfolded_wo\"\n  \"\\<forall> a b. (a, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\"\n  \"\\<forall> a b. (b, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\"\n  \"\\<forall>u n. (u n, would_be_Cauchy u) \\<in> Bonk_Schramm_extension_unfolded_wo\"", "lemma Bonk_Schramm_extension_unfolded_wo_props':\n  \"a \\<in> wo.underS (middle a b)\"\n  \"b \\<in> wo.underS (middle a b)\"\n  \"u n \\<in> wo.underS (would_be_Cauchy u)\"", "lemma wo_adm_extend_distance:\n  \"wo.adm_wo extend_distance\"", "lemma extend_distance_fp:\n  \"extend_distance_fp = extend_distance (extend_distance_fp)\"", "lemma extended_distance_symmetric:\n  \"extended_distance x y = extended_distance y x\"", "lemma extended_distance_basepoint:\n  \"extended_distance (basepoint x) (basepoint y) = dist x y\"", "lemma extended_distance_set_basepoint:\n  \"basepoint x \\<in> extended_distance_set\"", "lemma extended_distance_set_middle:\n  assumes \"a \\<in> extended_distance_set\" \"b \\<in> extended_distance_set\"\n  shows \"middle a b \\<in> extended_distance_set\"", "lemma extended_distance_set_middle':\n  assumes \"middle a b \\<in> extended_distance_set\"\n  shows \"a \\<in> extended_distance_set \\<inter> wo.underS (middle a b)\"\n        \"b \\<in> extended_distance_set \\<inter> wo.underS (middle a b)\"", "lemma extended_distance_middle_formula:\n  assumes \"x \\<in> wo.underS (middle a b)\"\n  shows \"extended_distance x (middle a b) = (extended_distance a b)/2\n    + (SUP w\\<in>wo.underS (middle a b) \\<inter> extended_distance_set.\n          extended_distance x w - max (extended_distance a w) (extended_distance b w))\"", "lemma extended_distance_set_Cauchy:\n  assumes \"(would_be_Cauchy u) \\<in> extended_distance_set\"\n  shows \"u n \\<in> extended_distance_set \\<inter> wo.underS (would_be_Cauchy u)\"\n        \"\\<forall>eps > (0::real). \\<exists>N. \\<forall>n \\<ge> N. \\<forall>m \\<ge> N. extended_distance (u n) (u m) < eps\"", "lemma extended_distance_triang_ineq:\n  assumes \"x \\<in> extended_distance_set\"\n          \"y \\<in> extended_distance_set\"\n          \"z \\<in> extended_distance_set\"\n  shows \"extended_distance x z \\<le> extended_distance x y + extended_distance y z\"", "lemma extended_distance_pos:\n  assumes \"a \\<in> extended_distance_set\"\n          \"b \\<in> extended_distance_set\"\n  shows \"extended_distance a b \\<ge> 0\"", "lemma extended_distance_middle:\n  assumes \"a \\<in> extended_distance_set\"\n          \"b \\<in> extended_distance_set\"\n  shows \"extended_distance a (middle a b) = extended_distance a b / 2\"\n        \"extended_distance b (middle a b) = extended_distance a b / 2\"", "lemma extended_distance_Cauchy:\n  assumes \"\\<And>(n::nat). u n \\<in> extended_distance_set\"\n      and \"\\<forall>eps > (0::real). \\<exists>N. \\<forall>n \\<ge> N. \\<forall>m \\<ge> N. extended_distance (u n) (u m) < eps\"\n  shows \"would_be_Cauchy u \\<in> extended_distance_set\"\n        \"(\\<lambda>n. extended_distance (u n) (would_be_Cauchy u)) \\<longlonglongrightarrow> 0\"", "lemma to_Bonk_Schramm_extension_isometry:\n  \"isometry_on UNIV to_Bonk_Schramm_extension\"", "lemma (in Gromov_hyperbolic_space) Bonk_Schramm_extension_unfolded_hyperbolic:\n  fixes x y z t::\"('a::metric_space) Bonk_Schramm_extension_unfolded\"\n  assumes \"x \\<in> extended_distance_set\"\n          \"y \\<in> extended_distance_set\"\n          \"z \\<in> extended_distance_set\"\n          \"t \\<in> extended_distance_set\"\n  shows \"extended_distance x y + extended_distance z t \\<le> max (extended_distance x z + extended_distance y t) (extended_distance x t + extended_distance y z) + 2 * deltaG(TYPE('a))\"", "lemma (in Gromov_hyperbolic_space) Bonk_Schramm_extension_hyperbolic:\n  \"Gromov_hyperbolic_subset (deltaG(TYPE('a))) (UNIV::('a Bonk_Schramm_extension) set)\"", "theorem (in Gromov_hyperbolic_space) Morse_Gromov_theorem':\n  fixes f::\"real \\<Rightarrow> 'a\"\n  assumes \"lambda C-quasi_isometry_on {a..b} f\"\n          \"geodesic_segment_between G (f a) (f b)\"\n  shows \"hausdorff_distance (f`{a..b}) G \\<le> 92 * lambda\\<^sup>2 * (C + deltaG(TYPE('a)))\"", "theorem (in Gromov_hyperbolic_space) Morse_Gromov_theorem2':\n  fixes c d::\"real \\<Rightarrow> 'a\"\n  assumes \"lambda C-quasi_isometry_on {A..B} c\"\n          \"lambda C-quasi_isometry_on {A..B} d\"\n          \"c A = d A\" \"c B = d B\"\n  shows \"hausdorff_distance (c`{A..B}) (d`{A..B}) \\<le> 184 * lambda^2 * (C + deltaG(TYPE('a)))\"", "lemma Gromov_hyperbolic_invariant_under_quasi_isometry_explicit':\n  fixes f::\"'a::geodesic_space \\<Rightarrow> 'b::Gromov_hyperbolic_space\"\n  assumes \"lambda C-quasi_isometry f\"\n  shows \"Gromov_hyperbolic_subset (752 * lambda^3 * (C + deltaG(TYPE('b)))) (UNIV::('a set))\"", "theorem Gromov_hyperbolic_invariant_under_quasi_isometry':\n  assumes \"quasi_isometric (UNIV::('a::geodesic_space) set) (UNIV::('b::Gromov_hyperbolic_space) set)\"\n  shows \"\\<exists>delta. Gromov_hyperbolic_subset delta (UNIV::'a set)\""], "translations": [["", "lemma wo_aux_exists:\n  \"Card_order wo_aux \\<and> \\<not>finite (Field wo_aux) \\<and> regularCard wo_aux \\<and> |UNIV::'a Bonk_Schramm_extension_unfolded set| <o wo_aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Card_order wo_aux \\<and>\n    infinite (Field wo_aux) \\<and>\n    regularCard wo_aux \\<and> |UNIV| <o wo_aux", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Card_order wo_aux \\<and>\n    infinite (Field wo_aux) \\<and>\n    regularCard wo_aux \\<and> |UNIV| <o wo_aux", "have *: \"\\<forall>r \\<in> {|UNIV::'a Bonk_Schramm_extension_unfolded set|}. Card_order r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>{|UNIV|}. Card_order r", "by auto"], ["proof (state)\nthis:\n  \\<forall>r\\<in>{|UNIV|}. Card_order r\n\ngoal (1 subgoal):\n 1. Card_order wo_aux \\<and>\n    infinite (Field wo_aux) \\<and>\n    regularCard wo_aux \\<and> |UNIV| <o wo_aux", "have **: \"\\<exists>(r::(nat + 'a Bonk_Schramm_extension_unfolded set) rel).\n    Card_order r \\<and> \\<not>finite(Field r) \\<and> regularCard r \\<and> ( |UNIV::'a Bonk_Schramm_extension_unfolded set| <o r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       Card_order r \\<and>\n       infinite (Field r) \\<and> regularCard r \\<and> |UNIV| <o r", "by (metis card_of_card_order_on Field_card_of singletonI infinite_regularCard_exists[OF *])"], ["proof (state)\nthis:\n  \\<exists>r.\n     Card_order r \\<and>\n     infinite (Field r) \\<and> regularCard r \\<and> |UNIV| <o r\n\ngoal (1 subgoal):\n 1. Card_order wo_aux \\<and>\n    infinite (Field wo_aux) \\<and>\n    regularCard wo_aux \\<and> |UNIV| <o wo_aux", "then"], ["proof (chain)\npicking this:\n  \\<exists>r.\n     Card_order r \\<and>\n     infinite (Field r) \\<and> regularCard r \\<and> |UNIV| <o r", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>r.\n     Card_order r \\<and>\n     infinite (Field r) \\<and> regularCard r \\<and> |UNIV| <o r\n\ngoal (1 subgoal):\n 1. Card_order wo_aux \\<and>\n    infinite (Field wo_aux) \\<and>\n    regularCard wo_aux \\<and> |UNIV| <o wo_aux", "unfolding wo_aux_def"], ["proof (prove)\nusing this:\n  \\<exists>r.\n     Card_order r \\<and>\n     infinite (Field r) \\<and> regularCard r \\<and> |UNIV| <o r\n\ngoal (1 subgoal):\n 1. Card_order\n     (SOME r.\n         Card_order r \\<and>\n         infinite (Field r) \\<and> regularCard r \\<and> |UNIV| <o r) \\<and>\n    infinite\n     (Field\n       (SOME r.\n           Card_order r \\<and>\n           infinite (Field r) \\<and>\n           regularCard r \\<and> |UNIV| <o r)) \\<and>\n    regularCard\n     (SOME r.\n         Card_order r \\<and>\n         infinite (Field r) \\<and> regularCard r \\<and> |UNIV| <o r) \\<and>\n    |UNIV| <o\n    (SOME r.\n        Card_order r \\<and>\n        infinite (Field r) \\<and> regularCard r \\<and> |UNIV| <o r)", "using someI_ex[OF **]"], ["proof (prove)\nusing this:\n  \\<exists>r.\n     Card_order r \\<and>\n     infinite (Field r) \\<and> regularCard r \\<and> |UNIV| <o r\n  Card_order\n   (SOME x.\n       Card_order x \\<and>\n       infinite (Field x) \\<and> regularCard x \\<and> |UNIV| <o x) \\<and>\n  infinite\n   (Field\n     (SOME x.\n         Card_order x \\<and>\n         infinite (Field x) \\<and> regularCard x \\<and> |UNIV| <o x)) \\<and>\n  regularCard\n   (SOME x.\n       Card_order x \\<and>\n       infinite (Field x) \\<and> regularCard x \\<and> |UNIV| <o x) \\<and>\n  |UNIV| <o\n  (SOME x.\n      Card_order x \\<and>\n      infinite (Field x) \\<and> regularCard x \\<and> |UNIV| <o x)\n\ngoal (1 subgoal):\n 1. Card_order\n     (SOME r.\n         Card_order r \\<and>\n         infinite (Field r) \\<and> regularCard r \\<and> |UNIV| <o r) \\<and>\n    infinite\n     (Field\n       (SOME r.\n           Card_order r \\<and>\n           infinite (Field r) \\<and>\n           regularCard r \\<and> |UNIV| <o r)) \\<and>\n    regularCard\n     (SOME r.\n         Card_order r \\<and>\n         infinite (Field r) \\<and> regularCard r \\<and> |UNIV| <o r) \\<and>\n    |UNIV| <o\n    (SOME r.\n        Card_order r \\<and>\n        infinite (Field r) \\<and> regularCard r \\<and> |UNIV| <o r)", "by auto"], ["proof (state)\nthis:\n  Card_order wo_aux \\<and>\n  infinite (Field wo_aux) \\<and> regularCard wo_aux \\<and> |UNIV| <o wo_aux\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation wo_aux: wo_rel wo_aux"], ["proof (prove)\ngoal (1 subgoal):\n 1. wo_rel wo_aux", "using wo_aux_exists Card_order_wo_rel"], ["proof (prove)\nusing this:\n  Card_order wo_aux \\<and>\n  infinite (Field wo_aux) \\<and> regularCard wo_aux \\<and> |UNIV| <o wo_aux\n  Card_order ?r \\<Longrightarrow> wo_rel ?r\n\ngoal (1 subgoal):\n 1. wo_rel wo_aux", "by auto"], ["", "primrec map_aux::\"'a Bonk_Schramm_extension_unfolded \\<Rightarrow> nat + 'a Bonk_Schramm_extension_unfolded set\" where\n  \"map_aux (basepoint x) = wo_aux.zero\"\n  | \"map_aux (middle a b) = wo_aux.suc ({map_aux a} \\<union> {map_aux b})\"\n  | \"map_aux (would_be_Cauchy u) = wo_aux.suc ((map_aux o u)`UNIV)\""], ["", "lemma map_aux_AboveS_not_empty:\n  assumes \"map_aux`S \\<subseteq> Field wo_aux\"\n  shows \"wo_aux.AboveS (map_aux`S) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AboveS wo_aux (map_aux ` S) \\<noteq> {}", "apply (rule AboveS_not_empty_in_regularCard'[of S])"], ["proof (prove)\ngoal (6 subgoals):\n 1. |S| <o wo_aux\n 2. map_aux ` S \\<subseteq> Field wo_aux\n 3. S \\<subseteq> S\n 4. Card_order wo_aux\n 5. regularCard wo_aux\n 6. infinite (Field wo_aux)", "using wo_aux_exists assms"], ["proof (prove)\nusing this:\n  Card_order wo_aux \\<and>\n  infinite (Field wo_aux) \\<and> regularCard wo_aux \\<and> |UNIV| <o wo_aux\n  map_aux ` S \\<subseteq> Field wo_aux\n\ngoal (6 subgoals):\n 1. |S| <o wo_aux\n 2. map_aux ` S \\<subseteq> Field wo_aux\n 3. S \\<subseteq> S\n 4. Card_order wo_aux\n 5. regularCard wo_aux\n 6. infinite (Field wo_aux)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>map_aux ` S \\<subseteq> Field wo_aux; Card_order wo_aux;\n     infinite (Field wo_aux); regularCard wo_aux; |UNIV| <o wo_aux\\<rbrakk>\n    \\<Longrightarrow> |S| <o wo_aux", "using card_of_UNIV ordLeq_ordLess_trans"], ["proof (prove)\nusing this:\n  |?A| \\<le>o |UNIV|\n  \\<lbrakk>?r \\<le>o ?r'; ?r' <o ?r''\\<rbrakk> \\<Longrightarrow> ?r <o ?r''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>map_aux ` S \\<subseteq> Field wo_aux; Card_order wo_aux;\n     infinite (Field wo_aux); regularCard wo_aux; |UNIV| <o wo_aux\\<rbrakk>\n    \\<Longrightarrow> |S| <o wo_aux", "by blast"], ["", "lemma map_aux_in_Field:\n  \"map_aux x \\<in> Field wo_aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_aux x \\<in> Field wo_aux", "proof (induction)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. map_aux (basepoint x) \\<in> Field wo_aux\n 2. \\<And>x1a x2.\n       \\<lbrakk>map_aux x1a \\<in> Field wo_aux;\n        map_aux x2 \\<in> Field wo_aux\\<rbrakk>\n       \\<Longrightarrow> map_aux (middle x1a x2) \\<in> Field wo_aux\n 3. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> range x \\<Longrightarrow>\n           map_aux xa \\<in> Field wo_aux) \\<Longrightarrow>\n       map_aux (would_be_Cauchy x) \\<in> Field wo_aux", "case (basepoint x)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>x. map_aux (basepoint x) \\<in> Field wo_aux\n 2. \\<And>x1a x2.\n       \\<lbrakk>map_aux x1a \\<in> Field wo_aux;\n        map_aux x2 \\<in> Field wo_aux\\<rbrakk>\n       \\<Longrightarrow> map_aux (middle x1a x2) \\<in> Field wo_aux\n 3. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> range x \\<Longrightarrow>\n           map_aux xa \\<in> Field wo_aux) \\<Longrightarrow>\n       map_aux (would_be_Cauchy x) \\<in> Field wo_aux", "have \"wo_aux.zero \\<in> Field wo_aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero wo_aux \\<in> Field wo_aux", "using Card_order_infinite_not_under wo_aux_exists under_empty wo_aux.zero_in_Field"], ["proof (prove)\nusing this:\n  \\<lbrakk>Card_order ?r; infinite (Field ?r)\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>a. Field ?r = under ?r a\n  Card_order wo_aux \\<and>\n  infinite (Field wo_aux) \\<and> regularCard wo_aux \\<and> |UNIV| <o wo_aux\n  ?a \\<notin> Field ?r \\<Longrightarrow> under ?r ?a = {}\n  Field wo_aux \\<noteq> {} \\<Longrightarrow> zero wo_aux \\<in> Field wo_aux\n\ngoal (1 subgoal):\n 1. zero wo_aux \\<in> Field wo_aux", "by fastforce"], ["proof (state)\nthis:\n  zero wo_aux \\<in> Field wo_aux\n\ngoal (3 subgoals):\n 1. \\<And>x. map_aux (basepoint x) \\<in> Field wo_aux\n 2. \\<And>x1a x2.\n       \\<lbrakk>map_aux x1a \\<in> Field wo_aux;\n        map_aux x2 \\<in> Field wo_aux\\<rbrakk>\n       \\<Longrightarrow> map_aux (middle x1a x2) \\<in> Field wo_aux\n 3. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> range x \\<Longrightarrow>\n           map_aux xa \\<in> Field wo_aux) \\<Longrightarrow>\n       map_aux (would_be_Cauchy x) \\<in> Field wo_aux", "then"], ["proof (chain)\npicking this:\n  zero wo_aux \\<in> Field wo_aux", "show ?case"], ["proof (prove)\nusing this:\n  zero wo_aux \\<in> Field wo_aux\n\ngoal (1 subgoal):\n 1. map_aux (basepoint x) \\<in> Field wo_aux", "by auto"], ["proof (state)\nthis:\n  map_aux (basepoint x) \\<in> Field wo_aux\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2.\n       \\<lbrakk>map_aux x1a \\<in> Field wo_aux;\n        map_aux x2 \\<in> Field wo_aux\\<rbrakk>\n       \\<Longrightarrow> map_aux (middle x1a x2) \\<in> Field wo_aux\n 2. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> range x \\<Longrightarrow>\n           map_aux xa \\<in> Field wo_aux) \\<Longrightarrow>\n       map_aux (would_be_Cauchy x) \\<in> Field wo_aux", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1a x2.\n       \\<lbrakk>map_aux x1a \\<in> Field wo_aux;\n        map_aux x2 \\<in> Field wo_aux\\<rbrakk>\n       \\<Longrightarrow> map_aux (middle x1a x2) \\<in> Field wo_aux\n 2. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> range x \\<Longrightarrow>\n           map_aux xa \\<in> Field wo_aux) \\<Longrightarrow>\n       map_aux (would_be_Cauchy x) \\<in> Field wo_aux", "case mid: (middle a b)"], ["proof (state)\nthis:\n  map_aux a \\<in> Field wo_aux\n  map_aux b \\<in> Field wo_aux\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2.\n       \\<lbrakk>map_aux x1a \\<in> Field wo_aux;\n        map_aux x2 \\<in> Field wo_aux\\<rbrakk>\n       \\<Longrightarrow> map_aux (middle x1a x2) \\<in> Field wo_aux\n 2. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> range x \\<Longrightarrow>\n           map_aux xa \\<in> Field wo_aux) \\<Longrightarrow>\n       map_aux (would_be_Cauchy x) \\<in> Field wo_aux", "have \"({map_aux a} \\<union> {map_aux b}) \\<subseteq> Field wo_aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {map_aux a} \\<union> {map_aux b} \\<subseteq> Field wo_aux", "using mid.IH"], ["proof (prove)\nusing this:\n  map_aux a \\<in> Field wo_aux\n  map_aux b \\<in> Field wo_aux\n\ngoal (1 subgoal):\n 1. {map_aux a} \\<union> {map_aux b} \\<subseteq> Field wo_aux", "by auto"], ["proof (state)\nthis:\n  {map_aux a} \\<union> {map_aux b} \\<subseteq> Field wo_aux\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2.\n       \\<lbrakk>map_aux x1a \\<in> Field wo_aux;\n        map_aux x2 \\<in> Field wo_aux\\<rbrakk>\n       \\<Longrightarrow> map_aux (middle x1a x2) \\<in> Field wo_aux\n 2. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> range x \\<Longrightarrow>\n           map_aux xa \\<in> Field wo_aux) \\<Longrightarrow>\n       map_aux (would_be_Cauchy x) \\<in> Field wo_aux", "then"], ["proof (chain)\npicking this:\n  {map_aux a} \\<union> {map_aux b} \\<subseteq> Field wo_aux", "have \"wo_aux.AboveS ({map_aux a} \\<union> {map_aux b}) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  {map_aux a} \\<union> {map_aux b} \\<subseteq> Field wo_aux\n\ngoal (1 subgoal):\n 1. AboveS wo_aux ({map_aux a} \\<union> {map_aux b}) \\<noteq> {}", "using map_aux_AboveS_not_empty[of \"{a} \\<union> {b}\"]"], ["proof (prove)\nusing this:\n  {map_aux a} \\<union> {map_aux b} \\<subseteq> Field wo_aux\n  map_aux ` ({a} \\<union> {b}) \\<subseteq> Field wo_aux \\<Longrightarrow>\n  AboveS wo_aux (map_aux ` ({a} \\<union> {b})) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. AboveS wo_aux ({map_aux a} \\<union> {map_aux b}) \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  AboveS wo_aux ({map_aux a} \\<union> {map_aux b}) \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2.\n       \\<lbrakk>map_aux x1a \\<in> Field wo_aux;\n        map_aux x2 \\<in> Field wo_aux\\<rbrakk>\n       \\<Longrightarrow> map_aux (middle x1a x2) \\<in> Field wo_aux\n 2. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> range x \\<Longrightarrow>\n           map_aux xa \\<in> Field wo_aux) \\<Longrightarrow>\n       map_aux (would_be_Cauchy x) \\<in> Field wo_aux", "then"], ["proof (chain)\npicking this:\n  AboveS wo_aux ({map_aux a} \\<union> {map_aux b}) \\<noteq> {}", "show ?case"], ["proof (prove)\nusing this:\n  AboveS wo_aux ({map_aux a} \\<union> {map_aux b}) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. map_aux (middle a b) \\<in> Field wo_aux", "by (simp add: AboveS_Field wo_aux.suc_def)"], ["proof (state)\nthis:\n  map_aux (middle a b) \\<in> Field wo_aux\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> range x \\<Longrightarrow>\n           map_aux xa \\<in> Field wo_aux) \\<Longrightarrow>\n       map_aux (would_be_Cauchy x) \\<in> Field wo_aux", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> range x \\<Longrightarrow>\n           map_aux xa \\<in> Field wo_aux) \\<Longrightarrow>\n       map_aux (would_be_Cauchy x) \\<in> Field wo_aux", "case cauchy: (would_be_Cauchy u)"], ["proof (state)\nthis:\n  ?xa1 \\<in> range u \\<Longrightarrow> map_aux ?xa1 \\<in> Field wo_aux\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> range x \\<Longrightarrow>\n           map_aux xa \\<in> Field wo_aux) \\<Longrightarrow>\n       map_aux (would_be_Cauchy x) \\<in> Field wo_aux", "have \"(map_aux o u)`UNIV \\<subseteq> Field wo_aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (map_aux \\<circ> u) \\<subseteq> Field wo_aux", "using cauchy.IH"], ["proof (prove)\nusing this:\n  ?xa1 \\<in> range u \\<Longrightarrow> map_aux ?xa1 \\<in> Field wo_aux\n\ngoal (1 subgoal):\n 1. range (map_aux \\<circ> u) \\<subseteq> Field wo_aux", "by auto"], ["proof (state)\nthis:\n  range (map_aux \\<circ> u) \\<subseteq> Field wo_aux\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> range x \\<Longrightarrow>\n           map_aux xa \\<in> Field wo_aux) \\<Longrightarrow>\n       map_aux (would_be_Cauchy x) \\<in> Field wo_aux", "then"], ["proof (chain)\npicking this:\n  range (map_aux \\<circ> u) \\<subseteq> Field wo_aux", "have \"wo_aux.AboveS ((map_aux o u)`UNIV) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  range (map_aux \\<circ> u) \\<subseteq> Field wo_aux\n\ngoal (1 subgoal):\n 1. AboveS wo_aux (range (map_aux \\<circ> u)) \\<noteq> {}", "using map_aux_AboveS_not_empty[of \"u`(UNIV)\"]"], ["proof (prove)\nusing this:\n  range (map_aux \\<circ> u) \\<subseteq> Field wo_aux\n  map_aux ` range u \\<subseteq> Field wo_aux \\<Longrightarrow>\n  AboveS wo_aux (map_aux ` range u) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. AboveS wo_aux (range (map_aux \\<circ> u)) \\<noteq> {}", "by (simp add: image_image)"], ["proof (state)\nthis:\n  AboveS wo_aux (range (map_aux \\<circ> u)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> range x \\<Longrightarrow>\n           map_aux xa \\<in> Field wo_aux) \\<Longrightarrow>\n       map_aux (would_be_Cauchy x) \\<in> Field wo_aux", "then"], ["proof (chain)\npicking this:\n  AboveS wo_aux (range (map_aux \\<circ> u)) \\<noteq> {}", "show ?case"], ["proof (prove)\nusing this:\n  AboveS wo_aux (range (map_aux \\<circ> u)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. map_aux (would_be_Cauchy u) \\<in> Field wo_aux", "by (simp add: AboveS_Field wo_aux.suc_def)"], ["proof (state)\nthis:\n  map_aux (would_be_Cauchy u) \\<in> Field wo_aux\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma middle_rel_a:\n  \"(map_aux a, map_aux (middle a b)) \\<in> wo_aux - Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_aux a, map_aux (middle a b)) \\<in> wo_aux - Id", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (map_aux a, map_aux (middle a b)) \\<in> wo_aux - Id", "have *: \"({map_aux a} \\<union> {map_aux b}) \\<subseteq> Field wo_aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {map_aux a} \\<union> {map_aux b} \\<subseteq> Field wo_aux", "using map_aux_in_Field"], ["proof (prove)\nusing this:\n  map_aux ?x \\<in> Field wo_aux\n\ngoal (1 subgoal):\n 1. {map_aux a} \\<union> {map_aux b} \\<subseteq> Field wo_aux", "by auto"], ["proof (state)\nthis:\n  {map_aux a} \\<union> {map_aux b} \\<subseteq> Field wo_aux\n\ngoal (1 subgoal):\n 1. (map_aux a, map_aux (middle a b)) \\<in> wo_aux - Id", "then"], ["proof (chain)\npicking this:\n  {map_aux a} \\<union> {map_aux b} \\<subseteq> Field wo_aux", "have \"wo_aux.AboveS ({map_aux a} \\<union> {map_aux b}) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  {map_aux a} \\<union> {map_aux b} \\<subseteq> Field wo_aux\n\ngoal (1 subgoal):\n 1. AboveS wo_aux ({map_aux a} \\<union> {map_aux b}) \\<noteq> {}", "using map_aux_AboveS_not_empty[of \"{a} \\<union> {b}\"]"], ["proof (prove)\nusing this:\n  {map_aux a} \\<union> {map_aux b} \\<subseteq> Field wo_aux\n  map_aux ` ({a} \\<union> {b}) \\<subseteq> Field wo_aux \\<Longrightarrow>\n  AboveS wo_aux (map_aux ` ({a} \\<union> {b})) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. AboveS wo_aux ({map_aux a} \\<union> {map_aux b}) \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  AboveS wo_aux ({map_aux a} \\<union> {map_aux b}) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (map_aux a, map_aux (middle a b)) \\<in> wo_aux - Id", "then"], ["proof (chain)\npicking this:\n  AboveS wo_aux ({map_aux a} \\<union> {map_aux b}) \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  AboveS wo_aux ({map_aux a} \\<union> {map_aux b}) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (map_aux a, map_aux (middle a b)) \\<in> wo_aux - Id", "using *"], ["proof (prove)\nusing this:\n  AboveS wo_aux ({map_aux a} \\<union> {map_aux b}) \\<noteq> {}\n  {map_aux a} \\<union> {map_aux b} \\<subseteq> Field wo_aux\n\ngoal (1 subgoal):\n 1. (map_aux a, map_aux (middle a b)) \\<in> wo_aux - Id", "by (simp add: wo_aux.suc_greater Id_def)"], ["proof (state)\nthis:\n  (map_aux a, map_aux (middle a b)) \\<in> wo_aux - Id\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma middle_rel_b:\n  \"(map_aux b, map_aux (middle a b)) \\<in> wo_aux - Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_aux b, map_aux (middle a b)) \\<in> wo_aux - Id", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (map_aux b, map_aux (middle a b)) \\<in> wo_aux - Id", "have *: \"({map_aux a} \\<union> {map_aux b}) \\<subseteq> Field wo_aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {map_aux a} \\<union> {map_aux b} \\<subseteq> Field wo_aux", "using map_aux_in_Field"], ["proof (prove)\nusing this:\n  map_aux ?x \\<in> Field wo_aux\n\ngoal (1 subgoal):\n 1. {map_aux a} \\<union> {map_aux b} \\<subseteq> Field wo_aux", "by auto"], ["proof (state)\nthis:\n  {map_aux a} \\<union> {map_aux b} \\<subseteq> Field wo_aux\n\ngoal (1 subgoal):\n 1. (map_aux b, map_aux (middle a b)) \\<in> wo_aux - Id", "then"], ["proof (chain)\npicking this:\n  {map_aux a} \\<union> {map_aux b} \\<subseteq> Field wo_aux", "have \"wo_aux.AboveS ({map_aux a} \\<union> {map_aux b}) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  {map_aux a} \\<union> {map_aux b} \\<subseteq> Field wo_aux\n\ngoal (1 subgoal):\n 1. AboveS wo_aux ({map_aux a} \\<union> {map_aux b}) \\<noteq> {}", "using map_aux_AboveS_not_empty[of \"{a} \\<union> {b}\"]"], ["proof (prove)\nusing this:\n  {map_aux a} \\<union> {map_aux b} \\<subseteq> Field wo_aux\n  map_aux ` ({a} \\<union> {b}) \\<subseteq> Field wo_aux \\<Longrightarrow>\n  AboveS wo_aux (map_aux ` ({a} \\<union> {b})) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. AboveS wo_aux ({map_aux a} \\<union> {map_aux b}) \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  AboveS wo_aux ({map_aux a} \\<union> {map_aux b}) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (map_aux b, map_aux (middle a b)) \\<in> wo_aux - Id", "then"], ["proof (chain)\npicking this:\n  AboveS wo_aux ({map_aux a} \\<union> {map_aux b}) \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  AboveS wo_aux ({map_aux a} \\<union> {map_aux b}) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (map_aux b, map_aux (middle a b)) \\<in> wo_aux - Id", "using *"], ["proof (prove)\nusing this:\n  AboveS wo_aux ({map_aux a} \\<union> {map_aux b}) \\<noteq> {}\n  {map_aux a} \\<union> {map_aux b} \\<subseteq> Field wo_aux\n\ngoal (1 subgoal):\n 1. (map_aux b, map_aux (middle a b)) \\<in> wo_aux - Id", "by (simp add: wo_aux.suc_greater Id_def)"], ["proof (state)\nthis:\n  (map_aux b, map_aux (middle a b)) \\<in> wo_aux - Id\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cauchy_rel:\n  \"(map_aux (u n), map_aux (would_be_Cauchy u)) \\<in> wo_aux - Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_aux (u n), map_aux (would_be_Cauchy u)) \\<in> wo_aux - Id", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (map_aux (u n), map_aux (would_be_Cauchy u)) \\<in> wo_aux - Id", "have *: \"(map_aux o u)`UNIV \\<subseteq> Field wo_aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (map_aux \\<circ> u) \\<subseteq> Field wo_aux", "using map_aux_in_Field"], ["proof (prove)\nusing this:\n  map_aux ?x \\<in> Field wo_aux\n\ngoal (1 subgoal):\n 1. range (map_aux \\<circ> u) \\<subseteq> Field wo_aux", "by auto"], ["proof (state)\nthis:\n  range (map_aux \\<circ> u) \\<subseteq> Field wo_aux\n\ngoal (1 subgoal):\n 1. (map_aux (u n), map_aux (would_be_Cauchy u)) \\<in> wo_aux - Id", "then"], ["proof (chain)\npicking this:\n  range (map_aux \\<circ> u) \\<subseteq> Field wo_aux", "have \"wo_aux.AboveS ((map_aux o u)`UNIV) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  range (map_aux \\<circ> u) \\<subseteq> Field wo_aux\n\ngoal (1 subgoal):\n 1. AboveS wo_aux (range (map_aux \\<circ> u)) \\<noteq> {}", "using map_aux_AboveS_not_empty[of \"u`(UNIV)\"]"], ["proof (prove)\nusing this:\n  range (map_aux \\<circ> u) \\<subseteq> Field wo_aux\n  map_aux ` range u \\<subseteq> Field wo_aux \\<Longrightarrow>\n  AboveS wo_aux (map_aux ` range u) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. AboveS wo_aux (range (map_aux \\<circ> u)) \\<noteq> {}", "by (simp add: image_image)"], ["proof (state)\nthis:\n  AboveS wo_aux (range (map_aux \\<circ> u)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (map_aux (u n), map_aux (would_be_Cauchy u)) \\<in> wo_aux - Id", "then"], ["proof (chain)\npicking this:\n  AboveS wo_aux (range (map_aux \\<circ> u)) \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  AboveS wo_aux (range (map_aux \\<circ> u)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (map_aux (u n), map_aux (would_be_Cauchy u)) \\<in> wo_aux - Id", "using *"], ["proof (prove)\nusing this:\n  AboveS wo_aux (range (map_aux \\<circ> u)) \\<noteq> {}\n  range (map_aux \\<circ> u) \\<subseteq> Field wo_aux\n\ngoal (1 subgoal):\n 1. (map_aux (u n), map_aux (would_be_Cauchy u)) \\<in> wo_aux - Id", "by (simp add: wo_aux.suc_greater Id_def)"], ["proof (state)\nthis:\n  (map_aux (u n), map_aux (would_be_Cauchy u)) \\<in> wo_aux - Id\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>From the above properties of \\verb+wo_aux+, it follows using \\verb+Well_order_pullback+\nthat an order satisfying all the properties we want of \\verb+Bonk_Schramm_extension_unfolded_wo+\nexists. Hence, we get the following lemma.\\<close>"], ["", "lemma Bonk_Schramm_extension_unfolded_wo_props:\n  \"well_order_on UNIV Bonk_Schramm_extension_unfolded_wo\"\n  \"\\<forall>x \\<in> range basepoint. \\<forall>y \\<in> - range basepoint. (x, y) \\<in> Bonk_Schramm_extension_unfolded_wo\"\n  \"\\<forall> a b. (a, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\"\n  \"\\<forall> a b. (b, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\"\n  \"\\<forall>u n. (u n, would_be_Cauchy u) \\<in> Bonk_Schramm_extension_unfolded_wo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (well_order Bonk_Schramm_extension_unfolded_wo &&&\n     \\<forall>x\\<in>range basepoint.\n        \\<forall>y\\<in>- range basepoint.\n           (x, y) \\<in> Bonk_Schramm_extension_unfolded_wo) &&&\n    \\<forall>a b.\n       (a, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo &&&\n    \\<forall>a b.\n       (b, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo &&&\n    \\<forall>u n.\n       (u n, would_be_Cauchy u) \\<in> Bonk_Schramm_extension_unfolded_wo", "proof -"], ["proof (state)\ngoal (5 subgoals):\n 1. well_order Bonk_Schramm_extension_unfolded_wo\n 2. \\<forall>x\\<in>range basepoint.\n       \\<forall>y\\<in>- range basepoint.\n          (x, y) \\<in> Bonk_Schramm_extension_unfolded_wo\n 3. \\<forall>a b. (a, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n 4. \\<forall>a b. (b, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n 5. \\<forall>u n.\n       (u n, would_be_Cauchy u) \\<in> Bonk_Schramm_extension_unfolded_wo", "obtain r::\"'a Bonk_Schramm_extension_unfolded rel\" where r:\n    \"Well_order r\"\n    \"Field r = UNIV\"\n    \"\\<And>x y. (map_aux x, map_aux y) \\<in> wo_aux - Id \\<Longrightarrow> (x, y) \\<in> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>Well_order r; Field r = UNIV;\n         \\<And>x y.\n            (map_aux x, map_aux y) \\<in> wo_aux - Id \\<Longrightarrow>\n            (x, y) \\<in> r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Well_order_pullback[of wo_aux map_aux]"], ["proof (prove)\nusing this:\n  Well_order wo_aux \\<Longrightarrow>\n  \\<exists>s.\n     Well_order s \\<and>\n     Field s = UNIV \\<and>\n     (\\<forall>x y.\n         (map_aux x, map_aux y) \\<in> wo_aux - Id \\<longrightarrow>\n         (x, y) \\<in> s)\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>Well_order r; Field r = UNIV;\n         \\<And>x y.\n            (map_aux x, map_aux y) \\<in> wo_aux - Id \\<Longrightarrow>\n            (x, y) \\<in> r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis wo_aux.WELL)"], ["proof (state)\nthis:\n  Well_order r\n  Field r = UNIV\n  (map_aux ?x1, map_aux ?y1) \\<in> wo_aux - Id \\<Longrightarrow>\n  (?x1, ?y1) \\<in> r\n\ngoal (5 subgoals):\n 1. well_order Bonk_Schramm_extension_unfolded_wo\n 2. \\<forall>x\\<in>range basepoint.\n       \\<forall>y\\<in>- range basepoint.\n          (x, y) \\<in> Bonk_Schramm_extension_unfolded_wo\n 3. \\<forall>a b. (a, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n 4. \\<forall>a b. (b, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n 5. \\<forall>u n.\n       (u n, would_be_Cauchy u) \\<in> Bonk_Schramm_extension_unfolded_wo", "have \"(x, y) \\<in> r\" if \"x \\<in> range basepoint\" \"y \\<in> - range basepoint\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> r", "apply (rule r(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_aux x, map_aux y) \\<in> wo_aux - Id", "using that"], ["proof (prove)\nusing this:\n  x \\<in> range basepoint\n  y \\<in> - range basepoint\n\ngoal (1 subgoal):\n 1. (map_aux x, map_aux y) \\<in> wo_aux - Id", "apply (cases y)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>x \\<in> range basepoint; y \\<in> - range basepoint;\n        y = basepoint x1\\<rbrakk>\n       \\<Longrightarrow> (map_aux x, map_aux y) \\<in> wo_aux - Id\n 2. \\<And>x21 x22.\n       \\<lbrakk>x \\<in> range basepoint; y \\<in> - range basepoint;\n        y = middle x21 x22\\<rbrakk>\n       \\<Longrightarrow> (map_aux x, map_aux y) \\<in> wo_aux - Id\n 3. \\<And>x3.\n       \\<lbrakk>x \\<in> range basepoint; y \\<in> - range basepoint;\n        y = would_be_Cauchy x3\\<rbrakk>\n       \\<Longrightarrow> (map_aux x, map_aux y) \\<in> wo_aux - Id", "apply (auto cong del: image_cong_simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x21 x22 xa.\n       \\<lbrakk>middle x21 x22 \\<notin> range basepoint; y = middle x21 x22;\n        x = basepoint xa\\<rbrakk>\n       \\<Longrightarrow> (zero wo_aux,\n                          suc wo_aux {map_aux x22, map_aux x21})\n                         \\<in> wo_aux\n 2. \\<And>x21 x22 xa.\n       \\<lbrakk>middle x21 x22 \\<notin> range basepoint; y = middle x21 x22;\n        x = basepoint xa;\n        zero wo_aux = suc wo_aux {map_aux x22, map_aux x21}\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x3 xa.\n       \\<lbrakk>would_be_Cauchy x3 \\<notin> range basepoint;\n        y = would_be_Cauchy x3; x = basepoint xa\\<rbrakk>\n       \\<Longrightarrow> (zero wo_aux,\n                          suc wo_aux (range (map_aux \\<circ> x3)))\n                         \\<in> wo_aux\n 4. \\<And>x3 xa.\n       \\<lbrakk>would_be_Cauchy x3 \\<notin> range basepoint;\n        y = would_be_Cauchy x3; x = basepoint xa;\n        zero wo_aux = suc wo_aux (range (map_aux \\<circ> x3))\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis insert_is_Un map_aux.simps(2) map_aux_in_Field wo_aux.zero_smallest)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22 xa.\n       \\<lbrakk>middle x21 x22 \\<notin> range basepoint; y = middle x21 x22;\n        x = basepoint xa;\n        zero wo_aux = suc wo_aux {map_aux x22, map_aux x21}\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x3 xa.\n       \\<lbrakk>would_be_Cauchy x3 \\<notin> range basepoint;\n        y = would_be_Cauchy x3; x = basepoint xa\\<rbrakk>\n       \\<Longrightarrow> (zero wo_aux,\n                          suc wo_aux (range (map_aux \\<circ> x3)))\n                         \\<in> wo_aux\n 3. \\<And>x3 xa.\n       \\<lbrakk>would_be_Cauchy x3 \\<notin> range basepoint;\n        y = would_be_Cauchy x3; x = basepoint xa;\n        zero wo_aux = suc wo_aux (range (map_aux \\<circ> x3))\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis Diff_iff insert_is_Un wo_aux.leq_zero_imp map_aux.simps(2) middle_rel_a pair_in_Id_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x3 xa.\n       \\<lbrakk>would_be_Cauchy x3 \\<notin> range basepoint;\n        y = would_be_Cauchy x3; x = basepoint xa\\<rbrakk>\n       \\<Longrightarrow> (zero wo_aux,\n                          suc wo_aux (range (map_aux \\<circ> x3)))\n                         \\<in> wo_aux\n 2. \\<And>x3 xa.\n       \\<lbrakk>would_be_Cauchy x3 \\<notin> range basepoint;\n        y = would_be_Cauchy x3; x = basepoint xa;\n        zero wo_aux = suc wo_aux (range (map_aux \\<circ> x3))\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis map_aux.simps(3) map_aux_in_Field wo_aux.zero_smallest)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x3 xa.\n       \\<lbrakk>would_be_Cauchy x3 \\<notin> range basepoint;\n        y = would_be_Cauchy x3; x = basepoint xa;\n        zero wo_aux = suc wo_aux (range (map_aux \\<circ> x3))\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis Diff_iff cauchy_rel wo_aux.leq_zero_imp map_aux.simps(3) pair_in_Id_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>?x1 \\<in> range basepoint; ?y1 \\<in> - range basepoint\\<rbrakk>\n  \\<Longrightarrow> (?x1, ?y1) \\<in> r\n\ngoal (5 subgoals):\n 1. well_order Bonk_Schramm_extension_unfolded_wo\n 2. \\<forall>x\\<in>range basepoint.\n       \\<forall>y\\<in>- range basepoint.\n          (x, y) \\<in> Bonk_Schramm_extension_unfolded_wo\n 3. \\<forall>a b. (a, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n 4. \\<forall>a b. (b, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n 5. \\<forall>u n.\n       (u n, would_be_Cauchy u) \\<in> Bonk_Schramm_extension_unfolded_wo", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?x1 \\<in> range basepoint; ?y1 \\<in> - range basepoint\\<rbrakk>\n  \\<Longrightarrow> (?x1, ?y1) \\<in> r\n\ngoal (5 subgoals):\n 1. well_order Bonk_Schramm_extension_unfolded_wo\n 2. \\<forall>x\\<in>range basepoint.\n       \\<forall>y\\<in>- range basepoint.\n          (x, y) \\<in> Bonk_Schramm_extension_unfolded_wo\n 3. \\<forall>a b. (a, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n 4. \\<forall>a b. (b, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n 5. \\<forall>u n.\n       (u n, would_be_Cauchy u) \\<in> Bonk_Schramm_extension_unfolded_wo", "have \"(a, middle a b) \\<in> r\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, middle a b) \\<in> r", "apply (rule r(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_aux a, map_aux (middle a b)) \\<in> wo_aux - Id", "using middle_rel_a"], ["proof (prove)\nusing this:\n  (map_aux ?a, map_aux (middle ?a ?b)) \\<in> wo_aux - Id\n\ngoal (1 subgoal):\n 1. (map_aux a, map_aux (middle a b)) \\<in> wo_aux - Id", "by auto"], ["proof (state)\nthis:\n  (?a1, middle ?a1 ?b1) \\<in> r\n\ngoal (5 subgoals):\n 1. well_order Bonk_Schramm_extension_unfolded_wo\n 2. \\<forall>x\\<in>range basepoint.\n       \\<forall>y\\<in>- range basepoint.\n          (x, y) \\<in> Bonk_Schramm_extension_unfolded_wo\n 3. \\<forall>a b. (a, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n 4. \\<forall>a b. (b, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n 5. \\<forall>u n.\n       (u n, would_be_Cauchy u) \\<in> Bonk_Schramm_extension_unfolded_wo", "moreover"], ["proof (state)\nthis:\n  (?a1, middle ?a1 ?b1) \\<in> r\n\ngoal (5 subgoals):\n 1. well_order Bonk_Schramm_extension_unfolded_wo\n 2. \\<forall>x\\<in>range basepoint.\n       \\<forall>y\\<in>- range basepoint.\n          (x, y) \\<in> Bonk_Schramm_extension_unfolded_wo\n 3. \\<forall>a b. (a, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n 4. \\<forall>a b. (b, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n 5. \\<forall>u n.\n       (u n, would_be_Cauchy u) \\<in> Bonk_Schramm_extension_unfolded_wo", "have \"(b, middle a b) \\<in> r\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. (b, middle a b) \\<in> r", "apply (rule r(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_aux b, map_aux (middle a b)) \\<in> wo_aux - Id", "using middle_rel_b"], ["proof (prove)\nusing this:\n  (map_aux ?b, map_aux (middle ?a ?b)) \\<in> wo_aux - Id\n\ngoal (1 subgoal):\n 1. (map_aux b, map_aux (middle a b)) \\<in> wo_aux - Id", "by auto"], ["proof (state)\nthis:\n  (?b1, middle ?a1 ?b1) \\<in> r\n\ngoal (5 subgoals):\n 1. well_order Bonk_Schramm_extension_unfolded_wo\n 2. \\<forall>x\\<in>range basepoint.\n       \\<forall>y\\<in>- range basepoint.\n          (x, y) \\<in> Bonk_Schramm_extension_unfolded_wo\n 3. \\<forall>a b. (a, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n 4. \\<forall>a b. (b, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n 5. \\<forall>u n.\n       (u n, would_be_Cauchy u) \\<in> Bonk_Schramm_extension_unfolded_wo", "moreover"], ["proof (state)\nthis:\n  (?b1, middle ?a1 ?b1) \\<in> r\n\ngoal (5 subgoals):\n 1. well_order Bonk_Schramm_extension_unfolded_wo\n 2. \\<forall>x\\<in>range basepoint.\n       \\<forall>y\\<in>- range basepoint.\n          (x, y) \\<in> Bonk_Schramm_extension_unfolded_wo\n 3. \\<forall>a b. (a, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n 4. \\<forall>a b. (b, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n 5. \\<forall>u n.\n       (u n, would_be_Cauchy u) \\<in> Bonk_Schramm_extension_unfolded_wo", "have \"(u n, would_be_Cauchy u) \\<in> r\" for u n"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u n, would_be_Cauchy u) \\<in> r", "apply (rule r(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_aux (u n), map_aux (would_be_Cauchy u)) \\<in> wo_aux - Id", "using cauchy_rel"], ["proof (prove)\nusing this:\n  (map_aux (?u ?n), map_aux (would_be_Cauchy ?u)) \\<in> wo_aux - Id\n\ngoal (1 subgoal):\n 1. (map_aux (u n), map_aux (would_be_Cauchy u)) \\<in> wo_aux - Id", "by auto"], ["proof (state)\nthis:\n  (?u1 ?n1, would_be_Cauchy ?u1) \\<in> r\n\ngoal (5 subgoals):\n 1. well_order Bonk_Schramm_extension_unfolded_wo\n 2. \\<forall>x\\<in>range basepoint.\n       \\<forall>y\\<in>- range basepoint.\n          (x, y) \\<in> Bonk_Schramm_extension_unfolded_wo\n 3. \\<forall>a b. (a, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n 4. \\<forall>a b. (b, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n 5. \\<forall>u n.\n       (u n, would_be_Cauchy u) \\<in> Bonk_Schramm_extension_unfolded_wo", "moreover"], ["proof (state)\nthis:\n  (?u1 ?n1, would_be_Cauchy ?u1) \\<in> r\n\ngoal (5 subgoals):\n 1. well_order Bonk_Schramm_extension_unfolded_wo\n 2. \\<forall>x\\<in>range basepoint.\n       \\<forall>y\\<in>- range basepoint.\n          (x, y) \\<in> Bonk_Schramm_extension_unfolded_wo\n 3. \\<forall>a b. (a, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n 4. \\<forall>a b. (b, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n 5. \\<forall>u n.\n       (u n, would_be_Cauchy u) \\<in> Bonk_Schramm_extension_unfolded_wo", "have \"well_order_on UNIV r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_order r", "using r(1) r(2)"], ["proof (prove)\nusing this:\n  Well_order r\n  Field r = UNIV\n\ngoal (1 subgoal):\n 1. well_order r", "by auto"], ["proof (state)\nthis:\n  well_order r\n\ngoal (5 subgoals):\n 1. well_order Bonk_Schramm_extension_unfolded_wo\n 2. \\<forall>x\\<in>range basepoint.\n       \\<forall>y\\<in>- range basepoint.\n          (x, y) \\<in> Bonk_Schramm_extension_unfolded_wo\n 3. \\<forall>a b. (a, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n 4. \\<forall>a b. (b, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n 5. \\<forall>u n.\n       (u n, would_be_Cauchy u) \\<in> Bonk_Schramm_extension_unfolded_wo", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x1 \\<in> range basepoint; ?y1 \\<in> - range basepoint\\<rbrakk>\n  \\<Longrightarrow> (?x1, ?y1) \\<in> r\n  (?a1, middle ?a1 ?b1) \\<in> r\n  (?b1, middle ?a1 ?b1) \\<in> r\n  (?u1 ?n1, would_be_Cauchy ?u1) \\<in> r\n  well_order r", "have *: \"\\<exists> (r::'a Bonk_Schramm_extension_unfolded rel).\n      well_order_on UNIV r\n      \\<and> (\\<forall>x \\<in> range basepoint. \\<forall>y \\<in> - range basepoint. (x, y) \\<in> r)\n      \\<and> (\\<forall> a b. (a, middle a b) \\<in> r)\n      \\<and> (\\<forall> a b. (b, middle a b) \\<in> r)\n      \\<and> (\\<forall>u n. (u n, would_be_Cauchy u) \\<in> r)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x1 \\<in> range basepoint; ?y1 \\<in> - range basepoint\\<rbrakk>\n  \\<Longrightarrow> (?x1, ?y1) \\<in> r\n  (?a1, middle ?a1 ?b1) \\<in> r\n  (?b1, middle ?a1 ?b1) \\<in> r\n  (?u1 ?n1, would_be_Cauchy ?u1) \\<in> r\n  well_order r\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       well_order r \\<and>\n       (\\<forall>x\\<in>range basepoint.\n           \\<forall>y\\<in>- range basepoint. (x, y) \\<in> r) \\<and>\n       (\\<forall>a b. (a, middle a b) \\<in> r) \\<and>\n       (\\<forall>a b. (b, middle a b) \\<in> r) \\<and>\n       (\\<forall>u n. (u n, would_be_Cauchy u) \\<in> r)", "by blast"], ["proof (state)\nthis:\n  \\<exists>r.\n     well_order r \\<and>\n     (\\<forall>x\\<in>range basepoint.\n         \\<forall>y\\<in>- range basepoint. (x, y) \\<in> r) \\<and>\n     (\\<forall>a b. (a, middle a b) \\<in> r) \\<and>\n     (\\<forall>a b. (b, middle a b) \\<in> r) \\<and>\n     (\\<forall>u n. (u n, would_be_Cauchy u) \\<in> r)\n\ngoal (5 subgoals):\n 1. well_order Bonk_Schramm_extension_unfolded_wo\n 2. \\<forall>x\\<in>range basepoint.\n       \\<forall>y\\<in>- range basepoint.\n          (x, y) \\<in> Bonk_Schramm_extension_unfolded_wo\n 3. \\<forall>a b. (a, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n 4. \\<forall>a b. (b, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n 5. \\<forall>u n.\n       (u n, would_be_Cauchy u) \\<in> Bonk_Schramm_extension_unfolded_wo", "show\n    \"well_order_on UNIV Bonk_Schramm_extension_unfolded_wo\"\n    \"\\<forall>x \\<in> range basepoint. \\<forall>y \\<in> - range basepoint. (x, y) \\<in> Bonk_Schramm_extension_unfolded_wo\"\n    \"\\<forall> a b. (a, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\"\n    \"\\<forall> a b. (b, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\"\n    \"\\<forall>u n. (u n, would_be_Cauchy u) \\<in> Bonk_Schramm_extension_unfolded_wo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (well_order Bonk_Schramm_extension_unfolded_wo &&&\n     \\<forall>x\\<in>range basepoint.\n        \\<forall>y\\<in>- range basepoint.\n           (x, y) \\<in> Bonk_Schramm_extension_unfolded_wo) &&&\n    \\<forall>a b.\n       (a, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo &&&\n    \\<forall>a b.\n       (b, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo &&&\n    \\<forall>u n.\n       (u n, would_be_Cauchy u) \\<in> Bonk_Schramm_extension_unfolded_wo", "unfolding Bonk_Schramm_extension_unfolded_wo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (well_order\n      (SOME r.\n          well_order r \\<and>\n          (\\<forall>x\\<in>range basepoint.\n              \\<forall>y\\<in>- range basepoint. (x, y) \\<in> r) \\<and>\n          (\\<forall>a b. (a, middle a b) \\<in> r) \\<and>\n          (\\<forall>a b. (b, middle a b) \\<in> r) \\<and>\n          (\\<forall>u n. (u n, would_be_Cauchy u) \\<in> r)) &&&\n     \\<forall>x\\<in>range basepoint.\n        \\<forall>y\\<in>- range basepoint.\n           (x, y)\n           \\<in> (SOME r.\n                     well_order r \\<and>\n                     (\\<forall>x\\<in>range basepoint.\n                         \\<forall>y\\<in>- range basepoint.\n                            (x, y) \\<in> r) \\<and>\n                     (\\<forall>a b. (a, middle a b) \\<in> r) \\<and>\n                     (\\<forall>a b. (b, middle a b) \\<in> r) \\<and>\n                     (\\<forall>u n. (u n, would_be_Cauchy u) \\<in> r))) &&&\n    \\<forall>a b.\n       (a, middle a b)\n       \\<in> (SOME r.\n                 well_order r \\<and>\n                 (\\<forall>x\\<in>range basepoint.\n                     \\<forall>y\\<in>- range basepoint.\n                        (x, y) \\<in> r) \\<and>\n                 (\\<forall>a b. (a, middle a b) \\<in> r) \\<and>\n                 (\\<forall>a b. (b, middle a b) \\<in> r) \\<and>\n                 (\\<forall>u n. (u n, would_be_Cauchy u) \\<in> r)) &&&\n    \\<forall>a b.\n       (b, middle a b)\n       \\<in> (SOME r.\n                 well_order r \\<and>\n                 (\\<forall>x\\<in>range basepoint.\n                     \\<forall>y\\<in>- range basepoint.\n                        (x, y) \\<in> r) \\<and>\n                 (\\<forall>a b. (a, middle a b) \\<in> r) \\<and>\n                 (\\<forall>a b. (b, middle a b) \\<in> r) \\<and>\n                 (\\<forall>u n. (u n, would_be_Cauchy u) \\<in> r)) &&&\n    \\<forall>u n.\n       (u n, would_be_Cauchy u)\n       \\<in> (SOME r.\n                 well_order r \\<and>\n                 (\\<forall>x\\<in>range basepoint.\n                     \\<forall>y\\<in>- range basepoint.\n                        (x, y) \\<in> r) \\<and>\n                 (\\<forall>a b. (a, middle a b) \\<in> r) \\<and>\n                 (\\<forall>a b. (b, middle a b) \\<in> r) \\<and>\n                 (\\<forall>u n. (u n, would_be_Cauchy u) \\<in> r))", "using someI_ex[OF *]"], ["proof (prove)\nusing this:\n  well_order\n   (SOME x.\n       well_order x \\<and>\n       (\\<forall>xa\\<in>range basepoint.\n           \\<forall>y\\<in>- range basepoint. (xa, y) \\<in> x) \\<and>\n       (\\<forall>a b. (a, middle a b) \\<in> x) \\<and>\n       (\\<forall>a b. (b, middle a b) \\<in> x) \\<and>\n       (\\<forall>u n. (u n, would_be_Cauchy u) \\<in> x)) \\<and>\n  (\\<forall>x\\<in>range basepoint.\n      \\<forall>y\\<in>- range basepoint.\n         (x, y)\n         \\<in> (SOME x.\n                   well_order x \\<and>\n                   (\\<forall>xa\\<in>range basepoint.\n                       \\<forall>y\\<in>- range basepoint.\n                          (xa, y) \\<in> x) \\<and>\n                   (\\<forall>a b. (a, middle a b) \\<in> x) \\<and>\n                   (\\<forall>a b. (b, middle a b) \\<in> x) \\<and>\n                   (\\<forall>u n. (u n, would_be_Cauchy u) \\<in> x))) \\<and>\n  (\\<forall>a b.\n      (a, middle a b)\n      \\<in> (SOME x.\n                well_order x \\<and>\n                (\\<forall>xa\\<in>range basepoint.\n                    \\<forall>y\\<in>- range basepoint.\n                       (xa, y) \\<in> x) \\<and>\n                (\\<forall>a b. (a, middle a b) \\<in> x) \\<and>\n                (\\<forall>a b. (b, middle a b) \\<in> x) \\<and>\n                (\\<forall>u n. (u n, would_be_Cauchy u) \\<in> x))) \\<and>\n  (\\<forall>a b.\n      (b, middle a b)\n      \\<in> (SOME x.\n                well_order x \\<and>\n                (\\<forall>xa\\<in>range basepoint.\n                    \\<forall>y\\<in>- range basepoint.\n                       (xa, y) \\<in> x) \\<and>\n                (\\<forall>a b. (a, middle a b) \\<in> x) \\<and>\n                (\\<forall>a b. (b, middle a b) \\<in> x) \\<and>\n                (\\<forall>u n. (u n, would_be_Cauchy u) \\<in> x))) \\<and>\n  (\\<forall>u n.\n      (u n, would_be_Cauchy u)\n      \\<in> (SOME x.\n                well_order x \\<and>\n                (\\<forall>xa\\<in>range basepoint.\n                    \\<forall>y\\<in>- range basepoint.\n                       (xa, y) \\<in> x) \\<and>\n                (\\<forall>a b. (a, middle a b) \\<in> x) \\<and>\n                (\\<forall>a b. (b, middle a b) \\<in> x) \\<and>\n                (\\<forall>u n. (u n, would_be_Cauchy u) \\<in> x)))\n\ngoal (1 subgoal):\n 1. (well_order\n      (SOME r.\n          well_order r \\<and>\n          (\\<forall>x\\<in>range basepoint.\n              \\<forall>y\\<in>- range basepoint. (x, y) \\<in> r) \\<and>\n          (\\<forall>a b. (a, middle a b) \\<in> r) \\<and>\n          (\\<forall>a b. (b, middle a b) \\<in> r) \\<and>\n          (\\<forall>u n. (u n, would_be_Cauchy u) \\<in> r)) &&&\n     \\<forall>x\\<in>range basepoint.\n        \\<forall>y\\<in>- range basepoint.\n           (x, y)\n           \\<in> (SOME r.\n                     well_order r \\<and>\n                     (\\<forall>x\\<in>range basepoint.\n                         \\<forall>y\\<in>- range basepoint.\n                            (x, y) \\<in> r) \\<and>\n                     (\\<forall>a b. (a, middle a b) \\<in> r) \\<and>\n                     (\\<forall>a b. (b, middle a b) \\<in> r) \\<and>\n                     (\\<forall>u n. (u n, would_be_Cauchy u) \\<in> r))) &&&\n    \\<forall>a b.\n       (a, middle a b)\n       \\<in> (SOME r.\n                 well_order r \\<and>\n                 (\\<forall>x\\<in>range basepoint.\n                     \\<forall>y\\<in>- range basepoint.\n                        (x, y) \\<in> r) \\<and>\n                 (\\<forall>a b. (a, middle a b) \\<in> r) \\<and>\n                 (\\<forall>a b. (b, middle a b) \\<in> r) \\<and>\n                 (\\<forall>u n. (u n, would_be_Cauchy u) \\<in> r)) &&&\n    \\<forall>a b.\n       (b, middle a b)\n       \\<in> (SOME r.\n                 well_order r \\<and>\n                 (\\<forall>x\\<in>range basepoint.\n                     \\<forall>y\\<in>- range basepoint.\n                        (x, y) \\<in> r) \\<and>\n                 (\\<forall>a b. (a, middle a b) \\<in> r) \\<and>\n                 (\\<forall>a b. (b, middle a b) \\<in> r) \\<and>\n                 (\\<forall>u n. (u n, would_be_Cauchy u) \\<in> r)) &&&\n    \\<forall>u n.\n       (u n, would_be_Cauchy u)\n       \\<in> (SOME r.\n                 well_order r \\<and>\n                 (\\<forall>x\\<in>range basepoint.\n                     \\<forall>y\\<in>- range basepoint.\n                        (x, y) \\<in> r) \\<and>\n                 (\\<forall>a b. (a, middle a b) \\<in> r) \\<and>\n                 (\\<forall>a b. (b, middle a b) \\<in> r) \\<and>\n                 (\\<forall>u n. (u n, would_be_Cauchy u) \\<in> r))", "by auto"], ["proof (state)\nthis:\n  well_order Bonk_Schramm_extension_unfolded_wo\n  \\<forall>x\\<in>range basepoint.\n     \\<forall>y\\<in>- range basepoint.\n        (x, y) \\<in> Bonk_Schramm_extension_unfolded_wo\n  \\<forall>a b. (a, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n  \\<forall>a b. (b, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n  \\<forall>u n.\n     (u n, would_be_Cauchy u) \\<in> Bonk_Schramm_extension_unfolded_wo\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation wo: wo_rel Bonk_Schramm_extension_unfolded_wo"], ["proof (prove)\ngoal (1 subgoal):\n 1. wo_rel Bonk_Schramm_extension_unfolded_wo", "using well_order_on_Well_order wo_rel_def wfrec_def Bonk_Schramm_extension_unfolded_wo_props(1)"], ["proof (prove)\nusing this:\n  well_order_on ?A ?r \\<Longrightarrow> ?A = Field ?r \\<and> Well_order ?r\n  wo_rel ?r \\<equiv> Well_order ?r\n  wfrec ?R ?F =\n  (\\<lambda>x. THE y. wfrec_rel ?R (\\<lambda>f x. ?F (cut f ?R x) x) x y)\n  well_order Bonk_Schramm_extension_unfolded_wo\n\ngoal (1 subgoal):\n 1. wo_rel Bonk_Schramm_extension_unfolded_wo", "by blast"], ["", "text \\<open>We reformulate in the interpretation \\verb+wo+ the main properties of\n\\verb+Bonk_Schramm_extension_unfolded_wo+ that we established in Lemma~\\verb+Bonk_Schramm_extension_unfolded_wo_props+\\<close>"], ["", "lemma Bonk_Schramm_extension_unfolded_wo_props':\n  \"a \\<in> wo.underS (middle a b)\"\n  \"b \\<in> wo.underS (middle a b)\"\n  \"u n \\<in> wo.underS (would_be_Cauchy u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b) &&&\n    b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b) &&&\n    u n \\<in> underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n 2. b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n 3. u n \\<in> underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)", "have \"(a, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo", "using Bonk_Schramm_extension_unfolded_wo_props(3)"], ["proof (prove)\nusing this:\n  \\<forall>a b. (a, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n\ngoal (1 subgoal):\n 1. (a, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo", "by auto"], ["proof (state)\nthis:\n  (a, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n\ngoal (3 subgoals):\n 1. a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n 2. b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n 3. u n \\<in> underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)", "then"], ["proof (chain)\npicking this:\n  (a, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo", "show \"a \\<in> wo.underS (middle a b)\""], ["proof (prove)\nusing this:\n  (a, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n\ngoal (1 subgoal):\n 1. a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b)", "by (metis Diff_iff middle_rel_a pair_in_Id_conv underS_I)"], ["proof (state)\nthis:\n  a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n\ngoal (2 subgoals):\n 1. b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n 2. u n \\<in> underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)", "have \"(b, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo", "using Bonk_Schramm_extension_unfolded_wo_props(4)"], ["proof (prove)\nusing this:\n  \\<forall>a b. (b, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n\ngoal (1 subgoal):\n 1. (b, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo", "by auto"], ["proof (state)\nthis:\n  (b, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n\ngoal (2 subgoals):\n 1. b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n 2. u n \\<in> underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)", "then"], ["proof (chain)\npicking this:\n  (b, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo", "show \"b \\<in> wo.underS (middle a b)\""], ["proof (prove)\nusing this:\n  (b, middle a b) \\<in> Bonk_Schramm_extension_unfolded_wo\n\ngoal (1 subgoal):\n 1. b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b)", "by (metis Diff_iff middle_rel_b pair_in_Id_conv underS_I)"], ["proof (state)\nthis:\n  b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n\ngoal (1 subgoal):\n 1. u n \\<in> underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)", "have \"(u n, would_be_Cauchy u) \\<in> Bonk_Schramm_extension_unfolded_wo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u n, would_be_Cauchy u) \\<in> Bonk_Schramm_extension_unfolded_wo", "using Bonk_Schramm_extension_unfolded_wo_props(5)"], ["proof (prove)\nusing this:\n  \\<forall>u n.\n     (u n, would_be_Cauchy u) \\<in> Bonk_Schramm_extension_unfolded_wo\n\ngoal (1 subgoal):\n 1. (u n, would_be_Cauchy u) \\<in> Bonk_Schramm_extension_unfolded_wo", "by auto"], ["proof (state)\nthis:\n  (u n, would_be_Cauchy u) \\<in> Bonk_Schramm_extension_unfolded_wo\n\ngoal (1 subgoal):\n 1. u n \\<in> underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)", "then"], ["proof (chain)\npicking this:\n  (u n, would_be_Cauchy u) \\<in> Bonk_Schramm_extension_unfolded_wo", "show \"u n \\<in> wo.underS (would_be_Cauchy u)\""], ["proof (prove)\nusing this:\n  (u n, would_be_Cauchy u) \\<in> Bonk_Schramm_extension_unfolded_wo\n\ngoal (1 subgoal):\n 1. u n \\<in> underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)", "by (metis Diff_iff cauchy_rel pair_in_Id_conv underS_I)"], ["proof (state)\nthis:\n  u n \\<in> underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We want to define by transfinite induction a distance on \\verb+'a Bonk_Schramm_extension_unfolded+,\nadding one point at a time (i.e., if the distance is defined on $E$, then one wants to define it\non $E \\cup \\{x\\}$, if $x$ is a middle or a potential Cauchy sequence, by prescribing the distance\nfrom $x$ to all the points in $E$.\n\nTechnically, we define a family of distances, indexed by $x$, on $\\{y : y \\leq x\\}^2$. As all\nfunctions should be defined everywhere, this will be a family of functions on $X \\times X$, indexed\nby points in $X$. They will have a compatibility condition, making it possible to define a global\ndistance by gluing them together.\n\nTechnically, transfinite induction is implemented in Isabelle/HOL by an updating rule: a function\nthat associates, to a family of distances indexed by $x$, a new family of distances indexed by $x$.\nThe result of the transfinite induction is obtained by starting from an arbitrary object, and then\napplying the updating rule infinitely many times. The characteristic property of the result of this\ntransfinite induction is that it is a fixed point of the updating rule, as it should.\n\nBelow, this is implemented as follows:\n\\begin{itemize}\n\\item \\verb+extend_distance+ is the updating rule.\n\\item Its fixed point \\verb+extend_distance_fp+ is by definition \\verb+wo.worec extend_distance+\n(it only makes sense if the udpating rule satisfies a compatibility condition\n\\verb+wo.adm_wo extend_distance+ saying that the update of a family, at $x$,\nonly depends on the value of the family\nstrictly below $x$.\n\\item Finally, the global distance \\verb+extended_distance+ is taken as the\nvalue of the fixed point above, on $x y y'$ (i.e., using the distance indexed by $x$) for any $x\n\\geq \\max(y, y')$. For definiteness, we use $\\max(y, y')$, but it does not matter as everything is\ncompatible.\n\\end{itemize}\\<close>"], ["", "fun extend_distance::\"('a Bonk_Schramm_extension_unfolded \\<Rightarrow> ('a Bonk_Schramm_extension_unfolded \\<Rightarrow> 'a Bonk_Schramm_extension_unfolded \\<Rightarrow> real))\n                    \\<Rightarrow> ('a Bonk_Schramm_extension_unfolded \\<Rightarrow> ('a Bonk_Schramm_extension_unfolded \\<Rightarrow> 'a Bonk_Schramm_extension_unfolded \\<Rightarrow> real))\"\n  where\n    \"extend_distance f (basepoint x) = (\\<lambda>y z. if y \\<in> range basepoint \\<and> z \\<in> range basepoint then\n        dist (SOME y'. y = basepoint y') (SOME z'. z = basepoint z') else 1)\"\n  | \"extend_distance f (middle a b) = (\\<lambda>y z.\n      if (y \\<in> wo.underS (middle a b)) \\<and> (z \\<in> wo.underS (middle a b)) then f (wo.max2 y z) y z\n      else if (y \\<in> wo.underS (middle a b)) \\<and> (z = middle a b) then (f (wo.max2 a b) a b)/2 + (SUP w\\<in>{z \\<in> wo.underS (middle a b). f z z z = 0}. f (wo.max2 y w) y w - max (f (wo.max2 a w) a w) (f (wo.max2 b w) b w))\n      else if (y = middle a b) \\<and> (z \\<in> wo.underS (middle a b)) then (f (wo.max2 a b) a b)/2 + (SUP w\\<in>{z \\<in> wo.underS (middle a b). f z z z = 0}. f (wo.max2 z w) z w - max (f (wo.max2 a w) a w) (f (wo.max2 b w) b w))\n      else if (y = middle a b) \\<and> (z = middle a b) \\<and> (f a a a = 0) \\<and> (f b b b = 0) then 0\n      else 1)\"\n  | \"extend_distance f (would_be_Cauchy u) = (\\<lambda>y z.\n      if (y \\<in> wo.underS (would_be_Cauchy u)) \\<and> (z \\<in> wo.underS (would_be_Cauchy u)) then f (wo.max2 y z) y z\n      else if (\\<not>(\\<forall>eps > (0::real). \\<exists>N. \\<forall>n \\<ge> N. \\<forall>m \\<ge> N. f (wo.max2 (u n) (u m)) (u n) (u m) < eps)) then 1\n      else if (y \\<in> wo.underS (would_be_Cauchy u)) \\<and> (z = would_be_Cauchy u) then lim (\\<lambda>n. f (wo.max2 (u n) y) (u n) y)\n      else if (y = would_be_Cauchy u) \\<and> (z \\<in> wo.underS (would_be_Cauchy u)) then lim (\\<lambda>n. f (wo.max2 (u n) z) (u n) z)\n      else if (y = would_be_Cauchy u) \\<and> (z = would_be_Cauchy u) \\<and> (\\<forall>n. f (u n) (u n) (u n) = 0) then 0\n      else 1)\""], ["", "definition \"extend_distance_fp = wo.worec extend_distance\""], ["", "definition \"extended_distance x y = extend_distance_fp (wo.max2 x y) x y\""], ["", "definition \"extended_distance_set = {z. extended_distance z z = 0}\""], ["", "lemma wo_adm_extend_distance:\n  \"wo.adm_wo extend_distance\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm_wo Bonk_Schramm_extension_unfolded_wo extend_distance", "unfolding wo.adm_wo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f g x.\n       (\\<forall>y\\<in>underS Bonk_Schramm_extension_unfolded_wo x.\n           f y = g y) \\<longrightarrow>\n       extend_distance f x = extend_distance g x", "proof (auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g x.\n       \\<forall>y\\<in>underS Bonk_Schramm_extension_unfolded_wo x.\n          f y = g y \\<Longrightarrow>\n       extend_distance f x = extend_distance g x", "fix f g::\"'a Bonk_Schramm_extension_unfolded \\<Rightarrow> 'a Bonk_Schramm_extension_unfolded \\<Rightarrow> 'a Bonk_Schramm_extension_unfolded \\<Rightarrow> real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g x.\n       \\<forall>y\\<in>underS Bonk_Schramm_extension_unfolded_wo x.\n          f y = g y \\<Longrightarrow>\n       extend_distance f x = extend_distance g x", "fix x::\"'a Bonk_Schramm_extension_unfolded\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g x.\n       \\<forall>y\\<in>underS Bonk_Schramm_extension_unfolded_wo x.\n          f y = g y \\<Longrightarrow>\n       extend_distance f x = extend_distance g x", "assume \"\\<forall>y\\<in>wo.underS x. f y = g y\""], ["proof (state)\nthis:\n  \\<forall>y\\<in>underS Bonk_Schramm_extension_unfolded_wo x. f y = g y\n\ngoal (1 subgoal):\n 1. \\<And>f g x.\n       \\<forall>y\\<in>underS Bonk_Schramm_extension_unfolded_wo x.\n          f y = g y \\<Longrightarrow>\n       extend_distance f x = extend_distance g x", "then"], ["proof (chain)\npicking this:\n  \\<forall>y\\<in>underS Bonk_Schramm_extension_unfolded_wo x. f y = g y", "have *: \"f y = g y\" if \"y \\<in> wo.underS x\" for y"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>underS Bonk_Schramm_extension_unfolded_wo x. f y = g y\n\ngoal (1 subgoal):\n 1. f y = g y", "using that"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>underS Bonk_Schramm_extension_unfolded_wo x. f y = g y\n  y \\<in> underS Bonk_Schramm_extension_unfolded_wo x\n\ngoal (1 subgoal):\n 1. f y = g y", "by auto"], ["proof (state)\nthis:\n  ?y1 \\<in> underS Bonk_Schramm_extension_unfolded_wo x \\<Longrightarrow>\n  f ?y1 = g ?y1\n\ngoal (1 subgoal):\n 1. \\<And>f g x.\n       \\<forall>y\\<in>underS Bonk_Schramm_extension_unfolded_wo x.\n          f y = g y \\<Longrightarrow>\n       extend_distance f x = extend_distance g x", "show \"extend_distance f x = extend_distance g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_distance f x = extend_distance g x", "apply (cases x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       x = basepoint x1 \\<Longrightarrow>\n       extend_distance f x = extend_distance g x\n 2. \\<And>x21 x22.\n       x = middle x21 x22 \\<Longrightarrow>\n       extend_distance f x = extend_distance g x\n 3. \\<And>x3.\n       x = would_be_Cauchy x3 \\<Longrightarrow>\n       extend_distance f x = extend_distance g x", "(* We use the basic properties of our good order (middles and sequences come after their generators,\n    and the fact that initial segments are stable under max2 *)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       x = basepoint x1 \\<Longrightarrow>\n       extend_distance f x = extend_distance g x\n 2. \\<And>x21 x22.\n       x = middle x21 x22 \\<Longrightarrow>\n       extend_distance f x = extend_distance g x\n 3. \\<And>x3.\n       x = would_be_Cauchy x3 \\<Longrightarrow>\n       extend_distance f x = extend_distance g x", "apply (insert Bonk_Schramm_extension_unfolded_wo_props' *)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>x = basepoint x1;\n        \\<And>a b.\n           a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>b a.\n           b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>u n.\n           u n\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy u);\n        \\<And>y.\n           y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    x \\<Longrightarrow>\n           f y = g y\\<rbrakk>\n       \\<Longrightarrow> extend_distance f x = extend_distance g x\n 2. \\<And>x21 x22.\n       \\<lbrakk>x = middle x21 x22;\n        \\<And>a b.\n           a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>b a.\n           b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>u n.\n           u n\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy u);\n        \\<And>y.\n           y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    x \\<Longrightarrow>\n           f y = g y\\<rbrakk>\n       \\<Longrightarrow> extend_distance f x = extend_distance g x\n 3. \\<And>x3.\n       \\<lbrakk>x = would_be_Cauchy x3;\n        \\<And>a b.\n           a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>b a.\n           b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>u n.\n           u n\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy u);\n        \\<And>y.\n           y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    x \\<Longrightarrow>\n           f y = g y\\<rbrakk>\n       \\<Longrightarrow> extend_distance f x = extend_distance g x", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>x = middle x21 x22;\n        \\<And>a b.\n           a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>b a.\n           b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>u n.\n           u n\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy u);\n        \\<And>y.\n           y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    (middle x21 x22) \\<Longrightarrow>\n           f y = g y\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>y z.\n                             if y \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (middle x21 x22) \\<and>\n                                z \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (middle x21 x22)\n                             then f (max2 Bonk_Schramm_extension_unfolded_wo\ny z)\n                                   y z\n                             else if y \\<in> underS\n        Bonk_Schramm_extension_unfolded_wo (middle x21 x22) \\<and>\n                                     z = middle x21 x22\n                                  then f\n  (max2 Bonk_Schramm_extension_unfolded_wo x21 x22) x21 x22 /\n 2 +\n (SUP w\\<in>{z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                      (middle x21 x22).\n             f z z z = 0}.\n     f (max2 Bonk_Schramm_extension_unfolded_wo y w) y w -\n     max (f (max2 Bonk_Schramm_extension_unfolded_wo x21 w) x21 w)\n      (f (max2 Bonk_Schramm_extension_unfolded_wo x22 w) x22 w))\n                                  else if y = middle x21 x22 \\<and>\n    z \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle x21 x22)\n then f (max2 Bonk_Schramm_extension_unfolded_wo x21 x22) x21 x22 / 2 +\n      (SUP w\\<in>{z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                           (middle x21 x22).\n                  f z z z = 0}.\n          f (max2 Bonk_Schramm_extension_unfolded_wo z w) z w -\n          max (f (max2 Bonk_Schramm_extension_unfolded_wo x21 w) x21 w)\n           (f (max2 Bonk_Schramm_extension_unfolded_wo x22 w) x22 w))\n else if y = middle x21 x22 \\<and>\n         z = middle x21 x22 \\<and>\n         f x21 x21 x21 = 0 \\<and> f x22 x22 x22 = 0\n      then 0 else 1) =\n                         (\\<lambda>y z.\n                             if y \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (middle x21 x22) \\<and>\n                                z \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (middle x21 x22)\n                             then g (max2 Bonk_Schramm_extension_unfolded_wo\ny z)\n                                   y z\n                             else if y \\<in> underS\n        Bonk_Schramm_extension_unfolded_wo (middle x21 x22) \\<and>\n                                     z = middle x21 x22\n                                  then g\n  (max2 Bonk_Schramm_extension_unfolded_wo x21 x22) x21 x22 /\n 2 +\n (SUP w\\<in>{z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                      (middle x21 x22).\n             g z z z = 0}.\n     g (max2 Bonk_Schramm_extension_unfolded_wo y w) y w -\n     max (g (max2 Bonk_Schramm_extension_unfolded_wo x21 w) x21 w)\n      (g (max2 Bonk_Schramm_extension_unfolded_wo x22 w) x22 w))\n                                  else if y = middle x21 x22 \\<and>\n    z \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle x21 x22)\n then g (max2 Bonk_Schramm_extension_unfolded_wo x21 x22) x21 x22 / 2 +\n      (SUP w\\<in>{z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                           (middle x21 x22).\n                  g z z z = 0}.\n          g (max2 Bonk_Schramm_extension_unfolded_wo z w) z w -\n          max (g (max2 Bonk_Schramm_extension_unfolded_wo x21 w) x21 w)\n           (g (max2 Bonk_Schramm_extension_unfolded_wo x22 w) x22 w))\n else if y = middle x21 x22 \\<and>\n         z = middle x21 x22 \\<and>\n         g x21 x21 x21 = 0 \\<and> g x22 x22 x22 = 0\n      then 0 else 1)\n 2. \\<And>x3.\n       \\<lbrakk>x = would_be_Cauchy x3;\n        \\<And>a b.\n           a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>b a.\n           b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>u n.\n           u n\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy u);\n        \\<And>y.\n           y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    (would_be_Cauchy x3) \\<Longrightarrow>\n           f y = g y\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>y z.\n                             if y \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3) \\<and>\n                                z \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3)\n                             then f (max2 Bonk_Schramm_extension_unfolded_wo\ny z)\n                                   y z\n                             else if \\<not> (\\<forall>eps>0.\n          \\<exists>N.\n             \\<forall>n\\<ge>N.\n                \\<forall>m\\<ge>N.\n                   f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) (x3 m))\n                    (x3 n) (x3 m)\n                   < eps)\n                                  then 1\n                                  else if y\n    \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy x3) \\<and>\n    z = would_be_Cauchy x3\n then lim (\\<lambda>n.\n              f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) y) (x3 n) y)\n else if y = would_be_Cauchy x3 \\<and>\n         z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy x3)\n      then lim (\\<lambda>n.\n                   f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) z)\n                    (x3 n) z)\n      else if y = would_be_Cauchy x3 \\<and>\n              z = would_be_Cauchy x3 \\<and>\n              (\\<forall>n. f (x3 n) (x3 n) (x3 n) = 0)\n           then 0 else 1) =\n                         (\\<lambda>y z.\n                             if y \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3) \\<and>\n                                z \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3)\n                             then g (max2 Bonk_Schramm_extension_unfolded_wo\ny z)\n                                   y z\n                             else if \\<not> (\\<forall>eps>0.\n          \\<exists>N.\n             \\<forall>n\\<ge>N.\n                \\<forall>m\\<ge>N.\n                   g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) (x3 m))\n                    (x3 n) (x3 m)\n                   < eps)\n                                  then 1\n                                  else if y\n    \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy x3) \\<and>\n    z = would_be_Cauchy x3\n then lim (\\<lambda>n.\n              g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) y) (x3 n) y)\n else if y = would_be_Cauchy x3 \\<and>\n         z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy x3)\n      then lim (\\<lambda>n.\n                   g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) z)\n                    (x3 n) z)\n      else if y = would_be_Cauchy x3 \\<and>\n              z = would_be_Cauchy x3 \\<and>\n              (\\<forall>n. g (x3 n) (x3 n) (x3 n) = 0)\n           then 0 else 1)", "(* Deal with the case of a middle, treating separately all the ifs *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>x = middle x21 x22;\n        \\<And>a b.\n           a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>b a.\n           b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>u n.\n           u n\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy u);\n        \\<And>y.\n           y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    (middle x21 x22) \\<Longrightarrow>\n           f y = g y\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>y z.\n                             if y \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (middle x21 x22) \\<and>\n                                z \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (middle x21 x22)\n                             then f (max2 Bonk_Schramm_extension_unfolded_wo\ny z)\n                                   y z\n                             else if y \\<in> underS\n        Bonk_Schramm_extension_unfolded_wo (middle x21 x22) \\<and>\n                                     z = middle x21 x22\n                                  then f\n  (max2 Bonk_Schramm_extension_unfolded_wo x21 x22) x21 x22 /\n 2 +\n (SUP w\\<in>{z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                      (middle x21 x22).\n             f z z z = 0}.\n     f (max2 Bonk_Schramm_extension_unfolded_wo y w) y w -\n     max (f (max2 Bonk_Schramm_extension_unfolded_wo x21 w) x21 w)\n      (f (max2 Bonk_Schramm_extension_unfolded_wo x22 w) x22 w))\n                                  else if y = middle x21 x22 \\<and>\n    z \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle x21 x22)\n then f (max2 Bonk_Schramm_extension_unfolded_wo x21 x22) x21 x22 / 2 +\n      (SUP w\\<in>{z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                           (middle x21 x22).\n                  f z z z = 0}.\n          f (max2 Bonk_Schramm_extension_unfolded_wo z w) z w -\n          max (f (max2 Bonk_Schramm_extension_unfolded_wo x21 w) x21 w)\n           (f (max2 Bonk_Schramm_extension_unfolded_wo x22 w) x22 w))\n else if y = middle x21 x22 \\<and>\n         z = middle x21 x22 \\<and>\n         f x21 x21 x21 = 0 \\<and> f x22 x22 x22 = 0\n      then 0 else 1) =\n                         (\\<lambda>y z.\n                             if y \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (middle x21 x22) \\<and>\n                                z \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (middle x21 x22)\n                             then g (max2 Bonk_Schramm_extension_unfolded_wo\ny z)\n                                   y z\n                             else if y \\<in> underS\n        Bonk_Schramm_extension_unfolded_wo (middle x21 x22) \\<and>\n                                     z = middle x21 x22\n                                  then g\n  (max2 Bonk_Schramm_extension_unfolded_wo x21 x22) x21 x22 /\n 2 +\n (SUP w\\<in>{z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                      (middle x21 x22).\n             g z z z = 0}.\n     g (max2 Bonk_Schramm_extension_unfolded_wo y w) y w -\n     max (g (max2 Bonk_Schramm_extension_unfolded_wo x21 w) x21 w)\n      (g (max2 Bonk_Schramm_extension_unfolded_wo x22 w) x22 w))\n                                  else if y = middle x21 x22 \\<and>\n    z \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle x21 x22)\n then g (max2 Bonk_Schramm_extension_unfolded_wo x21 x22) x21 x22 / 2 +\n      (SUP w\\<in>{z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                           (middle x21 x22).\n                  g z z z = 0}.\n          g (max2 Bonk_Schramm_extension_unfolded_wo z w) z w -\n          max (g (max2 Bonk_Schramm_extension_unfolded_wo x21 w) x21 w)\n           (g (max2 Bonk_Schramm_extension_unfolded_wo x22 w) x22 w))\n else if y = middle x21 x22 \\<and>\n         z = middle x21 x22 \\<and>\n         g x21 x21 x21 = 0 \\<and> g x22 x22 x22 = 0\n      then 0 else 1)\n 2. \\<And>x3.\n       \\<lbrakk>x = would_be_Cauchy x3;\n        \\<And>a b.\n           a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>b a.\n           b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>u n.\n           u n\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy u);\n        \\<And>y.\n           y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    (would_be_Cauchy x3) \\<Longrightarrow>\n           f y = g y\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>y z.\n                             if y \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3) \\<and>\n                                z \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3)\n                             then f (max2 Bonk_Schramm_extension_unfolded_wo\ny z)\n                                   y z\n                             else if \\<not> (\\<forall>eps>0.\n          \\<exists>N.\n             \\<forall>n\\<ge>N.\n                \\<forall>m\\<ge>N.\n                   f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) (x3 m))\n                    (x3 n) (x3 m)\n                   < eps)\n                                  then 1\n                                  else if y\n    \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy x3) \\<and>\n    z = would_be_Cauchy x3\n then lim (\\<lambda>n.\n              f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) y) (x3 n) y)\n else if y = would_be_Cauchy x3 \\<and>\n         z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy x3)\n      then lim (\\<lambda>n.\n                   f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) z)\n                    (x3 n) z)\n      else if y = would_be_Cauchy x3 \\<and>\n              z = would_be_Cauchy x3 \\<and>\n              (\\<forall>n. f (x3 n) (x3 n) (x3 n) = 0)\n           then 0 else 1) =\n                         (\\<lambda>y z.\n                             if y \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3) \\<and>\n                                z \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3)\n                             then g (max2 Bonk_Schramm_extension_unfolded_wo\ny z)\n                                   y z\n                             else if \\<not> (\\<forall>eps>0.\n          \\<exists>N.\n             \\<forall>n\\<ge>N.\n                \\<forall>m\\<ge>N.\n                   g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) (x3 m))\n                    (x3 n) (x3 m)\n                   < eps)\n                                  then 1\n                                  else if y\n    \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy x3) \\<and>\n    z = would_be_Cauchy x3\n then lim (\\<lambda>n.\n              g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) y) (x3 n) y)\n else if y = would_be_Cauchy x3 \\<and>\n         z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy x3)\n      then lim (\\<lambda>n.\n                   g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) z)\n                    (x3 n) z)\n      else if y = would_be_Cauchy x3 \\<and>\n              z = would_be_Cauchy x3 \\<and>\n              (\\<forall>n. g (x3 n) (x3 n) (x3 n) = 0)\n           then 0 else 1)", "apply (rule ext)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 y z.\n       \\<lbrakk>x = middle x21 x22;\n        \\<And>a b.\n           a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>b a.\n           b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>u n.\n           u n\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy u);\n        \\<And>y.\n           y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    (middle x21 x22) \\<Longrightarrow>\n           f y = g y\\<rbrakk>\n       \\<Longrightarrow> (if y \\<in> underS\nBonk_Schramm_extension_unfolded_wo (middle x21 x22) \\<and>\n                             z \\<in> underS\nBonk_Schramm_extension_unfolded_wo (middle x21 x22)\n                          then f (max2 Bonk_Schramm_extension_unfolded_wo y\n                                   z)\n                                y z\n                          else if y \\<in> underS\n     Bonk_Schramm_extension_unfolded_wo (middle x21 x22) \\<and>\n                                  z = middle x21 x22\n                               then f (max2\n  Bonk_Schramm_extension_unfolded_wo x21 x22)\n                                     x21 x22 /\n                                    2 +\n                                    (SUP w\\<in>{z\n          \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle x21 x22).\n          f z z z = 0}.\n  f (max2 Bonk_Schramm_extension_unfolded_wo y w) y w -\n  max (f (max2 Bonk_Schramm_extension_unfolded_wo x21 w) x21 w)\n   (f (max2 Bonk_Schramm_extension_unfolded_wo x22 w) x22 w))\n                               else if y = middle x21 x22 \\<and>\n z \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle x21 x22)\n                                    then f\n    (max2 Bonk_Schramm_extension_unfolded_wo x21 x22) x21 x22 /\n   2 +\n   (SUP w\\<in>{z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                        (middle x21 x22).\n               f z z z = 0}.\n       f (max2 Bonk_Schramm_extension_unfolded_wo z w) z w -\n       max (f (max2 Bonk_Schramm_extension_unfolded_wo x21 w) x21 w)\n        (f (max2 Bonk_Schramm_extension_unfolded_wo x22 w) x22 w))\n                                    else if y = middle x21 x22 \\<and>\n      z = middle x21 x22 \\<and> f x21 x21 x21 = 0 \\<and> f x22 x22 x22 = 0\n   then 0 else 1) =\n                         (if y \\<in> underS\nBonk_Schramm_extension_unfolded_wo (middle x21 x22) \\<and>\n                             z \\<in> underS\nBonk_Schramm_extension_unfolded_wo (middle x21 x22)\n                          then g (max2 Bonk_Schramm_extension_unfolded_wo y\n                                   z)\n                                y z\n                          else if y \\<in> underS\n     Bonk_Schramm_extension_unfolded_wo (middle x21 x22) \\<and>\n                                  z = middle x21 x22\n                               then g (max2\n  Bonk_Schramm_extension_unfolded_wo x21 x22)\n                                     x21 x22 /\n                                    2 +\n                                    (SUP w\\<in>{z\n          \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle x21 x22).\n          g z z z = 0}.\n  g (max2 Bonk_Schramm_extension_unfolded_wo y w) y w -\n  max (g (max2 Bonk_Schramm_extension_unfolded_wo x21 w) x21 w)\n   (g (max2 Bonk_Schramm_extension_unfolded_wo x22 w) x22 w))\n                               else if y = middle x21 x22 \\<and>\n z \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle x21 x22)\n                                    then g\n    (max2 Bonk_Schramm_extension_unfolded_wo x21 x22) x21 x22 /\n   2 +\n   (SUP w\\<in>{z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                        (middle x21 x22).\n               g z z z = 0}.\n       g (max2 Bonk_Schramm_extension_unfolded_wo z w) z w -\n       max (g (max2 Bonk_Schramm_extension_unfolded_wo x21 w) x21 w)\n        (g (max2 Bonk_Schramm_extension_unfolded_wo x22 w) x22 w))\n                                    else if y = middle x21 x22 \\<and>\n      z = middle x21 x22 \\<and> g x21 x21 x21 = 0 \\<and> g x22 x22 x22 = 0\n   then 0 else 1)\n 2. \\<And>x3.\n       \\<lbrakk>x = would_be_Cauchy x3;\n        \\<And>a b.\n           a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>b a.\n           b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>u n.\n           u n\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy u);\n        \\<And>y.\n           y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    (would_be_Cauchy x3) \\<Longrightarrow>\n           f y = g y\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>y z.\n                             if y \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3) \\<and>\n                                z \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3)\n                             then f (max2 Bonk_Schramm_extension_unfolded_wo\ny z)\n                                   y z\n                             else if \\<not> (\\<forall>eps>0.\n          \\<exists>N.\n             \\<forall>n\\<ge>N.\n                \\<forall>m\\<ge>N.\n                   f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) (x3 m))\n                    (x3 n) (x3 m)\n                   < eps)\n                                  then 1\n                                  else if y\n    \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy x3) \\<and>\n    z = would_be_Cauchy x3\n then lim (\\<lambda>n.\n              f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) y) (x3 n) y)\n else if y = would_be_Cauchy x3 \\<and>\n         z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy x3)\n      then lim (\\<lambda>n.\n                   f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) z)\n                    (x3 n) z)\n      else if y = would_be_Cauchy x3 \\<and>\n              z = would_be_Cauchy x3 \\<and>\n              (\\<forall>n. f (x3 n) (x3 n) (x3 n) = 0)\n           then 0 else 1) =\n                         (\\<lambda>y z.\n                             if y \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3) \\<and>\n                                z \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3)\n                             then g (max2 Bonk_Schramm_extension_unfolded_wo\ny z)\n                                   y z\n                             else if \\<not> (\\<forall>eps>0.\n          \\<exists>N.\n             \\<forall>n\\<ge>N.\n                \\<forall>m\\<ge>N.\n                   g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) (x3 m))\n                    (x3 n) (x3 m)\n                   < eps)\n                                  then 1\n                                  else if y\n    \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy x3) \\<and>\n    z = would_be_Cauchy x3\n then lim (\\<lambda>n.\n              g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) y) (x3 n) y)\n else if y = would_be_Cauchy x3 \\<and>\n         z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy x3)\n      then lim (\\<lambda>n.\n                   g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) z)\n                    (x3 n) z)\n      else if y = would_be_Cauchy x3 \\<and>\n              z = would_be_Cauchy x3 \\<and>\n              (\\<forall>n. g (x3 n) (x3 n) (x3 n) = 0)\n           then 0 else 1)", "apply (rule if_cong, simp, simp)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22 y.\n       \\<lbrakk>x = middle x21 x22;\n        \\<And>a b.\n           a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>b a.\n           b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>u n.\n           u n\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy u);\n        \\<And>y.\n           y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    (middle x21 x22) \\<Longrightarrow>\n           f y = g y;\n        y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                 (middle x21 x22)\\<rbrakk>\n       \\<Longrightarrow> (SUP x\\<in>{z \\<in> underS\n        Bonk_Schramm_extension_unfolded_wo (middle x21 x22).\n                                     f z z z = 0}.\n                             g (max2 Bonk_Schramm_extension_unfolded_wo y x)\n                              y x -\n                             max (g (max2 Bonk_Schramm_extension_unfolded_wo\nx21 x)\n                                   x21 x)\n                              (g (max2 Bonk_Schramm_extension_unfolded_wo\n                                   x22 x)\n                                x22 x)) =\n                         (SUP w\\<in>{z \\<in> underS\n        Bonk_Schramm_extension_unfolded_wo (middle x21 x22).\n                                     g z z z = 0}.\n                             g (max2 Bonk_Schramm_extension_unfolded_wo y w)\n                              y w -\n                             max (g (max2 Bonk_Schramm_extension_unfolded_wo\nx21 w)\n                                   x21 w)\n                              (g (max2 Bonk_Schramm_extension_unfolded_wo\n                                   x22 w)\n                                x22 w))\n 2. \\<And>x21 x22 y z.\n       \\<lbrakk>x = middle x21 x22;\n        \\<And>a b.\n           a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>b a.\n           b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>u n.\n           u n\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy u);\n        \\<And>y.\n           y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    (middle x21 x22) \\<Longrightarrow>\n           f y = g y;\n        \\<not> (y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (middle x21 x22) \\<and>\n                z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (middle x21 x22));\n        \\<not> (y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (middle x21 x22) \\<and>\n                z = middle x21 x22)\\<rbrakk>\n       \\<Longrightarrow> (if y = middle x21 x22 \\<and>\n                             z \\<in> underS\nBonk_Schramm_extension_unfolded_wo (middle x21 x22)\n                          then f (max2 Bonk_Schramm_extension_unfolded_wo\n                                   x21 x22)\n                                x21 x22 /\n                               2 +\n                               (SUP w\\<in>{z\n     \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle x21 x22).\n     f z z z = 0}.\n                                   f (max2\n Bonk_Schramm_extension_unfolded_wo z w)\n                                    z w -\n                                   max (f\n   (max2 Bonk_Schramm_extension_unfolded_wo x21 w) x21 w)\n                                    (f\n(max2 Bonk_Schramm_extension_unfolded_wo x22 w) x22 w))\n                          else if y = middle x21 x22 \\<and>\n                                  z = middle x21 x22 \\<and>\n                                  f x21 x21 x21 = 0 \\<and> f x22 x22 x22 = 0\n                               then 0 else 1) =\n                         (if y = middle x21 x22 \\<and>\n                             z \\<in> underS\nBonk_Schramm_extension_unfolded_wo (middle x21 x22)\n                          then g (max2 Bonk_Schramm_extension_unfolded_wo\n                                   x21 x22)\n                                x21 x22 /\n                               2 +\n                               (SUP w\\<in>{z\n     \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle x21 x22).\n     g z z z = 0}.\n                                   g (max2\n Bonk_Schramm_extension_unfolded_wo z w)\n                                    z w -\n                                   max (g\n   (max2 Bonk_Schramm_extension_unfolded_wo x21 w) x21 w)\n                                    (g\n(max2 Bonk_Schramm_extension_unfolded_wo x22 w) x22 w))\n                          else if y = middle x21 x22 \\<and>\n                                  z = middle x21 x22 \\<and>\n                                  g x21 x21 x21 = 0 \\<and> g x22 x22 x22 = 0\n                               then 0 else 1)\n 3. \\<And>x3.\n       \\<lbrakk>x = would_be_Cauchy x3;\n        \\<And>a b.\n           a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>b a.\n           b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>u n.\n           u n\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy u);\n        \\<And>y.\n           y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    (would_be_Cauchy x3) \\<Longrightarrow>\n           f y = g y\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>y z.\n                             if y \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3) \\<and>\n                                z \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3)\n                             then f (max2 Bonk_Schramm_extension_unfolded_wo\ny z)\n                                   y z\n                             else if \\<not> (\\<forall>eps>0.\n          \\<exists>N.\n             \\<forall>n\\<ge>N.\n                \\<forall>m\\<ge>N.\n                   f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) (x3 m))\n                    (x3 n) (x3 m)\n                   < eps)\n                                  then 1\n                                  else if y\n    \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy x3) \\<and>\n    z = would_be_Cauchy x3\n then lim (\\<lambda>n.\n              f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) y) (x3 n) y)\n else if y = would_be_Cauchy x3 \\<and>\n         z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy x3)\n      then lim (\\<lambda>n.\n                   f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) z)\n                    (x3 n) z)\n      else if y = would_be_Cauchy x3 \\<and>\n              z = would_be_Cauchy x3 \\<and>\n              (\\<forall>n. f (x3 n) (x3 n) (x3 n) = 0)\n           then 0 else 1) =\n                         (\\<lambda>y z.\n                             if y \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3) \\<and>\n                                z \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3)\n                             then g (max2 Bonk_Schramm_extension_unfolded_wo\ny z)\n                                   y z\n                             else if \\<not> (\\<forall>eps>0.\n          \\<exists>N.\n             \\<forall>n\\<ge>N.\n                \\<forall>m\\<ge>N.\n                   g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) (x3 m))\n                    (x3 n) (x3 m)\n                   < eps)\n                                  then 1\n                                  else if y\n    \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy x3) \\<and>\n    z = would_be_Cauchy x3\n then lim (\\<lambda>n.\n              g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) y) (x3 n) y)\n else if y = would_be_Cauchy x3 \\<and>\n         z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy x3)\n      then lim (\\<lambda>n.\n                   g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) z)\n                    (x3 n) z)\n      else if y = would_be_Cauchy x3 \\<and>\n              z = would_be_Cauchy x3 \\<and>\n              (\\<forall>n. g (x3 n) (x3 n) (x3 n) = 0)\n           then 0 else 1)", "apply (rule SUP_cong, fastforce, blast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 y z.\n       \\<lbrakk>x = middle x21 x22;\n        \\<And>a b.\n           a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>b a.\n           b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>u n.\n           u n\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy u);\n        \\<And>y.\n           y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    (middle x21 x22) \\<Longrightarrow>\n           f y = g y;\n        \\<not> (y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (middle x21 x22) \\<and>\n                z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (middle x21 x22));\n        \\<not> (y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (middle x21 x22) \\<and>\n                z = middle x21 x22)\\<rbrakk>\n       \\<Longrightarrow> (if y = middle x21 x22 \\<and>\n                             z \\<in> underS\nBonk_Schramm_extension_unfolded_wo (middle x21 x22)\n                          then f (max2 Bonk_Schramm_extension_unfolded_wo\n                                   x21 x22)\n                                x21 x22 /\n                               2 +\n                               (SUP w\\<in>{z\n     \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle x21 x22).\n     f z z z = 0}.\n                                   f (max2\n Bonk_Schramm_extension_unfolded_wo z w)\n                                    z w -\n                                   max (f\n   (max2 Bonk_Schramm_extension_unfolded_wo x21 w) x21 w)\n                                    (f\n(max2 Bonk_Schramm_extension_unfolded_wo x22 w) x22 w))\n                          else if y = middle x21 x22 \\<and>\n                                  z = middle x21 x22 \\<and>\n                                  f x21 x21 x21 = 0 \\<and> f x22 x22 x22 = 0\n                               then 0 else 1) =\n                         (if y = middle x21 x22 \\<and>\n                             z \\<in> underS\nBonk_Schramm_extension_unfolded_wo (middle x21 x22)\n                          then g (max2 Bonk_Schramm_extension_unfolded_wo\n                                   x21 x22)\n                                x21 x22 /\n                               2 +\n                               (SUP w\\<in>{z\n     \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle x21 x22).\n     g z z z = 0}.\n                                   g (max2\n Bonk_Schramm_extension_unfolded_wo z w)\n                                    z w -\n                                   max (g\n   (max2 Bonk_Schramm_extension_unfolded_wo x21 w) x21 w)\n                                    (g\n(max2 Bonk_Schramm_extension_unfolded_wo x22 w) x22 w))\n                          else if y = middle x21 x22 \\<and>\n                                  z = middle x21 x22 \\<and>\n                                  g x21 x21 x21 = 0 \\<and> g x22 x22 x22 = 0\n                               then 0 else 1)\n 2. \\<And>x3.\n       \\<lbrakk>x = would_be_Cauchy x3;\n        \\<And>a b.\n           a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>b a.\n           b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>u n.\n           u n\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy u);\n        \\<And>y.\n           y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    (would_be_Cauchy x3) \\<Longrightarrow>\n           f y = g y\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>y z.\n                             if y \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3) \\<and>\n                                z \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3)\n                             then f (max2 Bonk_Schramm_extension_unfolded_wo\ny z)\n                                   y z\n                             else if \\<not> (\\<forall>eps>0.\n          \\<exists>N.\n             \\<forall>n\\<ge>N.\n                \\<forall>m\\<ge>N.\n                   f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) (x3 m))\n                    (x3 n) (x3 m)\n                   < eps)\n                                  then 1\n                                  else if y\n    \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy x3) \\<and>\n    z = would_be_Cauchy x3\n then lim (\\<lambda>n.\n              f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) y) (x3 n) y)\n else if y = would_be_Cauchy x3 \\<and>\n         z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy x3)\n      then lim (\\<lambda>n.\n                   f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) z)\n                    (x3 n) z)\n      else if y = would_be_Cauchy x3 \\<and>\n              z = would_be_Cauchy x3 \\<and>\n              (\\<forall>n. f (x3 n) (x3 n) (x3 n) = 0)\n           then 0 else 1) =\n                         (\\<lambda>y z.\n                             if y \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3) \\<and>\n                                z \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3)\n                             then g (max2 Bonk_Schramm_extension_unfolded_wo\ny z)\n                                   y z\n                             else if \\<not> (\\<forall>eps>0.\n          \\<exists>N.\n             \\<forall>n\\<ge>N.\n                \\<forall>m\\<ge>N.\n                   g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) (x3 m))\n                    (x3 n) (x3 m)\n                   < eps)\n                                  then 1\n                                  else if y\n    \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy x3) \\<and>\n    z = would_be_Cauchy x3\n then lim (\\<lambda>n.\n              g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) y) (x3 n) y)\n else if y = would_be_Cauchy x3 \\<and>\n         z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy x3)\n      then lim (\\<lambda>n.\n                   g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) z)\n                    (x3 n) z)\n      else if y = would_be_Cauchy x3 \\<and>\n              z = would_be_Cauchy x3 \\<and>\n              (\\<forall>n. g (x3 n) (x3 n) (x3 n) = 0)\n           then 0 else 1)", "apply (rule if_cong, simp, simp)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22 z.\n       \\<lbrakk>x = middle x21 x22;\n        \\<And>a b.\n           a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>b a.\n           b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>u n.\n           u n\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy u);\n        \\<And>y.\n           y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    (middle x21 x22) \\<Longrightarrow>\n           f y = g y;\n        z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                 (middle x21 x22)\\<rbrakk>\n       \\<Longrightarrow> (SUP x\\<in>{z \\<in> underS\n        Bonk_Schramm_extension_unfolded_wo (middle x21 x22).\n                                     f z z z = 0}.\n                             g (max2 Bonk_Schramm_extension_unfolded_wo z x)\n                              z x -\n                             max (g (max2 Bonk_Schramm_extension_unfolded_wo\nx21 x)\n                                   x21 x)\n                              (g (max2 Bonk_Schramm_extension_unfolded_wo\n                                   x22 x)\n                                x22 x)) =\n                         (SUP w\\<in>{z \\<in> underS\n        Bonk_Schramm_extension_unfolded_wo (middle x21 x22).\n                                     g z z z = 0}.\n                             g (max2 Bonk_Schramm_extension_unfolded_wo z w)\n                              z w -\n                             max (g (max2 Bonk_Schramm_extension_unfolded_wo\nx21 w)\n                                   x21 w)\n                              (g (max2 Bonk_Schramm_extension_unfolded_wo\n                                   x22 w)\n                                x22 w))\n 2. \\<And>x21 x22 y z.\n       \\<lbrakk>x = middle x21 x22;\n        \\<And>a b.\n           a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>b a.\n           b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>u n.\n           u n\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy u);\n        \\<And>y.\n           y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    (middle x21 x22) \\<Longrightarrow>\n           f y = g y;\n        \\<not> (y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (middle x21 x22) \\<and>\n                z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (middle x21 x22));\n        \\<not> (y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (middle x21 x22) \\<and>\n                z = middle x21 x22);\n        \\<not> (y = middle x21 x22 \\<and>\n                z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (middle x21 x22))\\<rbrakk>\n       \\<Longrightarrow> (if y = middle x21 x22 \\<and>\n                             z = middle x21 x22 \\<and>\n                             f x21 x21 x21 = 0 \\<and> f x22 x22 x22 = 0\n                          then 0 else 1) =\n                         (if y = middle x21 x22 \\<and>\n                             z = middle x21 x22 \\<and>\n                             g x21 x21 x21 = 0 \\<and> g x22 x22 x22 = 0\n                          then 0 else 1)\n 3. \\<And>x3.\n       \\<lbrakk>x = would_be_Cauchy x3;\n        \\<And>a b.\n           a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>b a.\n           b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>u n.\n           u n\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy u);\n        \\<And>y.\n           y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    (would_be_Cauchy x3) \\<Longrightarrow>\n           f y = g y\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>y z.\n                             if y \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3) \\<and>\n                                z \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3)\n                             then f (max2 Bonk_Schramm_extension_unfolded_wo\ny z)\n                                   y z\n                             else if \\<not> (\\<forall>eps>0.\n          \\<exists>N.\n             \\<forall>n\\<ge>N.\n                \\<forall>m\\<ge>N.\n                   f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) (x3 m))\n                    (x3 n) (x3 m)\n                   < eps)\n                                  then 1\n                                  else if y\n    \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy x3) \\<and>\n    z = would_be_Cauchy x3\n then lim (\\<lambda>n.\n              f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) y) (x3 n) y)\n else if y = would_be_Cauchy x3 \\<and>\n         z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy x3)\n      then lim (\\<lambda>n.\n                   f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) z)\n                    (x3 n) z)\n      else if y = would_be_Cauchy x3 \\<and>\n              z = would_be_Cauchy x3 \\<and>\n              (\\<forall>n. f (x3 n) (x3 n) (x3 n) = 0)\n           then 0 else 1) =\n                         (\\<lambda>y z.\n                             if y \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3) \\<and>\n                                z \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3)\n                             then g (max2 Bonk_Schramm_extension_unfolded_wo\ny z)\n                                   y z\n                             else if \\<not> (\\<forall>eps>0.\n          \\<exists>N.\n             \\<forall>n\\<ge>N.\n                \\<forall>m\\<ge>N.\n                   g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) (x3 m))\n                    (x3 n) (x3 m)\n                   < eps)\n                                  then 1\n                                  else if y\n    \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy x3) \\<and>\n    z = would_be_Cauchy x3\n then lim (\\<lambda>n.\n              g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) y) (x3 n) y)\n else if y = would_be_Cauchy x3 \\<and>\n         z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy x3)\n      then lim (\\<lambda>n.\n                   g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) z)\n                    (x3 n) z)\n      else if y = would_be_Cauchy x3 \\<and>\n              z = would_be_Cauchy x3 \\<and>\n              (\\<forall>n. g (x3 n) (x3 n) (x3 n) = 0)\n           then 0 else 1)", "apply (rule SUP_cong, fastforce, blast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 y z.\n       \\<lbrakk>x = middle x21 x22;\n        \\<And>a b.\n           a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>b a.\n           b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>u n.\n           u n\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy u);\n        \\<And>y.\n           y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    (middle x21 x22) \\<Longrightarrow>\n           f y = g y;\n        \\<not> (y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (middle x21 x22) \\<and>\n                z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (middle x21 x22));\n        \\<not> (y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (middle x21 x22) \\<and>\n                z = middle x21 x22);\n        \\<not> (y = middle x21 x22 \\<and>\n                z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (middle x21 x22))\\<rbrakk>\n       \\<Longrightarrow> (if y = middle x21 x22 \\<and>\n                             z = middle x21 x22 \\<and>\n                             f x21 x21 x21 = 0 \\<and> f x22 x22 x22 = 0\n                          then 0 else 1) =\n                         (if y = middle x21 x22 \\<and>\n                             z = middle x21 x22 \\<and>\n                             g x21 x21 x21 = 0 \\<and> g x22 x22 x22 = 0\n                          then 0 else 1)\n 2. \\<And>x3.\n       \\<lbrakk>x = would_be_Cauchy x3;\n        \\<And>a b.\n           a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>b a.\n           b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>u n.\n           u n\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy u);\n        \\<And>y.\n           y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    (would_be_Cauchy x3) \\<Longrightarrow>\n           f y = g y\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>y z.\n                             if y \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3) \\<and>\n                                z \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3)\n                             then f (max2 Bonk_Schramm_extension_unfolded_wo\ny z)\n                                   y z\n                             else if \\<not> (\\<forall>eps>0.\n          \\<exists>N.\n             \\<forall>n\\<ge>N.\n                \\<forall>m\\<ge>N.\n                   f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) (x3 m))\n                    (x3 n) (x3 m)\n                   < eps)\n                                  then 1\n                                  else if y\n    \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy x3) \\<and>\n    z = would_be_Cauchy x3\n then lim (\\<lambda>n.\n              f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) y) (x3 n) y)\n else if y = would_be_Cauchy x3 \\<and>\n         z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy x3)\n      then lim (\\<lambda>n.\n                   f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) z)\n                    (x3 n) z)\n      else if y = would_be_Cauchy x3 \\<and>\n              z = would_be_Cauchy x3 \\<and>\n              (\\<forall>n. f (x3 n) (x3 n) (x3 n) = 0)\n           then 0 else 1) =\n                         (\\<lambda>y z.\n                             if y \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3) \\<and>\n                                z \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3)\n                             then g (max2 Bonk_Schramm_extension_unfolded_wo\ny z)\n                                   y z\n                             else if \\<not> (\\<forall>eps>0.\n          \\<exists>N.\n             \\<forall>n\\<ge>N.\n                \\<forall>m\\<ge>N.\n                   g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) (x3 m))\n                    (x3 n) (x3 m)\n                   < eps)\n                                  then 1\n                                  else if y\n    \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy x3) \\<and>\n    z = would_be_Cauchy x3\n then lim (\\<lambda>n.\n              g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) y) (x3 n) y)\n else if y = would_be_Cauchy x3 \\<and>\n         z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy x3)\n      then lim (\\<lambda>n.\n                   g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) z)\n                    (x3 n) z)\n      else if y = would_be_Cauchy x3 \\<and>\n              z = would_be_Cauchy x3 \\<and>\n              (\\<forall>n. g (x3 n) (x3 n) (x3 n) = 0)\n           then 0 else 1)", "apply (rule if_cong, simp, simp)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 y z.\n       \\<lbrakk>x = middle x21 x22;\n        \\<And>a b.\n           a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>b a.\n           b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>u n.\n           u n\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy u);\n        \\<And>y.\n           y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    (middle x21 x22) \\<Longrightarrow>\n           f y = g y;\n        \\<not> (y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (middle x21 x22) \\<and>\n                z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (middle x21 x22));\n        \\<not> (y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (middle x21 x22) \\<and>\n                z = middle x21 x22);\n        \\<not> (y = middle x21 x22 \\<and>\n                z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (middle x21 x22));\n        \\<not> (y = middle x21 x22 \\<and>\n                z = middle x21 x22 \\<and>\n                g x21 x21 x21 = 0 \\<and> g x22 x22 x22 = 0)\\<rbrakk>\n       \\<Longrightarrow> 1 = 1\n 2. \\<And>x3.\n       \\<lbrakk>x = would_be_Cauchy x3;\n        \\<And>a b.\n           a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>b a.\n           b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>u n.\n           u n\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy u);\n        \\<And>y.\n           y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    (would_be_Cauchy x3) \\<Longrightarrow>\n           f y = g y\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>y z.\n                             if y \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3) \\<and>\n                                z \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3)\n                             then f (max2 Bonk_Schramm_extension_unfolded_wo\ny z)\n                                   y z\n                             else if \\<not> (\\<forall>eps>0.\n          \\<exists>N.\n             \\<forall>n\\<ge>N.\n                \\<forall>m\\<ge>N.\n                   f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) (x3 m))\n                    (x3 n) (x3 m)\n                   < eps)\n                                  then 1\n                                  else if y\n    \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy x3) \\<and>\n    z = would_be_Cauchy x3\n then lim (\\<lambda>n.\n              f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) y) (x3 n) y)\n else if y = would_be_Cauchy x3 \\<and>\n         z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy x3)\n      then lim (\\<lambda>n.\n                   f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) z)\n                    (x3 n) z)\n      else if y = would_be_Cauchy x3 \\<and>\n              z = would_be_Cauchy x3 \\<and>\n              (\\<forall>n. f (x3 n) (x3 n) (x3 n) = 0)\n           then 0 else 1) =\n                         (\\<lambda>y z.\n                             if y \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3) \\<and>\n                                z \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3)\n                             then g (max2 Bonk_Schramm_extension_unfolded_wo\ny z)\n                                   y z\n                             else if \\<not> (\\<forall>eps>0.\n          \\<exists>N.\n             \\<forall>n\\<ge>N.\n                \\<forall>m\\<ge>N.\n                   g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) (x3 m))\n                    (x3 n) (x3 m)\n                   < eps)\n                                  then 1\n                                  else if y\n    \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy x3) \\<and>\n    z = would_be_Cauchy x3\n then lim (\\<lambda>n.\n              g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) y) (x3 n) y)\n else if y = would_be_Cauchy x3 \\<and>\n         z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy x3)\n      then lim (\\<lambda>n.\n                   g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) z)\n                    (x3 n) z)\n      else if y = would_be_Cauchy x3 \\<and>\n              z = would_be_Cauchy x3 \\<and>\n              (\\<forall>n. g (x3 n) (x3 n) (x3 n) = 0)\n           then 0 else 1)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>x = would_be_Cauchy x3;\n        \\<And>a b.\n           a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>b a.\n           b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>u n.\n           u n\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy u);\n        \\<And>y.\n           y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    (would_be_Cauchy x3) \\<Longrightarrow>\n           f y = g y\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>y z.\n                             if y \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3) \\<and>\n                                z \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3)\n                             then f (max2 Bonk_Schramm_extension_unfolded_wo\ny z)\n                                   y z\n                             else if \\<not> (\\<forall>eps>0.\n          \\<exists>N.\n             \\<forall>n\\<ge>N.\n                \\<forall>m\\<ge>N.\n                   f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) (x3 m))\n                    (x3 n) (x3 m)\n                   < eps)\n                                  then 1\n                                  else if y\n    \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy x3) \\<and>\n    z = would_be_Cauchy x3\n then lim (\\<lambda>n.\n              f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) y) (x3 n) y)\n else if y = would_be_Cauchy x3 \\<and>\n         z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy x3)\n      then lim (\\<lambda>n.\n                   f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) z)\n                    (x3 n) z)\n      else if y = would_be_Cauchy x3 \\<and>\n              z = would_be_Cauchy x3 \\<and>\n              (\\<forall>n. f (x3 n) (x3 n) (x3 n) = 0)\n           then 0 else 1) =\n                         (\\<lambda>y z.\n                             if y \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3) \\<and>\n                                z \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3)\n                             then g (max2 Bonk_Schramm_extension_unfolded_wo\ny z)\n                                   y z\n                             else if \\<not> (\\<forall>eps>0.\n          \\<exists>N.\n             \\<forall>n\\<ge>N.\n                \\<forall>m\\<ge>N.\n                   g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) (x3 m))\n                    (x3 n) (x3 m)\n                   < eps)\n                                  then 1\n                                  else if y\n    \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy x3) \\<and>\n    z = would_be_Cauchy x3\n then lim (\\<lambda>n.\n              g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) y) (x3 n) y)\n else if y = would_be_Cauchy x3 \\<and>\n         z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy x3)\n      then lim (\\<lambda>n.\n                   g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) z)\n                    (x3 n) z)\n      else if y = would_be_Cauchy x3 \\<and>\n              z = would_be_Cauchy x3 \\<and>\n              (\\<forall>n. g (x3 n) (x3 n) (x3 n) = 0)\n           then 0 else 1)", "(* Deal with the case of a sequence, treating separately all the ifs *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>x = would_be_Cauchy x3;\n        \\<And>a b.\n           a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>b a.\n           b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>u n.\n           u n\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy u);\n        \\<And>y.\n           y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    (would_be_Cauchy x3) \\<Longrightarrow>\n           f y = g y\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>y z.\n                             if y \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3) \\<and>\n                                z \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3)\n                             then f (max2 Bonk_Schramm_extension_unfolded_wo\ny z)\n                                   y z\n                             else if \\<not> (\\<forall>eps>0.\n          \\<exists>N.\n             \\<forall>n\\<ge>N.\n                \\<forall>m\\<ge>N.\n                   f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) (x3 m))\n                    (x3 n) (x3 m)\n                   < eps)\n                                  then 1\n                                  else if y\n    \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy x3) \\<and>\n    z = would_be_Cauchy x3\n then lim (\\<lambda>n.\n              f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) y) (x3 n) y)\n else if y = would_be_Cauchy x3 \\<and>\n         z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy x3)\n      then lim (\\<lambda>n.\n                   f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) z)\n                    (x3 n) z)\n      else if y = would_be_Cauchy x3 \\<and>\n              z = would_be_Cauchy x3 \\<and>\n              (\\<forall>n. f (x3 n) (x3 n) (x3 n) = 0)\n           then 0 else 1) =\n                         (\\<lambda>y z.\n                             if y \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3) \\<and>\n                                z \\<in> underS\n   Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3)\n                             then g (max2 Bonk_Schramm_extension_unfolded_wo\ny z)\n                                   y z\n                             else if \\<not> (\\<forall>eps>0.\n          \\<exists>N.\n             \\<forall>n\\<ge>N.\n                \\<forall>m\\<ge>N.\n                   g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) (x3 m))\n                    (x3 n) (x3 m)\n                   < eps)\n                                  then 1\n                                  else if y\n    \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy x3) \\<and>\n    z = would_be_Cauchy x3\n then lim (\\<lambda>n.\n              g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) y) (x3 n) y)\n else if y = would_be_Cauchy x3 \\<and>\n         z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy x3)\n      then lim (\\<lambda>n.\n                   g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) z)\n                    (x3 n) z)\n      else if y = would_be_Cauchy x3 \\<and>\n              z = would_be_Cauchy x3 \\<and>\n              (\\<forall>n. g (x3 n) (x3 n) (x3 n) = 0)\n           then 0 else 1)", "apply (rule ext)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x3 y z.\n       \\<lbrakk>x = would_be_Cauchy x3;\n        \\<And>a b.\n           a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>b a.\n           b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>u n.\n           u n\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy u);\n        \\<And>y.\n           y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    (would_be_Cauchy x3) \\<Longrightarrow>\n           f y = g y\\<rbrakk>\n       \\<Longrightarrow> (if y \\<in> underS\nBonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3) \\<and>\n                             z \\<in> underS\nBonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3)\n                          then f (max2 Bonk_Schramm_extension_unfolded_wo y\n                                   z)\n                                y z\n                          else if \\<not> (\\<forall>eps>0.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) (x3 m))\n                 (x3 n) (x3 m)\n                < eps)\n                               then 1\n                               else if y\n \\<in> underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3) \\<and>\n z = would_be_Cauchy x3\n                                    then lim\n    (\\<lambda>n.\n        f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) y) (x3 n) y)\n                                    else if y = would_be_Cauchy x3 \\<and>\n      z \\<in> underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3)\n   then lim (\\<lambda>n.\n                f (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) z) (x3 n)\n                 z)\n   else if y = would_be_Cauchy x3 \\<and>\n           z = would_be_Cauchy x3 \\<and>\n           (\\<forall>n. f (x3 n) (x3 n) (x3 n) = 0)\n        then 0 else 1) =\n                         (if y \\<in> underS\nBonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3) \\<and>\n                             z \\<in> underS\nBonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3)\n                          then g (max2 Bonk_Schramm_extension_unfolded_wo y\n                                   z)\n                                y z\n                          else if \\<not> (\\<forall>eps>0.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) (x3 m))\n                 (x3 n) (x3 m)\n                < eps)\n                               then 1\n                               else if y\n \\<in> underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3) \\<and>\n z = would_be_Cauchy x3\n                                    then lim\n    (\\<lambda>n.\n        g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) y) (x3 n) y)\n                                    else if y = would_be_Cauchy x3 \\<and>\n      z \\<in> underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy x3)\n   then lim (\\<lambda>n.\n                g (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) z) (x3 n)\n                 z)\n   else if y = would_be_Cauchy x3 \\<and>\n           z = would_be_Cauchy x3 \\<and>\n           (\\<forall>n. g (x3 n) (x3 n) (x3 n) = 0)\n        then 0 else 1)", "apply (rule if_cong, simp, simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x3 y z.\n       \\<lbrakk>x = would_be_Cauchy x3;\n        \\<And>a b.\n           a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>b a.\n           b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b);\n        \\<And>u n.\n           u n\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                  (would_be_Cauchy u);\n        \\<And>y.\n           y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    (would_be_Cauchy x3) \\<Longrightarrow>\n           f y = g y;\n        \\<not> (y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (would_be_Cauchy x3) \\<and>\n                z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (would_be_Cauchy x3));\n        \\<not> \\<not> (\\<forall>eps>0.\n                          \\<exists>N.\n                             \\<forall>n\\<ge>N.\n                                \\<forall>m\\<ge>N.\n                                   g (max2\n Bonk_Schramm_extension_unfolded_wo (x3 n) (x3 m))\n                                    (x3 n) (x3 m)\n                                   < eps);\n        \\<not> (y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (would_be_Cauchy x3) \\<and>\n                z = would_be_Cauchy x3);\n        \\<not> (y = would_be_Cauchy x3 \\<and>\n                z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (would_be_Cauchy x3));\n        \\<not> (y = would_be_Cauchy x3 \\<and>\n                z = would_be_Cauchy x3 \\<and>\n                (\\<forall>n. g (x3 n) (x3 n) (x3 n) = 0))\\<rbrakk>\n       \\<Longrightarrow> 1 = 1", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  extend_distance f x = extend_distance g x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extend_distance_fp:\n  \"extend_distance_fp = extend_distance (extend_distance_fp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_distance_fp = extend_distance extend_distance_fp", "using wo.worec_fixpoint[OF wo_adm_extend_distance]"], ["proof (prove)\nusing this:\n  worec Bonk_Schramm_extension_unfolded_wo extend_distance =\n  extend_distance (worec Bonk_Schramm_extension_unfolded_wo extend_distance)\n\ngoal (1 subgoal):\n 1. extend_distance_fp = extend_distance extend_distance_fp", "unfolding extend_distance_fp_def"], ["proof (prove)\nusing this:\n  worec Bonk_Schramm_extension_unfolded_wo extend_distance =\n  extend_distance (worec Bonk_Schramm_extension_unfolded_wo extend_distance)\n\ngoal (1 subgoal):\n 1. worec Bonk_Schramm_extension_unfolded_wo extend_distance =\n    extend_distance\n     (worec Bonk_Schramm_extension_unfolded_wo extend_distance)", "."], ["", "lemma extended_distance_symmetric:\n  \"extended_distance x y = extended_distance y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance x y = extended_distance y x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. extended_distance x y = extended_distance y x", "have *: \"extend_distance (extend_distance_fp) x x y = extend_distance (extend_distance_fp) x y x\" if \"y \\<in> wo.underS x\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_distance extend_distance_fp x x y =\n    extend_distance extend_distance_fp x y x", "apply (cases x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       x = basepoint x1 \\<Longrightarrow>\n       extend_distance extend_distance_fp x x y =\n       extend_distance extend_distance_fp x y x\n 2. \\<And>x21 x22.\n       x = middle x21 x22 \\<Longrightarrow>\n       extend_distance extend_distance_fp x x y =\n       extend_distance extend_distance_fp x y x\n 3. \\<And>x3.\n       x = would_be_Cauchy x3 \\<Longrightarrow>\n       extend_distance extend_distance_fp x x y =\n       extend_distance extend_distance_fp x y x", "apply (simp add: that dist_commute)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x3.\n       x = would_be_Cauchy x3 \\<Longrightarrow>\n       (y = would_be_Cauchy x3 \\<longrightarrow>\n        (\\<exists>n.\n            extend_distance_fp (x3 n) (x3 n) (x3 n) \\<noteq>\n            0)) \\<longrightarrow>\n       (\\<exists>eps>0.\n           \\<forall>N.\n              \\<exists>n\\<ge>N.\n                 \\<exists>m\\<ge>N.\n                    \\<not> extend_distance_fp\n                            (max2 Bonk_Schramm_extension_unfolded_wo (x3 n)\n                              (x3 m))\n                            (x3 n) (x3 m)\n                           < eps) \\<longrightarrow>\n       y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                (would_be_Cauchy x3) \\<longrightarrow>\n       (\\<forall>eps>0.\n           \\<exists>N.\n              \\<forall>n\\<ge>N.\n                 \\<forall>m\\<ge>N.\n                    extend_distance_fp\n                     (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) (x3 m))\n                     (x3 n) (x3 m)\n                    < eps) \\<longrightarrow>\n       lim (\\<lambda>n.\n               extend_distance_fp\n                (max2 Bonk_Schramm_extension_unfolded_wo (x3 n) y) (x3 n)\n                y) =\n       1", "by blast"], ["proof (state)\nthis:\n  ?y1 \\<in> underS Bonk_Schramm_extension_unfolded_wo ?x1 \\<Longrightarrow>\n  extend_distance extend_distance_fp ?x1 ?x1 ?y1 =\n  extend_distance extend_distance_fp ?x1 ?y1 ?x1\n\ngoal (1 subgoal):\n 1. extended_distance x y = extended_distance y x", "have **: \"extended_distance x y = extended_distance y x\" if \"y \\<in> wo.underS x\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance x y = extended_distance y x", "unfolding extended_distance_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_distance_fp (max2 Bonk_Schramm_extension_unfolded_wo x y) x y =\n    extend_distance_fp (max2 Bonk_Schramm_extension_unfolded_wo y x) y x", "using that *[OF that] extend_distance_fp"], ["proof (prove)\nusing this:\n  y \\<in> underS Bonk_Schramm_extension_unfolded_wo x\n  extend_distance extend_distance_fp x x y =\n  extend_distance extend_distance_fp x y x\n  extend_distance_fp = extend_distance extend_distance_fp\n\ngoal (1 subgoal):\n 1. extend_distance_fp (max2 Bonk_Schramm_extension_unfolded_wo x y) x y =\n    extend_distance_fp (max2 Bonk_Schramm_extension_unfolded_wo y x) y x", "by simp"], ["proof (state)\nthis:\n  ?y1 \\<in> underS Bonk_Schramm_extension_unfolded_wo ?x1 \\<Longrightarrow>\n  extended_distance ?x1 ?y1 = extended_distance ?y1 ?x1\n\ngoal (1 subgoal):\n 1. extended_distance x y = extended_distance y x", "consider \"y \\<in> wo.underS x\"|\"x \\<in> wo.underS y\"|\"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                      x \\<Longrightarrow>\n             thesis;\n     x \\<in> underS Bonk_Schramm_extension_unfolded_wo y \\<Longrightarrow>\n     thesis;\n     x = y \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis UNIV_I Bonk_Schramm_extension_unfolded_wo_props(1) that(1) underS_I well_order_on_Well_order wo.TOTALS)"], ["proof (state)\nthis:\n  \\<lbrakk>y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    x \\<Longrightarrow>\n           ?thesis1;\n   x \\<in> underS Bonk_Schramm_extension_unfolded_wo y \\<Longrightarrow>\n   ?thesis1;\n   x = y \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. extended_distance x y = extended_distance y x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    x \\<Longrightarrow>\n           ?thesis1;\n   x \\<in> underS Bonk_Schramm_extension_unfolded_wo y \\<Longrightarrow>\n   ?thesis1;\n   x = y \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>y \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    x \\<Longrightarrow>\n           ?thesis1;\n   x \\<in> underS Bonk_Schramm_extension_unfolded_wo y \\<Longrightarrow>\n   ?thesis1;\n   x = y \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. extended_distance x y = extended_distance y x", "apply (cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. y \\<in> underS Bonk_Schramm_extension_unfolded_wo x \\<Longrightarrow>\n    extended_distance x y = extended_distance y x\n 2. x \\<in> underS Bonk_Schramm_extension_unfolded_wo y \\<Longrightarrow>\n    extended_distance x y = extended_distance y x\n 3. x = y \\<Longrightarrow> extended_distance x y = extended_distance y x", "using **"], ["proof (prove)\nusing this:\n  ?y1 \\<in> underS Bonk_Schramm_extension_unfolded_wo ?x1 \\<Longrightarrow>\n  extended_distance ?x1 ?y1 = extended_distance ?y1 ?x1\n\ngoal (3 subgoals):\n 1. y \\<in> underS Bonk_Schramm_extension_unfolded_wo x \\<Longrightarrow>\n    extended_distance x y = extended_distance y x\n 2. x \\<in> underS Bonk_Schramm_extension_unfolded_wo y \\<Longrightarrow>\n    extended_distance x y = extended_distance y x\n 3. x = y \\<Longrightarrow> extended_distance x y = extended_distance y x", "by auto"], ["proof (state)\nthis:\n  extended_distance x y = extended_distance y x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extended_distance_basepoint:\n  \"extended_distance (basepoint x) (basepoint y) = dist x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance (basepoint x) (basepoint y) = dist x y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. extended_distance (basepoint x) (basepoint y) = dist x y", "consider \"wo.max2 (basepoint x) (basepoint y) = basepoint x\" | \"wo.max2 (basepoint x) (basepoint y) = basepoint y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>max2 Bonk_Schramm_extension_unfolded_wo (basepoint x)\n              (basepoint y) =\n             basepoint x \\<Longrightarrow>\n             thesis;\n     max2 Bonk_Schramm_extension_unfolded_wo (basepoint x) (basepoint y) =\n     basepoint y \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (meson wo.max2_def)"], ["proof (state)\nthis:\n  \\<lbrakk>max2 Bonk_Schramm_extension_unfolded_wo (basepoint x)\n            (basepoint y) =\n           basepoint x \\<Longrightarrow>\n           ?thesis1;\n   max2 Bonk_Schramm_extension_unfolded_wo (basepoint x) (basepoint y) =\n   basepoint y \\<Longrightarrow>\n   ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. extended_distance (basepoint x) (basepoint y) = dist x y", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>max2 Bonk_Schramm_extension_unfolded_wo (basepoint x)\n            (basepoint y) =\n           basepoint x \\<Longrightarrow>\n           ?thesis1;\n   max2 Bonk_Schramm_extension_unfolded_wo (basepoint x) (basepoint y) =\n   basepoint y \\<Longrightarrow>\n   ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>max2 Bonk_Schramm_extension_unfolded_wo (basepoint x)\n            (basepoint y) =\n           basepoint x \\<Longrightarrow>\n           ?thesis1;\n   max2 Bonk_Schramm_extension_unfolded_wo (basepoint x) (basepoint y) =\n   basepoint y \\<Longrightarrow>\n   ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. extended_distance (basepoint x) (basepoint y) = dist x y", "apply cases"], ["proof (prove)\ngoal (2 subgoals):\n 1. max2 Bonk_Schramm_extension_unfolded_wo (basepoint x) (basepoint y) =\n    basepoint x \\<Longrightarrow>\n    extended_distance (basepoint x) (basepoint y) = dist x y\n 2. max2 Bonk_Schramm_extension_unfolded_wo (basepoint x) (basepoint y) =\n    basepoint y \\<Longrightarrow>\n    extended_distance (basepoint x) (basepoint y) = dist x y", "unfolding extended_distance_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. max2 Bonk_Schramm_extension_unfolded_wo (basepoint x) (basepoint y) =\n    basepoint x \\<Longrightarrow>\n    extend_distance_fp\n     (max2 Bonk_Schramm_extension_unfolded_wo (basepoint x) (basepoint y))\n     (basepoint x) (basepoint y) =\n    dist x y\n 2. max2 Bonk_Schramm_extension_unfolded_wo (basepoint x) (basepoint y) =\n    basepoint y \\<Longrightarrow>\n    extend_distance_fp\n     (max2 Bonk_Schramm_extension_unfolded_wo (basepoint x) (basepoint y))\n     (basepoint x) (basepoint y) =\n    dist x y", "by (subst extend_distance_fp, simp)+"], ["proof (state)\nthis:\n  extended_distance (basepoint x) (basepoint y) = dist x y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extended_distance_set_basepoint:\n  \"basepoint x \\<in> extended_distance_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basepoint x \\<in> extended_distance_set", "unfolding extended_distance_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. basepoint x \\<in> {z. extended_distance z z = 0}", "using extended_distance_basepoint"], ["proof (prove)\nusing this:\n  extended_distance (basepoint ?x) (basepoint ?y) = dist ?x ?y\n\ngoal (1 subgoal):\n 1. basepoint x \\<in> {z. extended_distance z z = 0}", "by auto"], ["", "lemma extended_distance_set_middle:\n  assumes \"a \\<in> extended_distance_set\" \"b \\<in> extended_distance_set\"\n  shows \"middle a b \\<in> extended_distance_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. middle a b \\<in> extended_distance_set", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> extended_distance_set\n  b \\<in> extended_distance_set\n\ngoal (1 subgoal):\n 1. middle a b \\<in> extended_distance_set", "unfolding extended_distance_set_def extended_distance_def"], ["proof (prove)\nusing this:\n  a \\<in> {z. extend_distance_fp\n               (max2 Bonk_Schramm_extension_unfolded_wo z z) z z =\n              0}\n  b \\<in> {z. extend_distance_fp\n               (max2 Bonk_Schramm_extension_unfolded_wo z z) z z =\n              0}\n\ngoal (1 subgoal):\n 1. middle a b\n    \\<in> {z. extend_distance_fp\n               (max2 Bonk_Schramm_extension_unfolded_wo z z) z z =\n              0}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extend_distance_fp a a a = 0;\n     extend_distance_fp b b b = 0\\<rbrakk>\n    \\<Longrightarrow> extend_distance_fp (middle a b) (middle a b)\n                       (middle a b) =\n                      0", "by (metis (no_types, lifting) extend_distance_fp extend_distance.simps(2) underS_E)"], ["", "lemma extended_distance_set_middle':\n  assumes \"middle a b \\<in> extended_distance_set\"\n  shows \"a \\<in> extended_distance_set \\<inter> wo.underS (middle a b)\"\n        \"b \\<in> extended_distance_set \\<inter> wo.underS (middle a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> extended_distance_set \\<inter>\n            underS Bonk_Schramm_extension_unfolded_wo (middle a b) &&&\n    b \\<in> extended_distance_set \\<inter>\n            underS Bonk_Schramm_extension_unfolded_wo (middle a b)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> extended_distance_set \\<inter>\n            underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n 2. b \\<in> extended_distance_set \\<inter>\n            underS Bonk_Schramm_extension_unfolded_wo (middle a b)", "have \"extend_distance (extend_distance_fp) (middle a b) (middle a b) (middle a b) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_distance extend_distance_fp (middle a b) (middle a b)\n     (middle a b) =\n    0", "apply (subst extend_distance_fp[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_distance_fp (middle a b) (middle a b) (middle a b) = 0", "using assms"], ["proof (prove)\nusing this:\n  middle a b \\<in> extended_distance_set\n\ngoal (1 subgoal):\n 1. extend_distance_fp (middle a b) (middle a b) (middle a b) = 0", "unfolding extended_distance_set_def extended_distance_def"], ["proof (prove)\nusing this:\n  middle a b\n  \\<in> {z. extend_distance_fp (max2 Bonk_Schramm_extension_unfolded_wo z z)\n             z z =\n            0}\n\ngoal (1 subgoal):\n 1. extend_distance_fp (middle a b) (middle a b) (middle a b) = 0", "by simp"], ["proof (state)\nthis:\n  extend_distance extend_distance_fp (middle a b) (middle a b)\n   (middle a b) =\n  0\n\ngoal (2 subgoals):\n 1. a \\<in> extended_distance_set \\<inter>\n            underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n 2. b \\<in> extended_distance_set \\<inter>\n            underS Bonk_Schramm_extension_unfolded_wo (middle a b)", "then"], ["proof (chain)\npicking this:\n  extend_distance extend_distance_fp (middle a b) (middle a b)\n   (middle a b) =\n  0", "have \"a \\<in> extended_distance_set\" \"b \\<in> extended_distance_set\""], ["proof (prove)\nusing this:\n  extend_distance extend_distance_fp (middle a b) (middle a b)\n   (middle a b) =\n  0\n\ngoal (1 subgoal):\n 1. a \\<in> extended_distance_set &&& b \\<in> extended_distance_set", "unfolding extended_distance_set_def extended_distance_def"], ["proof (prove)\nusing this:\n  extend_distance extend_distance_fp (middle a b) (middle a b)\n   (middle a b) =\n  0\n\ngoal (1 subgoal):\n 1. a \\<in> {z. extend_distance_fp\n                 (max2 Bonk_Schramm_extension_unfolded_wo z z) z z =\n                0} &&&\n    b \\<in> {z. extend_distance_fp\n                 (max2 Bonk_Schramm_extension_unfolded_wo z z) z z =\n                0}", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. (if extend_distance_fp a a a = 0 \\<and> extend_distance_fp b b b = 0\n     then 0 else 1) =\n    0 \\<Longrightarrow>\n    extend_distance_fp a a a = 0\n 2. (if extend_distance_fp a a a = 0 \\<and> extend_distance_fp b b b = 0\n     then 0 else 1) =\n    0 \\<Longrightarrow>\n    extend_distance_fp b b b = 0", "by (metis zero_neq_one)+"], ["proof (state)\nthis:\n  a \\<in> extended_distance_set\n  b \\<in> extended_distance_set\n\ngoal (2 subgoals):\n 1. a \\<in> extended_distance_set \\<inter>\n            underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n 2. b \\<in> extended_distance_set \\<inter>\n            underS Bonk_Schramm_extension_unfolded_wo (middle a b)", "moreover"], ["proof (state)\nthis:\n  a \\<in> extended_distance_set\n  b \\<in> extended_distance_set\n\ngoal (2 subgoals):\n 1. a \\<in> extended_distance_set \\<inter>\n            underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n 2. b \\<in> extended_distance_set \\<inter>\n            underS Bonk_Schramm_extension_unfolded_wo (middle a b)", "have \"a \\<in> wo.underS (middle a b)\" \"b \\<in> wo.underS (middle a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b) &&&\n    b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b)", "by (auto simp add: Bonk_Schramm_extension_unfolded_wo_props')"], ["proof (state)\nthis:\n  a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n  b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n\ngoal (2 subgoals):\n 1. a \\<in> extended_distance_set \\<inter>\n            underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n 2. b \\<in> extended_distance_set \\<inter>\n            underS Bonk_Schramm_extension_unfolded_wo (middle a b)", "ultimately"], ["proof (chain)\npicking this:\n  a \\<in> extended_distance_set\n  b \\<in> extended_distance_set\n  a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n  b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b)", "show \"a \\<in> extended_distance_set \\<inter> wo.underS (middle a b)\"\n                  \"b \\<in> extended_distance_set \\<inter> wo.underS (middle a b)\""], ["proof (prove)\nusing this:\n  a \\<in> extended_distance_set\n  b \\<in> extended_distance_set\n  a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n  b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n\ngoal (1 subgoal):\n 1. a \\<in> extended_distance_set \\<inter>\n            underS Bonk_Schramm_extension_unfolded_wo (middle a b) &&&\n    b \\<in> extended_distance_set \\<inter>\n            underS Bonk_Schramm_extension_unfolded_wo (middle a b)", "by auto"], ["proof (state)\nthis:\n  a \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n  b \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extended_distance_middle_formula:\n  assumes \"x \\<in> wo.underS (middle a b)\"\n  shows \"extended_distance x (middle a b) = (extended_distance a b)/2\n    + (SUP w\\<in>wo.underS (middle a b) \\<inter> extended_distance_set.\n          extended_distance x w - max (extended_distance a w) (extended_distance b w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance x (middle a b) =\n    extended_distance a b / 2 +\n    (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set.\n        extended_distance x w -\n        max (extended_distance a w) (extended_distance b w))", "unfolding extended_distance_set_def extended_distance_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_distance_fp\n     (max2 Bonk_Schramm_extension_unfolded_wo x (middle a b)) x\n     (middle a b) =\n    extend_distance_fp (max2 Bonk_Schramm_extension_unfolded_wo a b) a b /\n    2 +\n    (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               {z. extend_distance_fp\n                    (max2 Bonk_Schramm_extension_unfolded_wo z z) z z =\n                   0}.\n        extend_distance_fp (max2 Bonk_Schramm_extension_unfolded_wo x w) x\n         w -\n        max (extend_distance_fp\n              (max2 Bonk_Schramm_extension_unfolded_wo a w) a w)\n         (extend_distance_fp (max2 Bonk_Schramm_extension_unfolded_wo b w) b\n           w))", "apply (subst extend_distance_fp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_distance extend_distance_fp\n     (max2 Bonk_Schramm_extension_unfolded_wo x (middle a b)) x\n     (middle a b) =\n    extend_distance_fp (max2 Bonk_Schramm_extension_unfolded_wo a b) a b /\n    2 +\n    (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               {z. extend_distance_fp\n                    (max2 Bonk_Schramm_extension_unfolded_wo z z) z z =\n                   0}.\n        extend_distance_fp (max2 Bonk_Schramm_extension_unfolded_wo x w) x\n         w -\n        max (extend_distance_fp\n              (max2 Bonk_Schramm_extension_unfolded_wo a w) a w)\n         (extend_distance_fp (max2 Bonk_Schramm_extension_unfolded_wo b w) b\n           w))", "apply (simp add: assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP w\\<in>{z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (middle a b).\n                extend_distance_fp z z z = 0}.\n        extend_distance_fp (max2 Bonk_Schramm_extension_unfolded_wo x w) x\n         w -\n        max (extend_distance_fp\n              (max2 Bonk_Schramm_extension_unfolded_wo a w) a w)\n         (extend_distance_fp (max2 Bonk_Schramm_extension_unfolded_wo b w) b\n           w)) =\n    (SUP xa\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                 (middle a b) \\<inter>\n                {z. extend_distance_fp z z z = 0}.\n        extend_distance_fp (max2 Bonk_Schramm_extension_unfolded_wo x xa) x\n         xa -\n        max (extend_distance_fp\n              (max2 Bonk_Schramm_extension_unfolded_wo a xa) a xa)\n         (extend_distance_fp (max2 Bonk_Schramm_extension_unfolded_wo b xa)\n           b xa))", "apply (rule SUP_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {z \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b).\n     extend_distance_fp z z z = 0} =\n    underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n    {z. extend_distance_fp z z z = 0}\n 2. \\<And>xa.\n       xa \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                 (middle a b) \\<inter>\n                {z. extend_distance_fp z z z = 0} \\<Longrightarrow>\n       extend_distance_fp (max2 Bonk_Schramm_extension_unfolded_wo x xa) x\n        xa -\n       max (extend_distance_fp\n             (max2 Bonk_Schramm_extension_unfolded_wo a xa) a xa)\n        (extend_distance_fp (max2 Bonk_Schramm_extension_unfolded_wo b xa) b\n          xa) =\n       extend_distance_fp (max2 Bonk_Schramm_extension_unfolded_wo x xa) x\n        xa -\n       max (extend_distance_fp\n             (max2 Bonk_Schramm_extension_unfolded_wo a xa) a xa)\n        (extend_distance_fp (max2 Bonk_Schramm_extension_unfolded_wo b xa) b\n          xa)", "apply (auto simp add: wo.max2_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma extended_distance_set_Cauchy:\n  assumes \"(would_be_Cauchy u) \\<in> extended_distance_set\"\n  shows \"u n \\<in> extended_distance_set \\<inter> wo.underS (would_be_Cauchy u)\"\n        \"\\<forall>eps > (0::real). \\<exists>N. \\<forall>n \\<ge> N. \\<forall>m \\<ge> N. extended_distance (u n) (u m) < eps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u n\n    \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u) &&&\n    \\<forall>eps>0.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. extended_distance (u n) (u m) < eps", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. u n\n    \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n 2. \\<forall>eps>0.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. extended_distance (u n) (u m) < eps", "have *: \"extend_distance (extend_distance_fp) (would_be_Cauchy u) (would_be_Cauchy u) (would_be_Cauchy u) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_distance extend_distance_fp (would_be_Cauchy u)\n     (would_be_Cauchy u) (would_be_Cauchy u) =\n    0", "apply (subst extend_distance_fp[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_distance_fp (would_be_Cauchy u) (would_be_Cauchy u)\n     (would_be_Cauchy u) =\n    0", "using assms"], ["proof (prove)\nusing this:\n  would_be_Cauchy u \\<in> extended_distance_set\n\ngoal (1 subgoal):\n 1. extend_distance_fp (would_be_Cauchy u) (would_be_Cauchy u)\n     (would_be_Cauchy u) =\n    0", "unfolding extended_distance_set_def extended_distance_def"], ["proof (prove)\nusing this:\n  would_be_Cauchy u\n  \\<in> {z. extend_distance_fp (max2 Bonk_Schramm_extension_unfolded_wo z z)\n             z z =\n            0}\n\ngoal (1 subgoal):\n 1. extend_distance_fp (would_be_Cauchy u) (would_be_Cauchy u)\n     (would_be_Cauchy u) =\n    0", "by simp"], ["proof (state)\nthis:\n  extend_distance extend_distance_fp (would_be_Cauchy u) (would_be_Cauchy u)\n   (would_be_Cauchy u) =\n  0\n\ngoal (2 subgoals):\n 1. u n\n    \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n 2. \\<forall>eps>0.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. extended_distance (u n) (u m) < eps", "then"], ["proof (chain)\npicking this:\n  extend_distance extend_distance_fp (would_be_Cauchy u) (would_be_Cauchy u)\n   (would_be_Cauchy u) =\n  0", "have \"u n \\<in> extended_distance_set\""], ["proof (prove)\nusing this:\n  extend_distance extend_distance_fp (would_be_Cauchy u) (would_be_Cauchy u)\n   (would_be_Cauchy u) =\n  0\n\ngoal (1 subgoal):\n 1. u n \\<in> extended_distance_set", "unfolding extended_distance_set_def extended_distance_def"], ["proof (prove)\nusing this:\n  extend_distance extend_distance_fp (would_be_Cauchy u) (would_be_Cauchy u)\n   (would_be_Cauchy u) =\n  0\n\ngoal (1 subgoal):\n 1. u n\n    \\<in> {z. extend_distance_fp\n               (max2 Bonk_Schramm_extension_unfolded_wo z z) z z =\n              0}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<exists>eps>0.\n           \\<forall>N.\n              \\<exists>n\\<ge>N.\n                 \\<exists>m\\<ge>N.\n                    \\<not> extend_distance_fp\n                            (max2 Bonk_Schramm_extension_unfolded_wo (u n)\n                              (u m))\n                            (u n) (u m)\n                           < eps\n     then 1\n     else if would_be_Cauchy u\n             \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    (would_be_Cauchy u) \\<and>\n             would_be_Cauchy u = would_be_Cauchy u\n          then lim (\\<lambda>n.\n                       extend_distance_fp\n                        (max2 Bonk_Schramm_extension_unfolded_wo (u n)\n                          (would_be_Cauchy u))\n                        (u n) (would_be_Cauchy u))\n          else if would_be_Cauchy u = would_be_Cauchy u \\<and>\n                  would_be_Cauchy u\n                  \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (would_be_Cauchy u)\n               then lim (\\<lambda>n.\n                            extend_distance_fp\n                             (max2 Bonk_Schramm_extension_unfolded_wo (u n)\n                               (would_be_Cauchy u))\n                             (u n) (would_be_Cauchy u))\n               else if would_be_Cauchy u = would_be_Cauchy u \\<and>\n                       would_be_Cauchy u = would_be_Cauchy u \\<and>\n                       (\\<forall>n.\n                           extend_distance_fp (u n) (u n) (u n) = 0)\n                    then 0 else 1) =\n    0 \\<Longrightarrow>\n    extend_distance_fp (u n) (u n) (u n) = 0", "by (metis (no_types, hide_lams) underS_notIn zero_neq_one)"], ["proof (state)\nthis:\n  u n \\<in> extended_distance_set\n\ngoal (2 subgoals):\n 1. u n\n    \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n 2. \\<forall>eps>0.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. extended_distance (u n) (u m) < eps", "moreover"], ["proof (state)\nthis:\n  u n \\<in> extended_distance_set\n\ngoal (2 subgoals):\n 1. u n\n    \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n 2. \\<forall>eps>0.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. extended_distance (u n) (u m) < eps", "have \"u n \\<in> wo.underS (would_be_Cauchy u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u n \\<in> underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)", "by (auto simp add: Bonk_Schramm_extension_unfolded_wo_props')"], ["proof (state)\nthis:\n  u n \\<in> underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n\ngoal (2 subgoals):\n 1. u n\n    \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n 2. \\<forall>eps>0.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. extended_distance (u n) (u m) < eps", "ultimately"], ["proof (chain)\npicking this:\n  u n \\<in> extended_distance_set\n  u n \\<in> underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)", "show \"u n \\<in> extended_distance_set \\<inter> wo.underS (would_be_Cauchy u)\""], ["proof (prove)\nusing this:\n  u n \\<in> extended_distance_set\n  u n \\<in> underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n\ngoal (1 subgoal):\n 1. u n\n    \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)", "by auto"], ["proof (state)\nthis:\n  u n\n  \\<in> extended_distance_set \\<inter>\n        underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n\ngoal (1 subgoal):\n 1. \\<forall>eps>0.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. extended_distance (u n) (u m) < eps", "show \"\\<forall>eps > (0::real). \\<exists>N. \\<forall>n \\<ge> N. \\<forall>m \\<ge> N. extended_distance (u n) (u m) < eps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>eps>0.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. extended_distance (u n) (u m) < eps", "using *"], ["proof (prove)\nusing this:\n  extend_distance extend_distance_fp (would_be_Cauchy u) (would_be_Cauchy u)\n   (would_be_Cauchy u) =\n  0\n\ngoal (1 subgoal):\n 1. \\<forall>eps>0.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. extended_distance (u n) (u m) < eps", "unfolding extended_distance_set_def extended_distance_def"], ["proof (prove)\nusing this:\n  extend_distance extend_distance_fp (would_be_Cauchy u) (would_be_Cauchy u)\n   (would_be_Cauchy u) =\n  0\n\ngoal (1 subgoal):\n 1. \\<forall>eps>0.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                extend_distance_fp\n                 (max2 Bonk_Schramm_extension_unfolded_wo (u n) (u m)) (u n)\n                 (u m)\n                < eps", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>eps.\n       \\<lbrakk>(if \\<exists>eps>0.\n                       \\<forall>N.\n                          \\<exists>n\\<ge>N.\n                             \\<exists>m\\<ge>N.\n                                \\<not> extend_distance_fp\n  (max2 Bonk_Schramm_extension_unfolded_wo (u n) (u m)) (u n) (u m)\n < eps\n                 then 1\n                 else if would_be_Cauchy u\n                         \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                                (would_be_Cauchy u) \\<and>\n                         would_be_Cauchy u = would_be_Cauchy u\n                      then lim (\\<lambda>n.\n                                   extend_distance_fp\n                                    (max2 Bonk_Schramm_extension_unfolded_wo\n(u n) (would_be_Cauchy u))\n                                    (u n) (would_be_Cauchy u))\n                      else if would_be_Cauchy u = would_be_Cauchy u \\<and>\n                              would_be_Cauchy u\n                              \\<in> underS\n                                     Bonk_Schramm_extension_unfolded_wo\n                                     (would_be_Cauchy u)\n                           then lim (\\<lambda>n.\n  extend_distance_fp\n   (max2 Bonk_Schramm_extension_unfolded_wo (u n) (would_be_Cauchy u)) (u n)\n   (would_be_Cauchy u))\n                           else if would_be_Cauchy u =\n                                   would_be_Cauchy u \\<and>\n                                   would_be_Cauchy u =\n                                   would_be_Cauchy u \\<and>\n                                   (\\<forall>n.\n extend_distance_fp (u n) (u n) (u n) = 0)\n                                then 0 else 1) =\n                0;\n        0 < eps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N.\n                            \\<forall>n\\<ge>N.\n                               \\<forall>m\\<ge>N.\n                                  extend_distance_fp\n                                   (max2 Bonk_Schramm_extension_unfolded_wo\n                                     (u n) (u m))\n                                   (u n) (u m)\n                                  < eps", "by (metis (no_types, hide_lams) zero_neq_one)"], ["proof (state)\nthis:\n  \\<forall>eps>0.\n     \\<exists>N.\n        \\<forall>n\\<ge>N.\n           \\<forall>m\\<ge>N. extended_distance (u n) (u m) < eps\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extended_distance_triang_ineq:\n  assumes \"x \\<in> extended_distance_set\"\n          \"y \\<in> extended_distance_set\"\n          \"z \\<in> extended_distance_set\"\n  shows \"extended_distance x z \\<le> extended_distance x y + extended_distance y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x y + extended_distance y z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x y + extended_distance y z", "(* The proof of the triangular inequality is done by induction: one should show that adding\n  a middle or a Cauchy sequence does not spoil the estimates. Technically, we show that the\n  triangular inequality holds on all points under $t$, for all $t$, using a transfinite induction.\n  The conclusion of the lemma then follows by using for $t$ the maximum of $x$, $y$, $z$.*)"], ["proof (state)\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x y + extended_distance y z", "have ineq_rec: \"\\<forall>x y z. x \\<in> wo.under t \\<inter> extended_distance_set \\<longrightarrow> y \\<in> wo.under t \\<inter> extended_distance_set \\<longrightarrow> z \\<in> wo.under t \\<inter> extended_distance_set\n      \\<longrightarrow> extended_distance x z \\<le> extended_distance x y + extended_distance y z\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x y + extended_distance y z", "proof (rule wo.well_order_induct[of _ t])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          y \\<noteq> x \\<and>\n          (y, x) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n          (\\<forall>x ya z.\n              x \\<in> under Bonk_Schramm_extension_unfolded_wo y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              ya \\<in> under Bonk_Schramm_extension_unfolded_wo y \\<inter>\n                       extended_distance_set \\<longrightarrow>\n              z \\<in> under Bonk_Schramm_extension_unfolded_wo y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              extended_distance x z\n              \\<le> extended_distance x ya +\n                    extended_distance ya z) \\<Longrightarrow>\n       \\<forall>xa y z.\n          xa \\<in> under Bonk_Schramm_extension_unfolded_wo x \\<inter>\n                   extended_distance_set \\<longrightarrow>\n          y \\<in> under Bonk_Schramm_extension_unfolded_wo x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          z \\<in> under Bonk_Schramm_extension_unfolded_wo x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          extended_distance xa z\n          \\<le> extended_distance xa y + extended_distance y z", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          y \\<noteq> x \\<and>\n          (y, x) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n          (\\<forall>x ya z.\n              x \\<in> under Bonk_Schramm_extension_unfolded_wo y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              ya \\<in> under Bonk_Schramm_extension_unfolded_wo y \\<inter>\n                       extended_distance_set \\<longrightarrow>\n              z \\<in> under Bonk_Schramm_extension_unfolded_wo y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              extended_distance x z\n              \\<le> extended_distance x ya +\n                    extended_distance ya z) \\<Longrightarrow>\n       \\<forall>xa y z.\n          xa \\<in> under Bonk_Schramm_extension_unfolded_wo x \\<inter>\n                   extended_distance_set \\<longrightarrow>\n          y \\<in> under Bonk_Schramm_extension_unfolded_wo x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          z \\<in> under Bonk_Schramm_extension_unfolded_wo x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          extended_distance xa z\n          \\<le> extended_distance xa y + extended_distance y z", "assume IH_orig: \"\\<forall>t2. t2 \\<noteq> t \\<and> (t2, t) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n               (\\<forall>x y z. x \\<in> wo.under t2 \\<inter> extended_distance_set \\<longrightarrow>\n                        y \\<in> wo.under t2 \\<inter> extended_distance_set \\<longrightarrow>\n                        z \\<in> wo.under t2 \\<inter> extended_distance_set \\<longrightarrow>\n                        extended_distance x z \\<le> extended_distance x y + extended_distance y z)\""], ["proof (state)\nthis:\n  \\<forall>t2.\n     t2 \\<noteq> t \\<and>\n     (t2, t) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n     (\\<forall>x y z.\n         x \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                 extended_distance_set \\<longrightarrow>\n         y \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                 extended_distance_set \\<longrightarrow>\n         z \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                 extended_distance_set \\<longrightarrow>\n         extended_distance x z\n         \\<le> extended_distance x y + extended_distance y z)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          y \\<noteq> x \\<and>\n          (y, x) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n          (\\<forall>x ya z.\n              x \\<in> under Bonk_Schramm_extension_unfolded_wo y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              ya \\<in> under Bonk_Schramm_extension_unfolded_wo y \\<inter>\n                       extended_distance_set \\<longrightarrow>\n              z \\<in> under Bonk_Schramm_extension_unfolded_wo y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              extended_distance x z\n              \\<le> extended_distance x ya +\n                    extended_distance ya z) \\<Longrightarrow>\n       \\<forall>xa y z.\n          xa \\<in> under Bonk_Schramm_extension_unfolded_wo x \\<inter>\n                   extended_distance_set \\<longrightarrow>\n          y \\<in> under Bonk_Schramm_extension_unfolded_wo x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          z \\<in> under Bonk_Schramm_extension_unfolded_wo x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          extended_distance xa z\n          \\<le> extended_distance xa y + extended_distance y z", "(*Reformulate the induction assumption in more convenient terms*)"], ["proof (state)\nthis:\n  \\<forall>t2.\n     t2 \\<noteq> t \\<and>\n     (t2, t) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n     (\\<forall>x y z.\n         x \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                 extended_distance_set \\<longrightarrow>\n         y \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                 extended_distance_set \\<longrightarrow>\n         z \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                 extended_distance_set \\<longrightarrow>\n         extended_distance x z\n         \\<le> extended_distance x y + extended_distance y z)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          y \\<noteq> x \\<and>\n          (y, x) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n          (\\<forall>x ya z.\n              x \\<in> under Bonk_Schramm_extension_unfolded_wo y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              ya \\<in> under Bonk_Schramm_extension_unfolded_wo y \\<inter>\n                       extended_distance_set \\<longrightarrow>\n              z \\<in> under Bonk_Schramm_extension_unfolded_wo y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              extended_distance x z\n              \\<le> extended_distance x ya +\n                    extended_distance ya z) \\<Longrightarrow>\n       \\<forall>xa y z.\n          xa \\<in> under Bonk_Schramm_extension_unfolded_wo x \\<inter>\n                   extended_distance_set \\<longrightarrow>\n          y \\<in> under Bonk_Schramm_extension_unfolded_wo x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          z \\<in> under Bonk_Schramm_extension_unfolded_wo x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          extended_distance xa z\n          \\<le> extended_distance xa y + extended_distance y z", "then"], ["proof (chain)\npicking this:\n  \\<forall>t2.\n     t2 \\<noteq> t \\<and>\n     (t2, t) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n     (\\<forall>x y z.\n         x \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                 extended_distance_set \\<longrightarrow>\n         y \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                 extended_distance_set \\<longrightarrow>\n         z \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                 extended_distance_set \\<longrightarrow>\n         extended_distance x z\n         \\<le> extended_distance x y + extended_distance y z)", "have IH: \"extended_distance x z \\<le> extended_distance x y + extended_distance y z\"\n      if \"x \\<in> wo.underS t \\<inter> extended_distance_set\"\n         \"y \\<in> wo.underS t \\<inter> extended_distance_set\"\n         \"z \\<in> wo.underS t \\<inter> extended_distance_set\"\n      for x y z"], ["proof (prove)\nusing this:\n  \\<forall>t2.\n     t2 \\<noteq> t \\<and>\n     (t2, t) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n     (\\<forall>x y z.\n         x \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                 extended_distance_set \\<longrightarrow>\n         y \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                 extended_distance_set \\<longrightarrow>\n         z \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                 extended_distance_set \\<longrightarrow>\n         extended_distance x z\n         \\<le> extended_distance x y + extended_distance y z)\n\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x y + extended_distance y z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>t2.\n       t2 \\<noteq> t \\<and>\n       (t2, t) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n       (\\<forall>x y z.\n           x \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           y \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           z \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           extended_distance x z\n           \\<le> extended_distance x y +\n                 extended_distance y z) \\<Longrightarrow>\n    extended_distance x z\n    \\<le> extended_distance x y + extended_distance y z", "define t2 where \"t2 = wo.max2 (wo.max2 x y) z\""], ["proof (state)\nthis:\n  t2 =\n  max2 Bonk_Schramm_extension_unfolded_wo\n   (max2 Bonk_Schramm_extension_unfolded_wo x y) z\n\ngoal (1 subgoal):\n 1. \\<forall>t2.\n       t2 \\<noteq> t \\<and>\n       (t2, t) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n       (\\<forall>x y z.\n           x \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           y \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           z \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           extended_distance x z\n           \\<le> extended_distance x y +\n                 extended_distance y z) \\<Longrightarrow>\n    extended_distance x z\n    \\<le> extended_distance x y + extended_distance y z", "have \"t2 \\<in> wo.underS t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t2 \\<in> underS Bonk_Schramm_extension_unfolded_wo t", "using that t2_def"], ["proof (prove)\nusing this:\n  x \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  y \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  z \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  t2 =\n  max2 Bonk_Schramm_extension_unfolded_wo\n   (max2 Bonk_Schramm_extension_unfolded_wo x y) z\n\ngoal (1 subgoal):\n 1. t2 \\<in> underS Bonk_Schramm_extension_unfolded_wo t", "by auto"], ["proof (state)\nthis:\n  t2 \\<in> underS Bonk_Schramm_extension_unfolded_wo t\n\ngoal (1 subgoal):\n 1. \\<forall>t2.\n       t2 \\<noteq> t \\<and>\n       (t2, t) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n       (\\<forall>x y z.\n           x \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           y \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           z \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           extended_distance x z\n           \\<le> extended_distance x y +\n                 extended_distance y z) \\<Longrightarrow>\n    extended_distance x z\n    \\<le> extended_distance x y + extended_distance y z", "have \"x \\<in> wo.under t2\" \"y \\<in> wo.under t2\" \"z \\<in> wo.under t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> under Bonk_Schramm_extension_unfolded_wo t2 &&&\n    y \\<in> under Bonk_Schramm_extension_unfolded_wo t2 &&&\n    z \\<in> under Bonk_Schramm_extension_unfolded_wo t2", "unfolding t2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> under Bonk_Schramm_extension_unfolded_wo\n             (max2 Bonk_Schramm_extension_unfolded_wo\n               (max2 Bonk_Schramm_extension_unfolded_wo x y) z) &&&\n    y \\<in> under Bonk_Schramm_extension_unfolded_wo\n             (max2 Bonk_Schramm_extension_unfolded_wo\n               (max2 Bonk_Schramm_extension_unfolded_wo x y) z) &&&\n    z \\<in> under Bonk_Schramm_extension_unfolded_wo\n             (max2 Bonk_Schramm_extension_unfolded_wo\n               (max2 Bonk_Schramm_extension_unfolded_wo x y) z)", "by (metis UNIV_I Bonk_Schramm_extension_unfolded_wo_props(1) mem_Collect_eq under_def well_order_on_Well_order wo.TOTALS wo.max2_iff)+"], ["proof (state)\nthis:\n  x \\<in> under Bonk_Schramm_extension_unfolded_wo t2\n  y \\<in> under Bonk_Schramm_extension_unfolded_wo t2\n  z \\<in> under Bonk_Schramm_extension_unfolded_wo t2\n\ngoal (1 subgoal):\n 1. \\<forall>t2.\n       t2 \\<noteq> t \\<and>\n       (t2, t) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n       (\\<forall>x y z.\n           x \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           y \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           z \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           extended_distance x z\n           \\<le> extended_distance x y +\n                 extended_distance y z) \\<Longrightarrow>\n    extended_distance x z\n    \\<le> extended_distance x y + extended_distance y z", "then"], ["proof (chain)\npicking this:\n  x \\<in> under Bonk_Schramm_extension_unfolded_wo t2\n  y \\<in> under Bonk_Schramm_extension_unfolded_wo t2\n  z \\<in> under Bonk_Schramm_extension_unfolded_wo t2", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> under Bonk_Schramm_extension_unfolded_wo t2\n  y \\<in> under Bonk_Schramm_extension_unfolded_wo t2\n  z \\<in> under Bonk_Schramm_extension_unfolded_wo t2\n\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x y + extended_distance y z", "using that IH_orig \\<open>t2 \\<in> wo.underS t\\<close> underS_E"], ["proof (prove)\nusing this:\n  x \\<in> under Bonk_Schramm_extension_unfolded_wo t2\n  y \\<in> under Bonk_Schramm_extension_unfolded_wo t2\n  z \\<in> under Bonk_Schramm_extension_unfolded_wo t2\n  x \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  y \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  z \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  \\<forall>t2.\n     t2 \\<noteq> t \\<and>\n     (t2, t) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n     (\\<forall>x y z.\n         x \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                 extended_distance_set \\<longrightarrow>\n         y \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                 extended_distance_set \\<longrightarrow>\n         z \\<in> under Bonk_Schramm_extension_unfolded_wo t2 \\<inter>\n                 extended_distance_set \\<longrightarrow>\n         extended_distance x z\n         \\<le> extended_distance x y + extended_distance y z)\n  t2 \\<in> underS Bonk_Schramm_extension_unfolded_wo t\n  ?i \\<in> underS ?R ?j \\<Longrightarrow>\n  ?i \\<noteq> ?j \\<and> (?i, ?j) \\<in> ?R\n\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x y + extended_distance y z", "by fastforce"], ["proof (state)\nthis:\n  extended_distance x z \\<le> extended_distance x y + extended_distance y z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?y1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set;\n   ?z1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x1 ?z1\n                    \\<le> extended_distance ?x1 ?y1 +\n                          extended_distance ?y1 ?z1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          y \\<noteq> x \\<and>\n          (y, x) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n          (\\<forall>x ya z.\n              x \\<in> under Bonk_Schramm_extension_unfolded_wo y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              ya \\<in> under Bonk_Schramm_extension_unfolded_wo y \\<inter>\n                       extended_distance_set \\<longrightarrow>\n              z \\<in> under Bonk_Schramm_extension_unfolded_wo y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              extended_distance x z\n              \\<le> extended_distance x ya +\n                    extended_distance ya z) \\<Longrightarrow>\n       \\<forall>xa y z.\n          xa \\<in> under Bonk_Schramm_extension_unfolded_wo x \\<inter>\n                   extended_distance_set \\<longrightarrow>\n          y \\<in> under Bonk_Schramm_extension_unfolded_wo x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          z \\<in> under Bonk_Schramm_extension_unfolded_wo x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          extended_distance xa z\n          \\<le> extended_distance xa y + extended_distance y z", "have pos: \"extended_distance x y \\<ge> 0\" if \"x \\<in> wo.underS t \\<inter> extended_distance_set\" \"y \\<in> wo.underS t \\<inter> extended_distance_set\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> extended_distance x y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> extended_distance x y", "have \"0 = extended_distance x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = extended_distance x x", "using that(1) extended_distance_set_def"], ["proof (prove)\nusing this:\n  x \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  extended_distance_set = {z. extended_distance z z = 0}\n\ngoal (1 subgoal):\n 1. 0 = extended_distance x x", "by auto"], ["proof (state)\nthis:\n  0 = extended_distance x x\n\ngoal (1 subgoal):\n 1. 0 \\<le> extended_distance x y", "also"], ["proof (state)\nthis:\n  0 = extended_distance x x\n\ngoal (1 subgoal):\n 1. 0 \\<le> extended_distance x y", "have \"... \\<le> extended_distance x y + extended_distance y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance x x\n    \\<le> extended_distance x y + extended_distance y x", "using IH that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?y1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set;\n   ?z1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x1 ?z1\n                    \\<le> extended_distance ?x1 ?y1 +\n                          extended_distance ?y1 ?z1\n  x \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  y \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n\ngoal (1 subgoal):\n 1. extended_distance x x\n    \\<le> extended_distance x y + extended_distance y x", "by auto"], ["proof (state)\nthis:\n  extended_distance x x \\<le> extended_distance x y + extended_distance y x\n\ngoal (1 subgoal):\n 1. 0 \\<le> extended_distance x y", "also"], ["proof (state)\nthis:\n  extended_distance x x \\<le> extended_distance x y + extended_distance y x\n\ngoal (1 subgoal):\n 1. 0 \\<le> extended_distance x y", "have \"... = 2 * extended_distance x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance x y + extended_distance y x =\n    2 * extended_distance x y", "using extended_distance_symmetric"], ["proof (prove)\nusing this:\n  extended_distance ?x ?y = extended_distance ?y ?x\n\ngoal (1 subgoal):\n 1. extended_distance x y + extended_distance y x =\n    2 * extended_distance x y", "by auto"], ["proof (state)\nthis:\n  extended_distance x y + extended_distance y x = 2 * extended_distance x y\n\ngoal (1 subgoal):\n 1. 0 \\<le> extended_distance x y", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> 2 * extended_distance x y", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> 2 * extended_distance x y\n\ngoal (1 subgoal):\n 1. 0 \\<le> extended_distance x y", "by auto"], ["proof (state)\nthis:\n  0 \\<le> extended_distance x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?y1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> extended_distance ?x1 ?y1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          y \\<noteq> x \\<and>\n          (y, x) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n          (\\<forall>x ya z.\n              x \\<in> under Bonk_Schramm_extension_unfolded_wo y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              ya \\<in> under Bonk_Schramm_extension_unfolded_wo y \\<inter>\n                       extended_distance_set \\<longrightarrow>\n              z \\<in> under Bonk_Schramm_extension_unfolded_wo y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              extended_distance x z\n              \\<le> extended_distance x ya +\n                    extended_distance ya z) \\<Longrightarrow>\n       \\<forall>xa y z.\n          xa \\<in> under Bonk_Schramm_extension_unfolded_wo x \\<inter>\n                   extended_distance_set \\<longrightarrow>\n          y \\<in> under Bonk_Schramm_extension_unfolded_wo x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          z \\<in> under Bonk_Schramm_extension_unfolded_wo x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          extended_distance xa z\n          \\<le> extended_distance xa y + extended_distance y z", "(* The conclusion is easy if $t$ is not in \\verb+extended_distance_set+, as there is no\n    additional point to consider for the triangular inequality. The interesting case is when\n    $t$ is admissible, then we will argue differently depending on its type.*)"], ["proof (state)\nthis:\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?y1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> extended_distance ?x1 ?y1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          y \\<noteq> x \\<and>\n          (y, x) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n          (\\<forall>x ya z.\n              x \\<in> under Bonk_Schramm_extension_unfolded_wo y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              ya \\<in> under Bonk_Schramm_extension_unfolded_wo y \\<inter>\n                       extended_distance_set \\<longrightarrow>\n              z \\<in> under Bonk_Schramm_extension_unfolded_wo y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              extended_distance x z\n              \\<le> extended_distance x ya +\n                    extended_distance ya z) \\<Longrightarrow>\n       \\<forall>xa y z.\n          xa \\<in> under Bonk_Schramm_extension_unfolded_wo x \\<inter>\n                   extended_distance_set \\<longrightarrow>\n          y \\<in> under Bonk_Schramm_extension_unfolded_wo x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          z \\<in> under Bonk_Schramm_extension_unfolded_wo x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          extended_distance xa z\n          \\<le> extended_distance xa y + extended_distance y z", "consider \"t \\<notin> extended_distance_set\" | \"t \\<in> extended_distance_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<notin> extended_distance_set \\<Longrightarrow> thesis;\n     t \\<in> extended_distance_set \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>t \\<notin> extended_distance_set \\<Longrightarrow> ?thesis1;\n   t \\<in> extended_distance_set \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          y \\<noteq> x \\<and>\n          (y, x) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n          (\\<forall>x ya z.\n              x \\<in> under Bonk_Schramm_extension_unfolded_wo y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              ya \\<in> under Bonk_Schramm_extension_unfolded_wo y \\<inter>\n                       extended_distance_set \\<longrightarrow>\n              z \\<in> under Bonk_Schramm_extension_unfolded_wo y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              extended_distance x z\n              \\<le> extended_distance x ya +\n                    extended_distance ya z) \\<Longrightarrow>\n       \\<forall>xa y z.\n          xa \\<in> under Bonk_Schramm_extension_unfolded_wo x \\<inter>\n                   extended_distance_set \\<longrightarrow>\n          y \\<in> under Bonk_Schramm_extension_unfolded_wo x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          z \\<in> under Bonk_Schramm_extension_unfolded_wo x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          extended_distance xa z\n          \\<le> extended_distance xa y + extended_distance y z", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>t \\<notin> extended_distance_set \\<Longrightarrow> ?thesis1;\n   t \\<in> extended_distance_set \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1", "show \"\\<forall>x y z. x \\<in> wo.under t \\<inter> extended_distance_set \\<longrightarrow>\n                  y \\<in> wo.under t \\<inter> extended_distance_set \\<longrightarrow>\n                  z \\<in> wo.under t \\<inter> extended_distance_set \\<longrightarrow>\n          extended_distance x z \\<le> extended_distance x y + extended_distance y z\""], ["proof (prove)\nusing this:\n  \\<lbrakk>t \\<notin> extended_distance_set \\<Longrightarrow> ?thesis1;\n   t \\<in> extended_distance_set \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x y + extended_distance y z", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<notin> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z.\n       x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x y + extended_distance y z\n 2. t \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z.\n       x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x y + extended_distance y z", "case 1"], ["proof (state)\nthis:\n  t \\<notin> extended_distance_set\n\ngoal (2 subgoals):\n 1. t \\<notin> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z.\n       x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x y + extended_distance y z\n 2. t \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z.\n       x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x y + extended_distance y z", "then"], ["proof (chain)\npicking this:\n  t \\<notin> extended_distance_set", "have \"wo.under t \\<inter> extended_distance_set = wo.underS t \\<inter> extended_distance_set\""], ["proof (prove)\nusing this:\n  t \\<notin> extended_distance_set\n\ngoal (1 subgoal):\n 1. under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n    extended_distance_set =\n    underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n    extended_distance_set", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>t \\<notin> extended_distance_set;\n        x \\<in> under Bonk_Schramm_extension_unfolded_wo t;\n        x \\<in> extended_distance_set\\<rbrakk>\n       \\<Longrightarrow> x \\<in> underS Bonk_Schramm_extension_unfolded_wo t\n 2. \\<And>x.\n       \\<lbrakk>t \\<notin> extended_distance_set;\n        x \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n        x \\<in> extended_distance_set\\<rbrakk>\n       \\<Longrightarrow> x \\<in> under Bonk_Schramm_extension_unfolded_wo t", "apply (metis mem_Collect_eq underS_I under_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>t \\<notin> extended_distance_set;\n        x \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n        x \\<in> extended_distance_set\\<rbrakk>\n       \\<Longrightarrow> x \\<in> under Bonk_Schramm_extension_unfolded_wo t", "by (simp add: underS_E under_def)"], ["proof (state)\nthis:\n  under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n  extended_distance_set =\n  underS Bonk_Schramm_extension_unfolded_wo t \\<inter> extended_distance_set\n\ngoal (2 subgoals):\n 1. t \\<notin> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z.\n       x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x y + extended_distance y z\n 2. t \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z.\n       x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x y + extended_distance y z", "then"], ["proof (chain)\npicking this:\n  under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n  extended_distance_set =\n  underS Bonk_Schramm_extension_unfolded_wo t \\<inter> extended_distance_set", "show ?thesis"], ["proof (prove)\nusing this:\n  under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n  extended_distance_set =\n  underS Bonk_Schramm_extension_unfolded_wo t \\<inter> extended_distance_set\n\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x y + extended_distance y z", "using IH"], ["proof (prove)\nusing this:\n  under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n  extended_distance_set =\n  underS Bonk_Schramm_extension_unfolded_wo t \\<inter> extended_distance_set\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?y1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set;\n   ?z1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x1 ?z1\n                    \\<le> extended_distance ?x1 ?y1 +\n                          extended_distance ?y1 ?z1\n\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x y + extended_distance y z", "by auto"], ["proof (state)\nthis:\n  \\<forall>x y z.\n     x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n             extended_distance_set \\<longrightarrow>\n     y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n             extended_distance_set \\<longrightarrow>\n     z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n             extended_distance_set \\<longrightarrow>\n     extended_distance x z\n     \\<le> extended_distance x y + extended_distance y z\n\ngoal (1 subgoal):\n 1. t \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z.\n       x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x y + extended_distance y z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z.\n       x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x y + extended_distance y z", "case 2"], ["proof (state)\nthis:\n  t \\<in> extended_distance_set\n\ngoal (1 subgoal):\n 1. t \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z.\n       x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x y + extended_distance y z", "(*We assume now that $t$ is admissible.\n      We will prove now the triangular inequality for points under t, in the two basic cases\n      where t is either the first point in the inequality, or the middle point.\n      All other cases can be reduced to this one by permuting the variables, or they are\n      trivial (if several variables are equal to t, for instance).*)"], ["proof (state)\nthis:\n  t \\<in> extended_distance_set\n\ngoal (1 subgoal):\n 1. t \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z.\n       x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x y + extended_distance y z", "have main_ineq: \"extended_distance x z \\<le> extended_distance x t + extended_distance t z\n                    \\<and> extended_distance x t \\<le> extended_distance x z + extended_distance z t\"\n        if \"x \\<in> wo.underS t \\<inter> extended_distance_set\"\n           \"z \\<in> wo.underS t \\<inter> extended_distance_set\"\n        for x z"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x t + extended_distance t z \\<and>\n    extended_distance x t\n    \\<le> extended_distance x z + extended_distance z t", "proof (cases t)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       t = basepoint x1 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 3. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "(*In the case of a basepoint, the distance comes from the original distance, hence\n        it satisfies the triangular inequality*)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       t = basepoint x1 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 3. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "case A: (basepoint t')"], ["proof (state)\nthis:\n  t = basepoint t'\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       t = basepoint x1 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 3. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "then"], ["proof (chain)\npicking this:\n  t = basepoint t'", "have \"x \\<in> range basepoint\""], ["proof (prove)\nusing this:\n  t = basepoint t'\n\ngoal (1 subgoal):\n 1. x \\<in> range basepoint", "using Bonk_Schramm_extension_unfolded_wo_props(2)"], ["proof (prove)\nusing this:\n  t = basepoint t'\n  \\<forall>x\\<in>range basepoint.\n     \\<forall>y\\<in>- range basepoint.\n        (x, y) \\<in> Bonk_Schramm_extension_unfolded_wo\n\ngoal (1 subgoal):\n 1. x \\<in> range basepoint", "by (metis that(1) Compl_iff Int_iff range_eqI wo.max2_def wo.max2_underS'(2))"], ["proof (state)\nthis:\n  x \\<in> range basepoint\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       t = basepoint x1 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 3. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "then"], ["proof (chain)\npicking this:\n  x \\<in> range basepoint", "obtain x' where x: \"x = basepoint x'\""], ["proof (prove)\nusing this:\n  x \\<in> range basepoint\n\ngoal (1 subgoal):\n 1. (\\<And>x'. x = basepoint x' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = basepoint x'\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       t = basepoint x1 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 3. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "have \"z \\<in> range basepoint\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> range basepoint", "using Bonk_Schramm_extension_unfolded_wo_props(2) A"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>range basepoint.\n     \\<forall>y\\<in>- range basepoint.\n        (x, y) \\<in> Bonk_Schramm_extension_unfolded_wo\n  t = basepoint t'\n\ngoal (1 subgoal):\n 1. z \\<in> range basepoint", "by (metis that(2) Compl_iff Int_iff range_eqI wo.max2_def wo.max2_underS'(2))"], ["proof (state)\nthis:\n  z \\<in> range basepoint\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       t = basepoint x1 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 3. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "then"], ["proof (chain)\npicking this:\n  z \\<in> range basepoint", "obtain z' where z: \"z = basepoint z'\""], ["proof (prove)\nusing this:\n  z \\<in> range basepoint\n\ngoal (1 subgoal):\n 1. (\\<And>z'. z = basepoint z' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z = basepoint z'\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       t = basepoint x1 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 3. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "show \"extended_distance x z \\<le> extended_distance x t + extended_distance t z\n            \\<and> extended_distance x t \\<le> extended_distance x z + extended_distance z t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x t + extended_distance t z \\<and>\n    extended_distance x t\n    \\<le> extended_distance x z + extended_distance z t", "unfolding x z A extended_distance_basepoint"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x' z' \\<le> dist x' t' + dist t' z' \\<and>\n    dist x' t' \\<le> dist x' z' + dist z' t'", "by (simp add: dist_triangle)"], ["proof (state)\nthis:\n  extended_distance x z\n  \\<le> extended_distance x t + extended_distance t z \\<and>\n  extended_distance x t \\<le> extended_distance x z + extended_distance z t\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "(*In the case of a middle, the triangular inequality follows from the specific formula\n        devised by Bonk and Schramm and (not very complicated) computations. The only mild difficulty\n        is that the formula is defined in terms of a supremum, so one should check that this\n        supremum is taken over a bounded set. This boundedness comes from the triangular inequality\n        for point strictly below $t$, i.e., our inductive assumption.*)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "case M: (middle a b)"], ["proof (state)\nthis:\n  t = middle a b\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "then"], ["proof (chain)\npicking this:\n  t = middle a b", "have ab: \"a \\<in> extended_distance_set \\<inter> wo.underS (middle a b)\"\n                      \"b \\<in> extended_distance_set \\<inter> wo.underS (middle a b)\""], ["proof (prove)\nusing this:\n  t = middle a b\n\ngoal (1 subgoal):\n 1. a \\<in> extended_distance_set \\<inter>\n            underS Bonk_Schramm_extension_unfolded_wo (middle a b) &&&\n    b \\<in> extended_distance_set \\<inter>\n            underS Bonk_Schramm_extension_unfolded_wo (middle a b)", "using 2 extended_distance_set_middle'[of a b]"], ["proof (prove)\nusing this:\n  t = middle a b\n  t \\<in> extended_distance_set\n  middle a b \\<in> extended_distance_set \\<Longrightarrow>\n  a \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n  middle a b \\<in> extended_distance_set \\<Longrightarrow>\n  b \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n\ngoal (1 subgoal):\n 1. a \\<in> extended_distance_set \\<inter>\n            underS Bonk_Schramm_extension_unfolded_wo (middle a b) &&&\n    b \\<in> extended_distance_set \\<inter>\n            underS Bonk_Schramm_extension_unfolded_wo (middle a b)", "by auto"], ["proof (state)\nthis:\n  a \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n  b \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "have dxt: \"extended_distance x t = (extended_distance a b)/2\n          + (SUP w\\<in>wo.underS (middle a b) \\<inter> extended_distance_set.\n              extended_distance x w - max (extended_distance a w) (extended_distance b w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance x t =\n    extended_distance a b / 2 +\n    (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set.\n        extended_distance x w -\n        max (extended_distance a w) (extended_distance b w))", "using that(1)"], ["proof (prove)\nusing this:\n  x \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n\ngoal (1 subgoal):\n 1. extended_distance x t =\n    extended_distance a b / 2 +\n    (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set.\n        extended_distance x w -\n        max (extended_distance a w) (extended_distance b w))", "unfolding M"], ["proof (prove)\nusing this:\n  x \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n          extended_distance_set\n\ngoal (1 subgoal):\n 1. extended_distance x (middle a b) =\n    extended_distance a b / 2 +\n    (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set.\n        extended_distance x w -\n        max (extended_distance a w) (extended_distance b w))", "using extended_distance_middle_formula"], ["proof (prove)\nusing this:\n  x \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n          extended_distance_set\n  ?x \\<in> underS Bonk_Schramm_extension_unfolded_wo\n            (middle ?a ?b) \\<Longrightarrow>\n  extended_distance ?x (middle ?a ?b) =\n  extended_distance ?a ?b / 2 +\n  (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n              (middle ?a ?b) \\<inter>\n             extended_distance_set.\n      extended_distance ?x w -\n      max (extended_distance ?a w) (extended_distance ?b w))\n\ngoal (1 subgoal):\n 1. extended_distance x (middle a b) =\n    extended_distance a b / 2 +\n    (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set.\n        extended_distance x w -\n        max (extended_distance a w) (extended_distance b w))", "by auto"], ["proof (state)\nthis:\n  extended_distance x t =\n  extended_distance a b / 2 +\n  (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n             extended_distance_set.\n      extended_distance x w -\n      max (extended_distance a w) (extended_distance b w))\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "have dzt: \"extended_distance z t = (extended_distance a b)/2\n            + (SUP w\\<in>wo.underS (middle a b) \\<inter> extended_distance_set.\n              extended_distance z w - max (extended_distance a w) (extended_distance b w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance z t =\n    extended_distance a b / 2 +\n    (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set.\n        extended_distance z w -\n        max (extended_distance a w) (extended_distance b w))", "using that(2)"], ["proof (prove)\nusing this:\n  z \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n\ngoal (1 subgoal):\n 1. extended_distance z t =\n    extended_distance a b / 2 +\n    (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set.\n        extended_distance z w -\n        max (extended_distance a w) (extended_distance b w))", "unfolding M"], ["proof (prove)\nusing this:\n  z \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n          extended_distance_set\n\ngoal (1 subgoal):\n 1. extended_distance z (middle a b) =\n    extended_distance a b / 2 +\n    (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set.\n        extended_distance z w -\n        max (extended_distance a w) (extended_distance b w))", "using extended_distance_middle_formula"], ["proof (prove)\nusing this:\n  z \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n          extended_distance_set\n  ?x \\<in> underS Bonk_Schramm_extension_unfolded_wo\n            (middle ?a ?b) \\<Longrightarrow>\n  extended_distance ?x (middle ?a ?b) =\n  extended_distance ?a ?b / 2 +\n  (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n              (middle ?a ?b) \\<inter>\n             extended_distance_set.\n      extended_distance ?x w -\n      max (extended_distance ?a w) (extended_distance ?b w))\n\ngoal (1 subgoal):\n 1. extended_distance z (middle a b) =\n    extended_distance a b / 2 +\n    (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set.\n        extended_distance z w -\n        max (extended_distance a w) (extended_distance b w))", "by auto"], ["proof (state)\nthis:\n  extended_distance z t =\n  extended_distance a b / 2 +\n  (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n             extended_distance_set.\n      extended_distance z w -\n      max (extended_distance a w) (extended_distance b w))\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "have bdd: \"bdd_above ((\\<lambda>w. extended_distance x w - max (extended_distance a w) (extended_distance b w))` (wo.underS (middle a b) \\<inter> extended_distance_set))\"\n          if \"x \\<in> wo.underS t \\<inter> extended_distance_set\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above\n     ((\\<lambda>w.\n          extended_distance x w -\n          max (extended_distance a w) (extended_distance b w)) `\n      (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n       extended_distance_set))", "proof (rule bdd_aboveI2)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set \\<Longrightarrow>\n       extended_distance x x -\n       max (extended_distance a x) (extended_distance b x)\n       \\<le> ?M", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set \\<Longrightarrow>\n       extended_distance x x -\n       max (extended_distance a x) (extended_distance b x)\n       \\<le> ?M", "assume w: \"w \\<in> wo.underS (middle a b) \\<inter> extended_distance_set\""], ["proof (state)\nthis:\n  w \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n          extended_distance_set\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set \\<Longrightarrow>\n       extended_distance x x -\n       max (extended_distance a x) (extended_distance b x)\n       \\<le> ?M", "have \"extended_distance x w \\<le> extended_distance x a + extended_distance a w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance x w\n    \\<le> extended_distance x a + extended_distance a w", "apply (rule IH)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n            extended_distance_set\n 2. a \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n            extended_distance_set\n 3. w \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n            extended_distance_set", "using ab w M that(1)"], ["proof (prove)\nusing this:\n  a \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n  b \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n  w \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n          extended_distance_set\n  t = middle a b\n  x \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n\ngoal (3 subgoals):\n 1. x \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n            extended_distance_set\n 2. a \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n            extended_distance_set\n 3. w \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n            extended_distance_set", "by auto"], ["proof (state)\nthis:\n  extended_distance x w \\<le> extended_distance x a + extended_distance a w\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set \\<Longrightarrow>\n       extended_distance x x -\n       max (extended_distance a x) (extended_distance b x)\n       \\<le> ?M", "also"], ["proof (state)\nthis:\n  extended_distance x w \\<le> extended_distance x a + extended_distance a w\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set \\<Longrightarrow>\n       extended_distance x x -\n       max (extended_distance a x) (extended_distance b x)\n       \\<le> ?M", "have \"... \\<le> extended_distance x a + max (extended_distance a w) (extended_distance b w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance x a + extended_distance a w\n    \\<le> extended_distance x a +\n          max (extended_distance a w) (extended_distance b w)", "by auto"], ["proof (state)\nthis:\n  extended_distance x a + extended_distance a w\n  \\<le> extended_distance x a +\n        max (extended_distance a w) (extended_distance b w)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set \\<Longrightarrow>\n       extended_distance x x -\n       max (extended_distance a x) (extended_distance b x)\n       \\<le> ?M", "finally"], ["proof (chain)\npicking this:\n  extended_distance x w\n  \\<le> extended_distance x a +\n        max (extended_distance a w) (extended_distance b w)", "show \"extended_distance x w - max (extended_distance a w) (extended_distance b w)\n                        \\<le> extended_distance x a\""], ["proof (prove)\nusing this:\n  extended_distance x w\n  \\<le> extended_distance x a +\n        max (extended_distance a w) (extended_distance b w)\n\ngoal (1 subgoal):\n 1. extended_distance x w -\n    max (extended_distance a w) (extended_distance b w)\n    \\<le> extended_distance x a", "by auto"], ["proof (state)\nthis:\n  extended_distance x w -\n  max (extended_distance a w) (extended_distance b w)\n  \\<le> extended_distance x a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x1\n  \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n        extended_distance_set \\<Longrightarrow>\n  bdd_above\n   ((\\<lambda>w.\n        extended_distance ?x1 w -\n        max (extended_distance a w) (extended_distance b w)) `\n    (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n     extended_distance_set))\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "have \"(\\<lambda>w. extended_distance x z + extended_distance z w - max (extended_distance a w) (extended_distance b w)) ` (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter> extended_distance_set)\n            = (\\<lambda>s. s + extended_distance x z)` (\\<lambda>w. extended_distance z w - max (extended_distance a w) (extended_distance b w)) ` (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter> extended_distance_set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>w.\n        extended_distance x z + extended_distance z w -\n        max (extended_distance a w) (extended_distance b w)) `\n    (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n     extended_distance_set) =\n    (\\<lambda>s. s + extended_distance x z) `\n    (\\<lambda>w.\n        extended_distance z w -\n        max (extended_distance a w) (extended_distance b w)) `\n    (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n     extended_distance_set)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>w.\n      extended_distance x z + extended_distance z w -\n      max (extended_distance a w) (extended_distance b w)) `\n  (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n   extended_distance_set) =\n  (\\<lambda>s. s + extended_distance x z) `\n  (\\<lambda>w.\n      extended_distance z w -\n      max (extended_distance a w) (extended_distance b w)) `\n  (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n   extended_distance_set)\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>w.\n      extended_distance x z + extended_distance z w -\n      max (extended_distance a w) (extended_distance b w)) `\n  (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n   extended_distance_set) =\n  (\\<lambda>s. s + extended_distance x z) `\n  (\\<lambda>w.\n      extended_distance z w -\n      max (extended_distance a w) (extended_distance b w)) `\n  (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n   extended_distance_set)\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "have \"bdd_above ((\\<lambda>s. s + extended_distance x z)` (\\<lambda>w. extended_distance z w - max (extended_distance a w) (extended_distance b w)) ` (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter> extended_distance_set))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above\n     ((\\<lambda>s. s + extended_distance x z) `\n      (\\<lambda>w.\n          extended_distance z w -\n          max (extended_distance a w) (extended_distance b w)) `\n      (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n       extended_distance_set))", "apply (rule bdd_above_image_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. mono (\\<lambda>s. s + extended_distance x z)\n 2. bdd_above\n     ((\\<lambda>w.\n          extended_distance z w -\n          max (extended_distance a w) (extended_distance b w)) `\n      (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n       extended_distance_set))", "using bdd that"], ["proof (prove)\nusing this:\n  ?x1\n  \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n        extended_distance_set \\<Longrightarrow>\n  bdd_above\n   ((\\<lambda>w.\n        extended_distance ?x1 w -\n        max (extended_distance a w) (extended_distance b w)) `\n    (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n     extended_distance_set))\n  x \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  z \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n\ngoal (2 subgoals):\n 1. mono (\\<lambda>s. s + extended_distance x z)\n 2. bdd_above\n     ((\\<lambda>w.\n          extended_distance z w -\n          max (extended_distance a w) (extended_distance b w)) `\n      (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n       extended_distance_set))", "by (auto simp add: mono_def)"], ["proof (state)\nthis:\n  bdd_above\n   ((\\<lambda>s. s + extended_distance x z) `\n    (\\<lambda>w.\n        extended_distance z w -\n        max (extended_distance a w) (extended_distance b w)) `\n    (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n     extended_distance_set))\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>w.\n      extended_distance x z + extended_distance z w -\n      max (extended_distance a w) (extended_distance b w)) `\n  (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n   extended_distance_set) =\n  (\\<lambda>s. s + extended_distance x z) `\n  (\\<lambda>w.\n      extended_distance z w -\n      max (extended_distance a w) (extended_distance b w)) `\n  (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n   extended_distance_set)\n  bdd_above\n   ((\\<lambda>s. s + extended_distance x z) `\n    (\\<lambda>w.\n        extended_distance z w -\n        max (extended_distance a w) (extended_distance b w)) `\n    (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n     extended_distance_set))", "have bdd_3: \"bdd_above ((\\<lambda>w. extended_distance x z + extended_distance z w - max (extended_distance a w) (extended_distance b w)) ` (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter> extended_distance_set))\""], ["proof (prove)\nusing this:\n  (\\<lambda>w.\n      extended_distance x z + extended_distance z w -\n      max (extended_distance a w) (extended_distance b w)) `\n  (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n   extended_distance_set) =\n  (\\<lambda>s. s + extended_distance x z) `\n  (\\<lambda>w.\n      extended_distance z w -\n      max (extended_distance a w) (extended_distance b w)) `\n  (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n   extended_distance_set)\n  bdd_above\n   ((\\<lambda>s. s + extended_distance x z) `\n    (\\<lambda>w.\n        extended_distance z w -\n        max (extended_distance a w) (extended_distance b w)) `\n    (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n     extended_distance_set))\n\ngoal (1 subgoal):\n 1. bdd_above\n     ((\\<lambda>w.\n          extended_distance x z + extended_distance z w -\n          max (extended_distance a w) (extended_distance b w)) `\n      (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n       extended_distance_set))", "by simp"], ["proof (state)\nthis:\n  bdd_above\n   ((\\<lambda>w.\n        extended_distance x z + extended_distance z w -\n        max (extended_distance a w) (extended_distance b w)) `\n    (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n     extended_distance_set))\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "have **: \"max (extended_distance a a) (extended_distance b a) = extended_distance b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (extended_distance a a) (extended_distance b a) =\n    extended_distance b a", "apply (rule max_absorb2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance a a \\<le> extended_distance b a", "using pos ab extended_distance_set_def M"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?y1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> extended_distance ?x1 ?y1\n  a \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n  b \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n  extended_distance_set = {z. extended_distance z z = 0}\n  t = middle a b\n\ngoal (1 subgoal):\n 1. extended_distance a a \\<le> extended_distance b a", "by auto"], ["proof (state)\nthis:\n  max (extended_distance a a) (extended_distance b a) =\n  extended_distance b a\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "then"], ["proof (chain)\npicking this:\n  max (extended_distance a a) (extended_distance b a) =\n  extended_distance b a", "have \"-extended_distance a b / 2 + extended_distance x a\n              = (extended_distance a b)/2 + extended_distance x a - max (extended_distance a a) (extended_distance b a)\""], ["proof (prove)\nusing this:\n  max (extended_distance a a) (extended_distance b a) =\n  extended_distance b a\n\ngoal (1 subgoal):\n 1. - extended_distance a b / 2 + extended_distance x a =\n    extended_distance a b / 2 + extended_distance x a -\n    max (extended_distance a a) (extended_distance b a)", "unfolding extended_distance_symmetric[of a b]"], ["proof (prove)\nusing this:\n  max (extended_distance a a) (extended_distance b a) =\n  extended_distance b a\n\ngoal (1 subgoal):\n 1. - extended_distance b a / 2 + extended_distance x a =\n    extended_distance b a / 2 + extended_distance x a -\n    max (extended_distance a a) (extended_distance b a)", "by auto"], ["proof (state)\nthis:\n  - extended_distance a b / 2 + extended_distance x a =\n  extended_distance a b / 2 + extended_distance x a -\n  max (extended_distance a a) (extended_distance b a)\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "also"], ["proof (state)\nthis:\n  - extended_distance a b / 2 + extended_distance x a =\n  extended_distance a b / 2 + extended_distance x a -\n  max (extended_distance a a) (extended_distance b a)\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "have \"... \\<le> extended_distance x t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance a b / 2 + extended_distance x a -\n    max (extended_distance a a) (extended_distance b a)\n    \\<le> extended_distance x t", "unfolding dxt"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance a b / 2 + extended_distance x a -\n    max (extended_distance a a) (extended_distance b a)\n    \\<le> extended_distance a b / 2 +\n          (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                      (middle a b) \\<inter>\n                     extended_distance_set.\n              extended_distance x w -\n              max (extended_distance a w) (extended_distance b w))", "apply (simp, rule cSUP_upper, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<and>\n    a \\<in> extended_distance_set\n 2. bdd_above\n     ((\\<lambda>w.\n          extended_distance x w -\n          max (extended_distance a w) (extended_distance b w)) `\n      (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n       extended_distance_set))", "using bdd that M ab"], ["proof (prove)\nusing this:\n  ?x1\n  \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n        extended_distance_set \\<Longrightarrow>\n  bdd_above\n   ((\\<lambda>w.\n        extended_distance ?x1 w -\n        max (extended_distance a w) (extended_distance b w)) `\n    (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n     extended_distance_set))\n  x \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  z \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  t = middle a b\n  a \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n  b \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n\ngoal (2 subgoals):\n 1. a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<and>\n    a \\<in> extended_distance_set\n 2. bdd_above\n     ((\\<lambda>w.\n          extended_distance x w -\n          max (extended_distance a w) (extended_distance b w)) `\n      (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n       extended_distance_set))", "by auto"], ["proof (state)\nthis:\n  extended_distance a b / 2 + extended_distance x a -\n  max (extended_distance a a) (extended_distance b a)\n  \\<le> extended_distance x t\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "finally"], ["proof (chain)\npicking this:\n  - extended_distance a b / 2 + extended_distance x a\n  \\<le> extended_distance x t", "have D1: \"-extended_distance a b / 2 + extended_distance x a \\<le> extended_distance x t\""], ["proof (prove)\nusing this:\n  - extended_distance a b / 2 + extended_distance x a\n  \\<le> extended_distance x t\n\ngoal (1 subgoal):\n 1. - extended_distance a b / 2 + extended_distance x a\n    \\<le> extended_distance x t", "by simp"], ["proof (state)\nthis:\n  - extended_distance a b / 2 + extended_distance x a\n  \\<le> extended_distance x t\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "have **: \"max (extended_distance a b) (extended_distance b b) = extended_distance a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (extended_distance a b) (extended_distance b b) =\n    extended_distance a b", "apply (rule max_absorb1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance b b \\<le> extended_distance a b", "using pos ab extended_distance_set_def M"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?y1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> extended_distance ?x1 ?y1\n  a \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n  b \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n  extended_distance_set = {z. extended_distance z z = 0}\n  t = middle a b\n\ngoal (1 subgoal):\n 1. extended_distance b b \\<le> extended_distance a b", "by auto"], ["proof (state)\nthis:\n  max (extended_distance a b) (extended_distance b b) =\n  extended_distance a b\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "then"], ["proof (chain)\npicking this:\n  max (extended_distance a b) (extended_distance b b) =\n  extended_distance a b", "have \"-extended_distance a b / 2 + extended_distance x b\n              = (extended_distance a b)/2 + extended_distance x b - max (extended_distance a b) (extended_distance b b)\""], ["proof (prove)\nusing this:\n  max (extended_distance a b) (extended_distance b b) =\n  extended_distance a b\n\ngoal (1 subgoal):\n 1. - extended_distance a b / 2 + extended_distance x b =\n    extended_distance a b / 2 + extended_distance x b -\n    max (extended_distance a b) (extended_distance b b)", "unfolding extended_distance_symmetric[of a b]"], ["proof (prove)\nusing this:\n  max (extended_distance b a) (extended_distance b b) =\n  extended_distance b a\n\ngoal (1 subgoal):\n 1. - extended_distance b a / 2 + extended_distance x b =\n    extended_distance b a / 2 + extended_distance x b -\n    max (extended_distance b a) (extended_distance b b)", "by auto"], ["proof (state)\nthis:\n  - extended_distance a b / 2 + extended_distance x b =\n  extended_distance a b / 2 + extended_distance x b -\n  max (extended_distance a b) (extended_distance b b)\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "also"], ["proof (state)\nthis:\n  - extended_distance a b / 2 + extended_distance x b =\n  extended_distance a b / 2 + extended_distance x b -\n  max (extended_distance a b) (extended_distance b b)\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "have \"... \\<le> extended_distance x t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance a b / 2 + extended_distance x b -\n    max (extended_distance a b) (extended_distance b b)\n    \\<le> extended_distance x t", "unfolding dxt"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance a b / 2 + extended_distance x b -\n    max (extended_distance a b) (extended_distance b b)\n    \\<le> extended_distance a b / 2 +\n          (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                      (middle a b) \\<inter>\n                     extended_distance_set.\n              extended_distance x w -\n              max (extended_distance a w) (extended_distance b w))", "apply (simp, rule cSUP_upper, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<and>\n    b \\<in> extended_distance_set\n 2. bdd_above\n     ((\\<lambda>w.\n          extended_distance x w -\n          max (extended_distance a w) (extended_distance b w)) `\n      (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n       extended_distance_set))", "using bdd that ab"], ["proof (prove)\nusing this:\n  ?x1\n  \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n        extended_distance_set \\<Longrightarrow>\n  bdd_above\n   ((\\<lambda>w.\n        extended_distance ?x1 w -\n        max (extended_distance a w) (extended_distance b w)) `\n    (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n     extended_distance_set))\n  x \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  z \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  a \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n  b \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n\ngoal (2 subgoals):\n 1. b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<and>\n    b \\<in> extended_distance_set\n 2. bdd_above\n     ((\\<lambda>w.\n          extended_distance x w -\n          max (extended_distance a w) (extended_distance b w)) `\n      (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n       extended_distance_set))", "by auto"], ["proof (state)\nthis:\n  extended_distance a b / 2 + extended_distance x b -\n  max (extended_distance a b) (extended_distance b b)\n  \\<le> extended_distance x t\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "finally"], ["proof (chain)\npicking this:\n  - extended_distance a b / 2 + extended_distance x b\n  \\<le> extended_distance x t", "have \"-extended_distance a b / 2 + extended_distance x b \\<le> extended_distance x t\""], ["proof (prove)\nusing this:\n  - extended_distance a b / 2 + extended_distance x b\n  \\<le> extended_distance x t\n\ngoal (1 subgoal):\n 1. - extended_distance a b / 2 + extended_distance x b\n    \\<le> extended_distance x t", "by simp"], ["proof (state)\nthis:\n  - extended_distance a b / 2 + extended_distance x b\n  \\<le> extended_distance x t\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "then"], ["proof (chain)\npicking this:\n  - extended_distance a b / 2 + extended_distance x b\n  \\<le> extended_distance x t", "have D2: \"-extended_distance a b / 2 + max (extended_distance x a) (extended_distance x b) \\<le> extended_distance x t\""], ["proof (prove)\nusing this:\n  - extended_distance a b / 2 + extended_distance x b\n  \\<le> extended_distance x t\n\ngoal (1 subgoal):\n 1. - extended_distance a b / 2 +\n    max (extended_distance x a) (extended_distance x b)\n    \\<le> extended_distance x t", "using D1"], ["proof (prove)\nusing this:\n  - extended_distance a b / 2 + extended_distance x b\n  \\<le> extended_distance x t\n  - extended_distance a b / 2 + extended_distance x a\n  \\<le> extended_distance x t\n\ngoal (1 subgoal):\n 1. - extended_distance a b / 2 +\n    max (extended_distance x a) (extended_distance x b)\n    \\<le> extended_distance x t", "by auto"], ["proof (state)\nthis:\n  - extended_distance a b / 2 +\n  max (extended_distance x a) (extended_distance x b)\n  \\<le> extended_distance x t\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "have \"extended_distance x z = (-extended_distance a b / 2 + max (extended_distance x a) (extended_distance x b)) +\n                      (extended_distance a b / 2 + extended_distance x z - max (extended_distance x a) (extended_distance x b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance x z =\n    - extended_distance a b / 2 +\n    max (extended_distance x a) (extended_distance x b) +\n    (extended_distance a b / 2 + extended_distance x z -\n     max (extended_distance x a) (extended_distance x b))", "by auto"], ["proof (state)\nthis:\n  extended_distance x z =\n  - extended_distance a b / 2 +\n  max (extended_distance x a) (extended_distance x b) +\n  (extended_distance a b / 2 + extended_distance x z -\n   max (extended_distance x a) (extended_distance x b))\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "also"], ["proof (state)\nthis:\n  extended_distance x z =\n  - extended_distance a b / 2 +\n  max (extended_distance x a) (extended_distance x b) +\n  (extended_distance a b / 2 + extended_distance x z -\n   max (extended_distance x a) (extended_distance x b))\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "have \"... \\<le> extended_distance x t +\n                      (extended_distance a b / 2 + extended_distance z x - max (extended_distance a x) (extended_distance b x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - extended_distance a b / 2 +\n    max (extended_distance x a) (extended_distance x b) +\n    (extended_distance a b / 2 + extended_distance x z -\n     max (extended_distance x a) (extended_distance x b))\n    \\<le> extended_distance x t +\n          (extended_distance a b / 2 + extended_distance z x -\n           max (extended_distance a x) (extended_distance b x))", "using D2 extended_distance_symmetric"], ["proof (prove)\nusing this:\n  - extended_distance a b / 2 +\n  max (extended_distance x a) (extended_distance x b)\n  \\<le> extended_distance x t\n  extended_distance ?x ?y = extended_distance ?y ?x\n\ngoal (1 subgoal):\n 1. - extended_distance a b / 2 +\n    max (extended_distance x a) (extended_distance x b) +\n    (extended_distance a b / 2 + extended_distance x z -\n     max (extended_distance x a) (extended_distance x b))\n    \\<le> extended_distance x t +\n          (extended_distance a b / 2 + extended_distance z x -\n           max (extended_distance a x) (extended_distance b x))", "by auto"], ["proof (state)\nthis:\n  - extended_distance a b / 2 +\n  max (extended_distance x a) (extended_distance x b) +\n  (extended_distance a b / 2 + extended_distance x z -\n   max (extended_distance x a) (extended_distance x b))\n  \\<le> extended_distance x t +\n        (extended_distance a b / 2 + extended_distance z x -\n         max (extended_distance a x) (extended_distance b x))\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "also"], ["proof (state)\nthis:\n  - extended_distance a b / 2 +\n  max (extended_distance x a) (extended_distance x b) +\n  (extended_distance a b / 2 + extended_distance x z -\n   max (extended_distance x a) (extended_distance x b))\n  \\<le> extended_distance x t +\n        (extended_distance a b / 2 + extended_distance z x -\n         max (extended_distance a x) (extended_distance b x))\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "have \"... \\<le> extended_distance x t + extended_distance z t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance x t +\n    (extended_distance a b / 2 + extended_distance z x -\n     max (extended_distance a x) (extended_distance b x))\n    \\<le> extended_distance x t + extended_distance z t", "unfolding dzt"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance x t +\n    (extended_distance a b / 2 + extended_distance z x -\n     max (extended_distance a x) (extended_distance b x))\n    \\<le> extended_distance x t +\n          (extended_distance a b / 2 +\n           (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                       (middle a b) \\<inter>\n                      extended_distance_set.\n               extended_distance z w -\n               max (extended_distance a w) (extended_distance b w)))", "apply (simp, rule cSUP_upper)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n            extended_distance_set\n 2. bdd_above\n     ((\\<lambda>w.\n          extended_distance z w -\n          max (extended_distance a w) (extended_distance b w)) `\n      (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n       extended_distance_set))", "using bdd that M ab"], ["proof (prove)\nusing this:\n  ?x1\n  \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n        extended_distance_set \\<Longrightarrow>\n  bdd_above\n   ((\\<lambda>w.\n        extended_distance ?x1 w -\n        max (extended_distance a w) (extended_distance b w)) `\n    (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n     extended_distance_set))\n  x \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  z \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  t = middle a b\n  a \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n  b \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n\ngoal (2 subgoals):\n 1. x \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n            extended_distance_set\n 2. bdd_above\n     ((\\<lambda>w.\n          extended_distance z w -\n          max (extended_distance a w) (extended_distance b w)) `\n      (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n       extended_distance_set))", "by auto"], ["proof (state)\nthis:\n  extended_distance x t +\n  (extended_distance a b / 2 + extended_distance z x -\n   max (extended_distance a x) (extended_distance b x))\n  \\<le> extended_distance x t + extended_distance z t\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "finally"], ["proof (chain)\npicking this:\n  extended_distance x z \\<le> extended_distance x t + extended_distance z t", "have I: \"extended_distance x z \\<le> extended_distance x t + extended_distance z t\""], ["proof (prove)\nusing this:\n  extended_distance x z \\<le> extended_distance x t + extended_distance z t\n\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x t + extended_distance z t", "using extended_distance_symmetric"], ["proof (prove)\nusing this:\n  extended_distance x z \\<le> extended_distance x t + extended_distance z t\n  extended_distance ?x ?y = extended_distance ?y ?x\n\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x t + extended_distance z t", "by auto"], ["proof (state)\nthis:\n  extended_distance x z \\<le> extended_distance x t + extended_distance z t\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "have T: \"underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter> extended_distance_set \\<noteq> {}\"\n                \"mono ((+) (extended_distance x z))\"\n                \"bij ((+) (extended_distance x z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n    extended_distance_set \\<noteq>\n    {} &&&\n    mono ((+) (extended_distance x z)) &&& bij ((+) (extended_distance x z))", "using ab(1)"], ["proof (prove)\nusing this:\n  a \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (middle a b)\n\ngoal (1 subgoal):\n 1. underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n    extended_distance_set \\<noteq>\n    {} &&&\n    mono ((+) (extended_distance x z)) &&& bij ((+) (extended_distance x z))", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. mono ((+) (extended_distance x z))\n 2. bij ((+) (extended_distance x z))", "by (simp add: monoI, rule bij_betw_byWitness[of _ \"\\<lambda>s. s - (extended_distance x z)\"], auto)"], ["proof (state)\nthis:\n  underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n  extended_distance_set \\<noteq>\n  {}\n  mono ((+) (extended_distance x z))\n  bij ((+) (extended_distance x z))\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "have \"extended_distance x t \\<le> (extended_distance a b)/2\n          + (SUP w\\<in>wo.underS (middle a b) \\<inter> extended_distance_set.\n              extended_distance x z + extended_distance z w - max (extended_distance a w) (extended_distance b w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance x t\n    \\<le> extended_distance a b / 2 +\n          (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                      (middle a b) \\<inter>\n                     extended_distance_set.\n              extended_distance x z + extended_distance z w -\n              max (extended_distance a w) (extended_distance b w))", "unfolding dxt"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance a b / 2 +\n    (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set.\n        extended_distance x w -\n        max (extended_distance a w) (extended_distance b w))\n    \\<le> extended_distance a b / 2 +\n          (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                      (middle a b) \\<inter>\n                     extended_distance_set.\n              extended_distance x z + extended_distance z w -\n              max (extended_distance a w) (extended_distance b w))", "apply (simp, rule cSUP_subset_mono)"], ["proof (prove)\ngoal (4 subgoals):\n 1. underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n    extended_distance_set \\<noteq>\n    {}\n 2. bdd_above\n     ((\\<lambda>w.\n          extended_distance x z + extended_distance z w -\n          max (extended_distance a w) (extended_distance b w)) `\n      (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n       extended_distance_set))\n 3. underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n    extended_distance_set\n    \\<subseteq> underS Bonk_Schramm_extension_unfolded_wo\n                 (middle a b) \\<inter>\n                extended_distance_set\n 4. \\<And>x.\n       x \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set \\<Longrightarrow>\n       extended_distance x x -\n       max (extended_distance a x) (extended_distance b x)\n       \\<le> extended_distance x z + extended_distance z x -\n             max (extended_distance a x) (extended_distance b x)", "using M that IH bdd_3"], ["proof (prove)\nusing this:\n  t = middle a b\n  x \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  z \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?y1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set;\n   ?z1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x1 ?z1\n                    \\<le> extended_distance ?x1 ?y1 +\n                          extended_distance ?y1 ?z1\n  bdd_above\n   ((\\<lambda>w.\n        extended_distance x z + extended_distance z w -\n        max (extended_distance a w) (extended_distance b w)) `\n    (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n     extended_distance_set))\n\ngoal (4 subgoals):\n 1. underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n    extended_distance_set \\<noteq>\n    {}\n 2. bdd_above\n     ((\\<lambda>w.\n          extended_distance x z + extended_distance z w -\n          max (extended_distance a w) (extended_distance b w)) `\n      (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n       extended_distance_set))\n 3. underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n    extended_distance_set\n    \\<subseteq> underS Bonk_Schramm_extension_unfolded_wo\n                 (middle a b) \\<inter>\n                extended_distance_set\n 4. \\<And>x.\n       x \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set \\<Longrightarrow>\n       extended_distance x x -\n       max (extended_distance a x) (extended_distance b x)\n       \\<le> extended_distance x z + extended_distance z x -\n             max (extended_distance a x) (extended_distance b x)", "by (auto)"], ["proof (state)\nthis:\n  extended_distance x t\n  \\<le> extended_distance a b / 2 +\n        (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                    (middle a b) \\<inter>\n                   extended_distance_set.\n            extended_distance x z + extended_distance z w -\n            max (extended_distance a w) (extended_distance b w))\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "also"], ["proof (state)\nthis:\n  extended_distance x t\n  \\<le> extended_distance a b / 2 +\n        (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                    (middle a b) \\<inter>\n                   extended_distance_set.\n            extended_distance x z + extended_distance z w -\n            max (extended_distance a w) (extended_distance b w))\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "have \"... = extended_distance x z + extended_distance z t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance a b / 2 +\n    (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set.\n        extended_distance x z + extended_distance z w -\n        max (extended_distance a w) (extended_distance b w)) =\n    extended_distance x z + extended_distance z t", "unfolding dzt"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance a b / 2 +\n    (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set.\n        extended_distance x z + extended_distance z w -\n        max (extended_distance a w) (extended_distance b w)) =\n    extended_distance x z +\n    (extended_distance a b / 2 +\n     (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                 (middle a b) \\<inter>\n                extended_distance_set.\n         extended_distance z w -\n         max (extended_distance a w) (extended_distance b w)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set.\n        extended_distance x z + extended_distance z w -\n        max (extended_distance a w) (extended_distance b w)) =\n    extended_distance x z +\n    (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set.\n        extended_distance z w -\n        max (extended_distance a w) (extended_distance b w))", "using mono_cSup_bij[of \"(\\<lambda>w. extended_distance z w - max (extended_distance a w) (extended_distance b w))`(wo.underS (middle a b) \\<inter> extended_distance_set)\" \"\\<lambda>s. extended_distance x z + s\", OF _ _ T(2) T(3)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>bdd_above\n            ((\\<lambda>w.\n                 extended_distance z w -\n                 max (extended_distance a w) (extended_distance b w)) `\n             (underS Bonk_Schramm_extension_unfolded_wo\n               (middle a b) \\<inter>\n              extended_distance_set));\n   (\\<lambda>w.\n       extended_distance z w -\n       max (extended_distance a w) (extended_distance b w)) `\n   (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n    extended_distance_set) \\<noteq>\n   {}\\<rbrakk>\n  \\<Longrightarrow> Sup ((+) (extended_distance x z) `\n                         (\\<lambda>w.\n                             extended_distance z w -\n                             max (extended_distance a w)\n                              (extended_distance b w)) `\n                         (underS Bonk_Schramm_extension_unfolded_wo\n                           (middle a b) \\<inter>\n                          extended_distance_set)) =\n                    extended_distance x z +\n                    (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                                (middle a b) \\<inter>\n                               extended_distance_set.\n                        extended_distance z w -\n                        max (extended_distance a w) (extended_distance b w))\n\ngoal (1 subgoal):\n 1. (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set.\n        extended_distance x z + extended_distance z w -\n        max (extended_distance a w) (extended_distance b w)) =\n    extended_distance x z +\n    (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set.\n        extended_distance z w -\n        max (extended_distance a w) (extended_distance b w))", "by (auto simp add: bdd [OF that(2)] ab(1) T(1) add_diff_eq image_comp)"], ["proof (state)\nthis:\n  extended_distance a b / 2 +\n  (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n             extended_distance_set.\n      extended_distance x z + extended_distance z w -\n      max (extended_distance a w) (extended_distance b w)) =\n  extended_distance x z + extended_distance z t\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "finally"], ["proof (chain)\npicking this:\n  extended_distance x t \\<le> extended_distance x z + extended_distance z t", "have \"extended_distance x t \\<le> extended_distance x z + extended_distance z t\""], ["proof (prove)\nusing this:\n  extended_distance x t \\<le> extended_distance x z + extended_distance z t\n\ngoal (1 subgoal):\n 1. extended_distance x t\n    \\<le> extended_distance x z + extended_distance z t", "by simp"], ["proof (state)\nthis:\n  extended_distance x t \\<le> extended_distance x z + extended_distance z t\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       t = middle x21 x22 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t\n 2. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "then"], ["proof (chain)\npicking this:\n  extended_distance x t \\<le> extended_distance x z + extended_distance z t", "show \"extended_distance x z \\<le> extended_distance x t + extended_distance t z\n                  \\<and> extended_distance x t \\<le> extended_distance x z + extended_distance z t\""], ["proof (prove)\nusing this:\n  extended_distance x t \\<le> extended_distance x z + extended_distance z t\n\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x t + extended_distance t z \\<and>\n    extended_distance x t\n    \\<le> extended_distance x z + extended_distance z t", "using I extended_distance_symmetric"], ["proof (prove)\nusing this:\n  extended_distance x t \\<le> extended_distance x z + extended_distance z t\n  extended_distance x z \\<le> extended_distance x t + extended_distance z t\n  extended_distance ?x ?y = extended_distance ?y ?x\n\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x t + extended_distance t z \\<and>\n    extended_distance x t\n    \\<le> extended_distance x z + extended_distance z t", "by auto"], ["proof (state)\nthis:\n  extended_distance x z\n  \\<le> extended_distance x t + extended_distance t z \\<and>\n  extended_distance x t \\<le> extended_distance x z + extended_distance z t\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "(*For Cauchy sequences, the distance to the Cauchy sequence is the limit of the distances\n        to terms of the sequence, hence the triangular inequality follows from the triangular inequality\n        for points strictly below $t$ by passing to the limit.*)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "case C: (would_be_Cauchy u)"], ["proof (state)\nthis:\n  t = would_be_Cauchy u\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "then"], ["proof (chain)\npicking this:\n  t = would_be_Cauchy u", "have un: \"u n \\<in> extended_distance_set \\<inter> wo.underS (would_be_Cauchy u)\" for n"], ["proof (prove)\nusing this:\n  t = would_be_Cauchy u\n\ngoal (1 subgoal):\n 1. u n\n    \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)", "using extended_distance_set_Cauchy 2"], ["proof (prove)\nusing this:\n  t = would_be_Cauchy u\n  would_be_Cauchy ?u \\<in> extended_distance_set \\<Longrightarrow>\n  ?u ?n\n  \\<in> extended_distance_set \\<inter>\n        underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy ?u)\n  would_be_Cauchy ?u \\<in> extended_distance_set \\<Longrightarrow>\n  \\<forall>eps>0.\n     \\<exists>N.\n        \\<forall>n\\<ge>N.\n           \\<forall>m\\<ge>N. extended_distance (?u n) (?u m) < eps\n  t \\<in> extended_distance_set\n\ngoal (1 subgoal):\n 1. u n\n    \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)", "by auto"], ["proof (state)\nthis:\n  u ?n1\n  \\<in> extended_distance_set \\<inter>\n        underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "have lim: \"(\\<lambda>n. extended_distance y (u n)) \\<longlonglongrightarrow> (extended_distance y (would_be_Cauchy u))\"\n            if y: \"y \\<in> extended_distance_set \\<inter> wo.underS (would_be_Cauchy u)\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "have \"extend_distance extend_distance_fp (wo.max2 (would_be_Cauchy u) (would_be_Cauchy u)) (would_be_Cauchy u) (would_be_Cauchy u) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_distance extend_distance_fp\n     (max2 Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n       (would_be_Cauchy u))\n     (would_be_Cauchy u) (would_be_Cauchy u) =\n    0", "using 2"], ["proof (prove)\nusing this:\n  t \\<in> extended_distance_set\n\ngoal (1 subgoal):\n 1. extend_distance extend_distance_fp\n     (max2 Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n       (would_be_Cauchy u))\n     (would_be_Cauchy u) (would_be_Cauchy u) =\n    0", "unfolding C extended_distance_set_def extended_distance_def"], ["proof (prove)\nusing this:\n  would_be_Cauchy u\n  \\<in> {z. extend_distance_fp (max2 Bonk_Schramm_extension_unfolded_wo z z)\n             z z =\n            0}\n\ngoal (1 subgoal):\n 1. extend_distance extend_distance_fp\n     (max2 Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n       (would_be_Cauchy u))\n     (would_be_Cauchy u) (would_be_Cauchy u) =\n    0", "using extend_distance_fp"], ["proof (prove)\nusing this:\n  would_be_Cauchy u\n  \\<in> {z. extend_distance_fp (max2 Bonk_Schramm_extension_unfolded_wo z z)\n             z z =\n            0}\n  extend_distance_fp = extend_distance extend_distance_fp\n\ngoal (1 subgoal):\n 1. extend_distance extend_distance_fp\n     (max2 Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n       (would_be_Cauchy u))\n     (would_be_Cauchy u) (would_be_Cauchy u) =\n    0", "by auto"], ["proof (state)\nthis:\n  extend_distance extend_distance_fp\n   (max2 Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n     (would_be_Cauchy u))\n   (would_be_Cauchy u) (would_be_Cauchy u) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "then"], ["proof (chain)\npicking this:\n  extend_distance extend_distance_fp\n   (max2 Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n     (would_be_Cauchy u))\n   (would_be_Cauchy u) (would_be_Cauchy u) =\n  0", "have cauch: \"\\<exists>N. \\<forall>n \\<ge> N. \\<forall>m \\<ge> N. extend_distance_fp (wo.max2 (u n) (u m)) (u n) (u m) < e\" if \"e > 0\" for e"], ["proof (prove)\nusing this:\n  extend_distance extend_distance_fp\n   (max2 Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n     (would_be_Cauchy u))\n   (would_be_Cauchy u) (would_be_Cauchy u) =\n  0\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             extend_distance_fp\n              (max2 Bonk_Schramm_extension_unfolded_wo (u n) (u m)) (u n)\n              (u m)\n             < e", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<exists>eps>0.\n           \\<forall>N.\n              \\<exists>n\\<ge>N.\n                 \\<exists>m\\<ge>N.\n                    \\<not> extend_distance_fp\n                            (max2 Bonk_Schramm_extension_unfolded_wo (u n)\n                              (u m))\n                            (u n) (u m)\n                           < eps\n     then 1\n     else if would_be_Cauchy u\n             \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    (would_be_Cauchy u) \\<and>\n             would_be_Cauchy u = would_be_Cauchy u\n          then lim (\\<lambda>n.\n                       extend_distance_fp\n                        (max2 Bonk_Schramm_extension_unfolded_wo (u n)\n                          (would_be_Cauchy u))\n                        (u n) (would_be_Cauchy u))\n          else if would_be_Cauchy u = would_be_Cauchy u \\<and>\n                  would_be_Cauchy u\n                  \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (would_be_Cauchy u)\n               then lim (\\<lambda>n.\n                            extend_distance_fp\n                             (max2 Bonk_Schramm_extension_unfolded_wo (u n)\n                               (would_be_Cauchy u))\n                             (u n) (would_be_Cauchy u))\n               else if would_be_Cauchy u = would_be_Cauchy u \\<and>\n                       would_be_Cauchy u = would_be_Cauchy u \\<and>\n                       (\\<forall>n.\n                           extend_distance_fp (u n) (u n) (u n) = 0)\n                    then 0 else 1) =\n    0 \\<Longrightarrow>\n    \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             extend_distance_fp\n              (max2 Bonk_Schramm_extension_unfolded_wo (u n) (u m)) (u n)\n              (u m)\n             < e", "using \\<open>e > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < e\n\ngoal (1 subgoal):\n 1. (if \\<exists>eps>0.\n           \\<forall>N.\n              \\<exists>n\\<ge>N.\n                 \\<exists>m\\<ge>N.\n                    \\<not> extend_distance_fp\n                            (max2 Bonk_Schramm_extension_unfolded_wo (u n)\n                              (u m))\n                            (u n) (u m)\n                           < eps\n     then 1\n     else if would_be_Cauchy u\n             \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                    (would_be_Cauchy u) \\<and>\n             would_be_Cauchy u = would_be_Cauchy u\n          then lim (\\<lambda>n.\n                       extend_distance_fp\n                        (max2 Bonk_Schramm_extension_unfolded_wo (u n)\n                          (would_be_Cauchy u))\n                        (u n) (would_be_Cauchy u))\n          else if would_be_Cauchy u = would_be_Cauchy u \\<and>\n                  would_be_Cauchy u\n                  \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                         (would_be_Cauchy u)\n               then lim (\\<lambda>n.\n                            extend_distance_fp\n                             (max2 Bonk_Schramm_extension_unfolded_wo (u n)\n                               (would_be_Cauchy u))\n                             (u n) (would_be_Cauchy u))\n               else if would_be_Cauchy u = would_be_Cauchy u \\<and>\n                       would_be_Cauchy u = would_be_Cauchy u \\<and>\n                       (\\<forall>n.\n                           extend_distance_fp (u n) (u n) (u n) = 0)\n                    then 0 else 1) =\n    0 \\<Longrightarrow>\n    \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             extend_distance_fp\n              (max2 Bonk_Schramm_extension_unfolded_wo (u n) (u m)) (u n)\n              (u m)\n             < e", "by (metis (no_types, hide_lams) zero_neq_one)"], ["proof (state)\nthis:\n  0 < ?e1 \\<Longrightarrow>\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N.\n           extend_distance_fp\n            (max2 Bonk_Schramm_extension_unfolded_wo (u n) (u m)) (u n)\n            (u m)\n           < ?e1\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "have \"\\<exists>N. \\<forall>n \\<ge> N. \\<forall>m \\<ge> N. abs(extended_distance y (u n) - extended_distance y (u m)) < e\" if \"e > 0\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "obtain N where *: \"extend_distance_fp (wo.max2 (u n) (u m)) (u n) (u m) < e\" if \"n \\<ge> N\" \"m \\<ge> N\" for m n"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>m n.\n            \\<lbrakk>N \\<le> n; N \\<le> m\\<rbrakk>\n            \\<Longrightarrow> extend_distance_fp\n                               (max2 Bonk_Schramm_extension_unfolded_wo\n                                 (u n) (u m))\n                               (u n) (u m)\n                              < e) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using cauch"], ["proof (prove)\nusing this:\n  0 < ?e1 \\<Longrightarrow>\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N.\n           extend_distance_fp\n            (max2 Bonk_Schramm_extension_unfolded_wo (u n) (u m)) (u n)\n            (u m)\n           < ?e1\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>m n.\n            \\<lbrakk>N \\<le> n; N \\<le> m\\<rbrakk>\n            \\<Longrightarrow> extend_distance_fp\n                               (max2 Bonk_Schramm_extension_unfolded_wo\n                                 (u n) (u m))\n                               (u n) (u m)\n                              < e) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson \\<open>0 < e\\<close>)"], ["proof (state)\nthis:\n  \\<lbrakk>N \\<le> ?n1; N \\<le> ?m1\\<rbrakk>\n  \\<Longrightarrow> extend_distance_fp\n                     (max2 Bonk_Schramm_extension_unfolded_wo (u ?n1)\n                       (u ?m1))\n                     (u ?n1) (u ?m1)\n                    < e\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "{"], ["proof (state)\nthis:\n  \\<lbrakk>N \\<le> ?n1; N \\<le> ?m1\\<rbrakk>\n  \\<Longrightarrow> extend_distance_fp\n                     (max2 Bonk_Schramm_extension_unfolded_wo (u ?n1)\n                       (u ?m1))\n                     (u ?n1) (u ?m1)\n                    < e\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "fix m n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "assume \"m \\<ge> N\" \"n \\<ge> N\""], ["proof (state)\nthis:\n  N \\<le> m\n  N \\<le> n\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "then"], ["proof (chain)\npicking this:\n  N \\<le> m\n  N \\<le> n", "have e: \"extended_distance (u n) (u m) < e\""], ["proof (prove)\nusing this:\n  N \\<le> m\n  N \\<le> n\n\ngoal (1 subgoal):\n 1. extended_distance (u n) (u m) < e", "using *"], ["proof (prove)\nusing this:\n  N \\<le> m\n  N \\<le> n\n  \\<lbrakk>N \\<le> ?n1; N \\<le> ?m1\\<rbrakk>\n  \\<Longrightarrow> extend_distance_fp\n                     (max2 Bonk_Schramm_extension_unfolded_wo (u ?n1)\n                       (u ?m1))\n                     (u ?n1) (u ?m1)\n                    < e\n\ngoal (1 subgoal):\n 1. extended_distance (u n) (u m) < e", "unfolding extended_distance_def"], ["proof (prove)\nusing this:\n  N \\<le> m\n  N \\<le> n\n  \\<lbrakk>N \\<le> ?n1; N \\<le> ?m1\\<rbrakk>\n  \\<Longrightarrow> extend_distance_fp\n                     (max2 Bonk_Schramm_extension_unfolded_wo (u ?n1)\n                       (u ?m1))\n                     (u ?n1) (u ?m1)\n                    < e\n\ngoal (1 subgoal):\n 1. extend_distance_fp (max2 Bonk_Schramm_extension_unfolded_wo (u n) (u m))\n     (u n) (u m)\n    < e", "by auto"], ["proof (state)\nthis:\n  extended_distance (u n) (u m) < e\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "have \"extended_distance y (u n) \\<le> extended_distance y (u m) + extended_distance (u m) (u n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance y (u n)\n    \\<le> extended_distance y (u m) + extended_distance (u m) (u n)", "using IH y un C"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?y1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set;\n   ?z1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x1 ?z1\n                    \\<le> extended_distance ?x1 ?y1 +\n                          extended_distance ?y1 ?z1\n  y \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n  u ?n1\n  \\<in> extended_distance_set \\<inter>\n        underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n  t = would_be_Cauchy u\n\ngoal (1 subgoal):\n 1. extended_distance y (u n)\n    \\<le> extended_distance y (u m) + extended_distance (u m) (u n)", "by blast"], ["proof (state)\nthis:\n  extended_distance y (u n)\n  \\<le> extended_distance y (u m) + extended_distance (u m) (u n)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "then"], ["proof (chain)\npicking this:\n  extended_distance y (u n)\n  \\<le> extended_distance y (u m) + extended_distance (u m) (u n)", "have 1: \"extended_distance y (u n) - extended_distance y (u m) < e\""], ["proof (prove)\nusing this:\n  extended_distance y (u n)\n  \\<le> extended_distance y (u m) + extended_distance (u m) (u n)\n\ngoal (1 subgoal):\n 1. extended_distance y (u n) - extended_distance y (u m) < e", "using e extended_distance_symmetric"], ["proof (prove)\nusing this:\n  extended_distance y (u n)\n  \\<le> extended_distance y (u m) + extended_distance (u m) (u n)\n  extended_distance (u n) (u m) < e\n  extended_distance ?x ?y = extended_distance ?y ?x\n\ngoal (1 subgoal):\n 1. extended_distance y (u n) - extended_distance y (u m) < e", "by auto"], ["proof (state)\nthis:\n  extended_distance y (u n) - extended_distance y (u m) < e\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "have \"extended_distance y (u m) \\<le> extended_distance y (u n) + extended_distance (u n) (u m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance y (u m)\n    \\<le> extended_distance y (u n) + extended_distance (u n) (u m)", "using IH y un C"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?y1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set;\n   ?z1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x1 ?z1\n                    \\<le> extended_distance ?x1 ?y1 +\n                          extended_distance ?y1 ?z1\n  y \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n  u ?n1\n  \\<in> extended_distance_set \\<inter>\n        underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n  t = would_be_Cauchy u\n\ngoal (1 subgoal):\n 1. extended_distance y (u m)\n    \\<le> extended_distance y (u n) + extended_distance (u n) (u m)", "by blast"], ["proof (state)\nthis:\n  extended_distance y (u m)\n  \\<le> extended_distance y (u n) + extended_distance (u n) (u m)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "then"], ["proof (chain)\npicking this:\n  extended_distance y (u m)\n  \\<le> extended_distance y (u n) + extended_distance (u n) (u m)", "have \"extended_distance y (u m) - extended_distance y (u n) < e\""], ["proof (prove)\nusing this:\n  extended_distance y (u m)\n  \\<le> extended_distance y (u n) + extended_distance (u n) (u m)\n\ngoal (1 subgoal):\n 1. extended_distance y (u m) - extended_distance y (u n) < e", "using e extended_distance_symmetric"], ["proof (prove)\nusing this:\n  extended_distance y (u m)\n  \\<le> extended_distance y (u n) + extended_distance (u n) (u m)\n  extended_distance (u n) (u m) < e\n  extended_distance ?x ?y = extended_distance ?y ?x\n\ngoal (1 subgoal):\n 1. extended_distance y (u m) - extended_distance y (u n) < e", "by auto"], ["proof (state)\nthis:\n  extended_distance y (u m) - extended_distance y (u n) < e\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "then"], ["proof (chain)\npicking this:\n  extended_distance y (u m) - extended_distance y (u n) < e", "have \"abs(extended_distance y (u n) - extended_distance y (u m)) < e\""], ["proof (prove)\nusing this:\n  extended_distance y (u m) - extended_distance y (u n) < e\n\ngoal (1 subgoal):\n 1. \\<bar>extended_distance y (u n) - extended_distance y (u m)\\<bar> < e", "using 1"], ["proof (prove)\nusing this:\n  extended_distance y (u m) - extended_distance y (u n) < e\n  extended_distance y (u n) - extended_distance y (u m) < e\n\ngoal (1 subgoal):\n 1. \\<bar>extended_distance y (u n) - extended_distance y (u m)\\<bar> < e", "by auto"], ["proof (state)\nthis:\n  \\<bar>extended_distance y (u n) - extended_distance y (u m)\\<bar> < e\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "}"], ["proof (state)\nthis:\n  \\<lbrakk>N \\<le> ?m3; N \\<le> ?n3\\<rbrakk>\n  \\<Longrightarrow> \\<bar>extended_distance y (u ?n3) -\n                          extended_distance y (u ?m3)\\<bar>\n                    < e\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>N \\<le> ?m3; N \\<le> ?n3\\<rbrakk>\n  \\<Longrightarrow> \\<bar>extended_distance y (u ?n3) -\n                          extended_distance y (u ?m3)\\<bar>\n                    < e", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>N \\<le> ?m3; N \\<le> ?n3\\<rbrakk>\n  \\<Longrightarrow> \\<bar>extended_distance y (u ?n3) -\n                          extended_distance y (u ?m3)\\<bar>\n                    < e\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "by auto"], ["proof (state)\nthis:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N.\n           \\<bar>extended_distance y (u n) - extended_distance y (u m)\\<bar>\n           < e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?e1 \\<Longrightarrow>\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N.\n           \\<bar>extended_distance y (u n) - extended_distance y (u m)\\<bar>\n           < ?e1\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "then"], ["proof (chain)\npicking this:\n  0 < ?e1 \\<Longrightarrow>\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N.\n           \\<bar>extended_distance y (u n) - extended_distance y (u m)\\<bar>\n           < ?e1", "have \"convergent (\\<lambda>n. extended_distance y (u n))\""], ["proof (prove)\nusing this:\n  0 < ?e1 \\<Longrightarrow>\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N.\n           \\<bar>extended_distance y (u n) - extended_distance y (u m)\\<bar>\n           < ?e1\n\ngoal (1 subgoal):\n 1. convergent (\\<lambda>n. extended_distance y (u n))", "by (simp add: Cauchy_iff real_Cauchy_convergent)"], ["proof (state)\nthis:\n  convergent (\\<lambda>n. extended_distance y (u n))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "then"], ["proof (chain)\npicking this:\n  convergent (\\<lambda>n. extended_distance y (u n))", "have lim: \"(\\<lambda>n. extended_distance y (u n)) \\<longlonglongrightarrow> lim (\\<lambda>n. extended_distance y (u n))\""], ["proof (prove)\nusing this:\n  convergent (\\<lambda>n. extended_distance y (u n))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> lim (\\<lambda>n. extended_distance y (u n))", "using convergent_LIMSEQ_iff"], ["proof (prove)\nusing this:\n  convergent (\\<lambda>n. extended_distance y (u n))\n  convergent ?X = ?X \\<longlonglongrightarrow> lim ?X\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> lim (\\<lambda>n. extended_distance y (u n))", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. extended_distance y (u n))\n  \\<longlonglongrightarrow> lim (\\<lambda>n. extended_distance y (u n))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "have *: \"wo.max2 y (would_be_Cauchy u) = would_be_Cauchy u\" \"y \\<noteq> would_be_Cauchy u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max2 Bonk_Schramm_extension_unfolded_wo y (would_be_Cauchy u) =\n    would_be_Cauchy u &&&\n    y \\<noteq> would_be_Cauchy u", "using y"], ["proof (prove)\nusing this:\n  y \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n\ngoal (1 subgoal):\n 1. max2 Bonk_Schramm_extension_unfolded_wo y (would_be_Cauchy u) =\n    would_be_Cauchy u &&&\n    y \\<noteq> would_be_Cauchy u", "by auto"], ["proof (state)\nthis:\n  max2 Bonk_Schramm_extension_unfolded_wo y (would_be_Cauchy u) =\n  would_be_Cauchy u\n  y \\<noteq> would_be_Cauchy u\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "have \"extended_distance y (would_be_Cauchy u) = lim (\\<lambda>n. extended_distance (u n) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance y (would_be_Cauchy u) =\n    lim (\\<lambda>n. extended_distance (u n) y)", "unfolding extended_distance_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_distance_fp\n     (max2 Bonk_Schramm_extension_unfolded_wo y (would_be_Cauchy u)) y\n     (would_be_Cauchy u) =\n    lim (\\<lambda>n.\n            extend_distance_fp\n             (max2 Bonk_Schramm_extension_unfolded_wo (u n) y) (u n) y)", "apply (subst extend_distance_fp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_distance extend_distance_fp\n     (max2 Bonk_Schramm_extension_unfolded_wo y (would_be_Cauchy u)) y\n     (would_be_Cauchy u) =\n    lim (\\<lambda>n.\n            extend_distance_fp\n             (max2 Bonk_Schramm_extension_unfolded_wo (u n) y) (u n) y)", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_distance extend_distance_fp (would_be_Cauchy u) y\n     (would_be_Cauchy u) =\n    lim (\\<lambda>n.\n            extend_distance_fp\n             (max2 Bonk_Schramm_extension_unfolded_wo (u n) y) (u n) y)", "using *(2) y cauch"], ["proof (prove)\nusing this:\n  y \\<noteq> would_be_Cauchy u\n  y \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n  0 < ?e1 \\<Longrightarrow>\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N.\n           extend_distance_fp\n            (max2 Bonk_Schramm_extension_unfolded_wo (u n) (u m)) (u n)\n            (u m)\n           < ?e1\n\ngoal (1 subgoal):\n 1. extend_distance extend_distance_fp (would_be_Cauchy u) y\n     (would_be_Cauchy u) =\n    lim (\\<lambda>n.\n            extend_distance_fp\n             (max2 Bonk_Schramm_extension_unfolded_wo (u n) y) (u n) y)", "by auto"], ["proof (state)\nthis:\n  extended_distance y (would_be_Cauchy u) =\n  lim (\\<lambda>n. extended_distance (u n) y)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "then"], ["proof (chain)\npicking this:\n  extended_distance y (would_be_Cauchy u) =\n  lim (\\<lambda>n. extended_distance (u n) y)", "show \"(\\<lambda>n. extended_distance y (u n)) \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)\""], ["proof (prove)\nusing this:\n  extended_distance y (would_be_Cauchy u) =\n  lim (\\<lambda>n. extended_distance (u n) y)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "using lim extended_distance_symmetric"], ["proof (prove)\nusing this:\n  extended_distance y (would_be_Cauchy u) =\n  lim (\\<lambda>n. extended_distance (u n) y)\n  (\\<lambda>n. extended_distance y (u n))\n  \\<longlonglongrightarrow> lim (\\<lambda>n. extended_distance y (u n))\n  extended_distance ?x ?y = extended_distance ?y ?x\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. extended_distance y (u n))\n  \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?y1\n  \\<in> extended_distance_set \\<inter>\n        underS Bonk_Schramm_extension_unfolded_wo\n         (would_be_Cauchy u) \\<Longrightarrow>\n  (\\<lambda>n. extended_distance ?y1 (u n))\n  \\<longlonglongrightarrow> extended_distance ?y1 (would_be_Cauchy u)\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "have \"extended_distance x z \\<le> extended_distance x (u n) + extended_distance (u n) z\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x (u n) + extended_distance (u n) z", "using IH un that C"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?y1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set;\n   ?z1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x1 ?z1\n                    \\<le> extended_distance ?x1 ?y1 +\n                          extended_distance ?y1 ?z1\n  u ?n1\n  \\<in> extended_distance_set \\<inter>\n        underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n  x \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  z \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  t = would_be_Cauchy u\n\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x (u n) + extended_distance (u n) z", "by auto"], ["proof (state)\nthis:\n  extended_distance x z\n  \\<le> extended_distance x (u ?n1) + extended_distance (u ?n1) z\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "moreover"], ["proof (state)\nthis:\n  extended_distance x z\n  \\<le> extended_distance x (u ?n1) + extended_distance (u ?n1) z\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "have \"(\\<lambda>n. extended_distance x (u n) + extended_distance (u n) z) \\<longlonglongrightarrow> extended_distance x t + extended_distance t z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance x (u n) + extended_distance (u n) z)\n    \\<longlonglongrightarrow> extended_distance x t + extended_distance t z", "apply (auto intro!: tendsto_add)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>x. extended_distance x (u x))\n    \\<longlonglongrightarrow> extended_distance x t\n 2. (\\<lambda>x. extended_distance (u x) z)\n    \\<longlonglongrightarrow> extended_distance t z", "using lim that extended_distance_symmetric"], ["proof (prove)\nusing this:\n  ?y1\n  \\<in> extended_distance_set \\<inter>\n        underS Bonk_Schramm_extension_unfolded_wo\n         (would_be_Cauchy u) \\<Longrightarrow>\n  (\\<lambda>n. extended_distance ?y1 (u n))\n  \\<longlonglongrightarrow> extended_distance ?y1 (would_be_Cauchy u)\n  x \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  z \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  extended_distance ?x ?y = extended_distance ?y ?x\n\ngoal (2 subgoals):\n 1. (\\<lambda>x. extended_distance x (u x))\n    \\<longlonglongrightarrow> extended_distance x t\n 2. (\\<lambda>x. extended_distance (u x) z)\n    \\<longlonglongrightarrow> extended_distance t z", "unfolding C"], ["proof (prove)\nusing this:\n  ?y1\n  \\<in> extended_distance_set \\<inter>\n        underS Bonk_Schramm_extension_unfolded_wo\n         (would_be_Cauchy u) \\<Longrightarrow>\n  (\\<lambda>n. extended_distance ?y1 (u n))\n  \\<longlonglongrightarrow> extended_distance ?y1 (would_be_Cauchy u)\n  x \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy u) \\<inter>\n          extended_distance_set\n  z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy u) \\<inter>\n          extended_distance_set\n  extended_distance ?x ?y = extended_distance ?y ?x\n\ngoal (2 subgoals):\n 1. (\\<lambda>x. extended_distance x (u x))\n    \\<longlonglongrightarrow> extended_distance x (would_be_Cauchy u)\n 2. (\\<lambda>x. extended_distance (u x) z)\n    \\<longlonglongrightarrow> extended_distance (would_be_Cauchy u) z", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. extended_distance x (u n) + extended_distance (u n) z)\n  \\<longlonglongrightarrow> extended_distance x t + extended_distance t z\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "ultimately"], ["proof (chain)\npicking this:\n  extended_distance x z\n  \\<le> extended_distance x (u ?n1) + extended_distance (u ?n1) z\n  (\\<lambda>n. extended_distance x (u n) + extended_distance (u n) z)\n  \\<longlonglongrightarrow> extended_distance x t + extended_distance t z", "have I: \"extended_distance x z \\<le> extended_distance x t + extended_distance t z\""], ["proof (prove)\nusing this:\n  extended_distance x z\n  \\<le> extended_distance x (u ?n1) + extended_distance (u ?n1) z\n  (\\<lambda>n. extended_distance x (u n) + extended_distance (u n) z)\n  \\<longlonglongrightarrow> extended_distance x t + extended_distance t z\n\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x t + extended_distance t z", "using LIMSEQ_le_const"], ["proof (prove)\nusing this:\n  extended_distance x z\n  \\<le> extended_distance x (u ?n1) + extended_distance (u ?n1) z\n  (\\<lambda>n. extended_distance x (u n) + extended_distance (u n) z)\n  \\<longlonglongrightarrow> extended_distance x t + extended_distance t z\n  \\<lbrakk>?X \\<longlonglongrightarrow> ?x;\n   \\<exists>N. \\<forall>n\\<ge>N. ?a \\<le> ?X n\\<rbrakk>\n  \\<Longrightarrow> ?a \\<le> ?x\n\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x t + extended_distance t z", "by blast"], ["proof (state)\nthis:\n  extended_distance x z \\<le> extended_distance x t + extended_distance t z\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "have \"extended_distance x (u n) \\<le> extended_distance x z + extended_distance z (u n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance x (u n)\n    \\<le> extended_distance x z + extended_distance z (u n)", "using IH un that C"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?y1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set;\n   ?z1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x1 ?z1\n                    \\<le> extended_distance ?x1 ?y1 +\n                          extended_distance ?y1 ?z1\n  u ?n1\n  \\<in> extended_distance_set \\<inter>\n        underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n  x \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  z \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  t = would_be_Cauchy u\n\ngoal (1 subgoal):\n 1. extended_distance x (u n)\n    \\<le> extended_distance x z + extended_distance z (u n)", "by auto"], ["proof (state)\nthis:\n  extended_distance x (u ?n1)\n  \\<le> extended_distance x z + extended_distance z (u ?n1)\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "moreover"], ["proof (state)\nthis:\n  extended_distance x (u ?n1)\n  \\<le> extended_distance x z + extended_distance z (u ?n1)\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "have \"(\\<lambda>n. extended_distance x (u n)) \\<longlonglongrightarrow> extended_distance x t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance x (u n))\n    \\<longlonglongrightarrow> extended_distance x t", "using lim that extended_distance_symmetric"], ["proof (prove)\nusing this:\n  ?y1\n  \\<in> extended_distance_set \\<inter>\n        underS Bonk_Schramm_extension_unfolded_wo\n         (would_be_Cauchy u) \\<Longrightarrow>\n  (\\<lambda>n. extended_distance ?y1 (u n))\n  \\<longlonglongrightarrow> extended_distance ?y1 (would_be_Cauchy u)\n  x \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  z \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  extended_distance ?x ?y = extended_distance ?y ?x\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance x (u n))\n    \\<longlonglongrightarrow> extended_distance x t", "unfolding C"], ["proof (prove)\nusing this:\n  ?y1\n  \\<in> extended_distance_set \\<inter>\n        underS Bonk_Schramm_extension_unfolded_wo\n         (would_be_Cauchy u) \\<Longrightarrow>\n  (\\<lambda>n. extended_distance ?y1 (u n))\n  \\<longlonglongrightarrow> extended_distance ?y1 (would_be_Cauchy u)\n  x \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy u) \\<inter>\n          extended_distance_set\n  z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy u) \\<inter>\n          extended_distance_set\n  extended_distance ?x ?y = extended_distance ?y ?x\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance x (u n))\n    \\<longlonglongrightarrow> extended_distance x (would_be_Cauchy u)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. extended_distance x (u n))\n  \\<longlonglongrightarrow> extended_distance x t\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>n. extended_distance x (u n))\n  \\<longlonglongrightarrow> extended_distance x t\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "have \"(\\<lambda>n. extended_distance x z + extended_distance z (u n)) \\<longlonglongrightarrow> extended_distance x z + extended_distance z t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance x z + extended_distance z (u n))\n    \\<longlonglongrightarrow> extended_distance x z + extended_distance z t", "apply (auto intro!: tendsto_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. extended_distance z (u x))\n    \\<longlonglongrightarrow> extended_distance z t", "using lim that extended_distance_symmetric"], ["proof (prove)\nusing this:\n  ?y1\n  \\<in> extended_distance_set \\<inter>\n        underS Bonk_Schramm_extension_unfolded_wo\n         (would_be_Cauchy u) \\<Longrightarrow>\n  (\\<lambda>n. extended_distance ?y1 (u n))\n  \\<longlonglongrightarrow> extended_distance ?y1 (would_be_Cauchy u)\n  x \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  z \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  extended_distance ?x ?y = extended_distance ?y ?x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. extended_distance z (u x))\n    \\<longlonglongrightarrow> extended_distance z t", "unfolding C"], ["proof (prove)\nusing this:\n  ?y1\n  \\<in> extended_distance_set \\<inter>\n        underS Bonk_Schramm_extension_unfolded_wo\n         (would_be_Cauchy u) \\<Longrightarrow>\n  (\\<lambda>n. extended_distance ?y1 (u n))\n  \\<longlonglongrightarrow> extended_distance ?y1 (would_be_Cauchy u)\n  x \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy u) \\<inter>\n          extended_distance_set\n  z \\<in> underS Bonk_Schramm_extension_unfolded_wo\n           (would_be_Cauchy u) \\<inter>\n          extended_distance_set\n  extended_distance ?x ?y = extended_distance ?y ?x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. extended_distance z (u x))\n    \\<longlonglongrightarrow> extended_distance z (would_be_Cauchy u)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. extended_distance x z + extended_distance z (u n))\n  \\<longlonglongrightarrow> extended_distance x z + extended_distance z t\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "ultimately"], ["proof (chain)\npicking this:\n  extended_distance x (u ?n1)\n  \\<le> extended_distance x z + extended_distance z (u ?n1)\n  (\\<lambda>n. extended_distance x (u n))\n  \\<longlonglongrightarrow> extended_distance x t\n  (\\<lambda>n. extended_distance x z + extended_distance z (u n))\n  \\<longlonglongrightarrow> extended_distance x z + extended_distance z t", "have \"extended_distance x t \\<le> extended_distance x z + extended_distance z t\""], ["proof (prove)\nusing this:\n  extended_distance x (u ?n1)\n  \\<le> extended_distance x z + extended_distance z (u ?n1)\n  (\\<lambda>n. extended_distance x (u n))\n  \\<longlonglongrightarrow> extended_distance x t\n  (\\<lambda>n. extended_distance x z + extended_distance z (u n))\n  \\<longlonglongrightarrow> extended_distance x z + extended_distance z t\n\ngoal (1 subgoal):\n 1. extended_distance x t\n    \\<le> extended_distance x z + extended_distance z t", "using LIMSEQ_le"], ["proof (prove)\nusing this:\n  extended_distance x (u ?n1)\n  \\<le> extended_distance x z + extended_distance z (u ?n1)\n  (\\<lambda>n. extended_distance x (u n))\n  \\<longlonglongrightarrow> extended_distance x t\n  (\\<lambda>n. extended_distance x z + extended_distance z (u n))\n  \\<longlonglongrightarrow> extended_distance x z + extended_distance z t\n  \\<lbrakk>?X \\<longlonglongrightarrow> ?x; ?Y \\<longlonglongrightarrow> ?y;\n   \\<exists>N. \\<forall>n\\<ge>N. ?X n \\<le> ?Y n\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. extended_distance x t\n    \\<le> extended_distance x z + extended_distance z t", "by blast"], ["proof (state)\nthis:\n  extended_distance x t \\<le> extended_distance x z + extended_distance z t\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       t = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x t + extended_distance t z \\<and>\n       extended_distance x t\n       \\<le> extended_distance x z + extended_distance z t", "then"], ["proof (chain)\npicking this:\n  extended_distance x t \\<le> extended_distance x z + extended_distance z t", "show \"extended_distance x z \\<le> extended_distance x t + extended_distance t z\n                  \\<and> extended_distance x t \\<le> extended_distance x z + extended_distance z t\""], ["proof (prove)\nusing this:\n  extended_distance x t \\<le> extended_distance x z + extended_distance z t\n\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x t + extended_distance t z \\<and>\n    extended_distance x t\n    \\<le> extended_distance x z + extended_distance z t", "using I"], ["proof (prove)\nusing this:\n  extended_distance x t \\<le> extended_distance x z + extended_distance z t\n  extended_distance x z \\<le> extended_distance x t + extended_distance t z\n\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x t + extended_distance t z \\<and>\n    extended_distance x t\n    \\<le> extended_distance x z + extended_distance z t", "by auto"], ["proof (state)\nthis:\n  extended_distance x z\n  \\<le> extended_distance x t + extended_distance t z \\<and>\n  extended_distance x t \\<le> extended_distance x z + extended_distance z t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?z1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x1 ?z1\n                    \\<le> extended_distance ?x1 t +\n                          extended_distance t ?z1 \\<and>\n                    extended_distance ?x1 t\n                    \\<le> extended_distance ?x1 ?z1 +\n                          extended_distance ?z1 t\n\ngoal (1 subgoal):\n 1. t \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z.\n       x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x y + extended_distance y z", "(* Now, we deduce (from the above bounds in specific cases) the general triangular inequality,\n      by considering separately if each point is equal to $t$ or strictly under it.*)"], ["proof (state)\nthis:\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?z1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x1 ?z1\n                    \\<le> extended_distance ?x1 t +\n                          extended_distance t ?z1 \\<and>\n                    extended_distance ?x1 t\n                    \\<le> extended_distance ?x1 ?z1 +\n                          extended_distance ?z1 t\n\ngoal (1 subgoal):\n 1. t \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z.\n       x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x y + extended_distance y z", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?z1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x1 ?z1\n                    \\<le> extended_distance ?x1 t +\n                          extended_distance t ?z1 \\<and>\n                    extended_distance ?x1 t\n                    \\<le> extended_distance ?x1 ?z1 +\n                          extended_distance ?z1 t\n\ngoal (1 subgoal):\n 1. t \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z.\n       x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x y + extended_distance y z", "fix x y z"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z.\n       x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x y + extended_distance y z", "assume H: \"x \\<in> wo.under t \\<inter> extended_distance_set\"\n                            \"y \\<in> wo.under t \\<inter> extended_distance_set\"\n                            \"z \\<in> wo.under t \\<inter> extended_distance_set\""], ["proof (state)\nthis:\n  x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n\ngoal (1 subgoal):\n 1. t \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z.\n       x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x y + extended_distance y z", "have t: \"extended_distance t t = 0\" \"extended_distance t t \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance t t = 0 &&& 0 \\<le> extended_distance t t", "using 2 extended_distance_set_def"], ["proof (prove)\nusing this:\n  t \\<in> extended_distance_set\n  extended_distance_set = {z. extended_distance z z = 0}\n\ngoal (1 subgoal):\n 1. extended_distance t t = 0 &&& 0 \\<le> extended_distance t t", "by auto"], ["proof (state)\nthis:\n  extended_distance t t = 0\n  0 \\<le> extended_distance t t\n\ngoal (1 subgoal):\n 1. t \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z.\n       x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x y + extended_distance y z", "have *: \"((x \\<in> wo.underS t \\<inter> extended_distance_set) \\<or> (x = t))\n            \\<and> ((y \\<in> wo.underS t \\<inter> extended_distance_set) \\<or> (y = t))\n            \\<and> ((z \\<in> wo.underS t \\<inter> extended_distance_set) \\<or> (z = t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n             extended_distance_set \\<or>\n     x = t) \\<and>\n    (y \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n             extended_distance_set \\<or>\n     y = t) \\<and>\n    (z \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n             extended_distance_set \\<or>\n     z = t)", "using H"], ["proof (prove)\nusing this:\n  x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n  z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n          extended_distance_set\n\ngoal (1 subgoal):\n 1. (x \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n             extended_distance_set \\<or>\n     x = t) \\<and>\n    (y \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n             extended_distance_set \\<or>\n     y = t) \\<and>\n    (z \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n             extended_distance_set \\<or>\n     z = t)", "by (simp add: underS_def under_def)"], ["proof (state)\nthis:\n  (x \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n           extended_distance_set \\<or>\n   x = t) \\<and>\n  (y \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n           extended_distance_set \\<or>\n   y = t) \\<and>\n  (z \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n           extended_distance_set \\<or>\n   z = t)\n\ngoal (1 subgoal):\n 1. t \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z.\n       x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x y + extended_distance y z", "have \"extended_distance x z \\<le> extended_distance x y + extended_distance y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x y + extended_distance y z", "using *"], ["proof (prove)\nusing this:\n  (x \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n           extended_distance_set \\<or>\n   x = t) \\<and>\n  (y \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n           extended_distance_set \\<or>\n   y = t) \\<and>\n  (z \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n           extended_distance_set \\<or>\n   z = t)\n\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x y + extended_distance y z", "apply auto"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>x \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     x \\<in> extended_distance_set;\n     y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance x z\n                      \\<le> extended_distance x y + extended_distance y z\n 2. \\<lbrakk>x \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     x \\<in> extended_distance_set;\n     y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set; z = t\\<rbrakk>\n    \\<Longrightarrow> extended_distance x t\n                      \\<le> extended_distance x y + extended_distance y t\n 3. \\<lbrakk>x \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     x \\<in> extended_distance_set; y = t;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance x z\n                      \\<le> extended_distance x t + extended_distance t z\n 4. \\<lbrakk>x \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     x \\<in> extended_distance_set; y = t; z = t\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t\n 5. \\<lbrakk>x = t; y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> extended_distance t y + extended_distance y z\n 6. \\<lbrakk>x = t; y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set; z = t\\<rbrakk>\n    \\<Longrightarrow> extended_distance t t\n                      \\<le> extended_distance t y + extended_distance y t\n 7. \\<lbrakk>x = t; y = t;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t\n 8. \\<lbrakk>x = t; y = t; z = t\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t", "using t main_ineq extended_distance_symmetric IH pos"], ["proof (prove)\nusing this:\n  extended_distance t t = 0\n  0 \\<le> extended_distance t t\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?z1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x1 ?z1\n                    \\<le> extended_distance ?x1 t +\n                          extended_distance t ?z1 \\<and>\n                    extended_distance ?x1 t\n                    \\<le> extended_distance ?x1 ?z1 +\n                          extended_distance ?z1 t\n  extended_distance ?x ?y = extended_distance ?y ?x\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?y1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set;\n   ?z1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x1 ?z1\n                    \\<le> extended_distance ?x1 ?y1 +\n                          extended_distance ?y1 ?z1\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?y1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> extended_distance ?x1 ?y1\n\ngoal (8 subgoals):\n 1. \\<lbrakk>x \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     x \\<in> extended_distance_set;\n     y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance x z\n                      \\<le> extended_distance x y + extended_distance y z\n 2. \\<lbrakk>x \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     x \\<in> extended_distance_set;\n     y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set; z = t\\<rbrakk>\n    \\<Longrightarrow> extended_distance x t\n                      \\<le> extended_distance x y + extended_distance y t\n 3. \\<lbrakk>x \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     x \\<in> extended_distance_set; y = t;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance x z\n                      \\<le> extended_distance x t + extended_distance t z\n 4. \\<lbrakk>x \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     x \\<in> extended_distance_set; y = t; z = t\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t\n 5. \\<lbrakk>x = t; y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> extended_distance t y + extended_distance y z\n 6. \\<lbrakk>x = t; y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set; z = t\\<rbrakk>\n    \\<Longrightarrow> extended_distance t t\n                      \\<le> extended_distance t y + extended_distance y t\n 7. \\<lbrakk>x = t; y = t;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t\n 8. \\<lbrakk>x = t; y = t; z = t\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t", "apply blast"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>x \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     x \\<in> extended_distance_set;\n     y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set; z = t\\<rbrakk>\n    \\<Longrightarrow> extended_distance x t\n                      \\<le> extended_distance x y + extended_distance y t\n 2. \\<lbrakk>x \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     x \\<in> extended_distance_set; y = t;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance x z\n                      \\<le> extended_distance x t + extended_distance t z\n 3. \\<lbrakk>x \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     x \\<in> extended_distance_set; y = t; z = t\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t\n 4. \\<lbrakk>x = t; y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> extended_distance t y + extended_distance y z\n 5. \\<lbrakk>x = t; y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set; z = t\\<rbrakk>\n    \\<Longrightarrow> extended_distance t t\n                      \\<le> extended_distance t y + extended_distance y t\n 6. \\<lbrakk>x = t; y = t;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t\n 7. \\<lbrakk>x = t; y = t; z = t\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t", "using t main_ineq extended_distance_symmetric IH pos"], ["proof (prove)\nusing this:\n  extended_distance t t = 0\n  0 \\<le> extended_distance t t\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?z1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x1 ?z1\n                    \\<le> extended_distance ?x1 t +\n                          extended_distance t ?z1 \\<and>\n                    extended_distance ?x1 t\n                    \\<le> extended_distance ?x1 ?z1 +\n                          extended_distance ?z1 t\n  extended_distance ?x ?y = extended_distance ?y ?x\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?y1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set;\n   ?z1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x1 ?z1\n                    \\<le> extended_distance ?x1 ?y1 +\n                          extended_distance ?y1 ?z1\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?y1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> extended_distance ?x1 ?y1\n\ngoal (7 subgoals):\n 1. \\<lbrakk>x \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     x \\<in> extended_distance_set;\n     y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set; z = t\\<rbrakk>\n    \\<Longrightarrow> extended_distance x t\n                      \\<le> extended_distance x y + extended_distance y t\n 2. \\<lbrakk>x \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     x \\<in> extended_distance_set; y = t;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance x z\n                      \\<le> extended_distance x t + extended_distance t z\n 3. \\<lbrakk>x \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     x \\<in> extended_distance_set; y = t; z = t\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t\n 4. \\<lbrakk>x = t; y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> extended_distance t y + extended_distance y z\n 5. \\<lbrakk>x = t; y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set; z = t\\<rbrakk>\n    \\<Longrightarrow> extended_distance t t\n                      \\<le> extended_distance t y + extended_distance y t\n 6. \\<lbrakk>x = t; y = t;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t\n 7. \\<lbrakk>x = t; y = t; z = t\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t", "apply blast"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>x \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     x \\<in> extended_distance_set; y = t;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance x z\n                      \\<le> extended_distance x t + extended_distance t z\n 2. \\<lbrakk>x \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     x \\<in> extended_distance_set; y = t; z = t\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t\n 3. \\<lbrakk>x = t; y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> extended_distance t y + extended_distance y z\n 4. \\<lbrakk>x = t; y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set; z = t\\<rbrakk>\n    \\<Longrightarrow> extended_distance t t\n                      \\<le> extended_distance t y + extended_distance y t\n 5. \\<lbrakk>x = t; y = t;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t\n 6. \\<lbrakk>x = t; y = t; z = t\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t", "using t main_ineq extended_distance_symmetric IH pos"], ["proof (prove)\nusing this:\n  extended_distance t t = 0\n  0 \\<le> extended_distance t t\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?z1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x1 ?z1\n                    \\<le> extended_distance ?x1 t +\n                          extended_distance t ?z1 \\<and>\n                    extended_distance ?x1 t\n                    \\<le> extended_distance ?x1 ?z1 +\n                          extended_distance ?z1 t\n  extended_distance ?x ?y = extended_distance ?y ?x\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?y1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set;\n   ?z1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x1 ?z1\n                    \\<le> extended_distance ?x1 ?y1 +\n                          extended_distance ?y1 ?z1\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?y1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> extended_distance ?x1 ?y1\n\ngoal (6 subgoals):\n 1. \\<lbrakk>x \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     x \\<in> extended_distance_set; y = t;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance x z\n                      \\<le> extended_distance x t + extended_distance t z\n 2. \\<lbrakk>x \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     x \\<in> extended_distance_set; y = t; z = t\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t\n 3. \\<lbrakk>x = t; y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> extended_distance t y + extended_distance y z\n 4. \\<lbrakk>x = t; y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set; z = t\\<rbrakk>\n    \\<Longrightarrow> extended_distance t t\n                      \\<le> extended_distance t y + extended_distance y t\n 5. \\<lbrakk>x = t; y = t;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t\n 6. \\<lbrakk>x = t; y = t; z = t\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t", "apply blast"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>x \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     x \\<in> extended_distance_set; y = t; z = t\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t\n 2. \\<lbrakk>x = t; y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> extended_distance t y + extended_distance y z\n 3. \\<lbrakk>x = t; y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set; z = t\\<rbrakk>\n    \\<Longrightarrow> extended_distance t t\n                      \\<le> extended_distance t y + extended_distance y t\n 4. \\<lbrakk>x = t; y = t;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t\n 5. \\<lbrakk>x = t; y = t; z = t\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t", "using t main_ineq extended_distance_symmetric IH pos"], ["proof (prove)\nusing this:\n  extended_distance t t = 0\n  0 \\<le> extended_distance t t\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?z1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x1 ?z1\n                    \\<le> extended_distance ?x1 t +\n                          extended_distance t ?z1 \\<and>\n                    extended_distance ?x1 t\n                    \\<le> extended_distance ?x1 ?z1 +\n                          extended_distance ?z1 t\n  extended_distance ?x ?y = extended_distance ?y ?x\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?y1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set;\n   ?z1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x1 ?z1\n                    \\<le> extended_distance ?x1 ?y1 +\n                          extended_distance ?y1 ?z1\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?y1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> extended_distance ?x1 ?y1\n\ngoal (5 subgoals):\n 1. \\<lbrakk>x \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     x \\<in> extended_distance_set; y = t; z = t\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t\n 2. \\<lbrakk>x = t; y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> extended_distance t y + extended_distance y z\n 3. \\<lbrakk>x = t; y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set; z = t\\<rbrakk>\n    \\<Longrightarrow> extended_distance t t\n                      \\<le> extended_distance t y + extended_distance y t\n 4. \\<lbrakk>x = t; y = t;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t\n 5. \\<lbrakk>x = t; y = t; z = t\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t", "apply blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x = t; y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> extended_distance t y + extended_distance y z\n 2. \\<lbrakk>x = t; y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set; z = t\\<rbrakk>\n    \\<Longrightarrow> extended_distance t t\n                      \\<le> extended_distance t y + extended_distance y t\n 3. \\<lbrakk>x = t; y = t;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t\n 4. \\<lbrakk>x = t; y = t; z = t\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t", "using t main_ineq extended_distance_symmetric IH pos"], ["proof (prove)\nusing this:\n  extended_distance t t = 0\n  0 \\<le> extended_distance t t\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?z1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x1 ?z1\n                    \\<le> extended_distance ?x1 t +\n                          extended_distance t ?z1 \\<and>\n                    extended_distance ?x1 t\n                    \\<le> extended_distance ?x1 ?z1 +\n                          extended_distance ?z1 t\n  extended_distance ?x ?y = extended_distance ?y ?x\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?y1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set;\n   ?z1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x1 ?z1\n                    \\<le> extended_distance ?x1 ?y1 +\n                          extended_distance ?y1 ?z1\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?y1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> extended_distance ?x1 ?y1\n\ngoal (4 subgoals):\n 1. \\<lbrakk>x = t; y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> extended_distance t y + extended_distance y z\n 2. \\<lbrakk>x = t; y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set; z = t\\<rbrakk>\n    \\<Longrightarrow> extended_distance t t\n                      \\<le> extended_distance t y + extended_distance y t\n 3. \\<lbrakk>x = t; y = t;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t\n 4. \\<lbrakk>x = t; y = t; z = t\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t", "apply (metis * Int_commute add.commute underS_notIn)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x = t; y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set; z = t\\<rbrakk>\n    \\<Longrightarrow> extended_distance t t\n                      \\<le> extended_distance t y + extended_distance y t\n 2. \\<lbrakk>x = t; y = t;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t\n 3. \\<lbrakk>x = t; y = t; z = t\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t", "using t main_ineq extended_distance_symmetric IH pos"], ["proof (prove)\nusing this:\n  extended_distance t t = 0\n  0 \\<le> extended_distance t t\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?z1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x1 ?z1\n                    \\<le> extended_distance ?x1 t +\n                          extended_distance t ?z1 \\<and>\n                    extended_distance ?x1 t\n                    \\<le> extended_distance ?x1 ?z1 +\n                          extended_distance ?z1 t\n  extended_distance ?x ?y = extended_distance ?y ?x\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?y1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set;\n   ?z1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x1 ?z1\n                    \\<le> extended_distance ?x1 ?y1 +\n                          extended_distance ?y1 ?z1\n  \\<lbrakk>?x1\n           \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?y1\n   \\<in> underS Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> extended_distance ?x1 ?y1\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x = t; y \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     y \\<in> extended_distance_set; z = t\\<rbrakk>\n    \\<Longrightarrow> extended_distance t t\n                      \\<le> extended_distance t y + extended_distance y t\n 2. \\<lbrakk>x = t; y = t;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t\n 3. \\<lbrakk>x = t; y = t; z = t\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t", "apply (metis (mono_tags, lifting) \"*\" extended_distance_set_def mem_Collect_eq underS_notIn)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = t; y = t;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t\n 2. \\<lbrakk>x = t; y = t; z = t\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t", "using t"], ["proof (prove)\nusing this:\n  extended_distance t t = 0\n  0 \\<le> extended_distance t t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = t; y = t;\n     z \\<in> underS Bonk_Schramm_extension_unfolded_wo t;\n     z \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t\n 2. \\<lbrakk>x = t; y = t; z = t\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extended_distance t t", "by auto"], ["proof (state)\nthis:\n  extended_distance x z \\<le> extended_distance x y + extended_distance y z\n\ngoal (1 subgoal):\n 1. t \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z.\n       x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x y + extended_distance y z", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?xa3\n           \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?ya3\n   \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set;\n   ?za3\n   \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?xa3 ?za3\n                    \\<le> extended_distance ?xa3 ?ya3 +\n                          extended_distance ?ya3 ?za3\n\ngoal (1 subgoal):\n 1. t \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z.\n       x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x y + extended_distance y z", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?xa3\n           \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?ya3\n   \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set;\n   ?za3\n   \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?xa3 ?za3\n                    \\<le> extended_distance ?xa3 ?ya3 +\n                          extended_distance ?ya3 ?za3", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xa3\n           \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n                 extended_distance_set;\n   ?ya3\n   \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set;\n   ?za3\n   \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n         extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?xa3 ?za3\n                    \\<le> extended_distance ?xa3 ?ya3 +\n                          extended_distance ?ya3 ?za3\n\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n               extended_distance_set \\<longrightarrow>\n       extended_distance x z\n       \\<le> extended_distance x y + extended_distance y z", "by auto"], ["proof (state)\nthis:\n  \\<forall>x y z.\n     x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n             extended_distance_set \\<longrightarrow>\n     y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n             extended_distance_set \\<longrightarrow>\n     z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n             extended_distance_set \\<longrightarrow>\n     extended_distance x z\n     \\<le> extended_distance x y + extended_distance y z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x y z.\n     x \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n             extended_distance_set \\<longrightarrow>\n     y \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n             extended_distance_set \\<longrightarrow>\n     z \\<in> under Bonk_Schramm_extension_unfolded_wo t \\<inter>\n             extended_distance_set \\<longrightarrow>\n     extended_distance x z\n     \\<le> extended_distance x y + extended_distance y z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x y z.\n     x \\<in> under Bonk_Schramm_extension_unfolded_wo ?t1 \\<inter>\n             extended_distance_set \\<longrightarrow>\n     y \\<in> under Bonk_Schramm_extension_unfolded_wo ?t1 \\<inter>\n             extended_distance_set \\<longrightarrow>\n     z \\<in> under Bonk_Schramm_extension_unfolded_wo ?t1 \\<inter>\n             extended_distance_set \\<longrightarrow>\n     extended_distance x z\n     \\<le> extended_distance x y + extended_distance y z\n\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x y + extended_distance y z", "(*End of the inductive proof*)"], ["proof (state)\nthis:\n  \\<forall>x y z.\n     x \\<in> under Bonk_Schramm_extension_unfolded_wo ?t1 \\<inter>\n             extended_distance_set \\<longrightarrow>\n     y \\<in> under Bonk_Schramm_extension_unfolded_wo ?t1 \\<inter>\n             extended_distance_set \\<longrightarrow>\n     z \\<in> under Bonk_Schramm_extension_unfolded_wo ?t1 \\<inter>\n             extended_distance_set \\<longrightarrow>\n     extended_distance x z\n     \\<le> extended_distance x y + extended_distance y z\n\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x y + extended_distance y z", "define t where \"t = wo.max2 (wo.max2 x y) z\""], ["proof (state)\nthis:\n  t =\n  max2 Bonk_Schramm_extension_unfolded_wo\n   (max2 Bonk_Schramm_extension_unfolded_wo x y) z\n\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x y + extended_distance y z", "have \"x \\<in> wo.under t\" \"y \\<in> wo.under t\" \"z \\<in> wo.under t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> under Bonk_Schramm_extension_unfolded_wo t &&&\n    y \\<in> under Bonk_Schramm_extension_unfolded_wo t &&&\n    z \\<in> under Bonk_Schramm_extension_unfolded_wo t", "unfolding t_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> under Bonk_Schramm_extension_unfolded_wo\n             (max2 Bonk_Schramm_extension_unfolded_wo\n               (max2 Bonk_Schramm_extension_unfolded_wo x y) z) &&&\n    y \\<in> under Bonk_Schramm_extension_unfolded_wo\n             (max2 Bonk_Schramm_extension_unfolded_wo\n               (max2 Bonk_Schramm_extension_unfolded_wo x y) z) &&&\n    z \\<in> under Bonk_Schramm_extension_unfolded_wo\n             (max2 Bonk_Schramm_extension_unfolded_wo\n               (max2 Bonk_Schramm_extension_unfolded_wo x y) z)", "by (metis UNIV_I Bonk_Schramm_extension_unfolded_wo_props(1) mem_Collect_eq under_def well_order_on_Well_order wo.max2_equals1 wo.max2_iff wo.max2_xx)+"], ["proof (state)\nthis:\n  x \\<in> under Bonk_Schramm_extension_unfolded_wo t\n  y \\<in> under Bonk_Schramm_extension_unfolded_wo t\n  z \\<in> under Bonk_Schramm_extension_unfolded_wo t\n\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x y + extended_distance y z", "then"], ["proof (chain)\npicking this:\n  x \\<in> under Bonk_Schramm_extension_unfolded_wo t\n  y \\<in> under Bonk_Schramm_extension_unfolded_wo t\n  z \\<in> under Bonk_Schramm_extension_unfolded_wo t", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> under Bonk_Schramm_extension_unfolded_wo t\n  y \\<in> under Bonk_Schramm_extension_unfolded_wo t\n  z \\<in> under Bonk_Schramm_extension_unfolded_wo t\n\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x y + extended_distance y z", "using assms ineq_rec"], ["proof (prove)\nusing this:\n  x \\<in> under Bonk_Schramm_extension_unfolded_wo t\n  y \\<in> under Bonk_Schramm_extension_unfolded_wo t\n  z \\<in> under Bonk_Schramm_extension_unfolded_wo t\n  x \\<in> extended_distance_set\n  y \\<in> extended_distance_set\n  z \\<in> extended_distance_set\n  \\<forall>x y z.\n     x \\<in> under Bonk_Schramm_extension_unfolded_wo ?t1 \\<inter>\n             extended_distance_set \\<longrightarrow>\n     y \\<in> under Bonk_Schramm_extension_unfolded_wo ?t1 \\<inter>\n             extended_distance_set \\<longrightarrow>\n     z \\<in> under Bonk_Schramm_extension_unfolded_wo ?t1 \\<inter>\n             extended_distance_set \\<longrightarrow>\n     extended_distance x z\n     \\<le> extended_distance x y + extended_distance y z\n\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x y + extended_distance y z", "by auto"], ["proof (state)\nthis:\n  extended_distance x z \\<le> extended_distance x y + extended_distance y z\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We can now show the two main properties of the construction: the middle is indeed a middle\nfrom the metric point of view (in \\verb+extended_distance_middle+), and Cauchy sequences have\na limit (the corresponding \\verb+would_be_Cauchy+ point).\\<close>"], ["", "lemma extended_distance_pos:\n  assumes \"a \\<in> extended_distance_set\"\n          \"b \\<in> extended_distance_set\"\n  shows \"extended_distance a b \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> extended_distance a b", "using assms extended_distance_set_def extended_distance_triang_ineq[of a b a]"], ["proof (prove)\nusing this:\n  a \\<in> extended_distance_set\n  b \\<in> extended_distance_set\n  extended_distance_set = {z. extended_distance z z = 0}\n  \\<lbrakk>a \\<in> extended_distance_set; b \\<in> extended_distance_set;\n   a \\<in> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance a a\n                    \\<le> extended_distance a b + extended_distance b a\n\ngoal (1 subgoal):\n 1. 0 \\<le> extended_distance a b", "unfolding extended_distance_symmetric[of b a]"], ["proof (prove)\nusing this:\n  a \\<in> extended_distance_set\n  b \\<in> extended_distance_set\n  extended_distance_set = {z. extended_distance z z = 0}\n  \\<lbrakk>a \\<in> extended_distance_set; b \\<in> extended_distance_set;\n   a \\<in> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance a a\n                    \\<le> extended_distance a b + extended_distance a b\n\ngoal (1 subgoal):\n 1. 0 \\<le> extended_distance a b", "by auto"], ["", "lemma extended_distance_middle:\n  assumes \"a \\<in> extended_distance_set\"\n          \"b \\<in> extended_distance_set\"\n  shows \"extended_distance a (middle a b) = extended_distance a b / 2\"\n        \"extended_distance b (middle a b) = extended_distance a b / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance a (middle a b) = extended_distance a b / 2 &&&\n    extended_distance b (middle a b) = extended_distance a b / 2", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. extended_distance a (middle a b) = extended_distance a b / 2\n 2. extended_distance b (middle a b) = extended_distance a b / 2", "have \"0 = extended_distance a b - max (extended_distance a b) (extended_distance b b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 =\n    extended_distance a b -\n    max (extended_distance a b) (extended_distance b b)", "using extended_distance_pos[OF assms] assms(2) extended_distance_set_def"], ["proof (prove)\nusing this:\n  0 \\<le> extended_distance a b\n  b \\<in> extended_distance_set\n  extended_distance_set = {z. extended_distance z z = 0}\n\ngoal (1 subgoal):\n 1. 0 =\n    extended_distance a b -\n    max (extended_distance a b) (extended_distance b b)", "by auto"], ["proof (state)\nthis:\n  0 =\n  extended_distance a b -\n  max (extended_distance a b) (extended_distance b b)\n\ngoal (2 subgoals):\n 1. extended_distance a (middle a b) = extended_distance a b / 2\n 2. extended_distance b (middle a b) = extended_distance a b / 2", "also"], ["proof (state)\nthis:\n  0 =\n  extended_distance a b -\n  max (extended_distance a b) (extended_distance b b)\n\ngoal (2 subgoals):\n 1. extended_distance a (middle a b) = extended_distance a b / 2\n 2. extended_distance b (middle a b) = extended_distance a b / 2", "have \"... \\<le> (SUP w\\<in>wo.underS (middle a b) \\<inter> extended_distance_set.\n          extended_distance a w - max (extended_distance a w) (extended_distance b w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance a b -\n    max (extended_distance a b) (extended_distance b b)\n    \\<le> (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                      (middle a b) \\<inter>\n                     extended_distance_set.\n              extended_distance a w -\n              max (extended_distance a w) (extended_distance b w))", "apply (rule cSUP_upper)"], ["proof (prove)\ngoal (2 subgoals):\n 1. b \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n            extended_distance_set\n 2. bdd_above\n     ((\\<lambda>w.\n          extended_distance a w -\n          max (extended_distance a w) (extended_distance b w)) `\n      (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n       extended_distance_set))", "apply (simp add: assms(2) Bonk_Schramm_extension_unfolded_wo_props'(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above\n     ((\\<lambda>w.\n          extended_distance a w -\n          max (extended_distance a w) (extended_distance b w)) `\n      (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n       extended_distance_set))", "by (rule bdd_aboveI2[of _ _ 0], auto)"], ["proof (state)\nthis:\n  extended_distance a b -\n  max (extended_distance a b) (extended_distance b b)\n  \\<le> (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                    (middle a b) \\<inter>\n                   extended_distance_set.\n            extended_distance a w -\n            max (extended_distance a w) (extended_distance b w))\n\ngoal (2 subgoals):\n 1. extended_distance a (middle a b) = extended_distance a b / 2\n 2. extended_distance b (middle a b) = extended_distance a b / 2", "ultimately"], ["proof (chain)\npicking this:\n  0 =\n  extended_distance a b -\n  max (extended_distance a b) (extended_distance b b)\n  extended_distance a b -\n  max (extended_distance a b) (extended_distance b b)\n  \\<le> (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                    (middle a b) \\<inter>\n                   extended_distance_set.\n            extended_distance a w -\n            max (extended_distance a w) (extended_distance b w))", "have \"0 \\<le> (SUP w\\<in>wo.underS (middle a b) \\<inter> extended_distance_set.\n          extended_distance a w - max (extended_distance a w) (extended_distance b w))\""], ["proof (prove)\nusing this:\n  0 =\n  extended_distance a b -\n  max (extended_distance a b) (extended_distance b b)\n  extended_distance a b -\n  max (extended_distance a b) (extended_distance b b)\n  \\<le> (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                    (middle a b) \\<inter>\n                   extended_distance_set.\n            extended_distance a w -\n            max (extended_distance a w) (extended_distance b w))\n\ngoal (1 subgoal):\n 1. 0 \\<le> (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                        (middle a b) \\<inter>\n                       extended_distance_set.\n                extended_distance a w -\n                max (extended_distance a w) (extended_distance b w))", "by auto"], ["proof (state)\nthis:\n  0 \\<le> (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                      (middle a b) \\<inter>\n                     extended_distance_set.\n              extended_distance a w -\n              max (extended_distance a w) (extended_distance b w))\n\ngoal (2 subgoals):\n 1. extended_distance a (middle a b) = extended_distance a b / 2\n 2. extended_distance b (middle a b) = extended_distance a b / 2", "moreover"], ["proof (state)\nthis:\n  0 \\<le> (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                      (middle a b) \\<inter>\n                     extended_distance_set.\n              extended_distance a w -\n              max (extended_distance a w) (extended_distance b w))\n\ngoal (2 subgoals):\n 1. extended_distance a (middle a b) = extended_distance a b / 2\n 2. extended_distance b (middle a b) = extended_distance a b / 2", "have \"(SUP w\\<in>wo.underS (middle a b) \\<inter> extended_distance_set.\n          extended_distance a w - max (extended_distance a w) (extended_distance b w)) \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set.\n        extended_distance a w -\n        max (extended_distance a w) (extended_distance b w))\n    \\<le> 0", "apply (rule cSUP_least)"], ["proof (prove)\ngoal (2 subgoals):\n 1. underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n    extended_distance_set \\<noteq>\n    {}\n 2. \\<And>x.\n       x \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set \\<Longrightarrow>\n       extended_distance a x -\n       max (extended_distance a x) (extended_distance b x)\n       \\<le> 0", "using assms(1) Bonk_Schramm_extension_unfolded_wo_props'(1)"], ["proof (prove)\nusing this:\n  a \\<in> extended_distance_set\n  ?a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle ?a ?b)\n\ngoal (2 subgoals):\n 1. underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n    extended_distance_set \\<noteq>\n    {}\n 2. \\<And>x.\n       x \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set \\<Longrightarrow>\n       extended_distance a x -\n       max (extended_distance a x) (extended_distance b x)\n       \\<le> 0", "by (fastforce, auto)"], ["proof (state)\nthis:\n  (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n             extended_distance_set.\n      extended_distance a w -\n      max (extended_distance a w) (extended_distance b w))\n  \\<le> 0\n\ngoal (2 subgoals):\n 1. extended_distance a (middle a b) = extended_distance a b / 2\n 2. extended_distance b (middle a b) = extended_distance a b / 2", "moreover"], ["proof (state)\nthis:\n  (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n             extended_distance_set.\n      extended_distance a w -\n      max (extended_distance a w) (extended_distance b w))\n  \\<le> 0\n\ngoal (2 subgoals):\n 1. extended_distance a (middle a b) = extended_distance a b / 2\n 2. extended_distance b (middle a b) = extended_distance a b / 2", "have \"extended_distance a (middle a b) = (extended_distance a b)/2\n    + (SUP w\\<in>wo.underS (middle a b) \\<inter> extended_distance_set.\n          extended_distance a w - max (extended_distance a w) (extended_distance b w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance a (middle a b) =\n    extended_distance a b / 2 +\n    (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set.\n        extended_distance a w -\n        max (extended_distance a w) (extended_distance b w))", "by (rule extended_distance_middle_formula, simp add: Bonk_Schramm_extension_unfolded_wo_props'(1))"], ["proof (state)\nthis:\n  extended_distance a (middle a b) =\n  extended_distance a b / 2 +\n  (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n             extended_distance_set.\n      extended_distance a w -\n      max (extended_distance a w) (extended_distance b w))\n\ngoal (2 subgoals):\n 1. extended_distance a (middle a b) = extended_distance a b / 2\n 2. extended_distance b (middle a b) = extended_distance a b / 2", "ultimately"], ["proof (chain)\npicking this:\n  0 \\<le> (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                      (middle a b) \\<inter>\n                     extended_distance_set.\n              extended_distance a w -\n              max (extended_distance a w) (extended_distance b w))\n  (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n             extended_distance_set.\n      extended_distance a w -\n      max (extended_distance a w) (extended_distance b w))\n  \\<le> 0\n  extended_distance a (middle a b) =\n  extended_distance a b / 2 +\n  (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n             extended_distance_set.\n      extended_distance a w -\n      max (extended_distance a w) (extended_distance b w))", "show \"extended_distance a (middle a b) = (extended_distance a b)/2\""], ["proof (prove)\nusing this:\n  0 \\<le> (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                      (middle a b) \\<inter>\n                     extended_distance_set.\n              extended_distance a w -\n              max (extended_distance a w) (extended_distance b w))\n  (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n             extended_distance_set.\n      extended_distance a w -\n      max (extended_distance a w) (extended_distance b w))\n  \\<le> 0\n  extended_distance a (middle a b) =\n  extended_distance a b / 2 +\n  (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n             extended_distance_set.\n      extended_distance a w -\n      max (extended_distance a w) (extended_distance b w))\n\ngoal (1 subgoal):\n 1. extended_distance a (middle a b) = extended_distance a b / 2", "by auto"], ["proof (state)\nthis:\n  extended_distance a (middle a b) = extended_distance a b / 2\n\ngoal (1 subgoal):\n 1. extended_distance b (middle a b) = extended_distance a b / 2", "have \"0 = extended_distance b a - max (extended_distance a a) (extended_distance b a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 =\n    extended_distance b a -\n    max (extended_distance a a) (extended_distance b a)", "using extended_distance_pos[OF assms] assms(1) extended_distance_set_def extended_distance_symmetric"], ["proof (prove)\nusing this:\n  0 \\<le> extended_distance a b\n  a \\<in> extended_distance_set\n  extended_distance_set = {z. extended_distance z z = 0}\n  extended_distance ?x ?y = extended_distance ?y ?x\n\ngoal (1 subgoal):\n 1. 0 =\n    extended_distance b a -\n    max (extended_distance a a) (extended_distance b a)", "by auto"], ["proof (state)\nthis:\n  0 =\n  extended_distance b a -\n  max (extended_distance a a) (extended_distance b a)\n\ngoal (1 subgoal):\n 1. extended_distance b (middle a b) = extended_distance a b / 2", "also"], ["proof (state)\nthis:\n  0 =\n  extended_distance b a -\n  max (extended_distance a a) (extended_distance b a)\n\ngoal (1 subgoal):\n 1. extended_distance b (middle a b) = extended_distance a b / 2", "have \"... \\<le> (SUP w\\<in>wo.underS (middle a b) \\<inter> extended_distance_set.\n          extended_distance b w - max (extended_distance a w) (extended_distance b w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance b a -\n    max (extended_distance a a) (extended_distance b a)\n    \\<le> (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                      (middle a b) \\<inter>\n                     extended_distance_set.\n              extended_distance b w -\n              max (extended_distance a w) (extended_distance b w))", "apply (rule cSUP_upper)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n            extended_distance_set\n 2. bdd_above\n     ((\\<lambda>w.\n          extended_distance b w -\n          max (extended_distance a w) (extended_distance b w)) `\n      (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n       extended_distance_set))", "apply (simp add: assms(1) Bonk_Schramm_extension_unfolded_wo_props'(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above\n     ((\\<lambda>w.\n          extended_distance b w -\n          max (extended_distance a w) (extended_distance b w)) `\n      (underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n       extended_distance_set))", "by (rule bdd_aboveI2[of _ _ 0], auto)"], ["proof (state)\nthis:\n  extended_distance b a -\n  max (extended_distance a a) (extended_distance b a)\n  \\<le> (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                    (middle a b) \\<inter>\n                   extended_distance_set.\n            extended_distance b w -\n            max (extended_distance a w) (extended_distance b w))\n\ngoal (1 subgoal):\n 1. extended_distance b (middle a b) = extended_distance a b / 2", "ultimately"], ["proof (chain)\npicking this:\n  0 =\n  extended_distance b a -\n  max (extended_distance a a) (extended_distance b a)\n  extended_distance b a -\n  max (extended_distance a a) (extended_distance b a)\n  \\<le> (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                    (middle a b) \\<inter>\n                   extended_distance_set.\n            extended_distance b w -\n            max (extended_distance a w) (extended_distance b w))", "have \"0 \\<le> (SUP w\\<in>wo.underS (middle a b) \\<inter> extended_distance_set.\n          extended_distance b w - max (extended_distance a w) (extended_distance b w))\""], ["proof (prove)\nusing this:\n  0 =\n  extended_distance b a -\n  max (extended_distance a a) (extended_distance b a)\n  extended_distance b a -\n  max (extended_distance a a) (extended_distance b a)\n  \\<le> (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                    (middle a b) \\<inter>\n                   extended_distance_set.\n            extended_distance b w -\n            max (extended_distance a w) (extended_distance b w))\n\ngoal (1 subgoal):\n 1. 0 \\<le> (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                        (middle a b) \\<inter>\n                       extended_distance_set.\n                extended_distance b w -\n                max (extended_distance a w) (extended_distance b w))", "by auto"], ["proof (state)\nthis:\n  0 \\<le> (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                      (middle a b) \\<inter>\n                     extended_distance_set.\n              extended_distance b w -\n              max (extended_distance a w) (extended_distance b w))\n\ngoal (1 subgoal):\n 1. extended_distance b (middle a b) = extended_distance a b / 2", "moreover"], ["proof (state)\nthis:\n  0 \\<le> (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                      (middle a b) \\<inter>\n                     extended_distance_set.\n              extended_distance b w -\n              max (extended_distance a w) (extended_distance b w))\n\ngoal (1 subgoal):\n 1. extended_distance b (middle a b) = extended_distance a b / 2", "have \"(SUP w\\<in>wo.underS (middle a b) \\<inter> extended_distance_set.\n          extended_distance b w - max (extended_distance a w) (extended_distance b w)) \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set.\n        extended_distance b w -\n        max (extended_distance a w) (extended_distance b w))\n    \\<le> 0", "apply (rule cSUP_least)"], ["proof (prove)\ngoal (2 subgoals):\n 1. underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n    extended_distance_set \\<noteq>\n    {}\n 2. \\<And>x.\n       x \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set \\<Longrightarrow>\n       extended_distance b x -\n       max (extended_distance a x) (extended_distance b x)\n       \\<le> 0", "using assms(1) Bonk_Schramm_extension_unfolded_wo_props'(1)"], ["proof (prove)\nusing this:\n  a \\<in> extended_distance_set\n  ?a \\<in> underS Bonk_Schramm_extension_unfolded_wo (middle ?a ?b)\n\ngoal (2 subgoals):\n 1. underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n    extended_distance_set \\<noteq>\n    {}\n 2. \\<And>x.\n       x \\<in> underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set \\<Longrightarrow>\n       extended_distance b x -\n       max (extended_distance a x) (extended_distance b x)\n       \\<le> 0", "by (fastforce, auto)"], ["proof (state)\nthis:\n  (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n             extended_distance_set.\n      extended_distance b w -\n      max (extended_distance a w) (extended_distance b w))\n  \\<le> 0\n\ngoal (1 subgoal):\n 1. extended_distance b (middle a b) = extended_distance a b / 2", "moreover"], ["proof (state)\nthis:\n  (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n             extended_distance_set.\n      extended_distance b w -\n      max (extended_distance a w) (extended_distance b w))\n  \\<le> 0\n\ngoal (1 subgoal):\n 1. extended_distance b (middle a b) = extended_distance a b / 2", "have \"extended_distance b (middle a b) = (extended_distance a b)/2\n    + (SUP w\\<in>wo.underS (middle a b) \\<inter> extended_distance_set.\n          extended_distance b w - max (extended_distance a w) (extended_distance b w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance b (middle a b) =\n    extended_distance a b / 2 +\n    (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                (middle a b) \\<inter>\n               extended_distance_set.\n        extended_distance b w -\n        max (extended_distance a w) (extended_distance b w))", "by (rule extended_distance_middle_formula, simp add: Bonk_Schramm_extension_unfolded_wo_props'(2))"], ["proof (state)\nthis:\n  extended_distance b (middle a b) =\n  extended_distance a b / 2 +\n  (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n             extended_distance_set.\n      extended_distance b w -\n      max (extended_distance a w) (extended_distance b w))\n\ngoal (1 subgoal):\n 1. extended_distance b (middle a b) = extended_distance a b / 2", "ultimately"], ["proof (chain)\npicking this:\n  0 \\<le> (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                      (middle a b) \\<inter>\n                     extended_distance_set.\n              extended_distance b w -\n              max (extended_distance a w) (extended_distance b w))\n  (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n             extended_distance_set.\n      extended_distance b w -\n      max (extended_distance a w) (extended_distance b w))\n  \\<le> 0\n  extended_distance b (middle a b) =\n  extended_distance a b / 2 +\n  (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n             extended_distance_set.\n      extended_distance b w -\n      max (extended_distance a w) (extended_distance b w))", "show \"extended_distance b (middle a b) = (extended_distance a b)/2\""], ["proof (prove)\nusing this:\n  0 \\<le> (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo\n                      (middle a b) \\<inter>\n                     extended_distance_set.\n              extended_distance b w -\n              max (extended_distance a w) (extended_distance b w))\n  (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n             extended_distance_set.\n      extended_distance b w -\n      max (extended_distance a w) (extended_distance b w))\n  \\<le> 0\n  extended_distance b (middle a b) =\n  extended_distance a b / 2 +\n  (SUP w\\<in>underS Bonk_Schramm_extension_unfolded_wo (middle a b) \\<inter>\n             extended_distance_set.\n      extended_distance b w -\n      max (extended_distance a w) (extended_distance b w))\n\ngoal (1 subgoal):\n 1. extended_distance b (middle a b) = extended_distance a b / 2", "by auto"], ["proof (state)\nthis:\n  extended_distance b (middle a b) = extended_distance a b / 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extended_distance_Cauchy:\n  assumes \"\\<And>(n::nat). u n \\<in> extended_distance_set\"\n      and \"\\<forall>eps > (0::real). \\<exists>N. \\<forall>n \\<ge> N. \\<forall>m \\<ge> N. extended_distance (u n) (u m) < eps\"\n  shows \"would_be_Cauchy u \\<in> extended_distance_set\"\n        \"(\\<lambda>n. extended_distance (u n) (would_be_Cauchy u)) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. would_be_Cauchy u \\<in> extended_distance_set &&&\n    (\\<lambda>n. extended_distance (u n) (would_be_Cauchy u))\n    \\<longlonglongrightarrow> 0", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. would_be_Cauchy u \\<in> extended_distance_set\n 2. (\\<lambda>n. extended_distance (u n) (would_be_Cauchy u))\n    \\<longlonglongrightarrow> 0", "show 2: \"would_be_Cauchy u \\<in> extended_distance_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. would_be_Cauchy u \\<in> extended_distance_set", "unfolding extended_distance_set_def extended_distance_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. would_be_Cauchy u\n    \\<in> {z. extend_distance_fp\n               (max2 Bonk_Schramm_extension_unfolded_wo z z) z z =\n              0}", "apply (simp, subst extend_distance_fp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_distance extend_distance_fp (would_be_Cauchy u)\n     (would_be_Cauchy u) (would_be_Cauchy u) =\n    0", "using assms"], ["proof (prove)\nusing this:\n  u ?n1 \\<in> extended_distance_set\n  \\<forall>eps>0.\n     \\<exists>N.\n        \\<forall>n\\<ge>N.\n           \\<forall>m\\<ge>N. extended_distance (u n) (u m) < eps\n\ngoal (1 subgoal):\n 1. extend_distance extend_distance_fp (would_be_Cauchy u)\n     (would_be_Cauchy u) (would_be_Cauchy u) =\n    0", "unfolding extended_distance_set_def extended_distance_def"], ["proof (prove)\nusing this:\n  u ?n1\n  \\<in> {z. extend_distance_fp (max2 Bonk_Schramm_extension_unfolded_wo z z)\n             z z =\n            0}\n  \\<forall>eps>0.\n     \\<exists>N.\n        \\<forall>n\\<ge>N.\n           \\<forall>m\\<ge>N.\n              extend_distance_fp\n               (max2 Bonk_Schramm_extension_unfolded_wo (u n) (u m)) (u n)\n               (u m)\n              < eps\n\ngoal (1 subgoal):\n 1. extend_distance extend_distance_fp (would_be_Cauchy u)\n     (would_be_Cauchy u) (would_be_Cauchy u) =\n    0", "by simp"], ["proof (state)\nthis:\n  would_be_Cauchy u \\<in> extended_distance_set\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance (u n) (would_be_Cauchy u))\n    \\<longlonglongrightarrow> 0", "have lim: \"(\\<lambda>n. extended_distance y (u n)) \\<longlonglongrightarrow> (extended_distance y (would_be_Cauchy u))\"\n      if y: \"y \\<in> extended_distance_set \\<inter> wo.underS (would_be_Cauchy u)\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "have \"\\<exists>N. \\<forall>n \\<ge> N. \\<forall>m \\<ge> N. abs(extended_distance y (u n) - extended_distance y (u m)) < e\" if \"e > 0\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "obtain N where *: \"extended_distance (u n) (u m) < e\" if \"n \\<ge> N\" \"m \\<ge> N\" for m n"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>m n.\n            \\<lbrakk>N \\<le> n; N \\<le> m\\<rbrakk>\n            \\<Longrightarrow> extended_distance (u n) (u m)\n                              < e) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(2) that \\<open>e > 0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>eps>0.\n     \\<exists>N.\n        \\<forall>n\\<ge>N.\n           \\<forall>m\\<ge>N. extended_distance (u n) (u m) < eps\n  (\\<And>m n.\n      \\<lbrakk>?N1 \\<le> n; ?N1 \\<le> m\\<rbrakk>\n      \\<Longrightarrow> extended_distance (u n) (u m) < e) \\<Longrightarrow>\n  thesis\n  0 < e\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>m n.\n            \\<lbrakk>N \\<le> n; N \\<le> m\\<rbrakk>\n            \\<Longrightarrow> extended_distance (u n) (u m)\n                              < e) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by meson"], ["proof (state)\nthis:\n  \\<lbrakk>N \\<le> ?n1; N \\<le> ?m1\\<rbrakk>\n  \\<Longrightarrow> extended_distance (u ?n1) (u ?m1) < e\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "{"], ["proof (state)\nthis:\n  \\<lbrakk>N \\<le> ?n1; N \\<le> ?m1\\<rbrakk>\n  \\<Longrightarrow> extended_distance (u ?n1) (u ?m1) < e\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "fix m n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "assume \"m \\<ge> N\" \"n \\<ge> N\""], ["proof (state)\nthis:\n  N \\<le> m\n  N \\<le> n\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "then"], ["proof (chain)\npicking this:\n  N \\<le> m\n  N \\<le> n", "have e: \"extended_distance (u n) (u m) < e\""], ["proof (prove)\nusing this:\n  N \\<le> m\n  N \\<le> n\n\ngoal (1 subgoal):\n 1. extended_distance (u n) (u m) < e", "using *"], ["proof (prove)\nusing this:\n  N \\<le> m\n  N \\<le> n\n  \\<lbrakk>N \\<le> ?n1; N \\<le> ?m1\\<rbrakk>\n  \\<Longrightarrow> extended_distance (u ?n1) (u ?m1) < e\n\ngoal (1 subgoal):\n 1. extended_distance (u n) (u m) < e", "by auto"], ["proof (state)\nthis:\n  extended_distance (u n) (u m) < e\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "have \"extended_distance y (u n) \\<le> extended_distance y (u m) + extended_distance (u m) (u n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance y (u n)\n    \\<le> extended_distance y (u m) + extended_distance (u m) (u n)", "using extended_distance_triang_ineq y assms(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> extended_distance_set; ?y \\<in> extended_distance_set;\n   ?z \\<in> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x ?z\n                    \\<le> extended_distance ?x ?y + extended_distance ?y ?z\n  y \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n  u ?n1 \\<in> extended_distance_set\n\ngoal (1 subgoal):\n 1. extended_distance y (u n)\n    \\<le> extended_distance y (u m) + extended_distance (u m) (u n)", "by blast"], ["proof (state)\nthis:\n  extended_distance y (u n)\n  \\<le> extended_distance y (u m) + extended_distance (u m) (u n)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "then"], ["proof (chain)\npicking this:\n  extended_distance y (u n)\n  \\<le> extended_distance y (u m) + extended_distance (u m) (u n)", "have 1: \"extended_distance y (u n) - extended_distance y (u m) < e\""], ["proof (prove)\nusing this:\n  extended_distance y (u n)\n  \\<le> extended_distance y (u m) + extended_distance (u m) (u n)\n\ngoal (1 subgoal):\n 1. extended_distance y (u n) - extended_distance y (u m) < e", "using e extended_distance_symmetric"], ["proof (prove)\nusing this:\n  extended_distance y (u n)\n  \\<le> extended_distance y (u m) + extended_distance (u m) (u n)\n  extended_distance (u n) (u m) < e\n  extended_distance ?x ?y = extended_distance ?y ?x\n\ngoal (1 subgoal):\n 1. extended_distance y (u n) - extended_distance y (u m) < e", "by auto"], ["proof (state)\nthis:\n  extended_distance y (u n) - extended_distance y (u m) < e\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "have \"extended_distance y (u m) \\<le> extended_distance y (u n) + extended_distance (u n) (u m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance y (u m)\n    \\<le> extended_distance y (u n) + extended_distance (u n) (u m)", "using extended_distance_triang_ineq y assms(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> extended_distance_set; ?y \\<in> extended_distance_set;\n   ?z \\<in> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x ?z\n                    \\<le> extended_distance ?x ?y + extended_distance ?y ?z\n  y \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n  u ?n1 \\<in> extended_distance_set\n\ngoal (1 subgoal):\n 1. extended_distance y (u m)\n    \\<le> extended_distance y (u n) + extended_distance (u n) (u m)", "by blast"], ["proof (state)\nthis:\n  extended_distance y (u m)\n  \\<le> extended_distance y (u n) + extended_distance (u n) (u m)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "then"], ["proof (chain)\npicking this:\n  extended_distance y (u m)\n  \\<le> extended_distance y (u n) + extended_distance (u n) (u m)", "have \"extended_distance y (u m) - extended_distance y (u n) < e\""], ["proof (prove)\nusing this:\n  extended_distance y (u m)\n  \\<le> extended_distance y (u n) + extended_distance (u n) (u m)\n\ngoal (1 subgoal):\n 1. extended_distance y (u m) - extended_distance y (u n) < e", "using e extended_distance_symmetric"], ["proof (prove)\nusing this:\n  extended_distance y (u m)\n  \\<le> extended_distance y (u n) + extended_distance (u n) (u m)\n  extended_distance (u n) (u m) < e\n  extended_distance ?x ?y = extended_distance ?y ?x\n\ngoal (1 subgoal):\n 1. extended_distance y (u m) - extended_distance y (u n) < e", "by auto"], ["proof (state)\nthis:\n  extended_distance y (u m) - extended_distance y (u n) < e\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "then"], ["proof (chain)\npicking this:\n  extended_distance y (u m) - extended_distance y (u n) < e", "have \"abs(extended_distance y (u n) - extended_distance y (u m)) < e\""], ["proof (prove)\nusing this:\n  extended_distance y (u m) - extended_distance y (u n) < e\n\ngoal (1 subgoal):\n 1. \\<bar>extended_distance y (u n) - extended_distance y (u m)\\<bar> < e", "using 1"], ["proof (prove)\nusing this:\n  extended_distance y (u m) - extended_distance y (u n) < e\n  extended_distance y (u n) - extended_distance y (u m) < e\n\ngoal (1 subgoal):\n 1. \\<bar>extended_distance y (u n) - extended_distance y (u m)\\<bar> < e", "by auto"], ["proof (state)\nthis:\n  \\<bar>extended_distance y (u n) - extended_distance y (u m)\\<bar> < e\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "}"], ["proof (state)\nthis:\n  \\<lbrakk>N \\<le> ?m3; N \\<le> ?n3\\<rbrakk>\n  \\<Longrightarrow> \\<bar>extended_distance y (u ?n3) -\n                          extended_distance y (u ?m3)\\<bar>\n                    < e\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>N \\<le> ?m3; N \\<le> ?n3\\<rbrakk>\n  \\<Longrightarrow> \\<bar>extended_distance y (u ?n3) -\n                          extended_distance y (u ?m3)\\<bar>\n                    < e", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>N \\<le> ?m3; N \\<le> ?n3\\<rbrakk>\n  \\<Longrightarrow> \\<bar>extended_distance y (u ?n3) -\n                          extended_distance y (u ?m3)\\<bar>\n                    < e\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             \\<bar>extended_distance y (u n) -\n                   extended_distance y (u m)\\<bar>\n             < e", "by auto"], ["proof (state)\nthis:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N.\n           \\<bar>extended_distance y (u n) - extended_distance y (u m)\\<bar>\n           < e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?e1 \\<Longrightarrow>\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N.\n           \\<bar>extended_distance y (u n) - extended_distance y (u m)\\<bar>\n           < ?e1\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "then"], ["proof (chain)\npicking this:\n  0 < ?e1 \\<Longrightarrow>\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N.\n           \\<bar>extended_distance y (u n) - extended_distance y (u m)\\<bar>\n           < ?e1", "have \"convergent (\\<lambda>n. extended_distance y (u n))\""], ["proof (prove)\nusing this:\n  0 < ?e1 \\<Longrightarrow>\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N.\n           \\<bar>extended_distance y (u n) - extended_distance y (u m)\\<bar>\n           < ?e1\n\ngoal (1 subgoal):\n 1. convergent (\\<lambda>n. extended_distance y (u n))", "by (simp add: Cauchy_iff real_Cauchy_convergent)"], ["proof (state)\nthis:\n  convergent (\\<lambda>n. extended_distance y (u n))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "then"], ["proof (chain)\npicking this:\n  convergent (\\<lambda>n. extended_distance y (u n))", "have lim: \"(\\<lambda>n. extended_distance y (u n)) \\<longlonglongrightarrow> lim (\\<lambda>n. extended_distance y (u n))\""], ["proof (prove)\nusing this:\n  convergent (\\<lambda>n. extended_distance y (u n))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> lim (\\<lambda>n. extended_distance y (u n))", "using convergent_LIMSEQ_iff"], ["proof (prove)\nusing this:\n  convergent (\\<lambda>n. extended_distance y (u n))\n  convergent ?X = ?X \\<longlonglongrightarrow> lim ?X\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> lim (\\<lambda>n. extended_distance y (u n))", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. extended_distance y (u n))\n  \\<longlonglongrightarrow> lim (\\<lambda>n. extended_distance y (u n))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "have *: \"wo.max2 y (would_be_Cauchy u) = would_be_Cauchy u\" \"y \\<noteq> would_be_Cauchy u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max2 Bonk_Schramm_extension_unfolded_wo y (would_be_Cauchy u) =\n    would_be_Cauchy u &&&\n    y \\<noteq> would_be_Cauchy u", "using y"], ["proof (prove)\nusing this:\n  y \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n\ngoal (1 subgoal):\n 1. max2 Bonk_Schramm_extension_unfolded_wo y (would_be_Cauchy u) =\n    would_be_Cauchy u &&&\n    y \\<noteq> would_be_Cauchy u", "by auto"], ["proof (state)\nthis:\n  max2 Bonk_Schramm_extension_unfolded_wo y (would_be_Cauchy u) =\n  would_be_Cauchy u\n  y \\<noteq> would_be_Cauchy u\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "have \"extended_distance y (would_be_Cauchy u) = lim (\\<lambda>n. extended_distance (u n) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance y (would_be_Cauchy u) =\n    lim (\\<lambda>n. extended_distance (u n) y)", "unfolding extended_distance_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_distance_fp\n     (max2 Bonk_Schramm_extension_unfolded_wo y (would_be_Cauchy u)) y\n     (would_be_Cauchy u) =\n    lim (\\<lambda>n.\n            extend_distance_fp\n             (max2 Bonk_Schramm_extension_unfolded_wo (u n) y) (u n) y)", "apply (subst extend_distance_fp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_distance extend_distance_fp\n     (max2 Bonk_Schramm_extension_unfolded_wo y (would_be_Cauchy u)) y\n     (would_be_Cauchy u) =\n    lim (\\<lambda>n.\n            extend_distance_fp\n             (max2 Bonk_Schramm_extension_unfolded_wo (u n) y) (u n) y)", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_distance extend_distance_fp (would_be_Cauchy u) y\n     (would_be_Cauchy u) =\n    lim (\\<lambda>n.\n            extend_distance_fp\n             (max2 Bonk_Schramm_extension_unfolded_wo (u n) y) (u n) y)", "using *(2) y assms(2) extended_distance_def"], ["proof (prove)\nusing this:\n  y \\<noteq> would_be_Cauchy u\n  y \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)\n  \\<forall>eps>0.\n     \\<exists>N.\n        \\<forall>n\\<ge>N.\n           \\<forall>m\\<ge>N. extended_distance (u n) (u m) < eps\n  extended_distance ?x ?y =\n  extend_distance_fp (max2 Bonk_Schramm_extension_unfolded_wo ?x ?y) ?x ?y\n\ngoal (1 subgoal):\n 1. extend_distance extend_distance_fp (would_be_Cauchy u) y\n     (would_be_Cauchy u) =\n    lim (\\<lambda>n.\n            extend_distance_fp\n             (max2 Bonk_Schramm_extension_unfolded_wo (u n) y) (u n) y)", "by auto"], ["proof (state)\nthis:\n  extended_distance y (would_be_Cauchy u) =\n  lim (\\<lambda>n. extended_distance (u n) y)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "then"], ["proof (chain)\npicking this:\n  extended_distance y (would_be_Cauchy u) =\n  lim (\\<lambda>n. extended_distance (u n) y)", "show \"(\\<lambda>n. extended_distance y (u n)) \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)\""], ["proof (prove)\nusing this:\n  extended_distance y (would_be_Cauchy u) =\n  lim (\\<lambda>n. extended_distance (u n) y)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "using lim extended_distance_symmetric"], ["proof (prove)\nusing this:\n  extended_distance y (would_be_Cauchy u) =\n  lim (\\<lambda>n. extended_distance (u n) y)\n  (\\<lambda>n. extended_distance y (u n))\n  \\<longlonglongrightarrow> lim (\\<lambda>n. extended_distance y (u n))\n  extended_distance ?x ?y = extended_distance ?y ?x\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. extended_distance y (u n))\n  \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?y1\n  \\<in> extended_distance_set \\<inter>\n        underS Bonk_Schramm_extension_unfolded_wo\n         (would_be_Cauchy u) \\<Longrightarrow>\n  (\\<lambda>n. extended_distance ?y1 (u n))\n  \\<longlonglongrightarrow> extended_distance ?y1 (would_be_Cauchy u)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance (u n) (would_be_Cauchy u))\n    \\<longlonglongrightarrow> 0", "have \"\\<exists>N. \\<forall>n \\<ge> N. abs(extended_distance (u n) (would_be_Cauchy u)) < e\" if \"e > 0\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<bar>extended_distance (u n) (would_be_Cauchy u)\\<bar> < e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<bar>extended_distance (u n) (would_be_Cauchy u)\\<bar> < e", "obtain N where *: \"extended_distance (u n) (u m) < e/2\" if \"n \\<ge> N\" \"m \\<ge> N\" for m n"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>m n.\n            \\<lbrakk>N \\<le> n; N \\<le> m\\<rbrakk>\n            \\<Longrightarrow> extended_distance (u n) (u m)\n                              < e / 2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(2) that \\<open>e > 0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>eps>0.\n     \\<exists>N.\n        \\<forall>n\\<ge>N.\n           \\<forall>m\\<ge>N. extended_distance (u n) (u m) < eps\n  (\\<And>m n.\n      \\<lbrakk>?N1 \\<le> n; ?N1 \\<le> m\\<rbrakk>\n      \\<Longrightarrow> extended_distance (u n) (u m)\n                        < e / 2) \\<Longrightarrow>\n  thesis\n  0 < e\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>m n.\n            \\<lbrakk>N \\<le> n; N \\<le> m\\<rbrakk>\n            \\<Longrightarrow> extended_distance (u n) (u m)\n                              < e / 2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson half_gt_zero)"], ["proof (state)\nthis:\n  \\<lbrakk>N \\<le> ?n1; N \\<le> ?m1\\<rbrakk>\n  \\<Longrightarrow> extended_distance (u ?n1) (u ?m1) < e / 2\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<bar>extended_distance (u n) (would_be_Cauchy u)\\<bar> < e", "have \"abs(extended_distance (u n) (would_be_Cauchy u)) \\<le> e/2\" if \"n \\<ge> N\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>extended_distance (u n) (would_be_Cauchy u)\\<bar> \\<le> e / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>extended_distance (u n) (would_be_Cauchy u)\\<bar> \\<le> e / 2", "have \"eventually (\\<lambda>m. extended_distance (u n) (u m) \\<le> e/2) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially.\n       extended_distance (u n) (u m) \\<le> e / 2", "apply (rule eventually_sequentiallyI[of N])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       N \\<le> x \\<Longrightarrow> extended_distance (u n) (u x) \\<le> e / 2", "using *[OF \\<open>n \\<ge> N\\<close>] less_imp_le"], ["proof (prove)\nusing this:\n  N \\<le> ?m1 \\<Longrightarrow> extended_distance (u n) (u ?m1) < e / 2\n  ?x < ?y \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       N \\<le> x \\<Longrightarrow> extended_distance (u n) (u x) \\<le> e / 2", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F m in sequentially.\n     extended_distance (u n) (u m) \\<le> e / 2\n\ngoal (1 subgoal):\n 1. \\<bar>extended_distance (u n) (would_be_Cauchy u)\\<bar> \\<le> e / 2", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F m in sequentially.\n     extended_distance (u n) (u m) \\<le> e / 2\n\ngoal (1 subgoal):\n 1. \\<bar>extended_distance (u n) (would_be_Cauchy u)\\<bar> \\<le> e / 2", "have \"(\\<lambda>m. extended_distance (u n) (u m)) \\<longlonglongrightarrow> extended_distance (u n) (would_be_Cauchy u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>m. extended_distance (u n) (u m))\n    \\<longlonglongrightarrow> extended_distance (u n) (would_be_Cauchy u)", "apply (rule lim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. u n\n    \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)", "using \"2\" extended_distance_set_Cauchy"], ["proof (prove)\nusing this:\n  would_be_Cauchy u \\<in> extended_distance_set\n  would_be_Cauchy ?u \\<in> extended_distance_set \\<Longrightarrow>\n  ?u ?n\n  \\<in> extended_distance_set \\<inter>\n        underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy ?u)\n  would_be_Cauchy ?u \\<in> extended_distance_set \\<Longrightarrow>\n  \\<forall>eps>0.\n     \\<exists>N.\n        \\<forall>n\\<ge>N.\n           \\<forall>m\\<ge>N. extended_distance (?u n) (?u m) < eps\n\ngoal (1 subgoal):\n 1. u n\n    \\<in> extended_distance_set \\<inter>\n          underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy u)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>m. extended_distance (u n) (u m))\n  \\<longlonglongrightarrow> extended_distance (u n) (would_be_Cauchy u)\n\ngoal (1 subgoal):\n 1. \\<bar>extended_distance (u n) (would_be_Cauchy u)\\<bar> \\<le> e / 2", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F m in sequentially.\n     extended_distance (u n) (u m) \\<le> e / 2\n  (\\<lambda>m. extended_distance (u n) (u m))\n  \\<longlonglongrightarrow> extended_distance (u n) (would_be_Cauchy u)", "have \"extended_distance (u n) (would_be_Cauchy u) \\<le> e/2\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F m in sequentially.\n     extended_distance (u n) (u m) \\<le> e / 2\n  (\\<lambda>m. extended_distance (u n) (u m))\n  \\<longlonglongrightarrow> extended_distance (u n) (would_be_Cauchy u)\n\ngoal (1 subgoal):\n 1. extended_distance (u n) (would_be_Cauchy u) \\<le> e / 2", "by (meson \"*\" LIMSEQ_le_const2 less_imp_le that)"], ["proof (state)\nthis:\n  extended_distance (u n) (would_be_Cauchy u) \\<le> e / 2\n\ngoal (1 subgoal):\n 1. \\<bar>extended_distance (u n) (would_be_Cauchy u)\\<bar> \\<le> e / 2", "then"], ["proof (chain)\npicking this:\n  extended_distance (u n) (would_be_Cauchy u) \\<le> e / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  extended_distance (u n) (would_be_Cauchy u) \\<le> e / 2\n\ngoal (1 subgoal):\n 1. \\<bar>extended_distance (u n) (would_be_Cauchy u)\\<bar> \\<le> e / 2", "using extended_distance_pos[OF assms(1)[of n] 2]"], ["proof (prove)\nusing this:\n  extended_distance (u n) (would_be_Cauchy u) \\<le> e / 2\n  0 \\<le> extended_distance (u n) (would_be_Cauchy u)\n\ngoal (1 subgoal):\n 1. \\<bar>extended_distance (u n) (would_be_Cauchy u)\\<bar> \\<le> e / 2", "by auto"], ["proof (state)\nthis:\n  \\<bar>extended_distance (u n) (would_be_Cauchy u)\\<bar> \\<le> e / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  N \\<le> ?n1 \\<Longrightarrow>\n  \\<bar>extended_distance (u ?n1) (would_be_Cauchy u)\\<bar> \\<le> e / 2\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<bar>extended_distance (u n) (would_be_Cauchy u)\\<bar> < e", "then"], ["proof (chain)\npicking this:\n  N \\<le> ?n1 \\<Longrightarrow>\n  \\<bar>extended_distance (u ?n1) (would_be_Cauchy u)\\<bar> \\<le> e / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  N \\<le> ?n1 \\<Longrightarrow>\n  \\<bar>extended_distance (u ?n1) (would_be_Cauchy u)\\<bar> \\<le> e / 2\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<bar>extended_distance (u n) (would_be_Cauchy u)\\<bar> < e", "using \\<open>e > 0\\<close>"], ["proof (prove)\nusing this:\n  N \\<le> ?n1 \\<Longrightarrow>\n  \\<bar>extended_distance (u ?n1) (would_be_Cauchy u)\\<bar> \\<le> e / 2\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<bar>extended_distance (u n) (would_be_Cauchy u)\\<bar> < e", "by force"], ["proof (state)\nthis:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<bar>extended_distance (u n) (would_be_Cauchy u)\\<bar> < e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?e1 \\<Longrightarrow>\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<bar>extended_distance (u n) (would_be_Cauchy u)\\<bar> < ?e1\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance (u n) (would_be_Cauchy u))\n    \\<longlonglongrightarrow> 0", "then"], ["proof (chain)\npicking this:\n  0 < ?e1 \\<Longrightarrow>\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<bar>extended_distance (u n) (would_be_Cauchy u)\\<bar> < ?e1", "show \"(\\<lambda>n. extended_distance (u n) (would_be_Cauchy u)) \\<longlonglongrightarrow> 0\""], ["proof (prove)\nusing this:\n  0 < ?e1 \\<Longrightarrow>\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<bar>extended_distance (u n) (would_be_Cauchy u)\\<bar> < ?e1\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance (u n) (would_be_Cauchy u))\n    \\<longlonglongrightarrow> 0", "using LIMSEQ_iff"], ["proof (prove)\nusing this:\n  0 < ?e1 \\<Longrightarrow>\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<bar>extended_distance (u n) (would_be_Cauchy u)\\<bar> < ?e1\n  ?X \\<longlonglongrightarrow> ?L =\n  (\\<forall>r>0. \\<exists>no. \\<forall>n\\<ge>no. norm (?X n - ?L) < r)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance (u n) (would_be_Cauchy u))\n    \\<longlonglongrightarrow> 0", "by force"], ["proof (state)\nthis:\n  (\\<lambda>n. extended_distance (u n) (would_be_Cauchy u))\n  \\<longlonglongrightarrow> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* of context \\verb+metric_space+ *)"], ["", "subsection \\<open>The Bonk Schramm extension\\<close>"], ["", "quotient_type (overloaded) 'a Bonk_Schramm_extension =\n  \"('a::metric_space) Bonk_Schramm_extension_unfolded\"\n  / partial: \"\\<lambda>x y. (x \\<in> extended_distance_set \\<and> y \\<in> extended_distance_set \\<and> extended_distance x y = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. part_equivp\n     (\\<lambda>x y.\n         x \\<in> extended_distance_set \\<and>\n         y \\<in> extended_distance_set \\<and> extended_distance x y = 0)", "unfolding part_equivp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        x \\<in> extended_distance_set \\<and>\n        x \\<in> extended_distance_set \\<and>\n        extended_distance x x = 0) \\<and>\n    (\\<forall>x y.\n        (x \\<in> extended_distance_set \\<and>\n         y \\<in> extended_distance_set \\<and> extended_distance x y = 0) =\n        ((x \\<in> extended_distance_set \\<and>\n          x \\<in> extended_distance_set \\<and>\n          extended_distance x x = 0) \\<and>\n         (y \\<in> extended_distance_set \\<and>\n          y \\<in> extended_distance_set \\<and>\n          extended_distance y y = 0) \\<and>\n         (\\<lambda>y.\n             x \\<in> extended_distance_set \\<and>\n             y \\<in> extended_distance_set \\<and>\n             extended_distance x y = 0) =\n         (\\<lambda>ya.\n             y \\<in> extended_distance_set \\<and>\n             ya \\<in> extended_distance_set \\<and>\n             extended_distance y ya = 0)))", "proof(auto intro!: ext simp: extended_distance_set_def)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<exists>x. extended_distance x x = 0\n 2. \\<And>x y ya.\n       \\<lbrakk>extended_distance y y = 0; extended_distance x y = 0;\n        extended_distance x x = 0; extended_distance ya ya = 0;\n        extended_distance x ya = 0\\<rbrakk>\n       \\<Longrightarrow> extended_distance y ya = 0\n 3. \\<And>x y ya.\n       \\<lbrakk>extended_distance x x = 0; extended_distance x y = 0;\n        extended_distance y y = 0; extended_distance ya ya = 0;\n        extended_distance y ya = 0\\<rbrakk>\n       \\<Longrightarrow> extended_distance x ya = 0\n 4. \\<And>x y.\n       \\<lbrakk>extended_distance x x = 0; extended_distance y y = 0;\n        (\\<lambda>y.\n            extended_distance y y = 0 \\<and> extended_distance x y = 0) =\n        (\\<lambda>ya.\n            extended_distance ya ya = 0 \\<and>\n            extended_distance y ya = 0)\\<rbrakk>\n       \\<Longrightarrow> extended_distance x y = 0", "show \"\\<exists>x. extended_distance x x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. extended_distance x x = 0", "using extended_distance_set_basepoint extended_distance_set_def"], ["proof (prove)\nusing this:\n  basepoint ?x \\<in> extended_distance_set\n  extended_distance_set = {z. extended_distance z z = 0}\n\ngoal (1 subgoal):\n 1. \\<exists>x. extended_distance x x = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. extended_distance x x = 0\n\ngoal (3 subgoals):\n 1. \\<And>x y ya.\n       \\<lbrakk>extended_distance y y = 0; extended_distance x y = 0;\n        extended_distance x x = 0; extended_distance ya ya = 0;\n        extended_distance x ya = 0\\<rbrakk>\n       \\<Longrightarrow> extended_distance y ya = 0\n 2. \\<And>x y ya.\n       \\<lbrakk>extended_distance x x = 0; extended_distance x y = 0;\n        extended_distance y y = 0; extended_distance ya ya = 0;\n        extended_distance y ya = 0\\<rbrakk>\n       \\<Longrightarrow> extended_distance x ya = 0\n 3. \\<And>x y.\n       \\<lbrakk>extended_distance x x = 0; extended_distance y y = 0;\n        (\\<lambda>y.\n            extended_distance y y = 0 \\<and> extended_distance x y = 0) =\n        (\\<lambda>ya.\n            extended_distance ya ya = 0 \\<and>\n            extended_distance y ya = 0)\\<rbrakk>\n       \\<Longrightarrow> extended_distance x y = 0", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y ya.\n       \\<lbrakk>extended_distance y y = 0; extended_distance x y = 0;\n        extended_distance x x = 0; extended_distance ya ya = 0;\n        extended_distance x ya = 0\\<rbrakk>\n       \\<Longrightarrow> extended_distance y ya = 0\n 2. \\<And>x y ya.\n       \\<lbrakk>extended_distance x x = 0; extended_distance x y = 0;\n        extended_distance y y = 0; extended_distance ya ya = 0;\n        extended_distance y ya = 0\\<rbrakk>\n       \\<Longrightarrow> extended_distance x ya = 0\n 3. \\<And>x y.\n       \\<lbrakk>extended_distance x x = 0; extended_distance y y = 0;\n        (\\<lambda>y.\n            extended_distance y y = 0 \\<and> extended_distance x y = 0) =\n        (\\<lambda>ya.\n            extended_distance ya ya = 0 \\<and>\n            extended_distance y ya = 0)\\<rbrakk>\n       \\<Longrightarrow> extended_distance x y = 0", "fix x y z::\"'a Bonk_Schramm_extension_unfolded\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y ya.\n       \\<lbrakk>extended_distance y y = 0; extended_distance x y = 0;\n        extended_distance x x = 0; extended_distance ya ya = 0;\n        extended_distance x ya = 0\\<rbrakk>\n       \\<Longrightarrow> extended_distance y ya = 0\n 2. \\<And>x y ya.\n       \\<lbrakk>extended_distance x x = 0; extended_distance x y = 0;\n        extended_distance y y = 0; extended_distance ya ya = 0;\n        extended_distance y ya = 0\\<rbrakk>\n       \\<Longrightarrow> extended_distance x ya = 0\n 3. \\<And>x y.\n       \\<lbrakk>extended_distance x x = 0; extended_distance y y = 0;\n        (\\<lambda>y.\n            extended_distance y y = 0 \\<and> extended_distance x y = 0) =\n        (\\<lambda>ya.\n            extended_distance ya ya = 0 \\<and>\n            extended_distance y ya = 0)\\<rbrakk>\n       \\<Longrightarrow> extended_distance x y = 0", "assume H: \"extended_distance x x = 0\" \"extended_distance y y = 0\" \"extended_distance z z = 0\"\n            \"extended_distance x y = 0\" \"extended_distance x z = 0\""], ["proof (state)\nthis:\n  extended_distance x x = 0\n  extended_distance y y = 0\n  extended_distance z z = 0\n  extended_distance x y = 0\n  extended_distance x z = 0\n\ngoal (3 subgoals):\n 1. \\<And>x y ya.\n       \\<lbrakk>extended_distance y y = 0; extended_distance x y = 0;\n        extended_distance x x = 0; extended_distance ya ya = 0;\n        extended_distance x ya = 0\\<rbrakk>\n       \\<Longrightarrow> extended_distance y ya = 0\n 2. \\<And>x y ya.\n       \\<lbrakk>extended_distance x x = 0; extended_distance x y = 0;\n        extended_distance y y = 0; extended_distance ya ya = 0;\n        extended_distance y ya = 0\\<rbrakk>\n       \\<Longrightarrow> extended_distance x ya = 0\n 3. \\<And>x y.\n       \\<lbrakk>extended_distance x x = 0; extended_distance y y = 0;\n        (\\<lambda>y.\n            extended_distance y y = 0 \\<and> extended_distance x y = 0) =\n        (\\<lambda>ya.\n            extended_distance ya ya = 0 \\<and>\n            extended_distance y ya = 0)\\<rbrakk>\n       \\<Longrightarrow> extended_distance x y = 0", "have \"extended_distance y z \\<le> extended_distance y x + extended_distance x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance y z\n    \\<le> extended_distance y x + extended_distance x z", "apply (rule extended_distance_triang_ineq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. y \\<in> extended_distance_set\n 2. x \\<in> extended_distance_set\n 3. z \\<in> extended_distance_set", "using H"], ["proof (prove)\nusing this:\n  extended_distance x x = 0\n  extended_distance y y = 0\n  extended_distance z z = 0\n  extended_distance x y = 0\n  extended_distance x z = 0\n\ngoal (3 subgoals):\n 1. y \\<in> extended_distance_set\n 2. x \\<in> extended_distance_set\n 3. z \\<in> extended_distance_set", "unfolding extended_distance_set_def"], ["proof (prove)\nusing this:\n  extended_distance x x = 0\n  extended_distance y y = 0\n  extended_distance z z = 0\n  extended_distance x y = 0\n  extended_distance x z = 0\n\ngoal (3 subgoals):\n 1. y \\<in> {z. extended_distance z z = 0}\n 2. x \\<in> {z. extended_distance z z = 0}\n 3. z \\<in> {z. extended_distance z z = 0}", "by auto"], ["proof (state)\nthis:\n  extended_distance y z \\<le> extended_distance y x + extended_distance x z\n\ngoal (3 subgoals):\n 1. \\<And>x y ya.\n       \\<lbrakk>extended_distance y y = 0; extended_distance x y = 0;\n        extended_distance x x = 0; extended_distance ya ya = 0;\n        extended_distance x ya = 0\\<rbrakk>\n       \\<Longrightarrow> extended_distance y ya = 0\n 2. \\<And>x y ya.\n       \\<lbrakk>extended_distance x x = 0; extended_distance x y = 0;\n        extended_distance y y = 0; extended_distance ya ya = 0;\n        extended_distance y ya = 0\\<rbrakk>\n       \\<Longrightarrow> extended_distance x ya = 0\n 3. \\<And>x y.\n       \\<lbrakk>extended_distance x x = 0; extended_distance y y = 0;\n        (\\<lambda>y.\n            extended_distance y y = 0 \\<and> extended_distance x y = 0) =\n        (\\<lambda>ya.\n            extended_distance ya ya = 0 \\<and>\n            extended_distance y ya = 0)\\<rbrakk>\n       \\<Longrightarrow> extended_distance x y = 0", "also"], ["proof (state)\nthis:\n  extended_distance y z \\<le> extended_distance y x + extended_distance x z\n\ngoal (3 subgoals):\n 1. \\<And>x y ya.\n       \\<lbrakk>extended_distance y y = 0; extended_distance x y = 0;\n        extended_distance x x = 0; extended_distance ya ya = 0;\n        extended_distance x ya = 0\\<rbrakk>\n       \\<Longrightarrow> extended_distance y ya = 0\n 2. \\<And>x y ya.\n       \\<lbrakk>extended_distance x x = 0; extended_distance x y = 0;\n        extended_distance y y = 0; extended_distance ya ya = 0;\n        extended_distance y ya = 0\\<rbrakk>\n       \\<Longrightarrow> extended_distance x ya = 0\n 3. \\<And>x y.\n       \\<lbrakk>extended_distance x x = 0; extended_distance y y = 0;\n        (\\<lambda>y.\n            extended_distance y y = 0 \\<and> extended_distance x y = 0) =\n        (\\<lambda>ya.\n            extended_distance ya ya = 0 \\<and>\n            extended_distance y ya = 0)\\<rbrakk>\n       \\<Longrightarrow> extended_distance x y = 0", "have \"... \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance y x + extended_distance x z \\<le> 0", "by (auto simp add: extended_distance_symmetric H)"], ["proof (state)\nthis:\n  extended_distance y x + extended_distance x z \\<le> 0\n\ngoal (3 subgoals):\n 1. \\<And>x y ya.\n       \\<lbrakk>extended_distance y y = 0; extended_distance x y = 0;\n        extended_distance x x = 0; extended_distance ya ya = 0;\n        extended_distance x ya = 0\\<rbrakk>\n       \\<Longrightarrow> extended_distance y ya = 0\n 2. \\<And>x y ya.\n       \\<lbrakk>extended_distance x x = 0; extended_distance x y = 0;\n        extended_distance y y = 0; extended_distance ya ya = 0;\n        extended_distance y ya = 0\\<rbrakk>\n       \\<Longrightarrow> extended_distance x ya = 0\n 3. \\<And>x y.\n       \\<lbrakk>extended_distance x x = 0; extended_distance y y = 0;\n        (\\<lambda>y.\n            extended_distance y y = 0 \\<and> extended_distance x y = 0) =\n        (\\<lambda>ya.\n            extended_distance ya ya = 0 \\<and>\n            extended_distance y ya = 0)\\<rbrakk>\n       \\<Longrightarrow> extended_distance x y = 0", "finally"], ["proof (chain)\npicking this:\n  extended_distance y z \\<le> 0", "show \"extended_distance y z = 0\""], ["proof (prove)\nusing this:\n  extended_distance y z \\<le> 0\n\ngoal (1 subgoal):\n 1. extended_distance y z = 0", "using extended_distance_pos[of y z] H"], ["proof (prove)\nusing this:\n  extended_distance y z \\<le> 0\n  \\<lbrakk>y \\<in> extended_distance_set;\n   z \\<in> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> extended_distance y z\n  extended_distance x x = 0\n  extended_distance y y = 0\n  extended_distance z z = 0\n  extended_distance x y = 0\n  extended_distance x z = 0\n\ngoal (1 subgoal):\n 1. extended_distance y z = 0", "unfolding extended_distance_set_def"], ["proof (prove)\nusing this:\n  extended_distance y z \\<le> 0\n  \\<lbrakk>y \\<in> {z. extended_distance z z = 0};\n   z \\<in> {z. extended_distance z z = 0}\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> extended_distance y z\n  extended_distance x x = 0\n  extended_distance y y = 0\n  extended_distance z z = 0\n  extended_distance x y = 0\n  extended_distance x z = 0\n\ngoal (1 subgoal):\n 1. extended_distance y z = 0", "by auto"], ["proof (state)\nthis:\n  extended_distance y z = 0\n\ngoal (2 subgoals):\n 1. \\<And>x y ya.\n       \\<lbrakk>extended_distance x x = 0; extended_distance x y = 0;\n        extended_distance y y = 0; extended_distance ya ya = 0;\n        extended_distance y ya = 0\\<rbrakk>\n       \\<Longrightarrow> extended_distance x ya = 0\n 2. \\<And>x y.\n       \\<lbrakk>extended_distance x x = 0; extended_distance y y = 0;\n        (\\<lambda>y.\n            extended_distance y y = 0 \\<and> extended_distance x y = 0) =\n        (\\<lambda>ya.\n            extended_distance ya ya = 0 \\<and>\n            extended_distance y ya = 0)\\<rbrakk>\n       \\<Longrightarrow> extended_distance x y = 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y ya.\n       \\<lbrakk>extended_distance x x = 0; extended_distance x y = 0;\n        extended_distance y y = 0; extended_distance ya ya = 0;\n        extended_distance y ya = 0\\<rbrakk>\n       \\<Longrightarrow> extended_distance x ya = 0\n 2. \\<And>x y.\n       \\<lbrakk>extended_distance x x = 0; extended_distance y y = 0;\n        (\\<lambda>y.\n            extended_distance y y = 0 \\<and> extended_distance x y = 0) =\n        (\\<lambda>ya.\n            extended_distance ya ya = 0 \\<and>\n            extended_distance y ya = 0)\\<rbrakk>\n       \\<Longrightarrow> extended_distance x y = 0", "fix x y z::\"'a Bonk_Schramm_extension_unfolded\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y ya.\n       \\<lbrakk>extended_distance x x = 0; extended_distance x y = 0;\n        extended_distance y y = 0; extended_distance ya ya = 0;\n        extended_distance y ya = 0\\<rbrakk>\n       \\<Longrightarrow> extended_distance x ya = 0\n 2. \\<And>x y.\n       \\<lbrakk>extended_distance x x = 0; extended_distance y y = 0;\n        (\\<lambda>y.\n            extended_distance y y = 0 \\<and> extended_distance x y = 0) =\n        (\\<lambda>ya.\n            extended_distance ya ya = 0 \\<and>\n            extended_distance y ya = 0)\\<rbrakk>\n       \\<Longrightarrow> extended_distance x y = 0", "assume H: \"extended_distance x x = 0\" \"extended_distance y y = 0\" \"extended_distance z z = 0\"\n            \"extended_distance x y = 0\" \"extended_distance y z = 0\""], ["proof (state)\nthis:\n  extended_distance x x = 0\n  extended_distance y y = 0\n  extended_distance z z = 0\n  extended_distance x y = 0\n  extended_distance y z = 0\n\ngoal (2 subgoals):\n 1. \\<And>x y ya.\n       \\<lbrakk>extended_distance x x = 0; extended_distance x y = 0;\n        extended_distance y y = 0; extended_distance ya ya = 0;\n        extended_distance y ya = 0\\<rbrakk>\n       \\<Longrightarrow> extended_distance x ya = 0\n 2. \\<And>x y.\n       \\<lbrakk>extended_distance x x = 0; extended_distance y y = 0;\n        (\\<lambda>y.\n            extended_distance y y = 0 \\<and> extended_distance x y = 0) =\n        (\\<lambda>ya.\n            extended_distance ya ya = 0 \\<and>\n            extended_distance y ya = 0)\\<rbrakk>\n       \\<Longrightarrow> extended_distance x y = 0", "have \"extended_distance x z \\<le> extended_distance x y + extended_distance y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x y + extended_distance y z", "apply (rule extended_distance_triang_ineq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<in> extended_distance_set\n 2. y \\<in> extended_distance_set\n 3. z \\<in> extended_distance_set", "using H"], ["proof (prove)\nusing this:\n  extended_distance x x = 0\n  extended_distance y y = 0\n  extended_distance z z = 0\n  extended_distance x y = 0\n  extended_distance y z = 0\n\ngoal (3 subgoals):\n 1. x \\<in> extended_distance_set\n 2. y \\<in> extended_distance_set\n 3. z \\<in> extended_distance_set", "unfolding extended_distance_set_def"], ["proof (prove)\nusing this:\n  extended_distance x x = 0\n  extended_distance y y = 0\n  extended_distance z z = 0\n  extended_distance x y = 0\n  extended_distance y z = 0\n\ngoal (3 subgoals):\n 1. x \\<in> {z. extended_distance z z = 0}\n 2. y \\<in> {z. extended_distance z z = 0}\n 3. z \\<in> {z. extended_distance z z = 0}", "by auto"], ["proof (state)\nthis:\n  extended_distance x z \\<le> extended_distance x y + extended_distance y z\n\ngoal (2 subgoals):\n 1. \\<And>x y ya.\n       \\<lbrakk>extended_distance x x = 0; extended_distance x y = 0;\n        extended_distance y y = 0; extended_distance ya ya = 0;\n        extended_distance y ya = 0\\<rbrakk>\n       \\<Longrightarrow> extended_distance x ya = 0\n 2. \\<And>x y.\n       \\<lbrakk>extended_distance x x = 0; extended_distance y y = 0;\n        (\\<lambda>y.\n            extended_distance y y = 0 \\<and> extended_distance x y = 0) =\n        (\\<lambda>ya.\n            extended_distance ya ya = 0 \\<and>\n            extended_distance y ya = 0)\\<rbrakk>\n       \\<Longrightarrow> extended_distance x y = 0", "also"], ["proof (state)\nthis:\n  extended_distance x z \\<le> extended_distance x y + extended_distance y z\n\ngoal (2 subgoals):\n 1. \\<And>x y ya.\n       \\<lbrakk>extended_distance x x = 0; extended_distance x y = 0;\n        extended_distance y y = 0; extended_distance ya ya = 0;\n        extended_distance y ya = 0\\<rbrakk>\n       \\<Longrightarrow> extended_distance x ya = 0\n 2. \\<And>x y.\n       \\<lbrakk>extended_distance x x = 0; extended_distance y y = 0;\n        (\\<lambda>y.\n            extended_distance y y = 0 \\<and> extended_distance x y = 0) =\n        (\\<lambda>ya.\n            extended_distance ya ya = 0 \\<and>\n            extended_distance y ya = 0)\\<rbrakk>\n       \\<Longrightarrow> extended_distance x y = 0", "have \"... \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance x y + extended_distance y z \\<le> 0", "by (auto simp add: extended_distance_symmetric H)"], ["proof (state)\nthis:\n  extended_distance x y + extended_distance y z \\<le> 0\n\ngoal (2 subgoals):\n 1. \\<And>x y ya.\n       \\<lbrakk>extended_distance x x = 0; extended_distance x y = 0;\n        extended_distance y y = 0; extended_distance ya ya = 0;\n        extended_distance y ya = 0\\<rbrakk>\n       \\<Longrightarrow> extended_distance x ya = 0\n 2. \\<And>x y.\n       \\<lbrakk>extended_distance x x = 0; extended_distance y y = 0;\n        (\\<lambda>y.\n            extended_distance y y = 0 \\<and> extended_distance x y = 0) =\n        (\\<lambda>ya.\n            extended_distance ya ya = 0 \\<and>\n            extended_distance y ya = 0)\\<rbrakk>\n       \\<Longrightarrow> extended_distance x y = 0", "finally"], ["proof (chain)\npicking this:\n  extended_distance x z \\<le> 0", "show \"extended_distance x z = 0\""], ["proof (prove)\nusing this:\n  extended_distance x z \\<le> 0\n\ngoal (1 subgoal):\n 1. extended_distance x z = 0", "using extended_distance_pos[of x z] H"], ["proof (prove)\nusing this:\n  extended_distance x z \\<le> 0\n  \\<lbrakk>x \\<in> extended_distance_set;\n   z \\<in> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> extended_distance x z\n  extended_distance x x = 0\n  extended_distance y y = 0\n  extended_distance z z = 0\n  extended_distance x y = 0\n  extended_distance y z = 0\n\ngoal (1 subgoal):\n 1. extended_distance x z = 0", "unfolding extended_distance_set_def"], ["proof (prove)\nusing this:\n  extended_distance x z \\<le> 0\n  \\<lbrakk>x \\<in> {z. extended_distance z z = 0};\n   z \\<in> {z. extended_distance z z = 0}\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> extended_distance x z\n  extended_distance x x = 0\n  extended_distance y y = 0\n  extended_distance z z = 0\n  extended_distance x y = 0\n  extended_distance y z = 0\n\ngoal (1 subgoal):\n 1. extended_distance x z = 0", "by auto"], ["proof (state)\nthis:\n  extended_distance x z = 0\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>extended_distance x x = 0; extended_distance y y = 0;\n        (\\<lambda>y.\n            extended_distance y y = 0 \\<and> extended_distance x y = 0) =\n        (\\<lambda>ya.\n            extended_distance ya ya = 0 \\<and>\n            extended_distance y ya = 0)\\<rbrakk>\n       \\<Longrightarrow> extended_distance x y = 0", "qed (metis)"], ["", "instantiation Bonk_Schramm_extension :: (metric_space) metric_space\nbegin"], ["", "lift_definition dist_Bonk_Schramm_extension::\"('a::metric_space) Bonk_Schramm_extension \\<Rightarrow> 'a Bonk_Schramm_extension \\<Rightarrow> real\"\n  is \"\\<lambda>x y. extended_distance x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Bonk_Schramm_extension_unfolded1 Bonk_Schramm_extension_unfolded2\n       Bonk_Schramm_extension_unfolded3 Bonk_Schramm_extension_unfolded4.\n       \\<lbrakk>Bonk_Schramm_extension_unfolded1\n                \\<in> extended_distance_set \\<and>\n                Bonk_Schramm_extension_unfolded2\n                \\<in> extended_distance_set \\<and>\n                extended_distance Bonk_Schramm_extension_unfolded1\n                 Bonk_Schramm_extension_unfolded2 =\n                0;\n        Bonk_Schramm_extension_unfolded3 \\<in> extended_distance_set \\<and>\n        Bonk_Schramm_extension_unfolded4 \\<in> extended_distance_set \\<and>\n        extended_distance Bonk_Schramm_extension_unfolded3\n         Bonk_Schramm_extension_unfolded4 =\n        0\\<rbrakk>\n       \\<Longrightarrow> extended_distance Bonk_Schramm_extension_unfolded1\n                          Bonk_Schramm_extension_unfolded3 =\n                         extended_distance Bonk_Schramm_extension_unfolded2\n                          Bonk_Schramm_extension_unfolded4", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Bonk_Schramm_extension_unfolded1 Bonk_Schramm_extension_unfolded2\n       Bonk_Schramm_extension_unfolded3 Bonk_Schramm_extension_unfolded4.\n       \\<lbrakk>Bonk_Schramm_extension_unfolded1\n                \\<in> extended_distance_set \\<and>\n                Bonk_Schramm_extension_unfolded2\n                \\<in> extended_distance_set \\<and>\n                extended_distance Bonk_Schramm_extension_unfolded1\n                 Bonk_Schramm_extension_unfolded2 =\n                0;\n        Bonk_Schramm_extension_unfolded3 \\<in> extended_distance_set \\<and>\n        Bonk_Schramm_extension_unfolded4 \\<in> extended_distance_set \\<and>\n        extended_distance Bonk_Schramm_extension_unfolded3\n         Bonk_Schramm_extension_unfolded4 =\n        0\\<rbrakk>\n       \\<Longrightarrow> extended_distance Bonk_Schramm_extension_unfolded1\n                          Bonk_Schramm_extension_unfolded3 =\n                         extended_distance Bonk_Schramm_extension_unfolded2\n                          Bonk_Schramm_extension_unfolded4", "fix x y z t::\"'a Bonk_Schramm_extension_unfolded\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Bonk_Schramm_extension_unfolded1 Bonk_Schramm_extension_unfolded2\n       Bonk_Schramm_extension_unfolded3 Bonk_Schramm_extension_unfolded4.\n       \\<lbrakk>Bonk_Schramm_extension_unfolded1\n                \\<in> extended_distance_set \\<and>\n                Bonk_Schramm_extension_unfolded2\n                \\<in> extended_distance_set \\<and>\n                extended_distance Bonk_Schramm_extension_unfolded1\n                 Bonk_Schramm_extension_unfolded2 =\n                0;\n        Bonk_Schramm_extension_unfolded3 \\<in> extended_distance_set \\<and>\n        Bonk_Schramm_extension_unfolded4 \\<in> extended_distance_set \\<and>\n        extended_distance Bonk_Schramm_extension_unfolded3\n         Bonk_Schramm_extension_unfolded4 =\n        0\\<rbrakk>\n       \\<Longrightarrow> extended_distance Bonk_Schramm_extension_unfolded1\n                          Bonk_Schramm_extension_unfolded3 =\n                         extended_distance Bonk_Schramm_extension_unfolded2\n                          Bonk_Schramm_extension_unfolded4", "assume H: \"x \\<in> extended_distance_set \\<and> y \\<in> extended_distance_set \\<and> extended_distance x y = 0\"\n            \"z \\<in> extended_distance_set \\<and> t \\<in> extended_distance_set \\<and> extended_distance z t = 0\""], ["proof (state)\nthis:\n  x \\<in> extended_distance_set \\<and>\n  y \\<in> extended_distance_set \\<and> extended_distance x y = 0\n  z \\<in> extended_distance_set \\<and>\n  t \\<in> extended_distance_set \\<and> extended_distance z t = 0\n\ngoal (1 subgoal):\n 1. \\<And>Bonk_Schramm_extension_unfolded1 Bonk_Schramm_extension_unfolded2\n       Bonk_Schramm_extension_unfolded3 Bonk_Schramm_extension_unfolded4.\n       \\<lbrakk>Bonk_Schramm_extension_unfolded1\n                \\<in> extended_distance_set \\<and>\n                Bonk_Schramm_extension_unfolded2\n                \\<in> extended_distance_set \\<and>\n                extended_distance Bonk_Schramm_extension_unfolded1\n                 Bonk_Schramm_extension_unfolded2 =\n                0;\n        Bonk_Schramm_extension_unfolded3 \\<in> extended_distance_set \\<and>\n        Bonk_Schramm_extension_unfolded4 \\<in> extended_distance_set \\<and>\n        extended_distance Bonk_Schramm_extension_unfolded3\n         Bonk_Schramm_extension_unfolded4 =\n        0\\<rbrakk>\n       \\<Longrightarrow> extended_distance Bonk_Schramm_extension_unfolded1\n                          Bonk_Schramm_extension_unfolded3 =\n                         extended_distance Bonk_Schramm_extension_unfolded2\n                          Bonk_Schramm_extension_unfolded4", "have \"extended_distance x z \\<le> extended_distance x y + extended_distance y t + extended_distance t z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x y + extended_distance y t +\n          extended_distance t z", "using extended_distance_triang_ineq[of x y z] extended_distance_triang_ineq[of y t z] H"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> extended_distance_set; y \\<in> extended_distance_set;\n   z \\<in> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance x z\n                    \\<le> extended_distance x y + extended_distance y z\n  \\<lbrakk>y \\<in> extended_distance_set; t \\<in> extended_distance_set;\n   z \\<in> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance y z\n                    \\<le> extended_distance y t + extended_distance t z\n  x \\<in> extended_distance_set \\<and>\n  y \\<in> extended_distance_set \\<and> extended_distance x y = 0\n  z \\<in> extended_distance_set \\<and>\n  t \\<in> extended_distance_set \\<and> extended_distance z t = 0\n\ngoal (1 subgoal):\n 1. extended_distance x z\n    \\<le> extended_distance x y + extended_distance y t +\n          extended_distance t z", "by auto"], ["proof (state)\nthis:\n  extended_distance x z\n  \\<le> extended_distance x y + extended_distance y t +\n        extended_distance t z\n\ngoal (1 subgoal):\n 1. \\<And>Bonk_Schramm_extension_unfolded1 Bonk_Schramm_extension_unfolded2\n       Bonk_Schramm_extension_unfolded3 Bonk_Schramm_extension_unfolded4.\n       \\<lbrakk>Bonk_Schramm_extension_unfolded1\n                \\<in> extended_distance_set \\<and>\n                Bonk_Schramm_extension_unfolded2\n                \\<in> extended_distance_set \\<and>\n                extended_distance Bonk_Schramm_extension_unfolded1\n                 Bonk_Schramm_extension_unfolded2 =\n                0;\n        Bonk_Schramm_extension_unfolded3 \\<in> extended_distance_set \\<and>\n        Bonk_Schramm_extension_unfolded4 \\<in> extended_distance_set \\<and>\n        extended_distance Bonk_Schramm_extension_unfolded3\n         Bonk_Schramm_extension_unfolded4 =\n        0\\<rbrakk>\n       \\<Longrightarrow> extended_distance Bonk_Schramm_extension_unfolded1\n                          Bonk_Schramm_extension_unfolded3 =\n                         extended_distance Bonk_Schramm_extension_unfolded2\n                          Bonk_Schramm_extension_unfolded4", "also"], ["proof (state)\nthis:\n  extended_distance x z\n  \\<le> extended_distance x y + extended_distance y t +\n        extended_distance t z\n\ngoal (1 subgoal):\n 1. \\<And>Bonk_Schramm_extension_unfolded1 Bonk_Schramm_extension_unfolded2\n       Bonk_Schramm_extension_unfolded3 Bonk_Schramm_extension_unfolded4.\n       \\<lbrakk>Bonk_Schramm_extension_unfolded1\n                \\<in> extended_distance_set \\<and>\n                Bonk_Schramm_extension_unfolded2\n                \\<in> extended_distance_set \\<and>\n                extended_distance Bonk_Schramm_extension_unfolded1\n                 Bonk_Schramm_extension_unfolded2 =\n                0;\n        Bonk_Schramm_extension_unfolded3 \\<in> extended_distance_set \\<and>\n        Bonk_Schramm_extension_unfolded4 \\<in> extended_distance_set \\<and>\n        extended_distance Bonk_Schramm_extension_unfolded3\n         Bonk_Schramm_extension_unfolded4 =\n        0\\<rbrakk>\n       \\<Longrightarrow> extended_distance Bonk_Schramm_extension_unfolded1\n                          Bonk_Schramm_extension_unfolded3 =\n                         extended_distance Bonk_Schramm_extension_unfolded2\n                          Bonk_Schramm_extension_unfolded4", "have \"... = extended_distance y t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance x y + extended_distance y t + extended_distance t z =\n    extended_distance y t", "using H"], ["proof (prove)\nusing this:\n  x \\<in> extended_distance_set \\<and>\n  y \\<in> extended_distance_set \\<and> extended_distance x y = 0\n  z \\<in> extended_distance_set \\<and>\n  t \\<in> extended_distance_set \\<and> extended_distance z t = 0\n\ngoal (1 subgoal):\n 1. extended_distance x y + extended_distance y t + extended_distance t z =\n    extended_distance y t", "by (auto simp add: extended_distance_symmetric)"], ["proof (state)\nthis:\n  extended_distance x y + extended_distance y t + extended_distance t z =\n  extended_distance y t\n\ngoal (1 subgoal):\n 1. \\<And>Bonk_Schramm_extension_unfolded1 Bonk_Schramm_extension_unfolded2\n       Bonk_Schramm_extension_unfolded3 Bonk_Schramm_extension_unfolded4.\n       \\<lbrakk>Bonk_Schramm_extension_unfolded1\n                \\<in> extended_distance_set \\<and>\n                Bonk_Schramm_extension_unfolded2\n                \\<in> extended_distance_set \\<and>\n                extended_distance Bonk_Schramm_extension_unfolded1\n                 Bonk_Schramm_extension_unfolded2 =\n                0;\n        Bonk_Schramm_extension_unfolded3 \\<in> extended_distance_set \\<and>\n        Bonk_Schramm_extension_unfolded4 \\<in> extended_distance_set \\<and>\n        extended_distance Bonk_Schramm_extension_unfolded3\n         Bonk_Schramm_extension_unfolded4 =\n        0\\<rbrakk>\n       \\<Longrightarrow> extended_distance Bonk_Schramm_extension_unfolded1\n                          Bonk_Schramm_extension_unfolded3 =\n                         extended_distance Bonk_Schramm_extension_unfolded2\n                          Bonk_Schramm_extension_unfolded4", "finally"], ["proof (chain)\npicking this:\n  extended_distance x z \\<le> extended_distance y t", "have *: \"extended_distance x z \\<le> extended_distance y t\""], ["proof (prove)\nusing this:\n  extended_distance x z \\<le> extended_distance y t\n\ngoal (1 subgoal):\n 1. extended_distance x z \\<le> extended_distance y t", "by simp"], ["proof (state)\nthis:\n  extended_distance x z \\<le> extended_distance y t\n\ngoal (1 subgoal):\n 1. \\<And>Bonk_Schramm_extension_unfolded1 Bonk_Schramm_extension_unfolded2\n       Bonk_Schramm_extension_unfolded3 Bonk_Schramm_extension_unfolded4.\n       \\<lbrakk>Bonk_Schramm_extension_unfolded1\n                \\<in> extended_distance_set \\<and>\n                Bonk_Schramm_extension_unfolded2\n                \\<in> extended_distance_set \\<and>\n                extended_distance Bonk_Schramm_extension_unfolded1\n                 Bonk_Schramm_extension_unfolded2 =\n                0;\n        Bonk_Schramm_extension_unfolded3 \\<in> extended_distance_set \\<and>\n        Bonk_Schramm_extension_unfolded4 \\<in> extended_distance_set \\<and>\n        extended_distance Bonk_Schramm_extension_unfolded3\n         Bonk_Schramm_extension_unfolded4 =\n        0\\<rbrakk>\n       \\<Longrightarrow> extended_distance Bonk_Schramm_extension_unfolded1\n                          Bonk_Schramm_extension_unfolded3 =\n                         extended_distance Bonk_Schramm_extension_unfolded2\n                          Bonk_Schramm_extension_unfolded4", "have \"extended_distance y t \\<le> extended_distance y x + extended_distance x z + extended_distance z t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance y t\n    \\<le> extended_distance y x + extended_distance x z +\n          extended_distance z t", "using extended_distance_triang_ineq[of y x t] extended_distance_triang_ineq[of x z t] H"], ["proof (prove)\nusing this:\n  \\<lbrakk>y \\<in> extended_distance_set; x \\<in> extended_distance_set;\n   t \\<in> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance y t\n                    \\<le> extended_distance y x + extended_distance x t\n  \\<lbrakk>x \\<in> extended_distance_set; z \\<in> extended_distance_set;\n   t \\<in> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance x t\n                    \\<le> extended_distance x z + extended_distance z t\n  x \\<in> extended_distance_set \\<and>\n  y \\<in> extended_distance_set \\<and> extended_distance x y = 0\n  z \\<in> extended_distance_set \\<and>\n  t \\<in> extended_distance_set \\<and> extended_distance z t = 0\n\ngoal (1 subgoal):\n 1. extended_distance y t\n    \\<le> extended_distance y x + extended_distance x z +\n          extended_distance z t", "by auto"], ["proof (state)\nthis:\n  extended_distance y t\n  \\<le> extended_distance y x + extended_distance x z +\n        extended_distance z t\n\ngoal (1 subgoal):\n 1. \\<And>Bonk_Schramm_extension_unfolded1 Bonk_Schramm_extension_unfolded2\n       Bonk_Schramm_extension_unfolded3 Bonk_Schramm_extension_unfolded4.\n       \\<lbrakk>Bonk_Schramm_extension_unfolded1\n                \\<in> extended_distance_set \\<and>\n                Bonk_Schramm_extension_unfolded2\n                \\<in> extended_distance_set \\<and>\n                extended_distance Bonk_Schramm_extension_unfolded1\n                 Bonk_Schramm_extension_unfolded2 =\n                0;\n        Bonk_Schramm_extension_unfolded3 \\<in> extended_distance_set \\<and>\n        Bonk_Schramm_extension_unfolded4 \\<in> extended_distance_set \\<and>\n        extended_distance Bonk_Schramm_extension_unfolded3\n         Bonk_Schramm_extension_unfolded4 =\n        0\\<rbrakk>\n       \\<Longrightarrow> extended_distance Bonk_Schramm_extension_unfolded1\n                          Bonk_Schramm_extension_unfolded3 =\n                         extended_distance Bonk_Schramm_extension_unfolded2\n                          Bonk_Schramm_extension_unfolded4", "also"], ["proof (state)\nthis:\n  extended_distance y t\n  \\<le> extended_distance y x + extended_distance x z +\n        extended_distance z t\n\ngoal (1 subgoal):\n 1. \\<And>Bonk_Schramm_extension_unfolded1 Bonk_Schramm_extension_unfolded2\n       Bonk_Schramm_extension_unfolded3 Bonk_Schramm_extension_unfolded4.\n       \\<lbrakk>Bonk_Schramm_extension_unfolded1\n                \\<in> extended_distance_set \\<and>\n                Bonk_Schramm_extension_unfolded2\n                \\<in> extended_distance_set \\<and>\n                extended_distance Bonk_Schramm_extension_unfolded1\n                 Bonk_Schramm_extension_unfolded2 =\n                0;\n        Bonk_Schramm_extension_unfolded3 \\<in> extended_distance_set \\<and>\n        Bonk_Schramm_extension_unfolded4 \\<in> extended_distance_set \\<and>\n        extended_distance Bonk_Schramm_extension_unfolded3\n         Bonk_Schramm_extension_unfolded4 =\n        0\\<rbrakk>\n       \\<Longrightarrow> extended_distance Bonk_Schramm_extension_unfolded1\n                          Bonk_Schramm_extension_unfolded3 =\n                         extended_distance Bonk_Schramm_extension_unfolded2\n                          Bonk_Schramm_extension_unfolded4", "have \"... = extended_distance x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance y x + extended_distance x z + extended_distance z t =\n    extended_distance x z", "using H"], ["proof (prove)\nusing this:\n  x \\<in> extended_distance_set \\<and>\n  y \\<in> extended_distance_set \\<and> extended_distance x y = 0\n  z \\<in> extended_distance_set \\<and>\n  t \\<in> extended_distance_set \\<and> extended_distance z t = 0\n\ngoal (1 subgoal):\n 1. extended_distance y x + extended_distance x z + extended_distance z t =\n    extended_distance x z", "by (auto simp add: extended_distance_symmetric)"], ["proof (state)\nthis:\n  extended_distance y x + extended_distance x z + extended_distance z t =\n  extended_distance x z\n\ngoal (1 subgoal):\n 1. \\<And>Bonk_Schramm_extension_unfolded1 Bonk_Schramm_extension_unfolded2\n       Bonk_Schramm_extension_unfolded3 Bonk_Schramm_extension_unfolded4.\n       \\<lbrakk>Bonk_Schramm_extension_unfolded1\n                \\<in> extended_distance_set \\<and>\n                Bonk_Schramm_extension_unfolded2\n                \\<in> extended_distance_set \\<and>\n                extended_distance Bonk_Schramm_extension_unfolded1\n                 Bonk_Schramm_extension_unfolded2 =\n                0;\n        Bonk_Schramm_extension_unfolded3 \\<in> extended_distance_set \\<and>\n        Bonk_Schramm_extension_unfolded4 \\<in> extended_distance_set \\<and>\n        extended_distance Bonk_Schramm_extension_unfolded3\n         Bonk_Schramm_extension_unfolded4 =\n        0\\<rbrakk>\n       \\<Longrightarrow> extended_distance Bonk_Schramm_extension_unfolded1\n                          Bonk_Schramm_extension_unfolded3 =\n                         extended_distance Bonk_Schramm_extension_unfolded2\n                          Bonk_Schramm_extension_unfolded4", "finally"], ["proof (chain)\npicking this:\n  extended_distance y t \\<le> extended_distance x z", "show \"extended_distance x z = extended_distance y t\""], ["proof (prove)\nusing this:\n  extended_distance y t \\<le> extended_distance x z\n\ngoal (1 subgoal):\n 1. extended_distance x z = extended_distance y t", "using *"], ["proof (prove)\nusing this:\n  extended_distance y t \\<le> extended_distance x z\n  extended_distance x z \\<le> extended_distance y t\n\ngoal (1 subgoal):\n 1. extended_distance x z = extended_distance y t", "by simp"], ["proof (state)\nthis:\n  extended_distance x z = extended_distance y t\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>To define a metric space in the current library of Isabelle/HOL, one should also introduce\na uniformity structure and a topology, as follows (they are prescribed by the distance):\\<close>"], ["", "definition uniformity_Bonk_Schramm_extension::\"(('a Bonk_Schramm_extension) \\<times> ('a Bonk_Schramm_extension)) filter\"\n  where \"uniformity_Bonk_Schramm_extension = (INF e\\<in>{0 <..}. principal {(x, y). dist x y < e})\""], ["", "definition open_Bonk_Schramm_extension :: \"'a Bonk_Schramm_extension set \\<Rightarrow> bool\"\n  where \"open_Bonk_Schramm_extension U = (\\<forall>x\\<in>U. eventually (\\<lambda>(x', y). x' = x \\<longrightarrow> y \\<in> U) uniformity)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a Bonk_Schramm_extension, metric_space_class)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 2. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 3. \\<And>x y. (dist x y = 0) = (x = y)\n 4. \\<And>x y z. dist x y \\<le> dist x z + dist y z", "fix x y::\"'a Bonk_Schramm_extension\""], ["proof (state)\ngoal (4 subgoals):\n 1. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 2. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 3. \\<And>x y. (dist x y = 0) = (x = y)\n 4. \\<And>x y z. dist x y \\<le> dist x z + dist y z", "have C: \"rep_Bonk_Schramm_extension x \\<in> extended_distance_set\"\n          \"rep_Bonk_Schramm_extension y \\<in> extended_distance_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_Bonk_Schramm_extension x \\<in> extended_distance_set &&&\n    rep_Bonk_Schramm_extension y \\<in> extended_distance_set", "using Quotient3_Bonk_Schramm_extension Quotient3_rep_reflp"], ["proof (prove)\nusing this:\n  Quotient3\n   (\\<lambda>x y.\n       x \\<in> extended_distance_set \\<and>\n       y \\<in> extended_distance_set \\<and> extended_distance x y = 0)\n   abs_Bonk_Schramm_extension rep_Bonk_Schramm_extension\n  Quotient3 ?R ?Abs ?Rep \\<Longrightarrow> ?R (?Rep ?a) (?Rep ?a)\n\ngoal (1 subgoal):\n 1. rep_Bonk_Schramm_extension x \\<in> extended_distance_set &&&\n    rep_Bonk_Schramm_extension y \\<in> extended_distance_set", "by fastforce+"], ["proof (state)\nthis:\n  rep_Bonk_Schramm_extension x \\<in> extended_distance_set\n  rep_Bonk_Schramm_extension y \\<in> extended_distance_set\n\ngoal (4 subgoals):\n 1. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 2. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 3. \\<And>x y. (dist x y = 0) = (x = y)\n 4. \\<And>x y z. dist x y \\<le> dist x z + dist y z", "show \"(dist x y = 0) = (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dist x y = 0) = (x = y)", "apply (subst Quotient3_rel_rep[OF Quotient3_Bonk_Schramm_extension, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (dist x y = 0) =\n    (rep_Bonk_Schramm_extension x \\<in> extended_distance_set \\<and>\n     rep_Bonk_Schramm_extension y \\<in> extended_distance_set \\<and>\n     extended_distance (rep_Bonk_Schramm_extension x)\n      (rep_Bonk_Schramm_extension y) =\n     0)", "unfolding dist_Bonk_Schramm_extension_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_fun rep_Bonk_Schramm_extension\n      (map_fun rep_Bonk_Schramm_extension id) extended_distance x y =\n     0) =\n    (rep_Bonk_Schramm_extension x \\<in> extended_distance_set \\<and>\n     rep_Bonk_Schramm_extension y \\<in> extended_distance_set \\<and>\n     extended_distance (rep_Bonk_Schramm_extension x)\n      (rep_Bonk_Schramm_extension y) =\n     0)", "using C"], ["proof (prove)\nusing this:\n  rep_Bonk_Schramm_extension x \\<in> extended_distance_set\n  rep_Bonk_Schramm_extension y \\<in> extended_distance_set\n\ngoal (1 subgoal):\n 1. (map_fun rep_Bonk_Schramm_extension\n      (map_fun rep_Bonk_Schramm_extension id) extended_distance x y =\n     0) =\n    (rep_Bonk_Schramm_extension x \\<in> extended_distance_set \\<and>\n     rep_Bonk_Schramm_extension y \\<in> extended_distance_set \\<and>\n     extended_distance (rep_Bonk_Schramm_extension x)\n      (rep_Bonk_Schramm_extension y) =\n     0)", "by auto"], ["proof (state)\nthis:\n  (dist x y = 0) = (x = y)\n\ngoal (3 subgoals):\n 1. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 2. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 3. \\<And>x y z. dist x y \\<le> dist x z + dist y z", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 2. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 3. \\<And>x y z. dist x y \\<le> dist x z + dist y z", "fix x y z::\"'a Bonk_Schramm_extension\""], ["proof (state)\ngoal (3 subgoals):\n 1. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 2. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 3. \\<And>x y z. dist x y \\<le> dist x z + dist y z", "have C: \"rep_Bonk_Schramm_extension x \\<in> extended_distance_set\"\n          \"rep_Bonk_Schramm_extension y \\<in> extended_distance_set\"\n          \"rep_Bonk_Schramm_extension z \\<in> extended_distance_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_Bonk_Schramm_extension x \\<in> extended_distance_set &&&\n    rep_Bonk_Schramm_extension y \\<in> extended_distance_set &&&\n    rep_Bonk_Schramm_extension z \\<in> extended_distance_set", "using Quotient3_Bonk_Schramm_extension Quotient3_rep_reflp"], ["proof (prove)\nusing this:\n  Quotient3\n   (\\<lambda>x y.\n       x \\<in> extended_distance_set \\<and>\n       y \\<in> extended_distance_set \\<and> extended_distance x y = 0)\n   abs_Bonk_Schramm_extension rep_Bonk_Schramm_extension\n  Quotient3 ?R ?Abs ?Rep \\<Longrightarrow> ?R (?Rep ?a) (?Rep ?a)\n\ngoal (1 subgoal):\n 1. rep_Bonk_Schramm_extension x \\<in> extended_distance_set &&&\n    rep_Bonk_Schramm_extension y \\<in> extended_distance_set &&&\n    rep_Bonk_Schramm_extension z \\<in> extended_distance_set", "by fastforce+"], ["proof (state)\nthis:\n  rep_Bonk_Schramm_extension x \\<in> extended_distance_set\n  rep_Bonk_Schramm_extension y \\<in> extended_distance_set\n  rep_Bonk_Schramm_extension z \\<in> extended_distance_set\n\ngoal (3 subgoals):\n 1. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 2. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 3. \\<And>x y z. dist x y \\<le> dist x z + dist y z", "show \"dist x y \\<le> dist x z + dist y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x y \\<le> dist x z + dist y z", "unfolding dist_Bonk_Schramm_extension_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_fun rep_Bonk_Schramm_extension\n     (map_fun rep_Bonk_Schramm_extension id) extended_distance x y\n    \\<le> map_fun rep_Bonk_Schramm_extension\n           (map_fun rep_Bonk_Schramm_extension id) extended_distance x z +\n          map_fun rep_Bonk_Schramm_extension\n           (map_fun rep_Bonk_Schramm_extension id) extended_distance y z", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance (rep_Bonk_Schramm_extension x)\n     (rep_Bonk_Schramm_extension y)\n    \\<le> extended_distance (rep_Bonk_Schramm_extension x)\n           (rep_Bonk_Schramm_extension z) +\n          extended_distance (rep_Bonk_Schramm_extension y)\n           (rep_Bonk_Schramm_extension z)", "by (metis C extended_distance_symmetric extended_distance_triang_ineq)"], ["proof (state)\nthis:\n  dist x y \\<le> dist x z + dist y z\n\ngoal (2 subgoals):\n 1. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 2. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)", "qed (auto simp add: uniformity_Bonk_Schramm_extension_def open_Bonk_Schramm_extension_def)"], ["", "end"], ["", "instance Bonk_Schramm_extension :: (metric_space) complete_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a Bonk_Schramm_extension, complete_space_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "fix X::\"nat \\<Rightarrow> 'a Bonk_Schramm_extension\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "assume \"Cauchy X\""], ["proof (state)\nthis:\n  Cauchy X\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "have *: \"\\<And>n. rep_Bonk_Schramm_extension (X n) \\<in> extended_distance_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. rep_Bonk_Schramm_extension (X n) \\<in> extended_distance_set", "using Quotient3_Bonk_Schramm_extension Quotient3_rep_reflp"], ["proof (prove)\nusing this:\n  Quotient3\n   (\\<lambda>x y.\n       x \\<in> extended_distance_set \\<and>\n       y \\<in> extended_distance_set \\<and> extended_distance x y = 0)\n   abs_Bonk_Schramm_extension rep_Bonk_Schramm_extension\n  Quotient3 ?R ?Abs ?Rep \\<Longrightarrow> ?R (?Rep ?a) (?Rep ?a)\n\ngoal (1 subgoal):\n 1. \\<And>n. rep_Bonk_Schramm_extension (X n) \\<in> extended_distance_set", "by fastforce"], ["proof (state)\nthis:\n  rep_Bonk_Schramm_extension (X ?n) \\<in> extended_distance_set\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "have **: \"extended_distance (rep_Bonk_Schramm_extension (X n)) (rep_Bonk_Schramm_extension (X m)) = dist (X n) (X m)\" for m n"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance (rep_Bonk_Schramm_extension (X n))\n     (rep_Bonk_Schramm_extension (X m)) =\n    dist (X n) (X m)", "unfolding dist_Bonk_Schramm_extension_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance (rep_Bonk_Schramm_extension (X n))\n     (rep_Bonk_Schramm_extension (X m)) =\n    map_fun rep_Bonk_Schramm_extension\n     (map_fun rep_Bonk_Schramm_extension id) extended_distance (X n) (X m)", "by auto"], ["proof (state)\nthis:\n  extended_distance (rep_Bonk_Schramm_extension (X ?n))\n   (rep_Bonk_Schramm_extension (X ?m)) =\n  dist (X ?n) (X ?m)\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "define y where \"y = would_be_Cauchy (\\<lambda>n. rep_Bonk_Schramm_extension (X n))\""], ["proof (state)\nthis:\n  y = would_be_Cauchy (\\<lambda>n. rep_Bonk_Schramm_extension (X n))\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "have \"y \\<in> extended_distance_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> extended_distance_set", "unfolding y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. would_be_Cauchy (\\<lambda>n. rep_Bonk_Schramm_extension (X n))\n    \\<in> extended_distance_set", "apply (rule extended_distance_Cauchy)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n. rep_Bonk_Schramm_extension (X n) \\<in> extended_distance_set\n 2. \\<forall>eps>0.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                extended_distance (rep_Bonk_Schramm_extension (X n))\n                 (rep_Bonk_Schramm_extension (X m))\n                < eps", "using * \\<open>Cauchy X\\<close>"], ["proof (prove)\nusing this:\n  rep_Bonk_Schramm_extension (X ?n) \\<in> extended_distance_set\n  Cauchy X\n\ngoal (2 subgoals):\n 1. \\<And>n. rep_Bonk_Schramm_extension (X n) \\<in> extended_distance_set\n 2. \\<forall>eps>0.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                extended_distance (rep_Bonk_Schramm_extension (X n))\n                 (rep_Bonk_Schramm_extension (X m))\n                < eps", "unfolding Cauchy_def **[symmetric]"], ["proof (prove)\nusing this:\n  rep_Bonk_Schramm_extension (X ?n) \\<in> extended_distance_set\n  \\<forall>e>0.\n     \\<exists>M.\n        \\<forall>m\\<ge>M.\n           \\<forall>n\\<ge>M.\n              extended_distance (rep_Bonk_Schramm_extension (X m))\n               (rep_Bonk_Schramm_extension (X n))\n              < e\n\ngoal (2 subgoals):\n 1. \\<And>n. rep_Bonk_Schramm_extension (X n) \\<in> extended_distance_set\n 2. \\<forall>eps>0.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                extended_distance (rep_Bonk_Schramm_extension (X n))\n                 (rep_Bonk_Schramm_extension (X m))\n                < eps", "by auto"], ["proof (state)\nthis:\n  y \\<in> extended_distance_set\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "define x where \"x = abs_Bonk_Schramm_extension y\""], ["proof (state)\nthis:\n  x = abs_Bonk_Schramm_extension y\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "have \"dist (X n) x = extended_distance (rep_Bonk_Schramm_extension (X n)) y\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (X n) x = extended_distance (rep_Bonk_Schramm_extension (X n)) y", "unfolding x_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (X n) (abs_Bonk_Schramm_extension y) =\n    extended_distance (rep_Bonk_Schramm_extension (X n)) y", "apply (subst Quotient3_abs_rep[OF Quotient3_Bonk_Schramm_extension, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (abs_Bonk_Schramm_extension (rep_Bonk_Schramm_extension (X n)))\n     (abs_Bonk_Schramm_extension y) =\n    extended_distance (rep_Bonk_Schramm_extension (X n)) y", "apply (rule dist_Bonk_Schramm_extension.abs_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rep_Bonk_Schramm_extension (X n) \\<in> extended_distance_set \\<and>\n    rep_Bonk_Schramm_extension (X n) \\<in> extended_distance_set \\<and>\n    extended_distance (rep_Bonk_Schramm_extension (X n))\n     (rep_Bonk_Schramm_extension (X n)) =\n    0\n 2. y \\<in> extended_distance_set \\<and>\n    y \\<in> extended_distance_set \\<and> extended_distance y y = 0", "using * \\<open>y \\<in> extended_distance_set\\<close>"], ["proof (prove)\nusing this:\n  rep_Bonk_Schramm_extension (X ?n) \\<in> extended_distance_set\n  y \\<in> extended_distance_set\n\ngoal (2 subgoals):\n 1. rep_Bonk_Schramm_extension (X n) \\<in> extended_distance_set \\<and>\n    rep_Bonk_Schramm_extension (X n) \\<in> extended_distance_set \\<and>\n    extended_distance (rep_Bonk_Schramm_extension (X n))\n     (rep_Bonk_Schramm_extension (X n)) =\n    0\n 2. y \\<in> extended_distance_set \\<and>\n    y \\<in> extended_distance_set \\<and> extended_distance y y = 0", "by (auto simp add: extended_distance_set_def)"], ["proof (state)\nthis:\n  dist (X ?n) x = extended_distance (rep_Bonk_Schramm_extension (X ?n)) y\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "moreover"], ["proof (state)\nthis:\n  dist (X ?n) x = extended_distance (rep_Bonk_Schramm_extension (X ?n)) y\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "have \"(\\<lambda>n. extended_distance (rep_Bonk_Schramm_extension (X n)) y) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance (rep_Bonk_Schramm_extension (X n)) y)\n    \\<longlonglongrightarrow> 0", "unfolding y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        extended_distance (rep_Bonk_Schramm_extension (X n))\n         (would_be_Cauchy (\\<lambda>n. rep_Bonk_Schramm_extension (X n))))\n    \\<longlonglongrightarrow> 0", "apply (rule extended_distance_Cauchy)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n. rep_Bonk_Schramm_extension (X n) \\<in> extended_distance_set\n 2. \\<forall>eps>0.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                extended_distance (rep_Bonk_Schramm_extension (X n))\n                 (rep_Bonk_Schramm_extension (X m))\n                < eps", "using * \\<open>Cauchy X\\<close>"], ["proof (prove)\nusing this:\n  rep_Bonk_Schramm_extension (X ?n) \\<in> extended_distance_set\n  Cauchy X\n\ngoal (2 subgoals):\n 1. \\<And>n. rep_Bonk_Schramm_extension (X n) \\<in> extended_distance_set\n 2. \\<forall>eps>0.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                extended_distance (rep_Bonk_Schramm_extension (X n))\n                 (rep_Bonk_Schramm_extension (X m))\n                < eps", "unfolding Cauchy_def **[symmetric]"], ["proof (prove)\nusing this:\n  rep_Bonk_Schramm_extension (X ?n) \\<in> extended_distance_set\n  \\<forall>e>0.\n     \\<exists>M.\n        \\<forall>m\\<ge>M.\n           \\<forall>n\\<ge>M.\n              extended_distance (rep_Bonk_Schramm_extension (X m))\n               (rep_Bonk_Schramm_extension (X n))\n              < e\n\ngoal (2 subgoals):\n 1. \\<And>n. rep_Bonk_Schramm_extension (X n) \\<in> extended_distance_set\n 2. \\<forall>eps>0.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                extended_distance (rep_Bonk_Schramm_extension (X n))\n                 (rep_Bonk_Schramm_extension (X m))\n                < eps", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. extended_distance (rep_Bonk_Schramm_extension (X n)) y)\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "ultimately"], ["proof (chain)\npicking this:\n  dist (X ?n) x = extended_distance (rep_Bonk_Schramm_extension (X ?n)) y\n  (\\<lambda>n. extended_distance (rep_Bonk_Schramm_extension (X n)) y)\n  \\<longlonglongrightarrow> 0", "have *: \"(\\<lambda>n. dist (X n) x) \\<longlonglongrightarrow> 0\""], ["proof (prove)\nusing this:\n  dist (X ?n) x = extended_distance (rep_Bonk_Schramm_extension (X ?n)) y\n  (\\<lambda>n. extended_distance (rep_Bonk_Schramm_extension (X n)) y)\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. dist (X n) x) \\<longlonglongrightarrow> 0", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>n. dist (X n) x) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "have \"X \\<longlonglongrightarrow> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<longlonglongrightarrow> x", "apply (rule tendstoI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F xa in sequentially. dist (X xa) x < e", "using *"], ["proof (prove)\nusing this:\n  (\\<lambda>n. dist (X n) x) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<forall>\\<^sub>F xa in sequentially. dist (X xa) x < e", "by (auto simp add: order_tendsto_iff)"], ["proof (state)\nthis:\n  X \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "then"], ["proof (chain)\npicking this:\n  X \\<longlonglongrightarrow> x", "show \"convergent X\""], ["proof (prove)\nusing this:\n  X \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. convergent X", "unfolding convergent_def"], ["proof (prove)\nusing this:\n  X \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. \\<exists>L. X \\<longlonglongrightarrow> L", "by auto"], ["proof (state)\nthis:\n  convergent X\n\ngoal:\nNo subgoals!", "qed"], ["", "instance Bonk_Schramm_extension :: (metric_space) geodesic_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a Bonk_Schramm_extension, geodesic_space_class)", "proof (rule complete_with_middles_imp_geodesic)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<exists>m. dist x m = dist x y / 2 \\<and> dist m y = dist x y / 2", "fix x y::\"'a Bonk_Schramm_extension\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<exists>m. dist x m = dist x y / 2 \\<and> dist m y = dist x y / 2", "have H: \"rep_Bonk_Schramm_extension x \\<in> extended_distance_set\"\n          \"rep_Bonk_Schramm_extension y \\<in> extended_distance_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_Bonk_Schramm_extension x \\<in> extended_distance_set &&&\n    rep_Bonk_Schramm_extension y \\<in> extended_distance_set", "using Quotient3_Bonk_Schramm_extension Quotient3_rep_reflp"], ["proof (prove)\nusing this:\n  Quotient3\n   (\\<lambda>x y.\n       x \\<in> extended_distance_set \\<and>\n       y \\<in> extended_distance_set \\<and> extended_distance x y = 0)\n   abs_Bonk_Schramm_extension rep_Bonk_Schramm_extension\n  Quotient3 ?R ?Abs ?Rep \\<Longrightarrow> ?R (?Rep ?a) (?Rep ?a)\n\ngoal (1 subgoal):\n 1. rep_Bonk_Schramm_extension x \\<in> extended_distance_set &&&\n    rep_Bonk_Schramm_extension y \\<in> extended_distance_set", "by fastforce+"], ["proof (state)\nthis:\n  rep_Bonk_Schramm_extension x \\<in> extended_distance_set\n  rep_Bonk_Schramm_extension y \\<in> extended_distance_set\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<exists>m. dist x m = dist x y / 2 \\<and> dist m y = dist x y / 2", "define M where \"M = middle (rep_Bonk_Schramm_extension x) (rep_Bonk_Schramm_extension y)\""], ["proof (state)\nthis:\n  M = middle (rep_Bonk_Schramm_extension x) (rep_Bonk_Schramm_extension y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<exists>m. dist x m = dist x y / 2 \\<and> dist m y = dist x y / 2", "then"], ["proof (chain)\npicking this:\n  M = middle (rep_Bonk_Schramm_extension x) (rep_Bonk_Schramm_extension y)", "have M: \"M \\<in> extended_distance_set\""], ["proof (prove)\nusing this:\n  M = middle (rep_Bonk_Schramm_extension x) (rep_Bonk_Schramm_extension y)\n\ngoal (1 subgoal):\n 1. M \\<in> extended_distance_set", "using extended_distance_set_middle[OF H]"], ["proof (prove)\nusing this:\n  M = middle (rep_Bonk_Schramm_extension x) (rep_Bonk_Schramm_extension y)\n  middle (rep_Bonk_Schramm_extension x) (rep_Bonk_Schramm_extension y)\n  \\<in> extended_distance_set\n\ngoal (1 subgoal):\n 1. M \\<in> extended_distance_set", "by simp"], ["proof (state)\nthis:\n  M \\<in> extended_distance_set\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<exists>m. dist x m = dist x y / 2 \\<and> dist m y = dist x y / 2", "define m where \"m = abs_Bonk_Schramm_extension M\""], ["proof (state)\nthis:\n  m = abs_Bonk_Schramm_extension M\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<exists>m. dist x m = dist x y / 2 \\<and> dist m y = dist x y / 2", "have \"dist x m = extended_distance (rep_Bonk_Schramm_extension x) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x m = extended_distance (rep_Bonk_Schramm_extension x) M", "apply (subst Quotient3_abs_rep[OF Quotient3_Bonk_Schramm_extension, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (abs_Bonk_Schramm_extension (rep_Bonk_Schramm_extension x)) m =\n    extended_distance (rep_Bonk_Schramm_extension x) M", "unfolding m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (abs_Bonk_Schramm_extension (rep_Bonk_Schramm_extension x))\n     (abs_Bonk_Schramm_extension M) =\n    extended_distance (rep_Bonk_Schramm_extension x) M", "apply (rule dist_Bonk_Schramm_extension.abs_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rep_Bonk_Schramm_extension x \\<in> extended_distance_set \\<and>\n    rep_Bonk_Schramm_extension x \\<in> extended_distance_set \\<and>\n    extended_distance (rep_Bonk_Schramm_extension x)\n     (rep_Bonk_Schramm_extension x) =\n    0\n 2. M \\<in> extended_distance_set \\<and>\n    M \\<in> extended_distance_set \\<and> extended_distance M M = 0", "using H M extended_distance_set_def"], ["proof (prove)\nusing this:\n  rep_Bonk_Schramm_extension x \\<in> extended_distance_set\n  rep_Bonk_Schramm_extension y \\<in> extended_distance_set\n  M \\<in> extended_distance_set\n  extended_distance_set = {z. extended_distance z z = 0}\n\ngoal (2 subgoals):\n 1. rep_Bonk_Schramm_extension x \\<in> extended_distance_set \\<and>\n    rep_Bonk_Schramm_extension x \\<in> extended_distance_set \\<and>\n    extended_distance (rep_Bonk_Schramm_extension x)\n     (rep_Bonk_Schramm_extension x) =\n    0\n 2. M \\<in> extended_distance_set \\<and>\n    M \\<in> extended_distance_set \\<and> extended_distance M M = 0", "by auto"], ["proof (state)\nthis:\n  dist x m = extended_distance (rep_Bonk_Schramm_extension x) M\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<exists>m. dist x m = dist x y / 2 \\<and> dist m y = dist x y / 2", "also"], ["proof (state)\nthis:\n  dist x m = extended_distance (rep_Bonk_Schramm_extension x) M\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<exists>m. dist x m = dist x y / 2 \\<and> dist m y = dist x y / 2", "have \"... = extended_distance (rep_Bonk_Schramm_extension x) (rep_Bonk_Schramm_extension y) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance (rep_Bonk_Schramm_extension x) M =\n    extended_distance (rep_Bonk_Schramm_extension x)\n     (rep_Bonk_Schramm_extension y) /\n    2", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance (rep_Bonk_Schramm_extension x)\n     (middle (rep_Bonk_Schramm_extension x)\n       (rep_Bonk_Schramm_extension y)) =\n    extended_distance (rep_Bonk_Schramm_extension x)\n     (rep_Bonk_Schramm_extension y) /\n    2", "by (rule extended_distance_middle[OF H])"], ["proof (state)\nthis:\n  extended_distance (rep_Bonk_Schramm_extension x) M =\n  extended_distance (rep_Bonk_Schramm_extension x)\n   (rep_Bonk_Schramm_extension y) /\n  2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<exists>m. dist x m = dist x y / 2 \\<and> dist m y = dist x y / 2", "also"], ["proof (state)\nthis:\n  extended_distance (rep_Bonk_Schramm_extension x) M =\n  extended_distance (rep_Bonk_Schramm_extension x)\n   (rep_Bonk_Schramm_extension y) /\n  2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<exists>m. dist x m = dist x y / 2 \\<and> dist m y = dist x y / 2", "have \"... = dist x y / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance (rep_Bonk_Schramm_extension x)\n     (rep_Bonk_Schramm_extension y) /\n    2 =\n    dist x y / 2", "unfolding dist_Bonk_Schramm_extension_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance (rep_Bonk_Schramm_extension x)\n     (rep_Bonk_Schramm_extension y) /\n    2 =\n    map_fun rep_Bonk_Schramm_extension\n     (map_fun rep_Bonk_Schramm_extension id) extended_distance x y /\n    2", "by auto"], ["proof (state)\nthis:\n  extended_distance (rep_Bonk_Schramm_extension x)\n   (rep_Bonk_Schramm_extension y) /\n  2 =\n  dist x y / 2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<exists>m. dist x m = dist x y / 2 \\<and> dist m y = dist x y / 2", "finally"], ["proof (chain)\npicking this:\n  dist x m = dist x y / 2", "have *: \"dist x m = dist x y / 2\""], ["proof (prove)\nusing this:\n  dist x m = dist x y / 2\n\ngoal (1 subgoal):\n 1. dist x m = dist x y / 2", "by simp"], ["proof (state)\nthis:\n  dist x m = dist x y / 2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<exists>m. dist x m = dist x y / 2 \\<and> dist m y = dist x y / 2", "have \"dist m y = extended_distance M (rep_Bonk_Schramm_extension y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist m y = extended_distance M (rep_Bonk_Schramm_extension y)", "apply (subst Quotient3_abs_rep[OF Quotient3_Bonk_Schramm_extension, of y, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist m (abs_Bonk_Schramm_extension (rep_Bonk_Schramm_extension y)) =\n    extended_distance M (rep_Bonk_Schramm_extension y)", "unfolding m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (abs_Bonk_Schramm_extension M)\n     (abs_Bonk_Schramm_extension (rep_Bonk_Schramm_extension y)) =\n    extended_distance M (rep_Bonk_Schramm_extension y)", "apply (rule dist_Bonk_Schramm_extension.abs_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. M \\<in> extended_distance_set \\<and>\n    M \\<in> extended_distance_set \\<and> extended_distance M M = 0\n 2. rep_Bonk_Schramm_extension y \\<in> extended_distance_set \\<and>\n    rep_Bonk_Schramm_extension y \\<in> extended_distance_set \\<and>\n    extended_distance (rep_Bonk_Schramm_extension y)\n     (rep_Bonk_Schramm_extension y) =\n    0", "using H M extended_distance_set_def"], ["proof (prove)\nusing this:\n  rep_Bonk_Schramm_extension x \\<in> extended_distance_set\n  rep_Bonk_Schramm_extension y \\<in> extended_distance_set\n  M \\<in> extended_distance_set\n  extended_distance_set = {z. extended_distance z z = 0}\n\ngoal (2 subgoals):\n 1. M \\<in> extended_distance_set \\<and>\n    M \\<in> extended_distance_set \\<and> extended_distance M M = 0\n 2. rep_Bonk_Schramm_extension y \\<in> extended_distance_set \\<and>\n    rep_Bonk_Schramm_extension y \\<in> extended_distance_set \\<and>\n    extended_distance (rep_Bonk_Schramm_extension y)\n     (rep_Bonk_Schramm_extension y) =\n    0", "by auto"], ["proof (state)\nthis:\n  dist m y = extended_distance M (rep_Bonk_Schramm_extension y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<exists>m. dist x m = dist x y / 2 \\<and> dist m y = dist x y / 2", "also"], ["proof (state)\nthis:\n  dist m y = extended_distance M (rep_Bonk_Schramm_extension y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<exists>m. dist x m = dist x y / 2 \\<and> dist m y = dist x y / 2", "have \"... = extended_distance (rep_Bonk_Schramm_extension x) (rep_Bonk_Schramm_extension y) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance M (rep_Bonk_Schramm_extension y) =\n    extended_distance (rep_Bonk_Schramm_extension x)\n     (rep_Bonk_Schramm_extension y) /\n    2", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance\n     (middle (rep_Bonk_Schramm_extension x) (rep_Bonk_Schramm_extension y))\n     (rep_Bonk_Schramm_extension y) =\n    extended_distance (rep_Bonk_Schramm_extension x)\n     (rep_Bonk_Schramm_extension y) /\n    2", "using extended_distance_middle(2)[OF H]"], ["proof (prove)\nusing this:\n  extended_distance (rep_Bonk_Schramm_extension y)\n   (middle (rep_Bonk_Schramm_extension x) (rep_Bonk_Schramm_extension y)) =\n  extended_distance (rep_Bonk_Schramm_extension x)\n   (rep_Bonk_Schramm_extension y) /\n  2\n\ngoal (1 subgoal):\n 1. extended_distance\n     (middle (rep_Bonk_Schramm_extension x) (rep_Bonk_Schramm_extension y))\n     (rep_Bonk_Schramm_extension y) =\n    extended_distance (rep_Bonk_Schramm_extension x)\n     (rep_Bonk_Schramm_extension y) /\n    2", "by (simp add: extended_distance_symmetric)"], ["proof (state)\nthis:\n  extended_distance M (rep_Bonk_Schramm_extension y) =\n  extended_distance (rep_Bonk_Schramm_extension x)\n   (rep_Bonk_Schramm_extension y) /\n  2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<exists>m. dist x m = dist x y / 2 \\<and> dist m y = dist x y / 2", "also"], ["proof (state)\nthis:\n  extended_distance M (rep_Bonk_Schramm_extension y) =\n  extended_distance (rep_Bonk_Schramm_extension x)\n   (rep_Bonk_Schramm_extension y) /\n  2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<exists>m. dist x m = dist x y / 2 \\<and> dist m y = dist x y / 2", "have \"... = dist x y / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance (rep_Bonk_Schramm_extension x)\n     (rep_Bonk_Schramm_extension y) /\n    2 =\n    dist x y / 2", "unfolding dist_Bonk_Schramm_extension_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance (rep_Bonk_Schramm_extension x)\n     (rep_Bonk_Schramm_extension y) /\n    2 =\n    map_fun rep_Bonk_Schramm_extension\n     (map_fun rep_Bonk_Schramm_extension id) extended_distance x y /\n    2", "by auto"], ["proof (state)\nthis:\n  extended_distance (rep_Bonk_Schramm_extension x)\n   (rep_Bonk_Schramm_extension y) /\n  2 =\n  dist x y / 2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<exists>m. dist x m = dist x y / 2 \\<and> dist m y = dist x y / 2", "finally"], ["proof (chain)\npicking this:\n  dist m y = dist x y / 2", "have \"dist m y = dist x y / 2\""], ["proof (prove)\nusing this:\n  dist m y = dist x y / 2\n\ngoal (1 subgoal):\n 1. dist m y = dist x y / 2", "by simp"], ["proof (state)\nthis:\n  dist m y = dist x y / 2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<exists>m. dist x m = dist x y / 2 \\<and> dist m y = dist x y / 2", "then"], ["proof (chain)\npicking this:\n  dist m y = dist x y / 2", "show \"\\<exists>m. dist x m = dist x y / 2 \\<and> dist m y = dist x y / 2\""], ["proof (prove)\nusing this:\n  dist m y = dist x y / 2\n\ngoal (1 subgoal):\n 1. \\<exists>m. dist x m = dist x y / 2 \\<and> dist m y = dist x y / 2", "using *"], ["proof (prove)\nusing this:\n  dist m y = dist x y / 2\n  dist x m = dist x y / 2\n\ngoal (1 subgoal):\n 1. \\<exists>m. dist x m = dist x y / 2 \\<and> dist m y = dist x y / 2", "by auto"], ["proof (state)\nthis:\n  \\<exists>m. dist x m = dist x y / 2 \\<and> dist m y = dist x y / 2\n\ngoal:\nNo subgoals!", "qed"], ["", "definition to_Bonk_Schramm_extension::\"'a::metric_space \\<Rightarrow> 'a Bonk_Schramm_extension\"\n  where \"to_Bonk_Schramm_extension x = abs_Bonk_Schramm_extension (basepoint x)\""], ["", "lemma to_Bonk_Schramm_extension_isometry:\n  \"isometry_on UNIV to_Bonk_Schramm_extension\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isometry_on UNIV to_Bonk_Schramm_extension", "proof (rule isometry_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> dist (to_Bonk_Schramm_extension x)\n                          (to_Bonk_Schramm_extension y) =\n                         dist x y", "fix x y::'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> dist (to_Bonk_Schramm_extension x)\n                          (to_Bonk_Schramm_extension y) =\n                         dist x y", "show \"dist (to_Bonk_Schramm_extension x) (to_Bonk_Schramm_extension y) = dist x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (to_Bonk_Schramm_extension x) (to_Bonk_Schramm_extension y) =\n    dist x y", "unfolding to_Bonk_Schramm_extension_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (abs_Bonk_Schramm_extension (basepoint x))\n     (abs_Bonk_Schramm_extension (basepoint y)) =\n    dist x y", "apply (subst dist_Bonk_Schramm_extension.abs_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. basepoint x \\<in> extended_distance_set \\<and>\n    basepoint x \\<in> extended_distance_set \\<and>\n    extended_distance (basepoint x) (basepoint x) = 0\n 2. basepoint y \\<in> extended_distance_set \\<and>\n    basepoint y \\<in> extended_distance_set \\<and>\n    extended_distance (basepoint y) (basepoint y) = 0\n 3. extended_distance (basepoint x) (basepoint y) = dist x y", "unfolding extended_distance_set_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. basepoint x \\<in> {z. extended_distance z z = 0} \\<and>\n    basepoint x \\<in> {z. extended_distance z z = 0} \\<and>\n    extended_distance (basepoint x) (basepoint x) = 0\n 2. basepoint y \\<in> {z. extended_distance z z = 0} \\<and>\n    basepoint y \\<in> {z. extended_distance z z = 0} \\<and>\n    extended_distance (basepoint y) (basepoint y) = 0\n 3. extended_distance (basepoint x) (basepoint y) = dist x y", "by (auto simp add: extended_distance_basepoint)"], ["proof (state)\nthis:\n  dist (to_Bonk_Schramm_extension x) (to_Bonk_Schramm_extension y) =\n  dist x y\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Bonk-Schramm extension of hyperbolic spaces\\<close>"], ["", "subsection \\<open>The Bonk-Schramm extension preserves hyperbolicity\\<close>"], ["", "text \\<open>A central feature of the Bonk-Schramm extension is that it preserves hyperbolicity, with the\nsame hyperbolicity constant $\\delta$, as we prove now.\\<close>"], ["", "lemma (in Gromov_hyperbolic_space) Bonk_Schramm_extension_unfolded_hyperbolic:\n  fixes x y z t::\"('a::metric_space) Bonk_Schramm_extension_unfolded\"\n  assumes \"x \\<in> extended_distance_set\"\n          \"y \\<in> extended_distance_set\"\n          \"z \\<in> extended_distance_set\"\n          \"t \\<in> extended_distance_set\"\n  shows \"extended_distance x y + extended_distance z t \\<le> max (extended_distance x z + extended_distance y t) (extended_distance x t + extended_distance y z) + 2 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance x y + extended_distance z t\n    \\<le> max (extended_distance x z + extended_distance y t)\n           (extended_distance x t + extended_distance y z) +\n          2 * deltaG TYPE('a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. extended_distance x y + extended_distance z t\n    \\<le> max (extended_distance x z + extended_distance y t)\n           (extended_distance x t + extended_distance y z) +\n          2 * deltaG TYPE('a)", "interpret wo: wo_rel Bonk_Schramm_extension_unfolded_wo"], ["proof (prove)\ngoal (1 subgoal):\n 1. wo_rel Bonk_Schramm_extension_unfolded_wo", "using well_order_on_Well_order wo_rel_def wfrec_def metric_space_class.Bonk_Schramm_extension_unfolded_wo_props(1)"], ["proof (prove)\nusing this:\n  well_order_on ?A ?r \\<Longrightarrow> ?A = Field ?r \\<and> Well_order ?r\n  wo_rel ?r \\<equiv> Well_order ?r\n  wfrec ?R ?F =\n  (\\<lambda>x. THE y. wfrec_rel ?R (\\<lambda>f x. ?F (cut f ?R x) x) x y)\n  well_order Bonk_Schramm_extension_unfolded_wo\n\ngoal (1 subgoal):\n 1. wo_rel Bonk_Schramm_extension_unfolded_wo", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. extended_distance x y + extended_distance z t\n    \\<le> max (extended_distance x z + extended_distance y t)\n           (extended_distance x t + extended_distance y z) +\n          2 * deltaG TYPE('a)", "(*To prove the hyperbolicity inequality, we prove it on larger and larger sets, by induction, adding\n  one point $a$ at a time. Then the result will follow readily.*)"], ["proof (state)\ngoal (1 subgoal):\n 1. extended_distance x y + extended_distance z t\n    \\<le> max (extended_distance x z + extended_distance y t)\n           (extended_distance x t + extended_distance y z) +\n          2 * deltaG TYPE('a)", "have ineq_rec: \"\\<forall>x y z t. x \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow> y \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow> z \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow> t \\<in> wo.under a \\<inter> extended_distance_set\n      \\<longrightarrow> extended_distance x y + extended_distance z t \\<le> max (extended_distance x z + extended_distance y t) (extended_distance x t + extended_distance y z) + 2 * deltaG(TYPE('a))\"\n    for a::\"'a Bonk_Schramm_extension_unfolded\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y z t.\n       x \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       y \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       z \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       t \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       extended_distance x y + extended_distance z t\n       \\<le> max (extended_distance x z + extended_distance y t)\n              (extended_distance x t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "proof (rule wo.well_order_induct[of _ a])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          y \\<noteq> x \\<and>\n          (y, x) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n          (\\<forall>x ya z t.\n              x \\<in> wo.under y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              ya \\<in> wo.under y \\<inter>\n                       extended_distance_set \\<longrightarrow>\n              z \\<in> wo.under y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              t \\<in> wo.under y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              extended_distance x ya + extended_distance z t\n              \\<le> max (extended_distance x z + extended_distance ya t)\n                     (extended_distance x t + extended_distance ya z) +\n                    2 * deltaG TYPE('a)) \\<Longrightarrow>\n       \\<forall>xa y z t.\n          xa \\<in> wo.under x \\<inter>\n                   extended_distance_set \\<longrightarrow>\n          y \\<in> wo.under x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          z \\<in> wo.under x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          t \\<in> wo.under x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          extended_distance xa y + extended_distance z t\n          \\<le> max (extended_distance xa z + extended_distance y t)\n                 (extended_distance xa t + extended_distance y z) +\n                2 * deltaG TYPE('a)", "fix a::\"'a Bonk_Schramm_extension_unfolded\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          y \\<noteq> x \\<and>\n          (y, x) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n          (\\<forall>x ya z t.\n              x \\<in> wo.under y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              ya \\<in> wo.under y \\<inter>\n                       extended_distance_set \\<longrightarrow>\n              z \\<in> wo.under y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              t \\<in> wo.under y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              extended_distance x ya + extended_distance z t\n              \\<le> max (extended_distance x z + extended_distance ya t)\n                     (extended_distance x t + extended_distance ya z) +\n                    2 * deltaG TYPE('a)) \\<Longrightarrow>\n       \\<forall>xa y z t.\n          xa \\<in> wo.under x \\<inter>\n                   extended_distance_set \\<longrightarrow>\n          y \\<in> wo.under x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          z \\<in> wo.under x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          t \\<in> wo.under x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          extended_distance xa y + extended_distance z t\n          \\<le> max (extended_distance xa z + extended_distance y t)\n                 (extended_distance xa t + extended_distance y z) +\n                2 * deltaG TYPE('a)", "assume IH_orig: \"\\<forall>b. b \\<noteq> a \\<and> (b, a) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n               (\\<forall>x y z t. x \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n                          y \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n                          z \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n                          t \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n      extended_distance x y + extended_distance z t \\<le> max (extended_distance x z + extended_distance y t) (extended_distance x t + extended_distance y z) + 2 * deltaG(TYPE('a)))\""], ["proof (state)\nthis:\n  \\<forall>b.\n     b \\<noteq> a \\<and>\n     (b, a) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n     (\\<forall>x y z t.\n         x \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n         y \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n         z \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n         t \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n         extended_distance x y + extended_distance z t\n         \\<le> max (extended_distance x z + extended_distance y t)\n                (extended_distance x t + extended_distance y z) +\n               2 * deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          y \\<noteq> x \\<and>\n          (y, x) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n          (\\<forall>x ya z t.\n              x \\<in> wo.under y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              ya \\<in> wo.under y \\<inter>\n                       extended_distance_set \\<longrightarrow>\n              z \\<in> wo.under y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              t \\<in> wo.under y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              extended_distance x ya + extended_distance z t\n              \\<le> max (extended_distance x z + extended_distance ya t)\n                     (extended_distance x t + extended_distance ya z) +\n                    2 * deltaG TYPE('a)) \\<Longrightarrow>\n       \\<forall>xa y z t.\n          xa \\<in> wo.under x \\<inter>\n                   extended_distance_set \\<longrightarrow>\n          y \\<in> wo.under x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          z \\<in> wo.under x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          t \\<in> wo.under x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          extended_distance xa y + extended_distance z t\n          \\<le> max (extended_distance xa z + extended_distance y t)\n                 (extended_distance xa t + extended_distance y z) +\n                2 * deltaG TYPE('a)", "(*Reformulate the induction assumption in more convenient terms*)"], ["proof (state)\nthis:\n  \\<forall>b.\n     b \\<noteq> a \\<and>\n     (b, a) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n     (\\<forall>x y z t.\n         x \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n         y \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n         z \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n         t \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n         extended_distance x y + extended_distance z t\n         \\<le> max (extended_distance x z + extended_distance y t)\n                (extended_distance x t + extended_distance y z) +\n               2 * deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          y \\<noteq> x \\<and>\n          (y, x) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n          (\\<forall>x ya z t.\n              x \\<in> wo.under y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              ya \\<in> wo.under y \\<inter>\n                       extended_distance_set \\<longrightarrow>\n              z \\<in> wo.under y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              t \\<in> wo.under y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              extended_distance x ya + extended_distance z t\n              \\<le> max (extended_distance x z + extended_distance ya t)\n                     (extended_distance x t + extended_distance ya z) +\n                    2 * deltaG TYPE('a)) \\<Longrightarrow>\n       \\<forall>xa y z t.\n          xa \\<in> wo.under x \\<inter>\n                   extended_distance_set \\<longrightarrow>\n          y \\<in> wo.under x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          z \\<in> wo.under x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          t \\<in> wo.under x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          extended_distance xa y + extended_distance z t\n          \\<le> max (extended_distance xa z + extended_distance y t)\n                 (extended_distance xa t + extended_distance y z) +\n                2 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  \\<forall>b.\n     b \\<noteq> a \\<and>\n     (b, a) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n     (\\<forall>x y z t.\n         x \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n         y \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n         z \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n         t \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n         extended_distance x y + extended_distance z t\n         \\<le> max (extended_distance x z + extended_distance y t)\n                (extended_distance x t + extended_distance y z) +\n               2 * deltaG TYPE('a))", "have IH: \"extended_distance x y + extended_distance z t \\<le> max (extended_distance x z + extended_distance y t) (extended_distance x t + extended_distance y z) + 2 * deltaG(TYPE('a))\"\n      if \"x \\<in> wo.underS a \\<inter> extended_distance_set\"\n         \"y \\<in> wo.underS a \\<inter> extended_distance_set\"\n         \"z \\<in> wo.underS a \\<inter> extended_distance_set\"\n         \"t \\<in> wo.underS a \\<inter> extended_distance_set\"\n      for x y z t"], ["proof (prove)\nusing this:\n  \\<forall>b.\n     b \\<noteq> a \\<and>\n     (b, a) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n     (\\<forall>x y z t.\n         x \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n         y \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n         z \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n         t \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n         extended_distance x y + extended_distance z t\n         \\<le> max (extended_distance x z + extended_distance y t)\n                (extended_distance x t + extended_distance y z) +\n               2 * deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. extended_distance x y + extended_distance z t\n    \\<le> max (extended_distance x z + extended_distance y t)\n           (extended_distance x t + extended_distance y z) +\n          2 * deltaG TYPE('a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>b.\n       b \\<noteq> a \\<and>\n       (b, a) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n       (\\<forall>x y z t.\n           x \\<in> wo.under b \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           y \\<in> wo.under b \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           z \\<in> wo.under b \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           t \\<in> wo.under b \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           extended_distance x y + extended_distance z t\n           \\<le> max (extended_distance x z + extended_distance y t)\n                  (extended_distance x t + extended_distance y z) +\n                 2 * deltaG TYPE('a)) \\<Longrightarrow>\n    extended_distance x y + extended_distance z t\n    \\<le> max (extended_distance x z + extended_distance y t)\n           (extended_distance x t + extended_distance y z) +\n          2 * deltaG TYPE('a)", "define b where \"b = wo.max2 (wo.max2 x y) (wo.max2 z t)\""], ["proof (state)\nthis:\n  b = wo.max2 (wo.max2 x y) (wo.max2 z t)\n\ngoal (1 subgoal):\n 1. \\<forall>b.\n       b \\<noteq> a \\<and>\n       (b, a) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n       (\\<forall>x y z t.\n           x \\<in> wo.under b \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           y \\<in> wo.under b \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           z \\<in> wo.under b \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           t \\<in> wo.under b \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           extended_distance x y + extended_distance z t\n           \\<le> max (extended_distance x z + extended_distance y t)\n                  (extended_distance x t + extended_distance y z) +\n                 2 * deltaG TYPE('a)) \\<Longrightarrow>\n    extended_distance x y + extended_distance z t\n    \\<le> max (extended_distance x z + extended_distance y t)\n           (extended_distance x t + extended_distance y z) +\n          2 * deltaG TYPE('a)", "have \"b \\<in> wo.underS a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> wo.underS a", "using that b_def"], ["proof (prove)\nusing this:\n  x \\<in> wo.underS a \\<inter> extended_distance_set\n  y \\<in> wo.underS a \\<inter> extended_distance_set\n  z \\<in> wo.underS a \\<inter> extended_distance_set\n  t \\<in> wo.underS a \\<inter> extended_distance_set\n  b = wo.max2 (wo.max2 x y) (wo.max2 z t)\n\ngoal (1 subgoal):\n 1. b \\<in> wo.underS a", "by auto"], ["proof (state)\nthis:\n  b \\<in> wo.underS a\n\ngoal (1 subgoal):\n 1. \\<forall>b.\n       b \\<noteq> a \\<and>\n       (b, a) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n       (\\<forall>x y z t.\n           x \\<in> wo.under b \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           y \\<in> wo.under b \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           z \\<in> wo.under b \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           t \\<in> wo.under b \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           extended_distance x y + extended_distance z t\n           \\<le> max (extended_distance x z + extended_distance y t)\n                  (extended_distance x t + extended_distance y z) +\n                 2 * deltaG TYPE('a)) \\<Longrightarrow>\n    extended_distance x y + extended_distance z t\n    \\<le> max (extended_distance x z + extended_distance y t)\n           (extended_distance x t + extended_distance y z) +\n          2 * deltaG TYPE('a)", "have \"x \\<in> wo.under b\" \"y \\<in> wo.under b\" \"z \\<in> wo.under b\" \"t \\<in> wo.under b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> wo.under b &&& y \\<in> wo.under b) &&&\n    z \\<in> wo.under b &&& t \\<in> wo.under b", "unfolding b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> wo.under (wo.max2 (wo.max2 x y) (wo.max2 z t)) &&&\n     y \\<in> wo.under (wo.max2 (wo.max2 x y) (wo.max2 z t))) &&&\n    z \\<in> wo.under (wo.max2 (wo.max2 x y) (wo.max2 z t)) &&&\n    t \\<in> wo.under (wo.max2 (wo.max2 x y) (wo.max2 z t))", "apply (auto simp add: under_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. (x, wo.max2 (wo.max2 x y) (wo.max2 z t))\n    \\<in> Bonk_Schramm_extension_unfolded_wo\n 2. (y, wo.max2 (wo.max2 x y) (wo.max2 z t))\n    \\<in> Bonk_Schramm_extension_unfolded_wo\n 3. (z, wo.max2 (wo.max2 x y) (wo.max2 z t))\n    \\<in> Bonk_Schramm_extension_unfolded_wo\n 4. (t, wo.max2 (wo.max2 x y) (wo.max2 z t))\n    \\<in> Bonk_Schramm_extension_unfolded_wo", "by (metis UNIV_I metric_space_class.Bonk_Schramm_extension_unfolded_wo_props(1) mem_Collect_eq under_def well_order_on_Well_order wo.TOTALS wo.max2_iff)+"], ["proof (state)\nthis:\n  x \\<in> wo.under b\n  y \\<in> wo.under b\n  z \\<in> wo.under b\n  t \\<in> wo.under b\n\ngoal (1 subgoal):\n 1. \\<forall>b.\n       b \\<noteq> a \\<and>\n       (b, a) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n       (\\<forall>x y z t.\n           x \\<in> wo.under b \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           y \\<in> wo.under b \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           z \\<in> wo.under b \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           t \\<in> wo.under b \\<inter>\n                   extended_distance_set \\<longrightarrow>\n           extended_distance x y + extended_distance z t\n           \\<le> max (extended_distance x z + extended_distance y t)\n                  (extended_distance x t + extended_distance y z) +\n                 2 * deltaG TYPE('a)) \\<Longrightarrow>\n    extended_distance x y + extended_distance z t\n    \\<le> max (extended_distance x z + extended_distance y t)\n           (extended_distance x t + extended_distance y z) +\n          2 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  x \\<in> wo.under b\n  y \\<in> wo.under b\n  z \\<in> wo.under b\n  t \\<in> wo.under b", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> wo.under b\n  y \\<in> wo.under b\n  z \\<in> wo.under b\n  t \\<in> wo.under b\n\ngoal (1 subgoal):\n 1. extended_distance x y + extended_distance z t\n    \\<le> max (extended_distance x z + extended_distance y t)\n           (extended_distance x t + extended_distance y z) +\n          2 * deltaG TYPE('a)", "using that IH_orig \\<open>b \\<in> wo.underS a\\<close> underS_E"], ["proof (prove)\nusing this:\n  x \\<in> wo.under b\n  y \\<in> wo.under b\n  z \\<in> wo.under b\n  t \\<in> wo.under b\n  x \\<in> wo.underS a \\<inter> extended_distance_set\n  y \\<in> wo.underS a \\<inter> extended_distance_set\n  z \\<in> wo.underS a \\<inter> extended_distance_set\n  t \\<in> wo.underS a \\<inter> extended_distance_set\n  \\<forall>b.\n     b \\<noteq> a \\<and>\n     (b, a) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n     (\\<forall>x y z t.\n         x \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n         y \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n         z \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n         t \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n         extended_distance x y + extended_distance z t\n         \\<le> max (extended_distance x z + extended_distance y t)\n                (extended_distance x t + extended_distance y z) +\n               2 * deltaG TYPE('a))\n  b \\<in> wo.underS a\n  ?i \\<in> underS ?R ?j \\<Longrightarrow>\n  ?i \\<noteq> ?j \\<and> (?i, ?j) \\<in> ?R\n\ngoal (1 subgoal):\n 1. extended_distance x y + extended_distance z t\n    \\<le> max (extended_distance x z + extended_distance y t)\n           (extended_distance x t + extended_distance y z) +\n          2 * deltaG TYPE('a)", "by fastforce"], ["proof (state)\nthis:\n  extended_distance x y + extended_distance z t\n  \\<le> max (extended_distance x z + extended_distance y t)\n         (extended_distance x t + extended_distance y z) +\n        2 * deltaG TYPE('a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x1 \\<in> wo.underS a \\<inter> extended_distance_set;\n   ?y1 \\<in> wo.underS a \\<inter> extended_distance_set;\n   ?z1 \\<in> wo.underS a \\<inter> extended_distance_set;\n   ?t1 \\<in> wo.underS a \\<inter> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x1 ?y1 + extended_distance ?z1 ?t1\n                    \\<le> max (extended_distance ?x1 ?z1 +\n                               extended_distance ?y1 ?t1)\n                           (extended_distance ?x1 ?t1 +\n                            extended_distance ?y1 ?z1) +\n                          2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          y \\<noteq> x \\<and>\n          (y, x) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n          (\\<forall>x ya z t.\n              x \\<in> wo.under y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              ya \\<in> wo.under y \\<inter>\n                       extended_distance_set \\<longrightarrow>\n              z \\<in> wo.under y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              t \\<in> wo.under y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              extended_distance x ya + extended_distance z t\n              \\<le> max (extended_distance x z + extended_distance ya t)\n                     (extended_distance x t + extended_distance ya z) +\n                    2 * deltaG TYPE('a)) \\<Longrightarrow>\n       \\<forall>xa y z t.\n          xa \\<in> wo.under x \\<inter>\n                   extended_distance_set \\<longrightarrow>\n          y \\<in> wo.under x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          z \\<in> wo.under x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          t \\<in> wo.under x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          extended_distance xa y + extended_distance z t\n          \\<le> max (extended_distance xa z + extended_distance y t)\n                 (extended_distance xa t + extended_distance y z) +\n                2 * deltaG TYPE('a)", "consider \"a \\<notin> extended_distance_set\" | \"a \\<in> extended_distance_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<notin> extended_distance_set \\<Longrightarrow> thesis;\n     a \\<in> extended_distance_set \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<notin> extended_distance_set \\<Longrightarrow> ?thesis1;\n   a \\<in> extended_distance_set \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          y \\<noteq> x \\<and>\n          (y, x) \\<in> Bonk_Schramm_extension_unfolded_wo \\<longrightarrow>\n          (\\<forall>x ya z t.\n              x \\<in> wo.under y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              ya \\<in> wo.under y \\<inter>\n                       extended_distance_set \\<longrightarrow>\n              z \\<in> wo.under y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              t \\<in> wo.under y \\<inter>\n                      extended_distance_set \\<longrightarrow>\n              extended_distance x ya + extended_distance z t\n              \\<le> max (extended_distance x z + extended_distance ya t)\n                     (extended_distance x t + extended_distance ya z) +\n                    2 * deltaG TYPE('a)) \\<Longrightarrow>\n       \\<forall>xa y z t.\n          xa \\<in> wo.under x \\<inter>\n                   extended_distance_set \\<longrightarrow>\n          y \\<in> wo.under x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          z \\<in> wo.under x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          t \\<in> wo.under x \\<inter>\n                  extended_distance_set \\<longrightarrow>\n          extended_distance xa y + extended_distance z t\n          \\<le> max (extended_distance xa z + extended_distance y t)\n                 (extended_distance xa t + extended_distance y z) +\n                2 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>a \\<notin> extended_distance_set \\<Longrightarrow> ?thesis1;\n   a \\<in> extended_distance_set \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1", "show \"\\<forall>x y z t. x \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n                          y \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n                          z \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n                          t \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n      extended_distance x y + extended_distance z t \\<le> max (extended_distance x z + extended_distance y t) (extended_distance x t + extended_distance y z) + 2 * deltaG(TYPE('a))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<notin> extended_distance_set \\<Longrightarrow> ?thesis1;\n   a \\<in> extended_distance_set \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<forall>x y z t.\n       x \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       y \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       z \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       t \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       extended_distance x y + extended_distance z t\n       \\<le> max (extended_distance x z + extended_distance y t)\n              (extended_distance x t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<notin> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z t.\n       x \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       y \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       z \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       t \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       extended_distance x y + extended_distance z t\n       \\<le> max (extended_distance x z + extended_distance y t)\n              (extended_distance x t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 2. a \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z t.\n       x \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       y \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       z \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       t \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       extended_distance x y + extended_distance z t\n       \\<le> max (extended_distance x z + extended_distance y t)\n              (extended_distance x t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "(* If the point $a$ is not admissible for the distance, then we are not adding any point,\n      and the result follows readily from the assumption hypothesis.*)"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<notin> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z t.\n       x \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       y \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       z \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       t \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       extended_distance x y + extended_distance z t\n       \\<le> max (extended_distance x z + extended_distance y t)\n              (extended_distance x t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 2. a \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z t.\n       x \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       y \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       z \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       t \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       extended_distance x y + extended_distance z t\n       \\<le> max (extended_distance x z + extended_distance y t)\n              (extended_distance x t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "case 1"], ["proof (state)\nthis:\n  a \\<notin> extended_distance_set\n\ngoal (2 subgoals):\n 1. a \\<notin> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z t.\n       x \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       y \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       z \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       t \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       extended_distance x y + extended_distance z t\n       \\<le> max (extended_distance x z + extended_distance y t)\n              (extended_distance x t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 2. a \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z t.\n       x \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       y \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       z \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       t \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       extended_distance x y + extended_distance z t\n       \\<le> max (extended_distance x z + extended_distance y t)\n              (extended_distance x t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  a \\<notin> extended_distance_set", "have \"wo.under a \\<inter> extended_distance_set = wo.underS a \\<inter> extended_distance_set\""], ["proof (prove)\nusing this:\n  a \\<notin> extended_distance_set\n\ngoal (1 subgoal):\n 1. wo.under a \\<inter> extended_distance_set =\n    wo.underS a \\<inter> extended_distance_set", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>a \\<notin> extended_distance_set; x \\<in> wo.under a;\n        x \\<in> extended_distance_set\\<rbrakk>\n       \\<Longrightarrow> x \\<in> wo.underS a\n 2. \\<And>x.\n       \\<lbrakk>a \\<notin> extended_distance_set; x \\<in> wo.underS a;\n        x \\<in> extended_distance_set\\<rbrakk>\n       \\<Longrightarrow> x \\<in> wo.under a", "apply (metis mem_Collect_eq underS_I under_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>a \\<notin> extended_distance_set; x \\<in> wo.underS a;\n        x \\<in> extended_distance_set\\<rbrakk>\n       \\<Longrightarrow> x \\<in> wo.under a", "by (simp add: underS_E under_def)"], ["proof (state)\nthis:\n  wo.under a \\<inter> extended_distance_set =\n  wo.underS a \\<inter> extended_distance_set\n\ngoal (2 subgoals):\n 1. a \\<notin> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z t.\n       x \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       y \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       z \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       t \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       extended_distance x y + extended_distance z t\n       \\<le> max (extended_distance x z + extended_distance y t)\n              (extended_distance x t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 2. a \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z t.\n       x \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       y \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       z \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       t \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       extended_distance x y + extended_distance z t\n       \\<le> max (extended_distance x z + extended_distance y t)\n              (extended_distance x t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  wo.under a \\<inter> extended_distance_set =\n  wo.underS a \\<inter> extended_distance_set", "show ?thesis"], ["proof (prove)\nusing this:\n  wo.under a \\<inter> extended_distance_set =\n  wo.underS a \\<inter> extended_distance_set\n\ngoal (1 subgoal):\n 1. \\<forall>x y z t.\n       x \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       y \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       z \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       t \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       extended_distance x y + extended_distance z t\n       \\<le> max (extended_distance x z + extended_distance y t)\n              (extended_distance x t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "using IH"], ["proof (prove)\nusing this:\n  wo.under a \\<inter> extended_distance_set =\n  wo.underS a \\<inter> extended_distance_set\n  \\<lbrakk>?x1 \\<in> wo.underS a \\<inter> extended_distance_set;\n   ?y1 \\<in> wo.underS a \\<inter> extended_distance_set;\n   ?z1 \\<in> wo.underS a \\<inter> extended_distance_set;\n   ?t1 \\<in> wo.underS a \\<inter> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x1 ?y1 + extended_distance ?z1 ?t1\n                    \\<le> max (extended_distance ?x1 ?z1 +\n                               extended_distance ?y1 ?t1)\n                           (extended_distance ?x1 ?t1 +\n                            extended_distance ?y1 ?z1) +\n                          2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<forall>x y z t.\n       x \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       y \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       z \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       t \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       extended_distance x y + extended_distance z t\n       \\<le> max (extended_distance x z + extended_distance y t)\n              (extended_distance x t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x y z t.\n     x \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n     y \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n     z \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n     t \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n     extended_distance x y + extended_distance z t\n     \\<le> max (extended_distance x z + extended_distance y t)\n            (extended_distance x t + extended_distance y z) +\n           2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. a \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z t.\n       x \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       y \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       z \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       t \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       extended_distance x y + extended_distance z t\n       \\<le> max (extended_distance x z + extended_distance y t)\n              (extended_distance x t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z t.\n       x \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       y \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       z \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       t \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       extended_distance x y + extended_distance z t\n       \\<le> max (extended_distance x z + extended_distance y t)\n              (extended_distance x t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "(*Now, we assume that the point $a$ is admissible. We will first check the desired\n      inequality when the first point is $a$, and the other points are strictly below $a$.\n      The general inequality will follow from this one by a simple reduction below*)"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z t.\n       x \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       y \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       z \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       t \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       extended_distance x y + extended_distance z t\n       \\<le> max (extended_distance x z + extended_distance y t)\n              (extended_distance x t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "case 2"], ["proof (state)\nthis:\n  a \\<in> extended_distance_set\n\ngoal (1 subgoal):\n 1. a \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z t.\n       x \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       y \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       z \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       t \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       extended_distance x y + extended_distance z t\n       \\<le> max (extended_distance x z + extended_distance y t)\n              (extended_distance x t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  a \\<in> extended_distance_set", "have a: \"extended_distance a a = 0\""], ["proof (prove)\nusing this:\n  a \\<in> extended_distance_set\n\ngoal (1 subgoal):\n 1. extended_distance a a = 0", "unfolding metric_space_class.extended_distance_set_def"], ["proof (prove)\nusing this:\n  a \\<in> {z. extended_distance z z = 0}\n\ngoal (1 subgoal):\n 1. extended_distance a a = 0", "by auto"], ["proof (state)\nthis:\n  extended_distance a a = 0\n\ngoal (1 subgoal):\n 1. a \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z t.\n       x \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       y \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       z \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       t \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       extended_distance x y + extended_distance z t\n       \\<le> max (extended_distance x z + extended_distance y t)\n              (extended_distance x t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "have main_ineq: \"extended_distance a y + extended_distance z t \\<le> max (extended_distance a z + extended_distance y t) (extended_distance a t + extended_distance y z) + 2 * deltaG(TYPE('a))\"\n        if yzt: \"y \\<in> wo.underS a \\<inter> extended_distance_set\"\n                \"z \\<in> wo.underS a \\<inter> extended_distance_set\"\n                \"t \\<in> wo.underS a \\<inter> extended_distance_set\"\n        for y z t"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance a y + extended_distance z t\n    \\<le> max (extended_distance a z + extended_distance y t)\n           (extended_distance a t + extended_distance y z) +\n          2 * deltaG TYPE('a)", "proof (cases a)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       a = basepoint x1 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 2. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 3. \\<And>x3.\n       a = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "(*In the case of a basepoint, the desired inequality follows from the corresponding\n        inequality in the original --hyperbolic-- space.*)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       a = basepoint x1 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 2. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 3. \\<And>x3.\n       a = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "case A: (basepoint a')"], ["proof (state)\nthis:\n  a = basepoint a'\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       a = basepoint x1 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 2. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 3. \\<And>x3.\n       a = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  a = basepoint a'", "have \"y \\<in> range basepoint\""], ["proof (prove)\nusing this:\n  a = basepoint a'\n\ngoal (1 subgoal):\n 1. y \\<in> range basepoint", "using metric_space_class.Bonk_Schramm_extension_unfolded_wo_props(2)"], ["proof (prove)\nusing this:\n  a = basepoint a'\n  \\<forall>x\\<in>range basepoint.\n     \\<forall>y\\<in>- range basepoint.\n        (x, y) \\<in> Bonk_Schramm_extension_unfolded_wo\n\ngoal (1 subgoal):\n 1. y \\<in> range basepoint", "by (metis yzt(1) Compl_iff Int_iff range_eqI wo.max2_def wo.max2_underS'(2))"], ["proof (state)\nthis:\n  y \\<in> range basepoint\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       a = basepoint x1 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 2. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 3. \\<And>x3.\n       a = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  y \\<in> range basepoint", "obtain y' where y: \"y = basepoint y'\""], ["proof (prove)\nusing this:\n  y \\<in> range basepoint\n\ngoal (1 subgoal):\n 1. (\\<And>y'. y = basepoint y' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y = basepoint y'\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       a = basepoint x1 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 2. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 3. \\<And>x3.\n       a = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "have \"z \\<in> range basepoint\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> range basepoint", "using metric_space_class.Bonk_Schramm_extension_unfolded_wo_props(2) A"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>range basepoint.\n     \\<forall>y\\<in>- range basepoint.\n        (x, y) \\<in> Bonk_Schramm_extension_unfolded_wo\n  a = basepoint a'\n\ngoal (1 subgoal):\n 1. z \\<in> range basepoint", "by (metis yzt(2) Compl_iff Int_iff range_eqI wo.max2_def wo.max2_underS'(2))"], ["proof (state)\nthis:\n  z \\<in> range basepoint\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       a = basepoint x1 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 2. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 3. \\<And>x3.\n       a = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  z \\<in> range basepoint", "obtain z' where z: \"z = basepoint z'\""], ["proof (prove)\nusing this:\n  z \\<in> range basepoint\n\ngoal (1 subgoal):\n 1. (\\<And>z'. z = basepoint z' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z = basepoint z'\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       a = basepoint x1 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 2. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 3. \\<And>x3.\n       a = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "have \"t \\<in> range basepoint\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> range basepoint", "using metric_space_class.Bonk_Schramm_extension_unfolded_wo_props(2) A"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>range basepoint.\n     \\<forall>y\\<in>- range basepoint.\n        (x, y) \\<in> Bonk_Schramm_extension_unfolded_wo\n  a = basepoint a'\n\ngoal (1 subgoal):\n 1. t \\<in> range basepoint", "by (metis yzt(3) Compl_iff Int_iff range_eqI wo.max2_def wo.max2_underS'(2))"], ["proof (state)\nthis:\n  t \\<in> range basepoint\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       a = basepoint x1 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 2. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 3. \\<And>x3.\n       a = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  t \\<in> range basepoint", "obtain t' where t: \"t = basepoint t'\""], ["proof (prove)\nusing this:\n  t \\<in> range basepoint\n\ngoal (1 subgoal):\n 1. (\\<And>t'. t = basepoint t' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t = basepoint t'\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       a = basepoint x1 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 2. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 3. \\<And>x3.\n       a = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance a y + extended_distance z t\n    \\<le> max (extended_distance a z + extended_distance y t)\n           (extended_distance a t + extended_distance y z) +\n          2 * deltaG TYPE('a)", "unfolding y z t A metric_space_class.extended_distance_basepoint"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist a' y' + dist z' t'\n    \\<le> max (dist a' z' + dist y' t') (dist a' t' + dist y' z') +\n          2 * deltaG TYPE('a)", "using hyperb_quad_ineq UNIV_I"], ["proof (prove)\nusing this:\n  dist ?x ?y + dist ?z ?t\n  \\<le> max (dist ?x ?z + dist ?y ?t) (dist ?x ?t + dist ?y ?z) +\n        2 * deltaG TYPE('a)\n  ?x \\<in> UNIV\n\ngoal (1 subgoal):\n 1. dist a' y' + dist z' t'\n    \\<le> max (dist a' z' + dist y' t') (dist a' t' + dist y' z') +\n          2 * deltaG TYPE('a)", "unfolding Gromov_hyperbolic_subset_def"], ["proof (prove)\nusing this:\n  dist ?x ?y + dist ?z ?t\n  \\<le> max (dist ?x ?z + dist ?y ?t) (dist ?x ?t + dist ?y ?z) +\n        2 * deltaG TYPE('a)\n  ?x \\<in> UNIV\n\ngoal (1 subgoal):\n 1. dist a' y' + dist z' t'\n    \\<le> max (dist a' z' + dist y' t') (dist a' t' + dist y' z') +\n          2 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  extended_distance a y + extended_distance z t\n  \\<le> max (extended_distance a z + extended_distance y t)\n         (extended_distance a t + extended_distance y z) +\n        2 * deltaG TYPE('a)\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 2. \\<And>x3.\n       a = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 2. \\<And>x3.\n       a = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "(*In the case of a Cauchy sequence, the desired inequality is obtained from the inequality\n        for the points defining the Cauchy sequence --which holds thanks to the induction\n        assumption-- by passing to the limit.*)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 2. \\<And>x3.\n       a = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "case C: (would_be_Cauchy u)"], ["proof (state)\nthis:\n  a = would_be_Cauchy u\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 2. \\<And>x3.\n       a = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  a = would_be_Cauchy u", "have u: \"would_be_Cauchy u \\<in> extended_distance_set\"\n                     \"u n \\<in> extended_distance_set \\<inter> wo.underS (would_be_Cauchy u)\" for n"], ["proof (prove)\nusing this:\n  a = would_be_Cauchy u\n\ngoal (1 subgoal):\n 1. would_be_Cauchy u \\<in> extended_distance_set &&&\n    u n \\<in> extended_distance_set \\<inter> wo.underS (would_be_Cauchy u)", "using metric_space_class.extended_distance_set_Cauchy 2"], ["proof (prove)\nusing this:\n  a = would_be_Cauchy u\n  would_be_Cauchy ?u \\<in> extended_distance_set \\<Longrightarrow>\n  ?u ?n\n  \\<in> extended_distance_set \\<inter>\n        underS Bonk_Schramm_extension_unfolded_wo (would_be_Cauchy ?u)\n  would_be_Cauchy ?u \\<in> extended_distance_set \\<Longrightarrow>\n  \\<forall>eps>0.\n     \\<exists>N.\n        \\<forall>n\\<ge>N.\n           \\<forall>m\\<ge>N. extended_distance (?u n) (?u m) < eps\n  a \\<in> extended_distance_set\n\ngoal (1 subgoal):\n 1. would_be_Cauchy u \\<in> extended_distance_set &&&\n    u n \\<in> extended_distance_set \\<inter> wo.underS (would_be_Cauchy u)", "by auto"], ["proof (state)\nthis:\n  would_be_Cauchy u \\<in> extended_distance_set\n  u ?n1 \\<in> extended_distance_set \\<inter> wo.underS (would_be_Cauchy u)\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 2. \\<And>x3.\n       a = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "have lim: \"(\\<lambda>n. extended_distance y (u n)) \\<longlonglongrightarrow> (extended_distance y (would_be_Cauchy u))\"\n          if y: \"y \\<in> extended_distance_set\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "have a: \"abs(extended_distance y (u n) - extended_distance y (would_be_Cauchy u)) \\<le> extended_distance (u n) (would_be_Cauchy u)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>extended_distance y (u n) -\n          extended_distance y (would_be_Cauchy u)\\<bar>\n    \\<le> extended_distance (u n) (would_be_Cauchy u)", "using u(2)[of n] 2 y metric_space_class.extended_distance_triang_ineq"], ["proof (prove)\nusing this:\n  u n \\<in> extended_distance_set \\<inter> wo.underS (would_be_Cauchy u)\n  a \\<in> extended_distance_set\n  y \\<in> extended_distance_set\n  \\<lbrakk>?x \\<in> extended_distance_set; ?y \\<in> extended_distance_set;\n   ?z \\<in> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x ?z\n                    \\<le> extended_distance ?x ?y + extended_distance ?y ?z\n\ngoal (1 subgoal):\n 1. \\<bar>extended_distance y (u n) -\n          extended_distance y (would_be_Cauchy u)\\<bar>\n    \\<le> extended_distance (u n) (would_be_Cauchy u)", "unfolding C"], ["proof (prove)\nusing this:\n  u n \\<in> extended_distance_set \\<inter> wo.underS (would_be_Cauchy u)\n  would_be_Cauchy u \\<in> extended_distance_set\n  y \\<in> extended_distance_set\n  \\<lbrakk>?x \\<in> extended_distance_set; ?y \\<in> extended_distance_set;\n   ?z \\<in> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x ?z\n                    \\<le> extended_distance ?x ?y + extended_distance ?y ?z\n\ngoal (1 subgoal):\n 1. \\<bar>extended_distance y (u n) -\n          extended_distance y (would_be_Cauchy u)\\<bar>\n    \\<le> extended_distance (u n) (would_be_Cauchy u)", "apply (subst abs_le_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u n\n             \\<in> extended_distance_set \\<inter>\n                   wo.underS (would_be_Cauchy u);\n     would_be_Cauchy u \\<in> extended_distance_set;\n     y \\<in> extended_distance_set;\n     \\<And>x y z.\n        \\<lbrakk>x \\<in> extended_distance_set;\n         y \\<in> extended_distance_set;\n         z \\<in> extended_distance_set\\<rbrakk>\n        \\<Longrightarrow> extended_distance x z\n                          \\<le> extended_distance x y +\n                                extended_distance y z\\<rbrakk>\n    \\<Longrightarrow> extended_distance y (u n) -\n                      extended_distance y (would_be_Cauchy u)\n                      \\<le> extended_distance (u n)\n                             (would_be_Cauchy u) \\<and>\n                      - (extended_distance y (u n) -\n                         extended_distance y (would_be_Cauchy u))\n                      \\<le> extended_distance (u n) (would_be_Cauchy u)", "apply (auto simp add: algebra_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>would_be_Cauchy u \\<in> extended_distance_set;\n     y \\<in> extended_distance_set;\n     \\<And>x y z.\n        \\<lbrakk>x \\<in> extended_distance_set;\n         y \\<in> extended_distance_set;\n         z \\<in> extended_distance_set\\<rbrakk>\n        \\<Longrightarrow> extended_distance x z\n                          \\<le> extended_distance x y +\n                                extended_distance y z;\n     u n \\<in> extended_distance_set;\n     u n \\<in> wo.underS (would_be_Cauchy u)\\<rbrakk>\n    \\<Longrightarrow> extended_distance y (u n)\n                      \\<le> extended_distance y (would_be_Cauchy u) +\n                            extended_distance (u n) (would_be_Cauchy u)", "by (metis metric_space_class.extended_distance_symmetric)"], ["proof (state)\nthis:\n  \\<bar>extended_distance y (u ?n1) -\n        extended_distance y (would_be_Cauchy u)\\<bar>\n  \\<le> extended_distance (u ?n1) (would_be_Cauchy u)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "have b: \"(\\<lambda>n. extended_distance (u n) (would_be_Cauchy u)) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance (u n) (would_be_Cauchy u))\n    \\<longlonglongrightarrow> 0", "unfolding C"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance (u n) (would_be_Cauchy u))\n    \\<longlonglongrightarrow> 0", "apply (rule metric_space_class.extended_distance_Cauchy(2))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n. u n \\<in> extended_distance_set\n 2. \\<forall>eps>0.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. extended_distance (u n) (u m) < eps", "using metric_space_class.extended_distance_set_Cauchy[of u] C 2"], ["proof (prove)\nusing this:\n  would_be_Cauchy u \\<in> extended_distance_set \\<Longrightarrow>\n  u ?n \\<in> extended_distance_set \\<inter> wo.underS (would_be_Cauchy u)\n  would_be_Cauchy u \\<in> extended_distance_set \\<Longrightarrow>\n  \\<forall>eps>0.\n     \\<exists>N.\n        \\<forall>n\\<ge>N.\n           \\<forall>m\\<ge>N. extended_distance (u n) (u m) < eps\n  a = would_be_Cauchy u\n  a \\<in> extended_distance_set\n\ngoal (2 subgoals):\n 1. \\<And>n. u n \\<in> extended_distance_set\n 2. \\<forall>eps>0.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. extended_distance (u n) (u m) < eps", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. extended_distance (u n) (would_be_Cauchy u))\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "have \"(\\<lambda>n. abs(extended_distance y (u n) - extended_distance y (would_be_Cauchy u))) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        \\<bar>extended_distance y (u n) -\n              extended_distance y (would_be_Cauchy u)\\<bar>)\n    \\<longlonglongrightarrow> 0", "apply (rule tendsto_sandwich[of \"\\<lambda>_. 0\", OF _ _ _ b])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       0 \\<le> \\<bar>extended_distance y (u n) -\n                     extended_distance y (would_be_Cauchy u)\\<bar>\n 2. \\<forall>\\<^sub>F n in sequentially.\n       \\<bar>extended_distance y (u n) -\n             extended_distance y (would_be_Cauchy u)\\<bar>\n       \\<le> extended_distance (u n) (would_be_Cauchy u)\n 3. (\\<lambda>_. 0) \\<longlonglongrightarrow> 0", "using a"], ["proof (prove)\nusing this:\n  \\<bar>extended_distance y (u ?n1) -\n        extended_distance y (would_be_Cauchy u)\\<bar>\n  \\<le> extended_distance (u ?n1) (would_be_Cauchy u)\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       0 \\<le> \\<bar>extended_distance y (u n) -\n                     extended_distance y (would_be_Cauchy u)\\<bar>\n 2. \\<forall>\\<^sub>F n in sequentially.\n       \\<bar>extended_distance y (u n) -\n             extended_distance y (would_be_Cauchy u)\\<bar>\n       \\<le> extended_distance (u n) (would_be_Cauchy u)\n 3. (\\<lambda>_. 0) \\<longlonglongrightarrow> 0", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      \\<bar>extended_distance y (u n) -\n            extended_distance y (would_be_Cauchy u)\\<bar>)\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n.\n      \\<bar>extended_distance y (u n) -\n            extended_distance y (would_be_Cauchy u)\\<bar>)\n  \\<longlonglongrightarrow> 0", "show \"(\\<lambda>n. extended_distance y (u n)) \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)\""], ["proof (prove)\nusing this:\n  (\\<lambda>n.\n      \\<bar>extended_distance y (u n) -\n            extended_distance y (would_be_Cauchy u)\\<bar>)\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "using Lim_null tendsto_rabs_zero_cancel"], ["proof (prove)\nusing this:\n  (\\<lambda>n.\n      \\<bar>extended_distance y (u n) -\n            extended_distance y (would_be_Cauchy u)\\<bar>)\n  \\<longlonglongrightarrow> 0\n  (?f \\<longlongrightarrow> ?l) ?net =\n  ((\\<lambda>x. ?f x - ?l) \\<longlongrightarrow> (0::?'b)) ?net\n  ((\\<lambda>x. \\<bar>?f x\\<bar>) \\<longlongrightarrow> 0)\n   ?F \\<Longrightarrow>\n  (?f \\<longlongrightarrow> 0) ?F\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_distance y (u n))\n    \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>n. extended_distance y (u n))\n  \\<longlonglongrightarrow> extended_distance y (would_be_Cauchy u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?y1 \\<in> extended_distance_set \\<Longrightarrow>\n  (\\<lambda>n. extended_distance ?y1 (u n))\n  \\<longlonglongrightarrow> extended_distance ?y1 (would_be_Cauchy u)\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 2. \\<And>x3.\n       a = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "have \"max (extended_distance (u n) z + extended_distance y t) (extended_distance (u n) t + extended_distance y z) + 2 * deltaG(TYPE('a)) - extended_distance (u n) y - extended_distance z t \\<ge> 0\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> max (extended_distance (u n) z + extended_distance y t)\n             (extended_distance (u n) t + extended_distance y z) +\n            2 * deltaG TYPE('a) -\n            extended_distance (u n) y -\n            extended_distance z t", "using IH[of \"u n\" y z t] u yzt C"], ["proof (prove)\nusing this:\n  \\<lbrakk>u n \\<in> wo.underS a \\<inter> extended_distance_set;\n   y \\<in> wo.underS a \\<inter> extended_distance_set;\n   z \\<in> wo.underS a \\<inter> extended_distance_set;\n   t \\<in> wo.underS a \\<inter> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance (u n) y + extended_distance z t\n                    \\<le> max (extended_distance (u n) z +\n                               extended_distance y t)\n                           (extended_distance (u n) t +\n                            extended_distance y z) +\n                          2 * deltaG TYPE('a)\n  would_be_Cauchy u \\<in> extended_distance_set\n  u ?n1 \\<in> extended_distance_set \\<inter> wo.underS (would_be_Cauchy u)\n  y \\<in> wo.underS a \\<inter> extended_distance_set\n  z \\<in> wo.underS a \\<inter> extended_distance_set\n  t \\<in> wo.underS a \\<inter> extended_distance_set\n  a = would_be_Cauchy u\n\ngoal (1 subgoal):\n 1. 0 \\<le> max (extended_distance (u n) z + extended_distance y t)\n             (extended_distance (u n) t + extended_distance y z) +\n            2 * deltaG TYPE('a) -\n            extended_distance (u n) y -\n            extended_distance z t", "by auto"], ["proof (state)\nthis:\n  0 \\<le> max (extended_distance (u ?n1) z + extended_distance y t)\n           (extended_distance (u ?n1) t + extended_distance y z) +\n          2 * deltaG TYPE('a) -\n          extended_distance (u ?n1) y -\n          extended_distance z t\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 2. \\<And>x3.\n       a = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "moreover"], ["proof (state)\nthis:\n  0 \\<le> max (extended_distance (u ?n1) z + extended_distance y t)\n           (extended_distance (u ?n1) t + extended_distance y z) +\n          2 * deltaG TYPE('a) -\n          extended_distance (u ?n1) y -\n          extended_distance z t\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 2. \\<And>x3.\n       a = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "have \"(\\<lambda>n. max (extended_distance (u n) z + extended_distance y t) (extended_distance (u n) t + extended_distance y z) + 2 * deltaG(TYPE('a)) - extended_distance (u n) y - extended_distance z t)\n              \\<longlonglongrightarrow> max (extended_distance (would_be_Cauchy u) z + extended_distance y t) (extended_distance (would_be_Cauchy u) t + extended_distance y z) + 2 * deltaG(TYPE('a)) - extended_distance (would_be_Cauchy u) y - extended_distance z t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        max (extended_distance (u n) z + extended_distance y t)\n         (extended_distance (u n) t + extended_distance y z) +\n        2 * deltaG TYPE('a) -\n        extended_distance (u n) y -\n        extended_distance z t)\n    \\<longlonglongrightarrow> max (extended_distance (would_be_Cauchy u) z +\n                                   extended_distance y t)\n                               (extended_distance (would_be_Cauchy u) t +\n                                extended_distance y z) +\n                              2 * deltaG TYPE('a) -\n                              extended_distance (would_be_Cauchy u) y -\n                              extended_distance z t", "apply (auto intro!: tendsto_intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>x. extended_distance (u x) z)\n    \\<longlonglongrightarrow> extended_distance (would_be_Cauchy u) z\n 2. (\\<lambda>x. extended_distance (u x) t)\n    \\<longlonglongrightarrow> extended_distance (would_be_Cauchy u) t\n 3. (\\<lambda>x. extended_distance (u x) y)\n    \\<longlonglongrightarrow> extended_distance (would_be_Cauchy u) y", "using lim that u"], ["proof (prove)\nusing this:\n  ?y1 \\<in> extended_distance_set \\<Longrightarrow>\n  (\\<lambda>n. extended_distance ?y1 (u n))\n  \\<longlonglongrightarrow> extended_distance ?y1 (would_be_Cauchy u)\n  y \\<in> wo.underS a \\<inter> extended_distance_set\n  z \\<in> wo.underS a \\<inter> extended_distance_set\n  t \\<in> wo.underS a \\<inter> extended_distance_set\n  would_be_Cauchy u \\<in> extended_distance_set\n  u ?n1 \\<in> extended_distance_set \\<inter> wo.underS (would_be_Cauchy u)\n\ngoal (3 subgoals):\n 1. (\\<lambda>x. extended_distance (u x) z)\n    \\<longlonglongrightarrow> extended_distance (would_be_Cauchy u) z\n 2. (\\<lambda>x. extended_distance (u x) t)\n    \\<longlonglongrightarrow> extended_distance (would_be_Cauchy u) t\n 3. (\\<lambda>x. extended_distance (u x) y)\n    \\<longlonglongrightarrow> extended_distance (would_be_Cauchy u) y", "by (auto simp add: metric_space_class.extended_distance_symmetric)"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      max (extended_distance (u n) z + extended_distance y t)\n       (extended_distance (u n) t + extended_distance y z) +\n      2 * deltaG TYPE('a) -\n      extended_distance (u n) y -\n      extended_distance z t)\n  \\<longlonglongrightarrow> max (extended_distance (would_be_Cauchy u) z +\n                                 extended_distance y t)\n                             (extended_distance (would_be_Cauchy u) t +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a) -\n                            extended_distance (would_be_Cauchy u) y -\n                            extended_distance z t\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 2. \\<And>x3.\n       a = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "ultimately"], ["proof (chain)\npicking this:\n  0 \\<le> max (extended_distance (u ?n1) z + extended_distance y t)\n           (extended_distance (u ?n1) t + extended_distance y z) +\n          2 * deltaG TYPE('a) -\n          extended_distance (u ?n1) y -\n          extended_distance z t\n  (\\<lambda>n.\n      max (extended_distance (u n) z + extended_distance y t)\n       (extended_distance (u n) t + extended_distance y z) +\n      2 * deltaG TYPE('a) -\n      extended_distance (u n) y -\n      extended_distance z t)\n  \\<longlonglongrightarrow> max (extended_distance (would_be_Cauchy u) z +\n                                 extended_distance y t)\n                             (extended_distance (would_be_Cauchy u) t +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a) -\n                            extended_distance (would_be_Cauchy u) y -\n                            extended_distance z t", "have I: \"max (extended_distance (would_be_Cauchy u) z + extended_distance y t) (extended_distance (would_be_Cauchy u) t + extended_distance y z) + 2 * deltaG(TYPE('a)) - extended_distance (would_be_Cauchy u) y - extended_distance z t \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> max (extended_distance (u ?n1) z + extended_distance y t)\n           (extended_distance (u ?n1) t + extended_distance y z) +\n          2 * deltaG TYPE('a) -\n          extended_distance (u ?n1) y -\n          extended_distance z t\n  (\\<lambda>n.\n      max (extended_distance (u n) z + extended_distance y t)\n       (extended_distance (u n) t + extended_distance y z) +\n      2 * deltaG TYPE('a) -\n      extended_distance (u n) y -\n      extended_distance z t)\n  \\<longlonglongrightarrow> max (extended_distance (would_be_Cauchy u) z +\n                                 extended_distance y t)\n                             (extended_distance (would_be_Cauchy u) t +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a) -\n                            extended_distance (would_be_Cauchy u) y -\n                            extended_distance z t\n\ngoal (1 subgoal):\n 1. 0 \\<le> max (extended_distance (would_be_Cauchy u) z +\n                 extended_distance y t)\n             (extended_distance (would_be_Cauchy u) t +\n              extended_distance y z) +\n            2 * deltaG TYPE('a) -\n            extended_distance (would_be_Cauchy u) y -\n            extended_distance z t", "using LIMSEQ_le_const"], ["proof (prove)\nusing this:\n  0 \\<le> max (extended_distance (u ?n1) z + extended_distance y t)\n           (extended_distance (u ?n1) t + extended_distance y z) +\n          2 * deltaG TYPE('a) -\n          extended_distance (u ?n1) y -\n          extended_distance z t\n  (\\<lambda>n.\n      max (extended_distance (u n) z + extended_distance y t)\n       (extended_distance (u n) t + extended_distance y z) +\n      2 * deltaG TYPE('a) -\n      extended_distance (u n) y -\n      extended_distance z t)\n  \\<longlonglongrightarrow> max (extended_distance (would_be_Cauchy u) z +\n                                 extended_distance y t)\n                             (extended_distance (would_be_Cauchy u) t +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a) -\n                            extended_distance (would_be_Cauchy u) y -\n                            extended_distance z t\n  \\<lbrakk>?X \\<longlonglongrightarrow> ?x;\n   \\<exists>N. \\<forall>n\\<ge>N. ?a \\<le> ?X n\\<rbrakk>\n  \\<Longrightarrow> ?a \\<le> ?x\n\ngoal (1 subgoal):\n 1. 0 \\<le> max (extended_distance (would_be_Cauchy u) z +\n                 extended_distance y t)\n             (extended_distance (would_be_Cauchy u) t +\n              extended_distance y z) +\n            2 * deltaG TYPE('a) -\n            extended_distance (would_be_Cauchy u) y -\n            extended_distance z t", "by blast"], ["proof (state)\nthis:\n  0 \\<le> max (extended_distance (would_be_Cauchy u) z +\n               extended_distance y t)\n           (extended_distance (would_be_Cauchy u) t +\n            extended_distance y z) +\n          2 * deltaG TYPE('a) -\n          extended_distance (would_be_Cauchy u) y -\n          extended_distance z t\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)\n 2. \\<And>x3.\n       a = would_be_Cauchy x3 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  0 \\<le> max (extended_distance (would_be_Cauchy u) z +\n               extended_distance y t)\n           (extended_distance (would_be_Cauchy u) t +\n            extended_distance y z) +\n          2 * deltaG TYPE('a) -\n          extended_distance (would_be_Cauchy u) y -\n          extended_distance z t", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> max (extended_distance (would_be_Cauchy u) z +\n               extended_distance y t)\n           (extended_distance (would_be_Cauchy u) t +\n            extended_distance y z) +\n          2 * deltaG TYPE('a) -\n          extended_distance (would_be_Cauchy u) y -\n          extended_distance z t\n\ngoal (1 subgoal):\n 1. extended_distance a y + extended_distance z t\n    \\<le> max (extended_distance a z + extended_distance y t)\n           (extended_distance a t + extended_distance y z) +\n          2 * deltaG TYPE('a)", "unfolding C"], ["proof (prove)\nusing this:\n  0 \\<le> max (extended_distance (would_be_Cauchy u) z +\n               extended_distance y t)\n           (extended_distance (would_be_Cauchy u) t +\n            extended_distance y z) +\n          2 * deltaG TYPE('a) -\n          extended_distance (would_be_Cauchy u) y -\n          extended_distance z t\n\ngoal (1 subgoal):\n 1. extended_distance (would_be_Cauchy u) y + extended_distance z t\n    \\<le> max (extended_distance (would_be_Cauchy u) z +\n               extended_distance y t)\n           (extended_distance (would_be_Cauchy u) t +\n            extended_distance y z) +\n          2 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  extended_distance a y + extended_distance z t\n  \\<le> max (extended_distance a z + extended_distance y t)\n         (extended_distance a t + extended_distance y z) +\n        2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "(*In the case of a middle, the desired inequality follows from the formula defining\n        the distance to the middle, and simple computations, as explained by Bonk and Schramm.*)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "case M: (middle c d)"], ["proof (state)\nthis:\n  a = middle c d\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  a = middle c d", "have cd: \"c \\<in> extended_distance_set \\<inter> wo.underS (middle c d)\"\n                      \"d \\<in> extended_distance_set \\<inter> wo.underS (middle c d)\""], ["proof (prove)\nusing this:\n  a = middle c d\n\ngoal (1 subgoal):\n 1. c \\<in> extended_distance_set \\<inter> wo.underS (middle c d) &&&\n    d \\<in> extended_distance_set \\<inter> wo.underS (middle c d)", "using 2 metric_space_class.extended_distance_set_middle'[of c d]"], ["proof (prove)\nusing this:\n  a = middle c d\n  a \\<in> extended_distance_set\n  middle c d \\<in> extended_distance_set \\<Longrightarrow>\n  c \\<in> extended_distance_set \\<inter> wo.underS (middle c d)\n  middle c d \\<in> extended_distance_set \\<Longrightarrow>\n  d \\<in> extended_distance_set \\<inter> wo.underS (middle c d)\n\ngoal (1 subgoal):\n 1. c \\<in> extended_distance_set \\<inter> wo.underS (middle c d) &&&\n    d \\<in> extended_distance_set \\<inter> wo.underS (middle c d)", "by auto"], ["proof (state)\nthis:\n  c \\<in> extended_distance_set \\<inter> wo.underS (middle c d)\n  d \\<in> extended_distance_set \\<inter> wo.underS (middle c d)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "have bdd: \"bdd_above ((\\<lambda>w. extended_distance s w - max (extended_distance c w) (extended_distance d w))` (wo.underS (middle c d) \\<inter> extended_distance_set))\"\n          if \"s \\<in> extended_distance_set\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above\n     ((\\<lambda>w.\n          extended_distance s w -\n          max (extended_distance c w) (extended_distance d w)) `\n      (wo.underS (middle c d) \\<inter> extended_distance_set))", "proof (rule bdd_aboveI2)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> wo.underS (middle c d) \\<inter>\n               extended_distance_set \\<Longrightarrow>\n       extended_distance s x -\n       max (extended_distance c x) (extended_distance d x)\n       \\<le> ?M", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> wo.underS (middle c d) \\<inter>\n               extended_distance_set \\<Longrightarrow>\n       extended_distance s x -\n       max (extended_distance c x) (extended_distance d x)\n       \\<le> ?M", "assume w: \"w \\<in> wo.underS (middle c d) \\<inter> extended_distance_set\""], ["proof (state)\nthis:\n  w \\<in> wo.underS (middle c d) \\<inter> extended_distance_set\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> wo.underS (middle c d) \\<inter>\n               extended_distance_set \\<Longrightarrow>\n       extended_distance s x -\n       max (extended_distance c x) (extended_distance d x)\n       \\<le> ?M", "have \"extended_distance s w \\<le> extended_distance s c + extended_distance c w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance s w\n    \\<le> extended_distance s c + extended_distance c w", "using w that metric_space_class.extended_distance_triang_ineq cd"], ["proof (prove)\nusing this:\n  w \\<in> wo.underS (middle c d) \\<inter> extended_distance_set\n  s \\<in> extended_distance_set\n  \\<lbrakk>?x \\<in> extended_distance_set; ?y \\<in> extended_distance_set;\n   ?z \\<in> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x ?z\n                    \\<le> extended_distance ?x ?y + extended_distance ?y ?z\n  c \\<in> extended_distance_set \\<inter> wo.underS (middle c d)\n  d \\<in> extended_distance_set \\<inter> wo.underS (middle c d)\n\ngoal (1 subgoal):\n 1. extended_distance s w\n    \\<le> extended_distance s c + extended_distance c w", "by auto"], ["proof (state)\nthis:\n  extended_distance s w \\<le> extended_distance s c + extended_distance c w\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> wo.underS (middle c d) \\<inter>\n               extended_distance_set \\<Longrightarrow>\n       extended_distance s x -\n       max (extended_distance c x) (extended_distance d x)\n       \\<le> ?M", "also"], ["proof (state)\nthis:\n  extended_distance s w \\<le> extended_distance s c + extended_distance c w\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> wo.underS (middle c d) \\<inter>\n               extended_distance_set \\<Longrightarrow>\n       extended_distance s x -\n       max (extended_distance c x) (extended_distance d x)\n       \\<le> ?M", "have \"... \\<le> extended_distance s c + max (extended_distance c w) (extended_distance d w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance s c + extended_distance c w\n    \\<le> extended_distance s c +\n          max (extended_distance c w) (extended_distance d w)", "by auto"], ["proof (state)\nthis:\n  extended_distance s c + extended_distance c w\n  \\<le> extended_distance s c +\n        max (extended_distance c w) (extended_distance d w)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> wo.underS (middle c d) \\<inter>\n               extended_distance_set \\<Longrightarrow>\n       extended_distance s x -\n       max (extended_distance c x) (extended_distance d x)\n       \\<le> ?M", "finally"], ["proof (chain)\npicking this:\n  extended_distance s w\n  \\<le> extended_distance s c +\n        max (extended_distance c w) (extended_distance d w)", "show \"extended_distance s w - max (extended_distance c w) (extended_distance d w)\n                       \\<le> extended_distance s c\""], ["proof (prove)\nusing this:\n  extended_distance s w\n  \\<le> extended_distance s c +\n        max (extended_distance c w) (extended_distance d w)\n\ngoal (1 subgoal):\n 1. extended_distance s w -\n    max (extended_distance c w) (extended_distance d w)\n    \\<le> extended_distance s c", "by auto"], ["proof (state)\nthis:\n  extended_distance s w -\n  max (extended_distance c w) (extended_distance d w)\n  \\<le> extended_distance s c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?s1 \\<in> extended_distance_set \\<Longrightarrow>\n  bdd_above\n   ((\\<lambda>w.\n        extended_distance ?s1 w -\n        max (extended_distance c w) (extended_distance d w)) `\n    (wo.underS (middle c d) \\<inter> extended_distance_set))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "have I: \"extended_distance y w - max (extended_distance c w) (extended_distance d w)\n              \\<le> max (extended_distance y z + extended_distance t (middle c d)) (extended_distance y t + extended_distance z (middle c d)) + 2 * deltaG(TYPE('a))\n                - (extended_distance c d)/2 - extended_distance z t\"\n          if w: \"w \\<in> wo.underS (middle c d) \\<inter> extended_distance_set\" for w"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance y w -\n    max (extended_distance c w) (extended_distance d w)\n    \\<le> max (extended_distance y z + extended_distance t (middle c d))\n           (extended_distance y t + extended_distance z (middle c d)) +\n          2 * deltaG TYPE('a) -\n          extended_distance c d / 2 -\n          extended_distance z t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. extended_distance y w -\n    max (extended_distance c w) (extended_distance d w)\n    \\<le> max (extended_distance y z + extended_distance t (middle c d))\n           (extended_distance y t + extended_distance z (middle c d)) +\n          2 * deltaG TYPE('a) -\n          extended_distance c d / 2 -\n          extended_distance z t", "have J: \"(extended_distance c d)/2 + extended_distance s w - max (extended_distance c w) (extended_distance d w) \\<le> extended_distance s (middle c d)\"\n              if \"s \\<in> wo.underS a \\<inter> extended_distance_set\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance c d / 2 + extended_distance s w -\n    max (extended_distance c w) (extended_distance d w)\n    \\<le> extended_distance s (middle c d)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. extended_distance c d / 2 + extended_distance s w -\n    max (extended_distance c w) (extended_distance d w)\n    \\<le> extended_distance s (middle c d)", "have \"(extended_distance c d)/2 + extended_distance s w - max (extended_distance c w) (extended_distance d w)\n                \\<le> (extended_distance c d)/2\n                    + (SUP w\\<in>wo.underS (middle c d) \\<inter> extended_distance_set. extended_distance s w - max (extended_distance c w) (extended_distance d w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance c d / 2 + extended_distance s w -\n    max (extended_distance c w) (extended_distance d w)\n    \\<le> extended_distance c d / 2 +\n          (SUP w\\<in>wo.underS (middle c d) \\<inter> extended_distance_set.\n              extended_distance s w -\n              max (extended_distance c w) (extended_distance d w))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance s w -\n    max (extended_distance c w) (extended_distance d w)\n    \\<le> (SUP w\\<in>wo.underS (middle c d) \\<inter> extended_distance_set.\n              extended_distance s w -\n              max (extended_distance c w) (extended_distance d w))", "apply (rule cSUP_upper)"], ["proof (prove)\ngoal (2 subgoals):\n 1. w \\<in> wo.underS (middle c d) \\<inter> extended_distance_set\n 2. bdd_above\n     ((\\<lambda>w.\n          extended_distance s w -\n          max (extended_distance c w) (extended_distance d w)) `\n      (wo.underS (middle c d) \\<inter> extended_distance_set))", "using w bdd that"], ["proof (prove)\nusing this:\n  w \\<in> wo.underS (middle c d) \\<inter> extended_distance_set\n  ?s1 \\<in> extended_distance_set \\<Longrightarrow>\n  bdd_above\n   ((\\<lambda>w.\n        extended_distance ?s1 w -\n        max (extended_distance c w) (extended_distance d w)) `\n    (wo.underS (middle c d) \\<inter> extended_distance_set))\n  s \\<in> wo.underS a \\<inter> extended_distance_set\n\ngoal (2 subgoals):\n 1. w \\<in> wo.underS (middle c d) \\<inter> extended_distance_set\n 2. bdd_above\n     ((\\<lambda>w.\n          extended_distance s w -\n          max (extended_distance c w) (extended_distance d w)) `\n      (wo.underS (middle c d) \\<inter> extended_distance_set))", "by auto"], ["proof (state)\nthis:\n  extended_distance c d / 2 + extended_distance s w -\n  max (extended_distance c w) (extended_distance d w)\n  \\<le> extended_distance c d / 2 +\n        (SUP w\\<in>wo.underS (middle c d) \\<inter> extended_distance_set.\n            extended_distance s w -\n            max (extended_distance c w) (extended_distance d w))\n\ngoal (1 subgoal):\n 1. extended_distance c d / 2 + extended_distance s w -\n    max (extended_distance c w) (extended_distance d w)\n    \\<le> extended_distance s (middle c d)", "also"], ["proof (state)\nthis:\n  extended_distance c d / 2 + extended_distance s w -\n  max (extended_distance c w) (extended_distance d w)\n  \\<le> extended_distance c d / 2 +\n        (SUP w\\<in>wo.underS (middle c d) \\<inter> extended_distance_set.\n            extended_distance s w -\n            max (extended_distance c w) (extended_distance d w))\n\ngoal (1 subgoal):\n 1. extended_distance c d / 2 + extended_distance s w -\n    max (extended_distance c w) (extended_distance d w)\n    \\<le> extended_distance s (middle c d)", "have \"... = extended_distance s (middle c d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance c d / 2 +\n    (SUP w\\<in>wo.underS (middle c d) \\<inter> extended_distance_set.\n        extended_distance s w -\n        max (extended_distance c w) (extended_distance d w)) =\n    extended_distance s (middle c d)", "apply (rule metric_space_class.extended_distance_middle_formula[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> wo.underS (middle c d)", "using that M"], ["proof (prove)\nusing this:\n  s \\<in> wo.underS a \\<inter> extended_distance_set\n  a = middle c d\n\ngoal (1 subgoal):\n 1. s \\<in> wo.underS (middle c d)", "by auto"], ["proof (state)\nthis:\n  extended_distance c d / 2 +\n  (SUP w\\<in>wo.underS (middle c d) \\<inter> extended_distance_set.\n      extended_distance s w -\n      max (extended_distance c w) (extended_distance d w)) =\n  extended_distance s (middle c d)\n\ngoal (1 subgoal):\n 1. extended_distance c d / 2 + extended_distance s w -\n    max (extended_distance c w) (extended_distance d w)\n    \\<le> extended_distance s (middle c d)", "finally"], ["proof (chain)\npicking this:\n  extended_distance c d / 2 + extended_distance s w -\n  max (extended_distance c w) (extended_distance d w)\n  \\<le> extended_distance s (middle c d)", "show ?thesis"], ["proof (prove)\nusing this:\n  extended_distance c d / 2 + extended_distance s w -\n  max (extended_distance c w) (extended_distance d w)\n  \\<le> extended_distance s (middle c d)\n\ngoal (1 subgoal):\n 1. extended_distance c d / 2 + extended_distance s w -\n    max (extended_distance c w) (extended_distance d w)\n    \\<le> extended_distance s (middle c d)", "by simp"], ["proof (state)\nthis:\n  extended_distance c d / 2 + extended_distance s w -\n  max (extended_distance c w) (extended_distance d w)\n  \\<le> extended_distance s (middle c d)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?s1 \\<in> wo.underS a \\<inter> extended_distance_set \\<Longrightarrow>\n  extended_distance c d / 2 + extended_distance ?s1 w -\n  max (extended_distance c w) (extended_distance d w)\n  \\<le> extended_distance ?s1 (middle c d)\n\ngoal (1 subgoal):\n 1. extended_distance y w -\n    max (extended_distance c w) (extended_distance d w)\n    \\<le> max (extended_distance y z + extended_distance t (middle c d))\n           (extended_distance y t + extended_distance z (middle c d)) +\n          2 * deltaG TYPE('a) -\n          extended_distance c d / 2 -\n          extended_distance z t", "have \"(extended_distance c d)/2 + extended_distance y w - max (extended_distance c w) (extended_distance d w) + extended_distance z t\n            \\<le> (extended_distance c d)/2 + max (extended_distance y z + extended_distance t w) (extended_distance y t + extended_distance z w) + 2 * deltaG(TYPE('a)) - max (extended_distance c w) (extended_distance d w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance c d / 2 + extended_distance y w -\n    max (extended_distance c w) (extended_distance d w) +\n    extended_distance z t\n    \\<le> extended_distance c d / 2 +\n          max (extended_distance y z + extended_distance t w)\n           (extended_distance y t + extended_distance z w) +\n          2 * deltaG TYPE('a) -\n          max (extended_distance c w) (extended_distance d w)", "using IH[of y w z t] w yzt M"], ["proof (prove)\nusing this:\n  \\<lbrakk>y \\<in> wo.underS a \\<inter> extended_distance_set;\n   w \\<in> wo.underS a \\<inter> extended_distance_set;\n   z \\<in> wo.underS a \\<inter> extended_distance_set;\n   t \\<in> wo.underS a \\<inter> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance y w + extended_distance z t\n                    \\<le> max (extended_distance y z +\n                               extended_distance w t)\n                           (extended_distance y t + extended_distance w z) +\n                          2 * deltaG TYPE('a)\n  w \\<in> wo.underS (middle c d) \\<inter> extended_distance_set\n  y \\<in> wo.underS a \\<inter> extended_distance_set\n  z \\<in> wo.underS a \\<inter> extended_distance_set\n  t \\<in> wo.underS a \\<inter> extended_distance_set\n  a = middle c d\n\ngoal (1 subgoal):\n 1. extended_distance c d / 2 + extended_distance y w -\n    max (extended_distance c w) (extended_distance d w) +\n    extended_distance z t\n    \\<le> extended_distance c d / 2 +\n          max (extended_distance y z + extended_distance t w)\n           (extended_distance y t + extended_distance z w) +\n          2 * deltaG TYPE('a) -\n          max (extended_distance c w) (extended_distance d w)", "by (auto simp add: metric_space_class.extended_distance_symmetric)"], ["proof (state)\nthis:\n  extended_distance c d / 2 + extended_distance y w -\n  max (extended_distance c w) (extended_distance d w) +\n  extended_distance z t\n  \\<le> extended_distance c d / 2 +\n        max (extended_distance y z + extended_distance t w)\n         (extended_distance y t + extended_distance z w) +\n        2 * deltaG TYPE('a) -\n        max (extended_distance c w) (extended_distance d w)\n\ngoal (1 subgoal):\n 1. extended_distance y w -\n    max (extended_distance c w) (extended_distance d w)\n    \\<le> max (extended_distance y z + extended_distance t (middle c d))\n           (extended_distance y t + extended_distance z (middle c d)) +\n          2 * deltaG TYPE('a) -\n          extended_distance c d / 2 -\n          extended_distance z t", "also"], ["proof (state)\nthis:\n  extended_distance c d / 2 + extended_distance y w -\n  max (extended_distance c w) (extended_distance d w) +\n  extended_distance z t\n  \\<le> extended_distance c d / 2 +\n        max (extended_distance y z + extended_distance t w)\n         (extended_distance y t + extended_distance z w) +\n        2 * deltaG TYPE('a) -\n        max (extended_distance c w) (extended_distance d w)\n\ngoal (1 subgoal):\n 1. extended_distance y w -\n    max (extended_distance c w) (extended_distance d w)\n    \\<le> max (extended_distance y z + extended_distance t (middle c d))\n           (extended_distance y t + extended_distance z (middle c d)) +\n          2 * deltaG TYPE('a) -\n          extended_distance c d / 2 -\n          extended_distance z t", "have \"... = max (extended_distance y z + (extended_distance c d)/2 + extended_distance t w - max (extended_distance c w) (extended_distance d w))\n                               (extended_distance y t + (extended_distance c d)/2 + extended_distance z w - max (extended_distance c w) (extended_distance d w))\n                            + 2 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance c d / 2 +\n    max (extended_distance y z + extended_distance t w)\n     (extended_distance y t + extended_distance z w) +\n    2 * deltaG TYPE('a) -\n    max (extended_distance c w) (extended_distance d w) =\n    max (extended_distance y z + extended_distance c d / 2 +\n         extended_distance t w -\n         max (extended_distance c w) (extended_distance d w))\n     (extended_distance y t + extended_distance c d / 2 +\n      extended_distance z w -\n      max (extended_distance c w) (extended_distance d w)) +\n    2 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  extended_distance c d / 2 +\n  max (extended_distance y z + extended_distance t w)\n   (extended_distance y t + extended_distance z w) +\n  2 * deltaG TYPE('a) -\n  max (extended_distance c w) (extended_distance d w) =\n  max (extended_distance y z + extended_distance c d / 2 +\n       extended_distance t w -\n       max (extended_distance c w) (extended_distance d w))\n   (extended_distance y t + extended_distance c d / 2 +\n    extended_distance z w -\n    max (extended_distance c w) (extended_distance d w)) +\n  2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. extended_distance y w -\n    max (extended_distance c w) (extended_distance d w)\n    \\<le> max (extended_distance y z + extended_distance t (middle c d))\n           (extended_distance y t + extended_distance z (middle c d)) +\n          2 * deltaG TYPE('a) -\n          extended_distance c d / 2 -\n          extended_distance z t", "also"], ["proof (state)\nthis:\n  extended_distance c d / 2 +\n  max (extended_distance y z + extended_distance t w)\n   (extended_distance y t + extended_distance z w) +\n  2 * deltaG TYPE('a) -\n  max (extended_distance c w) (extended_distance d w) =\n  max (extended_distance y z + extended_distance c d / 2 +\n       extended_distance t w -\n       max (extended_distance c w) (extended_distance d w))\n   (extended_distance y t + extended_distance c d / 2 +\n    extended_distance z w -\n    max (extended_distance c w) (extended_distance d w)) +\n  2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. extended_distance y w -\n    max (extended_distance c w) (extended_distance d w)\n    \\<le> max (extended_distance y z + extended_distance t (middle c d))\n           (extended_distance y t + extended_distance z (middle c d)) +\n          2 * deltaG TYPE('a) -\n          extended_distance c d / 2 -\n          extended_distance z t", "have \"... \\<le> max (extended_distance y z + extended_distance t (middle c d)) (extended_distance y t + extended_distance z (middle c d)) + 2 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (extended_distance y z + extended_distance c d / 2 +\n         extended_distance t w -\n         max (extended_distance c w) (extended_distance d w))\n     (extended_distance y t + extended_distance c d / 2 +\n      extended_distance z w -\n      max (extended_distance c w) (extended_distance d w)) +\n    2 * deltaG TYPE('a)\n    \\<le> max (extended_distance y z + extended_distance t (middle c d))\n           (extended_distance y t + extended_distance z (middle c d)) +\n          2 * deltaG TYPE('a)", "using J[OF yzt(3)] J[OF yzt(2)]"], ["proof (prove)\nusing this:\n  extended_distance c d / 2 + extended_distance t w -\n  max (extended_distance c w) (extended_distance d w)\n  \\<le> extended_distance t (middle c d)\n  extended_distance c d / 2 + extended_distance z w -\n  max (extended_distance c w) (extended_distance d w)\n  \\<le> extended_distance z (middle c d)\n\ngoal (1 subgoal):\n 1. max (extended_distance y z + extended_distance c d / 2 +\n         extended_distance t w -\n         max (extended_distance c w) (extended_distance d w))\n     (extended_distance y t + extended_distance c d / 2 +\n      extended_distance z w -\n      max (extended_distance c w) (extended_distance d w)) +\n    2 * deltaG TYPE('a)\n    \\<le> max (extended_distance y z + extended_distance t (middle c d))\n           (extended_distance y t + extended_distance z (middle c d)) +\n          2 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  max (extended_distance y z + extended_distance c d / 2 +\n       extended_distance t w -\n       max (extended_distance c w) (extended_distance d w))\n   (extended_distance y t + extended_distance c d / 2 +\n    extended_distance z w -\n    max (extended_distance c w) (extended_distance d w)) +\n  2 * deltaG TYPE('a)\n  \\<le> max (extended_distance y z + extended_distance t (middle c d))\n         (extended_distance y t + extended_distance z (middle c d)) +\n        2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. extended_distance y w -\n    max (extended_distance c w) (extended_distance d w)\n    \\<le> max (extended_distance y z + extended_distance t (middle c d))\n           (extended_distance y t + extended_distance z (middle c d)) +\n          2 * deltaG TYPE('a) -\n          extended_distance c d / 2 -\n          extended_distance z t", "finally"], ["proof (chain)\npicking this:\n  extended_distance c d / 2 + extended_distance y w -\n  max (extended_distance c w) (extended_distance d w) +\n  extended_distance z t\n  \\<le> max (extended_distance y z + extended_distance t (middle c d))\n         (extended_distance y t + extended_distance z (middle c d)) +\n        2 * deltaG TYPE('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  extended_distance c d / 2 + extended_distance y w -\n  max (extended_distance c w) (extended_distance d w) +\n  extended_distance z t\n  \\<le> max (extended_distance y z + extended_distance t (middle c d))\n         (extended_distance y t + extended_distance z (middle c d)) +\n        2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. extended_distance y w -\n    max (extended_distance c w) (extended_distance d w)\n    \\<le> max (extended_distance y z + extended_distance t (middle c d))\n           (extended_distance y t + extended_distance z (middle c d)) +\n          2 * deltaG TYPE('a) -\n          extended_distance c d / 2 -\n          extended_distance z t", "by simp"], ["proof (state)\nthis:\n  extended_distance y w -\n  max (extended_distance c w) (extended_distance d w)\n  \\<le> max (extended_distance y z + extended_distance t (middle c d))\n         (extended_distance y t + extended_distance z (middle c d)) +\n        2 * deltaG TYPE('a) -\n        extended_distance c d / 2 -\n        extended_distance z t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?w1\n  \\<in> wo.underS (middle c d) \\<inter>\n        extended_distance_set \\<Longrightarrow>\n  extended_distance y ?w1 -\n  max (extended_distance c ?w1) (extended_distance d ?w1)\n  \\<le> max (extended_distance y z + extended_distance t (middle c d))\n         (extended_distance y t + extended_distance z (middle c d)) +\n        2 * deltaG TYPE('a) -\n        extended_distance c d / 2 -\n        extended_distance z t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "have *: \"(SUP w\\<in>wo.underS (middle c d) \\<inter> extended_distance_set. extended_distance y w - max (extended_distance c w) (extended_distance d w)) \\<le>\n                max (extended_distance y z + extended_distance t (middle c d)) (extended_distance y t + extended_distance z (middle c d)) + 2 * deltaG(TYPE('a))\n                - (extended_distance c d)/2 - extended_distance z t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP w\\<in>wo.underS (middle c d) \\<inter> extended_distance_set.\n        extended_distance y w -\n        max (extended_distance c w) (extended_distance d w))\n    \\<le> max (extended_distance y z + extended_distance t (middle c d))\n           (extended_distance y t + extended_distance z (middle c d)) +\n          2 * deltaG TYPE('a) -\n          extended_distance c d / 2 -\n          extended_distance z t", "apply (rule cSUP_least)"], ["proof (prove)\ngoal (2 subgoals):\n 1. wo.underS (middle c d) \\<inter> extended_distance_set \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> wo.underS (middle c d) \\<inter>\n               extended_distance_set \\<Longrightarrow>\n       extended_distance y x -\n       max (extended_distance c x) (extended_distance d x)\n       \\<le> max (extended_distance y z + extended_distance t (middle c d))\n              (extended_distance y t + extended_distance z (middle c d)) +\n             2 * deltaG TYPE('a) -\n             extended_distance c d / 2 -\n             extended_distance z t", "using yzt(1) M I"], ["proof (prove)\nusing this:\n  y \\<in> wo.underS a \\<inter> extended_distance_set\n  a = middle c d\n  ?w1\n  \\<in> wo.underS (middle c d) \\<inter>\n        extended_distance_set \\<Longrightarrow>\n  extended_distance y ?w1 -\n  max (extended_distance c ?w1) (extended_distance d ?w1)\n  \\<le> max (extended_distance y z + extended_distance t (middle c d))\n         (extended_distance y t + extended_distance z (middle c d)) +\n        2 * deltaG TYPE('a) -\n        extended_distance c d / 2 -\n        extended_distance z t\n\ngoal (2 subgoals):\n 1. wo.underS (middle c d) \\<inter> extended_distance_set \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> wo.underS (middle c d) \\<inter>\n               extended_distance_set \\<Longrightarrow>\n       extended_distance y x -\n       max (extended_distance c x) (extended_distance d x)\n       \\<le> max (extended_distance y z + extended_distance t (middle c d))\n              (extended_distance y t + extended_distance z (middle c d)) +\n             2 * deltaG TYPE('a) -\n             extended_distance c d / 2 -\n             extended_distance z t", "by auto"], ["proof (state)\nthis:\n  (SUP w\\<in>wo.underS (middle c d) \\<inter> extended_distance_set.\n      extended_distance y w -\n      max (extended_distance c w) (extended_distance d w))\n  \\<le> max (extended_distance y z + extended_distance t (middle c d))\n         (extended_distance y t + extended_distance z (middle c d)) +\n        2 * deltaG TYPE('a) -\n        extended_distance c d / 2 -\n        extended_distance z t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "have \"extended_distance y (middle c d) + extended_distance z t\n          = (extended_distance c d)/2 + (SUP w\\<in>wo.underS (middle c d) \\<inter> extended_distance_set. extended_distance y w - max (extended_distance c w) (extended_distance d w)) + extended_distance z t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance y (middle c d) + extended_distance z t =\n    extended_distance c d / 2 +\n    (SUP w\\<in>wo.underS (middle c d) \\<inter> extended_distance_set.\n        extended_distance y w -\n        max (extended_distance c w) (extended_distance d w)) +\n    extended_distance z t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance y (middle c d) =\n    extended_distance c d / 2 +\n    (SUP w\\<in>wo.underS (middle c d) \\<inter> extended_distance_set.\n        extended_distance y w -\n        max (extended_distance c w) (extended_distance d w))", "apply (rule metric_space_class.extended_distance_middle_formula)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> wo.underS (middle c d)", "using yzt(1) M"], ["proof (prove)\nusing this:\n  y \\<in> wo.underS a \\<inter> extended_distance_set\n  a = middle c d\n\ngoal (1 subgoal):\n 1. y \\<in> wo.underS (middle c d)", "by auto"], ["proof (state)\nthis:\n  extended_distance y (middle c d) + extended_distance z t =\n  extended_distance c d / 2 +\n  (SUP w\\<in>wo.underS (middle c d) \\<inter> extended_distance_set.\n      extended_distance y w -\n      max (extended_distance c w) (extended_distance d w)) +\n  extended_distance z t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "also"], ["proof (state)\nthis:\n  extended_distance y (middle c d) + extended_distance z t =\n  extended_distance c d / 2 +\n  (SUP w\\<in>wo.underS (middle c d) \\<inter> extended_distance_set.\n      extended_distance y w -\n      max (extended_distance c w) (extended_distance d w)) +\n  extended_distance z t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "have \"... \\<le> max (extended_distance y z + extended_distance t (middle c d)) (extended_distance y t + extended_distance z (middle c d)) + 2 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance c d / 2 +\n    (SUP w\\<in>wo.underS (middle c d) \\<inter> extended_distance_set.\n        extended_distance y w -\n        max (extended_distance c w) (extended_distance d w)) +\n    extended_distance z t\n    \\<le> max (extended_distance y z + extended_distance t (middle c d))\n           (extended_distance y t + extended_distance z (middle c d)) +\n          2 * deltaG TYPE('a)", "using *"], ["proof (prove)\nusing this:\n  (SUP w\\<in>wo.underS (middle c d) \\<inter> extended_distance_set.\n      extended_distance y w -\n      max (extended_distance c w) (extended_distance d w))\n  \\<le> max (extended_distance y z + extended_distance t (middle c d))\n         (extended_distance y t + extended_distance z (middle c d)) +\n        2 * deltaG TYPE('a) -\n        extended_distance c d / 2 -\n        extended_distance z t\n\ngoal (1 subgoal):\n 1. extended_distance c d / 2 +\n    (SUP w\\<in>wo.underS (middle c d) \\<inter> extended_distance_set.\n        extended_distance y w -\n        max (extended_distance c w) (extended_distance d w)) +\n    extended_distance z t\n    \\<le> max (extended_distance y z + extended_distance t (middle c d))\n           (extended_distance y t + extended_distance z (middle c d)) +\n          2 * deltaG TYPE('a)", "by simp"], ["proof (state)\nthis:\n  extended_distance c d / 2 +\n  (SUP w\\<in>wo.underS (middle c d) \\<inter> extended_distance_set.\n      extended_distance y w -\n      max (extended_distance c w) (extended_distance d w)) +\n  extended_distance z t\n  \\<le> max (extended_distance y z + extended_distance t (middle c d))\n         (extended_distance y t + extended_distance z (middle c d)) +\n        2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       a = middle x21 x22 \\<Longrightarrow>\n       extended_distance a y + extended_distance z t\n       \\<le> max (extended_distance a z + extended_distance y t)\n              (extended_distance a t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "finally"], ["proof (chain)\npicking this:\n  extended_distance y (middle c d) + extended_distance z t\n  \\<le> max (extended_distance y z + extended_distance t (middle c d))\n         (extended_distance y t + extended_distance z (middle c d)) +\n        2 * deltaG TYPE('a)", "show \"extended_distance a y + extended_distance z t\n                \\<le> max (extended_distance a z + extended_distance y t) (extended_distance a t + extended_distance y z) + 2 * deltaG(TYPE('a))\""], ["proof (prove)\nusing this:\n  extended_distance y (middle c d) + extended_distance z t\n  \\<le> max (extended_distance y z + extended_distance t (middle c d))\n         (extended_distance y t + extended_distance z (middle c d)) +\n        2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. extended_distance a y + extended_distance z t\n    \\<le> max (extended_distance a z + extended_distance y t)\n           (extended_distance a t + extended_distance y z) +\n          2 * deltaG TYPE('a)", "unfolding M"], ["proof (prove)\nusing this:\n  extended_distance y (middle c d) + extended_distance z t\n  \\<le> max (extended_distance y z + extended_distance t (middle c d))\n         (extended_distance y t + extended_distance z (middle c d)) +\n        2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. extended_distance (middle c d) y + extended_distance z t\n    \\<le> max (extended_distance (middle c d) z + extended_distance y t)\n           (extended_distance (middle c d) t + extended_distance y z) +\n          2 * deltaG TYPE('a)", "by (auto simp add: metric_space_class.extended_distance_symmetric)"], ["proof (state)\nthis:\n  extended_distance a y + extended_distance z t\n  \\<le> max (extended_distance a z + extended_distance y t)\n         (extended_distance a t + extended_distance y z) +\n        2 * deltaG TYPE('a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?y1 \\<in> wo.underS a \\<inter> extended_distance_set;\n   ?z1 \\<in> wo.underS a \\<inter> extended_distance_set;\n   ?t1 \\<in> wo.underS a \\<inter> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance a ?y1 + extended_distance ?z1 ?t1\n                    \\<le> max (extended_distance a ?z1 +\n                               extended_distance ?y1 ?t1)\n                           (extended_distance a ?t1 +\n                            extended_distance ?y1 ?z1) +\n                          2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. a \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z t.\n       x \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       y \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       z \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       t \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       extended_distance x y + extended_distance z t\n       \\<le> max (extended_distance x z + extended_distance y t)\n              (extended_distance x t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "(*To prove the general inequality, we consider\n      separately if each point is equal to $a$ or different from $a$. If no point is equal to $a$,\n      then the inequality follows from the induction assumption. If exactly one point is equal to\n      $a$, we can put in first position by permuting the variables, and use the main inequality\n      above.\n      Finally, if at least two points are equal to $a$, then the inequality follows from the\n      triangular inequality.\n      This reduction is straightforward, and should be automatable, but since there are 4 variables\n      it is too complicated for metis, and we have to do it by hand below.*)"], ["proof (state)\nthis:\n  \\<lbrakk>?y1 \\<in> wo.underS a \\<inter> extended_distance_set;\n   ?z1 \\<in> wo.underS a \\<inter> extended_distance_set;\n   ?t1 \\<in> wo.underS a \\<inter> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance a ?y1 + extended_distance ?z1 ?t1\n                    \\<le> max (extended_distance a ?z1 +\n                               extended_distance ?y1 ?t1)\n                           (extended_distance a ?t1 +\n                            extended_distance ?y1 ?z1) +\n                          2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. a \\<in> extended_distance_set \\<Longrightarrow>\n    \\<forall>x y z t.\n       x \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       y \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       z \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       t \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       extended_distance x y + extended_distance z t\n       \\<le> max (extended_distance x z + extended_distance y t)\n              (extended_distance x t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y z t.\n       x \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       y \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       z \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       t \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n       extended_distance x y + extended_distance z t\n       \\<le> max (extended_distance x z + extended_distance y t)\n              (extended_distance x t + extended_distance y z) +\n             2 * deltaG TYPE('a)", "proof (auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z t.\n       \\<lbrakk>x \\<in> wo.under a; x \\<in> extended_distance_set;\n        y \\<in> wo.under a; y \\<in> extended_distance_set;\n        z \\<in> wo.under a; z \\<in> extended_distance_set;\n        t \\<in> wo.under a; t \\<in> extended_distance_set\\<rbrakk>\n       \\<Longrightarrow> extended_distance x y + extended_distance z t\n                         \\<le> max (extended_distance x z +\n                                    extended_distance y t)\n                                (extended_distance x t +\n                                 extended_distance y z) +\n                               2 * deltaG TYPE('a)", "fix x y z t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z t.\n       \\<lbrakk>x \\<in> wo.under a; x \\<in> extended_distance_set;\n        y \\<in> wo.under a; y \\<in> extended_distance_set;\n        z \\<in> wo.under a; z \\<in> extended_distance_set;\n        t \\<in> wo.under a; t \\<in> extended_distance_set\\<rbrakk>\n       \\<Longrightarrow> extended_distance x y + extended_distance z t\n                         \\<le> max (extended_distance x z +\n                                    extended_distance y t)\n                                (extended_distance x t +\n                                 extended_distance y z) +\n                               2 * deltaG TYPE('a)", "assume H: \"x \\<in> wo.under a\" \"x \\<in> extended_distance_set\"\n                              \"y \\<in> wo.under a\" \"y \\<in> extended_distance_set\"\n                              \"z \\<in> wo.under a\" \"z \\<in> extended_distance_set\"\n                              \"t \\<in> wo.under a\" \"t \\<in> extended_distance_set\""], ["proof (state)\nthis:\n  x \\<in> wo.under a\n  x \\<in> extended_distance_set\n  y \\<in> wo.under a\n  y \\<in> extended_distance_set\n  z \\<in> wo.under a\n  z \\<in> extended_distance_set\n  t \\<in> wo.under a\n  t \\<in> extended_distance_set\n\ngoal (1 subgoal):\n 1. \\<And>x y z t.\n       \\<lbrakk>x \\<in> wo.under a; x \\<in> extended_distance_set;\n        y \\<in> wo.under a; y \\<in> extended_distance_set;\n        z \\<in> wo.under a; z \\<in> extended_distance_set;\n        t \\<in> wo.under a; t \\<in> extended_distance_set\\<rbrakk>\n       \\<Longrightarrow> extended_distance x y + extended_distance z t\n                         \\<le> max (extended_distance x z +\n                                    extended_distance y t)\n                                (extended_distance x t +\n                                 extended_distance y z) +\n                               2 * deltaG TYPE('a)", "have *: \"((x \\<in> wo.underS a \\<inter> extended_distance_set) \\<or> (x = a))\n                \\<and> ((y \\<in> wo.underS a \\<inter> extended_distance_set) \\<or> (y = a))\n                \\<and> ((z \\<in> wo.underS a \\<inter> extended_distance_set) \\<or> (z = a))\n                \\<and> ((t \\<in> wo.underS a \\<inter> extended_distance_set) \\<or> (t = a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> wo.underS a \\<inter> extended_distance_set \\<or> x = a) \\<and>\n    (y \\<in> wo.underS a \\<inter> extended_distance_set \\<or> y = a) \\<and>\n    (z \\<in> wo.underS a \\<inter> extended_distance_set \\<or> z = a) \\<and>\n    (t \\<in> wo.underS a \\<inter> extended_distance_set \\<or> t = a)", "using H"], ["proof (prove)\nusing this:\n  x \\<in> wo.under a\n  x \\<in> extended_distance_set\n  y \\<in> wo.under a\n  y \\<in> extended_distance_set\n  z \\<in> wo.under a\n  z \\<in> extended_distance_set\n  t \\<in> wo.under a\n  t \\<in> extended_distance_set\n\ngoal (1 subgoal):\n 1. (x \\<in> wo.underS a \\<inter> extended_distance_set \\<or> x = a) \\<and>\n    (y \\<in> wo.underS a \\<inter> extended_distance_set \\<or> y = a) \\<and>\n    (z \\<in> wo.underS a \\<inter> extended_distance_set \\<or> z = a) \\<and>\n    (t \\<in> wo.underS a \\<inter> extended_distance_set \\<or> t = a)", "by (simp add: underS_def under_def)"], ["proof (state)\nthis:\n  (x \\<in> wo.underS a \\<inter> extended_distance_set \\<or> x = a) \\<and>\n  (y \\<in> wo.underS a \\<inter> extended_distance_set \\<or> y = a) \\<and>\n  (z \\<in> wo.underS a \\<inter> extended_distance_set \\<or> z = a) \\<and>\n  (t \\<in> wo.underS a \\<inter> extended_distance_set \\<or> t = a)\n\ngoal (1 subgoal):\n 1. \\<And>x y z t.\n       \\<lbrakk>x \\<in> wo.under a; x \\<in> extended_distance_set;\n        y \\<in> wo.under a; y \\<in> extended_distance_set;\n        z \\<in> wo.under a; z \\<in> extended_distance_set;\n        t \\<in> wo.under a; t \\<in> extended_distance_set\\<rbrakk>\n       \\<Longrightarrow> extended_distance x y + extended_distance z t\n                         \\<le> max (extended_distance x z +\n                                    extended_distance y t)\n                                (extended_distance x t +\n                                 extended_distance y z) +\n                               2 * deltaG TYPE('a)", "have d: \"2 * deltaG(TYPE('a)) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 2 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> 2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<And>x y z t.\n       \\<lbrakk>x \\<in> wo.under a; x \\<in> extended_distance_set;\n        y \\<in> wo.under a; y \\<in> extended_distance_set;\n        z \\<in> wo.under a; z \\<in> extended_distance_set;\n        t \\<in> wo.under a; t \\<in> extended_distance_set\\<rbrakk>\n       \\<Longrightarrow> extended_distance x y + extended_distance z t\n                         \\<le> max (extended_distance x z +\n                                    extended_distance y t)\n                                (extended_distance x t +\n                                 extended_distance y z) +\n                               2 * deltaG TYPE('a)", "show \"extended_distance x y + extended_distance z t \\<le> max (extended_distance x z + extended_distance y t) (extended_distance x t + extended_distance y z) + 2 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_distance x y + extended_distance z t\n    \\<le> max (extended_distance x z + extended_distance y t)\n           (extended_distance x t + extended_distance y z) +\n          2 * deltaG TYPE('a)", "using *"], ["proof (prove)\nusing this:\n  (x \\<in> wo.underS a \\<inter> extended_distance_set \\<or> x = a) \\<and>\n  (y \\<in> wo.underS a \\<inter> extended_distance_set \\<or> y = a) \\<and>\n  (z \\<in> wo.underS a \\<inter> extended_distance_set \\<or> z = a) \\<and>\n  (t \\<in> wo.underS a \\<inter> extended_distance_set \\<or> t = a)\n\ngoal (1 subgoal):\n 1. extended_distance x y + extended_distance z t\n    \\<le> max (extended_distance x z + extended_distance y t)\n           (extended_distance x t + extended_distance y z) +\n          2 * deltaG TYPE('a)", "apply (auto simp add: metric_space_class.extended_distance_symmetric a)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set;\n     y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance x y + extended_distance t z\n                      \\<le> max (extended_distance x z +\n                                 extended_distance t y)\n                             (extended_distance t x +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 2. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set;\n     y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance x y + extended_distance a z\n                      \\<le> max (extended_distance x z +\n                                 extended_distance a y)\n                             (extended_distance a x +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 3. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set;\n     y \\<in> wo.underS a; y \\<in> extended_distance_set; z = a;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance x y + extended_distance a t\n                      \\<le> max (extended_distance a x +\n                                 extended_distance t y)\n                             (extended_distance t x +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 4. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set;\n     y \\<in> wo.underS a; y \\<in> extended_distance_set; z = a;\n     t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance x y\n                      \\<le> extended_distance a x + extended_distance a y +\n                            2 * deltaG TYPE('a)\n 5. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance t z\n                      \\<le> max (extended_distance x z +\n                                 extended_distance a t)\n                             (extended_distance t x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 6. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a z\n                      \\<le> max (extended_distance x z)\n                             (extended_distance a x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 7. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a t\n                      \\<le> max (extended_distance a x +\n                                 extended_distance a t)\n                             (extended_distance t x) +\n                            2 * deltaG TYPE('a)\n 8. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 9. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a y)\n                             (extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 10. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n      z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n     \\<Longrightarrow> extended_distance a y + extended_distance a t\n                       \\<le> max (extended_distance t y)\n                              (extended_distance a t +\n                               extended_distance a y) +\n                             2 * deltaG TYPE('a)\nA total of 11 subgoals...", "using IH[of x y z t]"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> wo.underS a \\<inter> extended_distance_set;\n   y \\<in> wo.underS a \\<inter> extended_distance_set;\n   z \\<in> wo.underS a \\<inter> extended_distance_set;\n   t \\<in> wo.underS a \\<inter> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance x y + extended_distance z t\n                    \\<le> max (extended_distance x z +\n                               extended_distance y t)\n                           (extended_distance x t + extended_distance y z) +\n                          2 * deltaG TYPE('a)\n\ngoal (11 subgoals):\n 1. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set;\n     y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance x y + extended_distance t z\n                      \\<le> max (extended_distance x z +\n                                 extended_distance t y)\n                             (extended_distance t x +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 2. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set;\n     y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance x y + extended_distance a z\n                      \\<le> max (extended_distance x z +\n                                 extended_distance a y)\n                             (extended_distance a x +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 3. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set;\n     y \\<in> wo.underS a; y \\<in> extended_distance_set; z = a;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance x y + extended_distance a t\n                      \\<le> max (extended_distance a x +\n                                 extended_distance t y)\n                             (extended_distance t x +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 4. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set;\n     y \\<in> wo.underS a; y \\<in> extended_distance_set; z = a;\n     t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance x y\n                      \\<le> extended_distance a x + extended_distance a y +\n                            2 * deltaG TYPE('a)\n 5. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance t z\n                      \\<le> max (extended_distance x z +\n                                 extended_distance a t)\n                             (extended_distance t x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 6. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a z\n                      \\<le> max (extended_distance x z)\n                             (extended_distance a x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 7. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a t\n                      \\<le> max (extended_distance a x +\n                                 extended_distance a t)\n                             (extended_distance t x) +\n                            2 * deltaG TYPE('a)\n 8. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 9. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a y)\n                             (extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 10. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n      z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n     \\<Longrightarrow> extended_distance a y + extended_distance a t\n                       \\<le> max (extended_distance t y)\n                              (extended_distance a t +\n                               extended_distance a y) +\n                             2 * deltaG TYPE('a)\nA total of 11 subgoals...", "apply (simp add: metric_space_class.extended_distance_symmetric)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set;\n     y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance x y + extended_distance a z\n                      \\<le> max (extended_distance x z +\n                                 extended_distance a y)\n                             (extended_distance a x +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 2. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set;\n     y \\<in> wo.underS a; y \\<in> extended_distance_set; z = a;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance x y + extended_distance a t\n                      \\<le> max (extended_distance a x +\n                                 extended_distance t y)\n                             (extended_distance t x +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 3. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set;\n     y \\<in> wo.underS a; y \\<in> extended_distance_set; z = a;\n     t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance x y\n                      \\<le> extended_distance a x + extended_distance a y +\n                            2 * deltaG TYPE('a)\n 4. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance t z\n                      \\<le> max (extended_distance x z +\n                                 extended_distance a t)\n                             (extended_distance t x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 5. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a z\n                      \\<le> max (extended_distance x z)\n                             (extended_distance a x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 6. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a t\n                      \\<le> max (extended_distance a x +\n                                 extended_distance a t)\n                             (extended_distance t x) +\n                            2 * deltaG TYPE('a)\n 7. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 8. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a y)\n                             (extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 9. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a t\n                      \\<le> max (extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 10. \\<lbrakk>x = a; y = a; z \\<in> wo.underS a;\n      z \\<in> extended_distance_set; t \\<in> wo.underS a;\n      t \\<in> extended_distance_set\\<rbrakk>\n     \\<Longrightarrow> extended_distance t z\n                       \\<le> max (extended_distance a z +\n                                  extended_distance a t)\n                              (extended_distance a t +\n                               extended_distance a z) +\n                             2 * deltaG TYPE('a)", "using main_ineq[of z x y]"], ["proof (prove)\nusing this:\n  \\<lbrakk>z \\<in> wo.underS a \\<inter> extended_distance_set;\n   x \\<in> wo.underS a \\<inter> extended_distance_set;\n   y \\<in> wo.underS a \\<inter> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance a z + extended_distance x y\n                    \\<le> max (extended_distance a x +\n                               extended_distance z y)\n                           (extended_distance a y + extended_distance z x) +\n                          2 * deltaG TYPE('a)\n\ngoal (10 subgoals):\n 1. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set;\n     y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance x y + extended_distance a z\n                      \\<le> max (extended_distance x z +\n                                 extended_distance a y)\n                             (extended_distance a x +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 2. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set;\n     y \\<in> wo.underS a; y \\<in> extended_distance_set; z = a;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance x y + extended_distance a t\n                      \\<le> max (extended_distance a x +\n                                 extended_distance t y)\n                             (extended_distance t x +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 3. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set;\n     y \\<in> wo.underS a; y \\<in> extended_distance_set; z = a;\n     t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance x y\n                      \\<le> extended_distance a x + extended_distance a y +\n                            2 * deltaG TYPE('a)\n 4. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance t z\n                      \\<le> max (extended_distance x z +\n                                 extended_distance a t)\n                             (extended_distance t x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 5. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a z\n                      \\<le> max (extended_distance x z)\n                             (extended_distance a x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 6. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a t\n                      \\<le> max (extended_distance a x +\n                                 extended_distance a t)\n                             (extended_distance t x) +\n                            2 * deltaG TYPE('a)\n 7. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 8. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a y)\n                             (extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 9. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a t\n                      \\<le> max (extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 10. \\<lbrakk>x = a; y = a; z \\<in> wo.underS a;\n      z \\<in> extended_distance_set; t \\<in> wo.underS a;\n      t \\<in> extended_distance_set\\<rbrakk>\n     \\<Longrightarrow> extended_distance t z\n                       \\<le> max (extended_distance a z +\n                                  extended_distance a t)\n                              (extended_distance a t +\n                               extended_distance a z) +\n                             2 * deltaG TYPE('a)", "apply (simp add: metric_space_class.extended_distance_symmetric)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set;\n     y \\<in> wo.underS a; y \\<in> extended_distance_set; z = a;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance x y + extended_distance a t\n                      \\<le> max (extended_distance a x +\n                                 extended_distance t y)\n                             (extended_distance t x +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 2. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set;\n     y \\<in> wo.underS a; y \\<in> extended_distance_set; z = a;\n     t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance x y\n                      \\<le> extended_distance a x + extended_distance a y +\n                            2 * deltaG TYPE('a)\n 3. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance t z\n                      \\<le> max (extended_distance x z +\n                                 extended_distance a t)\n                             (extended_distance t x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 4. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a z\n                      \\<le> max (extended_distance x z)\n                             (extended_distance a x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 5. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a t\n                      \\<le> max (extended_distance a x +\n                                 extended_distance a t)\n                             (extended_distance t x) +\n                            2 * deltaG TYPE('a)\n 6. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 7. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a y)\n                             (extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 8. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a t\n                      \\<le> max (extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 9. \\<lbrakk>x = a; y = a; z \\<in> wo.underS a;\n     z \\<in> extended_distance_set; t \\<in> wo.underS a;\n     t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a t)\n                             (extended_distance a t +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)", "using main_ineq[of t x y]"], ["proof (prove)\nusing this:\n  \\<lbrakk>t \\<in> wo.underS a \\<inter> extended_distance_set;\n   x \\<in> wo.underS a \\<inter> extended_distance_set;\n   y \\<in> wo.underS a \\<inter> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance a t + extended_distance x y\n                    \\<le> max (extended_distance a x +\n                               extended_distance t y)\n                           (extended_distance a y + extended_distance t x) +\n                          2 * deltaG TYPE('a)\n\ngoal (9 subgoals):\n 1. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set;\n     y \\<in> wo.underS a; y \\<in> extended_distance_set; z = a;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance x y + extended_distance a t\n                      \\<le> max (extended_distance a x +\n                                 extended_distance t y)\n                             (extended_distance t x +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 2. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set;\n     y \\<in> wo.underS a; y \\<in> extended_distance_set; z = a;\n     t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance x y\n                      \\<le> extended_distance a x + extended_distance a y +\n                            2 * deltaG TYPE('a)\n 3. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance t z\n                      \\<le> max (extended_distance x z +\n                                 extended_distance a t)\n                             (extended_distance t x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 4. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a z\n                      \\<le> max (extended_distance x z)\n                             (extended_distance a x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 5. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a t\n                      \\<le> max (extended_distance a x +\n                                 extended_distance a t)\n                             (extended_distance t x) +\n                            2 * deltaG TYPE('a)\n 6. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 7. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a y)\n                             (extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 8. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a t\n                      \\<le> max (extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 9. \\<lbrakk>x = a; y = a; z \\<in> wo.underS a;\n     z \\<in> extended_distance_set; t \\<in> wo.underS a;\n     t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a t)\n                             (extended_distance a t +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)", "apply (simp add: metric_space_class.extended_distance_symmetric)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set;\n     y \\<in> wo.underS a; y \\<in> extended_distance_set; z = a;\n     t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance x y\n                      \\<le> extended_distance a x + extended_distance a y +\n                            2 * deltaG TYPE('a)\n 2. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance t z\n                      \\<le> max (extended_distance x z +\n                                 extended_distance a t)\n                             (extended_distance t x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 3. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a z\n                      \\<le> max (extended_distance x z)\n                             (extended_distance a x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 4. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a t\n                      \\<le> max (extended_distance a x +\n                                 extended_distance a t)\n                             (extended_distance t x) +\n                            2 * deltaG TYPE('a)\n 5. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 6. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a y)\n                             (extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 7. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a t\n                      \\<le> max (extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 8. \\<lbrakk>x = a; y = a; z \\<in> wo.underS a;\n     z \\<in> extended_distance_set; t \\<in> wo.underS a;\n     t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a t)\n                             (extended_distance a t +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)", "using 2 metric_space_class.extended_distance_triang_ineq[of x a y] H"], ["proof (prove)\nusing this:\n  a \\<in> extended_distance_set\n  \\<lbrakk>x \\<in> extended_distance_set; a \\<in> extended_distance_set;\n   y \\<in> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance x y\n                    \\<le> extended_distance x a + extended_distance a y\n  x \\<in> wo.under a\n  x \\<in> extended_distance_set\n  y \\<in> wo.under a\n  y \\<in> extended_distance_set\n  z \\<in> wo.under a\n  z \\<in> extended_distance_set\n  t \\<in> wo.under a\n  t \\<in> extended_distance_set\n\ngoal (8 subgoals):\n 1. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set;\n     y \\<in> wo.underS a; y \\<in> extended_distance_set; z = a;\n     t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance x y\n                      \\<le> extended_distance a x + extended_distance a y +\n                            2 * deltaG TYPE('a)\n 2. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance t z\n                      \\<le> max (extended_distance x z +\n                                 extended_distance a t)\n                             (extended_distance t x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 3. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a z\n                      \\<le> max (extended_distance x z)\n                             (extended_distance a x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 4. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a t\n                      \\<le> max (extended_distance a x +\n                                 extended_distance a t)\n                             (extended_distance t x) +\n                            2 * deltaG TYPE('a)\n 5. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 6. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a y)\n                             (extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 7. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a t\n                      \\<le> max (extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 8. \\<lbrakk>x = a; y = a; z \\<in> wo.underS a;\n     z \\<in> extended_distance_set; t \\<in> wo.underS a;\n     t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a t)\n                             (extended_distance a t +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)", "apply (simp add: metric_space_class.extended_distance_symmetric)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>x \\<in> wo.underS a; y \\<in> wo.underS a; z = a; t = a;\n     a \\<in> extended_distance_set;\n     extended_distance x y\n     \\<le> extended_distance a x + extended_distance a y;\n     x \\<in> wo.under a; x \\<in> extended_distance_set; y \\<in> wo.under a;\n     y \\<in> extended_distance_set; a \\<in> wo.under a\\<rbrakk>\n    \\<Longrightarrow> extended_distance x y\n                      \\<le> extended_distance a x + extended_distance a y +\n                            2 * deltaG TYPE('a)\n 2. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance t z\n                      \\<le> max (extended_distance x z +\n                                 extended_distance a t)\n                             (extended_distance t x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 3. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a z\n                      \\<le> max (extended_distance x z)\n                             (extended_distance a x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 4. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a t\n                      \\<le> max (extended_distance a x +\n                                 extended_distance a t)\n                             (extended_distance t x) +\n                            2 * deltaG TYPE('a)\n 5. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 6. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a y)\n                             (extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 7. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a t\n                      \\<le> max (extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 8. \\<lbrakk>x = a; y = a; z \\<in> wo.underS a;\n     z \\<in> extended_distance_set; t \\<in> wo.underS a;\n     t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a t)\n                             (extended_distance a t +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)", "using d"], ["proof (prove)\nusing this:\n  0 \\<le> 2 * deltaG TYPE('a)\n\ngoal (8 subgoals):\n 1. \\<lbrakk>x \\<in> wo.underS a; y \\<in> wo.underS a; z = a; t = a;\n     a \\<in> extended_distance_set;\n     extended_distance x y\n     \\<le> extended_distance a x + extended_distance a y;\n     x \\<in> wo.under a; x \\<in> extended_distance_set; y \\<in> wo.under a;\n     y \\<in> extended_distance_set; a \\<in> wo.under a\\<rbrakk>\n    \\<Longrightarrow> extended_distance x y\n                      \\<le> extended_distance a x + extended_distance a y +\n                            2 * deltaG TYPE('a)\n 2. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance t z\n                      \\<le> max (extended_distance x z +\n                                 extended_distance a t)\n                             (extended_distance t x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 3. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a z\n                      \\<le> max (extended_distance x z)\n                             (extended_distance a x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 4. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a t\n                      \\<le> max (extended_distance a x +\n                                 extended_distance a t)\n                             (extended_distance t x) +\n                            2 * deltaG TYPE('a)\n 5. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 6. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a y)\n                             (extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 7. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a t\n                      \\<le> max (extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 8. \\<lbrakk>x = a; y = a; z \\<in> wo.underS a;\n     z \\<in> extended_distance_set; t \\<in> wo.underS a;\n     t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a t)\n                             (extended_distance a t +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)", "apply linarith"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance t z\n                      \\<le> max (extended_distance x z +\n                                 extended_distance a t)\n                             (extended_distance t x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 2. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a z\n                      \\<le> max (extended_distance x z)\n                             (extended_distance a x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 3. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a t\n                      \\<le> max (extended_distance a x +\n                                 extended_distance a t)\n                             (extended_distance t x) +\n                            2 * deltaG TYPE('a)\n 4. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 5. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a y)\n                             (extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 6. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a t\n                      \\<le> max (extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 7. \\<lbrakk>x = a; y = a; z \\<in> wo.underS a;\n     z \\<in> extended_distance_set; t \\<in> wo.underS a;\n     t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a t)\n                             (extended_distance a t +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)", "using main_ineq[of x z t]"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> wo.underS a \\<inter> extended_distance_set;\n   z \\<in> wo.underS a \\<inter> extended_distance_set;\n   t \\<in> wo.underS a \\<inter> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance a x + extended_distance z t\n                    \\<le> max (extended_distance a z +\n                               extended_distance x t)\n                           (extended_distance a t + extended_distance x z) +\n                          2 * deltaG TYPE('a)\n\ngoal (7 subgoals):\n 1. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance t z\n                      \\<le> max (extended_distance x z +\n                                 extended_distance a t)\n                             (extended_distance t x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 2. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a z\n                      \\<le> max (extended_distance x z)\n                             (extended_distance a x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 3. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a t\n                      \\<le> max (extended_distance a x +\n                                 extended_distance a t)\n                             (extended_distance t x) +\n                            2 * deltaG TYPE('a)\n 4. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 5. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a y)\n                             (extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 6. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a t\n                      \\<le> max (extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 7. \\<lbrakk>x = a; y = a; z \\<in> wo.underS a;\n     z \\<in> extended_distance_set; t \\<in> wo.underS a;\n     t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a t)\n                             (extended_distance a t +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)", "apply (simp add: metric_space_class.extended_distance_symmetric)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a z\n                      \\<le> max (extended_distance x z)\n                             (extended_distance a x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 2. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a t\n                      \\<le> max (extended_distance a x +\n                                 extended_distance a t)\n                             (extended_distance t x) +\n                            2 * deltaG TYPE('a)\n 3. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 4. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a y)\n                             (extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 5. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a t\n                      \\<le> max (extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 6. \\<lbrakk>x = a; y = a; z \\<in> wo.underS a;\n     z \\<in> extended_distance_set; t \\<in> wo.underS a;\n     t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a t)\n                             (extended_distance a t +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)", "using d"], ["proof (prove)\nusing this:\n  0 \\<le> 2 * deltaG TYPE('a)\n\ngoal (6 subgoals):\n 1. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a z\n                      \\<le> max (extended_distance x z)\n                             (extended_distance a x +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)\n 2. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a t\n                      \\<le> max (extended_distance a x +\n                                 extended_distance a t)\n                             (extended_distance t x) +\n                            2 * deltaG TYPE('a)\n 3. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 4. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a y)\n                             (extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 5. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a t\n                      \\<le> max (extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 6. \\<lbrakk>x = a; y = a; z \\<in> wo.underS a;\n     z \\<in> extended_distance_set; t \\<in> wo.underS a;\n     t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a t)\n                             (extended_distance a t +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)", "apply linarith"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a t\n                      \\<le> max (extended_distance a x +\n                                 extended_distance a t)\n                             (extended_distance t x) +\n                            2 * deltaG TYPE('a)\n 2. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 3. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a y)\n                             (extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 4. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a t\n                      \\<le> max (extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 5. \\<lbrakk>x = a; y = a; z \\<in> wo.underS a;\n     z \\<in> extended_distance_set; t \\<in> wo.underS a;\n     t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a t)\n                             (extended_distance a t +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)", "using d"], ["proof (prove)\nusing this:\n  0 \\<le> 2 * deltaG TYPE('a)\n\ngoal (5 subgoals):\n 1. \\<lbrakk>x \\<in> wo.underS a; x \\<in> extended_distance_set; y = a;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a x + extended_distance a t\n                      \\<le> max (extended_distance a x +\n                                 extended_distance a t)\n                             (extended_distance t x) +\n                            2 * deltaG TYPE('a)\n 2. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 3. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a y)\n                             (extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 4. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a t\n                      \\<le> max (extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 5. \\<lbrakk>x = a; y = a; z \\<in> wo.underS a;\n     z \\<in> extended_distance_set; t \\<in> wo.underS a;\n     t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a t)\n                             (extended_distance a t +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)", "apply linarith"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 2. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a y)\n                             (extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 3. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a t\n                      \\<le> max (extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 4. \\<lbrakk>x = a; y = a; z \\<in> wo.underS a;\n     z \\<in> extended_distance_set; t \\<in> wo.underS a;\n     t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a t)\n                             (extended_distance a t +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)", "using main_ineq[of y z t]"], ["proof (prove)\nusing this:\n  \\<lbrakk>y \\<in> wo.underS a \\<inter> extended_distance_set;\n   z \\<in> wo.underS a \\<inter> extended_distance_set;\n   t \\<in> wo.underS a \\<inter> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance a y + extended_distance z t\n                    \\<le> max (extended_distance a z +\n                               extended_distance y t)\n                           (extended_distance a t + extended_distance y z) +\n                          2 * deltaG TYPE('a)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set;\n     t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 2. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a y)\n                             (extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 3. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a t\n                      \\<le> max (extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 4. \\<lbrakk>x = a; y = a; z \\<in> wo.underS a;\n     z \\<in> extended_distance_set; t \\<in> wo.underS a;\n     t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a t)\n                             (extended_distance a t +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)", "apply (simp add: metric_space_class.extended_distance_symmetric)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a y)\n                             (extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 2. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a t\n                      \\<le> max (extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 3. \\<lbrakk>x = a; y = a; z \\<in> wo.underS a;\n     z \\<in> extended_distance_set; t \\<in> wo.underS a;\n     t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a t)\n                             (extended_distance a t +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)", "using d"], ["proof (prove)\nusing this:\n  0 \\<le> 2 * deltaG TYPE('a)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z \\<in> wo.underS a; z \\<in> extended_distance_set; t = a\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a y)\n                             (extended_distance y z) +\n                            2 * deltaG TYPE('a)\n 2. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a t\n                      \\<le> max (extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 3. \\<lbrakk>x = a; y = a; z \\<in> wo.underS a;\n     z \\<in> extended_distance_set; t \\<in> wo.underS a;\n     t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a t)\n                             (extended_distance a t +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)", "apply linarith"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a t\n                      \\<le> max (extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 2. \\<lbrakk>x = a; y = a; z \\<in> wo.underS a;\n     z \\<in> extended_distance_set; t \\<in> wo.underS a;\n     t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a t)\n                             (extended_distance a t +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)", "using d"], ["proof (prove)\nusing this:\n  0 \\<le> 2 * deltaG TYPE('a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = a; y \\<in> wo.underS a; y \\<in> extended_distance_set;\n     z = a; t \\<in> wo.underS a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance a y + extended_distance a t\n                      \\<le> max (extended_distance t y)\n                             (extended_distance a t +\n                              extended_distance a y) +\n                            2 * deltaG TYPE('a)\n 2. \\<lbrakk>x = a; y = a; z \\<in> wo.underS a;\n     z \\<in> extended_distance_set; t \\<in> wo.underS a;\n     t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a t)\n                             (extended_distance a t +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)", "apply linarith"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = a; y = a; z \\<in> wo.underS a;\n     z \\<in> extended_distance_set; t \\<in> wo.underS a;\n     t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a t)\n                             (extended_distance a t +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)", "using 2 metric_space_class.extended_distance_triang_ineq[of t a z] H"], ["proof (prove)\nusing this:\n  a \\<in> extended_distance_set\n  \\<lbrakk>t \\<in> extended_distance_set; a \\<in> extended_distance_set;\n   z \\<in> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance t z\n                    \\<le> extended_distance t a + extended_distance a z\n  x \\<in> wo.under a\n  x \\<in> extended_distance_set\n  y \\<in> wo.under a\n  y \\<in> extended_distance_set\n  z \\<in> wo.under a\n  z \\<in> extended_distance_set\n  t \\<in> wo.under a\n  t \\<in> extended_distance_set\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = a; y = a; z \\<in> wo.underS a;\n     z \\<in> extended_distance_set; t \\<in> wo.underS a;\n     t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a t)\n                             (extended_distance a t +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)", "apply (simp add: metric_space_class.extended_distance_symmetric)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = a; y = a; z \\<in> wo.underS a; t \\<in> wo.underS a;\n     a \\<in> extended_distance_set;\n     extended_distance t z\n     \\<le> extended_distance a t + extended_distance a z;\n     a \\<in> wo.under a; z \\<in> wo.under a; z \\<in> extended_distance_set;\n     t \\<in> wo.under a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a t)\n                             (extended_distance a t +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)", "using d"], ["proof (prove)\nusing this:\n  0 \\<le> 2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = a; y = a; z \\<in> wo.underS a; t \\<in> wo.underS a;\n     a \\<in> extended_distance_set;\n     extended_distance t z\n     \\<le> extended_distance a t + extended_distance a z;\n     a \\<in> wo.under a; z \\<in> wo.under a; z \\<in> extended_distance_set;\n     t \\<in> wo.under a; t \\<in> extended_distance_set\\<rbrakk>\n    \\<Longrightarrow> extended_distance t z\n                      \\<le> max (extended_distance a z +\n                                 extended_distance a t)\n                             (extended_distance a t +\n                              extended_distance a z) +\n                            2 * deltaG TYPE('a)", "apply linarith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  extended_distance x y + extended_distance z t\n  \\<le> max (extended_distance x z + extended_distance y t)\n         (extended_distance x t + extended_distance y z) +\n        2 * deltaG TYPE('a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x y z t.\n     x \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n     y \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n     z \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n     t \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n     extended_distance x y + extended_distance z t\n     \\<le> max (extended_distance x z + extended_distance y t)\n            (extended_distance x t + extended_distance y z) +\n           2 * deltaG TYPE('a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x y z t.\n     x \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n     y \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n     z \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n     t \\<in> wo.under a \\<inter> extended_distance_set \\<longrightarrow>\n     extended_distance x y + extended_distance z t\n     \\<le> max (extended_distance x z + extended_distance y t)\n            (extended_distance x t + extended_distance y z) +\n           2 * deltaG TYPE('a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x y z t.\n     x \\<in> wo.under ?a1 \\<inter> extended_distance_set \\<longrightarrow>\n     y \\<in> wo.under ?a1 \\<inter> extended_distance_set \\<longrightarrow>\n     z \\<in> wo.under ?a1 \\<inter> extended_distance_set \\<longrightarrow>\n     t \\<in> wo.under ?a1 \\<inter> extended_distance_set \\<longrightarrow>\n     extended_distance x y + extended_distance z t\n     \\<le> max (extended_distance x z + extended_distance y t)\n            (extended_distance x t + extended_distance y z) +\n           2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. extended_distance x y + extended_distance z t\n    \\<le> max (extended_distance x z + extended_distance y t)\n           (extended_distance x t + extended_distance y z) +\n          2 * deltaG TYPE('a)", "define b where \"b = wo.max2 (wo.max2 x y) (wo.max2 z t)\""], ["proof (state)\nthis:\n  b = wo.max2 (wo.max2 x y) (wo.max2 z t)\n\ngoal (1 subgoal):\n 1. extended_distance x y + extended_distance z t\n    \\<le> max (extended_distance x z + extended_distance y t)\n           (extended_distance x t + extended_distance y z) +\n          2 * deltaG TYPE('a)", "have \"x \\<in> wo.under b\" \"y \\<in> wo.under b\" \"z \\<in> wo.under b\" \"t \\<in> wo.under b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> wo.under b &&& y \\<in> wo.under b) &&&\n    z \\<in> wo.under b &&& t \\<in> wo.under b", "unfolding b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> wo.under (wo.max2 (wo.max2 x y) (wo.max2 z t)) &&&\n     y \\<in> wo.under (wo.max2 (wo.max2 x y) (wo.max2 z t))) &&&\n    z \\<in> wo.under (wo.max2 (wo.max2 x y) (wo.max2 z t)) &&&\n    t \\<in> wo.under (wo.max2 (wo.max2 x y) (wo.max2 z t))", "apply (auto simp add: under_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. (x, wo.max2 (wo.max2 x y) (wo.max2 z t))\n    \\<in> Bonk_Schramm_extension_unfolded_wo\n 2. (y, wo.max2 (wo.max2 x y) (wo.max2 z t))\n    \\<in> Bonk_Schramm_extension_unfolded_wo\n 3. (z, wo.max2 (wo.max2 x y) (wo.max2 z t))\n    \\<in> Bonk_Schramm_extension_unfolded_wo\n 4. (t, wo.max2 (wo.max2 x y) (wo.max2 z t))\n    \\<in> Bonk_Schramm_extension_unfolded_wo", "by (metis UNIV_I metric_space_class.Bonk_Schramm_extension_unfolded_wo_props(1) mem_Collect_eq under_def well_order_on_Well_order wo.TOTALS wo.max2_iff)+"], ["proof (state)\nthis:\n  x \\<in> wo.under b\n  y \\<in> wo.under b\n  z \\<in> wo.under b\n  t \\<in> wo.under b\n\ngoal (1 subgoal):\n 1. extended_distance x y + extended_distance z t\n    \\<le> max (extended_distance x z + extended_distance y t)\n           (extended_distance x t + extended_distance y z) +\n          2 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  x \\<in> wo.under b\n  y \\<in> wo.under b\n  z \\<in> wo.under b\n  t \\<in> wo.under b", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> wo.under b\n  y \\<in> wo.under b\n  z \\<in> wo.under b\n  t \\<in> wo.under b\n\ngoal (1 subgoal):\n 1. extended_distance x y + extended_distance z t\n    \\<le> max (extended_distance x z + extended_distance y t)\n           (extended_distance x t + extended_distance y z) +\n          2 * deltaG TYPE('a)", "using ineq_rec[of b] assms"], ["proof (prove)\nusing this:\n  x \\<in> wo.under b\n  y \\<in> wo.under b\n  z \\<in> wo.under b\n  t \\<in> wo.under b\n  \\<forall>x y z t.\n     x \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n     y \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n     z \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n     t \\<in> wo.under b \\<inter> extended_distance_set \\<longrightarrow>\n     extended_distance x y + extended_distance z t\n     \\<le> max (extended_distance x z + extended_distance y t)\n            (extended_distance x t + extended_distance y z) +\n           2 * deltaG TYPE('a)\n  x \\<in> extended_distance_set\n  y \\<in> extended_distance_set\n  z \\<in> extended_distance_set\n  t \\<in> extended_distance_set\n\ngoal (1 subgoal):\n 1. extended_distance x y + extended_distance z t\n    \\<le> max (extended_distance x z + extended_distance y t)\n           (extended_distance x t + extended_distance y z) +\n          2 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  extended_distance x y + extended_distance z t\n  \\<le> max (extended_distance x z + extended_distance y t)\n         (extended_distance x t + extended_distance y z) +\n        2 * deltaG TYPE('a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in Gromov_hyperbolic_space) Bonk_Schramm_extension_hyperbolic:\n  \"Gromov_hyperbolic_subset (deltaG(TYPE('a))) (UNIV::('a Bonk_Schramm_extension) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (deltaG TYPE('a)) UNIV", "apply (rule Gromov_hyperbolic_subsetI, simp, transfer fixing: deltaG)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z t.\n       \\<lbrakk>x \\<in> extended_distance_set \\<and>\n                x \\<in> extended_distance_set \\<and>\n                extended_distance x x = 0;\n        y \\<in> extended_distance_set \\<and>\n        y \\<in> extended_distance_set \\<and> extended_distance y y = 0;\n        z \\<in> extended_distance_set \\<and>\n        z \\<in> extended_distance_set \\<and> extended_distance z z = 0;\n        t \\<in> extended_distance_set \\<and>\n        t \\<in> extended_distance_set \\<and>\n        extended_distance t t = 0\\<rbrakk>\n       \\<Longrightarrow> extended_distance x y + extended_distance z t\n                         \\<le> max (extended_distance x z +\n                                    extended_distance y t)\n                                (extended_distance x t +\n                                 extended_distance y z) +\n                               2 * deltaG TYPE('a)", "using metric_space_class.extended_distance_set_def Bonk_Schramm_extension_unfolded_hyperbolic"], ["proof (prove)\nusing this:\n  extended_distance_set = {z. extended_distance z z = 0}\n  \\<lbrakk>?x \\<in> extended_distance_set; ?y \\<in> extended_distance_set;\n   ?z \\<in> extended_distance_set; ?t \\<in> extended_distance_set\\<rbrakk>\n  \\<Longrightarrow> extended_distance ?x ?y + extended_distance ?z ?t\n                    \\<le> max (extended_distance ?x ?z +\n                               extended_distance ?y ?t)\n                           (extended_distance ?x ?t +\n                            extended_distance ?y ?z) +\n                          2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<And>x y z t.\n       \\<lbrakk>x \\<in> extended_distance_set \\<and>\n                x \\<in> extended_distance_set \\<and>\n                extended_distance x x = 0;\n        y \\<in> extended_distance_set \\<and>\n        y \\<in> extended_distance_set \\<and> extended_distance y y = 0;\n        z \\<in> extended_distance_set \\<and>\n        z \\<in> extended_distance_set \\<and> extended_distance z z = 0;\n        t \\<in> extended_distance_set \\<and>\n        t \\<in> extended_distance_set \\<and>\n        extended_distance t t = 0\\<rbrakk>\n       \\<Longrightarrow> extended_distance x y + extended_distance z t\n                         \\<le> max (extended_distance x z +\n                                    extended_distance y t)\n                                (extended_distance x t +\n                                 extended_distance y z) +\n                               2 * deltaG TYPE('a)", "by auto"], ["", "instantiation Bonk_Schramm_extension :: (Gromov_hyperbolic_space) Gromov_hyperbolic_space_geodesic\nbegin"], ["", "definition deltaG_Bonk_Schramm_extension::\"('a Bonk_Schramm_extension) itself \\<Rightarrow> real\" where\n  \"deltaG_Bonk_Schramm_extension _ = deltaG(TYPE('a))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS\n     ('a Bonk_Schramm_extension, Gromov_hyperbolic_space_geodesic_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (deltaG TYPE('a Bonk_Schramm_extension)) UNIV", "unfolding deltaG_Bonk_Schramm_extension_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (deltaG TYPE('a)) UNIV", "using Bonk_Schramm_extension_hyperbolic"], ["proof (prove)\nusing this:\n  Gromov_hyperbolic_subset (deltaG TYPE(?'a)) UNIV\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (deltaG TYPE('a)) UNIV", "by auto"], ["", "end"], ["", "(* of instantiation proof *)"], ["", "text \\<open>Finally, it follows that the Bonk Schramm extension of a $0$-hyperbolic space\n(in which it embeds isometrically) is a metric tree or, equivalently, a geodesic $0$-hyperbolic\nspace (the equivalence is proved at the end of \\verb+Geodesic_Spaces.thy+).\\<close>"], ["", "instance Bonk_Schramm_extension :: (Gromov_hyperbolic_space_0) Gromov_hyperbolic_space_0_geodesic"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS\n     ('a Bonk_Schramm_extension, Gromov_hyperbolic_space_0_geodesic_class)", "by (standard, simp add: deltaG_Bonk_Schramm_extension_def delta0)"], ["", "text \\<open>It then follows that it is also a metric tree, from what we have already proved.\nWe write explicitly for definiteness.\\<close>"], ["", "instance Bonk_Schramm_extension :: (Gromov_hyperbolic_space_0) metric_tree"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a Bonk_Schramm_extension, metric_tree_class)", "by standard"], ["", "subsection \\<open>Applications\\<close>"], ["", "text \\<open>We deduce that we can extend results on Gromov-hyperbolic spaces without the geodesicity assumption,\neven if it is used in the proofs. These results are given for illustrative purpose mainly, as one\nworks most often in geodesic spaces anyway.\n\nThe following results have already been proved in hyperbolic geodesic spaces. The same results\nfollow in a general hyperbolic space, as everything is invariant under isometries and can thus\nbe pulled from the corresponding result in the Bonk Schramm extension. The straightforward proofs\nonly express this invariance under isometries of all the properties under consideration.\\<close>"], ["", "proposition (in Gromov_hyperbolic_space) lipschitz_path_close_to_geodesic':\n  fixes c::\"real \\<Rightarrow> 'a\"\n  assumes \"lipschitz_on M {A..B} c\"\n          \"geodesic_segment_between G (c A) (c B)\"\n          \"x \\<in> G\"\n  shows \"infdist x (c`{A..B}) \\<le> (4/ln 2) * deltaG(TYPE('a)) * max 0 (ln (B-A)) + M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "interpret BS: Gromov_hyperbolic_space_geodesic \"dist::('a Bonk_Schramm_extension \\<Rightarrow> 'a Bonk_Schramm_extension \\<Rightarrow> real)\" \"uniformity\" \"open\" \"(\\<lambda>_. deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.Gromov_hyperbolic_space_geodesic dist uniformity open\n     (\\<lambda>_. deltaG TYPE('a))", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (deltaG TYPE('a)) UNIV", "using Bonk_Schramm_extension_hyperbolic"], ["proof (prove)\nusing this:\n  Gromov_hyperbolic_subset (deltaG TYPE('a)) UNIV\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (deltaG TYPE('a)) UNIV", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "have \"infdist x (c`{A..B}) = infdist (to_Bonk_Schramm_extension x) ((to_Bonk_Schramm_extension o c)`{A..B})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B}) =\n    infdist (to_Bonk_Schramm_extension x)\n     ((to_Bonk_Schramm_extension \\<circ> c) ` {A..B})", "unfolding image_comp[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B}) =\n    infdist (to_Bonk_Schramm_extension x)\n     (to_Bonk_Schramm_extension ` c ` {A..B})", "apply (rule isometry_preserves_infdist[symmetric, of UNIV])"], ["proof (prove)\ngoal (3 subgoals):\n 1. isometry_on UNIV to_Bonk_Schramm_extension\n 2. c ` {A..B} \\<subseteq> UNIV\n 3. x \\<in> UNIV", "using to_Bonk_Schramm_extension_isometry"], ["proof (prove)\nusing this:\n  isometry_on UNIV to_Bonk_Schramm_extension\n\ngoal (3 subgoals):\n 1. isometry_on UNIV to_Bonk_Schramm_extension\n 2. c ` {A..B} \\<subseteq> UNIV\n 3. x \\<in> UNIV", "by auto"], ["proof (state)\nthis:\n  infdist x (c ` {A..B}) =\n  infdist (to_Bonk_Schramm_extension x)\n   ((to_Bonk_Schramm_extension \\<circ> c) ` {A..B})\n\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "also"], ["proof (state)\nthis:\n  infdist x (c ` {A..B}) =\n  infdist (to_Bonk_Schramm_extension x)\n   ((to_Bonk_Schramm_extension \\<circ> c) ` {A..B})\n\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "have \"... \\<le> (4/ln 2) * deltaG(TYPE(('a))) * max 0 (ln (B-A)) + (1*M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist (to_Bonk_Schramm_extension x)\n     ((to_Bonk_Schramm_extension \\<circ> c) ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + 1 * M", "apply (rule BS.lipschitz_path_close_to_geodesic[of _ _ _ _ \"to_Bonk_Schramm_extension`G\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (1 * M)-lipschitz_on {A..B} (to_Bonk_Schramm_extension \\<circ> c)\n 2. geodesic_segment_between (to_Bonk_Schramm_extension ` G)\n     ((to_Bonk_Schramm_extension \\<circ> c) A)\n     ((to_Bonk_Schramm_extension \\<circ> c) B)\n 3. to_Bonk_Schramm_extension x \\<in> to_Bonk_Schramm_extension ` G", "apply (rule lipschitz_on_compose)"], ["proof (prove)\ngoal (4 subgoals):\n 1. M-lipschitz_on {A..B} c\n 2. 1-lipschitz_on (c ` {A..B}) to_Bonk_Schramm_extension\n 3. geodesic_segment_between (to_Bonk_Schramm_extension ` G)\n     ((to_Bonk_Schramm_extension \\<circ> c) A)\n     ((to_Bonk_Schramm_extension \\<circ> c) B)\n 4. to_Bonk_Schramm_extension x \\<in> to_Bonk_Schramm_extension ` G", "using assms"], ["proof (prove)\nusing this:\n  M-lipschitz_on {A..B} c\n  geodesic_segment_between G (c A) (c B)\n  x \\<in> G\n\ngoal (4 subgoals):\n 1. M-lipschitz_on {A..B} c\n 2. 1-lipschitz_on (c ` {A..B}) to_Bonk_Schramm_extension\n 3. geodesic_segment_between (to_Bonk_Schramm_extension ` G)\n     ((to_Bonk_Schramm_extension \\<circ> c) A)\n     ((to_Bonk_Schramm_extension \\<circ> c) B)\n 4. to_Bonk_Schramm_extension x \\<in> to_Bonk_Schramm_extension ` G", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1-lipschitz_on (c ` {A..B}) to_Bonk_Schramm_extension\n 2. geodesic_segment_between (to_Bonk_Schramm_extension ` G)\n     ((to_Bonk_Schramm_extension \\<circ> c) A)\n     ((to_Bonk_Schramm_extension \\<circ> c) B)\n 3. to_Bonk_Schramm_extension x \\<in> to_Bonk_Schramm_extension ` G", "apply (meson UNIV_I isometry_on_lipschitz lipschitz_on_def to_Bonk_Schramm_extension_isometry)"], ["proof (prove)\ngoal (2 subgoals):\n 1. geodesic_segment_between (to_Bonk_Schramm_extension ` G)\n     ((to_Bonk_Schramm_extension \\<circ> c) A)\n     ((to_Bonk_Schramm_extension \\<circ> c) B)\n 2. to_Bonk_Schramm_extension x \\<in> to_Bonk_Schramm_extension ` G", "unfolding comp_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. geodesic_segment_between (to_Bonk_Schramm_extension ` G)\n     (to_Bonk_Schramm_extension (c A)) (to_Bonk_Schramm_extension (c B))\n 2. to_Bonk_Schramm_extension x \\<in> to_Bonk_Schramm_extension ` G", "apply (rule isometry_preserves_geodesic_segment_between[of UNIV])"], ["proof (prove)\ngoal (4 subgoals):\n 1. isometry_on UNIV to_Bonk_Schramm_extension\n 2. G \\<subseteq> UNIV\n 3. geodesic_segment_between G (c A) (c B)\n 4. to_Bonk_Schramm_extension x \\<in> to_Bonk_Schramm_extension ` G", "using assms to_Bonk_Schramm_extension_isometry"], ["proof (prove)\nusing this:\n  M-lipschitz_on {A..B} c\n  geodesic_segment_between G (c A) (c B)\n  x \\<in> G\n  isometry_on UNIV to_Bonk_Schramm_extension\n\ngoal (4 subgoals):\n 1. isometry_on UNIV to_Bonk_Schramm_extension\n 2. G \\<subseteq> UNIV\n 3. geodesic_segment_between G (c A) (c B)\n 4. to_Bonk_Schramm_extension x \\<in> to_Bonk_Schramm_extension ` G", "by auto"], ["proof (state)\nthis:\n  infdist (to_Bonk_Schramm_extension x)\n   ((to_Bonk_Schramm_extension \\<circ> c) ` {A..B})\n  \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + 1 * M\n\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "finally"], ["proof (chain)\npicking this:\n  infdist x (c ` {A..B})\n  \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + 1 * M", "show ?thesis"], ["proof (prove)\nusing this:\n  infdist x (c ` {A..B})\n  \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + 1 * M\n\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "by auto"], ["proof (state)\nthis:\n  infdist x (c ` {A..B})\n  \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem (in Gromov_hyperbolic_space) Morse_Gromov_theorem':\n  fixes f::\"real \\<Rightarrow> 'a\"\n  assumes \"lambda C-quasi_isometry_on {a..b} f\"\n          \"geodesic_segment_between G (f a) (f b)\"\n  shows \"hausdorff_distance (f`{a..b}) G \\<le> 92 * lambda\\<^sup>2 * (C + deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "interpret BS: Gromov_hyperbolic_space_geodesic \"dist::('a Bonk_Schramm_extension \\<Rightarrow> 'a Bonk_Schramm_extension \\<Rightarrow> real)\" \"uniformity\" \"open\" \"(\\<lambda>_. deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.Gromov_hyperbolic_space_geodesic dist uniformity open\n     (\\<lambda>_. deltaG TYPE('a))", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (deltaG TYPE('a)) UNIV", "using Bonk_Schramm_extension_hyperbolic"], ["proof (prove)\nusing this:\n  Gromov_hyperbolic_subset (deltaG TYPE('a)) UNIV\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (deltaG TYPE('a)) UNIV", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "have \"hausdorff_distance (f`{a..b}) (G) = hausdorff_distance ((to_Bonk_Schramm_extension o f)`{a..b}) ((to_Bonk_Schramm_extension)`G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) G =\n    hausdorff_distance ((to_Bonk_Schramm_extension \\<circ> f) ` {a..b})\n     (to_Bonk_Schramm_extension ` G)", "unfolding image_comp[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) G =\n    hausdorff_distance (to_Bonk_Schramm_extension ` f ` {a..b})\n     (to_Bonk_Schramm_extension ` G)", "apply (rule isometry_preserves_hausdorff_distance[symmetric, of UNIV])"], ["proof (prove)\ngoal (3 subgoals):\n 1. isometry_on UNIV to_Bonk_Schramm_extension\n 2. f ` {a..b} \\<subseteq> UNIV\n 3. G \\<subseteq> UNIV", "using to_Bonk_Schramm_extension_isometry"], ["proof (prove)\nusing this:\n  isometry_on UNIV to_Bonk_Schramm_extension\n\ngoal (3 subgoals):\n 1. isometry_on UNIV to_Bonk_Schramm_extension\n 2. f ` {a..b} \\<subseteq> UNIV\n 3. G \\<subseteq> UNIV", "by auto"], ["proof (state)\nthis:\n  hausdorff_distance (f ` {a..b}) G =\n  hausdorff_distance ((to_Bonk_Schramm_extension \\<circ> f) ` {a..b})\n   (to_Bonk_Schramm_extension ` G)\n\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "also"], ["proof (state)\nthis:\n  hausdorff_distance (f ` {a..b}) G =\n  hausdorff_distance ((to_Bonk_Schramm_extension \\<circ> f) ` {a..b})\n   (to_Bonk_Schramm_extension ` G)\n\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "have \"... \\<le> 92 * (lambda*1)^2 * ((C*1+0) + deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance ((to_Bonk_Schramm_extension \\<circ> f) ` {a..b})\n     (to_Bonk_Schramm_extension ` G)\n    \\<le> 92 * (lambda * 1)\\<^sup>2 * (C * 1 + 0 + deltaG TYPE('a))", "apply (intro BS.Morse_Gromov_theorem quasi_isometry_on_compose[where Y = UNIV])"], ["proof (prove)\ngoal (4 subgoals):\n 1. lambda C -quasi_isometry_on {a..b} f\n 2. 1 0 -quasi_isometry to_Bonk_Schramm_extension\n 3. f ` {a..b} \\<subseteq> UNIV\n 4. geodesic_segment_between (to_Bonk_Schramm_extension ` G)\n     ((to_Bonk_Schramm_extension \\<circ> f) a)\n     ((to_Bonk_Schramm_extension \\<circ> f) b)", "using assms isometry_quasi_isometry_on to_Bonk_Schramm_extension_isometry"], ["proof (prove)\nusing this:\n  lambda C -quasi_isometry_on {a..b} f\n  geodesic_segment_between G (f a) (f b)\n  isometry_on ?X ?f \\<Longrightarrow> 1 0 -quasi_isometry_on ?X ?f\n  isometry_on UNIV to_Bonk_Schramm_extension\n\ngoal (4 subgoals):\n 1. lambda C -quasi_isometry_on {a..b} f\n 2. 1 0 -quasi_isometry to_Bonk_Schramm_extension\n 3. f ` {a..b} \\<subseteq> UNIV\n 4. geodesic_segment_between (to_Bonk_Schramm_extension ` G)\n     ((to_Bonk_Schramm_extension \\<circ> f) a)\n     ((to_Bonk_Schramm_extension \\<circ> f) b)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lambda C -quasi_isometry_on {a..b} f;\n     geodesic_segment_between G (f a) (f b);\n     \\<And>X f.\n        isometry_on X f \\<Longrightarrow> 1 0 -quasi_isometry_on X f;\n     isometry_on UNIV to_Bonk_Schramm_extension\\<rbrakk>\n    \\<Longrightarrow> geodesic_segment_between\n                       (to_Bonk_Schramm_extension ` G)\n                       (to_Bonk_Schramm_extension (f a))\n                       (to_Bonk_Schramm_extension (f b))", "using isometry_preserves_geodesic_segment_between"], ["proof (prove)\nusing this:\n  \\<lbrakk>isometry_on ?X ?f; ?G \\<subseteq> ?X;\n   geodesic_segment_between ?G ?x ?y\\<rbrakk>\n  \\<Longrightarrow> geodesic_segment_between (?f ` ?G) (?f ?x) (?f ?y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lambda C -quasi_isometry_on {a..b} f;\n     geodesic_segment_between G (f a) (f b);\n     \\<And>X f.\n        isometry_on X f \\<Longrightarrow> 1 0 -quasi_isometry_on X f;\n     isometry_on UNIV to_Bonk_Schramm_extension\\<rbrakk>\n    \\<Longrightarrow> geodesic_segment_between\n                       (to_Bonk_Schramm_extension ` G)\n                       (to_Bonk_Schramm_extension (f a))\n                       (to_Bonk_Schramm_extension (f b))", "by blast"], ["proof (state)\nthis:\n  hausdorff_distance ((to_Bonk_Schramm_extension \\<circ> f) ` {a..b})\n   (to_Bonk_Schramm_extension ` G)\n  \\<le> 92 * (lambda * 1)\\<^sup>2 * (C * 1 + 0 + deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "finally"], ["proof (chain)\npicking this:\n  hausdorff_distance (f ` {a..b}) G\n  \\<le> 92 * (lambda * 1)\\<^sup>2 * (C * 1 + 0 + deltaG TYPE('a))", "show ?thesis"], ["proof (prove)\nusing this:\n  hausdorff_distance (f ` {a..b}) G\n  \\<le> 92 * (lambda * 1)\\<^sup>2 * (C * 1 + 0 + deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "by simp"], ["proof (state)\nthis:\n  hausdorff_distance (f ` {a..b}) G\n  \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem (in Gromov_hyperbolic_space) Morse_Gromov_theorem2':\n  fixes c d::\"real \\<Rightarrow> 'a\"\n  assumes \"lambda C-quasi_isometry_on {A..B} c\"\n          \"lambda C-quasi_isometry_on {A..B} d\"\n          \"c A = d A\" \"c B = d B\"\n  shows \"hausdorff_distance (c`{A..B}) (d`{A..B}) \\<le> 184 * lambda^2 * (C + deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "interpret BS: Gromov_hyperbolic_space_geodesic \"dist::('a Bonk_Schramm_extension \\<Rightarrow> 'a Bonk_Schramm_extension \\<Rightarrow> real)\" \"uniformity\" \"open\" \"(\\<lambda>_. deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.Gromov_hyperbolic_space_geodesic dist uniformity open\n     (\\<lambda>_. deltaG TYPE('a))", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (deltaG TYPE('a)) UNIV", "using Bonk_Schramm_extension_hyperbolic"], ["proof (prove)\nusing this:\n  Gromov_hyperbolic_subset (deltaG TYPE('a)) UNIV\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (deltaG TYPE('a)) UNIV", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "have \"hausdorff_distance (c`{A..B}) (d`{A..B}) = hausdorff_distance ((to_Bonk_Schramm_extension o c)`{A..B}) ((to_Bonk_Schramm_extension o d)`{A..B})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) (d ` {A..B}) =\n    hausdorff_distance ((to_Bonk_Schramm_extension \\<circ> c) ` {A..B})\n     ((to_Bonk_Schramm_extension \\<circ> d) ` {A..B})", "unfolding image_comp[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) (d ` {A..B}) =\n    hausdorff_distance (to_Bonk_Schramm_extension ` c ` {A..B})\n     (to_Bonk_Schramm_extension ` d ` {A..B})", "apply (rule isometry_preserves_hausdorff_distance[symmetric, of UNIV])"], ["proof (prove)\ngoal (3 subgoals):\n 1. isometry_on UNIV to_Bonk_Schramm_extension\n 2. c ` {A..B} \\<subseteq> UNIV\n 3. d ` {A..B} \\<subseteq> UNIV", "using to_Bonk_Schramm_extension_isometry"], ["proof (prove)\nusing this:\n  isometry_on UNIV to_Bonk_Schramm_extension\n\ngoal (3 subgoals):\n 1. isometry_on UNIV to_Bonk_Schramm_extension\n 2. c ` {A..B} \\<subseteq> UNIV\n 3. d ` {A..B} \\<subseteq> UNIV", "by auto"], ["proof (state)\nthis:\n  hausdorff_distance (c ` {A..B}) (d ` {A..B}) =\n  hausdorff_distance ((to_Bonk_Schramm_extension \\<circ> c) ` {A..B})\n   ((to_Bonk_Schramm_extension \\<circ> d) ` {A..B})\n\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "also"], ["proof (state)\nthis:\n  hausdorff_distance (c ` {A..B}) (d ` {A..B}) =\n  hausdorff_distance ((to_Bonk_Schramm_extension \\<circ> c) ` {A..B})\n   ((to_Bonk_Schramm_extension \\<circ> d) ` {A..B})\n\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "have \"... \\<le> 184 * (lambda*1)^2 * ((C*1+0) + deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance ((to_Bonk_Schramm_extension \\<circ> c) ` {A..B})\n     ((to_Bonk_Schramm_extension \\<circ> d) ` {A..B})\n    \\<le> 184 * (lambda * 1)\\<^sup>2 * (C * 1 + 0 + deltaG TYPE('a))", "apply (intro BS.Morse_Gromov_theorem2 quasi_isometry_on_compose[where Y = UNIV])"], ["proof (prove)\ngoal (8 subgoals):\n 1. lambda C -quasi_isometry_on {A..B} c\n 2. 1 0 -quasi_isometry to_Bonk_Schramm_extension\n 3. c ` {A..B} \\<subseteq> UNIV\n 4. lambda C -quasi_isometry_on {A..B} d\n 5. 1 0 -quasi_isometry to_Bonk_Schramm_extension\n 6. d ` {A..B} \\<subseteq> UNIV\n 7. (to_Bonk_Schramm_extension \\<circ> c) A =\n    (to_Bonk_Schramm_extension \\<circ> d) A\n 8. (to_Bonk_Schramm_extension \\<circ> c) B =\n    (to_Bonk_Schramm_extension \\<circ> d) B", "using assms isometry_quasi_isometry_on to_Bonk_Schramm_extension_isometry"], ["proof (prove)\nusing this:\n  lambda C -quasi_isometry_on {A..B} c\n  lambda C -quasi_isometry_on {A..B} d\n  c A = d A\n  c B = d B\n  isometry_on ?X ?f \\<Longrightarrow> 1 0 -quasi_isometry_on ?X ?f\n  isometry_on UNIV to_Bonk_Schramm_extension\n\ngoal (8 subgoals):\n 1. lambda C -quasi_isometry_on {A..B} c\n 2. 1 0 -quasi_isometry to_Bonk_Schramm_extension\n 3. c ` {A..B} \\<subseteq> UNIV\n 4. lambda C -quasi_isometry_on {A..B} d\n 5. 1 0 -quasi_isometry to_Bonk_Schramm_extension\n 6. d ` {A..B} \\<subseteq> UNIV\n 7. (to_Bonk_Schramm_extension \\<circ> c) A =\n    (to_Bonk_Schramm_extension \\<circ> d) A\n 8. (to_Bonk_Schramm_extension \\<circ> c) B =\n    (to_Bonk_Schramm_extension \\<circ> d) B", "by auto"], ["proof (state)\nthis:\n  hausdorff_distance ((to_Bonk_Schramm_extension \\<circ> c) ` {A..B})\n   ((to_Bonk_Schramm_extension \\<circ> d) ` {A..B})\n  \\<le> 184 * (lambda * 1)\\<^sup>2 * (C * 1 + 0 + deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "finally"], ["proof (chain)\npicking this:\n  hausdorff_distance (c ` {A..B}) (d ` {A..B})\n  \\<le> 184 * (lambda * 1)\\<^sup>2 * (C * 1 + 0 + deltaG TYPE('a))", "show ?thesis"], ["proof (prove)\nusing this:\n  hausdorff_distance (c ` {A..B}) (d ` {A..B})\n  \\<le> 184 * (lambda * 1)\\<^sup>2 * (C * 1 + 0 + deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "by simp"], ["proof (state)\nthis:\n  hausdorff_distance (c ` {A..B}) (d ` {A..B})\n  \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Gromov_hyperbolic_invariant_under_quasi_isometry_explicit':\n  fixes f::\"'a::geodesic_space \\<Rightarrow> 'b::Gromov_hyperbolic_space\"\n  assumes \"lambda C-quasi_isometry f\"\n  shows \"Gromov_hyperbolic_subset (752 * lambda^3 * (C + deltaG(TYPE('b)))) (UNIV::('a set))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV", "interpret BS: Gromov_hyperbolic_space_geodesic \"dist::('b Bonk_Schramm_extension \\<Rightarrow> 'b Bonk_Schramm_extension \\<Rightarrow> real)\" \"uniformity\" \"open\" \"(\\<lambda>_. deltaG(TYPE('b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.Gromov_hyperbolic_space_geodesic dist uniformity open\n     (\\<lambda>_. deltaG TYPE('b))", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (deltaG TYPE('b)) UNIV", "using Bonk_Schramm_extension_hyperbolic"], ["proof (prove)\nusing this:\n  Gromov_hyperbolic_subset (deltaG TYPE(?'a)) UNIV\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (deltaG TYPE('b)) UNIV", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV", "have A: \"(lambda * 1) (C * 1 + 0)-quasi_isometry_on UNIV (to_Bonk_Schramm_extension o f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lambda * 1) (C * 1 + 0) -quasi_isometry\n     (to_Bonk_Schramm_extension \\<circ> f)", "by (rule quasi_isometry_on_compose[OF assms, of _ _ UNIV])\n       (auto simp add: isometry_quasi_isometry_on[OF to_Bonk_Schramm_extension_isometry])"], ["proof (state)\nthis:\n  (lambda * 1) (C * 1 + 0) -quasi_isometry\n   (to_Bonk_Schramm_extension \\<circ> f)\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV", "have *: \"deltaG(TYPE('b)) = deltaG(TYPE('b Bonk_Schramm_extension))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deltaG TYPE('b) = deltaG TYPE('b Bonk_Schramm_extension)", "by (simp add: deltaG_Bonk_Schramm_extension_def)"], ["proof (state)\nthis:\n  deltaG TYPE('b) = deltaG TYPE('b Bonk_Schramm_extension)\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset\n     (752 * lambda ^ 3 * (C + deltaG TYPE('b Bonk_Schramm_extension))) UNIV", "apply (rule Gromov_hyperbolic_invariant_under_quasi_isometry_explicit[of _ _ \"to_Bonk_Schramm_extension o f\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda C -quasi_isometry (to_Bonk_Schramm_extension \\<circ> f)", "using A"], ["proof (prove)\nusing this:\n  (lambda * 1) (C * 1 + 0) -quasi_isometry\n   (to_Bonk_Schramm_extension \\<circ> f)\n\ngoal (1 subgoal):\n 1. lambda C -quasi_isometry (to_Bonk_Schramm_extension \\<circ> f)", "by auto"], ["proof (state)\nthis:\n  Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem Gromov_hyperbolic_invariant_under_quasi_isometry':\n  assumes \"quasi_isometric (UNIV::('a::geodesic_space) set) (UNIV::('b::Gromov_hyperbolic_space) set)\"\n  shows \"\\<exists>delta. Gromov_hyperbolic_subset delta (UNIV::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>delta. Gromov_hyperbolic_subset delta UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>delta. Gromov_hyperbolic_subset delta UNIV", "obtain C lambda f where f: \"lambda C-quasi_isometry_between (UNIV::'a set) (UNIV::'b set) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lambda C f.\n        lambda C -quasi_isometry_between UNIV UNIV f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  quasi_isometric UNIV UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>lambda C f.\n        lambda C -quasi_isometry_between UNIV UNIV f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding quasi_isometric_def"], ["proof (prove)\nusing this:\n  \\<exists>lambda C. Ex (lambda C -quasi_isometry_between UNIV UNIV)\n\ngoal (1 subgoal):\n 1. (\\<And>lambda C f.\n        lambda C -quasi_isometry_between UNIV UNIV f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  lambda C -quasi_isometry_between UNIV UNIV f\n\ngoal (1 subgoal):\n 1. \\<exists>delta. Gromov_hyperbolic_subset delta UNIV", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>delta. Gromov_hyperbolic_subset delta UNIV", "using Gromov_hyperbolic_invariant_under_quasi_isometry_explicit'[OF quasi_isometry_betweenD(1)[OF f]]"], ["proof (prove)\nusing this:\n  Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>delta. Gromov_hyperbolic_subset delta UNIV", "by blast"], ["proof (state)\nthis:\n  \\<exists>delta. Gromov_hyperbolic_subset delta UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(*of theory Bonk_Schramm_Extension*)"]]}