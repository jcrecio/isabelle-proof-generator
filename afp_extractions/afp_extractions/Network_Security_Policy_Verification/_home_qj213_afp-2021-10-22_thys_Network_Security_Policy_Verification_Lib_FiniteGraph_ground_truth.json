{"file_name": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification/Lib/FiniteGraph.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification", "problem_names": ["lemma E_wfD: assumes \"(v,v') \\<in> E\"\n      shows \"v \\<in> V\" \"v' \\<in> V\"", "lemma E_wfD2: \"\\<forall>e \\<in> E. fst e \\<in> V \\<and> snd e \\<in> V\"", "lemma succ_tran_finite: \"wf_graph G \\<Longrightarrow> finite (succ_tran G v)\"", "lemma succ_tran_empty: \"\\<lbrakk> wf_graph G; v \\<notin> (fst ` edges G) \\<rbrakk> \\<Longrightarrow> succ_tran G v = {}\"", "lemma succ_tran_subseteq_nodes: \"\\<lbrakk> wf_graph G \\<rbrakk> \\<Longrightarrow> succ_tran G v \\<subseteq> nodes G\"", "lemma num_reachable_zero: \"\\<lbrakk>wf_graph G; num_reachable G v = 0\\<rbrakk> \\<Longrightarrow> succ_tran G v = {}\"", "lemma num_succtran_zero: \"\\<lbrakk>succ_tran G v = {}\\<rbrakk> \\<Longrightarrow> num_reachable G v = 0\"", "lemma num_reachable_zero_iff: \"\\<lbrakk>wf_graph G\\<rbrakk> \\<Longrightarrow> (num_reachable G v = 0) \\<longleftrightarrow> (succ_tran G v = {})\"", "lemma graph_eq_intro: \"(nodes (G::'a graph) = nodes G') \\<Longrightarrow> (edges G = edges G') \\<Longrightarrow> G = G'\"", "lemma wf_graph_finite_filterE: \"wf_graph G \\<Longrightarrow> finite {(e1, e2). (e1, e2) \\<in> edges G \\<and> P e1 e2}\"", "lemma wf_graph_finite_filterV: \"wf_graph G \\<Longrightarrow> finite {n. n \\<in> nodes G \\<and> P n}\"", "lemma empty_wf[simp]: \"wf_graph empty\"", "lemma nodes_empty[simp]: \"nodes empty = {}\"", "lemma edges_empty[simp]: \"edges empty = {}\"", "lemma add_node_wf[simp]: \"wf_graph g \\<Longrightarrow> wf_graph (add_node v g)\"", "lemma delete_node_wf[simp]: \"wf_graph G \\<Longrightarrow> wf_graph (delete_node v G)\"", "lemma add_edge_wf[simp]: \"wf_graph G \\<Longrightarrow> wf_graph (add_edge v v' G)\"", "lemma delete_edge_wf[simp]: \"wf_graph G \\<Longrightarrow> wf_graph (delete_edge v v' G)\"", "lemma delete_edges_list_wf[simp]: \"wf_graph G \\<Longrightarrow> wf_graph (delete_edges_list G E)\"", "lemma delete_edges_wf[simp]: \"wf_graph G \\<Longrightarrow> wf_graph (delete_edges G E)\"", "lemma delete_edges_list_set: \"delete_edges_list G E = delete_edges G (set E)\"", "lemma delete_edges_list_union: \"delete_edges_list G (ff @ keeps) = delete_edges G (set ff \\<union> set keeps)\"", "lemma add_edge_delete_edges_list: \n    \"(add_edge (fst a) (snd a) (delete_edges_list G (a # ff))) = (add_edge (fst a) (snd a) (delete_edges G (set ff)))\"", "lemma delete_edges_empty[simp]: \"delete_edges G {} = G\"", "lemma delete_edges_simp2: \"delete_edges G E = \\<lparr> nodes = nodes G, edges = edges G - E\\<rparr>\"", "lemma delete_edges_set_nodes: \"nodes (delete_edges G E) = nodes G\"", "lemma delete_edges_edges_mono: \"E' \\<subseteq> E \\<Longrightarrow> edges (delete_edges G E) \\<subseteq> edges (delete_edges G E')\"", "lemma delete_edges_edges_empty: \"(delete_edges G (edges G)) = G\\<lparr>edges := {}\\<rparr>\"", "lemma add_delete_edge: \"wf_graph (G::'a graph) \\<Longrightarrow> (a,b) \\<in> edges G \\<Longrightarrow> add_edge a b (delete_edge a b G) = G\"", "lemma add_delete_edges: \"wf_graph (G::'v graph) \\<Longrightarrow> (a,b) \\<in> edges G \\<Longrightarrow> (a,b) \\<notin> fs \\<Longrightarrow>\n    add_edge a b (delete_edges G (insert (a, b) fs)) = (delete_edges G fs)\"", "lemma fully_connected_simp: \"fully_connected \\<lparr>nodes = N, edges = ignore \\<rparr>\\<equiv> \\<lparr>nodes = N, edges = N \\<times> N \\<rparr>\"", "lemma fully_connected_wf: \"wf_graph G \\<Longrightarrow> wf_graph (fully_connected G)\"", "lemma succ_tran_mono: \n  \"wf_graph \\<lparr>nodes=N, edges=E\\<rparr> \\<Longrightarrow> E' \\<subseteq> E \\<Longrightarrow> succ_tran \\<lparr>nodes=N, edges=E'\\<rparr> v \\<subseteq> succ_tran \\<lparr>nodes=N, edges=E\\<rparr> v\"", "lemma num_reachable_mono:\n  \"wf_graph \\<lparr>nodes=N, edges=E\\<rparr> \\<Longrightarrow> E' \\<subseteq> E \\<Longrightarrow> num_reachable \\<lparr>nodes=N, edges=E'\\<rparr> v \\<le> num_reachable \\<lparr>nodes=N, edges=E\\<rparr> v\"", "lemma num_reachable_norefl_mono:\n  \"wf_graph \\<lparr>nodes=N, edges=E\\<rparr> \\<Longrightarrow> E' \\<subseteq> E \\<Longrightarrow> num_reachable_norefl \\<lparr>nodes=N, edges=E'\\<rparr> v \\<le> num_reachable_norefl \\<lparr>nodes=N, edges=E\\<rparr> v\"", "lemma backflows_wf: \n    \"wf_graph \\<lparr>nodes=N, edges=E\\<rparr> \\<Longrightarrow> wf_graph \\<lparr>nodes=N, edges=backflows E\\<rparr>\"", "lemma undirected_backflows: \n    \"undirected G = \\<lparr> nodes = nodes G, edges = (edges G) \\<union> backflows (edges G) \\<rparr>\"", "lemma backflows_id: \n    \"backflows (backflows E) = E\"", "lemma backflows_finite: \"finite E \\<Longrightarrow> finite (backflows E)\"", "lemma backflows_minus_backflows: \"backflows (X - backflows Y) = (backflows X) - Y\"", "lemma backflows_subseteq: \"X \\<subseteq> Y \\<longleftrightarrow> backflows X \\<subseteq> backflows Y\"", "lemma backflows_un: \"backflows (A \\<union> B) = (backflows A) \\<union> (backflows B)\"", "lemma backflows_inter: \"backflows (A \\<inter> B) = (backflows A) \\<inter> (backflows B)\"", "lemma backflows_alt_fstsnd: \"backflows E = (\\<lambda>e. (snd e, fst e)) ` E\"", "lemmas graph_ops=add_node_def delete_node_def add_edge_def delete_edge_def delete_edges_simp2\n\n\n  \\<comment> \\<open>wf_graph\\<close>", "lemma wf_graph_remove_edges: \"wf_graph \\<lparr> nodes = V, edges = E \\<rparr> \\<Longrightarrow> wf_graph \\<lparr> nodes = V, edges=E - X\\<rparr>\"", "lemma wf_graph_remove_edges_union: \n    \"wf_graph \\<lparr> nodes = V, edges = E \\<union> E' \\<rparr> \\<Longrightarrow> wf_graph \\<lparr> nodes = V, edges=E\\<rparr>\"", "lemma wf_graph_union_edges: \"\\<lbrakk> wf_graph \\<lparr> nodes = V, edges = E \\<rparr>; wf_graph \\<lparr> nodes = V, edges=E'\\<rparr> \\<rbrakk> \\<Longrightarrow>\n     wf_graph \\<lparr> nodes = V, edges=E \\<union> E'\\<rparr>\"", "lemma wf_graph_add_subset_edges: \"\\<lbrakk> wf_graph \\<lparr> nodes = V, edges = E \\<rparr>; E' \\<subseteq> E \\<rbrakk> \\<Longrightarrow>\n     wf_graph \\<lparr> nodes = V, edges= E \\<union> E'\\<rparr>\"", "lemma succ_finite[simp, intro]: \"finite (edges G) \\<Longrightarrow> finite (succ G v)\"", "lemma succ_empty: \"succ empty v = {}\"", "lemma (in wf_graph) succ_subset: \"succ G v \\<subseteq> V\""], "translations": [["", "lemma E_wfD: assumes \"(v,v') \\<in> E\"\n      shows \"v \\<in> V\" \"v' \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> V &&& v' \\<in> V", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. v \\<in> V\n 2. v' \\<in> V", "apply (rule subsetD[OF E_wf(1)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. v \\<in> fst ` E\n 2. v' \\<in> V", "using assms"], ["proof (prove)\nusing this:\n  (v, v') \\<in> E\n\ngoal (2 subgoals):\n 1. v \\<in> fst ` E\n 2. v' \\<in> V", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. v' \\<in> V", "apply (rule subsetD[OF E_wf(2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. v' \\<in> snd ` E", "using assms"], ["proof (prove)\nusing this:\n  (v, v') \\<in> E\n\ngoal (1 subgoal):\n 1. v' \\<in> snd ` E", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma E_wfD2: \"\\<forall>e \\<in> E. fst e \\<in> V \\<and> snd e \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>E. fst e \\<in> V \\<and> snd e \\<in> V", "by (auto simp add: E_wfD)"], ["", "end"], ["", "subsection \\<open>Basic operations on Graphs\\<close>"], ["", "text \\<open>The empty graph.\\<close>"], ["", "definition empty :: \"'v graph\" where \n    \"empty \\<equiv> \\<lparr> nodes = {}, edges = {} \\<rparr>\""], ["", "text \\<open>Adds a node to a graph.\\<close>"], ["", "definition add_node :: \"'v \\<Rightarrow> 'v graph \\<Rightarrow> 'v graph\" where \n    \"add_node v G \\<equiv> \\<lparr> nodes = ({v} \\<union> (nodes G)), edges=edges G \\<rparr>\""], ["", "text \\<open>Deletes a node from a graph. Also deletes all adjacent edges.\\<close>"], ["", "definition delete_node where \"delete_node v G \\<equiv> \\<lparr> \n      nodes = (nodes G) - {v},   \n      edges = {(e1, e2). (e1, e2) \\<in> edges G \\<and> e1 \\<noteq> v \\<and> e2 \\<noteq> v}\n    \\<rparr>\""], ["", "text \\<open>Adds an edge to a graph.\\<close>"], ["", "definition add_edge where \n  \"add_edge v v' G = \\<lparr>nodes = nodes G \\<union> {v,v'}, edges = {(v, v')} \\<union> edges G \\<rparr>\""], ["", "text \\<open>Deletes an edge from a graph.\\<close>"], ["", "definition delete_edge where \"delete_edge v v' G \\<equiv> \\<lparr>\n      nodes = nodes G, \n      edges = {(e1,e2). (e1, e2) \\<in> edges G \\<and> (e1,e2) \\<noteq> (v,v')}\n    \\<rparr>\""], ["", "definition delete_edges::\"'v graph \\<Rightarrow> ('v \\<times> 'v) set \\<Rightarrow> 'v graph\" where \n    \"delete_edges G es \\<equiv> \\<lparr>\n      nodes = nodes G, \n      edges = {(e1,e2). (e1, e2) \\<in> edges G \\<and> (e1,e2) \\<notin> es}\n    \\<rparr>\""], ["", "fun delete_edges_list::\"'v graph \\<Rightarrow> ('v \\<times> 'v) list \\<Rightarrow> 'v graph\" where \n    \"delete_edges_list G [] = G\"|\n    \"delete_edges_list G ((v,v')#es) = delete_edges_list (delete_edge v v' G) es\""], ["", "definition fully_connected :: \"'v graph \\<Rightarrow> 'v graph\" where\n    \"fully_connected G \\<equiv> \\<lparr>nodes = nodes G, edges = nodes G \\<times> nodes G \\<rparr>\""], ["", "text \\<open>Extended graph operations\\<close>"], ["", "text \\<open>Reflexive transitive successors of a node. Or: All reachable nodes for \\<open>v\\<close> including \\<open>v\\<close>.\\<close>"], ["", "definition succ_rtran :: \"'v graph \\<Rightarrow> 'v \\<Rightarrow> 'v set\" where\n    \"succ_rtran G v = {e2. (v,e2) \\<in> (edges G)\\<^sup>*}\""], ["", "text \\<open>Transitive successors of a node. Or: All reachable nodes for \\<open>v\\<close>.\\<close>"], ["", "definition succ_tran :: \"'v graph \\<Rightarrow> 'v \\<Rightarrow> 'v set\" where\n    \"succ_tran G v = {e2. (v,e2) \\<in> (edges G)\\<^sup>+}\"\n\n  \\<comment> \\<open>succ_tran is always finite\\<close>"], ["", "lemma succ_tran_finite: \"wf_graph G \\<Longrightarrow> finite (succ_tran G v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> finite (succ_tran G v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> finite (succ_tran G v)", "assume \"wf_graph G\""], ["proof (state)\nthis:\n  wf_graph G\n\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> finite (succ_tran G v)", "from wf_graph.finiteE[OF this]"], ["proof (chain)\npicking this:\n  finite (edges G)", "have \"finite ((edges G)\\<^sup>+)\""], ["proof (prove)\nusing this:\n  finite (edges G)\n\ngoal (1 subgoal):\n 1. finite ((edges G)\\<^sup>+)", "using finite_trancl[symmetric, of \"edges G\"]"], ["proof (prove)\nusing this:\n  finite (edges G)\n  finite (edges G) = finite ((edges G)\\<^sup>+)\n\ngoal (1 subgoal):\n 1. finite ((edges G)\\<^sup>+)", "by metis"], ["proof (state)\nthis:\n  finite ((edges G)\\<^sup>+)\n\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> finite (succ_tran G v)", "from this"], ["proof (chain)\npicking this:\n  finite ((edges G)\\<^sup>+)", "have \"finite {(e1,e2). (e1, e2) \\<in> (edges G)\\<^sup>+}\""], ["proof (prove)\nusing this:\n  finite ((edges G)\\<^sup>+)\n\ngoal (1 subgoal):\n 1. finite {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+}", "by simp"], ["proof (state)\nthis:\n  finite {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+}\n\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> finite (succ_tran G v)", "from this"], ["proof (chain)\npicking this:\n  finite {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+}", "have finite: \"finite (snd ` {(e1,e2). (e1, e2) \\<in> (edges G)\\<^sup>+})\""], ["proof (prove)\nusing this:\n  finite {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+}\n\ngoal (1 subgoal):\n 1. finite (snd ` {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+})", "by (metis finite_imageI)"], ["proof (state)\nthis:\n  finite (snd ` {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+})\n\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> finite (succ_tran G v)", "have \"{(e1,e2). (e1, e2) \\<in> (edges G)\\<^sup>+ \\<and> e1 = v} \\<subseteq> {(e1,e2). (e1, e2) \\<in> (edges G)\\<^sup>+}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+ \\<and> e1 = v}\n    \\<subseteq> {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+}", "by blast"], ["proof (state)\nthis:\n  {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+ \\<and> e1 = v}\n  \\<subseteq> {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+}\n\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> finite (succ_tran G v)", "have 1: \"snd ` {(e1,e2). (e1, e2) \\<in> (edges G)\\<^sup>+ \\<and> e1 = v} \\<subseteq> snd ` {(e1,e2). (e1, e2) \\<in> (edges G)\\<^sup>+}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+ \\<and> e1 = v}\n    \\<subseteq> snd ` {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+}", "by blast"], ["proof (state)\nthis:\n  snd ` {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+ \\<and> e1 = v}\n  \\<subseteq> snd ` {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+}\n\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> finite (succ_tran G v)", "have 2: \"snd ` {(e1,e2). (e1, e2) \\<in> (edges G)\\<^sup>+ \\<and> e1 = v} = {e2. (v,e2) \\<in> (edges G)\\<^sup>+}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+ \\<and> e1 = v} =\n    {e2. (v, e2) \\<in> (edges G)\\<^sup>+}", "by force"], ["proof (state)\nthis:\n  snd ` {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+ \\<and> e1 = v} =\n  {e2. (v, e2) \\<in> (edges G)\\<^sup>+}\n\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> finite (succ_tran G v)", "from 1 2"], ["proof (chain)\npicking this:\n  snd ` {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+ \\<and> e1 = v}\n  \\<subseteq> snd ` {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+}\n  snd ` {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+ \\<and> e1 = v} =\n  {e2. (v, e2) \\<in> (edges G)\\<^sup>+}", "have \"{e2. (v,e2) \\<in> (edges G)\\<^sup>+} \\<subseteq> snd ` {(e1,e2). (e1, e2) \\<in> (edges G)\\<^sup>+}\""], ["proof (prove)\nusing this:\n  snd ` {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+ \\<and> e1 = v}\n  \\<subseteq> snd ` {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+}\n  snd ` {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+ \\<and> e1 = v} =\n  {e2. (v, e2) \\<in> (edges G)\\<^sup>+}\n\ngoal (1 subgoal):\n 1. {e2. (v, e2) \\<in> (edges G)\\<^sup>+}\n    \\<subseteq> snd ` {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+}", "by blast"], ["proof (state)\nthis:\n  {e2. (v, e2) \\<in> (edges G)\\<^sup>+}\n  \\<subseteq> snd ` {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+}\n\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> finite (succ_tran G v)", "from this finite"], ["proof (chain)\npicking this:\n  {e2. (v, e2) \\<in> (edges G)\\<^sup>+}\n  \\<subseteq> snd ` {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+}\n  finite (snd ` {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+})", "have \"finite {e2. (v, e2) \\<in> (edges G)\\<^sup>+}\""], ["proof (prove)\nusing this:\n  {e2. (v, e2) \\<in> (edges G)\\<^sup>+}\n  \\<subseteq> snd ` {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+}\n  finite (snd ` {(e1, e2). (e1, e2) \\<in> (edges G)\\<^sup>+})\n\ngoal (1 subgoal):\n 1. finite {e2. (v, e2) \\<in> (edges G)\\<^sup>+}", "by (metis finite_subset)"], ["proof (state)\nthis:\n  finite {e2. (v, e2) \\<in> (edges G)\\<^sup>+}\n\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> finite (succ_tran G v)", "thus \"finite (succ_tran G v)\""], ["proof (prove)\nusing this:\n  finite {e2. (v, e2) \\<in> (edges G)\\<^sup>+}\n\ngoal (1 subgoal):\n 1. finite (succ_tran G v)", "using succ_tran_def"], ["proof (prove)\nusing this:\n  finite {e2. (v, e2) \\<in> (edges G)\\<^sup>+}\n  succ_tran ?G ?v = {e2. (?v, e2) \\<in> (edges ?G)\\<^sup>+}\n\ngoal (1 subgoal):\n 1. finite (succ_tran G v)", "by metis"], ["proof (state)\nthis:\n  finite (succ_tran G v)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>If there is no edge leaving from \\<open>v\\<close>, then \\<open>v\\<close> has no successors\\<close>"], ["", "lemma succ_tran_empty: \"\\<lbrakk> wf_graph G; v \\<notin> (fst ` edges G) \\<rbrakk> \\<Longrightarrow> succ_tran G v = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G; v \\<notin> fst ` edges G\\<rbrakk>\n    \\<Longrightarrow> succ_tran G v = {}", "unfolding succ_tran_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G; v \\<notin> fst ` edges G\\<rbrakk>\n    \\<Longrightarrow> {e2. (v, e2) \\<in> (edges G)\\<^sup>+} = {}", "using image_iff tranclD"], ["proof (prove)\nusing this:\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)\n  (?x, ?y) \\<in> ?R\\<^sup>+ \\<Longrightarrow>\n  \\<exists>z. (?x, z) \\<in> ?R \\<and> (z, ?y) \\<in> ?R\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G; v \\<notin> fst ` edges G\\<rbrakk>\n    \\<Longrightarrow> {e2. (v, e2) \\<in> (edges G)\\<^sup>+} = {}", "by fastforce"], ["", "text\\<open>@{const succ_tran} is subset of nodes\\<close>"], ["", "lemma succ_tran_subseteq_nodes: \"\\<lbrakk> wf_graph G \\<rbrakk> \\<Longrightarrow> succ_tran G v \\<subseteq> nodes G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> succ_tran G v \\<subseteq> nodes G", "unfolding succ_tran_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow>\n    {e2. (v, e2) \\<in> (edges G)\\<^sup>+} \\<subseteq> nodes G", "using tranclD2 wf_graph.E_wfD(2)"], ["proof (prove)\nusing this:\n  (?x, ?y) \\<in> ?R\\<^sup>+ \\<Longrightarrow>\n  \\<exists>z. (?x, z) \\<in> ?R\\<^sup>* \\<and> (z, ?y) \\<in> ?R\n  \\<lbrakk>wf_graph ?G; (?v, ?v') \\<in> edges ?G\\<rbrakk>\n  \\<Longrightarrow> ?v' \\<in> nodes ?G\n\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow>\n    {e2. (v, e2) \\<in> (edges G)\\<^sup>+} \\<subseteq> nodes G", "by fastforce"], ["", "text \\<open>The number of reachable nodes from \\<open>v\\<close>\\<close>"], ["", "definition num_reachable :: \"'v graph \\<Rightarrow> 'v \\<Rightarrow> nat\" where\n    \"num_reachable G v = card (succ_tran G v)\""], ["", "definition num_reachable_norefl :: \"'v graph \\<Rightarrow> 'v \\<Rightarrow> nat\" where\n    \"num_reachable_norefl G v = card (succ_tran G v - {v})\""], ["", "text\\<open>@{const card} returns @{term 0} for infinite sets.\n        Here, for a well-formed graph, if @{const num_reachable} is zero, there are actually no nodes reachable.\\<close>"], ["", "lemma num_reachable_zero: \"\\<lbrakk>wf_graph G; num_reachable G v = 0\\<rbrakk> \\<Longrightarrow> succ_tran G v = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G; num_reachable G v = 0\\<rbrakk>\n    \\<Longrightarrow> succ_tran G v = {}", "unfolding num_reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G; card (succ_tran G v) = 0\\<rbrakk>\n    \\<Longrightarrow> succ_tran G v = {}", "apply(subgoal_tac \"finite (succ_tran G v)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_graph G; card (succ_tran G v) = 0;\n     finite (succ_tran G v)\\<rbrakk>\n    \\<Longrightarrow> succ_tran G v = {}\n 2. \\<lbrakk>wf_graph G; card (succ_tran G v) = 0\\<rbrakk>\n    \\<Longrightarrow> finite (succ_tran G v)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G; card (succ_tran G v) = 0\\<rbrakk>\n    \\<Longrightarrow> finite (succ_tran G v)", "apply(blast intro: succ_tran_finite)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma num_succtran_zero: \"\\<lbrakk>succ_tran G v = {}\\<rbrakk> \\<Longrightarrow> num_reachable G v = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ_tran G v = {} \\<Longrightarrow> num_reachable G v = 0", "unfolding num_reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. succ_tran G v = {} \\<Longrightarrow> card (succ_tran G v) = 0", "by simp"], ["", "lemma num_reachable_zero_iff: \"\\<lbrakk>wf_graph G\\<rbrakk> \\<Longrightarrow> (num_reachable G v = 0) \\<longleftrightarrow> (succ_tran G v = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow>\n    (num_reachable G v = 0) = (succ_tran G v = {})", "by(metis num_succtran_zero num_reachable_zero)"], ["", "section\\<open>Undirected Graph\\<close>"], ["", "subsection\\<open>undirected graph simulation\\<close>"], ["", "text \\<open>Create undirected graph from directed graph by adding backward links\\<close>"], ["", "definition backflows :: \"('v \\<times> 'v) set \\<Rightarrow> ('v \\<times> 'v) set\" where\n    \"backflows E \\<equiv> {(r,s). (s,r) \\<in> E}\""], ["", "definition undirected :: \"'v graph \\<Rightarrow> 'v graph\"\n    where \"undirected G = \\<lparr> nodes = nodes G, edges = (edges G) \\<union> {(b,a). (a,b) \\<in> edges G} \\<rparr>\""], ["", "section \\<open>Graph Lemmas\\<close>"], ["", "lemma graph_eq_intro: \"(nodes (G::'a graph) = nodes G') \\<Longrightarrow> (edges G = edges G') \\<Longrightarrow> G = G'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nodes G = nodes G'; edges G = edges G'\\<rbrakk>\n    \\<Longrightarrow> G = G'", "by simp\n\n  \\<comment> \\<open>finite\\<close>"], ["", "lemma wf_graph_finite_filterE: \"wf_graph G \\<Longrightarrow> finite {(e1, e2). (e1, e2) \\<in> edges G \\<and> P e1 e2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow>\n    finite {(e1, e2). (e1, e2) \\<in> edges G \\<and> P e1 e2}", "by(simp add: wf_graph.finiteE split_def)"], ["", "lemma wf_graph_finite_filterV: \"wf_graph G \\<Longrightarrow> finite {n. n \\<in> nodes G \\<and> P n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> finite {n \\<in> nodes G. P n}", "by(simp add: wf_graph.finiteV)\n\n  \\<comment> \\<open>empty\\<close>"], ["", "lemma empty_wf[simp]: \"wf_graph empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph FiniteGraph.empty", "unfolding empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph \\<lparr>nodes = {}, edges = {}\\<rparr>", "by unfold_locales auto"], ["", "lemma nodes_empty[simp]: \"nodes empty = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes FiniteGraph.empty = {}", "unfolding empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes \\<lparr>nodes = {}, edges = {}\\<rparr> = {}", "by simp"], ["", "lemma edges_empty[simp]: \"edges empty = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges FiniteGraph.empty = {}", "unfolding empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. edges \\<lparr>nodes = {}, edges = {}\\<rparr> = {}", "by simp\n\n  \\<comment> \\<open>add node\\<close>"], ["", "lemma add_node_wf[simp]: \"wf_graph g \\<Longrightarrow> wf_graph (add_node v g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph g \\<Longrightarrow> wf_graph (add_node v g)", "unfolding add_node_def wf_graph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst ` edges g \\<subseteq> nodes g \\<and>\n     snd ` edges g \\<subseteq> nodes g) \\<and>\n    finite (edges g) \\<and> finite (nodes g) \\<Longrightarrow>\n    (fst `\n     edges \\<lparr>nodes = {v} \\<union> nodes g, edges = edges g\\<rparr>\n     \\<subseteq> nodes\n                  \\<lparr>nodes = {v} \\<union> nodes g,\n                     edges = edges g\\<rparr> \\<and>\n     snd `\n     edges \\<lparr>nodes = {v} \\<union> nodes g, edges = edges g\\<rparr>\n     \\<subseteq> nodes\n                  \\<lparr>nodes = {v} \\<union> nodes g,\n                     edges = edges g\\<rparr>) \\<and>\n    finite\n     (edges\n       \\<lparr>nodes = {v} \\<union> nodes g, edges = edges g\\<rparr>) \\<and>\n    finite\n     (nodes \\<lparr>nodes = {v} \\<union> nodes g, edges = edges g\\<rparr>)", "by (auto)"], ["", "lemma delete_node_wf[simp]: \"wf_graph G \\<Longrightarrow> wf_graph (delete_node v G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> wf_graph (delete_node v G)", "by(auto simp add: delete_node_def wf_graph_def wf_graph_finite_filterE)\n\n  \\<comment> \\<open>add edgde\\<close>"], ["", "lemma add_edge_wf[simp]: \"wf_graph G \\<Longrightarrow> wf_graph (add_edge v v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> wf_graph (add_edge v v' G)", "by(auto simp add: add_edge_def add_node_def wf_graph_def)\n\n  \\<comment> \\<open>delete edge\\<close>"], ["", "lemma delete_edge_wf[simp]: \"wf_graph G \\<Longrightarrow> wf_graph (delete_edge v v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> wf_graph (delete_edge v v' G)", "by(auto simp add: delete_edge_def add_node_def wf_graph_def split_def)\n \n  \\<comment> \\<open>delte edges\\<close>"], ["", "lemma delete_edges_list_wf[simp]: \"wf_graph G \\<Longrightarrow> wf_graph (delete_edges_list G E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> wf_graph (delete_edges_list G E)", "by(induction E arbitrary: G, simp, force)"], ["", "lemma delete_edges_wf[simp]: \"wf_graph G \\<Longrightarrow> wf_graph (delete_edges G E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> wf_graph (delete_edges G E)", "by(auto simp add: delete_edges_def add_node_def wf_graph_def split_def)"], ["", "lemma delete_edges_list_set: \"delete_edges_list G E = delete_edges G (set E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete_edges_list G E = delete_edges G (set E)", "proof(induction E arbitrary: G)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>G. delete_edges_list G [] = delete_edges G (set [])\n 2. \\<And>a E G.\n       (\\<And>G.\n           delete_edges_list G E = delete_edges G (set E)) \\<Longrightarrow>\n       delete_edges_list G (a # E) = delete_edges G (set (a # E))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>G. delete_edges_list G [] = delete_edges G (set [])\n 2. \\<And>a E G.\n       (\\<And>G.\n           delete_edges_list G E = delete_edges G (set E)) \\<Longrightarrow>\n       delete_edges_list G (a # E) = delete_edges G (set (a # E))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. delete_edges_list G [] = delete_edges G (set [])", "by (simp add: delete_edges_def)"], ["proof (state)\nthis:\n  delete_edges_list G [] = delete_edges G (set [])\n\ngoal (1 subgoal):\n 1. \\<And>a E G.\n       (\\<And>G.\n           delete_edges_list G E = delete_edges G (set E)) \\<Longrightarrow>\n       delete_edges_list G (a # E) = delete_edges G (set (a # E))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a E G.\n       (\\<And>G.\n           delete_edges_list G E = delete_edges G (set E)) \\<Longrightarrow>\n       delete_edges_list G (a # E) = delete_edges G (set (a # E))", "case (Cons e E)"], ["proof (state)\nthis:\n  delete_edges_list ?G E = delete_edges ?G (set E)\n\ngoal (1 subgoal):\n 1. \\<And>a E G.\n       (\\<And>G.\n           delete_edges_list G E = delete_edges G (set E)) \\<Longrightarrow>\n       delete_edges_list G (a # E) = delete_edges G (set (a # E))", "thus ?case"], ["proof (prove)\nusing this:\n  delete_edges_list ?G E = delete_edges ?G (set E)\n\ngoal (1 subgoal):\n 1. delete_edges_list G (e # E) = delete_edges G (set (e # E))", "by(cases e)(simp add: delete_edge_def delete_edges_def)"], ["proof (state)\nthis:\n  delete_edges_list G (e # E) = delete_edges G (set (e # E))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delete_edges_list_union: \"delete_edges_list G (ff @ keeps) = delete_edges G (set ff \\<union> set keeps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete_edges_list G (ff @ keeps) =\n    delete_edges G (set ff \\<union> set keeps)", "by(simp add: delete_edges_list_set)"], ["", "lemma add_edge_delete_edges_list: \n    \"(add_edge (fst a) (snd a) (delete_edges_list G (a # ff))) = (add_edge (fst a) (snd a) (delete_edges G (set ff)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_edge (fst a) (snd a) (delete_edges_list G (a # ff)) =\n    add_edge (fst a) (snd a) (delete_edges G (set ff))", "by(auto simp add: delete_edges_list_set delete_edges_def add_edge_def add_node_def)"], ["", "lemma delete_edges_empty[simp]: \"delete_edges G {} = G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete_edges G {} = G", "by(simp add: delete_edges_def)"], ["", "lemma delete_edges_simp2: \"delete_edges G E = \\<lparr> nodes = nodes G, edges = edges G - E\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete_edges G E = \\<lparr>nodes = nodes G, edges = edges G - E\\<rparr>", "by(auto simp add: delete_edges_def)"], ["", "lemma delete_edges_set_nodes: \"nodes (delete_edges G E) = nodes G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (delete_edges G E) = nodes G", "by(simp add: delete_edges_simp2)"], ["", "lemma delete_edges_edges_mono: \"E' \\<subseteq> E \\<Longrightarrow> edges (delete_edges G E) \\<subseteq> edges (delete_edges G E')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E' \\<subseteq> E \\<Longrightarrow>\n    edges (delete_edges G E) \\<subseteq> edges (delete_edges G E')", "by(simp add: delete_edges_def, fast)"], ["", "lemma delete_edges_edges_empty: \"(delete_edges G (edges G)) = G\\<lparr>edges := {}\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete_edges G (edges G) = G\\<lparr>edges := {}\\<rparr>", "by(simp add: delete_edges_simp2)\n\n \\<comment> \\<open>add delete\\<close>"], ["", "lemma add_delete_edge: \"wf_graph (G::'a graph) \\<Longrightarrow> (a,b) \\<in> edges G \\<Longrightarrow> add_edge a b (delete_edge a b G) = G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G; (a, b) \\<in> edges G\\<rbrakk>\n    \\<Longrightarrow> add_edge a b (delete_edge a b G) = G", "apply(simp add: delete_edge_def add_edge_def wf_graph_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst ` edges G \\<subseteq> nodes G \\<and>\n             snd ` edges G \\<subseteq> nodes G \\<and>\n             finite (edges G) \\<and> finite (nodes G);\n     (a, b) \\<in> edges G\\<rbrakk>\n    \\<Longrightarrow> \\<lparr>nodes = insert a (insert b (nodes G)),\n                         edges =\n                           insert (a, b)\n                            {(e1, e2).\n                             (e1, e2) \\<in> edges G \\<and>\n                             (e1 = a \\<longrightarrow>\n                              e2 \\<noteq> b)}\\<rparr> =\n                      G", "apply(intro graph_eq_intro)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fst ` edges G \\<subseteq> nodes G \\<and>\n             snd ` edges G \\<subseteq> nodes G \\<and>\n             finite (edges G) \\<and> finite (nodes G);\n     (a, b) \\<in> edges G\\<rbrakk>\n    \\<Longrightarrow> nodes\n                       \\<lparr>nodes = insert a (insert b (nodes G)),\n                          edges =\n                            insert (a, b)\n                             {(e1, e2).\n                              (e1, e2) \\<in> edges G \\<and>\n                              (e1 = a \\<longrightarrow>\n                               e2 \\<noteq> b)}\\<rparr> =\n                      nodes G\n 2. \\<lbrakk>fst ` edges G \\<subseteq> nodes G \\<and>\n             snd ` edges G \\<subseteq> nodes G \\<and>\n             finite (edges G) \\<and> finite (nodes G);\n     (a, b) \\<in> edges G\\<rbrakk>\n    \\<Longrightarrow> edges\n                       \\<lparr>nodes = insert a (insert b (nodes G)),\n                          edges =\n                            insert (a, b)\n                             {(e1, e2).\n                              (e1, e2) \\<in> edges G \\<and>\n                              (e1 = a \\<longrightarrow>\n                               e2 \\<noteq> b)}\\<rparr> =\n                      edges G", "by auto"], ["", "lemma add_delete_edges: \"wf_graph (G::'v graph) \\<Longrightarrow> (a,b) \\<in> edges G \\<Longrightarrow> (a,b) \\<notin> fs \\<Longrightarrow>\n    add_edge a b (delete_edges G (insert (a, b) fs)) = (delete_edges G fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G; (a, b) \\<in> edges G; (a, b) \\<notin> fs\\<rbrakk>\n    \\<Longrightarrow> add_edge a b (delete_edges G (insert (a, b) fs)) =\n                      delete_edges G fs", "by(auto simp add: delete_edges_simp2 add_edge_def wf_graph_def)\n\n\n \\<comment> \\<open>fully_connected\\<close>"], ["", "lemma fully_connected_simp: \"fully_connected \\<lparr>nodes = N, edges = ignore \\<rparr>\\<equiv> \\<lparr>nodes = N, edges = N \\<times> N \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fully_connected \\<lparr>nodes = N, edges = ignore\\<rparr> \\<equiv>\n    \\<lparr>nodes = N, edges = N \\<times> N\\<rparr>", "by(simp add: fully_connected_def)"], ["", "lemma fully_connected_wf: \"wf_graph G \\<Longrightarrow> wf_graph (fully_connected G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> wf_graph (fully_connected G)", "by(simp add: fully_connected_def wf_graph_def)\n\n \\<comment> \\<open>succ_tran\\<close>"], ["", "lemma succ_tran_mono: \n  \"wf_graph \\<lparr>nodes=N, edges=E\\<rparr> \\<Longrightarrow> E' \\<subseteq> E \\<Longrightarrow> succ_tran \\<lparr>nodes=N, edges=E'\\<rparr> v \\<subseteq> succ_tran \\<lparr>nodes=N, edges=E\\<rparr> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n     E' \\<subseteq> E\\<rbrakk>\n    \\<Longrightarrow> succ_tran \\<lparr>nodes = N, edges = E'\\<rparr> v\n                      \\<subseteq> succ_tran\n                                   \\<lparr>nodes = N, edges = E\\<rparr> v", "apply(drule wf_graph.finiteE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>E' \\<subseteq> E;\n     finite (edges \\<lparr>nodes = N, edges = E\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> succ_tran \\<lparr>nodes = N, edges = E'\\<rparr> v\n                      \\<subseteq> succ_tran\n                                   \\<lparr>nodes = N, edges = E\\<rparr> v", "apply(frule_tac A=\"E'\" in rev_finite_subset, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>E' \\<subseteq> E;\n     finite (edges \\<lparr>nodes = N, edges = E\\<rparr>); finite E'\\<rbrakk>\n    \\<Longrightarrow> succ_tran \\<lparr>nodes = N, edges = E'\\<rparr> v\n                      \\<subseteq> succ_tran\n                                   \\<lparr>nodes = N, edges = E\\<rparr> v", "apply(simp add: num_reachable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>E' \\<subseteq> E; finite E; finite E'\\<rbrakk>\n    \\<Longrightarrow> succ_tran \\<lparr>nodes = N, edges = E'\\<rparr> v\n                      \\<subseteq> succ_tran\n                                   \\<lparr>nodes = N, edges = E\\<rparr> v", "apply(simp add: succ_tran_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>E' \\<subseteq> E; finite E; finite E'\\<rbrakk>\n    \\<Longrightarrow> {e2. (v, e2) \\<in> E'\\<^sup>+}\n                      \\<subseteq> {e2. (v, e2) \\<in> E\\<^sup>+}", "apply(metis (lifting, full_types) Collect_mono trancl_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n  \\<comment> \\<open>num_reachable\\<close>"], ["", "lemma num_reachable_mono:\n  \"wf_graph \\<lparr>nodes=N, edges=E\\<rparr> \\<Longrightarrow> E' \\<subseteq> E \\<Longrightarrow> num_reachable \\<lparr>nodes=N, edges=E'\\<rparr> v \\<le> num_reachable \\<lparr>nodes=N, edges=E\\<rparr> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n     E' \\<subseteq> E\\<rbrakk>\n    \\<Longrightarrow> num_reachable \\<lparr>nodes = N, edges = E'\\<rparr> v\n                      \\<le> num_reachable\n                             \\<lparr>nodes = N, edges = E\\<rparr> v", "apply(simp add: num_reachable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n     E' \\<subseteq> E\\<rbrakk>\n    \\<Longrightarrow> card\n                       (succ_tran \\<lparr>nodes = N, edges = E'\\<rparr> v)\n                      \\<le> card\n                             (succ_tran \\<lparr>nodes = N, edges = E\\<rparr>\n                               v)", "apply(frule_tac E'=\"E'\" and v=\"v\" in succ_tran_mono, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     succ_tran \\<lparr>nodes = N, edges = E'\\<rparr> v\n     \\<subseteq> succ_tran \\<lparr>nodes = N, edges = E\\<rparr> v\\<rbrakk>\n    \\<Longrightarrow> card\n                       (succ_tran \\<lparr>nodes = N, edges = E'\\<rparr> v)\n                      \\<le> card\n                             (succ_tran \\<lparr>nodes = N, edges = E\\<rparr>\n                               v)", "apply(frule_tac v=\"v\" in succ_tran_finite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     succ_tran \\<lparr>nodes = N, edges = E'\\<rparr> v\n     \\<subseteq> succ_tran \\<lparr>nodes = N, edges = E\\<rparr> v;\n     finite (succ_tran \\<lparr>nodes = N, edges = E\\<rparr> v)\\<rbrakk>\n    \\<Longrightarrow> card\n                       (succ_tran \\<lparr>nodes = N, edges = E'\\<rparr> v)\n                      \\<le> card\n                             (succ_tran \\<lparr>nodes = N, edges = E\\<rparr>\n                               v)", "apply(simp add: card_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n  \\<comment> \\<open>num_reachable_norefl\\<close>"], ["", "lemma num_reachable_norefl_mono:\n  \"wf_graph \\<lparr>nodes=N, edges=E\\<rparr> \\<Longrightarrow> E' \\<subseteq> E \\<Longrightarrow> num_reachable_norefl \\<lparr>nodes=N, edges=E'\\<rparr> v \\<le> num_reachable_norefl \\<lparr>nodes=N, edges=E\\<rparr> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n     E' \\<subseteq> E\\<rbrakk>\n    \\<Longrightarrow> num_reachable_norefl\n                       \\<lparr>nodes = N, edges = E'\\<rparr> v\n                      \\<le> num_reachable_norefl\n                             \\<lparr>nodes = N, edges = E\\<rparr> v", "apply(simp add: num_reachable_norefl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n     E' \\<subseteq> E\\<rbrakk>\n    \\<Longrightarrow> card\n                       (succ_tran \\<lparr>nodes = N, edges = E'\\<rparr> v -\n                        {v})\n                      \\<le> card\n                             (succ_tran \\<lparr>nodes = N, edges = E\\<rparr>\n                               v -\n                              {v})", "apply(frule_tac E'=\"E'\" and v=\"v\" in succ_tran_mono, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     succ_tran \\<lparr>nodes = N, edges = E'\\<rparr> v\n     \\<subseteq> succ_tran \\<lparr>nodes = N, edges = E\\<rparr> v\\<rbrakk>\n    \\<Longrightarrow> card\n                       (succ_tran \\<lparr>nodes = N, edges = E'\\<rparr> v -\n                        {v})\n                      \\<le> card\n                             (succ_tran \\<lparr>nodes = N, edges = E\\<rparr>\n                               v -\n                              {v})", "apply(frule_tac v=\"v\" in succ_tran_finite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     succ_tran \\<lparr>nodes = N, edges = E'\\<rparr> v\n     \\<subseteq> succ_tran \\<lparr>nodes = N, edges = E\\<rparr> v;\n     finite (succ_tran \\<lparr>nodes = N, edges = E\\<rparr> v)\\<rbrakk>\n    \\<Longrightarrow> card\n                       (succ_tran \\<lparr>nodes = N, edges = E'\\<rparr> v -\n                        {v})\n                      \\<le> card\n                             (succ_tran \\<lparr>nodes = N, edges = E\\<rparr>\n                               v -\n                              {v})", "using card_mono"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?B; ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> card ?A \\<le> card ?B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     succ_tran \\<lparr>nodes = N, edges = E'\\<rparr> v\n     \\<subseteq> succ_tran \\<lparr>nodes = N, edges = E\\<rparr> v;\n     finite (succ_tran \\<lparr>nodes = N, edges = E\\<rparr> v)\\<rbrakk>\n    \\<Longrightarrow> card\n                       (succ_tran \\<lparr>nodes = N, edges = E'\\<rparr> v -\n                        {v})\n                      \\<le> card\n                             (succ_tran \\<lparr>nodes = N, edges = E\\<rparr>\n                               v -\n                              {v})", "by (metis Diff_mono finite_Diff subset_refl)\n\n  \\<comment> \\<open>backflows\\<close>"], ["", "lemma backflows_wf: \n    \"wf_graph \\<lparr>nodes=N, edges=E\\<rparr> \\<Longrightarrow> wf_graph \\<lparr>nodes=N, edges=backflows E\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<Longrightarrow>\n    wf_graph \\<lparr>nodes = N, edges = backflows E\\<rparr>", "using [[simproc add: finite_Collect]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<Longrightarrow>\n    wf_graph \\<lparr>nodes = N, edges = backflows E\\<rparr>", "by(auto simp add: wf_graph_def backflows_def)"], ["", "lemma undirected_backflows: \n    \"undirected G = \\<lparr> nodes = nodes G, edges = (edges G) \\<union> backflows (edges G) \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. undirected G =\n    \\<lparr>nodes = nodes G,\n       edges = edges G \\<union> backflows (edges G)\\<rparr>", "by(simp add: backflows_def undirected_def)"], ["", "lemma backflows_id: \n    \"backflows (backflows E) = E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backflows (backflows E) = E", "by(simp add: backflows_def)"], ["", "lemma backflows_finite: \"finite E \\<Longrightarrow> finite (backflows E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite E \\<Longrightarrow> finite (backflows E)", "using [[simproc add: finite_Collect]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite E \\<Longrightarrow> finite (backflows E)", "by(simp add: backflows_def)"], ["", "lemma backflows_minus_backflows: \"backflows (X - backflows Y) = (backflows X) - Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backflows (X - backflows Y) = backflows X - Y", "by(auto simp add: backflows_def)"], ["", "lemma backflows_subseteq: \"X \\<subseteq> Y \\<longleftrightarrow> backflows X \\<subseteq> backflows Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<subseteq> Y) = (backflows X \\<subseteq> backflows Y)", "by(auto simp add: backflows_def)"], ["", "lemma backflows_un: \"backflows (A \\<union> B) = (backflows A) \\<union> (backflows B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backflows (A \\<union> B) = backflows A \\<union> backflows B", "by(auto simp add: backflows_def)"], ["", "lemma backflows_inter: \"backflows (A \\<inter> B) = (backflows A) \\<inter> (backflows B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backflows (A \\<inter> B) = backflows A \\<inter> backflows B", "by(auto simp add: backflows_def)"], ["", "lemma backflows_alt_fstsnd: \"backflows E = (\\<lambda>e. (snd e, fst e)) ` E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backflows E = (\\<lambda>e. (snd e, fst e)) ` E", "by(auto simp add: backflows_def, force)"], ["", "lemmas graph_ops=add_node_def delete_node_def add_edge_def delete_edge_def delete_edges_simp2\n\n\n  \\<comment> \\<open>wf_graph\\<close>"], ["", "lemma wf_graph_remove_edges: \"wf_graph \\<lparr> nodes = V, edges = E \\<rparr> \\<Longrightarrow> wf_graph \\<lparr> nodes = V, edges=E - X\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    wf_graph \\<lparr>nodes = V, edges = E - X\\<rparr>", "by (metis delete_edges_simp2 delete_edges_wf select_convs(1) select_convs(2))"], ["", "lemma wf_graph_remove_edges_union: \n    \"wf_graph \\<lparr> nodes = V, edges = E \\<union> E' \\<rparr> \\<Longrightarrow> wf_graph \\<lparr> nodes = V, edges=E\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph\n     \\<lparr>nodes = V, edges = E \\<union> E'\\<rparr> \\<Longrightarrow>\n    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>", "by(auto simp add: wf_graph_def)"], ["", "lemma wf_graph_union_edges: \"\\<lbrakk> wf_graph \\<lparr> nodes = V, edges = E \\<rparr>; wf_graph \\<lparr> nodes = V, edges=E'\\<rparr> \\<rbrakk> \\<Longrightarrow>\n     wf_graph \\<lparr> nodes = V, edges=E \\<union> E'\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     wf_graph \\<lparr>nodes = V, edges = E'\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> wf_graph\n                       \\<lparr>nodes = V, edges = E \\<union> E'\\<rparr>", "by(auto simp add: wf_graph_def)"], ["", "lemma wf_graph_add_subset_edges: \"\\<lbrakk> wf_graph \\<lparr> nodes = V, edges = E \\<rparr>; E' \\<subseteq> E \\<rbrakk> \\<Longrightarrow>\n     wf_graph \\<lparr> nodes = V, edges= E \\<union> E'\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E\\<rbrakk>\n    \\<Longrightarrow> wf_graph\n                       \\<lparr>nodes = V, edges = E \\<union> E'\\<rparr>", "by(auto simp add: wf_graph_def) (metis rev_finite_subset)"], ["", "(*Inspired by \nBenedikt Nordhoff and Peter Lammich\nDijkstra's Shortest Path Algorithm\nhttp://isa-afp.org/entries/Dijkstra_Shortest_Path.shtml*)\n(*more a literal copy of http://isa-afp.org/browser_info/current/AFP/Dijkstra_Shortest_Path/Graph.html*)"], ["", "text \\<open>Successors of a node.\\<close>"], ["", "definition succ :: \"'v graph \\<Rightarrow> 'v \\<Rightarrow> 'v set\"\n    where \"succ G v \\<equiv> {v'. (v,v')\\<in>edges G}\""], ["", "lemma succ_finite[simp, intro]: \"finite (edges G) \\<Longrightarrow> finite (succ G v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (edges G) \\<Longrightarrow> finite (succ G v)", "unfolding succ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (edges G) \\<Longrightarrow> finite {v'. (v, v') \\<in> edges G}", "by (rule finite_subset[where B=\"snd`edges G\"]) force+"], ["", "lemma succ_empty: \"succ empty v = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ FiniteGraph.empty v = {}", "unfolding empty_def succ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v'. (v, v') \\<in> edges \\<lparr>nodes = {}, edges = {}\\<rparr>} = {}", "by auto"], ["", "lemma (in wf_graph) succ_subset: \"succ G v \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ G v \\<subseteq> V", "unfolding succ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v'. (v, v') \\<in> E} \\<subseteq> V", "using E_wf"], ["proof (prove)\nusing this:\n  fst ` E \\<subseteq> V\n  snd ` E \\<subseteq> V\n\ngoal (1 subgoal):\n 1. {v'. (v, v') \\<in> E} \\<subseteq> V", "by (force)"], ["", "end"]]}