{"file_name": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification/Examples/Distributed_WebApp.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification", "problem_names": ["lemma \"wf_list_graph policy\"", "lemma \"all_security_requirements_fulfilled security_invariants policy\"", "lemma \"implc_get_offending_flows security_invariants policy = []\"", "lemma \"max_policy = \n   \\<lparr>nodesL = [''WebFrnt'', ''DB'', ''Log'', ''WebApp'', ''INET''],\n    edgesL = [(''WebFrnt'', ''WebFrnt''), (''WebFrnt'', ''Log''), (''WebFrnt'', ''WebApp''), (''WebFrnt'', ''INET''), (''DB'', ''DB''),\n              (''DB'', ''Log''), (''DB'', ''WebApp''), (''Log'', ''Log''), (''WebApp'', ''WebFrnt''), (''WebApp'', ''DB''),\n              (''WebApp'', ''Log''), (''WebApp'', ''WebApp''), (''WebApp'', ''INET''), (''INET'', ''WebFrnt''), (''INET'', ''INET'')]\\<rparr>\"", "lemma \"all_security_requirements_fulfilled security_invariants max_policy\"", "lemma \"all_security_requirements_fulfilled security_invariants my_policy\"", "lemma \"set (edgesL my_policy) \\<subset> set (edgesL max_policy)\"", "lemma \"all_security_requirements_fulfilled (get_IFS security_invariants) (stateful_list_policy_to_list_graph stateful_policy)\"", "lemma \"\\<forall> F \\<in> set (implc_get_offending_flows (get_ACS security_invariants) (stateful_list_policy_to_list_graph stateful_policy)).\n            set F \\<subseteq> set (backlinks (flows_stateL stateful_policy)) - (set (flows_fixL stateful_policy))\"", "lemma \"set (flows_stateL stateful_policy) \\<subseteq> set (flows_fixL stateful_policy)\"", "lemma \"wf_list_graph dockermynet4policy\""], "translations": [["", "lemma \"wf_list_graph policy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_list_graph policy", "by eval"], ["", "(*proof by eval means we have executable code to show the lemma. No need to show anything by hand*)"], ["", "text\\<open>Defining the security invariants\\<close>"], ["", "definition LogSink_m::\"(string SecurityInvariant)\" where\n  \"LogSink_m \\<equiv> new_configured_list_SecurityInvariant SINVAR_LIB_Sink \\<lparr> \n          node_properties = [''Log'' \\<mapsto> Sink]\n          \\<rparr> ''No information must leave the logging server''\""], ["", "text\\<open>\n0 - unclassified\n1 - confidential\n\\<close>\n\\<comment> \\<open>trusted: can access any security level, privacy-level 0: can reveal to anyone. I.e. can declassify\\<close>"], ["", "definition BLP_m::\"(string SecurityInvariant)\" where\n    \"BLP_m \\<equiv> new_configured_list_SecurityInvariant SINVAR_LIB_BLPtrusted \\<lparr> \n          node_properties = [''DB'' \\<mapsto> \\<lparr> security_level = 1, trusted = False \\<rparr>,\n                             ''Log'' \\<mapsto> \\<lparr> security_level = 1, trusted = False \\<rparr>,\n                             ''WebApp'' \\<mapsto> \\<lparr> security_level = 0, trusted = True \\<rparr> \n                             ]\n          \\<rparr> ''The database and the logging server have confidential information''\""], ["", "definition Subnet_m::\"(string SecurityInvariant)\" where\n    \"Subnet_m \\<equiv> new_configured_list_SecurityInvariant SINVAR_LIB_SubnetsInGW \\<lparr> \n          node_properties = [''DB'' \\<mapsto> Member,\n                             ''Log'' \\<mapsto> Member,\n                             ''WebApp'' \\<mapsto> Member,\n                             ''WebFrnt'' \\<mapsto> InboundGateway \\<comment> \\<open>DMZ\\<close>\n                             ]\n          \\<rparr> ''internal/DMZ structure''\""], ["", "definition DBACL_m::\"(string SecurityInvariant)\" where\n    \"DBACL_m \\<equiv> new_configured_list_SecurityInvariant SINVAR_LIB_CommunicationPartners \\<lparr> \n          node_properties = [''DB'' \\<mapsto> Master [''WebApp''],\n                             ''WebApp'' \\<mapsto> Care\n                             ]\n          \\<rparr> ''ACL of db''\""], ["", "text\\<open>The list of security invariants\\<close>"], ["", "definition \"security_invariants = [Subnet_m, BLP_m, LogSink_m, DBACL_m]\""], ["", "text\\<open>All security invariants are fulfilled (obviously, the policy permits no flows).\\<close>"], ["", "lemma \"all_security_requirements_fulfilled security_invariants policy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TopoS_Composition_Theory_impl.all_security_requirements_fulfilled\n     security_invariants policy", "by eval"], ["", "text\\<open>Obviously, no policy rules violate the security invariants.\\<close>"], ["", "lemma \"implc_get_offending_flows security_invariants policy = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implc_get_offending_flows security_invariants policy = []", "by eval"], ["", "text\\<open>We generate the maximum security policy.\\<close>"], ["", "definition \"max_policy = generate_valid_topology security_invariants \\<lparr>nodesL = nodesL policy, edgesL = List.product (nodesL policy) (nodesL policy) \\<rparr>\""], ["", "text\\<open>Calculating the maximum policy (executing it).\\<close>"], ["", "value \"max_policy\""], ["", "lemma \"max_policy = \n   \\<lparr>nodesL = [''WebFrnt'', ''DB'', ''Log'', ''WebApp'', ''INET''],\n    edgesL = [(''WebFrnt'', ''WebFrnt''), (''WebFrnt'', ''Log''), (''WebFrnt'', ''WebApp''), (''WebFrnt'', ''INET''), (''DB'', ''DB''),\n              (''DB'', ''Log''), (''DB'', ''WebApp''), (''Log'', ''Log''), (''WebApp'', ''WebFrnt''), (''WebApp'', ''DB''),\n              (''WebApp'', ''Log''), (''WebApp'', ''WebApp''), (''WebApp'', ''INET''), (''INET'', ''WebFrnt''), (''INET'', ''INET'')]\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_policy =\n    \\<lparr>nodesL = [''WebFrnt'', ''DB'', ''Log'', ''WebApp'', ''INET''],\n       edgesL =\n         [(''WebFrnt'', ''WebFrnt''), (''WebFrnt'', ''Log''),\n          (''WebFrnt'', ''WebApp''), (''WebFrnt'', ''INET''),\n          (''DB'', ''DB''), (''DB'', ''Log''), (''DB'', ''WebApp''),\n          (''Log'', ''Log''), (''WebApp'', ''WebFrnt''),\n          (''WebApp'', ''DB''), (''WebApp'', ''Log''),\n          (''WebApp'', ''WebApp''), (''WebApp'', ''INET''),\n          (''INET'', ''WebFrnt''), (''INET'', ''INET'')]\\<rparr>", "by eval"], ["", "(*proof by eval means it can be directly executed*)"], ["", "text\\<open>\nVisualizing the maximum policy\n\\<close>"], ["", "ML\\<open>\nvisualize_graph @{context} @{term \"security_invariants\"} @{term \"max_policy\"};\n\\<close>"], ["", "text\\<open>The maximum policy also fulfills all security invariants.\\<close>"], ["", "lemma \"all_security_requirements_fulfilled security_invariants max_policy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TopoS_Composition_Theory_impl.all_security_requirements_fulfilled\n     security_invariants max_policy", "by eval"], ["", "text\\<open>This holds in general: @{thm generate_valid_topology_sound}.\\<close>"], ["", "text\\<open>fine-tuning generated policy.\\<close>"], ["", "definition \"my_policy = \\<lparr>nodesL = [''WebFrnt'', ''DB'', ''Log'', ''WebApp'', ''INET''],\n    edgesL = [(''WebFrnt'', ''WebFrnt''), (''WebFrnt'', ''Log''), (''WebFrnt'', ''WebApp''), (''DB'', ''DB''), (''DB'', ''Log''),\n              (''DB'', ''WebApp''), (''Log'', ''Log''), (''WebApp'', ''WebFrnt''), (''WebApp'', ''DB''), (''WebApp'', ''Log''), (''WebApp'', ''WebApp''),\n              (''WebApp'', ''INET''), (''INET'', ''WebFrnt''), (''INET'', ''INET'')]\\<rparr>\""], ["", "lemma \"all_security_requirements_fulfilled security_invariants my_policy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TopoS_Composition_Theory_impl.all_security_requirements_fulfilled\n     security_invariants my_policy", "by eval"], ["", "lemma \"set (edgesL my_policy) \\<subset> set (edgesL max_policy)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (edgesL my_policy) \\<subset> set (edgesL max_policy)", "by eval"], ["", "text\\<open>\nThe diff to the maximum policy.\n\\<close>"], ["", "ML_val\\<open>\nvisualize_edges @{context} @{term \"edgesL my_policy\"} \n    [(\"edge [dir=\\\"arrow\\\", style=dashed, color=\\\"#3399FF\\\", constraint=false]\", @{term \"[e \\<leftarrow> edgesL max_policy. e \\<notin> set (edgesL my_policy)]\"})] \"\"; \n\\<close>"], ["", "section\\<open>A stateful implementation\\<close>"], ["", "definition \"stateful_policy = generate_valid_stateful_policy_IFSACS my_policy security_invariants\""], ["", "value \"stateful_policy\""], ["", "text\\<open>the stateful compliance criteria\\<close>"], ["", "text\\<open>No information flow violations\\<close>"], ["", "lemma \"all_security_requirements_fulfilled (get_IFS security_invariants) (stateful_list_policy_to_list_graph stateful_policy)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TopoS_Composition_Theory_impl.all_security_requirements_fulfilled\n     (TopoS_Composition_Theory_impl.get_IFS security_invariants)\n     (stateful_list_policy_to_list_graph stateful_policy)", "by eval"], ["", "text\\<open>No access control side effects\\<close>"], ["", "lemma \"\\<forall> F \\<in> set (implc_get_offending_flows (get_ACS security_invariants) (stateful_list_policy_to_list_graph stateful_policy)).\n            set F \\<subseteq> set (backlinks (flows_stateL stateful_policy)) - (set (flows_fixL stateful_policy))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>set (implc_get_offending_flows\n                         (TopoS_Composition_Theory_impl.get_ACS\n                           security_invariants)\n                         (stateful_list_policy_to_list_graph\n                           stateful_policy)).\n       set F\n       \\<subseteq> set (backlinks (flows_stateL stateful_policy)) -\n                   set (flows_fixL stateful_policy)", "by eval"], ["", "text\\<open>In general, the calculated stateful policy complies with the security policy: @{thm generate_valid_stateful_policy_IFSACS_stateful_policy_compliance}\\<close>"], ["", "text\\<open>Visualizing the stateful policy.\\<close>"], ["", "ML_val\\<open>\nvisualize_edges @{context} @{term \"flows_fixL stateful_policy\"} \n    [(\"edge [dir=\\\"arrow\\\", style=dashed, color=\\\"#FF8822\\\", constraint=false]\", @{term \"flows_stateL stateful_policy\"})] \"\"; \n\\<close>"], ["", "subsection\\<open>Exporting to Network Security Mechanism Configurations\\<close>"], ["", "text\\<open>Space-separated policy dump\\<close>"], ["", "ML_val\\<open>\niterate_edges_ML @{context} @{term \"flows_fixL stateful_policy\"}\n  (fn (v1,v2) => writeln (\"\"^v1^\" \"^v2) )\n  (fn _ => () )\n  (fn _ => () );\n\nwriteln \"# stateful answers\";\niterate_edges_ML @{context} @{term \"flows_stateL stateful_policy\"}\n  (fn (v1,v2) => writeln (v2^\" \"^v1) )\n  (fn _ => () )\n  (fn _ => () )\n\\<close>"], ["", "text\\<open>firewall -- classical use case\\<close>"], ["", "ML_val\\<open>\n\n(*header*)\nwriteln (\"echo 1 > /proc/sys/net/ipv4/ip_forward\"^\"\\n\"^\n         \"# flush all rules\"^\"\\n\"^\n         \"iptables -F\"^\"\\n\"^\n         \"#default policy for FORWARD chain:\"^\"\\n\"^\n         \"iptables -P FORWARD DROP\");\n\niterate_edges_ML @{context}  @{term \"flows_fixL stateful_policy\"}\n  (fn (v1,v2) => writeln (\"iptables -A FORWARD -i $\"^v1^\"_iface -s $\"^v1^\"_ipv4 -o $\"^v2^\"_iface -d $\"^v2^\"_ipv4 -j ACCEPT\"^\" # \"^v1^\" -> \"^v2) )\n  (fn _ => () )\n  (fn _ => () );\n\niterate_edges_ML @{context} @{term \"flows_stateL stateful_policy\"}\n  (fn (v1,v2) => writeln (\"iptables -I FORWARD -m state --state ESTABLISHED -i $\"^v2^\"_iface -s $\"^v2^\"_ipv4 -o $\"^v1^\"_iface -d $\"^v1^\"_ipv4 -j ACCEPT # \"^v2^\" -> \"^v1^\" (answer)\") )\n  (fn _ => () )\n  (fn _ => () )\n\\<close>"], ["", "text\\<open>firewall -- OpenVPN scenario\\<close>"], ["", "ML_val\\<open>\n\n(*header*)\nwriteln (\"echo 1 > /proc/sys/net/ipv4/ip_forward\"^\"\\n\"^\n         \"# flush all rules\"^\"\\n\"^\n         \"iptables -F\"^\"\\n\"^\n         \"#default policy for FORWARD chain:\"^\"\\n\"^\n         \"iptables -P FORWARD DROP\");\n\nfun iface (s: string): string =\n  if s = \"INET\" then \"eth0\" else \"tun0\";\n\niterate_edges_ML @{context} @{term \"[(s,r) \\<leftarrow> flows_fixL stateful_policy. s \\<noteq> r]\"}\n  (fn (v1,v2) => writeln (\"iptables -A FORWARD -i \"^iface v1^\" -s $\"^v1^\"_ipv4 -o \"^iface v2^\" -d $\"^v2^\"_ipv4 -j ACCEPT\") )\n  (fn _ => () )\n  (fn _ => () );\n\niterate_edges_ML @{context} @{term \"flows_stateL stateful_policy\"}\n  (fn (v1,v2) => writeln (\"iptables -I FORWARD -m state --state ESTABLISHED -i \"^iface v2^\" -s $\"^v2^\"_ipv4 -o \"^iface v1^\" -d $\"^v1^\"_ipv4 -j ACCEPT\") )\n  (fn _ => () )\n  (fn _ => () )\n\\<close>"], ["", "lemma \"set (flows_stateL stateful_policy) \\<subseteq> set (flows_fixL stateful_policy)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (flows_stateL stateful_policy)\n    \\<subseteq> set (flows_fixL stateful_policy)", "by eval"], ["", "definition stateful_flows :: \"(string \\<times> string) list\" where\n  \"stateful_flows \\<equiv> [(src, dst) \\<leftarrow> flows_stateL stateful_policy. src \\<noteq> dst]\""], ["", "value \"stateful_flows\""], ["", "definition stateless_flows :: \"(string \\<times> string) list\" where\n  \"stateless_flows \\<equiv> [(src, dst) \\<leftarrow> flows_fixL stateful_policy. src \\<noteq> dst \\<and> (src, dst) \\<notin> set stateful_flows]\""], ["", "value \"stateless_flows\""], ["", "text\\<open>OpenFlow Flow table Rules\\<close>"], ["", "ML_val\\<open>\nfun ARP (src: string) (dst: string): string =\n  \"# ARP Request\\n\"^\n  \"in_port=${port_\"^src^\"} dl_src=${mac_\"^src^\"} dl_dst=ff:ff:ff:ff:ff:ff arp arp_sha=${mac_\"^src^\"} \"^\n  \"arp_spa=${ip4_\"^src^\"} arp_tpa=${ip4_\"^dst^\"} priority=40000 action=mod_dl_dst:${mac_\"^dst^\"},output:${port_\"^dst^\"}\"^\"\\n\"^\n  \"# ARP Reply\\n\"^\n  \"dl_src=${mac_\"^dst^\"} dl_dst=${mac_\"^src^\"} arp arp_sha=${mac_\"^dst^\"} \"^\n  \"arp_spa=${ip4_\"^dst^\"} arp_tpa=${ip4_\"^src^\"} priority=40000 action=output:${port_\"^src^\"}\";\n\nlocal\n  fun IPv4_helper (priority: int) (nw_src_wildcard: bool) (nw_dst_wildcard: bool) (src: string) (dst: string): string =\n    let\n      val nw_src = (if nw_src_wildcard then \"*\" else \"${ip4_\"^src^\"}\");\n      val nw_dst = (if nw_dst_wildcard then \"*\" else \"${ip4_\"^dst^\"}\");\n    in\n      \"in_port=${port_\"^src^\"} dl_src=${mac_\"^src^\"} ip nw_src=\"^nw_src^\" \"^\n      \"nw_dst=\"^nw_dst^\" priority=\"^(Int.toString priority)^\" action=mod_dl_dst:${mac_\"^dst^\"},output:${port_\"^dst^\"}\"\n    end;\nin\n  fun IPv4 (src: string) (dst: string): string =\n    if dst = \"INET\" then\n      IPv4_helper 30000 false true src dst\n    else if src = \"INET\" then\n      IPv4_helper 30000 true false src dst\n    else\n      IPv4_helper 40000 false false src dst\n      ;\nend;\n\niterate_edges_ML @{context} @{term \"stateful_flows\"}\n  (fn (v1,v2) => writeln ((ARP v1 v2) ^ \"\\n\" ^ (ARP v2 v1) ^ \"\\n\" ^ (IPv4 v1 v2) ^ \"\\n\" ^ (IPv4 v2 v1) ^\"\\n\"))\n  (fn _ => () )\n  (fn _ => () );\n\niterate_edges_ML @{context} @{term \"stateless_flows\"}\n  (fn (v1,v2) =>  writeln ((ARP v1 v2) ^ \"\\n\" ^ (IPv4 v1 v2) ^ \"\\n\"))\n  (fn _ => () )\n  (fn _ => () )\n\\<close>"], ["", "text\\<open>Finally, all the functions demonstrated here can be exported to several programming languages\n     to obtain a stand-alone tool.\\<close>"], ["", "export_code\n  security_invariants\n  policy\n  all_security_requirements_fulfilled\n  implc_get_offending_flows\n  max_policy\n  my_policy\n  generate_valid_stateful_policy_IFSACS\n  stateful_policy\n  stateful_flows\n  stateless_flows\nin Scala"], ["", "(*dockermynet4*)"], ["", "definition dockermynet4policy :: \"string list_graph\" where\n    \"dockermynet4policy \\<equiv> \\<lparr> nodesL = [''WebFrnt'', ''DB'', ''Log'', ''WebApp'', ''INET''],\n                edgesL = [(''INET'',''INET''),\n                          (''INET'',''WebFrnt''),\n                          (''WebApp'',''INET''),\n                          (''WebApp'',''WebApp''),\n                          (''WebApp'',''DB''),\n                          (''WebApp'',''Log''),\n                          (''WebApp'',''WebFrnt''),\n                          (''DB'',''WebApp''),\n                          (''DB'',''DB''),\n                          (''DB'',''Log''),\n                          (''Log'',''Log''),\n                          (''Log'',''WebFrnt''),\n                          (''WebFrnt'',''WebApp''),\n                          (''WebFrnt'',''Log''),\n                          (''WebFrnt'',''WebFrnt'')] \\<rparr>\""], ["", "lemma \"wf_list_graph dockermynet4policy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_list_graph dockermynet4policy", "by eval"], ["", "ML\\<open>\nvisualize_graph @{context} @{term \"security_invariants\"} @{term \"dockermynet4policy\"};\n\\<close>"], ["", "ML_val\\<open>\nwriteln (\"*filter\"^\"\\n\"^\n         \":INPUT ACCEPT [0:0]\"^\"\\n\"^\n         \":FORWARD DROP [0:0]\"^\"\\n\"^\n         \":OUTPUT ACCEPT [0:0]\"^\"\\n\");\n\nfun mkiface s = if s = \"INET\" then \"INET_iface\" else \"br-b74b417b331f\";\n\niterate_edges_ML @{context}  @{term \"flows_fixL (generate_valid_stateful_policy_IFSACS max_policy security_invariants)\"}\n  (fn (v1,v2) => writeln (\"-A FORWARD -i \"^mkiface v1^\" -s $\"^v1^\"_ipv4 -o \"^mkiface v2^\" -d $\"^v2^\"_ipv4 -j ACCEPT\") )\n  (fn _ => () )\n  (fn _ => () );\n\niterate_edges_ML @{context} @{term \"flows_stateL (generate_valid_stateful_policy_IFSACS max_policy security_invariants)\"}\n  (fn (v1,v2) => writeln (\"-I FORWARD -m state --state ESTABLISHED -i \"^mkiface v2^\" -s $\"^v2^\"_ipv4 -o \"^mkiface v1^\" -d $\"^v1^\"_ipv4 -j ACCEPT\") )\n  (fn _ => () )\n  (fn _ => () );\n\nwriteln (\"COMMIT\"^\"\\n\");\n\\<close>"], ["", "ML_val\\<open>\nvisualize_edges @{context} @{term \"flows_fixL (generate_valid_stateful_policy_IFSACS max_policy security_invariants)\"} \n    [(\"edge [dir=\\\"arrow\\\", style=dashed, color=\\\"#FF8822\\\", constraint=false]\", @{term \"flows_stateL (generate_valid_stateful_policy_IFSACS max_policy security_invariants)\"})] \"\"; \n\\<close>"], ["", "(*dfwfw (docker firewall) rules: https://github.com/irsl/dfwfw*)"], ["", "ML_val\\<open>\nwriteln (\"{\"^\"\\n\"^\n         \"\\\"container_to_container\\\": {\"^\"\\n\"^\n         \"\\\"rules\\\": [\"^\"\\n\"^\n         \"\\n\");\n\nfun mkdfwfwrule filter v1 v2 = \"{\"^\"\\n\"^\n             \"  \\\"network\\\": \\\"mynet\\\",\"^\"\\n\"^\n             \"  \\\"src_container\\\": \\\"Name =~ ^\"^ String.map Char.toLower v1 ^\"-?\\\\\\\\d*$\\\",\"^\"\\n\"^\n             \"  \\\"dst_container\\\": \\\"Name =~ ^\"^ String.map Char.toLower v2 ^\"-?\\\\\\\\d*$\\\",\"^\"\\n\"^\n             \"  \\\"filter\\\": \\\"\"^filter^\"\\\",\"^\"\\n\"^\n             \"  \\\"action\\\": \\\"ACCEPT\\\"\"^\"\\n\"^\n          \"},\";\n\niterate_edges_ML @{context}  @{term \"flows_fixL (generate_valid_stateful_policy_IFSACS max_policy security_invariants)\"}\n  (fn (v1,v2) => writeln (mkdfwfwrule \"\" v1 v2) )\n  (fn _ => () )\n  (fn _ => () );\n\niterate_edges_ML @{context} @{term \"flows_stateL (generate_valid_stateful_policy_IFSACS max_policy security_invariants)\"}\n  (fn (v1,v2) => writeln (mkdfwfwrule \"-m state --state ESTABLISHED\" v2 v1))\n  (fn _ => () )\n  (fn _ => () );\n\nwriteln (\"]}}\"^\"\\n\");\n\\<close>"], ["", "end"]]}