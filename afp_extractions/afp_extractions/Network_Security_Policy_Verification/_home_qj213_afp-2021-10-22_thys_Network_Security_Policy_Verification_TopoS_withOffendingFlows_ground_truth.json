{"file_name": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification/TopoS_withOffendingFlows.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification", "problem_names": ["lemma sinvar_mono_I_proofrule_simple: \n  \"\\<lbrakk> (\\<forall> G nP. sinvar G nP = (\\<forall> (e1, e2) \\<in> edges G. P e1 e2 nP) ) \\<rbrakk> \\<Longrightarrow> sinvar_mono\"", "lemma sinvar_mono_I_proofrule:\n  \"\\<lbrakk> (\\<forall> nP (G:: 'v graph). sinvar G nP = (\\<forall> (e1, e2) \\<in> edges G. P e1 e2 nP G) ); \n    (\\<forall> nP e1 e2 N E' E. \n      wf_graph \\<lparr> nodes = N, edges = E \\<rparr> \\<and> \n      (e1,e2) \\<in> E \\<and> \n      E' \\<subseteq> E \\<and> \n      P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr> \\<longrightarrow> P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>) \\<rbrakk> \\<Longrightarrow> sinvar_mono\"", "lemma sinvar_mono_imp_negative_mono:\n   \"sinvar_mono \\<Longrightarrow> wf_graph \\<lparr> nodes = N, edges = E \\<rparr> \\<Longrightarrow>  E' \\<subseteq> E \\<Longrightarrow>\n   \\<not> sinvar \\<lparr> nodes = N, edges = E' \\<rparr> nP \\<Longrightarrow> \\<not> sinvar \\<lparr> nodes = N, edges = E \\<rparr> nP\"", "lemma sinvar_mono_imp_is_offending_flows_mono:\n  assumes mono: \"sinvar_mono\"\n  and wfG: \"wf_graph G\"\n  shows \"is_offending_flows FF G nP  \\<Longrightarrow> is_offending_flows (FF \\<union> F) G nP\"", "lemma sinvar_mono_imp_sinvar_mono: \n  \"sinvar_mono \\<Longrightarrow> wf_graph \\<lparr> nodes = N, edges = E \\<rparr> \\<Longrightarrow> E' \\<subseteq> E \\<Longrightarrow> sinvar \\<lparr> nodes = N, edges = E \\<rparr> nP \\<Longrightarrow> \n        sinvar \\<lparr> nodes = N, edges = E' \\<rparr> nP\"", "lemma minimalize_offending_overapprox_subset:\n  \"set (minimalize_offending_overapprox ff keeps G nP) \\<subseteq> set ff \\<union> set keeps\"", "lemma not_model_mono_imp_addedge_mono: \n  assumes mono: \"sinvar_mono\"\n   and vG: \"wf_graph G\" and ain: \"(a1,a2) \\<in> edges G\" and xy: \"X \\<subseteq> Y\" and ns: \"\\<not> sinvar (add_edge a1 a2 (delete_edges G (Y))) nP\"  \n  shows \"\\<not> sinvar (add_edge a1 a2 (delete_edges G X)) nP\"", "theorem is_offending_flows_min_set_minimalize_offending_overapprox:\n      assumes mono: \"sinvar_mono\"\n      and vG: \"wf_graph G\" and iO: \"is_offending_flows (set ff) G nP\" and sF: \"set ff \\<subseteq> edges G\" and dF: \"distinct ff\"\n      shows \"is_offending_flows_min_set (set (minimalize_offending_overapprox ff [] G nP)) G nP\"\n              (is \"is_offending_flows_min_set ?minset G nP\")", "theorem valid_empty_edges_iff_exists_offending_flows: \n    assumes mono: \"sinvar_mono\" and wfG: \"wf_graph G\" and noteval: \"\\<not> sinvar G nP\"\n    shows \"sinvar \\<lparr> nodes = nodes G, edges = {} \\<rparr> nP \\<longleftrightarrow> set_offending_flows G nP \\<noteq> {}\"", "lemma minimalize_offending_overapprox_keeps_keeps: \"(set keeps) \\<subseteq> set (minimalize_offending_overapprox ff keeps G nP)\"", "lemma minimalize_offending_overapprox_subseteq_input: \"set (minimalize_offending_overapprox ff keeps G nP) \\<subseteq> (set ff) \\<union> (set keeps)\"", "lemma sinvar_monoI: \"sinvar_mono\"", "lemma assumes \"wf_graph G\" and \"is_offending_flows_min_set F G nP\" and \"F \\<subseteq> edges G\" and \"E \\<subseteq> F\" and \"E \\<noteq> {}\"\n          shows \"\\<not> sinvar \\<lparr> nodes = nodes G, edges = ((edges G) - F) \\<union> E \\<rparr> nP\"", "lemma minimalize_offending_overapprox_sound: \n      \"\\<lbrakk> wf_graph G; is_offending_flows (set ff) G nP; set ff \\<subseteq> edges G; distinct ff \\<rbrakk>\n        \\<Longrightarrow> is_offending_flows_min_set (set (minimalize_offending_overapprox ff [] G nP)) G nP \"", "theorem minimalize_offending_overapprox_gives_back_an_offending_flow:\n      \"\\<lbrakk> wf_graph G; is_offending_flows (set ff) G nP; set ff \\<subseteq> edges G; distinct ff \\<rbrakk>\n        \\<Longrightarrow>\n         (set (minimalize_offending_overapprox ff [] G nP)) \\<in> set_offending_flows G nP\"", "lemma minimalize_offending_overapprox_boundnP:\nshows \"minimalize_offending_overapprox (\\<lambda>G. m G nP) fs keeps G =\n         SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox m fs keeps G nP\"", "lemma mono_imp_emptyoffending_eq_nevervalid:\n       \"\\<lbrakk> sinvar_mono; wf_graph G; \\<not> sinvar G nP; set_offending_flows G nP = {}\\<rbrakk> \\<Longrightarrow> \n        \\<not> (\\<exists> F \\<subseteq> edges G. sinvar (delete_edges G F) nP)\"", "lemma minimality_offending_flows_mono_edges_graph_extend:\n    \"\\<lbrakk> wf_graph \\<lparr> nodes = V, edges = E \\<rparr>; E' \\<subseteq> E; Fadd \\<inter> E' = {}; F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr> nP \\<rbrakk> \\<Longrightarrow> \n            (\\<forall>(e1, e2)\\<in>F'. \\<not> sinvar (add_edge e1 e2 (delete_edges \\<lparr>nodes = V, edges = E \\<rparr> (F' \\<union> Fadd))) nP)\"", "theorem mono_extend_set_offending_flows: \"\\<lbrakk> wf_graph \\<lparr> nodes = V, edges = E \\<rparr>; E' \\<subseteq> E; F' \\<in> set_offending_flows \\<lparr> nodes = V, edges = E' \\<rparr> nP \\<rbrakk> \\<Longrightarrow>\n        \\<exists> F \\<in> set_offending_flows \\<lparr> nodes = V, edges = E \\<rparr> nP. F' \\<subseteq> F\"", "lemma set_offending_flows_insert_contains_new:\n   \"\\<lbrakk> wf_graph \\<lparr> nodes = V, edges = insert e E \\<rparr>; set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP = {}; set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr> nP \\<noteq> {} \\<rbrakk> \\<Longrightarrow> \n      {e} \\<in> set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr> nP\"", "lemma pow_combine_mono: \n    fixes S :: \"'a set set\"\n    and   X :: \"'a set\"\n    and   Y :: \"'a set\"\n    assumes a1: \"\\<forall> F \\<in> S. F \\<subseteq> X\"\n    shows \"\\<forall> F \\<in> pow_combine Y S. F \\<subseteq> Y \\<union> X\"", "lemma \"S \\<subseteq> pow_combine X S\"", "lemma \"Pow X \\<subseteq> pow_combine X S\"", "lemma rule_pow_combine_fixfst: \"B \\<subseteq> C \\<Longrightarrow> pow_combine A B \\<subseteq> pow_combine A C\"", "lemma rule_pow_combine_fixfst_Union: \"\\<Union> B \\<subseteq> \\<Union> C \\<Longrightarrow> \\<Union> (pow_combine A B) \\<subseteq> \\<Union> (pow_combine A C)\"", "lemma offending_partition_subset_empty: \n    assumes a1:\"\\<forall> F \\<in> (set_offending_flows \\<lparr>nodes = V, edges = E \\<union> X\\<rparr> nP). F \\<subseteq> X\"\n    and wfGEX: \"wf_graph \\<lparr>nodes = V, edges = E \\<union> X\\<rparr>\"\n    and disj: \"E \\<inter> X = {}\"\n    shows \"(set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP) = {}\"", "lemma Un_set_offending_flows_bound_minus:\n    assumes wfG: \"wf_graph \\<lparr> nodes = V, edges = E \\<rparr>\"\n    and     Foffending: \"\\<Union>(set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP) \\<subseteq> X\"\n    shows   \"\\<Union>(set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP) \\<subseteq> X - {f}\"", "lemma Un_set_offending_flows_bound_minus_subseteq:\n    assumes wfG: \"wf_graph \\<lparr> nodes = V, edges = E \\<rparr>\"\n    and     Foffending: \"\\<Union> (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP) \\<subseteq> X\"\n    shows   \"\\<Union> (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP) \\<subseteq> X - E'\""], "translations": [["", "lemma sinvar_mono_I_proofrule_simple: \n  \"\\<lbrakk> (\\<forall> G nP. sinvar G nP = (\\<forall> (e1, e2) \\<in> edges G. P e1 e2 nP) ) \\<rbrakk> \\<Longrightarrow> sinvar_mono\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>G nP.\n       sinvar G nP =\n       (\\<forall>(e1, e2)\\<in>edges G. P e1 e2 nP) \\<Longrightarrow>\n    sinvar_mono", "apply(simp add: sinvar_mono_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>G nP.\n       sinvar G nP =\n       (\\<forall>x\\<in>edges G.\n           case x of (e1, e2) \\<Rightarrow> P e1 e2 nP) \\<Longrightarrow>\n    \\<forall>nP N E'.\n       (\\<exists>E.\n           wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n           E' \\<subseteq> E \\<and>\n           (\\<forall>x\\<in>E.\n               case x of\n               (e1, e2) \\<Rightarrow> P e1 e2 nP)) \\<longrightarrow>\n       (\\<forall>x\\<in>E'. case x of (e1, e2) \\<Rightarrow> P e1 e2 nP)", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nP N E' a b E.\n       \\<lbrakk>\\<forall>G nP.\n                   sinvar G nP =\n                   (\\<forall>(e1, e2)\\<in>edges G. P e1 e2 nP);\n        (a, b) \\<in> E'; wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E; \\<forall>(e1, e2)\\<in>E. P e1 e2 nP\\<rbrakk>\n       \\<Longrightarrow> P a b nP", "apply(fast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sinvar_mono_I_proofrule:\n  \"\\<lbrakk> (\\<forall> nP (G:: 'v graph). sinvar G nP = (\\<forall> (e1, e2) \\<in> edges G. P e1 e2 nP G) ); \n    (\\<forall> nP e1 e2 N E' E. \n      wf_graph \\<lparr> nodes = N, edges = E \\<rparr> \\<and> \n      (e1,e2) \\<in> E \\<and> \n      E' \\<subseteq> E \\<and> \n      P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr> \\<longrightarrow> P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>) \\<rbrakk> \\<Longrightarrow> sinvar_mono\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>nP G.\n                sinvar G nP = (\\<forall>(e1, e2)\\<in>edges G. P e1 e2 nP G);\n     \\<forall>nP e1 e2 N E' E.\n        wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n        (e1, e2) \\<in> E \\<and>\n        E' \\<subseteq> E \\<and>\n        P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr> \\<longrightarrow>\n        P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> sinvar_mono", "unfolding sinvar_mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>nP G.\n                sinvar G nP = (\\<forall>(e1, e2)\\<in>edges G. P e1 e2 nP G);\n     \\<forall>nP e1 e2 N E' E.\n        wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n        (e1, e2) \\<in> E \\<and>\n        E' \\<subseteq> E \\<and>\n        P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr> \\<longrightarrow>\n        P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>nP N E' E.\n                         wf_graph\n                          \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n                         E' \\<subseteq> E \\<and>\n                         sinvar \\<lparr>nodes = N, edges = E\\<rparr>\n                          nP \\<longrightarrow>\n                         sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nP N E' E.\n       \\<lbrakk>\\<forall>nP G.\n                   sinvar G nP =\n                   (\\<forall>(e1, e2)\\<in>edges G. P e1 e2 nP G);\n        \\<forall>nP e1 e2 N E' E.\n           wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n           (e1, e2) \\<in> E \\<and>\n           E' \\<subseteq> E \\<and>\n           P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr> \\<longrightarrow>\n           P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>;\n        wf_graph \\<lparr>nodes = N, edges = E\\<rparr>; E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP", "fix nP N E' E"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nP N E' E.\n       \\<lbrakk>\\<forall>nP G.\n                   sinvar G nP =\n                   (\\<forall>(e1, e2)\\<in>edges G. P e1 e2 nP G);\n        \\<forall>nP e1 e2 N E' E.\n           wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n           (e1, e2) \\<in> E \\<and>\n           E' \\<subseteq> E \\<and>\n           P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr> \\<longrightarrow>\n           P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>;\n        wf_graph \\<lparr>nodes = N, edges = E\\<rparr>; E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP", "assume AllForm: \"(\\<forall> nP (G:: 'v graph). sinvar G nP = (\\<forall> (e1, e2) \\<in> edges G. P e1 e2 nP G) )\"\n    and Pmono: \"\\<forall>nP e1 e2 N E' E. wf_graph \\<lparr> nodes = N, edges = E \\<rparr> \\<and> (e1,e2) \\<in> E \\<and> E' \\<subseteq> E \\<and> P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr> \\<longrightarrow> P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>\"\n    and wfG: \"wf_graph \\<lparr>nodes = N, edges = E\\<rparr>\"\n    and E'subset: \"E' \\<subseteq> E\"\n    and evalE: \"sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\""], ["proof (state)\nthis:\n  \\<forall>nP G. sinvar G nP = (\\<forall>(e1, e2)\\<in>edges G. P e1 e2 nP G)\n  \\<forall>nP e1 e2 N E' E.\n     wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n     (e1, e2) \\<in> E \\<and>\n     E' \\<subseteq> E \\<and>\n     P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr> \\<longrightarrow>\n     P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>\n  wf_graph \\<lparr>nodes = N, edges = E\\<rparr>\n  E' \\<subseteq> E\n  sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\n\ngoal (1 subgoal):\n 1. \\<And>nP N E' E.\n       \\<lbrakk>\\<forall>nP G.\n                   sinvar G nP =\n                   (\\<forall>(e1, e2)\\<in>edges G. P e1 e2 nP G);\n        \\<forall>nP e1 e2 N E' E.\n           wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n           (e1, e2) \\<in> E \\<and>\n           E' \\<subseteq> E \\<and>\n           P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr> \\<longrightarrow>\n           P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>;\n        wf_graph \\<lparr>nodes = N, edges = E\\<rparr>; E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP", "from Pmono"], ["proof (chain)\npicking this:\n  \\<forall>nP e1 e2 N E' E.\n     wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n     (e1, e2) \\<in> E \\<and>\n     E' \\<subseteq> E \\<and>\n     P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr> \\<longrightarrow>\n     P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>", "have Pmono1: \n      \"\\<And>nP N E' E. wf_graph \\<lparr> nodes = N, edges = E \\<rparr> \\<Longrightarrow> E' \\<subseteq> E \\<Longrightarrow> (\\<forall>(e1,e2) \\<in> E. P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr> \\<longrightarrow> P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>)\""], ["proof (prove)\nusing this:\n  \\<forall>nP e1 e2 N E' E.\n     wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n     (e1, e2) \\<in> E \\<and>\n     E' \\<subseteq> E \\<and>\n     P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr> \\<longrightarrow>\n     P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>nP N E' E.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(e1, e2)\\<in>E.\n                            P e1 e2 nP\n                             \\<lparr>nodes = N,\n                                edges = E\\<rparr> \\<longrightarrow>\n                            P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>wf_graph \\<lparr>nodes = ?N, edges = ?E\\<rparr>;\n   ?E' \\<subseteq> ?E\\<rbrakk>\n  \\<Longrightarrow> \\<forall>(e1, e2)\\<in>?E.\n                       P e1 e2 ?nP\n                        \\<lparr>nodes = ?N,\n                           edges = ?E\\<rparr> \\<longrightarrow>\n                       P e1 e2 ?nP \\<lparr>nodes = ?N, edges = ?E'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>nP N E' E.\n       \\<lbrakk>\\<forall>nP G.\n                   sinvar G nP =\n                   (\\<forall>(e1, e2)\\<in>edges G. P e1 e2 nP G);\n        \\<forall>nP e1 e2 N E' E.\n           wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n           (e1, e2) \\<in> E \\<and>\n           E' \\<subseteq> E \\<and>\n           P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr> \\<longrightarrow>\n           P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>;\n        wf_graph \\<lparr>nodes = N, edges = E\\<rparr>; E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP", "from AllForm"], ["proof (chain)\npicking this:\n  \\<forall>nP G. sinvar G nP = (\\<forall>(e1, e2)\\<in>edges G. P e1 e2 nP G)", "have \"sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP = (\\<forall> (e1, e2) \\<in> E. P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr>)\""], ["proof (prove)\nusing this:\n  \\<forall>nP G. sinvar G nP = (\\<forall>(e1, e2)\\<in>edges G. P e1 e2 nP G)\n\ngoal (1 subgoal):\n 1. sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP =\n    (\\<forall>(e1, e2)\\<in>E.\n        P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr>)", "by force"], ["proof (state)\nthis:\n  sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP =\n  (\\<forall>(e1, e2)\\<in>E. P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>nP N E' E.\n       \\<lbrakk>\\<forall>nP G.\n                   sinvar G nP =\n                   (\\<forall>(e1, e2)\\<in>edges G. P e1 e2 nP G);\n        \\<forall>nP e1 e2 N E' E.\n           wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n           (e1, e2) \\<in> E \\<and>\n           E' \\<subseteq> E \\<and>\n           P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr> \\<longrightarrow>\n           P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>;\n        wf_graph \\<lparr>nodes = N, edges = E\\<rparr>; E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP", "from this evalE"], ["proof (chain)\npicking this:\n  sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP =\n  (\\<forall>(e1, e2)\\<in>E. P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr>)\n  sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP", "have \"(\\<forall> (e1, e2) \\<in> E. P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr>)\""], ["proof (prove)\nusing this:\n  sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP =\n  (\\<forall>(e1, e2)\\<in>E. P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr>)\n  sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\n\ngoal (1 subgoal):\n 1. \\<forall>(e1, e2)\\<in>E. P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr>", "by simp"], ["proof (state)\nthis:\n  \\<forall>(e1, e2)\\<in>E. P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>nP N E' E.\n       \\<lbrakk>\\<forall>nP G.\n                   sinvar G nP =\n                   (\\<forall>(e1, e2)\\<in>edges G. P e1 e2 nP G);\n        \\<forall>nP e1 e2 N E' E.\n           wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n           (e1, e2) \\<in> E \\<and>\n           E' \\<subseteq> E \\<and>\n           P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr> \\<longrightarrow>\n           P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>;\n        wf_graph \\<lparr>nodes = N, edges = E\\<rparr>; E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP", "from Pmono1[OF wfG E'subset, of \"nP\"] this"], ["proof (chain)\npicking this:\n  \\<forall>(e1, e2)\\<in>E.\n     P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr> \\<longrightarrow>\n     P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>\n  \\<forall>(e1, e2)\\<in>E. P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr>", "have \"\\<forall>(e1, e2) \\<in> E. P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>\""], ["proof (prove)\nusing this:\n  \\<forall>(e1, e2)\\<in>E.\n     P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr> \\<longrightarrow>\n     P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>\n  \\<forall>(e1, e2)\\<in>E. P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<forall>(e1, e2)\\<in>E.\n       P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>", "by fast"], ["proof (state)\nthis:\n  \\<forall>(e1, e2)\\<in>E. P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>nP N E' E.\n       \\<lbrakk>\\<forall>nP G.\n                   sinvar G nP =\n                   (\\<forall>(e1, e2)\\<in>edges G. P e1 e2 nP G);\n        \\<forall>nP e1 e2 N E' E.\n           wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n           (e1, e2) \\<in> E \\<and>\n           E' \\<subseteq> E \\<and>\n           P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr> \\<longrightarrow>\n           P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>;\n        wf_graph \\<lparr>nodes = N, edges = E\\<rparr>; E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP", "from this E'subset"], ["proof (chain)\npicking this:\n  \\<forall>(e1, e2)\\<in>E. P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>\n  E' \\<subseteq> E", "have \"\\<forall>(e1, e2) \\<in> E'. P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>\""], ["proof (prove)\nusing this:\n  \\<forall>(e1, e2)\\<in>E. P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>\n  E' \\<subseteq> E\n\ngoal (1 subgoal):\n 1. \\<forall>(e1, e2)\\<in>E'.\n       P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>", "by fast"], ["proof (state)\nthis:\n  \\<forall>(e1, e2)\\<in>E'. P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>nP N E' E.\n       \\<lbrakk>\\<forall>nP G.\n                   sinvar G nP =\n                   (\\<forall>(e1, e2)\\<in>edges G. P e1 e2 nP G);\n        \\<forall>nP e1 e2 N E' E.\n           wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n           (e1, e2) \\<in> E \\<and>\n           E' \\<subseteq> E \\<and>\n           P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr> \\<longrightarrow>\n           P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>;\n        wf_graph \\<lparr>nodes = N, edges = E\\<rparr>; E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP", "from this"], ["proof (chain)\npicking this:\n  \\<forall>(e1, e2)\\<in>E'. P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>", "have \"\\<forall>(e1, e2) \\<in> (edges \\<lparr>nodes = N, edges = E'\\<rparr>). P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>\""], ["proof (prove)\nusing this:\n  \\<forall>(e1, e2)\\<in>E'. P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<forall>(e1, e2)\\<in>edges \\<lparr>nodes = N, edges = E'\\<rparr>.\n       P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>", "by simp"], ["proof (state)\nthis:\n  \\<forall>(e1, e2)\\<in>edges \\<lparr>nodes = N, edges = E'\\<rparr>.\n     P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>nP N E' E.\n       \\<lbrakk>\\<forall>nP G.\n                   sinvar G nP =\n                   (\\<forall>(e1, e2)\\<in>edges G. P e1 e2 nP G);\n        \\<forall>nP e1 e2 N E' E.\n           wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n           (e1, e2) \\<in> E \\<and>\n           E' \\<subseteq> E \\<and>\n           P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr> \\<longrightarrow>\n           P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>;\n        wf_graph \\<lparr>nodes = N, edges = E\\<rparr>; E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP", "from this AllForm"], ["proof (chain)\npicking this:\n  \\<forall>(e1, e2)\\<in>edges \\<lparr>nodes = N, edges = E'\\<rparr>.\n     P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>\n  \\<forall>nP G. sinvar G nP = (\\<forall>(e1, e2)\\<in>edges G. P e1 e2 nP G)", "show \"sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\""], ["proof (prove)\nusing this:\n  \\<forall>(e1, e2)\\<in>edges \\<lparr>nodes = N, edges = E'\\<rparr>.\n     P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>\n  \\<forall>nP G. sinvar G nP = (\\<forall>(e1, e2)\\<in>edges G. P e1 e2 nP G)\n\ngoal (1 subgoal):\n 1. sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP", "by presburger"], ["proof (state)\nthis:\n  sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Invariant violations do not disappear if we add more flows.\\<close>"], ["", "lemma sinvar_mono_imp_negative_mono:\n   \"sinvar_mono \\<Longrightarrow> wf_graph \\<lparr> nodes = N, edges = E \\<rparr> \\<Longrightarrow>  E' \\<subseteq> E \\<Longrightarrow>\n   \\<not> sinvar \\<lparr> nodes = N, edges = E' \\<rparr> nP \\<Longrightarrow> \\<not> sinvar \\<lparr> nodes = N, edges = E \\<rparr> nP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sinvar_mono; wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     \\<not> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\\<rbrakk>\n    \\<Longrightarrow> \\<not> sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP", "unfolding sinvar_mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>nP N E' E.\n                wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n                E' \\<subseteq> E \\<and>\n                sinvar \\<lparr>nodes = N, edges = E\\<rparr>\n                 nP \\<longrightarrow>\n                sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP;\n     wf_graph \\<lparr>nodes = N, edges = E\\<rparr>; E' \\<subseteq> E;\n     \\<not> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\\<rbrakk>\n    \\<Longrightarrow> \\<not> sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP", "by(blast)"], ["", "corollary sinvar_mono_imp_negative_delete_edge_mono:\n   \"sinvar_mono \\<Longrightarrow> wf_graph G \\<Longrightarrow> X \\<subseteq> Y \\<Longrightarrow> \\<not> sinvar (delete_edges G Y) nP \\<Longrightarrow> \\<not> sinvar (delete_edges G X) nP \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sinvar_mono; wf_graph G; X \\<subseteq> Y;\n     \\<not> sinvar (delete_edges G Y) nP\\<rbrakk>\n    \\<Longrightarrow> \\<not> sinvar (delete_edges G X) nP", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sinvar_mono; wf_graph G; X \\<subseteq> Y;\n     \\<not> sinvar (delete_edges G Y) nP\\<rbrakk>\n    \\<Longrightarrow> \\<not> sinvar (delete_edges G X) nP", "assume sinvar_mono\n   and \"wf_graph G\" and \"X \\<subseteq> Y\" and \"\\<not> sinvar (delete_edges G Y) nP\""], ["proof (state)\nthis:\n  sinvar_mono\n  wf_graph G\n  X \\<subseteq> Y\n  \\<not> sinvar (delete_edges G Y) nP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sinvar_mono; wf_graph G; X \\<subseteq> Y;\n     \\<not> sinvar (delete_edges G Y) nP\\<rbrakk>\n    \\<Longrightarrow> \\<not> sinvar (delete_edges G X) nP", "from delete_edges_wf[OF \\<open>wf_graph G\\<close>]"], ["proof (chain)\npicking this:\n  wf_graph (delete_edges G ?E)", "have valid_G_delete: \"wf_graph \\<lparr>nodes = nodes G, edges = edges G - X\\<rparr>\""], ["proof (prove)\nusing this:\n  wf_graph (delete_edges G ?E)\n\ngoal (1 subgoal):\n 1. wf_graph \\<lparr>nodes = nodes G, edges = edges G - X\\<rparr>", "by(simp add: delete_edges_simp2)"], ["proof (state)\nthis:\n  wf_graph \\<lparr>nodes = nodes G, edges = edges G - X\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sinvar_mono; wf_graph G; X \\<subseteq> Y;\n     \\<not> sinvar (delete_edges G Y) nP\\<rbrakk>\n    \\<Longrightarrow> \\<not> sinvar (delete_edges G X) nP", "from \\<open>X \\<subseteq> Y\\<close>"], ["proof (chain)\npicking this:\n  X \\<subseteq> Y", "have \"edges G - Y \\<subseteq> edges G - X\""], ["proof (prove)\nusing this:\n  X \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. edges G - Y \\<subseteq> edges G - X", "by blast"], ["proof (state)\nthis:\n  edges G - Y \\<subseteq> edges G - X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sinvar_mono; wf_graph G; X \\<subseteq> Y;\n     \\<not> sinvar (delete_edges G Y) nP\\<rbrakk>\n    \\<Longrightarrow> \\<not> sinvar (delete_edges G X) nP", "with \\<open>sinvar_mono\\<close> sinvar_mono_def valid_G_delete"], ["proof (chain)\npicking this:\n  sinvar_mono\n  sinvar_mono =\n  (\\<forall>nP N E' E.\n      wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n      E' \\<subseteq> E \\<and>\n      sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP \\<longrightarrow>\n      sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP)\n  wf_graph \\<lparr>nodes = nodes G, edges = edges G - X\\<rparr>\n  edges G - Y \\<subseteq> edges G - X", "have\n    \"sinvar \\<lparr>nodes = nodes G, edges = edges G - X\\<rparr> nP \\<Longrightarrow> sinvar \\<lparr>nodes = nodes G, edges = edges G - Y\\<rparr> nP\""], ["proof (prove)\nusing this:\n  sinvar_mono\n  sinvar_mono =\n  (\\<forall>nP N E' E.\n      wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n      E' \\<subseteq> E \\<and>\n      sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP \\<longrightarrow>\n      sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP)\n  wf_graph \\<lparr>nodes = nodes G, edges = edges G - X\\<rparr>\n  edges G - Y \\<subseteq> edges G - X\n\ngoal (1 subgoal):\n 1. sinvar \\<lparr>nodes = nodes G, edges = edges G - X\\<rparr>\n     nP \\<Longrightarrow>\n    sinvar \\<lparr>nodes = nodes G, edges = edges G - Y\\<rparr> nP", "by blast"], ["proof (state)\nthis:\n  sinvar \\<lparr>nodes = nodes G, edges = edges G - X\\<rparr>\n   nP \\<Longrightarrow>\n  sinvar \\<lparr>nodes = nodes G, edges = edges G - Y\\<rparr> nP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sinvar_mono; wf_graph G; X \\<subseteq> Y;\n     \\<not> sinvar (delete_edges G Y) nP\\<rbrakk>\n    \\<Longrightarrow> \\<not> sinvar (delete_edges G X) nP", "hence \"sinvar (delete_edges G X) nP \\<Longrightarrow> sinvar (delete_edges G Y) nP\""], ["proof (prove)\nusing this:\n  sinvar \\<lparr>nodes = nodes G, edges = edges G - X\\<rparr>\n   nP \\<Longrightarrow>\n  sinvar \\<lparr>nodes = nodes G, edges = edges G - Y\\<rparr> nP\n\ngoal (1 subgoal):\n 1. sinvar (delete_edges G X) nP \\<Longrightarrow>\n    sinvar (delete_edges G Y) nP", "by(simp add: delete_edges_simp2)"], ["proof (state)\nthis:\n  sinvar (delete_edges G X) nP \\<Longrightarrow>\n  sinvar (delete_edges G Y) nP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sinvar_mono; wf_graph G; X \\<subseteq> Y;\n     \\<not> sinvar (delete_edges G Y) nP\\<rbrakk>\n    \\<Longrightarrow> \\<not> sinvar (delete_edges G X) nP", "with \\<open>\\<not> sinvar (delete_edges G Y) nP\\<close>"], ["proof (chain)\npicking this:\n  \\<not> sinvar (delete_edges G Y) nP\n  sinvar (delete_edges G X) nP \\<Longrightarrow>\n  sinvar (delete_edges G Y) nP", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> sinvar (delete_edges G Y) nP\n  sinvar (delete_edges G X) nP \\<Longrightarrow>\n  sinvar (delete_edges G Y) nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges G X) nP", "by blast"], ["proof (state)\nthis:\n  \\<not> sinvar (delete_edges G X) nP\n\ngoal:\nNo subgoals!", "qed"], ["", "(*lemma mono_offending_flows_min_set:\n  assumes mono_isoffending: \"(\\<forall> ff f' G nP. is_offending_flows ff G nP \\<longrightarrow> is_offending_flows (f' \\<union> ff) G nP)\"\n  and offending: \"is_offending_flows_min_set As G nP\"\n  shows \"sinvar (delete_edges G (As \\<union> Bs)) nP\"\n  proof -\n    from offending have \"is_offending_flows As G nP\" using is_offending_flows_min_set_def by simp\n    from mono_isoffending this have \"is_offending_flows (Bs \\<union> As) G nP\" by simp\n    hence \"is_offending_flows (As \\<union> Bs) G nP\" by (metis Un_commute)\n    from this is_offending_flows_def show ?thesis by simp\n  qed*)\n\n\n  (*use this to show locale preliminaries from mono*)"], ["", "lemma sinvar_mono_imp_is_offending_flows_mono:\n  assumes mono: \"sinvar_mono\"\n  and wfG: \"wf_graph G\"\n  shows \"is_offending_flows FF G nP  \\<Longrightarrow> is_offending_flows (FF \\<union> F) G nP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_offending_flows FF G nP \\<Longrightarrow>\n    is_offending_flows (FF \\<union> F) G nP", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_offending_flows FF G nP \\<Longrightarrow>\n    is_offending_flows (FF \\<union> F) G nP", "from wfG"], ["proof (chain)\npicking this:\n  wf_graph G", "have wfG': \"wf_graph \\<lparr>nodes = nodes G, edges = {(e1, e2). (e1, e2) \\<in> edges G \\<and> (e1, e2) \\<notin> FF}\\<rparr>\""], ["proof (prove)\nusing this:\n  wf_graph G\n\ngoal (1 subgoal):\n 1. wf_graph\n     \\<lparr>nodes = nodes G,\n        edges =\n          {(e1, e2).\n           (e1, e2) \\<in> edges G \\<and> (e1, e2) \\<notin> FF}\\<rparr>", "by (metis delete_edges_def delete_edges_wf)"], ["proof (state)\nthis:\n  wf_graph\n   \\<lparr>nodes = nodes G,\n      edges =\n        {(e1, e2).\n         (e1, e2) \\<in> edges G \\<and> (e1, e2) \\<notin> FF}\\<rparr>\n\ngoal (1 subgoal):\n 1. is_offending_flows FF G nP \\<Longrightarrow>\n    is_offending_flows (FF \\<union> F) G nP", "from mono"], ["proof (chain)\npicking this:\n  sinvar_mono", "have sinvarE: \"(\\<And> nP N E' E. wf_graph \\<lparr> nodes = N, edges = E \\<rparr> \\<Longrightarrow> E' \\<subseteq> E \\<Longrightarrow> sinvar \\<lparr> nodes = N, edges = E \\<rparr> nP \\<Longrightarrow> sinvar \\<lparr> nodes = N, edges = E' \\<rparr> nP )\""], ["proof (prove)\nusing this:\n  sinvar_mono\n\ngoal (1 subgoal):\n 1. \\<And>nP N E' E.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP", "unfolding sinvar_mono_def"], ["proof (prove)\nusing this:\n  \\<forall>nP N E' E.\n     wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n     E' \\<subseteq> E \\<and>\n     sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP \\<longrightarrow>\n     sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n\ngoal (1 subgoal):\n 1. \\<And>nP N E' E.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP", "by metis"], ["proof (state)\nthis:\n  \\<lbrakk>wf_graph \\<lparr>nodes = ?N, edges = ?E\\<rparr>;\n   ?E' \\<subseteq> ?E;\n   sinvar \\<lparr>nodes = ?N, edges = ?E\\<rparr> ?nP\\<rbrakk>\n  \\<Longrightarrow> sinvar \\<lparr>nodes = ?N, edges = ?E'\\<rparr> ?nP\n\ngoal (1 subgoal):\n 1. is_offending_flows FF G nP \\<Longrightarrow>\n    is_offending_flows (FF \\<union> F) G nP", "have \"\\<And> G FF F. {(e1, e2). (e1, e2) \\<in> edges G \\<and> (e1, e2) \\<notin> FF \\<and> (e1, e2) \\<notin> F} \\<subseteq> {(e1, e2). (e1, e2) \\<in> edges G \\<and> (e1, e2) \\<notin> FF} \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G FF F.\n       {(e1, e2).\n        (e1, e2) \\<in> edges G \\<and>\n        (e1, e2) \\<notin> FF \\<and> (e1, e2) \\<notin> F}\n       \\<subseteq> {(e1, e2).\n                    (e1, e2) \\<in> edges G \\<and> (e1, e2) \\<notin> FF}", "by(rule Collect_mono) (simp)"], ["proof (state)\nthis:\n  {(e1, e2).\n   (e1, e2) \\<in> edges ?G \\<and>\n   (e1, e2) \\<notin> ?FF \\<and> (e1, e2) \\<notin> ?F}\n  \\<subseteq> {(e1, e2).\n               (e1, e2) \\<in> edges ?G \\<and> (e1, e2) \\<notin> ?FF}\n\ngoal (1 subgoal):\n 1. is_offending_flows FF G nP \\<Longrightarrow>\n    is_offending_flows (FF \\<union> F) G nP", "from sinvarE[OF wfG' this]"], ["proof (chain)\npicking this:\n  sinvar\n   \\<lparr>nodes = nodes G,\n      edges =\n        {(e1, e2).\n         (e1, e2) \\<in> edges G \\<and> (e1, e2) \\<notin> FF}\\<rparr>\n   ?nP \\<Longrightarrow>\n  sinvar\n   \\<lparr>nodes = nodes G,\n      edges =\n        {(e1, e2).\n         (e1, e2) \\<in> edges G \\<and>\n         (e1, e2) \\<notin> FF \\<and> (e1, e2) \\<notin> ?F1}\\<rparr>\n   ?nP", "show \"is_offending_flows FF G nP \\<Longrightarrow> is_offending_flows (FF \\<union> F) G nP\""], ["proof (prove)\nusing this:\n  sinvar\n   \\<lparr>nodes = nodes G,\n      edges =\n        {(e1, e2).\n         (e1, e2) \\<in> edges G \\<and> (e1, e2) \\<notin> FF}\\<rparr>\n   ?nP \\<Longrightarrow>\n  sinvar\n   \\<lparr>nodes = nodes G,\n      edges =\n        {(e1, e2).\n         (e1, e2) \\<in> edges G \\<and>\n         (e1, e2) \\<notin> FF \\<and> (e1, e2) \\<notin> ?F1}\\<rparr>\n   ?nP\n\ngoal (1 subgoal):\n 1. is_offending_flows FF G nP \\<Longrightarrow>\n    is_offending_flows (FF \\<union> F) G nP", "by(simp add: is_offending_flows_def delete_edges_def)"], ["proof (state)\nthis:\n  is_offending_flows FF G nP \\<Longrightarrow>\n  is_offending_flows (FF \\<union> F) G nP\n\ngoal:\nNo subgoals!", "qed"], ["", "(*use this to show locale sinvar_mono*)"], ["", "lemma sinvar_mono_imp_sinvar_mono: \n  \"sinvar_mono \\<Longrightarrow> wf_graph \\<lparr> nodes = N, edges = E \\<rparr> \\<Longrightarrow> E' \\<subseteq> E \\<Longrightarrow> sinvar \\<lparr> nodes = N, edges = E \\<rparr> nP \\<Longrightarrow> \n        sinvar \\<lparr> nodes = N, edges = E' \\<rparr> nP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sinvar_mono; wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n    \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP", "apply(simp add: sinvar_mono_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>nP N E'.\n                (\\<exists>E.\n                    wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n                    E' \\<subseteq> E \\<and>\n                    sinvar \\<lparr>nodes = N, edges = E\\<rparr>\n                     nP) \\<longrightarrow>\n                sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP;\n     wf_graph \\<lparr>nodes = N, edges = E\\<rparr>; E' \\<subseteq> E;\n     sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n    \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP", "by blast"], ["", "end"], ["", "subsection \\<open>Offending Flows Not Empty Helper Lemmata\\<close>"], ["", "context SecurityInvariant_withOffendingFlows\nbegin"], ["", "text \\<open>Give an over-approximation of offending flows (e.g. all edges) and get back a\n          minimal set\\<close>"], ["", "(*offending_overapproximation keepingInOffendingApproximation G nP*)"], ["", "fun minimalize_offending_overapprox :: \"('v \\<times> 'v) list \\<Rightarrow> ('v \\<times> 'v) list \\<Rightarrow> \n  'v graph \\<Rightarrow> ('v \\<Rightarrow> 'a) \\<Rightarrow> ('v \\<times> 'v) list\" where\n  \"minimalize_offending_overapprox [] keep _ _ = keep\" |\n  \"minimalize_offending_overapprox (f#fs) keep G nP = (if sinvar (delete_edges_list G (fs@keep)) nP then\n      minimalize_offending_overapprox fs keep G nP \n    else\n      minimalize_offending_overapprox fs (f#keep) G nP\n    )\""], ["", "text\\<open>The graph we check in @{const minimalize_offending_overapprox},\n  @{term \"G minus (fs \\<union> keep)\"} is the graph from the \\<open>offending_flows_min_set\\<close> condition.\n  We add @{term f} and remove it.\\<close>"], ["", "(*lemma minimalize_offending_overapprox_not_in: \n  \"f \\<notin> set fs \\<Longrightarrow> f \\<notin> set keep \\<Longrightarrow> f \\<notin> set (minimalize_offending_overapprox fs keep G nP)\"\n   apply(induction fs arbitrary: keep)\n    by(simp_all)*)\n\n\n\n\n  (*lemma offending_min_set_ab_in_fs: \"wf_graph (G::'v graph) \\<Longrightarrow> (a,b) \\<in> edges G \\<Longrightarrow>\n       is_offending_flows_min_set ({(a, b)} \\<union> fs) G nP \\<Longrightarrow>\n       sinvar (delete_edges G fs) nP \\<Longrightarrow>\n       (a,b) \\<in> fs\"\n  apply(rule ccontr)\n  apply(simp add: is_offending_flows_min_set_def)\n  apply(clarify)\n  apply(simp add: add_delete_edges)\n  done*)"], ["", "lemma minimalize_offending_overapprox_subset:\n  \"set (minimalize_offending_overapprox ff keeps G nP) \\<subseteq> set ff \\<union> set keeps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (minimalize_offending_overapprox ff keeps G nP)\n    \\<subseteq> set ff \\<union> set keeps", "proof(induction ff arbitrary: keeps)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>keeps.\n       set (minimalize_offending_overapprox [] keeps G nP)\n       \\<subseteq> set [] \\<union> set keeps\n 2. \\<And>a ff keeps.\n       (\\<And>keeps.\n           set (minimalize_offending_overapprox ff keeps G nP)\n           \\<subseteq> set ff \\<union> set keeps) \\<Longrightarrow>\n       set (minimalize_offending_overapprox (a # ff) keeps G nP)\n       \\<subseteq> set (a # ff) \\<union> set keeps", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>keeps.\n       set (minimalize_offending_overapprox [] keeps G nP)\n       \\<subseteq> set [] \\<union> set keeps\n 2. \\<And>a ff keeps.\n       (\\<And>keeps.\n           set (minimalize_offending_overapprox ff keeps G nP)\n           \\<subseteq> set ff \\<union> set keeps) \\<Longrightarrow>\n       set (minimalize_offending_overapprox (a # ff) keeps G nP)\n       \\<subseteq> set (a # ff) \\<union> set keeps", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (minimalize_offending_overapprox [] keeps G nP)\n    \\<subseteq> set [] \\<union> set keeps", "by simp"], ["proof (state)\nthis:\n  set (minimalize_offending_overapprox [] keeps G nP)\n  \\<subseteq> set [] \\<union> set keeps\n\ngoal (1 subgoal):\n 1. \\<And>a ff keeps.\n       (\\<And>keeps.\n           set (minimalize_offending_overapprox ff keeps G nP)\n           \\<subseteq> set ff \\<union> set keeps) \\<Longrightarrow>\n       set (minimalize_offending_overapprox (a # ff) keeps G nP)\n       \\<subseteq> set (a # ff) \\<union> set keeps", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ff keeps.\n       (\\<And>keeps.\n           set (minimalize_offending_overapprox ff keeps G nP)\n           \\<subseteq> set ff \\<union> set keeps) \\<Longrightarrow>\n       set (minimalize_offending_overapprox (a # ff) keeps G nP)\n       \\<subseteq> set (a # ff) \\<union> set keeps", "case (Cons a ff)"], ["proof (state)\nthis:\n  set (minimalize_offending_overapprox ff ?keeps G nP)\n  \\<subseteq> set ff \\<union> set ?keeps\n\ngoal (1 subgoal):\n 1. \\<And>a ff keeps.\n       (\\<And>keeps.\n           set (minimalize_offending_overapprox ff keeps G nP)\n           \\<subseteq> set ff \\<union> set keeps) \\<Longrightarrow>\n       set (minimalize_offending_overapprox (a # ff) keeps G nP)\n       \\<subseteq> set (a # ff) \\<union> set keeps", "from Cons"], ["proof (chain)\npicking this:\n  set (minimalize_offending_overapprox ff ?keeps G nP)\n  \\<subseteq> set ff \\<union> set ?keeps", "have case1: \"(sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n     set (minimalize_offending_overapprox ff keeps G nP) \\<subseteq> insert a (set ff \\<union> set keeps))\""], ["proof (prove)\nusing this:\n  set (minimalize_offending_overapprox ff ?keeps G nP)\n  \\<subseteq> set ff \\<union> set ?keeps\n\ngoal (1 subgoal):\n 1. sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n    set (minimalize_offending_overapprox ff keeps G nP)\n    \\<subseteq> insert a (set ff \\<union> set keeps)", "by blast"], ["proof (state)\nthis:\n  sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n  set (minimalize_offending_overapprox ff keeps G nP)\n  \\<subseteq> insert a (set ff \\<union> set keeps)\n\ngoal (1 subgoal):\n 1. \\<And>a ff keeps.\n       (\\<And>keeps.\n           set (minimalize_offending_overapprox ff keeps G nP)\n           \\<subseteq> set ff \\<union> set keeps) \\<Longrightarrow>\n       set (minimalize_offending_overapprox (a # ff) keeps G nP)\n       \\<subseteq> set (a # ff) \\<union> set keeps", "from Cons"], ["proof (chain)\npicking this:\n  set (minimalize_offending_overapprox ff ?keeps G nP)\n  \\<subseteq> set ff \\<union> set ?keeps", "have case2: \"(\\<not> sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n     set (minimalize_offending_overapprox ff (a # keeps) G nP) \\<subseteq> insert a (set ff \\<union> set keeps))\""], ["proof (prove)\nusing this:\n  set (minimalize_offending_overapprox ff ?keeps G nP)\n  \\<subseteq> set ff \\<union> set ?keeps\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n    set (minimalize_offending_overapprox ff (a # keeps) G nP)\n    \\<subseteq> insert a (set ff \\<union> set keeps)", "by fastforce"], ["proof (state)\nthis:\n  \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n  set (minimalize_offending_overapprox ff (a # keeps) G nP)\n  \\<subseteq> insert a (set ff \\<union> set keeps)\n\ngoal (1 subgoal):\n 1. \\<And>a ff keeps.\n       (\\<And>keeps.\n           set (minimalize_offending_overapprox ff keeps G nP)\n           \\<subseteq> set ff \\<union> set keeps) \\<Longrightarrow>\n       set (minimalize_offending_overapprox (a # ff) keeps G nP)\n       \\<subseteq> set (a # ff) \\<union> set keeps", "from case1 case2"], ["proof (chain)\npicking this:\n  sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n  set (minimalize_offending_overapprox ff keeps G nP)\n  \\<subseteq> insert a (set ff \\<union> set keeps)\n  \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n  set (minimalize_offending_overapprox ff (a # keeps) G nP)\n  \\<subseteq> insert a (set ff \\<union> set keeps)", "show ?case"], ["proof (prove)\nusing this:\n  sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n  set (minimalize_offending_overapprox ff keeps G nP)\n  \\<subseteq> insert a (set ff \\<union> set keeps)\n  \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n  set (minimalize_offending_overapprox ff (a # keeps) G nP)\n  \\<subseteq> insert a (set ff \\<union> set keeps)\n\ngoal (1 subgoal):\n 1. set (minimalize_offending_overapprox (a # ff) keeps G nP)\n    \\<subseteq> set (a # ff) \\<union> set keeps", "by simp"], ["proof (state)\nthis:\n  set (minimalize_offending_overapprox (a # ff) keeps G nP)\n  \\<subseteq> set (a # ff) \\<union> set keeps\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_model_mono_imp_addedge_mono: \n  assumes mono: \"sinvar_mono\"\n   and vG: \"wf_graph G\" and ain: \"(a1,a2) \\<in> edges G\" and xy: \"X \\<subseteq> Y\" and ns: \"\\<not> sinvar (add_edge a1 a2 (delete_edges G (Y))) nP\"  \n  shows \"\\<not> sinvar (add_edge a1 a2 (delete_edges G X)) nP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sinvar (add_edge a1 a2 (delete_edges G X)) nP", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> sinvar (add_edge a1 a2 (delete_edges G X)) nP", "have wf_graph_add_delete_edge_simp: \n        \"\\<And>Y. add_edge a1 a2 (delete_edges G Y) = (delete_edges G (Y - {(a1,a2)}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       add_edge a1 a2 (delete_edges G Y) = delete_edges G (Y - {(a1, a2)})", "apply(simp add: delete_edges_simp2 add_edge_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       insert a1 (insert a2 (nodes G)) = nodes G \\<and>\n       insert (a1, a2) (edges G - Y) = edges G - (Y - {(a1, a2)})", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Y. insert a1 (insert a2 (nodes G)) = nodes G\n 2. \\<And>Y. insert (a1, a2) (edges G - Y) = edges G - (Y - {(a1, a2)})", "using ain"], ["proof (prove)\nusing this:\n  (a1, a2) \\<in> edges G\n\ngoal (2 subgoals):\n 1. \\<And>Y. insert a1 (insert a2 (nodes G)) = nodes G\n 2. \\<And>Y. insert (a1, a2) (edges G - Y) = edges G - (Y - {(a1, a2)})", "apply (metis insert_absorb vG wf_graph.E_wfD(1) wf_graph.E_wfD(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y. insert (a1, a2) (edges G - Y) = edges G - (Y - {(a1, a2)})", "apply(auto simp add: ain)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  add_edge a1 a2 (delete_edges G ?Y) = delete_edges G (?Y - {(a1, a2)})\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (add_edge a1 a2 (delete_edges G X)) nP", "from this ns"], ["proof (chain)\npicking this:\n  add_edge a1 a2 (delete_edges G ?Y) = delete_edges G (?Y - {(a1, a2)})\n  \\<not> sinvar (add_edge a1 a2 (delete_edges G Y)) nP", "have 1: \"\\<not> sinvar (delete_edges G (Y - {(a1, a2)})) nP\""], ["proof (prove)\nusing this:\n  add_edge a1 a2 (delete_edges G ?Y) = delete_edges G (?Y - {(a1, a2)})\n  \\<not> sinvar (add_edge a1 a2 (delete_edges G Y)) nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges G (Y - {(a1, a2)})) nP", "by simp"], ["proof (state)\nthis:\n  \\<not> sinvar (delete_edges G (Y - {(a1, a2)})) nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (add_edge a1 a2 (delete_edges G X)) nP", "have 2: \"X - {(a1, a2)} \\<subseteq> Y - {(a1, a2)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X - {(a1, a2)} \\<subseteq> Y - {(a1, a2)}", "by (metis Diff_mono subset_refl xy)"], ["proof (state)\nthis:\n  X - {(a1, a2)} \\<subseteq> Y - {(a1, a2)}\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (add_edge a1 a2 (delete_edges G X)) nP", "from sinvar_mono_imp_negative_delete_edge_mono[OF mono] vG"], ["proof (chain)\npicking this:\n  \\<lbrakk>wf_graph ?G; ?X \\<subseteq> ?Y;\n   \\<not> sinvar (delete_edges ?G ?Y) ?nP\\<rbrakk>\n  \\<Longrightarrow> \\<not> sinvar (delete_edges ?G ?X) ?nP\n  wf_graph G", "have\n        \"\\<And>X Y. X \\<subseteq> Y \\<Longrightarrow> \\<not> sinvar (delete_edges G Y) nP \\<Longrightarrow> \\<not> sinvar (delete_edges G X) nP\""], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_graph ?G; ?X \\<subseteq> ?Y;\n   \\<not> sinvar (delete_edges ?G ?Y) ?nP\\<rbrakk>\n  \\<Longrightarrow> \\<not> sinvar (delete_edges ?G ?X) ?nP\n  wf_graph G\n\ngoal (1 subgoal):\n 1. \\<And>X Y.\n       \\<lbrakk>X \\<subseteq> Y;\n        \\<not> sinvar (delete_edges G Y) nP\\<rbrakk>\n       \\<Longrightarrow> \\<not> sinvar (delete_edges G X) nP", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?X \\<subseteq> ?Y; \\<not> sinvar (delete_edges G ?Y) nP\\<rbrakk>\n  \\<Longrightarrow> \\<not> sinvar (delete_edges G ?X) nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (add_edge a1 a2 (delete_edges G X)) nP", "from this[OF 2 1]"], ["proof (chain)\npicking this:\n  \\<not> sinvar (delete_edges G (X - {(a1, a2)})) nP", "have \"\\<not> sinvar (delete_edges G (X - {(a1, a2)})) nP\""], ["proof (prove)\nusing this:\n  \\<not> sinvar (delete_edges G (X - {(a1, a2)})) nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges G (X - {(a1, a2)})) nP", "by simp"], ["proof (state)\nthis:\n  \\<not> sinvar (delete_edges G (X - {(a1, a2)})) nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (add_edge a1 a2 (delete_edges G X)) nP", "from this wf_graph_add_delete_edge_simp[symmetric]"], ["proof (chain)\npicking this:\n  \\<not> sinvar (delete_edges G (X - {(a1, a2)})) nP\n  delete_edges G (?Y - {(a1, a2)}) = add_edge a1 a2 (delete_edges G ?Y)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> sinvar (delete_edges G (X - {(a1, a2)})) nP\n  delete_edges G (?Y - {(a1, a2)}) = add_edge a1 a2 (delete_edges G ?Y)\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (add_edge a1 a2 (delete_edges G X)) nP", "by simp"], ["proof (state)\nthis:\n  \\<not> sinvar (add_edge a1 a2 (delete_edges G X)) nP\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem is_offending_flows_min_set_minimalize_offending_overapprox:\n      assumes mono: \"sinvar_mono\"\n      and vG: \"wf_graph G\" and iO: \"is_offending_flows (set ff) G nP\" and sF: \"set ff \\<subseteq> edges G\" and dF: \"distinct ff\"\n      shows \"is_offending_flows_min_set (set (minimalize_offending_overapprox ff [] G nP)) G nP\"\n              (is \"is_offending_flows_min_set ?minset G nP\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_offending_flows_min_set\n     (set (minimalize_offending_overapprox ff [] G nP)) G nP", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_offending_flows_min_set\n     (set (minimalize_offending_overapprox ff [] G nP)) G nP", "from iO"], ["proof (chain)\npicking this:\n  is_offending_flows (set ff) G nP", "have \"sinvar (delete_edges G (set ff)) nP\""], ["proof (prove)\nusing this:\n  is_offending_flows (set ff) G nP\n\ngoal (1 subgoal):\n 1. sinvar (delete_edges G (set ff)) nP", "by (metis is_offending_flows_def)\n\n    \\<comment> \\<open>@{term \"sinvar\"} holds if we delete @{term \"ff\"}.\n        With the following generalized statement, we show that it also holds if we delete @{term \"minimalize_offending_overapprox ff []\"}\\<close>"], ["proof (state)\nthis:\n  sinvar (delete_edges G (set ff)) nP\n\ngoal (1 subgoal):\n 1. is_offending_flows_min_set\n     (set (minimalize_offending_overapprox ff [] G nP)) G nP", "{"], ["proof (state)\nthis:\n  sinvar (delete_edges G (set ff)) nP\n\ngoal (1 subgoal):\n 1. is_offending_flows_min_set\n     (set (minimalize_offending_overapprox ff [] G nP)) G nP", "fix keeps\n      \\<comment> \\<open>Generalized for arbitrary @{term keeps}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. is_offending_flows_min_set\n     (set (minimalize_offending_overapprox ff [] G nP)) G nP", "have \"sinvar (delete_edges G (set ff \\<union> set keeps)) nP \\<Longrightarrow> \n          sinvar (delete_edges G (set (minimalize_offending_overapprox ff keeps G nP))) nP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinvar (delete_edges G (set ff \\<union> set keeps)) nP \\<Longrightarrow>\n    sinvar\n     (delete_edges G (set (minimalize_offending_overapprox ff keeps G nP)))\n     nP", "apply(induction ff arbitrary: keeps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>keeps.\n       sinvar (delete_edges G (set [] \\<union> set keeps))\n        nP \\<Longrightarrow>\n       sinvar\n        (delete_edges G\n          (set (minimalize_offending_overapprox [] keeps G nP)))\n        nP\n 2. \\<And>a ff keeps.\n       \\<lbrakk>\\<And>keeps.\n                   sinvar (delete_edges G (set ff \\<union> set keeps))\n                    nP \\<Longrightarrow>\n                   sinvar\n                    (delete_edges G\n                      (set (minimalize_offending_overapprox ff keeps G nP)))\n                    nP;\n        sinvar (delete_edges G (set (a # ff) \\<union> set keeps))\n         nP\\<rbrakk>\n       \\<Longrightarrow> sinvar\n                          (delete_edges G\n                            (set (minimalize_offending_overapprox (a # ff)\n                                   keeps G nP)))\n                          nP", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ff keeps.\n       \\<lbrakk>\\<And>keeps.\n                   sinvar (delete_edges G (set ff \\<union> set keeps))\n                    nP \\<Longrightarrow>\n                   sinvar\n                    (delete_edges G\n                      (set (minimalize_offending_overapprox ff keeps G nP)))\n                    nP;\n        sinvar (delete_edges G (set (a # ff) \\<union> set keeps))\n         nP\\<rbrakk>\n       \\<Longrightarrow> sinvar\n                          (delete_edges G\n                            (set (minimalize_offending_overapprox (a # ff)\n                                   keeps G nP)))\n                          nP", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ff keeps.\n       \\<lbrakk>\\<And>keeps.\n                   sinvar (delete_edges G (set ff \\<union> set keeps))\n                    nP \\<Longrightarrow>\n                   sinvar\n                    (delete_edges G\n                      (set (minimalize_offending_overapprox ff keeps G nP)))\n                    nP;\n        sinvar (delete_edges G (insert a (set ff \\<union> set keeps)))\n         nP\\<rbrakk>\n       \\<Longrightarrow> sinvar (delete_edges_list G (ff @ keeps))\n                          nP \\<longrightarrow>\n                         sinvar\n                          (delete_edges G\n                            (set (minimalize_offending_overapprox ff keeps G\n                                   nP)))\n                          nP", "apply(rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ff keeps.\n       \\<lbrakk>\\<And>keeps.\n                   sinvar (delete_edges G (set ff \\<union> set keeps))\n                    nP \\<Longrightarrow>\n                   sinvar\n                    (delete_edges G\n                      (set (minimalize_offending_overapprox ff keeps G nP)))\n                    nP;\n        sinvar (delete_edges G (insert a (set ff \\<union> set keeps))) nP;\n        sinvar (delete_edges_list G (ff @ keeps)) nP\\<rbrakk>\n       \\<Longrightarrow> sinvar\n                          (delete_edges G\n                            (set (minimalize_offending_overapprox ff keeps G\n                                   nP)))\n                          nP", "apply(simp add:delete_edges_list_union)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sinvar (delete_edges G (set ff \\<union> set keeps)) nP \\<Longrightarrow>\n  sinvar\n   (delete_edges G (set (minimalize_offending_overapprox ff keeps G nP))) nP\n\ngoal (1 subgoal):\n 1. is_offending_flows_min_set\n     (set (minimalize_offending_overapprox ff [] G nP)) G nP", "} \n    \\<comment> \\<open>@{term \"keeps = []\"}\\<close>"], ["proof (state)\nthis:\n  sinvar (delete_edges G (set ff \\<union> set ?keeps2)) nP \\<Longrightarrow>\n  sinvar\n   (delete_edges G (set (minimalize_offending_overapprox ff ?keeps2 G nP)))\n   nP\n\ngoal (1 subgoal):\n 1. is_offending_flows_min_set\n     (set (minimalize_offending_overapprox ff [] G nP)) G nP", "note minimalize_offending_overapprox_maintains_evalmodel=this[of \"[]\"]"], ["proof (state)\nthis:\n  sinvar (delete_edges G (set ff \\<union> set [])) nP \\<Longrightarrow>\n  sinvar (delete_edges G (set (minimalize_offending_overapprox ff [] G nP)))\n   nP\n\ngoal (1 subgoal):\n 1. is_offending_flows_min_set\n     (set (minimalize_offending_overapprox ff [] G nP)) G nP", "from \\<open>sinvar (delete_edges G (set ff)) nP\\<close> minimalize_offending_overapprox_maintains_evalmodel"], ["proof (chain)\npicking this:\n  sinvar (delete_edges G (set ff)) nP\n  sinvar (delete_edges G (set ff \\<union> set [])) nP \\<Longrightarrow>\n  sinvar (delete_edges G (set (minimalize_offending_overapprox ff [] G nP)))\n   nP", "have\n      \"sinvar (delete_edges G ?minset) nP\""], ["proof (prove)\nusing this:\n  sinvar (delete_edges G (set ff)) nP\n  sinvar (delete_edges G (set ff \\<union> set [])) nP \\<Longrightarrow>\n  sinvar (delete_edges G (set (minimalize_offending_overapprox ff [] G nP)))\n   nP\n\ngoal (1 subgoal):\n 1. sinvar\n     (delete_edges G (set (minimalize_offending_overapprox ff [] G nP))) nP", "by simp"], ["proof (state)\nthis:\n  sinvar (delete_edges G (set (minimalize_offending_overapprox ff [] G nP)))\n   nP\n\ngoal (1 subgoal):\n 1. is_offending_flows_min_set\n     (set (minimalize_offending_overapprox ff [] G nP)) G nP", "hence 1: \"is_offending_flows ?minset G nP\""], ["proof (prove)\nusing this:\n  sinvar (delete_edges G (set (minimalize_offending_overapprox ff [] G nP)))\n   nP\n\ngoal (1 subgoal):\n 1. is_offending_flows (set (minimalize_offending_overapprox ff [] G nP)) G\n     nP", "by (metis iO is_offending_flows_def)"], ["proof (state)\nthis:\n  is_offending_flows (set (minimalize_offending_overapprox ff [] G nP)) G nP\n\ngoal (1 subgoal):\n 1. is_offending_flows_min_set\n     (set (minimalize_offending_overapprox ff [] G nP)) G nP", "txt\\<open>We need to show minimality of @{term \"minimalize_offending_overapprox ff []\"}.\n      Minimality means @{term \"\\<forall>(e1, e2)\\<in>?minset. \\<not> sinvar (add_edge e1 e2 (delete_edges G ?minset)) nP\"}.\n      We show the following generalized fact.\n\\<close>"], ["proof (state)\nthis:\n  is_offending_flows (set (minimalize_offending_overapprox ff [] G nP)) G nP\n\ngoal (1 subgoal):\n 1. is_offending_flows_min_set\n     (set (minimalize_offending_overapprox ff [] G nP)) G nP", "{"], ["proof (state)\nthis:\n  is_offending_flows (set (minimalize_offending_overapprox ff [] G nP)) G nP\n\ngoal (1 subgoal):\n 1. is_offending_flows_min_set\n     (set (minimalize_offending_overapprox ff [] G nP)) G nP", "fix ff keeps"], ["proof (state)\ngoal (1 subgoal):\n 1. is_offending_flows_min_set\n     (set (minimalize_offending_overapprox ff [] G nP)) G nP", "have \"\\<forall> x \\<in> set ff. x \\<notin> set keeps \\<Longrightarrow>\n        \\<forall> x \\<in> set ff. x \\<in> edges G \\<Longrightarrow>\n        distinct ff \\<Longrightarrow>\n        \\<forall>(e1, e2)\\<in> set keeps.\n           \\<not> sinvar (add_edge e1 e2 (delete_edges G (set (minimalize_offending_overapprox ff keeps G nP)))) nP \\<Longrightarrow>\n        \\<forall>(e1, e2)\\<in>set (minimalize_offending_overapprox ff keeps G nP).\n           \\<not> sinvar (add_edge e1 e2 (delete_edges G (set (minimalize_offending_overapprox ff keeps G nP)))) nP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set ff. x \\<notin> set keeps;\n     \\<forall>x\\<in>set ff. x \\<in> edges G; distinct ff;\n     \\<forall>(e1, e2)\\<in>set keeps.\n        \\<not> sinvar\n                (add_edge e1 e2\n                  (delete_edges G\n                    (set (minimalize_offending_overapprox ff keeps G nP))))\n                nP\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(e1, e2)\n                               \\<in>set (minimalize_offending_overapprox ff\n    keeps G nP).\n                         \\<not> sinvar\n                                 (add_edge e1 e2\n                                   (delete_edges G\n                                     (set\n (minimalize_offending_overapprox ff keeps G nP))))\n                                 nP", "proof(induction ff arbitrary: keeps)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>keeps.\n       \\<lbrakk>\\<forall>x\\<in>set []. x \\<notin> set keeps;\n        \\<forall>x\\<in>set []. x \\<in> edges G; distinct [];\n        \\<forall>(e1, e2)\\<in>set keeps.\n           \\<not> sinvar\n                   (add_edge e1 e2\n                     (delete_edges G\n                       (set (minimalize_offending_overapprox [] keeps G\n                              nP))))\n                   nP\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(e1, e2)\n                                  \\<in>set\n  (minimalize_offending_overapprox [] keeps G nP).\n                            \\<not> sinvar\n                                    (add_edge e1 e2\n(delete_edges G (set (minimalize_offending_overapprox [] keeps G nP))))\n                                    nP\n 2. \\<And>a ff keeps.\n       \\<lbrakk>\\<And>keeps.\n                   \\<lbrakk>\\<forall>x\\<in>set ff. x \\<notin> set keeps;\n                    \\<forall>x\\<in>set ff. x \\<in> edges G; distinct ff;\n                    \\<forall>(e1, e2)\\<in>set keeps.\n                       \\<not> sinvar\n                               (add_edge e1 e2\n                                 (delete_edges G\n                                   (set (minimalize_offending_overapprox ff\n    keeps G nP))))\n                               nP\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(e1, e2)\n        \\<in>set (minimalize_offending_overapprox ff keeps G nP).\n  \\<not> sinvar\n          (add_edge e1 e2\n            (delete_edges G\n              (set (minimalize_offending_overapprox ff keeps G nP))))\n          nP;\n        \\<forall>x\\<in>set (a # ff). x \\<notin> set keeps;\n        \\<forall>x\\<in>set (a # ff). x \\<in> edges G; distinct (a # ff);\n        \\<forall>(e1, e2)\\<in>set keeps.\n           \\<not> sinvar\n                   (add_edge e1 e2\n                     (delete_edges G\n                       (set (minimalize_offending_overapprox (a # ff) keeps\n                              G nP))))\n                   nP\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(e1, e2)\n                                  \\<in>set\n  (minimalize_offending_overapprox (a # ff) keeps G nP).\n                            \\<not> sinvar\n                                    (add_edge e1 e2\n(delete_edges G\n  (set (minimalize_offending_overapprox (a # ff) keeps G nP))))\n                                    nP", "case Nil"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set []. x \\<notin> set keeps\n  \\<forall>x\\<in>set []. x \\<in> edges G\n  distinct []\n  \\<forall>a\\<in>set keeps.\n     case a of\n     (e1, e2) \\<Rightarrow>\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges G\n                   (set (minimalize_offending_overapprox [] keeps G nP))))\n               nP\n\ngoal (2 subgoals):\n 1. \\<And>keeps.\n       \\<lbrakk>\\<forall>x\\<in>set []. x \\<notin> set keeps;\n        \\<forall>x\\<in>set []. x \\<in> edges G; distinct [];\n        \\<forall>(e1, e2)\\<in>set keeps.\n           \\<not> sinvar\n                   (add_edge e1 e2\n                     (delete_edges G\n                       (set (minimalize_offending_overapprox [] keeps G\n                              nP))))\n                   nP\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(e1, e2)\n                                  \\<in>set\n  (minimalize_offending_overapprox [] keeps G nP).\n                            \\<not> sinvar\n                                    (add_edge e1 e2\n(delete_edges G (set (minimalize_offending_overapprox [] keeps G nP))))\n                                    nP\n 2. \\<And>a ff keeps.\n       \\<lbrakk>\\<And>keeps.\n                   \\<lbrakk>\\<forall>x\\<in>set ff. x \\<notin> set keeps;\n                    \\<forall>x\\<in>set ff. x \\<in> edges G; distinct ff;\n                    \\<forall>(e1, e2)\\<in>set keeps.\n                       \\<not> sinvar\n                               (add_edge e1 e2\n                                 (delete_edges G\n                                   (set (minimalize_offending_overapprox ff\n    keeps G nP))))\n                               nP\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(e1, e2)\n        \\<in>set (minimalize_offending_overapprox ff keeps G nP).\n  \\<not> sinvar\n          (add_edge e1 e2\n            (delete_edges G\n              (set (minimalize_offending_overapprox ff keeps G nP))))\n          nP;\n        \\<forall>x\\<in>set (a # ff). x \\<notin> set keeps;\n        \\<forall>x\\<in>set (a # ff). x \\<in> edges G; distinct (a # ff);\n        \\<forall>(e1, e2)\\<in>set keeps.\n           \\<not> sinvar\n                   (add_edge e1 e2\n                     (delete_edges G\n                       (set (minimalize_offending_overapprox (a # ff) keeps\n                              G nP))))\n                   nP\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(e1, e2)\n                                  \\<in>set\n  (minimalize_offending_overapprox (a # ff) keeps G nP).\n                            \\<not> sinvar\n                                    (add_edge e1 e2\n(delete_edges G\n  (set (minimalize_offending_overapprox (a # ff) keeps G nP))))\n                                    nP", "from Nil"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set []. x \\<notin> set keeps\n  \\<forall>x\\<in>set []. x \\<in> edges G\n  distinct []\n  \\<forall>a\\<in>set keeps.\n     case a of\n     (e1, e2) \\<Rightarrow>\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges G\n                   (set (minimalize_offending_overapprox [] keeps G nP))))\n               nP", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set []. x \\<notin> set keeps\n  \\<forall>x\\<in>set []. x \\<in> edges G\n  distinct []\n  \\<forall>a\\<in>set keeps.\n     case a of\n     (e1, e2) \\<Rightarrow>\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges G\n                   (set (minimalize_offending_overapprox [] keeps G nP))))\n               nP\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set (minimalize_offending_overapprox [] keeps G nP).\n       case a of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox [] keeps G nP))))\n                 nP", "by(simp)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set (minimalize_offending_overapprox [] keeps G nP).\n     case a of\n     (e1, e2) \\<Rightarrow>\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges G\n                   (set (minimalize_offending_overapprox [] keeps G nP))))\n               nP\n\ngoal (1 subgoal):\n 1. \\<And>a ff keeps.\n       \\<lbrakk>\\<And>keeps.\n                   \\<lbrakk>\\<forall>x\\<in>set ff. x \\<notin> set keeps;\n                    \\<forall>x\\<in>set ff. x \\<in> edges G; distinct ff;\n                    \\<forall>(e1, e2)\\<in>set keeps.\n                       \\<not> sinvar\n                               (add_edge e1 e2\n                                 (delete_edges G\n                                   (set (minimalize_offending_overapprox ff\n    keeps G nP))))\n                               nP\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(e1, e2)\n        \\<in>set (minimalize_offending_overapprox ff keeps G nP).\n  \\<not> sinvar\n          (add_edge e1 e2\n            (delete_edges G\n              (set (minimalize_offending_overapprox ff keeps G nP))))\n          nP;\n        \\<forall>x\\<in>set (a # ff). x \\<notin> set keeps;\n        \\<forall>x\\<in>set (a # ff). x \\<in> edges G; distinct (a # ff);\n        \\<forall>(e1, e2)\\<in>set keeps.\n           \\<not> sinvar\n                   (add_edge e1 e2\n                     (delete_edges G\n                       (set (minimalize_offending_overapprox (a # ff) keeps\n                              G nP))))\n                   nP\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(e1, e2)\n                                  \\<in>set\n  (minimalize_offending_overapprox (a # ff) keeps G nP).\n                            \\<not> sinvar\n                                    (add_edge e1 e2\n(delete_edges G\n  (set (minimalize_offending_overapprox (a # ff) keeps G nP))))\n                                    nP", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ff keeps.\n       \\<lbrakk>\\<And>keeps.\n                   \\<lbrakk>\\<forall>x\\<in>set ff. x \\<notin> set keeps;\n                    \\<forall>x\\<in>set ff. x \\<in> edges G; distinct ff;\n                    \\<forall>(e1, e2)\\<in>set keeps.\n                       \\<not> sinvar\n                               (add_edge e1 e2\n                                 (delete_edges G\n                                   (set (minimalize_offending_overapprox ff\n    keeps G nP))))\n                               nP\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(e1, e2)\n        \\<in>set (minimalize_offending_overapprox ff keeps G nP).\n  \\<not> sinvar\n          (add_edge e1 e2\n            (delete_edges G\n              (set (minimalize_offending_overapprox ff keeps G nP))))\n          nP;\n        \\<forall>x\\<in>set (a # ff). x \\<notin> set keeps;\n        \\<forall>x\\<in>set (a # ff). x \\<in> edges G; distinct (a # ff);\n        \\<forall>(e1, e2)\\<in>set keeps.\n           \\<not> sinvar\n                   (add_edge e1 e2\n                     (delete_edges G\n                       (set (minimalize_offending_overapprox (a # ff) keeps\n                              G nP))))\n                   nP\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(e1, e2)\n                                  \\<in>set\n  (minimalize_offending_overapprox (a # ff) keeps G nP).\n                            \\<not> sinvar\n                                    (add_edge e1 e2\n(delete_edges G\n  (set (minimalize_offending_overapprox (a # ff) keeps G nP))))\n                                    nP", "case (Cons a ff)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x\\<in>set ff. x \\<notin> set ?keeps;\n   \\<forall>x\\<in>set ff. x \\<in> edges G; distinct ff;\n   \\<forall>a\\<in>set ?keeps.\n      case a of\n      (e1, e2) \\<Rightarrow>\n        \\<not> sinvar\n                (add_edge e1 e2\n                  (delete_edges G\n                    (set (minimalize_offending_overapprox ff ?keeps G nP))))\n                nP\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set (minimalize_offending_overapprox ff\n   ?keeps G nP).\n                       case a of\n                       (e1, e2) \\<Rightarrow>\n                         \\<not> sinvar\n                                 (add_edge e1 e2\n                                   (delete_edges G\n                                     (set\n (minimalize_offending_overapprox ff ?keeps G nP))))\n                                 nP\n  \\<forall>x\\<in>set (a # ff). x \\<notin> set keeps\n  \\<forall>x\\<in>set (a # ff). x \\<in> edges G\n  distinct (a # ff)\n  \\<forall>b\\<in>set keeps.\n     case b of\n     (e1, e2) \\<Rightarrow>\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges G\n                   (set (minimalize_offending_overapprox (a # ff) keeps G\n                          nP))))\n               nP\n\ngoal (1 subgoal):\n 1. \\<And>a ff keeps.\n       \\<lbrakk>\\<And>keeps.\n                   \\<lbrakk>\\<forall>x\\<in>set ff. x \\<notin> set keeps;\n                    \\<forall>x\\<in>set ff. x \\<in> edges G; distinct ff;\n                    \\<forall>(e1, e2)\\<in>set keeps.\n                       \\<not> sinvar\n                               (add_edge e1 e2\n                                 (delete_edges G\n                                   (set (minimalize_offending_overapprox ff\n    keeps G nP))))\n                               nP\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(e1, e2)\n        \\<in>set (minimalize_offending_overapprox ff keeps G nP).\n  \\<not> sinvar\n          (add_edge e1 e2\n            (delete_edges G\n              (set (minimalize_offending_overapprox ff keeps G nP))))\n          nP;\n        \\<forall>x\\<in>set (a # ff). x \\<notin> set keeps;\n        \\<forall>x\\<in>set (a # ff). x \\<in> edges G; distinct (a # ff);\n        \\<forall>(e1, e2)\\<in>set keeps.\n           \\<not> sinvar\n                   (add_edge e1 e2\n                     (delete_edges G\n                       (set (minimalize_offending_overapprox (a # ff) keeps\n                              G nP))))\n                   nP\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(e1, e2)\n                                  \\<in>set\n  (minimalize_offending_overapprox (a # ff) keeps G nP).\n                            \\<not> sinvar\n                                    (add_edge e1 e2\n(delete_edges G\n  (set (minimalize_offending_overapprox (a # ff) keeps G nP))))\n                                    nP", "assume not_in_keeps: \"\\<forall>x\\<in>set (a # ff). x \\<notin> set keeps\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (a # ff). x \\<notin> set keeps\n\ngoal (1 subgoal):\n 1. \\<And>a ff keeps.\n       \\<lbrakk>\\<And>keeps.\n                   \\<lbrakk>\\<forall>x\\<in>set ff. x \\<notin> set keeps;\n                    \\<forall>x\\<in>set ff. x \\<in> edges G; distinct ff;\n                    \\<forall>(e1, e2)\\<in>set keeps.\n                       \\<not> sinvar\n                               (add_edge e1 e2\n                                 (delete_edges G\n                                   (set (minimalize_offending_overapprox ff\n    keeps G nP))))\n                               nP\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(e1, e2)\n        \\<in>set (minimalize_offending_overapprox ff keeps G nP).\n  \\<not> sinvar\n          (add_edge e1 e2\n            (delete_edges G\n              (set (minimalize_offending_overapprox ff keeps G nP))))\n          nP;\n        \\<forall>x\\<in>set (a # ff). x \\<notin> set keeps;\n        \\<forall>x\\<in>set (a # ff). x \\<in> edges G; distinct (a # ff);\n        \\<forall>(e1, e2)\\<in>set keeps.\n           \\<not> sinvar\n                   (add_edge e1 e2\n                     (delete_edges G\n                       (set (minimalize_offending_overapprox (a # ff) keeps\n                              G nP))))\n                   nP\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(e1, e2)\n                                  \\<in>set\n  (minimalize_offending_overapprox (a # ff) keeps G nP).\n                            \\<not> sinvar\n                                    (add_edge e1 e2\n(delete_edges G\n  (set (minimalize_offending_overapprox (a # ff) keeps G nP))))\n                                    nP", "hence a_not_in_keeps: \"a \\<notin> set keeps\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (a # ff). x \\<notin> set keeps\n\ngoal (1 subgoal):\n 1. a \\<notin> set keeps", "by simp"], ["proof (state)\nthis:\n  a \\<notin> set keeps\n\ngoal (1 subgoal):\n 1. \\<And>a ff keeps.\n       \\<lbrakk>\\<And>keeps.\n                   \\<lbrakk>\\<forall>x\\<in>set ff. x \\<notin> set keeps;\n                    \\<forall>x\\<in>set ff. x \\<in> edges G; distinct ff;\n                    \\<forall>(e1, e2)\\<in>set keeps.\n                       \\<not> sinvar\n                               (add_edge e1 e2\n                                 (delete_edges G\n                                   (set (minimalize_offending_overapprox ff\n    keeps G nP))))\n                               nP\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(e1, e2)\n        \\<in>set (minimalize_offending_overapprox ff keeps G nP).\n  \\<not> sinvar\n          (add_edge e1 e2\n            (delete_edges G\n              (set (minimalize_offending_overapprox ff keeps G nP))))\n          nP;\n        \\<forall>x\\<in>set (a # ff). x \\<notin> set keeps;\n        \\<forall>x\\<in>set (a # ff). x \\<in> edges G; distinct (a # ff);\n        \\<forall>(e1, e2)\\<in>set keeps.\n           \\<not> sinvar\n                   (add_edge e1 e2\n                     (delete_edges G\n                       (set (minimalize_offending_overapprox (a # ff) keeps\n                              G nP))))\n                   nP\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(e1, e2)\n                                  \\<in>set\n  (minimalize_offending_overapprox (a # ff) keeps G nP).\n                            \\<not> sinvar\n                                    (add_edge e1 e2\n(delete_edges G\n  (set (minimalize_offending_overapprox (a # ff) keeps G nP))))\n                                    nP", "assume in_edges: \"\\<forall>x\\<in>set (a # ff). x \\<in> edges G\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (a # ff). x \\<in> edges G\n\ngoal (1 subgoal):\n 1. \\<And>a ff keeps.\n       \\<lbrakk>\\<And>keeps.\n                   \\<lbrakk>\\<forall>x\\<in>set ff. x \\<notin> set keeps;\n                    \\<forall>x\\<in>set ff. x \\<in> edges G; distinct ff;\n                    \\<forall>(e1, e2)\\<in>set keeps.\n                       \\<not> sinvar\n                               (add_edge e1 e2\n                                 (delete_edges G\n                                   (set (minimalize_offending_overapprox ff\n    keeps G nP))))\n                               nP\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(e1, e2)\n        \\<in>set (minimalize_offending_overapprox ff keeps G nP).\n  \\<not> sinvar\n          (add_edge e1 e2\n            (delete_edges G\n              (set (minimalize_offending_overapprox ff keeps G nP))))\n          nP;\n        \\<forall>x\\<in>set (a # ff). x \\<notin> set keeps;\n        \\<forall>x\\<in>set (a # ff). x \\<in> edges G; distinct (a # ff);\n        \\<forall>(e1, e2)\\<in>set keeps.\n           \\<not> sinvar\n                   (add_edge e1 e2\n                     (delete_edges G\n                       (set (minimalize_offending_overapprox (a # ff) keeps\n                              G nP))))\n                   nP\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(e1, e2)\n                                  \\<in>set\n  (minimalize_offending_overapprox (a # ff) keeps G nP).\n                            \\<not> sinvar\n                                    (add_edge e1 e2\n(delete_edges G\n  (set (minimalize_offending_overapprox (a # ff) keeps G nP))))\n                                    nP", "hence ff_in_edges: \"\\<forall>x\\<in>set ff. x \\<in> edges G\" and a_in_edges: \"a \\<in> edges G\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (a # ff). x \\<in> edges G\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set ff. x \\<in> edges G &&& a \\<in> edges G", "by simp_all"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set ff. x \\<in> edges G\n  a \\<in> edges G\n\ngoal (1 subgoal):\n 1. \\<And>a ff keeps.\n       \\<lbrakk>\\<And>keeps.\n                   \\<lbrakk>\\<forall>x\\<in>set ff. x \\<notin> set keeps;\n                    \\<forall>x\\<in>set ff. x \\<in> edges G; distinct ff;\n                    \\<forall>(e1, e2)\\<in>set keeps.\n                       \\<not> sinvar\n                               (add_edge e1 e2\n                                 (delete_edges G\n                                   (set (minimalize_offending_overapprox ff\n    keeps G nP))))\n                               nP\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(e1, e2)\n        \\<in>set (minimalize_offending_overapprox ff keeps G nP).\n  \\<not> sinvar\n          (add_edge e1 e2\n            (delete_edges G\n              (set (minimalize_offending_overapprox ff keeps G nP))))\n          nP;\n        \\<forall>x\\<in>set (a # ff). x \\<notin> set keeps;\n        \\<forall>x\\<in>set (a # ff). x \\<in> edges G; distinct (a # ff);\n        \\<forall>(e1, e2)\\<in>set keeps.\n           \\<not> sinvar\n                   (add_edge e1 e2\n                     (delete_edges G\n                       (set (minimalize_offending_overapprox (a # ff) keeps\n                              G nP))))\n                   nP\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(e1, e2)\n                                  \\<in>set\n  (minimalize_offending_overapprox (a # ff) keeps G nP).\n                            \\<not> sinvar\n                                    (add_edge e1 e2\n(delete_edges G\n  (set (minimalize_offending_overapprox (a # ff) keeps G nP))))\n                                    nP", "assume distinct: \"distinct (a # ff)\""], ["proof (state)\nthis:\n  distinct (a # ff)\n\ngoal (1 subgoal):\n 1. \\<And>a ff keeps.\n       \\<lbrakk>\\<And>keeps.\n                   \\<lbrakk>\\<forall>x\\<in>set ff. x \\<notin> set keeps;\n                    \\<forall>x\\<in>set ff. x \\<in> edges G; distinct ff;\n                    \\<forall>(e1, e2)\\<in>set keeps.\n                       \\<not> sinvar\n                               (add_edge e1 e2\n                                 (delete_edges G\n                                   (set (minimalize_offending_overapprox ff\n    keeps G nP))))\n                               nP\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(e1, e2)\n        \\<in>set (minimalize_offending_overapprox ff keeps G nP).\n  \\<not> sinvar\n          (add_edge e1 e2\n            (delete_edges G\n              (set (minimalize_offending_overapprox ff keeps G nP))))\n          nP;\n        \\<forall>x\\<in>set (a # ff). x \\<notin> set keeps;\n        \\<forall>x\\<in>set (a # ff). x \\<in> edges G; distinct (a # ff);\n        \\<forall>(e1, e2)\\<in>set keeps.\n           \\<not> sinvar\n                   (add_edge e1 e2\n                     (delete_edges G\n                       (set (minimalize_offending_overapprox (a # ff) keeps\n                              G nP))))\n                   nP\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(e1, e2)\n                                  \\<in>set\n  (minimalize_offending_overapprox (a # ff) keeps G nP).\n                            \\<not> sinvar\n                                    (add_edge e1 e2\n(delete_edges G\n  (set (minimalize_offending_overapprox (a # ff) keeps G nP))))\n                                    nP", "hence ff_distinct: \"distinct ff\" and a_not_in_ff: \"a \\<notin> set ff \""], ["proof (prove)\nusing this:\n  distinct (a # ff)\n\ngoal (1 subgoal):\n 1. distinct ff &&& a \\<notin> set ff", "by simp_all"], ["proof (state)\nthis:\n  distinct ff\n  a \\<notin> set ff\n\ngoal (1 subgoal):\n 1. \\<And>a ff keeps.\n       \\<lbrakk>\\<And>keeps.\n                   \\<lbrakk>\\<forall>x\\<in>set ff. x \\<notin> set keeps;\n                    \\<forall>x\\<in>set ff. x \\<in> edges G; distinct ff;\n                    \\<forall>(e1, e2)\\<in>set keeps.\n                       \\<not> sinvar\n                               (add_edge e1 e2\n                                 (delete_edges G\n                                   (set (minimalize_offending_overapprox ff\n    keeps G nP))))\n                               nP\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(e1, e2)\n        \\<in>set (minimalize_offending_overapprox ff keeps G nP).\n  \\<not> sinvar\n          (add_edge e1 e2\n            (delete_edges G\n              (set (minimalize_offending_overapprox ff keeps G nP))))\n          nP;\n        \\<forall>x\\<in>set (a # ff). x \\<notin> set keeps;\n        \\<forall>x\\<in>set (a # ff). x \\<in> edges G; distinct (a # ff);\n        \\<forall>(e1, e2)\\<in>set keeps.\n           \\<not> sinvar\n                   (add_edge e1 e2\n                     (delete_edges G\n                       (set (minimalize_offending_overapprox (a # ff) keeps\n                              G nP))))\n                   nP\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(e1, e2)\n                                  \\<in>set\n  (minimalize_offending_overapprox (a # ff) keeps G nP).\n                            \\<not> sinvar\n                                    (add_edge e1 e2\n(delete_edges G\n  (set (minimalize_offending_overapprox (a # ff) keeps G nP))))\n                                    nP", "assume minimal: \"\\<forall>(e1, e2)\\<in>set keeps. \n          \\<not> sinvar (add_edge e1 e2 (delete_edges G (set (minimalize_offending_overapprox (a # ff) keeps G nP)))) nP\""], ["proof (state)\nthis:\n  \\<forall>(e1, e2)\\<in>set keeps.\n     \\<not> sinvar\n             (add_edge e1 e2\n               (delete_edges G\n                 (set (minimalize_offending_overapprox (a # ff) keeps G\n                        nP))))\n             nP\n\ngoal (1 subgoal):\n 1. \\<And>a ff keeps.\n       \\<lbrakk>\\<And>keeps.\n                   \\<lbrakk>\\<forall>x\\<in>set ff. x \\<notin> set keeps;\n                    \\<forall>x\\<in>set ff. x \\<in> edges G; distinct ff;\n                    \\<forall>(e1, e2)\\<in>set keeps.\n                       \\<not> sinvar\n                               (add_edge e1 e2\n                                 (delete_edges G\n                                   (set (minimalize_offending_overapprox ff\n    keeps G nP))))\n                               nP\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(e1, e2)\n        \\<in>set (minimalize_offending_overapprox ff keeps G nP).\n  \\<not> sinvar\n          (add_edge e1 e2\n            (delete_edges G\n              (set (minimalize_offending_overapprox ff keeps G nP))))\n          nP;\n        \\<forall>x\\<in>set (a # ff). x \\<notin> set keeps;\n        \\<forall>x\\<in>set (a # ff). x \\<in> edges G; distinct (a # ff);\n        \\<forall>(e1, e2)\\<in>set keeps.\n           \\<not> sinvar\n                   (add_edge e1 e2\n                     (delete_edges G\n                       (set (minimalize_offending_overapprox (a # ff) keeps\n                              G nP))))\n                   nP\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(e1, e2)\n                                  \\<in>set\n  (minimalize_offending_overapprox (a # ff) keeps G nP).\n                            \\<not> sinvar\n                                    (add_edge e1 e2\n(delete_edges G\n  (set (minimalize_offending_overapprox (a # ff) keeps G nP))))\n                                    nP", "have delete_edges_list_union_insert: \"\\<And> f fs keep. delete_edges_list G (f#fs@keep) = delete_edges G ({f} \\<union> set fs \\<union> set keep)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f fs keep.\n       delete_edges_list G (f # fs @ keep) =\n       delete_edges G ({f} \\<union> set fs \\<union> set keep)", "by(simp add: graph_ops delete_edges_list_set)"], ["proof (state)\nthis:\n  delete_edges_list G (?f # ?fs @ ?keep) =\n  delete_edges G ({?f} \\<union> set ?fs \\<union> set ?keep)\n\ngoal (1 subgoal):\n 1. \\<And>a ff keeps.\n       \\<lbrakk>\\<And>keeps.\n                   \\<lbrakk>\\<forall>x\\<in>set ff. x \\<notin> set keeps;\n                    \\<forall>x\\<in>set ff. x \\<in> edges G; distinct ff;\n                    \\<forall>(e1, e2)\\<in>set keeps.\n                       \\<not> sinvar\n                               (add_edge e1 e2\n                                 (delete_edges G\n                                   (set (minimalize_offending_overapprox ff\n    keeps G nP))))\n                               nP\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(e1, e2)\n        \\<in>set (minimalize_offending_overapprox ff keeps G nP).\n  \\<not> sinvar\n          (add_edge e1 e2\n            (delete_edges G\n              (set (minimalize_offending_overapprox ff keeps G nP))))\n          nP;\n        \\<forall>x\\<in>set (a # ff). x \\<notin> set keeps;\n        \\<forall>x\\<in>set (a # ff). x \\<in> edges G; distinct (a # ff);\n        \\<forall>(e1, e2)\\<in>set keeps.\n           \\<not> sinvar\n                   (add_edge e1 e2\n                     (delete_edges G\n                       (set (minimalize_offending_overapprox (a # ff) keeps\n                              G nP))))\n                   nP\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(e1, e2)\n                                  \\<in>set\n  (minimalize_offending_overapprox (a # ff) keeps G nP).\n                            \\<not> sinvar\n                                    (add_edge e1 e2\n(delete_edges G\n  (set (minimalize_offending_overapprox (a # ff) keeps G nP))))\n                                    nP", "let ?goal=\"?case\" \\<comment> \\<open>we show this by case distinction\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ff keeps.\n       \\<lbrakk>\\<And>keeps.\n                   \\<lbrakk>\\<forall>x\\<in>set ff. x \\<notin> set keeps;\n                    \\<forall>x\\<in>set ff. x \\<in> edges G; distinct ff;\n                    \\<forall>(e1, e2)\\<in>set keeps.\n                       \\<not> sinvar\n                               (add_edge e1 e2\n                                 (delete_edges G\n                                   (set (minimalize_offending_overapprox ff\n    keeps G nP))))\n                               nP\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(e1, e2)\n        \\<in>set (minimalize_offending_overapprox ff keeps G nP).\n  \\<not> sinvar\n          (add_edge e1 e2\n            (delete_edges G\n              (set (minimalize_offending_overapprox ff keeps G nP))))\n          nP;\n        \\<forall>x\\<in>set (a # ff). x \\<notin> set keeps;\n        \\<forall>x\\<in>set (a # ff). x \\<in> edges G; distinct (a # ff);\n        \\<forall>(e1, e2)\\<in>set keeps.\n           \\<not> sinvar\n                   (add_edge e1 e2\n                     (delete_edges G\n                       (set (minimalize_offending_overapprox (a # ff) keeps\n                              G nP))))\n                   nP\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(e1, e2)\n                                  \\<in>set\n  (minimalize_offending_overapprox (a # ff) keeps G nP).\n                            \\<not> sinvar\n                                    (add_edge e1 e2\n(delete_edges G\n  (set (minimalize_offending_overapprox (a # ff) keeps G nP))))\n                                    nP", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G\n                         nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a # ff) keeps G\n                            nP))))\n                 nP", "proof(cases \"sinvar (delete_edges_list G (ff@keeps)) nP\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n    \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G\n                         nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a # ff) keeps G\n                            nP))))\n                 nP\n 2. \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n    \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G\n                         nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a # ff) keeps G\n                            nP))))\n                 nP", "case True"], ["proof (state)\nthis:\n  sinvar (delete_edges_list G (ff @ keeps)) nP\n\ngoal (2 subgoals):\n 1. sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n    \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G\n                         nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a # ff) keeps G\n                            nP))))\n                 nP\n 2. \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n    \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G\n                         nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a # ff) keeps G\n                            nP))))\n                 nP", "from True"], ["proof (chain)\npicking this:\n  sinvar (delete_edges_list G (ff @ keeps)) nP", "have \"sinvar (delete_edges_list G (ff@keeps)) nP\""], ["proof (prove)\nusing this:\n  sinvar (delete_edges_list G (ff @ keeps)) nP\n\ngoal (1 subgoal):\n 1. sinvar (delete_edges_list G (ff @ keeps)) nP", "."], ["proof (state)\nthis:\n  sinvar (delete_edges_list G (ff @ keeps)) nP\n\ngoal (2 subgoals):\n 1. sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n    \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G\n                         nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a # ff) keeps G\n                            nP))))\n                 nP\n 2. \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n    \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G\n                         nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a # ff) keeps G\n                            nP))))\n                 nP", "from this Cons"], ["proof (chain)\npicking this:\n  sinvar (delete_edges_list G (ff @ keeps)) nP\n  \\<lbrakk>\\<forall>x\\<in>set ff. x \\<notin> set ?keeps;\n   \\<forall>x\\<in>set ff. x \\<in> edges G; distinct ff;\n   \\<forall>a\\<in>set ?keeps.\n      case a of\n      (e1, e2) \\<Rightarrow>\n        \\<not> sinvar\n                (add_edge e1 e2\n                  (delete_edges G\n                    (set (minimalize_offending_overapprox ff ?keeps G nP))))\n                nP\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set (minimalize_offending_overapprox ff\n   ?keeps G nP).\n                       case a of\n                       (e1, e2) \\<Rightarrow>\n                         \\<not> sinvar\n                                 (add_edge e1 e2\n                                   (delete_edges G\n                                     (set\n (minimalize_offending_overapprox ff ?keeps G nP))))\n                                 nP\n  \\<forall>x\\<in>set (a # ff). x \\<notin> set keeps\n  \\<forall>x\\<in>set (a # ff). x \\<in> edges G\n  distinct (a # ff)\n  \\<forall>b\\<in>set keeps.\n     case b of\n     (e1, e2) \\<Rightarrow>\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges G\n                   (set (minimalize_offending_overapprox (a # ff) keeps G\n                          nP))))\n               nP", "show ?goal"], ["proof (prove)\nusing this:\n  sinvar (delete_edges_list G (ff @ keeps)) nP\n  \\<lbrakk>\\<forall>x\\<in>set ff. x \\<notin> set ?keeps;\n   \\<forall>x\\<in>set ff. x \\<in> edges G; distinct ff;\n   \\<forall>a\\<in>set ?keeps.\n      case a of\n      (e1, e2) \\<Rightarrow>\n        \\<not> sinvar\n                (add_edge e1 e2\n                  (delete_edges G\n                    (set (minimalize_offending_overapprox ff ?keeps G nP))))\n                nP\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set (minimalize_offending_overapprox ff\n   ?keeps G nP).\n                       case a of\n                       (e1, e2) \\<Rightarrow>\n                         \\<not> sinvar\n                                 (add_edge e1 e2\n                                   (delete_edges G\n                                     (set\n (minimalize_offending_overapprox ff ?keeps G nP))))\n                                 nP\n  \\<forall>x\\<in>set (a # ff). x \\<notin> set keeps\n  \\<forall>x\\<in>set (a # ff). x \\<in> edges G\n  distinct (a # ff)\n  \\<forall>b\\<in>set keeps.\n     case b of\n     (e1, e2) \\<Rightarrow>\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges G\n                   (set (minimalize_offending_overapprox (a # ff) keeps G\n                          nP))))\n               nP\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G\n                         nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a # ff) keeps G\n                            nP))))\n                 nP", "using delete_edges_list_union"], ["proof (prove)\nusing this:\n  sinvar (delete_edges_list G (ff @ keeps)) nP\n  \\<lbrakk>\\<forall>x\\<in>set ff. x \\<notin> set ?keeps;\n   \\<forall>x\\<in>set ff. x \\<in> edges G; distinct ff;\n   \\<forall>a\\<in>set ?keeps.\n      case a of\n      (e1, e2) \\<Rightarrow>\n        \\<not> sinvar\n                (add_edge e1 e2\n                  (delete_edges G\n                    (set (minimalize_offending_overapprox ff ?keeps G nP))))\n                nP\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set (minimalize_offending_overapprox ff\n   ?keeps G nP).\n                       case a of\n                       (e1, e2) \\<Rightarrow>\n                         \\<not> sinvar\n                                 (add_edge e1 e2\n                                   (delete_edges G\n                                     (set\n (minimalize_offending_overapprox ff ?keeps G nP))))\n                                 nP\n  \\<forall>x\\<in>set (a # ff). x \\<notin> set keeps\n  \\<forall>x\\<in>set (a # ff). x \\<in> edges G\n  distinct (a # ff)\n  \\<forall>b\\<in>set keeps.\n     case b of\n     (e1, e2) \\<Rightarrow>\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges G\n                   (set (minimalize_offending_overapprox (a # ff) keeps G\n                          nP))))\n               nP\n  delete_edges_list ?G (?ff @ ?keeps) =\n  delete_edges ?G (set ?ff \\<union> set ?keeps)\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G\n                         nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a # ff) keeps G\n                            nP))))\n                 nP", "by simp"], ["proof (state)\nthis:\n  \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G nP).\n     case b of\n     (e1, e2) \\<Rightarrow>\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges G\n                   (set (minimalize_offending_overapprox (a # ff) keeps G\n                          nP))))\n               nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n    \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G\n                         nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a # ff) keeps G\n                            nP))))\n                 nP", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n    \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G\n                         nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a # ff) keeps G\n                            nP))))\n                 nP", "case False"], ["proof (state)\nthis:\n  \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n    \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G\n                         nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a # ff) keeps G\n                            nP))))\n                 nP", "(*MONO=Cons.prems(1)\"*)"], ["proof (state)\nthis:\n  \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n    \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G\n                         nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a # ff) keeps G\n                            nP))))\n                 nP", "{ \\<comment> \\<open>a lemma we only need once here\\<close>"], ["proof (state)\nthis:\n  \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n    \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G\n                         nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a # ff) keeps G\n                            nP))))\n                 nP", "fix a ff keeps"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges_list G (ffb__ @ keepsa__))\n            nP \\<Longrightarrow>\n    \\<forall>b\\<in>set (minimalize_offending_overapprox (a__ # ffb__)\n                         keepsa__ G nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a__ # ffb__)\n                            keepsa__ G nP))))\n                 nP", "assume mono: \"sinvar_mono\" and ankeeps: \"a \\<notin> set keeps\"\n              and anff: \"a \\<notin> set ff\" and aE: \"a \\<in> edges G\"\n              and nsinvar: \"\\<not> sinvar (delete_edges_list G (ff @ keeps)) nP\""], ["proof (state)\nthis:\n  sinvar_mono\n  a \\<notin> set keeps\n  a \\<notin> set ff\n  a \\<in> edges G\n  \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges_list G (ffb__ @ keepsa__))\n            nP \\<Longrightarrow>\n    \\<forall>b\\<in>set (minimalize_offending_overapprox (a__ # ffb__)\n                         keepsa__ G nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a__ # ffb__)\n                            keepsa__ G nP))))\n                 nP", "have \"\\<not> sinvar (add_edge (fst a) (snd a) (delete_edges G (set (minimalize_offending_overapprox (a # ff) keeps G nP)))) nP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            (add_edge (fst a) (snd a)\n              (delete_edges G\n                (set (minimalize_offending_overapprox (a # ff) keeps G\n                       nP))))\n            nP", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            (add_edge (fst a) (snd a)\n              (delete_edges G\n                (set (minimalize_offending_overapprox (a # ff) keeps G\n                       nP))))\n            nP", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            (add_edge (fst a) (snd a)\n              (delete_edges G\n                (set (minimalize_offending_overapprox (a # ff) keeps G\n                       nP))))\n            nP", "fix F Fs keep"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            (add_edge (fst a) (snd a)\n              (delete_edges G\n                (set (minimalize_offending_overapprox (a # ff) keeps G\n                       nP))))\n            nP", "from vG"], ["proof (chain)\npicking this:\n  wf_graph G", "have \"F \\<in> edges G \\<Longrightarrow> F \\<notin> set Fs \\<Longrightarrow> F \\<notin> set keep \\<Longrightarrow>\n                    (add_edge (fst F) (snd F) (delete_edges_list G (F#Fs@keep))) = (delete_edges_list G (Fs@keep))\""], ["proof (prove)\nusing this:\n  wf_graph G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>F \\<in> edges G; F \\<notin> set Fs;\n     F \\<notin> set keep\\<rbrakk>\n    \\<Longrightarrow> add_edge (fst F) (snd F)\n                       (delete_edges_list G (F # Fs @ keep)) =\n                      delete_edges_list G (Fs @ keep)", "apply(simp add:delete_edges_list_union delete_edges_list_union_insert)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>F \\<in> edges G; F \\<notin> set Fs; F \\<notin> set keep;\n     wf_graph G\\<rbrakk>\n    \\<Longrightarrow> add_edge (fst F) (snd F)\n                       (delete_edges G\n                         (insert F (set Fs \\<union> set keep))) =\n                      delete_edges G (set Fs \\<union> set keep)", "apply(simp add: graph_ops)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>F \\<in> edges G; F \\<notin> set Fs; F \\<notin> set keep;\n     wf_graph G\\<rbrakk>\n    \\<Longrightarrow> insert (fst F) (insert (snd F) (nodes G)) =\n                      nodes G \\<and>\n                      insert F\n                       (edges G - insert F (set Fs \\<union> set keep)) =\n                      edges G - (set Fs \\<union> set keep)", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<in> edges G; F \\<notin> set Fs; F \\<notin> set keep;\n     wf_graph G\\<rbrakk>\n    \\<Longrightarrow> insert (fst F) (insert (snd F) (nodes G)) = nodes G\n 2. \\<lbrakk>F \\<in> edges G; F \\<notin> set Fs; F \\<notin> set keep;\n     wf_graph G\\<rbrakk>\n    \\<Longrightarrow> insert F\n                       (edges G - insert F (set Fs \\<union> set keep)) =\n                      edges G - (set Fs \\<union> set keep)", "apply(simp add: wf_graph_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>F \\<in> edges G; F \\<notin> set Fs; F \\<notin> set keep;\n     fst ` edges G \\<subseteq> nodes G \\<and>\n     snd ` edges G \\<subseteq> nodes G \\<and>\n     finite (edges G) \\<and> finite (nodes G)\\<rbrakk>\n    \\<Longrightarrow> insert (fst F) (insert (snd F) (nodes G)) = nodes G\n 2. \\<lbrakk>F \\<in> edges G; F \\<notin> set Fs; F \\<notin> set keep;\n     wf_graph G\\<rbrakk>\n    \\<Longrightarrow> insert F\n                       (edges G - insert F (set Fs \\<union> set keep)) =\n                      edges G - (set Fs \\<union> set keep)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>F \\<in> edges G; F \\<notin> set Fs; F \\<notin> set keep;\n     wf_graph G\\<rbrakk>\n    \\<Longrightarrow> insert F\n                       (edges G - insert F (set Fs \\<union> set keep)) =\n                      edges G - (set Fs \\<union> set keep)", "apply(simp add: wf_graph_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>F \\<in> edges G; F \\<notin> set Fs; F \\<notin> set keep;\n     fst ` edges G \\<subseteq> nodes G \\<and>\n     snd ` edges G \\<subseteq> nodes G \\<and>\n     finite (edges G) \\<and> finite (nodes G)\\<rbrakk>\n    \\<Longrightarrow> insert F\n                       (edges G - insert F (set Fs \\<union> set keep)) =\n                      edges G - (set Fs \\<union> set keep)", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>F \\<in> edges G; F \\<notin> set Fs; F \\<notin> set keep\\<rbrakk>\n  \\<Longrightarrow> add_edge (fst F) (snd F)\n                     (delete_edges_list G (F # Fs @ keep)) =\n                    delete_edges_list G (Fs @ keep)\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            (add_edge (fst a) (snd a)\n              (delete_edges G\n                (set (minimalize_offending_overapprox (a # ff) keeps G\n                       nP))))\n            nP", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?F2 \\<in> edges G; ?F2 \\<notin> set ?Fs2;\n   ?F2 \\<notin> set ?keep2\\<rbrakk>\n  \\<Longrightarrow> add_edge (fst ?F2) (snd ?F2)\n                     (delete_edges_list G (?F2 # ?Fs2 @ ?keep2)) =\n                    delete_edges_list G (?Fs2 @ ?keep2)\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            (add_edge (fst a) (snd a)\n              (delete_edges G\n                (set (minimalize_offending_overapprox (a # ff) keeps G\n                       nP))))\n            nP", "note delete_edges_list_add_add_iff=this"], ["proof (state)\nthis:\n  \\<lbrakk>?F2 \\<in> edges G; ?F2 \\<notin> set ?Fs2;\n   ?F2 \\<notin> set ?keep2\\<rbrakk>\n  \\<Longrightarrow> add_edge (fst ?F2) (snd ?F2)\n                     (delete_edges_list G (?F2 # ?Fs2 @ ?keep2)) =\n                    delete_edges_list G (?Fs2 @ ?keep2)\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            (add_edge (fst a) (snd a)\n              (delete_edges G\n                (set (minimalize_offending_overapprox (a # ff) keeps G\n                       nP))))\n            nP", "from aE"], ["proof (chain)\npicking this:\n  a \\<in> edges G", "have \"(fst a, snd a) \\<in> edges G\""], ["proof (prove)\nusing this:\n  a \\<in> edges G\n\ngoal (1 subgoal):\n 1. (fst a, snd a) \\<in> edges G", "by simp"], ["proof (state)\nthis:\n  (fst a, snd a) \\<in> edges G\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            (add_edge (fst a) (snd a)\n              (delete_edges G\n                (set (minimalize_offending_overapprox (a # ff) keeps G\n                       nP))))\n            nP", "from delete_edges_list_add_add_iff[of a ff keeps]"], ["proof (chain)\npicking this:\n  \\<lbrakk>a \\<in> edges G; a \\<notin> set ff; a \\<notin> set keeps\\<rbrakk>\n  \\<Longrightarrow> add_edge (fst a) (snd a)\n                     (delete_edges_list G (a # ff @ keeps)) =\n                    delete_edges_list G (ff @ keeps)", "have\n                  \"delete_edges_list G (ff @ keeps) = add_edge (fst a) (snd a) (delete_edges_list G (a # ff @ keeps))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<in> edges G; a \\<notin> set ff; a \\<notin> set keeps\\<rbrakk>\n  \\<Longrightarrow> add_edge (fst a) (snd a)\n                     (delete_edges_list G (a # ff @ keeps)) =\n                    delete_edges_list G (ff @ keeps)\n\ngoal (1 subgoal):\n 1. delete_edges_list G (ff @ keeps) =\n    add_edge (fst a) (snd a) (delete_edges_list G (a # ff @ keeps))", "by (metis aE anff ankeeps)"], ["proof (state)\nthis:\n  delete_edges_list G (ff @ keeps) =\n  add_edge (fst a) (snd a) (delete_edges_list G (a # ff @ keeps))\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            (add_edge (fst a) (snd a)\n              (delete_edges G\n                (set (minimalize_offending_overapprox (a # ff) keeps G\n                       nP))))\n            nP", "from this nsinvar"], ["proof (chain)\npicking this:\n  delete_edges_list G (ff @ keeps) =\n  add_edge (fst a) (snd a) (delete_edges_list G (a # ff @ keeps))\n  \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP", "have \"\\<not> sinvar (add_edge (fst a) (snd a) (delete_edges_list G (a # ff @ keeps))) nP\""], ["proof (prove)\nusing this:\n  delete_edges_list G (ff @ keeps) =\n  add_edge (fst a) (snd a) (delete_edges_list G (a # ff @ keeps))\n  \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            (add_edge (fst a) (snd a)\n              (delete_edges_list G (a # ff @ keeps)))\n            nP", "by simp"], ["proof (state)\nthis:\n  \\<not> sinvar\n          (add_edge (fst a) (snd a) (delete_edges_list G (a # ff @ keeps)))\n          nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            (add_edge (fst a) (snd a)\n              (delete_edges G\n                (set (minimalize_offending_overapprox (a # ff) keeps G\n                       nP))))\n            nP", "from this delete_edges_list_union_insert"], ["proof (chain)\npicking this:\n  \\<not> sinvar\n          (add_edge (fst a) (snd a) (delete_edges_list G (a # ff @ keeps)))\n          nP\n  delete_edges_list G (?f # ?fs @ ?keep) =\n  delete_edges G ({?f} \\<union> set ?fs \\<union> set ?keep)", "have 1:\n                  \"\\<not> sinvar (add_edge (fst a) (snd a) (delete_edges G (insert a (set ff \\<union> set keeps)))) nP\""], ["proof (prove)\nusing this:\n  \\<not> sinvar\n          (add_edge (fst a) (snd a) (delete_edges_list G (a # ff @ keeps)))\n          nP\n  delete_edges_list G (?f # ?fs @ ?keep) =\n  delete_edges G ({?f} \\<union> set ?fs \\<union> set ?keep)\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            (add_edge (fst a) (snd a)\n              (delete_edges G (insert a (set ff \\<union> set keeps))))\n            nP", "by (metis insert_is_Un sup_assoc)"], ["proof (state)\nthis:\n  \\<not> sinvar\n          (add_edge (fst a) (snd a)\n            (delete_edges G (insert a (set ff \\<union> set keeps))))\n          nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            (add_edge (fst a) (snd a)\n              (delete_edges G\n                (set (minimalize_offending_overapprox (a # ff) keeps G\n                       nP))))\n            nP", "from minimalize_offending_overapprox_subset[of \"ff\" \"a#keeps\" G nP]"], ["proof (chain)\npicking this:\n  set (minimalize_offending_overapprox ff (a # keeps) G nP)\n  \\<subseteq> set ff \\<union> set (a # keeps)", "have\n                  \"set (minimalize_offending_overapprox ff (a # keeps) G nP) \\<subseteq> insert a (set ff \\<union> set keeps)\""], ["proof (prove)\nusing this:\n  set (minimalize_offending_overapprox ff (a # keeps) G nP)\n  \\<subseteq> set ff \\<union> set (a # keeps)\n\ngoal (1 subgoal):\n 1. set (minimalize_offending_overapprox ff (a # keeps) G nP)\n    \\<subseteq> insert a (set ff \\<union> set keeps)", "by simp"], ["proof (state)\nthis:\n  set (minimalize_offending_overapprox ff (a # keeps) G nP)\n  \\<subseteq> insert a (set ff \\<union> set keeps)\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            (add_edge (fst a) (snd a)\n              (delete_edges G\n                (set (minimalize_offending_overapprox (a # ff) keeps G\n                       nP))))\n            nP", "from not_model_mono_imp_addedge_mono[OF mono vG \\<open>(fst a, snd a) \\<in> edges G\\<close> this 1]"], ["proof (chain)\npicking this:\n  \\<not> sinvar\n          (add_edge (fst a) (snd a)\n            (delete_edges G\n              (set (minimalize_offending_overapprox ff (a # keeps) G nP))))\n          nP", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> sinvar\n          (add_edge (fst a) (snd a)\n            (delete_edges G\n              (set (minimalize_offending_overapprox ff (a # keeps) G nP))))\n          nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            (add_edge (fst a) (snd a)\n              (delete_edges G\n                (set (minimalize_offending_overapprox (a # ff) keeps G\n                       nP))))\n            nP", "by (metis minimalize_offending_overapprox.simps(2) nsinvar)"], ["proof (state)\nthis:\n  \\<not> sinvar\n          (add_edge (fst a) (snd a)\n            (delete_edges G\n              (set (minimalize_offending_overapprox (a # ff) keeps G nP))))\n          nP\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> sinvar\n          (add_edge (fst a) (snd a)\n            (delete_edges G\n              (set (minimalize_offending_overapprox (a # ff) keeps G nP))))\n          nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges_list G (ffb__ @ keepsa__))\n            nP \\<Longrightarrow>\n    \\<forall>b\\<in>set (minimalize_offending_overapprox (a__ # ffb__)\n                         keepsa__ G nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a__ # ffb__)\n                            keepsa__ G nP))))\n                 nP", "}"], ["proof (state)\nthis:\n  \\<lbrakk>sinvar_mono; ?aa2 \\<notin> set ?keepsb2; ?aa2 \\<notin> set ?ffc2;\n   ?aa2 \\<in> edges G;\n   \\<not> sinvar (delete_edges_list G (?ffc2 @ ?keepsb2)) nP\\<rbrakk>\n  \\<Longrightarrow> \\<not> sinvar\n                            (add_edge (fst ?aa2) (snd ?aa2)\n                              (delete_edges G\n                                (set (minimalize_offending_overapprox\n (?aa2 # ?ffc2) ?keepsb2 G nP))))\n                            nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n    \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G\n                         nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a # ff) keeps G\n                            nP))))\n                 nP", "note not_model_mono_imp_addedge_mono_minimalize_offending_overapprox=this"], ["proof (state)\nthis:\n  \\<lbrakk>sinvar_mono; ?aa2 \\<notin> set ?keepsb2; ?aa2 \\<notin> set ?ffc2;\n   ?aa2 \\<in> edges G;\n   \\<not> sinvar (delete_edges_list G (?ffc2 @ ?keepsb2)) nP\\<rbrakk>\n  \\<Longrightarrow> \\<not> sinvar\n                            (add_edge (fst ?aa2) (snd ?aa2)\n                              (delete_edges G\n                                (set (minimalize_offending_overapprox\n (?aa2 # ?ffc2) ?keepsb2 G nP))))\n                            nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n    \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G\n                         nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a # ff) keeps G\n                            nP))))\n                 nP", "from not_model_mono_imp_addedge_mono_minimalize_offending_overapprox[OF mono a_not_in_keeps a_not_in_ff a_in_edges False]"], ["proof (chain)\npicking this:\n  \\<not> sinvar\n          (add_edge (fst a) (snd a)\n            (delete_edges G\n              (set (minimalize_offending_overapprox (a # ff) keeps G nP))))\n          nP", "have a_minimal: \"\n          \\<not> sinvar (add_edge (fst a) (snd a) (delete_edges G (set (minimalize_offending_overapprox (a # ff) keeps G nP)))) nP\""], ["proof (prove)\nusing this:\n  \\<not> sinvar\n          (add_edge (fst a) (snd a)\n            (delete_edges G\n              (set (minimalize_offending_overapprox (a # ff) keeps G nP))))\n          nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            (add_edge (fst a) (snd a)\n              (delete_edges G\n                (set (minimalize_offending_overapprox (a # ff) keeps G\n                       nP))))\n            nP", "by simp"], ["proof (state)\nthis:\n  \\<not> sinvar\n          (add_edge (fst a) (snd a)\n            (delete_edges G\n              (set (minimalize_offending_overapprox (a # ff) keeps G nP))))\n          nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n    \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G\n                         nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a # ff) keeps G\n                            nP))))\n                 nP", "from minimal a_minimal"], ["proof (chain)\npicking this:\n  \\<forall>(e1, e2)\\<in>set keeps.\n     \\<not> sinvar\n             (add_edge e1 e2\n               (delete_edges G\n                 (set (minimalize_offending_overapprox (a # ff) keeps G\n                        nP))))\n             nP\n  \\<not> sinvar\n          (add_edge (fst a) (snd a)\n            (delete_edges G\n              (set (minimalize_offending_overapprox (a # ff) keeps G nP))))\n          nP", "have a_keeps_minimal: \"\\<forall>(e1, e2)\\<in>set (a # keeps). \n          \\<not> sinvar (add_edge e1 e2 (delete_edges G (set (minimalize_offending_overapprox ff (a # keeps) G nP)))) nP\""], ["proof (prove)\nusing this:\n  \\<forall>(e1, e2)\\<in>set keeps.\n     \\<not> sinvar\n             (add_edge e1 e2\n               (delete_edges G\n                 (set (minimalize_offending_overapprox (a # ff) keeps G\n                        nP))))\n             nP\n  \\<not> sinvar\n          (add_edge (fst a) (snd a)\n            (delete_edges G\n              (set (minimalize_offending_overapprox (a # ff) keeps G nP))))\n          nP\n\ngoal (1 subgoal):\n 1. \\<forall>(e1, e2)\\<in>set (a # keeps).\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges G\n                   (set (minimalize_offending_overapprox ff (a # keeps) G\n                          nP))))\n               nP", "using False"], ["proof (prove)\nusing this:\n  \\<forall>(e1, e2)\\<in>set keeps.\n     \\<not> sinvar\n             (add_edge e1 e2\n               (delete_edges G\n                 (set (minimalize_offending_overapprox (a # ff) keeps G\n                        nP))))\n             nP\n  \\<not> sinvar\n          (add_edge (fst a) (snd a)\n            (delete_edges G\n              (set (minimalize_offending_overapprox (a # ff) keeps G nP))))\n          nP\n  \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP\n\ngoal (1 subgoal):\n 1. \\<forall>(e1, e2)\\<in>set (a # keeps).\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges G\n                   (set (minimalize_offending_overapprox ff (a # keeps) G\n                          nP))))\n               nP", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>(e1, e2)\\<in>set (a # keeps).\n     \\<not> sinvar\n             (add_edge e1 e2\n               (delete_edges G\n                 (set (minimalize_offending_overapprox ff (a # keeps) G\n                        nP))))\n             nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n    \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G\n                         nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a # ff) keeps G\n                            nP))))\n                 nP", "from Cons.prems"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set (a # ff). x \\<notin> set keeps\n  \\<forall>x\\<in>set (a # ff). x \\<in> edges G\n  distinct (a # ff)\n  \\<forall>b\\<in>set keeps.\n     case b of\n     (e1, e2) \\<Rightarrow>\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges G\n                   (set (minimalize_offending_overapprox (a # ff) keeps G\n                          nP))))\n               nP", "have a_not_in_keeps: \"\\<forall>x\\<in>set ff. x \\<notin> set (a#keeps)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (a # ff). x \\<notin> set keeps\n  \\<forall>x\\<in>set (a # ff). x \\<in> edges G\n  distinct (a # ff)\n  \\<forall>b\\<in>set keeps.\n     case b of\n     (e1, e2) \\<Rightarrow>\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges G\n                   (set (minimalize_offending_overapprox (a # ff) keeps G\n                          nP))))\n               nP\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set ff. x \\<notin> set (a # keeps)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set ff. x \\<notin> set (a # keeps)\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n    \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G\n                         nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a # ff) keeps G\n                            nP))))\n                 nP", "from Cons.IH[OF a_not_in_keeps ff_in_edges ff_distinct a_keeps_minimal]"], ["proof (chain)\npicking this:\n  \\<forall>b\\<in>set (minimalize_offending_overapprox ff (a # keeps) G nP).\n     case b of\n     (e1, e2) \\<Rightarrow>\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges G\n                   (set (minimalize_offending_overapprox ff (a # keeps) G\n                          nP))))\n               nP", "have IH:\n            \"\\<forall>(e1, e2)\\<in>set (minimalize_offending_overapprox ff (a # keeps) G nP).\n           \\<not> sinvar (add_edge e1 e2 (delete_edges G (set (minimalize_offending_overapprox ff (a # keeps) G nP)))) nP\""], ["proof (prove)\nusing this:\n  \\<forall>b\\<in>set (minimalize_offending_overapprox ff (a # keeps) G nP).\n     case b of\n     (e1, e2) \\<Rightarrow>\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges G\n                   (set (minimalize_offending_overapprox ff (a # keeps) G\n                          nP))))\n               nP\n\ngoal (1 subgoal):\n 1. \\<forall>(e1, e2)\n             \\<in>set (minimalize_offending_overapprox ff (a # keeps) G nP).\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges G\n                   (set (minimalize_offending_overapprox ff (a # keeps) G\n                          nP))))\n               nP", "."], ["proof (state)\nthis:\n  \\<forall>(e1, e2)\n           \\<in>set (minimalize_offending_overapprox ff (a # keeps) G nP).\n     \\<not> sinvar\n             (add_edge e1 e2\n               (delete_edges G\n                 (set (minimalize_offending_overapprox ff (a # keeps) G\n                        nP))))\n             nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n    \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G\n                         nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a # ff) keeps G\n                            nP))))\n                 nP", "from False"], ["proof (chain)\npicking this:\n  \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP", "have \"\\<not> sinvar (delete_edges G (set ff \\<union> set keeps)) nP \""], ["proof (prove)\nusing this:\n  \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges G (set ff \\<union> set keeps)) nP", "using delete_edges_list_union"], ["proof (prove)\nusing this:\n  \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP\n  delete_edges_list ?G (?ff @ ?keeps) =\n  delete_edges ?G (set ?ff \\<union> set ?keeps)\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges G (set ff \\<union> set keeps)) nP", "by metis"], ["proof (state)\nthis:\n  \\<not> sinvar (delete_edges G (set ff \\<union> set keeps)) nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n    \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G\n                         nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a # ff) keeps G\n                            nP))))\n                 nP", "from this"], ["proof (chain)\npicking this:\n  \\<not> sinvar (delete_edges G (set ff \\<union> set keeps)) nP", "have \"set (minimalize_offending_overapprox (a # ff) keeps G nP) = \n            set (minimalize_offending_overapprox ff (a#keeps) G nP)\""], ["proof (prove)\nusing this:\n  \\<not> sinvar (delete_edges G (set ff \\<union> set keeps)) nP\n\ngoal (1 subgoal):\n 1. set (minimalize_offending_overapprox (a # ff) keeps G nP) =\n    set (minimalize_offending_overapprox ff (a # keeps) G nP)", "by(simp add: delete_edges_list_union)"], ["proof (state)\nthis:\n  set (minimalize_offending_overapprox (a # ff) keeps G nP) =\n  set (minimalize_offending_overapprox ff (a # keeps) G nP)\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n    \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G\n                         nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a # ff) keeps G\n                            nP))))\n                 nP", "from this IH"], ["proof (chain)\npicking this:\n  set (minimalize_offending_overapprox (a # ff) keeps G nP) =\n  set (minimalize_offending_overapprox ff (a # keeps) G nP)\n  \\<forall>(e1, e2)\n           \\<in>set (minimalize_offending_overapprox ff (a # keeps) G nP).\n     \\<not> sinvar\n             (add_edge e1 e2\n               (delete_edges G\n                 (set (minimalize_offending_overapprox ff (a # keeps) G\n                        nP))))\n             nP", "have ?goal"], ["proof (prove)\nusing this:\n  set (minimalize_offending_overapprox (a # ff) keeps G nP) =\n  set (minimalize_offending_overapprox ff (a # keeps) G nP)\n  \\<forall>(e1, e2)\n           \\<in>set (minimalize_offending_overapprox ff (a # keeps) G nP).\n     \\<not> sinvar\n             (add_edge e1 e2\n               (delete_edges G\n                 (set (minimalize_offending_overapprox ff (a # keeps) G\n                        nP))))\n             nP\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G\n                         nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a # ff) keeps G\n                            nP))))\n                 nP", "by presburger"], ["proof (state)\nthis:\n  \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G nP).\n     case b of\n     (e1, e2) \\<Rightarrow>\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges G\n                   (set (minimalize_offending_overapprox (a # ff) keeps G\n                          nP))))\n               nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges_list G (ff @ keeps)) nP \\<Longrightarrow>\n    \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G\n                         nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a # ff) keeps G\n                            nP))))\n                 nP", "thus ?goal"], ["proof (prove)\nusing this:\n  \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G nP).\n     case b of\n     (e1, e2) \\<Rightarrow>\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges G\n                   (set (minimalize_offending_overapprox (a # ff) keeps G\n                          nP))))\n               nP\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G\n                         nP).\n       case b of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 (add_edge e1 e2\n                   (delete_edges G\n                     (set (minimalize_offending_overapprox (a # ff) keeps G\n                            nP))))\n                 nP", "."], ["proof (state)\nthis:\n  \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G nP).\n     case b of\n     (e1, e2) \\<Rightarrow>\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges G\n                   (set (minimalize_offending_overapprox (a # ff) keeps G\n                          nP))))\n               nP\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>b\\<in>set (minimalize_offending_overapprox (a # ff) keeps G nP).\n     case b of\n     (e1, e2) \\<Rightarrow>\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges G\n                   (set (minimalize_offending_overapprox (a # ff) keeps G\n                          nP))))\n               nP\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x\\<in>set ff. x \\<notin> set keeps;\n   \\<forall>x\\<in>set ff. x \\<in> edges G; distinct ff;\n   \\<forall>(e1, e2)\\<in>set keeps.\n      \\<not> sinvar\n              (add_edge e1 e2\n                (delete_edges G\n                  (set (minimalize_offending_overapprox ff keeps G nP))))\n              nP\\<rbrakk>\n  \\<Longrightarrow> \\<forall>(e1, e2)\n                             \\<in>set (minimalize_offending_overapprox ff\n  keeps G nP).\n                       \\<not> sinvar\n                               (add_edge e1 e2\n                                 (delete_edges G\n                                   (set (minimalize_offending_overapprox ff\n    keeps G nP))))\n                               nP\n\ngoal (1 subgoal):\n 1. is_offending_flows_min_set\n     (set (minimalize_offending_overapprox ff [] G nP)) G nP", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x\\<in>set ?ffa2. x \\<notin> set ?keeps2;\n   \\<forall>x\\<in>set ?ffa2. x \\<in> edges G; distinct ?ffa2;\n   \\<forall>(e1, e2)\\<in>set ?keeps2.\n      \\<not> sinvar\n              (add_edge e1 e2\n                (delete_edges G\n                  (set (minimalize_offending_overapprox ?ffa2 ?keeps2 G\n                         nP))))\n              nP\\<rbrakk>\n  \\<Longrightarrow> \\<forall>(e1, e2)\n                             \\<in>set (minimalize_offending_overapprox ?ffa2\n  ?keeps2 G nP).\n                       \\<not> sinvar\n                               (add_edge e1 e2\n                                 (delete_edges G\n                                   (set (minimalize_offending_overapprox\n    ?ffa2 ?keeps2 G nP))))\n                               nP\n\ngoal (1 subgoal):\n 1. is_offending_flows_min_set\n     (set (minimalize_offending_overapprox ff [] G nP)) G nP", "note mono_imp_minimalize_offending_overapprox_minimal=this[of ff \"[]\"]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x\\<in>set ff. x \\<notin> set [];\n   \\<forall>x\\<in>set ff. x \\<in> edges G; distinct ff;\n   \\<forall>(e1, e2)\\<in>set [].\n      \\<not> sinvar\n              (add_edge e1 e2\n                (delete_edges G\n                  (set (minimalize_offending_overapprox ff [] G nP))))\n              nP\\<rbrakk>\n  \\<Longrightarrow> \\<forall>(e1, e2)\n                             \\<in>set (minimalize_offending_overapprox ff []\n  G nP).\n                       \\<not> sinvar\n                               (add_edge e1 e2\n                                 (delete_edges G\n                                   (set (minimalize_offending_overapprox ff\n    [] G nP))))\n                               nP\n\ngoal (1 subgoal):\n 1. is_offending_flows_min_set\n     (set (minimalize_offending_overapprox ff [] G nP)) G nP", "from mono_imp_minimalize_offending_overapprox_minimal[OF _ _ dF] sF"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>x\\<in>set ff. x \\<notin> set [];\n   \\<forall>x\\<in>set ff. x \\<in> edges G;\n   \\<forall>(e1, e2)\\<in>set [].\n      \\<not> sinvar\n              (add_edge e1 e2\n                (delete_edges G\n                  (set (minimalize_offending_overapprox ff [] G nP))))\n              nP\\<rbrakk>\n  \\<Longrightarrow> \\<forall>(e1, e2)\n                             \\<in>set (minimalize_offending_overapprox ff []\n  G nP).\n                       \\<not> sinvar\n                               (add_edge e1 e2\n                                 (delete_edges G\n                                   (set (minimalize_offending_overapprox ff\n    [] G nP))))\n                               nP\n  set ff \\<subseteq> edges G", "have 2:\n      \"\\<forall>(e1, e2)\\<in>?minset. \\<not> sinvar (add_edge e1 e2 (delete_edges G ?minset)) nP\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>x\\<in>set ff. x \\<notin> set [];\n   \\<forall>x\\<in>set ff. x \\<in> edges G;\n   \\<forall>(e1, e2)\\<in>set [].\n      \\<not> sinvar\n              (add_edge e1 e2\n                (delete_edges G\n                  (set (minimalize_offending_overapprox ff [] G nP))))\n              nP\\<rbrakk>\n  \\<Longrightarrow> \\<forall>(e1, e2)\n                             \\<in>set (minimalize_offending_overapprox ff []\n  G nP).\n                       \\<not> sinvar\n                               (add_edge e1 e2\n                                 (delete_edges G\n                                   (set (minimalize_offending_overapprox ff\n    [] G nP))))\n                               nP\n  set ff \\<subseteq> edges G\n\ngoal (1 subgoal):\n 1. \\<forall>(e1, e2)\\<in>set (minimalize_offending_overapprox ff [] G nP).\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges G\n                   (set (minimalize_offending_overapprox ff [] G nP))))\n               nP", "by auto"], ["proof (state)\nthis:\n  \\<forall>(e1, e2)\\<in>set (minimalize_offending_overapprox ff [] G nP).\n     \\<not> sinvar\n             (add_edge e1 e2\n               (delete_edges G\n                 (set (minimalize_offending_overapprox ff [] G nP))))\n             nP\n\ngoal (1 subgoal):\n 1. is_offending_flows_min_set\n     (set (minimalize_offending_overapprox ff [] G nP)) G nP", "from 1 2"], ["proof (chain)\npicking this:\n  is_offending_flows (set (minimalize_offending_overapprox ff [] G nP)) G nP\n  \\<forall>(e1, e2)\\<in>set (minimalize_offending_overapprox ff [] G nP).\n     \\<not> sinvar\n             (add_edge e1 e2\n               (delete_edges G\n                 (set (minimalize_offending_overapprox ff [] G nP))))\n             nP", "show ?thesis"], ["proof (prove)\nusing this:\n  is_offending_flows (set (minimalize_offending_overapprox ff [] G nP)) G nP\n  \\<forall>(e1, e2)\\<in>set (minimalize_offending_overapprox ff [] G nP).\n     \\<not> sinvar\n             (add_edge e1 e2\n               (delete_edges G\n                 (set (minimalize_offending_overapprox ff [] G nP))))\n             nP\n\ngoal (1 subgoal):\n 1. is_offending_flows_min_set\n     (set (minimalize_offending_overapprox ff [] G nP)) G nP", "by(simp add: is_offending_flows_def is_offending_flows_min_set_def)"], ["proof (state)\nthis:\n  is_offending_flows_min_set\n   (set (minimalize_offending_overapprox ff [] G nP)) G nP\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary mono_imp_set_offending_flows_not_empty:\n  assumes mono_sinvar: \"sinvar_mono\"\n  and vG: \"wf_graph G\" and iO: \"is_offending_flows (set ff) G nP\" and sS: \"set ff \\<subseteq> edges G\" and dF: \"distinct ff\"\n  shows\n    \"set_offending_flows G nP \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_offending_flows G nP \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_offending_flows G nP \\<noteq> {}", "from iO SecurityInvariant_withOffendingFlows.is_offending_flows_def"], ["proof (chain)\npicking this:\n  is_offending_flows (set ff) G nP\n  SecurityInvariant_withOffendingFlows.is_offending_flows ?sinvar ?f ?G\n   ?nP \\<equiv>\n  \\<not> ?sinvar ?G ?nP \\<and> ?sinvar (delete_edges ?G ?f) ?nP", "have nS: \"\\<not> sinvar G nP\""], ["proof (prove)\nusing this:\n  is_offending_flows (set ff) G nP\n  SecurityInvariant_withOffendingFlows.is_offending_flows ?sinvar ?f ?G\n   ?nP \\<equiv>\n  \\<not> ?sinvar ?G ?nP \\<and> ?sinvar (delete_edges ?G ?f) ?nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar G nP", "by metis"], ["proof (state)\nthis:\n  \\<not> sinvar G nP\n\ngoal (1 subgoal):\n 1. set_offending_flows G nP \\<noteq> {}", "from sinvar_mono_imp_negative_delete_edge_mono[OF mono_sinvar]"], ["proof (chain)\npicking this:\n  \\<lbrakk>wf_graph ?G; ?X \\<subseteq> ?Y;\n   \\<not> sinvar (delete_edges ?G ?Y) ?nP\\<rbrakk>\n  \\<Longrightarrow> \\<not> sinvar (delete_edges ?G ?X) ?nP", "have negative_delete_edge_mono: \n      \"\\<forall> G nP X Y. wf_graph G \\<and> X \\<subseteq> Y \\<and> \\<not> sinvar (delete_edges G (Y)) nP \\<longrightarrow> \\<not> sinvar (delete_edges G X) nP\""], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_graph ?G; ?X \\<subseteq> ?Y;\n   \\<not> sinvar (delete_edges ?G ?Y) ?nP\\<rbrakk>\n  \\<Longrightarrow> \\<not> sinvar (delete_edges ?G ?X) ?nP\n\ngoal (1 subgoal):\n 1. \\<forall>G nP X Y.\n       wf_graph G \\<and>\n       X \\<subseteq> Y \\<and>\n       \\<not> sinvar (delete_edges G Y) nP \\<longrightarrow>\n       \\<not> sinvar (delete_edges G X) nP", "by blast"], ["proof (state)\nthis:\n  \\<forall>G nP X Y.\n     wf_graph G \\<and>\n     X \\<subseteq> Y \\<and>\n     \\<not> sinvar (delete_edges G Y) nP \\<longrightarrow>\n     \\<not> sinvar (delete_edges G X) nP\n\ngoal (1 subgoal):\n 1. set_offending_flows G nP \\<noteq> {}", "from is_offending_flows_min_set_minimalize_offending_overapprox[OF mono_sinvar vG iO sS dF]"], ["proof (chain)\npicking this:\n  is_offending_flows_min_set\n   (set (minimalize_offending_overapprox ff [] G nP)) G nP", "have \"is_offending_flows_min_set (set (minimalize_offending_overapprox ff [] G nP)) G nP\""], ["proof (prove)\nusing this:\n  is_offending_flows_min_set\n   (set (minimalize_offending_overapprox ff [] G nP)) G nP\n\ngoal (1 subgoal):\n 1. is_offending_flows_min_set\n     (set (minimalize_offending_overapprox ff [] G nP)) G nP", "by simp"], ["proof (state)\nthis:\n  is_offending_flows_min_set\n   (set (minimalize_offending_overapprox ff [] G nP)) G nP\n\ngoal (1 subgoal):\n 1. set_offending_flows G nP \\<noteq> {}", "from this set_offending_flows_def sS"], ["proof (chain)\npicking this:\n  is_offending_flows_min_set\n   (set (minimalize_offending_overapprox ff [] G nP)) G nP\n  set_offending_flows ?G ?nP =\n  {F. F \\<subseteq> edges ?G \\<and> is_offending_flows_min_set F ?G ?nP}\n  set ff \\<subseteq> edges G", "have\n      \"(set (minimalize_offending_overapprox ff [] G nP)) \\<in> set_offending_flows G nP\""], ["proof (prove)\nusing this:\n  is_offending_flows_min_set\n   (set (minimalize_offending_overapprox ff [] G nP)) G nP\n  set_offending_flows ?G ?nP =\n  {F. F \\<subseteq> edges ?G \\<and> is_offending_flows_min_set F ?G ?nP}\n  set ff \\<subseteq> edges G\n\ngoal (1 subgoal):\n 1. set (minimalize_offending_overapprox ff [] G nP)\n    \\<in> set_offending_flows G nP", "using minimalize_offending_overapprox_subset[where keeps=\"[]\"]"], ["proof (prove)\nusing this:\n  is_offending_flows_min_set\n   (set (minimalize_offending_overapprox ff [] G nP)) G nP\n  set_offending_flows ?G ?nP =\n  {F. F \\<subseteq> edges ?G \\<and> is_offending_flows_min_set F ?G ?nP}\n  set ff \\<subseteq> edges G\n  set (minimalize_offending_overapprox ?ff [] ?G ?nP)\n  \\<subseteq> set ?ff \\<union> set []\n\ngoal (1 subgoal):\n 1. set (minimalize_offending_overapprox ff [] G nP)\n    \\<in> set_offending_flows G nP", "by fastforce"], ["proof (state)\nthis:\n  set (minimalize_offending_overapprox ff [] G nP)\n  \\<in> set_offending_flows G nP\n\ngoal (1 subgoal):\n 1. set_offending_flows G nP \\<noteq> {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  set (minimalize_offending_overapprox ff [] G nP)\n  \\<in> set_offending_flows G nP\n\ngoal (1 subgoal):\n 1. set_offending_flows G nP \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  set_offending_flows G nP \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n   To show that @{const set_offending_flows} is not empty, the previous corollary @{thm mono_imp_set_offending_flows_not_empty} is very useful.\n   Just select @{term \"set ff = edges G\"}.\n\\<close>"], ["", "text\\<open>\n   If there exists a security violations,\n   there a means to fix it if and only if the network in which nobody communicates with anyone fulfills the security requirement\n\\<close>"], ["", "theorem valid_empty_edges_iff_exists_offending_flows: \n    assumes mono: \"sinvar_mono\" and wfG: \"wf_graph G\" and noteval: \"\\<not> sinvar G nP\"\n    shows \"sinvar \\<lparr> nodes = nodes G, edges = {} \\<rparr> nP \\<longleftrightarrow> set_offending_flows G nP \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP =\n    (set_offending_flows G nP \\<noteq> {})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP \\<Longrightarrow>\n    set_offending_flows G nP \\<noteq> {}\n 2. set_offending_flows G nP \\<noteq> {} \\<Longrightarrow>\n    sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP", "assume a: \"sinvar \\<lparr> nodes = nodes G, edges = {} \\<rparr> nP\""], ["proof (state)\nthis:\n  sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP\n\ngoal (2 subgoals):\n 1. sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP \\<Longrightarrow>\n    set_offending_flows G nP \\<noteq> {}\n 2. set_offending_flows G nP \\<noteq> {} \\<Longrightarrow>\n    sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP", "from finite_distinct_list[OF wf_graph.finiteE] wfG"], ["proof (chain)\npicking this:\n  wf_graph ?G1 \\<Longrightarrow>\n  \\<exists>xs. set xs = edges ?G1 \\<and> distinct xs\n  wf_graph G", "obtain list_edges where list_edges_props: \"set list_edges = edges G \\<and> distinct list_edges\""], ["proof (prove)\nusing this:\n  wf_graph ?G1 \\<Longrightarrow>\n  \\<exists>xs. set xs = edges ?G1 \\<and> distinct xs\n  wf_graph G\n\ngoal (1 subgoal):\n 1. (\\<And>list_edges.\n        set list_edges = edges G \\<and>\n        distinct list_edges \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  set list_edges = edges G \\<and> distinct list_edges\n\ngoal (2 subgoals):\n 1. sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP \\<Longrightarrow>\n    set_offending_flows G nP \\<noteq> {}\n 2. set_offending_flows G nP \\<noteq> {} \\<Longrightarrow>\n    sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP", "hence listedges_subseteq_edges: \"set list_edges \\<subseteq> edges G\""], ["proof (prove)\nusing this:\n  set list_edges = edges G \\<and> distinct list_edges\n\ngoal (1 subgoal):\n 1. set list_edges \\<subseteq> edges G", "by blast"], ["proof (state)\nthis:\n  set list_edges \\<subseteq> edges G\n\ngoal (2 subgoals):\n 1. sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP \\<Longrightarrow>\n    set_offending_flows G nP \\<noteq> {}\n 2. set_offending_flows G nP \\<noteq> {} \\<Longrightarrow>\n    sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP", "have empty_edge_graph_simp: \"(delete_edges G (edges G)) = \\<lparr> nodes = nodes G, edges = {} \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete_edges G (edges G) = \\<lparr>nodes = nodes G, edges = {}\\<rparr>", "by(auto simp add: graph_ops)"], ["proof (state)\nthis:\n  delete_edges G (edges G) = \\<lparr>nodes = nodes G, edges = {}\\<rparr>\n\ngoal (2 subgoals):\n 1. sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP \\<Longrightarrow>\n    set_offending_flows G nP \\<noteq> {}\n 2. set_offending_flows G nP \\<noteq> {} \\<Longrightarrow>\n    sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP", "from a is_offending_flows_def noteval list_edges_props empty_edge_graph_simp"], ["proof (chain)\npicking this:\n  sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP\n  is_offending_flows ?f ?G ?nP \\<equiv>\n  \\<not> sinvar ?G ?nP \\<and> sinvar (delete_edges ?G ?f) ?nP\n  \\<not> sinvar G nP\n  set list_edges = edges G \\<and> distinct list_edges\n  delete_edges G (edges G) = \\<lparr>nodes = nodes G, edges = {}\\<rparr>", "have overapprox: \"is_offending_flows (set list_edges) G nP\""], ["proof (prove)\nusing this:\n  sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP\n  is_offending_flows ?f ?G ?nP \\<equiv>\n  \\<not> sinvar ?G ?nP \\<and> sinvar (delete_edges ?G ?f) ?nP\n  \\<not> sinvar G nP\n  set list_edges = edges G \\<and> distinct list_edges\n  delete_edges G (edges G) = \\<lparr>nodes = nodes G, edges = {}\\<rparr>\n\ngoal (1 subgoal):\n 1. is_offending_flows (set list_edges) G nP", "by auto"], ["proof (state)\nthis:\n  is_offending_flows (set list_edges) G nP\n\ngoal (2 subgoals):\n 1. sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP \\<Longrightarrow>\n    set_offending_flows G nP \\<noteq> {}\n 2. set_offending_flows G nP \\<noteq> {} \\<Longrightarrow>\n    sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP", "from mono_imp_set_offending_flows_not_empty[OF mono wfG overapprox listedges_subseteq_edges] list_edges_props"], ["proof (chain)\npicking this:\n  distinct list_edges \\<Longrightarrow> set_offending_flows G nP \\<noteq> {}\n  set list_edges = edges G \\<and> distinct list_edges", "show \"set_offending_flows G nP \\<noteq> {}\""], ["proof (prove)\nusing this:\n  distinct list_edges \\<Longrightarrow> set_offending_flows G nP \\<noteq> {}\n  set list_edges = edges G \\<and> distinct list_edges\n\ngoal (1 subgoal):\n 1. set_offending_flows G nP \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  set_offending_flows G nP \\<noteq> {}\n\ngoal (1 subgoal):\n 1. set_offending_flows G nP \\<noteq> {} \\<Longrightarrow>\n    sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. set_offending_flows G nP \\<noteq> {} \\<Longrightarrow>\n    sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP", "assume a: \"set_offending_flows G nP \\<noteq> {}\""], ["proof (state)\nthis:\n  set_offending_flows G nP \\<noteq> {}\n\ngoal (1 subgoal):\n 1. set_offending_flows G nP \\<noteq> {} \\<Longrightarrow>\n    sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP", "from a"], ["proof (chain)\npicking this:\n  set_offending_flows G nP \\<noteq> {}", "obtain f where f_props: \"f \\<subseteq> edges G \\<and> is_offending_flows_min_set f G nP\""], ["proof (prove)\nusing this:\n  set_offending_flows G nP \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        f \\<subseteq> edges G \\<and>\n        is_offending_flows_min_set f G nP \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using set_offending_flows_def"], ["proof (prove)\nusing this:\n  set_offending_flows G nP \\<noteq> {}\n  set_offending_flows ?G ?nP =\n  {F. F \\<subseteq> edges ?G \\<and> is_offending_flows_min_set F ?G ?nP}\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        f \\<subseteq> edges G \\<and>\n        is_offending_flows_min_set f G nP \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  f \\<subseteq> edges G \\<and> is_offending_flows_min_set f G nP\n\ngoal (1 subgoal):\n 1. set_offending_flows G nP \\<noteq> {} \\<Longrightarrow>\n    sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP", "from f_props"], ["proof (chain)\npicking this:\n  f \\<subseteq> edges G \\<and> is_offending_flows_min_set f G nP", "have \"sinvar (delete_edges G f) nP\""], ["proof (prove)\nusing this:\n  f \\<subseteq> edges G \\<and> is_offending_flows_min_set f G nP\n\ngoal (1 subgoal):\n 1. sinvar (delete_edges G f) nP", "using is_offending_flows_min_set_def is_offending_flows_def"], ["proof (prove)\nusing this:\n  f \\<subseteq> edges G \\<and> is_offending_flows_min_set f G nP\n  is_offending_flows_min_set ?f ?G ?nP \\<equiv>\n  is_offending_flows ?f ?G ?nP \\<and>\n  (\\<forall>(e1, e2)\\<in>?f.\n      \\<not> sinvar (add_edge e1 e2 (delete_edges ?G ?f)) ?nP)\n  is_offending_flows ?f ?G ?nP \\<equiv>\n  \\<not> sinvar ?G ?nP \\<and> sinvar (delete_edges ?G ?f) ?nP\n\ngoal (1 subgoal):\n 1. sinvar (delete_edges G f) nP", "by simp"], ["proof (state)\nthis:\n  sinvar (delete_edges G f) nP\n\ngoal (1 subgoal):\n 1. set_offending_flows G nP \\<noteq> {} \\<Longrightarrow>\n    sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP", "hence evalGf: \"sinvar \\<lparr>nodes = nodes G, edges = {(e1, e2). (e1, e2) \\<in> edges G \\<and> (e1, e2) \\<notin> f}\\<rparr> nP\""], ["proof (prove)\nusing this:\n  sinvar (delete_edges G f) nP\n\ngoal (1 subgoal):\n 1. sinvar\n     \\<lparr>nodes = nodes G,\n        edges =\n          {(e1, e2).\n           (e1, e2) \\<in> edges G \\<and> (e1, e2) \\<notin> f}\\<rparr>\n     nP", "by(simp add: delete_edges_def)"], ["proof (state)\nthis:\n  sinvar\n   \\<lparr>nodes = nodes G,\n      edges =\n        {(e1, e2).\n         (e1, e2) \\<in> edges G \\<and> (e1, e2) \\<notin> f}\\<rparr>\n   nP\n\ngoal (1 subgoal):\n 1. set_offending_flows G nP \\<noteq> {} \\<Longrightarrow>\n    sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP", "from delete_edges_wf[OF wfG, unfolded delete_edges_def]"], ["proof (chain)\npicking this:\n  wf_graph\n   \\<lparr>nodes = nodes G,\n      edges =\n        {(e1, e2).\n         (e1, e2) \\<in> edges G \\<and> (e1, e2) \\<notin> ?E}\\<rparr>", "have wfGf: \"wf_graph \\<lparr>nodes = nodes G, edges = {(e1, e2). (e1, e2) \\<in> edges G \\<and> (e1, e2) \\<notin> f}\\<rparr>\""], ["proof (prove)\nusing this:\n  wf_graph\n   \\<lparr>nodes = nodes G,\n      edges =\n        {(e1, e2).\n         (e1, e2) \\<in> edges G \\<and> (e1, e2) \\<notin> ?E}\\<rparr>\n\ngoal (1 subgoal):\n 1. wf_graph\n     \\<lparr>nodes = nodes G,\n        edges =\n          {(e1, e2).\n           (e1, e2) \\<in> edges G \\<and> (e1, e2) \\<notin> f}\\<rparr>", "by simp"], ["proof (state)\nthis:\n  wf_graph\n   \\<lparr>nodes = nodes G,\n      edges =\n        {(e1, e2).\n         (e1, e2) \\<in> edges G \\<and> (e1, e2) \\<notin> f}\\<rparr>\n\ngoal (1 subgoal):\n 1. set_offending_flows G nP \\<noteq> {} \\<Longrightarrow>\n    sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP", "have emptyseqGf: \"{} \\<subseteq>  {(e1, e2). (e1, e2) \\<in> edges G \\<and> (e1, e2) \\<notin> f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<subseteq> {(e1, e2).\n                    (e1, e2) \\<in> edges G \\<and> (e1, e2) \\<notin> f}", "by simp"], ["proof (state)\nthis:\n  {} \\<subseteq> {(e1, e2).\n                  (e1, e2) \\<in> edges G \\<and> (e1, e2) \\<notin> f}\n\ngoal (1 subgoal):\n 1. set_offending_flows G nP \\<noteq> {} \\<Longrightarrow>\n    sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP", "from mono[unfolded sinvar_mono_def] evalGf wfGf emptyseqGf"], ["proof (chain)\npicking this:\n  \\<forall>nP N E' E.\n     wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n     E' \\<subseteq> E \\<and>\n     sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP \\<longrightarrow>\n     sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n  sinvar\n   \\<lparr>nodes = nodes G,\n      edges =\n        {(e1, e2).\n         (e1, e2) \\<in> edges G \\<and> (e1, e2) \\<notin> f}\\<rparr>\n   nP\n  wf_graph\n   \\<lparr>nodes = nodes G,\n      edges =\n        {(e1, e2).\n         (e1, e2) \\<in> edges G \\<and> (e1, e2) \\<notin> f}\\<rparr>\n  {} \\<subseteq> {(e1, e2).\n                  (e1, e2) \\<in> edges G \\<and> (e1, e2) \\<notin> f}", "have \"sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP\""], ["proof (prove)\nusing this:\n  \\<forall>nP N E' E.\n     wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n     E' \\<subseteq> E \\<and>\n     sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP \\<longrightarrow>\n     sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n  sinvar\n   \\<lparr>nodes = nodes G,\n      edges =\n        {(e1, e2).\n         (e1, e2) \\<in> edges G \\<and> (e1, e2) \\<notin> f}\\<rparr>\n   nP\n  wf_graph\n   \\<lparr>nodes = nodes G,\n      edges =\n        {(e1, e2).\n         (e1, e2) \\<in> edges G \\<and> (e1, e2) \\<notin> f}\\<rparr>\n  {} \\<subseteq> {(e1, e2).\n                  (e1, e2) \\<in> edges G \\<and> (e1, e2) \\<notin> f}\n\ngoal (1 subgoal):\n 1. sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP", "by blast"], ["proof (state)\nthis:\n  sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP\n\ngoal (1 subgoal):\n 1. set_offending_flows G nP \\<noteq> {} \\<Longrightarrow>\n    sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP", "thus \"sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP\""], ["proof (prove)\nusing this:\n  sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP\n\ngoal (1 subgoal):\n 1. sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP", "."], ["proof (state)\nthis:\n  sinvar \\<lparr>nodes = nodes G, edges = {}\\<rparr> nP\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n  @{const minimalize_offending_overapprox} not only computes a set where @{const is_offending_flows_min_set} holds, but it also returns a subset of the input.\n\\<close>"], ["", "lemma minimalize_offending_overapprox_keeps_keeps: \"(set keeps) \\<subseteq> set (minimalize_offending_overapprox ff keeps G nP)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set keeps\n    \\<subseteq> set (minimalize_offending_overapprox ff keeps G nP)", "proof(induction ff keeps G nP rule: minimalize_offending_overapprox.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>keep uu_ uv_.\n       set keep\n       \\<subseteq> set (minimalize_offending_overapprox [] keep uu_ uv_)\n 2. \\<And>f fs keep G nP.\n       \\<lbrakk>sinvar (delete_edges_list G (fs @ keep))\n                 nP \\<Longrightarrow>\n                set keep\n                \\<subseteq> set (minimalize_offending_overapprox fs keep G\n                                  nP);\n        \\<not> sinvar (delete_edges_list G (fs @ keep)) nP \\<Longrightarrow>\n        set (f # keep)\n        \\<subseteq> set (minimalize_offending_overapprox fs (f # keep) G\n                          nP)\\<rbrakk>\n       \\<Longrightarrow> set keep\n                         \\<subseteq> set\n(minimalize_offending_overapprox (f # fs) keep G nP)", "qed(simp_all)"], ["", "lemma minimalize_offending_overapprox_subseteq_input: \"set (minimalize_offending_overapprox ff keeps G nP) \\<subseteq> (set ff) \\<union> (set keeps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (minimalize_offending_overapprox ff keeps G nP)\n    \\<subseteq> set ff \\<union> set keeps", "proof(induction ff keeps G nP rule: minimalize_offending_overapprox.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>keep uu_ uv_.\n       set (minimalize_offending_overapprox [] keep uu_ uv_)\n       \\<subseteq> set [] \\<union> set keep\n 2. \\<And>f fs keep G nP.\n       \\<lbrakk>sinvar (delete_edges_list G (fs @ keep))\n                 nP \\<Longrightarrow>\n                set (minimalize_offending_overapprox fs keep G nP)\n                \\<subseteq> set fs \\<union> set keep;\n        \\<not> sinvar (delete_edges_list G (fs @ keep)) nP \\<Longrightarrow>\n        set (minimalize_offending_overapprox fs (f # keep) G nP)\n        \\<subseteq> set fs \\<union> set (f # keep)\\<rbrakk>\n       \\<Longrightarrow> set (minimalize_offending_overapprox (f # fs) keep\n                               G nP)\n                         \\<subseteq> set (f # fs) \\<union> set keep", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>keep uu_ uv_.\n       set (minimalize_offending_overapprox [] keep uu_ uv_)\n       \\<subseteq> set [] \\<union> set keep\n 2. \\<And>f fs keep G nP.\n       \\<lbrakk>sinvar (delete_edges_list G (fs @ keep))\n                 nP \\<Longrightarrow>\n                set (minimalize_offending_overapprox fs keep G nP)\n                \\<subseteq> set fs \\<union> set keep;\n        \\<not> sinvar (delete_edges_list G (fs @ keep)) nP \\<Longrightarrow>\n        set (minimalize_offending_overapprox fs (f # keep) G nP)\n        \\<subseteq> set fs \\<union> set (f # keep)\\<rbrakk>\n       \\<Longrightarrow> set (minimalize_offending_overapprox (f # fs) keep\n                               G nP)\n                         \\<subseteq> set (f # fs) \\<union> set keep", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (minimalize_offending_overapprox [] keep_ uu_ uv_)\n    \\<subseteq> set [] \\<union> set keep_", "by simp"], ["proof (state)\nthis:\n  set (minimalize_offending_overapprox [] keep_ uu_ uv_)\n  \\<subseteq> set [] \\<union> set keep_\n\ngoal (1 subgoal):\n 1. \\<And>f fs keep G nP.\n       \\<lbrakk>sinvar (delete_edges_list G (fs @ keep))\n                 nP \\<Longrightarrow>\n                set (minimalize_offending_overapprox fs keep G nP)\n                \\<subseteq> set fs \\<union> set keep;\n        \\<not> sinvar (delete_edges_list G (fs @ keep)) nP \\<Longrightarrow>\n        set (minimalize_offending_overapprox fs (f # keep) G nP)\n        \\<subseteq> set fs \\<union> set (f # keep)\\<rbrakk>\n       \\<Longrightarrow> set (minimalize_offending_overapprox (f # fs) keep\n                               G nP)\n                         \\<subseteq> set (f # fs) \\<union> set keep", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f fs keep G nP.\n       \\<lbrakk>sinvar (delete_edges_list G (fs @ keep))\n                 nP \\<Longrightarrow>\n                set (minimalize_offending_overapprox fs keep G nP)\n                \\<subseteq> set fs \\<union> set keep;\n        \\<not> sinvar (delete_edges_list G (fs @ keep)) nP \\<Longrightarrow>\n        set (minimalize_offending_overapprox fs (f # keep) G nP)\n        \\<subseteq> set fs \\<union> set (f # keep)\\<rbrakk>\n       \\<Longrightarrow> set (minimalize_offending_overapprox (f # fs) keep\n                               G nP)\n                         \\<subseteq> set (f # fs) \\<union> set keep", "case 2"], ["proof (state)\nthis:\n  sinvar (delete_edges_list G_ (fs_ @ keep_)) nP_ \\<Longrightarrow>\n  set (minimalize_offending_overapprox fs_ keep_ G_ nP_)\n  \\<subseteq> set fs_ \\<union> set keep_\n  \\<not> sinvar (delete_edges_list G_ (fs_ @ keep_)) nP_ \\<Longrightarrow>\n  set (minimalize_offending_overapprox fs_ (f_ # keep_) G_ nP_)\n  \\<subseteq> set fs_ \\<union> set (f_ # keep_)\n\ngoal (1 subgoal):\n 1. \\<And>f fs keep G nP.\n       \\<lbrakk>sinvar (delete_edges_list G (fs @ keep))\n                 nP \\<Longrightarrow>\n                set (minimalize_offending_overapprox fs keep G nP)\n                \\<subseteq> set fs \\<union> set keep;\n        \\<not> sinvar (delete_edges_list G (fs @ keep)) nP \\<Longrightarrow>\n        set (minimalize_offending_overapprox fs (f # keep) G nP)\n        \\<subseteq> set fs \\<union> set (f # keep)\\<rbrakk>\n       \\<Longrightarrow> set (minimalize_offending_overapprox (f # fs) keep\n                               G nP)\n                         \\<subseteq> set (f # fs) \\<union> set keep", "thus ?case"], ["proof (prove)\nusing this:\n  sinvar (delete_edges_list G_ (fs_ @ keep_)) nP_ \\<Longrightarrow>\n  set (minimalize_offending_overapprox fs_ keep_ G_ nP_)\n  \\<subseteq> set fs_ \\<union> set keep_\n  \\<not> sinvar (delete_edges_list G_ (fs_ @ keep_)) nP_ \\<Longrightarrow>\n  set (minimalize_offending_overapprox fs_ (f_ # keep_) G_ nP_)\n  \\<subseteq> set fs_ \\<union> set (f_ # keep_)\n\ngoal (1 subgoal):\n 1. set (minimalize_offending_overapprox (f_ # fs_) keep_ G_ nP_)\n    \\<subseteq> set (f_ # fs_) \\<union> set keep_", "by(simp add: delete_edges_list_set delete_edges_simp2) blast"], ["proof (state)\nthis:\n  set (minimalize_offending_overapprox (f_ # fs_) keep_ G_ nP_)\n  \\<subseteq> set (f_ # fs_) \\<union> set keep_\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context SecurityInvariant_preliminaries\n  begin"], ["", "text\\<open>@{const sinvar_mono} naturally holds in @{const SecurityInvariant_preliminaries}\\<close>"], ["", "lemma sinvar_monoI: \"sinvar_mono\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinvar_mono", "unfolding sinvar_mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>nP N E' E.\n       wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n       E' \\<subseteq> E \\<and>\n       sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP \\<longrightarrow>\n       sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP", "using mono_sinvar"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_graph \\<lparr>nodes = ?N, edges = ?E\\<rparr>;\n   ?E' \\<subseteq> ?E;\n   sinvar \\<lparr>nodes = ?N, edges = ?E\\<rparr> ?nP\\<rbrakk>\n  \\<Longrightarrow> sinvar \\<lparr>nodes = ?N, edges = ?E'\\<rparr> ?nP\n\ngoal (1 subgoal):\n 1. \\<forall>nP N E' E.\n       wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n       E' \\<subseteq> E \\<and>\n       sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP \\<longrightarrow>\n       sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP", "by blast"], ["", "text\\<open>Note: due to monotonicity, the minimality also holds for arbitrary subsets\\<close>"], ["", "lemma assumes \"wf_graph G\" and \"is_offending_flows_min_set F G nP\" and \"F \\<subseteq> edges G\" and \"E \\<subseteq> F\" and \"E \\<noteq> {}\"\n          shows \"\\<not> sinvar \\<lparr> nodes = nodes G, edges = ((edges G) - F) \\<union> E \\<rparr> nP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            \\<lparr>nodes = nodes G, edges = edges G - F \\<union> E\\<rparr>\n            nP", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            \\<lparr>nodes = nodes G, edges = edges G - F \\<union> E\\<rparr>\n            nP", "from sinvar_mono_imp_negative_delete_edge_mono[OF sinvar_monoI \\<open>wf_graph G\\<close>]"], ["proof (chain)\npicking this:\n  \\<lbrakk>?X \\<subseteq> ?Y; \\<not> sinvar (delete_edges G ?Y) ?nP\\<rbrakk>\n  \\<Longrightarrow> \\<not> sinvar (delete_edges G ?X) ?nP", "have negative_delete_edge_mono: \n      \"\\<And>X Y. X \\<subseteq> Y \\<Longrightarrow> \\<not> sinvar \\<lparr> nodes = nodes G, edges = (edges G) - Y \\<rparr> nP \\<Longrightarrow> \\<not> sinvar \\<lparr> nodes = nodes G, edges = edges G - X \\<rparr> nP\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?X \\<subseteq> ?Y; \\<not> sinvar (delete_edges G ?Y) ?nP\\<rbrakk>\n  \\<Longrightarrow> \\<not> sinvar (delete_edges G ?X) ?nP\n\ngoal (1 subgoal):\n 1. \\<And>X Y.\n       \\<lbrakk>X \\<subseteq> Y;\n        \\<not> sinvar \\<lparr>nodes = nodes G, edges = edges G - Y\\<rparr>\n                nP\\<rbrakk>\n       \\<Longrightarrow> \\<not> sinvar\n                                 \\<lparr>nodes = nodes G,\n                                    edges = edges G - X\\<rparr>\n                                 nP", "using delete_edges_simp2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?X \\<subseteq> ?Y; \\<not> sinvar (delete_edges G ?Y) ?nP\\<rbrakk>\n  \\<Longrightarrow> \\<not> sinvar (delete_edges G ?X) ?nP\n  delete_edges ?G ?E =\n  \\<lparr>nodes = nodes ?G, edges = edges ?G - ?E\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>X Y.\n       \\<lbrakk>X \\<subseteq> Y;\n        \\<not> sinvar \\<lparr>nodes = nodes G, edges = edges G - Y\\<rparr>\n                nP\\<rbrakk>\n       \\<Longrightarrow> \\<not> sinvar\n                                 \\<lparr>nodes = nodes G,\n                                    edges = edges G - X\\<rparr>\n                                 nP", "by metis"], ["proof (state)\nthis:\n  \\<lbrakk>?X \\<subseteq> ?Y;\n   \\<not> sinvar \\<lparr>nodes = nodes G, edges = edges G - ?Y\\<rparr>\n           nP\\<rbrakk>\n  \\<Longrightarrow> \\<not> sinvar\n                            \\<lparr>nodes = nodes G,\n                               edges = edges G - ?X\\<rparr>\n                            nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            \\<lparr>nodes = nodes G, edges = edges G - F \\<union> E\\<rparr>\n            nP", "from assms(2)"], ["proof (chain)\npicking this:\n  is_offending_flows_min_set F G nP", "have \"(\\<forall>(e1, e2)\\<in>F. \\<not> sinvar (add_edge e1 e2 (delete_edges G F)) nP)\""], ["proof (prove)\nusing this:\n  is_offending_flows_min_set F G nP\n\ngoal (1 subgoal):\n 1. \\<forall>(e1, e2)\\<in>F.\n       \\<not> sinvar (add_edge e1 e2 (delete_edges G F)) nP", "unfolding is_offending_flows_min_set_def"], ["proof (prove)\nusing this:\n  is_offending_flows F G nP \\<and>\n  (\\<forall>(e1, e2)\\<in>F.\n      \\<not> sinvar (add_edge e1 e2 (delete_edges G F)) nP)\n\ngoal (1 subgoal):\n 1. \\<forall>(e1, e2)\\<in>F.\n       \\<not> sinvar (add_edge e1 e2 (delete_edges G F)) nP", "by simp"], ["proof (state)\nthis:\n  \\<forall>(e1, e2)\\<in>F.\n     \\<not> sinvar (add_edge e1 e2 (delete_edges G F)) nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            \\<lparr>nodes = nodes G, edges = edges G - F \\<union> E\\<rparr>\n            nP", "with \\<open>wf_graph G\\<close>"], ["proof (chain)\npicking this:\n  wf_graph G\n  \\<forall>(e1, e2)\\<in>F.\n     \\<not> sinvar (add_edge e1 e2 (delete_edges G F)) nP", "have min: \"(\\<forall>(e1, e2)\\<in>F. \\<not> sinvar \\<lparr> nodes = nodes G, edges = ((edges G) - F) \\<union> {(e1,e2)} \\<rparr> nP)\""], ["proof (prove)\nusing this:\n  wf_graph G\n  \\<forall>(e1, e2)\\<in>F.\n     \\<not> sinvar (add_edge e1 e2 (delete_edges G F)) nP\n\ngoal (1 subgoal):\n 1. \\<forall>(e1, e2)\\<in>F.\n       \\<not> sinvar\n               \\<lparr>nodes = nodes G,\n                  edges = edges G - F \\<union> {(e1, e2)}\\<rparr>\n               nP", "apply(simp add: delete_edges_simp2 add_edge_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G;\n     \\<forall>x\\<in>F.\n        case x of\n        (e1, e2) \\<Rightarrow>\n          \\<not> sinvar\n                  \\<lparr>nodes = insert e1 (insert e2 (nodes G)),\n                     edges = insert (e1, e2) (edges G - F)\\<rparr>\n                  nP\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>F.\n                         \\<not> sinvar\n                                 \\<lparr>nodes = nodes G,\n                                    edges = insert x (edges G - F)\\<rparr>\n                                 nP", "apply(rule, rename_tac x, case_tac x, rename_tac e1 e2, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x e1 e2.\n       \\<lbrakk>wf_graph G;\n        \\<forall>x\\<in>F.\n           case x of\n           (e1, e2) \\<Rightarrow>\n             \\<not> sinvar\n                     \\<lparr>nodes = insert e1 (insert e2 (nodes G)),\n                        edges = insert (e1, e2) (edges G - F)\\<rparr>\n                     nP;\n        (e1, e2) \\<in> F; x = (e1, e2)\\<rbrakk>\n       \\<Longrightarrow> \\<not> sinvar\n                                 \\<lparr>nodes = nodes G,\n                                    edges =\ninsert (e1, e2) (edges G - F)\\<rparr>\n                                 nP", "apply(erule_tac x=\"(e1, e2)\" in ballE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x e1 e2.\n       \\<lbrakk>wf_graph G; (e1, e2) \\<in> F; x = (e1, e2);\n        case (e1, e2) of\n        (e1, e2) \\<Rightarrow>\n          \\<not> sinvar\n                  \\<lparr>nodes = insert e1 (insert e2 (nodes G)),\n                     edges = insert (e1, e2) (edges G - F)\\<rparr>\n                  nP\\<rbrakk>\n       \\<Longrightarrow> \\<not> sinvar\n                                 \\<lparr>nodes = nodes G,\n                                    edges =\ninsert (e1, e2) (edges G - F)\\<rparr>\n                                 nP\n 2. \\<And>x e1 e2.\n       \\<lbrakk>wf_graph G; (e1, e2) \\<in> F; x = (e1, e2);\n        (e1, e2) \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> \\<not> sinvar\n                                 \\<lparr>nodes = nodes G,\n                                    edges =\ninsert (e1, e2) (edges G - F)\\<rparr>\n                                 nP", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x e1 e2.\n       \\<lbrakk>wf_graph G; (e1, e2) \\<in> F; x = (e1, e2);\n        \\<not> sinvar\n                \\<lparr>nodes = insert e1 (insert e2 (nodes G)),\n                   edges = insert (e1, e2) (edges G - F)\\<rparr>\n                nP\\<rbrakk>\n       \\<Longrightarrow> \\<not> sinvar\n                                 \\<lparr>nodes = nodes G,\n                                    edges =\ninsert (e1, e2) (edges G - F)\\<rparr>\n                                 nP", "apply(subgoal_tac \"insert e1 (insert e2 (nodes G)) = nodes G\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x e1 e2.\n       \\<lbrakk>wf_graph G; (e1, e2) \\<in> F; x = (e1, e2);\n        \\<not> sinvar\n                \\<lparr>nodes = insert e1 (insert e2 (nodes G)),\n                   edges = insert (e1, e2) (edges G - F)\\<rparr>\n                nP;\n        insert e1 (insert e2 (nodes G)) = nodes G\\<rbrakk>\n       \\<Longrightarrow> \\<not> sinvar\n                                 \\<lparr>nodes = nodes G,\n                                    edges =\ninsert (e1, e2) (edges G - F)\\<rparr>\n                                 nP\n 2. \\<And>x e1 e2.\n       \\<lbrakk>wf_graph G; (e1, e2) \\<in> F; x = (e1, e2);\n        \\<not> sinvar\n                \\<lparr>nodes = insert e1 (insert e2 (nodes G)),\n                   edges = insert (e1, e2) (edges G - F)\\<rparr>\n                nP\\<rbrakk>\n       \\<Longrightarrow> insert e1 (insert e2 (nodes G)) = nodes G", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x e1 e2.\n       \\<lbrakk>wf_graph G; (e1, e2) \\<in> F; x = (e1, e2);\n        \\<not> sinvar\n                \\<lparr>nodes = insert e1 (insert e2 (nodes G)),\n                   edges = insert (e1, e2) (edges G - F)\\<rparr>\n                nP\\<rbrakk>\n       \\<Longrightarrow> insert e1 (insert e2 (nodes G)) = nodes G", "by (metis assms(3) insert_absorb rev_subsetD wf_graph.E_wfD(1) wf_graph.E_wfD(2))"], ["proof (state)\nthis:\n  \\<forall>(e1, e2)\\<in>F.\n     \\<not> sinvar\n             \\<lparr>nodes = nodes G,\n                edges = edges G - F \\<union> {(e1, e2)}\\<rparr>\n             nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            \\<lparr>nodes = nodes G, edges = edges G - F \\<union> E\\<rparr>\n            nP", "from \\<open>E \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  E \\<noteq> {}", "obtain e where \"e \\<in> E\""], ["proof (prove)\nusing this:\n  E \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>e. e \\<in> E \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  e \\<in> E\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            \\<lparr>nodes = nodes G, edges = edges G - F \\<union> E\\<rparr>\n            nP", "with min \\<open>E \\<subseteq> F\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>(e1, e2)\\<in>F.\n     \\<not> sinvar\n             \\<lparr>nodes = nodes G,\n                edges = edges G - F \\<union> {(e1, e2)}\\<rparr>\n             nP\n  E \\<subseteq> F\n  e \\<in> E", "have mine: \"\\<not> sinvar \\<lparr> nodes = nodes G, edges = ((edges G) - F) \\<union> {e} \\<rparr> nP\""], ["proof (prove)\nusing this:\n  \\<forall>(e1, e2)\\<in>F.\n     \\<not> sinvar\n             \\<lparr>nodes = nodes G,\n                edges = edges G - F \\<union> {(e1, e2)}\\<rparr>\n             nP\n  E \\<subseteq> F\n  e \\<in> E\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            \\<lparr>nodes = nodes G,\n               edges = edges G - F \\<union> {e}\\<rparr>\n            nP", "by fast"], ["proof (state)\nthis:\n  \\<not> sinvar\n          \\<lparr>nodes = nodes G, edges = edges G - F \\<union> {e}\\<rparr>\n          nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            \\<lparr>nodes = nodes G, edges = edges G - F \\<union> E\\<rparr>\n            nP", "have e1: \"edges G - (F - {e}) = insert e (edges G - F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges G - (F - {e}) = insert e (edges G - F)", "using DiffD2 \\<open>e \\<in> E\\<close> assms(3) assms(4)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?c \\<in> ?A - ?B; ?c \\<in> ?B\\<rbrakk> \\<Longrightarrow> ?P\n  e \\<in> E\n  F \\<subseteq> edges G\n  E \\<subseteq> F\n\ngoal (1 subgoal):\n 1. edges G - (F - {e}) = insert e (edges G - F)", "by auto"], ["proof (state)\nthis:\n  edges G - (F - {e}) = insert e (edges G - F)\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            \\<lparr>nodes = nodes G, edges = edges G - F \\<union> E\\<rparr>\n            nP", "have e2: \"edges G - (F - E) = ((edges G) - F) \\<union> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges G - (F - E) = edges G - F \\<union> E", "using assms(3) assms(4)"], ["proof (prove)\nusing this:\n  F \\<subseteq> edges G\n  E \\<subseteq> F\n\ngoal (1 subgoal):\n 1. edges G - (F - E) = edges G - F \\<union> E", "by auto"], ["proof (state)\nthis:\n  edges G - (F - E) = edges G - F \\<union> E\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            \\<lparr>nodes = nodes G, edges = edges G - F \\<union> E\\<rparr>\n            nP", "from negative_delete_edge_mono[where Y=\"F - {e}\" and X=\"F - E\"] \\<open>e \\<in> E\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>F - E \\<subseteq> F - {e};\n   \\<not> sinvar\n           \\<lparr>nodes = nodes G, edges = edges G - (F - {e})\\<rparr>\n           nP\\<rbrakk>\n  \\<Longrightarrow> \\<not> sinvar\n                            \\<lparr>nodes = nodes G,\n                               edges = edges G - (F - E)\\<rparr>\n                            nP\n  e \\<in> E", "have\n      \"\\<not> sinvar \\<lparr>nodes = nodes G, edges = edges G - (F - {e})\\<rparr> nP \\<Longrightarrow> \\<not> sinvar \\<lparr>nodes = nodes G, edges = edges G - (F - E)\\<rparr> nP\""], ["proof (prove)\nusing this:\n  \\<lbrakk>F - E \\<subseteq> F - {e};\n   \\<not> sinvar\n           \\<lparr>nodes = nodes G, edges = edges G - (F - {e})\\<rparr>\n           nP\\<rbrakk>\n  \\<Longrightarrow> \\<not> sinvar\n                            \\<lparr>nodes = nodes G,\n                               edges = edges G - (F - E)\\<rparr>\n                            nP\n  e \\<in> E\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            \\<lparr>nodes = nodes G, edges = edges G - (F - {e})\\<rparr>\n            nP \\<Longrightarrow>\n    \\<not> sinvar \\<lparr>nodes = nodes G, edges = edges G - (F - E)\\<rparr>\n            nP", "by blast"], ["proof (state)\nthis:\n  \\<not> sinvar \\<lparr>nodes = nodes G, edges = edges G - (F - {e})\\<rparr>\n          nP \\<Longrightarrow>\n  \\<not> sinvar \\<lparr>nodes = nodes G, edges = edges G - (F - E)\\<rparr>\n          nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            \\<lparr>nodes = nodes G, edges = edges G - F \\<union> E\\<rparr>\n            nP", "with mine e1 e2"], ["proof (chain)\npicking this:\n  \\<not> sinvar\n          \\<lparr>nodes = nodes G, edges = edges G - F \\<union> {e}\\<rparr>\n          nP\n  edges G - (F - {e}) = insert e (edges G - F)\n  edges G - (F - E) = edges G - F \\<union> E\n  \\<not> sinvar \\<lparr>nodes = nodes G, edges = edges G - (F - {e})\\<rparr>\n          nP \\<Longrightarrow>\n  \\<not> sinvar \\<lparr>nodes = nodes G, edges = edges G - (F - E)\\<rparr>\n          nP", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> sinvar\n          \\<lparr>nodes = nodes G, edges = edges G - F \\<union> {e}\\<rparr>\n          nP\n  edges G - (F - {e}) = insert e (edges G - F)\n  edges G - (F - E) = edges G - F \\<union> E\n  \\<not> sinvar \\<lparr>nodes = nodes G, edges = edges G - (F - {e})\\<rparr>\n          nP \\<Longrightarrow>\n  \\<not> sinvar \\<lparr>nodes = nodes G, edges = edges G - (F - E)\\<rparr>\n          nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            \\<lparr>nodes = nodes G, edges = edges G - F \\<union> E\\<rparr>\n            nP", "by simp"], ["proof (state)\nthis:\n  \\<not> sinvar\n          \\<lparr>nodes = nodes G, edges = edges G - F \\<union> E\\<rparr> nP\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The algorithm @{const minimalize_offending_overapprox} is correct\\<close>"], ["", "lemma minimalize_offending_overapprox_sound: \n      \"\\<lbrakk> wf_graph G; is_offending_flows (set ff) G nP; set ff \\<subseteq> edges G; distinct ff \\<rbrakk>\n        \\<Longrightarrow> is_offending_flows_min_set (set (minimalize_offending_overapprox ff [] G nP)) G nP \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G; is_offending_flows (set ff) G nP;\n     set ff \\<subseteq> edges G; distinct ff\\<rbrakk>\n    \\<Longrightarrow> is_offending_flows_min_set\n                       (set (minimalize_offending_overapprox ff [] G nP)) G\n                       nP", "using is_offending_flows_min_set_minimalize_offending_overapprox sinvar_monoI"], ["proof (prove)\nusing this:\n  \\<lbrakk>sinvar_mono; wf_graph ?G; is_offending_flows (set ?ff) ?G ?nP;\n   set ?ff \\<subseteq> edges ?G; distinct ?ff\\<rbrakk>\n  \\<Longrightarrow> is_offending_flows_min_set\n                     (set (minimalize_offending_overapprox ?ff [] ?G ?nP))\n                     ?G ?nP\n  sinvar_mono\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G; is_offending_flows (set ff) G nP;\n     set ff \\<subseteq> edges G; distinct ff\\<rbrakk>\n    \\<Longrightarrow> is_offending_flows_min_set\n                       (set (minimalize_offending_overapprox ff [] G nP)) G\n                       nP", "by blast"], ["", "text\\<open>\n      If @{term \"\\<not> sinvar G nP\"}\n      Given a list ff, (ff is distinct and a subset of G's edges)\n      such that \\<open>sinvar (V, E - ff) nP\\<close>\n      @{const minimalize_offending_overapprox} minimizes ff such that we get an offending flows\n      Note: choosing ff = edges G is a good choice!\n\\<close>"], ["", "theorem minimalize_offending_overapprox_gives_back_an_offending_flow:\n      \"\\<lbrakk> wf_graph G; is_offending_flows (set ff) G nP; set ff \\<subseteq> edges G; distinct ff \\<rbrakk>\n        \\<Longrightarrow>\n         (set (minimalize_offending_overapprox ff [] G nP)) \\<in> set_offending_flows G nP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G; is_offending_flows (set ff) G nP;\n     set ff \\<subseteq> edges G; distinct ff\\<rbrakk>\n    \\<Longrightarrow> set (minimalize_offending_overapprox ff [] G nP)\n                      \\<in> set_offending_flows G nP", "apply(frule(3) minimalize_offending_overapprox_sound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G; is_offending_flows (set ff) G nP;\n     set ff \\<subseteq> edges G; distinct ff;\n     is_offending_flows_min_set\n      (set (minimalize_offending_overapprox ff [] G nP)) G nP\\<rbrakk>\n    \\<Longrightarrow> set (minimalize_offending_overapprox ff [] G nP)\n                      \\<in> set_offending_flows G nP", "apply(simp add: set_offending_flows_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G; is_offending_flows (set ff) G nP;\n     set ff \\<subseteq> edges G; distinct ff;\n     is_offending_flows_min_set\n      (set (minimalize_offending_overapprox ff [] G nP)) G nP\\<rbrakk>\n    \\<Longrightarrow> set (minimalize_offending_overapprox ff [] G nP)\n                      \\<subseteq> edges G", "using minimalize_offending_overapprox_subseteq_input[where keeps=\"[]\", simplified]"], ["proof (prove)\nusing this:\n  set (minimalize_offending_overapprox ?ff [] ?G ?nP) \\<subseteq> set ?ff\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G; is_offending_flows (set ff) G nP;\n     set ff \\<subseteq> edges G; distinct ff;\n     is_offending_flows_min_set\n      (set (minimalize_offending_overapprox ff [] G nP)) G nP\\<rbrakk>\n    \\<Longrightarrow> set (minimalize_offending_overapprox ff [] G nP)\n                      \\<subseteq> edges G", "by blast"], ["", "(*TODO better minimality condition for keeps*)\n    (*lemma  minimalize_offending_overapprox_sound_fixKeep:\n      \"\\<lbrakk> wf_graph G; is_offending_flows (set (ff @ keeps)) G nP; \\<forall> x \\<in> set ff. x \\<notin> set keeps; \\<forall> x \\<in> set ff. x \\<in> edges G; distinct ff; \n        \\<forall>(e1, e2)\\<in> set keeps. \\<not> sinvar (add_edge e1 e2 (delete_edges G (set (minimalize_offending_overapprox ff keeps G nP)))) nP \\<rbrakk>\n        \\<Longrightarrow>\n         is_offending_flows_min_set (set (minimalize_offending_overapprox ff keeps G nP)) G nP \\<and> set keeps \\<subseteq> (set (minimalize_offending_overapprox ff keeps G nP))\"\n       apply(rule conjI)\n        apply(simp only: is_offending_flows_min_set_def)\n        apply(rule conjI)\n         apply(simp add: is_offending_flows_def is_offending_flows_min_set_def)\n         apply(simp add:minimalize_offending_overapprox_maintains_evalmodel)\n        apply(rule mono_imp_minimalize_offending_overapprox_minimal)\n             apply (metis sinvar_monoI sinvar_mono_imp_negative_delete_edge_mono)\n            apply(simp)\n           apply(simp)\n          apply(simp)\n         apply(simp)\n        apply(simp)\n          \n       apply(thin_tac \"?x\")+\n       apply(induction ff keeps G nP rule: minimalize_offending_overapprox.induct)\n        apply(simp_all)\n      done*)"], ["", "end"], ["", "text\\<open>A version which acts on configured security invariants.\n      I.e. there is no type @{typ 'a} for the host attributes in it.\\<close>"], ["", "fun minimalize_offending_overapprox :: \"('v graph \\<Rightarrow> bool) \\<Rightarrow> ('v \\<times> 'v) list \\<Rightarrow> ('v \\<times> 'v) list \\<Rightarrow> \n'v graph \\<Rightarrow>('v \\<times> 'v) list\" where\n\"minimalize_offending_overapprox _ [] keep _ = keep\" |\n\"minimalize_offending_overapprox m (f#fs) keep G = (if m (delete_edges_list G (fs@keep)) then\n    minimalize_offending_overapprox m fs keep G\n  else\n    minimalize_offending_overapprox m fs (f#keep) G\n  )\""], ["", "lemma minimalize_offending_overapprox_boundnP:\nshows \"minimalize_offending_overapprox (\\<lambda>G. m G nP) fs keeps G =\n         SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox m fs keeps G nP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimalize_offending_overapprox (\\<lambda>G. m G nP) fs keeps G =\n    SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox m\n     fs keeps G nP", "apply(induction fs arbitrary: keeps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>keeps.\n       minimalize_offending_overapprox (\\<lambda>G. m G nP) [] keeps G =\n       SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox\n        m [] keeps G nP\n 2. \\<And>a fs keeps.\n       (\\<And>keeps.\n           minimalize_offending_overapprox (\\<lambda>G. m G nP) fs keeps G =\n           SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox\n            m fs keeps G nP) \\<Longrightarrow>\n       minimalize_offending_overapprox (\\<lambda>G. m G nP) (a # fs) keeps\n        G =\n       SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox\n        m (a # fs) keeps G nP", "apply(simp add: SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox.simps; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a fs keeps.\n       (\\<And>keeps.\n           minimalize_offending_overapprox (\\<lambda>G. m G nP) fs keeps G =\n           SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox\n            m fs keeps G nP) \\<Longrightarrow>\n       minimalize_offending_overapprox (\\<lambda>G. m G nP) (a # fs) keeps\n        G =\n       SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox\n        m (a # fs) keeps G nP", "apply(simp add: SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context SecurityInvariant_withOffendingFlows\nbegin"], ["", "text\\<open>If there is a violation and there are no offending flows, there does not exist a possibility to fix the violation by \n          tightening the policy. @{thm valid_empty_edges_iff_exists_offending_flows} already hints this.\\<close>"], ["", "lemma mono_imp_emptyoffending_eq_nevervalid:\n       \"\\<lbrakk> sinvar_mono; wf_graph G; \\<not> sinvar G nP; set_offending_flows G nP = {}\\<rbrakk> \\<Longrightarrow> \n        \\<not> (\\<exists> F \\<subseteq> edges G. sinvar (delete_edges G F) nP)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sinvar_mono; wf_graph G; \\<not> sinvar G nP;\n     set_offending_flows G nP = {}\\<rbrakk>\n    \\<Longrightarrow> \\<not> (\\<exists>F\\<subseteq>edges G.\n                                 sinvar (delete_edges G F) nP)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sinvar_mono; wf_graph G; \\<not> sinvar G nP;\n     set_offending_flows G nP = {}\\<rbrakk>\n    \\<Longrightarrow> \\<not> (\\<exists>F\\<subseteq>edges G.\n                                 sinvar (delete_edges G F) nP)", "assume mono: \"sinvar_mono\"\n      and wfG: \"wf_graph G\"\n      and a1:  \"\\<not> sinvar G nP\"\n      and a2: \"set_offending_flows G nP = {}\""], ["proof (state)\nthis:\n  sinvar_mono\n  wf_graph G\n  \\<not> sinvar G nP\n  set_offending_flows G nP = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sinvar_mono; wf_graph G; \\<not> sinvar G nP;\n     set_offending_flows G nP = {}\\<rbrakk>\n    \\<Longrightarrow> \\<not> (\\<exists>F\\<subseteq>edges G.\n                                 sinvar (delete_edges G F) nP)", "from wfG"], ["proof (chain)\npicking this:\n  wf_graph G", "have wfG': \"wf_graph \\<lparr>nodes = nodes G, edges = edges G\\<rparr>\""], ["proof (prove)\nusing this:\n  wf_graph G\n\ngoal (1 subgoal):\n 1. wf_graph \\<lparr>nodes = nodes G, edges = edges G\\<rparr>", "by(simp add:wf_graph_def)"], ["proof (state)\nthis:\n  wf_graph \\<lparr>nodes = nodes G, edges = edges G\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sinvar_mono; wf_graph G; \\<not> sinvar G nP;\n     set_offending_flows G nP = {}\\<rbrakk>\n    \\<Longrightarrow> \\<not> (\\<exists>F\\<subseteq>edges G.\n                                 sinvar (delete_edges G F) nP)", "from a2 set_offending_flows_def"], ["proof (chain)\npicking this:\n  set_offending_flows G nP = {}\n  set_offending_flows ?G ?nP =\n  {F. F \\<subseteq> edges ?G \\<and> is_offending_flows_min_set F ?G ?nP}", "have \"\\<forall>f \\<subseteq> edges G. \\<not> is_offending_flows_min_set f G nP\""], ["proof (prove)\nusing this:\n  set_offending_flows G nP = {}\n  set_offending_flows ?G ?nP =\n  {F. F \\<subseteq> edges ?G \\<and> is_offending_flows_min_set F ?G ?nP}\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<subseteq>edges G. \\<not> is_offending_flows_min_set f G nP", "by simp"], ["proof (state)\nthis:\n  \\<forall>f\\<subseteq>edges G. \\<not> is_offending_flows_min_set f G nP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sinvar_mono; wf_graph G; \\<not> sinvar G nP;\n     set_offending_flows G nP = {}\\<rbrakk>\n    \\<Longrightarrow> \\<not> (\\<exists>F\\<subseteq>edges G.\n                                 sinvar (delete_edges G F) nP)", "from this is_offending_flows_min_set_def is_offending_flows_def a1"], ["proof (chain)\npicking this:\n  \\<forall>f\\<subseteq>edges G. \\<not> is_offending_flows_min_set f G nP\n  is_offending_flows_min_set ?f ?G ?nP \\<equiv>\n  is_offending_flows ?f ?G ?nP \\<and>\n  (\\<forall>(e1, e2)\\<in>?f.\n      \\<not> sinvar (add_edge e1 e2 (delete_edges ?G ?f)) ?nP)\n  is_offending_flows ?f ?G ?nP \\<equiv>\n  \\<not> sinvar ?G ?nP \\<and> sinvar (delete_edges ?G ?f) ?nP\n  \\<not> sinvar G nP", "have notdeleteconj:\n        \"\\<forall>f \\<subseteq> edges G. \n          \\<not> sinvar (delete_edges G f) nP \\<or> \n          \\<not> ((\\<forall>(e1, e2)\\<in>f. \\<not> sinvar (add_edge e1 e2 (delete_edges G f)) nP))\""], ["proof (prove)\nusing this:\n  \\<forall>f\\<subseteq>edges G. \\<not> is_offending_flows_min_set f G nP\n  is_offending_flows_min_set ?f ?G ?nP \\<equiv>\n  is_offending_flows ?f ?G ?nP \\<and>\n  (\\<forall>(e1, e2)\\<in>?f.\n      \\<not> sinvar (add_edge e1 e2 (delete_edges ?G ?f)) ?nP)\n  is_offending_flows ?f ?G ?nP \\<equiv>\n  \\<not> sinvar ?G ?nP \\<and> sinvar (delete_edges ?G ?f) ?nP\n  \\<not> sinvar G nP\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<subseteq>edges G.\n       \\<not> sinvar (delete_edges G f) nP \\<or>\n       \\<not> (\\<forall>(e1, e2)\\<in>f.\n                  \\<not> sinvar (add_edge e1 e2 (delete_edges G f)) nP)", "by simp"], ["proof (state)\nthis:\n  \\<forall>f\\<subseteq>edges G.\n     \\<not> sinvar (delete_edges G f) nP \\<or>\n     \\<not> (\\<forall>(e1, e2)\\<in>f.\n                \\<not> sinvar (add_edge e1 e2 (delete_edges G f)) nP)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sinvar_mono; wf_graph G; \\<not> sinvar G nP;\n     set_offending_flows G nP = {}\\<rbrakk>\n    \\<Longrightarrow> \\<not> (\\<exists>F\\<subseteq>edges G.\n                                 sinvar (delete_edges G F) nP)", "have \"\\<forall>f\\<subseteq>edges G. \\<not> sinvar (delete_edges G f) nP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<subseteq>edges G. \\<not> sinvar (delete_edges G f) nP", "proof (rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<subseteq> edges G \\<Longrightarrow>\n       \\<not> sinvar (delete_edges G f) nP", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<subseteq> edges G \\<Longrightarrow>\n       \\<not> sinvar (delete_edges G f) nP", "assume \"f \\<subseteq> edges G\""], ["proof (state)\nthis:\n  f \\<subseteq> edges G\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<subseteq> edges G \\<Longrightarrow>\n       \\<not> sinvar (delete_edges G f) nP", "from this notdeleteconj"], ["proof (chain)\npicking this:\n  f \\<subseteq> edges G\n  \\<forall>f\\<subseteq>edges G.\n     \\<not> sinvar (delete_edges G f) nP \\<or>\n     \\<not> (\\<forall>(e1, e2)\\<in>f.\n                \\<not> sinvar (add_edge e1 e2 (delete_edges G f)) nP)", "have \n         \"\\<not> sinvar (delete_edges G f) nP \\<or> \n          \\<not> ((\\<forall>(e1, e2)\\<in>f. \\<not> sinvar (add_edge e1 e2 (delete_edges G f)) nP))\""], ["proof (prove)\nusing this:\n  f \\<subseteq> edges G\n  \\<forall>f\\<subseteq>edges G.\n     \\<not> sinvar (delete_edges G f) nP \\<or>\n     \\<not> (\\<forall>(e1, e2)\\<in>f.\n                \\<not> sinvar (add_edge e1 e2 (delete_edges G f)) nP)\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges G f) nP \\<or>\n    \\<not> (\\<forall>(e1, e2)\\<in>f.\n               \\<not> sinvar (add_edge e1 e2 (delete_edges G f)) nP)", "by simp"], ["proof (state)\nthis:\n  \\<not> sinvar (delete_edges G f) nP \\<or>\n  \\<not> (\\<forall>(e1, e2)\\<in>f.\n             \\<not> sinvar (add_edge e1 e2 (delete_edges G f)) nP)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<subseteq> edges G \\<Longrightarrow>\n       \\<not> sinvar (delete_edges G f) nP", "from this"], ["proof (chain)\npicking this:\n  \\<not> sinvar (delete_edges G f) nP \\<or>\n  \\<not> (\\<forall>(e1, e2)\\<in>f.\n             \\<not> sinvar (add_edge e1 e2 (delete_edges G f)) nP)", "show \"\\<not> sinvar (delete_edges G f) nP\""], ["proof (prove)\nusing this:\n  \\<not> sinvar (delete_edges G f) nP \\<or>\n  \\<not> (\\<forall>(e1, e2)\\<in>f.\n             \\<not> sinvar (add_edge e1 e2 (delete_edges G f)) nP)\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges G f) nP", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> sinvar (delete_edges G f) nP \\<Longrightarrow>\n    \\<not> sinvar (delete_edges G f) nP\n 2. \\<not> (\\<forall>(e1, e2)\\<in>f.\n               \\<not> sinvar (add_edge e1 e2 (delete_edges G f))\n                       nP) \\<Longrightarrow>\n    \\<not> sinvar (delete_edges G f) nP", "assume \"\\<not> sinvar (delete_edges G f) nP\""], ["proof (state)\nthis:\n  \\<not> sinvar (delete_edges G f) nP\n\ngoal (2 subgoals):\n 1. \\<not> sinvar (delete_edges G f) nP \\<Longrightarrow>\n    \\<not> sinvar (delete_edges G f) nP\n 2. \\<not> (\\<forall>(e1, e2)\\<in>f.\n               \\<not> sinvar (add_edge e1 e2 (delete_edges G f))\n                       nP) \\<Longrightarrow>\n    \\<not> sinvar (delete_edges G f) nP", "thus \"\\<not> sinvar (delete_edges G f) nP\""], ["proof (prove)\nusing this:\n  \\<not> sinvar (delete_edges G f) nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges G f) nP", "."], ["proof (state)\nthis:\n  \\<not> sinvar (delete_edges G f) nP\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(e1, e2)\\<in>f.\n               \\<not> sinvar (add_edge e1 e2 (delete_edges G f))\n                       nP) \\<Longrightarrow>\n    \\<not> sinvar (delete_edges G f) nP", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(e1, e2)\\<in>f.\n               \\<not> sinvar (add_edge e1 e2 (delete_edges G f))\n                       nP) \\<Longrightarrow>\n    \\<not> sinvar (delete_edges G f) nP", "assume \"\\<not> (\\<forall>(e1, e2)\\<in>f. \\<not> sinvar (add_edge e1 e2 (delete_edges G f)) nP)\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>(e1, e2)\\<in>f.\n             \\<not> sinvar (add_edge e1 e2 (delete_edges G f)) nP)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(e1, e2)\\<in>f.\n               \\<not> sinvar (add_edge e1 e2 (delete_edges G f))\n                       nP) \\<Longrightarrow>\n    \\<not> sinvar (delete_edges G f) nP", "hence \"\\<exists>(e1,e2)\\<in>f. sinvar (add_edge e1 e2 (delete_edges G f)) nP\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>(e1, e2)\\<in>f.\n             \\<not> sinvar (add_edge e1 e2 (delete_edges G f)) nP)\n\ngoal (1 subgoal):\n 1. \\<exists>(e1, e2)\\<in>f. sinvar (add_edge e1 e2 (delete_edges G f)) nP", "by(auto)"], ["proof (state)\nthis:\n  \\<exists>(e1, e2)\\<in>f. sinvar (add_edge e1 e2 (delete_edges G f)) nP\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(e1, e2)\\<in>f.\n               \\<not> sinvar (add_edge e1 e2 (delete_edges G f))\n                       nP) \\<Longrightarrow>\n    \\<not> sinvar (delete_edges G f) nP", "from this"], ["proof (chain)\npicking this:\n  \\<exists>(e1, e2)\\<in>f. sinvar (add_edge e1 e2 (delete_edges G f)) nP", "obtain e1 e2 where e1e2cond: \"(e1,e2)\\<in>f \\<and> sinvar (add_edge e1 e2 (delete_edges G f)) nP\""], ["proof (prove)\nusing this:\n  \\<exists>(e1, e2)\\<in>f. sinvar (add_edge e1 e2 (delete_edges G f)) nP\n\ngoal (1 subgoal):\n 1. (\\<And>e1 e2.\n        (e1, e2) \\<in> f \\<and>\n        sinvar (add_edge e1 e2 (delete_edges G f)) nP \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (e1, e2) \\<in> f \\<and> sinvar (add_edge e1 e2 (delete_edges G f)) nP\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(e1, e2)\\<in>f.\n               \\<not> sinvar (add_edge e1 e2 (delete_edges G f))\n                       nP) \\<Longrightarrow>\n    \\<not> sinvar (delete_edges G f) nP", "from \\<open>f \\<subseteq> edges G\\<close> wfG"], ["proof (chain)\npicking this:\n  f \\<subseteq> edges G\n  wf_graph G", "have \"finite f\""], ["proof (prove)\nusing this:\n  f \\<subseteq> edges G\n  wf_graph G\n\ngoal (1 subgoal):\n 1. finite f", "apply(simp add: wf_graph_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<subseteq> edges G;\n     fst ` edges G \\<subseteq> nodes G \\<and>\n     snd ` edges G \\<subseteq> nodes G \\<and>\n     finite (edges G) \\<and> finite (nodes G)\\<rbrakk>\n    \\<Longrightarrow> finite f", "by (metis rev_finite_subset)"], ["proof (state)\nthis:\n  finite f\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(e1, e2)\\<in>f.\n               \\<not> sinvar (add_edge e1 e2 (delete_edges G f))\n                       nP) \\<Longrightarrow>\n    \\<not> sinvar (delete_edges G f) nP", "from this"], ["proof (chain)\npicking this:\n  finite f", "obtain listf where listf: \"set listf = f \\<and> distinct listf\""], ["proof (prove)\nusing this:\n  finite f\n\ngoal (1 subgoal):\n 1. (\\<And>listf.\n        set listf = f \\<and> distinct listf \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis finite_distinct_list)"], ["proof (state)\nthis:\n  set listf = f \\<and> distinct listf\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(e1, e2)\\<in>f.\n               \\<not> sinvar (add_edge e1 e2 (delete_edges G f))\n                       nP) \\<Longrightarrow>\n    \\<not> sinvar (delete_edges G f) nP", "from e1e2cond \\<open>f \\<subseteq> edges G\\<close>"], ["proof (chain)\npicking this:\n  (e1, e2) \\<in> f \\<and> sinvar (add_edge e1 e2 (delete_edges G f)) nP\n  f \\<subseteq> edges G", "have Geq:\n            \"(add_edge e1 e2 (delete_edges G f)) = \\<lparr> nodes = nodes G, edges = edges G - f \\<union> {(e1,e2)}\\<rparr>\""], ["proof (prove)\nusing this:\n  (e1, e2) \\<in> f \\<and> sinvar (add_edge e1 e2 (delete_edges G f)) nP\n  f \\<subseteq> edges G\n\ngoal (1 subgoal):\n 1. add_edge e1 e2 (delete_edges G f) =\n    \\<lparr>nodes = nodes G, edges = edges G - f \\<union> {(e1, e2)}\\<rparr>", "apply(simp add: graph_ops wfG')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(e1, e2) \\<in> f \\<and>\n             sinvar\n              \\<lparr>nodes = insert e1 (insert e2 (nodes G)),\n                 edges = insert (e1, e2) (edges G - f)\\<rparr>\n              nP;\n     f \\<subseteq> edges G\\<rbrakk>\n    \\<Longrightarrow> insert e1 (insert e2 (nodes G)) = nodes G", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<subseteq> edges G; (e1, e2) \\<in> f;\n     sinvar\n      \\<lparr>nodes = insert e1 (insert e2 (nodes G)),\n         edges = insert (e1, e2) (edges G - f)\\<rparr>\n      nP\\<rbrakk>\n    \\<Longrightarrow> insert e1 (insert e2 (nodes G)) = nodes G", "using wfG[unfolded wf_graph_def]"], ["proof (prove)\nusing this:\n  (fst ` edges G \\<subseteq> nodes G \\<and>\n   snd ` edges G \\<subseteq> nodes G) \\<and>\n  finite (edges G) \\<and> finite (nodes G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<subseteq> edges G; (e1, e2) \\<in> f;\n     sinvar\n      \\<lparr>nodes = insert e1 (insert e2 (nodes G)),\n         edges = insert (e1, e2) (edges G - f)\\<rparr>\n      nP\\<rbrakk>\n    \\<Longrightarrow> insert e1 (insert e2 (nodes G)) = nodes G", "by force"], ["proof (state)\nthis:\n  add_edge e1 e2 (delete_edges G f) =\n  \\<lparr>nodes = nodes G, edges = edges G - f \\<union> {(e1, e2)}\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(e1, e2)\\<in>f.\n               \\<not> sinvar (add_edge e1 e2 (delete_edges G f))\n                       nP) \\<Longrightarrow>\n    \\<not> sinvar (delete_edges G f) nP", "from this[symmetric] add_edge_wf[OF delete_edges_wf[OF wfG]]"], ["proof (chain)\npicking this:\n  \\<lparr>nodes = nodes G, edges = edges G - f \\<union> {(e1, e2)}\\<rparr> =\n  add_edge e1 e2 (delete_edges G f)\n  wf_graph (add_edge ?v ?v' (delete_edges G ?E1))", "have \n              \"wf_graph \\<lparr>nodes = nodes G, edges = edges G - f \\<union> {(e1, e2)}\\<rparr>\""], ["proof (prove)\nusing this:\n  \\<lparr>nodes = nodes G, edges = edges G - f \\<union> {(e1, e2)}\\<rparr> =\n  add_edge e1 e2 (delete_edges G f)\n  wf_graph (add_edge ?v ?v' (delete_edges G ?E1))\n\ngoal (1 subgoal):\n 1. wf_graph\n     \\<lparr>nodes = nodes G,\n        edges = edges G - f \\<union> {(e1, e2)}\\<rparr>", "by simp"], ["proof (state)\nthis:\n  wf_graph\n   \\<lparr>nodes = nodes G, edges = edges G - f \\<union> {(e1, e2)}\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(e1, e2)\\<in>f.\n               \\<not> sinvar (add_edge e1 e2 (delete_edges G f))\n                       nP) \\<Longrightarrow>\n    \\<not> sinvar (delete_edges G f) nP", "from mono this"], ["proof (chain)\npicking this:\n  sinvar_mono\n  wf_graph\n   \\<lparr>nodes = nodes G, edges = edges G - f \\<union> {(e1, e2)}\\<rparr>", "have mono'':\n              \"\\<And> E'. E' \\<subseteq> edges G - f \\<union> {(e1, e2)} \\<Longrightarrow>\n                sinvar \\<lparr>nodes = nodes G, edges = edges G - f \\<union> {(e1, e2)}\\<rparr> nP \\<Longrightarrow> \n                sinvar \\<lparr>nodes = nodes G, edges = E'\\<rparr> nP\""], ["proof (prove)\nusing this:\n  sinvar_mono\n  wf_graph\n   \\<lparr>nodes = nodes G, edges = edges G - f \\<union> {(e1, e2)}\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>E'.\n       \\<lbrakk>E' \\<subseteq> edges G - f \\<union> {(e1, e2)};\n        sinvar\n         \\<lparr>nodes = nodes G,\n            edges = edges G - f \\<union> {(e1, e2)}\\<rparr>\n         nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = nodes G, edges = E'\\<rparr>\n                          nP", "unfolding sinvar_mono_def"], ["proof (prove)\nusing this:\n  \\<forall>nP N E' E.\n     wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n     E' \\<subseteq> E \\<and>\n     sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP \\<longrightarrow>\n     sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n  wf_graph\n   \\<lparr>nodes = nodes G, edges = edges G - f \\<union> {(e1, e2)}\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>E'.\n       \\<lbrakk>E' \\<subseteq> edges G - f \\<union> {(e1, e2)};\n        sinvar\n         \\<lparr>nodes = nodes G,\n            edges = edges G - f \\<union> {(e1, e2)}\\<rparr>\n         nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = nodes G, edges = E'\\<rparr>\n                          nP", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?E' \\<subseteq> edges G - f \\<union> {(e1, e2)};\n   sinvar\n    \\<lparr>nodes = nodes G, edges = edges G - f \\<union> {(e1, e2)}\\<rparr>\n    nP\\<rbrakk>\n  \\<Longrightarrow> sinvar \\<lparr>nodes = nodes G, edges = ?E'\\<rparr> nP\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(e1, e2)\\<in>f.\n               \\<not> sinvar (add_edge e1 e2 (delete_edges G f))\n                       nP) \\<Longrightarrow>\n    \\<not> sinvar (delete_edges G f) nP", "from e1e2cond Geq"], ["proof (chain)\npicking this:\n  (e1, e2) \\<in> f \\<and> sinvar (add_edge e1 e2 (delete_edges G f)) nP\n  add_edge e1 e2 (delete_edges G f) =\n  \\<lparr>nodes = nodes G, edges = edges G - f \\<union> {(e1, e2)}\\<rparr>", "have \"sinvar \\<lparr> nodes = nodes G, edges = edges G - f \\<union> {(e1,e2)}\\<rparr> nP\""], ["proof (prove)\nusing this:\n  (e1, e2) \\<in> f \\<and> sinvar (add_edge e1 e2 (delete_edges G f)) nP\n  add_edge e1 e2 (delete_edges G f) =\n  \\<lparr>nodes = nodes G, edges = edges G - f \\<union> {(e1, e2)}\\<rparr>\n\ngoal (1 subgoal):\n 1. sinvar\n     \\<lparr>nodes = nodes G,\n        edges = edges G - f \\<union> {(e1, e2)}\\<rparr>\n     nP", "by simp"], ["proof (state)\nthis:\n  sinvar\n   \\<lparr>nodes = nodes G, edges = edges G - f \\<union> {(e1, e2)}\\<rparr>\n   nP\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(e1, e2)\\<in>f.\n               \\<not> sinvar (add_edge e1 e2 (delete_edges G f))\n                       nP) \\<Longrightarrow>\n    \\<not> sinvar (delete_edges G f) nP", "from this mono''"], ["proof (chain)\npicking this:\n  sinvar\n   \\<lparr>nodes = nodes G, edges = edges G - f \\<union> {(e1, e2)}\\<rparr>\n   nP\n  \\<lbrakk>?E' \\<subseteq> edges G - f \\<union> {(e1, e2)};\n   sinvar\n    \\<lparr>nodes = nodes G, edges = edges G - f \\<union> {(e1, e2)}\\<rparr>\n    nP\\<rbrakk>\n  \\<Longrightarrow> sinvar \\<lparr>nodes = nodes G, edges = ?E'\\<rparr> nP", "have \"sinvar \\<lparr> nodes = nodes G, edges = edges G - f\\<rparr> nP\""], ["proof (prove)\nusing this:\n  sinvar\n   \\<lparr>nodes = nodes G, edges = edges G - f \\<union> {(e1, e2)}\\<rparr>\n   nP\n  \\<lbrakk>?E' \\<subseteq> edges G - f \\<union> {(e1, e2)};\n   sinvar\n    \\<lparr>nodes = nodes G, edges = edges G - f \\<union> {(e1, e2)}\\<rparr>\n    nP\\<rbrakk>\n  \\<Longrightarrow> sinvar \\<lparr>nodes = nodes G, edges = ?E'\\<rparr> nP\n\ngoal (1 subgoal):\n 1. sinvar \\<lparr>nodes = nodes G, edges = edges G - f\\<rparr> nP", "by auto"], ["proof (state)\nthis:\n  sinvar \\<lparr>nodes = nodes G, edges = edges G - f\\<rparr> nP\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(e1, e2)\\<in>f.\n               \\<not> sinvar (add_edge e1 e2 (delete_edges G f))\n                       nP) \\<Longrightarrow>\n    \\<not> sinvar (delete_edges G f) nP", "hence overapprox: \"sinvar (delete_edges G f) nP\""], ["proof (prove)\nusing this:\n  sinvar \\<lparr>nodes = nodes G, edges = edges G - f\\<rparr> nP\n\ngoal (1 subgoal):\n 1. sinvar (delete_edges G f) nP", "by (simp add: delete_edges_simp2)"], ["proof (state)\nthis:\n  sinvar (delete_edges G f) nP\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(e1, e2)\\<in>f.\n               \\<not> sinvar (add_edge e1 e2 (delete_edges G f))\n                       nP) \\<Longrightarrow>\n    \\<not> sinvar (delete_edges G f) nP", "(*Interesting, the opposite of what we want to show holds ...*)"], ["proof (state)\nthis:\n  sinvar (delete_edges G f) nP\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(e1, e2)\\<in>f.\n               \\<not> sinvar (add_edge e1 e2 (delete_edges G f))\n                       nP) \\<Longrightarrow>\n    \\<not> sinvar (delete_edges G f) nP", "from a1 overapprox"], ["proof (chain)\npicking this:\n  \\<not> sinvar G nP\n  sinvar (delete_edges G f) nP", "have \"is_offending_flows f G nP\""], ["proof (prove)\nusing this:\n  \\<not> sinvar G nP\n  sinvar (delete_edges G f) nP\n\ngoal (1 subgoal):\n 1. is_offending_flows f G nP", "by(simp add: is_offending_flows_def)"], ["proof (state)\nthis:\n  is_offending_flows f G nP\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(e1, e2)\\<in>f.\n               \\<not> sinvar (add_edge e1 e2 (delete_edges G f))\n                       nP) \\<Longrightarrow>\n    \\<not> sinvar (delete_edges G f) nP", "from this listf"], ["proof (chain)\npicking this:\n  is_offending_flows f G nP\n  set listf = f \\<and> distinct listf", "have c1: \"is_offending_flows (set listf) G nP\""], ["proof (prove)\nusing this:\n  is_offending_flows f G nP\n  set listf = f \\<and> distinct listf\n\ngoal (1 subgoal):\n 1. is_offending_flows (set listf) G nP", "by(simp add: is_offending_flows_def)"], ["proof (state)\nthis:\n  is_offending_flows (set listf) G nP\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(e1, e2)\\<in>f.\n               \\<not> sinvar (add_edge e1 e2 (delete_edges G f))\n                       nP) \\<Longrightarrow>\n    \\<not> sinvar (delete_edges G f) nP", "from listf \\<open>f \\<subseteq> edges G\\<close>"], ["proof (chain)\npicking this:\n  set listf = f \\<and> distinct listf\n  f \\<subseteq> edges G", "have c2: \"set listf \\<subseteq> edges G\""], ["proof (prove)\nusing this:\n  set listf = f \\<and> distinct listf\n  f \\<subseteq> edges G\n\ngoal (1 subgoal):\n 1. set listf \\<subseteq> edges G", "by simp"], ["proof (state)\nthis:\n  set listf \\<subseteq> edges G\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(e1, e2)\\<in>f.\n               \\<not> sinvar (add_edge e1 e2 (delete_edges G f))\n                       nP) \\<Longrightarrow>\n    \\<not> sinvar (delete_edges G f) nP", "from mono_imp_set_offending_flows_not_empty[OF mono wfG c1 c2 conjunct2[OF listf]]"], ["proof (chain)\npicking this:\n  set_offending_flows G nP \\<noteq> {}", "have \n              \"set_offending_flows G nP \\<noteq> {}\""], ["proof (prove)\nusing this:\n  set_offending_flows G nP \\<noteq> {}\n\ngoal (1 subgoal):\n 1. set_offending_flows G nP \\<noteq> {}", "."], ["proof (state)\nthis:\n  set_offending_flows G nP \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(e1, e2)\\<in>f.\n               \\<not> sinvar (add_edge e1 e2 (delete_edges G f))\n                       nP) \\<Longrightarrow>\n    \\<not> sinvar (delete_edges G f) nP", "from this a2"], ["proof (chain)\npicking this:\n  set_offending_flows G nP \\<noteq> {}\n  set_offending_flows G nP = {}", "have \"False\""], ["proof (prove)\nusing this:\n  set_offending_flows G nP \\<noteq> {}\n  set_offending_flows G nP = {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(e1, e2)\\<in>f.\n               \\<not> sinvar (add_edge e1 e2 (delete_edges G f))\n                       nP) \\<Longrightarrow>\n    \\<not> sinvar (delete_edges G f) nP", "(*I knew this can't be!*)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(e1, e2)\\<in>f.\n               \\<not> sinvar (add_edge e1 e2 (delete_edges G f))\n                       nP) \\<Longrightarrow>\n    \\<not> sinvar (delete_edges G f) nP", "thus \"\\<not> sinvar (delete_edges G f) nP\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> sinvar (delete_edges G f) nP", "by simp"], ["proof (state)\nthis:\n  \\<not> sinvar (delete_edges G f) nP\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> sinvar (delete_edges G f) nP\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>f\\<subseteq>edges G. \\<not> sinvar (delete_edges G f) nP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sinvar_mono; wf_graph G; \\<not> sinvar G nP;\n     set_offending_flows G nP = {}\\<rbrakk>\n    \\<Longrightarrow> \\<not> (\\<exists>F\\<subseteq>edges G.\n                                 sinvar (delete_edges G F) nP)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>f\\<subseteq>edges G. \\<not> sinvar (delete_edges G f) nP\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>F\\<subseteq>edges G. sinvar (delete_edges G F) nP)", "by simp"], ["proof (state)\nthis:\n  \\<not> (\\<exists>F\\<subseteq>edges G. sinvar (delete_edges G F) nP)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(*\ntext{* Old version of security invariant gave @{term \"F \\<in> set_offending_flows G nP\"} and @{term \"sinvar (delete_edges G F) nP\"}\n  as assumption for @{text \"default_secure\"}. We can conclude this from mono. *}\ncontext SecurityInvariant_withOffendingFlows\nbegin\n  lemma mono_exists_offending_flows:\n  \"\\<lbrakk> sinvar_mono; wf_graph G; is_offending_flows (set ff) G nP; set ff \\<subseteq> edges G; distinct ff \\<rbrakk> \n    \\<Longrightarrow> \\<exists>F. F \\<in> set_offending_flows G nP \\<and> sinvar (delete_edges G F) nP\"\n    apply(frule mono_imp_set_offending_flows_not_empty[of G nP ff])\n         apply(simp_all add:is_offending_flows_def)\n    apply(simp add: set_offending_flows_def)\n    apply(erule exE)\n    apply(rename_tac exF)\n    apply(clarify)\n    apply(rule_tac x=\"exF\" in exI)\n    apply(rule conjI)\n     apply(simp)\n    apply(rule conjI)\n     apply(simp)\n    apply(simp add:is_offending_flows_min_set_def is_offending_flows_def)\n  done\nend\n*)"], ["", "subsection \\<open>Monotonicity of offending flows\\<close>"], ["", "context SecurityInvariant_preliminaries\n  begin"], ["", "(*todo: simplify proof*)"], ["", "text\\<open>If there is some @{term \"F'\"} in the offending flows of a small graph and you have a bigger graph, \n          you can extend @{term \"F'\"} by some @{term \"Fadd\"} and minimality in @{term F} is preserved\\<close>"], ["", "lemma minimality_offending_flows_mono_edges_graph_extend:\n    \"\\<lbrakk> wf_graph \\<lparr> nodes = V, edges = E \\<rparr>; E' \\<subseteq> E; Fadd \\<inter> E' = {}; F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr> nP \\<rbrakk> \\<Longrightarrow> \n            (\\<forall>(e1, e2)\\<in>F'. \\<not> sinvar (add_edge e1 e2 (delete_edges \\<lparr>nodes = V, edges = E \\<rparr> (F' \\<union> Fadd))) nP)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E; Fadd \\<inter> E' = {};\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(e1, e2)\\<in>F'.\n                         \\<not> sinvar\n                                 (add_edge e1 e2\n                                   (delete_edges\n                                     \\<lparr>nodes = V, edges = E\\<rparr>\n                                     (F' \\<union> Fadd)))\n                                 nP", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E; Fadd \\<inter> E' = {};\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(e1, e2)\\<in>F'.\n                         \\<not> sinvar\n                                 (add_edge e1 e2\n                                   (delete_edges\n                                     \\<lparr>nodes = V, edges = E\\<rparr>\n                                     (F' \\<union> Fadd)))\n                                 nP", "assume a1: \"wf_graph \\<lparr> nodes = V, edges = E \\<rparr>\"\n      and    a2: \"E' \\<subseteq> E\"\n      and    a3: \"Fadd \\<inter> E' = {}\"\n      and    a4: \"F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr> nP\""], ["proof (state)\nthis:\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n  E' \\<subseteq> E\n  Fadd \\<inter> E' = {}\n  F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr> nP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E; Fadd \\<inter> E' = {};\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(e1, e2)\\<in>F'.\n                         \\<not> sinvar\n                                 (add_edge e1 e2\n                                   (delete_edges\n                                     \\<lparr>nodes = V, edges = E\\<rparr>\n                                     (F' \\<union> Fadd)))\n                                 nP", "from a4"], ["proof (chain)\npicking this:\n  F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr> nP", "have \"F' \\<subseteq> E'\""], ["proof (prove)\nusing this:\n  F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr> nP\n\ngoal (1 subgoal):\n 1. F' \\<subseteq> E'", "by(simp add: set_offending_flows_def)"], ["proof (state)\nthis:\n  F' \\<subseteq> E'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E; Fadd \\<inter> E' = {};\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(e1, e2)\\<in>F'.\n                         \\<not> sinvar\n                                 (add_edge e1 e2\n                                   (delete_edges\n                                     \\<lparr>nodes = V, edges = E\\<rparr>\n                                     (F' \\<union> Fadd)))\n                                 nP", "obtain Eadd where Eadd_prop: \"E' \\<union> Eadd = E\" and \"E' \\<inter> Eadd = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Eadd.\n        \\<lbrakk>E' \\<union> Eadd = E; E' \\<inter> Eadd = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using a2"], ["proof (prove)\nusing this:\n  E' \\<subseteq> E\n\ngoal (1 subgoal):\n 1. (\\<And>Eadd.\n        \\<lbrakk>E' \\<union> Eadd = E; E' \\<inter> Eadd = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  E' \\<union> Eadd = E\n  E' \\<inter> Eadd = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E; Fadd \\<inter> E' = {};\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(e1, e2)\\<in>F'.\n                         \\<not> sinvar\n                                 (add_edge e1 e2\n                                   (delete_edges\n                                     \\<lparr>nodes = V, edges = E\\<rparr>\n                                     (F' \\<union> Fadd)))\n                                 nP", "have Fadd_notinE': \"\\<And>Fadd. Fadd \\<inter> E' = {} \\<Longrightarrow>  E' - (F' \\<union> Fadd) =  E' - F'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Fadd.\n       Fadd \\<inter> E' = {} \\<Longrightarrow>\n       E' - (F' \\<union> Fadd) = E' - F'", "by blast"], ["proof (state)\nthis:\n  ?Fadd \\<inter> E' = {} \\<Longrightarrow>\n  E' - (F' \\<union> ?Fadd) = E' - F'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E; Fadd \\<inter> E' = {};\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(e1, e2)\\<in>F'.\n                         \\<not> sinvar\n                                 (add_edge e1 e2\n                                   (delete_edges\n                                     \\<lparr>nodes = V, edges = E\\<rparr>\n                                     (F' \\<union> Fadd)))\n                                 nP", "from \\<open>F' \\<subseteq> E'\\<close> a1[simplified wf_graph_def] a2"], ["proof (chain)\npicking this:\n  F' \\<subseteq> E'\n  (fst ` edges \\<lparr>nodes = V, edges = E\\<rparr>\n   \\<subseteq> nodes \\<lparr>nodes = V, edges = E\\<rparr> \\<and>\n   snd ` edges \\<lparr>nodes = V, edges = E\\<rparr>\n   \\<subseteq> nodes \\<lparr>nodes = V, edges = E\\<rparr>) \\<and>\n  finite (edges \\<lparr>nodes = V, edges = E\\<rparr>) \\<and>\n  finite (nodes \\<lparr>nodes = V, edges = E\\<rparr>)\n  E' \\<subseteq> E", "have FinV1: \"fst ` F' \\<subseteq> V\" and FinV2: \"snd ` F' \\<subseteq> V\""], ["proof (prove)\nusing this:\n  F' \\<subseteq> E'\n  (fst ` edges \\<lparr>nodes = V, edges = E\\<rparr>\n   \\<subseteq> nodes \\<lparr>nodes = V, edges = E\\<rparr> \\<and>\n   snd ` edges \\<lparr>nodes = V, edges = E\\<rparr>\n   \\<subseteq> nodes \\<lparr>nodes = V, edges = E\\<rparr>) \\<and>\n  finite (edges \\<lparr>nodes = V, edges = E\\<rparr>) \\<and>\n  finite (nodes \\<lparr>nodes = V, edges = E\\<rparr>)\n  E' \\<subseteq> E\n\ngoal (1 subgoal):\n 1. fst ` F' \\<subseteq> V &&& snd ` F' \\<subseteq> V", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>F' \\<subseteq> E';\n     (fst ` edges \\<lparr>nodes = V, edges = E\\<rparr>\n      \\<subseteq> nodes \\<lparr>nodes = V, edges = E\\<rparr> \\<and>\n      snd ` edges \\<lparr>nodes = V, edges = E\\<rparr>\n      \\<subseteq> nodes \\<lparr>nodes = V, edges = E\\<rparr>) \\<and>\n     finite (edges \\<lparr>nodes = V, edges = E\\<rparr>) \\<and>\n     finite (nodes \\<lparr>nodes = V, edges = E\\<rparr>);\n     E' \\<subseteq> E\\<rbrakk>\n    \\<Longrightarrow> fst ` F' \\<subseteq> V\n 2. \\<lbrakk>F' \\<subseteq> E';\n     (fst ` edges \\<lparr>nodes = V, edges = E\\<rparr>\n      \\<subseteq> nodes \\<lparr>nodes = V, edges = E\\<rparr> \\<and>\n      snd ` edges \\<lparr>nodes = V, edges = E\\<rparr>\n      \\<subseteq> nodes \\<lparr>nodes = V, edges = E\\<rparr>) \\<and>\n     finite (edges \\<lparr>nodes = V, edges = E\\<rparr>) \\<and>\n     finite (nodes \\<lparr>nodes = V, edges = E\\<rparr>);\n     E' \\<subseteq> E\\<rbrakk>\n    \\<Longrightarrow> snd ` F' \\<subseteq> V", "from a1"], ["proof (chain)\npicking this:\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>", "have \"fst ` E \\<subseteq> V\""], ["proof (prove)\nusing this:\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n\ngoal (1 subgoal):\n 1. fst ` E \\<subseteq> V", "by(simp add: wf_graph_def)"], ["proof (state)\nthis:\n  fst ` E \\<subseteq> V\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F' \\<subseteq> E';\n     (fst ` edges \\<lparr>nodes = V, edges = E\\<rparr>\n      \\<subseteq> nodes \\<lparr>nodes = V, edges = E\\<rparr> \\<and>\n      snd ` edges \\<lparr>nodes = V, edges = E\\<rparr>\n      \\<subseteq> nodes \\<lparr>nodes = V, edges = E\\<rparr>) \\<and>\n     finite (edges \\<lparr>nodes = V, edges = E\\<rparr>) \\<and>\n     finite (nodes \\<lparr>nodes = V, edges = E\\<rparr>);\n     E' \\<subseteq> E\\<rbrakk>\n    \\<Longrightarrow> fst ` F' \\<subseteq> V\n 2. \\<lbrakk>F' \\<subseteq> E';\n     (fst ` edges \\<lparr>nodes = V, edges = E\\<rparr>\n      \\<subseteq> nodes \\<lparr>nodes = V, edges = E\\<rparr> \\<and>\n      snd ` edges \\<lparr>nodes = V, edges = E\\<rparr>\n      \\<subseteq> nodes \\<lparr>nodes = V, edges = E\\<rparr>) \\<and>\n     finite (edges \\<lparr>nodes = V, edges = E\\<rparr>) \\<and>\n     finite (nodes \\<lparr>nodes = V, edges = E\\<rparr>);\n     E' \\<subseteq> E\\<rbrakk>\n    \\<Longrightarrow> snd ` F' \\<subseteq> V", "with \\<open>F' \\<subseteq> E'\\<close> a2"], ["proof (chain)\npicking this:\n  F' \\<subseteq> E'\n  E' \\<subseteq> E\n  fst ` E \\<subseteq> V", "show \"fst ` F' \\<subseteq> V\""], ["proof (prove)\nusing this:\n  F' \\<subseteq> E'\n  E' \\<subseteq> E\n  fst ` E \\<subseteq> V\n\ngoal (1 subgoal):\n 1. fst ` F' \\<subseteq> V", "by fast"], ["proof (state)\nthis:\n  fst ` F' \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>F' \\<subseteq> E';\n     (fst ` edges \\<lparr>nodes = V, edges = E\\<rparr>\n      \\<subseteq> nodes \\<lparr>nodes = V, edges = E\\<rparr> \\<and>\n      snd ` edges \\<lparr>nodes = V, edges = E\\<rparr>\n      \\<subseteq> nodes \\<lparr>nodes = V, edges = E\\<rparr>) \\<and>\n     finite (edges \\<lparr>nodes = V, edges = E\\<rparr>) \\<and>\n     finite (nodes \\<lparr>nodes = V, edges = E\\<rparr>);\n     E' \\<subseteq> E\\<rbrakk>\n    \\<Longrightarrow> snd ` F' \\<subseteq> V", "from a1"], ["proof (chain)\npicking this:\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>", "have \"snd ` E \\<subseteq> V\""], ["proof (prove)\nusing this:\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n\ngoal (1 subgoal):\n 1. snd ` E \\<subseteq> V", "by(simp add: wf_graph_def)"], ["proof (state)\nthis:\n  snd ` E \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>F' \\<subseteq> E';\n     (fst ` edges \\<lparr>nodes = V, edges = E\\<rparr>\n      \\<subseteq> nodes \\<lparr>nodes = V, edges = E\\<rparr> \\<and>\n      snd ` edges \\<lparr>nodes = V, edges = E\\<rparr>\n      \\<subseteq> nodes \\<lparr>nodes = V, edges = E\\<rparr>) \\<and>\n     finite (edges \\<lparr>nodes = V, edges = E\\<rparr>) \\<and>\n     finite (nodes \\<lparr>nodes = V, edges = E\\<rparr>);\n     E' \\<subseteq> E\\<rbrakk>\n    \\<Longrightarrow> snd ` F' \\<subseteq> V", "with \\<open>F' \\<subseteq> E'\\<close> a2"], ["proof (chain)\npicking this:\n  F' \\<subseteq> E'\n  E' \\<subseteq> E\n  snd ` E \\<subseteq> V", "show \"snd ` F' \\<subseteq> V\""], ["proof (prove)\nusing this:\n  F' \\<subseteq> E'\n  E' \\<subseteq> E\n  snd ` E \\<subseteq> V\n\ngoal (1 subgoal):\n 1. snd ` F' \\<subseteq> V", "by fast"], ["proof (state)\nthis:\n  snd ` F' \\<subseteq> V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst ` F' \\<subseteq> V\n  snd ` F' \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E; Fadd \\<inter> E' = {};\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(e1, e2)\\<in>F'.\n                         \\<not> sinvar\n                                 (add_edge e1 e2\n                                   (delete_edges\n                                     \\<lparr>nodes = V, edges = E\\<rparr>\n                                     (F' \\<union> Fadd)))\n                                 nP", "hence insert_e1_e2_V: \"\\<forall> (e1, e2) \\<in> F'. insert e1 (insert e2 V) = V\""], ["proof (prove)\nusing this:\n  fst ` F' \\<subseteq> V\n  snd ` F' \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<forall>(e1, e2)\\<in>F'. insert e1 (insert e2 V) = V", "by auto"], ["proof (state)\nthis:\n  \\<forall>(e1, e2)\\<in>F'. insert e1 (insert e2 V) = V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E; Fadd \\<inter> E' = {};\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(e1, e2)\\<in>F'.\n                         \\<not> sinvar\n                                 (add_edge e1 e2\n                                   (delete_edges\n                                     \\<lparr>nodes = V, edges = E\\<rparr>\n                                     (F' \\<union> Fadd)))\n                                 nP", "hence add_edge_F: \"\\<forall> (e1, e2) \\<in> F'. add_edge e1 e2 \\<lparr>nodes = V, edges = E' - F' \\<rparr> =  \\<lparr>nodes = V, edges = (E' - F') \\<union> {(e1, e2)}\\<rparr>\""], ["proof (prove)\nusing this:\n  \\<forall>(e1, e2)\\<in>F'. insert e1 (insert e2 V) = V\n\ngoal (1 subgoal):\n 1. \\<forall>(e1, e2)\\<in>F'.\n       add_edge e1 e2 \\<lparr>nodes = V, edges = E' - F'\\<rparr> =\n       \\<lparr>nodes = V, edges = E' - F' \\<union> {(e1, e2)}\\<rparr>", "by(simp add: add_edge_def)"], ["proof (state)\nthis:\n  \\<forall>(e1, e2)\\<in>F'.\n     add_edge e1 e2 \\<lparr>nodes = V, edges = E' - F'\\<rparr> =\n     \\<lparr>nodes = V, edges = E' - F' \\<union> {(e1, e2)}\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E; Fadd \\<inter> E' = {};\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(e1, e2)\\<in>F'.\n                         \\<not> sinvar\n                                 (add_edge e1 e2\n                                   (delete_edges\n                                     \\<lparr>nodes = V, edges = E\\<rparr>\n                                     (F' \\<union> Fadd)))\n                                 nP", "have Fadd_notinE': \"\\<And>Fadd. Fadd \\<inter> E' = {} \\<Longrightarrow>  E' - (F' \\<union> Fadd) =  E' - F'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Fadd.\n       Fadd \\<inter> E' = {} \\<Longrightarrow>\n       E' - (F' \\<union> Fadd) = E' - F'", "by blast"], ["proof (state)\nthis:\n  ?Fadd \\<inter> E' = {} \\<Longrightarrow>\n  E' - (F' \\<union> ?Fadd) = E' - F'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E; Fadd \\<inter> E' = {};\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(e1, e2)\\<in>F'.\n                         \\<not> sinvar\n                                 (add_edge e1 e2\n                                   (delete_edges\n                                     \\<lparr>nodes = V, edges = E\\<rparr>\n                                     (F' \\<union> Fadd)))\n                                 nP", "from \\<open>F' \\<subseteq> E'\\<close> this"], ["proof (chain)\npicking this:\n  F' \\<subseteq> E'\n  ?Fadd \\<inter> E' = {} \\<Longrightarrow>\n  E' - (F' \\<union> ?Fadd) = E' - F'", "have Fadd_notinF: \"\\<And>Fadd. Fadd \\<inter> E' = {} \\<Longrightarrow>  F' \\<inter> Fadd = {}\""], ["proof (prove)\nusing this:\n  F' \\<subseteq> E'\n  ?Fadd \\<inter> E' = {} \\<Longrightarrow>\n  E' - (F' \\<union> ?Fadd) = E' - F'\n\ngoal (1 subgoal):\n 1. \\<And>Fadd.\n       Fadd \\<inter> E' = {} \\<Longrightarrow> F' \\<inter> Fadd = {}", "by blast"], ["proof (state)\nthis:\n  ?Fadd \\<inter> E' = {} \\<Longrightarrow> F' \\<inter> ?Fadd = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E; Fadd \\<inter> E' = {};\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(e1, e2)\\<in>F'.\n                         \\<not> sinvar\n                                 (add_edge e1 e2\n                                   (delete_edges\n                                     \\<lparr>nodes = V, edges = E\\<rparr>\n                                     (F' \\<union> Fadd)))\n                                 nP", "have Fadd_subseteq_Eadd: \"\\<And>Fadd. (Fadd \\<inter> E' = {} \\<and> Fadd \\<subseteq> E) = (Fadd \\<subseteq> Eadd)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Fadd.\n       (Fadd \\<inter> E' = {} \\<and> Fadd \\<subseteq> E) =\n       (Fadd \\<subseteq> Eadd)", "proof(rule iffI, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Fadd.\n       Fadd \\<inter> E' = {} \\<and> Fadd \\<subseteq> E \\<Longrightarrow>\n       Fadd \\<subseteq> Eadd\n 2. \\<And>Fadd.\n       Fadd \\<subseteq> Eadd \\<Longrightarrow>\n       Fadd \\<inter> E' = {} \\<and> Fadd \\<subseteq> E", "case 1"], ["proof (state)\nthis:\n  Fadd_ \\<inter> E' = {} \\<and> Fadd_ \\<subseteq> E\n\ngoal (2 subgoals):\n 1. \\<And>Fadd.\n       Fadd \\<inter> E' = {} \\<and> Fadd \\<subseteq> E \\<Longrightarrow>\n       Fadd \\<subseteq> Eadd\n 2. \\<And>Fadd.\n       Fadd \\<subseteq> Eadd \\<Longrightarrow>\n       Fadd \\<inter> E' = {} \\<and> Fadd \\<subseteq> E", "thus ?case"], ["proof (prove)\nusing this:\n  Fadd_ \\<inter> E' = {} \\<and> Fadd_ \\<subseteq> E\n\ngoal (1 subgoal):\n 1. Fadd_ \\<subseteq> Eadd", "using Eadd_prop a2"], ["proof (prove)\nusing this:\n  Fadd_ \\<inter> E' = {} \\<and> Fadd_ \\<subseteq> E\n  E' \\<union> Eadd = E\n  E' \\<subseteq> E\n\ngoal (1 subgoal):\n 1. Fadd_ \\<subseteq> Eadd", "by blast"], ["proof (state)\nthis:\n  Fadd_ \\<subseteq> Eadd\n\ngoal (1 subgoal):\n 1. \\<And>Fadd.\n       Fadd \\<subseteq> Eadd \\<Longrightarrow>\n       Fadd \\<inter> E' = {} \\<and> Fadd \\<subseteq> E", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Fadd.\n       Fadd \\<subseteq> Eadd \\<Longrightarrow>\n       Fadd \\<inter> E' = {} \\<and> Fadd \\<subseteq> E", "case 2"], ["proof (state)\nthis:\n  Fadd_ \\<subseteq> Eadd\n\ngoal (1 subgoal):\n 1. \\<And>Fadd.\n       Fadd \\<subseteq> Eadd \\<Longrightarrow>\n       Fadd \\<inter> E' = {} \\<and> Fadd \\<subseteq> E", "thus ?case"], ["proof (prove)\nusing this:\n  Fadd_ \\<subseteq> Eadd\n\ngoal (1 subgoal):\n 1. Fadd_ \\<inter> E' = {} \\<and> Fadd_ \\<subseteq> E", "using Eadd_prop a2 \\<open>E' \\<inter> Eadd = {}\\<close>"], ["proof (prove)\nusing this:\n  Fadd_ \\<subseteq> Eadd\n  E' \\<union> Eadd = E\n  E' \\<subseteq> E\n  E' \\<inter> Eadd = {}\n\ngoal (1 subgoal):\n 1. Fadd_ \\<inter> E' = {} \\<and> Fadd_ \\<subseteq> E", "by blast"], ["proof (state)\nthis:\n  Fadd_ \\<inter> E' = {} \\<and> Fadd_ \\<subseteq> E\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?Fadd \\<inter> E' = {} \\<and> ?Fadd \\<subseteq> E) =\n  (?Fadd \\<subseteq> Eadd)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E; Fadd \\<inter> E' = {};\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(e1, e2)\\<in>F'.\n                         \\<not> sinvar\n                                 (add_edge e1 e2\n                                   (delete_edges\n                                     \\<lparr>nodes = V, edges = E\\<rparr>\n                                     (F' \\<union> Fadd)))\n                                 nP", "from a4"], ["proof (chain)\npicking this:\n  F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr> nP", "have \"(\\<forall>(e1, e2)\\<in>F'. \\<not> sinvar (add_edge e1 e2 \\<lparr>nodes = V, edges = E' - F'\\<rparr>) nP)\""], ["proof (prove)\nusing this:\n  F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr> nP\n\ngoal (1 subgoal):\n 1. \\<forall>(e1, e2)\\<in>F'.\n       \\<not> sinvar\n               (add_edge e1 e2 \\<lparr>nodes = V, edges = E' - F'\\<rparr>)\n               nP", "by(simp add: set_offending_flows_def is_offending_flows_min_set_def delete_edges_simp2)"], ["proof (state)\nthis:\n  \\<forall>(e1, e2)\\<in>F'.\n     \\<not> sinvar\n             (add_edge e1 e2 \\<lparr>nodes = V, edges = E' - F'\\<rparr>) nP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E; Fadd \\<inter> E' = {};\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(e1, e2)\\<in>F'.\n                         \\<not> sinvar\n                                 (add_edge e1 e2\n                                   (delete_edges\n                                     \\<lparr>nodes = V, edges = E\\<rparr>\n                                     (F' \\<union> Fadd)))\n                                 nP", "with add_edge_F"], ["proof (chain)\npicking this:\n  \\<forall>(e1, e2)\\<in>F'.\n     add_edge e1 e2 \\<lparr>nodes = V, edges = E' - F'\\<rparr> =\n     \\<lparr>nodes = V, edges = E' - F' \\<union> {(e1, e2)}\\<rparr>\n  \\<forall>(e1, e2)\\<in>F'.\n     \\<not> sinvar\n             (add_edge e1 e2 \\<lparr>nodes = V, edges = E' - F'\\<rparr>) nP", "have noteval_F: \"\\<forall>(e1, e2)\\<in>F'. \\<not> sinvar \\<lparr>nodes = V, edges = (E' - F') \\<union> {(e1, e2)}\\<rparr> nP\""], ["proof (prove)\nusing this:\n  \\<forall>(e1, e2)\\<in>F'.\n     add_edge e1 e2 \\<lparr>nodes = V, edges = E' - F'\\<rparr> =\n     \\<lparr>nodes = V, edges = E' - F' \\<union> {(e1, e2)}\\<rparr>\n  \\<forall>(e1, e2)\\<in>F'.\n     \\<not> sinvar\n             (add_edge e1 e2 \\<lparr>nodes = V, edges = E' - F'\\<rparr>) nP\n\ngoal (1 subgoal):\n 1. \\<forall>(e1, e2)\\<in>F'.\n       \\<not> sinvar\n               \\<lparr>nodes = V,\n                  edges = E' - F' \\<union> {(e1, e2)}\\<rparr>\n               nP", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>(e1, e2)\\<in>F'.\n     \\<not> sinvar\n             \\<lparr>nodes = V, edges = E' - F' \\<union> {(e1, e2)}\\<rparr>\n             nP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E; Fadd \\<inter> E' = {};\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(e1, e2)\\<in>F'.\n                         \\<not> sinvar\n                                 (add_edge e1 e2\n                                   (delete_edges\n                                     \\<lparr>nodes = V, edges = E\\<rparr>\n                                     (F' \\<union> Fadd)))\n                                 nP", "(*proof rule that preserves the tuple*)"], ["proof (state)\nthis:\n  \\<forall>(e1, e2)\\<in>F'.\n     \\<not> sinvar\n             \\<lparr>nodes = V, edges = E' - F' \\<union> {(e1, e2)}\\<rparr>\n             nP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E; Fadd \\<inter> E' = {};\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(e1, e2)\\<in>F'.\n                         \\<not> sinvar\n                                 (add_edge e1 e2\n                                   (delete_edges\n                                     \\<lparr>nodes = V, edges = E\\<rparr>\n                                     (F' \\<union> Fadd)))\n                                 nP", "have tupleBallI: \"\\<And>A P. (\\<And>e1 e2. (e1, e2)\\<in>A \\<Longrightarrow> P (e1, e2)) \\<Longrightarrow> ALL (e1, e2):A. P (e1, e2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A P.\n       (\\<And>e1 e2.\n           (e1, e2) \\<in> A \\<Longrightarrow> P (e1, e2)) \\<Longrightarrow>\n       \\<forall>(e1, e2)\\<in>A. P (e1, e2)", "by force"], ["proof (state)\nthis:\n  (\\<And>e1 e2.\n      (e1, e2) \\<in> ?A \\<Longrightarrow> ?P (e1, e2)) \\<Longrightarrow>\n  \\<forall>(e1, e2)\\<in>?A. ?P (e1, e2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E; Fadd \\<inter> E' = {};\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(e1, e2)\\<in>F'.\n                         \\<not> sinvar\n                                 (add_edge e1 e2\n                                   (delete_edges\n                                     \\<lparr>nodes = V, edges = E\\<rparr>\n                                     (F' \\<union> Fadd)))\n                                 nP", "have \"\\<forall>(e1, e2)\\<in>F'. \\<not> sinvar \\<lparr>nodes = V, edges = (E - (F' \\<union> Fadd)) \\<union> {(e1, e2)}\\<rparr> nP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(e1, e2)\\<in>F'.\n       \\<not> sinvar\n               \\<lparr>nodes = V,\n                  edges = E - (F' \\<union> Fadd) \\<union> {(e1, e2)}\\<rparr>\n               nP", "proof(rule tupleBallI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e1 e2.\n       (e1, e2) \\<in> F' \\<Longrightarrow>\n       \\<not> sinvar\n               \\<lparr>nodes = V,\n                  edges = E - (F' \\<union> Fadd) \\<union> {(e1, e2)}\\<rparr>\n               nP", "fix e1 e2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e1 e2.\n       (e1, e2) \\<in> F' \\<Longrightarrow>\n       \\<not> sinvar\n               \\<lparr>nodes = V,\n                  edges = E - (F' \\<union> Fadd) \\<union> {(e1, e2)}\\<rparr>\n               nP", "assume f2: \"(e1, e2) \\<in> F'\""], ["proof (state)\nthis:\n  (e1, e2) \\<in> F'\n\ngoal (1 subgoal):\n 1. \\<And>e1 e2.\n       (e1, e2) \\<in> F' \\<Longrightarrow>\n       \\<not> sinvar\n               \\<lparr>nodes = V,\n                  edges = E - (F' \\<union> Fadd) \\<union> {(e1, e2)}\\<rparr>\n               nP", "with a3"], ["proof (chain)\npicking this:\n  Fadd \\<inter> E' = {}\n  (e1, e2) \\<in> F'", "have gFadd1: \"\\<not> sinvar \\<lparr>nodes = V, edges = (E' - (F' \\<union> Fadd)) \\<union> {(e1, e2)}\\<rparr> nP\""], ["proof (prove)\nusing this:\n  Fadd \\<inter> E' = {}\n  (e1, e2) \\<in> F'\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            \\<lparr>nodes = V,\n               edges = E' - (F' \\<union> Fadd) \\<union> {(e1, e2)}\\<rparr>\n            nP", "using Fadd_notinE' noteval_F"], ["proof (prove)\nusing this:\n  Fadd \\<inter> E' = {}\n  (e1, e2) \\<in> F'\n  ?Fadd \\<inter> E' = {} \\<Longrightarrow>\n  E' - (F' \\<union> ?Fadd) = E' - F'\n  \\<forall>(e1, e2)\\<in>F'.\n     \\<not> sinvar\n             \\<lparr>nodes = V, edges = E' - F' \\<union> {(e1, e2)}\\<rparr>\n             nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            \\<lparr>nodes = V,\n               edges = E' - (F' \\<union> Fadd) \\<union> {(e1, e2)}\\<rparr>\n            nP", "by fastforce"], ["proof (state)\nthis:\n  \\<not> sinvar\n          \\<lparr>nodes = V,\n             edges = E' - (F' \\<union> Fadd) \\<union> {(e1, e2)}\\<rparr>\n          nP\n\ngoal (1 subgoal):\n 1. \\<And>e1 e2.\n       (e1, e2) \\<in> F' \\<Longrightarrow>\n       \\<not> sinvar\n               \\<lparr>nodes = V,\n                  edges = E - (F' \\<union> Fadd) \\<union> {(e1, e2)}\\<rparr>\n               nP", "from a1 FinV1 FinV2 a3 f2"], ["proof (chain)\npicking this:\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n  fst ` F' \\<subseteq> V\n  snd ` F' \\<subseteq> V\n  Fadd \\<inter> E' = {}\n  (e1, e2) \\<in> F'", "have gFadd2: \n             \"wf_graph \\<lparr>nodes = V, edges = (E - (F' \\<union> Fadd)) \\<union> {(e1, e2)}\\<rparr>\""], ["proof (prove)\nusing this:\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n  fst ` F' \\<subseteq> V\n  snd ` F' \\<subseteq> V\n  Fadd \\<inter> E' = {}\n  (e1, e2) \\<in> F'\n\ngoal (1 subgoal):\n 1. wf_graph\n     \\<lparr>nodes = V,\n        edges = E - (F' \\<union> Fadd) \\<union> {(e1, e2)}\\<rparr>", "by(auto simp add: wf_graph_def)"], ["proof (state)\nthis:\n  wf_graph\n   \\<lparr>nodes = V,\n      edges = E - (F' \\<union> Fadd) \\<union> {(e1, e2)}\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>e1 e2.\n       (e1, e2) \\<in> F' \\<Longrightarrow>\n       \\<not> sinvar\n               \\<lparr>nodes = V,\n                  edges = E - (F' \\<union> Fadd) \\<union> {(e1, e2)}\\<rparr>\n               nP", "from a2 a3 f2"], ["proof (chain)\npicking this:\n  E' \\<subseteq> E\n  Fadd \\<inter> E' = {}\n  (e1, e2) \\<in> F'", "have gFadd3: \n                \"(E' - (F' \\<union> Fadd)) \\<union> {(e1, e2)} \\<subseteq> (E - (F' \\<union> Fadd)) \\<union> {(e1, e2)}\""], ["proof (prove)\nusing this:\n  E' \\<subseteq> E\n  Fadd \\<inter> E' = {}\n  (e1, e2) \\<in> F'\n\ngoal (1 subgoal):\n 1. E' - (F' \\<union> Fadd) \\<union> {(e1, e2)}\n    \\<subseteq> E - (F' \\<union> Fadd) \\<union> {(e1, e2)}", "by blast"], ["proof (state)\nthis:\n  E' - (F' \\<union> Fadd) \\<union> {(e1, e2)}\n  \\<subseteq> E - (F' \\<union> Fadd) \\<union> {(e1, e2)}\n\ngoal (1 subgoal):\n 1. \\<And>e1 e2.\n       (e1, e2) \\<in> F' \\<Longrightarrow>\n       \\<not> sinvar\n               \\<lparr>nodes = V,\n                  edges = E - (F' \\<union> Fadd) \\<union> {(e1, e2)}\\<rparr>\n               nP", "from mono_sinvar[OF gFadd2 gFadd3] gFadd1"], ["proof (chain)\npicking this:\n  sinvar\n   \\<lparr>nodes = V,\n      edges = E - (F' \\<union> Fadd) \\<union> {(e1, e2)}\\<rparr>\n   ?nP \\<Longrightarrow>\n  sinvar\n   \\<lparr>nodes = V,\n      edges = E' - (F' \\<union> Fadd) \\<union> {(e1, e2)}\\<rparr>\n   ?nP\n  \\<not> sinvar\n          \\<lparr>nodes = V,\n             edges = E' - (F' \\<union> Fadd) \\<union> {(e1, e2)}\\<rparr>\n          nP", "show \"\\<not> sinvar \\<lparr>nodes = V, edges = (E - (F' \\<union> Fadd)) \\<union> {(e1, e2)}\\<rparr> nP\""], ["proof (prove)\nusing this:\n  sinvar\n   \\<lparr>nodes = V,\n      edges = E - (F' \\<union> Fadd) \\<union> {(e1, e2)}\\<rparr>\n   ?nP \\<Longrightarrow>\n  sinvar\n   \\<lparr>nodes = V,\n      edges = E' - (F' \\<union> Fadd) \\<union> {(e1, e2)}\\<rparr>\n   ?nP\n  \\<not> sinvar\n          \\<lparr>nodes = V,\n             edges = E' - (F' \\<union> Fadd) \\<union> {(e1, e2)}\\<rparr>\n          nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar\n            \\<lparr>nodes = V,\n               edges = E - (F' \\<union> Fadd) \\<union> {(e1, e2)}\\<rparr>\n            nP", "by blast"], ["proof (state)\nthis:\n  \\<not> sinvar\n          \\<lparr>nodes = V,\n             edges = E - (F' \\<union> Fadd) \\<union> {(e1, e2)}\\<rparr>\n          nP\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>(e1, e2)\\<in>F'.\n     \\<not> sinvar\n             \\<lparr>nodes = V,\n                edges = E - (F' \\<union> Fadd) \\<union> {(e1, e2)}\\<rparr>\n             nP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E; Fadd \\<inter> E' = {};\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(e1, e2)\\<in>F'.\n                         \\<not> sinvar\n                                 (add_edge e1 e2\n                                   (delete_edges\n                                     \\<lparr>nodes = V, edges = E\\<rparr>\n                                     (F' \\<union> Fadd)))\n                                 nP", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>(e1, e2)\\<in>F'.\n     \\<not> sinvar\n             \\<lparr>nodes = V,\n                edges = E - (F' \\<union> Fadd) \\<union> {(e1, e2)}\\<rparr>\n             nP\n\ngoal (1 subgoal):\n 1. \\<forall>(e1, e2)\\<in>F'.\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges \\<lparr>nodes = V, edges = E\\<rparr>\n                   (F' \\<union> Fadd)))\n               nP", "apply(simp add: delete_edges_simp2 Fadd_notinE' add_edge_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>F'.\n       \\<not> sinvar\n               \\<lparr>nodes = V,\n                  edges = insert x (E - (F' \\<union> Fadd))\\<rparr>\n               nP \\<Longrightarrow>\n    \\<forall>x\\<in>F'.\n       case x of\n       (e1, e2) \\<Rightarrow>\n         \\<not> sinvar\n                 \\<lparr>nodes = insert e1 (insert e2 V),\n                    edges = insert (e1, e2) (E - (F' \\<union> Fadd))\\<rparr>\n                 nP", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>x\\<in>F'.\n                   \\<not> sinvar\n                           \\<lparr>nodes = V,\n                              edges =\n                                insert x (E - (F' \\<union> Fadd))\\<rparr>\n                           nP;\n        (a, b) \\<in> F';\n        sinvar\n         \\<lparr>nodes = insert a (insert b V),\n            edges = insert (a, b) (E - (F' \\<union> Fadd))\\<rparr>\n         nP\\<rbrakk>\n       \\<Longrightarrow> False", "using insert_e1_e2_V"], ["proof (prove)\nusing this:\n  \\<forall>(e1, e2)\\<in>F'. insert e1 (insert e2 V) = V\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>x\\<in>F'.\n                   \\<not> sinvar\n                           \\<lparr>nodes = V,\n                              edges =\n                                insert x (E - (F' \\<union> Fadd))\\<rparr>\n                           nP;\n        (a, b) \\<in> F';\n        sinvar\n         \\<lparr>nodes = insert a (insert b V),\n            edges = insert (a, b) (E - (F' \\<union> Fadd))\\<rparr>\n         nP\\<rbrakk>\n       \\<Longrightarrow> False", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>(e1, e2)\\<in>F'.\n     \\<not> sinvar\n             (add_edge e1 e2\n               (delete_edges \\<lparr>nodes = V, edges = E\\<rparr>\n                 (F' \\<union> Fadd)))\n             nP\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The minimality condition of the offending flows also holds if we increase the graph.\\<close>"], ["", "corollary minimality_offending_flows_mono_edges_graph: \n      \"\\<lbrakk> wf_graph \\<lparr> nodes = V, edges = E \\<rparr>; \n         E' \\<subseteq> E;\n         F \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr> nP \\<rbrakk> \\<Longrightarrow>\n      \\<forall>(e1, e2)\\<in>F. \\<not> sinvar (add_edge e1 e2 (delete_edges \\<lparr>nodes = V, edges = E \\<rparr> F)) nP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     F \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n              nP\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(e1, e2)\\<in>F.\n                         \\<not> sinvar\n                                 (add_edge e1 e2\n                                   (delete_edges\n                                     \\<lparr>nodes = V, edges = E\\<rparr>\n                                     F))\n                                 nP", "using minimality_offending_flows_mono_edges_graph_extend[where Fadd=\"{}\", simplified]"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_graph \\<lparr>nodes = ?V, edges = ?E\\<rparr>;\n   ?E' \\<subseteq> ?E;\n   ?F'\n   \\<in> set_offending_flows \\<lparr>nodes = ?V, edges = ?E'\\<rparr>\n          ?nP\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>?F'.\n                       case x of\n                       (e1, e2) \\<Rightarrow>\n                         \\<not> sinvar\n                                 (add_edge e1 e2\n                                   (delete_edges\n                                     \\<lparr>nodes = ?V, edges = ?E\\<rparr>\n                                     ?F'))\n                                 ?nP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     F \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n              nP\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(e1, e2)\\<in>F.\n                         \\<not> sinvar\n                                 (add_edge e1 e2\n                                   (delete_edges\n                                     \\<lparr>nodes = V, edges = E\\<rparr>\n                                     F))\n                                 nP", "by presburger"], ["", "text\\<open>all sets in the set of offending flows are monotonic, hence, for a larger graph, they can be extended to match the smaller graph. I.e. everything is monotonic.\\<close>"], ["", "theorem mono_extend_set_offending_flows: \"\\<lbrakk> wf_graph \\<lparr> nodes = V, edges = E \\<rparr>; E' \\<subseteq> E; F' \\<in> set_offending_flows \\<lparr> nodes = V, edges = E' \\<rparr> nP \\<rbrakk> \\<Longrightarrow>\n        \\<exists> F \\<in> set_offending_flows \\<lparr> nodes = V, edges = E \\<rparr> nP. F' \\<subseteq> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F\\<in>set_offending_flows\n\\<lparr>nodes = V, edges = E\\<rparr> nP.\n                         F' \\<subseteq> F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F\\<in>set_offending_flows\n\\<lparr>nodes = V, edges = E\\<rparr> nP.\n                         F' \\<subseteq> F", "fix F'V E E'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F\\<in>set_offending_flows\n\\<lparr>nodes = V, edges = E\\<rparr> nP.\n                         F' \\<subseteq> F", "assume a1: \"wf_graph \\<lparr> nodes = V, edges = E \\<rparr>\"\n        and    a2: \"E' \\<subseteq> E\"\n        and    a4: \"F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr> nP\"\n\n        \\<comment> \\<open>Idea: @{text \"F = F' \\<union> minimize (E - E')\"}\\<close>"], ["proof (state)\nthis:\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n  E' \\<subseteq> E\n  F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr> nP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F\\<in>set_offending_flows\n\\<lparr>nodes = V, edges = E\\<rparr> nP.\n                         F' \\<subseteq> F", "have \"\\<And>f. wf_graph (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. wf_graph (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> f)", "using delete_edges_wf[OF a1]"], ["proof (prove)\nusing this:\n  wf_graph (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> ?E)\n\ngoal (1 subgoal):\n 1. \\<And>f. wf_graph (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> f)", "by fast"], ["proof (state)\nthis:\n  wf_graph (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> ?f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F\\<in>set_offending_flows\n\\<lparr>nodes = V, edges = E\\<rparr> nP.\n                         F' \\<subseteq> F", "hence wf1: \"\\<And>f. wf_graph \\<lparr>nodes = V, edges = E -f\\<rparr>\""], ["proof (prove)\nusing this:\n  wf_graph (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> ?f)\n\ngoal (1 subgoal):\n 1. \\<And>f. wf_graph \\<lparr>nodes = V, edges = E - f\\<rparr>", "by(simp add: delete_edges_simp2)"], ["proof (state)\nthis:\n  wf_graph \\<lparr>nodes = V, edges = E - ?f\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F\\<in>set_offending_flows\n\\<lparr>nodes = V, edges = E\\<rparr> nP.\n                         F' \\<subseteq> F", "obtain Eadd where Eadd_prop: \"E' \\<union> Eadd = E\" and \"E' \\<inter> Eadd = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Eadd.\n        \\<lbrakk>E' \\<union> Eadd = E; E' \\<inter> Eadd = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using a2"], ["proof (prove)\nusing this:\n  E' \\<subseteq> E\n\ngoal (1 subgoal):\n 1. (\\<And>Eadd.\n        \\<lbrakk>E' \\<union> Eadd = E; E' \\<inter> Eadd = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  E' \\<union> Eadd = E\n  E' \\<inter> Eadd = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F\\<in>set_offending_flows\n\\<lparr>nodes = V, edges = E\\<rparr> nP.\n                         F' \\<subseteq> F", "from a4"], ["proof (chain)\npicking this:\n  F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr> nP", "have \"F' \\<subseteq> E'\""], ["proof (prove)\nusing this:\n  F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr> nP\n\ngoal (1 subgoal):\n 1. F' \\<subseteq> E'", "by(simp add: set_offending_flows_def)"], ["proof (state)\nthis:\n  F' \\<subseteq> E'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F\\<in>set_offending_flows\n\\<lparr>nodes = V, edges = E\\<rparr> nP.\n                         F' \\<subseteq> F", "from wf1"], ["proof (chain)\npicking this:\n  wf_graph \\<lparr>nodes = V, edges = E - ?f\\<rparr>", "have wf2: \"wf_graph \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\""], ["proof (prove)\nusing this:\n  wf_graph \\<lparr>nodes = V, edges = E - ?f\\<rparr>\n\ngoal (1 subgoal):\n 1. wf_graph \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>", "apply(subgoal_tac \"E' - F' \\<union> Eadd = E - F'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>f. wf_graph \\<lparr>nodes = V, edges = E - f\\<rparr>;\n     E' - F' \\<union> Eadd = E - F'\\<rbrakk>\n    \\<Longrightarrow> wf_graph\n                       \\<lparr>nodes = V,\n                          edges = E' - F' \\<union> Eadd\\<rparr>\n 2. (\\<And>f.\n        wf_graph \\<lparr>nodes = V, edges = E - f\\<rparr>) \\<Longrightarrow>\n    E' - F' \\<union> Eadd = E - F'", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        wf_graph \\<lparr>nodes = V, edges = E - f\\<rparr>) \\<Longrightarrow>\n    E' - F' \\<union> Eadd = E - F'", "using Eadd_prop \\<open>E' \\<inter> Eadd = {}\\<close> \\<open>F' \\<subseteq> E'\\<close>"], ["proof (prove)\nusing this:\n  E' \\<union> Eadd = E\n  E' \\<inter> Eadd = {}\n  F' \\<subseteq> E'\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        wf_graph \\<lparr>nodes = V, edges = E - f\\<rparr>) \\<Longrightarrow>\n    E' - F' \\<union> Eadd = E - F'", "by fast"], ["proof (state)\nthis:\n  wf_graph \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F\\<in>set_offending_flows\n\\<lparr>nodes = V, edges = E\\<rparr> nP.\n                         F' \\<subseteq> F", "from a4"], ["proof (chain)\npicking this:\n  F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr> nP", "have offending_F: \"\\<not> sinvar \\<lparr>nodes = V, edges = E'\\<rparr> nP\""], ["proof (prove)\nusing this:\n  F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr> nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar \\<lparr>nodes = V, edges = E'\\<rparr> nP", "by(simp add: set_offending_flows_def is_offending_flows_min_set_def is_offending_flows_def)"], ["proof (state)\nthis:\n  \\<not> sinvar \\<lparr>nodes = V, edges = E'\\<rparr> nP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F\\<in>set_offending_flows\n\\<lparr>nodes = V, edges = E\\<rparr> nP.\n                         F' \\<subseteq> F", "from this mono_sinvar[OF a1 a2]"], ["proof (chain)\npicking this:\n  \\<not> sinvar \\<lparr>nodes = V, edges = E'\\<rparr> nP\n  sinvar \\<lparr>nodes = V, edges = E\\<rparr> ?nP \\<Longrightarrow>\n  sinvar \\<lparr>nodes = V, edges = E'\\<rparr> ?nP", "have \n          goal_noteval: \"\\<not> sinvar \\<lparr>nodes = V, edges = E\\<rparr> nP\""], ["proof (prove)\nusing this:\n  \\<not> sinvar \\<lparr>nodes = V, edges = E'\\<rparr> nP\n  sinvar \\<lparr>nodes = V, edges = E\\<rparr> ?nP \\<Longrightarrow>\n  sinvar \\<lparr>nodes = V, edges = E'\\<rparr> ?nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar \\<lparr>nodes = V, edges = E\\<rparr> nP", "by blast"], ["proof (state)\nthis:\n  \\<not> sinvar \\<lparr>nodes = V, edges = E\\<rparr> nP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F\\<in>set_offending_flows\n\\<lparr>nodes = V, edges = E\\<rparr> nP.\n                         F' \\<subseteq> F", "from a4"], ["proof (chain)\npicking this:\n  F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr> nP", "have eval_E_minus_FEadd_simp: \"sinvar \\<lparr>nodes = V, edges = E' - F'\\<rparr> nP\""], ["proof (prove)\nusing this:\n  F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr> nP\n\ngoal (1 subgoal):\n 1. sinvar \\<lparr>nodes = V, edges = E' - F'\\<rparr> nP", "by(simp add: set_offending_flows_def is_offending_flows_min_set_def is_offending_flows_def delete_edges_simp2)"], ["proof (state)\nthis:\n  sinvar \\<lparr>nodes = V, edges = E' - F'\\<rparr> nP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F\\<in>set_offending_flows\n\\<lparr>nodes = V, edges = E\\<rparr> nP.\n                         F' \\<subseteq> F", "(* moreover have \"E - (F' \\<union> Eadd) = E' - F'\"  using `E' \\<inter> Eadd = {}` Eadd_prop by blast\n         ultimately have eval_E_minus_FEadd: \"sinvar (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> (F' \\<union> Eadd)) nP\"\n           by(simp add: delete_edges_simp2)*)"], ["proof (state)\nthis:\n  sinvar \\<lparr>nodes = V, edges = E' - F'\\<rparr> nP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n               nP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F\\<in>set_offending_flows\n\\<lparr>nodes = V, edges = E\\<rparr> nP.\n                         F' \\<subseteq> F", "show \"\\<exists> F \\<in> set_offending_flows \\<lparr> nodes = V, edges = E \\<rparr> nP. F' \\<subseteq> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "proof(cases \"\\<not> sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n            nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F\n 2. \\<not> \\<not> sinvar\n                   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                   nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "assume assumption_new_violation: \"\\<not> sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP\""], ["proof (state)\nthis:\n  \\<not> sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP\n\ngoal (2 subgoals):\n 1. \\<not> sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n            nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F\n 2. \\<not> \\<not> sinvar\n                   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                   nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "from a1"], ["proof (chain)\npicking this:\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>", "have \"finite Eadd\""], ["proof (prove)\nusing this:\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n\ngoal (1 subgoal):\n 1. finite Eadd", "apply(simp add: wf_graph_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` E \\<subseteq> V \\<and>\n    snd ` E \\<subseteq> V \\<and> finite E \\<and> finite V \\<Longrightarrow>\n    finite Eadd", "using Eadd_prop wf_graph.finiteE"], ["proof (prove)\nusing this:\n  E' \\<union> Eadd = E\n  wf_graph ?G \\<Longrightarrow> finite (edges ?G)\n\ngoal (1 subgoal):\n 1. fst ` E \\<subseteq> V \\<and>\n    snd ` E \\<subseteq> V \\<and> finite E \\<and> finite V \\<Longrightarrow>\n    finite Eadd", "by blast"], ["proof (state)\nthis:\n  finite Eadd\n\ngoal (2 subgoals):\n 1. \\<not> sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n            nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F\n 2. \\<not> \\<not> sinvar\n                   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                   nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "from this"], ["proof (chain)\npicking this:\n  finite Eadd", "obtain Eadd_list where Eadd_list_prop: \"set Eadd_list = Eadd\" and \"distinct Eadd_list\""], ["proof (prove)\nusing this:\n  finite Eadd\n\ngoal (1 subgoal):\n 1. (\\<And>Eadd_list.\n        \\<lbrakk>set Eadd_list = Eadd; distinct Eadd_list\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis finite_distinct_list)"], ["proof (state)\nthis:\n  set Eadd_list = Eadd\n  distinct Eadd_list\n\ngoal (2 subgoals):\n 1. \\<not> sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n            nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F\n 2. \\<not> \\<not> sinvar\n                   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                   nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "from a1"], ["proof (chain)\npicking this:\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>", "have \"finite E'\""], ["proof (prove)\nusing this:\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n\ngoal (1 subgoal):\n 1. finite E'", "apply(simp add: wf_graph_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` E \\<subseteq> V \\<and>\n    snd ` E \\<subseteq> V \\<and> finite E \\<and> finite V \\<Longrightarrow>\n    finite E'", "using Eadd_prop"], ["proof (prove)\nusing this:\n  E' \\<union> Eadd = E\n\ngoal (1 subgoal):\n 1. fst ` E \\<subseteq> V \\<and>\n    snd ` E \\<subseteq> V \\<and> finite E \\<and> finite V \\<Longrightarrow>\n    finite E'", "by blast"], ["proof (state)\nthis:\n  finite E'\n\ngoal (2 subgoals):\n 1. \\<not> sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n            nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F\n 2. \\<not> \\<not> sinvar\n                   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                   nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "from this"], ["proof (chain)\npicking this:\n  finite E'", "obtain E'_list where E'_list_prop: \"set E'_list = E'\" and \"distinct E'_list\""], ["proof (prove)\nusing this:\n  finite E'\n\ngoal (1 subgoal):\n 1. (\\<And>E'_list.\n        \\<lbrakk>set E'_list = E'; distinct E'_list\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis finite_distinct_list)"], ["proof (state)\nthis:\n  set E'_list = E'\n  distinct E'_list\n\ngoal (2 subgoals):\n 1. \\<not> sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n            nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F\n 2. \\<not> \\<not> sinvar\n                   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                   nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "from \\<open>finite E'\\<close> \\<open>F' \\<subseteq> E'\\<close>"], ["proof (chain)\npicking this:\n  finite E'\n  F' \\<subseteq> E'", "obtain F'_list where \"set F'_list = F'\" and \"distinct F'_list\""], ["proof (prove)\nusing this:\n  finite E'\n  F' \\<subseteq> E'\n\ngoal (1 subgoal):\n 1. (\\<And>F'_list.\n        \\<lbrakk>set F'_list = F'; distinct F'_list\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis finite_distinct_list rev_finite_subset)"], ["proof (state)\nthis:\n  set F'_list = F'\n  distinct F'_list\n\ngoal (2 subgoals):\n 1. \\<not> sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n            nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F\n 2. \\<not> \\<not> sinvar\n                   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                   nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "have \"E' - F' \\<union> Eadd - Eadd = E' - F'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E' - F' \\<union> Eadd - Eadd = E' - F'", "using Eadd_prop \\<open>E' \\<inter> Eadd = {}\\<close> \\<open>F' \\<subseteq> E'\\<close>"], ["proof (prove)\nusing this:\n  E' \\<union> Eadd = E\n  E' \\<inter> Eadd = {}\n  F' \\<subseteq> E'\n\ngoal (1 subgoal):\n 1. E' - F' \\<union> Eadd - Eadd = E' - F'", "by blast"], ["proof (state)\nthis:\n  E' - F' \\<union> Eadd - Eadd = E' - F'\n\ngoal (2 subgoals):\n 1. \\<not> sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n            nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F\n 2. \\<not> \\<not> sinvar\n                   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                   nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "with assumption_new_violation eval_E_minus_FEadd_simp"], ["proof (chain)\npicking this:\n  \\<not> sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP\n  sinvar \\<lparr>nodes = V, edges = E' - F'\\<rparr> nP\n  E' - F' \\<union> Eadd - Eadd = E' - F'", "have\n            \"is_offending_flows (set (Eadd_list)) \\<lparr>nodes = V, edges = (E' - F') \\<union> Eadd\\<rparr> nP\""], ["proof (prove)\nusing this:\n  \\<not> sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP\n  sinvar \\<lparr>nodes = V, edges = E' - F'\\<rparr> nP\n  E' - F' \\<union> Eadd - Eadd = E' - F'\n\ngoal (1 subgoal):\n 1. is_offending_flows (set Eadd_list)\n     \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP", "by (simp add: Eadd_list_prop delete_edges_simp2 is_offending_flows_def)"], ["proof (state)\nthis:\n  is_offending_flows (set Eadd_list)\n   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP\n\ngoal (2 subgoals):\n 1. \\<not> sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n            nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F\n 2. \\<not> \\<not> sinvar\n                   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                   nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "from minimalize_offending_overapprox_sound[OF wf2 this _ \\<open>distinct Eadd_list\\<close>]"], ["proof (chain)\npicking this:\n  set Eadd_list\n  \\<subseteq> edges\n               \\<lparr>nodes = V,\n                  edges = E' - F' \\<union> Eadd\\<rparr> \\<Longrightarrow>\n  is_offending_flows_min_set\n   (set (local.minimalize_offending_overapprox Eadd_list []\n          \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP))\n   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP", "have\n            \"is_offending_flows_min_set\n              (set (minimalize_offending_overapprox Eadd_list []\n                 \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP)) \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP\""], ["proof (prove)\nusing this:\n  set Eadd_list\n  \\<subseteq> edges\n               \\<lparr>nodes = V,\n                  edges = E' - F' \\<union> Eadd\\<rparr> \\<Longrightarrow>\n  is_offending_flows_min_set\n   (set (local.minimalize_offending_overapprox Eadd_list []\n          \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP))\n   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP\n\ngoal (1 subgoal):\n 1. is_offending_flows_min_set\n     (set (local.minimalize_offending_overapprox Eadd_list []\n            \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP))\n     \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP", "by(simp add: Eadd_list_prop)"], ["proof (state)\nthis:\n  is_offending_flows_min_set\n   (set (local.minimalize_offending_overapprox Eadd_list []\n          \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP))\n   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP\n\ngoal (2 subgoals):\n 1. \\<not> sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n            nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F\n 2. \\<not> \\<not> sinvar\n                   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                   nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "with minimalize_offending_overapprox_subseteq_input[of \"Eadd_list\" \"[]\" \"\\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\" \"nP\", simplified Eadd_list_prop]"], ["proof (chain)\npicking this:\n  set (local.minimalize_offending_overapprox Eadd_list []\n        \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP)\n  \\<subseteq> Eadd \\<union> set []\n  is_offending_flows_min_set\n   (set (local.minimalize_offending_overapprox Eadd_list []\n          \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP))\n   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP", "obtain Fadd where Fadd_prop: \"is_offending_flows_min_set Fadd \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP\" and \"Fadd \\<subseteq> Eadd\""], ["proof (prove)\nusing this:\n  set (local.minimalize_offending_overapprox Eadd_list []\n        \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP)\n  \\<subseteq> Eadd \\<union> set []\n  is_offending_flows_min_set\n   (set (local.minimalize_offending_overapprox Eadd_list []\n          \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP))\n   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP\n\ngoal (1 subgoal):\n 1. (\\<And>Fadd.\n        \\<lbrakk>is_offending_flows_min_set Fadd\n                  \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                  nP;\n         Fadd \\<subseteq> Eadd\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_offending_flows_min_set Fadd\n   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP\n  Fadd \\<subseteq> Eadd\n\ngoal (2 subgoals):\n 1. \\<not> sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n            nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F\n 2. \\<not> \\<not> sinvar\n                   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                   nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "have graph_edges_simp_helper: \"E' - F' \\<union> Eadd - Fadd =  E - (F' \\<union> Fadd)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E' - F' \\<union> Eadd - Fadd = E - (F' \\<union> Fadd)", "using \\<open>E' \\<inter> Eadd = {}\\<close> Eadd_prop \\<open>F' \\<subseteq> E'\\<close>"], ["proof (prove)\nusing this:\n  E' \\<inter> Eadd = {}\n  E' \\<union> Eadd = E\n  F' \\<subseteq> E'\n\ngoal (1 subgoal):\n 1. E' - F' \\<union> Eadd - Fadd = E - (F' \\<union> Fadd)", "by blast"], ["proof (state)\nthis:\n  E' - F' \\<union> Eadd - Fadd = E - (F' \\<union> Fadd)\n\ngoal (2 subgoals):\n 1. \\<not> sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n            nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F\n 2. \\<not> \\<not> sinvar\n                   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                   nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "from Fadd_prop graph_edges_simp_helper"], ["proof (chain)\npicking this:\n  is_offending_flows_min_set Fadd\n   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP\n  E' - F' \\<union> Eadd - Fadd = E - (F' \\<union> Fadd)", "have\n            goal_eval_Fadd: \"sinvar (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> (F' \\<union> Fadd)) nP\" and\n            pre_goal_minimal_Fadd: \"(\\<forall>(e1, e2)\\<in>Fadd. \\<not> sinvar (add_edge e1 e2 (delete_edges \\<lparr>nodes = V, edges = E \\<rparr> (F' \\<union> Fadd))) nP)\""], ["proof (prove)\nusing this:\n  is_offending_flows_min_set Fadd\n   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP\n  E' - F' \\<union> Eadd - Fadd = E - (F' \\<union> Fadd)\n\ngoal (1 subgoal):\n 1. sinvar\n     (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> (F' \\<union> Fadd))\n     nP &&&\n    \\<forall>(e1, e2)\\<in>Fadd.\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges \\<lparr>nodes = V, edges = E\\<rparr>\n                   (F' \\<union> Fadd)))\n               nP", "by(simp add: is_offending_flows_min_set_def is_offending_flows_def delete_edges_simp2)+"], ["proof (state)\nthis:\n  sinvar\n   (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> (F' \\<union> Fadd)) nP\n  \\<forall>(e1, e2)\\<in>Fadd.\n     \\<not> sinvar\n             (add_edge e1 e2\n               (delete_edges \\<lparr>nodes = V, edges = E\\<rparr>\n                 (F' \\<union> Fadd)))\n             nP\n\ngoal (2 subgoals):\n 1. \\<not> sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n            nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F\n 2. \\<not> \\<not> sinvar\n                   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                   nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "from \\<open>E' \\<inter> Eadd = {}\\<close> \\<open>Fadd \\<subseteq> Eadd\\<close>"], ["proof (chain)\npicking this:\n  E' \\<inter> Eadd = {}\n  Fadd \\<subseteq> Eadd", "have \"Fadd \\<inter> E' = {}\""], ["proof (prove)\nusing this:\n  E' \\<inter> Eadd = {}\n  Fadd \\<subseteq> Eadd\n\ngoal (1 subgoal):\n 1. Fadd \\<inter> E' = {}", "by blast"], ["proof (state)\nthis:\n  Fadd \\<inter> E' = {}\n\ngoal (2 subgoals):\n 1. \\<not> sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n            nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F\n 2. \\<not> \\<not> sinvar\n                   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                   nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "from minimality_offending_flows_mono_edges_graph_extend[OF a1 \\<open>E' \\<subseteq> E\\<close> \\<open>Fadd \\<inter> E' = {}\\<close> a4]"], ["proof (chain)\npicking this:\n  \\<forall>(e1, e2)\\<in>F'.\n     \\<not> sinvar\n             (add_edge e1 e2\n               (delete_edges \\<lparr>nodes = V, edges = E\\<rparr>\n                 (F' \\<union> Fadd)))\n             nP", "have mono_delete_edges_minimal: \"(\\<forall>(e1, e2)\\<in>F'. \\<not> sinvar (add_edge e1 e2 (delete_edges \\<lparr>nodes = V, edges = E \\<rparr> (F' \\<union> Fadd))) nP)\""], ["proof (prove)\nusing this:\n  \\<forall>(e1, e2)\\<in>F'.\n     \\<not> sinvar\n             (add_edge e1 e2\n               (delete_edges \\<lparr>nodes = V, edges = E\\<rparr>\n                 (F' \\<union> Fadd)))\n             nP\n\ngoal (1 subgoal):\n 1. \\<forall>(e1, e2)\\<in>F'.\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges \\<lparr>nodes = V, edges = E\\<rparr>\n                   (F' \\<union> Fadd)))\n               nP", "."], ["proof (state)\nthis:\n  \\<forall>(e1, e2)\\<in>F'.\n     \\<not> sinvar\n             (add_edge e1 e2\n               (delete_edges \\<lparr>nodes = V, edges = E\\<rparr>\n                 (F' \\<union> Fadd)))\n             nP\n\ngoal (2 subgoals):\n 1. \\<not> sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n            nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F\n 2. \\<not> \\<not> sinvar\n                   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                   nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "from mono_delete_edges_minimal pre_goal_minimal_Fadd"], ["proof (chain)\npicking this:\n  \\<forall>(e1, e2)\\<in>F'.\n     \\<not> sinvar\n             (add_edge e1 e2\n               (delete_edges \\<lparr>nodes = V, edges = E\\<rparr>\n                 (F' \\<union> Fadd)))\n             nP\n  \\<forall>(e1, e2)\\<in>Fadd.\n     \\<not> sinvar\n             (add_edge e1 e2\n               (delete_edges \\<lparr>nodes = V, edges = E\\<rparr>\n                 (F' \\<union> Fadd)))\n             nP", "have goal_minimal: \n            \"\\<forall>(e1, e2)\\<in>F' \\<union> Fadd. \\<not> sinvar (add_edge e1 e2 (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> (F' \\<union> Fadd))) nP\""], ["proof (prove)\nusing this:\n  \\<forall>(e1, e2)\\<in>F'.\n     \\<not> sinvar\n             (add_edge e1 e2\n               (delete_edges \\<lparr>nodes = V, edges = E\\<rparr>\n                 (F' \\<union> Fadd)))\n             nP\n  \\<forall>(e1, e2)\\<in>Fadd.\n     \\<not> sinvar\n             (add_edge e1 e2\n               (delete_edges \\<lparr>nodes = V, edges = E\\<rparr>\n                 (F' \\<union> Fadd)))\n             nP\n\ngoal (1 subgoal):\n 1. \\<forall>(e1, e2)\\<in>F' \\<union> Fadd.\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges \\<lparr>nodes = V, edges = E\\<rparr>\n                   (F' \\<union> Fadd)))\n               nP", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>(e1, e2)\\<in>F' \\<union> Fadd.\n     \\<not> sinvar\n             (add_edge e1 e2\n               (delete_edges \\<lparr>nodes = V, edges = E\\<rparr>\n                 (F' \\<union> Fadd)))\n             nP\n\ngoal (2 subgoals):\n 1. \\<not> sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n            nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F\n 2. \\<not> \\<not> sinvar\n                   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                   nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "from Eadd_prop \\<open>Fadd \\<subseteq> Eadd\\<close> \\<open>F' \\<subseteq> E'\\<close>"], ["proof (chain)\npicking this:\n  E' \\<union> Eadd = E\n  Fadd \\<subseteq> Eadd\n  F' \\<subseteq> E'", "have goal_subset: \"F' \\<subseteq> E \\<and> Fadd \\<subseteq> E\""], ["proof (prove)\nusing this:\n  E' \\<union> Eadd = E\n  Fadd \\<subseteq> Eadd\n  F' \\<subseteq> E'\n\ngoal (1 subgoal):\n 1. F' \\<subseteq> E \\<and> Fadd \\<subseteq> E", "by blast"], ["proof (state)\nthis:\n  F' \\<subseteq> E \\<and> Fadd \\<subseteq> E\n\ngoal (2 subgoals):\n 1. \\<not> sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n            nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F\n 2. \\<not> \\<not> sinvar\n                   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                   nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "show \"\\<exists> F \\<in> set_offending_flows \\<lparr> nodes = V, edges = E \\<rparr> nP. F' \\<subseteq> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "apply(simp add: set_offending_flows_def is_offending_flows_min_set_def is_offending_flows_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<subseteq>E.\n       \\<not> sinvar \\<lparr>nodes = V, edges = E\\<rparr> nP \\<and>\n       sinvar (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> x)\n        nP \\<and>\n       (\\<forall>(e1, e2)\\<in>x.\n           \\<not> sinvar\n                   (add_edge e1 e2\n                     (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> x))\n                   nP) \\<and>\n       F' \\<subseteq> x", "apply(rule_tac x=\"F' \\<union> Fadd\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. F' \\<union> Fadd \\<subseteq> E \\<and>\n    \\<not> sinvar \\<lparr>nodes = V, edges = E\\<rparr> nP \\<and>\n    sinvar\n     (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> (F' \\<union> Fadd))\n     nP \\<and>\n    (\\<forall>(e1, e2)\\<in>F' \\<union> Fadd.\n        \\<not> sinvar\n                (add_edge e1 e2\n                  (delete_edges \\<lparr>nodes = V, edges = E\\<rparr>\n                    (F' \\<union> Fadd)))\n                nP) \\<and>\n    F' \\<subseteq> F' \\<union> Fadd", "apply(simp add: goal_noteval goal_eval_Fadd goal_minimal goal_subset)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                  nP.\n     F' \\<subseteq> F\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> sinvar\n                   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                   nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<not> sinvar\n                   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                   nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "assume \"\\<not> \\<not> sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP\""], ["proof (state)\nthis:\n  \\<not> \\<not> sinvar\n                 \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> sinvar\n                   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                   nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "hence assumption_no_new_violation: \"sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP\""], ["proof (prove)\nusing this:\n  \\<not> \\<not> sinvar\n                 \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP\n\ngoal (1 subgoal):\n 1. sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP", "by simp"], ["proof (state)\nthis:\n  sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> sinvar\n                   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                   nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "from this  \\<open>F' \\<subseteq> E'\\<close> \\<open>E' \\<inter> Eadd = {}\\<close>"], ["proof (chain)\npicking this:\n  sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP\n  F' \\<subseteq> E'\n  E' \\<inter> Eadd = {}", "have \"sinvar \\<lparr>nodes = V, edges = E - F'\\<rparr> nP\""], ["proof (prove)\nusing this:\n  sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP\n  F' \\<subseteq> E'\n  E' \\<inter> Eadd = {}\n\ngoal (1 subgoal):\n 1. sinvar \\<lparr>nodes = V, edges = E - F'\\<rparr> nP", "proof(subst Eadd_prop[symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n              nP;\n     F' \\<subseteq> E'; E' \\<inter> Eadd = {}\\<rbrakk>\n    \\<Longrightarrow> sinvar\n                       \\<lparr>nodes = V,\n                          edges = E' \\<union> Eadd - F'\\<rparr>\n                       nP", "assume a1: \"F' \\<subseteq> E'\""], ["proof (state)\nthis:\n  F' \\<subseteq> E'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n              nP;\n     F' \\<subseteq> E'; E' \\<inter> Eadd = {}\\<rbrakk>\n    \\<Longrightarrow> sinvar\n                       \\<lparr>nodes = V,\n                          edges = E' \\<union> Eadd - F'\\<rparr>\n                       nP", "assume a2: \"E' \\<inter> Eadd = {}\""], ["proof (state)\nthis:\n  E' \\<inter> Eadd = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n              nP;\n     F' \\<subseteq> E'; E' \\<inter> Eadd = {}\\<rbrakk>\n    \\<Longrightarrow> sinvar\n                       \\<lparr>nodes = V,\n                          edges = E' \\<union> Eadd - F'\\<rparr>\n                       nP", "assume a3: \"sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP\""], ["proof (state)\nthis:\n  sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n              nP;\n     F' \\<subseteq> E'; E' \\<inter> Eadd = {}\\<rbrakk>\n    \\<Longrightarrow> sinvar\n                       \\<lparr>nodes = V,\n                          edges = E' \\<union> Eadd - F'\\<rparr>\n                       nP", "have \"\\<And>x\\<^sub>1. x\\<^sub>1 \\<inter> E' - Eadd = x\\<^sub>1 \\<inter> E'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>1. x\\<^sub>1 \\<inter> E' - Eadd = x\\<^sub>1 \\<inter> E'", "using a2 Un_Diff_Int"], ["proof (prove)\nusing this:\n  E' \\<inter> Eadd = {}\n  ?A - ?B \\<union> ?A \\<inter> ?B = ?A\n\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>1. x\\<^sub>1 \\<inter> E' - Eadd = x\\<^sub>1 \\<inter> E'", "by auto"], ["proof (state)\nthis:\n  ?x\\<^sub>1 \\<inter> E' - Eadd = ?x\\<^sub>1 \\<inter> E'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n              nP;\n     F' \\<subseteq> E'; E' \\<inter> Eadd = {}\\<rbrakk>\n    \\<Longrightarrow> sinvar\n                       \\<lparr>nodes = V,\n                          edges = E' \\<union> Eadd - F'\\<rparr>\n                       nP", "hence \"F' - Eadd = F'\""], ["proof (prove)\nusing this:\n  ?x\\<^sub>1 \\<inter> E' - Eadd = ?x\\<^sub>1 \\<inter> E'\n\ngoal (1 subgoal):\n 1. F' - Eadd = F'", "using a1"], ["proof (prove)\nusing this:\n  ?x\\<^sub>1 \\<inter> E' - Eadd = ?x\\<^sub>1 \\<inter> E'\n  F' \\<subseteq> E'\n\ngoal (1 subgoal):\n 1. F' - Eadd = F'", "by auto"], ["proof (state)\nthis:\n  F' - Eadd = F'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n              nP;\n     F' \\<subseteq> E'; E' \\<inter> Eadd = {}\\<rbrakk>\n    \\<Longrightarrow> sinvar\n                       \\<lparr>nodes = V,\n                          edges = E' \\<union> Eadd - F'\\<rparr>\n                       nP", "hence \"{} \\<union> (Eadd - F') = Eadd\""], ["proof (prove)\nusing this:\n  F' - Eadd = F'\n\ngoal (1 subgoal):\n 1. {} \\<union> (Eadd - F') = Eadd", "using Int_Diff Un_Diff_Int sup_commute"], ["proof (prove)\nusing this:\n  F' - Eadd = F'\n  ?A \\<inter> ?B - ?C = ?A \\<inter> (?B - ?C)\n  ?A - ?B \\<union> ?A \\<inter> ?B = ?A\n  sup ?x ?y = sup ?y ?x\n\ngoal (1 subgoal):\n 1. {} \\<union> (Eadd - F') = Eadd", "by auto"], ["proof (state)\nthis:\n  {} \\<union> (Eadd - F') = Eadd\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n              nP;\n     F' \\<subseteq> E'; E' \\<inter> Eadd = {}\\<rbrakk>\n    \\<Longrightarrow> sinvar\n                       \\<lparr>nodes = V,\n                          edges = E' \\<union> Eadd - F'\\<rparr>\n                       nP", "thus \"sinvar \\<lparr>nodes = V, edges = E' \\<union> Eadd - F'\\<rparr> nP\""], ["proof (prove)\nusing this:\n  {} \\<union> (Eadd - F') = Eadd\n\ngoal (1 subgoal):\n 1. sinvar \\<lparr>nodes = V, edges = E' \\<union> Eadd - F'\\<rparr> nP", "using a3"], ["proof (prove)\nusing this:\n  {} \\<union> (Eadd - F') = Eadd\n  sinvar \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr> nP\n\ngoal (1 subgoal):\n 1. sinvar \\<lparr>nodes = V, edges = E' \\<union> Eadd - F'\\<rparr> nP", "by (metis Un_Diff sup_bot.left_neutral)"], ["proof (state)\nthis:\n  sinvar \\<lparr>nodes = V, edges = E' \\<union> Eadd - F'\\<rparr> nP\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sinvar \\<lparr>nodes = V, edges = E - F'\\<rparr> nP\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> sinvar\n                   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                   nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "from this"], ["proof (chain)\npicking this:\n  sinvar \\<lparr>nodes = V, edges = E - F'\\<rparr> nP", "have goal_eval: \"sinvar (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> F') nP\""], ["proof (prove)\nusing this:\n  sinvar \\<lparr>nodes = V, edges = E - F'\\<rparr> nP\n\ngoal (1 subgoal):\n 1. sinvar (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> F') nP", "by(simp add: delete_edges_simp2)"], ["proof (state)\nthis:\n  sinvar (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> F') nP\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> sinvar\n                   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                   nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "from Eadd_prop \\<open>F' \\<subseteq> E'\\<close>"], ["proof (chain)\npicking this:\n  E' \\<union> Eadd = E\n  F' \\<subseteq> E'", "have goal_subset: \"F' \\<subseteq> E\""], ["proof (prove)\nusing this:\n  E' \\<union> Eadd = E\n  F' \\<subseteq> E'\n\ngoal (1 subgoal):\n 1. F' \\<subseteq> E", "by(blast)"], ["proof (state)\nthis:\n  F' \\<subseteq> E\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> sinvar\n                   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                   nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "from minimality_offending_flows_mono_edges_graph[OF a1 a2 a4]"], ["proof (chain)\npicking this:\n  \\<forall>(e1, e2)\\<in>F'.\n     \\<not> sinvar\n             (add_edge e1 e2\n               (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> F'))\n             nP", "have goal_minimal: \"(\\<forall>(e1, e2)\\<in>F'. \\<not> sinvar (add_edge e1 e2 (delete_edges \\<lparr>nodes = V, edges = E \\<rparr> F')) nP)\""], ["proof (prove)\nusing this:\n  \\<forall>(e1, e2)\\<in>F'.\n     \\<not> sinvar\n             (add_edge e1 e2\n               (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> F'))\n             nP\n\ngoal (1 subgoal):\n 1. \\<forall>(e1, e2)\\<in>F'.\n       \\<not> sinvar\n               (add_edge e1 e2\n                 (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> F'))\n               nP", "."], ["proof (state)\nthis:\n  \\<forall>(e1, e2)\\<in>F'.\n     \\<not> sinvar\n             (add_edge e1 e2\n               (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> F'))\n             nP\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> sinvar\n                   \\<lparr>nodes = V, edges = E' - F' \\<union> Eadd\\<rparr>\n                   nP \\<Longrightarrow>\n    \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "show \"\\<exists> F \\<in> set_offending_flows \\<lparr> nodes = V, edges = E \\<rparr> nP. F' \\<subseteq> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                    nP.\n       F' \\<subseteq> F", "apply(simp add: set_offending_flows_def is_offending_flows_min_set_def is_offending_flows_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<subseteq>E.\n       \\<not> sinvar \\<lparr>nodes = V, edges = E\\<rparr> nP \\<and>\n       sinvar (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> x)\n        nP \\<and>\n       (\\<forall>(e1, e2)\\<in>x.\n           \\<not> sinvar\n                   (add_edge e1 e2\n                     (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> x))\n                   nP) \\<and>\n       F' \\<subseteq> x", "apply(rule_tac x=\"F'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. F' \\<subseteq> E \\<and>\n    \\<not> sinvar \\<lparr>nodes = V, edges = E\\<rparr> nP \\<and>\n    sinvar (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> F') nP \\<and>\n    (\\<forall>(e1, e2)\\<in>F'.\n        \\<not> sinvar\n                (add_edge e1 e2\n                  (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> F'))\n                nP) \\<and>\n    F' \\<subseteq> F'", "apply(simp add: goal_noteval goal_subset goal_minimal goal_eval)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                  nP.\n     F' \\<subseteq> F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                  nP.\n     F' \\<subseteq> F\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The offending flows are monotonic.\\<close>"], ["", "corollary offending_flows_union_mono: \"\\<lbrakk> wf_graph \\<lparr> nodes = V, edges = E \\<rparr>; E' \\<subseteq> E \\<rbrakk> \\<Longrightarrow> \n      \\<Union> (set_offending_flows \\<lparr> nodes = V, edges = E' \\<rparr> nP) \\<subseteq> \\<Union> (set_offending_flows \\<lparr> nodes = V, edges = E \\<rparr> nP)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E\\<rbrakk>\n    \\<Longrightarrow> \\<Union>\n                       (set_offending_flows\n                         \\<lparr>nodes = V, edges = E'\\<rparr> nP)\n                      \\<subseteq> \\<Union>\n                                   (set_offending_flows\n                                     \\<lparr>nodes = V, edges = E\\<rparr>\n                                     nP)", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b X.\n       \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        E' \\<subseteq> E; (a, b) \\<in> X;\n        X \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n                 nP\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> \\<Union>\n                                (set_offending_flows\n                                  \\<lparr>nodes = V, edges = E\\<rparr> nP)", "apply(drule(2) mono_extend_set_offending_flows)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b X.\n       \\<lbrakk>E' \\<subseteq> E; (a, b) \\<in> X;\n        X \\<in> set_offending_flows \\<lparr>nodes = V, edges = E'\\<rparr>\n                 nP;\n        \\<exists>F\\<in>set_offending_flows\n                        \\<lparr>nodes = V, edges = E\\<rparr> nP.\n           X \\<subseteq> F\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> \\<Union>\n                                (set_offending_flows\n                                  \\<lparr>nodes = V, edges = E\\<rparr> nP)", "by blast"], ["", "(* I guess set_offending_flows = {{e}} does not hold. Consider the Dependability invariant:\n      having a wf graph.\n      Add an edge s.t. a dependability violation occurs.\n      The offending flows now contains the new edge ans all edges on the path from the node with the violation to the end of the new edge. *)"], ["", "lemma set_offending_flows_insert_contains_new:\n   \"\\<lbrakk> wf_graph \\<lparr> nodes = V, edges = insert e E \\<rparr>; set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP = {}; set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr> nP \\<noteq> {} \\<rbrakk> \\<Longrightarrow> \n      {e} \\<in> set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr> nP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = insert e E\\<rparr>;\n     set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP = {};\n     set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr>\n      nP \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> {e}\n                      \\<in> set_offending_flows\n                             \\<lparr>nodes = V, edges = insert e E\\<rparr>\n                             nP", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = insert e E\\<rparr>;\n     set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP = {};\n     set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr>\n      nP \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> {e}\n                      \\<in> set_offending_flows\n                             \\<lparr>nodes = V, edges = insert e E\\<rparr>\n                             nP", "assume wfG: \"wf_graph \\<lparr> nodes = V, edges = insert e E \\<rparr>\"\n       and    a1: \"set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP = {}\"\n       and    a2: \"set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr> nP \\<noteq> {}\""], ["proof (state)\nthis:\n  wf_graph \\<lparr>nodes = V, edges = insert e E\\<rparr>\n  set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP = {}\n  set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr>\n   nP \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = insert e E\\<rparr>;\n     set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP = {};\n     set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr>\n      nP \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> {e}\n                      \\<in> set_offending_flows\n                             \\<lparr>nodes = V, edges = insert e E\\<rparr>\n                             nP", "from a1 a2"], ["proof (chain)\npicking this:\n  set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP = {}\n  set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr>\n   nP \\<noteq>\n  {}", "have \"e \\<notin> E\""], ["proof (prove)\nusing this:\n  set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP = {}\n  set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr>\n   nP \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. e \\<notin> E", "by (metis insert_absorb)"], ["proof (state)\nthis:\n  e \\<notin> E\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = insert e E\\<rparr>;\n     set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP = {};\n     set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr>\n      nP \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> {e}\n                      \\<in> set_offending_flows\n                             \\<lparr>nodes = V, edges = insert e E\\<rparr>\n                             nP", "from a1"], ["proof (chain)\npicking this:\n  set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP = {}", "have a1': \"\\<forall>F \\<subseteq> E. \\<not> is_offending_flows_min_set F \\<lparr>nodes = V, edges = E\\<rparr> nP\""], ["proof (prove)\nusing this:\n  set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP = {}\n\ngoal (1 subgoal):\n 1. \\<forall>F\\<subseteq>E.\n       \\<not> is_offending_flows_min_set F\n               \\<lparr>nodes = V, edges = E\\<rparr> nP", "by(simp add: set_offending_flows_def)"], ["proof (state)\nthis:\n  \\<forall>F\\<subseteq>E.\n     \\<not> is_offending_flows_min_set F\n             \\<lparr>nodes = V, edges = E\\<rparr> nP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = insert e E\\<rparr>;\n     set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP = {};\n     set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr>\n      nP \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> {e}\n                      \\<in> set_offending_flows\n                             \\<lparr>nodes = V, edges = insert e E\\<rparr>\n                             nP", "from a2"], ["proof (chain)\npicking this:\n  set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr>\n   nP \\<noteq>\n  {}", "have a2': \"\\<exists>F \\<subseteq> insert e E. is_offending_flows_min_set F \\<lparr>nodes = V, edges = insert e E\\<rparr> nP\""], ["proof (prove)\nusing this:\n  set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr>\n   nP \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<exists>F\\<subseteq>insert e E.\n       is_offending_flows_min_set F\n        \\<lparr>nodes = V, edges = insert e E\\<rparr> nP", "by(simp add: set_offending_flows_def)"], ["proof (state)\nthis:\n  \\<exists>F\\<subseteq>insert e E.\n     is_offending_flows_min_set F\n      \\<lparr>nodes = V, edges = insert e E\\<rparr> nP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = insert e E\\<rparr>;\n     set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP = {};\n     set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr>\n      nP \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> {e}\n                      \\<in> set_offending_flows\n                             \\<lparr>nodes = V, edges = insert e E\\<rparr>\n                             nP", "from wfG"], ["proof (chain)\npicking this:\n  wf_graph \\<lparr>nodes = V, edges = insert e E\\<rparr>", "have wfG': \"wf_graph \\<lparr> nodes = V, edges = E \\<rparr>\""], ["proof (prove)\nusing this:\n  wf_graph \\<lparr>nodes = V, edges = insert e E\\<rparr>\n\ngoal (1 subgoal):\n 1. wf_graph \\<lparr>nodes = V, edges = E\\<rparr>", "by(simp add:wf_graph_def)"], ["proof (state)\nthis:\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = insert e E\\<rparr>;\n     set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP = {};\n     set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr>\n      nP \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> {e}\n                      \\<in> set_offending_flows\n                             \\<lparr>nodes = V, edges = insert e E\\<rparr>\n                             nP", "from a1 defined_offending[OF wfG']"], ["proof (chain)\npicking this:\n  set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP = {}\n  \\<not> sinvar \\<lparr>nodes = V, edges = E\\<rparr> ?nP \\<Longrightarrow>\n  set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> ?nP \\<noteq> {}", "have evalG: \"sinvar \\<lparr>nodes = V, edges = E \\<rparr> nP\""], ["proof (prove)\nusing this:\n  set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP = {}\n  \\<not> sinvar \\<lparr>nodes = V, edges = E\\<rparr> ?nP \\<Longrightarrow>\n  set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> ?nP \\<noteq> {}\n\ngoal (1 subgoal):\n 1. sinvar \\<lparr>nodes = V, edges = E\\<rparr> nP", "by blast"], ["proof (state)\nthis:\n  sinvar \\<lparr>nodes = V, edges = E\\<rparr> nP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = insert e E\\<rparr>;\n     set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP = {};\n     set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr>\n      nP \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> {e}\n                      \\<in> set_offending_flows\n                             \\<lparr>nodes = V, edges = insert e E\\<rparr>\n                             nP", "from sinvar_monoI[unfolded sinvar_mono_def] wfG' this"], ["proof (chain)\npicking this:\n  \\<forall>nP N E' E.\n     wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n     E' \\<subseteq> E \\<and>\n     sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP \\<longrightarrow>\n     sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n  sinvar \\<lparr>nodes = V, edges = E\\<rparr> nP", "have goal_eval: \"sinvar \\<lparr>nodes = V, edges = E - {e}\\<rparr> nP\""], ["proof (prove)\nusing this:\n  \\<forall>nP N E' E.\n     wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n     E' \\<subseteq> E \\<and>\n     sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP \\<longrightarrow>\n     sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n  sinvar \\<lparr>nodes = V, edges = E\\<rparr> nP\n\ngoal (1 subgoal):\n 1. sinvar \\<lparr>nodes = V, edges = E - {e}\\<rparr> nP", "by (metis Diff_subset)"], ["proof (state)\nthis:\n  sinvar \\<lparr>nodes = V, edges = E - {e}\\<rparr> nP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = insert e E\\<rparr>;\n     set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP = {};\n     set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr>\n      nP \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> {e}\n                      \\<in> set_offending_flows\n                             \\<lparr>nodes = V, edges = insert e E\\<rparr>\n                             nP", "from sinvar_no_offending a2"], ["proof (chain)\npicking this:\n  sinvar ?G ?nP \\<Longrightarrow> set_offending_flows ?G ?nP = {}\n  set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr>\n   nP \\<noteq>\n  {}", "have goal_not_eval: \"\\<not> sinvar \\<lparr>nodes = V, edges = insert e E\\<rparr> nP\""], ["proof (prove)\nusing this:\n  sinvar ?G ?nP \\<Longrightarrow> set_offending_flows ?G ?nP = {}\n  set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr>\n   nP \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<not> sinvar \\<lparr>nodes = V, edges = insert e E\\<rparr> nP", "by blast"], ["proof (state)\nthis:\n  \\<not> sinvar \\<lparr>nodes = V, edges = insert e E\\<rparr> nP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = insert e E\\<rparr>;\n     set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP = {};\n     set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr>\n      nP \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> {e}\n                      \\<in> set_offending_flows\n                             \\<lparr>nodes = V, edges = insert e E\\<rparr>\n                             nP", "obtain a b where e: \"e = (a,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b. e = (a, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases e) blast"], ["proof (state)\nthis:\n  e = (a, b)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = insert e E\\<rparr>;\n     set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP = {};\n     set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr>\n      nP \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> {e}\n                      \\<in> set_offending_flows\n                             \\<lparr>nodes = V, edges = insert e E\\<rparr>\n                             nP", "with wfG"], ["proof (chain)\npicking this:\n  wf_graph \\<lparr>nodes = V, edges = insert e E\\<rparr>\n  e = (a, b)", "have insert_e_V: \"insert a (insert b V) = V\""], ["proof (prove)\nusing this:\n  wf_graph \\<lparr>nodes = V, edges = insert e E\\<rparr>\n  e = (a, b)\n\ngoal (1 subgoal):\n 1. insert a (insert b V) = V", "by(auto simp add: wf_graph_def)"], ["proof (state)\nthis:\n  insert a (insert b V) = V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = insert e E\\<rparr>;\n     set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP = {};\n     set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr>\n      nP \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> {e}\n                      \\<in> set_offending_flows\n                             \\<lparr>nodes = V, edges = insert e E\\<rparr>\n                             nP", "from a1' a2'"], ["proof (chain)\npicking this:\n  \\<forall>F\\<subseteq>E.\n     \\<not> is_offending_flows_min_set F\n             \\<lparr>nodes = V, edges = E\\<rparr> nP\n  \\<exists>F\\<subseteq>insert e E.\n     is_offending_flows_min_set F\n      \\<lparr>nodes = V, edges = insert e E\\<rparr> nP", "have min_set_e: \"is_offending_flows_min_set {e} \\<lparr>nodes = V, edges = insert e E\\<rparr> nP\""], ["proof (prove)\nusing this:\n  \\<forall>F\\<subseteq>E.\n     \\<not> is_offending_flows_min_set F\n             \\<lparr>nodes = V, edges = E\\<rparr> nP\n  \\<exists>F\\<subseteq>insert e E.\n     is_offending_flows_min_set F\n      \\<lparr>nodes = V, edges = insert e E\\<rparr> nP\n\ngoal (1 subgoal):\n 1. is_offending_flows_min_set {e}\n     \\<lparr>nodes = V, edges = insert e E\\<rparr> nP", "apply(simp add: is_offending_flows_min_set_def is_offending_flows_def add_edge_def delete_edges_simp2 goal_not_eval goal_eval)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>F\\<subseteq>E.\n                sinvar \\<lparr>nodes = V, edges = E - F\\<rparr>\n                 nP \\<longrightarrow>\n                sinvar \\<lparr>nodes = V, edges = E\\<rparr> nP \\<or>\n                (\\<exists>x\\<in>F.\n                    \\<not> (case x of\n                            (e1, e2) \\<Rightarrow>\n                              \\<not> sinvar\n\\<lparr>nodes = insert e1 (insert e2 V),\n   edges = insert (e1, e2) (E - F)\\<rparr>\nnP));\n     \\<exists>F\\<subseteq>insert e E.\n        sinvar \\<lparr>nodes = V, edges = insert e E - F\\<rparr> nP \\<and>\n        (\\<forall>x\\<in>F.\n            case x of\n            (e1, e2) \\<Rightarrow>\n              \\<not> sinvar\n                      \\<lparr>nodes = insert e1 (insert e2 V),\n                         edges = insert (e1, e2) (insert e E - F)\\<rparr>\n                      nP)\\<rbrakk>\n    \\<Longrightarrow> case e of\n                      (e1, e2) \\<Rightarrow>\n                        \\<not> sinvar\n                                \\<lparr>nodes = insert e1 (insert e2 V),\n                                   edges = insert (e1, e2) (E - {e})\\<rparr>\n                                nP", "using goal_not_eval"], ["proof (prove)\nusing this:\n  \\<not> sinvar \\<lparr>nodes = V, edges = insert e E\\<rparr> nP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>F\\<subseteq>E.\n                sinvar \\<lparr>nodes = V, edges = E - F\\<rparr>\n                 nP \\<longrightarrow>\n                sinvar \\<lparr>nodes = V, edges = E\\<rparr> nP \\<or>\n                (\\<exists>x\\<in>F.\n                    \\<not> (case x of\n                            (e1, e2) \\<Rightarrow>\n                              \\<not> sinvar\n\\<lparr>nodes = insert e1 (insert e2 V),\n   edges = insert (e1, e2) (E - F)\\<rparr>\nnP));\n     \\<exists>F\\<subseteq>insert e E.\n        sinvar \\<lparr>nodes = V, edges = insert e E - F\\<rparr> nP \\<and>\n        (\\<forall>x\\<in>F.\n            case x of\n            (e1, e2) \\<Rightarrow>\n              \\<not> sinvar\n                      \\<lparr>nodes = insert e1 (insert e2 V),\n                         edges = insert (e1, e2) (insert e E - F)\\<rparr>\n                      nP)\\<rbrakk>\n    \\<Longrightarrow> case e of\n                      (e1, e2) \\<Rightarrow>\n                        \\<not> sinvar\n                                \\<lparr>nodes = insert e1 (insert e2 V),\n                                   edges = insert (e1, e2) (E - {e})\\<rparr>\n                                nP", "by(simp add: e insert_e_V)"], ["proof (state)\nthis:\n  is_offending_flows_min_set {e}\n   \\<lparr>nodes = V, edges = insert e E\\<rparr> nP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = insert e E\\<rparr>;\n     set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP = {};\n     set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr>\n      nP \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> {e}\n                      \\<in> set_offending_flows\n                             \\<lparr>nodes = V, edges = insert e E\\<rparr>\n                             nP", "thus \"{e} \\<in> set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr> nP\""], ["proof (prove)\nusing this:\n  is_offending_flows_min_set {e}\n   \\<lparr>nodes = V, edges = insert e E\\<rparr> nP\n\ngoal (1 subgoal):\n 1. {e}\n    \\<in> set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr>\n           nP", "by(simp add: set_offending_flows_def)"], ["proof (state)\nthis:\n  {e}\n  \\<in> set_offending_flows \\<lparr>nodes = V, edges = insert e E\\<rparr> nP\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "value \"Pow {1::int, 2, 3} \\<union> {{8}, {9}}\""], ["", "value \"\\<Union> x\\<in>Pow {1::int, 2, 3}. \\<Union> y \\<in> {{8::int}, {9}}. {x \\<union> y}\"\n    \n    (*similar to \\<times>_def*)\n    \\<comment> \\<open>combines powerset of A with B\\<close>"], ["", "definition pow_combine :: \"'x set \\<Rightarrow> 'x set set \\<Rightarrow> 'x set set\" where \n      \"pow_combine A B \\<equiv> (\\<Union> X \\<in> Pow A. \\<Union> Y \\<in> B. {X \\<union> Y}) \\<union> Pow A\""], ["", "value \"pow_combine {1::int,2} {{5::int, 6}, {8}}\""], ["", "value \"pow_combine {1::int,2} {}\""], ["", "lemma pow_combine_mono: \n    fixes S :: \"'a set set\"\n    and   X :: \"'a set\"\n    and   Y :: \"'a set\"\n    assumes a1: \"\\<forall> F \\<in> S. F \\<subseteq> X\"\n    shows \"\\<forall> F \\<in> pow_combine Y S. F \\<subseteq> Y \\<union> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>pow_combine Y S. F \\<subseteq> Y \\<union> X", "apply(simp add: pow_combine_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>(\\<Union>X\\<in>Pow Y.\n                       \\<Union>Y\\<in>S. {X \\<union> Y}) \\<union>\n                   Pow Y.\n       F \\<subseteq> Y \\<union> X", "apply(rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F.\n       F \\<in> (\\<Union>X\\<in>Pow Y.\n                   \\<Union>Y\\<in>S. {X \\<union> Y}) \\<union>\n               Pow Y \\<Longrightarrow>\n       F \\<subseteq> Y \\<union> X", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F.\n       (\\<exists>x\\<in>Pow Y. \\<exists>xa\\<in>S. F = x \\<union> xa) \\<or>\n       F \\<subseteq> Y \\<Longrightarrow>\n       F \\<subseteq> Y \\<union> X", "by (metis Pow_iff assms sup.coboundedI1 sup.orderE sup.orderI sup_assoc)"], ["", "lemma \"S \\<subseteq> pow_combine X S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> pow_combine X S", "by(auto simp add: pow_combine_def)"], ["", "lemma \"Pow X \\<subseteq> pow_combine X S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pow X \\<subseteq> pow_combine X S", "by(auto simp add: pow_combine_def)"], ["", "lemma rule_pow_combine_fixfst: \"B \\<subseteq> C \\<Longrightarrow> pow_combine A B \\<subseteq> pow_combine A C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<subseteq> C \\<Longrightarrow>\n    pow_combine A B \\<subseteq> pow_combine A C", "by(auto simp add: pow_combine_def)"], ["", "value \"pow_combine {1::int,2} {{5::int, 6}, {1}} \\<subseteq> pow_combine {1::int,2} {{5::int, 6}, {8}}\""], ["", "lemma rule_pow_combine_fixfst_Union: \"\\<Union> B \\<subseteq> \\<Union> C \\<Longrightarrow> \\<Union> (pow_combine A B) \\<subseteq> \\<Union> (pow_combine A C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> B \\<subseteq> \\<Union> C \\<Longrightarrow>\n    \\<Union> (pow_combine A B) \\<subseteq> \\<Union> (pow_combine A C)", "apply(rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<Union> B \\<subseteq> \\<Union> C;\n        x \\<in> \\<Union> (pow_combine A B)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<Union> (pow_combine A C)", "apply(fastforce simp: pow_combine_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*does the following hold?\n      (set_offending_flows \\<lparr>nodes = V, edges = E \\<union> X\\<rparr> nP) \\<subseteq> pow_combine X (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP)\n\n      I guess not:  ^D  I'm convinced this does not hold!\n      Graph:   A -> B -> C\n      E = A -> B\n      E \\<union> X = A -> B -> C\n      \n      model is A and C are interfering\n\n      set_offending_flows(E \\<union> X) = {{(A,B)}, {B,C}}\n       set_offending_flows(E) = {}\n      pow_combine X set_offending_flows(E) = {{}, {C}}\n\n      the {(A,B)} is the problem here such that subset does not hold.\n\n      It holds if\n        \\<forall> F \\<in> (set_offending_flows \\<lparr>nodes = V, edges = E \\<union> X\\<rparr> nP). F \\<subseteq> X\n      however, then (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP) = {} which renders the whole statement useless\n     *)"], ["", "context SecurityInvariant_preliminaries\n  begin"], ["", "lemma offending_partition_subset_empty: \n    assumes a1:\"\\<forall> F \\<in> (set_offending_flows \\<lparr>nodes = V, edges = E \\<union> X\\<rparr> nP). F \\<subseteq> X\"\n    and wfGEX: \"wf_graph \\<lparr>nodes = V, edges = E \\<union> X\\<rparr>\"\n    and disj: \"E \\<inter> X = {}\"\n    shows \"(set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP = {}", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP \\<noteq>\n    {} \\<Longrightarrow>\n    False", "assume c: \"set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP \\<noteq> {}\""], ["proof (state)\nthis:\n  set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP \\<noteq> {}\n\ngoal (1 subgoal):\n 1. set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP \\<noteq>\n    {} \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP \\<noteq> {}", "obtain F' where F'_prop: \"F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP\""], ["proof (prove)\nusing this:\n  set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>F'.\n        F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                  nP \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP\n\ngoal (1 subgoal):\n 1. set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP \\<noteq>\n    {} \\<Longrightarrow>\n    False", "from F'_prop"], ["proof (chain)\npicking this:\n  F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP", "have \"F' \\<subseteq> E\""], ["proof (prove)\nusing this:\n  F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP\n\ngoal (1 subgoal):\n 1. F' \\<subseteq> E", "using set_offending_flows_def"], ["proof (prove)\nusing this:\n  F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP\n  set_offending_flows ?G ?nP =\n  {F. F \\<subseteq> edges ?G \\<and> is_offending_flows_min_set F ?G ?nP}\n\ngoal (1 subgoal):\n 1. F' \\<subseteq> E", "by simp"], ["proof (state)\nthis:\n  F' \\<subseteq> E\n\ngoal (1 subgoal):\n 1. set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP \\<noteq>\n    {} \\<Longrightarrow>\n    False", "from mono_extend_set_offending_flows[OF wfGEX _ F'_prop]"], ["proof (chain)\npicking this:\n  E \\<subseteq> E \\<union> X \\<Longrightarrow>\n  \\<exists>F\\<in>set_offending_flows\n                  \\<lparr>nodes = V, edges = E \\<union> X\\<rparr> nP.\n     F' \\<subseteq> F", "have \n        \"\\<exists>F\\<in>set_offending_flows \\<lparr>nodes = V, edges = E \\<union> X\\<rparr> nP. F' \\<subseteq> F\""], ["proof (prove)\nusing this:\n  E \\<subseteq> E \\<union> X \\<Longrightarrow>\n  \\<exists>F\\<in>set_offending_flows\n                  \\<lparr>nodes = V, edges = E \\<union> X\\<rparr> nP.\n     F' \\<subseteq> F\n\ngoal (1 subgoal):\n 1. \\<exists>F\\<in>set_offending_flows\n                    \\<lparr>nodes = V, edges = E \\<union> X\\<rparr> nP.\n       F' \\<subseteq> F", "by blast"], ["proof (state)\nthis:\n  \\<exists>F\\<in>set_offending_flows\n                  \\<lparr>nodes = V, edges = E \\<union> X\\<rparr> nP.\n     F' \\<subseteq> F\n\ngoal (1 subgoal):\n 1. set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP \\<noteq>\n    {} \\<Longrightarrow>\n    False", "from this a1"], ["proof (chain)\npicking this:\n  \\<exists>F\\<in>set_offending_flows\n                  \\<lparr>nodes = V, edges = E \\<union> X\\<rparr> nP.\n     F' \\<subseteq> F\n  \\<forall>F\\<in>set_offending_flows\n                  \\<lparr>nodes = V, edges = E \\<union> X\\<rparr> nP.\n     F \\<subseteq> X", "have \"F' \\<subseteq> X\""], ["proof (prove)\nusing this:\n  \\<exists>F\\<in>set_offending_flows\n                  \\<lparr>nodes = V, edges = E \\<union> X\\<rparr> nP.\n     F' \\<subseteq> F\n  \\<forall>F\\<in>set_offending_flows\n                  \\<lparr>nodes = V, edges = E \\<union> X\\<rparr> nP.\n     F \\<subseteq> X\n\ngoal (1 subgoal):\n 1. F' \\<subseteq> X", "by fast"], ["proof (state)\nthis:\n  F' \\<subseteq> X\n\ngoal (1 subgoal):\n 1. set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP \\<noteq>\n    {} \\<Longrightarrow>\n    False", "from F'_prop"], ["proof (chain)\npicking this:\n  F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP", "have \"{} \\<noteq> F'\""], ["proof (prove)\nusing this:\n  F' \\<in> set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP\n\ngoal (1 subgoal):\n 1. {} \\<noteq> F'", "by (metis empty_offending_contra)"], ["proof (state)\nthis:\n  {} \\<noteq> F'\n\ngoal (1 subgoal):\n 1. set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP \\<noteq>\n    {} \\<Longrightarrow>\n    False", "from \\<open>F' \\<subseteq> X\\<close> \\<open>F' \\<subseteq> E\\<close> disj \\<open>{} \\<noteq> F'\\<close>"], ["proof (chain)\npicking this:\n  F' \\<subseteq> X\n  F' \\<subseteq> E\n  E \\<inter> X = {}\n  {} \\<noteq> F'", "show \"False\""], ["proof (prove)\nusing this:\n  F' \\<subseteq> X\n  F' \\<subseteq> E\n  E \\<inter> X = {}\n  {} \\<noteq> F'\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary partitioned_offending_subseteq_pow_combine:\n    assumes wfGEX: \"wf_graph \\<lparr>nodes = V, edges = E \\<union> X\\<rparr>\"\n    and disj: \"E \\<inter> X = {}\"\n    and partitioned_offending: \"\\<forall> F \\<in> (set_offending_flows \\<lparr>nodes = V, edges = E \\<union> X\\<rparr> nP). F \\<subseteq> X\" (*offending does not contain E*)\n    shows \"(set_offending_flows \\<lparr>nodes = V, edges = E \\<union> X\\<rparr> nP) \\<subseteq> pow_combine X (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_offending_flows \\<lparr>nodes = V, edges = E \\<union> X\\<rparr> nP\n    \\<subseteq> pow_combine X\n                 (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                   nP)", "apply(subst offending_partition_subset_empty[OF partitioned_offending wfGEX disj])"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_offending_flows \\<lparr>nodes = V, edges = E \\<union> X\\<rparr> nP\n    \\<subseteq> pow_combine X {}", "apply(simp add: pow_combine_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_offending_flows \\<lparr>nodes = V, edges = E \\<union> X\\<rparr> nP\n    \\<subseteq> Pow X", "apply(rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_offending_flows\n                \\<lparr>nodes = V, edges = E \\<union> X\\<rparr>\n                nP \\<Longrightarrow>\n       x \\<in> Pow X", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_offending_flows\n                \\<lparr>nodes = V, edges = E \\<union> X\\<rparr>\n                nP \\<Longrightarrow>\n       x \\<subseteq> X", "using partitioned_offending"], ["proof (prove)\nusing this:\n  \\<forall>F\\<in>set_offending_flows\n                  \\<lparr>nodes = V, edges = E \\<union> X\\<rparr> nP.\n     F \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_offending_flows\n                \\<lparr>nodes = V, edges = E \\<union> X\\<rparr>\n                nP \\<Longrightarrow>\n       x \\<subseteq> X", "by simp"], ["", "end"], ["", "context SecurityInvariant_preliminaries\n  begin"], ["", "text\\<open>Knowing that the \\<open>\\<Union> offending is \\<subseteq> X\\<close>, removing something from the graphs's edges, \n           it also disappears from the offending flows.\\<close>"], ["", "lemma Un_set_offending_flows_bound_minus:\n    assumes wfG: \"wf_graph \\<lparr> nodes = V, edges = E \\<rparr>\"\n    and     Foffending: \"\\<Union>(set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP) \\<subseteq> X\"\n    shows   \"\\<Union>(set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP) \\<subseteq> X - {f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP)\n    \\<subseteq> X - {f}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Union>\n     (set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP)\n    \\<subseteq> X - {f}", "from wfG"], ["proof (chain)\npicking this:\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>", "have wfG': \"wf_graph \\<lparr> nodes = V, edges = E - {f} \\<rparr>\""], ["proof (prove)\nusing this:\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n\ngoal (1 subgoal):\n 1. wf_graph \\<lparr>nodes = V, edges = E - {f}\\<rparr>", "by(auto simp add: wf_graph_def finite_subset)"], ["proof (state)\nthis:\n  wf_graph \\<lparr>nodes = V, edges = E - {f}\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP)\n    \\<subseteq> X - {f}", "from offending_flows_union_mono[OF wfG, where E'=\"E - {f}\"]"], ["proof (chain)\npicking this:\n  E - {f} \\<subseteq> E \\<Longrightarrow>\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> ?nP)\n  \\<subseteq> \\<Union>\n               (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                 ?nP)", "have \n        \"\\<Union>(set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP) - {f} \\<subseteq> \\<Union>(set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP) - {f}\""], ["proof (prove)\nusing this:\n  E - {f} \\<subseteq> E \\<Longrightarrow>\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> ?nP)\n  \\<subseteq> \\<Union>\n               (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                 ?nP)\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP) -\n    {f}\n    \\<subseteq> \\<Union>\n                 (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                   nP) -\n                {f}", "by blast"], ["proof (state)\nthis:\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP) -\n  {f}\n  \\<subseteq> \\<Union>\n               (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                 nP) -\n              {f}\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP)\n    \\<subseteq> X - {f}", "also"], ["proof (state)\nthis:\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP) -\n  {f}\n  \\<subseteq> \\<Union>\n               (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                 nP) -\n              {f}\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP)\n    \\<subseteq> X - {f}", "have \n        \"\\<Union>(set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP) \\<subseteq> \\<Union>(set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP) - {f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP)\n    \\<subseteq> \\<Union>\n                 (set_offending_flows\n                   \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP) -\n                {f}", "apply(simp add: set_offending_flows_simp[OF wfG'])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     {F. F \\<subseteq> E - {f} \\<and>\n         \\<not> sinvar \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP \\<and>\n         sinvar \\<lparr>nodes = V, edges = E - {f} - F\\<rparr> nP \\<and>\n         (\\<forall>x\\<in>F.\n             \\<not> sinvar\n                     \\<lparr>nodes = V,\n                        edges = insert x (E - {f} - F)\\<rparr>\n                     nP)}\n    \\<subseteq> \\<Union>\n                 {F. F \\<subseteq> E - {f} \\<and>\n                     \\<not> sinvar\n                             \\<lparr>nodes = V, edges = E - {f}\\<rparr>\n                             nP \\<and>\n                     sinvar \\<lparr>nodes = V, edges = E - {f} - F\\<rparr>\n                      nP \\<and>\n                     (\\<forall>x\\<in>F.\n                         \\<not> sinvar\n                                 \\<lparr>nodes = V,\n                                    edges = insert x (E - {f} - F)\\<rparr>\n                                 nP)} -\n                {f}", "by blast"], ["proof (state)\nthis:\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP)\n  \\<subseteq> \\<Union>\n               (set_offending_flows\n                 \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP) -\n              {f}\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP)\n    \\<subseteq> X - {f}", "ultimately"], ["proof (chain)\npicking this:\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP) -\n  {f}\n  \\<subseteq> \\<Union>\n               (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                 nP) -\n              {f}\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP)\n  \\<subseteq> \\<Union>\n               (set_offending_flows\n                 \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP) -\n              {f}", "have Un_set_offending_flows_minus:\n        \"\\<Union>(set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP) \\<subseteq> \\<Union>(set_offending_flows \\<lparr>nodes = V, edges = E \\<rparr> nP) - {f}\""], ["proof (prove)\nusing this:\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP) -\n  {f}\n  \\<subseteq> \\<Union>\n               (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                 nP) -\n              {f}\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP)\n  \\<subseteq> \\<Union>\n               (set_offending_flows\n                 \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP) -\n              {f}\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP)\n    \\<subseteq> \\<Union>\n                 (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                   nP) -\n                {f}", "by blast"], ["proof (state)\nthis:\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP)\n  \\<subseteq> \\<Union>\n               (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                 nP) -\n              {f}\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP)\n    \\<subseteq> X - {f}", "from Foffending Un_set_offending_flows_minus"], ["proof (chain)\npicking this:\n  \\<Union> (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP)\n  \\<subseteq> X\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP)\n  \\<subseteq> \\<Union>\n               (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                 nP) -\n              {f}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Union> (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP)\n  \\<subseteq> X\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP)\n  \\<subseteq> \\<Union>\n               (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                 nP) -\n              {f}\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP)\n    \\<subseteq> X - {f}", "by blast"], ["proof (state)\nthis:\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - {f}\\<rparr> nP)\n  \\<subseteq> X - {f}\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n    If the offending flows are bound by some @{term X},\n    the we can remove all finite @{term \"E'\"}from the graph's edges\n    and the offending flows from the smaller graph are bound by @{term \"X - E'\"}.\n\\<close>"], ["", "lemma Un_set_offending_flows_bound_minus_subseteq:\n    assumes wfG: \"wf_graph \\<lparr> nodes = V, edges = E \\<rparr>\"\n    and     Foffending: \"\\<Union> (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP) \\<subseteq> X\"\n    shows   \"\\<Union> (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP) \\<subseteq> X - E'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP)\n    \\<subseteq> X - E'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Union>\n     (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP)\n    \\<subseteq> X - E'", "from wfG"], ["proof (chain)\npicking this:\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>", "have wfG': \"wf_graph \\<lparr> nodes = V, edges = E - E' \\<rparr>\""], ["proof (prove)\nusing this:\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n\ngoal (1 subgoal):\n 1. wf_graph \\<lparr>nodes = V, edges = E - E'\\<rparr>", "by(auto simp add: wf_graph_def finite_subset)"], ["proof (state)\nthis:\n  wf_graph \\<lparr>nodes = V, edges = E - E'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP)\n    \\<subseteq> X - E'", "from offending_flows_union_mono[OF wfG, where E'=\"E - E'\"]"], ["proof (chain)\npicking this:\n  E - E' \\<subseteq> E \\<Longrightarrow>\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> ?nP)\n  \\<subseteq> \\<Union>\n               (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                 ?nP)", "have \n        \"\\<Union>(set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP) - E' \\<subseteq> \\<Union>(set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP) - E'\""], ["proof (prove)\nusing this:\n  E - E' \\<subseteq> E \\<Longrightarrow>\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> ?nP)\n  \\<subseteq> \\<Union>\n               (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                 ?nP)\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP) -\n    E'\n    \\<subseteq> \\<Union>\n                 (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                   nP) -\n                E'", "by blast"], ["proof (state)\nthis:\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP) -\n  E'\n  \\<subseteq> \\<Union>\n               (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                 nP) -\n              E'\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP)\n    \\<subseteq> X - E'", "also"], ["proof (state)\nthis:\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP) -\n  E'\n  \\<subseteq> \\<Union>\n               (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                 nP) -\n              E'\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP)\n    \\<subseteq> X - E'", "have \n        \"\\<Union>(set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP) \\<subseteq> \\<Union>(set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP) - E'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP)\n    \\<subseteq> \\<Union>\n                 (set_offending_flows\n                   \\<lparr>nodes = V, edges = E - E'\\<rparr> nP) -\n                E'", "apply(simp add: set_offending_flows_simp[OF wfG'])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     {F. F \\<subseteq> E - E' \\<and>\n         \\<not> sinvar \\<lparr>nodes = V, edges = E - E'\\<rparr> nP \\<and>\n         sinvar \\<lparr>nodes = V, edges = E - E' - F\\<rparr> nP \\<and>\n         (\\<forall>x\\<in>F.\n             \\<not> sinvar\n                     \\<lparr>nodes = V,\n                        edges = insert x (E - E' - F)\\<rparr>\n                     nP)}\n    \\<subseteq> \\<Union>\n                 {F. F \\<subseteq> E - E' \\<and>\n                     \\<not> sinvar \\<lparr>nodes = V, edges = E - E'\\<rparr>\n                             nP \\<and>\n                     sinvar \\<lparr>nodes = V, edges = E - E' - F\\<rparr>\n                      nP \\<and>\n                     (\\<forall>x\\<in>F.\n                         \\<not> sinvar\n                                 \\<lparr>nodes = V,\n                                    edges = insert x (E - E' - F)\\<rparr>\n                                 nP)} -\n                E'", "by blast"], ["proof (state)\nthis:\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP)\n  \\<subseteq> \\<Union>\n               (set_offending_flows\n                 \\<lparr>nodes = V, edges = E - E'\\<rparr> nP) -\n              E'\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP)\n    \\<subseteq> X - E'", "ultimately"], ["proof (chain)\npicking this:\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP) -\n  E'\n  \\<subseteq> \\<Union>\n               (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                 nP) -\n              E'\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP)\n  \\<subseteq> \\<Union>\n               (set_offending_flows\n                 \\<lparr>nodes = V, edges = E - E'\\<rparr> nP) -\n              E'", "have Un_set_offending_flows_minus:\n        \"\\<Union> (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP) \\<subseteq> \\<Union> (set_offending_flows \\<lparr>nodes = V, edges = E \\<rparr> nP) - E'\""], ["proof (prove)\nusing this:\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP) -\n  E'\n  \\<subseteq> \\<Union>\n               (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                 nP) -\n              E'\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP)\n  \\<subseteq> \\<Union>\n               (set_offending_flows\n                 \\<lparr>nodes = V, edges = E - E'\\<rparr> nP) -\n              E'\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP)\n    \\<subseteq> \\<Union>\n                 (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                   nP) -\n                E'", "by blast"], ["proof (state)\nthis:\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP)\n  \\<subseteq> \\<Union>\n               (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                 nP) -\n              E'\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP)\n    \\<subseteq> X - E'", "from Foffending Un_set_offending_flows_minus"], ["proof (chain)\npicking this:\n  \\<Union> (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP)\n  \\<subseteq> X\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP)\n  \\<subseteq> \\<Union>\n               (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                 nP) -\n              E'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Union> (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP)\n  \\<subseteq> X\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP)\n  \\<subseteq> \\<Union>\n               (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr>\n                 nP) -\n              E'\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP)\n    \\<subseteq> X - E'", "by blast"], ["proof (state)\nthis:\n  \\<Union>\n   (set_offending_flows \\<lparr>nodes = V, edges = E - E'\\<rparr> nP)\n  \\<subseteq> X - E'\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary Un_set_offending_flows_bound_minus_subseteq': \n    \"\\<lbrakk> wf_graph \\<lparr> nodes = V, edges = E \\<rparr>;\n    \\<Union> (set_offending_flows \\<lparr> nodes = V, edges = E \\<rparr> nP) \\<subseteq> X \\<rbrakk> \\<Longrightarrow>\n    \\<Union> (set_offending_flows \\<lparr> nodes = V, edges = E - E' \\<rparr> nP) \\<subseteq> X - E'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     \\<Union> (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP)\n     \\<subseteq> X\\<rbrakk>\n    \\<Longrightarrow> \\<Union>\n                       (set_offending_flows\n                         \\<lparr>nodes = V, edges = E - E'\\<rparr> nP)\n                      \\<subseteq> X - E'", "apply(drule(1) Un_set_offending_flows_bound_minus_subseteq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Union>\n              (set_offending_flows \\<lparr>nodes = V, edges = E\\<rparr> nP)\n             \\<subseteq> X;\n     \\<Union>\n      (set_offending_flows \\<lparr>nodes = V, edges = E - ?E'\\<rparr> nP)\n     \\<subseteq> X - ?E'\\<rbrakk>\n    \\<Longrightarrow> \\<Union>\n                       (set_offending_flows\n                         \\<lparr>nodes = V, edges = E - E'\\<rparr> nP)\n                      \\<subseteq> X - E'", "by blast"], ["", "end"], ["", "end"]]}