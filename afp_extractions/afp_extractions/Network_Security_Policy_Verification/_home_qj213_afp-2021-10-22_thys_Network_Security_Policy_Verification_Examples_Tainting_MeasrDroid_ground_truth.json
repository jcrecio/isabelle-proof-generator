{"file_name": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification/Examples/Tainting/MeasrDroid.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification", "problem_names": ["lemma \"dom (taint_labels) \\<subseteq> set (nodesL policy)\"", "lemma \"taint_labels = (let (Enc_A, Dec_A) = mk_Enc_Dec_pair {''A''};\n                             (Enc_B, Dec_B) = mk_Enc_Dec_pair {''B''};\n                             (Enc_C, Dec_C) = mk_Enc_Dec_pair {''C''}\n                       in [\n                           ''Sensors_A'' \\<mapsto> TaintsUntaints {''A''} {},\n                           ''Sensors_B'' \\<mapsto> TaintsUntaints {''B''} {},\n                           ''Sensors_C'' \\<mapsto> TaintsUntaints {''C''} {},\n\n                           ''Encryption_A'' \\<mapsto> Enc_A,\n                           ''Encryption_B'' \\<mapsto> Enc_B,\n                           ''Encryption_C'' \\<mapsto> Enc_C,\n\n                           ''C3PO_Dec_A'' \\<mapsto> Dec_A,\n                           ''C3PO_Dec_B'' \\<mapsto> Dec_B,\n                           ''C3PO_Dec_C'' \\<mapsto> Dec_C,\n\n                           ''C3PO_Storage'' \\<mapsto> TaintsUntaints {''A'',''B'',''C''} {}\n                           ])\"", "lemma \"wf_list_graph policy\"", "lemma \"dom (map_of smartphone_system_A) \\<subseteq> set (nodesL policy)\"", "lemma \"dom(map_of smartphone_system_B) \\<subseteq> set (nodesL policy)\"", "lemma \"dom(map_of smartphone_system_C) \\<subseteq> set (nodesL policy)\"", "lemma \"dom(map_of system_C3PO) \\<subseteq> set (nodesL policy)\"", "lemma \"dom(map_of system_UploadDroid) \\<subseteq> set (nodesL policy)\"", "lemma \"all_security_requirements_fulfilled invariants policy\"", "lemma \"set (edgesL policy) \\<subseteq> set (edgesL (make_policy invariants (nodesL policy)))\"", "lemma \"set [e \\<leftarrow> edgesL (make_policy invariants (nodesL policy)). e \\<notin> set (edgesL policy)] =\n set [(v,v). v \\<leftarrow> (nodesL policy)] \\<union>\n {(''Encryption_A'', ''Sensors_A''), (''Client_A_out'', ''Sensors_A''), (''Client_A_out'', ''Encryption_A'')} \\<union>\n\n {(''Encryption_B'', ''Sensors_B''), (''Client_B_out'', ''Sensors_B''), (''Client_B_out'', ''Encryption_B'')} \\<union>\n\n {(''Encryption_C'', ''Sensors_C''), (''Client_C_out'', ''Sensors_C''),  (''Client_C_out'', ''Encryption_C'')} \\<union>\n \n {(''Client_C_out'', ''Adversary''),\n  (''Client_B_out'', ''Adversary''),\n  (''Client_A_out'', ''Adversary'')} \\<union>\n\n {(''C3PO_in'', ''Adversary'')} \\<union>\n\n {(''Adversary'', ''UploadDroid'')} \\<union>\n\n {(''UploadDroid'', ''Adversary'')} \\<union>\n\n {(''C3PO_in'', ''C3PO_Storage'')}\"", "lemma \"stateful_policy =\n\\<lparr>hostsL =\n    [''Sensors_A'', ''Encryption_A'', ''Client_A_out'', ''Sensors_B'', ''Encryption_B'', ''Client_B_out'', ''Sensors_C'',\n     ''Encryption_C'', ''Client_C_out'', ''UploadDroid'', ''C3PO_in'', ''C3PO_Dec_A'', ''C3PO_Dec_B'', ''C3PO_Dec_C'',\n     ''C3PO_Storage'', ''Adversary''],\n    flows_fixL =\n      [(''Sensors_A'', ''Encryption_A''), (''Encryption_A'', ''Client_A_out''), (''Client_A_out'', ''UploadDroid''),\n       (''Sensors_B'', ''Encryption_B''), (''Encryption_B'', ''Client_B_out''), (''Client_B_out'', ''UploadDroid''),\n       (''Sensors_C'', ''Encryption_C''), (''Encryption_C'', ''Client_C_out''), (''Client_C_out'', ''UploadDroid''),\n       (''C3PO_in'', ''UploadDroid''), (''C3PO_in'', ''C3PO_Dec_A''), (''C3PO_in'', ''C3PO_Dec_B''),\n       (''C3PO_in'', ''C3PO_Dec_C''), (''C3PO_Dec_A'', ''C3PO_Storage''), (''C3PO_Dec_B'', ''C3PO_Storage''),\n       (''C3PO_Dec_C'', ''C3PO_Storage'')],\n    flows_stateL =\n      [(''Sensors_A'', ''Encryption_A''), (''Encryption_A'', ''Client_A_out''), (''Client_A_out'', ''UploadDroid''),\n       (''Sensors_B'', ''Encryption_B''), (''Encryption_B'', ''Client_B_out''), (''Client_B_out'', ''UploadDroid''),\n       (''Sensors_C'', ''Encryption_C''), (''Encryption_C'', ''Client_C_out''), (''Client_C_out'', ''UploadDroid''),\n       (''C3PO_in'', ''UploadDroid'')]\\<rparr>\""], "translations": [["", "lemma \"dom (taint_labels) \\<subseteq> set (nodesL policy)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom taint_labels \\<subseteq> set (nodesL policy)", "by(simp add: taint_labels_def policy_def)"], ["", "definition \"Tainting_m \\<equiv> new_configured_list_SecurityInvariant SINVAR_LIB_TaintingTrusted \\<lparr>\n        node_properties = taint_labels \\<rparr> ''taint labels''\""], ["", "text\\<open>A convenient way to specify encryption and decryption pairs\\<close>"], ["", "private"], ["", "definition mk_Enc_Dec_pair\n    :: \"string set \\<Rightarrow> (SINVAR_TaintingTrusted.taints \\<times> SINVAR_TaintingTrusted.taints)\"\n  where\n  \"mk_Enc_Dec_pair taints_to_be_encrypted \\<equiv> (TaintsUntaints {} taints_to_be_encrypted,\n                                             TaintsUntaints taints_to_be_encrypted {})\""], ["", "lemma \"taint_labels = (let (Enc_A, Dec_A) = mk_Enc_Dec_pair {''A''};\n                             (Enc_B, Dec_B) = mk_Enc_Dec_pair {''B''};\n                             (Enc_C, Dec_C) = mk_Enc_Dec_pair {''C''}\n                       in [\n                           ''Sensors_A'' \\<mapsto> TaintsUntaints {''A''} {},\n                           ''Sensors_B'' \\<mapsto> TaintsUntaints {''B''} {},\n                           ''Sensors_C'' \\<mapsto> TaintsUntaints {''C''} {},\n\n                           ''Encryption_A'' \\<mapsto> Enc_A,\n                           ''Encryption_B'' \\<mapsto> Enc_B,\n                           ''Encryption_C'' \\<mapsto> Enc_C,\n\n                           ''C3PO_Dec_A'' \\<mapsto> Dec_A,\n                           ''C3PO_Dec_B'' \\<mapsto> Dec_B,\n                           ''C3PO_Dec_C'' \\<mapsto> Dec_C,\n\n                           ''C3PO_Storage'' \\<mapsto> TaintsUntaints {''A'',''B'',''C''} {}\n                           ])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. taint_labels =\n    (let (Enc_A, Dec_A) = mk_Enc_Dec_pair {''A''};\n         (Enc_B, Dec_B) = mk_Enc_Dec_pair {''B''};\n         (Enc_C, Dec_C) = mk_Enc_Dec_pair {''C''}\n     in [''Sensors_A'' \\<mapsto> TaintsUntaints {''A''} {}, ''Sensors_B'' \n         \\<mapsto> TaintsUntaints {''B''} {}, ''Sensors_C'' \\<mapsto>\n         TaintsUntaints {''C''} {}, ''Encryption_A'' \\<mapsto> Enc_A,\n         ''Encryption_B'' \\<mapsto> Enc_B, ''Encryption_C'' \\<mapsto> Enc_C,\n         ''C3PO_Dec_A'' \\<mapsto> Dec_A, ''C3PO_Dec_B'' \\<mapsto> Dec_B,\n         ''C3PO_Dec_C'' \\<mapsto> Dec_C, ''C3PO_Storage'' \\<mapsto>\n         TaintsUntaints {''A'', ''B'', ''C''} {}])", "by(simp add: taint_labels_def mk_Enc_Dec_pair_def)"], ["", "end"], ["", "lemma \"wf_list_graph policy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_list_graph policy", "by eval"], ["", "ML_val\\<open>\nvisualize_graph @{context} @{term \"[]::string SecurityInvariant list\"} @{term \"policy\"};\n\\<close>"], ["", "context begin"], ["", "private"], ["", "definition \"smartphone_system_A \\<equiv>\n                [(''Client_A_out'' ,  SystemBoundaryOutput),\n                 (''Sensors_A'' ,  SystemComponent),\n                 (''Encryption_A'' ,  SystemComponent)\n                 ]\""], ["", "private"], ["", "lemma \"dom (map_of smartphone_system_A) \\<subseteq> set (nodesL policy)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (map_of smartphone_system_A) \\<subseteq> set (nodesL policy)", "by(simp add: smartphone_system_A_def policy_def)"], ["", "definition \"SystemA_m \\<equiv> new_meta_system_boundary smartphone_system_A ''smartphone A''\""], ["", "end"], ["", "context begin"], ["", "private"], ["", "definition \"smartphone_system_B \\<equiv>\n                [(''Client_B_out'' ,  SystemBoundaryOutput),\n                 (''Sensors_B'' ,  SystemComponent),\n                 (''Encryption_B'' ,  SystemComponent)\n                 ]\""], ["", "private"], ["", "lemma \"dom(map_of smartphone_system_B) \\<subseteq> set (nodesL policy)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (map_of smartphone_system_B) \\<subseteq> set (nodesL policy)", "by(simp add: smartphone_system_B_def policy_def)"], ["", "definition \"SystemB_m \\<equiv> new_meta_system_boundary smartphone_system_B ''smartphone B''\""], ["", "end"], ["", "context begin"], ["", "private"], ["", "definition \"smartphone_system_C \\<equiv>\n                [(''Client_C_out'' ,  SystemBoundaryOutput),\n                 (''Sensors_C'' ,  SystemComponent),\n                 (''Encryption_C'' ,  SystemComponent)\n                 ]\""], ["", "private"], ["", "lemma \"dom(map_of smartphone_system_C) \\<subseteq> set (nodesL policy)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (map_of smartphone_system_C) \\<subseteq> set (nodesL policy)", "by(simp add: smartphone_system_C_def policy_def)"], ["", "definition \"SystemC_m \\<equiv> new_meta_system_boundary smartphone_system_C ''smartphone C''\""], ["", "end"], ["", "context begin"], ["", "private"], ["", "definition \"system_C3PO \\<equiv>\n                [(''C3PO_in'' ,  SystemBoundaryOutput),\n                 (''C3PO_Dec_A'' ,  SystemComponent),\n                 (''C3PO_Dec_C'' ,  SystemComponent),\n                 (''C3PO_Dec_B'' ,  SystemComponent),\n                 (''C3PO_Storage'' ,  SystemComponent)\n                 ]\""], ["", "private"], ["", "lemma \"dom(map_of system_C3PO) \\<subseteq> set (nodesL policy)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (map_of system_C3PO) \\<subseteq> set (nodesL policy)", "by(simp add: system_C3PO_def policy_def)"], ["", "definition \"SystemC3PO_m \\<equiv> new_meta_system_boundary system_C3PO ''C3PO''\""], ["", "end"], ["", "context begin"], ["", "text\\<open>Technically, the following definition does not impose any restrictions.\n       Upload Droid must be reachable from anywhere, therefore it is an @{const SystemBoundaryInput}.\n       In addition, Upload Droid will maintain stateful connections with other entities.\n       Therefore, we want to allow Upload Droid to send out any data, which also makes it an\n       @{const SystemBoundaryOutput}.\n       \\<close>"], ["", "private"], ["", "definition \"system_UploadDroid \\<equiv>\n                [(''UploadDroid'',  SystemBoundaryInputOutput)\n                 ]\""], ["", "private"], ["", "lemma \"dom(map_of system_UploadDroid) \\<subseteq> set (nodesL policy)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (map_of system_UploadDroid) \\<subseteq> set (nodesL policy)", "by(simp add: system_UploadDroid_def policy_def)"], ["", "definition \"SystemUploadDroid_m \\<equiv> new_meta_system_boundary system_UploadDroid ''UploadDroid''\""], ["", "end"], ["", "definition \"invariants \\<equiv> [Tainting_m] @ SystemA_m @ SystemB_m @ SystemC_m @ SystemC3PO_m @ SystemUploadDroid_m\""], ["", "lemma \"all_security_requirements_fulfilled invariants policy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TopoS_Composition_Theory_impl.all_security_requirements_fulfilled\n     invariants policy", "by eval"], ["", "ML\\<open>\nvisualize_graph @{context} @{term \"invariants\"} @{term \"policy\"};\n\\<close>"], ["", "value[code] \"implc_get_offending_flows invariants (policy\\<lparr> edgesL := edgesL policy\\<rparr>)\""], ["", "(*ML{*\nvisualize_graph @{context} @{term \"invariants\"} @{term \"(policy\\<lparr> edgesL := (''Adversary'', ''C3PO_Storage'')#edgesL policy\\<rparr>)\"};\n*}*)"], ["", "ML\\<open>\nvisualize_graph_header @{context} @{term \"invariants\"} @{term \"policy\"} @{term taint_labels};\n\\<close>"], ["", "subsection\\<open>Analyzing the Policy\\<close>"], ["", "definition make_policy :: \"('a SecurityInvariant) list \\<Rightarrow> 'a list \\<Rightarrow> 'a list_graph\" where\n  \"make_policy sinvars Vs \\<equiv> generate_valid_topology sinvars \\<lparr>nodesL = Vs, edgesL = List.product Vs Vs \\<rparr>\""], ["", "value[code] \"make_policy invariants (nodesL policy)\""], ["", "lemma \"set (edgesL policy) \\<subseteq> set (edgesL (make_policy invariants (nodesL policy)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (edgesL policy)\n    \\<subseteq> set (edgesL (make_policy invariants (nodesL policy)))", "by eval"], ["", "text\\<open>\nWe analyze the specification of our security invariants. The model includes a node @{term \"''Adversary''\"}\nand we will analyze which interaction with an adversary are not prohibited by the requirements. \nTherefore, we generate a policy only from the security invariants and compare it to our manually designed policy.\n\nWe find the following flows which are allowed but which we did not consider in our policy \n \\<^item> All reflexive flows, i.e. every component can interact with itself. This is fine.\n \\<^item> Within each smartphone, internally, arbitrary communication is possible. We cannot prevent this at a user's smartphone.\n \\<^item> Every smartphone could send data to the adversary.\n   It is important that this is generally allowed since we don't to put any restrictions on the\n   Internet connectivity of a smartphone. \n   For example, this allows the smartphone user to surf facebook, which is not a trusted component in our system.\n   The collected data is encrypted once it leaves the smartphone (via MeasrDroid), therefore, sensor data is not leaked.\n \\<^item> @{term \"''C3PO_in''\"} could send data to the adversary. At this point, the data is still encrypted.\n   It would be possible to add an additional security invariant to make sure that @{term \"''C3PO_in''\"}\n   only connects to @{term \"''UploadDroid''\"}.\n \\<^item> An adversary could send data to @{term \"''UploadDroid''\"}.\n   Since the system shall be accessible to any smartphone connected to the Internet, without authentication,\n   we cannot prevent that a malicious user might send fake data.\n \\<^item> The Upload Droid could send data to the adversary.\n   This does not undermine the security concept because upload droid only stores encrypted data. \n   In fact, the security assumptions were from the very beginning that @{term \"''UploadDroid''\"} can get compromised.\n \\<^item> C3PO could directly save data in its database without decrypting.\n   This is fine and might potentially be used in a future version for backups.\n\\<close>"], ["", "lemma \"set [e \\<leftarrow> edgesL (make_policy invariants (nodesL policy)). e \\<notin> set (edgesL policy)] =\n set [(v,v). v \\<leftarrow> (nodesL policy)] \\<union>\n {(''Encryption_A'', ''Sensors_A''), (''Client_A_out'', ''Sensors_A''), (''Client_A_out'', ''Encryption_A'')} \\<union>\n\n {(''Encryption_B'', ''Sensors_B''), (''Client_B_out'', ''Sensors_B''), (''Client_B_out'', ''Encryption_B'')} \\<union>\n\n {(''Encryption_C'', ''Sensors_C''), (''Client_C_out'', ''Sensors_C''),  (''Client_C_out'', ''Encryption_C'')} \\<union>\n \n {(''Client_C_out'', ''Adversary''),\n  (''Client_B_out'', ''Adversary''),\n  (''Client_A_out'', ''Adversary'')} \\<union>\n\n {(''C3PO_in'', ''Adversary'')} \\<union>\n\n {(''Adversary'', ''UploadDroid'')} \\<union>\n\n {(''UploadDroid'', ''Adversary'')} \\<union>\n\n {(''C3PO_in'', ''C3PO_Storage'')}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>e. e \\<notin> set (edgesL policy))\n          (edgesL (make_policy invariants (nodesL policy)))) =\n    set (map (\\<lambda>v. (v, v)) (nodesL policy)) \\<union>\n    {(''Encryption_A'', ''Sensors_A''), (''Client_A_out'', ''Sensors_A''),\n     (''Client_A_out'', ''Encryption_A'')} \\<union>\n    {(''Encryption_B'', ''Sensors_B''), (''Client_B_out'', ''Sensors_B''),\n     (''Client_B_out'', ''Encryption_B'')} \\<union>\n    {(''Encryption_C'', ''Sensors_C''), (''Client_C_out'', ''Sensors_C''),\n     (''Client_C_out'', ''Encryption_C'')} \\<union>\n    {(''Client_C_out'', ''Adversary''), (''Client_B_out'', ''Adversary''),\n     (''Client_A_out'', ''Adversary'')} \\<union>\n    {(''C3PO_in'', ''Adversary'')} \\<union>\n    {(''Adversary'', ''UploadDroid'')} \\<union>\n    {(''UploadDroid'', ''Adversary'')} \\<union>\n    {(''C3PO_in'', ''C3PO_Storage'')}", "by eval"], ["", "text\\<open>visualization\\<close>"], ["", "ML_val\\<open>\nvisualize_edges @{context} @{term \"edgesL policy\"} \n    [(\"edge [dir=\\\"arrow\\\", style=dashed, color=\\\"#3399FF\\\", constraint=false]\",\n     @{term \"[e \\<leftarrow> edgesL (make_policy invariants (nodesL policy)). e \\<notin> set (edgesL policy)]\"})] \"\"; \n\\<close>"], ["", "text\\<open>A visualization which shows all flows to the adversary which must NEVER happen\n      (only considering taint labels, i.e. system boundaries are not considered).\\<close>"], ["", "ML_val\\<open>\nvisualize_edges @{context} @{term \"edgesL policy\"}\n    [(\"edge [dir=\\\"arrow\\\", style=dashed, color=\\\"#FF8822\\\", constraint=false]\",\n     @{term \"[(e1, e2) \\<leftarrow>  List.product  (nodesL policy) (nodesL policy).\n     (e1,e2) \\<notin> set (edgesL (make_policy [Tainting_m] (nodesL policy))) \\<and> (e2 = ''Adversary'') \\<and> (e1 \\<noteq> ''Adversary'')]\"})] \"\";\n\\<close>"], ["", "text\\<open>We conclude that the security invariants adequately reflect all aspects of the system we wanted to specify.\\<close>"], ["", "subsection\\<open>A stateful implementation\\<close>"], ["", "definition \"stateful_policy = generate_valid_stateful_policy_IFSACS policy invariants\""], ["", "ML_val\\<open>\nvisualize_edges @{context} @{term \"flows_fixL stateful_policy\"}\n    [(\"edge [dir=\\\"arrow\\\", style=dashed, color=\\\"#FF8822\\\", constraint=false]\", @{term \"flows_stateL stateful_policy\"})] \"\";\n\\<close>"], ["", "lemma \"stateful_policy =\n\\<lparr>hostsL =\n    [''Sensors_A'', ''Encryption_A'', ''Client_A_out'', ''Sensors_B'', ''Encryption_B'', ''Client_B_out'', ''Sensors_C'',\n     ''Encryption_C'', ''Client_C_out'', ''UploadDroid'', ''C3PO_in'', ''C3PO_Dec_A'', ''C3PO_Dec_B'', ''C3PO_Dec_C'',\n     ''C3PO_Storage'', ''Adversary''],\n    flows_fixL =\n      [(''Sensors_A'', ''Encryption_A''), (''Encryption_A'', ''Client_A_out''), (''Client_A_out'', ''UploadDroid''),\n       (''Sensors_B'', ''Encryption_B''), (''Encryption_B'', ''Client_B_out''), (''Client_B_out'', ''UploadDroid''),\n       (''Sensors_C'', ''Encryption_C''), (''Encryption_C'', ''Client_C_out''), (''Client_C_out'', ''UploadDroid''),\n       (''C3PO_in'', ''UploadDroid''), (''C3PO_in'', ''C3PO_Dec_A''), (''C3PO_in'', ''C3PO_Dec_B''),\n       (''C3PO_in'', ''C3PO_Dec_C''), (''C3PO_Dec_A'', ''C3PO_Storage''), (''C3PO_Dec_B'', ''C3PO_Storage''),\n       (''C3PO_Dec_C'', ''C3PO_Storage'')],\n    flows_stateL =\n      [(''Sensors_A'', ''Encryption_A''), (''Encryption_A'', ''Client_A_out''), (''Client_A_out'', ''UploadDroid''),\n       (''Sensors_B'', ''Encryption_B''), (''Encryption_B'', ''Client_B_out''), (''Client_B_out'', ''UploadDroid''),\n       (''Sensors_C'', ''Encryption_C''), (''Encryption_C'', ''Client_C_out''), (''Client_C_out'', ''UploadDroid''),\n       (''C3PO_in'', ''UploadDroid'')]\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stateful_policy =\n    \\<lparr>hostsL =\n              [''Sensors_A'', ''Encryption_A'', ''Client_A_out'',\n               ''Sensors_B'', ''Encryption_B'', ''Client_B_out'',\n               ''Sensors_C'', ''Encryption_C'', ''Client_C_out'',\n               ''UploadDroid'', ''C3PO_in'', ''C3PO_Dec_A'', ''C3PO_Dec_B'',\n               ''C3PO_Dec_C'', ''C3PO_Storage'', ''Adversary''],\n       flows_fixL =\n         [(''Sensors_A'', ''Encryption_A''),\n          (''Encryption_A'', ''Client_A_out''),\n          (''Client_A_out'', ''UploadDroid''),\n          (''Sensors_B'', ''Encryption_B''),\n          (''Encryption_B'', ''Client_B_out''),\n          (''Client_B_out'', ''UploadDroid''),\n          (''Sensors_C'', ''Encryption_C''),\n          (''Encryption_C'', ''Client_C_out''),\n          (''Client_C_out'', ''UploadDroid''),\n          (''C3PO_in'', ''UploadDroid''), (''C3PO_in'', ''C3PO_Dec_A''),\n          (''C3PO_in'', ''C3PO_Dec_B''), (''C3PO_in'', ''C3PO_Dec_C''),\n          (''C3PO_Dec_A'', ''C3PO_Storage''),\n          (''C3PO_Dec_B'', ''C3PO_Storage''),\n          (''C3PO_Dec_C'', ''C3PO_Storage'')],\n       flows_stateL =\n         [(''Sensors_A'', ''Encryption_A''),\n          (''Encryption_A'', ''Client_A_out''),\n          (''Client_A_out'', ''UploadDroid''),\n          (''Sensors_B'', ''Encryption_B''),\n          (''Encryption_B'', ''Client_B_out''),\n          (''Client_B_out'', ''UploadDroid''),\n          (''Sensors_C'', ''Encryption_C''),\n          (''Encryption_C'', ''Client_C_out''),\n          (''Client_C_out'', ''UploadDroid''),\n          (''C3PO_in'', ''UploadDroid'')]\\<rparr>", "by eval"], ["", "subsection\\<open>A firewall for Collect Droid\\<close>"], ["", "text\\<open>The firewall is installed at @{term \"''C3PO_in''\"}, this we only filter for the rules which affect this component.\\<close>"], ["", "ML_val\\<open>\n\n(*header*)\nwriteln (\"# flush all rules\"^\"\\n\"^\n         \"iptables -F\"^\"\\n\"^\n         \"#default policy for FORWARD chain:\"^\"\\n\"^\n         \"iptables -P INPUT DROP\"^\"\\n\"^\n         \"iptables -P OUTPUT DROP\"^\"\\n\"^\n         \"iptables -P FORWARD DROP\");\n\n\nwriteln (\"# INPUT\"^\"\\n\");\niterate_edges_ML @{context}  @{term \"[(s,r) \\<leftarrow> flows_fixL stateful_policy. r = ''C3PO_in'']\"}\n  (fn (v1,v2) => writeln (\"iptables -A INPUT -i $\"^v1^\"_iface -s $\"^v1^\"_ipv4 -o $\"^v2^\"_iface -d $\"^v2^\"_ipv4 -j ACCEPT\"^\" # \"^v1^\" -> \"^v2) )\n  (fn _ => () )\n  (fn _ => () );\niterate_edges_ML @{context} @{term \"[(s,r) \\<leftarrow> flows_stateL stateful_policy. s = ''C3PO_in'']\"}\n  (fn (v1,v2) => writeln (\"iptables -I INPUT -m state --state ESTABLISHED -i $\"^v2^\"_iface -s $\"^v2^\"_ipv4 -o $\"^v1^\"_iface -d $\"^v1^\"_ipv4 -j ACCEPT # \"^v2^\" -> \"^v1^\" (answer)\") )\n  (fn _ => () )\n  (fn _ => () );\n\nwriteln (\"# OUTPUT\"^\"\\n\");\niterate_edges_ML @{context}  @{term \"[(s,r) \\<leftarrow> flows_fixL stateful_policy. s = ''C3PO_in'']\"}\n  (fn (v1,v2) => writeln (\"iptables -A OUTPUT -i $\"^v1^\"_iface -s $\"^v1^\"_ipv4 -o $\"^v2^\"_iface -d $\"^v2^\"_ipv4 -j ACCEPT\"^\" # \"^v1^\" -> \"^v2) )\n  (fn _ => () )\n  (fn _ => () );\niterate_edges_ML @{context} @{term \"[(s,r) \\<leftarrow> flows_stateL stateful_policy. r = ''C3PO_in'']\"}\n  (fn (v1,v2) => writeln (\"iptables -I OUTPUT -m state --state ESTABLISHED -i $\"^v2^\"_iface -s $\"^v2^\"_ipv4 -o $\"^v1^\"_iface -d $\"^v1^\"_ipv4 -j ACCEPT # \"^v2^\" -> \"^v1^\" (answer)\") )\n  (fn _ => () )\n  (fn _ => () );\n\\<close>"], ["", "end"]]}