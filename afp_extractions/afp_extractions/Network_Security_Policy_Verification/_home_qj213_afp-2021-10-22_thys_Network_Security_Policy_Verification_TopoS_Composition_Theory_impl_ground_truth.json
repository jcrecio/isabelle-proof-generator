{"file_name": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification/TopoS_Composition_Theory_impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification", "problem_names": ["lemma TopoS_modelLibrary_yields_new_configured_SecurityInvariant:\n    assumes NetModelLib: \"TopoS_modelLibrary m sinvar_spec\"\n    and     nPdef:       \"nP = nm_node_props m C\"\n    and formalSpec:      \"Spec = \\<lparr> \n                              c_sinvar = (\\<lambda>G. sinvar_spec G nP),\n                              c_offending_flows = (\\<lambda>G. SecurityInvariant_withOffendingFlows.set_offending_flows sinvar_spec G nP),\n                              c_isIFS = nm_receiver_violation m\n                            \\<rparr>\"\n    shows \"new_configured_SecurityInvariant (sinvar_spec, nm_default m, nm_receiver_violation m, nP) = Some Spec\"", "lemma new_configured_list_SecurityInvariant_complies:\n    assumes NetModelLib: \"TopoS_modelLibrary m sinvar_spec\"\n    and     nPdef:       \"nP = nm_node_props m C\"\n    and formalSpec:      \"Spec = new_configured_SecurityInvariant (sinvar_spec, nm_default m, nm_receiver_violation m, nP)\"\n    and implSpec:        \"Impl = new_configured_list_SecurityInvariant m C description\"\n    shows \"SecurityInvariant_complies_formal_def Impl (the Spec)\"", "lemma implc_get_offending_flows_fold: \n    \"implc_get_offending_flows M G = fold (\\<lambda>m accu. accu@(implc_offending_flows m G)) M []\"", "lemma implc_get_offending_flows_Un: \"set`set (implc_get_offending_flows M G) = (\\<Union>m\\<in>set M. set`set (implc_offending_flows m G))\"", "lemma implc_get_offending_flows_map_concat: \"(implc_get_offending_flows M G) = concat [implc_offending_flows m G. m \\<leftarrow> M]\"", "theorem implc_get_offending_flows_complies:\n    assumes a1: \"\\<forall> (m_impl, m_spec) \\<in> set M. SecurityInvariant_complies_formal_def m_impl m_spec\"\n    and     a2: \"wf_list_graph G\"\n    shows   \"set`set (implc_get_offending_flows (get_impl M) G) = (get_offending_flows (get_spec M) (list_graph_to_graph G))\"", "lemma get_IFS_get_ACS_complies:\n  assumes a: \"\\<forall> (m_impl, m_spec) \\<in> set M. SecurityInvariant_complies_formal_def m_impl m_spec\"\n    shows \"\\<forall> (m_impl, m_spec) \\<in> set (zip (get_IFS (get_impl M)) (TopoS_Composition_Theory.get_IFS (get_spec M))).\n      SecurityInvariant_complies_formal_def m_impl m_spec\"\n    and \"\\<forall> (m_impl, m_spec) \\<in> set (zip (get_ACS (get_impl M)) (TopoS_Composition_Theory.get_ACS (get_spec M))).\n      SecurityInvariant_complies_formal_def m_impl m_spec\"", "lemma get_IFS_get_ACS_select_simps:\n    assumes a1: \"\\<forall> (m_impl, m_spec) \\<in> set M. SecurityInvariant_complies_formal_def m_impl m_spec\"\n    shows \"\\<forall> (m_impl, m_spec) \\<in> set (zip (get_IFS (get_impl M)) (TopoS_Composition_Theory.get_IFS (get_spec M))). SecurityInvariant_complies_formal_def m_impl m_spec\" (is \"\\<forall> (m_impl, m_spec) \\<in> set ?zippedIFS. SecurityInvariant_complies_formal_def m_impl m_spec\")\n    and   \"(get_impl (zip (TopoS_Composition_Theory_impl.get_IFS (get_impl M)) (TopoS_Composition_Theory.get_IFS (get_spec M)))) = TopoS_Composition_Theory_impl.get_IFS (get_impl M)\"\n    and   \"(get_spec (zip (TopoS_Composition_Theory_impl.get_IFS (get_impl M)) (TopoS_Composition_Theory.get_IFS (get_spec M)))) = TopoS_Composition_Theory.get_IFS (get_spec M)\"\n    and   \"\\<forall> (m_impl, m_spec) \\<in> set (zip (get_ACS (get_impl M)) (TopoS_Composition_Theory.get_ACS (get_spec M))). SecurityInvariant_complies_formal_def m_impl m_spec\" (is \"\\<forall> (m_impl, m_spec) \\<in> set ?zippedACS. SecurityInvariant_complies_formal_def m_impl m_spec\")\n    and   \"(get_impl (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M)) (TopoS_Composition_Theory.get_ACS (get_spec M)))) = TopoS_Composition_Theory_impl.get_ACS (get_impl M)\"\n    and   \"(get_spec (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M)) (TopoS_Composition_Theory.get_ACS (get_spec M)))) = TopoS_Composition_Theory.get_ACS (get_spec M)\"", "lemma all_security_requirements_fulfilled_complies:\n    \"\\<lbrakk> \\<forall> (m_impl, m_spec) \\<in> set M. SecurityInvariant_complies_formal_def m_impl m_spec; \n       wf_list_graph (G::('v::vertex) list_graph) \\<rbrakk> \\<Longrightarrow>\n    all_security_requirements_fulfilled (get_impl M) G \\<longleftrightarrow> TopoS_Composition_Theory.all_security_requirements_fulfilled (get_spec M) (list_graph_to_graph G)\"", "lemma generate_valid_topology_complies:\n    \"\\<lbrakk> \\<forall> (m_impl, m_spec) \\<in> set M. SecurityInvariant_complies_formal_def m_impl m_spec;\n       wf_list_graph (G::('v list_graph)) \\<rbrakk> \\<Longrightarrow> \n       list_graph_to_graph (generate_valid_topology (get_impl M) G) = \n       TopoS_Composition_Theory.generate_valid_topology (get_spec M) (list_graph_to_graph G)\"", "lemma generate_valid_topology_some_complies:\n    \"\\<lbrakk> \\<forall> (m_impl, m_spec) \\<in> set M. SecurityInvariant_complies_formal_def m_impl m_spec;\n       wf_list_graph (G::('v::vertex list_graph)) \\<rbrakk> \\<Longrightarrow> \n       list_graph_to_graph (generate_valid_topology_some (get_impl M) G) = \n       TopoS_Composition_Theory.generate_valid_topology_some (get_spec M) (edgesL G) (list_graph_to_graph G)\""], "translations": [["", "lemma TopoS_modelLibrary_yields_new_configured_SecurityInvariant:\n    assumes NetModelLib: \"TopoS_modelLibrary m sinvar_spec\"\n    and     nPdef:       \"nP = nm_node_props m C\"\n    and formalSpec:      \"Spec = \\<lparr> \n                              c_sinvar = (\\<lambda>G. sinvar_spec G nP),\n                              c_offending_flows = (\\<lambda>G. SecurityInvariant_withOffendingFlows.set_offending_flows sinvar_spec G nP),\n                              c_isIFS = nm_receiver_violation m\n                            \\<rparr>\"\n    shows \"new_configured_SecurityInvariant (sinvar_spec, nm_default m, nm_receiver_violation m, nP) = Some Spec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_configured_SecurityInvariant\n     (sinvar_spec, nm_default m, nm_receiver_violation m, nP) =\n    Some Spec", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. new_configured_SecurityInvariant\n     (sinvar_spec, nm_default m, nm_receiver_violation m, nP) =\n    Some Spec", "from NetModelLib"], ["proof (chain)\npicking this:\n  TopoS_modelLibrary m sinvar_spec", "have NetModel: \"SecurityInvariant sinvar_spec (nm_default m) (nm_receiver_violation m)\""], ["proof (prove)\nusing this:\n  TopoS_modelLibrary m sinvar_spec\n\ngoal (1 subgoal):\n 1. SecurityInvariant sinvar_spec (nm_default m) (nm_receiver_violation m)", "by(simp add: TopoS_modelLibrary_def TopoS_List_Impl_def)"], ["proof (state)\nthis:\n  SecurityInvariant sinvar_spec (nm_default m) (nm_receiver_violation m)\n\ngoal (1 subgoal):\n 1. new_configured_SecurityInvariant\n     (sinvar_spec, nm_default m, nm_receiver_violation m, nP) =\n    Some Spec", "have Spec: \"\\<lparr>c_sinvar = \\<lambda>G. sinvar_spec G nP,\n             c_offending_flows = \\<lambda>G. SecurityInvariant_withOffendingFlows.set_offending_flows sinvar_spec G nP,\n             c_isIFS = nm_receiver_violation m\\<rparr> = Spec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>c_sinvar = \\<lambda>G. sinvar_spec G nP,\n       c_offending_flows =\n         \\<lambda>G.\n            SecurityInvariant_withOffendingFlows.set_offending_flows\n             sinvar_spec G nP,\n       c_isIFS = nm_receiver_violation m\\<rparr> =\n    Spec", "by(simp add: formalSpec)"], ["proof (state)\nthis:\n  \\<lparr>c_sinvar = \\<lambda>G. sinvar_spec G nP,\n     c_offending_flows =\n       \\<lambda>G.\n          SecurityInvariant_withOffendingFlows.set_offending_flows\n           sinvar_spec G nP,\n     c_isIFS = nm_receiver_violation m\\<rparr> =\n  Spec\n\ngoal (1 subgoal):\n 1. new_configured_SecurityInvariant\n     (sinvar_spec, nm_default m, nm_receiver_violation m, nP) =\n    Some Spec", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. new_configured_SecurityInvariant\n     (sinvar_spec, nm_default m, nm_receiver_violation m, nP) =\n    Some Spec", "unfolding new_configured_SecurityInvariant.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if SecurityInvariant sinvar_spec (nm_default m)\n         (nm_receiver_violation m)\n     then Some\n           \\<lparr>c_sinvar = \\<lambda>G. sinvar_spec G nP,\n              c_offending_flows =\n                \\<lambda>G.\n                   SecurityInvariant_withOffendingFlows.set_offending_flows\n                    sinvar_spec G nP,\n              c_isIFS = nm_receiver_violation m\\<rparr>\n     else None) =\n    Some Spec", "by(simp add: NetModel Spec)"], ["proof (state)\nthis:\n  new_configured_SecurityInvariant\n   (sinvar_spec, nm_default m, nm_receiver_violation m, nP) =\n  Some Spec\n\ngoal:\nNo subgoals!", "qed"], ["", "thm TopoS_modelLibrary_yields_new_configured_SecurityInvariant[simplified]"], ["", "(*todo fold in Spec*)\n\n\n  (* The new_* functions comply, i.e. we can instance network security models that are executable. *)"], ["", "lemma new_configured_list_SecurityInvariant_complies:\n    assumes NetModelLib: \"TopoS_modelLibrary m sinvar_spec\"\n    and     nPdef:       \"nP = nm_node_props m C\"\n    and formalSpec:      \"Spec = new_configured_SecurityInvariant (sinvar_spec, nm_default m, nm_receiver_violation m, nP)\"\n    and implSpec:        \"Impl = new_configured_list_SecurityInvariant m C description\"\n    shows \"SecurityInvariant_complies_formal_def Impl (the Spec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_complies_formal_def Impl (the Spec)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. SecurityInvariant_complies_formal_def Impl (the Spec)", "from TopoS_modelLibrary_yields_new_configured_SecurityInvariant[OF NetModelLib nPdef]"], ["proof (chain)\npicking this:\n  ?Spec =\n  \\<lparr>c_sinvar = \\<lambda>G. sinvar_spec G nP,\n     c_offending_flows =\n       \\<lambda>G.\n          SecurityInvariant_withOffendingFlows.set_offending_flows\n           sinvar_spec G nP,\n     c_isIFS = nm_receiver_violation m\\<rparr> \\<Longrightarrow>\n  new_configured_SecurityInvariant\n   (sinvar_spec, nm_default m, nm_receiver_violation m, nP) =\n  Some ?Spec", "have SpecUnfolded: \"new_configured_SecurityInvariant (sinvar_spec, nm_default m, nm_receiver_violation m, nP) =\n        Some \\<lparr>c_sinvar = \\<lambda>G. sinvar_spec G nP,\n             c_offending_flows = \\<lambda>G. SecurityInvariant_withOffendingFlows.set_offending_flows sinvar_spec G nP,\n             c_isIFS = nm_receiver_violation m\\<rparr>\""], ["proof (prove)\nusing this:\n  ?Spec =\n  \\<lparr>c_sinvar = \\<lambda>G. sinvar_spec G nP,\n     c_offending_flows =\n       \\<lambda>G.\n          SecurityInvariant_withOffendingFlows.set_offending_flows\n           sinvar_spec G nP,\n     c_isIFS = nm_receiver_violation m\\<rparr> \\<Longrightarrow>\n  new_configured_SecurityInvariant\n   (sinvar_spec, nm_default m, nm_receiver_violation m, nP) =\n  Some ?Spec\n\ngoal (1 subgoal):\n 1. new_configured_SecurityInvariant\n     (sinvar_spec, nm_default m, nm_receiver_violation m, nP) =\n    Some\n     \\<lparr>c_sinvar = \\<lambda>G. sinvar_spec G nP,\n        c_offending_flows =\n          \\<lambda>G.\n             SecurityInvariant_withOffendingFlows.set_offending_flows\n              sinvar_spec G nP,\n        c_isIFS = nm_receiver_violation m\\<rparr>", "by simp"], ["proof (state)\nthis:\n  new_configured_SecurityInvariant\n   (sinvar_spec, nm_default m, nm_receiver_violation m, nP) =\n  Some\n   \\<lparr>c_sinvar = \\<lambda>G. sinvar_spec G nP,\n      c_offending_flows =\n        \\<lambda>G.\n           SecurityInvariant_withOffendingFlows.set_offending_flows\n            sinvar_spec G nP,\n      c_isIFS = nm_receiver_violation m\\<rparr>\n\ngoal (1 subgoal):\n 1. SecurityInvariant_complies_formal_def Impl (the Spec)", "from NetModelLib"], ["proof (chain)\npicking this:\n  TopoS_modelLibrary m sinvar_spec", "show ?thesis"], ["proof (prove)\nusing this:\n  TopoS_modelLibrary m sinvar_spec\n\ngoal (1 subgoal):\n 1. SecurityInvariant_complies_formal_def Impl (the Spec)", "apply(simp add: SpecUnfolded formalSpec implSpec Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. TopoS_modelLibrary m sinvar_spec \\<Longrightarrow>\n    SecurityInvariant_complies_formal_def\n     \\<lparr>implc_type = nm_name m, implc_description = description,\n        implc_sinvar = \\<lambda>G. nm_sinvar m G (nm_node_props m C),\n        implc_offending_flows =\n          \\<lambda>G. nm_offending_flows m G (nm_node_props m C),\n        implc_isIFS = nm_receiver_violation m\\<rparr>\n     \\<lparr>c_sinvar = \\<lambda>G. sinvar_spec G nP,\n        c_offending_flows =\n          \\<lambda>G.\n             SecurityInvariant_withOffendingFlows.set_offending_flows\n              sinvar_spec G nP,\n        c_isIFS = nm_receiver_violation m\\<rparr>", "apply(simp add: SecurityInvariant_complies_formal_def_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. TopoS_modelLibrary m sinvar_spec \\<Longrightarrow>\n    (\\<forall>G.\n        wf_list_graph G \\<longrightarrow>\n        nm_sinvar m G (nm_node_props m C) =\n        sinvar_spec (list_graph_to_graph G) nP) \\<and>\n    (\\<forall>G.\n        wf_list_graph G \\<longrightarrow>\n        set ` set (nm_offending_flows m G (nm_node_props m C)) =\n        SecurityInvariant_withOffendingFlows.set_offending_flows sinvar_spec\n         (list_graph_to_graph G) nP)", "apply(simp add: TopoS_modelLibrary_def TopoS_List_Impl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nm_name m \\<noteq> [] \\<and>\n    SecurityInvariant sinvar_spec (nm_default m)\n     (nm_receiver_violation m) \\<and>\n    (\\<forall>G.\n        wf_list_graph G \\<longrightarrow>\n        (\\<forall>nP.\n            sinvar_spec (list_graph_to_graph G) nP =\n            nm_sinvar m G nP)) \\<and>\n    (\\<forall>G.\n        wf_list_graph G \\<longrightarrow>\n        (\\<forall>nP.\n            SecurityInvariant_withOffendingFlows.set_offending_flows\n             sinvar_spec (list_graph_to_graph G) nP =\n            set ` set (nm_offending_flows m G nP))) \\<and>\n    (\\<forall>P.\n        SecurityInvariant.node_props_formaldef (nm_default m) P =\n        nm_node_props m P) \\<and>\n    (\\<forall>G P.\n        (distinct (nodesL G) \\<and>\n         distinct (edgesL G) \\<and>\n         SecurityInvariant.eval sinvar_spec (nm_default m)\n          (list_graph_to_graph G) P) =\n        nm_eval m G P) \\<Longrightarrow>\n    (\\<forall>G.\n        wf_list_graph G \\<longrightarrow>\n        nm_sinvar m G (nm_node_props m C) = nm_sinvar m G nP) \\<and>\n    (\\<forall>G.\n        wf_list_graph G \\<longrightarrow>\n        set ` set (nm_offending_flows m G (nm_node_props m C)) =\n        set ` set (nm_offending_flows m G nP))", "apply(simp add: nPdef)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  SecurityInvariant_complies_formal_def Impl (the Spec)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary new_configured_list_SecurityInvariant_complies':\n    \"\\<lbrakk> TopoS_modelLibrary m sinvar_spec \\<rbrakk> \\<Longrightarrow> \n    SecurityInvariant_complies_formal_def (new_configured_list_SecurityInvariant m C description)\n      (the (new_configured_SecurityInvariant (sinvar_spec, nm_default m, nm_receiver_violation m, nm_node_props m C)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TopoS_modelLibrary m sinvar_spec \\<Longrightarrow>\n    SecurityInvariant_complies_formal_def\n     (new_configured_list_SecurityInvariant m C description)\n     (the (new_configured_SecurityInvariant\n            (sinvar_spec, nm_default m, nm_receiver_violation m,\n             nm_node_props m C)))", "by(blast dest: new_configured_list_SecurityInvariant_complies)\n\n  \\<comment> \\<open>From\\<close>"], ["", "thm new_configured_SecurityInvariant_sound\n  \\<comment> \\<open>we get that @{const new_configured_list_SecurityInvariant} has all the necessary properties (modulo @{const SecurityInvariant_complies_formal_def})\\<close>"], ["", "subsection\\<open>About security invariants\\<close>"], ["", "text\\<open>specification and implementation comply.\\<close>"], ["", "type_synonym 'v security_models_spec_impl=\"('v SecurityInvariant \\<times> 'v TopoS_Composition_Theory.SecurityInvariant_configured) list\""], ["", "definition get_spec :: \"'v security_models_spec_impl \\<Rightarrow> ('v TopoS_Composition_Theory.SecurityInvariant_configured) list\" where\n    \"get_spec M \\<equiv> [snd m. m \\<leftarrow> M]\""], ["", "definition get_impl :: \"'v security_models_spec_impl \\<Rightarrow> ('v SecurityInvariant) list\" where\n    \"get_impl M \\<equiv> [fst m. m \\<leftarrow> M]\""], ["", "subsection\\<open>Calculating offending flows\\<close>"], ["", "fun implc_get_offending_flows :: \"('v) SecurityInvariant list \\<Rightarrow> 'v list_graph \\<Rightarrow> (('v \\<times> 'v) list list)\" where\n    \"implc_get_offending_flows [] G = []\"  |\n    \"implc_get_offending_flows (m#Ms) G = (implc_offending_flows m G)@(implc_get_offending_flows Ms G)\""], ["", "lemma implc_get_offending_flows_fold: \n    \"implc_get_offending_flows M G = fold (\\<lambda>m accu. accu@(implc_offending_flows m G)) M []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implc_get_offending_flows M G =\n    fold (\\<lambda>m accu. accu @ implc_offending_flows m G) M []", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. implc_get_offending_flows M G =\n    fold (\\<lambda>m accu. accu @ implc_offending_flows m G) M []", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. implc_get_offending_flows M G =\n    fold (\\<lambda>m accu. accu @ implc_offending_flows m G) M []", "fix accu"], ["proof (state)\ngoal (1 subgoal):\n 1. implc_get_offending_flows M G =\n    fold (\\<lambda>m accu. accu @ implc_offending_flows m G) M []", "have \"accu@(implc_get_offending_flows M G) = fold (\\<lambda>m accu. accu@(implc_offending_flows m G)) M accu\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accu @ implc_get_offending_flows M G =\n    fold (\\<lambda>m accu. accu @ implc_offending_flows m G) M accu", "apply(induction M arbitrary: accu)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>accu.\n       accu @ implc_get_offending_flows [] G =\n       fold (\\<lambda>m accu. accu @ implc_offending_flows m G) [] accu\n 2. \\<And>a M accu.\n       (\\<And>accu.\n           accu @ implc_get_offending_flows M G =\n           fold (\\<lambda>m accu. accu @ implc_offending_flows m G) M\n            accu) \\<Longrightarrow>\n       accu @ implc_get_offending_flows (a # M) G =\n       fold (\\<lambda>m accu. accu @ implc_offending_flows m G) (a # M) accu", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M accu.\n       (\\<And>accu.\n           accu @ implc_get_offending_flows M G =\n           fold (\\<lambda>m accu. accu @ implc_offending_flows m G) M\n            accu) \\<Longrightarrow>\n       accu @\n       fold (\\<lambda>m accu. accu @ implc_offending_flows m G) M\n        (implc_offending_flows a G) =\n       fold (\\<lambda>m accu. accu @ implc_offending_flows m G) M\n        (accu @ implc_offending_flows a G)", "by(metis append_eq_appendI)"], ["proof (state)\nthis:\n  accu @ implc_get_offending_flows M G =\n  fold (\\<lambda>m accu. accu @ implc_offending_flows m G) M accu\n\ngoal (1 subgoal):\n 1. implc_get_offending_flows M G =\n    fold (\\<lambda>m accu. accu @ implc_offending_flows m G) M []", "}"], ["proof (state)\nthis:\n  ?accu2 @ implc_get_offending_flows M G =\n  fold (\\<lambda>m accu. accu @ implc_offending_flows m G) M ?accu2\n\ngoal (1 subgoal):\n 1. implc_get_offending_flows M G =\n    fold (\\<lambda>m accu. accu @ implc_offending_flows m G) M []", "from this[where accu2=\"[]\"]"], ["proof (chain)\npicking this:\n  [] @ implc_get_offending_flows M G =\n  fold (\\<lambda>m accu. accu @ implc_offending_flows m G) M []", "show ?thesis"], ["proof (prove)\nusing this:\n  [] @ implc_get_offending_flows M G =\n  fold (\\<lambda>m accu. accu @ implc_offending_flows m G) M []\n\ngoal (1 subgoal):\n 1. implc_get_offending_flows M G =\n    fold (\\<lambda>m accu. accu @ implc_offending_flows m G) M []", "by simp"], ["proof (state)\nthis:\n  implc_get_offending_flows M G =\n  fold (\\<lambda>m accu. accu @ implc_offending_flows m G) M []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma implc_get_offending_flows_Un: \"set`set (implc_get_offending_flows M G) = (\\<Union>m\\<in>set M. set`set (implc_offending_flows m G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ` set (implc_get_offending_flows M G) =\n    (\\<Union>m\\<in>set M. set ` set (implc_offending_flows m G))", "apply(induction M)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set ` set (implc_get_offending_flows [] G) =\n    (\\<Union>m\\<in>set []. set ` set (implc_offending_flows m G))\n 2. \\<And>a M.\n       set ` set (implc_get_offending_flows M G) =\n       (\\<Union>m\\<in>set M.\n           set ` set (implc_offending_flows m G)) \\<Longrightarrow>\n       set ` set (implc_get_offending_flows (a # M) G) =\n       (\\<Union>m\\<in>set (a # M). set ` set (implc_offending_flows m G))", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       set ` set (implc_get_offending_flows M G) =\n       (\\<Union>m\\<in>set M.\n           set ` set (implc_offending_flows m G)) \\<Longrightarrow>\n       set `\n       (set (implc_offending_flows a G) \\<union>\n        set (implc_get_offending_flows M G)) =\n       set ` set (implc_offending_flows a G) \\<union>\n       (\\<Union>x\\<in>set M. set ` set (implc_offending_flows x G))", "by (metis image_Un)"], ["", "lemma implc_get_offending_flows_map_concat: \"(implc_get_offending_flows M G) = concat [implc_offending_flows m G. m \\<leftarrow> M]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implc_get_offending_flows M G =\n    concat (map (\\<lambda>m. implc_offending_flows m G) M)", "apply(induction M)"], ["proof (prove)\ngoal (2 subgoals):\n 1. implc_get_offending_flows [] G =\n    concat (map (\\<lambda>m. implc_offending_flows m G) [])\n 2. \\<And>a M.\n       implc_get_offending_flows M G =\n       concat\n        (map (\\<lambda>m. implc_offending_flows m G) M) \\<Longrightarrow>\n       implc_get_offending_flows (a # M) G =\n       concat (map (\\<lambda>m. implc_offending_flows m G) (a # M))", "by(simp_all)"], ["", "theorem implc_get_offending_flows_complies:\n    assumes a1: \"\\<forall> (m_impl, m_spec) \\<in> set M. SecurityInvariant_complies_formal_def m_impl m_spec\"\n    and     a2: \"wf_list_graph G\"\n    shows   \"set`set (implc_get_offending_flows (get_impl M) G) = (get_offending_flows (get_spec M) (list_graph_to_graph G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ` set (implc_get_offending_flows (get_impl M) G) =\n    get_offending_flows (get_spec M) (list_graph_to_graph G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set ` set (implc_get_offending_flows (get_impl M) G) =\n    get_offending_flows (get_spec M) (list_graph_to_graph G)", "from a1"], ["proof (chain)\npicking this:\n  \\<forall>(m_impl, m_spec)\\<in>set M.\n     SecurityInvariant_complies_formal_def m_impl m_spec", "have \"\\<forall> (m_impl, m_spec) \\<in> set M. set ` set (implc_offending_flows m_impl G) = c_offending_flows m_spec (list_graph_to_graph G)\""], ["proof (prove)\nusing this:\n  \\<forall>(m_impl, m_spec)\\<in>set M.\n     SecurityInvariant_complies_formal_def m_impl m_spec\n\ngoal (1 subgoal):\n 1. \\<forall>(m_impl, m_spec)\\<in>set M.\n       set ` set (implc_offending_flows m_impl G) =\n       c_offending_flows m_spec (list_graph_to_graph G)", "apply(simp add: SecurityInvariant_complies_formal_def_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set M.\n       case x of\n       (m_impl, m_spec) \\<Rightarrow>\n         (\\<forall>G.\n             wf_list_graph G \\<longrightarrow>\n             implc_sinvar m_impl G =\n             c_sinvar m_spec (list_graph_to_graph G)) \\<and>\n         (\\<forall>G.\n             wf_list_graph G \\<longrightarrow>\n             set ` set (implc_offending_flows m_impl G) =\n             c_offending_flows m_spec (list_graph_to_graph G)) \\<and>\n         implc_isIFS m_impl = c_isIFS m_spec \\<Longrightarrow>\n    \\<forall>x\\<in>set M.\n       case x of\n       (m_impl, m_spec) \\<Rightarrow>\n         set ` set (implc_offending_flows m_impl G) =\n         c_offending_flows m_spec (list_graph_to_graph G)", "using a2"], ["proof (prove)\nusing this:\n  wf_list_graph G\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set M.\n       case x of\n       (m_impl, m_spec) \\<Rightarrow>\n         (\\<forall>G.\n             wf_list_graph G \\<longrightarrow>\n             implc_sinvar m_impl G =\n             c_sinvar m_spec (list_graph_to_graph G)) \\<and>\n         (\\<forall>G.\n             wf_list_graph G \\<longrightarrow>\n             set ` set (implc_offending_flows m_impl G) =\n             c_offending_flows m_spec (list_graph_to_graph G)) \\<and>\n         implc_isIFS m_impl = c_isIFS m_spec \\<Longrightarrow>\n    \\<forall>x\\<in>set M.\n       case x of\n       (m_impl, m_spec) \\<Rightarrow>\n         set ` set (implc_offending_flows m_impl G) =\n         c_offending_flows m_spec (list_graph_to_graph G)", "by blast"], ["proof (state)\nthis:\n  \\<forall>(m_impl, m_spec)\\<in>set M.\n     set ` set (implc_offending_flows m_impl G) =\n     c_offending_flows m_spec (list_graph_to_graph G)\n\ngoal (1 subgoal):\n 1. set ` set (implc_get_offending_flows (get_impl M) G) =\n    get_offending_flows (get_spec M) (list_graph_to_graph G)", "hence \"\\<forall> m \\<in> set M. set ` set (implc_offending_flows (fst m) G) = c_offending_flows (snd m) (list_graph_to_graph G)\""], ["proof (prove)\nusing this:\n  \\<forall>(m_impl, m_spec)\\<in>set M.\n     set ` set (implc_offending_flows m_impl G) =\n     c_offending_flows m_spec (list_graph_to_graph G)\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>set M.\n       set ` set (implc_offending_flows (fst m) G) =\n       c_offending_flows (snd m) (list_graph_to_graph G)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>m\\<in>set M.\n     set ` set (implc_offending_flows (fst m) G) =\n     c_offending_flows (snd m) (list_graph_to_graph G)\n\ngoal (1 subgoal):\n 1. set ` set (implc_get_offending_flows (get_impl M) G) =\n    get_offending_flows (get_spec M) (list_graph_to_graph G)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>set M.\n     set ` set (implc_offending_flows (fst m) G) =\n     c_offending_flows (snd m) (list_graph_to_graph G)\n\ngoal (1 subgoal):\n 1. set ` set (implc_get_offending_flows (get_impl M) G) =\n    get_offending_flows (get_spec M) (list_graph_to_graph G)", "by(simp add: get_impl_def get_spec_def implc_get_offending_flows_Un get_offending_flows_def)"], ["proof (state)\nthis:\n  set ` set (implc_get_offending_flows (get_impl M) G) =\n  get_offending_flows (get_spec M) (list_graph_to_graph G)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Accessors\\<close>"], ["", "definition get_IFS :: \"'v SecurityInvariant list \\<Rightarrow> 'v SecurityInvariant list\" where\n    \"get_IFS M \\<equiv> [m \\<leftarrow> M. implc_isIFS m]\""], ["", "definition get_ACS :: \"'v SecurityInvariant list \\<Rightarrow> 'v SecurityInvariant list\" where\n    \"get_ACS M \\<equiv> [m \\<leftarrow> M. \\<not> implc_isIFS m]\""], ["", "lemma get_IFS_get_ACS_complies:\n  assumes a: \"\\<forall> (m_impl, m_spec) \\<in> set M. SecurityInvariant_complies_formal_def m_impl m_spec\"\n    shows \"\\<forall> (m_impl, m_spec) \\<in> set (zip (get_IFS (get_impl M)) (TopoS_Composition_Theory.get_IFS (get_spec M))).\n      SecurityInvariant_complies_formal_def m_impl m_spec\"\n    and \"\\<forall> (m_impl, m_spec) \\<in> set (zip (get_ACS (get_impl M)) (TopoS_Composition_Theory.get_ACS (get_spec M))).\n      SecurityInvariant_complies_formal_def m_impl m_spec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(m_impl, m_spec)\n             \\<in>set (zip (TopoS_Composition_Theory_impl.get_IFS\n                             (get_impl M))\n                        (TopoS_Composition_Theory.get_IFS (get_spec M))).\n       SecurityInvariant_complies_formal_def m_impl m_spec &&&\n    \\<forall>(m_impl, m_spec)\n             \\<in>set (zip (TopoS_Composition_Theory_impl.get_ACS\n                             (get_impl M))\n                        (TopoS_Composition_Theory.get_ACS (get_spec M))).\n       SecurityInvariant_complies_formal_def m_impl m_spec", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>(m_impl, m_spec)\n             \\<in>set (zip (TopoS_Composition_Theory_impl.get_IFS\n                             (get_impl M))\n                        (TopoS_Composition_Theory.get_IFS (get_spec M))).\n       SecurityInvariant_complies_formal_def m_impl m_spec\n 2. \\<forall>(m_impl, m_spec)\n             \\<in>set (zip (TopoS_Composition_Theory_impl.get_ACS\n                             (get_impl M))\n                        (TopoS_Composition_Theory.get_ACS (get_spec M))).\n       SecurityInvariant_complies_formal_def m_impl m_spec", "from a"], ["proof (chain)\npicking this:\n  \\<forall>(m_impl, m_spec)\\<in>set M.\n     SecurityInvariant_complies_formal_def m_impl m_spec", "have \"\\<forall> (m_impl, m_spec) \\<in> set M. implc_isIFS m_impl = c_isIFS m_spec\""], ["proof (prove)\nusing this:\n  \\<forall>(m_impl, m_spec)\\<in>set M.\n     SecurityInvariant_complies_formal_def m_impl m_spec\n\ngoal (1 subgoal):\n 1. \\<forall>(m_impl, m_spec)\\<in>set M. implc_isIFS m_impl = c_isIFS m_spec", "apply(simp add: SecurityInvariant_complies_formal_def_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set M.\n       case x of\n       (m_impl, m_spec) \\<Rightarrow>\n         (\\<forall>G.\n             wf_list_graph G \\<longrightarrow>\n             implc_sinvar m_impl G =\n             c_sinvar m_spec (list_graph_to_graph G)) \\<and>\n         (\\<forall>G.\n             wf_list_graph G \\<longrightarrow>\n             set ` set (implc_offending_flows m_impl G) =\n             c_offending_flows m_spec (list_graph_to_graph G)) \\<and>\n         implc_isIFS m_impl = c_isIFS m_spec \\<Longrightarrow>\n    \\<forall>x\\<in>set M.\n       case x of\n       (m_impl, m_spec) \\<Rightarrow> implc_isIFS m_impl = c_isIFS m_spec", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>(m_impl, m_spec)\\<in>set M. implc_isIFS m_impl = c_isIFS m_spec\n\ngoal (2 subgoals):\n 1. \\<forall>(m_impl, m_spec)\n             \\<in>set (zip (TopoS_Composition_Theory_impl.get_IFS\n                             (get_impl M))\n                        (TopoS_Composition_Theory.get_IFS (get_spec M))).\n       SecurityInvariant_complies_formal_def m_impl m_spec\n 2. \\<forall>(m_impl, m_spec)\n             \\<in>set (zip (TopoS_Composition_Theory_impl.get_ACS\n                             (get_impl M))\n                        (TopoS_Composition_Theory.get_ACS (get_spec M))).\n       SecurityInvariant_complies_formal_def m_impl m_spec", "hence set_zip_IFS: \"set (zip (filter implc_isIFS (get_impl M)) (filter c_isIFS (get_spec M))) \\<subseteq> set M\""], ["proof (prove)\nusing this:\n  \\<forall>(m_impl, m_spec)\\<in>set M. implc_isIFS m_impl = c_isIFS m_spec\n\ngoal (1 subgoal):\n 1. set (zip (filter implc_isIFS (get_impl M))\n          (filter c_isIFS (get_spec M)))\n    \\<subseteq> set M", "apply(simp add: get_impl_def get_spec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set M.\n       case x of\n       (m_impl, m_spec) \\<Rightarrow>\n         implc_isIFS m_impl = c_isIFS m_spec \\<Longrightarrow>\n    set (zip (filter implc_isIFS (map fst M)) (filter c_isIFS (map snd M)))\n    \\<subseteq> set M", "apply(induction M)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>(m_impl, m_spec)\\<in>set [].\n       implc_isIFS m_impl = c_isIFS m_spec \\<Longrightarrow>\n    set (zip (filter implc_isIFS (map fst []))\n          (filter c_isIFS (map snd [])))\n    \\<subseteq> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<forall>(m_impl, m_spec)\\<in>set M.\n                   implc_isIFS m_impl = c_isIFS m_spec \\<Longrightarrow>\n                set (zip (filter implc_isIFS (map fst M))\n                      (filter c_isIFS (map snd M)))\n                \\<subseteq> set M;\n        \\<forall>(m_impl, m_spec)\\<in>set (a # M).\n           implc_isIFS m_impl = c_isIFS m_spec\\<rbrakk>\n       \\<Longrightarrow> set (zip (filter implc_isIFS (map fst (a # M)))\n                               (filter c_isIFS (map snd (a # M))))\n                         \\<subseteq> set (a # M)", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>set (zip (filter implc_isIFS (map fst M))\n                      (filter c_isIFS (map snd M)))\n                \\<subseteq> set M;\n        (case a of\n         (m_impl, m_spec) \\<Rightarrow>\n           implc_isIFS m_impl = c_isIFS m_spec) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (m_impl, m_spec) \\<Rightarrow>\n              implc_isIFS m_impl = c_isIFS m_spec)\\<rbrakk>\n       \\<Longrightarrow> (implc_isIFS (fst a) \\<longrightarrow>\n                          (c_isIFS (snd a) \\<longrightarrow>\n                           set (zip (filter implc_isIFS (map fst M))\n                                 (filter c_isIFS (map snd M)))\n                           \\<subseteq> insert a (set M)) \\<and>\n                          (\\<not> c_isIFS (snd a) \\<longrightarrow>\n                           set (zip (fst a # filter implc_isIFS (map fst M))\n                                 (filter c_isIFS (map snd M)))\n                           \\<subseteq> insert a (set M))) \\<and>\n                         (\\<not> implc_isIFS (fst a) \\<longrightarrow>\n                          (c_isIFS (snd a) \\<longrightarrow>\n                           set (zip (filter implc_isIFS (map fst M))\n                                 (snd a # filter c_isIFS (map snd M)))\n                           \\<subseteq> insert a (set M)) \\<and>\n                          (\\<not> c_isIFS (snd a) \\<longrightarrow>\n                           set (zip (filter implc_isIFS (map fst M))\n                                 (filter c_isIFS (map snd M)))\n                           \\<subseteq> insert a (set M)))", "by force"], ["proof (state)\nthis:\n  set (zip (filter implc_isIFS (get_impl M)) (filter c_isIFS (get_spec M)))\n  \\<subseteq> set M\n\ngoal (2 subgoals):\n 1. \\<forall>(m_impl, m_spec)\n             \\<in>set (zip (TopoS_Composition_Theory_impl.get_IFS\n                             (get_impl M))\n                        (TopoS_Composition_Theory.get_IFS (get_spec M))).\n       SecurityInvariant_complies_formal_def m_impl m_spec\n 2. \\<forall>(m_impl, m_spec)\n             \\<in>set (zip (TopoS_Composition_Theory_impl.get_ACS\n                             (get_impl M))\n                        (TopoS_Composition_Theory.get_ACS (get_spec M))).\n       SecurityInvariant_complies_formal_def m_impl m_spec", "from set_zip_IFS a"], ["proof (chain)\npicking this:\n  set (zip (filter implc_isIFS (get_impl M)) (filter c_isIFS (get_spec M)))\n  \\<subseteq> set M\n  \\<forall>(m_impl, m_spec)\\<in>set M.\n     SecurityInvariant_complies_formal_def m_impl m_spec", "show \"\\<forall> (m_impl, m_spec) \\<in> set (zip (get_IFS (get_impl M)) (TopoS_Composition_Theory.get_IFS (get_spec M))).\n          SecurityInvariant_complies_formal_def m_impl m_spec\""], ["proof (prove)\nusing this:\n  set (zip (filter implc_isIFS (get_impl M)) (filter c_isIFS (get_spec M)))\n  \\<subseteq> set M\n  \\<forall>(m_impl, m_spec)\\<in>set M.\n     SecurityInvariant_complies_formal_def m_impl m_spec\n\ngoal (1 subgoal):\n 1. \\<forall>(m_impl, m_spec)\n             \\<in>set (zip (TopoS_Composition_Theory_impl.get_IFS\n                             (get_impl M))\n                        (TopoS_Composition_Theory.get_IFS (get_spec M))).\n       SecurityInvariant_complies_formal_def m_impl m_spec", "apply(simp add: get_IFS_def get_ACS_def\n          TopoS_Composition_Theory.get_IFS_def TopoS_Composition_Theory.get_ACS_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set (zip (filter implc_isIFS (get_impl M))\n                   (filter c_isIFS (get_spec M)))\n             \\<subseteq> set M;\n     \\<forall>x\\<in>set M.\n        case x of\n        (m_impl, m_spec) \\<Rightarrow>\n          SecurityInvariant_complies_formal_def m_impl m_spec\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set\n(zip (filter implc_isIFS (get_impl M)) (filter c_isIFS (get_spec M))).\n                         case x of\n                         (m_impl, m_spec) \\<Rightarrow>\n                           SecurityInvariant_complies_formal_def m_impl\n                            m_spec", "by blast"], ["proof (state)\nthis:\n  \\<forall>(m_impl, m_spec)\n           \\<in>set (zip (TopoS_Composition_Theory_impl.get_IFS\n                           (get_impl M))\n                      (TopoS_Composition_Theory.get_IFS (get_spec M))).\n     SecurityInvariant_complies_formal_def m_impl m_spec\n\ngoal (1 subgoal):\n 1. \\<forall>(m_impl, m_spec)\n             \\<in>set (zip (TopoS_Composition_Theory_impl.get_ACS\n                             (get_impl M))\n                        (TopoS_Composition_Theory.get_ACS (get_spec M))).\n       SecurityInvariant_complies_formal_def m_impl m_spec", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>(m_impl, m_spec)\n             \\<in>set (zip (TopoS_Composition_Theory_impl.get_ACS\n                             (get_impl M))\n                        (TopoS_Composition_Theory.get_ACS (get_spec M))).\n       SecurityInvariant_complies_formal_def m_impl m_spec", "from a"], ["proof (chain)\npicking this:\n  \\<forall>(m_impl, m_spec)\\<in>set M.\n     SecurityInvariant_complies_formal_def m_impl m_spec", "have \"\\<forall> (m_impl, m_spec) \\<in> set M. implc_isIFS m_impl = c_isIFS m_spec\""], ["proof (prove)\nusing this:\n  \\<forall>(m_impl, m_spec)\\<in>set M.\n     SecurityInvariant_complies_formal_def m_impl m_spec\n\ngoal (1 subgoal):\n 1. \\<forall>(m_impl, m_spec)\\<in>set M. implc_isIFS m_impl = c_isIFS m_spec", "apply(simp add: SecurityInvariant_complies_formal_def_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set M.\n       case x of\n       (m_impl, m_spec) \\<Rightarrow>\n         (\\<forall>G.\n             wf_list_graph G \\<longrightarrow>\n             implc_sinvar m_impl G =\n             c_sinvar m_spec (list_graph_to_graph G)) \\<and>\n         (\\<forall>G.\n             wf_list_graph G \\<longrightarrow>\n             set ` set (implc_offending_flows m_impl G) =\n             c_offending_flows m_spec (list_graph_to_graph G)) \\<and>\n         implc_isIFS m_impl = c_isIFS m_spec \\<Longrightarrow>\n    \\<forall>x\\<in>set M.\n       case x of\n       (m_impl, m_spec) \\<Rightarrow> implc_isIFS m_impl = c_isIFS m_spec", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>(m_impl, m_spec)\\<in>set M. implc_isIFS m_impl = c_isIFS m_spec\n\ngoal (1 subgoal):\n 1. \\<forall>(m_impl, m_spec)\n             \\<in>set (zip (TopoS_Composition_Theory_impl.get_ACS\n                             (get_impl M))\n                        (TopoS_Composition_Theory.get_ACS (get_spec M))).\n       SecurityInvariant_complies_formal_def m_impl m_spec", "hence set_zip_ACS: \"set (zip [m\\<leftarrow>get_impl M . \\<not> implc_isIFS m] [m\\<leftarrow>get_spec M . \\<not> c_isIFS m]) \\<subseteq> set M\""], ["proof (prove)\nusing this:\n  \\<forall>(m_impl, m_spec)\\<in>set M. implc_isIFS m_impl = c_isIFS m_spec\n\ngoal (1 subgoal):\n 1. set (zip (filter (\\<lambda>m. \\<not> implc_isIFS m) (get_impl M))\n          (filter (\\<lambda>m. \\<not> c_isIFS m) (get_spec M)))\n    \\<subseteq> set M", "apply(simp add: get_impl_def get_spec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set M.\n       case x of\n       (m_impl, m_spec) \\<Rightarrow>\n         implc_isIFS m_impl = c_isIFS m_spec \\<Longrightarrow>\n    set (zip (filter (\\<lambda>m. \\<not> implc_isIFS m) (map fst M))\n          (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M)))\n    \\<subseteq> set M", "apply(induction M)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>(m_impl, m_spec)\\<in>set [].\n       implc_isIFS m_impl = c_isIFS m_spec \\<Longrightarrow>\n    set (zip (filter (\\<lambda>m. \\<not> implc_isIFS m) (map fst []))\n          (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd [])))\n    \\<subseteq> set []\n 2. \\<And>a M.\n       \\<lbrakk>\\<forall>(m_impl, m_spec)\\<in>set M.\n                   implc_isIFS m_impl = c_isIFS m_spec \\<Longrightarrow>\n                set (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                           (map fst M))\n                      (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M)))\n                \\<subseteq> set M;\n        \\<forall>(m_impl, m_spec)\\<in>set (a # M).\n           implc_isIFS m_impl = c_isIFS m_spec\\<rbrakk>\n       \\<Longrightarrow> set (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                    (map fst (a # M)))\n                               (filter (\\<lambda>m. \\<not> c_isIFS m)\n                                 (map snd (a # M))))\n                         \\<subseteq> set (a # M)", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>set (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                           (map fst M))\n                      (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M)))\n                \\<subseteq> set M;\n        (case a of\n         (m_impl, m_spec) \\<Rightarrow>\n           implc_isIFS m_impl = c_isIFS m_spec) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (m_impl, m_spec) \\<Rightarrow>\n              implc_isIFS m_impl = c_isIFS m_spec)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> implc_isIFS (fst a) \\<longrightarrow>\n                          (\\<not> c_isIFS (snd a) \\<longrightarrow>\n                           set (zip (filter\n(\\<lambda>m. \\<not> implc_isIFS m) (map fst M))\n                                 (filter (\\<lambda>m. \\<not> c_isIFS m)\n                                   (map snd M)))\n                           \\<subseteq> insert a (set M)) \\<and>\n                          (c_isIFS (snd a) \\<longrightarrow>\n                           set (zip (fst a #\n                                     filter\n(\\<lambda>m. \\<not> implc_isIFS m) (map fst M))\n                                 (filter (\\<lambda>m. \\<not> c_isIFS m)\n                                   (map snd M)))\n                           \\<subseteq> insert a (set M))) \\<and>\n                         (implc_isIFS (fst a) \\<longrightarrow>\n                          (\\<not> c_isIFS (snd a) \\<longrightarrow>\n                           set (zip (filter\n(\\<lambda>m. \\<not> implc_isIFS m) (map fst M))\n                                 (snd a #\n                                  filter (\\<lambda>m. \\<not> c_isIFS m)\n                                   (map snd M)))\n                           \\<subseteq> insert a (set M)) \\<and>\n                          (c_isIFS (snd a) \\<longrightarrow>\n                           set (zip (filter\n(\\<lambda>m. \\<not> implc_isIFS m) (map fst M))\n                                 (filter (\\<lambda>m. \\<not> c_isIFS m)\n                                   (map snd M)))\n                           \\<subseteq> insert a (set M)))", "by force"], ["proof (state)\nthis:\n  set (zip (filter (\\<lambda>m. \\<not> implc_isIFS m) (get_impl M))\n        (filter (\\<lambda>m. \\<not> c_isIFS m) (get_spec M)))\n  \\<subseteq> set M\n\ngoal (1 subgoal):\n 1. \\<forall>(m_impl, m_spec)\n             \\<in>set (zip (TopoS_Composition_Theory_impl.get_ACS\n                             (get_impl M))\n                        (TopoS_Composition_Theory.get_ACS (get_spec M))).\n       SecurityInvariant_complies_formal_def m_impl m_spec", "from this a"], ["proof (chain)\npicking this:\n  set (zip (filter (\\<lambda>m. \\<not> implc_isIFS m) (get_impl M))\n        (filter (\\<lambda>m. \\<not> c_isIFS m) (get_spec M)))\n  \\<subseteq> set M\n  \\<forall>(m_impl, m_spec)\\<in>set M.\n     SecurityInvariant_complies_formal_def m_impl m_spec", "show \"\\<forall> (m_impl, m_spec) \\<in> set (zip (get_ACS (get_impl M)) (TopoS_Composition_Theory.get_ACS (get_spec M))).\n        SecurityInvariant_complies_formal_def m_impl m_spec\""], ["proof (prove)\nusing this:\n  set (zip (filter (\\<lambda>m. \\<not> implc_isIFS m) (get_impl M))\n        (filter (\\<lambda>m. \\<not> c_isIFS m) (get_spec M)))\n  \\<subseteq> set M\n  \\<forall>(m_impl, m_spec)\\<in>set M.\n     SecurityInvariant_complies_formal_def m_impl m_spec\n\ngoal (1 subgoal):\n 1. \\<forall>(m_impl, m_spec)\n             \\<in>set (zip (TopoS_Composition_Theory_impl.get_ACS\n                             (get_impl M))\n                        (TopoS_Composition_Theory.get_ACS (get_spec M))).\n       SecurityInvariant_complies_formal_def m_impl m_spec", "apply(simp add: get_IFS_def get_ACS_def\n          TopoS_Composition_Theory.get_IFS_def TopoS_Composition_Theory.get_ACS_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                        (get_impl M))\n                   (filter (\\<lambda>m. \\<not> c_isIFS m) (get_spec M)))\n             \\<subseteq> set M;\n     \\<forall>x\\<in>set M.\n        case x of\n        (m_impl, m_spec) \\<Rightarrow>\n          SecurityInvariant_complies_formal_def m_impl m_spec\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set\n(zip (filter (\\<lambda>m. \\<not> implc_isIFS m) (get_impl M))\n  (filter (\\<lambda>m. \\<not> c_isIFS m) (get_spec M))).\n                         case x of\n                         (m_impl, m_spec) \\<Rightarrow>\n                           SecurityInvariant_complies_formal_def m_impl\n                            m_spec", "by fast"], ["proof (state)\nthis:\n  \\<forall>(m_impl, m_spec)\n           \\<in>set (zip (TopoS_Composition_Theory_impl.get_ACS\n                           (get_impl M))\n                      (TopoS_Composition_Theory.get_ACS (get_spec M))).\n     SecurityInvariant_complies_formal_def m_impl m_spec\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma get_IFS_get_ACS_select_simps:\n    assumes a1: \"\\<forall> (m_impl, m_spec) \\<in> set M. SecurityInvariant_complies_formal_def m_impl m_spec\"\n    shows \"\\<forall> (m_impl, m_spec) \\<in> set (zip (get_IFS (get_impl M)) (TopoS_Composition_Theory.get_IFS (get_spec M))). SecurityInvariant_complies_formal_def m_impl m_spec\" (is \"\\<forall> (m_impl, m_spec) \\<in> set ?zippedIFS. SecurityInvariant_complies_formal_def m_impl m_spec\")\n    and   \"(get_impl (zip (TopoS_Composition_Theory_impl.get_IFS (get_impl M)) (TopoS_Composition_Theory.get_IFS (get_spec M)))) = TopoS_Composition_Theory_impl.get_IFS (get_impl M)\"\n    and   \"(get_spec (zip (TopoS_Composition_Theory_impl.get_IFS (get_impl M)) (TopoS_Composition_Theory.get_IFS (get_spec M)))) = TopoS_Composition_Theory.get_IFS (get_spec M)\"\n    and   \"\\<forall> (m_impl, m_spec) \\<in> set (zip (get_ACS (get_impl M)) (TopoS_Composition_Theory.get_ACS (get_spec M))). SecurityInvariant_complies_formal_def m_impl m_spec\" (is \"\\<forall> (m_impl, m_spec) \\<in> set ?zippedACS. SecurityInvariant_complies_formal_def m_impl m_spec\")\n    and   \"(get_impl (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M)) (TopoS_Composition_Theory.get_ACS (get_spec M)))) = TopoS_Composition_Theory_impl.get_ACS (get_impl M)\"\n    and   \"(get_spec (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M)) (TopoS_Composition_Theory.get_ACS (get_spec M)))) = TopoS_Composition_Theory.get_ACS (get_spec M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>(m_impl, m_spec)\n              \\<in>set (zip (TopoS_Composition_Theory_impl.get_IFS\n                              (get_impl M))\n                         (TopoS_Composition_Theory.get_IFS (get_spec M))).\n        SecurityInvariant_complies_formal_def m_impl m_spec &&&\n     get_impl\n      (zip (TopoS_Composition_Theory_impl.get_IFS (get_impl M))\n        (TopoS_Composition_Theory.get_IFS (get_spec M))) =\n     TopoS_Composition_Theory_impl.get_IFS (get_impl M) &&&\n     get_spec\n      (zip (TopoS_Composition_Theory_impl.get_IFS (get_impl M))\n        (TopoS_Composition_Theory.get_IFS (get_spec M))) =\n     TopoS_Composition_Theory.get_IFS (get_spec M)) &&&\n    \\<forall>(m_impl, m_spec)\n             \\<in>set (zip (TopoS_Composition_Theory_impl.get_ACS\n                             (get_impl M))\n                        (TopoS_Composition_Theory.get_ACS (get_spec M))).\n       SecurityInvariant_complies_formal_def m_impl m_spec &&&\n    get_impl\n     (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n       (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n    TopoS_Composition_Theory_impl.get_ACS (get_impl M) &&&\n    get_spec\n     (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n       (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n    TopoS_Composition_Theory.get_ACS (get_spec M)", "proof -"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<forall>(m_impl, m_spec)\n             \\<in>set (zip (TopoS_Composition_Theory_impl.get_IFS\n                             (get_impl M))\n                        (TopoS_Composition_Theory.get_IFS (get_spec M))).\n       SecurityInvariant_complies_formal_def m_impl m_spec\n 2. get_impl\n     (zip (TopoS_Composition_Theory_impl.get_IFS (get_impl M))\n       (TopoS_Composition_Theory.get_IFS (get_spec M))) =\n    TopoS_Composition_Theory_impl.get_IFS (get_impl M)\n 3. get_spec\n     (zip (TopoS_Composition_Theory_impl.get_IFS (get_impl M))\n       (TopoS_Composition_Theory.get_IFS (get_spec M))) =\n    TopoS_Composition_Theory.get_IFS (get_spec M)\n 4. \\<forall>(m_impl, m_spec)\n             \\<in>set (zip (TopoS_Composition_Theory_impl.get_ACS\n                             (get_impl M))\n                        (TopoS_Composition_Theory.get_ACS (get_spec M))).\n       SecurityInvariant_complies_formal_def m_impl m_spec\n 5. get_impl\n     (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n       (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n    TopoS_Composition_Theory_impl.get_ACS (get_impl M)\n 6. get_spec\n     (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n       (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n    TopoS_Composition_Theory.get_ACS (get_spec M)", "from get_IFS_get_ACS_complies(1)[OF a1]"], ["proof (chain)\npicking this:\n  \\<forall>(m_impl, m_spec)\n           \\<in>set (zip (TopoS_Composition_Theory_impl.get_IFS\n                           (get_impl M))\n                      (TopoS_Composition_Theory.get_IFS (get_spec M))).\n     SecurityInvariant_complies_formal_def m_impl m_spec", "show \"\\<forall> (m_impl, m_spec) \\<in> set (?zippedIFS). SecurityInvariant_complies_formal_def m_impl m_spec\""], ["proof (prove)\nusing this:\n  \\<forall>(m_impl, m_spec)\n           \\<in>set (zip (TopoS_Composition_Theory_impl.get_IFS\n                           (get_impl M))\n                      (TopoS_Composition_Theory.get_IFS (get_spec M))).\n     SecurityInvariant_complies_formal_def m_impl m_spec\n\ngoal (1 subgoal):\n 1. \\<forall>(m_impl, m_spec)\n             \\<in>set (zip (TopoS_Composition_Theory_impl.get_IFS\n                             (get_impl M))\n                        (TopoS_Composition_Theory.get_IFS (get_spec M))).\n       SecurityInvariant_complies_formal_def m_impl m_spec", "by simp"], ["proof (state)\nthis:\n  \\<forall>(m_impl, m_spec)\n           \\<in>set (zip (TopoS_Composition_Theory_impl.get_IFS\n                           (get_impl M))\n                      (TopoS_Composition_Theory.get_IFS (get_spec M))).\n     SecurityInvariant_complies_formal_def m_impl m_spec\n\ngoal (5 subgoals):\n 1. get_impl\n     (zip (TopoS_Composition_Theory_impl.get_IFS (get_impl M))\n       (TopoS_Composition_Theory.get_IFS (get_spec M))) =\n    TopoS_Composition_Theory_impl.get_IFS (get_impl M)\n 2. get_spec\n     (zip (TopoS_Composition_Theory_impl.get_IFS (get_impl M))\n       (TopoS_Composition_Theory.get_IFS (get_spec M))) =\n    TopoS_Composition_Theory.get_IFS (get_spec M)\n 3. \\<forall>(m_impl, m_spec)\n             \\<in>set (zip (TopoS_Composition_Theory_impl.get_ACS\n                             (get_impl M))\n                        (TopoS_Composition_Theory.get_ACS (get_spec M))).\n       SecurityInvariant_complies_formal_def m_impl m_spec\n 4. get_impl\n     (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n       (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n    TopoS_Composition_Theory_impl.get_ACS (get_impl M)\n 5. get_spec\n     (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n       (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n    TopoS_Composition_Theory.get_ACS (get_spec M)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. get_impl\n     (zip (TopoS_Composition_Theory_impl.get_IFS (get_impl M))\n       (TopoS_Composition_Theory.get_IFS (get_spec M))) =\n    TopoS_Composition_Theory_impl.get_IFS (get_impl M)\n 2. get_spec\n     (zip (TopoS_Composition_Theory_impl.get_IFS (get_impl M))\n       (TopoS_Composition_Theory.get_IFS (get_spec M))) =\n    TopoS_Composition_Theory.get_IFS (get_spec M)\n 3. \\<forall>(m_impl, m_spec)\n             \\<in>set (zip (TopoS_Composition_Theory_impl.get_ACS\n                             (get_impl M))\n                        (TopoS_Composition_Theory.get_ACS (get_spec M))).\n       SecurityInvariant_complies_formal_def m_impl m_spec\n 4. get_impl\n     (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n       (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n    TopoS_Composition_Theory_impl.get_ACS (get_impl M)\n 5. get_spec\n     (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n       (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n    TopoS_Composition_Theory.get_ACS (get_spec M)", "from a1"], ["proof (chain)\npicking this:\n  \\<forall>(m_impl, m_spec)\\<in>set M.\n     SecurityInvariant_complies_formal_def m_impl m_spec", "show \"(get_impl ?zippedIFS) = TopoS_Composition_Theory_impl.get_IFS (get_impl M)\""], ["proof (prove)\nusing this:\n  \\<forall>(m_impl, m_spec)\\<in>set M.\n     SecurityInvariant_complies_formal_def m_impl m_spec\n\ngoal (1 subgoal):\n 1. get_impl\n     (zip (TopoS_Composition_Theory_impl.get_IFS (get_impl M))\n       (TopoS_Composition_Theory.get_IFS (get_spec M))) =\n    TopoS_Composition_Theory_impl.get_IFS (get_impl M)", "apply(simp add: TopoS_Composition_Theory_impl.get_IFS_def get_spec_def get_impl_def TopoS_Composition_Theory.get_IFS_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set M.\n       case x of\n       (m_impl, m_spec) \\<Rightarrow>\n         SecurityInvariant_complies_formal_def m_impl\n          m_spec \\<Longrightarrow>\n    map fst\n     (zip (filter implc_isIFS (map fst M)) (filter c_isIFS (map snd M))) =\n    filter implc_isIFS (map fst M)", "apply(induction M)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>(x, y)\\<in>set [].\n       SecurityInvariant_complies_formal_def x y \\<Longrightarrow>\n    map fst\n     (zip (filter implc_isIFS (map fst [])) (filter c_isIFS (map snd []))) =\n    filter implc_isIFS (map fst [])\n 2. \\<And>a M.\n       \\<lbrakk>\\<forall>(x, y)\\<in>set M.\n                   SecurityInvariant_complies_formal_def x\n                    y \\<Longrightarrow>\n                map fst\n                 (zip (filter implc_isIFS (map fst M))\n                   (filter c_isIFS (map snd M))) =\n                filter implc_isIFS (map fst M);\n        \\<forall>(x, y)\\<in>set (a # M).\n           SecurityInvariant_complies_formal_def x y\\<rbrakk>\n       \\<Longrightarrow> map fst\n                          (zip (filter implc_isIFS (map fst (a # M)))\n                            (filter c_isIFS (map snd (a # M)))) =\n                         filter implc_isIFS (map fst (a # M))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<forall>(x, y)\\<in>set M.\n                   SecurityInvariant_complies_formal_def x\n                    y \\<Longrightarrow>\n                map fst\n                 (zip (filter implc_isIFS (map fst M))\n                   (filter c_isIFS (map snd M))) =\n                filter implc_isIFS (map fst M);\n        \\<forall>(x, y)\\<in>set (a # M).\n           SecurityInvariant_complies_formal_def x y\\<rbrakk>\n       \\<Longrightarrow> map fst\n                          (zip (filter implc_isIFS (map fst (a # M)))\n                            (filter c_isIFS (map snd (a # M)))) =\n                         filter implc_isIFS (map fst (a # M))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>map fst\n                 (zip (filter implc_isIFS (map fst M))\n                   (filter c_isIFS (map snd M))) =\n                filter implc_isIFS (map fst M);\n        (case a of\n         (x, xa) \\<Rightarrow>\n           SecurityInvariant_complies_formal_def x xa) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (x, xa) \\<Rightarrow>\n              SecurityInvariant_complies_formal_def x xa)\\<rbrakk>\n       \\<Longrightarrow> (c_isIFS (snd a) \\<longrightarrow>\n                          \\<not> implc_isIFS (fst a) \\<longrightarrow>\n                          map fst\n                           (zip (filter implc_isIFS (map fst M))\n                             (snd a # filter c_isIFS (map snd M))) =\n                          filter implc_isIFS (map fst M)) \\<and>\n                         (\\<not> c_isIFS (snd a) \\<longrightarrow>\n                          implc_isIFS (fst a) \\<longrightarrow>\n                          map fst\n                           (zip (fst a # filter implc_isIFS (map fst M))\n                             (filter c_isIFS (map snd M))) =\n                          fst a # filter implc_isIFS (map fst M))", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a M.\n       \\<lbrakk>map fst\n                 (zip (filter implc_isIFS (map fst M))\n                   (filter c_isIFS (map snd M))) =\n                filter implc_isIFS (map fst M);\n        (case a of\n         (x, xa) \\<Rightarrow>\n           SecurityInvariant_complies_formal_def x xa) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (x, xa) \\<Rightarrow>\n              SecurityInvariant_complies_formal_def x xa)\\<rbrakk>\n       \\<Longrightarrow> c_isIFS (snd a) \\<longrightarrow>\n                         \\<not> implc_isIFS (fst a) \\<longrightarrow>\n                         map fst\n                          (zip (filter implc_isIFS (map fst M))\n                            (snd a # filter c_isIFS (map snd M))) =\n                         filter implc_isIFS (map fst M)\n 2. \\<And>a M.\n       \\<lbrakk>map fst\n                 (zip (filter implc_isIFS (map fst M))\n                   (filter c_isIFS (map snd M))) =\n                filter implc_isIFS (map fst M);\n        (case a of\n         (x, xa) \\<Rightarrow>\n           SecurityInvariant_complies_formal_def x xa) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (x, xa) \\<Rightarrow>\n              SecurityInvariant_complies_formal_def x xa)\\<rbrakk>\n       \\<Longrightarrow> \\<not> c_isIFS (snd a) \\<longrightarrow>\n                         implc_isIFS (fst a) \\<longrightarrow>\n                         map fst\n                          (zip (fst a # filter implc_isIFS (map fst M))\n                            (filter c_isIFS (map snd M))) =\n                         fst a # filter implc_isIFS (map fst M)", "apply(clarify)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b M.\n       \\<lbrakk>map fst\n                 (zip (filter implc_isIFS (map fst M))\n                   (filter c_isIFS (map snd M))) =\n                filter implc_isIFS (map fst M);\n        SecurityInvariant_complies_formal_def a b;\n        \\<forall>(x, y)\\<in>set M.\n           SecurityInvariant_complies_formal_def x y;\n        c_isIFS (snd (a, b)); \\<not> implc_isIFS (fst (a, b))\\<rbrakk>\n       \\<Longrightarrow> map fst\n                          (zip (filter implc_isIFS (map fst M))\n                            (snd (a, b) # filter c_isIFS (map snd M))) =\n                         filter implc_isIFS (map fst M)\n 2. \\<And>a M.\n       \\<lbrakk>map fst\n                 (zip (filter implc_isIFS (map fst M))\n                   (filter c_isIFS (map snd M))) =\n                filter implc_isIFS (map fst M);\n        (case a of\n         (x, xa) \\<Rightarrow>\n           SecurityInvariant_complies_formal_def x xa) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (x, xa) \\<Rightarrow>\n              SecurityInvariant_complies_formal_def x xa)\\<rbrakk>\n       \\<Longrightarrow> \\<not> c_isIFS (snd a) \\<longrightarrow>\n                         implc_isIFS (fst a) \\<longrightarrow>\n                         map fst\n                          (zip (fst a # filter implc_isIFS (map fst M))\n                            (filter c_isIFS (map snd M))) =\n                         fst a # filter implc_isIFS (map fst M)", "using SecurityInvariant_complies_formal_def_def"], ["proof (prove)\nusing this:\n  SecurityInvariant_complies_formal_def ?impl ?spec \\<equiv>\n  (\\<forall>G.\n      wf_list_graph G \\<longrightarrow>\n      implc_sinvar ?impl G = c_sinvar ?spec (list_graph_to_graph G)) \\<and>\n  (\\<forall>G.\n      wf_list_graph G \\<longrightarrow>\n      set ` set (implc_offending_flows ?impl G) =\n      c_offending_flows ?spec (list_graph_to_graph G)) \\<and>\n  implc_isIFS ?impl = c_isIFS ?spec\n\ngoal (2 subgoals):\n 1. \\<And>a b M.\n       \\<lbrakk>map fst\n                 (zip (filter implc_isIFS (map fst M))\n                   (filter c_isIFS (map snd M))) =\n                filter implc_isIFS (map fst M);\n        SecurityInvariant_complies_formal_def a b;\n        \\<forall>(x, y)\\<in>set M.\n           SecurityInvariant_complies_formal_def x y;\n        c_isIFS (snd (a, b)); \\<not> implc_isIFS (fst (a, b))\\<rbrakk>\n       \\<Longrightarrow> map fst\n                          (zip (filter implc_isIFS (map fst M))\n                            (snd (a, b) # filter c_isIFS (map snd M))) =\n                         filter implc_isIFS (map fst M)\n 2. \\<And>a M.\n       \\<lbrakk>map fst\n                 (zip (filter implc_isIFS (map fst M))\n                   (filter c_isIFS (map snd M))) =\n                filter implc_isIFS (map fst M);\n        (case a of\n         (x, xa) \\<Rightarrow>\n           SecurityInvariant_complies_formal_def x xa) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (x, xa) \\<Rightarrow>\n              SecurityInvariant_complies_formal_def x xa)\\<rbrakk>\n       \\<Longrightarrow> \\<not> c_isIFS (snd a) \\<longrightarrow>\n                         implc_isIFS (fst a) \\<longrightarrow>\n                         map fst\n                          (zip (fst a # filter implc_isIFS (map fst M))\n                            (filter c_isIFS (map snd M))) =\n                         fst a # filter implc_isIFS (map fst M)", "apply (auto)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>map fst\n                 (zip (filter implc_isIFS (map fst M))\n                   (filter c_isIFS (map snd M))) =\n                filter implc_isIFS (map fst M);\n        (case a of\n         (x, xa) \\<Rightarrow>\n           SecurityInvariant_complies_formal_def x xa) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (x, xa) \\<Rightarrow>\n              SecurityInvariant_complies_formal_def x xa)\\<rbrakk>\n       \\<Longrightarrow> \\<not> c_isIFS (snd a) \\<longrightarrow>\n                         implc_isIFS (fst a) \\<longrightarrow>\n                         map fst\n                          (zip (fst a # filter implc_isIFS (map fst M))\n                            (filter c_isIFS (map snd M))) =\n                         fst a # filter implc_isIFS (map fst M)", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b M.\n       \\<lbrakk>map fst\n                 (zip (filter implc_isIFS (map fst M))\n                   (filter c_isIFS (map snd M))) =\n                filter implc_isIFS (map fst M);\n        SecurityInvariant_complies_formal_def a b;\n        \\<forall>(x, y)\\<in>set M.\n           SecurityInvariant_complies_formal_def x y;\n        \\<not> c_isIFS (snd (a, b)); implc_isIFS (fst (a, b))\\<rbrakk>\n       \\<Longrightarrow> map fst\n                          (zip (fst (a, b) # filter implc_isIFS (map fst M))\n                            (filter c_isIFS (map snd M))) =\n                         fst (a, b) # filter implc_isIFS (map fst M)", "using SecurityInvariant_complies_formal_def_def"], ["proof (prove)\nusing this:\n  SecurityInvariant_complies_formal_def ?impl ?spec \\<equiv>\n  (\\<forall>G.\n      wf_list_graph G \\<longrightarrow>\n      implc_sinvar ?impl G = c_sinvar ?spec (list_graph_to_graph G)) \\<and>\n  (\\<forall>G.\n      wf_list_graph G \\<longrightarrow>\n      set ` set (implc_offending_flows ?impl G) =\n      c_offending_flows ?spec (list_graph_to_graph G)) \\<and>\n  implc_isIFS ?impl = c_isIFS ?spec\n\ngoal (1 subgoal):\n 1. \\<And>a b M.\n       \\<lbrakk>map fst\n                 (zip (filter implc_isIFS (map fst M))\n                   (filter c_isIFS (map snd M))) =\n                filter implc_isIFS (map fst M);\n        SecurityInvariant_complies_formal_def a b;\n        \\<forall>(x, y)\\<in>set M.\n           SecurityInvariant_complies_formal_def x y;\n        \\<not> c_isIFS (snd (a, b)); implc_isIFS (fst (a, b))\\<rbrakk>\n       \\<Longrightarrow> map fst\n                          (zip (fst (a, b) # filter implc_isIFS (map fst M))\n                            (filter c_isIFS (map snd M))) =\n                         fst (a, b) # filter implc_isIFS (map fst M)", "apply (auto)[1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  get_impl\n   (zip (TopoS_Composition_Theory_impl.get_IFS (get_impl M))\n     (TopoS_Composition_Theory.get_IFS (get_spec M))) =\n  TopoS_Composition_Theory_impl.get_IFS (get_impl M)\n\ngoal (4 subgoals):\n 1. get_spec\n     (zip (TopoS_Composition_Theory_impl.get_IFS (get_impl M))\n       (TopoS_Composition_Theory.get_IFS (get_spec M))) =\n    TopoS_Composition_Theory.get_IFS (get_spec M)\n 2. \\<forall>(m_impl, m_spec)\n             \\<in>set (zip (TopoS_Composition_Theory_impl.get_ACS\n                             (get_impl M))\n                        (TopoS_Composition_Theory.get_ACS (get_spec M))).\n       SecurityInvariant_complies_formal_def m_impl m_spec\n 3. get_impl\n     (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n       (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n    TopoS_Composition_Theory_impl.get_ACS (get_impl M)\n 4. get_spec\n     (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n       (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n    TopoS_Composition_Theory.get_ACS (get_spec M)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. get_spec\n     (zip (TopoS_Composition_Theory_impl.get_IFS (get_impl M))\n       (TopoS_Composition_Theory.get_IFS (get_spec M))) =\n    TopoS_Composition_Theory.get_IFS (get_spec M)\n 2. \\<forall>(m_impl, m_spec)\n             \\<in>set (zip (TopoS_Composition_Theory_impl.get_ACS\n                             (get_impl M))\n                        (TopoS_Composition_Theory.get_ACS (get_spec M))).\n       SecurityInvariant_complies_formal_def m_impl m_spec\n 3. get_impl\n     (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n       (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n    TopoS_Composition_Theory_impl.get_ACS (get_impl M)\n 4. get_spec\n     (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n       (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n    TopoS_Composition_Theory.get_ACS (get_spec M)", "from a1"], ["proof (chain)\npicking this:\n  \\<forall>(m_impl, m_spec)\\<in>set M.\n     SecurityInvariant_complies_formal_def m_impl m_spec", "show \"(get_spec ?zippedIFS) = TopoS_Composition_Theory.get_IFS (get_spec M)\""], ["proof (prove)\nusing this:\n  \\<forall>(m_impl, m_spec)\\<in>set M.\n     SecurityInvariant_complies_formal_def m_impl m_spec\n\ngoal (1 subgoal):\n 1. get_spec\n     (zip (TopoS_Composition_Theory_impl.get_IFS (get_impl M))\n       (TopoS_Composition_Theory.get_IFS (get_spec M))) =\n    TopoS_Composition_Theory.get_IFS (get_spec M)", "apply(simp add: TopoS_Composition_Theory_impl.get_IFS_def get_spec_def get_impl_def TopoS_Composition_Theory.get_IFS_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set M.\n       case x of\n       (m_impl, m_spec) \\<Rightarrow>\n         SecurityInvariant_complies_formal_def m_impl\n          m_spec \\<Longrightarrow>\n    map snd\n     (zip (filter implc_isIFS (map fst M)) (filter c_isIFS (map snd M))) =\n    filter c_isIFS (map snd M)", "apply(induction M)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>(x, y)\\<in>set [].\n       SecurityInvariant_complies_formal_def x y \\<Longrightarrow>\n    map snd\n     (zip (filter implc_isIFS (map fst [])) (filter c_isIFS (map snd []))) =\n    filter c_isIFS (map snd [])\n 2. \\<And>a M.\n       \\<lbrakk>\\<forall>(x, y)\\<in>set M.\n                   SecurityInvariant_complies_formal_def x\n                    y \\<Longrightarrow>\n                map snd\n                 (zip (filter implc_isIFS (map fst M))\n                   (filter c_isIFS (map snd M))) =\n                filter c_isIFS (map snd M);\n        \\<forall>(x, y)\\<in>set (a # M).\n           SecurityInvariant_complies_formal_def x y\\<rbrakk>\n       \\<Longrightarrow> map snd\n                          (zip (filter implc_isIFS (map fst (a # M)))\n                            (filter c_isIFS (map snd (a # M)))) =\n                         filter c_isIFS (map snd (a # M))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<forall>(x, y)\\<in>set M.\n                   SecurityInvariant_complies_formal_def x\n                    y \\<Longrightarrow>\n                map snd\n                 (zip (filter implc_isIFS (map fst M))\n                   (filter c_isIFS (map snd M))) =\n                filter c_isIFS (map snd M);\n        \\<forall>(x, y)\\<in>set (a # M).\n           SecurityInvariant_complies_formal_def x y\\<rbrakk>\n       \\<Longrightarrow> map snd\n                          (zip (filter implc_isIFS (map fst (a # M)))\n                            (filter c_isIFS (map snd (a # M)))) =\n                         filter c_isIFS (map snd (a # M))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>map snd\n                 (zip (filter implc_isIFS (map fst M))\n                   (filter c_isIFS (map snd M))) =\n                filter c_isIFS (map snd M);\n        (case a of\n         (x, xa) \\<Rightarrow>\n           SecurityInvariant_complies_formal_def x xa) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (x, xa) \\<Rightarrow>\n              SecurityInvariant_complies_formal_def x xa)\\<rbrakk>\n       \\<Longrightarrow> (implc_isIFS (fst a) \\<longrightarrow>\n                          \\<not> c_isIFS (snd a) \\<longrightarrow>\n                          map snd\n                           (zip (fst a # filter implc_isIFS (map fst M))\n                             (filter c_isIFS (map snd M))) =\n                          filter c_isIFS (map snd M)) \\<and>\n                         (\\<not> implc_isIFS (fst a) \\<longrightarrow>\n                          c_isIFS (snd a) \\<longrightarrow>\n                          map snd\n                           (zip (filter implc_isIFS (map fst M))\n                             (snd a # filter c_isIFS (map snd M))) =\n                          snd a # filter c_isIFS (map snd M))", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a M.\n       \\<lbrakk>map snd\n                 (zip (filter implc_isIFS (map fst M))\n                   (filter c_isIFS (map snd M))) =\n                filter c_isIFS (map snd M);\n        (case a of\n         (x, xa) \\<Rightarrow>\n           SecurityInvariant_complies_formal_def x xa) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (x, xa) \\<Rightarrow>\n              SecurityInvariant_complies_formal_def x xa)\\<rbrakk>\n       \\<Longrightarrow> implc_isIFS (fst a) \\<longrightarrow>\n                         \\<not> c_isIFS (snd a) \\<longrightarrow>\n                         map snd\n                          (zip (fst a # filter implc_isIFS (map fst M))\n                            (filter c_isIFS (map snd M))) =\n                         filter c_isIFS (map snd M)\n 2. \\<And>a M.\n       \\<lbrakk>map snd\n                 (zip (filter implc_isIFS (map fst M))\n                   (filter c_isIFS (map snd M))) =\n                filter c_isIFS (map snd M);\n        (case a of\n         (x, xa) \\<Rightarrow>\n           SecurityInvariant_complies_formal_def x xa) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (x, xa) \\<Rightarrow>\n              SecurityInvariant_complies_formal_def x xa)\\<rbrakk>\n       \\<Longrightarrow> \\<not> implc_isIFS (fst a) \\<longrightarrow>\n                         c_isIFS (snd a) \\<longrightarrow>\n                         map snd\n                          (zip (filter implc_isIFS (map fst M))\n                            (snd a # filter c_isIFS (map snd M))) =\n                         snd a # filter c_isIFS (map snd M)", "apply(clarify)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b M.\n       \\<lbrakk>map snd\n                 (zip (filter implc_isIFS (map fst M))\n                   (filter c_isIFS (map snd M))) =\n                filter c_isIFS (map snd M);\n        SecurityInvariant_complies_formal_def a b;\n        \\<forall>(x, y)\\<in>set M.\n           SecurityInvariant_complies_formal_def x y;\n        implc_isIFS (fst (a, b)); \\<not> c_isIFS (snd (a, b))\\<rbrakk>\n       \\<Longrightarrow> map snd\n                          (zip (fst (a, b) # filter implc_isIFS (map fst M))\n                            (filter c_isIFS (map snd M))) =\n                         filter c_isIFS (map snd M)\n 2. \\<And>a M.\n       \\<lbrakk>map snd\n                 (zip (filter implc_isIFS (map fst M))\n                   (filter c_isIFS (map snd M))) =\n                filter c_isIFS (map snd M);\n        (case a of\n         (x, xa) \\<Rightarrow>\n           SecurityInvariant_complies_formal_def x xa) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (x, xa) \\<Rightarrow>\n              SecurityInvariant_complies_formal_def x xa)\\<rbrakk>\n       \\<Longrightarrow> \\<not> implc_isIFS (fst a) \\<longrightarrow>\n                         c_isIFS (snd a) \\<longrightarrow>\n                         map snd\n                          (zip (filter implc_isIFS (map fst M))\n                            (snd a # filter c_isIFS (map snd M))) =\n                         snd a # filter c_isIFS (map snd M)", "using SecurityInvariant_complies_formal_def_def"], ["proof (prove)\nusing this:\n  SecurityInvariant_complies_formal_def ?impl ?spec \\<equiv>\n  (\\<forall>G.\n      wf_list_graph G \\<longrightarrow>\n      implc_sinvar ?impl G = c_sinvar ?spec (list_graph_to_graph G)) \\<and>\n  (\\<forall>G.\n      wf_list_graph G \\<longrightarrow>\n      set ` set (implc_offending_flows ?impl G) =\n      c_offending_flows ?spec (list_graph_to_graph G)) \\<and>\n  implc_isIFS ?impl = c_isIFS ?spec\n\ngoal (2 subgoals):\n 1. \\<And>a b M.\n       \\<lbrakk>map snd\n                 (zip (filter implc_isIFS (map fst M))\n                   (filter c_isIFS (map snd M))) =\n                filter c_isIFS (map snd M);\n        SecurityInvariant_complies_formal_def a b;\n        \\<forall>(x, y)\\<in>set M.\n           SecurityInvariant_complies_formal_def x y;\n        implc_isIFS (fst (a, b)); \\<not> c_isIFS (snd (a, b))\\<rbrakk>\n       \\<Longrightarrow> map snd\n                          (zip (fst (a, b) # filter implc_isIFS (map fst M))\n                            (filter c_isIFS (map snd M))) =\n                         filter c_isIFS (map snd M)\n 2. \\<And>a M.\n       \\<lbrakk>map snd\n                 (zip (filter implc_isIFS (map fst M))\n                   (filter c_isIFS (map snd M))) =\n                filter c_isIFS (map snd M);\n        (case a of\n         (x, xa) \\<Rightarrow>\n           SecurityInvariant_complies_formal_def x xa) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (x, xa) \\<Rightarrow>\n              SecurityInvariant_complies_formal_def x xa)\\<rbrakk>\n       \\<Longrightarrow> \\<not> implc_isIFS (fst a) \\<longrightarrow>\n                         c_isIFS (snd a) \\<longrightarrow>\n                         map snd\n                          (zip (filter implc_isIFS (map fst M))\n                            (snd a # filter c_isIFS (map snd M))) =\n                         snd a # filter c_isIFS (map snd M)", "apply (auto)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>map snd\n                 (zip (filter implc_isIFS (map fst M))\n                   (filter c_isIFS (map snd M))) =\n                filter c_isIFS (map snd M);\n        (case a of\n         (x, xa) \\<Rightarrow>\n           SecurityInvariant_complies_formal_def x xa) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (x, xa) \\<Rightarrow>\n              SecurityInvariant_complies_formal_def x xa)\\<rbrakk>\n       \\<Longrightarrow> \\<not> implc_isIFS (fst a) \\<longrightarrow>\n                         c_isIFS (snd a) \\<longrightarrow>\n                         map snd\n                          (zip (filter implc_isIFS (map fst M))\n                            (snd a # filter c_isIFS (map snd M))) =\n                         snd a # filter c_isIFS (map snd M)", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b M.\n       \\<lbrakk>map snd\n                 (zip (filter implc_isIFS (map fst M))\n                   (filter c_isIFS (map snd M))) =\n                filter c_isIFS (map snd M);\n        SecurityInvariant_complies_formal_def a b;\n        \\<forall>(x, y)\\<in>set M.\n           SecurityInvariant_complies_formal_def x y;\n        \\<not> implc_isIFS (fst (a, b)); c_isIFS (snd (a, b))\\<rbrakk>\n       \\<Longrightarrow> map snd\n                          (zip (filter implc_isIFS (map fst M))\n                            (snd (a, b) # filter c_isIFS (map snd M))) =\n                         snd (a, b) # filter c_isIFS (map snd M)", "using SecurityInvariant_complies_formal_def_def"], ["proof (prove)\nusing this:\n  SecurityInvariant_complies_formal_def ?impl ?spec \\<equiv>\n  (\\<forall>G.\n      wf_list_graph G \\<longrightarrow>\n      implc_sinvar ?impl G = c_sinvar ?spec (list_graph_to_graph G)) \\<and>\n  (\\<forall>G.\n      wf_list_graph G \\<longrightarrow>\n      set ` set (implc_offending_flows ?impl G) =\n      c_offending_flows ?spec (list_graph_to_graph G)) \\<and>\n  implc_isIFS ?impl = c_isIFS ?spec\n\ngoal (1 subgoal):\n 1. \\<And>a b M.\n       \\<lbrakk>map snd\n                 (zip (filter implc_isIFS (map fst M))\n                   (filter c_isIFS (map snd M))) =\n                filter c_isIFS (map snd M);\n        SecurityInvariant_complies_formal_def a b;\n        \\<forall>(x, y)\\<in>set M.\n           SecurityInvariant_complies_formal_def x y;\n        \\<not> implc_isIFS (fst (a, b)); c_isIFS (snd (a, b))\\<rbrakk>\n       \\<Longrightarrow> map snd\n                          (zip (filter implc_isIFS (map fst M))\n                            (snd (a, b) # filter c_isIFS (map snd M))) =\n                         snd (a, b) # filter c_isIFS (map snd M)", "apply (auto)[1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  get_spec\n   (zip (TopoS_Composition_Theory_impl.get_IFS (get_impl M))\n     (TopoS_Composition_Theory.get_IFS (get_spec M))) =\n  TopoS_Composition_Theory.get_IFS (get_spec M)\n\ngoal (3 subgoals):\n 1. \\<forall>(m_impl, m_spec)\n             \\<in>set (zip (TopoS_Composition_Theory_impl.get_ACS\n                             (get_impl M))\n                        (TopoS_Composition_Theory.get_ACS (get_spec M))).\n       SecurityInvariant_complies_formal_def m_impl m_spec\n 2. get_impl\n     (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n       (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n    TopoS_Composition_Theory_impl.get_ACS (get_impl M)\n 3. get_spec\n     (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n       (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n    TopoS_Composition_Theory.get_ACS (get_spec M)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>(m_impl, m_spec)\n             \\<in>set (zip (TopoS_Composition_Theory_impl.get_ACS\n                             (get_impl M))\n                        (TopoS_Composition_Theory.get_ACS (get_spec M))).\n       SecurityInvariant_complies_formal_def m_impl m_spec\n 2. get_impl\n     (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n       (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n    TopoS_Composition_Theory_impl.get_ACS (get_impl M)\n 3. get_spec\n     (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n       (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n    TopoS_Composition_Theory.get_ACS (get_spec M)", "from get_IFS_get_ACS_complies(2)[OF a1]"], ["proof (chain)\npicking this:\n  \\<forall>(m_impl, m_spec)\n           \\<in>set (zip (TopoS_Composition_Theory_impl.get_ACS\n                           (get_impl M))\n                      (TopoS_Composition_Theory.get_ACS (get_spec M))).\n     SecurityInvariant_complies_formal_def m_impl m_spec", "show \"\\<forall> (m_impl, m_spec) \\<in> set (?zippedACS). SecurityInvariant_complies_formal_def m_impl m_spec\""], ["proof (prove)\nusing this:\n  \\<forall>(m_impl, m_spec)\n           \\<in>set (zip (TopoS_Composition_Theory_impl.get_ACS\n                           (get_impl M))\n                      (TopoS_Composition_Theory.get_ACS (get_spec M))).\n     SecurityInvariant_complies_formal_def m_impl m_spec\n\ngoal (1 subgoal):\n 1. \\<forall>(m_impl, m_spec)\n             \\<in>set (zip (TopoS_Composition_Theory_impl.get_ACS\n                             (get_impl M))\n                        (TopoS_Composition_Theory.get_ACS (get_spec M))).\n       SecurityInvariant_complies_formal_def m_impl m_spec", "by simp"], ["proof (state)\nthis:\n  \\<forall>(m_impl, m_spec)\n           \\<in>set (zip (TopoS_Composition_Theory_impl.get_ACS\n                           (get_impl M))\n                      (TopoS_Composition_Theory.get_ACS (get_spec M))).\n     SecurityInvariant_complies_formal_def m_impl m_spec\n\ngoal (2 subgoals):\n 1. get_impl\n     (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n       (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n    TopoS_Composition_Theory_impl.get_ACS (get_impl M)\n 2. get_spec\n     (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n       (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n    TopoS_Composition_Theory.get_ACS (get_spec M)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. get_impl\n     (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n       (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n    TopoS_Composition_Theory_impl.get_ACS (get_impl M)\n 2. get_spec\n     (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n       (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n    TopoS_Composition_Theory.get_ACS (get_spec M)", "from a1"], ["proof (chain)\npicking this:\n  \\<forall>(m_impl, m_spec)\\<in>set M.\n     SecurityInvariant_complies_formal_def m_impl m_spec", "show \"(get_impl ?zippedACS) = TopoS_Composition_Theory_impl.get_ACS (get_impl M)\""], ["proof (prove)\nusing this:\n  \\<forall>(m_impl, m_spec)\\<in>set M.\n     SecurityInvariant_complies_formal_def m_impl m_spec\n\ngoal (1 subgoal):\n 1. get_impl\n     (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n       (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n    TopoS_Composition_Theory_impl.get_ACS (get_impl M)", "apply(simp add: TopoS_Composition_Theory_impl.get_ACS_def get_spec_def get_impl_def TopoS_Composition_Theory.get_ACS_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set M.\n       case x of\n       (m_impl, m_spec) \\<Rightarrow>\n         SecurityInvariant_complies_formal_def m_impl\n          m_spec \\<Longrightarrow>\n    map fst\n     (zip (filter (\\<lambda>m. \\<not> implc_isIFS m) (map fst M))\n       (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n    filter (\\<lambda>m. \\<not> implc_isIFS m) (map fst M)", "apply(induction M)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>(x, y)\\<in>set [].\n       SecurityInvariant_complies_formal_def x y \\<Longrightarrow>\n    map fst\n     (zip (filter (\\<lambda>m. \\<not> implc_isIFS m) (map fst []))\n       (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd []))) =\n    filter (\\<lambda>m. \\<not> implc_isIFS m) (map fst [])\n 2. \\<And>a M.\n       \\<lbrakk>\\<forall>(x, y)\\<in>set M.\n                   SecurityInvariant_complies_formal_def x\n                    y \\<Longrightarrow>\n                map fst\n                 (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                        (map fst M))\n                   (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n                filter (\\<lambda>m. \\<not> implc_isIFS m) (map fst M);\n        \\<forall>(x, y)\\<in>set (a # M).\n           SecurityInvariant_complies_formal_def x y\\<rbrakk>\n       \\<Longrightarrow> map fst\n                          (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                 (map fst (a # M)))\n                            (filter (\\<lambda>m. \\<not> c_isIFS m)\n                              (map snd (a # M)))) =\n                         filter (\\<lambda>m. \\<not> implc_isIFS m)\n                          (map fst (a # M))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<forall>(x, y)\\<in>set M.\n                   SecurityInvariant_complies_formal_def x\n                    y \\<Longrightarrow>\n                map fst\n                 (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                        (map fst M))\n                   (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n                filter (\\<lambda>m. \\<not> implc_isIFS m) (map fst M);\n        \\<forall>(x, y)\\<in>set (a # M).\n           SecurityInvariant_complies_formal_def x y\\<rbrakk>\n       \\<Longrightarrow> map fst\n                          (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                 (map fst (a # M)))\n                            (filter (\\<lambda>m. \\<not> c_isIFS m)\n                              (map snd (a # M)))) =\n                         filter (\\<lambda>m. \\<not> implc_isIFS m)\n                          (map fst (a # M))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>map fst\n                 (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                        (map fst M))\n                   (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n                filter (\\<lambda>m. \\<not> implc_isIFS m) (map fst M);\n        (case a of\n         (x, xa) \\<Rightarrow>\n           SecurityInvariant_complies_formal_def x xa) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (x, xa) \\<Rightarrow>\n              SecurityInvariant_complies_formal_def x xa)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> c_isIFS (snd a) \\<longrightarrow>\n                          implc_isIFS (fst a) \\<longrightarrow>\n                          map fst\n                           (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                  (map fst M))\n                             (snd a #\n                              filter (\\<lambda>m. \\<not> c_isIFS m)\n                               (map snd M))) =\n                          filter (\\<lambda>m. \\<not> implc_isIFS m)\n                           (map fst M)) \\<and>\n                         (c_isIFS (snd a) \\<longrightarrow>\n                          \\<not> implc_isIFS (fst a) \\<longrightarrow>\n                          map fst\n                           (zip (fst a #\n                                 filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                  (map fst M))\n                             (filter (\\<lambda>m. \\<not> c_isIFS m)\n                               (map snd M))) =\n                          fst a #\n                          filter (\\<lambda>m. \\<not> implc_isIFS m)\n                           (map fst M))", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a M.\n       \\<lbrakk>map fst\n                 (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                        (map fst M))\n                   (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n                filter (\\<lambda>m. \\<not> implc_isIFS m) (map fst M);\n        (case a of\n         (x, xa) \\<Rightarrow>\n           SecurityInvariant_complies_formal_def x xa) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (x, xa) \\<Rightarrow>\n              SecurityInvariant_complies_formal_def x xa)\\<rbrakk>\n       \\<Longrightarrow> \\<not> c_isIFS (snd a) \\<longrightarrow>\n                         implc_isIFS (fst a) \\<longrightarrow>\n                         map fst\n                          (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                 (map fst M))\n                            (snd a #\n                             filter (\\<lambda>m. \\<not> c_isIFS m)\n                              (map snd M))) =\n                         filter (\\<lambda>m. \\<not> implc_isIFS m)\n                          (map fst M)\n 2. \\<And>a M.\n       \\<lbrakk>map fst\n                 (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                        (map fst M))\n                   (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n                filter (\\<lambda>m. \\<not> implc_isIFS m) (map fst M);\n        (case a of\n         (x, xa) \\<Rightarrow>\n           SecurityInvariant_complies_formal_def x xa) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (x, xa) \\<Rightarrow>\n              SecurityInvariant_complies_formal_def x xa)\\<rbrakk>\n       \\<Longrightarrow> c_isIFS (snd a) \\<longrightarrow>\n                         \\<not> implc_isIFS (fst a) \\<longrightarrow>\n                         map fst\n                          (zip (fst a #\n                                filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                 (map fst M))\n                            (filter (\\<lambda>m. \\<not> c_isIFS m)\n                              (map snd M))) =\n                         fst a #\n                         filter (\\<lambda>m. \\<not> implc_isIFS m)\n                          (map fst M)", "apply(clarify)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b M.\n       \\<lbrakk>map fst\n                 (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                        (map fst M))\n                   (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n                filter (\\<lambda>m. \\<not> implc_isIFS m) (map fst M);\n        SecurityInvariant_complies_formal_def a b;\n        \\<forall>(x, y)\\<in>set M.\n           SecurityInvariant_complies_formal_def x y;\n        \\<not> c_isIFS (snd (a, b)); implc_isIFS (fst (a, b))\\<rbrakk>\n       \\<Longrightarrow> map fst\n                          (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                 (map fst M))\n                            (snd (a, b) #\n                             filter (\\<lambda>m. \\<not> c_isIFS m)\n                              (map snd M))) =\n                         filter (\\<lambda>m. \\<not> implc_isIFS m)\n                          (map fst M)\n 2. \\<And>a M.\n       \\<lbrakk>map fst\n                 (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                        (map fst M))\n                   (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n                filter (\\<lambda>m. \\<not> implc_isIFS m) (map fst M);\n        (case a of\n         (x, xa) \\<Rightarrow>\n           SecurityInvariant_complies_formal_def x xa) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (x, xa) \\<Rightarrow>\n              SecurityInvariant_complies_formal_def x xa)\\<rbrakk>\n       \\<Longrightarrow> c_isIFS (snd a) \\<longrightarrow>\n                         \\<not> implc_isIFS (fst a) \\<longrightarrow>\n                         map fst\n                          (zip (fst a #\n                                filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                 (map fst M))\n                            (filter (\\<lambda>m. \\<not> c_isIFS m)\n                              (map snd M))) =\n                         fst a #\n                         filter (\\<lambda>m. \\<not> implc_isIFS m)\n                          (map fst M)", "using SecurityInvariant_complies_formal_def_def"], ["proof (prove)\nusing this:\n  SecurityInvariant_complies_formal_def ?impl ?spec \\<equiv>\n  (\\<forall>G.\n      wf_list_graph G \\<longrightarrow>\n      implc_sinvar ?impl G = c_sinvar ?spec (list_graph_to_graph G)) \\<and>\n  (\\<forall>G.\n      wf_list_graph G \\<longrightarrow>\n      set ` set (implc_offending_flows ?impl G) =\n      c_offending_flows ?spec (list_graph_to_graph G)) \\<and>\n  implc_isIFS ?impl = c_isIFS ?spec\n\ngoal (2 subgoals):\n 1. \\<And>a b M.\n       \\<lbrakk>map fst\n                 (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                        (map fst M))\n                   (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n                filter (\\<lambda>m. \\<not> implc_isIFS m) (map fst M);\n        SecurityInvariant_complies_formal_def a b;\n        \\<forall>(x, y)\\<in>set M.\n           SecurityInvariant_complies_formal_def x y;\n        \\<not> c_isIFS (snd (a, b)); implc_isIFS (fst (a, b))\\<rbrakk>\n       \\<Longrightarrow> map fst\n                          (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                 (map fst M))\n                            (snd (a, b) #\n                             filter (\\<lambda>m. \\<not> c_isIFS m)\n                              (map snd M))) =\n                         filter (\\<lambda>m. \\<not> implc_isIFS m)\n                          (map fst M)\n 2. \\<And>a M.\n       \\<lbrakk>map fst\n                 (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                        (map fst M))\n                   (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n                filter (\\<lambda>m. \\<not> implc_isIFS m) (map fst M);\n        (case a of\n         (x, xa) \\<Rightarrow>\n           SecurityInvariant_complies_formal_def x xa) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (x, xa) \\<Rightarrow>\n              SecurityInvariant_complies_formal_def x xa)\\<rbrakk>\n       \\<Longrightarrow> c_isIFS (snd a) \\<longrightarrow>\n                         \\<not> implc_isIFS (fst a) \\<longrightarrow>\n                         map fst\n                          (zip (fst a #\n                                filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                 (map fst M))\n                            (filter (\\<lambda>m. \\<not> c_isIFS m)\n                              (map snd M))) =\n                         fst a #\n                         filter (\\<lambda>m. \\<not> implc_isIFS m)\n                          (map fst M)", "apply (auto)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>map fst\n                 (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                        (map fst M))\n                   (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n                filter (\\<lambda>m. \\<not> implc_isIFS m) (map fst M);\n        (case a of\n         (x, xa) \\<Rightarrow>\n           SecurityInvariant_complies_formal_def x xa) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (x, xa) \\<Rightarrow>\n              SecurityInvariant_complies_formal_def x xa)\\<rbrakk>\n       \\<Longrightarrow> c_isIFS (snd a) \\<longrightarrow>\n                         \\<not> implc_isIFS (fst a) \\<longrightarrow>\n                         map fst\n                          (zip (fst a #\n                                filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                 (map fst M))\n                            (filter (\\<lambda>m. \\<not> c_isIFS m)\n                              (map snd M))) =\n                         fst a #\n                         filter (\\<lambda>m. \\<not> implc_isIFS m)\n                          (map fst M)", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b M.\n       \\<lbrakk>map fst\n                 (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                        (map fst M))\n                   (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n                filter (\\<lambda>m. \\<not> implc_isIFS m) (map fst M);\n        SecurityInvariant_complies_formal_def a b;\n        \\<forall>(x, y)\\<in>set M.\n           SecurityInvariant_complies_formal_def x y;\n        c_isIFS (snd (a, b)); \\<not> implc_isIFS (fst (a, b))\\<rbrakk>\n       \\<Longrightarrow> map fst\n                          (zip (fst (a, b) #\n                                filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                 (map fst M))\n                            (filter (\\<lambda>m. \\<not> c_isIFS m)\n                              (map snd M))) =\n                         fst (a, b) #\n                         filter (\\<lambda>m. \\<not> implc_isIFS m)\n                          (map fst M)", "using SecurityInvariant_complies_formal_def_def"], ["proof (prove)\nusing this:\n  SecurityInvariant_complies_formal_def ?impl ?spec \\<equiv>\n  (\\<forall>G.\n      wf_list_graph G \\<longrightarrow>\n      implc_sinvar ?impl G = c_sinvar ?spec (list_graph_to_graph G)) \\<and>\n  (\\<forall>G.\n      wf_list_graph G \\<longrightarrow>\n      set ` set (implc_offending_flows ?impl G) =\n      c_offending_flows ?spec (list_graph_to_graph G)) \\<and>\n  implc_isIFS ?impl = c_isIFS ?spec\n\ngoal (1 subgoal):\n 1. \\<And>a b M.\n       \\<lbrakk>map fst\n                 (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                        (map fst M))\n                   (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n                filter (\\<lambda>m. \\<not> implc_isIFS m) (map fst M);\n        SecurityInvariant_complies_formal_def a b;\n        \\<forall>(x, y)\\<in>set M.\n           SecurityInvariant_complies_formal_def x y;\n        c_isIFS (snd (a, b)); \\<not> implc_isIFS (fst (a, b))\\<rbrakk>\n       \\<Longrightarrow> map fst\n                          (zip (fst (a, b) #\n                                filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                 (map fst M))\n                            (filter (\\<lambda>m. \\<not> c_isIFS m)\n                              (map snd M))) =\n                         fst (a, b) #\n                         filter (\\<lambda>m. \\<not> implc_isIFS m)\n                          (map fst M)", "apply (auto)[1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  get_impl\n   (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n     (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n  TopoS_Composition_Theory_impl.get_ACS (get_impl M)\n\ngoal (1 subgoal):\n 1. get_spec\n     (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n       (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n    TopoS_Composition_Theory.get_ACS (get_spec M)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. get_spec\n     (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n       (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n    TopoS_Composition_Theory.get_ACS (get_spec M)", "from a1"], ["proof (chain)\npicking this:\n  \\<forall>(m_impl, m_spec)\\<in>set M.\n     SecurityInvariant_complies_formal_def m_impl m_spec", "show \"(get_spec ?zippedACS) = TopoS_Composition_Theory.get_ACS (get_spec M)\""], ["proof (prove)\nusing this:\n  \\<forall>(m_impl, m_spec)\\<in>set M.\n     SecurityInvariant_complies_formal_def m_impl m_spec\n\ngoal (1 subgoal):\n 1. get_spec\n     (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n       (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n    TopoS_Composition_Theory.get_ACS (get_spec M)", "apply(simp add: TopoS_Composition_Theory_impl.get_ACS_def get_spec_def get_impl_def TopoS_Composition_Theory.get_ACS_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set M.\n       case x of\n       (m_impl, m_spec) \\<Rightarrow>\n         SecurityInvariant_complies_formal_def m_impl\n          m_spec \\<Longrightarrow>\n    map snd\n     (zip (filter (\\<lambda>m. \\<not> implc_isIFS m) (map fst M))\n       (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n    filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M)", "apply(induction M)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>(x, y)\\<in>set [].\n       SecurityInvariant_complies_formal_def x y \\<Longrightarrow>\n    map snd\n     (zip (filter (\\<lambda>m. \\<not> implc_isIFS m) (map fst []))\n       (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd []))) =\n    filter (\\<lambda>m. \\<not> c_isIFS m) (map snd [])\n 2. \\<And>a M.\n       \\<lbrakk>\\<forall>(x, y)\\<in>set M.\n                   SecurityInvariant_complies_formal_def x\n                    y \\<Longrightarrow>\n                map snd\n                 (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                        (map fst M))\n                   (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n                filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M);\n        \\<forall>(x, y)\\<in>set (a # M).\n           SecurityInvariant_complies_formal_def x y\\<rbrakk>\n       \\<Longrightarrow> map snd\n                          (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                 (map fst (a # M)))\n                            (filter (\\<lambda>m. \\<not> c_isIFS m)\n                              (map snd (a # M)))) =\n                         filter (\\<lambda>m. \\<not> c_isIFS m)\n                          (map snd (a # M))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<forall>(x, y)\\<in>set M.\n                   SecurityInvariant_complies_formal_def x\n                    y \\<Longrightarrow>\n                map snd\n                 (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                        (map fst M))\n                   (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n                filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M);\n        \\<forall>(x, y)\\<in>set (a # M).\n           SecurityInvariant_complies_formal_def x y\\<rbrakk>\n       \\<Longrightarrow> map snd\n                          (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                 (map fst (a # M)))\n                            (filter (\\<lambda>m. \\<not> c_isIFS m)\n                              (map snd (a # M)))) =\n                         filter (\\<lambda>m. \\<not> c_isIFS m)\n                          (map snd (a # M))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>map snd\n                 (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                        (map fst M))\n                   (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n                filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M);\n        (case a of\n         (x, xa) \\<Rightarrow>\n           SecurityInvariant_complies_formal_def x xa) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (x, xa) \\<Rightarrow>\n              SecurityInvariant_complies_formal_def x xa)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> implc_isIFS (fst a) \\<longrightarrow>\n                          c_isIFS (snd a) \\<longrightarrow>\n                          map snd\n                           (zip (fst a #\n                                 filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                  (map fst M))\n                             (filter (\\<lambda>m. \\<not> c_isIFS m)\n                               (map snd M))) =\n                          filter (\\<lambda>m. \\<not> c_isIFS m)\n                           (map snd M)) \\<and>\n                         (implc_isIFS (fst a) \\<longrightarrow>\n                          \\<not> c_isIFS (snd a) \\<longrightarrow>\n                          map snd\n                           (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                  (map fst M))\n                             (snd a #\n                              filter (\\<lambda>m. \\<not> c_isIFS m)\n                               (map snd M))) =\n                          snd a #\n                          filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a M.\n       \\<lbrakk>map snd\n                 (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                        (map fst M))\n                   (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n                filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M);\n        (case a of\n         (x, xa) \\<Rightarrow>\n           SecurityInvariant_complies_formal_def x xa) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (x, xa) \\<Rightarrow>\n              SecurityInvariant_complies_formal_def x xa)\\<rbrakk>\n       \\<Longrightarrow> \\<not> implc_isIFS (fst a) \\<longrightarrow>\n                         c_isIFS (snd a) \\<longrightarrow>\n                         map snd\n                          (zip (fst a #\n                                filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                 (map fst M))\n                            (filter (\\<lambda>m. \\<not> c_isIFS m)\n                              (map snd M))) =\n                         filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M)\n 2. \\<And>a M.\n       \\<lbrakk>map snd\n                 (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                        (map fst M))\n                   (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n                filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M);\n        (case a of\n         (x, xa) \\<Rightarrow>\n           SecurityInvariant_complies_formal_def x xa) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (x, xa) \\<Rightarrow>\n              SecurityInvariant_complies_formal_def x xa)\\<rbrakk>\n       \\<Longrightarrow> implc_isIFS (fst a) \\<longrightarrow>\n                         \\<not> c_isIFS (snd a) \\<longrightarrow>\n                         map snd\n                          (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                 (map fst M))\n                            (snd a #\n                             filter (\\<lambda>m. \\<not> c_isIFS m)\n                              (map snd M))) =\n                         snd a #\n                         filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M)", "apply(clarify)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b M.\n       \\<lbrakk>map snd\n                 (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                        (map fst M))\n                   (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n                filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M);\n        SecurityInvariant_complies_formal_def a b;\n        \\<forall>(x, y)\\<in>set M.\n           SecurityInvariant_complies_formal_def x y;\n        \\<not> implc_isIFS (fst (a, b)); c_isIFS (snd (a, b))\\<rbrakk>\n       \\<Longrightarrow> map snd\n                          (zip (fst (a, b) #\n                                filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                 (map fst M))\n                            (filter (\\<lambda>m. \\<not> c_isIFS m)\n                              (map snd M))) =\n                         filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M)\n 2. \\<And>a M.\n       \\<lbrakk>map snd\n                 (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                        (map fst M))\n                   (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n                filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M);\n        (case a of\n         (x, xa) \\<Rightarrow>\n           SecurityInvariant_complies_formal_def x xa) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (x, xa) \\<Rightarrow>\n              SecurityInvariant_complies_formal_def x xa)\\<rbrakk>\n       \\<Longrightarrow> implc_isIFS (fst a) \\<longrightarrow>\n                         \\<not> c_isIFS (snd a) \\<longrightarrow>\n                         map snd\n                          (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                 (map fst M))\n                            (snd a #\n                             filter (\\<lambda>m. \\<not> c_isIFS m)\n                              (map snd M))) =\n                         snd a #\n                         filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M)", "using SecurityInvariant_complies_formal_def_def"], ["proof (prove)\nusing this:\n  SecurityInvariant_complies_formal_def ?impl ?spec \\<equiv>\n  (\\<forall>G.\n      wf_list_graph G \\<longrightarrow>\n      implc_sinvar ?impl G = c_sinvar ?spec (list_graph_to_graph G)) \\<and>\n  (\\<forall>G.\n      wf_list_graph G \\<longrightarrow>\n      set ` set (implc_offending_flows ?impl G) =\n      c_offending_flows ?spec (list_graph_to_graph G)) \\<and>\n  implc_isIFS ?impl = c_isIFS ?spec\n\ngoal (2 subgoals):\n 1. \\<And>a b M.\n       \\<lbrakk>map snd\n                 (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                        (map fst M))\n                   (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n                filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M);\n        SecurityInvariant_complies_formal_def a b;\n        \\<forall>(x, y)\\<in>set M.\n           SecurityInvariant_complies_formal_def x y;\n        \\<not> implc_isIFS (fst (a, b)); c_isIFS (snd (a, b))\\<rbrakk>\n       \\<Longrightarrow> map snd\n                          (zip (fst (a, b) #\n                                filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                 (map fst M))\n                            (filter (\\<lambda>m. \\<not> c_isIFS m)\n                              (map snd M))) =\n                         filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M)\n 2. \\<And>a M.\n       \\<lbrakk>map snd\n                 (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                        (map fst M))\n                   (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n                filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M);\n        (case a of\n         (x, xa) \\<Rightarrow>\n           SecurityInvariant_complies_formal_def x xa) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (x, xa) \\<Rightarrow>\n              SecurityInvariant_complies_formal_def x xa)\\<rbrakk>\n       \\<Longrightarrow> implc_isIFS (fst a) \\<longrightarrow>\n                         \\<not> c_isIFS (snd a) \\<longrightarrow>\n                         map snd\n                          (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                 (map fst M))\n                            (snd a #\n                             filter (\\<lambda>m. \\<not> c_isIFS m)\n                              (map snd M))) =\n                         snd a #\n                         filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M)", "apply (auto)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>map snd\n                 (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                        (map fst M))\n                   (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n                filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M);\n        (case a of\n         (x, xa) \\<Rightarrow>\n           SecurityInvariant_complies_formal_def x xa) \\<and>\n        (\\<forall>x\\<in>set M.\n            case x of\n            (x, xa) \\<Rightarrow>\n              SecurityInvariant_complies_formal_def x xa)\\<rbrakk>\n       \\<Longrightarrow> implc_isIFS (fst a) \\<longrightarrow>\n                         \\<not> c_isIFS (snd a) \\<longrightarrow>\n                         map snd\n                          (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                 (map fst M))\n                            (snd a #\n                             filter (\\<lambda>m. \\<not> c_isIFS m)\n                              (map snd M))) =\n                         snd a #\n                         filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M)", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b M.\n       \\<lbrakk>map snd\n                 (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                        (map fst M))\n                   (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n                filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M);\n        SecurityInvariant_complies_formal_def a b;\n        \\<forall>(x, y)\\<in>set M.\n           SecurityInvariant_complies_formal_def x y;\n        implc_isIFS (fst (a, b)); \\<not> c_isIFS (snd (a, b))\\<rbrakk>\n       \\<Longrightarrow> map snd\n                          (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                 (map fst M))\n                            (snd (a, b) #\n                             filter (\\<lambda>m. \\<not> c_isIFS m)\n                              (map snd M))) =\n                         snd (a, b) #\n                         filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M)", "using SecurityInvariant_complies_formal_def_def"], ["proof (prove)\nusing this:\n  SecurityInvariant_complies_formal_def ?impl ?spec \\<equiv>\n  (\\<forall>G.\n      wf_list_graph G \\<longrightarrow>\n      implc_sinvar ?impl G = c_sinvar ?spec (list_graph_to_graph G)) \\<and>\n  (\\<forall>G.\n      wf_list_graph G \\<longrightarrow>\n      set ` set (implc_offending_flows ?impl G) =\n      c_offending_flows ?spec (list_graph_to_graph G)) \\<and>\n  implc_isIFS ?impl = c_isIFS ?spec\n\ngoal (1 subgoal):\n 1. \\<And>a b M.\n       \\<lbrakk>map snd\n                 (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                        (map fst M))\n                   (filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M))) =\n                filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M);\n        SecurityInvariant_complies_formal_def a b;\n        \\<forall>(x, y)\\<in>set M.\n           SecurityInvariant_complies_formal_def x y;\n        implc_isIFS (fst (a, b)); \\<not> c_isIFS (snd (a, b))\\<rbrakk>\n       \\<Longrightarrow> map snd\n                          (zip (filter (\\<lambda>m. \\<not> implc_isIFS m)\n                                 (map fst M))\n                            (snd (a, b) #\n                             filter (\\<lambda>m. \\<not> c_isIFS m)\n                              (map snd M))) =\n                         snd (a, b) #\n                         filter (\\<lambda>m. \\<not> c_isIFS m) (map snd M)", "apply (auto)[1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  get_spec\n   (zip (TopoS_Composition_Theory_impl.get_ACS (get_impl M))\n     (TopoS_Composition_Theory.get_ACS (get_spec M))) =\n  TopoS_Composition_Theory.get_ACS (get_spec M)\n\ngoal:\nNo subgoals!", "qed"], ["", "thm get_IFS_get_ACS_select_simps"], ["", "subsection\\<open>All security requirements fulfilled\\<close>"], ["", "definition all_security_requirements_fulfilled :: \"'v SecurityInvariant list \\<Rightarrow> 'v list_graph \\<Rightarrow> bool\" where\n      \"all_security_requirements_fulfilled M G \\<equiv> \\<forall>m \\<in> set M. (implc_sinvar m) G\""], ["", "lemma all_security_requirements_fulfilled_complies:\n    \"\\<lbrakk> \\<forall> (m_impl, m_spec) \\<in> set M. SecurityInvariant_complies_formal_def m_impl m_spec; \n       wf_list_graph (G::('v::vertex) list_graph) \\<rbrakk> \\<Longrightarrow>\n    all_security_requirements_fulfilled (get_impl M) G \\<longleftrightarrow> TopoS_Composition_Theory.all_security_requirements_fulfilled (get_spec M) (list_graph_to_graph G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(m_impl, m_spec)\\<in>set M.\n                SecurityInvariant_complies_formal_def m_impl m_spec;\n     wf_list_graph G\\<rbrakk>\n    \\<Longrightarrow> TopoS_Composition_Theory_impl.all_security_requirements_fulfilled\n                       (get_impl M) G =\n                      TopoS_Composition_Theory.all_security_requirements_fulfilled\n                       (get_spec M) (list_graph_to_graph G)", "apply(simp add: all_security_requirements_fulfilled_def TopoS_Composition_Theory.all_security_requirements_fulfilled_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set M.\n                case x of\n                (m_impl, m_spec) \\<Rightarrow>\n                  SecurityInvariant_complies_formal_def m_impl m_spec;\n     wf_list_graph G\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>m\\<in>set (get_impl M). implc_sinvar m G) =\n                      (\\<forall>m\\<in>set (get_spec M).\n                          c_sinvar m (list_graph_to_graph G))", "apply(simp add: get_impl_def get_spec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set M.\n                case x of\n                (m_impl, m_spec) \\<Rightarrow>\n                  SecurityInvariant_complies_formal_def m_impl m_spec;\n     wf_list_graph G\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>m\\<in>set M. implc_sinvar (fst m) G) =\n                      (\\<forall>m\\<in>set M.\n                          c_sinvar (snd m) (list_graph_to_graph G))", "using SecurityInvariant_complies_formal_def_def"], ["proof (prove)\nusing this:\n  SecurityInvariant_complies_formal_def ?impl ?spec \\<equiv>\n  (\\<forall>G.\n      wf_list_graph G \\<longrightarrow>\n      implc_sinvar ?impl G = c_sinvar ?spec (list_graph_to_graph G)) \\<and>\n  (\\<forall>G.\n      wf_list_graph G \\<longrightarrow>\n      set ` set (implc_offending_flows ?impl G) =\n      c_offending_flows ?spec (list_graph_to_graph G)) \\<and>\n  implc_isIFS ?impl = c_isIFS ?spec\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set M.\n                case x of\n                (m_impl, m_spec) \\<Rightarrow>\n                  SecurityInvariant_complies_formal_def m_impl m_spec;\n     wf_list_graph G\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>m\\<in>set M. implc_sinvar (fst m) G) =\n                      (\\<forall>m\\<in>set M.\n                          c_sinvar (snd m) (list_graph_to_graph G))", "by fastforce"], ["", "subsection\\<open>generate valid topology\\<close>"], ["", "value \"concat [[1::int,2,3], [4,6,5]]\""], ["", "fun generate_valid_topology :: \"'v SecurityInvariant list \\<Rightarrow> 'v list_graph \\<Rightarrow> ('v list_graph)\" where\n    \"generate_valid_topology M G = delete_edges G (concat (implc_get_offending_flows M G))\""], ["", "lemma generate_valid_topology_complies:\n    \"\\<lbrakk> \\<forall> (m_impl, m_spec) \\<in> set M. SecurityInvariant_complies_formal_def m_impl m_spec;\n       wf_list_graph (G::('v list_graph)) \\<rbrakk> \\<Longrightarrow> \n       list_graph_to_graph (generate_valid_topology (get_impl M) G) = \n       TopoS_Composition_Theory.generate_valid_topology (get_spec M) (list_graph_to_graph G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(m_impl, m_spec)\\<in>set M.\n                SecurityInvariant_complies_formal_def m_impl m_spec;\n     wf_list_graph G\\<rbrakk>\n    \\<Longrightarrow> list_graph_to_graph\n                       (TopoS_Composition_Theory_impl.generate_valid_topology\n                         (get_impl M) G) =\n                      TopoS_Composition_Theory.generate_valid_topology\n                       (get_spec M) (list_graph_to_graph G)", "apply (subst generate_valid_topology_def_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(m_impl, m_spec)\\<in>set M.\n                SecurityInvariant_complies_formal_def m_impl m_spec;\n     wf_list_graph G\\<rbrakk>\n    \\<Longrightarrow> list_graph_to_graph\n                       (TopoS_Composition_Theory_impl.generate_valid_topology\n                         (get_impl M) G) =\n                      FiniteGraph.delete_edges (list_graph_to_graph G)\n                       (\\<Union>\n                         (get_offending_flows (get_spec M)\n                           (list_graph_to_graph G)))", "apply (drule(1) implc_get_offending_flows_complies)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_list_graph G;\n     set ` set (implc_get_offending_flows (get_impl M) G) =\n     get_offending_flows (get_spec M) (list_graph_to_graph G)\\<rbrakk>\n    \\<Longrightarrow> list_graph_to_graph\n                       (TopoS_Composition_Theory_impl.generate_valid_topology\n                         (get_impl M) G) =\n                      FiniteGraph.delete_edges (list_graph_to_graph G)\n                       (\\<Union>\n                         (get_offending_flows (get_spec M)\n                           (list_graph_to_graph G)))", "apply (simp add: delete_edges_correct [symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>generate valid topology\\<close>"], ["", "text\\<open>tuned for invariants where we don't want to calculate all offending flows\\<close>"], ["", "text\\<open>Theoretic foundations: The algorithm @{const generate_valid_topology_SOME} picks\n        ONE offending flow non-deterministically.\n        This is sound: @{thm generate_valid_topology_SOME_sound}.\n        However, this non-deterministic choice is hard to implement. \n        To pick one offending flow deterministically, we have implemented @{const minimalize_offending_overapprox}.\n        It gives back one offending flow:\n          @{thm SecurityInvariant_preliminaries.minimalize_offending_overapprox_gives_back_an_offending_flow}\n        The good thing about this function is, that it does not need to construct the complete\n        @{const SecurityInvariant_withOffendingFlows.set_offending_flows}. Therefore, \n        it can be used for security invariants which may have an exponential number of offending flows. \n        The corresponding algorithm that uses this function is @{const TopoS_Composition_Theory.generate_valid_topology_some}.\n        It is also sound: @{thm generate_valid_topology_some_sound}.\\<close>"], ["", "fun generate_valid_topology_some :: \"'v SecurityInvariant list \\<Rightarrow> 'v list_graph \\<Rightarrow> ('v list_graph)\" where\n    \"generate_valid_topology_some [] G = G\" |\n    \"generate_valid_topology_some (m#Ms) G = (if implc_sinvar m G\n      then generate_valid_topology_some Ms G\n      else delete_edges (generate_valid_topology_some Ms G) (minimalize_offending_overapprox (implc_sinvar m) (edgesL G) [] G)\n      )\""], ["", "thm TopoS_Composition_Theory.generate_valid_topology_some_sound"], ["", "lemma generate_valid_topology_some_complies:\n    \"\\<lbrakk> \\<forall> (m_impl, m_spec) \\<in> set M. SecurityInvariant_complies_formal_def m_impl m_spec;\n       wf_list_graph (G::('v::vertex list_graph)) \\<rbrakk> \\<Longrightarrow> \n       list_graph_to_graph (generate_valid_topology_some (get_impl M) G) = \n       TopoS_Composition_Theory.generate_valid_topology_some (get_spec M) (edgesL G) (list_graph_to_graph G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(m_impl, m_spec)\\<in>set M.\n                SecurityInvariant_complies_formal_def m_impl m_spec;\n     wf_list_graph G\\<rbrakk>\n    \\<Longrightarrow> list_graph_to_graph\n                       (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                         (get_impl M) G) =\n                      TopoS_Composition_Theory.generate_valid_topology_some\n                       (get_spec M) (edgesL G) (list_graph_to_graph G)", "proof(induction M)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>(x, y)\\<in>set [].\n                SecurityInvariant_complies_formal_def x y;\n     wf_list_graph G\\<rbrakk>\n    \\<Longrightarrow> list_graph_to_graph\n                       (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                         (get_impl []) G) =\n                      TopoS_Composition_Theory.generate_valid_topology_some\n                       (get_spec []) (edgesL G) (list_graph_to_graph G)\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>\\<forall>(x, y)\\<in>set M.\n                            SecurityInvariant_complies_formal_def x y;\n                 wf_list_graph G\\<rbrakk>\n                \\<Longrightarrow> list_graph_to_graph\n                                   (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                                     (get_impl M) G) =\n                                  TopoS_Composition_Theory.generate_valid_topology_some\n                                   (get_spec M) (edgesL G)\n                                   (list_graph_to_graph G);\n        \\<forall>(x, y)\\<in>set (a # M).\n           SecurityInvariant_complies_formal_def x y;\n        wf_list_graph G\\<rbrakk>\n       \\<Longrightarrow> list_graph_to_graph\n                          (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                            (get_impl (a # M)) G) =\n                         TopoS_Composition_Theory.generate_valid_topology_some\n                          (get_spec (a # M)) (edgesL G)\n                          (list_graph_to_graph G)", "case Nil"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set [].\n     case a of\n     (a, b) \\<Rightarrow> SecurityInvariant_complies_formal_def a b\n  wf_list_graph G\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>(x, y)\\<in>set [].\n                SecurityInvariant_complies_formal_def x y;\n     wf_list_graph G\\<rbrakk>\n    \\<Longrightarrow> list_graph_to_graph\n                       (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                         (get_impl []) G) =\n                      TopoS_Composition_Theory.generate_valid_topology_some\n                       (get_spec []) (edgesL G) (list_graph_to_graph G)\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>\\<forall>(x, y)\\<in>set M.\n                            SecurityInvariant_complies_formal_def x y;\n                 wf_list_graph G\\<rbrakk>\n                \\<Longrightarrow> list_graph_to_graph\n                                   (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                                     (get_impl M) G) =\n                                  TopoS_Composition_Theory.generate_valid_topology_some\n                                   (get_spec M) (edgesL G)\n                                   (list_graph_to_graph G);\n        \\<forall>(x, y)\\<in>set (a # M).\n           SecurityInvariant_complies_formal_def x y;\n        wf_list_graph G\\<rbrakk>\n       \\<Longrightarrow> list_graph_to_graph\n                          (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                            (get_impl (a # M)) G) =\n                         TopoS_Composition_Theory.generate_valid_topology_some\n                          (get_spec (a # M)) (edgesL G)\n                          (list_graph_to_graph G)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set [].\n     case a of\n     (a, b) \\<Rightarrow> SecurityInvariant_complies_formal_def a b\n  wf_list_graph G\n\ngoal (1 subgoal):\n 1. list_graph_to_graph\n     (TopoS_Composition_Theory_impl.generate_valid_topology_some\n       (get_impl []) G) =\n    TopoS_Composition_Theory.generate_valid_topology_some (get_spec [])\n     (edgesL G) (list_graph_to_graph G)", "by(simp add: get_spec_def get_impl_def)"], ["proof (state)\nthis:\n  list_graph_to_graph\n   (TopoS_Composition_Theory_impl.generate_valid_topology_some (get_impl [])\n     G) =\n  TopoS_Composition_Theory.generate_valid_topology_some (get_spec [])\n   (edgesL G) (list_graph_to_graph G)\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>\\<forall>(x, y)\\<in>set M.\n                            SecurityInvariant_complies_formal_def x y;\n                 wf_list_graph G\\<rbrakk>\n                \\<Longrightarrow> list_graph_to_graph\n                                   (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                                     (get_impl M) G) =\n                                  TopoS_Composition_Theory.generate_valid_topology_some\n                                   (get_spec M) (edgesL G)\n                                   (list_graph_to_graph G);\n        \\<forall>(x, y)\\<in>set (a # M).\n           SecurityInvariant_complies_formal_def x y;\n        wf_list_graph G\\<rbrakk>\n       \\<Longrightarrow> list_graph_to_graph\n                          (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                            (get_impl (a # M)) G) =\n                         TopoS_Composition_Theory.generate_valid_topology_some\n                          (get_spec (a # M)) (edgesL G)\n                          (list_graph_to_graph G)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>\\<forall>(x, y)\\<in>set M.\n                            SecurityInvariant_complies_formal_def x y;\n                 wf_list_graph G\\<rbrakk>\n                \\<Longrightarrow> list_graph_to_graph\n                                   (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                                     (get_impl M) G) =\n                                  TopoS_Composition_Theory.generate_valid_topology_some\n                                   (get_spec M) (edgesL G)\n                                   (list_graph_to_graph G);\n        \\<forall>(x, y)\\<in>set (a # M).\n           SecurityInvariant_complies_formal_def x y;\n        wf_list_graph G\\<rbrakk>\n       \\<Longrightarrow> list_graph_to_graph\n                          (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                            (get_impl (a # M)) G) =\n                         TopoS_Composition_Theory.generate_valid_topology_some\n                          (get_spec (a # M)) (edgesL G)\n                          (list_graph_to_graph G)", "case (Cons m M)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a\\<in>set M.\n              case a of\n              (a, b) \\<Rightarrow>\n                SecurityInvariant_complies_formal_def a b;\n   wf_list_graph G\\<rbrakk>\n  \\<Longrightarrow> list_graph_to_graph\n                     (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                       (get_impl M) G) =\n                    TopoS_Composition_Theory.generate_valid_topology_some\n                     (get_spec M) (edgesL G) (list_graph_to_graph G)\n  \\<forall>a\\<in>set (m # M).\n     case a of\n     (a, b) \\<Rightarrow> SecurityInvariant_complies_formal_def a b\n  wf_list_graph G\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>\\<forall>(x, y)\\<in>set M.\n                            SecurityInvariant_complies_formal_def x y;\n                 wf_list_graph G\\<rbrakk>\n                \\<Longrightarrow> list_graph_to_graph\n                                   (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                                     (get_impl M) G) =\n                                  TopoS_Composition_Theory.generate_valid_topology_some\n                                   (get_spec M) (edgesL G)\n                                   (list_graph_to_graph G);\n        \\<forall>(x, y)\\<in>set (a # M).\n           SecurityInvariant_complies_formal_def x y;\n        wf_list_graph G\\<rbrakk>\n       \\<Longrightarrow> list_graph_to_graph\n                          (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                            (get_impl (a # M)) G) =\n                         TopoS_Composition_Theory.generate_valid_topology_some\n                          (get_spec (a # M)) (edgesL G)\n                          (list_graph_to_graph G)", "obtain m_impl m_spec where m: \"m = (m_impl, m_spec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m_impl m_spec.\n        m = (m_impl, m_spec) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases m) blast"], ["proof (state)\nthis:\n  m = (m_impl, m_spec)\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>\\<forall>(x, y)\\<in>set M.\n                            SecurityInvariant_complies_formal_def x y;\n                 wf_list_graph G\\<rbrakk>\n                \\<Longrightarrow> list_graph_to_graph\n                                   (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                                     (get_impl M) G) =\n                                  TopoS_Composition_Theory.generate_valid_topology_some\n                                   (get_spec M) (edgesL G)\n                                   (list_graph_to_graph G);\n        \\<forall>(x, y)\\<in>set (a # M).\n           SecurityInvariant_complies_formal_def x y;\n        wf_list_graph G\\<rbrakk>\n       \\<Longrightarrow> list_graph_to_graph\n                          (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                            (get_impl (a # M)) G) =\n                         TopoS_Composition_Theory.generate_valid_topology_some\n                          (get_spec (a # M)) (edgesL G)\n                          (list_graph_to_graph G)", "from m"], ["proof (chain)\npicking this:\n  m = (m_impl, m_spec)", "have m_impl: \"get_impl ((m_impl, m_spec) # M) = m_impl # (get_impl M)\""], ["proof (prove)\nusing this:\n  m = (m_impl, m_spec)\n\ngoal (1 subgoal):\n 1. get_impl ((m_impl, m_spec) # M) = m_impl # get_impl M", "by (simp add: get_impl_def)"], ["proof (state)\nthis:\n  get_impl ((m_impl, m_spec) # M) = m_impl # get_impl M\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>\\<forall>(x, y)\\<in>set M.\n                            SecurityInvariant_complies_formal_def x y;\n                 wf_list_graph G\\<rbrakk>\n                \\<Longrightarrow> list_graph_to_graph\n                                   (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                                     (get_impl M) G) =\n                                  TopoS_Composition_Theory.generate_valid_topology_some\n                                   (get_spec M) (edgesL G)\n                                   (list_graph_to_graph G);\n        \\<forall>(x, y)\\<in>set (a # M).\n           SecurityInvariant_complies_formal_def x y;\n        wf_list_graph G\\<rbrakk>\n       \\<Longrightarrow> list_graph_to_graph\n                          (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                            (get_impl (a # M)) G) =\n                         TopoS_Composition_Theory.generate_valid_topology_some\n                          (get_spec (a # M)) (edgesL G)\n                          (list_graph_to_graph G)", "from m"], ["proof (chain)\npicking this:\n  m = (m_impl, m_spec)", "have m_spec: \"get_spec ((m_impl, m_spec) # M) = m_spec # (get_spec M)\""], ["proof (prove)\nusing this:\n  m = (m_impl, m_spec)\n\ngoal (1 subgoal):\n 1. get_spec ((m_impl, m_spec) # M) = m_spec # get_spec M", "by (simp add: get_spec_def)"], ["proof (state)\nthis:\n  get_spec ((m_impl, m_spec) # M) = m_spec # get_spec M\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>\\<forall>(x, y)\\<in>set M.\n                            SecurityInvariant_complies_formal_def x y;\n                 wf_list_graph G\\<rbrakk>\n                \\<Longrightarrow> list_graph_to_graph\n                                   (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                                     (get_impl M) G) =\n                                  TopoS_Composition_Theory.generate_valid_topology_some\n                                   (get_spec M) (edgesL G)\n                                   (list_graph_to_graph G);\n        \\<forall>(x, y)\\<in>set (a # M).\n           SecurityInvariant_complies_formal_def x y;\n        wf_list_graph G\\<rbrakk>\n       \\<Longrightarrow> list_graph_to_graph\n                          (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                            (get_impl (a # M)) G) =\n                         TopoS_Composition_Theory.generate_valid_topology_some\n                          (get_spec (a # M)) (edgesL G)\n                          (list_graph_to_graph G)", "from Cons.prems(1) m"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (m # M).\n     case a of\n     (a, b) \\<Rightarrow> SecurityInvariant_complies_formal_def a b\n  m = (m_impl, m_spec)", "have complies_formal_def: \"SecurityInvariant_complies_formal_def m_impl m_spec\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (m # M).\n     case a of\n     (a, b) \\<Rightarrow> SecurityInvariant_complies_formal_def a b\n  m = (m_impl, m_spec)\n\ngoal (1 subgoal):\n 1. SecurityInvariant_complies_formal_def m_impl m_spec", "by simp"], ["proof (state)\nthis:\n  SecurityInvariant_complies_formal_def m_impl m_spec\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>\\<forall>(x, y)\\<in>set M.\n                            SecurityInvariant_complies_formal_def x y;\n                 wf_list_graph G\\<rbrakk>\n                \\<Longrightarrow> list_graph_to_graph\n                                   (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                                     (get_impl M) G) =\n                                  TopoS_Composition_Theory.generate_valid_topology_some\n                                   (get_spec M) (edgesL G)\n                                   (list_graph_to_graph G);\n        \\<forall>(x, y)\\<in>set (a # M).\n           SecurityInvariant_complies_formal_def x y;\n        wf_list_graph G\\<rbrakk>\n       \\<Longrightarrow> list_graph_to_graph\n                          (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                            (get_impl (a # M)) G) =\n                         TopoS_Composition_Theory.generate_valid_topology_some\n                          (get_spec (a # M)) (edgesL G)\n                          (list_graph_to_graph G)", "with Cons.prems(2)"], ["proof (chain)\npicking this:\n  wf_list_graph G\n  SecurityInvariant_complies_formal_def m_impl m_spec", "have impl_spec: \"implc_sinvar m_impl G \\<longleftrightarrow> c_sinvar m_spec (list_graph_to_graph G)\""], ["proof (prove)\nusing this:\n  wf_list_graph G\n  SecurityInvariant_complies_formal_def m_impl m_spec\n\ngoal (1 subgoal):\n 1. implc_sinvar m_impl G = c_sinvar m_spec (list_graph_to_graph G)", "by (simp add: SecurityInvariant_complies_formal_def_def)"], ["proof (state)\nthis:\n  implc_sinvar m_impl G = c_sinvar m_spec (list_graph_to_graph G)\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>\\<forall>(x, y)\\<in>set M.\n                            SecurityInvariant_complies_formal_def x y;\n                 wf_list_graph G\\<rbrakk>\n                \\<Longrightarrow> list_graph_to_graph\n                                   (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                                     (get_impl M) G) =\n                                  TopoS_Composition_Theory.generate_valid_topology_some\n                                   (get_spec M) (edgesL G)\n                                   (list_graph_to_graph G);\n        \\<forall>(x, y)\\<in>set (a # M).\n           SecurityInvariant_complies_formal_def x y;\n        wf_list_graph G\\<rbrakk>\n       \\<Longrightarrow> list_graph_to_graph\n                          (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                            (get_impl (a # M)) G) =\n                         TopoS_Composition_Theory.generate_valid_topology_some\n                          (get_spec (a # M)) (edgesL G)\n                          (list_graph_to_graph G)", "from complies_formal_def"], ["proof (chain)\npicking this:\n  SecurityInvariant_complies_formal_def m_impl m_spec", "have \"\\<And>G nP. wf_list_graph G \\<Longrightarrow>\n        (\\<lambda>G nP. (c_sinvar m_spec) G) (list_graph_to_graph G) nP = (\\<lambda>G nP. (implc_sinvar m_impl) G) G nP\""], ["proof (prove)\nusing this:\n  SecurityInvariant_complies_formal_def m_impl m_spec\n\ngoal (1 subgoal):\n 1. \\<And>G nP.\n       wf_list_graph G \\<Longrightarrow>\n       c_sinvar m_spec (list_graph_to_graph G) = implc_sinvar m_impl G", "by (simp add: SecurityInvariant_complies_formal_def_def)"], ["proof (state)\nthis:\n  wf_list_graph ?G \\<Longrightarrow>\n  c_sinvar m_spec (list_graph_to_graph ?G) = implc_sinvar m_impl ?G\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>\\<forall>(x, y)\\<in>set M.\n                            SecurityInvariant_complies_formal_def x y;\n                 wf_list_graph G\\<rbrakk>\n                \\<Longrightarrow> list_graph_to_graph\n                                   (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                                     (get_impl M) G) =\n                                  TopoS_Composition_Theory.generate_valid_topology_some\n                                   (get_spec M) (edgesL G)\n                                   (list_graph_to_graph G);\n        \\<forall>(x, y)\\<in>set (a # M).\n           SecurityInvariant_complies_formal_def x y;\n        wf_list_graph G\\<rbrakk>\n       \\<Longrightarrow> list_graph_to_graph\n                          (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                            (get_impl (a # M)) G) =\n                         TopoS_Composition_Theory.generate_valid_topology_some\n                          (get_spec (a # M)) (edgesL G)\n                          (list_graph_to_graph G)", "from minimalize_offending_overapprox_spec_impl[OF Cons.prems(2),\n          of \"(\\<lambda>G nP. (c_sinvar m_spec) G)\" \"(\\<lambda>G nP. (implc_sinvar m_impl) G)\", OF this]"], ["proof (chain)\npicking this:\n  (\\<And>G nP.\n      wf_list_graph G \\<Longrightarrow> wf_list_graph G) \\<Longrightarrow>\n  TopoS_Interface_impl.minimalize_offending_overapprox (implc_sinvar m_impl)\n   ?fs ?keeps G =\n  TopoS_withOffendingFlows.minimalize_offending_overapprox (c_sinvar m_spec)\n   ?fs ?keeps (list_graph_to_graph G)", "(*TODO: because of funny type, horribly complex instantiation*)"], ["proof (chain)\npicking this:\n  (\\<And>G nP.\n      wf_list_graph G \\<Longrightarrow> wf_list_graph G) \\<Longrightarrow>\n  TopoS_Interface_impl.minimalize_offending_overapprox (implc_sinvar m_impl)\n   ?fs ?keeps G =\n  TopoS_withOffendingFlows.minimalize_offending_overapprox (c_sinvar m_spec)\n   ?fs ?keeps (list_graph_to_graph G)", "have \"TopoS_Interface_impl.minimalize_offending_overapprox (implc_sinvar m_impl) fs keeps G =\n            TopoS_withOffendingFlows.minimalize_offending_overapprox (c_sinvar m_spec) fs keeps (list_graph_to_graph G)\"\n        for fs keeps"], ["proof (prove)\nusing this:\n  (\\<And>G nP.\n      wf_list_graph G \\<Longrightarrow> wf_list_graph G) \\<Longrightarrow>\n  TopoS_Interface_impl.minimalize_offending_overapprox (implc_sinvar m_impl)\n   ?fs ?keeps G =\n  TopoS_withOffendingFlows.minimalize_offending_overapprox (c_sinvar m_spec)\n   ?fs ?keeps (list_graph_to_graph G)\n\ngoal (1 subgoal):\n 1. TopoS_Interface_impl.minimalize_offending_overapprox\n     (implc_sinvar m_impl) fs keeps G =\n    TopoS_withOffendingFlows.minimalize_offending_overapprox\n     (c_sinvar m_spec) fs keeps (list_graph_to_graph G)", "by simp"], ["proof (state)\nthis:\n  TopoS_Interface_impl.minimalize_offending_overapprox (implc_sinvar m_impl)\n   ?fs1 ?keeps1 G =\n  TopoS_withOffendingFlows.minimalize_offending_overapprox (c_sinvar m_spec)\n   ?fs1 ?keeps1 (list_graph_to_graph G)\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>\\<forall>(x, y)\\<in>set M.\n                            SecurityInvariant_complies_formal_def x y;\n                 wf_list_graph G\\<rbrakk>\n                \\<Longrightarrow> list_graph_to_graph\n                                   (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                                     (get_impl M) G) =\n                                  TopoS_Composition_Theory.generate_valid_topology_some\n                                   (get_spec M) (edgesL G)\n                                   (list_graph_to_graph G);\n        \\<forall>(x, y)\\<in>set (a # M).\n           SecurityInvariant_complies_formal_def x y;\n        wf_list_graph G\\<rbrakk>\n       \\<Longrightarrow> list_graph_to_graph\n                          (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                            (get_impl (a # M)) G) =\n                         TopoS_Composition_Theory.generate_valid_topology_some\n                          (get_spec (a # M)) (edgesL G)\n                          (list_graph_to_graph G)", "from this[of \"(edgesL G)\"  \"[]\"]"], ["proof (chain)\npicking this:\n  TopoS_Interface_impl.minimalize_offending_overapprox (implc_sinvar m_impl)\n   (edgesL G) [] G =\n  TopoS_withOffendingFlows.minimalize_offending_overapprox (c_sinvar m_spec)\n   (edgesL G) [] (list_graph_to_graph G)", "have minimalize_offending_overapprox_spec:\n         \"TopoS_Interface_impl.minimalize_offending_overapprox (implc_sinvar m_impl) (edgesL G) [] G =\n          TopoS_withOffendingFlows.minimalize_offending_overapprox (c_sinvar m_spec) (edgesL G) [] (list_graph_to_graph G)\""], ["proof (prove)\nusing this:\n  TopoS_Interface_impl.minimalize_offending_overapprox (implc_sinvar m_impl)\n   (edgesL G) [] G =\n  TopoS_withOffendingFlows.minimalize_offending_overapprox (c_sinvar m_spec)\n   (edgesL G) [] (list_graph_to_graph G)\n\ngoal (1 subgoal):\n 1. TopoS_Interface_impl.minimalize_offending_overapprox\n     (implc_sinvar m_impl) (edgesL G) [] G =\n    TopoS_withOffendingFlows.minimalize_offending_overapprox\n     (c_sinvar m_spec) (edgesL G) [] (list_graph_to_graph G)", "."], ["proof (state)\nthis:\n  TopoS_Interface_impl.minimalize_offending_overapprox (implc_sinvar m_impl)\n   (edgesL G) [] G =\n  TopoS_withOffendingFlows.minimalize_offending_overapprox (c_sinvar m_spec)\n   (edgesL G) [] (list_graph_to_graph G)\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>\\<forall>(x, y)\\<in>set M.\n                            SecurityInvariant_complies_formal_def x y;\n                 wf_list_graph G\\<rbrakk>\n                \\<Longrightarrow> list_graph_to_graph\n                                   (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                                     (get_impl M) G) =\n                                  TopoS_Composition_Theory.generate_valid_topology_some\n                                   (get_spec M) (edgesL G)\n                                   (list_graph_to_graph G);\n        \\<forall>(x, y)\\<in>set (a # M).\n           SecurityInvariant_complies_formal_def x y;\n        wf_list_graph G\\<rbrakk>\n       \\<Longrightarrow> list_graph_to_graph\n                          (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                            (get_impl (a # M)) G) =\n                         TopoS_Composition_Theory.generate_valid_topology_some\n                          (get_spec (a # M)) (edgesL G)\n                          (list_graph_to_graph G)", "from Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>a\\<in>set M.\n              case a of\n              (a, b) \\<Rightarrow>\n                SecurityInvariant_complies_formal_def a b;\n   wf_list_graph G\\<rbrakk>\n  \\<Longrightarrow> list_graph_to_graph\n                     (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                       (get_impl M) G) =\n                    TopoS_Composition_Theory.generate_valid_topology_some\n                     (get_spec M) (edgesL G) (list_graph_to_graph G)\n  \\<forall>a\\<in>set (m # M).\n     case a of\n     (a, b) \\<Rightarrow> SecurityInvariant_complies_formal_def a b\n  wf_list_graph G", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>a\\<in>set M.\n              case a of\n              (a, b) \\<Rightarrow>\n                SecurityInvariant_complies_formal_def a b;\n   wf_list_graph G\\<rbrakk>\n  \\<Longrightarrow> list_graph_to_graph\n                     (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                       (get_impl M) G) =\n                    TopoS_Composition_Theory.generate_valid_topology_some\n                     (get_spec M) (edgesL G) (list_graph_to_graph G)\n  \\<forall>a\\<in>set (m # M).\n     case a of\n     (a, b) \\<Rightarrow> SecurityInvariant_complies_formal_def a b\n  wf_list_graph G\n\ngoal (1 subgoal):\n 1. list_graph_to_graph\n     (TopoS_Composition_Theory_impl.generate_valid_topology_some\n       (get_impl (m # M)) G) =\n    TopoS_Composition_Theory.generate_valid_topology_some (get_spec (m # M))\n     (edgesL G) (list_graph_to_graph G)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_graph_to_graph\n              (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                (get_impl M) G) =\n             TopoS_Composition_Theory.generate_valid_topology_some\n              (get_spec M) (edgesL G) (list_graph_to_graph G);\n     (case m of\n      (x, xa) \\<Rightarrow>\n        SecurityInvariant_complies_formal_def x xa) \\<and>\n     (\\<forall>x\\<in>set M.\n         case x of\n         (x, xa) \\<Rightarrow> SecurityInvariant_complies_formal_def x xa);\n     wf_list_graph G\\<rbrakk>\n    \\<Longrightarrow> list_graph_to_graph\n                       (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                         (get_impl (m # M)) G) =\n                      TopoS_Composition_Theory.generate_valid_topology_some\n                       (get_spec (m # M)) (edgesL G) (list_graph_to_graph G)", "apply(simp add: m m_impl m_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_graph_to_graph\n              (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                (get_impl M) G) =\n             TopoS_Composition_Theory.generate_valid_topology_some\n              (get_spec M) (edgesL G) (list_graph_to_graph G);\n     SecurityInvariant_complies_formal_def m_impl m_spec \\<and>\n     (\\<forall>x\\<in>set M.\n         case x of\n         (x, xa) \\<Rightarrow> SecurityInvariant_complies_formal_def x xa);\n     wf_list_graph G\\<rbrakk>\n    \\<Longrightarrow> (implc_sinvar m_impl G \\<longrightarrow>\n                       \\<not> c_sinvar m_spec\n                               (list_graph_to_graph G) \\<longrightarrow>\n                       TopoS_Composition_Theory.generate_valid_topology_some\n                        (get_spec M) (edgesL G) (list_graph_to_graph G) =\n                       FiniteGraph.delete_edges\n                        (TopoS_Composition_Theory.generate_valid_topology_some\n                          (get_spec M) (edgesL G) (list_graph_to_graph G))\n                        (set (TopoS_withOffendingFlows.minimalize_offending_overapprox\n                               (c_sinvar m_spec) (edgesL G) []\n                               (list_graph_to_graph G)))) \\<and>\n                      (\\<not> implc_sinvar m_impl G \\<longrightarrow>\n                       (c_sinvar m_spec\n                         (list_graph_to_graph G) \\<longrightarrow>\n                        list_graph_to_graph\n                         (FiniteListGraph.delete_edges\n                           (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                             (get_impl M) G)\n                           (TopoS_Interface_impl.minimalize_offending_overapprox\n                             (implc_sinvar m_impl) (edgesL G) [] G)) =\n                        TopoS_Composition_Theory.generate_valid_topology_some\n                         (get_spec M) (edgesL G)\n                         (list_graph_to_graph G)) \\<and>\n                       (\\<not> c_sinvar m_spec\n                                (list_graph_to_graph G) \\<longrightarrow>\n                        list_graph_to_graph\n                         (FiniteListGraph.delete_edges\n                           (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                             (get_impl M) G)\n                           (TopoS_Interface_impl.minimalize_offending_overapprox\n                             (implc_sinvar m_impl) (edgesL G) [] G)) =\n                        FiniteGraph.delete_edges\n                         (TopoS_Composition_Theory.generate_valid_topology_some\n                           (get_spec M) (edgesL G) (list_graph_to_graph G))\n                         (set (TopoS_withOffendingFlows.minimalize_offending_overapprox\n                                (c_sinvar m_spec) (edgesL G) []\n                                (list_graph_to_graph G)))))", "apply(intro conjI impI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>list_graph_to_graph\n              (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                (get_impl M) G) =\n             TopoS_Composition_Theory.generate_valid_topology_some\n              (get_spec M) (edgesL G) (list_graph_to_graph G);\n     SecurityInvariant_complies_formal_def m_impl m_spec \\<and>\n     (\\<forall>x\\<in>set M.\n         case x of\n         (x, xa) \\<Rightarrow> SecurityInvariant_complies_formal_def x xa);\n     wf_list_graph G; implc_sinvar m_impl G;\n     \\<not> c_sinvar m_spec (list_graph_to_graph G)\\<rbrakk>\n    \\<Longrightarrow> TopoS_Composition_Theory.generate_valid_topology_some\n                       (get_spec M) (edgesL G) (list_graph_to_graph G) =\n                      FiniteGraph.delete_edges\n                       (TopoS_Composition_Theory.generate_valid_topology_some\n                         (get_spec M) (edgesL G) (list_graph_to_graph G))\n                       (set (TopoS_withOffendingFlows.minimalize_offending_overapprox\n                              (c_sinvar m_spec) (edgesL G) []\n                              (list_graph_to_graph G)))\n 2. \\<lbrakk>list_graph_to_graph\n              (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                (get_impl M) G) =\n             TopoS_Composition_Theory.generate_valid_topology_some\n              (get_spec M) (edgesL G) (list_graph_to_graph G);\n     SecurityInvariant_complies_formal_def m_impl m_spec \\<and>\n     (\\<forall>x\\<in>set M.\n         case x of\n         (x, xa) \\<Rightarrow> SecurityInvariant_complies_formal_def x xa);\n     wf_list_graph G; \\<not> implc_sinvar m_impl G;\n     c_sinvar m_spec (list_graph_to_graph G)\\<rbrakk>\n    \\<Longrightarrow> list_graph_to_graph\n                       (FiniteListGraph.delete_edges\n                         (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                           (get_impl M) G)\n                         (TopoS_Interface_impl.minimalize_offending_overapprox\n                           (implc_sinvar m_impl) (edgesL G) [] G)) =\n                      TopoS_Composition_Theory.generate_valid_topology_some\n                       (get_spec M) (edgesL G) (list_graph_to_graph G)\n 3. \\<lbrakk>list_graph_to_graph\n              (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                (get_impl M) G) =\n             TopoS_Composition_Theory.generate_valid_topology_some\n              (get_spec M) (edgesL G) (list_graph_to_graph G);\n     SecurityInvariant_complies_formal_def m_impl m_spec \\<and>\n     (\\<forall>x\\<in>set M.\n         case x of\n         (x, xa) \\<Rightarrow> SecurityInvariant_complies_formal_def x xa);\n     wf_list_graph G; \\<not> implc_sinvar m_impl G;\n     \\<not> c_sinvar m_spec (list_graph_to_graph G)\\<rbrakk>\n    \\<Longrightarrow> list_graph_to_graph\n                       (FiniteListGraph.delete_edges\n                         (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                           (get_impl M) G)\n                         (TopoS_Interface_impl.minimalize_offending_overapprox\n                           (implc_sinvar m_impl) (edgesL G) [] G)) =\n                      FiniteGraph.delete_edges\n                       (TopoS_Composition_Theory.generate_valid_topology_some\n                         (get_spec M) (edgesL G) (list_graph_to_graph G))\n                       (set (TopoS_withOffendingFlows.minimalize_offending_overapprox\n                              (c_sinvar m_spec) (edgesL G) []\n                              (list_graph_to_graph G)))", "apply (simp add: impl_spec; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>list_graph_to_graph\n              (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                (get_impl M) G) =\n             TopoS_Composition_Theory.generate_valid_topology_some\n              (get_spec M) (edgesL G) (list_graph_to_graph G);\n     SecurityInvariant_complies_formal_def m_impl m_spec \\<and>\n     (\\<forall>x\\<in>set M.\n         case x of\n         (x, xa) \\<Rightarrow> SecurityInvariant_complies_formal_def x xa);\n     wf_list_graph G; \\<not> implc_sinvar m_impl G;\n     c_sinvar m_spec (list_graph_to_graph G)\\<rbrakk>\n    \\<Longrightarrow> list_graph_to_graph\n                       (FiniteListGraph.delete_edges\n                         (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                           (get_impl M) G)\n                         (TopoS_Interface_impl.minimalize_offending_overapprox\n                           (implc_sinvar m_impl) (edgesL G) [] G)) =\n                      TopoS_Composition_Theory.generate_valid_topology_some\n                       (get_spec M) (edgesL G) (list_graph_to_graph G)\n 2. \\<lbrakk>list_graph_to_graph\n              (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                (get_impl M) G) =\n             TopoS_Composition_Theory.generate_valid_topology_some\n              (get_spec M) (edgesL G) (list_graph_to_graph G);\n     SecurityInvariant_complies_formal_def m_impl m_spec \\<and>\n     (\\<forall>x\\<in>set M.\n         case x of\n         (x, xa) \\<Rightarrow> SecurityInvariant_complies_formal_def x xa);\n     wf_list_graph G; \\<not> implc_sinvar m_impl G;\n     \\<not> c_sinvar m_spec (list_graph_to_graph G)\\<rbrakk>\n    \\<Longrightarrow> list_graph_to_graph\n                       (FiniteListGraph.delete_edges\n                         (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                           (get_impl M) G)\n                         (TopoS_Interface_impl.minimalize_offending_overapprox\n                           (implc_sinvar m_impl) (edgesL G) [] G)) =\n                      FiniteGraph.delete_edges\n                       (TopoS_Composition_Theory.generate_valid_topology_some\n                         (get_spec M) (edgesL G) (list_graph_to_graph G))\n                       (set (TopoS_withOffendingFlows.minimalize_offending_overapprox\n                              (c_sinvar m_spec) (edgesL G) []\n                              (list_graph_to_graph G)))", "apply (simp add: impl_spec; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_graph_to_graph\n              (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                (get_impl M) G) =\n             TopoS_Composition_Theory.generate_valid_topology_some\n              (get_spec M) (edgesL G) (list_graph_to_graph G);\n     SecurityInvariant_complies_formal_def m_impl m_spec \\<and>\n     (\\<forall>x\\<in>set M.\n         case x of\n         (x, xa) \\<Rightarrow> SecurityInvariant_complies_formal_def x xa);\n     wf_list_graph G; \\<not> implc_sinvar m_impl G;\n     \\<not> c_sinvar m_spec (list_graph_to_graph G)\\<rbrakk>\n    \\<Longrightarrow> list_graph_to_graph\n                       (FiniteListGraph.delete_edges\n                         (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                           (get_impl M) G)\n                         (TopoS_Interface_impl.minimalize_offending_overapprox\n                           (implc_sinvar m_impl) (edgesL G) [] G)) =\n                      FiniteGraph.delete_edges\n                       (TopoS_Composition_Theory.generate_valid_topology_some\n                         (get_spec M) (edgesL G) (list_graph_to_graph G))\n                       (set (TopoS_withOffendingFlows.minimalize_offending_overapprox\n                              (c_sinvar m_spec) (edgesL G) []\n                              (list_graph_to_graph G)))", "apply(simp add: delete_edges_correct[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_graph_to_graph\n              (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                (get_impl M) G) =\n             TopoS_Composition_Theory.generate_valid_topology_some\n              (get_spec M) (edgesL G) (list_graph_to_graph G);\n     SecurityInvariant_complies_formal_def m_impl m_spec \\<and>\n     (\\<forall>x\\<in>set M.\n         case x of\n         (x, xa) \\<Rightarrow> SecurityInvariant_complies_formal_def x xa);\n     wf_list_graph G; \\<not> implc_sinvar m_impl G;\n     \\<not> c_sinvar m_spec (list_graph_to_graph G)\\<rbrakk>\n    \\<Longrightarrow> FiniteGraph.delete_edges\n                       (TopoS_Composition_Theory.generate_valid_topology_some\n                         (get_spec M) (edgesL G) (list_graph_to_graph G))\n                       (set (TopoS_Interface_impl.minimalize_offending_overapprox\n                              (implc_sinvar m_impl) (edgesL G) [] G)) =\n                      FiniteGraph.delete_edges\n                       (TopoS_Composition_Theory.generate_valid_topology_some\n                         (get_spec M) (edgesL G) (list_graph_to_graph G))\n                       (set (TopoS_withOffendingFlows.minimalize_offending_overapprox\n                              (c_sinvar m_spec) (edgesL G) []\n                              (list_graph_to_graph G)))", "apply(simp add: list_graph_to_graph_def FiniteGraph.delete_edges_simp2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lparr>nodes =\n                       set (nodesL\n                             (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                               (get_impl M) G)),\n                edges =\n                  set (edgesL\n                        (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                          (get_impl M) G))\\<rparr> =\n             TopoS_Composition_Theory.generate_valid_topology_some\n              (get_spec M) (edgesL G)\n              \\<lparr>nodes = set (nodesL G),\n                 edges = set (edgesL G)\\<rparr>;\n     SecurityInvariant_complies_formal_def m_impl m_spec \\<and>\n     (\\<forall>x\\<in>set M.\n         case x of\n         (x, xa) \\<Rightarrow> SecurityInvariant_complies_formal_def x xa);\n     wf_list_graph G; \\<not> implc_sinvar m_impl G;\n     \\<not> c_sinvar m_spec\n             \\<lparr>nodes = set (nodesL G),\n                edges = set (edgesL G)\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> edges\n                       (TopoS_Composition_Theory.generate_valid_topology_some\n                         (get_spec M) (edgesL G)\n                         \\<lparr>nodes = set (nodesL G),\n                            edges = set (edgesL G)\\<rparr>) -\n                      set (TopoS_Interface_impl.minimalize_offending_overapprox\n                            (implc_sinvar m_impl) (edgesL G) [] G) =\n                      edges\n                       (TopoS_Composition_Theory.generate_valid_topology_some\n                         (get_spec M) (edgesL G)\n                         \\<lparr>nodes = set (nodesL G),\n                            edges = set (edgesL G)\\<rparr>) -\n                      set (TopoS_withOffendingFlows.minimalize_offending_overapprox\n                            (c_sinvar m_spec) (edgesL G) []\n                            \\<lparr>nodes = set (nodesL G),\n                               edges = set (edgesL G)\\<rparr>)", "apply(simp add: minimalize_offending_overapprox_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lparr>nodes =\n                       set (nodesL\n                             (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                               (get_impl M) G)),\n                edges =\n                  set (edgesL\n                        (TopoS_Composition_Theory_impl.generate_valid_topology_some\n                          (get_impl M) G))\\<rparr> =\n             TopoS_Composition_Theory.generate_valid_topology_some\n              (get_spec M) (edgesL G)\n              \\<lparr>nodes = set (nodesL G),\n                 edges = set (edgesL G)\\<rparr>;\n     SecurityInvariant_complies_formal_def m_impl m_spec \\<and>\n     (\\<forall>x\\<in>set M.\n         case x of\n         (x, xa) \\<Rightarrow> SecurityInvariant_complies_formal_def x xa);\n     wf_list_graph G; \\<not> implc_sinvar m_impl G;\n     \\<not> c_sinvar m_spec\n             \\<lparr>nodes = set (nodesL G),\n                edges = set (edgesL G)\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> edges\n                       (TopoS_Composition_Theory.generate_valid_topology_some\n                         (get_spec M) (edgesL G)\n                         \\<lparr>nodes = set (nodesL G),\n                            edges = set (edgesL G)\\<rparr>) -\n                      set (TopoS_withOffendingFlows.minimalize_offending_overapprox\n                            (c_sinvar m_spec) (edgesL G) []\n                            (list_graph_to_graph G)) =\n                      edges\n                       (TopoS_Composition_Theory.generate_valid_topology_some\n                         (get_spec M) (edgesL G)\n                         \\<lparr>nodes = set (nodesL G),\n                            edges = set (edgesL G)\\<rparr>) -\n                      set (TopoS_withOffendingFlows.minimalize_offending_overapprox\n                            (c_sinvar m_spec) (edgesL G) []\n                            \\<lparr>nodes = set (nodesL G),\n                               edges = set (edgesL G)\\<rparr>)", "by (simp add: list_graph_to_graph_def)"], ["proof (state)\nthis:\n  list_graph_to_graph\n   (TopoS_Composition_Theory_impl.generate_valid_topology_some\n     (get_impl (m # M)) G) =\n  TopoS_Composition_Theory.generate_valid_topology_some (get_spec (m # M))\n   (edgesL G) (list_graph_to_graph G)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\nsubsection{*generate valid topology*}\n  text{*tuned for invariants where we don't want to calculate all offending flows*}\n\n  fun generate_valid_topology_SOME :: \"'v SecurityInvariant list \\<Rightarrow> 'v list_graph \\<Rightarrow> ('v list_graph)\" where\n    \"generate_valid_topology_SOME [] G = G\" |\n    \"generate_valid_topology_SOME (m#Ms) G = (if implc_sinvar m G\n      then generate_valid_topology_SOME Ms G\n      else delete_edges (generate_valid_topology_SOME Ms G) (minimalize_offending_overapprox (implc_sinvar m) (edgesL G) [] G)\n      )\"\n\n  thm TopoS_Composition_Theory.generate_valid_topology_SOME_sound\n\n  (*TODO: show conformance to generate_valid_topology_some_sound*)\n  (*TODO: won't work because of the SOME!\n    I will probably have to show something like\n       all_security_requirements_fulfilled (get_impl M) (generate_valid_topology_SOME (get_impl M) G)\n    How can I do this without copy&pasting the proof of the spec?*)\n  lemma generate_valid_topology_SOME_complies:\n    \"\\<lbrakk> \\<forall> (m_impl, m_spec) \\<in> set M. SecurityInvariant_complies_formal_def m_impl m_spec;\n       wf_list_graph (G::('v list_graph)) \\<rbrakk> \\<Longrightarrow> \n       list_graph_to_graph (generate_valid_topology_SOME (get_impl M) G) = \n       TopoS_Composition_Theory.generate_valid_topology_SOME (get_spec M) (list_graph_to_graph G)\"\n    proof(induction M)\n    case Nil thus ?case by(simp add: get_spec_def get_impl_def)\n    next\n    case (Cons m M)\n      obtain m_impl m_spec where m: \"m = (m_impl, m_spec)\" by(cases m) blast\n      from m have m_impl: \"get_impl ((m_impl, m_spec) # M) = m_impl # (get_impl M)\" by (simp add: get_impl_def) \n      from m have m_spec: \"get_spec ((m_impl, m_spec) # M) = m_spec # (get_spec M)\" by (simp add: get_spec_def) \n      \n      from Cons.prems(1) m have complies_formal_def:  \"SecurityInvariant_complies_formal_def m_impl m_spec\" by simp\n      with Cons.prems(2) have impl_spec: \"implc_sinvar m_impl G \\<longleftrightarrow>  c_sinvar m_spec (list_graph_to_graph G)\"\n        by (simp add: SecurityInvariant_complies_formal_def_def)\n      \n      (*from minimalize_offending_overapprox_gives_some_offending_flow\n      have \"set (minimalize_offending_overapprox (implc_sinvar m_impl) (edgesL G) [] G)\n        \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows (c_sinvar_m_spec_bound_to_nP) (list_graph_to_graph G) nP\" sorry\n      *)\n\n      have my_todo: \"set (minimalize_offending_overapprox (implc_sinvar m_impl) (edgesL G) [] G)\n        \\<in> c_offending_flows m_spec (list_graph_to_graph G)\" sorry\n      \n      from my_todo[simplified list_graph_to_graph_def] have how_do_i_solve_this:\n      \"set (minimalize_offending_overapprox (implc_sinvar m_impl) (edgesL G) [] G) =\n       (SOME F. F \\<in> c_offending_flows m_spec \\<lparr>nodes = set (nodesL G), edges = set (edgesL G)\\<rparr>)\" sorry\n      \n      from Cons show ?case\n        apply(simp)\n        apply(simp add: m m_impl m_spec)\n        apply(intro conjI impI)\n          apply (simp add: impl_spec; fail)\n         apply (simp add: impl_spec; fail)\n        apply(simp add: delete_edges_correct[symmetric])\n        apply(simp add: list_graph_to_graph_def FiniteGraph.delete_edges_simp2)\n        using how_do_i_solve_this by simp\n    qed\n*)"], ["", "end"]]}