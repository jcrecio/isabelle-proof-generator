{"file_name": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification/TopoS_Interface.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification", "problem_names": ["lemma offending_not_empty: \"\\<lbrakk> F \\<in> set_offending_flows G nP \\<rbrakk> \\<Longrightarrow> F \\<noteq> {}\"", "lemma empty_offending_contra:\n       \"\\<lbrakk> F \\<in> set_offending_flows G nP; F = {}\\<rbrakk> \\<Longrightarrow> False\"", "lemma offending_notevalD: \"F \\<in> set_offending_flows G nP \\<Longrightarrow> \\<not> sinvar G nP\"", "lemma sinvar_no_offending: \"sinvar G nP \\<Longrightarrow> set_offending_flows G nP = {}\"", "theorem removing_offending_flows_makes_invariant_hold:\n      \"\\<forall>F \\<in> set_offending_flows G nP. sinvar (delete_edges G F) nP\"", "lemma set_offending_flows_simp: \n    \"\\<lbrakk> wf_graph G \\<rbrakk> \\<Longrightarrow>\n      set_offending_flows G nP = {F. F \\<subseteq> edges G \\<and>\n        (\\<not> sinvar G nP \\<and> sinvar \\<lparr>nodes = nodes G, edges = edges G - F\\<rparr> nP) \\<and>\n        (\\<forall>(e1, e2)\\<in>F. \\<not> sinvar \\<lparr>nodes = nodes G, edges = {(e1, e2)} \\<union> (edges G - F)\\<rparr> nP)}\"", "lemma \"SecurityInvariant_withOffendingFlows.set_offending_flows (\\<lambda>_ _. False) \\<lparr> nodes = {''v1''}, edges={} \\<rparr> id = {}\"", "lemma \"SecurityInvariant_withOffendingFlows.set_offending_flows (\\<lambda>_ _. False) \n  \\<lparr> nodes = {''v1'', ''v2''}, edges = {(''v1'', ''v2'')} \\<rparr> id = {}\"", "lemma \"\\<exists>sinvar. \\<not> sinvar G nP \\<and> SecurityInvariant_withOffendingFlows.set_offending_flows sinvar G nP = {}\"", "lemma node_props_eq_node_props_formaldef: \"node_props_formaldef = node_props\"", "lemma unique_common_math_notation:\n    assumes \"\\<forall>G nP i F. wf_graph (G::('v::vertex) graph) \\<and> \\<not> sinvar G nP \\<and> F \\<in> set_offending_flows G nP \\<and> \n         sinvar (delete_edges G F) nP \\<and> \n         (\\<not> receiver_violation \\<longrightarrow> i \\<in> fst ` F \\<longrightarrow> \\<not> sinvar G (nP(i := otherbot))) \\<and>\n         (receiver_violation \\<longrightarrow> i \\<in> snd ` F \\<longrightarrow> \\<not> sinvar G (nP(i := otherbot)))\"\n    shows \"otherbot = \\<bottom>\"", "lemma default_unique_EX_notation: \"otherbot \\<noteq> \\<bottom> \\<Longrightarrow> \n          \\<exists> G nP i f. wf_graph G \\<and> \\<not> sinvar G nP \\<and> f \\<in> set_offending_flows G nP \\<and> \n           sinvar (delete_edges G f) nP \\<and>\n           (i \\<in> snd` f \\<and> sinvar G (nP(i := otherbot)))\"", "lemma default_uniqueness_by_counterexample_IFS:\n  assumes \"(\\<forall>G F nP i. wf_graph G \\<and> F \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows sinvar G nP \\<and> i \\<in> snd` F \n                \\<longrightarrow> \\<not> sinvar G (nP(i := otherbot)))\"\n  and \"otherbot \\<noteq> default_value \\<Longrightarrow>\n    \\<exists>G nP i F. wf_graph G \\<and> \\<not> sinvar G nP \\<and> F \\<in> (SecurityInvariant_withOffendingFlows.set_offending_flows sinvar G nP) \\<and>\n       sinvar (delete_edges G F) nP \\<and>\n        i \\<in> snd ` F \\<and> sinvar G (nP(i := otherbot)) \"\n   shows \"otherbot = default_value\"", "lemma default_unique_EX_notation: \"otherbot \\<noteq> \\<bottom> \\<Longrightarrow> \n          \\<exists> G nP i f. wf_graph G \\<and> \\<not> sinvar G nP \\<and> f \\<in> set_offending_flows G nP \\<and> \n           sinvar (delete_edges G f) nP \\<and>\n           (i \\<in> fst` f \\<and> sinvar G (nP(i := otherbot)))\"", "lemma default_uniqueness_by_counterexample_ACS:\n  assumes \"(\\<forall>G F nP i. wf_graph G \\<and> F \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows sinvar G nP \\<and> i \\<in> fst ` F \n                \\<longrightarrow> \\<not> sinvar G (nP(i := otherbot)))\"\n  and \"otherbot \\<noteq> default_value \\<Longrightarrow>\n    \\<exists>G nP i F. wf_graph G \\<and> \\<not> sinvar G nP \\<and> F \\<in> (SecurityInvariant_withOffendingFlows.set_offending_flows sinvar G nP) \\<and>\n       sinvar (delete_edges G F) nP \\<and>\n        i \\<in> fst ` F \\<and> sinvar G (nP(i := otherbot))\"\n  shows \"otherbot = default_value\""], "translations": [["", "lemma offending_not_empty: \"\\<lbrakk> F \\<in> set_offending_flows G nP \\<rbrakk> \\<Longrightarrow> F \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<in> set_offending_flows G nP \\<Longrightarrow> F \\<noteq> {}", "by(auto simp add: set_offending_flows_def is_offending_flows_def is_offending_flows_min_set_def)"], ["", "lemma empty_offending_contra:\n       \"\\<lbrakk> F \\<in> set_offending_flows G nP; F = {}\\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>F \\<in> set_offending_flows G nP; F = {}\\<rbrakk>\n    \\<Longrightarrow> False", "by(simp add: set_offending_flows_def is_offending_flows_def is_offending_flows_min_set_def)"], ["", "lemma offending_notevalD: \"F \\<in> set_offending_flows G nP \\<Longrightarrow> \\<not> sinvar G nP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<in> set_offending_flows G nP \\<Longrightarrow> \\<not> sinvar G nP", "by(simp add: set_offending_flows_def is_offending_flows_def is_offending_flows_min_set_def)"], ["", "lemma sinvar_no_offending: \"sinvar G nP \\<Longrightarrow> set_offending_flows G nP = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinvar G nP \\<Longrightarrow> set_offending_flows G nP = {}", "by(simp add: set_offending_flows_def is_offending_flows_def is_offending_flows_min_set_def)"], ["", "theorem removing_offending_flows_makes_invariant_hold:\n      \"\\<forall>F \\<in> set_offending_flows G nP. sinvar (delete_edges G F) nP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>set_offending_flows G nP. sinvar (delete_edges G F) nP", "proof(cases \"sinvar G nP\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sinvar G nP \\<Longrightarrow>\n    \\<forall>F\\<in>set_offending_flows G nP. sinvar (delete_edges G F) nP\n 2. \\<not> sinvar G nP \\<Longrightarrow>\n    \\<forall>F\\<in>set_offending_flows G nP. sinvar (delete_edges G F) nP", "case True"], ["proof (state)\nthis:\n  sinvar G nP\n\ngoal (2 subgoals):\n 1. sinvar G nP \\<Longrightarrow>\n    \\<forall>F\\<in>set_offending_flows G nP. sinvar (delete_edges G F) nP\n 2. \\<not> sinvar G nP \\<Longrightarrow>\n    \\<forall>F\\<in>set_offending_flows G nP. sinvar (delete_edges G F) nP", "hence no_offending: \"set_offending_flows G nP = {}\""], ["proof (prove)\nusing this:\n  sinvar G nP\n\ngoal (1 subgoal):\n 1. set_offending_flows G nP = {}", "using sinvar_no_offending"], ["proof (prove)\nusing this:\n  sinvar G nP\n  sinvar ?G ?nP \\<Longrightarrow> set_offending_flows ?G ?nP = {}\n\ngoal (1 subgoal):\n 1. set_offending_flows G nP = {}", "by simp"], ["proof (state)\nthis:\n  set_offending_flows G nP = {}\n\ngoal (2 subgoals):\n 1. sinvar G nP \\<Longrightarrow>\n    \\<forall>F\\<in>set_offending_flows G nP. sinvar (delete_edges G F) nP\n 2. \\<not> sinvar G nP \\<Longrightarrow>\n    \\<forall>F\\<in>set_offending_flows G nP. sinvar (delete_edges G F) nP", "thus \"\\<forall>F\\<in>set_offending_flows G nP. sinvar (delete_edges G F) nP\""], ["proof (prove)\nusing this:\n  set_offending_flows G nP = {}\n\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>set_offending_flows G nP. sinvar (delete_edges G F) nP", "using empty_iff"], ["proof (prove)\nusing this:\n  set_offending_flows G nP = {}\n  (?c \\<in> {}) = False\n\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>set_offending_flows G nP. sinvar (delete_edges G F) nP", "by simp"], ["proof (state)\nthis:\n  \\<forall>F\\<in>set_offending_flows G nP. sinvar (delete_edges G F) nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar G nP \\<Longrightarrow>\n    \\<forall>F\\<in>set_offending_flows G nP. sinvar (delete_edges G F) nP", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> sinvar G nP \\<Longrightarrow>\n    \\<forall>F\\<in>set_offending_flows G nP. sinvar (delete_edges G F) nP", "case False"], ["proof (state)\nthis:\n  \\<not> sinvar G nP\n\ngoal (1 subgoal):\n 1. \\<not> sinvar G nP \\<Longrightarrow>\n    \\<forall>F\\<in>set_offending_flows G nP. sinvar (delete_edges G F) nP", "thus \"\\<forall>F\\<in>set_offending_flows G nP. sinvar (delete_edges G F) nP\""], ["proof (prove)\nusing this:\n  \\<not> sinvar G nP\n\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>set_offending_flows G nP. sinvar (delete_edges G F) nP", "by(simp add: set_offending_flows_def is_offending_flows_def is_offending_flows_min_set_def graph_ops)"], ["proof (state)\nthis:\n  \\<forall>F\\<in>set_offending_flows G nP. sinvar (delete_edges G F) nP\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary valid_without_offending_flows:\n  \"\\<lbrakk> F \\<in> set_offending_flows G nP \\<rbrakk> \\<Longrightarrow> sinvar (delete_edges G F) nP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<in> set_offending_flows G nP \\<Longrightarrow>\n    sinvar (delete_edges G F) nP", "by(simp add: removing_offending_flows_makes_invariant_hold)"], ["", "lemma set_offending_flows_simp: \n    \"\\<lbrakk> wf_graph G \\<rbrakk> \\<Longrightarrow>\n      set_offending_flows G nP = {F. F \\<subseteq> edges G \\<and>\n        (\\<not> sinvar G nP \\<and> sinvar \\<lparr>nodes = nodes G, edges = edges G - F\\<rparr> nP) \\<and>\n        (\\<forall>(e1, e2)\\<in>F. \\<not> sinvar \\<lparr>nodes = nodes G, edges = {(e1, e2)} \\<union> (edges G - F)\\<rparr> nP)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow>\n    set_offending_flows G nP =\n    {F. F \\<subseteq> edges G \\<and>\n        (\\<not> sinvar G nP \\<and>\n         sinvar \\<lparr>nodes = nodes G, edges = edges G - F\\<rparr>\n          nP) \\<and>\n        (\\<forall>(e1, e2)\\<in>F.\n            \\<not> sinvar\n                    \\<lparr>nodes = nodes G,\n                       edges = {(e1, e2)} \\<union> (edges G - F)\\<rparr>\n                    nP)}", "apply(simp only: set_offending_flows_def is_offending_flows_min_set_def \n      is_offending_flows_def delete_edges_simp2 add_edge_def graph.select_convs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow>\n    {F. F \\<subseteq> edges G \\<and>\n        (\\<not> sinvar G nP \\<and>\n         sinvar \\<lparr>nodes = nodes G, edges = edges G - F\\<rparr>\n          nP) \\<and>\n        (\\<forall>(e1, e2)\\<in>F.\n            \\<not> sinvar\n                    \\<lparr>nodes = nodes G \\<union> {e1, e2},\n                       edges = {(e1, e2)} \\<union> (edges G - F)\\<rparr>\n                    nP)} =\n    {F. F \\<subseteq> edges G \\<and>\n        (\\<not> sinvar G nP \\<and>\n         sinvar \\<lparr>nodes = nodes G, edges = edges G - F\\<rparr>\n          nP) \\<and>\n        (\\<forall>(e1, e2)\\<in>F.\n            \\<not> sinvar\n                    \\<lparr>nodes = nodes G,\n                       edges = {(e1, e2)} \\<union> (edges G - F)\\<rparr>\n                    nP)}", "apply(subgoal_tac \"\\<And>F e1 e2. F \\<subseteq> edges G \\<Longrightarrow> (e1, e2) \\<in> F \\<Longrightarrow> nodes G \\<union> {e1, e2} = nodes G\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_graph G;\n     \\<And>F e1 e2.\n        \\<lbrakk>F \\<subseteq> edges G; (e1, e2) \\<in> F\\<rbrakk>\n        \\<Longrightarrow> nodes G \\<union> {e1, e2} = nodes G\\<rbrakk>\n    \\<Longrightarrow> {F. F \\<subseteq> edges G \\<and>\n                          (\\<not> sinvar G nP \\<and>\n                           sinvar\n                            \\<lparr>nodes = nodes G,\n                               edges = edges G - F\\<rparr>\n                            nP) \\<and>\n                          (\\<forall>(e1, e2)\\<in>F.\n                              \\<not> sinvar\n\\<lparr>nodes = nodes G \\<union> {e1, e2},\n   edges = {(e1, e2)} \\<union> (edges G - F)\\<rparr>\nnP)} =\n                      {F. F \\<subseteq> edges G \\<and>\n                          (\\<not> sinvar G nP \\<and>\n                           sinvar\n                            \\<lparr>nodes = nodes G,\n                               edges = edges G - F\\<rparr>\n                            nP) \\<and>\n                          (\\<forall>(e1, e2)\\<in>F.\n                              \\<not> sinvar\n\\<lparr>nodes = nodes G, edges = {(e1, e2)} \\<union> (edges G - F)\\<rparr>\nnP)}\n 2. \\<And>F e1 e2.\n       \\<lbrakk>wf_graph G; F \\<subseteq> edges G; (e1, e2) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> nodes G \\<union> {e1, e2} = nodes G", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F e1 e2.\n       \\<lbrakk>wf_graph G; F \\<subseteq> edges G; (e1, e2) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> nodes G \\<union> {e1, e2} = nodes G", "apply(simp add: wf_graph_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F e1 e2.\n       \\<lbrakk>fst ` edges G \\<subseteq> nodes G \\<and>\n                snd ` edges G \\<subseteq> nodes G \\<and>\n                finite (edges G) \\<and> finite (nodes G);\n        F \\<subseteq> edges G; (e1, e2) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> insert e1 (insert e2 (nodes G)) = nodes G", "by (metis fst_conv imageI in_mono insert_absorb snd_conv)"], ["", "end"], ["", "print_locale! SecurityInvariant_withOffendingFlows"], ["", "text\\<open>\nThe locale \\<open>SecurityInvariant_withOffendingFlows\\<close> has no assumptions about the security invariant \\<open>sinvar\\<close>.\nUndesirable things may happen:\nThe offending flows can be empty, even for a violated invariant.\n\nWe provide an example, the security invariant @{term \"(\\<lambda>_ _. False)\"}.\nAs host attributes, we simply use the identity function @{const id}.\n\\<close>"], ["", "lemma \"SecurityInvariant_withOffendingFlows.set_offending_flows (\\<lambda>_ _. False) \\<lparr> nodes = {''v1''}, edges={} \\<rparr> id = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.set_offending_flows\n     (\\<lambda>_ _. False) \\<lparr>nodes = {''v1''}, edges = {}\\<rparr> id =\n    {}", "by %invisible (simp add: SecurityInvariant_withOffendingFlows.set_offending_flows_def \n  SecurityInvariant_withOffendingFlows.is_offending_flows_min_set_def SecurityInvariant_withOffendingFlows.is_offending_flows_def)"], ["", "lemma \"SecurityInvariant_withOffendingFlows.set_offending_flows (\\<lambda>_ _. False) \n  \\<lparr> nodes = {''v1'', ''v2''}, edges = {(''v1'', ''v2'')} \\<rparr> id = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.set_offending_flows\n     (\\<lambda>_ _. False)\n     \\<lparr>nodes = {''v1'', ''v2''}, edges = {(''v1'', ''v2'')}\\<rparr>\n     id =\n    {}", "by %invisible (simp add: SecurityInvariant_withOffendingFlows.set_offending_flows_def \n  SecurityInvariant_withOffendingFlows.is_offending_flows_min_set_def SecurityInvariant_withOffendingFlows.is_offending_flows_def)"], ["", "text \\<open>In general, there exists a @{term sinvar} such that the invariant does not hold and no offending flows exits.\\<close>"], ["", "lemma \"\\<exists>sinvar. \\<not> sinvar G nP \\<and> SecurityInvariant_withOffendingFlows.set_offending_flows sinvar G nP = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>sinvar.\n       \\<not> sinvar G nP \\<and>\n       SecurityInvariant_withOffendingFlows.set_offending_flows sinvar G\n        nP =\n       {}", "apply(simp add: SecurityInvariant_withOffendingFlows.set_offending_flows_def\n    SecurityInvariant_withOffendingFlows.is_offending_flows_min_set_def SecurityInvariant_withOffendingFlows.is_offending_flows_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>sinvar.\n       \\<not> sinvar G nP \\<and>\n       (\\<forall>x.\n           sinvar (delete_edges G x) nP \\<longrightarrow>\n           x \\<subseteq> edges G \\<longrightarrow>\n           sinvar G nP \\<or>\n           (\\<exists>xa\\<in>x.\n               \\<not> (case xa of\n                       (e1, e2) \\<Rightarrow>\n                         \\<not> sinvar (add_edge e1 e2 (delete_edges G x))\n                                 nP)))", "apply(rule_tac x=\"(\\<lambda>_ _. False)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> False \\<and>\n    (\\<forall>x.\n        False \\<longrightarrow>\n        x \\<subseteq> edges G \\<longrightarrow>\n        False \\<or>\n        (\\<exists>x\\<in>x.\n            \\<not> (case x of (e1, e2) \\<Rightarrow> \\<not> False)))", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Thus, we introduce usefulness properties that prohibits such useless invariants.\\<close>"], ["", "text\\<open>We summarize them in an invariant.\nIt requires the following: \n\\begin{enumerate}\n  \\item The offending flows are always defined.\n  \\item The invariant is monotonic, i.e. prohibiting more is more secure.\n  \\item And, the (non-minimal) offending flows are monotonic, i.e. prohibiting more solves more security issues.\n\\end{enumerate}\n\nLater, we will show that is suffices to show that the invariant is monotonic. The other two properties can be derived.\n\\<close>"], ["", "locale SecurityInvariant_preliminaries = SecurityInvariant_withOffendingFlows sinvar\n    for sinvar\n    +\n    assumes \n      defined_offending:\n      \"\\<lbrakk> wf_graph G; \\<not> sinvar G nP \\<rbrakk> \\<Longrightarrow> set_offending_flows G nP \\<noteq> {}\"\n    and\n      mono_sinvar:\n      \"\\<lbrakk> wf_graph \\<lparr> nodes = N, edges = E \\<rparr>; E' \\<subseteq> E; sinvar \\<lparr> nodes = N, edges = E \\<rparr> nP \\<rbrakk> \\<Longrightarrow> \n        sinvar \\<lparr> nodes = N, edges = E' \\<rparr> nP\"\n    and mono_offending:\n      \"\\<lbrakk> wf_graph G; is_offending_flows ff G nP \\<rbrakk> \\<Longrightarrow> is_offending_flows (ff \\<union> f') G nP\"\n  begin"], ["", "text \\<open>\n    \\begin{small}\n    To instantiate a @{const SecurityInvariant_preliminaries}, here are some hints: \n    Have a look at the \\<open>TopoS_withOffendingFlows.thy\\<close> file.\n    There is a definition of @{prop sinvar_mono}. It impplies @{prop mono_sinvar} and @{prop mono_offending}\n    \\<open>apply(fact SecurityInvariant_withOffendingFlows.sinvar_mono_imp_sinvar_mono[OF sinvar_mono])\n    apply(fact SecurityInvariant_withOffendingFlows.sinvar_mono_imp_is_offending_flows_mono[OF sinvar_mono])\\<close>\n  \n    In addition, \\<open>SecurityInvariant_withOffendingFlows.mono_imp_set_offending_flows_not_empty[OF sinvar_mono]\\<close> gives a nice proof rule for\n    @{prop defined_offending}\n  \n    Basically, \\<open>sinvar_mono.\\<close> implies almost all assumptions here and is equal to @{prop mono_sinvar}.\n    \\end{small}\n\\<close>"], ["", "end"], ["", "subsection\\<open>Security Invariants with secure auto-completion of host attribute mappings\\<close>"], ["", "text\\<open>\nWe will now add a new artifact to the Security Invariant.\nIt is a secure default host attribute, we will use the symbol \\<open>\\<bottom>\\<close>.\n\nThe newly introduced Boolean \\<open>receiver_violation\\<close> tells whether a security violation happens at the sender's or the receiver's side.\n\nThe details can be looked up in \\cite{diekmann2014forte}. \n\\<close>\n\n  \\<comment> \\<open>Some notes about the notation:\n          @{term \"fst ` F\"} means to apply the function @{const \"fst\"} to the set @{term \"F\"} element-wise.\n          Example: If @{term \"F\"} is a set of directed edges, \n          @{term \"F \\<subseteq> edges G\"}, then @{term \"fst ` F\"}\n          is the set of senders and @{term \"snd ` f\"} the set of receivers.\\<close>"], ["", "locale SecurityInvariant = SecurityInvariant_preliminaries sinvar\n    for sinvar::\"('v::vertex) graph \\<Rightarrow> ('v::vertex \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n    +\n    fixes default_node_properties :: \"'a\" (\"\\<bottom>\") \n    and receiver_violation :: \"bool\"\n    assumes \n      \\<comment> \\<open>default value can never fix a security violation.\\<close>\n      \\<comment> \\<open>Idea: Assume there is a violation, then there is some offending flow. \n        @{text receiver_violation} defines whether the violation happens at the sender's or the receiver's side. \n        We call the place of the violation the \\emph{offending host}. \n        We replace the host attribute of the offending host with the default attribute. \n        Giving an offending host, a \\emph{secure} default attribute does not change whether the invariant holds.\n        I.e.\\ this reconfiguration does not remove information, thus preserves all security critical information.\n        Thought experiment preliminaries: Can a default configuration ever solve an existing security violation? NO!\n        Thought experiment 1: admin forgot to configure host, hence it is handled by default configuration value ...\n        Thought experiment 2: new node (attacker) is added to the network. What is its default configuration value ...\\<close>\n      default_secure:\n      \"\\<lbrakk> wf_graph G; \\<not> sinvar G nP; F \\<in> set_offending_flows G nP \\<rbrakk> \\<Longrightarrow>\n        (\\<not> receiver_violation \\<longrightarrow> i \\<in> fst ` F \\<longrightarrow> \\<not> sinvar G (nP(i := \\<bottom>))) \\<and>\n        (receiver_violation \\<longrightarrow> i \\<in> snd ` F \\<longrightarrow> \\<not> sinvar G (nP(i := \\<bottom>)))\"\n      and\n      default_unique:\n      \"otherbot \\<noteq> \\<bottom> \\<Longrightarrow> \n        \\<exists> (G::('v::vertex) graph) nP i F. wf_graph G \\<and> \\<not> sinvar G nP \\<and> F \\<in> set_offending_flows G nP \\<and> \n         sinvar (delete_edges G F) nP \\<and>\n         (\\<not> receiver_violation \\<longrightarrow> i \\<in> fst ` F \\<and> sinvar G (nP(i := otherbot))) \\<and>\n         (receiver_violation \\<longrightarrow> i \\<in> snd ` F \\<and> sinvar G (nP(i := otherbot))) \"\n   begin\n    \\<comment> \\<open>Removes option type, replaces with default host attribute\\<close>"], ["", "fun node_props :: \"('v, 'a) TopoS_Params \\<Rightarrow> ('v \\<Rightarrow> 'a)\" where\n    \"node_props P = (\\<lambda> i. (case (node_properties P) i of Some property \\<Rightarrow> property | None \\<Rightarrow> \\<bottom>))\""], ["", "definition node_props_formaldef :: \"('v, 'a) TopoS_Params \\<Rightarrow> ('v \\<Rightarrow> 'a)\" where\n    \"node_props_formaldef P \\<equiv>\n    (\\<lambda> i. (if i \\<in> dom (node_properties P) then the (node_properties P i) else \\<bottom>))\""], ["", "lemma node_props_eq_node_props_formaldef: \"node_props_formaldef = node_props\""], ["proof (prove)\ngoal (1 subgoal):\n 1. node_props_formaldef = node_props", "by(simp add: fun_eq_iff node_props_formaldef_def option.case_eq_if domIff)"], ["", "text\\<open>\n      Checking whether a security invariant holds.\n      \\begin{enumerate}\n        \\item check that the policy @{term G} is syntactically valid\n        \\item check the security invariant @{term sinvar}\n      \\end{enumerate}\n\\<close>"], ["", "definition eval::\"'v graph \\<Rightarrow> ('v, 'a) TopoS_Params \\<Rightarrow> bool\" where\n    \"eval G P \\<equiv> wf_graph G \\<and> sinvar G (node_props P)\""], ["", "lemma unique_common_math_notation:\n    assumes \"\\<forall>G nP i F. wf_graph (G::('v::vertex) graph) \\<and> \\<not> sinvar G nP \\<and> F \\<in> set_offending_flows G nP \\<and> \n         sinvar (delete_edges G F) nP \\<and> \n         (\\<not> receiver_violation \\<longrightarrow> i \\<in> fst ` F \\<longrightarrow> \\<not> sinvar G (nP(i := otherbot))) \\<and>\n         (receiver_violation \\<longrightarrow> i \\<in> snd ` F \\<longrightarrow> \\<not> sinvar G (nP(i := otherbot)))\"\n    shows \"otherbot = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. otherbot = \\<bottom>", "apply(rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. otherbot \\<noteq> \\<bottom> \\<Longrightarrow> False", "apply(drule default_unique)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>G nP i F.\n       wf_graph G \\<and>\n       \\<not> sinvar G nP \\<and>\n       F \\<in> set_offending_flows G nP \\<and>\n       sinvar (delete_edges G F) nP \\<and>\n       (\\<not> receiver_violation \\<longrightarrow>\n        i \\<in> fst ` F \\<and> sinvar G (nP(i := otherbot))) \\<and>\n       (receiver_violation \\<longrightarrow>\n        i \\<in> snd ` F \\<and>\n        sinvar G (nP(i := otherbot))) \\<Longrightarrow>\n    False", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>G nP i F.\n     wf_graph G \\<and>\n     \\<not> sinvar G nP \\<and>\n     F \\<in> set_offending_flows G nP \\<and>\n     sinvar (delete_edges G F) nP \\<and>\n     (\\<not> receiver_violation \\<longrightarrow>\n      i \\<in> fst ` F \\<longrightarrow>\n      \\<not> sinvar G (nP(i := otherbot))) \\<and>\n     (receiver_violation \\<longrightarrow>\n      i \\<in> snd ` F \\<longrightarrow> \\<not> sinvar G (nP(i := otherbot)))\n\ngoal (1 subgoal):\n 1. \\<exists>G nP i F.\n       wf_graph G \\<and>\n       \\<not> sinvar G nP \\<and>\n       F \\<in> set_offending_flows G nP \\<and>\n       sinvar (delete_edges G F) nP \\<and>\n       (\\<not> receiver_violation \\<longrightarrow>\n        i \\<in> fst ` F \\<and> sinvar G (nP(i := otherbot))) \\<and>\n       (receiver_violation \\<longrightarrow>\n        i \\<in> snd ` F \\<and>\n        sinvar G (nP(i := otherbot))) \\<Longrightarrow>\n    False", "by blast"], ["", "end"], ["", "print_locale! SecurityInvariant"], ["", "subsection\\<open>Information Flow Security and Access Control\\<close>"], ["", "text\\<open>\n\n@{term receiver_violation} defines the offending host. Thus, it defines when the violation happens. \n\nWe found that this coincides with the invariant's security strategy. \n\n\\begin{description}\n\\item[ACS] If the violation happens at the sender, we have an access control strategy (\\emph{ACS}). \nI.e.\\ the sender does not have the appropriate rights to initiate the connection.\n\n\\item[IFS] If the violation happens at the receiver, we have an information flow security strategy (\\emph{IFS})\nI.e.\\ the receiver lacks the appropriate security level to retrieve the (confidential) information. \nThe violations happens only when the receiver reads the data.\n\\end{description}\n\nWe refine our @{term SecurityInvariant} locale.\n\\<close>"], ["", "subsection \\<open>Information Flow Security Strategy (IFS)\\<close>"], ["", "locale SecurityInvariant_IFS = SecurityInvariant_preliminaries sinvar\n      for sinvar::\"('v::vertex) graph \\<Rightarrow> ('v::vertex \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n      +\n      fixes default_node_properties :: \"'a\" (\"\\<bottom>\") \n      assumes  default_secure_IFS:\n        \"\\<lbrakk> wf_graph G; f \\<in> set_offending_flows G nP \\<rbrakk> \\<Longrightarrow>\n          \\<forall>i \\<in> snd` f. \\<not> sinvar G (nP(i := \\<bottom>))\"\n      and\n      \\<comment> \\<open>If some otherbot fulfills @{text default_secure}, it must be @{term \"\\<bottom>\"} \n             Hence, @{term \"\\<bottom>\"} is uniquely defined\\<close>\n      default_unique_IFS:\n      \"(\\<forall>G f nP i. wf_graph G \\<and> f \\<in> set_offending_flows G nP \\<and> i \\<in> snd` f \n                \\<longrightarrow> \\<not> sinvar G (nP(i := otherbot))) \\<Longrightarrow> otherbot = \\<bottom>\"\n      begin"], ["", "lemma default_unique_EX_notation: \"otherbot \\<noteq> \\<bottom> \\<Longrightarrow> \n          \\<exists> G nP i f. wf_graph G \\<and> \\<not> sinvar G nP \\<and> f \\<in> set_offending_flows G nP \\<and> \n           sinvar (delete_edges G f) nP \\<and>\n           (i \\<in> snd` f \\<and> sinvar G (nP(i := otherbot)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. otherbot \\<noteq> \\<bottom> \\<Longrightarrow>\n    \\<exists>G nP i f.\n       wf_graph G \\<and>\n       \\<not> sinvar G nP \\<and>\n       f \\<in> set_offending_flows G nP \\<and>\n       sinvar (delete_edges G f) nP \\<and>\n       i \\<in> snd ` f \\<and> sinvar G (nP(i := otherbot))", "apply(erule contrapos_pp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>G nP i f.\n       wf_graph G \\<and>\n       \\<not> sinvar G nP \\<and>\n       f \\<in> set_offending_flows G nP \\<and>\n       sinvar (delete_edges G f) nP \\<and>\n       i \\<in> snd ` f \\<and> sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n    \\<not> otherbot \\<noteq> \\<bottom>", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>G.\n       wf_graph G \\<longrightarrow>\n       (\\<forall>nP.\n           sinvar G nP \\<or>\n           (\\<forall>i f.\n               i \\<in> snd ` f \\<longrightarrow>\n               sinvar (delete_edges G f) nP \\<longrightarrow>\n               f \\<in> set_offending_flows G nP \\<longrightarrow>\n               \\<not> sinvar G (nP(i := otherbot)))) \\<Longrightarrow>\n    otherbot = \\<bottom>", "using default_unique_IFS SecurityInvariant_withOffendingFlows.valid_without_offending_flows offending_notevalD"], ["proof (prove)\nusing this:\n  \\<forall>G f nP i.\n     wf_graph G \\<and>\n     f \\<in> set_offending_flows G nP \\<and>\n     i \\<in> snd ` f \\<longrightarrow>\n     \\<not> sinvar G (nP(i := ?otherbot)) \\<Longrightarrow>\n  ?otherbot = \\<bottom>\n  ?F \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows ?sinvar\n            ?G ?nP \\<Longrightarrow>\n  ?sinvar (delete_edges ?G ?F) ?nP\n  ?F \\<in> set_offending_flows ?G ?nP \\<Longrightarrow> \\<not> sinvar ?G ?nP\n\ngoal (1 subgoal):\n 1. \\<forall>G.\n       wf_graph G \\<longrightarrow>\n       (\\<forall>nP.\n           sinvar G nP \\<or>\n           (\\<forall>i f.\n               i \\<in> snd ` f \\<longrightarrow>\n               sinvar (delete_edges G f) nP \\<longrightarrow>\n               f \\<in> set_offending_flows G nP \\<longrightarrow>\n               \\<not> sinvar G (nP(i := otherbot)))) \\<Longrightarrow>\n    otherbot = \\<bottom>", "by metis"], ["", "end"], ["", "sublocale SecurityInvariant_IFS \\<subseteq> SecurityInvariant where receiver_violation=True"], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant sinvar \\<bottom> True", "apply(unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>G nP F i.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP;\n        F \\<in> set_offending_flows G nP\\<rbrakk>\n       \\<Longrightarrow> (\\<not> True \\<longrightarrow>\n                          i \\<in> fst ` F \\<longrightarrow>\n                          \\<not> sinvar G (nP(i := \\<bottom>))) \\<and>\n                         (True \\<longrightarrow>\n                          i \\<in> snd ` F \\<longrightarrow>\n                          \\<not> sinvar G (nP(i := \\<bottom>)))\n 2. \\<And>otherbot.\n       otherbot \\<noteq> \\<bottom> \\<Longrightarrow>\n       \\<exists>G nP i F.\n          wf_graph G \\<and>\n          \\<not> sinvar G nP \\<and>\n          F \\<in> set_offending_flows G nP \\<and>\n          sinvar (delete_edges G F) nP \\<and>\n          (\\<not> True \\<longrightarrow>\n           i \\<in> fst ` F \\<and> sinvar G (nP(i := otherbot))) \\<and>\n          (True \\<longrightarrow>\n           i \\<in> snd ` F \\<and> sinvar G (nP(i := otherbot)))", "apply(simp add: default_secure_IFS)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>otherbot.\n       otherbot \\<noteq> \\<bottom> \\<Longrightarrow>\n       \\<exists>G nP i F.\n          wf_graph G \\<and>\n          \\<not> sinvar G nP \\<and>\n          F \\<in> set_offending_flows G nP \\<and>\n          sinvar (delete_edges G F) nP \\<and>\n          (\\<not> True \\<longrightarrow>\n           i \\<in> fst ` F \\<and> sinvar G (nP(i := otherbot))) \\<and>\n          (True \\<longrightarrow>\n           i \\<in> snd ` F \\<and> sinvar G (nP(i := otherbot)))", "apply(simp only: HOL.simp_thms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>otherbot.\n       otherbot \\<noteq> \\<bottom> \\<Longrightarrow>\n       \\<exists>G nP i F.\n          wf_graph G \\<and>\n          \\<not> sinvar G nP \\<and>\n          F \\<in> set_offending_flows G nP \\<and>\n          sinvar (delete_edges G F) nP \\<and>\n          i \\<in> snd ` F \\<and> sinvar G (nP(i := otherbot))", "apply(drule default_unique_EX_notation)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>otherbot.\n       \\<exists>G nP i f.\n          wf_graph G \\<and>\n          \\<not> sinvar G nP \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          sinvar (delete_edges G f) nP \\<and>\n          i \\<in> snd ` f \\<and>\n          sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n       \\<exists>G nP i F.\n          wf_graph G \\<and>\n          \\<not> sinvar G nP \\<and>\n          F \\<in> set_offending_flows G nP \\<and>\n          sinvar (delete_edges G F) nP \\<and>\n          i \\<in> snd ` F \\<and> sinvar G (nP(i := otherbot))", "apply(assumption)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*other direction*)"], ["", "locale SecurityInvariant_IFS_otherDirectrion = SecurityInvariant where receiver_violation=True"], ["", "sublocale SecurityInvariant_IFS_otherDirectrion \\<subseteq> SecurityInvariant_IFS"], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_IFS sinvar \\<bottom>", "apply(unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>G f nP.\n       \\<lbrakk>wf_graph G; f \\<in> set_offending_flows G nP\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>snd ` f.\n                            \\<not> sinvar G (nP(i := \\<bottom>))\n 2. \\<And>otherbot.\n       \\<forall>G f nP i.\n          wf_graph G \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          i \\<in> snd ` f \\<longrightarrow>\n          \\<not> sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n       otherbot = \\<bottom>", "apply (metis default_secure offending_notevalD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>otherbot.\n       \\<forall>G f nP i.\n          wf_graph G \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          i \\<in> snd ` f \\<longrightarrow>\n          \\<not> sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n       otherbot = \\<bottom>", "apply(erule contrapos_pp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>otherbot.\n       otherbot \\<noteq> \\<bottom> \\<Longrightarrow>\n       \\<not> (\\<forall>G f nP i.\n                  wf_graph G \\<and>\n                  f \\<in> set_offending_flows G nP \\<and>\n                  i \\<in> snd ` f \\<longrightarrow>\n                  \\<not> sinvar G (nP(i := otherbot)))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>otherbot.\n       otherbot \\<noteq> \\<bottom> \\<Longrightarrow>\n       \\<exists>G.\n          wf_graph G \\<and>\n          (\\<exists>f nP.\n              f \\<in> set_offending_flows G nP \\<and>\n              (\\<exists>i\\<in>f. sinvar G (nP(snd i := otherbot))))", "apply(drule default_unique)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>otherbot.\n       \\<exists>G nP i F.\n          wf_graph G \\<and>\n          \\<not> sinvar G nP \\<and>\n          F \\<in> set_offending_flows G nP \\<and>\n          sinvar (delete_edges G F) nP \\<and>\n          (\\<not> True \\<longrightarrow>\n           i \\<in> fst ` F \\<and> sinvar G (nP(i := otherbot))) \\<and>\n          (True \\<longrightarrow>\n           i \\<in> snd ` F \\<and>\n           sinvar G (nP(i := otherbot))) \\<Longrightarrow>\n       \\<exists>G.\n          wf_graph G \\<and>\n          (\\<exists>f nP.\n              f \\<in> set_offending_flows G nP \\<and>\n              (\\<exists>i\\<in>f. sinvar G (nP(snd i := otherbot))))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>otherbot.\n       \\<exists>G.\n          wf_graph G \\<and>\n          (\\<exists>nP.\n              \\<not> sinvar G nP \\<and>\n              (\\<exists>i F.\n                  F \\<in> set_offending_flows G nP \\<and>\n                  sinvar (delete_edges G F) nP \\<and>\n                  i \\<in> snd ` F \\<and>\n                  sinvar G (nP(i := otherbot)))) \\<Longrightarrow>\n       \\<exists>G.\n          wf_graph G \\<and>\n          (\\<exists>f nP.\n              f \\<in> set_offending_flows G nP \\<and>\n              (\\<exists>i\\<in>f. sinvar G (nP(snd i := otherbot))))", "apply(blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma default_uniqueness_by_counterexample_IFS:\n  assumes \"(\\<forall>G F nP i. wf_graph G \\<and> F \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows sinvar G nP \\<and> i \\<in> snd` F \n                \\<longrightarrow> \\<not> sinvar G (nP(i := otherbot)))\"\n  and \"otherbot \\<noteq> default_value \\<Longrightarrow>\n    \\<exists>G nP i F. wf_graph G \\<and> \\<not> sinvar G nP \\<and> F \\<in> (SecurityInvariant_withOffendingFlows.set_offending_flows sinvar G nP) \\<and>\n       sinvar (delete_edges G F) nP \\<and>\n        i \\<in> snd ` F \\<and> sinvar G (nP(i := otherbot)) \"\n   shows \"otherbot = default_value\""], ["proof (prove)\ngoal (1 subgoal):\n 1. otherbot = default_value", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>G F nP i.\n     wf_graph G \\<and>\n     F \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows sinvar\n              G nP \\<and>\n     i \\<in> snd ` F \\<longrightarrow>\n     \\<not> sinvar G (nP(i := otherbot))\n  otherbot \\<noteq> default_value \\<Longrightarrow>\n  \\<exists>G nP i F.\n     wf_graph G \\<and>\n     \\<not> sinvar G nP \\<and>\n     F \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows sinvar\n              G nP \\<and>\n     sinvar (delete_edges G F) nP \\<and>\n     i \\<in> snd ` F \\<and> sinvar G (nP(i := otherbot))\n\ngoal (1 subgoal):\n 1. otherbot = default_value", "by blast"], ["", "subsection \\<open>Access Control Strategy (ACS)\\<close>"], ["", "locale SecurityInvariant_ACS = SecurityInvariant_preliminaries sinvar\n      for sinvar::\"('v::vertex) graph \\<Rightarrow> ('v::vertex \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n      +\n      fixes default_node_properties :: \"'a\" (\"\\<bottom>\") \n      assumes  default_secure_ACS:\n        \"\\<lbrakk> wf_graph G; f \\<in> set_offending_flows G nP \\<rbrakk> \\<Longrightarrow>\n          \\<forall>i \\<in> fst` f. \\<not> sinvar G (nP(i := \\<bottom>))\"\n      and\n      default_unique_ACS:\n      \"(\\<forall>G f nP i. wf_graph G \\<and> f \\<in> set_offending_flows G nP \\<and> i \\<in> fst` f \n                \\<longrightarrow> \\<not> sinvar G (nP(i := otherbot))) \\<Longrightarrow> otherbot = \\<bottom>\"\n      begin"], ["", "lemma default_unique_EX_notation: \"otherbot \\<noteq> \\<bottom> \\<Longrightarrow> \n          \\<exists> G nP i f. wf_graph G \\<and> \\<not> sinvar G nP \\<and> f \\<in> set_offending_flows G nP \\<and> \n           sinvar (delete_edges G f) nP \\<and>\n           (i \\<in> fst` f \\<and> sinvar G (nP(i := otherbot)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. otherbot \\<noteq> \\<bottom> \\<Longrightarrow>\n    \\<exists>G nP i f.\n       wf_graph G \\<and>\n       \\<not> sinvar G nP \\<and>\n       f \\<in> set_offending_flows G nP \\<and>\n       sinvar (delete_edges G f) nP \\<and>\n       i \\<in> fst ` f \\<and> sinvar G (nP(i := otherbot))", "apply(erule contrapos_pp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>G nP i f.\n       wf_graph G \\<and>\n       \\<not> sinvar G nP \\<and>\n       f \\<in> set_offending_flows G nP \\<and>\n       sinvar (delete_edges G f) nP \\<and>\n       i \\<in> fst ` f \\<and> sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n    \\<not> otherbot \\<noteq> \\<bottom>", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>G.\n       wf_graph G \\<longrightarrow>\n       (\\<forall>nP.\n           sinvar G nP \\<or>\n           (\\<forall>i f.\n               i \\<in> fst ` f \\<longrightarrow>\n               sinvar (delete_edges G f) nP \\<longrightarrow>\n               f \\<in> set_offending_flows G nP \\<longrightarrow>\n               \\<not> sinvar G (nP(i := otherbot)))) \\<Longrightarrow>\n    otherbot = \\<bottom>", "using default_unique_ACS SecurityInvariant_withOffendingFlows.valid_without_offending_flows offending_notevalD"], ["proof (prove)\nusing this:\n  \\<forall>G f nP i.\n     wf_graph G \\<and>\n     f \\<in> set_offending_flows G nP \\<and>\n     i \\<in> fst ` f \\<longrightarrow>\n     \\<not> sinvar G (nP(i := ?otherbot)) \\<Longrightarrow>\n  ?otherbot = \\<bottom>\n  ?F \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows ?sinvar\n            ?G ?nP \\<Longrightarrow>\n  ?sinvar (delete_edges ?G ?F) ?nP\n  ?F \\<in> set_offending_flows ?G ?nP \\<Longrightarrow> \\<not> sinvar ?G ?nP\n\ngoal (1 subgoal):\n 1. \\<forall>G.\n       wf_graph G \\<longrightarrow>\n       (\\<forall>nP.\n           sinvar G nP \\<or>\n           (\\<forall>i f.\n               i \\<in> fst ` f \\<longrightarrow>\n               sinvar (delete_edges G f) nP \\<longrightarrow>\n               f \\<in> set_offending_flows G nP \\<longrightarrow>\n               \\<not> sinvar G (nP(i := otherbot)))) \\<Longrightarrow>\n    otherbot = \\<bottom>", "by metis"], ["", "end"], ["", "sublocale SecurityInvariant_ACS \\<subseteq> SecurityInvariant where receiver_violation=False"], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant sinvar \\<bottom> False", "apply(unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>G nP F i.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP;\n        F \\<in> set_offending_flows G nP\\<rbrakk>\n       \\<Longrightarrow> (\\<not> False \\<longrightarrow>\n                          i \\<in> fst ` F \\<longrightarrow>\n                          \\<not> sinvar G (nP(i := \\<bottom>))) \\<and>\n                         (False \\<longrightarrow>\n                          i \\<in> snd ` F \\<longrightarrow>\n                          \\<not> sinvar G (nP(i := \\<bottom>)))\n 2. \\<And>otherbot.\n       otherbot \\<noteq> \\<bottom> \\<Longrightarrow>\n       \\<exists>G nP i F.\n          wf_graph G \\<and>\n          \\<not> sinvar G nP \\<and>\n          F \\<in> set_offending_flows G nP \\<and>\n          sinvar (delete_edges G F) nP \\<and>\n          (\\<not> False \\<longrightarrow>\n           i \\<in> fst ` F \\<and> sinvar G (nP(i := otherbot))) \\<and>\n          (False \\<longrightarrow>\n           i \\<in> snd ` F \\<and> sinvar G (nP(i := otherbot)))", "apply(simp add: default_secure_ACS)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>otherbot.\n       otherbot \\<noteq> \\<bottom> \\<Longrightarrow>\n       \\<exists>G nP i F.\n          wf_graph G \\<and>\n          \\<not> sinvar G nP \\<and>\n          F \\<in> set_offending_flows G nP \\<and>\n          sinvar (delete_edges G F) nP \\<and>\n          (\\<not> False \\<longrightarrow>\n           i \\<in> fst ` F \\<and> sinvar G (nP(i := otherbot))) \\<and>\n          (False \\<longrightarrow>\n           i \\<in> snd ` F \\<and> sinvar G (nP(i := otherbot)))", "apply(simp only: HOL.simp_thms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>otherbot.\n       otherbot \\<noteq> \\<bottom> \\<Longrightarrow>\n       \\<exists>G nP i F.\n          wf_graph G \\<and>\n          \\<not> sinvar G nP \\<and>\n          F \\<in> set_offending_flows G nP \\<and>\n          sinvar (delete_edges G F) nP \\<and>\n          i \\<in> fst ` F \\<and> sinvar G (nP(i := otherbot))", "apply(drule default_unique_EX_notation)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>otherbot.\n       \\<exists>G nP i f.\n          wf_graph G \\<and>\n          \\<not> sinvar G nP \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          sinvar (delete_edges G f) nP \\<and>\n          i \\<in> fst ` f \\<and>\n          sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n       \\<exists>G nP i F.\n          wf_graph G \\<and>\n          \\<not> sinvar G nP \\<and>\n          F \\<in> set_offending_flows G nP \\<and>\n          sinvar (delete_edges G F) nP \\<and>\n          i \\<in> fst ` F \\<and> sinvar G (nP(i := otherbot))", "apply(assumption)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*other direction*)"], ["", "locale SecurityInvariant_ACS_otherDirectrion = SecurityInvariant where receiver_violation=False"], ["", "sublocale SecurityInvariant_ACS_otherDirectrion \\<subseteq> SecurityInvariant_ACS"], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_ACS sinvar \\<bottom>", "apply(unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>G f nP.\n       \\<lbrakk>wf_graph G; f \\<in> set_offending_flows G nP\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>fst ` f.\n                            \\<not> sinvar G (nP(i := \\<bottom>))\n 2. \\<And>otherbot.\n       \\<forall>G f nP i.\n          wf_graph G \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          i \\<in> fst ` f \\<longrightarrow>\n          \\<not> sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n       otherbot = \\<bottom>", "apply (metis default_secure offending_notevalD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>otherbot.\n       \\<forall>G f nP i.\n          wf_graph G \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          i \\<in> fst ` f \\<longrightarrow>\n          \\<not> sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n       otherbot = \\<bottom>", "apply(erule contrapos_pp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>otherbot.\n       otherbot \\<noteq> \\<bottom> \\<Longrightarrow>\n       \\<not> (\\<forall>G f nP i.\n                  wf_graph G \\<and>\n                  f \\<in> set_offending_flows G nP \\<and>\n                  i \\<in> fst ` f \\<longrightarrow>\n                  \\<not> sinvar G (nP(i := otherbot)))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>otherbot.\n       otherbot \\<noteq> \\<bottom> \\<Longrightarrow>\n       \\<exists>G.\n          wf_graph G \\<and>\n          (\\<exists>f nP.\n              f \\<in> set_offending_flows G nP \\<and>\n              (\\<exists>i\\<in>f. sinvar G (nP(fst i := otherbot))))", "apply(drule default_unique)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>otherbot.\n       \\<exists>G nP i F.\n          wf_graph G \\<and>\n          \\<not> sinvar G nP \\<and>\n          F \\<in> set_offending_flows G nP \\<and>\n          sinvar (delete_edges G F) nP \\<and>\n          (\\<not> False \\<longrightarrow>\n           i \\<in> fst ` F \\<and> sinvar G (nP(i := otherbot))) \\<and>\n          (False \\<longrightarrow>\n           i \\<in> snd ` F \\<and>\n           sinvar G (nP(i := otherbot))) \\<Longrightarrow>\n       \\<exists>G.\n          wf_graph G \\<and>\n          (\\<exists>f nP.\n              f \\<in> set_offending_flows G nP \\<and>\n              (\\<exists>i\\<in>f. sinvar G (nP(fst i := otherbot))))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>otherbot.\n       \\<exists>G.\n          wf_graph G \\<and>\n          (\\<exists>nP.\n              \\<not> sinvar G nP \\<and>\n              (\\<exists>i F.\n                  F \\<in> set_offending_flows G nP \\<and>\n                  sinvar (delete_edges G F) nP \\<and>\n                  i \\<in> fst ` F \\<and>\n                  sinvar G (nP(i := otherbot)))) \\<Longrightarrow>\n       \\<exists>G.\n          wf_graph G \\<and>\n          (\\<exists>f nP.\n              f \\<in> set_offending_flows G nP \\<and>\n              (\\<exists>i\\<in>f. sinvar G (nP(fst i := otherbot))))", "apply(blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma default_uniqueness_by_counterexample_ACS:\n  assumes \"(\\<forall>G F nP i. wf_graph G \\<and> F \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows sinvar G nP \\<and> i \\<in> fst ` F \n                \\<longrightarrow> \\<not> sinvar G (nP(i := otherbot)))\"\n  and \"otherbot \\<noteq> default_value \\<Longrightarrow>\n    \\<exists>G nP i F. wf_graph G \\<and> \\<not> sinvar G nP \\<and> F \\<in> (SecurityInvariant_withOffendingFlows.set_offending_flows sinvar G nP) \\<and>\n       sinvar (delete_edges G F) nP \\<and>\n        i \\<in> fst ` F \\<and> sinvar G (nP(i := otherbot))\"\n  shows \"otherbot = default_value\""], ["proof (prove)\ngoal (1 subgoal):\n 1. otherbot = default_value", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>G F nP i.\n     wf_graph G \\<and>\n     F \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows sinvar\n              G nP \\<and>\n     i \\<in> fst ` F \\<longrightarrow>\n     \\<not> sinvar G (nP(i := otherbot))\n  otherbot \\<noteq> default_value \\<Longrightarrow>\n  \\<exists>G nP i F.\n     wf_graph G \\<and>\n     \\<not> sinvar G nP \\<and>\n     F \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows sinvar\n              G nP \\<and>\n     sinvar (delete_edges G F) nP \\<and>\n     i \\<in> fst ` F \\<and> sinvar G (nP(i := otherbot))\n\ngoal (1 subgoal):\n 1. otherbot = default_value", "by blast"], ["", "text\\<open>The sublocale relationships tell that the simplified @{const SecurityInvariant_ACS} and @{const SecurityInvariant_IFS} \n  assumptions suffice to do tho generic SecurityInvariant assumptions.\\<close>"], ["", "end"]]}