{"file_name": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification/vertex_example_simps.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification", "problem_names": ["lemma False_set: \"{(e1, e2). False} = {}\"", "lemma succ_tran_empty: \"(succ_tran \\<lparr>nodes = V, edges = {}\\<rparr> v) = {}\"", "lemma vertex_1_vertex_2_set_simp: \"{vertex_1, vertex_2, vertex_1, vertex_2} = {vertex_1, vertex_2}\"", "lemma unique_default_example1: \"succ_tran \\<lparr>nodes = {vertex_1, vertex_2}, edges = {(vertex_1, vertex_2)}\\<rparr> vertex_1 = {vertex_2}\"", "lemma unique_default_example2: \"succ_tran \\<lparr>nodes = {vertex_1, vertex_2}, edges = {(vertex_2, vertex_1)}\\<rparr> vertex_1 = {}\"", "lemma unique_default_example3: \"succ_tran \\<lparr>nodes = {vertex_1, vertex_2}, edges = {(vertex_2, vertex_1)}\\<rparr> vertex_2 = {vertex_1}\"", "lemma unique_default_example_simp1: \"{(e1, e2). e1 = vertex_1 \\<and> e2 = vertex_2 \\<and> (e1 = vertex_1 \\<longrightarrow> e2 \\<noteq> vertex_2)} = {}\"", "lemma unique_default_example_simp2: \"{(vertex_1, vertex_2)}\\<^sup>+ = {(vertex_1, vertex_2)}\"", "lemma unique_default_example_simp3: \"{(e1, e2). e1 = vertex_2 \\<and> e2 = vertex_1 \\<and> (e1 = vertex_2 \\<longrightarrow> e2 \\<noteq> vertex_1)} = {}\"", "lemma vertex_set_simp2: \"{vertex_2, vertex_1, vertex_2} = {vertex_1, vertex_2}\"", "lemma canAccessThis_simp1: \"canAccessThis \\<noteq> vertex_1 \\<Longrightarrow> succ_tran \\<lparr>nodes = {vertex_1, canAccessThis}, edges = {(vertex_1, canAccessThis)}\\<rparr> vertex_1 = {canAccessThis}\"", "lemma canAccessThis_simp2: \"canAccessThis \\<noteq> vertex_1 \\<Longrightarrow> succ_tran \\<lparr>nodes = {vertex_1, canAccessThis}, edges = {(vertex_1, canAccessThis)}\\<rparr> canAccessThis = {}\"", "lemma canAccessThis_simp3: \n  \"canAccessThis \\<noteq> vertex_1 \\<Longrightarrow> {(e1, e2). e1 = vertex_1 \\<and> e2 = canAccessThis \\<and> (e1 = vertex_1 \\<longrightarrow> e2 \\<noteq> canAccessThis)} = {}\"", "lemma canAccessThis_simp4: \n  \"canAccessThis \\<noteq> vertex_1 \\<Longrightarrow> {vertex_1, canAccessThis, vertex_1, canAccessThis} = {vertex_1, canAccessThis}\"", "lemmas example_simps = unique_default_example_simp1 unique_default_example2 unique_default_example3 \n    unique_default_example_simp2 unique_default_example1 succ_tran_empty vertex_1_vertex_2_set_simp\n    unique_default_example_simp3 vertex_set_simp2 canAccessThis_simp1 canAccessThis_simp2 canAccessThis_simp3\n    canAccessThis_simp4"], "translations": [["", "lemma False_set: \"{(e1, e2). False} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(e1, e2). False} = {}", "by blast"], ["", "lemma succ_tran_empty: \"(succ_tran \\<lparr>nodes = V, edges = {}\\<rparr> v) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ_tran \\<lparr>nodes = V, edges = {}\\<rparr> v = {}", "by(simp add: succ_tran_def)"], ["", "lemma vertex_1_vertex_2_set_simp: \"{vertex_1, vertex_2, vertex_1, vertex_2} = {vertex_1, vertex_2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {vertex_1, vertex_2, vertex_1, vertex_2} = {vertex_1, vertex_2}", "by blast"], ["", "lemma unique_default_example1: \"succ_tran \\<lparr>nodes = {vertex_1, vertex_2}, edges = {(vertex_1, vertex_2)}\\<rparr> vertex_1 = {vertex_2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ_tran\n     \\<lparr>nodes = {vertex_1, vertex_2},\n        edges = {(vertex_1, vertex_2)}\\<rparr>\n     vertex_1 =\n    {vertex_2}", "apply (simp add: succ_tran_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {e2. (vertex_1, e2) \\<in> {(vertex_1, vertex_2)}\\<^sup>+} = {vertex_2}", "by (metis (lifting, no_types) Collect_cong Range.intros Range_empty Range_insert mem_Collect_eq singleton_conv singleton_iff trancl.r_into_trancl trancl_range)"], ["", "lemma unique_default_example2: \"succ_tran \\<lparr>nodes = {vertex_1, vertex_2}, edges = {(vertex_2, vertex_1)}\\<rparr> vertex_1 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ_tran\n     \\<lparr>nodes = {vertex_1, vertex_2},\n        edges = {(vertex_2, vertex_1)}\\<rparr>\n     vertex_1 =\n    {}", "apply (simp add: succ_tran_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (vertex_1, x) \\<notin> {(vertex_2, vertex_1)}\\<^sup>+", "by (metis Domain.DomainI Domain_empty Domain_insert distinct_vertices12 singleton_iff trancl_domain)"], ["", "lemma unique_default_example3: \"succ_tran \\<lparr>nodes = {vertex_1, vertex_2}, edges = {(vertex_2, vertex_1)}\\<rparr> vertex_2 = {vertex_1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ_tran\n     \\<lparr>nodes = {vertex_1, vertex_2},\n        edges = {(vertex_2, vertex_1)}\\<rparr>\n     vertex_2 =\n    {vertex_1}", "apply (simp add: succ_tran_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {e2. (vertex_2, e2) \\<in> {(vertex_2, vertex_1)}\\<^sup>+} = {vertex_1}", "by (metis (lifting, no_types) Collect_cong Range.intros Range_empty Range_insert mem_Collect_eq singleton_conv singleton_iff trancl.r_into_trancl trancl_range)"], ["", "lemma unique_default_example_simp1: \"{(e1, e2). e1 = vertex_1 \\<and> e2 = vertex_2 \\<and> (e1 = vertex_1 \\<longrightarrow> e2 \\<noteq> vertex_2)} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(e1, e2).\n     e1 = vertex_1 \\<and>\n     e2 = vertex_2 \\<and>\n     (e1 = vertex_1 \\<longrightarrow> e2 \\<noteq> vertex_2)} =\n    {}", "by blast"], ["", "lemma unique_default_example_simp2: \"{(vertex_1, vertex_2)}\\<^sup>+ = {(vertex_1, vertex_2)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(vertex_1, vertex_2)}\\<^sup>+ = {(vertex_1, vertex_2)}", "apply(rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {(vertex_1, vertex_2)}\\<^sup>+ \\<subseteq> {(vertex_1, vertex_2)}\n 2. {(vertex_1, vertex_2)} \\<subseteq> {(vertex_1, vertex_2)}\\<^sup>+", "apply(rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {(vertex_1, vertex_2)}\\<^sup>+ \\<Longrightarrow>\n       x \\<in> {(vertex_1, vertex_2)}\n 2. {(vertex_1, vertex_2)} \\<subseteq> {(vertex_1, vertex_2)}\\<^sup>+", "apply(clarify)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> {(vertex_1, vertex_2)}\\<^sup>+;\n        (a, b) \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> a = vertex_1 \\<and> b = vertex_2\n 2. {(vertex_1, vertex_2)} \\<subseteq> {(vertex_1, vertex_2)}\\<^sup>+", "apply(rule_tac P=\"\\<lambda> a b. a = vertex_1 \\<and> b = vertex_2\" in trancl.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> {(vertex_1, vertex_2)}\\<^sup>+;\n        (a, b) \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> (?r9 a b)\\<^sup>+\n 2. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> {(vertex_1, vertex_2)}\\<^sup>+;\n        (a, b) \\<notin> {}; (aa, ba) \\<in> ?r9 a b\\<rbrakk>\n       \\<Longrightarrow> aa = vertex_1 \\<and> ba = vertex_2\n 3. \\<And>a b aa ba c.\n       \\<lbrakk>(a, b) \\<in> {(vertex_1, vertex_2)}\\<^sup>+;\n        (a, b) \\<notin> {}; (aa, ba) \\<in> (?r9 a b)\\<^sup>+;\n        aa = vertex_1 \\<and> ba = vertex_2; (ba, c) \\<in> ?r9 a b\\<rbrakk>\n       \\<Longrightarrow> aa = vertex_1 \\<and> c = vertex_2\n 4. {(vertex_1, vertex_2)} \\<subseteq> {(vertex_1, vertex_2)}\\<^sup>+", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unique_default_example_simp3: \"{(e1, e2). e1 = vertex_2 \\<and> e2 = vertex_1 \\<and> (e1 = vertex_2 \\<longrightarrow> e2 \\<noteq> vertex_1)} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(e1, e2).\n     e1 = vertex_2 \\<and>\n     e2 = vertex_1 \\<and>\n     (e1 = vertex_2 \\<longrightarrow> e2 \\<noteq> vertex_1)} =\n    {}", "by(blast)"], ["", "lemma vertex_set_simp2: \"{vertex_2, vertex_1, vertex_2} = {vertex_1, vertex_2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {vertex_2, vertex_1, vertex_2} = {vertex_1, vertex_2}", "by blast"], ["", "lemma canAccessThis_simp1: \"canAccessThis \\<noteq> vertex_1 \\<Longrightarrow> succ_tran \\<lparr>nodes = {vertex_1, canAccessThis}, edges = {(vertex_1, canAccessThis)}\\<rparr> vertex_1 = {canAccessThis}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canAccessThis \\<noteq> vertex_1 \\<Longrightarrow>\n    succ_tran\n     \\<lparr>nodes = {vertex_1, canAccessThis},\n        edges = {(vertex_1, canAccessThis)}\\<rparr>\n     vertex_1 =\n    {canAccessThis}", "apply (simp add: succ_tran_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. canAccessThis \\<noteq> vertex_1 \\<Longrightarrow>\n    {e2. (vertex_1, e2) \\<in> {(vertex_1, canAccessThis)}\\<^sup>+} =\n    {canAccessThis}", "by (metis (lifting, no_types) Collect_cong Range.intros Range_empty Range_insert mem_Collect_eq singleton_conv singleton_iff trancl.r_into_trancl trancl_range)"], ["", "lemma canAccessThis_simp2: \"canAccessThis \\<noteq> vertex_1 \\<Longrightarrow> succ_tran \\<lparr>nodes = {vertex_1, canAccessThis}, edges = {(vertex_1, canAccessThis)}\\<rparr> canAccessThis = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canAccessThis \\<noteq> vertex_1 \\<Longrightarrow>\n    succ_tran\n     \\<lparr>nodes = {vertex_1, canAccessThis},\n        edges = {(vertex_1, canAccessThis)}\\<rparr>\n     canAccessThis =\n    {}", "apply (simp add: succ_tran_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. canAccessThis \\<noteq> vertex_1 \\<Longrightarrow>\n    \\<forall>x.\n       (canAccessThis, x) \\<notin> {(vertex_1, canAccessThis)}\\<^sup>+", "by (metis Domain.DomainI Domain_empty Domain_insert singleton_iff trancl_domain)"], ["", "lemma canAccessThis_simp3: \n  \"canAccessThis \\<noteq> vertex_1 \\<Longrightarrow> {(e1, e2). e1 = vertex_1 \\<and> e2 = canAccessThis \\<and> (e1 = vertex_1 \\<longrightarrow> e2 \\<noteq> canAccessThis)} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canAccessThis \\<noteq> vertex_1 \\<Longrightarrow>\n    {(e1, e2).\n     e1 = vertex_1 \\<and>\n     e2 = canAccessThis \\<and>\n     (e1 = vertex_1 \\<longrightarrow> e2 \\<noteq> canAccessThis)} =\n    {}", "by blast"], ["", "lemma canAccessThis_simp4: \n  \"canAccessThis \\<noteq> vertex_1 \\<Longrightarrow> {vertex_1, canAccessThis, vertex_1, canAccessThis} = {vertex_1, canAccessThis}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canAccessThis \\<noteq> vertex_1 \\<Longrightarrow>\n    {vertex_1, canAccessThis, vertex_1, canAccessThis} =\n    {vertex_1, canAccessThis}", "by blast"], ["", "lemmas example_simps = unique_default_example_simp1 unique_default_example2 unique_default_example3 \n    unique_default_example_simp2 unique_default_example1 succ_tran_empty vertex_1_vertex_2_set_simp\n    unique_default_example_simp3 vertex_set_simp2 canAccessThis_simp1 canAccessThis_simp2 canAccessThis_simp3\n    canAccessThis_simp4"], ["", "(*>*)"], ["", "end"]]}