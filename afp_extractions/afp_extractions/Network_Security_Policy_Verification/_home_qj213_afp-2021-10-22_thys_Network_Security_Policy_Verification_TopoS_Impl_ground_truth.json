{"file_name": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification/TopoS_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification", "problem_names": ["lemma rembiflowdups_complete: \"\\<lbrakk> \\<forall>(s,r) \\<in> set x. (r,s) \\<in> set x \\<rbrakk> \\<Longrightarrow> set (rembiflowdups x) \\<union> set (backlinks (rembiflowdups x)) = set x\"", "lemma filter_for_biflows_correct: \"\\<forall>(s,r) \\<in> set (filter_for_biflows E). (r,s) \\<in> set (filter_for_biflows E)\"", "lemma filter_for_biflows_un_filter_for_uniflows: \"set (filter_for_biflows E) \\<union> set (filter_for_uniflows E) = set E\"", "lemma partition_by_biflows_correct: \"case partition_by_biflows E of (biflows, uniflows) \\<Rightarrow> set biflows \\<union> set (backlinks (biflows)) \\<union> set uniflows = set E\"", "lemma \"partition_by_biflows [(1::int, 1::int), (1,2), (2, 1), (1,3)] = ([(1, 1), (2, 1)], [(1, 3)])\""], "translations": [["", "lemma rembiflowdups_complete: \"\\<lbrakk> \\<forall>(s,r) \\<in> set x. (r,s) \\<in> set x \\<rbrakk> \\<Longrightarrow> set (rembiflowdups x) \\<union> set (backlinks (rembiflowdups x)) = set x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(s, r)\\<in>set x. (r, s) \\<in> set x \\<Longrightarrow>\n    set (rembiflowdups x) \\<union> set (backlinks (rembiflowdups x)) = set x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>(s, r)\\<in>set x. (r, s) \\<in> set x \\<Longrightarrow>\n    set (rembiflowdups x) \\<union> set (backlinks (rembiflowdups x))\n    \\<subseteq> set x\n 2. \\<forall>(s, r)\\<in>set x. (r, s) \\<in> set x \\<Longrightarrow>\n    set x\n    \\<subseteq> set (rembiflowdups x) \\<union>\n                set (backlinks (rembiflowdups x))", "assume a: \"\\<forall>(s,r) \\<in> set x. (r,s) \\<in> set x\""], ["proof (state)\nthis:\n  \\<forall>(s, r)\\<in>set x. (r, s) \\<in> set x\n\ngoal (2 subgoals):\n 1. \\<forall>(s, r)\\<in>set x. (r, s) \\<in> set x \\<Longrightarrow>\n    set (rembiflowdups x) \\<union> set (backlinks (rembiflowdups x))\n    \\<subseteq> set x\n 2. \\<forall>(s, r)\\<in>set x. (r, s) \\<in> set x \\<Longrightarrow>\n    set x\n    \\<subseteq> set (rembiflowdups x) \\<union>\n                set (backlinks (rembiflowdups x))", "have subset1: \"set (rembiflowdups x) \\<subseteq> set x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rembiflowdups x) \\<subseteq> set x", "apply(induction x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set (rembiflowdups []) \\<subseteq> set []\n 2. \\<And>a x.\n       set (rembiflowdups x) \\<subseteq> set x \\<Longrightarrow>\n       set (rembiflowdups (a # x)) \\<subseteq> set (a # x)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x.\n       set (rembiflowdups x) \\<subseteq> set x \\<Longrightarrow>\n       set (rembiflowdups (a # x)) \\<subseteq> set (a # x)", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x aa ba.\n       \\<lbrakk>set (rembiflowdups x) \\<subseteq> set x;\n        (aa, ba)\n        \\<in> set (if (a, b) \\<in> set x \\<or> (b, a) \\<in> set x\n                   then rembiflowdups x else (a, b) # rembiflowdups x);\n        (aa, ba) \\<notin> set x\\<rbrakk>\n       \\<Longrightarrow> aa = a \\<and> ba = b", "apply(simp split: if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x aa ba.\n       \\<lbrakk>(aa, ba) \\<notin> set x;\n        set (rembiflowdups x) \\<subseteq> set x;\n        (a, b) \\<in> set x \\<or> (b, a) \\<in> set x;\n        (aa, ba) \\<in> set (rembiflowdups x)\\<rbrakk>\n       \\<Longrightarrow> aa = a \\<and> ba = b\n 2. \\<And>a b x aa ba.\n       \\<lbrakk>(aa, ba) \\<notin> set x;\n        set (rembiflowdups x) \\<subseteq> set x;\n        (a, b) \\<notin> set x \\<and> (b, a) \\<notin> set x;\n        aa = a \\<and> ba = b \\<or>\n        (aa, ba) \\<in> set (rembiflowdups x)\\<rbrakk>\n       \\<Longrightarrow> aa = a \\<and> ba = b", "by(blast)+"], ["proof (state)\nthis:\n  set (rembiflowdups x) \\<subseteq> set x\n\ngoal (2 subgoals):\n 1. \\<forall>(s, r)\\<in>set x. (r, s) \\<in> set x \\<Longrightarrow>\n    set (rembiflowdups x) \\<union> set (backlinks (rembiflowdups x))\n    \\<subseteq> set x\n 2. \\<forall>(s, r)\\<in>set x. (r, s) \\<in> set x \\<Longrightarrow>\n    set x\n    \\<subseteq> set (rembiflowdups x) \\<union>\n                set (backlinks (rembiflowdups x))", "have set_backlinks_simp: \"\\<And> x. \\<forall>(s,r) \\<in> set x. (r,s) \\<in> set x \\<Longrightarrow> set (backlinks x) = set x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>(s, r)\\<in>set x. (r, s) \\<in> set x \\<Longrightarrow>\n       set (backlinks x) = set x", "apply(simp add: backlinks_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>xa\\<in>set x.\n          case xa of\n          (s, r) \\<Rightarrow> (r, s) \\<in> set x \\<Longrightarrow>\n       {(e2, e1). (e1, e2) \\<in> set x} = set x", "apply(rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<forall>xa\\<in>set x.\n          case xa of\n          (s, r) \\<Rightarrow> (r, s) \\<in> set x \\<Longrightarrow>\n       {(e2, e1). (e1, e2) \\<in> set x} \\<subseteq> set x\n 2. \\<And>x.\n       \\<forall>xa\\<in>set x.\n          case xa of\n          (s, r) \\<Rightarrow> (r, s) \\<in> set x \\<Longrightarrow>\n       set x \\<subseteq> {(e2, e1). (e1, e2) \\<in> set x}", "by fast+"], ["proof (state)\nthis:\n  \\<forall>(s, r)\\<in>set ?x. (r, s) \\<in> set ?x \\<Longrightarrow>\n  set (backlinks ?x) = set ?x\n\ngoal (2 subgoals):\n 1. \\<forall>(s, r)\\<in>set x. (r, s) \\<in> set x \\<Longrightarrow>\n    set (rembiflowdups x) \\<union> set (backlinks (rembiflowdups x))\n    \\<subseteq> set x\n 2. \\<forall>(s, r)\\<in>set x. (r, s) \\<in> set x \\<Longrightarrow>\n    set x\n    \\<subseteq> set (rembiflowdups x) \\<union>\n                set (backlinks (rembiflowdups x))", "have subset2: \"set (backlinks (rembiflowdups x)) \\<subseteq> set x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (backlinks (rembiflowdups x)) \\<subseteq> set x", "apply(subst set_backlinks_simp[OF a, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (backlinks (rembiflowdups x)) \\<subseteq> set (backlinks x)", "by(simp add: backlinks_subset subset1)"], ["proof (state)\nthis:\n  set (backlinks (rembiflowdups x)) \\<subseteq> set x\n\ngoal (2 subgoals):\n 1. \\<forall>(s, r)\\<in>set x. (r, s) \\<in> set x \\<Longrightarrow>\n    set (rembiflowdups x) \\<union> set (backlinks (rembiflowdups x))\n    \\<subseteq> set x\n 2. \\<forall>(s, r)\\<in>set x. (r, s) \\<in> set x \\<Longrightarrow>\n    set x\n    \\<subseteq> set (rembiflowdups x) \\<union>\n                set (backlinks (rembiflowdups x))", "from subset1 subset2"], ["proof (chain)\npicking this:\n  set (rembiflowdups x) \\<subseteq> set x\n  set (backlinks (rembiflowdups x)) \\<subseteq> set x", "show \"set (rembiflowdups x) \\<union> set (backlinks (rembiflowdups x)) \\<subseteq> set x\""], ["proof (prove)\nusing this:\n  set (rembiflowdups x) \\<subseteq> set x\n  set (backlinks (rembiflowdups x)) \\<subseteq> set x\n\ngoal (1 subgoal):\n 1. set (rembiflowdups x) \\<union> set (backlinks (rembiflowdups x))\n    \\<subseteq> set x", "by blast"], ["proof (state)\nthis:\n  set (rembiflowdups x) \\<union> set (backlinks (rembiflowdups x))\n  \\<subseteq> set x\n\ngoal (1 subgoal):\n 1. \\<forall>(s, r)\\<in>set x. (r, s) \\<in> set x \\<Longrightarrow>\n    set x\n    \\<subseteq> set (rembiflowdups x) \\<union>\n                set (backlinks (rembiflowdups x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>(s, r)\\<in>set x. (r, s) \\<in> set x \\<Longrightarrow>\n    set x\n    \\<subseteq> set (rembiflowdups x) \\<union>\n                set (backlinks (rembiflowdups x))", "show \"set x \\<subseteq> set (rembiflowdups x) \\<union> set (backlinks (rembiflowdups x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set x\n    \\<subseteq> set (rembiflowdups x) \\<union>\n                set (backlinks (rembiflowdups x))", "apply(rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set x \\<Longrightarrow>\n       xa \\<in> set (rembiflowdups x) \\<union>\n                set (backlinks (rembiflowdups x))", "apply(induction x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set [] \\<Longrightarrow>\n       x \\<in> set (rembiflowdups []) \\<union>\n               set (backlinks (rembiflowdups []))\n 2. \\<And>a x xa.\n       \\<lbrakk>\\<And>xa.\n                   xa \\<in> set x \\<Longrightarrow>\n                   xa \\<in> set (rembiflowdups x) \\<union>\n                            set (backlinks (rembiflowdups x));\n        xa \\<in> set (a # x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> set (rembiflowdups (a # x)) \\<union>\n                                  set (backlinks (rembiflowdups (a # x)))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x xa.\n       \\<lbrakk>\\<And>xa.\n                   xa \\<in> set x \\<Longrightarrow>\n                   xa \\<in> set (rembiflowdups x) \\<union>\n                            set (backlinks (rembiflowdups x));\n        xa \\<in> set (a # x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> set (rembiflowdups (a # x)) \\<union>\n                                  set (backlinks (rembiflowdups (a # x)))", "apply(rename_tac a as e)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as e.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set as \\<Longrightarrow>\n                   x \\<in> set (rembiflowdups as) \\<union>\n                           set (backlinks (rembiflowdups as));\n        e \\<in> set (a # as)\\<rbrakk>\n       \\<Longrightarrow> e \\<in> set (rembiflowdups (a # as)) \\<union>\n                                 set (backlinks (rembiflowdups (a # as)))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as e.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set as \\<Longrightarrow>\n                   x \\<in> set (rembiflowdups as) \\<or>\n                   x \\<in> set (backlinks (rembiflowdups as));\n        e = a \\<or> e \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> e \\<in> set (rembiflowdups (a # as)) \\<or>\n                         e \\<in> set (backlinks (rembiflowdups (a # as)))", "apply(erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as e.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set as \\<Longrightarrow>\n                   x \\<in> set (rembiflowdups as) \\<or>\n                   x \\<in> set (backlinks (rembiflowdups as));\n        e = a\\<rbrakk>\n       \\<Longrightarrow> e \\<in> set (rembiflowdups (a # as)) \\<or>\n                         e \\<in> set (backlinks (rembiflowdups (a # as)))\n 2. \\<And>a as e.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set as \\<Longrightarrow>\n                   x \\<in> set (rembiflowdups as) \\<or>\n                   x \\<in> set (backlinks (rembiflowdups as));\n        e \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> e \\<in> set (rembiflowdups (a # as)) \\<or>\n                         e \\<in> set (backlinks (rembiflowdups (a # as)))", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as e.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set as \\<Longrightarrow>\n                   x \\<in> set (rembiflowdups as) \\<or>\n                   x \\<in> set (backlinks (rembiflowdups as));\n        e = a\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set (rembiflowdups (a # as)) \\<or>\n                         a \\<in> set (backlinks (rembiflowdups (a # as)))\n 2. \\<And>a as e.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set as \\<Longrightarrow>\n                   x \\<in> set (rembiflowdups as) \\<or>\n                   x \\<in> set (backlinks (rembiflowdups as));\n        e \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> e \\<in> set (rembiflowdups (a # as)) \\<or>\n                         e \\<in> set (backlinks (rembiflowdups (a # as)))", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as e.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set as \\<Longrightarrow>\n                   x \\<in> set (rembiflowdups as) \\<or>\n                   x \\<in> set (backlinks (rembiflowdups as));\n        e \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> e \\<in> set (rembiflowdups (a # as)) \\<or>\n                         e \\<in> set (backlinks (rembiflowdups (a # as)))\n 2. \\<And>a as e.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set as \\<Longrightarrow>\n                   x \\<in> set (rembiflowdups as) \\<or>\n                   x \\<in> set (backlinks (rembiflowdups as));\n        e = a\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set (rembiflowdups (a # as)) \\<or>\n                         a \\<in> set (backlinks (rembiflowdups (a # as)))", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as e.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set as \\<Longrightarrow>\n                   x \\<in> set (rembiflowdups as) \\<or>\n                   x \\<in> set (backlinks (rembiflowdups as));\n        e = a\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set (rembiflowdups (a # as)) \\<or>\n                         a \\<in> set (backlinks (rembiflowdups (a # as)))", "apply(case_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as e aa b.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set as \\<Longrightarrow>\n                   x \\<in> set (rembiflowdups as) \\<or>\n                   x \\<in> set (backlinks (rembiflowdups as));\n        e = a; a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set (rembiflowdups (a # as)) \\<or>\n                         a \\<in> set (backlinks (rembiflowdups (a # as)))", "apply(rename_tac s r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as e s r.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set as \\<Longrightarrow>\n                   x \\<in> set (rembiflowdups as) \\<or>\n                   x \\<in> set (backlinks (rembiflowdups as));\n        e = a; a = (s, r)\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set (rembiflowdups (a # as)) \\<or>\n                         a \\<in> set (backlinks (rembiflowdups (a # as)))", "apply(case_tac \"(s,r) \\<notin> set as \\<and> (r,s) \\<notin> set as\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as e s r.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set as \\<Longrightarrow>\n                   x \\<in> set (rembiflowdups as) \\<or>\n                   x \\<in> set (backlinks (rembiflowdups as));\n        e = a; a = (s, r);\n        (s, r) \\<notin> set as \\<and> (r, s) \\<notin> set as\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set (rembiflowdups (a # as)) \\<or>\n                         a \\<in> set (backlinks (rembiflowdups (a # as)))\n 2. \\<And>a as e s r.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set as \\<Longrightarrow>\n                   x \\<in> set (rembiflowdups as) \\<or>\n                   x \\<in> set (backlinks (rembiflowdups as));\n        e = a; a = (s, r);\n        \\<not> ((s, r) \\<notin> set as \\<and>\n                (r, s) \\<notin> set as)\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set (rembiflowdups (a # as)) \\<or>\n                         a \\<in> set (backlinks (rembiflowdups (a # as)))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as e s r.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set as \\<Longrightarrow>\n                   x \\<in> set (rembiflowdups as) \\<or>\n                   x \\<in> set (backlinks (rembiflowdups as));\n        e = a; a = (s, r);\n        \\<not> ((s, r) \\<notin> set as \\<and>\n                (r, s) \\<notin> set as)\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set (rembiflowdups (a # as)) \\<or>\n                         a \\<in> set (backlinks (rembiflowdups (a # as)))", "apply(simp add: backlinks_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as e s r.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set as \\<Longrightarrow>\n                   x \\<in> set (rembiflowdups as) \\<or>\n                   (case x of\n                    (e2, e1) \\<Rightarrow>\n                      (e1, e2) \\<in> set (rembiflowdups as));\n        e = (s, r); a = (s, r);\n        (s, r) \\<in> set as \\<or> (r, s) \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> (s, r) \\<in> set (rembiflowdups as) \\<or>\n                         (r, s) \\<in> set (rembiflowdups as)", "by blast"], ["proof (state)\nthis:\n  set x\n  \\<subseteq> set (rembiflowdups x) \\<union>\n              set (backlinks (rembiflowdups x))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>only for prettyprinting\\<close>"], ["", "definition filter_for_biflows:: \"('a \\<times> 'a) list \\<Rightarrow> ('a \\<times> 'a) list\" where\n    \"filter_for_biflows E \\<equiv> [e \\<leftarrow> E. (snd e, fst e) \\<in> set E]\""], ["", "definition filter_for_uniflows:: \"('a \\<times> 'a) list \\<Rightarrow> ('a \\<times> 'a) list\" where\n    \"filter_for_uniflows E \\<equiv> [e \\<leftarrow> E. (snd e, fst e) \\<notin> set E]\""], ["", "lemma filter_for_biflows_correct: \"\\<forall>(s,r) \\<in> set (filter_for_biflows E). (r,s) \\<in> set (filter_for_biflows E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(s, r)\\<in>set (filter_for_biflows E).\n       (r, s) \\<in> set (filter_for_biflows E)", "unfolding filter_for_biflows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(s, r)\n             \\<in>set (filter (\\<lambda>e. (snd e, fst e) \\<in> set E) E).\n       (r, s) \\<in> set (filter (\\<lambda>e. (snd e, fst e) \\<in> set E) E)", "by(induction E, auto)"], ["", "lemma filter_for_biflows_un_filter_for_uniflows: \"set (filter_for_biflows E) \\<union> set (filter_for_uniflows E) = set E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (filter_for_biflows E) \\<union> set (filter_for_uniflows E) = set E", "apply(simp add: filter_for_biflows_def filter_for_uniflows_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> set E. (snd x, fst x) \\<in> set E} \\<union>\n    {x \\<in> set E. (snd x, fst x) \\<notin> set E} =\n    set E", "by blast"], ["", "definition partition_by_biflows :: \"('a \\<times> 'a) list \\<Rightarrow> (('a \\<times> 'a) list \\<times> ('a \\<times> 'a) list)\" where\n    \"partition_by_biflows E \\<equiv> (rembiflowdups (filter_for_biflows E), remdups (filter_for_uniflows E))\""], ["", "lemma partition_by_biflows_correct: \"case partition_by_biflows E of (biflows, uniflows) \\<Rightarrow> set biflows \\<union> set (backlinks (biflows)) \\<union> set uniflows = set E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case partition_by_biflows E of\n    (biflows, uniflows) \\<Rightarrow>\n      set biflows \\<union> set (backlinks biflows) \\<union> set uniflows =\n      set E", "apply(simp add: partition_by_biflows_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rembiflowdups (filter_for_biflows E)) \\<union>\n    set (backlinks (rembiflowdups (filter_for_biflows E))) \\<union>\n    set (filter_for_uniflows E) =\n    set E", "by(simp add: filter_for_biflows_un_filter_for_uniflows filter_for_biflows_correct rembiflowdups_complete)"], ["", "lemma \"partition_by_biflows [(1::int, 1::int), (1,2), (2, 1), (1,3)] = ([(1, 1), (2, 1)], [(1, 3)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_by_biflows [(1, 1), (1, 2), (2, 1), (1, 3)] =\n    ([(1, 1), (2, 1)], [(1, 3)])", "by eval"], ["", "ML\\<open>\n(*apply args to f. f ist best supplied using @{const_name \"name_of_function\"} *)\nfun apply_function (ctxt: Proof.context) (f: string) (args: term list) : term = \n  let\n    val _ = writeln (\"applying \"^f^\" to \" ^ (fold (fn t => fn acc => acc^(Pretty.string_of (Syntax.pretty_term (Config.put show_types true ctxt) t))^\" \") args \"\"));\n    (*val t_eval = Code_Evaluation.dynamic_value_strict thy t;*)\n    (* $ associates to the left, give f its arguments*)\n    val applied_untyped_uneval: term = list_comb (Const (f, dummyT), args);\n    val applied_uneval: term = Syntax.check_term ctxt applied_untyped_uneval;\n  in\n    applied_uneval |> Code_Evaluation.dynamic_value_strict ctxt\n  end;\n\n\n(*ctxt -> edges -> (biflows, uniflows)*)\nfun partition_by_biflows ctxt (t: term) : (term * term) = \n  apply_function ctxt @{const_name \"partition_by_biflows\"} [t] |> HOLogic.dest_prod\n\n\nlocal\n  fun get_tune_node_format (edges: term) : term -> string -> string =\n    if (fastype_of edges) = @{typ \"(string \\<times> string) list\"}\n    then\n      tune_string_vertex_format\n    else\n      Graphviz.default_tune_node_format;\n\n  fun evalutae_term ctxt (edges: term) : term = \n    case Code_Evaluation.dynamic_value ctxt edges\n      of SOME x => x\n      | NONE => raise TERM (\"could not evaluate\", []);\nin\n  fun visualize_edges ctxt (edges: term) (coloredges: (string * term) list) (graphviz_header: string) = \n    let\n      val _ = writeln(\"visualize_edges\");\n      val (biflows, uniflows) = partition_by_biflows ctxt edges;\n    in\n      Graphviz.visualize_graph_pretty ctxt (get_tune_node_format edges) ([\n      (\"\", uniflows),\n      (\"edge [dir=\\\"none\\\", color=\\\"#000000\\\"]\", biflows)] @ coloredges) (*dir=none, dir=both*)\n       graphviz_header\n    end\n\n  (*iterate over the edges in ML, useful for printing them in certain formats*)\n  fun iterate_edges_ML ctxt (edges: term) (all: (string*string) -> unit) (bi: (string*string) -> unit) (uni: (string*string) -> unit): unit =\n    let\n      val _ = writeln(\"iterate_edges_ML\");\n      val tune_node_format = (get_tune_node_format edges);\n      val node_to_string = Graphviz.node_to_string ctxt tune_node_format;\n      val evaluated_edges : term = evalutae_term ctxt edges;\n      val (biflows, uniflows) = partition_by_biflows ctxt evaluated_edges;\n    in\n      let\n        fun edge_to_list (es: term) : (term * term) list = es |> HOLogic.dest_list |> map HOLogic.dest_prod;\n        fun edge_to_string (es: (term * term) list) : (string * string) list =\n          map (fn (v1, v2) => (node_to_string v1, node_to_string v2)) es\n      in\n        edge_to_list evaluated_edges |> edge_to_string |> map all;\n        edge_to_list biflows |> edge_to_string |> map bi;\n        edge_to_list uniflows |> edge_to_string |> map uni;\n        ()\n      end\n      handle Subscript => writeln (\"Subscript Exception in iterate_edges_ML\")\n    end;\n    \nend\n\\<close>"], ["", "ML_val\\<open>\nlocal\n  val (biflows, uniflows) = partition_by_biflows @{context} @{term \"[(1::int, 1::int), (1,2), (2, 1), (1,3)]\"};\nin\n  val _ = Pretty.writeln (Syntax.pretty_term (Config.put show_types true @{context}) biflows);\n  val _ = Pretty.writeln (Syntax.pretty_term (Config.put show_types true @{context}) uniflows);\nend;\n\nval t = fastype_of @{term \"[(''x'', 2::nat)]\"};\n\n\\<close>"], ["", "ML_val\\<open>(*\nvisualize_edges @{context}  @{term \"[(1::int, 1::int), (1,2), (2, 1), (1,3)]\"} []; *)\n\\<close>"], ["", "definition internal_get_invariant_types_list:: \"'a SecurityInvariant list \\<Rightarrow> string list\" where\n  \"internal_get_invariant_types_list M \\<equiv> map implc_type M\""], ["", "definition internal_node_configs :: \"'a list_graph \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<times>'b) list\" where\n  \"internal_node_configs G config \\<equiv> zip (nodesL G) (map config (nodesL G))\""], ["", "ML \\<open>\nlocal\n  fun get_graphivz_node_desc ctxt (node_config: term): string =\n   let\n     val (node, config) = HOLogic.dest_prod node_config;\n     (*TODO: tune node format? There must be a better way ...*)\n     val tune_node_format = if (fastype_of node) = @{typ \"string\"}\n      then\n        tune_string_vertex_format\n      else\n        Graphviz.default_tune_node_format;\n     val node_str = Graphviz.node_to_string ctxt tune_node_format node;\n     val config_str = Graphviz.term_to_string_html ctxt config;\n   in\n     node_str^\"[label=<<TABLE BORDER=\\\"0\\\" CELLSPACING=\\\"0\\\"><TR><TD><FONT face=\\\"Verdana Bold\\\">\"^node_str^\"</FONT></TD></TR><TR><TD>\"^config_str^\"</TD></TR></TABLE>>]\\n\"\n   end;\nin\n  fun generate_graphviz_header ctxt (G: term) (configs: term): string =\n    let\n      val configlist: term list = apply_function ctxt @{const_name \"internal_node_configs\"} [G, configs] |> HOLogic.dest_list;\n    in\n      fold (fn c => fn acc => acc^get_graphivz_node_desc ctxt c) configlist \"\"\n    end;\nend;\n\n(* Convenience function. Use whenever possible!\n  M: security requirements, list\n  G: list_graph*)\nfun visualize_graph_header ctxt (M: term) (G: term) (Config: term): unit = \n  let\n    val wf_list_graph = apply_function ctxt @{const_name \"wf_list_graph\"} [G];\n    val all_fulfilled = apply_function ctxt @{const_name \"all_security_requirements_fulfilled\"} [M, G];\n    val edges = apply_function ctxt @{const_name \"edgesL\"} [G];\n    val invariants = apply_function ctxt @{const_name \"internal_get_invariant_types_list\"} [M];\n    val _ = writeln(\"Invariants:\" ^ Pretty.string_of (Syntax.pretty_term ctxt invariants));\n    val header = if Config = @{term \"[]\"} then \"#header\" else generate_graphviz_header ctxt G Config;\n  in\n    if wf_list_graph = @{term \"False\"} then\n      error (\"The supplied graph is syntactically invalid. Check wf_list_graph.\")\n    else if all_fulfilled = @{term \"False\"} then\n      (let\n        val offending = apply_function ctxt @{const_name \"implc_get_offending_flows\"} [M, G];\n        val offending_flat = apply_function ctxt @{const_name \"List.remdups\"} [apply_function ctxt @{const_name \"List.concat\"} [offending]];\n        val offending_debug = apply_function ctxt @{const_name print_offending_flows_debug} [M, G];\n      in\n       writeln(\"offending flows:\");\n       Pretty.writeln (Syntax.pretty_term ctxt offending);\n       pretty_assoclist ctxt \"Offending flows per invariant:\\n\" offending_debug;\n       visualize_edges ctxt edges [(\"edge [dir=\\\"arrow\\\", style=dashed, color=\\\"#FF0000\\\", constraint=false]\", offending_flat)] header; \n      () end)\n    else if all_fulfilled <> @{term \"True\"} then raise ERROR \"all_fulfilled neither False nor True\" else (\n       writeln(\"All valid:\");\n       visualize_edges ctxt edges [] header; \n      ())\n  end;\n\n\nfun visualize_graph ctxt (M: term) (G: term): unit = visualize_graph_header ctxt M G @{term \"[]\"};\n\\<close>"], ["", "end"]]}