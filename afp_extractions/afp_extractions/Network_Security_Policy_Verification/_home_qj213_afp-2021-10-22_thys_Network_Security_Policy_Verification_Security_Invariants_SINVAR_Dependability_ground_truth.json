{"file_name": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification/Security_Invariants/SINVAR_Dependability.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification", "problem_names": ["theorem sinvar_edges_nodes_iff: \"wf_graph G \\<Longrightarrow> \n    sinvar_nodes G nP = sinvar G nP\"", "lemma num_reachable_le_nodes: \"\\<lbrakk> wf_graph G \\<rbrakk> \\<Longrightarrow> num_reachable G v \\<le> card (nodes G)\"", "lemma \"\\<lbrakk> wf_graph G; \\<forall>v \\<in> nodes G. nP v \\<ge> card (nodes G) \\<rbrakk> \\<Longrightarrow> sinvar G nP\"", "lemma dependability_fix_nP_valid: \"\\<lbrakk> wf_graph G \\<rbrakk> \\<Longrightarrow> sinvar G (dependability_fix_nP G nP)\"", "lemma dependability_fix_nP_minimal_solution: \"\\<lbrakk> wf_graph G; \\<exists> v \\<in> nodes G. (nP v) < (dependability_fix_nP G (\\<lambda>_. 0)) v \\<rbrakk> \\<Longrightarrow> \\<not> sinvar G nP\"", "lemma sinvar_mono: \"SecurityInvariant_withOffendingFlows.sinvar_mono sinvar\"", "lemma TopoS_Dependability: \"SecurityInvariant sinvar default_node_properties receiver_violation\""], "translations": [["", "theorem sinvar_edges_nodes_iff: \"wf_graph G \\<Longrightarrow> \n    sinvar_nodes G nP = sinvar G nP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> sinvar_nodes G nP = sinvar G nP", "proof(unfold sinvar_nodes.simps sinvar.simps, rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_graph G;\n     \\<forall>v\\<in>nodes G. num_reachable G v \\<le> nP v\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(e1, e2)\\<in>edges G.\n                         num_reachable G e1 \\<le> nP e1\n 2. \\<lbrakk>wf_graph G;\n     \\<forall>(e1, e2)\\<in>edges G. num_reachable G e1 \\<le> nP e1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>nodes G. num_reachable G v \\<le> nP v", "assume a1: \"wf_graph G\"\n      and  a2: \"\\<forall>v\\<in>nodes G. num_reachable G v \\<le> nP v\""], ["proof (state)\nthis:\n  wf_graph G\n  \\<forall>v\\<in>nodes G. num_reachable G v \\<le> nP v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_graph G;\n     \\<forall>v\\<in>nodes G. num_reachable G v \\<le> nP v\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(e1, e2)\\<in>edges G.\n                         num_reachable G e1 \\<le> nP e1\n 2. \\<lbrakk>wf_graph G;\n     \\<forall>(e1, e2)\\<in>edges G. num_reachable G e1 \\<le> nP e1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>nodes G. num_reachable G v \\<le> nP v", "from a1[simplified wf_graph_def]"], ["proof (chain)\npicking this:\n  (fst ` edges G \\<subseteq> nodes G \\<and>\n   snd ` edges G \\<subseteq> nodes G) \\<and>\n  finite (edges G) \\<and> finite (nodes G)", "have f1: \"fst ` edges G \\<subseteq> nodes G\""], ["proof (prove)\nusing this:\n  (fst ` edges G \\<subseteq> nodes G \\<and>\n   snd ` edges G \\<subseteq> nodes G) \\<and>\n  finite (edges G) \\<and> finite (nodes G)\n\ngoal (1 subgoal):\n 1. fst ` edges G \\<subseteq> nodes G", "by simp"], ["proof (state)\nthis:\n  fst ` edges G \\<subseteq> nodes G\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_graph G;\n     \\<forall>v\\<in>nodes G. num_reachable G v \\<le> nP v\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(e1, e2)\\<in>edges G.\n                         num_reachable G e1 \\<le> nP e1\n 2. \\<lbrakk>wf_graph G;\n     \\<forall>(e1, e2)\\<in>edges G. num_reachable G e1 \\<le> nP e1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>nodes G. num_reachable G v \\<le> nP v", "from f1 a2"], ["proof (chain)\npicking this:\n  fst ` edges G \\<subseteq> nodes G\n  \\<forall>v\\<in>nodes G. num_reachable G v \\<le> nP v", "have \"\\<forall>v \\<in> (fst ` edges G). num_reachable G v \\<le> nP v\""], ["proof (prove)\nusing this:\n  fst ` edges G \\<subseteq> nodes G\n  \\<forall>v\\<in>nodes G. num_reachable G v \\<le> nP v\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>fst ` edges G. num_reachable G v \\<le> nP v", "by auto"], ["proof (state)\nthis:\n  \\<forall>v\\<in>fst ` edges G. num_reachable G v \\<le> nP v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_graph G;\n     \\<forall>v\\<in>nodes G. num_reachable G v \\<le> nP v\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(e1, e2)\\<in>edges G.\n                         num_reachable G e1 \\<le> nP e1\n 2. \\<lbrakk>wf_graph G;\n     \\<forall>(e1, e2)\\<in>edges G. num_reachable G e1 \\<le> nP e1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>nodes G. num_reachable G v \\<le> nP v", "thus \"\\<forall>(e1, _) \\<in> edges G. num_reachable G e1 \\<le> nP e1\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>fst ` edges G. num_reachable G v \\<le> nP v\n\ngoal (1 subgoal):\n 1. \\<forall>(e1, uu_)\\<in>edges G. num_reachable G e1 \\<le> nP e1", "by auto"], ["proof (state)\nthis:\n  \\<forall>(e1, uu_)\\<in>edges G. num_reachable G e1 \\<le> nP e1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G;\n     \\<forall>(e1, e2)\\<in>edges G. num_reachable G e1 \\<le> nP e1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>nodes G. num_reachable G v \\<le> nP v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G;\n     \\<forall>(e1, e2)\\<in>edges G. num_reachable G e1 \\<le> nP e1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>nodes G. num_reachable G v \\<le> nP v", "assume a1: \"wf_graph G\"\n      and  a2: \"\\<forall>(e1, _)\\<in>edges G. num_reachable G e1 \\<le> nP e1\""], ["proof (state)\nthis:\n  wf_graph G\n  \\<forall>(e1, uu_)\\<in>edges G. num_reachable G e1 \\<le> nP e1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G;\n     \\<forall>(e1, e2)\\<in>edges G. num_reachable G e1 \\<le> nP e1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>nodes G. num_reachable G v \\<le> nP v", "from a2"], ["proof (chain)\npicking this:\n  \\<forall>(e1, uu_)\\<in>edges G. num_reachable G e1 \\<le> nP e1", "have g1: \"\\<forall> v \\<in> (fst ` edges G). num_reachable G v \\<le> nP v\""], ["proof (prove)\nusing this:\n  \\<forall>(e1, uu_)\\<in>edges G. num_reachable G e1 \\<le> nP e1\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>fst ` edges G. num_reachable G v \\<le> nP v", "by auto"], ["proof (state)\nthis:\n  \\<forall>v\\<in>fst ` edges G. num_reachable G v \\<le> nP v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G;\n     \\<forall>(e1, e2)\\<in>edges G. num_reachable G e1 \\<le> nP e1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>nodes G. num_reachable G v \\<le> nP v", "from FiniteGraph.succ_tran_empty[OF a1] num_reachable_zero_iff[OF a1, symmetric]"], ["proof (chain)\npicking this:\n  ?v \\<notin> fst ` edges G \\<Longrightarrow> succ_tran G ?v = {}\n  (succ_tran G ?v = {}) = (num_reachable G ?v = 0)", "have g2: \"\\<forall> v. v \\<notin> (fst ` edges G) \\<longrightarrow> num_reachable G v \\<le> nP v\""], ["proof (prove)\nusing this:\n  ?v \\<notin> fst ` edges G \\<Longrightarrow> succ_tran G ?v = {}\n  (succ_tran G ?v = {}) = (num_reachable G ?v = 0)\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       v \\<notin> fst ` edges G \\<longrightarrow>\n       num_reachable G v \\<le> nP v", "by (metis le0)"], ["proof (state)\nthis:\n  \\<forall>v.\n     v \\<notin> fst ` edges G \\<longrightarrow> num_reachable G v \\<le> nP v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G;\n     \\<forall>(e1, e2)\\<in>edges G. num_reachable G e1 \\<le> nP e1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>nodes G. num_reachable G v \\<le> nP v", "from g1 g2"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>fst ` edges G. num_reachable G v \\<le> nP v\n  \\<forall>v.\n     v \\<notin> fst ` edges G \\<longrightarrow> num_reachable G v \\<le> nP v", "show \"\\<forall>v\\<in>nodes G. num_reachable G v \\<le> nP v\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>fst ` edges G. num_reachable G v \\<le> nP v\n  \\<forall>v.\n     v \\<notin> fst ` edges G \\<longrightarrow> num_reachable G v \\<le> nP v\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>nodes G. num_reachable G v \\<le> nP v", "by metis"], ["proof (state)\nthis:\n  \\<forall>v\\<in>nodes G. num_reachable G v \\<le> nP v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma num_reachable_le_nodes: \"\\<lbrakk> wf_graph G \\<rbrakk> \\<Longrightarrow> num_reachable G v \\<le> card (nodes G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> num_reachable G v \\<le> card (nodes G)", "unfolding num_reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> card (succ_tran G v) \\<le> card (nodes G)", "using succ_tran_subseteq_nodes card_seteq nat_le_linear wf_graph.finiteV"], ["proof (prove)\nusing this:\n  wf_graph ?G \\<Longrightarrow> succ_tran ?G ?v \\<subseteq> nodes ?G\n  \\<lbrakk>finite ?B; ?A \\<subseteq> ?B; card ?B \\<le> card ?A\\<rbrakk>\n  \\<Longrightarrow> ?A = ?B\n  ?m \\<le> ?n \\<or> ?n \\<le> ?m\n  wf_graph ?G \\<Longrightarrow> finite (nodes ?G)\n\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> card (succ_tran G v) \\<le> card (nodes G)", "by metis"], ["", "text\\<open>nP is valid if all dependability level are greater equal the total number of nodes in the graph\\<close>"], ["", "lemma \"\\<lbrakk> wf_graph G; \\<forall>v \\<in> nodes G. nP v \\<ge> card (nodes G) \\<rbrakk> \\<Longrightarrow> sinvar G nP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G;\n     \\<forall>v\\<in>nodes G. card (nodes G) \\<le> nP v\\<rbrakk>\n    \\<Longrightarrow> sinvar G nP", "apply(subst sinvar_edges_nodes_iff[symmetric], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G;\n     \\<forall>v\\<in>nodes G. card (nodes G) \\<le> nP v\\<rbrakk>\n    \\<Longrightarrow> sinvar_nodes G nP", "apply(simp add:)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G;\n     \\<forall>v\\<in>nodes G. card (nodes G) \\<le> nP v\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>nodes G. num_reachable G v \\<le> nP v", "using num_reachable_le_nodes"], ["proof (prove)\nusing this:\n  wf_graph ?G \\<Longrightarrow> num_reachable ?G ?v \\<le> card (nodes ?G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G;\n     \\<forall>v\\<in>nodes G. card (nodes G) \\<le> nP v\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>nodes G. num_reachable G v \\<le> nP v", "by (metis le_trans)"], ["", "text\\<open>Generate a valid configuration to start from:\\<close>"], ["", "text\\<open>Takes arbitrary configuration, returns a valid one\\<close>"], ["", "fun dependability_fix_nP :: \"'v graph \\<Rightarrow> ('v \\<Rightarrow> dependability_level) \\<Rightarrow> ('v \\<Rightarrow> dependability_level)\" where\n      \"dependability_fix_nP G nP = (\\<lambda>v. if num_reachable G v \\<le> (nP v) then (nP v) else num_reachable G v)\""], ["", "text\\<open>@{const dependability_fix_nP} always gives you a valid solution\\<close>"], ["", "lemma dependability_fix_nP_valid: \"\\<lbrakk> wf_graph G \\<rbrakk> \\<Longrightarrow> sinvar G (dependability_fix_nP G nP)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> sinvar G (dependability_fix_nP G nP)", "by(subst sinvar_edges_nodes_iff[symmetric], simp_all)"], ["", "text\\<open>furthermore, it gives you a minimal solution, i.e. if someone supplies a configuration with a value lower than\n          calculated by @{const dependability_fix_nP}, this is invalid!\\<close>"], ["", "lemma dependability_fix_nP_minimal_solution: \"\\<lbrakk> wf_graph G; \\<exists> v \\<in> nodes G. (nP v) < (dependability_fix_nP G (\\<lambda>_. 0)) v \\<rbrakk> \\<Longrightarrow> \\<not> sinvar G nP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G;\n     \\<exists>v\\<in>nodes G.\n        nP v < dependability_fix_nP G (\\<lambda>_. 0) v\\<rbrakk>\n    \\<Longrightarrow> \\<not> sinvar G nP", "apply(subst sinvar_edges_nodes_iff[symmetric], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G;\n     \\<exists>v\\<in>nodes G.\n        nP v < dependability_fix_nP G (\\<lambda>_. 0) v\\<rbrakk>\n    \\<Longrightarrow> \\<not> sinvar_nodes G nP", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G;\n     \\<exists>v\\<in>nodes G. nP v < num_reachable G v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<in>nodes G.\n                         \\<not> num_reachable G v \\<le> nP v", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>wf_graph G; v \\<in> nodes G;\n        nP v < num_reachable G v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<in>nodes G.\n                            \\<not> num_reachable G v \\<le> nP v", "apply(rule_tac x=\"v\" in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>wf_graph G; v \\<in> nodes G;\n        nP v < num_reachable G v\\<rbrakk>\n       \\<Longrightarrow> \\<not> num_reachable G v \\<le> nP v\n 2. \\<And>v.\n       \\<lbrakk>wf_graph G; v \\<in> nodes G;\n        nP v < num_reachable G v\\<rbrakk>\n       \\<Longrightarrow> v \\<in> nodes G", "apply(simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*\nlemma card_less_equal_trancl: \"finite A \\<Longrightarrow> card {e2. (aa, e2) \\<in> (A - X)\\<^sup>+} \\<le> card {e2. (aa, e2) \\<in> (A)\\<^sup>+}\"\napply(subgoal_tac \"{e2. (aa, e2) \\<in> (A - X)\\<^sup>+} \\<subseteq> {e2. (aa, e2) \\<in> (A)\\<^sup>+}\")\napply(rule card_mono)\ndefer\napply(simp)\napply (metis (lifting) Collect_mono Diff_subset trancl_mono)\nby (metis (lifting) Range_iff finite_Range mem_Collect_eq rev_finite_subset subsetI trancl_range)\n*)"], ["", "lemma sinvar_mono: \"SecurityInvariant_withOffendingFlows.sinvar_mono sinvar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.sinvar_mono sinvar", "apply(rule_tac SecurityInvariant_withOffendingFlows.sinvar_mono_I_proofrule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>nP G.\n       sinvar G nP = (\\<forall>(e1, e2)\\<in>edges G. ?P e1 e2 nP G)\n 2. \\<forall>nP e1 e2 N E' E.\n       wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n       (e1, e2) \\<in> E \\<and>\n       E' \\<subseteq> E \\<and>\n       ?P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr> \\<longrightarrow>\n       ?P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nP e1 e2 N E' a b E.\n       \\<lbrakk>(a, b) \\<in> E';\n        wf_graph \\<lparr>nodes = N, edges = E\\<rparr>; (e1, e2) \\<in> E;\n        E' \\<subseteq> E;\n        \\<forall>x\\<in>E.\n           case x of\n           (e1, e2) \\<Rightarrow>\n             num_reachable \\<lparr>nodes = N, edges = E\\<rparr> e1\n             \\<le> nP e1\\<rbrakk>\n       \\<Longrightarrow> num_reachable \\<lparr>nodes = N, edges = E'\\<rparr>\n                          a\n                         \\<le> nP a", "(*TODO: auto in the midddle*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nP e1 e2 N E' a b E.\n       \\<lbrakk>(a, b) \\<in> E';\n        wf_graph \\<lparr>nodes = N, edges = E\\<rparr>; (e1, e2) \\<in> E;\n        E' \\<subseteq> E;\n        \\<forall>x\\<in>E.\n           case x of\n           (e1, e2) \\<Rightarrow>\n             num_reachable \\<lparr>nodes = N, edges = E\\<rparr> e1\n             \\<le> nP e1\\<rbrakk>\n       \\<Longrightarrow> num_reachable \\<lparr>nodes = N, edges = E'\\<rparr>\n                          a\n                         \\<le> nP a", "apply(rename_tac nP e1 e2 N E' e1' e2' E)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nP e1 e2 N E' e1' e2' E.\n       \\<lbrakk>(e1', e2') \\<in> E';\n        wf_graph \\<lparr>nodes = N, edges = E\\<rparr>; (e1, e2) \\<in> E;\n        E' \\<subseteq> E;\n        \\<forall>x\\<in>E.\n           case x of\n           (e1, e2) \\<Rightarrow>\n             num_reachable \\<lparr>nodes = N, edges = E\\<rparr> e1\n             \\<le> nP e1\\<rbrakk>\n       \\<Longrightarrow> num_reachable \\<lparr>nodes = N, edges = E'\\<rparr>\n                          e1'\n                         \\<le> nP e1'", "apply(drule_tac E'=\"E'\" and v=\"e1'\" in num_reachable_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nP e1 e2 N E' e1' e2' E.\n       \\<lbrakk>(e1', e2') \\<in> E'; (e1, e2) \\<in> E; E' \\<subseteq> E;\n        \\<forall>x\\<in>E.\n           case x of\n           (e1, e2) \\<Rightarrow>\n             num_reachable \\<lparr>nodes = N, edges = E\\<rparr> e1\n             \\<le> nP e1\\<rbrakk>\n       \\<Longrightarrow> E' \\<subseteq> E\n 2. \\<And>nP e1 e2 N E' e1' e2' E.\n       \\<lbrakk>(e1', e2') \\<in> E'; (e1, e2) \\<in> E; E' \\<subseteq> E;\n        \\<forall>x\\<in>E.\n           case x of\n           (e1, e2) \\<Rightarrow>\n             num_reachable \\<lparr>nodes = N, edges = E\\<rparr> e1\n             \\<le> nP e1;\n        num_reachable \\<lparr>nodes = N, edges = E'\\<rparr> e1'\n        \\<le> num_reachable \\<lparr>nodes = N, edges = E\\<rparr>\n               e1'\\<rbrakk>\n       \\<Longrightarrow> num_reachable \\<lparr>nodes = N, edges = E'\\<rparr>\n                          e1'\n                         \\<le> nP e1'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nP e1 e2 N E' e1' e2' E.\n       \\<lbrakk>(e1', e2') \\<in> E'; (e1, e2) \\<in> E; E' \\<subseteq> E;\n        \\<forall>x\\<in>E.\n           case x of\n           (e1, e2) \\<Rightarrow>\n             num_reachable \\<lparr>nodes = N, edges = E\\<rparr> e1\n             \\<le> nP e1;\n        num_reachable \\<lparr>nodes = N, edges = E'\\<rparr> e1'\n        \\<le> num_reachable \\<lparr>nodes = N, edges = E\\<rparr>\n               e1'\\<rbrakk>\n       \\<Longrightarrow> num_reachable \\<lparr>nodes = N, edges = E'\\<rparr>\n                          e1'\n                         \\<le> nP e1'", "apply(subgoal_tac \"(e1', e2') \\<in> E\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nP e1 e2 N E' e1' e2' E.\n       \\<lbrakk>(e1', e2') \\<in> E'; (e1, e2) \\<in> E; E' \\<subseteq> E;\n        \\<forall>x\\<in>E.\n           case x of\n           (e1, e2) \\<Rightarrow>\n             num_reachable \\<lparr>nodes = N, edges = E\\<rparr> e1\n             \\<le> nP e1;\n        num_reachable \\<lparr>nodes = N, edges = E'\\<rparr> e1'\n        \\<le> num_reachable \\<lparr>nodes = N, edges = E\\<rparr> e1';\n        (e1', e2') \\<in> E\\<rbrakk>\n       \\<Longrightarrow> num_reachable \\<lparr>nodes = N, edges = E'\\<rparr>\n                          e1'\n                         \\<le> nP e1'\n 2. \\<And>nP e1 e2 N E' e1' e2' E.\n       \\<lbrakk>(e1', e2') \\<in> E'; (e1, e2) \\<in> E; E' \\<subseteq> E;\n        \\<forall>x\\<in>E.\n           case x of\n           (e1, e2) \\<Rightarrow>\n             num_reachable \\<lparr>nodes = N, edges = E\\<rparr> e1\n             \\<le> nP e1;\n        num_reachable \\<lparr>nodes = N, edges = E'\\<rparr> e1'\n        \\<le> num_reachable \\<lparr>nodes = N, edges = E\\<rparr>\n               e1'\\<rbrakk>\n       \\<Longrightarrow> (e1', e2') \\<in> E", "apply(force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nP e1 e2 N E' e1' e2' E.\n       \\<lbrakk>(e1', e2') \\<in> E'; (e1, e2) \\<in> E; E' \\<subseteq> E;\n        \\<forall>x\\<in>E.\n           case x of\n           (e1, e2) \\<Rightarrow>\n             num_reachable \\<lparr>nodes = N, edges = E\\<rparr> e1\n             \\<le> nP e1;\n        num_reachable \\<lparr>nodes = N, edges = E'\\<rparr> e1'\n        \\<le> num_reachable \\<lparr>nodes = N, edges = E\\<rparr>\n               e1'\\<rbrakk>\n       \\<Longrightarrow> (e1', e2') \\<in> E", "apply(blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation SecurityInvariant_preliminaries\nwhere sinvar = sinvar"], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_preliminaries sinvar", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G nP.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.set_offending_flows\n                          sinvar G nP \\<noteq>\n                         {}\n 2. \\<And>N E E' nP.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n 3. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows sinvar ff G\n         nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (ff \\<union> f') G nP", "apply(frule_tac finite_distinct_list[OF wf_graph.finiteE])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G nP.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP;\n        \\<exists>xs. set xs = edges G \\<and> distinct xs\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.set_offending_flows\n                          sinvar G nP \\<noteq>\n                         {}\n 2. \\<And>N E E' nP.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n 3. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows sinvar ff G\n         nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (ff \\<union> f') G nP", "apply(erule_tac exE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G nP xs.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP;\n        set xs = edges G \\<and> distinct xs\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.set_offending_flows\n                          sinvar G nP \\<noteq>\n                         {}\n 2. \\<And>N E E' nP.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n 3. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows sinvar ff G\n         nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (ff \\<union> f') G nP", "apply(rename_tac list_edges)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G nP list_edges.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP;\n        set list_edges = edges G \\<and> distinct list_edges\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.set_offending_flows\n                          sinvar G nP \\<noteq>\n                         {}\n 2. \\<And>N E E' nP.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n 3. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows sinvar ff G\n         nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (ff \\<union> f') G nP", "apply(rule_tac ff=\"list_edges\" in SecurityInvariant_withOffendingFlows.mono_imp_set_offending_flows_not_empty[OF sinvar_mono])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>G nP list_edges.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP;\n        set list_edges = edges G \\<and> distinct list_edges\\<rbrakk>\n       \\<Longrightarrow> wf_graph G\n 2. \\<And>G nP list_edges.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP;\n        set list_edges = edges G \\<and> distinct list_edges\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (set list_edges) G nP\n 3. \\<And>G nP list_edges.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP;\n        set list_edges = edges G \\<and> distinct list_edges\\<rbrakk>\n       \\<Longrightarrow> set list_edges \\<subseteq> edges G\n 4. \\<And>G nP list_edges.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP;\n        set list_edges = edges G \\<and> distinct list_edges\\<rbrakk>\n       \\<Longrightarrow> distinct list_edges\n 5. \\<And>N E E' nP.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n 6. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows sinvar ff G\n         nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (ff \\<union> f') G nP", "apply(auto)[4]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G nP list_edges a b.\n       \\<lbrakk>wf_graph G; (a, b) \\<in> edges G;\n        \\<not> num_reachable G a \\<le> nP a; set list_edges = edges G;\n        distinct list_edges\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (edges G) G nP\n 2. \\<And>N E E' nP.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n 3. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows sinvar ff G\n         nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (ff \\<union> f') G nP", "apply(auto simp add: SecurityInvariant_withOffendingFlows.is_offending_flows_def graph_ops)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>N E E' nP.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n 2. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows sinvar ff G\n         nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (ff \\<union> f') G nP", "apply(fact SecurityInvariant_withOffendingFlows.sinvar_mono_imp_sinvar_mono[OF sinvar_mono])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows sinvar ff G\n         nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (ff \\<union> f') G nP", "apply(fact SecurityInvariant_withOffendingFlows.sinvar_mono_imp_is_offending_flows_mono[OF sinvar_mono])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation Dependability: SecurityInvariant_ACS\nwhere default_node_properties = SINVAR_Dependability.default_node_properties\nand sinvar = SINVAR_Dependability.sinvar"], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_ACS sinvar default_node_properties", "unfolding SINVAR_Dependability.default_node_properties_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_ACS sinvar 0", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>G f nP.\n       \\<lbrakk>wf_graph G; f \\<in> set_offending_flows G nP\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>fst ` f.\n                            \\<not> sinvar G (nP(i := 0))\n 2. \\<And>otherbot.\n       \\<forall>G f nP i.\n          wf_graph G \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          i \\<in> fst ` f \\<longrightarrow>\n          \\<not> sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n       otherbot = 0", "fix G::\"'a graph\" and f nP"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>G f nP.\n       \\<lbrakk>wf_graph G; f \\<in> set_offending_flows G nP\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>fst ` f.\n                            \\<not> sinvar G (nP(i := 0))\n 2. \\<And>otherbot.\n       \\<forall>G f nP i.\n          wf_graph G \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          i \\<in> fst ` f \\<longrightarrow>\n          \\<not> sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n       otherbot = 0", "assume \"wf_graph G\" and \"f \\<in> set_offending_flows G nP\""], ["proof (state)\nthis:\n  wf_graph G\n  f \\<in> set_offending_flows G nP\n\ngoal (2 subgoals):\n 1. \\<And>G f nP.\n       \\<lbrakk>wf_graph G; f \\<in> set_offending_flows G nP\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>fst ` f.\n                            \\<not> sinvar G (nP(i := 0))\n 2. \\<And>otherbot.\n       \\<forall>G f nP i.\n          wf_graph G \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          i \\<in> fst ` f \\<longrightarrow>\n          \\<not> sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n       otherbot = 0", "thus \"\\<forall>i\\<in>fst ` f. \\<not> sinvar G (nP(i := 0))\""], ["proof (prove)\nusing this:\n  wf_graph G\n  f \\<in> set_offending_flows G nP\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>fst ` f. \\<not> sinvar G (nP(i := 0))", "apply (simp add: SecurityInvariant_withOffendingFlows.set_offending_flows_def\n      SecurityInvariant_withOffendingFlows.is_offending_flows_min_set_def\n      SecurityInvariant_withOffendingFlows.is_offending_flows_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G;\n     f \\<subseteq> edges G \\<and>\n     (\\<exists>x\\<in>edges G.\n         \\<not> (case x of\n                 (e1, e2) \\<Rightarrow>\n                   num_reachable G e1 \\<le> nP e1)) \\<and>\n     (\\<forall>x\\<in>edges (delete_edges G f).\n         case x of\n         (e1, e2) \\<Rightarrow>\n           num_reachable (delete_edges G f) e1 \\<le> nP e1) \\<and>\n     (\\<forall>x\\<in>f.\n         case x of\n         (e1, e2) \\<Rightarrow>\n           \\<exists>x\\<in>edges (add_edge e1 e2 (delete_edges G f)).\n              \\<not> (case x of\n                      (e1a, e2a) \\<Rightarrow>\n                        num_reachable (add_edge e1 e2 (delete_edges G f))\n                         e1a\n                        \\<le> nP e1a))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>f.\n                         \\<exists>x\\<in>edges G.\n                            \\<not> (case x of\n                                    (e1, e2) \\<Rightarrow>\nnum_reachable G e1 \\<le> (if e1 = fst i then 0 else nP e1))", "apply (simp split: prod.split_asm prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>f.\n                \\<forall>x1 x2.\n                   x = (x1, x2) \\<longrightarrow>\n                   (\\<exists>x\\<in>edges\n                                    (add_edge x1 x2 (delete_edges G f)).\n                       \\<forall>x1a.\n                          (\\<forall>x2. x \\<noteq> (x1a, x2)) \\<or>\n                          \\<not> num_reachable\n                                  (add_edge x1 x2 (delete_edges G f)) x1a\n                                 \\<le> nP x1a);\n     wf_graph G; f \\<subseteq> edges G;\n     \\<exists>x\\<in>edges G.\n        \\<forall>x1.\n           (\\<forall>x2. x \\<noteq> (x1, x2)) \\<or>\n           \\<not> num_reachable G x1 \\<le> nP x1;\n     \\<forall>x\\<in>edges (delete_edges G f).\n        \\<forall>x1.\n           (\\<forall>x2. x \\<noteq> (x1, x2)) \\<or>\n           num_reachable (delete_edges G f) x1 \\<le> nP x1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>f.\n                         \\<exists>x\\<in>edges G.\n                            \\<forall>x1.\n                               (x1 = fst i \\<longrightarrow>\n                                (\\<exists>x2.\n                                    x = (fst i, x2)) \\<longrightarrow>\n                                0 < num_reachable G (fst i)) \\<and>\n                               (x1 \\<noteq> fst i \\<longrightarrow>\n                                (\\<exists>x2.\n                                    x = (x1, x2)) \\<longrightarrow>\n                                \\<not> num_reachable G x1 \\<le> nP x1)", "apply (simp add:graph_ops)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>f.\n                \\<forall>x1 x2.\n                   x = (x1, x2) \\<longrightarrow>\n                   num_reachable\n                    \\<lparr>nodes = insert x1 (insert x2 (nodes G)),\n                       edges = insert (x1, x2) (edges G - f)\\<rparr>\n                    x1\n                   \\<le> nP x1 \\<longrightarrow>\n                   (\\<exists>x\\<in>edges G - f.\n                       \\<forall>x1a.\n                          (\\<forall>x2. x \\<noteq> (x1a, x2)) \\<or>\n                          \\<not> num_reachable\n                                  \\<lparr>nodes =\n      insert x1 (insert x2 (nodes G)),\n                                     edges =\n insert (x1, x2) (edges G - f)\\<rparr>\n                                  x1a\n                                 \\<le> nP x1a);\n     wf_graph G; f \\<subseteq> edges G;\n     \\<exists>x\\<in>edges G.\n        \\<forall>x1.\n           (\\<forall>x2. x \\<noteq> (x1, x2)) \\<or>\n           \\<not> num_reachable G x1 \\<le> nP x1;\n     \\<forall>x\\<in>edges G - f.\n        \\<forall>x1.\n           (\\<forall>x2. x \\<noteq> (x1, x2)) \\<or>\n           num_reachable\n            \\<lparr>nodes = nodes G, edges = edges G - f\\<rparr> x1\n           \\<le> nP x1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>f.\n                         \\<exists>x\\<in>edges G.\n                            \\<forall>x1.\n                               (x1 = fst i \\<longrightarrow>\n                                (\\<exists>x2.\n                                    x = (fst i, x2)) \\<longrightarrow>\n                                0 < num_reachable G (fst i)) \\<and>\n                               (x1 \\<noteq> fst i \\<longrightarrow>\n                                (\\<exists>x2.\n                                    x = (x1, x2)) \\<longrightarrow>\n                                \\<not> num_reachable G x1 \\<le> nP x1)", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<forall>x\\<in>f.\n                   \\<forall>x1 x2.\n                      x = (x1, x2) \\<longrightarrow>\n                      num_reachable\n                       \\<lparr>nodes = insert x1 (insert x2 (nodes G)),\n                          edges = insert (x1, x2) (edges G - f)\\<rparr>\n                       x1\n                      \\<le> nP x1 \\<longrightarrow>\n                      (\\<exists>x\\<in>edges G - f.\n                          \\<forall>x1a.\n                             (\\<forall>x2. x \\<noteq> (x1a, x2)) \\<or>\n                             \\<not> num_reachable\n                                     \\<lparr>nodes =\n         insert x1 (insert x2 (nodes G)),\n  edges = insert (x1, x2) (edges G - f)\\<rparr>\n                                     x1a\n                                    \\<le> nP x1a);\n        wf_graph G; f \\<subseteq> edges G;\n        \\<forall>x\\<in>edges G - f.\n           \\<forall>x1.\n              (\\<forall>x2. x \\<noteq> (x1, x2)) \\<or>\n              num_reachable\n               \\<lparr>nodes = nodes G, edges = edges G - f\\<rparr> x1\n              \\<le> nP x1;\n        (a, b) \\<in> edges G;\n        \\<forall>x1.\n           (\\<forall>x2. (a, b) \\<noteq> (x1, x2)) \\<or>\n           \\<not> num_reachable G x1 \\<le> nP x1;\n        (aa, ba) \\<in> f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>edges G.\n                            \\<forall>x1.\n                               (x1 = fst (aa, ba) \\<longrightarrow>\n                                (\\<exists>x2.\n                                    x =\n                                    (fst (aa, ba), x2)) \\<longrightarrow>\n                                0 < num_reachable G (fst (aa, ba))) \\<and>\n                               (x1 \\<noteq> fst (aa, ba) \\<longrightarrow>\n                                (\\<exists>x2.\n                                    x = (x1, x2)) \\<longrightarrow>\n                                \\<not> num_reachable G x1 \\<le> nP x1)", "apply (metis gr0I le0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>i\\<in>fst ` f. \\<not> sinvar G (nP(i := 0))\n\ngoal (1 subgoal):\n 1. \\<And>otherbot.\n       \\<forall>G f nP i.\n          wf_graph G \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          i \\<in> fst ` f \\<longrightarrow>\n          \\<not> sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n       otherbot = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>otherbot.\n       \\<forall>G f nP i.\n          wf_graph G \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          i \\<in> fst ` f \\<longrightarrow>\n          \\<not> sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n       otherbot = 0", "fix otherbot"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>otherbot.\n       \\<forall>G f nP i.\n          wf_graph G \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          i \\<in> fst ` f \\<longrightarrow>\n          \\<not> sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n       otherbot = 0", "assume assm: \"\\<forall>G f nP i. wf_graph G \\<and> f \\<in> set_offending_flows G nP \\<and> i \\<in> fst ` f \\<longrightarrow> \\<not> sinvar G (nP(i := otherbot))\""], ["proof (state)\nthis:\n  \\<forall>G f nP i.\n     wf_graph G \\<and>\n     f \\<in> set_offending_flows G nP \\<and>\n     i \\<in> fst ` f \\<longrightarrow>\n     \\<not> sinvar G (nP(i := otherbot))\n\ngoal (1 subgoal):\n 1. \\<And>otherbot.\n       \\<forall>G f nP i.\n          wf_graph G \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          i \\<in> fst ` f \\<longrightarrow>\n          \\<not> sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n       otherbot = 0", "have unique_default_example_succ_tran:\n    \"succ_tran \\<lparr>nodes = {vertex_1, vertex_2}, edges = {(vertex_1, vertex_2)}\\<rparr> vertex_1 = {vertex_2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ_tran\n     \\<lparr>nodes = {vertex_1, vertex_2},\n        edges = {(vertex_1, vertex_2)}\\<rparr>\n     vertex_1 =\n    {vertex_2}", "using unique_default_example1"], ["proof (prove)\nusing this:\n  succ_tran\n   \\<lparr>nodes = {vertex_1, vertex_2},\n      edges = {(vertex_1, vertex_2)}\\<rparr>\n   vertex_1 =\n  {vertex_2}\n\ngoal (1 subgoal):\n 1. succ_tran\n     \\<lparr>nodes = {vertex_1, vertex_2},\n        edges = {(vertex_1, vertex_2)}\\<rparr>\n     vertex_1 =\n    {vertex_2}", "by blast"], ["proof (state)\nthis:\n  succ_tran\n   \\<lparr>nodes = {vertex_1, vertex_2},\n      edges = {(vertex_1, vertex_2)}\\<rparr>\n   vertex_1 =\n  {vertex_2}\n\ngoal (1 subgoal):\n 1. \\<And>otherbot.\n       \\<forall>G f nP i.\n          wf_graph G \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          i \\<in> fst ` f \\<longrightarrow>\n          \\<not> sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n       otherbot = 0", "from assm"], ["proof (chain)\npicking this:\n  \\<forall>G f nP i.\n     wf_graph G \\<and>\n     f \\<in> set_offending_flows G nP \\<and>\n     i \\<in> fst ` f \\<longrightarrow>\n     \\<not> sinvar G (nP(i := otherbot))", "show \"otherbot = 0\""], ["proof (prove)\nusing this:\n  \\<forall>G f nP i.\n     wf_graph G \\<and>\n     f \\<in> set_offending_flows G nP \\<and>\n     i \\<in> fst ` f \\<longrightarrow>\n     \\<not> sinvar G (nP(i := otherbot))\n\ngoal (1 subgoal):\n 1. otherbot = 0", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>G f nP i.\n       wf_graph G \\<and>\n       f \\<in> set_offending_flows G nP \\<and>\n       i \\<in> fst ` f \\<longrightarrow>\n       \\<not> sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n    otherbot = 0", "apply(elim default_uniqueness_by_counterexample_ACS)"], ["proof (prove)\ngoal (1 subgoal):\n 1. otherbot \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>G nP i f.\n       wf_graph G \\<and>\n       \\<not> sinvar G nP \\<and>\n       f \\<in> set_offending_flows G nP \\<and>\n       sinvar (delete_edges G f) nP \\<and>\n       i \\<in> fst ` f \\<and> sinvar G (nP(i := otherbot))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < otherbot \\<Longrightarrow>\n    \\<exists>G.\n       wf_graph G \\<and>\n       (\\<exists>nP.\n           (\\<exists>x\\<in>edges G.\n               \\<not> (case x of\n                       (e1, e2) \\<Rightarrow>\n                         num_reachable G e1 \\<le> nP e1)) \\<and>\n           (\\<exists>i f.\n               f \\<in> set_offending_flows G nP \\<and>\n               (\\<forall>x\\<in>edges (delete_edges G f).\n                   case x of\n                   (e1, e2) \\<Rightarrow>\n                     num_reachable (delete_edges G f) e1 \\<le> nP e1) \\<and>\n               i \\<in> fst ` f \\<and>\n               (\\<forall>x\\<in>edges G.\n                   case x of\n                   (e1, e2) \\<Rightarrow>\n                     num_reachable G e1\n                     \\<le> (if e1 = i then otherbot else nP e1))))", "apply (simp add: SecurityInvariant_withOffendingFlows.set_offending_flows_def\n        SecurityInvariant_withOffendingFlows.is_offending_flows_min_set_def\n        SecurityInvariant_withOffendingFlows.is_offending_flows_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < otherbot \\<Longrightarrow>\n    \\<exists>G.\n       wf_graph G \\<and>\n       (\\<exists>nP.\n           (\\<exists>x\\<in>edges G.\n               \\<not> (case x of\n                       (e1, e2) \\<Rightarrow>\n                         num_reachable G e1 \\<le> nP e1)) \\<and>\n           (\\<exists>i f.\n               f \\<subseteq> edges G \\<and>\n               (\\<exists>x\\<in>edges G.\n                   \\<not> (case x of\n                           (e1, e2) \\<Rightarrow>\n                             num_reachable G e1 \\<le> nP e1)) \\<and>\n               (\\<forall>(e1, e2)\\<in>edges (delete_edges G f).\n                   num_reachable (delete_edges G f) e1 \\<le> nP e1) \\<and>\n               (\\<forall>(e1, e2)\\<in>f.\n                   \\<exists>x\\<in>edges (add_edge e1 e2 (delete_edges G f)).\n                      \\<not> (case x of\n                              (e1a, e2a) \\<Rightarrow>\n                                num_reachable\n                                 (add_edge e1 e2 (delete_edges G f)) e1a\n                                \\<le> nP e1a)) \\<and>\n               (\\<forall>(e1, e2)\\<in>edges (delete_edges G f).\n                   num_reachable (delete_edges G f) e1 \\<le> nP e1) \\<and>\n               i \\<in> fst ` f \\<and>\n               (\\<forall>(e1, e2)\\<in>edges G.\n                   num_reachable G e1\n                   \\<le> (if e1 = i then otherbot else nP e1))))", "apply (simp add:graph_ops)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < otherbot \\<Longrightarrow>\n    \\<exists>G.\n       wf_graph G \\<and>\n       (\\<exists>nP.\n           (\\<exists>x\\<in>edges G.\n               \\<not> (case x of\n                       (e1, e2) \\<Rightarrow>\n                         num_reachable G e1 \\<le> nP e1)) \\<and>\n           (\\<exists>i f.\n               f \\<subseteq> edges G \\<and>\n               (\\<exists>x\\<in>edges G.\n                   \\<not> (case x of\n                           (e1, e2) \\<Rightarrow>\n                             num_reachable G e1 \\<le> nP e1)) \\<and>\n               (\\<forall>x\\<in>edges G - f.\n                   case x of\n                   (e1, e2) \\<Rightarrow>\n                     num_reachable\n                      \\<lparr>nodes = nodes G, edges = edges G - f\\<rparr>\n                      e1\n                     \\<le> nP e1) \\<and>\n               (\\<forall>x\\<in>f.\n                   case x of\n                   (e1, e2) \\<Rightarrow>\n                     num_reachable\n                      \\<lparr>nodes = insert e1 (insert e2 (nodes G)),\n                         edges = insert (e1, e2) (edges G - f)\\<rparr>\n                      e1\n                     \\<le> nP e1 \\<longrightarrow>\n                     (\\<exists>x\\<in>edges G - f.\n                         \\<not> (case x of\n                                 (e1a, e2a) \\<Rightarrow>\n                                   num_reachable\n                                    \\<lparr>nodes =\n        insert e1 (insert e2 (nodes G)),\n edges = insert (e1, e2) (edges G - f)\\<rparr>\n                                    e1a\n                                   \\<le> nP e1a))) \\<and>\n               (\\<forall>x\\<in>edges G - f.\n                   case x of\n                   (e1, e2) \\<Rightarrow>\n                     num_reachable\n                      \\<lparr>nodes = nodes G, edges = edges G - f\\<rparr>\n                      e1\n                     \\<le> nP e1) \\<and>\n               i \\<in> fst ` f \\<and>\n               (\\<forall>x\\<in>edges G.\n                   case x of\n                   (e1, e2) \\<Rightarrow>\n                     num_reachable G e1\n                     \\<le> (if e1 = i then otherbot else nP e1))))", "apply (simp split: prod.split_asm prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < otherbot \\<Longrightarrow>\n    \\<exists>G.\n       wf_graph G \\<and>\n       (\\<exists>nP.\n           (\\<exists>x\\<in>edges G.\n               \\<forall>x1.\n                  (\\<exists>x2. x = (x1, x2)) \\<longrightarrow>\n                  \\<not> num_reachable G x1 \\<le> nP x1) \\<and>\n           (\\<exists>i f.\n               f \\<subseteq> edges G \\<and>\n               (\\<exists>x\\<in>edges G.\n                   \\<forall>x1.\n                      (\\<exists>x2. x = (x1, x2)) \\<longrightarrow>\n                      \\<not> num_reachable G x1 \\<le> nP x1) \\<and>\n               (\\<forall>x\\<in>edges G - f.\n                   \\<forall>x1.\n                      (\\<exists>x2. x = (x1, x2)) \\<longrightarrow>\n                      num_reachable\n                       \\<lparr>nodes = nodes G, edges = edges G - f\\<rparr>\n                       x1\n                      \\<le> nP x1) \\<and>\n               (\\<forall>x\\<in>f.\n                   \\<forall>x1 x2.\n                      x = (x1, x2) \\<longrightarrow>\n                      num_reachable\n                       \\<lparr>nodes = insert x1 (insert x2 (nodes G)),\n                          edges = insert (x1, x2) (edges G - f)\\<rparr>\n                       x1\n                      \\<le> nP x1 \\<longrightarrow>\n                      (\\<exists>x\\<in>edges G - f.\n                          \\<forall>x1a.\n                             (\\<exists>x2. x = (x1a, x2)) \\<longrightarrow>\n                             \\<not> num_reachable\n                                     \\<lparr>nodes =\n         insert x1 (insert x2 (nodes G)),\n  edges = insert (x1, x2) (edges G - f)\\<rparr>\n                                     x1a\n                                    \\<le> nP x1a)) \\<and>\n               (\\<forall>x\\<in>edges G - f.\n                   \\<forall>x1.\n                      (\\<exists>x2. x = (x1, x2)) \\<longrightarrow>\n                      num_reachable\n                       \\<lparr>nodes = nodes G, edges = edges G - f\\<rparr>\n                       x1\n                      \\<le> nP x1) \\<and>\n               i \\<in> fst ` f \\<and>\n               (\\<forall>x\\<in>edges G.\n                   \\<forall>x1.\n                      (x1 = i \\<longrightarrow>\n                       (\\<exists>x2. x = (i, x2)) \\<longrightarrow>\n                       num_reachable G i \\<le> otherbot) \\<and>\n                      (x1 \\<noteq> i \\<longrightarrow>\n                       (\\<exists>x2. x = (x1, x2)) \\<longrightarrow>\n                       num_reachable G x1 \\<le> nP x1))))", "apply(rule_tac x=\"\\<lparr> nodes={vertex_1,vertex_2}, edges = {(vertex_1,vertex_2)} \\<rparr>\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < otherbot \\<Longrightarrow>\n    wf_graph\n     \\<lparr>nodes = {vertex_1, vertex_2},\n        edges = {(vertex_1, vertex_2)}\\<rparr> \\<and>\n    (\\<exists>nP.\n        \\<not> num_reachable\n                \\<lparr>nodes = {vertex_1, vertex_2},\n                   edges = {(vertex_1, vertex_2)}\\<rparr>\n                vertex_1\n               \\<le> nP vertex_1 \\<and>\n        (\\<exists>i f.\n            f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n            \\<not> num_reachable\n                    \\<lparr>nodes = {vertex_1, vertex_2},\n                       edges = {(vertex_1, vertex_2)}\\<rparr>\n                    vertex_1\n                   \\<le> nP vertex_1 \\<and>\n            (\\<forall>x\\<in>{(vertex_1, vertex_2)} - f.\n                num_reachable\n                 \\<lparr>nodes = {vertex_1, vertex_2},\n                    edges = {x} - f\\<rparr>\n                 vertex_1\n                \\<le> nP vertex_1) \\<and>\n            (\\<forall>x\\<in>f.\n                \\<forall>x1 x2.\n                   x = (x1, x2) \\<longrightarrow>\n                   num_reachable\n                    \\<lparr>nodes = {x1, x2, vertex_1, vertex_2},\n                       edges =\n                         insert (x1, x2)\n                          ({(vertex_1, vertex_2)} - f)\\<rparr>\n                    x1\n                   \\<le> nP x1 \\<longrightarrow>\n                   (\\<exists>x\\<in>{(vertex_1, vertex_2)} - f.\n                       \\<not> num_reachable\n                               \\<lparr>nodes = {x1, x2, vertex_1, vertex_2},\n                                  edges = insert (x1, x2) ({x} - f)\\<rparr>\n                               vertex_1\n                              \\<le> nP vertex_1)) \\<and>\n            (\\<forall>x\\<in>{(vertex_1, vertex_2)} - f.\n                num_reachable\n                 \\<lparr>nodes = {vertex_1, vertex_2},\n                    edges = {x} - f\\<rparr>\n                 vertex_1\n                \\<le> nP vertex_1) \\<and>\n            i \\<in> fst ` f \\<and>\n            (\\<forall>x1.\n                (x1 = i \\<longrightarrow>\n                 vertex_1 = i \\<longrightarrow>\n                 num_reachable\n                  \\<lparr>nodes = {vertex_1, vertex_2},\n                     edges = {(vertex_1, vertex_2)}\\<rparr>\n                  vertex_1\n                 \\<le> otherbot) \\<and>\n                (x1 \\<noteq> i \\<longrightarrow>\n                 vertex_1 = x1 \\<longrightarrow>\n                 num_reachable\n                  \\<lparr>nodes = {vertex_1, vertex_2},\n                     edges = {(vertex_1, vertex_2)}\\<rparr>\n                  vertex_1\n                 \\<le> nP vertex_1))))", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < otherbot \\<Longrightarrow>\n    wf_graph\n     \\<lparr>nodes = {vertex_1, vertex_2},\n        edges = {(vertex_1, vertex_2)}\\<rparr>\n 2. 0 < otherbot \\<Longrightarrow>\n    \\<exists>nP.\n       \\<not> num_reachable\n               \\<lparr>nodes = {vertex_1, vertex_2},\n                  edges = {(vertex_1, vertex_2)}\\<rparr>\n               vertex_1\n              \\<le> nP vertex_1 \\<and>\n       (\\<exists>i f.\n           f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n           \\<not> num_reachable\n                   \\<lparr>nodes = {vertex_1, vertex_2},\n                      edges = {(vertex_1, vertex_2)}\\<rparr>\n                   vertex_1\n                  \\<le> nP vertex_1 \\<and>\n           (\\<forall>x\\<in>{(vertex_1, vertex_2)} - f.\n               num_reachable\n                \\<lparr>nodes = {vertex_1, vertex_2},\n                   edges = {x} - f\\<rparr>\n                vertex_1\n               \\<le> nP vertex_1) \\<and>\n           (\\<forall>x\\<in>f.\n               \\<forall>x1 x2.\n                  x = (x1, x2) \\<longrightarrow>\n                  num_reachable\n                   \\<lparr>nodes = {x1, x2, vertex_1, vertex_2},\n                      edges =\n                        insert (x1, x2) ({(vertex_1, vertex_2)} - f)\\<rparr>\n                   x1\n                  \\<le> nP x1 \\<longrightarrow>\n                  (\\<exists>x\\<in>{(vertex_1, vertex_2)} - f.\n                      \\<not> num_reachable\n                              \\<lparr>nodes = {x1, x2, vertex_1, vertex_2},\n                                 edges = insert (x1, x2) ({x} - f)\\<rparr>\n                              vertex_1\n                             \\<le> nP vertex_1)) \\<and>\n           (\\<forall>x\\<in>{(vertex_1, vertex_2)} - f.\n               num_reachable\n                \\<lparr>nodes = {vertex_1, vertex_2},\n                   edges = {x} - f\\<rparr>\n                vertex_1\n               \\<le> nP vertex_1) \\<and>\n           i \\<in> fst ` f \\<and>\n           (\\<forall>x1.\n               (x1 = i \\<longrightarrow>\n                vertex_1 = i \\<longrightarrow>\n                num_reachable\n                 \\<lparr>nodes = {vertex_1, vertex_2},\n                    edges = {(vertex_1, vertex_2)}\\<rparr>\n                 vertex_1\n                \\<le> otherbot) \\<and>\n               (x1 \\<noteq> i \\<longrightarrow>\n                vertex_1 = x1 \\<longrightarrow>\n                num_reachable\n                 \\<lparr>nodes = {vertex_1, vertex_2},\n                    edges = {(vertex_1, vertex_2)}\\<rparr>\n                 vertex_1\n                \\<le> nP vertex_1)))", "apply(simp add: wf_graph_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < otherbot \\<Longrightarrow>\n    \\<exists>nP.\n       \\<not> num_reachable\n               \\<lparr>nodes = {vertex_1, vertex_2},\n                  edges = {(vertex_1, vertex_2)}\\<rparr>\n               vertex_1\n              \\<le> nP vertex_1 \\<and>\n       (\\<exists>i f.\n           f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n           \\<not> num_reachable\n                   \\<lparr>nodes = {vertex_1, vertex_2},\n                      edges = {(vertex_1, vertex_2)}\\<rparr>\n                   vertex_1\n                  \\<le> nP vertex_1 \\<and>\n           (\\<forall>x\\<in>{(vertex_1, vertex_2)} - f.\n               num_reachable\n                \\<lparr>nodes = {vertex_1, vertex_2},\n                   edges = {x} - f\\<rparr>\n                vertex_1\n               \\<le> nP vertex_1) \\<and>\n           (\\<forall>x\\<in>f.\n               \\<forall>x1 x2.\n                  x = (x1, x2) \\<longrightarrow>\n                  num_reachable\n                   \\<lparr>nodes = {x1, x2, vertex_1, vertex_2},\n                      edges =\n                        insert (x1, x2) ({(vertex_1, vertex_2)} - f)\\<rparr>\n                   x1\n                  \\<le> nP x1 \\<longrightarrow>\n                  (\\<exists>x\\<in>{(vertex_1, vertex_2)} - f.\n                      \\<not> num_reachable\n                              \\<lparr>nodes = {x1, x2, vertex_1, vertex_2},\n                                 edges = insert (x1, x2) ({x} - f)\\<rparr>\n                              vertex_1\n                             \\<le> nP vertex_1)) \\<and>\n           (\\<forall>x\\<in>{(vertex_1, vertex_2)} - f.\n               num_reachable\n                \\<lparr>nodes = {vertex_1, vertex_2},\n                   edges = {x} - f\\<rparr>\n                vertex_1\n               \\<le> nP vertex_1) \\<and>\n           i \\<in> fst ` f \\<and>\n           (\\<forall>x1.\n               (x1 = i \\<longrightarrow>\n                vertex_1 = i \\<longrightarrow>\n                num_reachable\n                 \\<lparr>nodes = {vertex_1, vertex_2},\n                    edges = {(vertex_1, vertex_2)}\\<rparr>\n                 vertex_1\n                \\<le> otherbot) \\<and>\n               (x1 \\<noteq> i \\<longrightarrow>\n                vertex_1 = x1 \\<longrightarrow>\n                num_reachable\n                 \\<lparr>nodes = {vertex_1, vertex_2},\n                    edges = {(vertex_1, vertex_2)}\\<rparr>\n                 vertex_1\n                \\<le> nP vertex_1)))", "apply(rule_tac x=\"(\\<lambda> x. 0)(vertex_1 := 0, vertex_2 := 0)\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < otherbot \\<Longrightarrow>\n    0 < num_reachable\n         \\<lparr>nodes = {vertex_1, vertex_2},\n            edges = {(vertex_1, vertex_2)}\\<rparr>\n         vertex_1 \\<and>\n    (\\<exists>i f.\n        f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n        0 < num_reachable\n             \\<lparr>nodes = {vertex_1, vertex_2},\n                edges = {(vertex_1, vertex_2)}\\<rparr>\n             vertex_1 \\<and>\n        (\\<forall>x\\<in>{(vertex_1, vertex_2)} - f.\n            num_reachable\n             \\<lparr>nodes = {vertex_1, vertex_2}, edges = {x} - f\\<rparr>\n             vertex_1 =\n            0) \\<and>\n        (\\<forall>x\\<in>f.\n            \\<forall>x1.\n               (x1 = vertex_2 \\<longrightarrow>\n                (\\<forall>x2.\n                    x = (vertex_2, x2) \\<longrightarrow>\n                    num_reachable\n                     \\<lparr>nodes = {vertex_2, x2, vertex_1, vertex_2},\n                        edges =\n                          insert (vertex_2, x2)\n                           ({(vertex_1, vertex_2)} - f)\\<rparr>\n                     vertex_2 =\n                    0 \\<longrightarrow>\n                    (\\<exists>x\\<in>{(vertex_1, vertex_2)} - f.\n                        0 < num_reachable\n                             \\<lparr>nodes =\n {vertex_2, x2, vertex_1, vertex_2},\n                                edges =\n                                  insert (vertex_2, x2) ({x} - f)\\<rparr>\n                             vertex_1))) \\<and>\n               (x1 \\<noteq> vertex_2 \\<longrightarrow>\n                (\\<forall>x2.\n                    x = (x1, x2) \\<longrightarrow>\n                    num_reachable\n                     \\<lparr>nodes = {x1, x2, vertex_1, vertex_2},\n                        edges =\n                          insert (x1, x2)\n                           ({(vertex_1, vertex_2)} - f)\\<rparr>\n                     x1 =\n                    0 \\<longrightarrow>\n                    (\\<exists>x\\<in>{(vertex_1, vertex_2)} - f.\n                        0 < num_reachable\n                             \\<lparr>nodes = {x1, x2, vertex_1, vertex_2},\n                                edges = insert (x1, x2) ({x} - f)\\<rparr>\n                             vertex_1)))) \\<and>\n        (\\<forall>x\\<in>{(vertex_1, vertex_2)} - f.\n            num_reachable\n             \\<lparr>nodes = {vertex_1, vertex_2}, edges = {x} - f\\<rparr>\n             vertex_1 =\n            0) \\<and>\n        i \\<in> fst ` f \\<and>\n        (\\<forall>x1.\n            (x1 = i \\<longrightarrow>\n             vertex_1 = i \\<longrightarrow>\n             num_reachable\n              \\<lparr>nodes = {vertex_1, vertex_2},\n                 edges = {(vertex_1, vertex_2)}\\<rparr>\n              vertex_1\n             \\<le> otherbot) \\<and>\n            (x1 \\<noteq> i \\<longrightarrow>\n             vertex_1 = x1 \\<longrightarrow>\n             num_reachable\n              \\<lparr>nodes = {vertex_1, vertex_2},\n                 edges = {(vertex_1, vertex_2)}\\<rparr>\n              vertex_1 =\n             0)))", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < otherbot \\<Longrightarrow>\n    0 < num_reachable\n         \\<lparr>nodes = {vertex_1, vertex_2},\n            edges = {(vertex_1, vertex_2)}\\<rparr>\n         vertex_1\n 2. 0 < otherbot \\<Longrightarrow>\n    \\<exists>i f.\n       f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n       0 < num_reachable\n            \\<lparr>nodes = {vertex_1, vertex_2},\n               edges = {(vertex_1, vertex_2)}\\<rparr>\n            vertex_1 \\<and>\n       (\\<forall>x\\<in>{(vertex_1, vertex_2)} - f.\n           num_reachable\n            \\<lparr>nodes = {vertex_1, vertex_2}, edges = {x} - f\\<rparr>\n            vertex_1 =\n           0) \\<and>\n       (\\<forall>x\\<in>f.\n           \\<forall>x1.\n              (x1 = vertex_2 \\<longrightarrow>\n               (\\<forall>x2.\n                   x = (vertex_2, x2) \\<longrightarrow>\n                   num_reachable\n                    \\<lparr>nodes = {vertex_2, x2, vertex_1, vertex_2},\n                       edges =\n                         insert (vertex_2, x2)\n                          ({(vertex_1, vertex_2)} - f)\\<rparr>\n                    vertex_2 =\n                   0 \\<longrightarrow>\n                   (\\<exists>x\\<in>{(vertex_1, vertex_2)} - f.\n                       0 < num_reachable\n                            \\<lparr>nodes =\n{vertex_2, x2, vertex_1, vertex_2},\n                               edges =\n                                 insert (vertex_2, x2) ({x} - f)\\<rparr>\n                            vertex_1))) \\<and>\n              (x1 \\<noteq> vertex_2 \\<longrightarrow>\n               (\\<forall>x2.\n                   x = (x1, x2) \\<longrightarrow>\n                   num_reachable\n                    \\<lparr>nodes = {x1, x2, vertex_1, vertex_2},\n                       edges =\n                         insert (x1, x2)\n                          ({(vertex_1, vertex_2)} - f)\\<rparr>\n                    x1 =\n                   0 \\<longrightarrow>\n                   (\\<exists>x\\<in>{(vertex_1, vertex_2)} - f.\n                       0 < num_reachable\n                            \\<lparr>nodes = {x1, x2, vertex_1, vertex_2},\n                               edges = insert (x1, x2) ({x} - f)\\<rparr>\n                            vertex_1)))) \\<and>\n       (\\<forall>x\\<in>{(vertex_1, vertex_2)} - f.\n           num_reachable\n            \\<lparr>nodes = {vertex_1, vertex_2}, edges = {x} - f\\<rparr>\n            vertex_1 =\n           0) \\<and>\n       i \\<in> fst ` f \\<and>\n       (\\<forall>x1.\n           (x1 = i \\<longrightarrow>\n            vertex_1 = i \\<longrightarrow>\n            num_reachable\n             \\<lparr>nodes = {vertex_1, vertex_2},\n                edges = {(vertex_1, vertex_2)}\\<rparr>\n             vertex_1\n            \\<le> otherbot) \\<and>\n           (x1 \\<noteq> i \\<longrightarrow>\n            vertex_1 = x1 \\<longrightarrow>\n            num_reachable\n             \\<lparr>nodes = {vertex_1, vertex_2},\n                edges = {(vertex_1, vertex_2)}\\<rparr>\n             vertex_1 =\n            0))", "apply(simp add: unique_default_example_succ_tran num_reachable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < otherbot \\<Longrightarrow>\n    \\<exists>i f.\n       f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n       0 < num_reachable\n            \\<lparr>nodes = {vertex_1, vertex_2},\n               edges = {(vertex_1, vertex_2)}\\<rparr>\n            vertex_1 \\<and>\n       (\\<forall>x\\<in>{(vertex_1, vertex_2)} - f.\n           num_reachable\n            \\<lparr>nodes = {vertex_1, vertex_2}, edges = {x} - f\\<rparr>\n            vertex_1 =\n           0) \\<and>\n       (\\<forall>x\\<in>f.\n           \\<forall>x1.\n              (x1 = vertex_2 \\<longrightarrow>\n               (\\<forall>x2.\n                   x = (vertex_2, x2) \\<longrightarrow>\n                   num_reachable\n                    \\<lparr>nodes = {vertex_2, x2, vertex_1, vertex_2},\n                       edges =\n                         insert (vertex_2, x2)\n                          ({(vertex_1, vertex_2)} - f)\\<rparr>\n                    vertex_2 =\n                   0 \\<longrightarrow>\n                   (\\<exists>x\\<in>{(vertex_1, vertex_2)} - f.\n                       0 < num_reachable\n                            \\<lparr>nodes =\n{vertex_2, x2, vertex_1, vertex_2},\n                               edges =\n                                 insert (vertex_2, x2) ({x} - f)\\<rparr>\n                            vertex_1))) \\<and>\n              (x1 \\<noteq> vertex_2 \\<longrightarrow>\n               (\\<forall>x2.\n                   x = (x1, x2) \\<longrightarrow>\n                   num_reachable\n                    \\<lparr>nodes = {x1, x2, vertex_1, vertex_2},\n                       edges =\n                         insert (x1, x2)\n                          ({(vertex_1, vertex_2)} - f)\\<rparr>\n                    x1 =\n                   0 \\<longrightarrow>\n                   (\\<exists>x\\<in>{(vertex_1, vertex_2)} - f.\n                       0 < num_reachable\n                            \\<lparr>nodes = {x1, x2, vertex_1, vertex_2},\n                               edges = insert (x1, x2) ({x} - f)\\<rparr>\n                            vertex_1)))) \\<and>\n       (\\<forall>x\\<in>{(vertex_1, vertex_2)} - f.\n           num_reachable\n            \\<lparr>nodes = {vertex_1, vertex_2}, edges = {x} - f\\<rparr>\n            vertex_1 =\n           0) \\<and>\n       i \\<in> fst ` f \\<and>\n       (\\<forall>x1.\n           (x1 = i \\<longrightarrow>\n            vertex_1 = i \\<longrightarrow>\n            num_reachable\n             \\<lparr>nodes = {vertex_1, vertex_2},\n                edges = {(vertex_1, vertex_2)}\\<rparr>\n             vertex_1\n            \\<le> otherbot) \\<and>\n           (x1 \\<noteq> i \\<longrightarrow>\n            vertex_1 = x1 \\<longrightarrow>\n            num_reachable\n             \\<lparr>nodes = {vertex_1, vertex_2},\n                edges = {(vertex_1, vertex_2)}\\<rparr>\n             vertex_1 =\n            0))", "apply(rule_tac x=\"vertex_1\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < otherbot \\<Longrightarrow>\n    \\<exists>f\\<subseteq>{(vertex_1, vertex_2)}.\n       0 < num_reachable\n            \\<lparr>nodes = {vertex_1, vertex_2},\n               edges = {(vertex_1, vertex_2)}\\<rparr>\n            vertex_1 \\<and>\n       (\\<forall>x\\<in>{(vertex_1, vertex_2)} - f.\n           num_reachable\n            \\<lparr>nodes = {vertex_1, vertex_2}, edges = {x} - f\\<rparr>\n            vertex_1 =\n           0) \\<and>\n       (\\<forall>x\\<in>f.\n           \\<forall>x1.\n              (x1 = vertex_2 \\<longrightarrow>\n               (\\<forall>x2.\n                   x = (vertex_2, x2) \\<longrightarrow>\n                   num_reachable\n                    \\<lparr>nodes = {vertex_2, x2, vertex_1, vertex_2},\n                       edges =\n                         insert (vertex_2, x2)\n                          ({(vertex_1, vertex_2)} - f)\\<rparr>\n                    vertex_2 =\n                   0 \\<longrightarrow>\n                   (\\<exists>x\\<in>{(vertex_1, vertex_2)} - f.\n                       0 < num_reachable\n                            \\<lparr>nodes =\n{vertex_2, x2, vertex_1, vertex_2},\n                               edges =\n                                 insert (vertex_2, x2) ({x} - f)\\<rparr>\n                            vertex_1))) \\<and>\n              (x1 \\<noteq> vertex_2 \\<longrightarrow>\n               (\\<forall>x2.\n                   x = (x1, x2) \\<longrightarrow>\n                   num_reachable\n                    \\<lparr>nodes = {x1, x2, vertex_1, vertex_2},\n                       edges =\n                         insert (x1, x2)\n                          ({(vertex_1, vertex_2)} - f)\\<rparr>\n                    x1 =\n                   0 \\<longrightarrow>\n                   (\\<exists>x\\<in>{(vertex_1, vertex_2)} - f.\n                       0 < num_reachable\n                            \\<lparr>nodes = {x1, x2, vertex_1, vertex_2},\n                               edges = insert (x1, x2) ({x} - f)\\<rparr>\n                            vertex_1)))) \\<and>\n       (\\<forall>x\\<in>{(vertex_1, vertex_2)} - f.\n           num_reachable\n            \\<lparr>nodes = {vertex_1, vertex_2}, edges = {x} - f\\<rparr>\n            vertex_1 =\n           0) \\<and>\n       vertex_1 \\<in> fst ` f \\<and>\n       num_reachable\n        \\<lparr>nodes = {vertex_1, vertex_2},\n           edges = {(vertex_1, vertex_2)}\\<rparr>\n        vertex_1\n       \\<le> otherbot", "apply(rule_tac x=\"{(vertex_1,vertex_2)}\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < otherbot \\<Longrightarrow>\n    0 < num_reachable\n         \\<lparr>nodes = {vertex_1, vertex_2},\n            edges = {(vertex_1, vertex_2)}\\<rparr>\n         vertex_1 \\<and>\n    0 < num_reachable\n         \\<lparr>nodes = {vertex_1, vertex_2, vertex_1, vertex_2},\n            edges = {(vertex_1, vertex_2)}\\<rparr>\n         vertex_1 \\<and>\n    num_reachable\n     \\<lparr>nodes = {vertex_1, vertex_2},\n        edges = {(vertex_1, vertex_2)}\\<rparr>\n     vertex_1\n    \\<le> otherbot", "apply(simp add: unique_default_example_succ_tran num_reachable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < otherbot \\<Longrightarrow>\n    0 < card\n         (succ_tran\n           \\<lparr>nodes = {vertex_1, vertex_2, vertex_1, vertex_2},\n              edges = {(vertex_1, vertex_2)}\\<rparr>\n           vertex_1)", "apply(simp add: succ_tran_def unique_default_example_simp1 unique_default_example_simp2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  otherbot = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma TopoS_Dependability: \"SecurityInvariant sinvar default_node_properties receiver_violation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant sinvar default_node_properties receiver_violation", "unfolding receiver_violation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant sinvar default_node_properties False", "by unfold_locales"], ["", "hide_const (open) sinvar receiver_violation default_node_properties"], ["", "end"]]}