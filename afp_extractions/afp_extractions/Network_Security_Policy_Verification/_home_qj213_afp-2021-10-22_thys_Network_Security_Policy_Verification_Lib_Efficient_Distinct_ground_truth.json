{"file_name": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification/Lib/Efficient_Distinct.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification", "problem_names": ["lemma list_length_iff_distinct: \n  \"\\<lbrakk>set xs = set ys; distinct ys\\<rbrakk> \\<Longrightarrow> distinct xs \\<longleftrightarrow> length xs = length ys\"", "lemma distinct_by_mergesort: \"(length (mergesort_remdups xs) = length xs) \\<longleftrightarrow> distinct xs\"", "lemma [code]: \"distinct xs = (length (mergesort_remdups xs) = length xs)\"", "lemma map_tailrec_is_listmap: \"rev (map_tailrec f l accs) = (rev accs)@(List.map f l)\"", "lemma [code]: \"List.map f l = efficient_map f l\"", "lemma merge_tailrec_inefficient_prepend:\n  \"merge_tailrec_inefficient as bs (a # accs) = a # merge_tailrec_inefficient as bs accs\"", "lemma merge_as_tailrec_inefficient: \"merge as bs = merge_tailrec_inefficient as bs []\"", "lemma merge_tailrec_listappend:\n    \"merge_tailrec as bs (accs1@accs2) = (rev accs2)@(merge_tailrec as bs accs1)\"", "lemma merge_tailrec_acc_append: \n    \"merge_tailrec as bs (accs@[a]) = a#(merge_tailrec as bs (accs))\"", "lemma merge_inefficient_as_efficient:\n    \"merge_tailrec_inefficient as bs (rev accs) = (merge_tailrec as bs accs)\"", "lemma [code]: \"merge as bs = merge_tailrec as bs []\""], "translations": [["", "lemma list_length_iff_distinct: \n  \"\\<lbrakk>set xs = set ys; distinct ys\\<rbrakk> \\<Longrightarrow> distinct xs \\<longleftrightarrow> length xs = length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set xs = set ys; distinct ys\\<rbrakk>\n    \\<Longrightarrow> distinct xs = (length xs = length ys)", "by (metis distinct_card card_distinct)"], ["", "lemma distinct_by_mergesort: \"(length (mergesort_remdups xs) = length xs) \\<longleftrightarrow> distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length (mergesort_remdups xs) = length xs) = distinct xs", "by (metis list_length_iff_distinct mergesort_remdups_correct)"], ["", "lemma [code]: \"distinct xs = (length (mergesort_remdups xs) = length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs = (length (mergesort_remdups xs) = length xs)", "by (fact distinct_by_mergesort[symmetric])"], ["", "text\\<open>providing tail recursive versions of certain functions\\<close>"], ["", "(*otherwise scala code generated with this code always produces a StackOverflowException for large inputs*)"], ["", "text\\<open>@{const List.map}\\<close>"], ["", "fun map_tailrec ::  \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a list \\<Rightarrow> 'b list \\<Rightarrow> 'b list\" where\n  \"map_tailrec f [] accs = accs\" | \n  \"map_tailrec f (a#as) accs = (map_tailrec f as ((f a)#accs))\""], ["", "lemma map_tailrec_is_listmap: \"rev (map_tailrec f l accs) = (rev accs)@(List.map f l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (Efficient_Distinct.map_tailrec f l accs) = rev accs @ map f l", "by (induction l accs rule: map_tailrec.induct) auto"], ["", "definition efficient_map :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a list \\<Rightarrow> 'b list\" where\n    \"efficient_map f l \\<equiv> rev (map_tailrec f l [])\""], ["", "lemma [code]: \"List.map f l = efficient_map f l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f l = efficient_map f l", "by (simp add: efficient_map_def map_tailrec_is_listmap)"], ["", "text\\<open>@{const merge}\\<close>"], ["", "(*inefficient version*)"], ["", "fun merge_tailrec_inefficient :: \"('a::linorder) list \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n    \"merge_tailrec_inefficient (a#as) (b#bs) accs = (if a < b\n      then merge_tailrec_inefficient (as) (b#bs) (accs@[a])\n      else if a = b then merge_tailrec_inefficient (as) (bs) (accs@[a])\n      else merge_tailrec_inefficient (a#as) (bs) (accs@[b]))\"\n  | \"merge_tailrec_inefficient [] bs accs= accs@bs\"\n  | \"merge_tailrec_inefficient as [] accs = accs@as\""], ["", "lemma merge_tailrec_inefficient_prepend:\n  \"merge_tailrec_inefficient as bs (a # accs) = a # merge_tailrec_inefficient as bs accs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_tailrec_inefficient as bs (a # accs) =\n    a # merge_tailrec_inefficient as bs accs", "by (induction as bs accs rule: merge_tailrec_inefficient.induct) auto"], ["", "lemma merge_as_tailrec_inefficient: \"merge as bs = merge_tailrec_inefficient as bs []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge as bs = merge_tailrec_inefficient as bs []", "by (induction as bs rule: merge.induct)  (auto simp: merge_tailrec_inefficient_prepend)"], ["", "fun merge_tailrec :: \"('a::linorder) list \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n    \"merge_tailrec (a#as) (b#bs) accs = (if a < b\n      then merge_tailrec (as) (b#bs) (a#accs)\n      else if a = b then merge_tailrec (as) (bs) (a#accs)\n      else merge_tailrec (a#as) (bs) (b#accs))\"\n  | \"merge_tailrec [] bs accs= (rev accs)@bs\"\n  | \"merge_tailrec as [] accs = (rev accs)@as\""], ["", "lemma merge_tailrec_listappend:\n    \"merge_tailrec as bs (accs1@accs2) = (rev accs2)@(merge_tailrec as bs accs1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_tailrec as bs (accs1 @ accs2) =\n    rev accs2 @ merge_tailrec as bs accs1", "proof (induction as bs \"accs1@accs2\" arbitrary: accs1 accs2 rule: merge_tailrec.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a as b bs accs1 accs2.\n       \\<lbrakk>\\<And>accs1a accs2a.\n                   \\<lbrakk>a < b;\n                    a # accs1 @ accs2 = accs1a @ accs2a\\<rbrakk>\n                   \\<Longrightarrow> merge_tailrec as (b # bs)\n(accs1a @ accs2a) =\n                                     rev accs2a @\n                                     merge_tailrec as (b # bs) accs1a;\n        \\<And>accs1a accs2a.\n           \\<lbrakk>\\<not> a < b; a = b;\n            a # accs1 @ accs2 = accs1a @ accs2a\\<rbrakk>\n           \\<Longrightarrow> merge_tailrec as bs (accs1a @ accs2a) =\n                             rev accs2a @ merge_tailrec as bs accs1a;\n        \\<And>accs1a accs2a.\n           \\<lbrakk>\\<not> a < b; a \\<noteq> b;\n            b # accs1 @ accs2 = accs1a @ accs2a\\<rbrakk>\n           \\<Longrightarrow> merge_tailrec (a # as) bs (accs1a @ accs2a) =\n                             rev accs2a @\n                             merge_tailrec (a # as) bs accs1a\\<rbrakk>\n       \\<Longrightarrow> merge_tailrec (a # as) (b # bs) (accs1 @ accs2) =\n                         rev accs2 @ merge_tailrec (a # as) (b # bs) accs1\n 2. \\<And>bs accs1 accs2.\n       merge_tailrec [] bs (accs1 @ accs2) =\n       rev accs2 @ merge_tailrec [] bs accs1\n 3. \\<And>v va accs1 accs2.\n       merge_tailrec (v # va) [] (accs1 @ accs2) =\n       rev accs2 @ merge_tailrec (v # va) [] accs1", "case (1 a as b bs)"], ["proof (state)\nthis:\n  \\<lbrakk>a < b; a # accs1 @ accs2 = ?accs1.0 @ ?accs2.0\\<rbrakk>\n  \\<Longrightarrow> merge_tailrec as (b # bs) (?accs1.0 @ ?accs2.0) =\n                    rev ?accs2.0 @ merge_tailrec as (b # bs) ?accs1.0\n  \\<lbrakk>\\<not> a < b; a = b;\n   a # accs1 @ accs2 = ?accs1.0 @ ?accs2.0\\<rbrakk>\n  \\<Longrightarrow> merge_tailrec as bs (?accs1.0 @ ?accs2.0) =\n                    rev ?accs2.0 @ merge_tailrec as bs ?accs1.0\n  \\<lbrakk>\\<not> a < b; a \\<noteq> b;\n   b # accs1 @ accs2 = ?accs1.0 @ ?accs2.0\\<rbrakk>\n  \\<Longrightarrow> merge_tailrec (a # as) bs (?accs1.0 @ ?accs2.0) =\n                    rev ?accs2.0 @ merge_tailrec (a # as) bs ?accs1.0\n\ngoal (3 subgoals):\n 1. \\<And>a as b bs accs1 accs2.\n       \\<lbrakk>\\<And>accs1a accs2a.\n                   \\<lbrakk>a < b;\n                    a # accs1 @ accs2 = accs1a @ accs2a\\<rbrakk>\n                   \\<Longrightarrow> merge_tailrec as (b # bs)\n(accs1a @ accs2a) =\n                                     rev accs2a @\n                                     merge_tailrec as (b # bs) accs1a;\n        \\<And>accs1a accs2a.\n           \\<lbrakk>\\<not> a < b; a = b;\n            a # accs1 @ accs2 = accs1a @ accs2a\\<rbrakk>\n           \\<Longrightarrow> merge_tailrec as bs (accs1a @ accs2a) =\n                             rev accs2a @ merge_tailrec as bs accs1a;\n        \\<And>accs1a accs2a.\n           \\<lbrakk>\\<not> a < b; a \\<noteq> b;\n            b # accs1 @ accs2 = accs1a @ accs2a\\<rbrakk>\n           \\<Longrightarrow> merge_tailrec (a # as) bs (accs1a @ accs2a) =\n                             rev accs2a @\n                             merge_tailrec (a # as) bs accs1a\\<rbrakk>\n       \\<Longrightarrow> merge_tailrec (a # as) (b # bs) (accs1 @ accs2) =\n                         rev accs2 @ merge_tailrec (a # as) (b # bs) accs1\n 2. \\<And>bs accs1 accs2.\n       merge_tailrec [] bs (accs1 @ accs2) =\n       rev accs2 @ merge_tailrec [] bs accs1\n 3. \\<And>v va accs1 accs2.\n       merge_tailrec (v # va) [] (accs1 @ accs2) =\n       rev accs2 @ merge_tailrec (v # va) [] accs1", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>a < b; a # accs1 @ accs2 = ?accs1.0 @ ?accs2.0\\<rbrakk>\n  \\<Longrightarrow> merge_tailrec as (b # bs) (?accs1.0 @ ?accs2.0) =\n                    rev ?accs2.0 @ merge_tailrec as (b # bs) ?accs1.0\n  \\<lbrakk>\\<not> a < b; a = b;\n   a # accs1 @ accs2 = ?accs1.0 @ ?accs2.0\\<rbrakk>\n  \\<Longrightarrow> merge_tailrec as bs (?accs1.0 @ ?accs2.0) =\n                    rev ?accs2.0 @ merge_tailrec as bs ?accs1.0\n  \\<lbrakk>\\<not> a < b; a \\<noteq> b;\n   b # accs1 @ accs2 = ?accs1.0 @ ?accs2.0\\<rbrakk>\n  \\<Longrightarrow> merge_tailrec (a # as) bs (?accs1.0 @ ?accs2.0) =\n                    rev ?accs2.0 @ merge_tailrec (a # as) bs ?accs1.0\n\ngoal (1 subgoal):\n 1. merge_tailrec (a # as) (b # bs) (accs1 @ accs2) =\n    rev accs2 @ merge_tailrec (a # as) (b # bs) accs1", "by (cases a b rule: linorder_cases) (metis append_Cons merge_tailrec.simps(1))+"], ["proof (state)\nthis:\n  merge_tailrec (a # as) (b # bs) (accs1 @ accs2) =\n  rev accs2 @ merge_tailrec (a # as) (b # bs) accs1\n\ngoal (2 subgoals):\n 1. \\<And>bs accs1 accs2.\n       merge_tailrec [] bs (accs1 @ accs2) =\n       rev accs2 @ merge_tailrec [] bs accs1\n 2. \\<And>v va accs1 accs2.\n       merge_tailrec (v # va) [] (accs1 @ accs2) =\n       rev accs2 @ merge_tailrec (v # va) [] accs1", "qed auto"], ["", "lemma merge_tailrec_acc_append: \n    \"merge_tailrec as bs (accs@[a]) = a#(merge_tailrec as bs (accs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_tailrec as bs (accs @ [a]) = a # merge_tailrec as bs accs", "by (induction as bs accs rule: merge_tailrec.induct) auto"], ["", "lemma merge_inefficient_as_efficient:\n    \"merge_tailrec_inefficient as bs (rev accs) = (merge_tailrec as bs accs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_tailrec_inefficient as bs (rev accs) = merge_tailrec as bs accs", "proof (induction as bs accs arbitrary: accs rule: merge_tailrec_inefficient.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a as b bs accs accsa.\n       \\<lbrakk>\\<And>accs.\n                   a < b \\<Longrightarrow>\n                   merge_tailrec_inefficient as (b # bs) (rev accs) =\n                   merge_tailrec as (b # bs) accs;\n        \\<And>accs.\n           \\<lbrakk>\\<not> a < b; a = b\\<rbrakk>\n           \\<Longrightarrow> merge_tailrec_inefficient as bs (rev accs) =\n                             merge_tailrec as bs accs;\n        \\<And>accs.\n           \\<lbrakk>\\<not> a < b; a \\<noteq> b\\<rbrakk>\n           \\<Longrightarrow> merge_tailrec_inefficient (a # as) bs\n                              (rev accs) =\n                             merge_tailrec (a # as) bs accs\\<rbrakk>\n       \\<Longrightarrow> merge_tailrec_inefficient (a # as) (b # bs)\n                          (rev accsa) =\n                         merge_tailrec (a # as) (b # bs) accsa\n 2. \\<And>bs accs accsa.\n       merge_tailrec_inefficient [] bs (rev accsa) =\n       merge_tailrec [] bs accsa\n 3. \\<And>v va accs accsa.\n       merge_tailrec_inefficient (v # va) [] (rev accsa) =\n       merge_tailrec (v # va) [] accsa", "case (1 a as b bs)"], ["proof (state)\nthis:\n  a < b \\<Longrightarrow>\n  merge_tailrec_inefficient as (b # bs) (rev ?accs) =\n  merge_tailrec as (b # bs) ?accs\n  \\<lbrakk>\\<not> a < b; a = b\\<rbrakk>\n  \\<Longrightarrow> merge_tailrec_inefficient as bs (rev ?accs) =\n                    merge_tailrec as bs ?accs\n  \\<lbrakk>\\<not> a < b; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> merge_tailrec_inefficient (a # as) bs (rev ?accs) =\n                    merge_tailrec (a # as) bs ?accs\n\ngoal (3 subgoals):\n 1. \\<And>a as b bs accs accsa.\n       \\<lbrakk>\\<And>accs.\n                   a < b \\<Longrightarrow>\n                   merge_tailrec_inefficient as (b # bs) (rev accs) =\n                   merge_tailrec as (b # bs) accs;\n        \\<And>accs.\n           \\<lbrakk>\\<not> a < b; a = b\\<rbrakk>\n           \\<Longrightarrow> merge_tailrec_inefficient as bs (rev accs) =\n                             merge_tailrec as bs accs;\n        \\<And>accs.\n           \\<lbrakk>\\<not> a < b; a \\<noteq> b\\<rbrakk>\n           \\<Longrightarrow> merge_tailrec_inefficient (a # as) bs\n                              (rev accs) =\n                             merge_tailrec (a # as) bs accs\\<rbrakk>\n       \\<Longrightarrow> merge_tailrec_inefficient (a # as) (b # bs)\n                          (rev accsa) =\n                         merge_tailrec (a # as) (b # bs) accsa\n 2. \\<And>bs accs accsa.\n       merge_tailrec_inefficient [] bs (rev accsa) =\n       merge_tailrec [] bs accsa\n 3. \\<And>v va accs accsa.\n       merge_tailrec_inefficient (v # va) [] (rev accsa) =\n       merge_tailrec (v # va) [] accsa", "thus ?case"], ["proof (prove)\nusing this:\n  a < b \\<Longrightarrow>\n  merge_tailrec_inefficient as (b # bs) (rev ?accs) =\n  merge_tailrec as (b # bs) ?accs\n  \\<lbrakk>\\<not> a < b; a = b\\<rbrakk>\n  \\<Longrightarrow> merge_tailrec_inefficient as bs (rev ?accs) =\n                    merge_tailrec as bs ?accs\n  \\<lbrakk>\\<not> a < b; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> merge_tailrec_inefficient (a # as) bs (rev ?accs) =\n                    merge_tailrec (a # as) bs ?accs\n\ngoal (1 subgoal):\n 1. merge_tailrec_inefficient (a # as) (b # bs) (rev accs) =\n    merge_tailrec (a # as) (b # bs) accs", "by (cases a b rule: linorder_cases) (metis merge_tailrec.simps(1) merge_tailrec_inefficient.simps(1) rev.simps(2))+"], ["proof (state)\nthis:\n  merge_tailrec_inefficient (a # as) (b # bs) (rev accs) =\n  merge_tailrec (a # as) (b # bs) accs\n\ngoal (2 subgoals):\n 1. \\<And>bs accs accsa.\n       merge_tailrec_inefficient [] bs (rev accsa) =\n       merge_tailrec [] bs accsa\n 2. \\<And>v va accs accsa.\n       merge_tailrec_inefficient (v # va) [] (rev accsa) =\n       merge_tailrec (v # va) [] accsa", "qed auto"], ["", "lemma [code]: \"merge as bs = merge_tailrec as bs []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge as bs = merge_tailrec as bs []", "apply (subst merge_as_tailrec_inefficient)"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_tailrec_inefficient as bs [] = merge_tailrec as bs []", "apply (subst merge_inefficient_as_efficient[where accs = \"[]\", unfolded rev.simps(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_tailrec as bs [] = merge_tailrec as bs []", "apply (rule refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*import scala.annotation.tailrec*)"], ["", "export_code distinct checking Scala"], ["", "value \"distinct [(CHR ''A'')]\""], ["", "value \"distinct [''a'', ''b'']\""], ["", "value \"distinct [(''a'', ''b'')]\""], ["", "value \"distinct (map fst [(''a'', ''b''), (''a'', ''c'')])\""], ["", "end"]]}