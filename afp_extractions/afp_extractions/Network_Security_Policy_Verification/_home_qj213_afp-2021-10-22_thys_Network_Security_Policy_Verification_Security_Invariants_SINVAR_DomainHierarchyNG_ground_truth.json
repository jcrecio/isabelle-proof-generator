{"file_name": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification/Security_Invariants/SINVAR_DomainHierarchyNG.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification", "problem_names": ["lemma \"hierarchy_next [Department ''i20'' [], Department ''i8'' [Department ''CoffeeMachine'' [], Department ''TeaMachine'' []]] \n        (''i8''--Leaf)\n        =\n        Some (Department ''i8'' [Department ''CoffeeMachine'' [], Department ''TeaMachine'' []])\"", "lemma \"hierarchy_next [Department ''i20'' [], Department ''i8'' [Department ''CoffeeMachine'' [], Department ''TeaMachine'' []]] \n        (''i8''--''whatsoever''--Leaf)\n        =\n        Some (Department ''i8'' [Department ''CoffeeMachine'' [], Department ''TeaMachine'' []])\"", "lemma \"hierarchy_next [Department ''i20'' [], Department ''i8'' [Department ''CoffeeMachine'' [], Department ''TeaMachine'' []]] \n        Leaf\n        = None\"", "lemma \"hierarchy_next [Department ''i20'' [], Department ''i8'' [Department ''CoffeeMachine'' [], Department ''TeaMachine'' []]] \n        (''i0''--Leaf)\n        = None\"", "lemma \"valid_hierarchy_pos (Department ''TUM'' []) Leaf\"", "lemma \"valid_hierarchy_pos (Department ''TUM'' []) Leaf\"", "lemma \"valid_hierarchy_pos (Department ''TUM'' []) (''TUM''--Leaf)\"", "lemma \"valid_hierarchy_pos (Department ''TUM'' []) (''TUM''--''facilityManagement''--Leaf) = False\"", "lemma \"valid_hierarchy_pos (Department ''TUM'' []) (''LMU''--Leaf) = False\"", "lemma \"valid_hierarchy_pos (Department ''TUM'' [Department ''i8'' [], (Department ''i20'' [])])  (''TUM''--Leaf)\"", "lemma \"valid_hierarchy_pos (Department ''TUM'' [Department ''i8'' [], Department ''i20'' []])  (''TUM''--''i8''--Leaf)\"", "lemma \"valid_hierarchy_pos \n        (Department ''TUM'' [\n           Department ''i8'' [\n            Department ''CoffeeMachine'' [],\n            Department ''TeaMachine'' []\n           ], \n           Department ''i20'' []\n        ]) \n        (''TUM''--''i8''--''CoffeeMachine''--Leaf)\"", "lemma \"valid_hierarchy_pos (Department ''TUM'' [Department ''i8'' [Department ''CoffeeMachine'' [], Department ''TeaMachine'' []], Department ''i20'' []]) \n        (''TUM''--''i8''--''CleanKitchen''--Leaf) = False\"", "lemma Leaf_Top: \"a \\<le> Leaf\"", "lemma Leaf_Top_Unique: \"Leaf \\<le> a = (a = Leaf)\"", "lemma no_Bot: \"n1 \\<noteq> n2 \\<Longrightarrow> z \\<le> n1 -- n1s \\<Longrightarrow> z \\<le> n2 -- n2s \\<Longrightarrow> False\"", "lemma uncomparable_sup_is_Top: \"n1 \\<noteq> n2 \\<Longrightarrow> n1 -- x \\<le> z \\<Longrightarrow> n2 -- y \\<le> z \\<Longrightarrow> z = Leaf\"", "lemma common_inf_imp_comparable: \"(z::domainNameDept) \\<le> a \\<Longrightarrow> z \\<le> b \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a\"", "lemma prepend_domain: \"a \\<le> b \\<Longrightarrow> x--a \\<le> x--b\"", "lemma unfold_dmain_leq: \"y \\<le> zn -- zns \\<Longrightarrow> \\<exists>yns. y = zn -- yns \\<and> yns \\<le> zns\"", "lemma less_eq_refl: \n      fixes x :: domainNameDept\n      shows \"x \\<le> y \\<Longrightarrow> y \\<le> z \\<Longrightarrow> x \\<le> z\"", "lemma \"(''TUM''--''BLUBB''--Leaf) \\<le> (''TUM''--Leaf)\"", "lemma \"(''TUM''--''i8''--Leaf) \\<le> (''TUM''--Leaf)\"", "lemma \"\\<not> (''TUM''--Leaf) \\<le> (''TUM''--''i8''--Leaf)\"", "lemma \"valid_hierarchy_pos (Department ''TUM'' [Department ''i8'' [], Department ''i20'' []]) (''TUM''--''i8''--Leaf)\"", "lemma \"(''TUM''--Leaf) \\<le> Leaf\"", "lemma \"valid_hierarchy_pos (Department ''TUM'' [Department ''i8'' [], Department ''i20'' []]) (Leaf)\"", "lemma \"\\<not> Leaf \\<le> (''TUM''--Leaf)\"", "lemma \"valid_hierarchy_pos (Department ''TUM'' [Department ''i8'' [], Department ''i20'' []]) (''TUM''--Leaf)\"", "lemma \"\\<not> (''TUM''--''BLUBB''--Leaf) \\<le> (''X''--''TUM''--''BLUBB''--Leaf)\"", "lemma \"(''TUM''--''i8''--''CoffeeMachine''--Leaf) \\<le> (''TUM''--''i8''--Leaf)\"", "lemma \"(''TUM''--''i8''--Leaf) \\<le> (''TUM''--''i8''--Leaf)\"", "lemma \"(''TUM''--''i8''--''CoffeeMachine''--Leaf) \\<le> (''TUM''--Leaf)\"", "lemma \"(''TUM''--''i8''--''CoffeeMachine''--Leaf) \\<le> (Leaf)\"", "lemma \"\\<not> (''TUM''--''i8''--Leaf) \\<le> (''TUM''--''i20''--Leaf)\"", "lemma \"\\<not> (''TUM''--''i20''--Leaf) \\<le> (''TUM''--''i8''--Leaf)\"", "lemma \"domainNameDeptChopOne (''i8''--''CoffeeMachine''--Leaf) = ''i8'' -- Leaf\"", "lemma \"domainNameDeptChopOne (''i8''--''CoffeeMachine''--''CoffeeSlave''--Leaf) = ''i8'' -- ''CoffeeMachine'' -- Leaf\"", "lemma \"domainNameDeptChopOne Leaf = Leaf\"", "theorem chopOne_not_decrease: \"dn \\<le> domainNameDeptChopOne dn\"", "lemma chopOneContinue: \"dpt \\<noteq> Leaf \\<Longrightarrow> domainNameDeptChopOne (name -- dpt) = name -- domainNameDeptChopOne (dpt)\"", "lemma \"domainNameChop (''i8''--''CoffeeMachine''--Leaf) 2 = Leaf\"", "lemma \"domainNameChop (''i8''--''CoffeeMachine''--''CoffeeSlave''--Leaf) 2 = ''i8''--Leaf\"", "lemma \"domainNameChop (''i8''--Leaf) 0 = ''i8''--Leaf\"", "lemma \"domainNameChop (Leaf) 8 = Leaf\"", "lemma chop0[simp]: \"domainNameChop dn 0 = dn\"", "lemma \"(domainNameDeptChopOne^^2) (''d1''--''d2''--''d3''--Leaf) = ''d1''--Leaf\"", "lemma domainNameChopFunApply: \"domainNameChop dn n = (domainNameDeptChopOne^^n) dn\"", "lemma domainNameChopRotateSuc: \"domainNameChop dn (Suc n) = domainNameDeptChopOne (domainNameChop dn n)\"", "lemma domainNameChopRotate: \"domainNameChop (domainNameDeptChopOne dn) n = domainNameDeptChopOne (domainNameChop dn n)\"", "theorem chop_not_decrease_hierarchy: \"dn \\<le> domainNameChop dn n\"", "lemma \"chop_sup (''a''--''b''--''c''--Leaf) (''a''--''b''--''d''--Leaf) = ''a'' -- ''b'' -- Leaf\"", "lemma \"chop_sup (''a''--''b''--''c''--Leaf) (''a''--''x''--''d''--Leaf) = ''a'' -- Leaf\"", "lemma \"chop_sup (''a''--''b''--''c''--Leaf) (''x''--''x''--''d''--Leaf) = Leaf\"", "lemma chop_sup_commute: \"chop_sup a b = chop_sup b a\"", "lemma chop_sup_max1: \"a \\<le> chop_sup a b\"", "lemma chop_sup_max2: \"b \\<le> chop_sup a b\"", "lemma chop_sup_is_sup: \"\\<forall>z. a \\<le> z \\<and> b \\<le> z \\<longrightarrow> chop_sup a b \\<le> z\"", "lemma \"is_Inf {Unassigned, DN Leaf} Unassigned\"", "lemma \"DN_inf (DN (''TUM''--''i8''--Leaf)) (DN (''TUM''--''i20''--Leaf)) = Unassigned\"", "lemma \"DN_inf (DN (''TUM''--''i8''--Leaf)) (DN (''TUM''--Leaf)) = DN (''TUM'' -- ''i8'' -- Leaf)\"", "lemma DN_inf_commute: \"DN_inf x y = DN_inf y x\"", "lemma DN_inf_is_inf: \"is_inf x y (DN_inf x y)\"", "lemma DN_sup_commute: \"DN_sup x y = DN_sup y x\"", "lemma DN_sup_is_sup: \"is_sup x y (DN_sup x y)\"", "lemma leq_domainNameTrust_refl: \"x \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t x\"", "lemma leq_domainNameTrust_NOT_trans: \"\\<exists>x y z. x \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t y \\<and> y \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t z \\<and> \\<not> x \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t z\"", "lemma leq_domainNameTrust_NOT_antisym: \"\\<exists>x y. x \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t y \\<and> y \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t x \\<and> x \\<noteq> y\"", "lemma \"verify_globals \\<lparr> nodes=set [1,2,3], edges=set [] \\<rparr> (\\<lambda>n. default_node_properties) (Department ''TUM'' [])\"", "lemma sinvar_mono: \"SecurityInvariant_withOffendingFlows.sinvar_mono sinvar\"", "lemma DomainHierarchyNG_ENF: \"SecurityInvariant_withOffendingFlows.sinvar_all_edges_normal_form sinvar (\\<lambda> s r. r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t s)\"", "lemma DomainHierarchyNG_ENF_refl: \"SecurityInvariant_withOffendingFlows.ENF_refl sinvar (\\<lambda> s r. r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t s)\"", "lemma unassigned_default_candidate: \"\\<forall>nP s r. \\<not> (nP r)  \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t (nP s) \\<longrightarrow> \\<not> (nP r)  \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t default_node_properties\"", "lemma DomainHierarchyNG_offending_set: \"SecurityInvariant_withOffendingFlows.set_offending_flows sinvar = DomainHierarchyNG_offending_set\"", "lemma Unassigned_unique_default: \"otherbot \\<noteq> default_node_properties \\<Longrightarrow>\n         \\<exists>G nP gP i f.\n            wf_graph G \\<and> \n            \\<not> sinvar G nP \\<and>\n            f \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows sinvar G nP \\<and>\n            sinvar (delete_edges G f) nP \\<and>\n            (i \\<in> fst ` f \\<and> sinvar G (nP(i := otherbot)))\"", "lemma TopoS_DomainHierarchyNG: \"SecurityInvariant sinvar default_node_properties receiver_violation\""], "translations": [["", "lemma \"hierarchy_next [Department ''i20'' [], Department ''i8'' [Department ''CoffeeMachine'' [], Department ''TeaMachine'' []]] \n        (''i8''--Leaf)\n        =\n        Some (Department ''i8'' [Department ''CoffeeMachine'' [], Department ''TeaMachine'' []])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hierarchy_next\n     [Department ''i20'' [],\n      Department ''i8''\n       [Department ''CoffeeMachine'' [], Department ''TeaMachine'' []]]\n     (''i8'' -- Leaf) =\n    Some\n     (Department ''i8''\n       [Department ''CoffeeMachine'' [], Department ''TeaMachine'' []])", "by eval"], ["", "lemma \"hierarchy_next [Department ''i20'' [], Department ''i8'' [Department ''CoffeeMachine'' [], Department ''TeaMachine'' []]] \n        (''i8''--''whatsoever''--Leaf)\n        =\n        Some (Department ''i8'' [Department ''CoffeeMachine'' [], Department ''TeaMachine'' []])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hierarchy_next\n     [Department ''i20'' [],\n      Department ''i8''\n       [Department ''CoffeeMachine'' [], Department ''TeaMachine'' []]]\n     (''i8'' -- ''whatsoever'' -- Leaf) =\n    Some\n     (Department ''i8''\n       [Department ''CoffeeMachine'' [], Department ''TeaMachine'' []])", "by eval"], ["", "lemma \"hierarchy_next [Department ''i20'' [], Department ''i8'' [Department ''CoffeeMachine'' [], Department ''TeaMachine'' []]] \n        Leaf\n        = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hierarchy_next\n     [Department ''i20'' [],\n      Department ''i8''\n       [Department ''CoffeeMachine'' [], Department ''TeaMachine'' []]]\n     Leaf =\n    None", "by eval"], ["", "lemma \"hierarchy_next [Department ''i20'' [], Department ''i8'' [Department ''CoffeeMachine'' [], Department ''TeaMachine'' []]] \n        (''i0''--Leaf)\n        = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hierarchy_next\n     [Department ''i20'' [],\n      Department ''i8''\n       [Department ''CoffeeMachine'' [], Department ''TeaMachine'' []]]\n     (''i0'' -- Leaf) =\n    None", "by eval"], ["", "text \\<open>Does a given @{typ domainNameDept} match the specified tree structure?\\<close>"], ["", "fun valid_hierarchy_pos :: \"domainTree \\<Rightarrow> domainNameDept \\<Rightarrow> bool\" where\n      \"valid_hierarchy_pos (Department d ds) Leaf = True\" |\n      \"valid_hierarchy_pos (Department d ds) (Dept n Leaf) = (d=n)\" |\n      \"valid_hierarchy_pos (Department d ds) (Dept n ns) = (n=d \\<and> \n        (case hierarchy_next ds ns of \n          None \\<Rightarrow> False |\n          Some t \\<Rightarrow> valid_hierarchy_pos t ns))\""], ["", "text \\<open>Examples:\\<close>"], ["", "lemma \"valid_hierarchy_pos (Department ''TUM'' []) Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_hierarchy_pos (Department ''TUM'' []) Leaf", "by eval"], ["", "lemma \"valid_hierarchy_pos (Department ''TUM'' []) Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_hierarchy_pos (Department ''TUM'' []) Leaf", "by eval"], ["", "lemma \"valid_hierarchy_pos (Department ''TUM'' []) (''TUM''--Leaf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_hierarchy_pos (Department ''TUM'' []) (''TUM'' -- Leaf)", "by eval"], ["", "lemma \"valid_hierarchy_pos (Department ''TUM'' []) (''TUM''--''facilityManagement''--Leaf) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_hierarchy_pos (Department ''TUM'' [])\n     (''TUM'' -- ''facilityManagement'' -- Leaf) =\n    False", "by eval"], ["", "lemma \"valid_hierarchy_pos (Department ''TUM'' []) (''LMU''--Leaf) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_hierarchy_pos (Department ''TUM'' []) (''LMU'' -- Leaf) = False", "by eval"], ["", "lemma \"valid_hierarchy_pos (Department ''TUM'' [Department ''i8'' [], (Department ''i20'' [])])  (''TUM''--Leaf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_hierarchy_pos\n     (Department ''TUM'' [Department ''i8'' [], Department ''i20'' []])\n     (''TUM'' -- Leaf)", "by eval"], ["", "lemma \"valid_hierarchy_pos (Department ''TUM'' [Department ''i8'' [], Department ''i20'' []])  (''TUM''--''i8''--Leaf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_hierarchy_pos\n     (Department ''TUM'' [Department ''i8'' [], Department ''i20'' []])\n     (''TUM'' -- ''i8'' -- Leaf)", "by eval"], ["", "lemma \"valid_hierarchy_pos \n        (Department ''TUM'' [\n           Department ''i8'' [\n            Department ''CoffeeMachine'' [],\n            Department ''TeaMachine'' []\n           ], \n           Department ''i20'' []\n        ]) \n        (''TUM''--''i8''--''CoffeeMachine''--Leaf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_hierarchy_pos\n     (Department ''TUM''\n       [Department ''i8''\n         [Department ''CoffeeMachine'' [], Department ''TeaMachine'' []],\n        Department ''i20'' []])\n     (''TUM'' -- ''i8'' -- ''CoffeeMachine'' -- Leaf)", "by eval"], ["", "lemma \"valid_hierarchy_pos (Department ''TUM'' [Department ''i8'' [Department ''CoffeeMachine'' [], Department ''TeaMachine'' []], Department ''i20'' []]) \n        (''TUM''--''i8''--''CleanKitchen''--Leaf) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_hierarchy_pos\n     (Department ''TUM''\n       [Department ''i8''\n         [Department ''CoffeeMachine'' [], Department ''TeaMachine'' []],\n        Department ''i20'' []])\n     (''TUM'' -- ''i8'' -- ''CleanKitchen'' -- Leaf) =\n    False", "by eval"], ["", "(*end tree*)"], ["", "instantiation domainNameDept :: order\n  begin"], ["", "print_context"], ["", "fun less_eq_domainNameDept :: \"domainNameDept \\<Rightarrow> domainNameDept \\<Rightarrow> bool\" where\n      \"Leaf \\<le> (Dept _ _) = False\" |\n      \"(Dept _ _) \\<le> Leaf = True\" |\n      \"Leaf \\<le> Leaf = True\" |\n      \"(Dept n1 n1s) \\<le> (Dept n2 n2s) = (n1=n2 \\<and> n1s \\<le> n2s)\""], ["", "fun less_domainNameDept :: \"domainNameDept \\<Rightarrow> domainNameDept \\<Rightarrow> bool\" where\n      \"Leaf < Leaf = False\" |\n      \"Leaf < (Dept _ _) = False\" |\n      \"(Dept _ _) < Leaf = True\" |\n      \"(Dept n1 n1s) < (Dept n2 n2s) = (n1=n2 \\<and> n1s < n2s)\""], ["", "lemma Leaf_Top: \"a \\<le> Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> Leaf", "apply(case_tac a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x11 x12. a = x11 -- x12 \\<Longrightarrow> a \\<le> Leaf\n 2. a = Leaf \\<Longrightarrow> a \\<le> Leaf", "by(simp_all)"], ["", "lemma Leaf_Top_Unique: \"Leaf \\<le> a = (a = Leaf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Leaf \\<le> a) = (a = Leaf)", "apply(case_tac a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       a = x11 -- x12 \\<Longrightarrow> (Leaf \\<le> a) = (a = Leaf)\n 2. a = Leaf \\<Longrightarrow> (Leaf \\<le> a) = (a = Leaf)", "by(simp_all)"], ["", "lemma no_Bot: \"n1 \\<noteq> n2 \\<Longrightarrow> z \\<le> n1 -- n1s \\<Longrightarrow> z \\<le> n2 -- n2s \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n1 \\<noteq> n2; z \\<le> n1 -- n1s; z \\<le> n2 -- n2s\\<rbrakk>\n    \\<Longrightarrow> False", "apply(case_tac z)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>n1 \\<noteq> n2; z \\<le> n1 -- n1s; z \\<le> n2 -- n2s;\n        z = x11 -- x12\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>n1 \\<noteq> n2; z \\<le> n1 -- n1s; z \\<le> n2 -- n2s;\n     z = Leaf\\<rbrakk>\n    \\<Longrightarrow> False", "by(simp_all)"], ["", "lemma uncomparable_sup_is_Top: \"n1 \\<noteq> n2 \\<Longrightarrow> n1 -- x \\<le> z \\<Longrightarrow> n2 -- y \\<le> z \\<Longrightarrow> z = Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n1 \\<noteq> n2; n1 -- x \\<le> z; n2 -- y \\<le> z\\<rbrakk>\n    \\<Longrightarrow> z = Leaf", "apply(case_tac z)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>n1 \\<noteq> n2; n1 -- x \\<le> z; n2 -- y \\<le> z;\n        z = x11 -- x12\\<rbrakk>\n       \\<Longrightarrow> z = Leaf\n 2. \\<lbrakk>n1 \\<noteq> n2; n1 -- x \\<le> z; n2 -- y \\<le> z;\n     z = Leaf\\<rbrakk>\n    \\<Longrightarrow> z = Leaf", "by(simp_all)"], ["", "lemma common_inf_imp_comparable: \"(z::domainNameDept) \\<le> a \\<Longrightarrow> z \\<le> b \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<le> a; z \\<le> b\\<rbrakk>\n    \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a", "apply(induction z arbitrary: a b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 z a b.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>z \\<le> a; z \\<le> b\\<rbrakk>\n                   \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a;\n        x1 -- z \\<le> a; x1 -- z \\<le> b\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a\n 2. \\<And>a b.\n       \\<lbrakk>Leaf \\<le> a; Leaf \\<le> b\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a", "apply(rename_tac zn zdpt a b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>zn zdpt a b.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>zdpt \\<le> a; zdpt \\<le> b\\<rbrakk>\n                   \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a;\n        zn -- zdpt \\<le> a; zn -- zdpt \\<le> b\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a\n 2. \\<And>a b.\n       \\<lbrakk>Leaf \\<le> a; Leaf \\<le> b\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a", "apply(simp_all add: Leaf_Top_Unique)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zn zdpt a b.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>zdpt \\<le> a; zdpt \\<le> b\\<rbrakk>\n                   \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a;\n        zn -- zdpt \\<le> a; zn -- zdpt \\<le> b\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a", "apply(case_tac a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>zn zdpt a b x11 x12.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>zdpt \\<le> a; zdpt \\<le> b\\<rbrakk>\n                   \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a;\n        zn -- zdpt \\<le> a; zn -- zdpt \\<le> b; a = x11 -- x12\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a\n 2. \\<And>zn zdpt a b.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>zdpt \\<le> a; zdpt \\<le> b\\<rbrakk>\n                   \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a;\n        zn -- zdpt \\<le> a; zn -- zdpt \\<le> b; a = Leaf\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a", "apply(rename_tac an adpt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>zn zdpt a b an adpt.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>zdpt \\<le> a; zdpt \\<le> b\\<rbrakk>\n                   \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a;\n        zn -- zdpt \\<le> a; zn -- zdpt \\<le> b; a = an -- adpt\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a\n 2. \\<And>zn zdpt a b.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>zdpt \\<le> a; zdpt \\<le> b\\<rbrakk>\n                   \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a;\n        zn -- zdpt \\<le> a; zn -- zdpt \\<le> b; a = Leaf\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a", "apply(simp_all add: Leaf_Top)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zn zdpt a b adpt.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>zdpt \\<le> a; zdpt \\<le> b\\<rbrakk>\n                   \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a;\n        zdpt \\<le> adpt; zn -- zdpt \\<le> b; a = zn -- adpt\\<rbrakk>\n       \\<Longrightarrow> zn -- adpt \\<le> b \\<or> b \\<le> zn -- adpt", "apply(case_tac b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>zn zdpt a b adpt x11 x12.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>zdpt \\<le> a; zdpt \\<le> b\\<rbrakk>\n                   \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a;\n        zdpt \\<le> adpt; zn -- zdpt \\<le> b; a = zn -- adpt;\n        b = x11 -- x12\\<rbrakk>\n       \\<Longrightarrow> zn -- adpt \\<le> b \\<or> b \\<le> zn -- adpt\n 2. \\<And>zn zdpt a b adpt.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>zdpt \\<le> a; zdpt \\<le> b\\<rbrakk>\n                   \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a;\n        zdpt \\<le> adpt; zn -- zdpt \\<le> b; a = zn -- adpt;\n        b = Leaf\\<rbrakk>\n       \\<Longrightarrow> zn -- adpt \\<le> b \\<or> b \\<le> zn -- adpt", "apply(rename_tac bn bdpt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>zn zdpt a b adpt bn bdpt.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>zdpt \\<le> a; zdpt \\<le> b\\<rbrakk>\n                   \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a;\n        zdpt \\<le> adpt; zn -- zdpt \\<le> b; a = zn -- adpt;\n        b = bn -- bdpt\\<rbrakk>\n       \\<Longrightarrow> zn -- adpt \\<le> b \\<or> b \\<le> zn -- adpt\n 2. \\<And>zn zdpt a b adpt.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>zdpt \\<le> a; zdpt \\<le> b\\<rbrakk>\n                   \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a;\n        zdpt \\<le> adpt; zn -- zdpt \\<le> b; a = zn -- adpt;\n        b = Leaf\\<rbrakk>\n       \\<Longrightarrow> zn -- adpt \\<le> b \\<or> b \\<le> zn -- adpt", "apply(simp_all add: Leaf_Top)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma prepend_domain: \"a \\<le> b \\<Longrightarrow> x--a \\<le> x--b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow> x -- a \\<le> x -- b", "by(simp)"], ["", "lemma unfold_dmain_leq: \"y \\<le> zn -- zns \\<Longrightarrow> \\<exists>yns. y = zn -- yns \\<and> yns \\<le> zns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> zn -- zns \\<Longrightarrow>\n    \\<exists>yns. y = zn -- yns \\<and> yns \\<le> zns", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<le> zn -- zns \\<Longrightarrow>\n    \\<exists>yns. y = zn -- yns \\<and> yns \\<le> zns", "assume a1: \"y \\<le> zn -- zns\""], ["proof (state)\nthis:\n  y \\<le> zn -- zns\n\ngoal (1 subgoal):\n 1. y \\<le> zn -- zns \\<Longrightarrow>\n    \\<exists>yns. y = zn -- yns \\<and> yns \\<le> zns", "obtain sk\\<^sub>3\\<^sub>0 :: \"domainNameDept \\<Rightarrow> char list\" and sk\\<^sub>3\\<^sub>1 :: \"domainNameDept \\<Rightarrow> domainNameDept\" where \"\\<forall>x\\<^sub>0. sk\\<^sub>3\\<^sub>0 x\\<^sub>0 -- sk\\<^sub>3\\<^sub>1 x\\<^sub>0 = x\\<^sub>0 \\<or> Leaf = x\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sk\\<^sub>3\\<^sub>0 sk\\<^sub>3\\<^sub>1.\n        \\<forall>x\\<^sub>0.\n           sk\\<^sub>3\\<^sub>0 x\\<^sub>0 -- sk\\<^sub>3\\<^sub>1 x\\<^sub>0 =\n           x\\<^sub>0 \\<or>\n           Leaf = x\\<^sub>0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis domainNameDept.exhaust)"], ["proof (state)\nthis:\n  \\<forall>x\\<^sub>0.\n     sk\\<^sub>3\\<^sub>0 x\\<^sub>0 -- sk\\<^sub>3\\<^sub>1 x\\<^sub>0 =\n     x\\<^sub>0 \\<or>\n     Leaf = x\\<^sub>0\n\ngoal (1 subgoal):\n 1. y \\<le> zn -- zns \\<Longrightarrow>\n    \\<exists>yns. y = zn -- yns \\<and> yns \\<le> zns", "thus \"\\<exists>yns. y = zn -- yns \\<and> yns \\<le> zns\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<^sub>0.\n     sk\\<^sub>3\\<^sub>0 x\\<^sub>0 -- sk\\<^sub>3\\<^sub>1 x\\<^sub>0 =\n     x\\<^sub>0 \\<or>\n     Leaf = x\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<exists>yns. y = zn -- yns \\<and> yns \\<le> zns", "using a1"], ["proof (prove)\nusing this:\n  \\<forall>x\\<^sub>0.\n     sk\\<^sub>3\\<^sub>0 x\\<^sub>0 -- sk\\<^sub>3\\<^sub>1 x\\<^sub>0 =\n     x\\<^sub>0 \\<or>\n     Leaf = x\\<^sub>0\n  y \\<le> zn -- zns\n\ngoal (1 subgoal):\n 1. \\<exists>yns. y = zn -- yns \\<and> yns \\<le> zns", "by (metis less_eq_domainNameDept.simps(1) less_eq_domainNameDept.simps(4))"], ["proof (state)\nthis:\n  \\<exists>yns. y = zn -- yns \\<and> yns \\<le> zns\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma less_eq_refl: \n      fixes x :: domainNameDept\n      shows \"x \\<le> y \\<Longrightarrow> y \\<le> z \\<Longrightarrow> x \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "have \"x \\<le> y \\<longrightarrow> y \\<le> z \\<longrightarrow> x \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<longrightarrow> y \\<le> z \\<longrightarrow> x \\<le> z", "(*induction over prems and conclusion*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<longrightarrow> y \\<le> z \\<longrightarrow> x \\<le> z", "proof(induction z arbitrary:x y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 z x y.\n       (\\<And>x y.\n           x \\<le> y \\<longrightarrow>\n           y \\<le> z \\<longrightarrow> x \\<le> z) \\<Longrightarrow>\n       x \\<le> y \\<longrightarrow>\n       y \\<le> x1 -- z \\<longrightarrow> x \\<le> x1 -- z\n 2. \\<And>x y.\n       x \\<le> y \\<longrightarrow>\n       y \\<le> Leaf \\<longrightarrow> x \\<le> Leaf", "case Leaf"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x1 z x y.\n       (\\<And>x y.\n           x \\<le> y \\<longrightarrow>\n           y \\<le> z \\<longrightarrow> x \\<le> z) \\<Longrightarrow>\n       x \\<le> y \\<longrightarrow>\n       y \\<le> x1 -- z \\<longrightarrow> x \\<le> x1 -- z\n 2. \\<And>x y.\n       x \\<le> y \\<longrightarrow>\n       y \\<le> Leaf \\<longrightarrow> x \\<le> Leaf", "have \"x \\<le> Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> Leaf", "using Leaf_Top"], ["proof (prove)\nusing this:\n  ?a \\<le> Leaf\n\ngoal (1 subgoal):\n 1. x \\<le> Leaf", "by simp"], ["proof (state)\nthis:\n  x \\<le> Leaf\n\ngoal (2 subgoals):\n 1. \\<And>x1 z x y.\n       (\\<And>x y.\n           x \\<le> y \\<longrightarrow>\n           y \\<le> z \\<longrightarrow> x \\<le> z) \\<Longrightarrow>\n       x \\<le> y \\<longrightarrow>\n       y \\<le> x1 -- z \\<longrightarrow> x \\<le> x1 -- z\n 2. \\<And>x y.\n       x \\<le> y \\<longrightarrow>\n       y \\<le> Leaf \\<longrightarrow> x \\<le> Leaf", "thus ?case"], ["proof (prove)\nusing this:\n  x \\<le> Leaf\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<longrightarrow> y \\<le> Leaf \\<longrightarrow> x \\<le> Leaf", "by simp"], ["proof (state)\nthis:\n  x \\<le> y \\<longrightarrow> y \\<le> Leaf \\<longrightarrow> x \\<le> Leaf\n\ngoal (1 subgoal):\n 1. \\<And>x1 z x y.\n       (\\<And>x y.\n           x \\<le> y \\<longrightarrow>\n           y \\<le> z \\<longrightarrow> x \\<le> z) \\<Longrightarrow>\n       x \\<le> y \\<longrightarrow>\n       y \\<le> x1 -- z \\<longrightarrow> x \\<le> x1 -- z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 z x y.\n       (\\<And>x y.\n           x \\<le> y \\<longrightarrow>\n           y \\<le> z \\<longrightarrow> x \\<le> z) \\<Longrightarrow>\n       x \\<le> y \\<longrightarrow>\n       y \\<le> x1 -- z \\<longrightarrow> x \\<le> x1 -- z", "case (Dept zn zns)"], ["proof (state)\nthis:\n  ?x \\<le> ?y \\<longrightarrow> ?y \\<le> zns \\<longrightarrow> ?x \\<le> zns\n\ngoal (1 subgoal):\n 1. \\<And>x1 z x y.\n       (\\<And>x y.\n           x \\<le> y \\<longrightarrow>\n           y \\<le> z \\<longrightarrow> x \\<le> z) \\<Longrightarrow>\n       x \\<le> y \\<longrightarrow>\n       y \\<le> x1 -- z \\<longrightarrow> x \\<le> x1 -- z", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<longrightarrow>\n    y \\<le> zn -- zns \\<longrightarrow> x \\<le> zn -- zns", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> zn -- zns\\<rbrakk>\n    \\<Longrightarrow> x \\<le> zn -- zns", "assume a1: \"x \\<le> y\" and a2: \"y \\<le> zn--zns\""], ["proof (state)\nthis:\n  x \\<le> y\n  y \\<le> zn -- zns\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> zn -- zns\\<rbrakk>\n    \\<Longrightarrow> x \\<le> zn -- zns", "from unfold_dmain_leq[OF a2]"], ["proof (chain)\npicking this:\n  \\<exists>yns. y = zn -- yns \\<and> yns \\<le> zns", "obtain yns where y1: \"y = zn--yns\" and y2: \"yns \\<le> zns\""], ["proof (prove)\nusing this:\n  \\<exists>yns. y = zn -- yns \\<and> yns \\<le> zns\n\ngoal (1 subgoal):\n 1. (\\<And>yns.\n        \\<lbrakk>y = zn -- yns; yns \\<le> zns\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y = zn -- yns\n  yns \\<le> zns\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> zn -- zns\\<rbrakk>\n    \\<Longrightarrow> x \\<le> zn -- zns", "from unfold_dmain_leq this a1"], ["proof (chain)\npicking this:\n  ?y \\<le> ?zn -- ?zns \\<Longrightarrow>\n  \\<exists>yns. ?y = ?zn -- yns \\<and> yns \\<le> ?zns\n  y = zn -- yns\n  yns \\<le> zns\n  x \\<le> y", "obtain xns where x1: \"x = zn -- xns\" and x2: \"xns \\<le> yns\""], ["proof (prove)\nusing this:\n  ?y \\<le> ?zn -- ?zns \\<Longrightarrow>\n  \\<exists>yns. ?y = ?zn -- yns \\<and> yns \\<le> ?zns\n  y = zn -- yns\n  yns \\<le> zns\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. (\\<And>xns.\n        \\<lbrakk>x = zn -- xns; xns \\<le> yns\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = zn -- xns\n  xns \\<le> yns\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> zn -- zns\\<rbrakk>\n    \\<Longrightarrow> x \\<le> zn -- zns", "from Dept y2 x2"], ["proof (chain)\npicking this:\n  ?x \\<le> ?y \\<longrightarrow> ?y \\<le> zns \\<longrightarrow> ?x \\<le> zns\n  yns \\<le> zns\n  xns \\<le> yns", "have \"xns \\<le> zns\""], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<longrightarrow> ?y \\<le> zns \\<longrightarrow> ?x \\<le> zns\n  yns \\<le> zns\n  xns \\<le> yns\n\ngoal (1 subgoal):\n 1. xns \\<le> zns", "by simp"], ["proof (state)\nthis:\n  xns \\<le> zns\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> zn -- zns\\<rbrakk>\n    \\<Longrightarrow> x \\<le> zn -- zns", "from this x1"], ["proof (chain)\npicking this:\n  xns \\<le> zns\n  x = zn -- xns", "show \"x \\<le> zn--zns\""], ["proof (prove)\nusing this:\n  xns \\<le> zns\n  x = zn -- xns\n\ngoal (1 subgoal):\n 1. x \\<le> zn -- zns", "by simp"], ["proof (state)\nthis:\n  x \\<le> zn -- zns\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<le> y \\<longrightarrow>\n  y \\<le> zn -- zns \\<longrightarrow> x \\<le> zn -- zns\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<le> y \\<longrightarrow> y \\<le> z \\<longrightarrow> x \\<le> z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "thus \"x \\<le> y \\<Longrightarrow> y \\<le> z \\<Longrightarrow> x \\<le> z\""], ["proof (prove)\nusing this:\n  x \\<le> y \\<longrightarrow> y \\<le> z \\<longrightarrow> x \\<le> z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n\ngoal:\nNo subgoals!", "qed"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(domainNameDept, order_class)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "fix x y ::domainNameDept"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "show \"(x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)", "apply(induction rule: less_domainNameDept.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. (Leaf < Leaf) = (Leaf \\<le> Leaf \\<and> \\<not> Leaf \\<le> Leaf)\n 2. \\<And>uu_ uv_.\n       (uu_ -- uv_ < Leaf) =\n       (uu_ -- uv_ \\<le> Leaf \\<and> \\<not> Leaf \\<le> uu_ -- uv_)\n 3. \\<And>uw_ ux_.\n       (Leaf < uw_ -- ux_) =\n       (Leaf \\<le> uw_ -- ux_ \\<and> \\<not> uw_ -- ux_ \\<le> Leaf)\n 4. \\<And>n1 n1s n2 n2s.\n       (n2s < n1s) =\n       (n2s \\<le> n1s \\<and> \\<not> n1s \\<le> n2s) \\<Longrightarrow>\n       (n2 -- n2s < n1 -- n1s) =\n       (n2 -- n2s \\<le> n1 -- n1s \\<and> \\<not> n1 -- n1s \\<le> n2 -- n2s)", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n1 n1s n2 n2s.\n       (n2s < n1s) =\n       (n2s \\<le> n1s \\<and> \\<not> n1s \\<le> n2s) \\<Longrightarrow>\n       (n2 = n1 \\<and> n2s \\<le> n1s \\<and> \\<not> n1s \\<le> n2s) =\n       (n2 = n1 \\<and>\n        n2s \\<le> n1s \\<and>\n        (n1 = n2 \\<longrightarrow> \\<not> n1s \\<le> n2s))", "by blast"], ["proof (state)\nthis:\n  (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n\ngoal (3 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "fix x::domainNameDept"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "show \"x \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x", "using[[show_types]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x\nvariables:\n  x :: domainNameDept", "apply(induction x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>(x1::char list) x::domainNameDept.\n       x \\<le> x \\<Longrightarrow> x1 -- x \\<le> x1 -- x\n 2. Leaf \\<le> Leaf\nvariables:\n  x :: domainNameDept", "by simp_all"], ["proof (state)\nthis:\n  x \\<le> x\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "fix x y z :: domainNameDept"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "show \"x \\<le> y \\<Longrightarrow> y \\<le> z \\<Longrightarrow> x \\<le> z \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "apply (rule less_eq_refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> ?y\n 2. \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> ?y \\<le> z", "by simp_all"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "fix x y ::domainNameDept"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "show \"x \\<le> y \\<Longrightarrow> y \\<le> x \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "apply(induction rule: less_domainNameDept.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>Leaf \\<le> Leaf; Leaf \\<le> Leaf\\<rbrakk>\n    \\<Longrightarrow> Leaf = Leaf\n 2. \\<And>uu_ uv_.\n       \\<lbrakk>Leaf \\<le> uu_ -- uv_; uu_ -- uv_ \\<le> Leaf\\<rbrakk>\n       \\<Longrightarrow> Leaf = uu_ -- uv_\n 3. \\<And>uw_ ux_.\n       \\<lbrakk>uw_ -- ux_ \\<le> Leaf; Leaf \\<le> uw_ -- ux_\\<rbrakk>\n       \\<Longrightarrow> uw_ -- ux_ = Leaf\n 4. \\<And>n1 n1s n2 n2s.\n       \\<lbrakk>\\<lbrakk>n1s \\<le> n2s; n2s \\<le> n1s\\<rbrakk>\n                \\<Longrightarrow> n1s = n2s;\n        n1 -- n1s \\<le> n2 -- n2s; n2 -- n2s \\<le> n1 -- n1s\\<rbrakk>\n       \\<Longrightarrow> n1 -- n1s = n2 -- n2s", "by(simp_all)"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation domainNameDept :: Orderings.top\n  begin"], ["", "definition top_domainNameDept where \"Orderings.top \\<equiv> Leaf\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(domainNameDept, top_class)", "by intro_classes"], ["", "end"], ["", "lemma \"(''TUM''--''BLUBB''--Leaf) \\<le> (''TUM''--Leaf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ''TUM'' -- ''BLUBB'' -- Leaf \\<le> ''TUM'' -- Leaf", "by eval"], ["", "lemma \"(''TUM''--''i8''--Leaf) \\<le> (''TUM''--Leaf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ''TUM'' -- ''i8'' -- Leaf \\<le> ''TUM'' -- Leaf", "by eval"], ["", "lemma \"\\<not> (''TUM''--Leaf) \\<le> (''TUM''--''i8''--Leaf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> ''TUM'' -- Leaf \\<le> ''TUM'' -- ''i8'' -- Leaf", "by eval"], ["", "lemma \"valid_hierarchy_pos (Department ''TUM'' [Department ''i8'' [], Department ''i20'' []]) (''TUM''--''i8''--Leaf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_hierarchy_pos\n     (Department ''TUM'' [Department ''i8'' [], Department ''i20'' []])\n     (''TUM'' -- ''i8'' -- Leaf)", "by eval"], ["", "lemma \"(''TUM''--Leaf) \\<le> Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ''TUM'' -- Leaf \\<le> Leaf", "by eval"], ["", "lemma \"valid_hierarchy_pos (Department ''TUM'' [Department ''i8'' [], Department ''i20'' []]) (Leaf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_hierarchy_pos\n     (Department ''TUM'' [Department ''i8'' [], Department ''i20'' []]) Leaf", "by eval"], ["", "lemma \"\\<not> Leaf \\<le> (''TUM''--Leaf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Leaf \\<le> ''TUM'' -- Leaf", "by eval"], ["", "lemma \"valid_hierarchy_pos (Department ''TUM'' [Department ''i8'' [], Department ''i20'' []]) (''TUM''--Leaf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_hierarchy_pos\n     (Department ''TUM'' [Department ''i8'' [], Department ''i20'' []])\n     (''TUM'' -- Leaf)", "by eval"], ["", "lemma \"\\<not> (''TUM''--''BLUBB''--Leaf) \\<le> (''X''--''TUM''--''BLUBB''--Leaf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> ''TUM'' -- ''BLUBB'' -- Leaf\n           \\<le> ''X'' -- ''TUM'' -- ''BLUBB'' -- Leaf", "by eval"], ["", "lemma \"(''TUM''--''i8''--''CoffeeMachine''--Leaf) \\<le> (''TUM''--''i8''--Leaf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ''TUM'' -- ''i8'' -- ''CoffeeMachine'' -- Leaf\n    \\<le> ''TUM'' -- ''i8'' -- Leaf", "by eval"], ["", "lemma \"(''TUM''--''i8''--Leaf) \\<le> (''TUM''--''i8''--Leaf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ''TUM'' -- ''i8'' -- Leaf \\<le> ''TUM'' -- ''i8'' -- Leaf", "by eval"], ["", "lemma \"(''TUM''--''i8''--''CoffeeMachine''--Leaf) \\<le> (''TUM''--Leaf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ''TUM'' -- ''i8'' -- ''CoffeeMachine'' -- Leaf \\<le> ''TUM'' -- Leaf", "by eval"], ["", "lemma \"(''TUM''--''i8''--''CoffeeMachine''--Leaf) \\<le> (Leaf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ''TUM'' -- ''i8'' -- ''CoffeeMachine'' -- Leaf \\<le> Leaf", "by eval"], ["", "lemma \"\\<not> (''TUM''--''i8''--Leaf) \\<le> (''TUM''--''i20''--Leaf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> ''TUM'' -- ''i8'' -- Leaf \\<le> ''TUM'' -- ''i20'' -- Leaf", "by eval"], ["", "lemma \"\\<not> (''TUM''--''i20''--Leaf) \\<le> (''TUM''--''i8''--Leaf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> ''TUM'' -- ''i20'' -- Leaf \\<le> ''TUM'' -- ''i8'' -- Leaf", "by eval"], ["", "subsubsection \\<open>Adding Chop\\<close>"], ["", "text\\<open>by putting entities higher in the hierarchy.\\<close>"], ["", "fun domainNameDeptChopOne :: \"domainNameDept \\<Rightarrow> domainNameDept\" where\n      \"domainNameDeptChopOne Leaf = Leaf\" |\n      \"domainNameDeptChopOne (name--Leaf) = Leaf\" |\n      \"domainNameDeptChopOne (name--dpt) = name--(domainNameDeptChopOne dpt)\""], ["", "lemma \"domainNameDeptChopOne (''i8''--''CoffeeMachine''--Leaf) = ''i8'' -- Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domainNameDeptChopOne (''i8'' -- ''CoffeeMachine'' -- Leaf) =\n    ''i8'' -- Leaf", "by eval"], ["", "lemma \"domainNameDeptChopOne (''i8''--''CoffeeMachine''--''CoffeeSlave''--Leaf) = ''i8'' -- ''CoffeeMachine'' -- Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domainNameDeptChopOne\n     (''i8'' -- ''CoffeeMachine'' -- ''CoffeeSlave'' -- Leaf) =\n    ''i8'' -- ''CoffeeMachine'' -- Leaf", "by eval"], ["", "lemma \"domainNameDeptChopOne Leaf = Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domainNameDeptChopOne Leaf = Leaf", "by(fact domainNameDeptChopOne.simps(1))"], ["", "theorem chopOne_not_decrease: \"dn \\<le> domainNameDeptChopOne dn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dn \\<le> domainNameDeptChopOne dn", "apply(induction dn)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 dn.\n       dn \\<le> domainNameDeptChopOne dn \\<Longrightarrow>\n       x1 -- dn \\<le> domainNameDeptChopOne (x1 -- dn)\n 2. Leaf \\<le> domainNameDeptChopOne Leaf", "apply(rename_tac name dpt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>name dpt.\n       dpt \\<le> domainNameDeptChopOne dpt \\<Longrightarrow>\n       name -- dpt \\<le> domainNameDeptChopOne (name -- dpt)\n 2. Leaf \\<le> domainNameDeptChopOne Leaf", "apply(drule_tac x=\"name\" in prepend_domain)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>name dpt.\n       name -- dpt \\<le> name -- domainNameDeptChopOne dpt \\<Longrightarrow>\n       name -- dpt \\<le> domainNameDeptChopOne (name -- dpt)\n 2. Leaf \\<le> domainNameDeptChopOne Leaf", "apply(case_tac dpt)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>name dpt x11 x12.\n       \\<lbrakk>name -- dpt \\<le> name -- domainNameDeptChopOne dpt;\n        dpt = x11 -- x12\\<rbrakk>\n       \\<Longrightarrow> name -- dpt\n                         \\<le> domainNameDeptChopOne (name -- dpt)\n 2. \\<And>name dpt.\n       \\<lbrakk>name -- dpt \\<le> name -- domainNameDeptChopOne dpt;\n        dpt = Leaf\\<rbrakk>\n       \\<Longrightarrow> name -- dpt\n                         \\<le> domainNameDeptChopOne (name -- dpt)\n 3. Leaf \\<le> domainNameDeptChopOne Leaf", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma chopOneContinue: \"dpt \\<noteq> Leaf \\<Longrightarrow> domainNameDeptChopOne (name -- dpt) = name -- domainNameDeptChopOne (dpt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dpt \\<noteq> Leaf \\<Longrightarrow>\n    domainNameDeptChopOne (name -- dpt) = name -- domainNameDeptChopOne dpt", "apply(case_tac dpt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>dpt \\<noteq> Leaf; dpt = x11 -- x12\\<rbrakk>\n       \\<Longrightarrow> domainNameDeptChopOne (name -- dpt) =\n                         name -- domainNameDeptChopOne dpt\n 2. \\<lbrakk>dpt \\<noteq> Leaf; dpt = Leaf\\<rbrakk>\n    \\<Longrightarrow> domainNameDeptChopOne (name -- dpt) =\n                      name -- domainNameDeptChopOne dpt", "by simp_all"], ["", "fun domainNameChop :: \"domainNameDept \\<Rightarrow> nat \\<Rightarrow> domainNameDept\" where\n      \"domainNameChop Leaf _ = Leaf\" |\n      \"domainNameChop namedpt 0 = namedpt\" |\n      \"domainNameChop namedpt (Suc n) = domainNameChop (domainNameDeptChopOne namedpt) n\""], ["", "lemma \"domainNameChop (''i8''--''CoffeeMachine''--Leaf) 2 = Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domainNameChop (''i8'' -- ''CoffeeMachine'' -- Leaf) 2 = Leaf", "by eval"], ["", "lemma \"domainNameChop (''i8''--''CoffeeMachine''--''CoffeeSlave''--Leaf) 2 = ''i8''--Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domainNameChop (''i8'' -- ''CoffeeMachine'' -- ''CoffeeSlave'' -- Leaf)\n     2 =\n    ''i8'' -- Leaf", "by eval"], ["", "lemma \"domainNameChop (''i8''--Leaf) 0 = ''i8''--Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domainNameChop (''i8'' -- Leaf) 0 = ''i8'' -- Leaf", "by eval"], ["", "lemma \"domainNameChop (Leaf) 8 = Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domainNameChop Leaf 8 = Leaf", "by eval"], ["", "lemma chop0[simp]: \"domainNameChop dn 0 = dn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domainNameChop dn 0 = dn", "apply(case_tac dn)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       dn = x11 -- x12 \\<Longrightarrow> domainNameChop dn 0 = dn\n 2. dn = Leaf \\<Longrightarrow> domainNameChop dn 0 = dn", "by simp_all"], ["", "lemma \"(domainNameDeptChopOne^^2) (''d1''--''d2''--''d3''--Leaf) = ''d1''--Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (domainNameDeptChopOne ^^ 2) (''d1'' -- ''d2'' -- ''d3'' -- Leaf) =\n    ''d1'' -- Leaf", "by eval"], ["", "text \\<open>domainNameChop is equal to applying n times chop one\\<close>"], ["", "lemma domainNameChopFunApply: \"domainNameChop dn n = (domainNameDeptChopOne^^n) dn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domainNameChop dn n = (domainNameDeptChopOne ^^ n) dn", "apply(induction dn n rule: domainNameChop.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_. domainNameChop Leaf uu_ = (domainNameDeptChopOne ^^ uu_) Leaf\n 2. \\<And>v va.\n       domainNameChop (v -- va) 0 = (domainNameDeptChopOne ^^ 0) (v -- va)\n 3. \\<And>v va n.\n       domainNameChop (domainNameDeptChopOne (v -- va)) n =\n       (domainNameDeptChopOne ^^ n)\n        (domainNameDeptChopOne (v -- va)) \\<Longrightarrow>\n       domainNameChop (v -- va) (Suc n) =\n       (domainNameDeptChopOne ^^ Suc n) (v -- va)", "apply (simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>uu_. Leaf = (domainNameDeptChopOne ^^ uu_) Leaf\n 2. \\<And>v va n.\n       domainNameChop (domainNameDeptChopOne (v -- va)) n =\n       (domainNameDeptChopOne ^^ n)\n        (domainNameDeptChopOne (v -- va)) \\<Longrightarrow>\n       (domainNameDeptChopOne ^^ n) (domainNameDeptChopOne (v -- va)) =\n       domainNameDeptChopOne ((domainNameDeptChopOne ^^ n) (v -- va))", "apply(rename_tac nat,induct_tac nat, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va n.\n       domainNameChop (domainNameDeptChopOne (v -- va)) n =\n       (domainNameDeptChopOne ^^ n)\n        (domainNameDeptChopOne (v -- va)) \\<Longrightarrow>\n       (domainNameDeptChopOne ^^ n) (domainNameDeptChopOne (v -- va)) =\n       domainNameDeptChopOne ((domainNameDeptChopOne ^^ n) (v -- va))", "apply(rename_tac n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va n.\n       domainNameChop (domainNameDeptChopOne (v -- va)) n =\n       (domainNameDeptChopOne ^^ n)\n        (domainNameDeptChopOne (v -- va)) \\<Longrightarrow>\n       (domainNameDeptChopOne ^^ n) (domainNameDeptChopOne (v -- va)) =\n       domainNameDeptChopOne ((domainNameDeptChopOne ^^ n) (v -- va))", "by (metis funpow_swap1)"], ["", "lemma domainNameChopRotateSuc: \"domainNameChop dn (Suc n) = domainNameDeptChopOne (domainNameChop dn n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domainNameChop dn (Suc n) = domainNameDeptChopOne (domainNameChop dn n)", "by(simp add: domainNameChopFunApply)"], ["", "lemma domainNameChopRotate: \"domainNameChop (domainNameDeptChopOne dn) n = domainNameDeptChopOne (domainNameChop dn n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domainNameChop (domainNameDeptChopOne dn) n =\n    domainNameDeptChopOne (domainNameChop dn n)", "apply(subgoal_tac \"domainNameChop (domainNameDeptChopOne dn) n = domainNameChop dn (Suc n)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. domainNameChop (domainNameDeptChopOne dn) n =\n    domainNameChop dn (Suc n) \\<Longrightarrow>\n    domainNameChop (domainNameDeptChopOne dn) n =\n    domainNameDeptChopOne (domainNameChop dn n)\n 2. domainNameChop (domainNameDeptChopOne dn) n = domainNameChop dn (Suc n)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. domainNameChop (domainNameDeptChopOne dn) n =\n    domainNameChop dn (Suc n) \\<Longrightarrow>\n    domainNameChop dn (Suc n) = domainNameDeptChopOne (domainNameChop dn n)\n 2. domainNameChop (domainNameDeptChopOne dn) n = domainNameChop dn (Suc n)", "apply(simp add: domainNameChopFunApply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. domainNameChop (domainNameDeptChopOne dn) n = domainNameChop dn (Suc n)", "apply(case_tac dn)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       dn = x11 -- x12 \\<Longrightarrow>\n       domainNameChop (domainNameDeptChopOne dn) n =\n       domainNameChop dn (Suc n)\n 2. dn = Leaf \\<Longrightarrow>\n    domainNameChop (domainNameDeptChopOne dn) n = domainNameChop dn (Suc n)", "by(simp_all)"], ["", "theorem chop_not_decrease_hierarchy: \"dn \\<le> domainNameChop dn n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dn \\<le> domainNameChop dn n", "apply(induction n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dn \\<le> domainNameChop dn 0\n 2. \\<And>n.\n       dn \\<le> domainNameChop dn n \\<Longrightarrow>\n       dn \\<le> domainNameChop dn (Suc n)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       dn \\<le> domainNameChop dn n \\<Longrightarrow>\n       dn \\<le> domainNameChop dn (Suc n)", "apply(case_tac dn)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n x11 x12.\n       \\<lbrakk>dn \\<le> domainNameChop dn n; dn = x11 -- x12\\<rbrakk>\n       \\<Longrightarrow> dn \\<le> domainNameChop dn (Suc n)\n 2. \\<And>n.\n       \\<lbrakk>dn \\<le> domainNameChop dn n; dn = Leaf\\<rbrakk>\n       \\<Longrightarrow> dn \\<le> domainNameChop dn (Suc n)", "apply(rename_tac name dpt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n name dpt.\n       \\<lbrakk>dn \\<le> domainNameChop dn n; dn = name -- dpt\\<rbrakk>\n       \\<Longrightarrow> dn \\<le> domainNameChop dn (Suc n)\n 2. \\<And>n.\n       \\<lbrakk>dn \\<le> domainNameChop dn n; dn = Leaf\\<rbrakk>\n       \\<Longrightarrow> dn \\<le> domainNameChop dn (Suc n)", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n name dpt.\n       \\<lbrakk>name -- dpt \\<le> domainNameChop (name -- dpt) n;\n        dn = name -- dpt\\<rbrakk>\n       \\<Longrightarrow> name -- dpt\n                         \\<le> domainNameChop\n                                (domainNameDeptChopOne (name -- dpt)) n\n 2. \\<And>n.\n       \\<lbrakk>dn \\<le> domainNameChop dn n; dn = Leaf\\<rbrakk>\n       \\<Longrightarrow> dn \\<le> domainNameChop dn (Suc n)", "apply(simp add:domainNameChopRotate)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n name dpt.\n       \\<lbrakk>name -- dpt \\<le> domainNameChop (name -- dpt) n;\n        dn = name -- dpt\\<rbrakk>\n       \\<Longrightarrow> name -- dpt\n                         \\<le> domainNameDeptChopOne\n                                (domainNameChop (name -- dpt) n)\n 2. \\<And>n.\n       \\<lbrakk>dn \\<le> domainNameChop dn n; dn = Leaf\\<rbrakk>\n       \\<Longrightarrow> dn \\<le> domainNameChop dn (Suc n)", "apply (metis chopOne_not_decrease less_eq_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>dn \\<le> domainNameChop dn n; dn = Leaf\\<rbrakk>\n       \\<Longrightarrow> dn \\<le> domainNameChop dn (Suc n)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary \"dn \\<le> domainNameDeptChopOne ((domainNameDeptChopOne ^^ n) (dn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dn \\<le> domainNameDeptChopOne ((domainNameDeptChopOne ^^ n) dn)", "by (metis chop_not_decrease_hierarchy domainNameChopFunApply domainNameChopRotateSuc)"], ["", "text\\<open>compute maximum common level of both inputs\\<close>"], ["", "fun chop_sup :: \"domainNameDept \\<Rightarrow> domainNameDept \\<Rightarrow> domainNameDept\" where\n      \"chop_sup Leaf _ = Leaf\" | \n      \"chop_sup _ Leaf = Leaf\" | \n      \"chop_sup (a--as) (b--bs) = (if a \\<noteq> b then Leaf else a--(chop_sup as bs))\""], ["", "lemma \"chop_sup (''a''--''b''--''c''--Leaf) (''a''--''b''--''d''--Leaf) = ''a'' -- ''b'' -- Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chop_sup (''a'' -- ''b'' -- ''c'' -- Leaf)\n     (''a'' -- ''b'' -- ''d'' -- Leaf) =\n    ''a'' -- ''b'' -- Leaf", "by eval"], ["", "lemma \"chop_sup (''a''--''b''--''c''--Leaf) (''a''--''x''--''d''--Leaf) = ''a'' -- Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chop_sup (''a'' -- ''b'' -- ''c'' -- Leaf)\n     (''a'' -- ''x'' -- ''d'' -- Leaf) =\n    ''a'' -- Leaf", "by eval"], ["", "lemma \"chop_sup (''a''--''b''--''c''--Leaf) (''x''--''x''--''d''--Leaf) = Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chop_sup (''a'' -- ''b'' -- ''c'' -- Leaf)\n     (''x'' -- ''x'' -- ''d'' -- Leaf) =\n    Leaf", "by eval"], ["", "lemma chop_sup_commute: \"chop_sup a b = chop_sup b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chop_sup a b = chop_sup b a", "apply(induction a b rule: chop_sup.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_. chop_sup Leaf uu_ = chop_sup uu_ Leaf\n 2. \\<And>v va. chop_sup (v -- va) Leaf = chop_sup Leaf (v -- va)\n 3. \\<And>a as b bs.\n       (\\<not> a \\<noteq> b \\<Longrightarrow>\n        chop_sup as bs = chop_sup bs as) \\<Longrightarrow>\n       chop_sup (a -- as) (b -- bs) = chop_sup (b -- bs) (a -- as)", "apply(rename_tac a)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a. chop_sup Leaf a = chop_sup a Leaf\n 2. \\<And>v va. chop_sup (v -- va) Leaf = chop_sup Leaf (v -- va)\n 3. \\<And>a as b bs.\n       (\\<not> a \\<noteq> b \\<Longrightarrow>\n        chop_sup as bs = chop_sup bs as) \\<Longrightarrow>\n       chop_sup (a -- as) (b -- bs) = chop_sup (b -- bs) (a -- as)", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. Leaf = chop_sup a Leaf", "apply(case_tac a, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma chop_sup_max1: \"a \\<le> chop_sup a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> chop_sup a b", "apply(induction a b rule: chop_sup.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_. Leaf \\<le> chop_sup Leaf uu_\n 2. \\<And>v va. v -- va \\<le> chop_sup (v -- va) Leaf\n 3. \\<And>a as b bs.\n       (\\<not> a \\<noteq> b \\<Longrightarrow>\n        as \\<le> chop_sup as bs) \\<Longrightarrow>\n       a -- as \\<le> chop_sup (a -- as) (b -- bs)", "by(simp_all)"], ["", "lemma chop_sup_max2: \"b \\<le> chop_sup a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> chop_sup a b", "apply(subst chop_sup_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> chop_sup b a", "by(simp add: chop_sup_max1)"], ["", "(* don't need this, preserver \\<le> on domainNameDept and \\<sqsubseteq> on domainName\n   instantiation domainNameDept :: partial_order\n   begin\n     fun leq_domainNameDept :: \"domainNameDept \\<Rightarrow> domainNameDept \\<Rightarrow> bool\" (* \\<sqsubseteq> *) where \n      \"leq_domainNameDept a b = (a \\<le> b)\"\n   instance\n      by(intro_classes,simp_all)\n   end\n   *)"], ["", "lemma chop_sup_is_sup: \"\\<forall>z. a \\<le> z \\<and> b \\<le> z \\<longrightarrow> chop_sup a b \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z.\n       a \\<le> z \\<and> b \\<le> z \\<longrightarrow> chop_sup a b \\<le> z", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>a \\<le> z; b \\<le> z\\<rbrakk>\n       \\<Longrightarrow> chop_sup a b \\<le> z", "apply(induction a b rule: chop_sup.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_ z.\n       \\<lbrakk>Leaf \\<le> z; uu_ \\<le> z\\<rbrakk>\n       \\<Longrightarrow> chop_sup Leaf uu_ \\<le> z\n 2. \\<And>v va z.\n       \\<lbrakk>v -- va \\<le> z; Leaf \\<le> z\\<rbrakk>\n       \\<Longrightarrow> chop_sup (v -- va) Leaf \\<le> z\n 3. \\<And>a as b bs z.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>\\<not> a \\<noteq> b; as \\<le> z;\n                    bs \\<le> z\\<rbrakk>\n                   \\<Longrightarrow> chop_sup as bs \\<le> z;\n        a -- as \\<le> z; b -- bs \\<le> z\\<rbrakk>\n       \\<Longrightarrow> chop_sup (a -- as) (b -- bs) \\<le> z", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as b bs z.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>a = b; as \\<le> z; bs \\<le> z\\<rbrakk>\n                   \\<Longrightarrow> chop_sup as bs \\<le> z;\n        a -- as \\<le> z; b -- bs \\<le> z\\<rbrakk>\n       \\<Longrightarrow> (a \\<noteq> b \\<longrightarrow>\n                          Leaf \\<le> z) \\<and>\n                         (a = b \\<longrightarrow>\n                          b -- chop_sup as bs \\<le> z)", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as b bs z.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>a = b; as \\<le> z; bs \\<le> z\\<rbrakk>\n                   \\<Longrightarrow> chop_sup as bs \\<le> z;\n        a -- as \\<le> z; b -- bs \\<le> z\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> b \\<longrightarrow> Leaf \\<le> z\n 2. \\<And>a as b bs z.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>a = b; as \\<le> z; bs \\<le> z\\<rbrakk>\n                   \\<Longrightarrow> chop_sup as bs \\<le> z;\n        a -- as \\<le> z; b -- bs \\<le> z\\<rbrakk>\n       \\<Longrightarrow> a = b \\<longrightarrow> b -- chop_sup as bs \\<le> z", "apply(clarify)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as b bs z.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>a = b; as \\<le> z; bs \\<le> z\\<rbrakk>\n                   \\<Longrightarrow> chop_sup as bs \\<le> z;\n        a -- as \\<le> z; b -- bs \\<le> z; a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> Leaf \\<le> z\n 2. \\<And>a as b bs z.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>a = b; as \\<le> z; bs \\<le> z\\<rbrakk>\n                   \\<Longrightarrow> chop_sup as bs \\<le> z;\n        a -- as \\<le> z; b -- bs \\<le> z\\<rbrakk>\n       \\<Longrightarrow> a = b \\<longrightarrow> b -- chop_sup as bs \\<le> z", "apply(subgoal_tac \"z=Leaf\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a as b bs z.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>a = b; as \\<le> z; bs \\<le> z\\<rbrakk>\n                   \\<Longrightarrow> chop_sup as bs \\<le> z;\n        a -- as \\<le> z; b -- bs \\<le> z; a \\<noteq> b; z = Leaf\\<rbrakk>\n       \\<Longrightarrow> Leaf \\<le> z\n 2. \\<And>a as b bs z.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>a = b; as \\<le> z; bs \\<le> z\\<rbrakk>\n                   \\<Longrightarrow> chop_sup as bs \\<le> z;\n        a -- as \\<le> z; b -- bs \\<le> z; a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> z = Leaf\n 3. \\<And>a as b bs z.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>a = b; as \\<le> z; bs \\<le> z\\<rbrakk>\n                   \\<Longrightarrow> chop_sup as bs \\<le> z;\n        a -- as \\<le> z; b -- bs \\<le> z\\<rbrakk>\n       \\<Longrightarrow> a = b \\<longrightarrow> b -- chop_sup as bs \\<le> z", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as b bs z.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>a = b; as \\<le> z; bs \\<le> z\\<rbrakk>\n                   \\<Longrightarrow> chop_sup as bs \\<le> z;\n        a -- as \\<le> z; b -- bs \\<le> z; a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> z = Leaf\n 2. \\<And>a as b bs z.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>a = b; as \\<le> z; bs \\<le> z\\<rbrakk>\n                   \\<Longrightarrow> chop_sup as bs \\<le> z;\n        a -- as \\<le> z; b -- bs \\<le> z\\<rbrakk>\n       \\<Longrightarrow> a = b \\<longrightarrow> b -- chop_sup as bs \\<le> z", "apply(simp add: uncomparable_sup_is_Top)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as b bs z.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>a = b; as \\<le> z; bs \\<le> z\\<rbrakk>\n                   \\<Longrightarrow> chop_sup as bs \\<le> z;\n        a -- as \\<le> z; b -- bs \\<le> z\\<rbrakk>\n       \\<Longrightarrow> a = b \\<longrightarrow> b -- chop_sup as bs \\<le> z", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as b bs z.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>b = b; as \\<le> z; bs \\<le> z\\<rbrakk>\n                   \\<Longrightarrow> chop_sup as bs \\<le> z;\n        b -- as \\<le> z; b -- bs \\<le> z\\<rbrakk>\n       \\<Longrightarrow> b -- chop_sup as bs \\<le> z", "apply(case_tac z)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as b bs z x11 x12.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>b = b; as \\<le> z; bs \\<le> z\\<rbrakk>\n                   \\<Longrightarrow> chop_sup as bs \\<le> z;\n        b -- as \\<le> z; b -- bs \\<le> z; z = x11 -- x12\\<rbrakk>\n       \\<Longrightarrow> b -- chop_sup as bs \\<le> z\n 2. \\<And>a as b bs z.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>b = b; as \\<le> z; bs \\<le> z\\<rbrakk>\n                   \\<Longrightarrow> chop_sup as bs \\<le> z;\n        b -- as \\<le> z; b -- bs \\<le> z; z = Leaf\\<rbrakk>\n       \\<Longrightarrow> b -- chop_sup as bs \\<le> z", "by(simp_all)"], ["", "datatype domainName = DN domainNameDept | Unassigned"], ["", "subsubsection \\<open>Makeing it a complete Lattice\\<close>"], ["", "instantiation domainName :: partial_order\n    begin"], ["", "(* adding trust here would violate transitivity or antsymmetry *)"], ["", "fun leq_domainName :: \"domainName \\<Rightarrow> domainName \\<Rightarrow> bool\" (* \\<sqsubseteq> *) where \n        \"leq_domainName Unassigned _ = True\" |\n        \"leq_domainName _ Unassigned = False\" |\n        \"leq_domainName (DN dnA) (DN dnB) = (dnA \\<le> dnB)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(domainName, partial_order_class)", "apply(intro_classes)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<sqsubseteq> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "(* x \\<sqsubseteq> x *)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<sqsubseteq> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply(case_tac x)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x x1. x = DN x1 \\<Longrightarrow> x \\<sqsubseteq> x\n 2. \\<And>x. x = Unassigned \\<Longrightarrow> x \\<sqsubseteq> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply(simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "(* x \\<sqsubseteq> y \\<Longrightarrow> y \\<sqsubseteq> z \\<Longrightarrow> x \\<sqsubseteq> z *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply(case_tac x, rename_tac dnX)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y z dnX.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z; x = DN dnX\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z;\n        x = Unassigned\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply(case_tac y, rename_tac dnY)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y z dnX dnY.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z; x = DN dnX;\n        y = DN dnY\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 2. \\<And>x y z dnX.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z; x = DN dnX;\n        y = Unassigned\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z;\n        x = Unassigned\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply(case_tac z, rename_tac dnZ)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y z dnX dnY dnZ.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z; x = DN dnX;\n        y = DN dnY; z = DN dnZ\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 2. \\<And>x y z dnX dnY.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z; x = DN dnX;\n        y = DN dnY; z = Unassigned\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 3. \\<And>x y z dnX.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z; x = DN dnX;\n        y = Unassigned\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z;\n        x = Unassigned\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 5. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "(* x \\<sqsubseteq> y \\<Longrightarrow> y \\<sqsubseteq> x \\<Longrightarrow> x = y *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply(case_tac x, rename_tac dnX)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y dnX.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x; x = DN dnX\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x;\n        x = Unassigned\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply(case_tac y, rename_tac dnY)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y dnX dnY.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x; x = DN dnX;\n        y = DN dnY\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y dnX.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x; x = DN dnX;\n        y = Unassigned\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x;\n        x = Unassigned\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>y \\<sqsubseteq> Unassigned; x = Unassigned\\<rbrakk>\n       \\<Longrightarrow> Unassigned = y", "apply(metis domainName.exhaust leq_domainName.simps(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma \"is_Inf {Unassigned, DN Leaf} Unassigned\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Inf {Unassigned, DN Leaf} Unassigned", "by(simp add: is_Inf_def)"], ["", "text \\<open>The infinum of two elements:\\<close>"], ["", "fun DN_inf :: \"domainName \\<Rightarrow> domainName \\<Rightarrow> domainName\" where\n      \"DN_inf Unassigned _ = Unassigned\" |\n      \"DN_inf _ Unassigned = Unassigned\" |\n      \"DN_inf (DN a) (DN b) = (if a \\<le> b then DN a else if b \\<le> a then DN b else Unassigned)\""], ["", "lemma \"DN_inf (DN (''TUM''--''i8''--Leaf)) (DN (''TUM''--''i20''--Leaf)) = Unassigned\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DN_inf (DN (''TUM'' -- ''i8'' -- Leaf))\n     (DN (''TUM'' -- ''i20'' -- Leaf)) =\n    Unassigned", "by eval"], ["", "lemma \"DN_inf (DN (''TUM''--''i8''--Leaf)) (DN (''TUM''--Leaf)) = DN (''TUM'' -- ''i8'' -- Leaf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DN_inf (DN (''TUM'' -- ''i8'' -- Leaf)) (DN (''TUM'' -- Leaf)) =\n    DN (''TUM'' -- ''i8'' -- Leaf)", "by eval"], ["", "lemma DN_inf_commute: \"DN_inf x y = DN_inf y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DN_inf x y = DN_inf y x", "apply(induction x y rule: DN_inf.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_. DN_inf Unassigned uu_ = DN_inf uu_ Unassigned\n 2. \\<And>v. DN_inf (DN v) Unassigned = DN_inf Unassigned (DN v)\n 3. \\<And>a b. DN_inf (DN a) (DN b) = DN_inf (DN b) (DN a)", "apply(rename_tac x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. DN_inf Unassigned x = DN_inf x Unassigned\n 2. \\<And>v. DN_inf (DN v) Unassigned = DN_inf Unassigned (DN v)\n 3. \\<And>a b. DN_inf (DN a) (DN b) = DN_inf (DN b) (DN a)", "apply(case_tac x)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x x1.\n       x = DN x1 \\<Longrightarrow> DN_inf Unassigned x = DN_inf x Unassigned\n 2. \\<And>x.\n       x = Unassigned \\<Longrightarrow>\n       DN_inf Unassigned x = DN_inf x Unassigned\n 3. \\<And>v. DN_inf (DN v) Unassigned = DN_inf Unassigned (DN v)\n 4. \\<And>a b. DN_inf (DN a) (DN b) = DN_inf (DN b) (DN a)", "by (simp_all)"], ["", "lemma DN_inf_is_inf: \"is_inf x y (DN_inf x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_inf x y (DN_inf x y)", "apply(induction x y rule: DN_inf.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_. is_inf Unassigned uu_ (DN_inf Unassigned uu_)\n 2. \\<And>v. is_inf (DN v) Unassigned (DN_inf (DN v) Unassigned)\n 3. \\<And>a b. is_inf (DN a) (DN b) (DN_inf (DN a) (DN b))", "apply(simp add: is_inf_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v. is_inf (DN v) Unassigned (DN_inf (DN v) Unassigned)\n 2. \\<And>a b. is_inf (DN a) (DN b) (DN_inf (DN a) (DN b))", "apply(simp add: is_inf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b. is_inf (DN a) (DN b) (DN_inf (DN a) (DN b))", "apply(simp add: is_inf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<not> b \\<le> a \\<longrightarrow>\n       \\<not> a \\<le> b \\<longrightarrow>\n       (\\<forall>z.\n           z \\<sqsubseteq> DN a \\<and>\n           z \\<sqsubseteq> DN b \\<longrightarrow>\n           z \\<sqsubseteq> Unassigned)", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b z.\n       \\<lbrakk>\\<not> b \\<le> a; \\<not> a \\<le> b; z \\<sqsubseteq> DN a;\n        z \\<sqsubseteq> DN b\\<rbrakk>\n       \\<Longrightarrow> z \\<sqsubseteq> Unassigned", "apply(rename_tac z)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b z.\n       \\<lbrakk>\\<not> b \\<le> a; \\<not> a \\<le> b; z \\<sqsubseteq> DN a;\n        z \\<sqsubseteq> DN b\\<rbrakk>\n       \\<Longrightarrow> z \\<sqsubseteq> Unassigned", "apply(case_tac z)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b z x1.\n       \\<lbrakk>\\<not> b \\<le> a; \\<not> a \\<le> b; z \\<sqsubseteq> DN a;\n        z \\<sqsubseteq> DN b; z = DN x1\\<rbrakk>\n       \\<Longrightarrow> z \\<sqsubseteq> Unassigned\n 2. \\<And>a b z.\n       \\<lbrakk>\\<not> b \\<le> a; \\<not> a \\<le> b; z \\<sqsubseteq> DN a;\n        z \\<sqsubseteq> DN b; z = Unassigned\\<rbrakk>\n       \\<Longrightarrow> z \\<sqsubseteq> Unassigned", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b z x1.\n       \\<lbrakk>\\<not> b \\<le> a; \\<not> a \\<le> b; x1 \\<le> a; x1 \\<le> b;\n        z = DN x1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b z.\n       \\<lbrakk>\\<not> b \\<le> a; \\<not> a \\<le> b; z \\<sqsubseteq> DN a;\n        z \\<sqsubseteq> DN b; z = Unassigned\\<rbrakk>\n       \\<Longrightarrow> z \\<sqsubseteq> Unassigned", "apply(rename_tac zn)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b z zn.\n       \\<lbrakk>\\<not> b \\<le> a; \\<not> a \\<le> b; zn \\<le> a; zn \\<le> b;\n        z = DN zn\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b z.\n       \\<lbrakk>\\<not> b \\<le> a; \\<not> a \\<le> b; z \\<sqsubseteq> DN a;\n        z \\<sqsubseteq> DN b; z = Unassigned\\<rbrakk>\n       \\<Longrightarrow> z \\<sqsubseteq> Unassigned", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b z zn.\n       \\<lbrakk>\\<not> b \\<le> a; \\<not> a \\<le> b; zn \\<le> a; zn \\<le> b;\n        z = DN zn\\<rbrakk>\n       \\<Longrightarrow> False", "using common_inf_imp_comparable"], ["proof (prove)\nusing this:\n  \\<lbrakk>?z \\<le> ?a; ?z \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> ?a \\<le> ?b \\<or> ?b \\<le> ?a\n\ngoal (1 subgoal):\n 1. \\<And>a b z zn.\n       \\<lbrakk>\\<not> b \\<le> a; \\<not> a \\<le> b; zn \\<le> a; zn \\<le> b;\n        z = DN zn\\<rbrakk>\n       \\<Longrightarrow> False", "by blast"], ["", "fun DN_sup :: \"domainName \\<Rightarrow> domainName \\<Rightarrow> domainName\" where\n      \"DN_sup Unassigned a = a\" | \n      \"DN_sup a Unassigned = a\" |\n      \"DN_sup (DN a) (DN b) = DN (chop_sup a b)\""], ["", "lemma DN_sup_commute: \"DN_sup x y = DN_sup y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DN_sup x y = DN_sup y x", "apply(induction x y rule: DN_sup.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a. DN_sup Unassigned a = DN_sup a Unassigned\n 2. \\<And>v. DN_sup (DN v) Unassigned = DN_sup Unassigned (DN v)\n 3. \\<And>a b. DN_sup (DN a) (DN b) = DN_sup (DN b) (DN a)", "apply(rename_tac x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. DN_sup Unassigned x = DN_sup x Unassigned\n 2. \\<And>v. DN_sup (DN v) Unassigned = DN_sup Unassigned (DN v)\n 3. \\<And>a b. DN_sup (DN a) (DN b) = DN_sup (DN b) (DN a)", "apply(case_tac x)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x x1.\n       x = DN x1 \\<Longrightarrow> DN_sup Unassigned x = DN_sup x Unassigned\n 2. \\<And>x.\n       x = Unassigned \\<Longrightarrow>\n       DN_sup Unassigned x = DN_sup x Unassigned\n 3. \\<And>v. DN_sup (DN v) Unassigned = DN_sup Unassigned (DN v)\n 4. \\<And>a b. DN_sup (DN a) (DN b) = DN_sup (DN b) (DN a)", "by(simp_all add: chop_sup_commute)"], ["", "lemma DN_sup_is_sup: \"is_sup x y (DN_sup x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_sup x y (DN_sup x y)", "apply(induction x y rule: DN_inf.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_. is_sup Unassigned uu_ (DN_sup Unassigned uu_)\n 2. \\<And>v. is_sup (DN v) Unassigned (DN_sup (DN v) Unassigned)\n 3. \\<And>a b. is_sup (DN a) (DN b) (DN_sup (DN a) (DN b))", "apply(simp add: is_sup_def leq_refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v. is_sup (DN v) Unassigned (DN_sup (DN v) Unassigned)\n 2. \\<And>a b. is_sup (DN a) (DN b) (DN_sup (DN a) (DN b))", "apply(simp add: is_sup_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b. is_sup (DN a) (DN b) (DN_sup (DN a) (DN b))", "apply(simp add: is_sup_def chop_sup_max1 chop_sup_max2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<forall>z.\n          DN a \\<sqsubseteq> z \\<and> DN b \\<sqsubseteq> z \\<longrightarrow>\n          DN (chop_sup a b) \\<sqsubseteq> z", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b z.\n       \\<lbrakk>DN a \\<sqsubseteq> z; DN b \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> DN (chop_sup a b) \\<sqsubseteq> z", "apply(rename_tac z)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b z.\n       \\<lbrakk>DN a \\<sqsubseteq> z; DN b \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> DN (chop_sup a b) \\<sqsubseteq> z", "apply(case_tac z)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b z x1.\n       \\<lbrakk>DN a \\<sqsubseteq> z; DN b \\<sqsubseteq> z;\n        z = DN x1\\<rbrakk>\n       \\<Longrightarrow> DN (chop_sup a b) \\<sqsubseteq> z\n 2. \\<And>a b z.\n       \\<lbrakk>DN a \\<sqsubseteq> z; DN b \\<sqsubseteq> z;\n        z = Unassigned\\<rbrakk>\n       \\<Longrightarrow> DN (chop_sup a b) \\<sqsubseteq> z", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b z x1.\n       \\<lbrakk>a \\<le> x1; b \\<le> x1; z = DN x1\\<rbrakk>\n       \\<Longrightarrow> chop_sup a b \\<le> x1\n 2. \\<And>a b z.\n       \\<lbrakk>DN a \\<sqsubseteq> z; DN b \\<sqsubseteq> z;\n        z = Unassigned\\<rbrakk>\n       \\<Longrightarrow> DN (chop_sup a b) \\<sqsubseteq> z", "apply(rename_tac zn)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b z zn.\n       \\<lbrakk>a \\<le> zn; b \\<le> zn; z = DN zn\\<rbrakk>\n       \\<Longrightarrow> chop_sup a b \\<le> zn\n 2. \\<And>a b z.\n       \\<lbrakk>DN a \\<sqsubseteq> z; DN b \\<sqsubseteq> z;\n        z = Unassigned\\<rbrakk>\n       \\<Longrightarrow> DN (chop_sup a b) \\<sqsubseteq> z", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b z zn.\n       \\<lbrakk>a \\<le> zn; b \\<le> zn; z = DN zn\\<rbrakk>\n       \\<Longrightarrow> chop_sup a b \\<le> zn", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b z zn.\n       \\<lbrakk>a \\<le> zn; b \\<le> zn\\<rbrakk>\n       \\<Longrightarrow> chop_sup a b \\<le> zn", "apply(simp add: chop_sup_is_sup)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>domainName is a Lattice:\\<close>"], ["", "instantiation domainName :: lattice\n      begin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(domainName, Lattice.lattice_class)", "apply intro_classes"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. \\<exists>inf. is_inf x y inf\n 2. \\<And>x y. \\<exists>sup. is_sup x y sup", "apply(rule_tac x=\"DN_inf x y\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. is_inf x y (DN_inf x y)\n 2. \\<And>x y. \\<exists>sup. is_sup x y sup", "apply(fact DN_inf_is_inf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. \\<exists>sup. is_sup x y sup", "apply(rule_tac x=\"DN_sup x y\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. is_sup x y (DN_sup x y)", "apply(rule DN_sup_is_sup)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "(*TRUST*)"], ["", "datatype domainNameTrust = DN \"(domainNameDept \\<times> nat)\" | Unassigned"], ["", "(*transitivity only if trustA \\<ge> trust C*)"], ["", "fun leq_domainNameTrust :: \"domainNameTrust \\<Rightarrow> domainNameTrust \\<Rightarrow> bool\" (infixr \"\\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\" 65)  where \n      \"leq_domainNameTrust Unassigned _ = True\" |\n      \"leq_domainNameTrust _ Unassigned = False\" |\n      \"leq_domainNameTrust (DN (dnA, trustA)) (DN (dnB, trustB)) = (dnA \\<le> (domainNameChop dnB trustB))\""], ["", "lemma leq_domainNameTrust_refl: \"x \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t x", "apply(case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       x = domainNameTrust.DN x1 \\<Longrightarrow>\n       x \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t x\n 2. x = domainNameTrust.Unassigned \\<Longrightarrow>\n    x \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t x", "apply(rename_tac prod)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>prod.\n       x = domainNameTrust.DN prod \\<Longrightarrow>\n       x \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t x\n 2. x = domainNameTrust.Unassigned \\<Longrightarrow>\n    x \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t x", "apply(case_tac prod)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>prod a b.\n       \\<lbrakk>x = domainNameTrust.DN prod; prod = (a, b)\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                         x\n 2. x = domainNameTrust.Unassigned \\<Longrightarrow>\n    x \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t x", "apply(simp add: chop_not_decrease_hierarchy)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = domainNameTrust.Unassigned \\<Longrightarrow>\n    x \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t x", "by(simp)"], ["", "lemma leq_domainNameTrust_NOT_trans: \"\\<exists>x y z. x \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t y \\<and> y \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t z \\<and> \\<not> x \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x y z.\n       x \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t y \\<and>\n       y \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t z \\<and>\n       \\<not> x \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t z", "apply(rule_tac x=\"DN (''TUM''--Leaf, 0)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y z.\n       domainNameTrust.DN\n        (''TUM'' -- Leaf,\n         0) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n       y \\<and>\n       y \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t z \\<and>\n       \\<not> domainNameTrust.DN\n               (''TUM'' -- Leaf,\n                0) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n              z", "apply(rule_tac x=\"DN (''TUM''--''i8''--Leaf, 1)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z.\n       domainNameTrust.DN\n        (''TUM'' -- Leaf,\n         0) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n       domainNameTrust.DN (''TUM'' -- ''i8'' -- Leaf, 1) \\<and>\n       domainNameTrust.DN\n        (''TUM'' -- ''i8'' -- Leaf,\n         1) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n       z \\<and>\n       \\<not> domainNameTrust.DN\n               (''TUM'' -- Leaf,\n                0) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n              z", "apply(rule_tac x=\"DN (''TUM''--''i8''--Leaf, 0)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. domainNameTrust.DN\n     (''TUM'' -- Leaf,\n      0) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n    domainNameTrust.DN (''TUM'' -- ''i8'' -- Leaf, 1) \\<and>\n    domainNameTrust.DN\n     (''TUM'' -- ''i8'' -- Leaf,\n      1) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n    domainNameTrust.DN (''TUM'' -- ''i8'' -- Leaf, 0) \\<and>\n    \\<not> domainNameTrust.DN\n            (''TUM'' -- Leaf,\n             0) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n           domainNameTrust.DN (''TUM'' -- ''i8'' -- Leaf, 0)", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma leq_domainNameTrust_NOT_antisym: \"\\<exists>x y. x \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t y \\<and> y \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t x \\<and> x \\<noteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x y.\n       x \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t y \\<and>\n       y \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t x \\<and>\n       x \\<noteq> y", "apply(rule_tac x=\"DN (Leaf, 3)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y.\n       domainNameTrust.DN\n        (Leaf, 3) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n       y \\<and>\n       y \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n       domainNameTrust.DN (Leaf, 3) \\<and>\n       domainNameTrust.DN (Leaf, 3) \\<noteq> y", "apply(rule_tac x=\"DN (Leaf, 4)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. domainNameTrust.DN\n     (Leaf, 3) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n    domainNameTrust.DN (Leaf, 4) \\<and>\n    domainNameTrust.DN\n     (Leaf, 4) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n    domainNameTrust.DN (Leaf, 3) \\<and>\n    domainNameTrust.DN (Leaf, 3) \\<noteq> domainNameTrust.DN (Leaf, 4)", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection\\<open>The network security invariant\\<close>"], ["", "definition default_node_properties :: \"domainNameTrust\"\n  where  \"default_node_properties = Unassigned\""], ["", "text\\<open>The sender is, noticing its trust level, on the same or higher hierarchy level as the receiver.\\<close>"], ["", "fun sinvar :: \"'v graph \\<Rightarrow> ('v \\<Rightarrow> domainNameTrust) \\<Rightarrow> bool\" where\n  \"sinvar G nP = (\\<forall> (s, r) \\<in> edges G. (nP r) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t (nP s))\""], ["", "(*TODO: old legacy function!*)"], ["", "text\\<open>a domain name must be in the supplied tree\\<close>"], ["", "fun verify_globals :: \"'v graph \\<Rightarrow> ('v \\<Rightarrow> domainNameTrust) \\<Rightarrow> domainTree \\<Rightarrow> bool\" where\n  \"verify_globals G nP tree = (\\<forall> v \\<in> nodes G. \n    case (nP v) of Unassigned \\<Rightarrow> True | DN (level, trust) \\<Rightarrow> valid_hierarchy_pos tree level\n   )\""], ["", "lemma \"verify_globals \\<lparr> nodes=set [1,2,3], edges=set [] \\<rparr> (\\<lambda>n. default_node_properties) (Department ''TUM'' [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. verify_globals\n     \\<lparr>nodes = set [1::'a, 2::'a, 3::'a], edges = set []\\<rparr>\n     (\\<lambda>n. default_node_properties) (Department ''TUM'' [])", "by (simp add: default_node_properties_def)"], ["", "definition receiver_violation :: \"bool\" where \"receiver_violation = False\""], ["", "thm SecurityInvariant_withOffendingFlows.sinvar_mono_def"], ["", "lemma sinvar_mono: \"SecurityInvariant_withOffendingFlows.sinvar_mono sinvar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.sinvar_mono sinvar", "apply(rule_tac SecurityInvariant_withOffendingFlows.sinvar_mono_I_proofrule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>nP G.\n       sinvar G nP = (\\<forall>(e1, e2)\\<in>edges G. ?P e1 e2 nP G)\n 2. \\<forall>nP e1 e2 N E' E.\n       wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n       (e1, e2) \\<in> E \\<and>\n       E' \\<subseteq> E \\<and>\n       ?P e1 e2 nP \\<lparr>nodes = N, edges = E\\<rparr> \\<longrightarrow>\n       ?P e1 e2 nP \\<lparr>nodes = N, edges = E'\\<rparr>", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nP e1 e2 N E' a b E.\n       \\<lbrakk>(a, b) \\<in> E';\n        wf_graph \\<lparr>nodes = N, edges = E\\<rparr>; (e1, e2) \\<in> E;\n        E' \\<subseteq> E;\n        \\<forall>x\\<in>E.\n           case x of\n           (s, r) \\<Rightarrow>\n             nP r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n             nP s\\<rbrakk>\n       \\<Longrightarrow> nP b \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                         nP a", "apply(rename_tac nP e1 e2 N E' e1' e2' E)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nP e1 e2 N E' e1' e2' E.\n       \\<lbrakk>(e1', e2') \\<in> E';\n        wf_graph \\<lparr>nodes = N, edges = E\\<rparr>; (e1, e2) \\<in> E;\n        E' \\<subseteq> E;\n        \\<forall>x\\<in>E.\n           case x of\n           (s, r) \\<Rightarrow>\n             nP r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n             nP s\\<rbrakk>\n       \\<Longrightarrow> nP e2' \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                         nP e1'", "apply(blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation SecurityInvariant_preliminaries\nwhere sinvar = sinvar"], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_preliminaries sinvar", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G nP.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.set_offending_flows\n                          sinvar G nP \\<noteq>\n                         {}\n 2. \\<And>N E E' nP.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n 3. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows sinvar ff G\n         nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (ff \\<union> f') G nP", "apply(frule_tac finite_distinct_list[OF wf_graph.finiteE])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G nP.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP;\n        \\<exists>xs. set xs = edges G \\<and> distinct xs\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.set_offending_flows\n                          sinvar G nP \\<noteq>\n                         {}\n 2. \\<And>N E E' nP.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n 3. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows sinvar ff G\n         nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (ff \\<union> f') G nP", "apply(erule_tac exE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G nP xs.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP;\n        set xs = edges G \\<and> distinct xs\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.set_offending_flows\n                          sinvar G nP \\<noteq>\n                         {}\n 2. \\<And>N E E' nP.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n 3. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows sinvar ff G\n         nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (ff \\<union> f') G nP", "apply(rename_tac list_edges)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G nP list_edges.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP;\n        set list_edges = edges G \\<and> distinct list_edges\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.set_offending_flows\n                          sinvar G nP \\<noteq>\n                         {}\n 2. \\<And>N E E' nP.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n 3. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows sinvar ff G\n         nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (ff \\<union> f') G nP", "apply(rule_tac ff=\"list_edges\" in SecurityInvariant_withOffendingFlows.mono_imp_set_offending_flows_not_empty[OF sinvar_mono])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>G nP list_edges.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP;\n        set list_edges = edges G \\<and> distinct list_edges\\<rbrakk>\n       \\<Longrightarrow> wf_graph G\n 2. \\<And>G nP list_edges.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP;\n        set list_edges = edges G \\<and> distinct list_edges\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (set list_edges) G nP\n 3. \\<And>G nP list_edges.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP;\n        set list_edges = edges G \\<and> distinct list_edges\\<rbrakk>\n       \\<Longrightarrow> set list_edges \\<subseteq> edges G\n 4. \\<And>G nP list_edges.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP;\n        set list_edges = edges G \\<and> distinct list_edges\\<rbrakk>\n       \\<Longrightarrow> distinct list_edges\n 5. \\<And>N E E' nP.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n 6. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows sinvar ff G\n         nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (ff \\<union> f') G nP", "apply(auto)[4]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G nP list_edges a b.\n       \\<lbrakk>wf_graph G; (a, b) \\<in> edges G;\n        \\<not> nP b \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n               nP a;\n        set list_edges = edges G; distinct list_edges\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (edges G) G nP\n 2. \\<And>N E E' nP.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n 3. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows sinvar ff G\n         nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (ff \\<union> f') G nP", "apply(auto simp add: SecurityInvariant_withOffendingFlows.is_offending_flows_def graph_ops)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>N E E' nP.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n 2. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows sinvar ff G\n         nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (ff \\<union> f') G nP", "apply(fact SecurityInvariant_withOffendingFlows.sinvar_mono_imp_sinvar_mono[OF sinvar_mono])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows sinvar ff G\n         nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (ff \\<union> f') G nP", "apply(fact SecurityInvariant_withOffendingFlows.sinvar_mono_imp_is_offending_flows_mono[OF sinvar_mono])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>ENF\\<close>"], ["", "lemma DomainHierarchyNG_ENF: \"SecurityInvariant_withOffendingFlows.sinvar_all_edges_normal_form sinvar (\\<lambda> s r. r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.sinvar_all_edges_normal_form sinvar\n     (\\<lambda>s r.\n         r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t s)", "unfolding SecurityInvariant_withOffendingFlows.sinvar_all_edges_normal_form_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>G nP.\n       sinvar G nP =\n       (\\<forall>(e1, e2)\\<in>edges G.\n           nP e2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n           nP e1)", "by simp"], ["", "lemma DomainHierarchyNG_ENF_refl: \"SecurityInvariant_withOffendingFlows.ENF_refl sinvar (\\<lambda> s r. r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.ENF_refl sinvar\n     (\\<lambda>s r.\n         r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t s)", "unfolding SecurityInvariant_withOffendingFlows.ENF_refl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.sinvar_all_edges_normal_form sinvar\n     (\\<lambda>s r.\n         r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t s) \\<and>\n    (\\<forall>p1.\n        p1 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t p1)", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. SecurityInvariant_withOffendingFlows.sinvar_all_edges_normal_form sinvar\n     (\\<lambda>s r.\n         r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t s)\n 2. \\<forall>p1. p1 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t p1", "apply(simp add: DomainHierarchyNG_ENF)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p1. p1 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t p1", "apply(simp add: leq_domainNameTrust_refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unassigned_default_candidate: \"\\<forall>nP s r. \\<not> (nP r)  \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t (nP s) \\<longrightarrow> \\<not> (nP r)  \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t default_node_properties\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>nP s r.\n       \\<not> nP r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n              nP s \\<longrightarrow>\n       \\<not> nP r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n              default_node_properties", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nP s r.\n       \\<lbrakk>\\<not> nP r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                       nP s;\n        nP r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n        default_node_properties\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp add: default_node_properties_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nP s r.\n       \\<lbrakk>\\<not> nP r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                       nP s;\n        nP r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n        domainNameTrust.Unassigned\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis leq_domainNameTrust.elims(3) leq_domainNameTrust.simps(2))"], ["", "definition DomainHierarchyNG_offending_set:: \"'v graph \\<Rightarrow> ('v \\<Rightarrow> domainNameTrust) \\<Rightarrow> ('v \\<times> 'v) set set\" where\n  \"DomainHierarchyNG_offending_set G nP = (if sinvar G nP then\n      {}\n     else \n      { {e \\<in> edges G. case e of (e1,e2) \\<Rightarrow> \\<not> (nP e2) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t (nP e1)} })\""], ["", "lemma DomainHierarchyNG_offending_set: \"SecurityInvariant_withOffendingFlows.set_offending_flows sinvar = DomainHierarchyNG_offending_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_offending_flows = DomainHierarchyNG_offending_set", "apply(simp only: fun_eq_iff SecurityInvariant_withOffendingFlows.ENF_offending_set[OF DomainHierarchyNG_ENF] DomainHierarchyNG_offending_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa.\n       (if sinvar x xa then {}\n        else {{(e1, e2).\n               (e1, e2) \\<in> edges x \\<and>\n               \\<not> xa e2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                      xa e1}}) =\n       (if sinvar x xa then {}\n        else {{e \\<in> edges x.\n               case e of\n               (e1, e2) \\<Rightarrow>\n                 \\<not> xa e2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                        xa e1}})", "apply(rule allI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (if sinvar x xa then {}\n        else {{(e1, e2).\n               (e1, e2) \\<in> edges x \\<and>\n               \\<not> xa e2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                      xa e1}}) =\n       (if sinvar x xa then {}\n        else {{e \\<in> edges x.\n               case e of\n               (e1, e2) \\<Rightarrow>\n                 \\<not> xa e2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                        xa e1}})", "apply(rename_tac G nP)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G nP.\n       (if sinvar G nP then {}\n        else {{(e1, e2).\n               (e1, e2) \\<in> edges G \\<and>\n               \\<not> nP e2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                      nP e1}}) =\n       (if sinvar G nP then {}\n        else {{e \\<in> edges G.\n               case e of\n               (e1, e2) \\<Rightarrow>\n                 \\<not> nP e2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                        nP e1}})", "apply(auto split:prod.split_asm prod.split simp add: Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Unassigned_unique_default: \"otherbot \\<noteq> default_node_properties \\<Longrightarrow>\n         \\<exists>G nP gP i f.\n            wf_graph G \\<and> \n            \\<not> sinvar G nP \\<and>\n            f \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows sinvar G nP \\<and>\n            sinvar (delete_edges G f) nP \\<and>\n            (i \\<in> fst ` f \\<and> sinvar G (nP(i := otherbot)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. otherbot \\<noteq> default_node_properties \\<Longrightarrow>\n    \\<exists>G nP gP i f.\n       wf_graph G \\<and>\n       \\<not> sinvar G nP \\<and>\n       f \\<in> set_offending_flows G nP \\<and>\n       sinvar (delete_edges G f) nP \\<and>\n       i \\<in> fst ` f \\<and> sinvar G (nP(i := otherbot))", "apply (simp add: SecurityInvariant_withOffendingFlows.set_offending_flows_def\n        SecurityInvariant_withOffendingFlows.is_offending_flows_min_set_def\n        SecurityInvariant_withOffendingFlows.is_offending_flows_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. otherbot \\<noteq> default_node_properties \\<Longrightarrow>\n    \\<exists>G.\n       wf_graph G \\<and>\n       (\\<exists>nP.\n           (\\<exists>x\\<in>edges G.\n               \\<not> (case x of\n                       (s, r) \\<Rightarrow>\n                         nP r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                         nP s)) \\<and>\n           (\\<exists>i f.\n               f \\<subseteq> edges G \\<and>\n               (\\<exists>x\\<in>edges G.\n                   \\<not> (case x of\n                           (s, r) \\<Rightarrow>\n                             nP r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                             nP s)) \\<and>\n               (\\<forall>x\\<in>edges (delete_edges G f).\n                   case x of\n                   (s, r) \\<Rightarrow>\n                     nP r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                     nP s) \\<and>\n               (\\<forall>x\\<in>f.\n                   case x of\n                   (e1, e2) \\<Rightarrow>\n                     \\<exists>x\\<in>edges\n                                     (add_edge e1 e2 (delete_edges G f)).\n                        \\<not> (case x of\n                                (s, r) \\<Rightarrow>\n                                  nP r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  nP s)) \\<and>\n               (\\<forall>x\\<in>edges (delete_edges G f).\n                   case x of\n                   (s, r) \\<Rightarrow>\n                     nP r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                     nP s) \\<and>\n               i \\<in> fst ` f \\<and>\n               (\\<forall>x\\<in>edges G.\n                   case x of\n                   (s, r) \\<Rightarrow>\n                     (r = i \\<longrightarrow>\n                      (s = i \\<longrightarrow>\n                       otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                       otherbot) \\<and>\n                      (s \\<noteq> i \\<longrightarrow>\n                       otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                       nP s)) \\<and>\n                     (r \\<noteq> i \\<longrightarrow>\n                      (s = i \\<longrightarrow>\n                       nP r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                       otherbot) \\<and>\n                      (s \\<noteq> i \\<longrightarrow>\n                       nP r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                       nP s)))))", "apply (simp add:graph_ops)"], ["proof (prove)\ngoal (1 subgoal):\n 1. otherbot \\<noteq> default_node_properties \\<Longrightarrow>\n    \\<exists>G.\n       wf_graph G \\<and>\n       (\\<exists>nP.\n           (\\<exists>x\\<in>edges G.\n               \\<not> (case x of\n                       (s, r) \\<Rightarrow>\n                         nP r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                         nP s)) \\<and>\n           (\\<exists>i f.\n               f \\<subseteq> edges G \\<and>\n               (\\<exists>x\\<in>edges G.\n                   \\<not> (case x of\n                           (s, r) \\<Rightarrow>\n                             nP r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                             nP s)) \\<and>\n               (\\<forall>x\\<in>edges G - f.\n                   case x of\n                   (s, r) \\<Rightarrow>\n                     nP r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                     nP s) \\<and>\n               (\\<forall>x\\<in>f.\n                   case x of\n                   (e1, e2) \\<Rightarrow>\n                     nP e2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                     nP e1 \\<longrightarrow>\n                     (\\<exists>x\\<in>edges G - f.\n                         \\<not> (case x of\n                                 (s, r) \\<Rightarrow>\n                                   nP r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                   nP s))) \\<and>\n               (\\<forall>x\\<in>edges G - f.\n                   case x of\n                   (s, r) \\<Rightarrow>\n                     nP r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                     nP s) \\<and>\n               i \\<in> fst ` f \\<and>\n               (\\<forall>x\\<in>edges G.\n                   case x of\n                   (s, r) \\<Rightarrow>\n                     (r = i \\<longrightarrow>\n                      (s = i \\<longrightarrow>\n                       otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                       otherbot) \\<and>\n                      (s \\<noteq> i \\<longrightarrow>\n                       otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                       nP s)) \\<and>\n                     (r \\<noteq> i \\<longrightarrow>\n                      (s = i \\<longrightarrow>\n                       nP r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                       otherbot) \\<and>\n                      (s \\<noteq> i \\<longrightarrow>\n                       nP r \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                       nP s)))))", "apply (simp split: prod.split_asm prod.split domainNameTrust.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. otherbot \\<noteq> default_node_properties \\<Longrightarrow>\n    \\<exists>G.\n       wf_graph G \\<and>\n       (\\<exists>nP.\n           (\\<exists>x\\<in>edges G.\n               \\<forall>x1 x2.\n                  x = (x1, x2) \\<longrightarrow>\n                  \\<not> nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                         nP x1) \\<and>\n           (\\<exists>i f.\n               f \\<subseteq> edges G \\<and>\n               (\\<exists>x\\<in>edges G.\n                   \\<forall>x1 x2.\n                      x = (x1, x2) \\<longrightarrow>\n                      \\<not> nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                             nP x1) \\<and>\n               (\\<forall>x\\<in>edges G - f.\n                   \\<forall>x1 x2.\n                      x = (x1, x2) \\<longrightarrow>\n                      nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                      nP x1) \\<and>\n               (\\<forall>x\\<in>f.\n                   \\<forall>x1 x2.\n                      x = (x1, x2) \\<longrightarrow>\n                      nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                      nP x1 \\<longrightarrow>\n                      (\\<exists>x\\<in>edges G - f.\n                          \\<forall>x1 x2.\n                             x = (x1, x2) \\<longrightarrow>\n                             \\<not> nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP x1)) \\<and>\n               (\\<forall>x\\<in>edges G - f.\n                   \\<forall>x1 x2.\n                      x = (x1, x2) \\<longrightarrow>\n                      nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                      nP x1) \\<and>\n               i \\<in> fst ` f \\<and>\n               (\\<forall>x\\<in>edges G.\n                   \\<forall>x1 x2.\n                      x = (x1, x2) \\<longrightarrow>\n                      (x2 = i \\<longrightarrow>\n                       (x1 = i \\<longrightarrow>\n                        otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                        otherbot) \\<and>\n                       (x1 \\<noteq> i \\<longrightarrow>\n                        otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                        nP x1)) \\<and>\n                      (x2 \\<noteq> i \\<longrightarrow>\n                       (x1 = i \\<longrightarrow>\n                        nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                        otherbot) \\<and>\n                       (x1 \\<noteq> i \\<longrightarrow>\n                        nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                        nP x1)))))", "apply(rule_tac x=\"\\<lparr> nodes={vertex_1,vertex_2}, edges = {(vertex_1,vertex_2)} \\<rparr>\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. otherbot \\<noteq> default_node_properties \\<Longrightarrow>\n    wf_graph\n     \\<lparr>nodes = {vertex_1, vertex_2},\n        edges = {(vertex_1, vertex_2)}\\<rparr> \\<and>\n    (\\<exists>nP.\n        \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n               nP vertex_1 \\<and>\n        (\\<exists>i f.\n            f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n            \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                   nP vertex_1 \\<and>\n            ((vertex_1, vertex_2) \\<notin> f \\<longrightarrow>\n             nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n             nP vertex_1) \\<and>\n            (\\<forall>x\\<in>f.\n                \\<forall>x1 x2.\n                   x = (x1, x2) \\<longrightarrow>\n                   nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                   nP x1 \\<longrightarrow>\n                   (vertex_1, vertex_2) \\<notin> f \\<and>\n                   \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                          nP vertex_1) \\<and>\n            ((vertex_1, vertex_2) \\<notin> f \\<longrightarrow>\n             nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n             nP vertex_1) \\<and>\n            i \\<in> fst ` f \\<and>\n            (vertex_2 = i \\<longrightarrow>\n             otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n             nP vertex_1) \\<and>\n            (vertex_2 \\<noteq> i \\<longrightarrow>\n             (vertex_1 = i \\<longrightarrow>\n              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n              otherbot) \\<and>\n             (vertex_1 \\<noteq> i \\<longrightarrow>\n              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n              nP vertex_1))))", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. otherbot \\<noteq> default_node_properties \\<Longrightarrow>\n    wf_graph\n     \\<lparr>nodes = {vertex_1, vertex_2},\n        edges = {(vertex_1, vertex_2)}\\<rparr>\n 2. otherbot \\<noteq> default_node_properties \\<Longrightarrow>\n    \\<exists>nP.\n       \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n              nP vertex_1 \\<and>\n       (\\<exists>i f.\n           f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n           \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                  nP vertex_1 \\<and>\n           ((vertex_1, vertex_2) \\<notin> f \\<longrightarrow>\n            nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n            nP vertex_1) \\<and>\n           (\\<forall>x\\<in>f.\n               \\<forall>x1 x2.\n                  x = (x1, x2) \\<longrightarrow>\n                  nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                  nP x1 \\<longrightarrow>\n                  (vertex_1, vertex_2) \\<notin> f \\<and>\n                  \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                         nP vertex_1) \\<and>\n           ((vertex_1, vertex_2) \\<notin> f \\<longrightarrow>\n            nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n            nP vertex_1) \\<and>\n           i \\<in> fst ` f \\<and>\n           (vertex_2 = i \\<longrightarrow>\n            otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n            nP vertex_1) \\<and>\n           (vertex_2 \\<noteq> i \\<longrightarrow>\n            (vertex_1 = i \\<longrightarrow>\n             nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n             otherbot) \\<and>\n            (vertex_1 \\<noteq> i \\<longrightarrow>\n             nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n             nP vertex_1)))", "apply(simp add: wf_graph_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. otherbot \\<noteq> default_node_properties \\<Longrightarrow>\n    \\<exists>nP.\n       \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n              nP vertex_1 \\<and>\n       (\\<exists>i f.\n           f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n           \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                  nP vertex_1 \\<and>\n           ((vertex_1, vertex_2) \\<notin> f \\<longrightarrow>\n            nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n            nP vertex_1) \\<and>\n           (\\<forall>x\\<in>f.\n               \\<forall>x1 x2.\n                  x = (x1, x2) \\<longrightarrow>\n                  nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                  nP x1 \\<longrightarrow>\n                  (vertex_1, vertex_2) \\<notin> f \\<and>\n                  \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                         nP vertex_1) \\<and>\n           ((vertex_1, vertex_2) \\<notin> f \\<longrightarrow>\n            nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n            nP vertex_1) \\<and>\n           i \\<in> fst ` f \\<and>\n           (vertex_2 = i \\<longrightarrow>\n            otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n            nP vertex_1) \\<and>\n           (vertex_2 \\<noteq> i \\<longrightarrow>\n            (vertex_1 = i \\<longrightarrow>\n             nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n             otherbot) \\<and>\n            (vertex_1 \\<noteq> i \\<longrightarrow>\n             nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n             nP vertex_1)))", "apply(case_tac otherbot)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>otherbot \\<noteq> default_node_properties;\n        otherbot = domainNameTrust.DN x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nP.\n                            \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                   nP vertex_1 \\<and>\n                            (\\<exists>i f.\n                                f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                                \\<not> nP\n  vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP vertex_1 \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (\\<forall>x\\<in>f.\n                                    \\<forall>x1 x2.\n x = (x1, x2) \\<longrightarrow>\n nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP x1 \\<longrightarrow>\n (vertex_1, vertex_2) \\<notin> f \\<and>\n \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n        nP vertex_1) \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                i \\<in> fst ` f \\<and>\n                                (vertex_2 = i \\<longrightarrow>\n                                 otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (vertex_2 \\<noteq> i \\<longrightarrow>\n                                 (vertex_1 = i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  otherbot) \\<and>\n                                 (vertex_1 \\<noteq> i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  nP vertex_1)))\n 2. \\<lbrakk>otherbot \\<noteq> default_node_properties;\n     otherbot = domainNameTrust.Unassigned\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nP.\n                         \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                nP vertex_1 \\<and>\n                         (\\<exists>i f.\n                             f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                             \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP vertex_1 \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (\\<forall>x\\<in>f.\n                                 \\<forall>x1 x2.\n                                    x = (x1, x2) \\<longrightarrow>\n                                    nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP x1 \\<longrightarrow>\n                                    (vertex_1, vertex_2) \\<notin> f \\<and>\n                                    \\<not> nP\n      vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     nP vertex_1) \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             i \\<in> fst ` f \\<and>\n                             (vertex_2 = i \\<longrightarrow>\n                              otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (vertex_2 \\<noteq> i \\<longrightarrow>\n                              (vertex_1 = i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               otherbot) \\<and>\n                              (vertex_1 \\<noteq> i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               nP vertex_1)))", "apply(rename_tac prod)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>prod.\n       \\<lbrakk>otherbot \\<noteq> default_node_properties;\n        otherbot = domainNameTrust.DN prod\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nP.\n                            \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                   nP vertex_1 \\<and>\n                            (\\<exists>i f.\n                                f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                                \\<not> nP\n  vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP vertex_1 \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (\\<forall>x\\<in>f.\n                                    \\<forall>x1 x2.\n x = (x1, x2) \\<longrightarrow>\n nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP x1 \\<longrightarrow>\n (vertex_1, vertex_2) \\<notin> f \\<and>\n \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n        nP vertex_1) \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                i \\<in> fst ` f \\<and>\n                                (vertex_2 = i \\<longrightarrow>\n                                 otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (vertex_2 \\<noteq> i \\<longrightarrow>\n                                 (vertex_1 = i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  otherbot) \\<and>\n                                 (vertex_1 \\<noteq> i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  nP vertex_1)))\n 2. \\<lbrakk>otherbot \\<noteq> default_node_properties;\n     otherbot = domainNameTrust.Unassigned\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nP.\n                         \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                nP vertex_1 \\<and>\n                         (\\<exists>i f.\n                             f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                             \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP vertex_1 \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (\\<forall>x\\<in>f.\n                                 \\<forall>x1 x2.\n                                    x = (x1, x2) \\<longrightarrow>\n                                    nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP x1 \\<longrightarrow>\n                                    (vertex_1, vertex_2) \\<notin> f \\<and>\n                                    \\<not> nP\n      vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     nP vertex_1) \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             i \\<in> fst ` f \\<and>\n                             (vertex_2 = i \\<longrightarrow>\n                              otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (vertex_2 \\<noteq> i \\<longrightarrow>\n                              (vertex_1 = i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               otherbot) \\<and>\n                              (vertex_1 \\<noteq> i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               nP vertex_1)))", "apply(case_tac prod)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>prod a b.\n       \\<lbrakk>otherbot \\<noteq> default_node_properties;\n        otherbot = domainNameTrust.DN prod; prod = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nP.\n                            \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                   nP vertex_1 \\<and>\n                            (\\<exists>i f.\n                                f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                                \\<not> nP\n  vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP vertex_1 \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (\\<forall>x\\<in>f.\n                                    \\<forall>x1 x2.\n x = (x1, x2) \\<longrightarrow>\n nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP x1 \\<longrightarrow>\n (vertex_1, vertex_2) \\<notin> f \\<and>\n \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n        nP vertex_1) \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                i \\<in> fst ` f \\<and>\n                                (vertex_2 = i \\<longrightarrow>\n                                 otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (vertex_2 \\<noteq> i \\<longrightarrow>\n                                 (vertex_1 = i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  otherbot) \\<and>\n                                 (vertex_1 \\<noteq> i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  nP vertex_1)))\n 2. \\<lbrakk>otherbot \\<noteq> default_node_properties;\n     otherbot = domainNameTrust.Unassigned\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nP.\n                         \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                nP vertex_1 \\<and>\n                         (\\<exists>i f.\n                             f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                             \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP vertex_1 \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (\\<forall>x\\<in>f.\n                                 \\<forall>x1 x2.\n                                    x = (x1, x2) \\<longrightarrow>\n                                    nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP x1 \\<longrightarrow>\n                                    (vertex_1, vertex_2) \\<notin> f \\<and>\n                                    \\<not> nP\n      vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     nP vertex_1) \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             i \\<in> fst ` f \\<and>\n                             (vertex_2 = i \\<longrightarrow>\n                              otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (vertex_2 \\<noteq> i \\<longrightarrow>\n                              (vertex_1 = i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               otherbot) \\<and>\n                              (vertex_1 \\<noteq> i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               nP vertex_1)))", "apply(rename_tac dn trustlevel)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>prod dn trustlevel.\n       \\<lbrakk>otherbot \\<noteq> default_node_properties;\n        otherbot = domainNameTrust.DN prod; prod = (dn, trustlevel)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nP.\n                            \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                   nP vertex_1 \\<and>\n                            (\\<exists>i f.\n                                f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                                \\<not> nP\n  vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP vertex_1 \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (\\<forall>x\\<in>f.\n                                    \\<forall>x1 x2.\n x = (x1, x2) \\<longrightarrow>\n nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP x1 \\<longrightarrow>\n (vertex_1, vertex_2) \\<notin> f \\<and>\n \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n        nP vertex_1) \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                i \\<in> fst ` f \\<and>\n                                (vertex_2 = i \\<longrightarrow>\n                                 otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (vertex_2 \\<noteq> i \\<longrightarrow>\n                                 (vertex_1 = i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  otherbot) \\<and>\n                                 (vertex_1 \\<noteq> i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  nP vertex_1)))\n 2. \\<lbrakk>otherbot \\<noteq> default_node_properties;\n     otherbot = domainNameTrust.Unassigned\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nP.\n                         \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                nP vertex_1 \\<and>\n                         (\\<exists>i f.\n                             f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                             \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP vertex_1 \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (\\<forall>x\\<in>f.\n                                 \\<forall>x1 x2.\n                                    x = (x1, x2) \\<longrightarrow>\n                                    nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP x1 \\<longrightarrow>\n                                    (vertex_1, vertex_2) \\<notin> f \\<and>\n                                    \\<not> nP\n      vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     nP vertex_1) \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             i \\<in> fst ` f \\<and>\n                             (vertex_2 = i \\<longrightarrow>\n                              otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (vertex_2 \\<noteq> i \\<longrightarrow>\n                              (vertex_1 = i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               otherbot) \\<and>\n                              (vertex_1 \\<noteq> i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               nP vertex_1)))", "apply(clarify)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b dn trustlevel.\n       \\<lbrakk>domainNameTrust.DN (dn, trustlevel) \\<noteq>\n                default_node_properties;\n        otherbot = domainNameTrust.DN (dn, trustlevel)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nP.\n                            \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                   nP vertex_1 \\<and>\n                            (\\<exists>i f.\n                                f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                                \\<not> nP\n  vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP vertex_1 \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (\\<forall>x\\<in>f.\n                                    \\<forall>x1 x2.\n x = (x1, x2) \\<longrightarrow>\n nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP x1 \\<longrightarrow>\n (vertex_1, vertex_2) \\<notin> f \\<and>\n \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n        nP vertex_1) \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                i \\<in> fst ` f \\<and>\n                                (vertex_2 = i \\<longrightarrow>\n                                 domainNameTrust.DN\n                                  (dn,\n                                   trustlevel) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (vertex_2 \\<noteq> i \\<longrightarrow>\n                                 (vertex_1 = i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  domainNameTrust.DN\n                                   (dn, trustlevel)) \\<and>\n                                 (vertex_1 \\<noteq> i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  nP vertex_1)))\n 2. \\<lbrakk>otherbot \\<noteq> default_node_properties;\n     otherbot = domainNameTrust.Unassigned\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nP.\n                         \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                nP vertex_1 \\<and>\n                         (\\<exists>i f.\n                             f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                             \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP vertex_1 \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (\\<forall>x\\<in>f.\n                                 \\<forall>x1 x2.\n                                    x = (x1, x2) \\<longrightarrow>\n                                    nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP x1 \\<longrightarrow>\n                                    (vertex_1, vertex_2) \\<notin> f \\<and>\n                                    \\<not> nP\n      vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     nP vertex_1) \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             i \\<in> fst ` f \\<and>\n                             (vertex_2 = i \\<longrightarrow>\n                              otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (vertex_2 \\<noteq> i \\<longrightarrow>\n                              (vertex_1 = i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               otherbot) \\<and>\n                              (vertex_1 \\<noteq> i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               nP vertex_1)))", "apply(case_tac dn)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b dn trustlevel x11 x12.\n       \\<lbrakk>domainNameTrust.DN (dn, trustlevel) \\<noteq>\n                default_node_properties;\n        otherbot = domainNameTrust.DN (dn, trustlevel);\n        dn = x11 -- x12\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nP.\n                            \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                   nP vertex_1 \\<and>\n                            (\\<exists>i f.\n                                f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                                \\<not> nP\n  vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP vertex_1 \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (\\<forall>x\\<in>f.\n                                    \\<forall>x1 x2.\n x = (x1, x2) \\<longrightarrow>\n nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP x1 \\<longrightarrow>\n (vertex_1, vertex_2) \\<notin> f \\<and>\n \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n        nP vertex_1) \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                i \\<in> fst ` f \\<and>\n                                (vertex_2 = i \\<longrightarrow>\n                                 domainNameTrust.DN\n                                  (dn,\n                                   trustlevel) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (vertex_2 \\<noteq> i \\<longrightarrow>\n                                 (vertex_1 = i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  domainNameTrust.DN\n                                   (dn, trustlevel)) \\<and>\n                                 (vertex_1 \\<noteq> i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  nP vertex_1)))\n 2. \\<And>a b dn trustlevel.\n       \\<lbrakk>domainNameTrust.DN (dn, trustlevel) \\<noteq>\n                default_node_properties;\n        otherbot = domainNameTrust.DN (dn, trustlevel); dn = Leaf\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nP.\n                            \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                   nP vertex_1 \\<and>\n                            (\\<exists>i f.\n                                f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                                \\<not> nP\n  vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP vertex_1 \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (\\<forall>x\\<in>f.\n                                    \\<forall>x1 x2.\n x = (x1, x2) \\<longrightarrow>\n nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP x1 \\<longrightarrow>\n (vertex_1, vertex_2) \\<notin> f \\<and>\n \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n        nP vertex_1) \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                i \\<in> fst ` f \\<and>\n                                (vertex_2 = i \\<longrightarrow>\n                                 domainNameTrust.DN\n                                  (dn,\n                                   trustlevel) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (vertex_2 \\<noteq> i \\<longrightarrow>\n                                 (vertex_1 = i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  domainNameTrust.DN\n                                   (dn, trustlevel)) \\<and>\n                                 (vertex_1 \\<noteq> i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  nP vertex_1)))\n 3. \\<lbrakk>otherbot \\<noteq> default_node_properties;\n     otherbot = domainNameTrust.Unassigned\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nP.\n                         \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                nP vertex_1 \\<and>\n                         (\\<exists>i f.\n                             f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                             \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP vertex_1 \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (\\<forall>x\\<in>f.\n                                 \\<forall>x1 x2.\n                                    x = (x1, x2) \\<longrightarrow>\n                                    nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP x1 \\<longrightarrow>\n                                    (vertex_1, vertex_2) \\<notin> f \\<and>\n                                    \\<not> nP\n      vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     nP vertex_1) \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             i \\<in> fst ` f \\<and>\n                             (vertex_2 = i \\<longrightarrow>\n                              otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (vertex_2 \\<noteq> i \\<longrightarrow>\n                              (vertex_1 = i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               otherbot) \\<and>\n                              (vertex_1 \\<noteq> i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               nP vertex_1)))", "(* case (name -- dpt, trustlevel)  *)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b dn trustlevel x11 x12.\n       \\<lbrakk>domainNameTrust.DN (dn, trustlevel) \\<noteq>\n                default_node_properties;\n        otherbot = domainNameTrust.DN (dn, trustlevel);\n        dn = x11 -- x12\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nP.\n                            \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                   nP vertex_1 \\<and>\n                            (\\<exists>i f.\n                                f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                                \\<not> nP\n  vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP vertex_1 \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (\\<forall>x\\<in>f.\n                                    \\<forall>x1 x2.\n x = (x1, x2) \\<longrightarrow>\n nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP x1 \\<longrightarrow>\n (vertex_1, vertex_2) \\<notin> f \\<and>\n \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n        nP vertex_1) \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                i \\<in> fst ` f \\<and>\n                                (vertex_2 = i \\<longrightarrow>\n                                 domainNameTrust.DN\n                                  (dn,\n                                   trustlevel) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (vertex_2 \\<noteq> i \\<longrightarrow>\n                                 (vertex_1 = i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  domainNameTrust.DN\n                                   (dn, trustlevel)) \\<and>\n                                 (vertex_1 \\<noteq> i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  nP vertex_1)))\n 2. \\<And>a b dn trustlevel.\n       \\<lbrakk>domainNameTrust.DN (dn, trustlevel) \\<noteq>\n                default_node_properties;\n        otherbot = domainNameTrust.DN (dn, trustlevel); dn = Leaf\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nP.\n                            \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                   nP vertex_1 \\<and>\n                            (\\<exists>i f.\n                                f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                                \\<not> nP\n  vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP vertex_1 \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (\\<forall>x\\<in>f.\n                                    \\<forall>x1 x2.\n x = (x1, x2) \\<longrightarrow>\n nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP x1 \\<longrightarrow>\n (vertex_1, vertex_2) \\<notin> f \\<and>\n \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n        nP vertex_1) \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                i \\<in> fst ` f \\<and>\n                                (vertex_2 = i \\<longrightarrow>\n                                 domainNameTrust.DN\n                                  (dn,\n                                   trustlevel) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (vertex_2 \\<noteq> i \\<longrightarrow>\n                                 (vertex_1 = i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  domainNameTrust.DN\n                                   (dn, trustlevel)) \\<and>\n                                 (vertex_1 \\<noteq> i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  nP vertex_1)))\n 3. \\<lbrakk>otherbot \\<noteq> default_node_properties;\n     otherbot = domainNameTrust.Unassigned\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nP.\n                         \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                nP vertex_1 \\<and>\n                         (\\<exists>i f.\n                             f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                             \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP vertex_1 \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (\\<forall>x\\<in>f.\n                                 \\<forall>x1 x2.\n                                    x = (x1, x2) \\<longrightarrow>\n                                    nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP x1 \\<longrightarrow>\n                                    (vertex_1, vertex_2) \\<notin> f \\<and>\n                                    \\<not> nP\n      vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     nP vertex_1) \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             i \\<in> fst ` f \\<and>\n                             (vertex_2 = i \\<longrightarrow>\n                              otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (vertex_2 \\<noteq> i \\<longrightarrow>\n                              (vertex_1 = i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               otherbot) \\<and>\n                              (vertex_1 \\<noteq> i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               nP vertex_1)))", "apply(rename_tac name dpt)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b dn trustlevel name dpt.\n       \\<lbrakk>domainNameTrust.DN (dn, trustlevel) \\<noteq>\n                default_node_properties;\n        otherbot = domainNameTrust.DN (dn, trustlevel);\n        dn = name -- dpt\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nP.\n                            \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                   nP vertex_1 \\<and>\n                            (\\<exists>i f.\n                                f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                                \\<not> nP\n  vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP vertex_1 \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (\\<forall>x\\<in>f.\n                                    \\<forall>x1 x2.\n x = (x1, x2) \\<longrightarrow>\n nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP x1 \\<longrightarrow>\n (vertex_1, vertex_2) \\<notin> f \\<and>\n \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n        nP vertex_1) \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                i \\<in> fst ` f \\<and>\n                                (vertex_2 = i \\<longrightarrow>\n                                 domainNameTrust.DN\n                                  (dn,\n                                   trustlevel) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (vertex_2 \\<noteq> i \\<longrightarrow>\n                                 (vertex_1 = i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  domainNameTrust.DN\n                                   (dn, trustlevel)) \\<and>\n                                 (vertex_1 \\<noteq> i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  nP vertex_1)))\n 2. \\<And>a b dn trustlevel.\n       \\<lbrakk>domainNameTrust.DN (dn, trustlevel) \\<noteq>\n                default_node_properties;\n        otherbot = domainNameTrust.DN (dn, trustlevel); dn = Leaf\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nP.\n                            \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                   nP vertex_1 \\<and>\n                            (\\<exists>i f.\n                                f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                                \\<not> nP\n  vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP vertex_1 \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (\\<forall>x\\<in>f.\n                                    \\<forall>x1 x2.\n x = (x1, x2) \\<longrightarrow>\n nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP x1 \\<longrightarrow>\n (vertex_1, vertex_2) \\<notin> f \\<and>\n \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n        nP vertex_1) \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                i \\<in> fst ` f \\<and>\n                                (vertex_2 = i \\<longrightarrow>\n                                 domainNameTrust.DN\n                                  (dn,\n                                   trustlevel) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (vertex_2 \\<noteq> i \\<longrightarrow>\n                                 (vertex_1 = i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  domainNameTrust.DN\n                                   (dn, trustlevel)) \\<and>\n                                 (vertex_1 \\<noteq> i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  nP vertex_1)))\n 3. \\<lbrakk>otherbot \\<noteq> default_node_properties;\n     otherbot = domainNameTrust.Unassigned\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nP.\n                         \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                nP vertex_1 \\<and>\n                         (\\<exists>i f.\n                             f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                             \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP vertex_1 \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (\\<forall>x\\<in>f.\n                                 \\<forall>x1 x2.\n                                    x = (x1, x2) \\<longrightarrow>\n                                    nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP x1 \\<longrightarrow>\n                                    (vertex_1, vertex_2) \\<notin> f \\<and>\n                                    \\<not> nP\n      vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     nP vertex_1) \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             i \\<in> fst ` f \\<and>\n                             (vertex_2 = i \\<longrightarrow>\n                              otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (vertex_2 \\<noteq> i \\<longrightarrow>\n                              (vertex_1 = i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               otherbot) \\<and>\n                              (vertex_1 \\<noteq> i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               nP vertex_1)))", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>dn trustlevel name dpt.\n       \\<lbrakk>domainNameTrust.DN (name -- dpt, trustlevel) \\<noteq>\n                default_node_properties;\n        otherbot = domainNameTrust.DN (name -- dpt, trustlevel);\n        dn = name -- dpt\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nP.\n                            \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                   nP vertex_1 \\<and>\n                            (\\<exists>i f.\n                                f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                                \\<not> nP\n  vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP vertex_1 \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (\\<forall>x\\<in>f.\n                                    \\<forall>x1 x2.\n x = (x1, x2) \\<longrightarrow>\n nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP x1 \\<longrightarrow>\n (vertex_1, vertex_2) \\<notin> f \\<and>\n \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n        nP vertex_1) \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                i \\<in> fst ` f \\<and>\n                                (vertex_2 = i \\<longrightarrow>\n                                 domainNameTrust.DN\n                                  (name -- dpt,\n                                   trustlevel) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (vertex_2 \\<noteq> i \\<longrightarrow>\n                                 (vertex_1 = i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  domainNameTrust.DN\n                                   (name -- dpt, trustlevel)) \\<and>\n                                 (vertex_1 \\<noteq> i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  nP vertex_1)))\n 2. \\<And>a b dn trustlevel.\n       \\<lbrakk>domainNameTrust.DN (dn, trustlevel) \\<noteq>\n                default_node_properties;\n        otherbot = domainNameTrust.DN (dn, trustlevel); dn = Leaf\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nP.\n                            \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                   nP vertex_1 \\<and>\n                            (\\<exists>i f.\n                                f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                                \\<not> nP\n  vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP vertex_1 \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (\\<forall>x\\<in>f.\n                                    \\<forall>x1 x2.\n x = (x1, x2) \\<longrightarrow>\n nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP x1 \\<longrightarrow>\n (vertex_1, vertex_2) \\<notin> f \\<and>\n \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n        nP vertex_1) \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                i \\<in> fst ` f \\<and>\n                                (vertex_2 = i \\<longrightarrow>\n                                 domainNameTrust.DN\n                                  (dn,\n                                   trustlevel) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (vertex_2 \\<noteq> i \\<longrightarrow>\n                                 (vertex_1 = i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  domainNameTrust.DN\n                                   (dn, trustlevel)) \\<and>\n                                 (vertex_1 \\<noteq> i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  nP vertex_1)))\n 3. \\<lbrakk>otherbot \\<noteq> default_node_properties;\n     otherbot = domainNameTrust.Unassigned\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nP.\n                         \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                nP vertex_1 \\<and>\n                         (\\<exists>i f.\n                             f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                             \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP vertex_1 \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (\\<forall>x\\<in>f.\n                                 \\<forall>x1 x2.\n                                    x = (x1, x2) \\<longrightarrow>\n                                    nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP x1 \\<longrightarrow>\n                                    (vertex_1, vertex_2) \\<notin> f \\<and>\n                                    \\<not> nP\n      vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     nP vertex_1) \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             i \\<in> fst ` f \\<and>\n                             (vertex_2 = i \\<longrightarrow>\n                              otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (vertex_2 \\<noteq> i \\<longrightarrow>\n                              (vertex_1 = i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               otherbot) \\<and>\n                              (vertex_1 \\<noteq> i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               nP vertex_1)))", "apply(rule_tac x=\"(\\<lambda> x. default_node_properties)(vertex_1 := Unassigned, vertex_2 := DN (name--dpt, 0 ))\" in exI, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>dn trustlevel name dpt.\n       \\<lbrakk>domainNameTrust.DN (name -- dpt, trustlevel) \\<noteq>\n                default_node_properties;\n        otherbot = domainNameTrust.DN (name -- dpt, trustlevel);\n        dn = name -- dpt\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i f.\n                            f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                            (vertex_1, vertex_2) \\<in> f \\<and>\n                            (\\<forall>x\\<in>f.\n                                \\<forall>x1.\n                                   (x1 = vertex_1 \\<longrightarrow>\n                                    (\\<forall>x2.\n  (x2 = vertex_1 \\<longrightarrow>\n   x = (vertex_1, vertex_1) \\<longrightarrow>\n   (vertex_1, vertex_2) \\<notin> f) \\<and>\n  (x2 \\<noteq> vertex_1 \\<longrightarrow>\n   x2 \\<noteq> vertex_2 \\<longrightarrow>\n   x = (vertex_1, x2) \\<longrightarrow>\n   default_node_properties \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n   domainNameTrust.Unassigned \\<longrightarrow>\n   (vertex_1, vertex_2) \\<notin> f))) \\<and>\n                                   (x1 \\<noteq> vertex_1 \\<longrightarrow>\n                                    (x1 = vertex_2 \\<longrightarrow>\n                                     (\\<forall>x2.\n   (x2 = vertex_1 \\<longrightarrow>\n    x = (vertex_2, vertex_1) \\<longrightarrow>\n    (vertex_1, vertex_2) \\<notin> f) \\<and>\n   (x2 \\<noteq> vertex_1 \\<longrightarrow>\n    (x2 = vertex_2 \\<longrightarrow>\n     x = (vertex_2, vertex_2) \\<longrightarrow>\n     (vertex_1, vertex_2) \\<notin> f) \\<and>\n    (x2 \\<noteq> vertex_2 \\<longrightarrow>\n     x = (vertex_2, x2) \\<longrightarrow>\n     default_node_properties \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     domainNameTrust.DN (name -- dpt, 0) \\<longrightarrow>\n     (vertex_1, vertex_2) \\<notin> f)))) \\<and>\n                                    (x1 \\<noteq> vertex_2 \\<longrightarrow>\n                                     (\\<forall>x2.\n   (x2 = vertex_1 \\<longrightarrow>\n    x = (x1, vertex_1) \\<longrightarrow>\n    (vertex_1, vertex_2) \\<notin> f) \\<and>\n   (x2 \\<noteq> vertex_1 \\<longrightarrow>\n    (x2 = vertex_2 \\<longrightarrow>\n     x = (x1, vertex_2) \\<longrightarrow>\n     domainNameTrust.DN\n      (name -- dpt, 0) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     default_node_properties \\<longrightarrow>\n     (vertex_1, vertex_2) \\<notin> f) \\<and>\n    (x2 \\<noteq> vertex_2 \\<longrightarrow>\n     x = (x1, x2) \\<longrightarrow>\n     default_node_properties \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     default_node_properties \\<longrightarrow>\n     (vertex_1, vertex_2) \\<notin> f)))))) \\<and>\n                            (vertex_1, vertex_2) \\<in> f \\<and>\n                            i \\<in> fst ` f \\<and>\n                            vertex_2 \\<noteq> i \\<and>\n                            (vertex_2 \\<noteq> i \\<longrightarrow>\n                             (vertex_1 = i \\<longrightarrow>\n                              name -- dpt\n                              \\<le> domainNameChop (name -- dpt)\n                                     trustlevel) \\<and>\n                             vertex_1 = i)\n 2. \\<And>a b dn trustlevel.\n       \\<lbrakk>domainNameTrust.DN (dn, trustlevel) \\<noteq>\n                default_node_properties;\n        otherbot = domainNameTrust.DN (dn, trustlevel); dn = Leaf\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nP.\n                            \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                   nP vertex_1 \\<and>\n                            (\\<exists>i f.\n                                f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                                \\<not> nP\n  vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP vertex_1 \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (\\<forall>x\\<in>f.\n                                    \\<forall>x1 x2.\n x = (x1, x2) \\<longrightarrow>\n nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP x1 \\<longrightarrow>\n (vertex_1, vertex_2) \\<notin> f \\<and>\n \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n        nP vertex_1) \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                i \\<in> fst ` f \\<and>\n                                (vertex_2 = i \\<longrightarrow>\n                                 domainNameTrust.DN\n                                  (dn,\n                                   trustlevel) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (vertex_2 \\<noteq> i \\<longrightarrow>\n                                 (vertex_1 = i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  domainNameTrust.DN\n                                   (dn, trustlevel)) \\<and>\n                                 (vertex_1 \\<noteq> i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  nP vertex_1)))\n 3. \\<lbrakk>otherbot \\<noteq> default_node_properties;\n     otherbot = domainNameTrust.Unassigned\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nP.\n                         \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                nP vertex_1 \\<and>\n                         (\\<exists>i f.\n                             f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                             \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP vertex_1 \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (\\<forall>x\\<in>f.\n                                 \\<forall>x1 x2.\n                                    x = (x1, x2) \\<longrightarrow>\n                                    nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP x1 \\<longrightarrow>\n                                    (vertex_1, vertex_2) \\<notin> f \\<and>\n                                    \\<not> nP\n      vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     nP vertex_1) \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             i \\<in> fst ` f \\<and>\n                             (vertex_2 = i \\<longrightarrow>\n                              otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (vertex_2 \\<noteq> i \\<longrightarrow>\n                              (vertex_1 = i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               otherbot) \\<and>\n                              (vertex_1 \\<noteq> i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               nP vertex_1)))", "apply(rule_tac x=\"vertex_1\" in exI, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>dn trustlevel name dpt.\n       \\<lbrakk>domainNameTrust.DN (name -- dpt, trustlevel) \\<noteq>\n                default_node_properties;\n        otherbot = domainNameTrust.DN (name -- dpt, trustlevel);\n        dn = name -- dpt\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<subseteq>{(vertex_1, vertex_2)}.\n                            (vertex_1, vertex_2) \\<in> f \\<and>\n                            (\\<forall>x\\<in>f.\n                                \\<forall>x1.\n                                   (x1 = vertex_1 \\<longrightarrow>\n                                    (\\<forall>x2.\n  (x2 = vertex_1 \\<longrightarrow>\n   x = (vertex_1, vertex_1) \\<longrightarrow>\n   (vertex_1, vertex_2) \\<notin> f) \\<and>\n  (x2 \\<noteq> vertex_1 \\<longrightarrow>\n   x2 \\<noteq> vertex_2 \\<longrightarrow>\n   x = (vertex_1, x2) \\<longrightarrow>\n   default_node_properties \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n   domainNameTrust.Unassigned \\<longrightarrow>\n   (vertex_1, vertex_2) \\<notin> f))) \\<and>\n                                   (x1 \\<noteq> vertex_1 \\<longrightarrow>\n                                    (x1 = vertex_2 \\<longrightarrow>\n                                     (\\<forall>x2.\n   (x2 = vertex_1 \\<longrightarrow>\n    x = (vertex_2, vertex_1) \\<longrightarrow>\n    (vertex_1, vertex_2) \\<notin> f) \\<and>\n   (x2 \\<noteq> vertex_1 \\<longrightarrow>\n    (x2 = vertex_2 \\<longrightarrow>\n     x = (vertex_2, vertex_2) \\<longrightarrow>\n     (vertex_1, vertex_2) \\<notin> f) \\<and>\n    (x2 \\<noteq> vertex_2 \\<longrightarrow>\n     x = (vertex_2, x2) \\<longrightarrow>\n     default_node_properties \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     domainNameTrust.DN (name -- dpt, 0) \\<longrightarrow>\n     (vertex_1, vertex_2) \\<notin> f)))) \\<and>\n                                    (x1 \\<noteq> vertex_2 \\<longrightarrow>\n                                     (\\<forall>x2.\n   (x2 = vertex_1 \\<longrightarrow>\n    x = (x1, vertex_1) \\<longrightarrow>\n    (vertex_1, vertex_2) \\<notin> f) \\<and>\n   (x2 \\<noteq> vertex_1 \\<longrightarrow>\n    (x2 = vertex_2 \\<longrightarrow>\n     x = (x1, vertex_2) \\<longrightarrow>\n     domainNameTrust.DN\n      (name -- dpt, 0) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     default_node_properties \\<longrightarrow>\n     (vertex_1, vertex_2) \\<notin> f) \\<and>\n    (x2 \\<noteq> vertex_2 \\<longrightarrow>\n     x = (x1, x2) \\<longrightarrow>\n     default_node_properties \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     default_node_properties \\<longrightarrow>\n     (vertex_1, vertex_2) \\<notin> f)))))) \\<and>\n                            (vertex_1, vertex_2) \\<in> f \\<and>\n                            vertex_1 \\<in> fst ` f \\<and>\n                            name -- dpt\n                            \\<le> domainNameChop (name -- dpt) trustlevel\n 2. \\<And>a b dn trustlevel.\n       \\<lbrakk>domainNameTrust.DN (dn, trustlevel) \\<noteq>\n                default_node_properties;\n        otherbot = domainNameTrust.DN (dn, trustlevel); dn = Leaf\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nP.\n                            \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                   nP vertex_1 \\<and>\n                            (\\<exists>i f.\n                                f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                                \\<not> nP\n  vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP vertex_1 \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (\\<forall>x\\<in>f.\n                                    \\<forall>x1 x2.\n x = (x1, x2) \\<longrightarrow>\n nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP x1 \\<longrightarrow>\n (vertex_1, vertex_2) \\<notin> f \\<and>\n \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n        nP vertex_1) \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                i \\<in> fst ` f \\<and>\n                                (vertex_2 = i \\<longrightarrow>\n                                 domainNameTrust.DN\n                                  (dn,\n                                   trustlevel) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (vertex_2 \\<noteq> i \\<longrightarrow>\n                                 (vertex_1 = i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  domainNameTrust.DN\n                                   (dn, trustlevel)) \\<and>\n                                 (vertex_1 \\<noteq> i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  nP vertex_1)))\n 3. \\<lbrakk>otherbot \\<noteq> default_node_properties;\n     otherbot = domainNameTrust.Unassigned\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nP.\n                         \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                nP vertex_1 \\<and>\n                         (\\<exists>i f.\n                             f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                             \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP vertex_1 \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (\\<forall>x\\<in>f.\n                                 \\<forall>x1 x2.\n                                    x = (x1, x2) \\<longrightarrow>\n                                    nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP x1 \\<longrightarrow>\n                                    (vertex_1, vertex_2) \\<notin> f \\<and>\n                                    \\<not> nP\n      vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     nP vertex_1) \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             i \\<in> fst ` f \\<and>\n                             (vertex_2 = i \\<longrightarrow>\n                              otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (vertex_2 \\<noteq> i \\<longrightarrow>\n                              (vertex_1 = i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               otherbot) \\<and>\n                              (vertex_1 \\<noteq> i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               nP vertex_1)))", "apply(rule_tac x=\"{(vertex_1,vertex_2)}\" in exI, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>dn trustlevel name dpt.\n       \\<lbrakk>domainNameTrust.DN (name -- dpt, trustlevel) \\<noteq>\n                default_node_properties;\n        otherbot = domainNameTrust.DN (name -- dpt, trustlevel);\n        dn = name -- dpt\\<rbrakk>\n       \\<Longrightarrow> name -- dpt\n                         \\<le> domainNameChop (name -- dpt) trustlevel\n 2. \\<And>a b dn trustlevel.\n       \\<lbrakk>domainNameTrust.DN (dn, trustlevel) \\<noteq>\n                default_node_properties;\n        otherbot = domainNameTrust.DN (dn, trustlevel); dn = Leaf\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nP.\n                            \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                   nP vertex_1 \\<and>\n                            (\\<exists>i f.\n                                f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                                \\<not> nP\n  vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP vertex_1 \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (\\<forall>x\\<in>f.\n                                    \\<forall>x1 x2.\n x = (x1, x2) \\<longrightarrow>\n nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP x1 \\<longrightarrow>\n (vertex_1, vertex_2) \\<notin> f \\<and>\n \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n        nP vertex_1) \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                i \\<in> fst ` f \\<and>\n                                (vertex_2 = i \\<longrightarrow>\n                                 domainNameTrust.DN\n                                  (dn,\n                                   trustlevel) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (vertex_2 \\<noteq> i \\<longrightarrow>\n                                 (vertex_1 = i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  domainNameTrust.DN\n                                   (dn, trustlevel)) \\<and>\n                                 (vertex_1 \\<noteq> i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  nP vertex_1)))\n 3. \\<lbrakk>otherbot \\<noteq> default_node_properties;\n     otherbot = domainNameTrust.Unassigned\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nP.\n                         \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                nP vertex_1 \\<and>\n                         (\\<exists>i f.\n                             f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                             \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP vertex_1 \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (\\<forall>x\\<in>f.\n                                 \\<forall>x1 x2.\n                                    x = (x1, x2) \\<longrightarrow>\n                                    nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP x1 \\<longrightarrow>\n                                    (vertex_1, vertex_2) \\<notin> f \\<and>\n                                    \\<not> nP\n      vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     nP vertex_1) \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             i \\<in> fst ` f \\<and>\n                             (vertex_2 = i \\<longrightarrow>\n                              otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (vertex_2 \\<noteq> i \\<longrightarrow>\n                              (vertex_1 = i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               otherbot) \\<and>\n                              (vertex_1 \\<noteq> i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               nP vertex_1)))", "apply(simp add:chop_not_decrease_hierarchy)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b dn trustlevel.\n       \\<lbrakk>domainNameTrust.DN (dn, trustlevel) \\<noteq>\n                default_node_properties;\n        otherbot = domainNameTrust.DN (dn, trustlevel); dn = Leaf\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nP.\n                            \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                   nP vertex_1 \\<and>\n                            (\\<exists>i f.\n                                f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                                \\<not> nP\n  vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP vertex_1 \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (\\<forall>x\\<in>f.\n                                    \\<forall>x1 x2.\n x = (x1, x2) \\<longrightarrow>\n nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP x1 \\<longrightarrow>\n (vertex_1, vertex_2) \\<notin> f \\<and>\n \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n        nP vertex_1) \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                i \\<in> fst ` f \\<and>\n                                (vertex_2 = i \\<longrightarrow>\n                                 domainNameTrust.DN\n                                  (dn,\n                                   trustlevel) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (vertex_2 \\<noteq> i \\<longrightarrow>\n                                 (vertex_1 = i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  domainNameTrust.DN\n                                   (dn, trustlevel)) \\<and>\n                                 (vertex_1 \\<noteq> i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  nP vertex_1)))\n 2. \\<lbrakk>otherbot \\<noteq> default_node_properties;\n     otherbot = domainNameTrust.Unassigned\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nP.\n                         \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                nP vertex_1 \\<and>\n                         (\\<exists>i f.\n                             f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                             \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP vertex_1 \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (\\<forall>x\\<in>f.\n                                 \\<forall>x1 x2.\n                                    x = (x1, x2) \\<longrightarrow>\n                                    nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP x1 \\<longrightarrow>\n                                    (vertex_1, vertex_2) \\<notin> f \\<and>\n                                    \\<not> nP\n      vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     nP vertex_1) \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             i \\<in> fst ` f \\<and>\n                             (vertex_2 = i \\<longrightarrow>\n                              otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (vertex_2 \\<noteq> i \\<longrightarrow>\n                              (vertex_1 = i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               otherbot) \\<and>\n                              (vertex_1 \\<noteq> i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               nP vertex_1)))", "(* case (Leaf, trustlevel)*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b dn trustlevel.\n       \\<lbrakk>domainNameTrust.DN (dn, trustlevel) \\<noteq>\n                default_node_properties;\n        otherbot = domainNameTrust.DN (dn, trustlevel); dn = Leaf\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nP.\n                            \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                   nP vertex_1 \\<and>\n                            (\\<exists>i f.\n                                f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                                \\<not> nP\n  vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP vertex_1 \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (\\<forall>x\\<in>f.\n                                    \\<forall>x1 x2.\n x = (x1, x2) \\<longrightarrow>\n nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP x1 \\<longrightarrow>\n (vertex_1, vertex_2) \\<notin> f \\<and>\n \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n        nP vertex_1) \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                i \\<in> fst ` f \\<and>\n                                (vertex_2 = i \\<longrightarrow>\n                                 domainNameTrust.DN\n                                  (dn,\n                                   trustlevel) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (vertex_2 \\<noteq> i \\<longrightarrow>\n                                 (vertex_1 = i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  domainNameTrust.DN\n                                   (dn, trustlevel)) \\<and>\n                                 (vertex_1 \\<noteq> i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  nP vertex_1)))\n 2. \\<lbrakk>otherbot \\<noteq> default_node_properties;\n     otherbot = domainNameTrust.Unassigned\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nP.\n                         \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                nP vertex_1 \\<and>\n                         (\\<exists>i f.\n                             f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                             \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP vertex_1 \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (\\<forall>x\\<in>f.\n                                 \\<forall>x1 x2.\n                                    x = (x1, x2) \\<longrightarrow>\n                                    nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP x1 \\<longrightarrow>\n                                    (vertex_1, vertex_2) \\<notin> f \\<and>\n                                    \\<not> nP\n      vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     nP vertex_1) \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             i \\<in> fst ` f \\<and>\n                             (vertex_2 = i \\<longrightarrow>\n                              otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (vertex_2 \\<noteq> i \\<longrightarrow>\n                              (vertex_1 = i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               otherbot) \\<and>\n                              (vertex_1 \\<noteq> i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               nP vertex_1)))", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>dn trustlevel.\n       \\<lbrakk>domainNameTrust.DN (Leaf, trustlevel) \\<noteq>\n                default_node_properties;\n        otherbot = domainNameTrust.DN (Leaf, trustlevel); dn = Leaf\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nP.\n                            \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                   nP vertex_1 \\<and>\n                            (\\<exists>i f.\n                                f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                                \\<not> nP\n  vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP vertex_1 \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (\\<forall>x\\<in>f.\n                                    \\<forall>x1 x2.\n x = (x1, x2) \\<longrightarrow>\n nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n nP x1 \\<longrightarrow>\n (vertex_1, vertex_2) \\<notin> f \\<and>\n \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n        nP vertex_1) \\<and>\n                                ((vertex_1, vertex_2)\n                                 \\<notin> f \\<longrightarrow>\n                                 nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                i \\<in> fst ` f \\<and>\n                                (vertex_2 = i \\<longrightarrow>\n                                 domainNameTrust.DN\n                                  (Leaf,\n                                   trustlevel) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                 nP vertex_1) \\<and>\n                                (vertex_2 \\<noteq> i \\<longrightarrow>\n                                 (vertex_1 = i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  domainNameTrust.DN\n                                   (Leaf, trustlevel)) \\<and>\n                                 (vertex_1 \\<noteq> i \\<longrightarrow>\n                                  nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                  nP vertex_1)))\n 2. \\<lbrakk>otherbot \\<noteq> default_node_properties;\n     otherbot = domainNameTrust.Unassigned\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nP.\n                         \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                nP vertex_1 \\<and>\n                         (\\<exists>i f.\n                             f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                             \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP vertex_1 \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (\\<forall>x\\<in>f.\n                                 \\<forall>x1 x2.\n                                    x = (x1, x2) \\<longrightarrow>\n                                    nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP x1 \\<longrightarrow>\n                                    (vertex_1, vertex_2) \\<notin> f \\<and>\n                                    \\<not> nP\n      vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     nP vertex_1) \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             i \\<in> fst ` f \\<and>\n                             (vertex_2 = i \\<longrightarrow>\n                              otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (vertex_2 \\<noteq> i \\<longrightarrow>\n                              (vertex_1 = i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               otherbot) \\<and>\n                              (vertex_1 \\<noteq> i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               nP vertex_1)))", "apply(rule_tac x=\"(\\<lambda> x. default_node_properties)(vertex_1 := Unassigned, vertex_2 := DN (Leaf, 0))\" in exI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>dn trustlevel.\n       \\<lbrakk>domainNameTrust.DN (Leaf, trustlevel) \\<noteq>\n                default_node_properties;\n        otherbot = domainNameTrust.DN (Leaf, trustlevel); dn = Leaf\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i f.\n                            f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                            (vertex_1, vertex_2) \\<in> f \\<and>\n                            (\\<forall>x\\<in>f.\n                                \\<forall>x1.\n                                   (x1 = vertex_1 \\<longrightarrow>\n                                    (\\<forall>x2.\n  (x2 = vertex_1 \\<longrightarrow>\n   x = (vertex_1, vertex_1) \\<longrightarrow>\n   (vertex_1, vertex_2) \\<notin> f) \\<and>\n  (x2 \\<noteq> vertex_1 \\<longrightarrow>\n   x2 \\<noteq> vertex_2 \\<longrightarrow>\n   x = (vertex_1, x2) \\<longrightarrow>\n   default_node_properties \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n   domainNameTrust.Unassigned \\<longrightarrow>\n   (vertex_1, vertex_2) \\<notin> f))) \\<and>\n                                   (x1 \\<noteq> vertex_1 \\<longrightarrow>\n                                    (x1 = vertex_2 \\<longrightarrow>\n                                     (\\<forall>x2.\n   (x2 = vertex_1 \\<longrightarrow>\n    x = (vertex_2, vertex_1) \\<longrightarrow>\n    (vertex_1, vertex_2) \\<notin> f) \\<and>\n   (x2 \\<noteq> vertex_1 \\<longrightarrow>\n    (x2 = vertex_2 \\<longrightarrow>\n     x = (vertex_2, vertex_2) \\<longrightarrow>\n     (vertex_1, vertex_2) \\<notin> f) \\<and>\n    (x2 \\<noteq> vertex_2 \\<longrightarrow>\n     x = (vertex_2, x2) \\<longrightarrow>\n     default_node_properties \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     domainNameTrust.DN (Leaf, 0) \\<longrightarrow>\n     (vertex_1, vertex_2) \\<notin> f)))) \\<and>\n                                    (x1 \\<noteq> vertex_2 \\<longrightarrow>\n                                     (\\<forall>x2.\n   (x2 = vertex_1 \\<longrightarrow>\n    x = (x1, vertex_1) \\<longrightarrow>\n    (vertex_1, vertex_2) \\<notin> f) \\<and>\n   (x2 \\<noteq> vertex_1 \\<longrightarrow>\n    (x2 = vertex_2 \\<longrightarrow>\n     x = (x1, vertex_2) \\<longrightarrow>\n     domainNameTrust.DN\n      (Leaf, 0) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     default_node_properties \\<longrightarrow>\n     (vertex_1, vertex_2) \\<notin> f) \\<and>\n    (x2 \\<noteq> vertex_2 \\<longrightarrow>\n     x = (x1, x2) \\<longrightarrow>\n     default_node_properties \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     default_node_properties \\<longrightarrow>\n     (vertex_1, vertex_2) \\<notin> f)))))) \\<and>\n                            (vertex_1, vertex_2) \\<in> f \\<and>\n                            i \\<in> fst ` f \\<and>\n                            vertex_2 \\<noteq> i \\<and>\n                            (vertex_2 \\<noteq> i \\<longrightarrow>\n                             vertex_1 = i)\n 2. \\<lbrakk>otherbot \\<noteq> default_node_properties;\n     otherbot = domainNameTrust.Unassigned\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nP.\n                         \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                nP vertex_1 \\<and>\n                         (\\<exists>i f.\n                             f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                             \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP vertex_1 \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (\\<forall>x\\<in>f.\n                                 \\<forall>x1 x2.\n                                    x = (x1, x2) \\<longrightarrow>\n                                    nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP x1 \\<longrightarrow>\n                                    (vertex_1, vertex_2) \\<notin> f \\<and>\n                                    \\<not> nP\n      vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     nP vertex_1) \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             i \\<in> fst ` f \\<and>\n                             (vertex_2 = i \\<longrightarrow>\n                              otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (vertex_2 \\<noteq> i \\<longrightarrow>\n                              (vertex_1 = i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               otherbot) \\<and>\n                              (vertex_1 \\<noteq> i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               nP vertex_1)))", "apply(rule_tac x=\"vertex_1\" in exI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>dn trustlevel.\n       \\<lbrakk>domainNameTrust.DN (Leaf, trustlevel) \\<noteq>\n                default_node_properties;\n        otherbot = domainNameTrust.DN (Leaf, trustlevel); dn = Leaf\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<subseteq>{(vertex_1, vertex_2)}.\n                            (vertex_1, vertex_2) \\<in> f \\<and>\n                            (\\<forall>x\\<in>f.\n                                \\<forall>x1.\n                                   (x1 = vertex_1 \\<longrightarrow>\n                                    (\\<forall>x2.\n  (x2 = vertex_1 \\<longrightarrow>\n   x = (vertex_1, vertex_1) \\<longrightarrow>\n   (vertex_1, vertex_2) \\<notin> f) \\<and>\n  (x2 \\<noteq> vertex_1 \\<longrightarrow>\n   x2 \\<noteq> vertex_2 \\<longrightarrow>\n   x = (vertex_1, x2) \\<longrightarrow>\n   default_node_properties \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n   domainNameTrust.Unassigned \\<longrightarrow>\n   (vertex_1, vertex_2) \\<notin> f))) \\<and>\n                                   (x1 \\<noteq> vertex_1 \\<longrightarrow>\n                                    (x1 = vertex_2 \\<longrightarrow>\n                                     (\\<forall>x2.\n   (x2 = vertex_1 \\<longrightarrow>\n    x = (vertex_2, vertex_1) \\<longrightarrow>\n    (vertex_1, vertex_2) \\<notin> f) \\<and>\n   (x2 \\<noteq> vertex_1 \\<longrightarrow>\n    (x2 = vertex_2 \\<longrightarrow>\n     x = (vertex_2, vertex_2) \\<longrightarrow>\n     (vertex_1, vertex_2) \\<notin> f) \\<and>\n    (x2 \\<noteq> vertex_2 \\<longrightarrow>\n     x = (vertex_2, x2) \\<longrightarrow>\n     default_node_properties \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     domainNameTrust.DN (Leaf, 0) \\<longrightarrow>\n     (vertex_1, vertex_2) \\<notin> f)))) \\<and>\n                                    (x1 \\<noteq> vertex_2 \\<longrightarrow>\n                                     (\\<forall>x2.\n   (x2 = vertex_1 \\<longrightarrow>\n    x = (x1, vertex_1) \\<longrightarrow>\n    (vertex_1, vertex_2) \\<notin> f) \\<and>\n   (x2 \\<noteq> vertex_1 \\<longrightarrow>\n    (x2 = vertex_2 \\<longrightarrow>\n     x = (x1, vertex_2) \\<longrightarrow>\n     domainNameTrust.DN\n      (Leaf, 0) \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     default_node_properties \\<longrightarrow>\n     (vertex_1, vertex_2) \\<notin> f) \\<and>\n    (x2 \\<noteq> vertex_2 \\<longrightarrow>\n     x = (x1, x2) \\<longrightarrow>\n     default_node_properties \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     default_node_properties \\<longrightarrow>\n     (vertex_1, vertex_2) \\<notin> f)))))) \\<and>\n                            (vertex_1, vertex_2) \\<in> f \\<and>\n                            vertex_1 \\<in> fst ` f\n 2. \\<lbrakk>otherbot \\<noteq> default_node_properties;\n     otherbot = domainNameTrust.Unassigned\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nP.\n                         \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                nP vertex_1 \\<and>\n                         (\\<exists>i f.\n                             f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                             \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP vertex_1 \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (\\<forall>x\\<in>f.\n                                 \\<forall>x1 x2.\n                                    x = (x1, x2) \\<longrightarrow>\n                                    nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP x1 \\<longrightarrow>\n                                    (vertex_1, vertex_2) \\<notin> f \\<and>\n                                    \\<not> nP\n      vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     nP vertex_1) \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             i \\<in> fst ` f \\<and>\n                             (vertex_2 = i \\<longrightarrow>\n                              otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (vertex_2 \\<noteq> i \\<longrightarrow>\n                              (vertex_1 = i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               otherbot) \\<and>\n                              (vertex_1 \\<noteq> i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               nP vertex_1)))", "apply(rule_tac x=\"{(vertex_1,vertex_2)}\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>otherbot \\<noteq> default_node_properties;\n     otherbot = domainNameTrust.Unassigned\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nP.\n                         \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                nP vertex_1 \\<and>\n                         (\\<exists>i f.\n                             f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                             \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP vertex_1 \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (\\<forall>x\\<in>f.\n                                 \\<forall>x1 x2.\n                                    x = (x1, x2) \\<longrightarrow>\n                                    nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP x1 \\<longrightarrow>\n                                    (vertex_1, vertex_2) \\<notin> f \\<and>\n                                    \\<not> nP\n      vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     nP vertex_1) \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             i \\<in> fst ` f \\<and>\n                             (vertex_2 = i \\<longrightarrow>\n                              otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (vertex_2 \\<noteq> i \\<longrightarrow>\n                              (vertex_1 = i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               otherbot) \\<and>\n                              (vertex_1 \\<noteq> i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               nP vertex_1)))", "(* case Unassigned *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>otherbot \\<noteq> default_node_properties;\n     otherbot = domainNameTrust.Unassigned\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nP.\n                         \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                nP vertex_1 \\<and>\n                         (\\<exists>i f.\n                             f \\<subseteq> {(vertex_1, vertex_2)} \\<and>\n                             \\<not> nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP vertex_1 \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (\\<forall>x\\<in>f.\n                                 \\<forall>x1 x2.\n                                    x = (x1, x2) \\<longrightarrow>\n                                    nP x2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                                    nP x1 \\<longrightarrow>\n                                    (vertex_1, vertex_2) \\<notin> f \\<and>\n                                    \\<not> nP\n      vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n     nP vertex_1) \\<and>\n                             ((vertex_1, vertex_2)\n                              \\<notin> f \\<longrightarrow>\n                              nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             i \\<in> fst ` f \\<and>\n                             (vertex_2 = i \\<longrightarrow>\n                              otherbot \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                              nP vertex_1) \\<and>\n                             (vertex_2 \\<noteq> i \\<longrightarrow>\n                              (vertex_1 = i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               otherbot) \\<and>\n                              (vertex_1 \\<noteq> i \\<longrightarrow>\n                               nP vertex_2 \\<sqsubseteq>\\<^sub>t\\<^sub>r\\<^sub>u\\<^sub>s\\<^sub>t\n                               nP vertex_1)))", "apply(simp add: default_node_properties_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation DomainHierarchyNG: SecurityInvariant_ACS\nwhere default_node_properties = default_node_properties\nand sinvar = sinvar\nrewrites \"SecurityInvariant_withOffendingFlows.set_offending_flows sinvar = DomainHierarchyNG_offending_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_ACS sinvar default_node_properties &&&\n    set_offending_flows = DomainHierarchyNG_offending_set", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G f nP.\n       \\<lbrakk>wf_graph G; f \\<in> set_offending_flows G nP\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>fst ` f.\n                            \\<not> sinvar G\n                                    (nP(i := default_node_properties))\n 2. \\<And>otherbot.\n       \\<forall>G f nP i.\n          wf_graph G \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          i \\<in> fst ` f \\<longrightarrow>\n          \\<not> sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n       otherbot = default_node_properties\n 3. set_offending_flows = DomainHierarchyNG_offending_set", "apply(rule ballI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G f nP i.\n       \\<lbrakk>wf_graph G; f \\<in> set_offending_flows G nP;\n        i \\<in> fst ` f\\<rbrakk>\n       \\<Longrightarrow> \\<not> sinvar G (nP(i := default_node_properties))\n 2. \\<And>otherbot.\n       \\<forall>G f nP i.\n          wf_graph G \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          i \\<in> fst ` f \\<longrightarrow>\n          \\<not> sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n       otherbot = default_node_properties\n 3. set_offending_flows = DomainHierarchyNG_offending_set", "apply(drule SecurityInvariant_withOffendingFlows.ENF_fsts_refl_instance[OF DomainHierarchyNG_ENF_refl unassigned_default_candidate], simp_all)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>otherbot.\n       \\<forall>G f nP i.\n          wf_graph G \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          i \\<in> fst ` f \\<longrightarrow>\n          \\<not> sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n       otherbot = default_node_properties\n 2. set_offending_flows = DomainHierarchyNG_offending_set", "apply(erule default_uniqueness_by_counterexample_ACS)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>otherbot.\n       otherbot \\<noteq> default_node_properties \\<Longrightarrow>\n       \\<exists>G nP i f.\n          wf_graph G \\<and>\n          \\<not> sinvar G nP \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          sinvar (delete_edges G f) nP \\<and>\n          i \\<in> fst ` f \\<and> sinvar G (nP(i := otherbot))\n 2. set_offending_flows = DomainHierarchyNG_offending_set", "apply(drule Unassigned_unique_default)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>otherbot.\n       \\<exists>G nP gP i f.\n          wf_graph G \\<and>\n          \\<not> sinvar G nP \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          sinvar (delete_edges G f) nP \\<and>\n          i \\<in> fst ` f \\<and>\n          sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n       \\<exists>G nP i f.\n          wf_graph G \\<and>\n          \\<not> sinvar G nP \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          sinvar (delete_edges G f) nP \\<and>\n          i \\<in> fst ` f \\<and> sinvar G (nP(i := otherbot))\n 2. set_offending_flows = DomainHierarchyNG_offending_set", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_offending_flows = DomainHierarchyNG_offending_set", "apply(fact DomainHierarchyNG_offending_set)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma TopoS_DomainHierarchyNG: \"SecurityInvariant sinvar default_node_properties receiver_violation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant sinvar default_node_properties receiver_violation", "unfolding receiver_violation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant sinvar default_node_properties False", "by(unfold_locales)"], ["", "hide_const (open) sinvar receiver_violation"], ["", "end"]]}