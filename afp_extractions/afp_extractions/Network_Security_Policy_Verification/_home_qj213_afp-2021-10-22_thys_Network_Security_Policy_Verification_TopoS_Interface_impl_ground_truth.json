{"file_name": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification/TopoS_Interface_impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification", "problem_names": ["lemma \"wf_list_graph G \\<Longrightarrow> wf_graph (list_graph_to_graph G)\"", "lemma TopoS_eval_impl_proofrule: \n    assumes inst: \"SecurityInvariant sinvar_spec default_node_properties receiver_violation\"\n    assumes ev: \"\\<And>nP. wf_list_graph G \\<Longrightarrow> sinvar_spec (list_graph_to_graph G) nP = sinvar_impl G nP\"\n    shows \"\n      (distinct (nodesL G) \\<and> distinct (edgesL G) \\<and> \n       SecurityInvariant.eval sinvar_spec default_node_properties (list_graph_to_graph G) P) =\n      (wf_list_graph G \\<and> sinvar_impl G (SecurityInvariant.node_props default_node_properties P))\"", "lemma Generic_offending_list_correct: \n    assumes valid: \"wf_list_graph G\"\n    assumes spec_impl: \"\\<And>G nP. wf_list_graph G \\<Longrightarrow> sinvar_spec (list_graph_to_graph G) nP = sinvar_impl G nP\"\n    shows \"SecurityInvariant_withOffendingFlows.set_offending_flows sinvar_spec (list_graph_to_graph G) nP = \n      set`set( Generic_offending_list sinvar_impl G nP )\"", "lemma all_edges_list_I: \"P (list_graph_to_graph G) = Pl G \\<Longrightarrow> \n    (\\<forall>(e1, e2)\\<in> (edges (list_graph_to_graph G)). P (list_graph_to_graph G) e1 e2) = (\\<forall>(e1, e2)\\<in>set (edgesL G). Pl G e1 e2)\"", "lemma all_nodes_list_I: \"P (list_graph_to_graph G) = Pl G \\<Longrightarrow> \n    (\\<forall>n \\<in> (nodes (list_graph_to_graph G)). P (list_graph_to_graph G) n) = (\\<forall> n \\<in>set (nodesL G). Pl G n)\"", "lemma minimalize_offending_overapprox_spec_impl:\n    assumes valid: \"wf_list_graph (G::'v::vertex list_graph)\"\n        and spec_impl: \"\\<And>G nP::('v \\<Rightarrow> 'a). wf_list_graph G \\<Longrightarrow> sinvar_spec (list_graph_to_graph G) nP = sinvar_impl G nP\"\n    shows \"minimalize_offending_overapprox (\\<lambda>G. sinvar_impl G nP) fs keeps G =\n       TopoS_withOffendingFlows.minimalize_offending_overapprox (\\<lambda>G. sinvar_spec G nP) fs keeps (list_graph_to_graph G)\"", "lemma minimalize_offending_overapprox_gives_some_offending_flow:\n    assumes wf: \"wf_list_graph G\"\n        and NetModelLib: \"TopoS_modelLibrary m sinvar_spec\"\n        and violation: \"\\<not> (nm_sinvar m) G nP\"\n    shows \"set (minimalize_offending_overapprox (\\<lambda>G. (nm_sinvar m) G nP) (edgesL G) [] G) \\<in>\n            SecurityInvariant_withOffendingFlows.set_offending_flows sinvar_spec (list_graph_to_graph G) nP\""], "translations": [["", "lemma \"wf_list_graph G \\<Longrightarrow> wf_graph (list_graph_to_graph G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_list_graph G \\<Longrightarrow> wf_graph (list_graph_to_graph G)", "by %invisible (metis wf_list_graph_def wf_list_graph_iff_wf_graph)"], ["", "locale TopoS_List_Impl = \n    fixes default_node_properties :: \"'a\" (\"\\<bottom>\") \n    and sinvar_spec::\"('v::vertex) graph \\<Rightarrow> ('v::vertex \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n    and sinvar_impl::\"('v::vertex) list_graph \\<Rightarrow> ('v::vertex \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n    and receiver_violation :: \"bool\"\n    and offending_flows_impl::\"('v::vertex) list_graph \\<Rightarrow> ('v \\<Rightarrow> 'a) \\<Rightarrow> ('v \\<times> 'v) list list\"\n    and node_props_impl::\"('v::vertex, 'a) TopoS_Params \\<Rightarrow> ('v \\<Rightarrow> 'a)\"\n    and eval_impl::\"('v::vertex) list_graph \\<Rightarrow> ('v, 'a) TopoS_Params \\<Rightarrow> bool\"\n    assumes\n      spec: \"SecurityInvariant sinvar_spec default_node_properties receiver_violation\" \\<comment> \\<open>specification is valid\\<close>\n    and\n      sinvar_spec_impl: \"wf_list_graph G \\<Longrightarrow> \n        (sinvar_spec (list_graph_to_graph G) nP) = (sinvar_impl G nP)\"\n    and\n      offending_flows_spec_impl: \"wf_list_graph G \\<Longrightarrow> \n      (SecurityInvariant_withOffendingFlows.set_offending_flows sinvar_spec (list_graph_to_graph G) nP) = \n      set`set (offending_flows_impl G nP)\"\n    and \n      node_props_spec_impl: \n     \"SecurityInvariant.node_props_formaldef default_node_properties P = node_props_impl P\"\n    and\n      eval_spec_impl:\n     \"(distinct (nodesL G) \\<and> distinct (edgesL G) \\<and> \n     SecurityInvariant.eval sinvar_spec default_node_properties (list_graph_to_graph G) P ) = \n     (eval_impl G P)\""], ["", "subsection \\<open>Security Invariants Packed\\<close>"], ["", "text \\<open>We pack all necessary functions and properties of a security invariant in a struct-like data structure.\\<close>"], ["", "record ('v::vertex, 'a) TopoS_packed =\n    nm_name :: \"string\"\n    nm_receiver_violation :: \"bool\"\n    nm_default :: \"'a\"\n    nm_sinvar::\"('v::vertex) list_graph \\<Rightarrow> ('v \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n    nm_offending_flows::\"('v::vertex) list_graph \\<Rightarrow> ('v \\<Rightarrow> 'a) \\<Rightarrow> ('v \\<times> 'v) list list\"\n    nm_node_props::\"('v::vertex, 'a) TopoS_Params \\<Rightarrow> ('v \\<Rightarrow> 'a)\" \n    nm_eval::\"('v::vertex) list_graph \\<Rightarrow> ('v, 'a)TopoS_Params \\<Rightarrow> bool\""], ["", "text\\<open>The packed list implementation must comply with the formal definition.\\<close>"], ["", "locale TopoS_modelLibrary =\n    fixes m :: \"('v::vertex, 'a) TopoS_packed\" \\<comment> \\<open>concrete model implementation\\<close>\n    and sinvar_spec::\"('v::vertex) graph \\<Rightarrow> ('v::vertex \\<Rightarrow> 'a) \\<Rightarrow> bool\" \\<comment> \\<open>specification\\<close>\n    assumes\n       name_not_empty: \"length (nm_name m) > 0\"\n     and\n       impl_spec: \"TopoS_List_Impl \n        (nm_default m)\n        sinvar_spec\n        (nm_sinvar m)\n        (nm_receiver_violation m)\n        (nm_offending_flows m)\n        (nm_node_props m)\n        (nm_eval m)\""], ["", "subsection\\<open>Helpful Lemmata\\<close>"], ["", "text\\<open>show that @{term \"sinvar\"} complies\\<close>"], ["", "lemma TopoS_eval_impl_proofrule: \n    assumes inst: \"SecurityInvariant sinvar_spec default_node_properties receiver_violation\"\n    assumes ev: \"\\<And>nP. wf_list_graph G \\<Longrightarrow> sinvar_spec (list_graph_to_graph G) nP = sinvar_impl G nP\"\n    shows \"\n      (distinct (nodesL G) \\<and> distinct (edgesL G) \\<and> \n       SecurityInvariant.eval sinvar_spec default_node_properties (list_graph_to_graph G) P) =\n      (wf_list_graph G \\<and> sinvar_impl G (SecurityInvariant.node_props default_node_properties P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (distinct (nodesL G) \\<and>\n     distinct (edgesL G) \\<and>\n     SecurityInvariant.eval sinvar_spec default_node_properties\n      (list_graph_to_graph G) P) =\n    (wf_list_graph G \\<and>\n     sinvar_impl G (SecurityInvariant.node_props default_node_properties P))", "proof (cases \"wf_list_graph G\")"], ["proof (state)\ngoal (2 subgoals):\n 1. wf_list_graph G \\<Longrightarrow>\n    (distinct (nodesL G) \\<and>\n     distinct (edgesL G) \\<and>\n     SecurityInvariant.eval sinvar_spec default_node_properties\n      (list_graph_to_graph G) P) =\n    (wf_list_graph G \\<and>\n     sinvar_impl G (SecurityInvariant.node_props default_node_properties P))\n 2. \\<not> wf_list_graph G \\<Longrightarrow>\n    (distinct (nodesL G) \\<and>\n     distinct (edgesL G) \\<and>\n     SecurityInvariant.eval sinvar_spec default_node_properties\n      (list_graph_to_graph G) P) =\n    (wf_list_graph G \\<and>\n     sinvar_impl G (SecurityInvariant.node_props default_node_properties P))", "case True"], ["proof (state)\nthis:\n  wf_list_graph G\n\ngoal (2 subgoals):\n 1. wf_list_graph G \\<Longrightarrow>\n    (distinct (nodesL G) \\<and>\n     distinct (edgesL G) \\<and>\n     SecurityInvariant.eval sinvar_spec default_node_properties\n      (list_graph_to_graph G) P) =\n    (wf_list_graph G \\<and>\n     sinvar_impl G (SecurityInvariant.node_props default_node_properties P))\n 2. \\<not> wf_list_graph G \\<Longrightarrow>\n    (distinct (nodesL G) \\<and>\n     distinct (edgesL G) \\<and>\n     SecurityInvariant.eval sinvar_spec default_node_properties\n      (list_graph_to_graph G) P) =\n    (wf_list_graph G \\<and>\n     sinvar_impl G (SecurityInvariant.node_props default_node_properties P))", "hence \"sinvar_spec (list_graph_to_graph G) (SecurityInvariant.node_props default_node_properties P) =\n       sinvar_impl G (SecurityInvariant.node_props default_node_properties P)\""], ["proof (prove)\nusing this:\n  wf_list_graph G\n\ngoal (1 subgoal):\n 1. sinvar_spec (list_graph_to_graph G)\n     (SecurityInvariant.node_props default_node_properties P) =\n    sinvar_impl G (SecurityInvariant.node_props default_node_properties P)", "using ev"], ["proof (prove)\nusing this:\n  wf_list_graph G\n  wf_list_graph G \\<Longrightarrow>\n  sinvar_spec (list_graph_to_graph G) ?nP = sinvar_impl G ?nP\n\ngoal (1 subgoal):\n 1. sinvar_spec (list_graph_to_graph G)\n     (SecurityInvariant.node_props default_node_properties P) =\n    sinvar_impl G (SecurityInvariant.node_props default_node_properties P)", "by blast"], ["proof (state)\nthis:\n  sinvar_spec (list_graph_to_graph G)\n   (SecurityInvariant.node_props default_node_properties P) =\n  sinvar_impl G (SecurityInvariant.node_props default_node_properties P)\n\ngoal (2 subgoals):\n 1. wf_list_graph G \\<Longrightarrow>\n    (distinct (nodesL G) \\<and>\n     distinct (edgesL G) \\<and>\n     SecurityInvariant.eval sinvar_spec default_node_properties\n      (list_graph_to_graph G) P) =\n    (wf_list_graph G \\<and>\n     sinvar_impl G (SecurityInvariant.node_props default_node_properties P))\n 2. \\<not> wf_list_graph G \\<Longrightarrow>\n    (distinct (nodesL G) \\<and>\n     distinct (edgesL G) \\<and>\n     SecurityInvariant.eval sinvar_spec default_node_properties\n      (list_graph_to_graph G) P) =\n    (wf_list_graph G \\<and>\n     sinvar_impl G (SecurityInvariant.node_props default_node_properties P))", "with inst"], ["proof (chain)\npicking this:\n  SecurityInvariant sinvar_spec default_node_properties receiver_violation\n  sinvar_spec (list_graph_to_graph G)\n   (SecurityInvariant.node_props default_node_properties P) =\n  sinvar_impl G (SecurityInvariant.node_props default_node_properties P)", "show ?thesis"], ["proof (prove)\nusing this:\n  SecurityInvariant sinvar_spec default_node_properties receiver_violation\n  sinvar_spec (list_graph_to_graph G)\n   (SecurityInvariant.node_props default_node_properties P) =\n  sinvar_impl G (SecurityInvariant.node_props default_node_properties P)\n\ngoal (1 subgoal):\n 1. (distinct (nodesL G) \\<and>\n     distinct (edgesL G) \\<and>\n     SecurityInvariant.eval sinvar_spec default_node_properties\n      (list_graph_to_graph G) P) =\n    (wf_list_graph G \\<and>\n     sinvar_impl G (SecurityInvariant.node_props default_node_properties P))", "unfolding wf_list_graph_def"], ["proof (prove)\nusing this:\n  SecurityInvariant sinvar_spec default_node_properties receiver_violation\n  sinvar_spec (list_graph_to_graph G)\n   (SecurityInvariant.node_props default_node_properties P) =\n  sinvar_impl G (SecurityInvariant.node_props default_node_properties P)\n\ngoal (1 subgoal):\n 1. (distinct (nodesL G) \\<and>\n     distinct (edgesL G) \\<and>\n     SecurityInvariant.eval sinvar_spec default_node_properties\n      (list_graph_to_graph G) P) =\n    ((distinct (nodesL G) \\<and>\n      distinct (edgesL G) \\<and> wf_list_graph_axioms G) \\<and>\n     sinvar_impl G (SecurityInvariant.node_props default_node_properties P))", "by (simp add: wf_list_graph_iff_wf_graph SecurityInvariant.eval_def)"], ["proof (state)\nthis:\n  (distinct (nodesL G) \\<and>\n   distinct (edgesL G) \\<and>\n   SecurityInvariant.eval sinvar_spec default_node_properties\n    (list_graph_to_graph G) P) =\n  (wf_list_graph G \\<and>\n   sinvar_impl G (SecurityInvariant.node_props default_node_properties P))\n\ngoal (1 subgoal):\n 1. \\<not> wf_list_graph G \\<Longrightarrow>\n    (distinct (nodesL G) \\<and>\n     distinct (edgesL G) \\<and>\n     SecurityInvariant.eval sinvar_spec default_node_properties\n      (list_graph_to_graph G) P) =\n    (wf_list_graph G \\<and>\n     sinvar_impl G (SecurityInvariant.node_props default_node_properties P))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> wf_list_graph G \\<Longrightarrow>\n    (distinct (nodesL G) \\<and>\n     distinct (edgesL G) \\<and>\n     SecurityInvariant.eval sinvar_spec default_node_properties\n      (list_graph_to_graph G) P) =\n    (wf_list_graph G \\<and>\n     sinvar_impl G (SecurityInvariant.node_props default_node_properties P))", "case False"], ["proof (state)\nthis:\n  \\<not> wf_list_graph G\n\ngoal (1 subgoal):\n 1. \\<not> wf_list_graph G \\<Longrightarrow>\n    (distinct (nodesL G) \\<and>\n     distinct (edgesL G) \\<and>\n     SecurityInvariant.eval sinvar_spec default_node_properties\n      (list_graph_to_graph G) P) =\n    (wf_list_graph G \\<and>\n     sinvar_impl G (SecurityInvariant.node_props default_node_properties P))", "hence \"(distinct (nodesL G) \\<and> distinct (edgesL G) \\<and> wf_list_graph_axioms G) = False\""], ["proof (prove)\nusing this:\n  \\<not> wf_list_graph G\n\ngoal (1 subgoal):\n 1. (distinct (nodesL G) \\<and>\n     distinct (edgesL G) \\<and> wf_list_graph_axioms G) =\n    False", "unfolding wf_list_graph_def"], ["proof (prove)\nusing this:\n  \\<not> (distinct (nodesL G) \\<and>\n          distinct (edgesL G) \\<and> wf_list_graph_axioms G)\n\ngoal (1 subgoal):\n 1. (distinct (nodesL G) \\<and>\n     distinct (edgesL G) \\<and> wf_list_graph_axioms G) =\n    False", "by blast"], ["proof (state)\nthis:\n  (distinct (nodesL G) \\<and>\n   distinct (edgesL G) \\<and> wf_list_graph_axioms G) =\n  False\n\ngoal (1 subgoal):\n 1. \\<not> wf_list_graph G \\<Longrightarrow>\n    (distinct (nodesL G) \\<and>\n     distinct (edgesL G) \\<and>\n     SecurityInvariant.eval sinvar_spec default_node_properties\n      (list_graph_to_graph G) P) =\n    (wf_list_graph G \\<and>\n     sinvar_impl G (SecurityInvariant.node_props default_node_properties P))", "with False"], ["proof (chain)\npicking this:\n  \\<not> wf_list_graph G\n  (distinct (nodesL G) \\<and>\n   distinct (edgesL G) \\<and> wf_list_graph_axioms G) =\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> wf_list_graph G\n  (distinct (nodesL G) \\<and>\n   distinct (edgesL G) \\<and> wf_list_graph_axioms G) =\n  False\n\ngoal (1 subgoal):\n 1. (distinct (nodesL G) \\<and>\n     distinct (edgesL G) \\<and>\n     SecurityInvariant.eval sinvar_spec default_node_properties\n      (list_graph_to_graph G) P) =\n    (wf_list_graph G \\<and>\n     sinvar_impl G (SecurityInvariant.node_props default_node_properties P))", "unfolding SecurityInvariant.eval_def[OF inst]"], ["proof (prove)\nusing this:\n  \\<not> wf_list_graph G\n  (distinct (nodesL G) \\<and>\n   distinct (edgesL G) \\<and> wf_list_graph_axioms G) =\n  False\n\ngoal (1 subgoal):\n 1. (distinct (nodesL G) \\<and>\n     distinct (edgesL G) \\<and>\n     wf_graph (list_graph_to_graph G) \\<and>\n     sinvar_spec (list_graph_to_graph G)\n      (SecurityInvariant.node_props default_node_properties P)) =\n    (wf_list_graph G \\<and>\n     sinvar_impl G (SecurityInvariant.node_props default_node_properties P))", "by (fastforce simp: wf_list_graph_iff_wf_graph)"], ["proof (state)\nthis:\n  (distinct (nodesL G) \\<and>\n   distinct (edgesL G) \\<and>\n   SecurityInvariant.eval sinvar_spec default_node_properties\n    (list_graph_to_graph G) P) =\n  (wf_list_graph G \\<and>\n   sinvar_impl G (SecurityInvariant.node_props default_node_properties P))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Helper lemmata\\<close>"], ["", "text\\<open>Provide @{term sinvar} function and get back a function that computes the list of offending flows\n  \n  Exponential time!\n\\<close>"], ["", "definition Generic_offending_list:: \"('v list_graph \\<Rightarrow> ('v \\<Rightarrow> 'a) \\<Rightarrow> bool )\\<Rightarrow> 'v list_graph \\<Rightarrow> ('v \\<Rightarrow> 'a) \\<Rightarrow> ('v \\<times> 'v) list list\" where\n    \"Generic_offending_list sinvar G nP = [f \\<leftarrow> (subseqs (edgesL G)). \n    (\\<not> sinvar G nP \\<and> sinvar (FiniteListGraph.delete_edges G f) nP) \\<and> \n      (\\<forall>(e1, e2)\\<in>set f. \\<not> sinvar (add_edge e1 e2 (FiniteListGraph.delete_edges G f)) nP)]\""], ["", "text\\<open>proof rule: if @{term sinvar} complies, @{const Generic_offending_list} complies\\<close>"], ["", "lemma Generic_offending_list_correct: \n    assumes valid: \"wf_list_graph G\"\n    assumes spec_impl: \"\\<And>G nP. wf_list_graph G \\<Longrightarrow> sinvar_spec (list_graph_to_graph G) nP = sinvar_impl G nP\"\n    shows \"SecurityInvariant_withOffendingFlows.set_offending_flows sinvar_spec (list_graph_to_graph G) nP = \n      set`set( Generic_offending_list sinvar_impl G nP )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.set_offending_flows sinvar_spec\n     (list_graph_to_graph G) nP =\n    set ` set (Generic_offending_list sinvar_impl G nP)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.set_offending_flows sinvar_spec\n     (list_graph_to_graph G) nP =\n    set ` set (Generic_offending_list sinvar_impl G nP)", "have \"\\<And> P G. set ` {x \\<in> set (subseqs (edgesL G)). P G (set x)} = {x \\<in> set ` set (subseqs (edgesL G)). P G (x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P G.\n       set ` {x \\<in> set (subseqs (edgesL G)). P G (set x)} =\n       {x \\<in> set ` set (subseqs (edgesL G)). P G x}", "by fastforce"], ["proof (state)\nthis:\n  set ` {x \\<in> set (subseqs (edgesL ?G)). ?P ?G (set x)} =\n  {x \\<in> set ` set (subseqs (edgesL ?G)). ?P ?G x}\n\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.set_offending_flows sinvar_spec\n     (list_graph_to_graph G) nP =\n    set ` set (Generic_offending_list sinvar_impl G nP)", "hence subset_subseqs_filter: \"\\<And> G P. {f. f \\<subseteq> edges (list_graph_to_graph G) \\<and> P G f} \n    = set ` set [f\\<leftarrow>subseqs (edgesL G) . P G (set f)]\""], ["proof (prove)\nusing this:\n  set ` {x \\<in> set (subseqs (edgesL ?G)). ?P ?G (set x)} =\n  {x \\<in> set ` set (subseqs (edgesL ?G)). ?P ?G x}\n\ngoal (1 subgoal):\n 1. \\<And>G P.\n       {f. f \\<subseteq> edges (list_graph_to_graph G) \\<and> P G f} =\n       set ` set (filter (\\<lambda>f. P G (set f)) (subseqs (edgesL G)))", "unfolding list_graph_to_graph_def"], ["proof (prove)\nusing this:\n  set ` {x \\<in> set (subseqs (edgesL ?G)). ?P ?G (set x)} =\n  {x \\<in> set ` set (subseqs (edgesL ?G)). ?P ?G x}\n\ngoal (1 subgoal):\n 1. \\<And>G P.\n       {f. f \\<subseteq> edges\n                          \\<lparr>nodes = set (nodesL G),\n                             edges = set (edgesL G)\\<rparr> \\<and>\n           P G f} =\n       set ` set (filter (\\<lambda>f. P G (set f)) (subseqs (edgesL G)))", "by (auto simp: subseqs_powset)"], ["proof (state)\nthis:\n  {f. f \\<subseteq> edges (list_graph_to_graph ?G1) \\<and> ?P1 ?G1 f} =\n  set ` set (filter (\\<lambda>f. ?P1 ?G1 (set f)) (subseqs (edgesL ?G1)))\n\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.set_offending_flows sinvar_spec\n     (list_graph_to_graph G) nP =\n    set ` set (Generic_offending_list sinvar_impl G nP)", "from valid delete_edges_wf"], ["proof (chain)\npicking this:\n  wf_list_graph G\n  wf_list_graph ?G \\<Longrightarrow>\n  wf_list_graph (FiniteListGraph.delete_edges ?G ?E)", "have \"\\<forall>f. wf_list_graph(FiniteListGraph.delete_edges G f)\""], ["proof (prove)\nusing this:\n  wf_list_graph G\n  wf_list_graph ?G \\<Longrightarrow>\n  wf_list_graph (FiniteListGraph.delete_edges ?G ?E)\n\ngoal (1 subgoal):\n 1. \\<forall>f. wf_list_graph (FiniteListGraph.delete_edges G f)", "by fast"], ["proof (state)\nthis:\n  \\<forall>f. wf_list_graph (FiniteListGraph.delete_edges G f)\n\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.set_offending_flows sinvar_spec\n     (list_graph_to_graph G) nP =\n    set ` set (Generic_offending_list sinvar_impl G nP)", "with spec_impl[symmetric] FiniteListGraph.delete_edges_correct[of \"G\"]"], ["proof (chain)\npicking this:\n  wf_list_graph ?G \\<Longrightarrow>\n  sinvar_impl ?G ?nP = sinvar_spec (list_graph_to_graph ?G) ?nP\n  FiniteGraph.delete_edges (list_graph_to_graph G) (set ?E) =\n  list_graph_to_graph (FiniteListGraph.delete_edges G ?E)\n  \\<forall>f. wf_list_graph (FiniteListGraph.delete_edges G f)", "have impl_spec_delete:\n      \"\\<forall>f. sinvar_impl (FiniteListGraph.delete_edges G f) nP = \n          sinvar_spec (FiniteGraph.delete_edges (list_graph_to_graph G) (set f)) nP\""], ["proof (prove)\nusing this:\n  wf_list_graph ?G \\<Longrightarrow>\n  sinvar_impl ?G ?nP = sinvar_spec (list_graph_to_graph ?G) ?nP\n  FiniteGraph.delete_edges (list_graph_to_graph G) (set ?E) =\n  list_graph_to_graph (FiniteListGraph.delete_edges G ?E)\n  \\<forall>f. wf_list_graph (FiniteListGraph.delete_edges G f)\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       sinvar_impl (FiniteListGraph.delete_edges G f) nP =\n       sinvar_spec\n        (FiniteGraph.delete_edges (list_graph_to_graph G) (set f)) nP", "by simp"], ["proof (state)\nthis:\n  \\<forall>f.\n     sinvar_impl (FiniteListGraph.delete_edges G f) nP =\n     sinvar_spec (FiniteGraph.delete_edges (list_graph_to_graph G) (set f))\n      nP\n\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.set_offending_flows sinvar_spec\n     (list_graph_to_graph G) nP =\n    set ` set (Generic_offending_list sinvar_impl G nP)", "from spec_impl[OF valid, symmetric]"], ["proof (chain)\npicking this:\n  sinvar_impl G ?nP = sinvar_spec (list_graph_to_graph G) ?nP", "have impl_spec_not:\n      \"(\\<not> sinvar_impl G nP) = (\\<not> sinvar_spec (list_graph_to_graph G) nP)\""], ["proof (prove)\nusing this:\n  sinvar_impl G ?nP = sinvar_spec (list_graph_to_graph G) ?nP\n\ngoal (1 subgoal):\n 1. (\\<not> sinvar_impl G nP) =\n    (\\<not> sinvar_spec (list_graph_to_graph G) nP)", "by auto"], ["proof (state)\nthis:\n  (\\<not> sinvar_impl G nP) =\n  (\\<not> sinvar_spec (list_graph_to_graph G) nP)\n\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.set_offending_flows sinvar_spec\n     (list_graph_to_graph G) nP =\n    set ` set (Generic_offending_list sinvar_impl G nP)", "from spec_impl[symmetric, OF FiniteListGraph.add_edge_wf[OF FiniteListGraph.delete_edges_wf[OF valid]]]"], ["proof (chain)\npicking this:\n  sinvar_impl\n   (FiniteListGraph.add_edge ?v1 ?v'1 (FiniteListGraph.delete_edges G ?E2))\n   ?nP =\n  sinvar_spec\n   (list_graph_to_graph\n     (FiniteListGraph.add_edge ?v1 ?v'1\n       (FiniteListGraph.delete_edges G ?E2)))\n   ?nP", "have impl_spec_allE:\n    \"\\<forall> e1 e2 E. sinvar_impl (FiniteListGraph.add_edge e1 e2 (FiniteListGraph.delete_edges G E)) nP =\n    sinvar_spec (list_graph_to_graph (FiniteListGraph.add_edge e1 e2 (FiniteListGraph.delete_edges G E))) nP\""], ["proof (prove)\nusing this:\n  sinvar_impl\n   (FiniteListGraph.add_edge ?v1 ?v'1 (FiniteListGraph.delete_edges G ?E2))\n   ?nP =\n  sinvar_spec\n   (list_graph_to_graph\n     (FiniteListGraph.add_edge ?v1 ?v'1\n       (FiniteListGraph.delete_edges G ?E2)))\n   ?nP\n\ngoal (1 subgoal):\n 1. \\<forall>e1 e2 E.\n       sinvar_impl\n        (FiniteListGraph.add_edge e1 e2 (FiniteListGraph.delete_edges G E))\n        nP =\n       sinvar_spec\n        (list_graph_to_graph\n          (FiniteListGraph.add_edge e1 e2\n            (FiniteListGraph.delete_edges G E)))\n        nP", "by simp"], ["proof (state)\nthis:\n  \\<forall>e1 e2 E.\n     sinvar_impl\n      (FiniteListGraph.add_edge e1 e2 (FiniteListGraph.delete_edges G E))\n      nP =\n     sinvar_spec\n      (list_graph_to_graph\n        (FiniteListGraph.add_edge e1 e2 (FiniteListGraph.delete_edges G E)))\n      nP\n\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.set_offending_flows sinvar_spec\n     (list_graph_to_graph G) nP =\n    set ` set (Generic_offending_list sinvar_impl G nP)", "have list_graph: \"\\<And> e1 e2 G f. (list_graph_to_graph (FiniteListGraph.add_edge e1 e2 (FiniteListGraph.delete_edges G f))) = \n      (FiniteGraph.add_edge e1 e2 (FiniteGraph.delete_edges (list_graph_to_graph G) (set f)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e1 e2 G f.\n       list_graph_to_graph\n        (FiniteListGraph.add_edge e1 e2\n          (FiniteListGraph.delete_edges G f)) =\n       FiniteGraph.add_edge e1 e2\n        (FiniteGraph.delete_edges (list_graph_to_graph G) (set f))", "by(simp add: FiniteListGraph.add_edge_correct FiniteListGraph.delete_edges_correct)"], ["proof (state)\nthis:\n  list_graph_to_graph\n   (FiniteListGraph.add_edge ?e1.2 ?e2.2\n     (FiniteListGraph.delete_edges ?G2 ?f2)) =\n  FiniteGraph.add_edge ?e1.2 ?e2.2\n   (FiniteGraph.delete_edges (list_graph_to_graph ?G2) (set ?f2))\n\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.set_offending_flows sinvar_spec\n     (list_graph_to_graph G) nP =\n    set ` set (Generic_offending_list sinvar_impl G nP)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.set_offending_flows sinvar_spec\n     (list_graph_to_graph G) nP =\n    set ` set (Generic_offending_list sinvar_impl G nP)", "unfolding SecurityInvariant_withOffendingFlows.set_offending_flows_def \n      SecurityInvariant_withOffendingFlows.is_offending_flows_min_set_def \n      SecurityInvariant_withOffendingFlows.is_offending_flows_def\n      Generic_offending_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {F. F \\<subseteq> edges (list_graph_to_graph G) \\<and>\n        (\\<not> sinvar_spec (list_graph_to_graph G) nP \\<and>\n         sinvar_spec (FiniteGraph.delete_edges (list_graph_to_graph G) F)\n          nP) \\<and>\n        (\\<forall>(e1, e2)\\<in>F.\n            \\<not> sinvar_spec\n                    (FiniteGraph.add_edge e1 e2\n                      (FiniteGraph.delete_edges (list_graph_to_graph G) F))\n                    nP)} =\n    set `\n    set (filter\n          (\\<lambda>f.\n              (\\<not> sinvar_impl G nP \\<and>\n               sinvar_impl (FiniteListGraph.delete_edges G f) nP) \\<and>\n              (\\<forall>(e1, e2)\\<in>set f.\n                  \\<not> sinvar_impl\n                          (FiniteListGraph.add_edge e1 e2\n                            (FiniteListGraph.delete_edges G f))\n                          nP))\n          (subseqs (edgesL G)))", "apply(subst impl_spec_delete)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {F. F \\<subseteq> edges (list_graph_to_graph G) \\<and>\n        (\\<not> sinvar_spec (list_graph_to_graph G) nP \\<and>\n         sinvar_spec (FiniteGraph.delete_edges (list_graph_to_graph G) F)\n          nP) \\<and>\n        (\\<forall>(e1, e2)\\<in>F.\n            \\<not> sinvar_spec\n                    (FiniteGraph.add_edge e1 e2\n                      (FiniteGraph.delete_edges (list_graph_to_graph G) F))\n                    nP)} =\n    set `\n    set (filter\n          (\\<lambda>f.\n              (\\<not> sinvar_impl G nP \\<and>\n               sinvar_spec\n                (FiniteGraph.delete_edges (list_graph_to_graph G) (set f))\n                nP) \\<and>\n              (\\<forall>(e1, e2)\\<in>set f.\n                  \\<not> sinvar_impl\n                          (FiniteListGraph.add_edge e1 e2\n                            (FiniteListGraph.delete_edges G f))\n                          nP))\n          (subseqs (edgesL G)))", "apply(subst impl_spec_not)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {F. F \\<subseteq> edges (list_graph_to_graph G) \\<and>\n        (\\<not> sinvar_spec (list_graph_to_graph G) nP \\<and>\n         sinvar_spec (FiniteGraph.delete_edges (list_graph_to_graph G) F)\n          nP) \\<and>\n        (\\<forall>(e1, e2)\\<in>F.\n            \\<not> sinvar_spec\n                    (FiniteGraph.add_edge e1 e2\n                      (FiniteGraph.delete_edges (list_graph_to_graph G) F))\n                    nP)} =\n    set `\n    set (filter\n          (\\<lambda>f.\n              (\\<not> sinvar_spec (list_graph_to_graph G) nP \\<and>\n               sinvar_spec\n                (FiniteGraph.delete_edges (list_graph_to_graph G) (set f))\n                nP) \\<and>\n              (\\<forall>(e1, e2)\\<in>set f.\n                  \\<not> sinvar_impl\n                          (FiniteListGraph.add_edge e1 e2\n                            (FiniteListGraph.delete_edges G f))\n                          nP))\n          (subseqs (edgesL G)))", "apply(subst impl_spec_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {F. F \\<subseteq> edges (list_graph_to_graph G) \\<and>\n        (\\<not> sinvar_spec (list_graph_to_graph G) nP \\<and>\n         sinvar_spec (FiniteGraph.delete_edges (list_graph_to_graph G) F)\n          nP) \\<and>\n        (\\<forall>(e1, e2)\\<in>F.\n            \\<not> sinvar_spec\n                    (FiniteGraph.add_edge e1 e2\n                      (FiniteGraph.delete_edges (list_graph_to_graph G) F))\n                    nP)} =\n    set `\n    set (filter\n          (\\<lambda>f.\n              (\\<not> sinvar_spec (list_graph_to_graph G) nP \\<and>\n               sinvar_spec\n                (FiniteGraph.delete_edges (list_graph_to_graph G) (set f))\n                nP) \\<and>\n              (\\<forall>(e1, e2)\\<in>set f.\n                  \\<not> sinvar_spec\n                          (list_graph_to_graph\n                            (FiniteListGraph.add_edge e1 e2\n                              (FiniteListGraph.delete_edges G f)))\n                          nP))\n          (subseqs (edgesL G)))", "apply(subst list_graph)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {F. F \\<subseteq> edges (list_graph_to_graph G) \\<and>\n        (\\<not> sinvar_spec (list_graph_to_graph G) nP \\<and>\n         sinvar_spec (FiniteGraph.delete_edges (list_graph_to_graph G) F)\n          nP) \\<and>\n        (\\<forall>(e1, e2)\\<in>F.\n            \\<not> sinvar_spec\n                    (FiniteGraph.add_edge e1 e2\n                      (FiniteGraph.delete_edges (list_graph_to_graph G) F))\n                    nP)} =\n    set `\n    set (filter\n          (\\<lambda>f.\n              (\\<not> sinvar_spec (list_graph_to_graph G) nP \\<and>\n               sinvar_spec\n                (FiniteGraph.delete_edges (list_graph_to_graph G) (set f))\n                nP) \\<and>\n              (\\<forall>(e1, e2)\\<in>set f.\n                  \\<not> sinvar_spec\n                          (FiniteGraph.add_edge e1 e2\n                            (FiniteGraph.delete_edges\n                              (list_graph_to_graph G) (set f)))\n                          nP))\n          (subseqs (edgesL G)))", "apply(rule subset_subseqs_filter)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  SecurityInvariant_withOffendingFlows.set_offending_flows sinvar_spec\n   (list_graph_to_graph G) nP =\n  set ` set (Generic_offending_list sinvar_impl G nP)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma all_edges_list_I: \"P (list_graph_to_graph G) = Pl G \\<Longrightarrow> \n    (\\<forall>(e1, e2)\\<in> (edges (list_graph_to_graph G)). P (list_graph_to_graph G) e1 e2) = (\\<forall>(e1, e2)\\<in>set (edgesL G). Pl G e1 e2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (list_graph_to_graph G) = Pl G \\<Longrightarrow>\n    (\\<forall>(e1, e2)\\<in>edges (list_graph_to_graph G).\n        P (list_graph_to_graph G) e1 e2) =\n    (\\<forall>(e1, e2)\\<in>set (edgesL G). Pl G e1 e2)", "unfolding list_graph_to_graph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<lparr>nodes = set (nodesL G), edges = set (edgesL G)\\<rparr> =\n    Pl G \\<Longrightarrow>\n    (\\<forall>(e1, e2)\n              \\<in>edges\n                    \\<lparr>nodes = set (nodesL G),\n                       edges = set (edgesL G)\\<rparr>.\n        P \\<lparr>nodes = set (nodesL G), edges = set (edgesL G)\\<rparr> e1\n         e2) =\n    (\\<forall>(e1, e2)\\<in>set (edgesL G). Pl G e1 e2)", "by simp"], ["", "lemma all_nodes_list_I: \"P (list_graph_to_graph G) = Pl G \\<Longrightarrow> \n    (\\<forall>n \\<in> (nodes (list_graph_to_graph G)). P (list_graph_to_graph G) n) = (\\<forall> n \\<in>set (nodesL G). Pl G n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (list_graph_to_graph G) = Pl G \\<Longrightarrow>\n    (\\<forall>n\\<in>nodes (list_graph_to_graph G).\n        P (list_graph_to_graph G) n) =\n    (\\<forall>n\\<in>set (nodesL G). Pl G n)", "unfolding list_graph_to_graph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<lparr>nodes = set (nodesL G), edges = set (edgesL G)\\<rparr> =\n    Pl G \\<Longrightarrow>\n    (\\<forall>n\\<in>nodes\n                     \\<lparr>nodes = set (nodesL G),\n                        edges = set (edgesL G)\\<rparr>.\n        P \\<lparr>nodes = set (nodesL G), edges = set (edgesL G)\\<rparr>\n         n) =\n    (\\<forall>n\\<in>set (nodesL G). Pl G n)", "by simp"], ["", "fun minimalize_offending_overapprox :: \"('v list_graph \\<Rightarrow> bool) \\<Rightarrow> \n    ('v \\<times> 'v) list \\<Rightarrow> ('v \\<times> 'v) list \\<Rightarrow> 'v list_graph \\<Rightarrow> ('v \\<times> 'v) list\" where\n  \"minimalize_offending_overapprox _ [] keep _ = keep\" |\n  \"minimalize_offending_overapprox m (f#fs) keep G = (if m (delete_edges G (fs@keep)) then\n      minimalize_offending_overapprox m fs keep G\n    else\n      minimalize_offending_overapprox m fs (f#keep) G\n    )\""], ["", "thm minimalize_offending_overapprox_boundnP"], ["", "(*is usage of this one better?*)"], ["", "lemma minimalize_offending_overapprox_spec_impl:\n    assumes valid: \"wf_list_graph (G::'v::vertex list_graph)\"\n        and spec_impl: \"\\<And>G nP::('v \\<Rightarrow> 'a). wf_list_graph G \\<Longrightarrow> sinvar_spec (list_graph_to_graph G) nP = sinvar_impl G nP\"\n    shows \"minimalize_offending_overapprox (\\<lambda>G. sinvar_impl G nP) fs keeps G =\n       TopoS_withOffendingFlows.minimalize_offending_overapprox (\\<lambda>G. sinvar_spec G nP) fs keeps (list_graph_to_graph G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TopoS_Interface_impl.minimalize_offending_overapprox\n     (\\<lambda>G. sinvar_impl G nP) fs keeps G =\n    TopoS_withOffendingFlows.minimalize_offending_overapprox\n     (\\<lambda>G. sinvar_spec G nP) fs keeps (list_graph_to_graph G)", "apply(subst minimalize_offending_overapprox_boundnP)"], ["proof (prove)\ngoal (1 subgoal):\n 1. TopoS_Interface_impl.minimalize_offending_overapprox\n     (\\<lambda>G. sinvar_impl G nP) fs keeps G =\n    SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox\n     sinvar_spec fs keeps (list_graph_to_graph G) nP", "using valid spec_impl"], ["proof (prove)\nusing this:\n  wf_list_graph G\n  wf_list_graph ?G \\<Longrightarrow>\n  sinvar_spec (list_graph_to_graph ?G) ?nP = sinvar_impl ?G ?nP\n\ngoal (1 subgoal):\n 1. TopoS_Interface_impl.minimalize_offending_overapprox\n     (\\<lambda>G. sinvar_impl G nP) fs keeps G =\n    SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox\n     sinvar_spec fs keeps (list_graph_to_graph G) nP", "apply(induction fs arbitrary: keeps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>keeps.\n       \\<lbrakk>wf_list_graph G;\n        \\<And>G nP.\n           wf_list_graph G \\<Longrightarrow>\n           sinvar_spec (list_graph_to_graph G) nP =\n           sinvar_impl G nP\\<rbrakk>\n       \\<Longrightarrow> TopoS_Interface_impl.minimalize_offending_overapprox\n                          (\\<lambda>G. sinvar_impl G nP) [] keeps G =\n                         SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox\n                          sinvar_spec [] keeps (list_graph_to_graph G) nP\n 2. \\<And>a fs keeps.\n       \\<lbrakk>\\<And>keeps.\n                   \\<lbrakk>wf_list_graph G;\n                    \\<And>G nP.\n                       wf_list_graph G \\<Longrightarrow>\n                       sinvar_spec (list_graph_to_graph G) nP =\n                       sinvar_impl G nP\\<rbrakk>\n                   \\<Longrightarrow> TopoS_Interface_impl.minimalize_offending_overapprox\n(\\<lambda>G. sinvar_impl G nP) fs keeps G =\n                                     SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox\nsinvar_spec fs keeps (list_graph_to_graph G) nP;\n        wf_list_graph G;\n        \\<And>G nP.\n           wf_list_graph G \\<Longrightarrow>\n           sinvar_spec (list_graph_to_graph G) nP =\n           sinvar_impl G nP\\<rbrakk>\n       \\<Longrightarrow> TopoS_Interface_impl.minimalize_offending_overapprox\n                          (\\<lambda>G. sinvar_impl G nP) (a # fs) keeps G =\n                         SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox\n                          sinvar_spec (a # fs) keeps (list_graph_to_graph G)\n                          nP", "apply(simp add: SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox.simps; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a fs keeps.\n       \\<lbrakk>\\<And>keeps.\n                   \\<lbrakk>wf_list_graph G;\n                    \\<And>G nP.\n                       wf_list_graph G \\<Longrightarrow>\n                       sinvar_spec (list_graph_to_graph G) nP =\n                       sinvar_impl G nP\\<rbrakk>\n                   \\<Longrightarrow> TopoS_Interface_impl.minimalize_offending_overapprox\n(\\<lambda>G. sinvar_impl G nP) fs keeps G =\n                                     SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox\nsinvar_spec fs keeps (list_graph_to_graph G) nP;\n        wf_list_graph G;\n        \\<And>G nP.\n           wf_list_graph G \\<Longrightarrow>\n           sinvar_spec (list_graph_to_graph G) nP =\n           sinvar_impl G nP\\<rbrakk>\n       \\<Longrightarrow> TopoS_Interface_impl.minimalize_offending_overapprox\n                          (\\<lambda>G. sinvar_impl G nP) (a # fs) keeps G =\n                         SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox\n                          sinvar_spec (a # fs) keeps (list_graph_to_graph G)\n                          nP", "apply(simp add: SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a fs keeps.\n       \\<lbrakk>\\<And>keeps.\n                   TopoS_Interface_impl.minimalize_offending_overapprox\n                    (\\<lambda>G. sinvar_impl G nP) fs keeps G =\n                   SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox\n                    sinvar_spec fs keeps (list_graph_to_graph G) nP;\n        wf_list_graph G;\n        \\<And>G nP.\n           wf_list_graph G \\<Longrightarrow>\n           sinvar_spec (list_graph_to_graph G) nP =\n           sinvar_impl G nP\\<rbrakk>\n       \\<Longrightarrow> (sinvar_impl\n                           (FiniteListGraph.delete_edges G (fs @ keeps))\n                           nP \\<longrightarrow>\n                          \\<not> sinvar_spec\n                                  (delete_edges_list (list_graph_to_graph G)\n                                    (fs @ keeps))\n                                  nP \\<longrightarrow>\n                          SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox\n                           sinvar_spec fs keeps (list_graph_to_graph G) nP =\n                          SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox\n                           sinvar_spec fs (a # keeps)\n                           (list_graph_to_graph G) nP) \\<and>\n                         (\\<not> sinvar_impl\n                                  (FiniteListGraph.delete_edges G\n                                    (fs @ keeps))\n                                  nP \\<longrightarrow>\n                          sinvar_spec\n                           (delete_edges_list (list_graph_to_graph G)\n                             (fs @ keeps))\n                           nP \\<longrightarrow>\n                          SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox\n                           sinvar_spec fs (a # keeps)\n                           (list_graph_to_graph G) nP =\n                          SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox\n                           sinvar_spec fs keeps (list_graph_to_graph G) nP)", "apply (metis FiniteListGraph.delete_edges_wf delete_edges_list_set list_graph_correct(5))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>With @{const minimalize_offending_overapprox}, we can get one offending flow\\<close>"], ["", "lemma minimalize_offending_overapprox_gives_some_offending_flow:\n    assumes wf: \"wf_list_graph G\"\n        and NetModelLib: \"TopoS_modelLibrary m sinvar_spec\"\n        and violation: \"\\<not> (nm_sinvar m) G nP\"\n    shows \"set (minimalize_offending_overapprox (\\<lambda>G. (nm_sinvar m) G nP) (edgesL G) [] G) \\<in>\n            SecurityInvariant_withOffendingFlows.set_offending_flows sinvar_spec (list_graph_to_graph G) nP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (TopoS_Interface_impl.minimalize_offending_overapprox\n          (\\<lambda>G. nm_sinvar m G nP) (edgesL G) [] G)\n    \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows\n           sinvar_spec (list_graph_to_graph G) nP", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (TopoS_Interface_impl.minimalize_offending_overapprox\n          (\\<lambda>G. nm_sinvar m G nP) (edgesL G) [] G)\n    \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows\n           sinvar_spec (list_graph_to_graph G) nP", "from wf"], ["proof (chain)\npicking this:\n  wf_list_graph G", "have wfG: \"wf_graph (list_graph_to_graph G)\""], ["proof (prove)\nusing this:\n  wf_list_graph G\n\ngoal (1 subgoal):\n 1. wf_graph (list_graph_to_graph G)", "by (simp add: wf_list_graph_def wf_list_graph_iff_wf_graph)"], ["proof (state)\nthis:\n  wf_graph (list_graph_to_graph G)\n\ngoal (1 subgoal):\n 1. set (TopoS_Interface_impl.minimalize_offending_overapprox\n          (\\<lambda>G. nm_sinvar m G nP) (edgesL G) [] G)\n    \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows\n           sinvar_spec (list_graph_to_graph G) nP", "from wf"], ["proof (chain)\npicking this:\n  wf_list_graph G", "have dist_edges: \"distinct (edgesL G)\""], ["proof (prove)\nusing this:\n  wf_list_graph G\n\ngoal (1 subgoal):\n 1. distinct (edgesL G)", "by (simp add: wf_list_graph_def)"], ["proof (state)\nthis:\n  distinct (edgesL G)\n\ngoal (1 subgoal):\n 1. set (TopoS_Interface_impl.minimalize_offending_overapprox\n          (\\<lambda>G. nm_sinvar m G nP) (edgesL G) [] G)\n    \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows\n           sinvar_spec (list_graph_to_graph G) nP", "let ?spec_algo=\"TopoS_withOffendingFlows.minimalize_offending_overapprox\n                          (\\<lambda>G. sinvar_spec G nP) (edgesL G) [] (list_graph_to_graph G)\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (TopoS_Interface_impl.minimalize_offending_overapprox\n          (\\<lambda>G. nm_sinvar m G nP) (edgesL G) [] G)\n    \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows\n           sinvar_spec (list_graph_to_graph G) nP", "note spec=TopoS_List_Impl.spec[OF TopoS_modelLibrary.impl_spec[OF NetModelLib]]"], ["proof (state)\nthis:\n  SecurityInvariant sinvar_spec (nm_default m) (nm_receiver_violation m)\n\ngoal (1 subgoal):\n 1. set (TopoS_Interface_impl.minimalize_offending_overapprox\n          (\\<lambda>G. nm_sinvar m G nP) (edgesL G) [] G)\n    \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows\n           sinvar_spec (list_graph_to_graph G) nP", "from spec"], ["proof (chain)\npicking this:\n  SecurityInvariant sinvar_spec (nm_default m) (nm_receiver_violation m)", "have spec_prelim: \"SecurityInvariant_preliminaries sinvar_spec\""], ["proof (prove)\nusing this:\n  SecurityInvariant sinvar_spec (nm_default m) (nm_receiver_violation m)\n\ngoal (1 subgoal):\n 1. SecurityInvariant_preliminaries sinvar_spec", "by(simp add: SecurityInvariant_def)"], ["proof (state)\nthis:\n  SecurityInvariant_preliminaries sinvar_spec\n\ngoal (1 subgoal):\n 1. set (TopoS_Interface_impl.minimalize_offending_overapprox\n          (\\<lambda>G. nm_sinvar m G nP) (edgesL G) [] G)\n    \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows\n           sinvar_spec (list_graph_to_graph G) nP", "from spec_prelim SecurityInvariant_preliminaries.sinvar_monoI"], ["proof (chain)\npicking this:\n  SecurityInvariant_preliminaries sinvar_spec\n  SecurityInvariant_preliminaries ?sinvar \\<Longrightarrow>\n  SecurityInvariant_withOffendingFlows.sinvar_mono ?sinvar", "have mono:\n        \"SecurityInvariant_withOffendingFlows.sinvar_mono sinvar_spec\""], ["proof (prove)\nusing this:\n  SecurityInvariant_preliminaries sinvar_spec\n  SecurityInvariant_preliminaries ?sinvar \\<Longrightarrow>\n  SecurityInvariant_withOffendingFlows.sinvar_mono ?sinvar\n\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.sinvar_mono sinvar_spec", "by blast"], ["proof (state)\nthis:\n  SecurityInvariant_withOffendingFlows.sinvar_mono sinvar_spec\n\ngoal (1 subgoal):\n 1. set (TopoS_Interface_impl.minimalize_offending_overapprox\n          (\\<lambda>G. nm_sinvar m G nP) (edgesL G) [] G)\n    \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows\n           sinvar_spec (list_graph_to_graph G) nP", "from spec_prelim"], ["proof (chain)\npicking this:\n  SecurityInvariant_preliminaries sinvar_spec", "have empty_edges: \"sinvar_spec \\<lparr>nodes = set (nodesL G), edges = {}\\<rparr> nP\""], ["proof (prove)\nusing this:\n  SecurityInvariant_preliminaries sinvar_spec\n\ngoal (1 subgoal):\n 1. sinvar_spec \\<lparr>nodes = set (nodesL G), edges = {}\\<rparr> nP", "using SecurityInvariant_preliminaries.defined_offending \n        SecurityInvariant_withOffendingFlows.sinvar_mono_imp_sinvar_mono \n        SecurityInvariant_withOffendingFlows.valid_empty_edges_iff_exists_offending_flows  \n        mono empty_subsetI graph.simps(1) \n        list_graph_to_graph_def local.wf wf_list_graph_def wf_list_graph_iff_wf_graph"], ["proof (prove)\nusing this:\n  SecurityInvariant_preliminaries sinvar_spec\n  \\<lbrakk>SecurityInvariant_preliminaries ?sinvar; wf_graph ?G;\n   \\<not> ?sinvar ?G ?nP\\<rbrakk>\n  \\<Longrightarrow> SecurityInvariant_withOffendingFlows.set_offending_flows\n                     ?sinvar ?G ?nP \\<noteq>\n                    {}\n  \\<lbrakk>SecurityInvariant_withOffendingFlows.sinvar_mono ?sinvar;\n   wf_graph \\<lparr>nodes = ?N, edges = ?E\\<rparr>; ?E' \\<subseteq> ?E;\n   ?sinvar \\<lparr>nodes = ?N, edges = ?E\\<rparr> ?nP\\<rbrakk>\n  \\<Longrightarrow> ?sinvar \\<lparr>nodes = ?N, edges = ?E'\\<rparr> ?nP\n  \\<lbrakk>SecurityInvariant_withOffendingFlows.sinvar_mono ?sinvar;\n   wf_graph ?G; \\<not> ?sinvar ?G ?nP\\<rbrakk>\n  \\<Longrightarrow> ?sinvar \\<lparr>nodes = nodes ?G, edges = {}\\<rparr>\n                     ?nP =\n                    (SecurityInvariant_withOffendingFlows.set_offending_flows\n                      ?sinvar ?G ?nP \\<noteq>\n                     {})\n  SecurityInvariant_withOffendingFlows.sinvar_mono sinvar_spec\n  {} \\<subseteq> ?A\n  nodes \\<lparr>nodes = ?nodes, edges = ?edges, \\<dots> = ?more\\<rparr> =\n  ?nodes\n  list_graph_to_graph ?G =\n  \\<lparr>nodes = set (nodesL ?G), edges = set (edgesL ?G)\\<rparr>\n  wf_list_graph G\n  wf_list_graph ?G =\n  (distinct (nodesL ?G) \\<and>\n   distinct (edgesL ?G) \\<and> wf_list_graph_axioms ?G)\n  wf_graph (list_graph_to_graph ?G) = wf_list_graph_axioms ?G\n\ngoal (1 subgoal):\n 1. sinvar_spec \\<lparr>nodes = set (nodesL G), edges = {}\\<rparr> nP", "by (metis)"], ["proof (state)\nthis:\n  sinvar_spec \\<lparr>nodes = set (nodesL G), edges = {}\\<rparr> nP\n\ngoal (1 subgoal):\n 1. set (TopoS_Interface_impl.minimalize_offending_overapprox\n          (\\<lambda>G. nm_sinvar m G nP) (edgesL G) [] G)\n    \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows\n           sinvar_spec (list_graph_to_graph G) nP", "(*TODO: tune*)"], ["proof (state)\nthis:\n  sinvar_spec \\<lparr>nodes = set (nodesL G), edges = {}\\<rparr> nP\n\ngoal (1 subgoal):\n 1. set (TopoS_Interface_impl.minimalize_offending_overapprox\n          (\\<lambda>G. nm_sinvar m G nP) (edgesL G) [] G)\n    \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows\n           sinvar_spec (list_graph_to_graph G) nP", "have spec_impl: \"wf_list_graph G \\<Longrightarrow> sinvar_spec (list_graph_to_graph G) nP = (nm_sinvar m) G nP\" for G nP"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_list_graph G \\<Longrightarrow>\n    sinvar_spec (list_graph_to_graph G) nP = nm_sinvar m G nP", "using NetModelLib TopoS_List_Impl.sinvar_spec_impl TopoS_modelLibrary.impl_spec"], ["proof (prove)\nusing this:\n  TopoS_modelLibrary m sinvar_spec\n  \\<lbrakk>TopoS_List_Impl ?default_node_properties ?sinvar_spec\n            ?sinvar_impl ?receiver_violation ?offending_flows_impl\n            ?node_props_impl ?eval_impl;\n   wf_list_graph ?G\\<rbrakk>\n  \\<Longrightarrow> ?sinvar_spec (list_graph_to_graph ?G) ?nP =\n                    ?sinvar_impl ?G ?nP\n  TopoS_modelLibrary ?m ?sinvar_spec \\<Longrightarrow>\n  TopoS_List_Impl (nm_default ?m) ?sinvar_spec (nm_sinvar ?m)\n   (nm_receiver_violation ?m) (nm_offending_flows ?m) (nm_node_props ?m)\n   (nm_eval ?m)\n\ngoal (1 subgoal):\n 1. wf_list_graph G \\<Longrightarrow>\n    sinvar_spec (list_graph_to_graph G) nP = nm_sinvar m G nP", "by fastforce"], ["proof (state)\nthis:\n  wf_list_graph ?G \\<Longrightarrow>\n  sinvar_spec (list_graph_to_graph ?G) ?nP = nm_sinvar m ?G ?nP\n\ngoal (1 subgoal):\n 1. set (TopoS_Interface_impl.minimalize_offending_overapprox\n          (\\<lambda>G. nm_sinvar m G nP) (edgesL G) [] G)\n    \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows\n           sinvar_spec (list_graph_to_graph G) nP", "from minimalize_offending_overapprox_spec_impl[OF wf] spec_impl"], ["proof (chain)\npicking this:\n  (\\<And>G nP.\n      wf_list_graph G \\<Longrightarrow>\n      ?sinvar_spec (list_graph_to_graph G) nP =\n      ?sinvar_impl G nP) \\<Longrightarrow>\n  TopoS_Interface_impl.minimalize_offending_overapprox\n   (\\<lambda>G. ?sinvar_impl G ?nP) ?fs ?keeps G =\n  TopoS_withOffendingFlows.minimalize_offending_overapprox\n   (\\<lambda>G. ?sinvar_spec G ?nP) ?fs ?keeps (list_graph_to_graph G)\n  wf_list_graph ?G \\<Longrightarrow>\n  sinvar_spec (list_graph_to_graph ?G) ?nP = nm_sinvar m ?G ?nP", "have alog_spec:\n        \"minimalize_offending_overapprox (\\<lambda>G. (nm_sinvar m) G nP) fs keeps G =\n         TopoS_withOffendingFlows.minimalize_offending_overapprox (\\<lambda>G. sinvar_spec G nP) fs keeps (list_graph_to_graph G)\"\n         for fs keeps"], ["proof (prove)\nusing this:\n  (\\<And>G nP.\n      wf_list_graph G \\<Longrightarrow>\n      ?sinvar_spec (list_graph_to_graph G) nP =\n      ?sinvar_impl G nP) \\<Longrightarrow>\n  TopoS_Interface_impl.minimalize_offending_overapprox\n   (\\<lambda>G. ?sinvar_impl G ?nP) ?fs ?keeps G =\n  TopoS_withOffendingFlows.minimalize_offending_overapprox\n   (\\<lambda>G. ?sinvar_spec G ?nP) ?fs ?keeps (list_graph_to_graph G)\n  wf_list_graph ?G \\<Longrightarrow>\n  sinvar_spec (list_graph_to_graph ?G) ?nP = nm_sinvar m ?G ?nP\n\ngoal (1 subgoal):\n 1. TopoS_Interface_impl.minimalize_offending_overapprox\n     (\\<lambda>G. nm_sinvar m G nP) fs keeps G =\n    TopoS_withOffendingFlows.minimalize_offending_overapprox\n     (\\<lambda>G. sinvar_spec G nP) fs keeps (list_graph_to_graph G)", "by blast"], ["proof (state)\nthis:\n  TopoS_Interface_impl.minimalize_offending_overapprox\n   (\\<lambda>G. nm_sinvar m G nP) ?fs ?keeps G =\n  TopoS_withOffendingFlows.minimalize_offending_overapprox\n   (\\<lambda>G. sinvar_spec G nP) ?fs ?keeps (list_graph_to_graph G)\n\ngoal (1 subgoal):\n 1. set (TopoS_Interface_impl.minimalize_offending_overapprox\n          (\\<lambda>G. nm_sinvar m G nP) (edgesL G) [] G)\n    \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows\n           sinvar_spec (list_graph_to_graph G) nP", "(*TODO: tune*)"], ["proof (state)\nthis:\n  TopoS_Interface_impl.minimalize_offending_overapprox\n   (\\<lambda>G. nm_sinvar m G nP) ?fs ?keeps G =\n  TopoS_withOffendingFlows.minimalize_offending_overapprox\n   (\\<lambda>G. sinvar_spec G nP) ?fs ?keeps (list_graph_to_graph G)\n\ngoal (1 subgoal):\n 1. set (TopoS_Interface_impl.minimalize_offending_overapprox\n          (\\<lambda>G. nm_sinvar m G nP) (edgesL G) [] G)\n    \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows\n           sinvar_spec (list_graph_to_graph G) nP", "from spec_impl violation"], ["proof (chain)\npicking this:\n  wf_list_graph ?G \\<Longrightarrow>\n  sinvar_spec (list_graph_to_graph ?G) ?nP = nm_sinvar m ?G ?nP\n  \\<not> nm_sinvar m G nP", "have\n        \"SecurityInvariant_withOffendingFlows.is_offending_flows sinvar_spec (set (edgesL G)) (list_graph_to_graph G) nP\""], ["proof (prove)\nusing this:\n  wf_list_graph ?G \\<Longrightarrow>\n  sinvar_spec (list_graph_to_graph ?G) ?nP = nm_sinvar m ?G ?nP\n  \\<not> nm_sinvar m G nP\n\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.is_offending_flows sinvar_spec\n     (set (edgesL G)) (list_graph_to_graph G) nP", "apply(simp add: SecurityInvariant_withOffendingFlows.is_offending_flows_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>G nP.\n                wf_list_graph G \\<Longrightarrow>\n                sinvar_spec (list_graph_to_graph G) nP = nm_sinvar m G nP;\n     \\<not> nm_sinvar m G nP\\<rbrakk>\n    \\<Longrightarrow> \\<not> sinvar_spec (list_graph_to_graph G) nP \\<and>\n                      sinvar_spec\n                       (FiniteGraph.delete_edges (list_graph_to_graph G)\n                         (set (edgesL G)))\n                       nP", "apply(intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>G nP.\n                wf_list_graph G \\<Longrightarrow>\n                sinvar_spec (list_graph_to_graph G) nP = nm_sinvar m G nP;\n     \\<not> nm_sinvar m G nP\\<rbrakk>\n    \\<Longrightarrow> \\<not> sinvar_spec (list_graph_to_graph G) nP\n 2. \\<lbrakk>\\<And>G nP.\n                wf_list_graph G \\<Longrightarrow>\n                sinvar_spec (list_graph_to_graph G) nP = nm_sinvar m G nP;\n     \\<not> nm_sinvar m G nP\\<rbrakk>\n    \\<Longrightarrow> sinvar_spec\n                       (FiniteGraph.delete_edges (list_graph_to_graph G)\n                         (set (edgesL G)))\n                       nP", "apply (simp add: local.wf; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>G nP.\n                wf_list_graph G \\<Longrightarrow>\n                sinvar_spec (list_graph_to_graph G) nP = nm_sinvar m G nP;\n     \\<not> nm_sinvar m G nP\\<rbrakk>\n    \\<Longrightarrow> sinvar_spec\n                       (FiniteGraph.delete_edges (list_graph_to_graph G)\n                         (set (edgesL G)))\n                       nP", "apply(simp add: FiniteGraph.delete_edges_simp2 list_graph_to_graph_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>G nP.\n                wf_list_graph G \\<Longrightarrow>\n                sinvar_spec\n                 \\<lparr>nodes = set (nodesL G),\n                    edges = set (edgesL G)\\<rparr>\n                 nP =\n                nm_sinvar m G nP;\n     \\<not> nm_sinvar m G nP\\<rbrakk>\n    \\<Longrightarrow> sinvar_spec\n                       \\<lparr>nodes = set (nodesL G), edges = {}\\<rparr> nP", "apply(simp add: empty_edges)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  SecurityInvariant_withOffendingFlows.is_offending_flows sinvar_spec\n   (set (edgesL G)) (list_graph_to_graph G) nP\n\ngoal (1 subgoal):\n 1. set (TopoS_Interface_impl.minimalize_offending_overapprox\n          (\\<lambda>G. nm_sinvar m G nP) (edgesL G) [] G)\n    \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows\n           sinvar_spec (list_graph_to_graph G) nP", "hence goal: \"SecurityInvariant_withOffendingFlows.is_offending_flows_min_set sinvar_spec\n        (set ?spec_algo) (list_graph_to_graph G) nP\""], ["proof (prove)\nusing this:\n  SecurityInvariant_withOffendingFlows.is_offending_flows sinvar_spec\n   (set (edgesL G)) (list_graph_to_graph G) nP\n\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.is_offending_flows_min_set\n     sinvar_spec\n     (set (TopoS_withOffendingFlows.minimalize_offending_overapprox\n            (\\<lambda>G. sinvar_spec G nP) (edgesL G) []\n            (list_graph_to_graph G)))\n     (list_graph_to_graph G) nP", "apply(subst minimalize_offending_overapprox_boundnP)"], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.is_offending_flows sinvar_spec\n     (set (edgesL G)) (list_graph_to_graph G) nP \\<Longrightarrow>\n    SecurityInvariant_withOffendingFlows.is_offending_flows_min_set\n     sinvar_spec\n     (set (SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox\n            sinvar_spec (edgesL G) [] (list_graph_to_graph G) nP))\n     (list_graph_to_graph G) nP", "(*we do this subst pretty often. is this the right abstraction here?*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.is_offending_flows sinvar_spec\n     (set (edgesL G)) (list_graph_to_graph G) nP \\<Longrightarrow>\n    SecurityInvariant_withOffendingFlows.is_offending_flows_min_set\n     sinvar_spec\n     (set (SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox\n            sinvar_spec (edgesL G) [] (list_graph_to_graph G) nP))\n     (list_graph_to_graph G) nP", "apply(rule SecurityInvariant_withOffendingFlows.is_offending_flows_min_set_minimalize_offending_overapprox[OF\n              mono wfG _ _ dist_edges])"], ["proof (prove)\ngoal (2 subgoals):\n 1. SecurityInvariant_withOffendingFlows.is_offending_flows sinvar_spec\n     (set (edgesL G)) (list_graph_to_graph G) nP \\<Longrightarrow>\n    SecurityInvariant_withOffendingFlows.is_offending_flows sinvar_spec\n     (set (edgesL G)) (list_graph_to_graph G) nP\n 2. SecurityInvariant_withOffendingFlows.is_offending_flows sinvar_spec\n     (set (edgesL G)) (list_graph_to_graph G) nP \\<Longrightarrow>\n    set (edgesL G) \\<subseteq> edges (list_graph_to_graph G)", "apply(simp add: list_graph_to_graph_def)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  SecurityInvariant_withOffendingFlows.is_offending_flows_min_set\n   sinvar_spec\n   (set (TopoS_withOffendingFlows.minimalize_offending_overapprox\n          (\\<lambda>G. sinvar_spec G nP) (edgesL G) []\n          (list_graph_to_graph G)))\n   (list_graph_to_graph G) nP\n\ngoal (1 subgoal):\n 1. set (TopoS_Interface_impl.minimalize_offending_overapprox\n          (\\<lambda>G. nm_sinvar m G nP) (edgesL G) [] G)\n    \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows\n           sinvar_spec (list_graph_to_graph G) nP", "from SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox_subseteq_input[of\n        \"sinvar_spec\" \"(edgesL G)\" \"[]\"]"], ["proof (chain)\npicking this:\n  set (SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox\n        sinvar_spec (edgesL G) [] ?G ?nP)\n  \\<subseteq> set (edgesL G) \\<union> set []", "have subset_edges:\n        \"set ?spec_algo \\<subseteq> edges (list_graph_to_graph G)\""], ["proof (prove)\nusing this:\n  set (SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox\n        sinvar_spec (edgesL G) [] ?G ?nP)\n  \\<subseteq> set (edgesL G) \\<union> set []\n\ngoal (1 subgoal):\n 1. set (TopoS_withOffendingFlows.minimalize_offending_overapprox\n          (\\<lambda>G. sinvar_spec G nP) (edgesL G) []\n          (list_graph_to_graph G))\n    \\<subseteq> edges (list_graph_to_graph G)", "apply(subst minimalize_offending_overapprox_boundnP)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Ga nP.\n        set (SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox\n              sinvar_spec (edgesL G) [] Ga nP)\n        \\<subseteq> set (edgesL G) \\<union> set []) \\<Longrightarrow>\n    set (SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox\n          sinvar_spec (edgesL G) [] (list_graph_to_graph G) nP)\n    \\<subseteq> edges (list_graph_to_graph G)", "by(simp add: list_graph_to_graph_def)"], ["proof (state)\nthis:\n  set (TopoS_withOffendingFlows.minimalize_offending_overapprox\n        (\\<lambda>G. sinvar_spec G nP) (edgesL G) []\n        (list_graph_to_graph G))\n  \\<subseteq> edges (list_graph_to_graph G)\n\ngoal (1 subgoal):\n 1. set (TopoS_Interface_impl.minimalize_offending_overapprox\n          (\\<lambda>G. nm_sinvar m G nP) (edgesL G) [] G)\n    \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows\n           sinvar_spec (list_graph_to_graph G) nP", "from goal"], ["proof (chain)\npicking this:\n  SecurityInvariant_withOffendingFlows.is_offending_flows_min_set\n   sinvar_spec\n   (set (TopoS_withOffendingFlows.minimalize_offending_overapprox\n          (\\<lambda>G. sinvar_spec G nP) (edgesL G) []\n          (list_graph_to_graph G)))\n   (list_graph_to_graph G) nP", "show ?thesis"], ["proof (prove)\nusing this:\n  SecurityInvariant_withOffendingFlows.is_offending_flows_min_set\n   sinvar_spec\n   (set (TopoS_withOffendingFlows.minimalize_offending_overapprox\n          (\\<lambda>G. sinvar_spec G nP) (edgesL G) []\n          (list_graph_to_graph G)))\n   (list_graph_to_graph G) nP\n\ngoal (1 subgoal):\n 1. set (TopoS_Interface_impl.minimalize_offending_overapprox\n          (\\<lambda>G. nm_sinvar m G nP) (edgesL G) [] G)\n    \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows\n           sinvar_spec (list_graph_to_graph G) nP", "by(simp add: SecurityInvariant_withOffendingFlows.set_offending_flows_def alog_spec subset_edges)"], ["proof (state)\nthis:\n  set (TopoS_Interface_impl.minimalize_offending_overapprox\n        (\\<lambda>G. nm_sinvar m G nP) (edgesL G) [] G)\n  \\<in> SecurityInvariant_withOffendingFlows.set_offending_flows sinvar_spec\n         (list_graph_to_graph G) nP\n\ngoal:\nNo subgoals!", "qed"], ["", "(*TODO: this should be a header of TopoS_Libary. The header should be printed BEFORE the imports are processed. *)"], ["", "section\\<open>Security Invariant Library\\<close>"], ["", "(*The SINVAR_* theory files all use the \"subsection\" command. Here is the top-section.*)"], ["", "end"]]}