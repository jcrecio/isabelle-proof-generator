{"file_name": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification/Security_Invariants/SINVAR_CommunicationPartners.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification", "problem_names": ["lemma sinvar_mono: \"SecurityInvariant_withOffendingFlows.sinvar_mono sinvar\"", "lemma CommunicationPartners_ENRnrSR: \"SecurityInvariant_withOffendingFlows.sinvar_all_edges_normal_form_not_refl_SR sinvar allowed_flow\"", "lemma Unassigned_weakrefl: \"\\<forall> s r. allowed_flow DontCare s DontCare r\"", "lemma Unassigned_botdefault: \"\\<forall> s r. (nP r) \\<noteq> DontCare \\<longrightarrow> \\<not> allowed_flow (nP s) s (nP r) r \\<longrightarrow> \\<not> allowed_flow DontCare s (nP r) r\"", "lemma  \"\\<not> allowed_flow DontCare s (Master M) r\"", "lemma  \"\\<not> allowed_flow any s (Master []) r\"", "lemma All_to_Unassigned: \"\\<forall> s r. allowed_flow (nP s) s DontCare r\"", "lemma Unassigned_default_candidate: \"\\<forall> s r. \\<not> allowed_flow (nP s) s (nP r) r \\<longrightarrow> \\<not> allowed_flow DontCare s (nP r) r\"", "lemma CommunicationPartners_offending_set: \n  \"SecurityInvariant_withOffendingFlows.set_offending_flows sinvar = CommunicationPartners_offending_set\"", "lemma TopoS_SubnetsInGW: \"SecurityInvariant sinvar default_node_properties receiver_violation\"", "lemma \"sinvar \\<lparr>nodes = {''db1'', ''db2'', ''h1'', ''h2'', ''foo'', ''bar''},\n               edges = {(''h1'', ''db1''), (''h2'', ''db1''), (''h1'', ''h2''),\n                        (''db1'', ''h1''), (''db1'', ''foo''), (''db1'', ''db2''), (''db1'', ''db1''),\n                        (''h1'', ''foo''), (''foo'', ''h1''), (''foo'', ''bar'')}\\<rparr>\n    (((((\\<lambda>h. default_node_properties)(''h1'' := Care))(''h2'' := Care))\n        (''db1'' := Master [''h1'', ''h2'']))(''db2'' := Master [''db1'']))\""], "translations": [["", "lemma sinvar_mono: \"SecurityInvariant_withOffendingFlows.sinvar_mono sinvar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.sinvar_mono sinvar", "apply(simp only: SecurityInvariant_withOffendingFlows.sinvar_mono_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>nP N E' E.\n       wf_graph \\<lparr>nodes = N, edges = E\\<rparr> \\<and>\n       E' \\<subseteq> E \\<and>\n       sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP \\<longrightarrow>\n       sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nP N E' E.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP", "by auto"], ["", "interpretation SecurityInvariant_preliminaries\n  where sinvar = sinvar"], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_preliminaries sinvar", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G nP.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.set_offending_flows\n                          sinvar G nP \\<noteq>\n                         {}\n 2. \\<And>N E E' nP.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n 3. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows sinvar ff G\n         nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (ff \\<union> f') G nP", "apply(frule_tac finite_distinct_list[OF wf_graph.finiteE])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G nP.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP;\n        \\<exists>xs. set xs = edges G \\<and> distinct xs\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.set_offending_flows\n                          sinvar G nP \\<noteq>\n                         {}\n 2. \\<And>N E E' nP.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n 3. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows sinvar ff G\n         nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (ff \\<union> f') G nP", "apply(erule_tac exE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G nP xs.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP;\n        set xs = edges G \\<and> distinct xs\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.set_offending_flows\n                          sinvar G nP \\<noteq>\n                         {}\n 2. \\<And>N E E' nP.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n 3. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows sinvar ff G\n         nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (ff \\<union> f') G nP", "apply(rename_tac list_edges)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G nP list_edges.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP;\n        set list_edges = edges G \\<and> distinct list_edges\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.set_offending_flows\n                          sinvar G nP \\<noteq>\n                         {}\n 2. \\<And>N E E' nP.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n 3. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows sinvar ff G\n         nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (ff \\<union> f') G nP", "apply(rule_tac ff=\"list_edges\" in SecurityInvariant_withOffendingFlows.mono_imp_set_offending_flows_not_empty[OF sinvar_mono])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>G nP list_edges.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP;\n        set list_edges = edges G \\<and> distinct list_edges\\<rbrakk>\n       \\<Longrightarrow> wf_graph G\n 2. \\<And>G nP list_edges.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP;\n        set list_edges = edges G \\<and> distinct list_edges\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (set list_edges) G nP\n 3. \\<And>G nP list_edges.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP;\n        set list_edges = edges G \\<and> distinct list_edges\\<rbrakk>\n       \\<Longrightarrow> set list_edges \\<subseteq> edges G\n 4. \\<And>G nP list_edges.\n       \\<lbrakk>wf_graph G; \\<not> sinvar G nP;\n        set list_edges = edges G \\<and> distinct list_edges\\<rbrakk>\n       \\<Longrightarrow> distinct list_edges\n 5. \\<And>N E E' nP.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP\n 6. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows sinvar ff G\n         nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (ff \\<union> f') G nP", "apply(auto)[6]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>G nP list_edges a b.\n       \\<lbrakk>wf_graph G; (a, b) \\<in> edges G; set list_edges = edges G;\n        distinct list_edges;\n        \\<not> SecurityInvariant_withOffendingFlows.is_offending_flows\n                sinvar (edges G) G nP;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> allowed_flow (nP a) a (nP b) b\n 2. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows sinvar ff G\n         nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (ff \\<union> f') G nP", "apply(auto simp add: SecurityInvariant_withOffendingFlows.is_offending_flows_def graph_ops)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows sinvar ff G\n         nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          sinvar (ff \\<union> f') G nP", "apply(fact SecurityInvariant_withOffendingFlows.sinvar_mono_imp_is_offending_flows_mono[OF sinvar_mono])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>ENRnr\\<close>"], ["", "lemma CommunicationPartners_ENRnrSR: \"SecurityInvariant_withOffendingFlows.sinvar_all_edges_normal_form_not_refl_SR sinvar allowed_flow\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinvar_all_edges_normal_form_not_refl_SR allowed_flow", "by(simp add: SecurityInvariant_withOffendingFlows.sinvar_all_edges_normal_form_not_refl_SR_def)"], ["", "lemma Unassigned_weakrefl: \"\\<forall> s r. allowed_flow DontCare s DontCare r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s r. allowed_flow DontCare s DontCare r", "by(simp)"], ["", "lemma Unassigned_botdefault: \"\\<forall> s r. (nP r) \\<noteq> DontCare \\<longrightarrow> \\<not> allowed_flow (nP s) s (nP r) r \\<longrightarrow> \\<not> allowed_flow DontCare s (nP r) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s r.\n       nP r \\<noteq> DontCare \\<longrightarrow>\n       \\<not> allowed_flow (nP s) s (nP r) r \\<longrightarrow>\n       \\<not> allowed_flow DontCare s (nP r) r", "apply(rule allI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r.\n       nP r \\<noteq> DontCare \\<longrightarrow>\n       \\<not> allowed_flow (nP s) s (nP r) r \\<longrightarrow>\n       \\<not> allowed_flow DontCare s (nP r) r", "apply(case_tac \"nP r\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s r.\n       nP r = DontCare \\<Longrightarrow>\n       nP r \\<noteq> DontCare \\<longrightarrow>\n       \\<not> allowed_flow (nP s) s (nP r) r \\<longrightarrow>\n       \\<not> allowed_flow DontCare s (nP r) r\n 2. \\<And>s r.\n       nP r = Care \\<Longrightarrow>\n       nP r \\<noteq> DontCare \\<longrightarrow>\n       \\<not> allowed_flow (nP s) s (nP r) r \\<longrightarrow>\n       \\<not> allowed_flow DontCare s (nP r) r\n 3. \\<And>s r x3.\n       nP r = Master x3 \\<Longrightarrow>\n       nP r \\<noteq> DontCare \\<longrightarrow>\n       \\<not> allowed_flow (nP s) s (nP r) r \\<longrightarrow>\n       \\<not> allowed_flow DontCare s (nP r) r", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r. nP r = Care \\<Longrightarrow> allowed_flow (nP s) s Care r", "apply(case_tac \"nP s\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s r.\n       \\<lbrakk>nP r = Care; nP s = DontCare\\<rbrakk>\n       \\<Longrightarrow> allowed_flow (nP s) s Care r\n 2. \\<And>s r.\n       \\<lbrakk>nP r = Care; nP s = Care\\<rbrakk>\n       \\<Longrightarrow> allowed_flow (nP s) s Care r\n 3. \\<And>s r x3.\n       \\<lbrakk>nP r = Care; nP s = Master x3\\<rbrakk>\n       \\<Longrightarrow> allowed_flow (nP s) s Care r", "apply(simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma  \"\\<not> allowed_flow DontCare s (Master M) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> allowed_flow DontCare s (Master M) r", "by(simp)"], ["", "lemma  \"\\<not> allowed_flow any s (Master []) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> allowed_flow any s (Master []) r", "by(cases any, simp_all)"], ["", "lemma All_to_Unassigned: \"\\<forall> s r. allowed_flow (nP s) s DontCare r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s r. allowed_flow (nP s) s DontCare r", "by (rule allI, rule allI, case_tac \"nP s\", simp_all)"], ["", "lemma Unassigned_default_candidate: \"\\<forall> s r. \\<not> allowed_flow (nP s) s (nP r) r \\<longrightarrow> \\<not> allowed_flow DontCare s (nP r) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s r.\n       \\<not> allowed_flow (nP s) s (nP r) r \\<longrightarrow>\n       \\<not> allowed_flow DontCare s (nP r) r", "apply(intro allI, rename_tac s r)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r.\n       \\<not> allowed_flow (nP s) s (nP r) r \\<longrightarrow>\n       \\<not> allowed_flow DontCare s (nP r) r", "apply(case_tac \"nP s\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s r.\n       nP s = DontCare \\<Longrightarrow>\n       \\<not> allowed_flow (nP s) s (nP r) r \\<longrightarrow>\n       \\<not> allowed_flow DontCare s (nP r) r\n 2. \\<And>s r.\n       nP s = Care \\<Longrightarrow>\n       \\<not> allowed_flow (nP s) s (nP r) r \\<longrightarrow>\n       \\<not> allowed_flow DontCare s (nP r) r\n 3. \\<And>s r x3.\n       nP s = Master x3 \\<Longrightarrow>\n       \\<not> allowed_flow (nP s) s (nP r) r \\<longrightarrow>\n       \\<not> allowed_flow DontCare s (nP r) r", "apply(simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s r.\n       nP s = Care \\<Longrightarrow>\n       \\<not> allowed_flow Care s (nP r) r \\<longrightarrow>\n       \\<not> allowed_flow DontCare s (nP r) r\n 2. \\<And>s r x3.\n       nP s = Master x3 \\<Longrightarrow>\n       \\<not> allowed_flow (Master x3) s (nP r) r \\<longrightarrow>\n       \\<not> allowed_flow DontCare s (nP r) r", "apply(case_tac \"nP r\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s r.\n       \\<lbrakk>nP s = Care; nP r = DontCare\\<rbrakk>\n       \\<Longrightarrow> \\<not> allowed_flow Care s (nP r)\n                                 r \\<longrightarrow>\n                         \\<not> allowed_flow DontCare s (nP r) r\n 2. \\<And>s r.\n       \\<lbrakk>nP s = Care; nP r = Care\\<rbrakk>\n       \\<Longrightarrow> \\<not> allowed_flow Care s (nP r)\n                                 r \\<longrightarrow>\n                         \\<not> allowed_flow DontCare s (nP r) r\n 3. \\<And>s r x3.\n       \\<lbrakk>nP s = Care; nP r = Master x3\\<rbrakk>\n       \\<Longrightarrow> \\<not> allowed_flow Care s (nP r)\n                                 r \\<longrightarrow>\n                         \\<not> allowed_flow DontCare s (nP r) r\n 4. \\<And>s r x3.\n       nP s = Master x3 \\<Longrightarrow>\n       \\<not> allowed_flow (Master x3) s (nP r) r \\<longrightarrow>\n       \\<not> allowed_flow DontCare s (nP r) r", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r x3.\n       nP s = Master x3 \\<Longrightarrow>\n       \\<not> allowed_flow (Master x3) s (nP r) r \\<longrightarrow>\n       \\<not> allowed_flow DontCare s (nP r) r", "apply(case_tac \"nP r\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s r x3.\n       \\<lbrakk>nP s = Master x3; nP r = DontCare\\<rbrakk>\n       \\<Longrightarrow> \\<not> allowed_flow (Master x3) s (nP r)\n                                 r \\<longrightarrow>\n                         \\<not> allowed_flow DontCare s (nP r) r\n 2. \\<And>s r x3.\n       \\<lbrakk>nP s = Master x3; nP r = Care\\<rbrakk>\n       \\<Longrightarrow> \\<not> allowed_flow (Master x3) s (nP r)\n                                 r \\<longrightarrow>\n                         \\<not> allowed_flow DontCare s (nP r) r\n 3. \\<And>s r x3 x3a.\n       \\<lbrakk>nP s = Master x3; nP r = Master x3a\\<rbrakk>\n       \\<Longrightarrow> \\<not> allowed_flow (Master x3) s (nP r)\n                                 r \\<longrightarrow>\n                         \\<not> allowed_flow DontCare s (nP r) r", "apply(simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition CommunicationPartners_offending_set:: \"'v graph \\<Rightarrow> ('v \\<Rightarrow> 'v node_config) \\<Rightarrow> ('v \\<times> 'v) set set\" where\n  \"CommunicationPartners_offending_set G nP = (if sinvar G nP then\n      {}\n     else \n      { {e \\<in> edges G. case e of (e1,e2) \\<Rightarrow> e1 \\<noteq> e2 \\<and> \\<not> allowed_flow (nP e1) e1 (nP e2) e2} })\""], ["", "lemma CommunicationPartners_offending_set: \n  \"SecurityInvariant_withOffendingFlows.set_offending_flows sinvar = CommunicationPartners_offending_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_offending_flows = CommunicationPartners_offending_set", "apply(simp only: fun_eq_iff ENFnrSR_offending_set[OF CommunicationPartners_ENRnrSR] CommunicationPartners_offending_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa.\n       (if sinvar x xa then {}\n        else {{(e1, e2).\n               (e1, e2) \\<in> edges x \\<and>\n               e1 \\<noteq> e2 \\<and>\n               \\<not> allowed_flow (xa e1) e1 (xa e2) e2}}) =\n       (if sinvar x xa then {}\n        else {{e \\<in> edges x.\n               case e of\n               (e1, e2) \\<Rightarrow>\n                 e1 \\<noteq> e2 \\<and>\n                 \\<not> allowed_flow (xa e1) e1 (xa e2) e2}})", "apply(rule allI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (if sinvar x xa then {}\n        else {{(e1, e2).\n               (e1, e2) \\<in> edges x \\<and>\n               e1 \\<noteq> e2 \\<and>\n               \\<not> allowed_flow (xa e1) e1 (xa e2) e2}}) =\n       (if sinvar x xa then {}\n        else {{e \\<in> edges x.\n               case e of\n               (e1, e2) \\<Rightarrow>\n                 e1 \\<noteq> e2 \\<and>\n                 \\<not> allowed_flow (xa e1) e1 (xa e2) e2}})", "apply(rename_tac G nP)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G nP.\n       (if sinvar G nP then {}\n        else {{(e1, e2).\n               (e1, e2) \\<in> edges G \\<and>\n               e1 \\<noteq> e2 \\<and>\n               \\<not> allowed_flow (nP e1) e1 (nP e2) e2}}) =\n       (if sinvar G nP then {}\n        else {{e \\<in> edges G.\n               case e of\n               (e1, e2) \\<Rightarrow>\n                 e1 \\<noteq> e2 \\<and>\n                 \\<not> allowed_flow (nP e1) e1 (nP e2) e2}})", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation CommunicationPartners: SecurityInvariant_ACS\nwhere default_node_properties = default_node_properties\nand sinvar = sinvar\nrewrites \"SecurityInvariant_withOffendingFlows.set_offending_flows sinvar = CommunicationPartners_offending_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_ACS sinvar default_node_properties &&&\n    set_offending_flows = CommunicationPartners_offending_set", "unfolding receiver_violation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_ACS sinvar default_node_properties &&&\n    set_offending_flows = CommunicationPartners_offending_set", "unfolding default_node_properties_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_ACS sinvar DontCare &&&\n    set_offending_flows = CommunicationPartners_offending_set", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G f nP.\n       \\<lbrakk>wf_graph G; f \\<in> set_offending_flows G nP\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>fst ` f.\n                            \\<not> sinvar G (nP(i := DontCare))\n 2. \\<And>otherbot.\n       \\<forall>G f nP i.\n          wf_graph G \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          i \\<in> fst ` f \\<longrightarrow>\n          \\<not> sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n       otherbot = DontCare\n 3. set_offending_flows = CommunicationPartners_offending_set", "apply(rule ballI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G f nP i.\n       \\<lbrakk>wf_graph G; f \\<in> set_offending_flows G nP;\n        i \\<in> fst ` f\\<rbrakk>\n       \\<Longrightarrow> \\<not> sinvar G (nP(i := DontCare))\n 2. \\<And>otherbot.\n       \\<forall>G f nP i.\n          wf_graph G \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          i \\<in> fst ` f \\<longrightarrow>\n          \\<not> sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n       otherbot = DontCare\n 3. set_offending_flows = CommunicationPartners_offending_set", "apply (rule_tac f=\"f\" in SecurityInvariant_withOffendingFlows.ENFnrSR_fsts_weakrefl_instance[OF CommunicationPartners_ENRnrSR Unassigned_weakrefl Unassigned_botdefault All_to_Unassigned])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>G f nP i.\n       \\<lbrakk>wf_graph G; f \\<in> set_offending_flows G nP;\n        i \\<in> fst ` f\\<rbrakk>\n       \\<Longrightarrow> f \\<in> set_offending_flows G nP\n 2. \\<And>G f nP i.\n       \\<lbrakk>wf_graph G; f \\<in> set_offending_flows G nP;\n        i \\<in> fst ` f\\<rbrakk>\n       \\<Longrightarrow> i \\<in> fst ` f\n 3. \\<And>otherbot.\n       \\<forall>G f nP i.\n          wf_graph G \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          i \\<in> fst ` f \\<longrightarrow>\n          \\<not> sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n       otherbot = DontCare\n 4. set_offending_flows = CommunicationPartners_offending_set", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G f nP i.\n       \\<lbrakk>wf_graph G; f \\<in> set_offending_flows G nP;\n        i \\<in> fst ` f\\<rbrakk>\n       \\<Longrightarrow> i \\<in> fst ` f\n 2. \\<And>otherbot.\n       \\<forall>G f nP i.\n          wf_graph G \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          i \\<in> fst ` f \\<longrightarrow>\n          \\<not> sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n       otherbot = DontCare\n 3. set_offending_flows = CommunicationPartners_offending_set", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>otherbot.\n       \\<forall>G f nP i.\n          wf_graph G \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          i \\<in> fst ` f \\<longrightarrow>\n          \\<not> sinvar G (nP(i := otherbot)) \\<Longrightarrow>\n       otherbot = DontCare\n 2. set_offending_flows = CommunicationPartners_offending_set", "apply(erule default_uniqueness_by_counterexample_ACS)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>otherbot.\n       otherbot \\<noteq> DontCare \\<Longrightarrow>\n       \\<exists>G nP i f.\n          wf_graph G \\<and>\n          \\<not> sinvar G nP \\<and>\n          f \\<in> set_offending_flows G nP \\<and>\n          sinvar (delete_edges G f) nP \\<and>\n          i \\<in> fst ` f \\<and> sinvar G (nP(i := otherbot))\n 2. set_offending_flows = CommunicationPartners_offending_set", "apply(rule_tac x=\"\\<lparr> nodes={vertex_1,vertex_2}, edges = {(vertex_1,vertex_2)} \\<rparr>\" in exI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>otherbot.\n       otherbot \\<noteq> DontCare \\<Longrightarrow>\n       wf_graph\n        \\<lparr>nodes = {vertex_1, vertex_2},\n           edges = {(vertex_1, vertex_2)}\\<rparr> \\<and>\n       (\\<exists>nP.\n           \\<not> allowed_flow (nP vertex_1) vertex_1 (nP vertex_2)\n                   vertex_2 \\<and>\n           (\\<exists>i.\n               (vertex_1 = i \\<longrightarrow>\n                (\\<exists>f.\n                    f \\<in> set_offending_flows\n                             \\<lparr>nodes = {vertex_1, vertex_2},\n                                edges = {(vertex_1, vertex_2)}\\<rparr>\n                             nP \\<and>\n                    (\\<forall>(s, r)\n                              \\<in>edges\n                                    (delete_edges\n\\<lparr>nodes = {vertex_1, vertex_2}, edges = {(vertex_1, vertex_2)}\\<rparr>\nf).\n                        s \\<noteq> r \\<longrightarrow>\n                        allowed_flow (nP s) s (nP r) r) \\<and>\n                    vertex_1 \\<in> fst ` f \\<and>\n                    allowed_flow otherbot vertex_1 (nP vertex_2)\n                     vertex_2)) \\<and>\n               (vertex_1 \\<noteq> i \\<longrightarrow>\n                (vertex_2 = i \\<longrightarrow>\n                 (\\<exists>f.\n                     f \\<in> set_offending_flows\n                              \\<lparr>nodes = {vertex_1, vertex_2},\n                                 edges = {(vertex_1, vertex_2)}\\<rparr>\n                              nP \\<and>\n                     (\\<forall>x\\<in>edges\n(delete_edges\n  \\<lparr>nodes = {vertex_1, vertex_2},\n     edges = {(vertex_1, vertex_2)}\\<rparr>\n  f).\n                         case x of\n                         (s, r) \\<Rightarrow>\n                           s \\<noteq> r \\<longrightarrow>\n                           allowed_flow (nP s) s (nP r) r) \\<and>\n                     vertex_2 \\<in> fst ` f \\<and>\n                     allowed_flow (nP vertex_1) vertex_1 otherbot\n                      vertex_2)) \\<and>\n                (vertex_2 \\<noteq> i \\<longrightarrow>\n                 (\\<exists>f.\n                     f \\<in> set_offending_flows\n                              \\<lparr>nodes = {vertex_1, vertex_2},\n                                 edges = {(vertex_1, vertex_2)}\\<rparr>\n                              nP \\<and>\n                     (\\<forall>x\\<in>edges\n(delete_edges\n  \\<lparr>nodes = {vertex_1, vertex_2},\n     edges = {(vertex_1, vertex_2)}\\<rparr>\n  f).\n                         case x of\n                         (s, r) \\<Rightarrow>\n                           s \\<noteq> r \\<longrightarrow>\n                           allowed_flow (nP s) s (nP r) r) \\<and>\n                     i \\<in> fst ` f \\<and>\n                     allowed_flow (nP vertex_1) vertex_1 (nP vertex_2)\n                      vertex_2)))))\n 2. set_offending_flows = CommunicationPartners_offending_set", "apply(rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>otherbot.\n       otherbot \\<noteq> DontCare \\<Longrightarrow>\n       wf_graph\n        \\<lparr>nodes = {vertex_1, vertex_2},\n           edges = {(vertex_1, vertex_2)}\\<rparr>\n 2. \\<And>otherbot.\n       otherbot \\<noteq> DontCare \\<Longrightarrow>\n       \\<exists>nP.\n          \\<not> allowed_flow (nP vertex_1) vertex_1 (nP vertex_2)\n                  vertex_2 \\<and>\n          (\\<exists>i.\n              (vertex_1 = i \\<longrightarrow>\n               (\\<exists>f.\n                   f \\<in> set_offending_flows\n                            \\<lparr>nodes = {vertex_1, vertex_2},\n                               edges = {(vertex_1, vertex_2)}\\<rparr>\n                            nP \\<and>\n                   (\\<forall>(s, r)\n                             \\<in>edges\n                                   (delete_edges\n                                     \\<lparr>nodes = {vertex_1, vertex_2},\n  edges = {(vertex_1, vertex_2)}\\<rparr>\n                                     f).\n                       s \\<noteq> r \\<longrightarrow>\n                       allowed_flow (nP s) s (nP r) r) \\<and>\n                   vertex_1 \\<in> fst ` f \\<and>\n                   allowed_flow otherbot vertex_1 (nP vertex_2)\n                    vertex_2)) \\<and>\n              (vertex_1 \\<noteq> i \\<longrightarrow>\n               (vertex_2 = i \\<longrightarrow>\n                (\\<exists>f.\n                    f \\<in> set_offending_flows\n                             \\<lparr>nodes = {vertex_1, vertex_2},\n                                edges = {(vertex_1, vertex_2)}\\<rparr>\n                             nP \\<and>\n                    (\\<forall>x\\<in>edges\n                                     (delete_edges\n \\<lparr>nodes = {vertex_1, vertex_2},\n    edges = {(vertex_1, vertex_2)}\\<rparr>\n f).\n                        case x of\n                        (s, r) \\<Rightarrow>\n                          s \\<noteq> r \\<longrightarrow>\n                          allowed_flow (nP s) s (nP r) r) \\<and>\n                    vertex_2 \\<in> fst ` f \\<and>\n                    allowed_flow (nP vertex_1) vertex_1 otherbot\n                     vertex_2)) \\<and>\n               (vertex_2 \\<noteq> i \\<longrightarrow>\n                (\\<exists>f.\n                    f \\<in> set_offending_flows\n                             \\<lparr>nodes = {vertex_1, vertex_2},\n                                edges = {(vertex_1, vertex_2)}\\<rparr>\n                             nP \\<and>\n                    (\\<forall>x\\<in>edges\n                                     (delete_edges\n \\<lparr>nodes = {vertex_1, vertex_2},\n    edges = {(vertex_1, vertex_2)}\\<rparr>\n f).\n                        case x of\n                        (s, r) \\<Rightarrow>\n                          s \\<noteq> r \\<longrightarrow>\n                          allowed_flow (nP s) s (nP r) r) \\<and>\n                    i \\<in> fst ` f \\<and>\n                    allowed_flow (nP vertex_1) vertex_1 (nP vertex_2)\n                     vertex_2))))\n 3. set_offending_flows = CommunicationPartners_offending_set", "apply(simp add: wf_graph_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>otherbot.\n       otherbot \\<noteq> DontCare \\<Longrightarrow>\n       \\<exists>nP.\n          \\<not> allowed_flow (nP vertex_1) vertex_1 (nP vertex_2)\n                  vertex_2 \\<and>\n          (\\<exists>i.\n              (vertex_1 = i \\<longrightarrow>\n               (\\<exists>f.\n                   f \\<in> set_offending_flows\n                            \\<lparr>nodes = {vertex_1, vertex_2},\n                               edges = {(vertex_1, vertex_2)}\\<rparr>\n                            nP \\<and>\n                   (\\<forall>(s, r)\n                             \\<in>edges\n                                   (delete_edges\n                                     \\<lparr>nodes = {vertex_1, vertex_2},\n  edges = {(vertex_1, vertex_2)}\\<rparr>\n                                     f).\n                       s \\<noteq> r \\<longrightarrow>\n                       allowed_flow (nP s) s (nP r) r) \\<and>\n                   vertex_1 \\<in> fst ` f \\<and>\n                   allowed_flow otherbot vertex_1 (nP vertex_2)\n                    vertex_2)) \\<and>\n              (vertex_1 \\<noteq> i \\<longrightarrow>\n               (vertex_2 = i \\<longrightarrow>\n                (\\<exists>f.\n                    f \\<in> set_offending_flows\n                             \\<lparr>nodes = {vertex_1, vertex_2},\n                                edges = {(vertex_1, vertex_2)}\\<rparr>\n                             nP \\<and>\n                    (\\<forall>x\\<in>edges\n                                     (delete_edges\n \\<lparr>nodes = {vertex_1, vertex_2},\n    edges = {(vertex_1, vertex_2)}\\<rparr>\n f).\n                        case x of\n                        (s, r) \\<Rightarrow>\n                          s \\<noteq> r \\<longrightarrow>\n                          allowed_flow (nP s) s (nP r) r) \\<and>\n                    vertex_2 \\<in> fst ` f \\<and>\n                    allowed_flow (nP vertex_1) vertex_1 otherbot\n                     vertex_2)) \\<and>\n               (vertex_2 \\<noteq> i \\<longrightarrow>\n                (\\<exists>f.\n                    f \\<in> set_offending_flows\n                             \\<lparr>nodes = {vertex_1, vertex_2},\n                                edges = {(vertex_1, vertex_2)}\\<rparr>\n                             nP \\<and>\n                    (\\<forall>x\\<in>edges\n                                     (delete_edges\n \\<lparr>nodes = {vertex_1, vertex_2},\n    edges = {(vertex_1, vertex_2)}\\<rparr>\n f).\n                        case x of\n                        (s, r) \\<Rightarrow>\n                          s \\<noteq> r \\<longrightarrow>\n                          allowed_flow (nP s) s (nP r) r) \\<and>\n                    i \\<in> fst ` f \\<and>\n                    allowed_flow (nP vertex_1) vertex_1 (nP vertex_2)\n                     vertex_2))))\n 2. set_offending_flows = CommunicationPartners_offending_set", "apply(simp add: CommunicationPartners_offending_set CommunicationPartners_offending_set_def delete_edges_simp2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>otherbot.\n       otherbot \\<noteq> DontCare \\<Longrightarrow>\n       \\<exists>nP.\n          \\<not> allowed_flow (nP vertex_1) vertex_1 (nP vertex_2)\n                  vertex_2 \\<and>\n          (\\<not> allowed_flow (nP vertex_1) vertex_1 (nP vertex_2)\n                   vertex_2 \\<longrightarrow>\n           (\\<exists>i.\n               (vertex_1 = i \\<longrightarrow>\n                vertex_1\n                \\<in> (\\<lambda>a. vertex_1) `\n                      {e. e = (vertex_1, vertex_2) \\<and>\n                          (case e of\n                           (e1, e2) \\<Rightarrow>\n                             e1 \\<noteq> e2 \\<and>\n                             \\<not> allowed_flow (nP e1) e1 (nP e2)\n                                     e2)} \\<and>\n                allowed_flow otherbot vertex_1 (nP vertex_2)\n                 vertex_2) \\<and>\n               (vertex_1 \\<noteq> i \\<longrightarrow>\n                (vertex_2 = i \\<longrightarrow>\n                 vertex_2\n                 \\<in> (\\<lambda>a. vertex_1) `\n                       {e. e = (vertex_1, vertex_2) \\<and>\n                           (case e of\n                            (e1, e2) \\<Rightarrow>\n                              e1 \\<noteq> e2 \\<and>\n                              \\<not> allowed_flow (nP e1) e1 (nP e2)\ne2)} \\<and>\n                 allowed_flow (nP vertex_1) vertex_1 otherbot\n                  vertex_2) \\<and>\n                vertex_2 = i)))\n 2. set_offending_flows = CommunicationPartners_offending_set", "apply(case_tac otherbot, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<exists>nP.\n       \\<not> allowed_flow (nP vertex_1) vertex_1 (nP vertex_2)\n               vertex_2 \\<and>\n       (\\<not> allowed_flow (nP vertex_1) vertex_1 (nP vertex_2)\n                vertex_2 \\<longrightarrow>\n        (\\<exists>i.\n            (vertex_1 = i \\<longrightarrow>\n             vertex_1\n             \\<in> (\\<lambda>a. vertex_1) `\n                   {e. e = (vertex_1, vertex_2) \\<and>\n                       (case e of\n                        (e1, e2) \\<Rightarrow>\n                          e1 \\<noteq> e2 \\<and>\n                          \\<not> allowed_flow (nP e1) e1 (nP e2) e2)} \\<and>\n             allowed_flow Care vertex_1 (nP vertex_2) vertex_2) \\<and>\n            (vertex_1 \\<noteq> i \\<longrightarrow>\n             (vertex_2 = i \\<longrightarrow>\n              vertex_2\n              \\<in> (\\<lambda>a. vertex_1) `\n                    {e. e = (vertex_1, vertex_2) \\<and>\n                        (case e of\n                         (e1, e2) \\<Rightarrow>\n                           e1 \\<noteq> e2 \\<and>\n                           \\<not> allowed_flow (nP e1) e1 (nP e2)\n                                   e2)} \\<and>\n              allowed_flow (nP vertex_1) vertex_1 Care vertex_2) \\<and>\n             vertex_2 = i)))\n 2. \\<And>otherbot x3.\n       otherbot = Master x3 \\<Longrightarrow>\n       \\<exists>nP.\n          \\<not> allowed_flow (nP vertex_1) vertex_1 (nP vertex_2)\n                  vertex_2 \\<and>\n          (\\<not> allowed_flow (nP vertex_1) vertex_1 (nP vertex_2)\n                   vertex_2 \\<longrightarrow>\n           (\\<exists>i.\n               (vertex_1 = i \\<longrightarrow>\n                vertex_1\n                \\<in> (\\<lambda>a. vertex_1) `\n                      {e. e = (vertex_1, vertex_2) \\<and>\n                          (case e of\n                           (e1, e2) \\<Rightarrow>\n                             e1 \\<noteq> e2 \\<and>\n                             \\<not> allowed_flow (nP e1) e1 (nP e2)\n                                     e2)} \\<and>\n                allowed_flow (Master x3) vertex_1 (nP vertex_2)\n                 vertex_2) \\<and>\n               (vertex_1 \\<noteq> i \\<longrightarrow>\n                (vertex_2 = i \\<longrightarrow>\n                 vertex_2\n                 \\<in> (\\<lambda>a. vertex_1) `\n                       {e. e = (vertex_1, vertex_2) \\<and>\n                           (case e of\n                            (e1, e2) \\<Rightarrow>\n                              e1 \\<noteq> e2 \\<and>\n                              \\<not> allowed_flow (nP e1) e1 (nP e2)\ne2)} \\<and>\n                 allowed_flow (nP vertex_1) vertex_1 (Master x3)\n                  vertex_2) \\<and>\n                vertex_2 = i)))\n 3. set_offending_flows = CommunicationPartners_offending_set", "apply(rule_tac x=\"(\\<lambda> x. DontCare)(vertex_1 := DontCare, vertex_2 := Master [vertex_1])\" in exI, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<exists>i.\n       (vertex_1 = i \\<longrightarrow>\n        vertex_1\n        \\<in> (\\<lambda>a. vertex_1) `\n              {e. e = (vertex_1, vertex_2) \\<and>\n                  (case e of\n                   (e1, e2) \\<Rightarrow>\n                     (e2 = vertex_2 \\<longrightarrow>\n                      e1 \\<noteq> vertex_2 \\<and>\n                      \\<not> allowed_flow\n                              (if e1 = vertex_2 then Master [vertex_1]\n                               else ((\\<lambda>x. DontCare)\n                                     (vertex_1 := DontCare))\n                                     e1)\n                              e1 (Master [vertex_1]) vertex_2) \\<and>\n                     (e2 \\<noteq> vertex_2 \\<longrightarrow>\n                      e1 \\<noteq> e2 \\<and>\n                      \\<not> allowed_flow\n                              (if e1 = vertex_2 then Master [vertex_1]\n                               else ((\\<lambda>x. DontCare)\n                                     (vertex_1 := DontCare))\n                                     e1)\n                              e1 DontCare e2))}) \\<and>\n       (vertex_1 \\<noteq> i \\<longrightarrow>\n        (vertex_2 = i \\<longrightarrow>\n         vertex_2\n         \\<in> (\\<lambda>a. vertex_1) `\n               {e. e = (vertex_1, vertex_2) \\<and>\n                   (case e of\n                    (e1, e2) \\<Rightarrow>\n                      (e2 = vertex_2 \\<longrightarrow>\n                       e1 \\<noteq> vertex_2 \\<and>\n                       \\<not> allowed_flow\n                               (if e1 = vertex_2 then Master [vertex_1]\n                                else ((\\<lambda>x. DontCare)\n(vertex_1 := DontCare))\ne1)\n                               e1 (Master [vertex_1]) vertex_2) \\<and>\n                      (e2 \\<noteq> vertex_2 \\<longrightarrow>\n                       e1 \\<noteq> e2 \\<and>\n                       \\<not> allowed_flow\n                               (if e1 = vertex_2 then Master [vertex_1]\n                                else ((\\<lambda>x. DontCare)\n(vertex_1 := DontCare))\ne1)\n                               e1 DontCare e2))}) \\<and>\n        vertex_2 = i)\n 2. \\<And>otherbot x3.\n       otherbot = Master x3 \\<Longrightarrow>\n       \\<exists>nP.\n          \\<not> allowed_flow (nP vertex_1) vertex_1 (nP vertex_2)\n                  vertex_2 \\<and>\n          (\\<not> allowed_flow (nP vertex_1) vertex_1 (nP vertex_2)\n                   vertex_2 \\<longrightarrow>\n           (\\<exists>i.\n               (vertex_1 = i \\<longrightarrow>\n                vertex_1\n                \\<in> (\\<lambda>a. vertex_1) `\n                      {e. e = (vertex_1, vertex_2) \\<and>\n                          (case e of\n                           (e1, e2) \\<Rightarrow>\n                             e1 \\<noteq> e2 \\<and>\n                             \\<not> allowed_flow (nP e1) e1 (nP e2)\n                                     e2)} \\<and>\n                allowed_flow (Master x3) vertex_1 (nP vertex_2)\n                 vertex_2) \\<and>\n               (vertex_1 \\<noteq> i \\<longrightarrow>\n                (vertex_2 = i \\<longrightarrow>\n                 vertex_2\n                 \\<in> (\\<lambda>a. vertex_1) `\n                       {e. e = (vertex_1, vertex_2) \\<and>\n                           (case e of\n                            (e1, e2) \\<Rightarrow>\n                              e1 \\<noteq> e2 \\<and>\n                              \\<not> allowed_flow (nP e1) e1 (nP e2)\ne2)} \\<and>\n                 allowed_flow (nP vertex_1) vertex_1 (Master x3)\n                  vertex_2) \\<and>\n                vertex_2 = i)))\n 3. set_offending_flows = CommunicationPartners_offending_set", "apply(rule_tac x=\"vertex_1\" in exI, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. vertex_1\n    \\<in> (\\<lambda>a. vertex_1) `\n          {e. e = (vertex_1, vertex_2) \\<and>\n              (case e of\n               (e1, e2) \\<Rightarrow>\n                 (e2 = vertex_2 \\<longrightarrow>\n                  e1 \\<noteq> vertex_2 \\<and>\n                  \\<not> allowed_flow\n                          (if e1 = vertex_2 then Master [vertex_1]\n                           else ((\\<lambda>x. DontCare)\n                                 (vertex_1 := DontCare))\n                                 e1)\n                          e1 (Master [vertex_1]) vertex_2) \\<and>\n                 (e2 \\<noteq> vertex_2 \\<longrightarrow>\n                  e1 \\<noteq> e2 \\<and>\n                  \\<not> allowed_flow\n                          (if e1 = vertex_2 then Master [vertex_1]\n                           else ((\\<lambda>x. DontCare)\n                                 (vertex_1 := DontCare))\n                                 e1)\n                          e1 DontCare e2))}\n 2. \\<And>otherbot x3.\n       otherbot = Master x3 \\<Longrightarrow>\n       \\<exists>nP.\n          \\<not> allowed_flow (nP vertex_1) vertex_1 (nP vertex_2)\n                  vertex_2 \\<and>\n          (\\<not> allowed_flow (nP vertex_1) vertex_1 (nP vertex_2)\n                   vertex_2 \\<longrightarrow>\n           (\\<exists>i.\n               (vertex_1 = i \\<longrightarrow>\n                vertex_1\n                \\<in> (\\<lambda>a. vertex_1) `\n                      {e. e = (vertex_1, vertex_2) \\<and>\n                          (case e of\n                           (e1, e2) \\<Rightarrow>\n                             e1 \\<noteq> e2 \\<and>\n                             \\<not> allowed_flow (nP e1) e1 (nP e2)\n                                     e2)} \\<and>\n                allowed_flow (Master x3) vertex_1 (nP vertex_2)\n                 vertex_2) \\<and>\n               (vertex_1 \\<noteq> i \\<longrightarrow>\n                (vertex_2 = i \\<longrightarrow>\n                 vertex_2\n                 \\<in> (\\<lambda>a. vertex_1) `\n                       {e. e = (vertex_1, vertex_2) \\<and>\n                           (case e of\n                            (e1, e2) \\<Rightarrow>\n                              e1 \\<noteq> e2 \\<and>\n                              \\<not> allowed_flow (nP e1) e1 (nP e2)\ne2)} \\<and>\n                 allowed_flow (nP vertex_1) vertex_1 (Master x3)\n                  vertex_2) \\<and>\n                vertex_2 = i)))\n 3. set_offending_flows = CommunicationPartners_offending_set", "apply(simp split: prod.split)"], ["proof (prove)\ngoal (3 subgoals):\n 1. vertex_1\n    \\<in> (\\<lambda>x. vertex_1) `\n          {e. \\<forall>x1.\n                 (x1 = vertex_2 \\<longrightarrow>\n                  (\\<forall>x2. e \\<noteq> (vertex_2, x2))) \\<and>\n                 (x1 \\<noteq> vertex_2 \\<longrightarrow>\n                  (\\<forall>x2.\n                      e = (x1, x2) \\<longrightarrow>\n                      x1 = vertex_1 \\<and> x2 = vertex_2))}\n 2. \\<And>otherbot x3.\n       otherbot = Master x3 \\<Longrightarrow>\n       \\<exists>nP.\n          \\<not> allowed_flow (nP vertex_1) vertex_1 (nP vertex_2)\n                  vertex_2 \\<and>\n          (\\<not> allowed_flow (nP vertex_1) vertex_1 (nP vertex_2)\n                   vertex_2 \\<longrightarrow>\n           (\\<exists>i.\n               (vertex_1 = i \\<longrightarrow>\n                vertex_1\n                \\<in> (\\<lambda>a. vertex_1) `\n                      {e. e = (vertex_1, vertex_2) \\<and>\n                          (case e of\n                           (e1, e2) \\<Rightarrow>\n                             e1 \\<noteq> e2 \\<and>\n                             \\<not> allowed_flow (nP e1) e1 (nP e2)\n                                     e2)} \\<and>\n                allowed_flow (Master x3) vertex_1 (nP vertex_2)\n                 vertex_2) \\<and>\n               (vertex_1 \\<noteq> i \\<longrightarrow>\n                (vertex_2 = i \\<longrightarrow>\n                 vertex_2\n                 \\<in> (\\<lambda>a. vertex_1) `\n                       {e. e = (vertex_1, vertex_2) \\<and>\n                           (case e of\n                            (e1, e2) \\<Rightarrow>\n                              e1 \\<noteq> e2 \\<and>\n                              \\<not> allowed_flow (nP e1) e1 (nP e2)\ne2)} \\<and>\n                 allowed_flow (nP vertex_1) vertex_1 (Master x3)\n                  vertex_2) \\<and>\n                vertex_2 = i)))\n 3. set_offending_flows = CommunicationPartners_offending_set", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>otherbot x3.\n       otherbot = Master x3 \\<Longrightarrow>\n       \\<exists>nP.\n          \\<not> allowed_flow (nP vertex_1) vertex_1 (nP vertex_2)\n                  vertex_2 \\<and>\n          (\\<not> allowed_flow (nP vertex_1) vertex_1 (nP vertex_2)\n                   vertex_2 \\<longrightarrow>\n           (\\<exists>i.\n               (vertex_1 = i \\<longrightarrow>\n                vertex_1\n                \\<in> (\\<lambda>a. vertex_1) `\n                      {e. e = (vertex_1, vertex_2) \\<and>\n                          (case e of\n                           (e1, e2) \\<Rightarrow>\n                             e1 \\<noteq> e2 \\<and>\n                             \\<not> allowed_flow (nP e1) e1 (nP e2)\n                                     e2)} \\<and>\n                allowed_flow (Master x3) vertex_1 (nP vertex_2)\n                 vertex_2) \\<and>\n               (vertex_1 \\<noteq> i \\<longrightarrow>\n                (vertex_2 = i \\<longrightarrow>\n                 vertex_2\n                 \\<in> (\\<lambda>a. vertex_1) `\n                       {e. e = (vertex_1, vertex_2) \\<and>\n                           (case e of\n                            (e1, e2) \\<Rightarrow>\n                              e1 \\<noteq> e2 \\<and>\n                              \\<not> allowed_flow (nP e1) e1 (nP e2)\ne2)} \\<and>\n                 allowed_flow (nP vertex_1) vertex_1 (Master x3)\n                  vertex_2) \\<and>\n                vertex_2 = i)))\n 2. set_offending_flows = CommunicationPartners_offending_set", "apply(rename_tac M)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>otherbot M.\n       otherbot = Master M \\<Longrightarrow>\n       \\<exists>nP.\n          \\<not> allowed_flow (nP vertex_1) vertex_1 (nP vertex_2)\n                  vertex_2 \\<and>\n          (\\<not> allowed_flow (nP vertex_1) vertex_1 (nP vertex_2)\n                   vertex_2 \\<longrightarrow>\n           (\\<exists>i.\n               (vertex_1 = i \\<longrightarrow>\n                vertex_1\n                \\<in> (\\<lambda>a. vertex_1) `\n                      {e. e = (vertex_1, vertex_2) \\<and>\n                          (case e of\n                           (e1, e2) \\<Rightarrow>\n                             e1 \\<noteq> e2 \\<and>\n                             \\<not> allowed_flow (nP e1) e1 (nP e2)\n                                     e2)} \\<and>\n                allowed_flow (Master M) vertex_1 (nP vertex_2)\n                 vertex_2) \\<and>\n               (vertex_1 \\<noteq> i \\<longrightarrow>\n                (vertex_2 = i \\<longrightarrow>\n                 vertex_2\n                 \\<in> (\\<lambda>a. vertex_1) `\n                       {e. e = (vertex_1, vertex_2) \\<and>\n                           (case e of\n                            (e1, e2) \\<Rightarrow>\n                              e1 \\<noteq> e2 \\<and>\n                              \\<not> allowed_flow (nP e1) e1 (nP e2)\ne2)} \\<and>\n                 allowed_flow (nP vertex_1) vertex_1 (Master M)\n                  vertex_2) \\<and>\n                vertex_2 = i)))\n 2. set_offending_flows = CommunicationPartners_offending_set", "(*case Master M*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>otherbot M.\n       otherbot = Master M \\<Longrightarrow>\n       \\<exists>nP.\n          \\<not> allowed_flow (nP vertex_1) vertex_1 (nP vertex_2)\n                  vertex_2 \\<and>\n          (\\<not> allowed_flow (nP vertex_1) vertex_1 (nP vertex_2)\n                   vertex_2 \\<longrightarrow>\n           (\\<exists>i.\n               (vertex_1 = i \\<longrightarrow>\n                vertex_1\n                \\<in> (\\<lambda>a. vertex_1) `\n                      {e. e = (vertex_1, vertex_2) \\<and>\n                          (case e of\n                           (e1, e2) \\<Rightarrow>\n                             e1 \\<noteq> e2 \\<and>\n                             \\<not> allowed_flow (nP e1) e1 (nP e2)\n                                     e2)} \\<and>\n                allowed_flow (Master M) vertex_1 (nP vertex_2)\n                 vertex_2) \\<and>\n               (vertex_1 \\<noteq> i \\<longrightarrow>\n                (vertex_2 = i \\<longrightarrow>\n                 vertex_2\n                 \\<in> (\\<lambda>a. vertex_1) `\n                       {e. e = (vertex_1, vertex_2) \\<and>\n                           (case e of\n                            (e1, e2) \\<Rightarrow>\n                              e1 \\<noteq> e2 \\<and>\n                              \\<not> allowed_flow (nP e1) e1 (nP e2)\ne2)} \\<and>\n                 allowed_flow (nP vertex_1) vertex_1 (Master M)\n                  vertex_2) \\<and>\n                vertex_2 = i)))\n 2. set_offending_flows = CommunicationPartners_offending_set", "apply(rule_tac x=\"(\\<lambda> x. DontCare)(vertex_1 := DontCare, vertex_2 := (Master (vertex_1#M')))\" in exI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>otherbot M.\n       otherbot = Master M \\<Longrightarrow>\n       vertex_1\n       \\<in> (\\<lambda>a. vertex_1) `\n             {e. e = (vertex_1, vertex_2) \\<and>\n                 (case e of\n                  (e1, e2) \\<Rightarrow>\n                    (e2 = vertex_2 \\<longrightarrow>\n                     e1 \\<noteq> vertex_2 \\<and>\n                     \\<not> allowed_flow\n                             (if e1 = vertex_2 then Master (vertex_1 # M')\n                              else ((\\<lambda>x. DontCare)\n                                    (vertex_1 := DontCare))\n                                    e1)\n                             e1 (Master (vertex_1 # M')) vertex_2) \\<and>\n                    (e2 \\<noteq> vertex_2 \\<longrightarrow>\n                     e1 \\<noteq> e2 \\<and>\n                     \\<not> allowed_flow\n                             (if e1 = vertex_2 then Master (vertex_1 # M')\n                              else ((\\<lambda>x. DontCare)\n                                    (vertex_1 := DontCare))\n                                    e1)\n                             e1 DontCare e2))}\n 2. set_offending_flows = CommunicationPartners_offending_set", "apply(simp split: prod.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>otherbot M.\n       otherbot = Master M \\<Longrightarrow>\n       vertex_1\n       \\<in> (\\<lambda>x. vertex_1) `\n             {e. \\<forall>x1.\n                    (x1 = vertex_2 \\<longrightarrow>\n                     (\\<forall>x2. e \\<noteq> (vertex_2, x2))) \\<and>\n                    (x1 \\<noteq> vertex_2 \\<longrightarrow>\n                     (\\<forall>x2.\n                         e = (x1, x2) \\<longrightarrow>\n                         x1 = vertex_1 \\<and> x2 = vertex_2))}\n 2. set_offending_flows = CommunicationPartners_offending_set", "apply(clarify)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>otherbot M.\n       vertex_1\n       \\<in> (\\<lambda>x. vertex_1) `\n             {e. \\<forall>x1.\n                    (x1 = vertex_2 \\<longrightarrow>\n                     (\\<forall>x2. e \\<noteq> (vertex_2, x2))) \\<and>\n                    (x1 \\<noteq> vertex_2 \\<longrightarrow>\n                     (\\<forall>x2.\n                         e = (x1, x2) \\<longrightarrow>\n                         x1 = vertex_1 \\<and> x2 = vertex_2))}\n 2. set_offending_flows = CommunicationPartners_offending_set", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_offending_flows = CommunicationPartners_offending_set", "apply(fact CommunicationPartners_offending_set)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma TopoS_SubnetsInGW: \"SecurityInvariant sinvar default_node_properties receiver_violation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant sinvar default_node_properties receiver_violation", "unfolding receiver_violation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant sinvar default_node_properties False", "by unfold_locales"], ["", "text\\<open>Example:\\<close>"], ["", "lemma \"sinvar \\<lparr>nodes = {''db1'', ''db2'', ''h1'', ''h2'', ''foo'', ''bar''},\n               edges = {(''h1'', ''db1''), (''h2'', ''db1''), (''h1'', ''h2''),\n                        (''db1'', ''h1''), (''db1'', ''foo''), (''db1'', ''db2''), (''db1'', ''db1''),\n                        (''h1'', ''foo''), (''foo'', ''h1''), (''foo'', ''bar'')}\\<rparr>\n    (((((\\<lambda>h. default_node_properties)(''h1'' := Care))(''h2'' := Care))\n        (''db1'' := Master [''h1'', ''h2'']))(''db2'' := Master [''db1'']))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinvar\n     \\<lparr>nodes = {''db1'', ''db2'', ''h1'', ''h2'', ''foo'', ''bar''},\n        edges =\n          {(''h1'', ''db1''), (''h2'', ''db1''), (''h1'', ''h2''),\n           (''db1'', ''h1''), (''db1'', ''foo''), (''db1'', ''db2''),\n           (''db1'', ''db1''), (''h1'', ''foo''), (''foo'', ''h1''),\n           (''foo'', ''bar'')}\\<rparr>\n     ((\\<lambda>h. default_node_properties)\n      (''h1'' := Care, ''h2'' := Care, ''db1'' := Master [''h1'', ''h2''],\n       ''db2'' := Master [''db1'']))", "by eval"], ["", "hide_fact (open) sinvar_mono"], ["", "hide_const (open) sinvar receiver_violation default_node_properties"], ["", "end"]]}