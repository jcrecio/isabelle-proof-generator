{"file_name": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification/Lib/FiniteListGraph.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification", "problem_names": ["lemma wf_list_graph_iff_wf_graph: \"wf_graph (list_graph_to_graph G) \\<longleftrightarrow> wf_list_graph_axioms G\"", "lemma add_node_wf: \"wf_list_graph G \\<Longrightarrow> wf_list_graph (add_node v G)\"", "lemma add_node_set_nodes: \"set (nodesL (add_node v G)) = set (nodesL G) \\<union> {v}\"", "lemma add_node_set_edges: \"set (edgesL (add_node v G)) = set (edgesL G)\"", "lemma add_node_correct: \"FiniteGraph.add_node v (list_graph_to_graph G) = list_graph_to_graph (add_node v G)\"", "lemma add_node_wf2: \"wf_graph (list_graph_to_graph G) \\<Longrightarrow> wf_graph (list_graph_to_graph (add_node v G))\"", "lemma add_edge_wf: \"wf_list_graph G \\<Longrightarrow> wf_list_graph (add_edge v v' G)\"", "lemma add_edge_set_nodes: \"set (nodesL (add_edge v v' G)) = set (nodesL G) \\<union> {v,v'}\"", "lemma add_edge_set_edges: \"set (edgesL (add_edge v v' G)) = set (edgesL G) \\<union> {(v,v')}\"", "lemma add_edge_correct: \"FiniteGraph.add_edge v v' (list_graph_to_graph G) = list_graph_to_graph (add_edge v v' G)\"", "lemma add_edge_wf2: \"wf_graph (list_graph_to_graph G) \\<Longrightarrow> wf_graph (list_graph_to_graph (add_edge v v' G))\"", "lemma delete_node_wf: \"wf_list_graph G \\<Longrightarrow> wf_list_graph (delete_node v G)\"", "lemma delete_node_set_edges:\n    \"set (edgesL (delete_node v G)) = {(a,b). (a, b) \\<in> set (edgesL G) \\<and> a \\<noteq> v \\<and> b \\<noteq> v}\"", "lemma delete_node_correct:\n    assumes \"wf_list_graph G\"\n    shows \"FiniteGraph.delete_node v (list_graph_to_graph G) = list_graph_to_graph (delete_node v G)\"", "lemma delete_edge_set_nodes: \"set (nodesL (delete_edge v v' G)) = set (nodesL G)\"", "lemma delete_edge_set_edges:\n    \"set (edgesL (delete_edge v v' G)) = {(a,b). (a,b) \\<in> set (edgesL G) \\<and> (a,b) \\<noteq> (v,v')}\"", "lemma delete_edge_set_edges2:\n    \"set (edgesL (delete_edge v v' G)) = set (edgesL G) - {(v,v')}\"", "lemma delete_edge_wf: \"wf_list_graph G \\<Longrightarrow> wf_list_graph (delete_edge v v' G)\"", "lemma delete_edge_length: \"length (edgesL (delete_edge v v' G)) \\<le> length (edgesL G)\"", "lemma delete_edge_commute: \"delete_edge a1 a2 (delete_edge b1 b2 G) = delete_edge b1 b2 (delete_edge a1 a2 G)\"", "lemma delete_edge_correct: \"FiniteGraph.delete_edge v v' (list_graph_to_graph G) = list_graph_to_graph (delete_edge v v' G)\"", "lemma delete_edge_wf2: \"wf_graph (list_graph_to_graph G) \\<Longrightarrow> wf_graph (list_graph_to_graph (delete_edge v v' G))\"", "lemma delete_edges_wf: \"wf_list_graph G \\<Longrightarrow> wf_list_graph (delete_edges G E)\"", "lemma delete_edges_set_nodes: \"set (nodesL (delete_edges G E)) = set (nodesL G)\"", "lemma delete_edges_nodes: \"nodesL (delete_edges G es) = nodesL G\"", "lemma delete_edges_set_edges: \"set (edgesL (delete_edges G E)) = set (edgesL G) - set E\"", "lemma delete_edges_set_edges2:\n    \"set (edgesL (delete_edges G E)) = {(a,b). (a,b) \\<in> set (edgesL G) \\<and> (a,b) \\<notin> set E}\"", "lemma delete_edges_length: \"length (edgesL (delete_edges G f)) \\<le> length (edgesL G)\"", "lemma delete_edges_chain: \"delete_edges G (as @ bs) = delete_edges (delete_edges G as) bs\"", "lemma delete_edges_delete_edge_commute:\n    \"delete_edges (delete_edge a1 a2 G) as = delete_edge a1 a2 (delete_edges G as)\"", "lemma delete_edges_commute:\n    \"delete_edges (delete_edges G as) bs = delete_edges (delete_edges G bs) as\"", "lemma delete_edges_as_filter:\n    \"delete_edges G l = \\<lparr> nodesL = nodesL G,  edgesL = [x \\<leftarrow> edgesL G. x \\<notin> set l] \\<rparr>\"", "lemma delete_edges_correct:\n    \"FiniteGraph.delete_edges (list_graph_to_graph G) (set E) = list_graph_to_graph (delete_edges G E)\"", "lemma delete_edges_wf2:\n    \"wf_graph (list_graph_to_graph G) \\<Longrightarrow> wf_graph (list_graph_to_graph (delete_edges G E))\"", "lemma distinct_relpow_impl:\n    \"distinct L \\<Longrightarrow> distinct new \\<Longrightarrow> distinct have \\<Longrightarrow> distinct (new@have) \\<Longrightarrow> \n     distinct (relpow_impl (\\<lambda>as. remdups (map snd [(a, b)\\<leftarrow>L . a \\<in> set as])) (\\<lambda>xs ys. [x\\<leftarrow>xs . x \\<notin> set ys] @ ys) (\\<lambda>x xs. x \\<in> set xs) new have M)\"", "lemma distinct_rtrancl_list_impl: \"distinct L \\<Longrightarrow> distinct ls \\<Longrightarrow> distinct (rtrancl_list_impl L ls)\"", "lemma distinct_trancl_list_impl: \"distinct L \\<Longrightarrow> distinct ls \\<Longrightarrow> distinct (trancl_list_impl L ls)\"", "lemma succ_rtran_correct: \"FiniteGraph.succ_rtran (list_graph_to_graph G) v = set (succ_rtran G v)\"", "lemma distinct_succ_rtran: \"wf_list_graph G \\<Longrightarrow> distinct (succ_rtran G v)\"", "lemma succ_rtran_set: \"set (succ_rtran G v) = {e2. (v,e2) \\<in> (set (edgesL G))\\<^sup>*}\"", "lemma distinct_succ_tran: \"wf_list_graph G \\<Longrightarrow> distinct (succ_tran G v)\"", "lemma succ_tran_set: \"set (succ_tran G v) = {e2. (v,e2) \\<in> (set (edgesL G))\\<^sup>+}\"", "lemma succ_tran_correct: \"FiniteGraph.succ_tran (list_graph_to_graph G) v = set (succ_tran G v)\"", "lemma num_reachable_correct:\n    \"wf_list_graph G \\<Longrightarrow> FiniteGraph.num_reachable (list_graph_to_graph G) v = num_reachable G v\"", "lemma num_reachable_norefl_correct:\n    \"wf_list_graph G \\<Longrightarrow> \n     FiniteGraph.num_reachable_norefl (list_graph_to_graph G) v = num_reachable_norefl G v\"", "lemma backlinks_alt: \"backlinks E = [(snd e, fst e). e \\<leftarrow> E]\"", "lemma backlinks_set: \"set (backlinks E) = {(e2, e1). (e1, e2) \\<in> set E}\"", "lemma undirected_nodes_set: \"set (edgesL (undirected G)) = set (edgesL G) \\<union> {(e2, e1). (e1, e2) \\<in> set (edgesL G)}\"", "lemma undirected_succ_tran_set: \"set (succ_tran (undirected G) v) = {e2. (v,e2) \\<in> (set (edgesL (undirected G)))\\<^sup>+}\"", "lemma backlinks_in_nodes_G: \"\\<lbrakk> fst ` set (edgesL G) \\<subseteq> set (nodesL G); snd ` set (edgesL G) \\<subseteq> set (nodesL G) \\<rbrakk> \\<Longrightarrow> \n    fst` set (edgesL (undirected G)) \\<subseteq> set (nodesL (undirected G)) \\<and> snd` set (edgesL (undirected G)) \\<subseteq> set (nodesL (undirected G))\"", "lemma backlinks_distinct: \"distinct E \\<Longrightarrow> distinct (backlinks E)\"", "lemma backlinks_subset: \"set (backlinks X) \\<subseteq> set (backlinks Y) \\<longleftrightarrow> set X \\<subseteq> set Y\"", "lemma backlinks_correct: \"FiniteGraph.backflows (set E) = set (backlinks E)\"", "lemma undirected_wf: \"wf_list_graph G \\<Longrightarrow> wf_list_graph (undirected G)\"", "lemma undirected_correct: \n    \"FiniteGraph.undirected (list_graph_to_graph G) = list_graph_to_graph (undirected G)\"", "lemmas wf_list_graph_wf =\n  add_node_wf\n  add_edge_wf\n  delete_node_wf\n  delete_edge_wf\n  delete_edges_wf\n  undirected_wf", "lemmas list_graph_correct =\n  add_node_correct\n  add_edge_correct\n  delete_node_correct\n  delete_edge_correct\n  delete_edges_correct\n  succ_rtran_correct\n  succ_tran_correct\n  num_reachable_correct\n  undirected_correct"], "translations": [["", "lemma wf_list_graph_iff_wf_graph: \"wf_graph (list_graph_to_graph G) \\<longleftrightarrow> wf_list_graph_axioms G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph (list_graph_to_graph G) = wf_list_graph_axioms G", "unfolding list_graph_to_graph_def wf_graph_def wf_list_graph_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((fst `\n      edges \\<lparr>nodes = set (nodesL G), edges = set (edgesL G)\\<rparr>\n      \\<subseteq> nodes\n                   \\<lparr>nodes = set (nodesL G),\n                      edges = set (edgesL G)\\<rparr> \\<and>\n      snd `\n      edges \\<lparr>nodes = set (nodesL G), edges = set (edgesL G)\\<rparr>\n      \\<subseteq> nodes\n                   \\<lparr>nodes = set (nodesL G),\n                      edges = set (edgesL G)\\<rparr>) \\<and>\n     finite\n      (edges\n        \\<lparr>nodes = set (nodesL G),\n           edges = set (edgesL G)\\<rparr>) \\<and>\n     finite\n      (nodes\n        \\<lparr>nodes = set (nodesL G), edges = set (edgesL G)\\<rparr>)) =\n    (fst ` set (edgesL G) \\<subseteq> set (nodesL G) \\<and>\n     snd ` set (edgesL G) \\<subseteq> set (nodesL G))", "by simp"], ["", "text\\<open>We say a @{typ \"'v list_graph\"} is valid if it fulfills the graph axioms and its lists are distinct\\<close>"], ["", "definition wf_list_graph::\"('v) list_graph \\<Rightarrow> bool\" where\n   \"wf_list_graph G = (distinct (nodesL G) \\<and> distinct (edgesL G) \\<and> wf_list_graph_axioms G)\""], ["", "section\\<open>FiniteListGraph operations\\<close>"], ["", "text \\<open>Adds a node to a graph.\\<close>"], ["", "definition add_node :: \"'v \\<Rightarrow> 'v list_graph \\<Rightarrow> 'v list_graph\" where \n    \"add_node v G = \\<lparr> nodesL = (if v \\<in> set (nodesL G) then nodesL G else v#nodesL G), edgesL=edgesL G \\<rparr>\""], ["", "text \\<open>Adds an edge to a graph.\\<close>"], ["", "definition add_edge :: \"'v \\<Rightarrow> 'v \\<Rightarrow> 'v list_graph \\<Rightarrow> 'v list_graph\" where \n    \"add_edge v v' G = (add_node v (add_node v' G)) \\<lparr>edgesL := (if (v, v') \\<in> set (edgesL G) then edgesL G else (v, v')#edgesL G) \\<rparr>\""], ["", "text \\<open>Deletes a node from a graph. Also deletes all adjacent edges.\\<close>"], ["", "definition delete_node :: \"'v \\<Rightarrow> 'v list_graph \\<Rightarrow> 'v list_graph\" where \n  \"delete_node v G = \\<lparr> \n    nodesL = remove1 v (nodesL G), edgesL = [(e1,e2) \\<leftarrow> (edgesL G). e1 \\<noteq> v \\<and> e2 \\<noteq> v]\n    \\<rparr>\""], ["", "text \\<open>Deletes an edge from a graph.\\<close>"], ["", "definition delete_edge :: \"'v \\<Rightarrow> 'v \\<Rightarrow> 'v list_graph \\<Rightarrow> 'v list_graph\" where \n    \"delete_edge v v' G = \\<lparr>nodesL = nodesL G, edgesL = [(e1,e2) \\<leftarrow> edgesL G. e1 \\<noteq> v \\<or> e2 \\<noteq> v'] \\<rparr>\""], ["", "fun delete_edges::\"'v list_graph \\<Rightarrow> ('v \\<times> 'v) list \\<Rightarrow> 'v list_graph\" where \n    \"delete_edges G [] = G\"|\n    \"delete_edges G ((v,v')#es) = delete_edges (delete_edge v v' G) es\""], ["", "text \\<open>extended graph operations\\<close>"], ["", "text \\<open>Reflexive transitive successors of a node. Or: All reachable nodes for v including v.\\<close>"], ["", "definition succ_rtran :: \"'v list_graph \\<Rightarrow> 'v \\<Rightarrow> 'v list\" where\n      \"succ_rtran G v = rtrancl_list_impl (edgesL G) [v]\""], ["", "text \\<open>Transitive successors of a node. Or: All reachable nodes for v.\\<close>"], ["", "definition succ_tran :: \"'v list_graph \\<Rightarrow> 'v \\<Rightarrow> 'v list\" where\n      \"succ_tran G v = trancl_list_impl (edgesL G) [v]\""], ["", "text \\<open>The number of reachable nodes from v\\<close>"], ["", "definition num_reachable :: \"'v list_graph \\<Rightarrow> 'v \\<Rightarrow> nat\" where\n      \"num_reachable G v = length (succ_tran G v)\""], ["", "definition num_reachable_norefl :: \"'v list_graph \\<Rightarrow> 'v \\<Rightarrow> nat\" where\n      \"num_reachable_norefl G v = length ([ x \\<leftarrow> succ_tran G v. x \\<noteq> v])\""], ["", "subsection\\<open>undirected graph simulation\\<close>"], ["", "text \\<open>Create undirected graph from directed graph by adding backward links\\<close>"], ["", "fun backlinks :: \"('v \\<times> 'v) list \\<Rightarrow> ('v \\<times> 'v) list\" where\n    \"backlinks [] = []\" |\n    \"backlinks ((e1, e2)#es) = (e2, e1)#(backlinks es)\""], ["", "definition undirected :: \"'v list_graph \\<Rightarrow> 'v list_graph\"\n    where \"undirected G \\<equiv> \\<lparr> nodesL = nodesL G, edgesL = remdups (edgesL G @ backlinks (edgesL G)) \\<rparr>\""], ["", "section\\<open>Correctness lemmata\\<close>\n\n  \\<comment> \\<open>add node\\<close>"], ["", "lemma add_node_wf: \"wf_list_graph G \\<Longrightarrow> wf_list_graph (add_node v G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_list_graph G \\<Longrightarrow>\n    wf_list_graph (FiniteListGraph.add_node v G)", "unfolding wf_list_graph_def wf_list_graph_axioms_def add_node_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (nodesL G) \\<and>\n    distinct (edgesL G) \\<and>\n    fst ` set (edgesL G) \\<subseteq> set (nodesL G) \\<and>\n    snd ` set (edgesL G) \\<subseteq> set (nodesL G) \\<Longrightarrow>\n    distinct\n     (nodesL\n       \\<lparr>nodesL =\n                 if v \\<in> set (nodesL G) then nodesL G else v # nodesL G,\n          edgesL = edgesL G\\<rparr>) \\<and>\n    distinct\n     (edgesL\n       \\<lparr>nodesL =\n                 if v \\<in> set (nodesL G) then nodesL G else v # nodesL G,\n          edgesL = edgesL G\\<rparr>) \\<and>\n    fst `\n    set (edgesL\n          \\<lparr>nodesL =\n                    if v \\<in> set (nodesL G) then nodesL G\n                    else v # nodesL G,\n             edgesL = edgesL G\\<rparr>)\n    \\<subseteq> set (nodesL\n                      \\<lparr>nodesL =\n                                if v \\<in> set (nodesL G) then nodesL G\n                                else v # nodesL G,\n                         edgesL = edgesL G\\<rparr>) \\<and>\n    snd `\n    set (edgesL\n          \\<lparr>nodesL =\n                    if v \\<in> set (nodesL G) then nodesL G\n                    else v # nodesL G,\n             edgesL = edgesL G\\<rparr>)\n    \\<subseteq> set (nodesL\n                      \\<lparr>nodesL =\n                                if v \\<in> set (nodesL G) then nodesL G\n                                else v # nodesL G,\n                         edgesL = edgesL G\\<rparr>)", "by auto"], ["", "lemma add_node_set_nodes: \"set (nodesL (add_node v G)) = set (nodesL G) \\<union> {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (nodesL (FiniteListGraph.add_node v G)) =\n    set (nodesL G) \\<union> {v}", "unfolding add_node_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (nodesL\n          \\<lparr>nodesL =\n                    if v \\<in> set (nodesL G) then nodesL G\n                    else v # nodesL G,\n             edgesL = edgesL G\\<rparr>) =\n    set (nodesL G) \\<union> {v}", "by auto"], ["", "lemma add_node_set_edges: \"set (edgesL (add_node v G)) = set (edgesL G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (edgesL (FiniteListGraph.add_node v G)) = set (edgesL G)", "unfolding add_node_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (edgesL\n          \\<lparr>nodesL =\n                    if v \\<in> set (nodesL G) then nodesL G\n                    else v # nodesL G,\n             edgesL = edgesL G\\<rparr>) =\n    set (edgesL G)", "by auto"], ["", "lemma add_node_correct: \"FiniteGraph.add_node v (list_graph_to_graph G) = list_graph_to_graph (add_node v G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FiniteGraph.add_node v (list_graph_to_graph G) =\n    list_graph_to_graph (FiniteListGraph.add_node v G)", "unfolding FiniteGraph.add_node_def list_graph_to_graph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>nodes =\n              {v} \\<union>\n              nodes\n               \\<lparr>nodes = set (nodesL G),\n                  edges = set (edgesL G)\\<rparr>,\n       edges =\n         edges\n          \\<lparr>nodes = set (nodesL G),\n             edges = set (edgesL G)\\<rparr>\\<rparr> =\n    \\<lparr>nodes = set (nodesL (FiniteListGraph.add_node v G)),\n       edges = set (edgesL (FiniteListGraph.add_node v G))\\<rparr>", "by (simp add: add_node_set_edges add_node_set_nodes)"], ["", "lemma add_node_wf2: \"wf_graph (list_graph_to_graph G) \\<Longrightarrow> wf_graph (list_graph_to_graph (add_node v G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph (list_graph_to_graph G) \\<Longrightarrow>\n    wf_graph (list_graph_to_graph (FiniteListGraph.add_node v G))", "by (subst add_node_correct[symmetric]) simp\n\n  \\<comment> \\<open>add edge\\<close>"], ["", "lemma add_edge_wf: \"wf_list_graph G \\<Longrightarrow> wf_list_graph (add_edge v v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_list_graph G \\<Longrightarrow>\n    wf_list_graph (FiniteListGraph.add_edge v v' G)", "unfolding wf_list_graph_def add_edge_def add_node_def wf_list_graph_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (nodesL G) \\<and>\n    distinct (edgesL G) \\<and>\n    fst ` set (edgesL G) \\<subseteq> set (nodesL G) \\<and>\n    snd ` set (edgesL G) \\<subseteq> set (nodesL G) \\<Longrightarrow>\n    distinct\n     (nodesL\n       (\\<lparr>nodesL =\n                  if v \\<in> set (nodesL\n                                   \\<lparr>nodesL =\n       if v' \\<in> set (nodesL G) then nodesL G else v' # nodesL G,\nedgesL = edgesL G\\<rparr>)\n                  then nodesL\n                        \\<lparr>nodesL =\n                                  if v' \\<in> set (nodesL G) then nodesL G\n                                  else v' # nodesL G,\n                           edgesL = edgesL G\\<rparr>\n                  else v #\n                       nodesL\n                        \\<lparr>nodesL =\n                                  if v' \\<in> set (nodesL G) then nodesL G\n                                  else v' # nodesL G,\n                           edgesL = edgesL G\\<rparr>,\n           edgesL =\n             edgesL\n              \\<lparr>nodesL =\n                        if v' \\<in> set (nodesL G) then nodesL G\n                        else v' # nodesL G,\n                 edgesL = edgesL G\\<rparr>\\<rparr>\n        \\<lparr>edgesL :=\n                  if (v, v') \\<in> set (edgesL G) then edgesL G\n                  else (v, v') # edgesL G\\<rparr>)) \\<and>\n    distinct\n     (edgesL\n       (\\<lparr>nodesL =\n                  if v \\<in> set (nodesL\n                                   \\<lparr>nodesL =\n       if v' \\<in> set (nodesL G) then nodesL G else v' # nodesL G,\nedgesL = edgesL G\\<rparr>)\n                  then nodesL\n                        \\<lparr>nodesL =\n                                  if v' \\<in> set (nodesL G) then nodesL G\n                                  else v' # nodesL G,\n                           edgesL = edgesL G\\<rparr>\n                  else v #\n                       nodesL\n                        \\<lparr>nodesL =\n                                  if v' \\<in> set (nodesL G) then nodesL G\n                                  else v' # nodesL G,\n                           edgesL = edgesL G\\<rparr>,\n           edgesL =\n             edgesL\n              \\<lparr>nodesL =\n                        if v' \\<in> set (nodesL G) then nodesL G\n                        else v' # nodesL G,\n                 edgesL = edgesL G\\<rparr>\\<rparr>\n        \\<lparr>edgesL :=\n                  if (v, v') \\<in> set (edgesL G) then edgesL G\n                  else (v, v') # edgesL G\\<rparr>)) \\<and>\n    fst `\n    set (edgesL\n          (\\<lparr>nodesL =\n                     if v \\<in> set (nodesL\n\\<lparr>nodesL =\n          if v' \\<in> set (nodesL G) then nodesL G else v' # nodesL G,\n   edgesL = edgesL G\\<rparr>)\n                     then nodesL\n                           \\<lparr>nodesL =\n                                     if v' \\<in> set (nodesL G)\n                                     then nodesL G else v' # nodesL G,\n                              edgesL = edgesL G\\<rparr>\n                     else v #\n                          nodesL\n                           \\<lparr>nodesL =\n                                     if v' \\<in> set (nodesL G)\n                                     then nodesL G else v' # nodesL G,\n                              edgesL = edgesL G\\<rparr>,\n              edgesL =\n                edgesL\n                 \\<lparr>nodesL =\n                           if v' \\<in> set (nodesL G) then nodesL G\n                           else v' # nodesL G,\n                    edgesL = edgesL G\\<rparr>\\<rparr>\n           \\<lparr>edgesL :=\n                     if (v, v') \\<in> set (edgesL G) then edgesL G\n                     else (v, v') # edgesL G\\<rparr>))\n    \\<subseteq> set (nodesL\n                      (\\<lparr>nodesL =\n                                 if v \\<in> set\n       (nodesL\n         \\<lparr>nodesL =\n                   if v' \\<in> set (nodesL G) then nodesL G\n                   else v' # nodesL G,\n            edgesL = edgesL G\\<rparr>)\n                                 then nodesL\n \\<lparr>nodesL =\n           if v' \\<in> set (nodesL G) then nodesL G else v' # nodesL G,\n    edgesL = edgesL G\\<rparr>\n                                 else v #\nnodesL\n \\<lparr>nodesL =\n           if v' \\<in> set (nodesL G) then nodesL G else v' # nodesL G,\n    edgesL = edgesL G\\<rparr>,\n                          edgesL =\n                            edgesL\n                             \\<lparr>nodesL =\n if v' \\<in> set (nodesL G) then nodesL G else v' # nodesL G,\n                                edgesL = edgesL G\\<rparr>\\<rparr>\n                       \\<lparr>edgesL :=\n                                 if (v, v') \\<in> set (edgesL G)\n                                 then edgesL G\n                                 else (v, v') # edgesL G\\<rparr>)) \\<and>\n    snd `\n    set (edgesL\n          (\\<lparr>nodesL =\n                     if v \\<in> set (nodesL\n\\<lparr>nodesL =\n          if v' \\<in> set (nodesL G) then nodesL G else v' # nodesL G,\n   edgesL = edgesL G\\<rparr>)\n                     then nodesL\n                           \\<lparr>nodesL =\n                                     if v' \\<in> set (nodesL G)\n                                     then nodesL G else v' # nodesL G,\n                              edgesL = edgesL G\\<rparr>\n                     else v #\n                          nodesL\n                           \\<lparr>nodesL =\n                                     if v' \\<in> set (nodesL G)\n                                     then nodesL G else v' # nodesL G,\n                              edgesL = edgesL G\\<rparr>,\n              edgesL =\n                edgesL\n                 \\<lparr>nodesL =\n                           if v' \\<in> set (nodesL G) then nodesL G\n                           else v' # nodesL G,\n                    edgesL = edgesL G\\<rparr>\\<rparr>\n           \\<lparr>edgesL :=\n                     if (v, v') \\<in> set (edgesL G) then edgesL G\n                     else (v, v') # edgesL G\\<rparr>))\n    \\<subseteq> set (nodesL\n                      (\\<lparr>nodesL =\n                                 if v \\<in> set\n       (nodesL\n         \\<lparr>nodesL =\n                   if v' \\<in> set (nodesL G) then nodesL G\n                   else v' # nodesL G,\n            edgesL = edgesL G\\<rparr>)\n                                 then nodesL\n \\<lparr>nodesL =\n           if v' \\<in> set (nodesL G) then nodesL G else v' # nodesL G,\n    edgesL = edgesL G\\<rparr>\n                                 else v #\nnodesL\n \\<lparr>nodesL =\n           if v' \\<in> set (nodesL G) then nodesL G else v' # nodesL G,\n    edgesL = edgesL G\\<rparr>,\n                          edgesL =\n                            edgesL\n                             \\<lparr>nodesL =\n if v' \\<in> set (nodesL G) then nodesL G else v' # nodesL G,\n                                edgesL = edgesL G\\<rparr>\\<rparr>\n                       \\<lparr>edgesL :=\n                                 if (v, v') \\<in> set (edgesL G)\n                                 then edgesL G\n                                 else (v, v') # edgesL G\\<rparr>))", "by auto"], ["", "lemma add_edge_set_nodes: \"set (nodesL (add_edge v v' G)) = set (nodesL G) \\<union> {v,v'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (nodesL (FiniteListGraph.add_edge v v' G)) =\n    set (nodesL G) \\<union> {v, v'}", "unfolding add_edge_def add_node_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (nodesL\n          (\\<lparr>nodesL =\n                     if v \\<in> set (nodesL\n\\<lparr>nodesL =\n          if v' \\<in> set (nodesL G) then nodesL G else v' # nodesL G,\n   edgesL = edgesL G\\<rparr>)\n                     then nodesL\n                           \\<lparr>nodesL =\n                                     if v' \\<in> set (nodesL G)\n                                     then nodesL G else v' # nodesL G,\n                              edgesL = edgesL G\\<rparr>\n                     else v #\n                          nodesL\n                           \\<lparr>nodesL =\n                                     if v' \\<in> set (nodesL G)\n                                     then nodesL G else v' # nodesL G,\n                              edgesL = edgesL G\\<rparr>,\n              edgesL =\n                edgesL\n                 \\<lparr>nodesL =\n                           if v' \\<in> set (nodesL G) then nodesL G\n                           else v' # nodesL G,\n                    edgesL = edgesL G\\<rparr>\\<rparr>\n           \\<lparr>edgesL :=\n                     if (v, v') \\<in> set (edgesL G) then edgesL G\n                     else (v, v') # edgesL G\\<rparr>)) =\n    set (nodesL G) \\<union> {v, v'}", "by auto"], ["", "lemma add_edge_set_edges: \"set (edgesL (add_edge v v' G)) = set (edgesL G) \\<union> {(v,v')}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (edgesL (FiniteListGraph.add_edge v v' G)) =\n    set (edgesL G) \\<union> {(v, v')}", "unfolding add_edge_def add_node_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (edgesL\n          (\\<lparr>nodesL =\n                     if v \\<in> set (nodesL\n\\<lparr>nodesL =\n          if v' \\<in> set (nodesL G) then nodesL G else v' # nodesL G,\n   edgesL = edgesL G\\<rparr>)\n                     then nodesL\n                           \\<lparr>nodesL =\n                                     if v' \\<in> set (nodesL G)\n                                     then nodesL G else v' # nodesL G,\n                              edgesL = edgesL G\\<rparr>\n                     else v #\n                          nodesL\n                           \\<lparr>nodesL =\n                                     if v' \\<in> set (nodesL G)\n                                     then nodesL G else v' # nodesL G,\n                              edgesL = edgesL G\\<rparr>,\n              edgesL =\n                edgesL\n                 \\<lparr>nodesL =\n                           if v' \\<in> set (nodesL G) then nodesL G\n                           else v' # nodesL G,\n                    edgesL = edgesL G\\<rparr>\\<rparr>\n           \\<lparr>edgesL :=\n                     if (v, v') \\<in> set (edgesL G) then edgesL G\n                     else (v, v') # edgesL G\\<rparr>)) =\n    set (edgesL G) \\<union> {(v, v')}", "by auto"], ["", "lemma add_edge_correct: \"FiniteGraph.add_edge v v' (list_graph_to_graph G) = list_graph_to_graph (add_edge v v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FiniteGraph.add_edge v v' (list_graph_to_graph G) =\n    list_graph_to_graph (FiniteListGraph.add_edge v v' G)", "unfolding FiniteGraph.add_edge_def add_edge_def list_graph_to_graph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>nodes =\n              nodes\n               \\<lparr>nodes = set (nodesL G),\n                  edges = set (edgesL G)\\<rparr> \\<union>\n              {v, v'},\n       edges =\n         {(v, v')} \\<union>\n         edges\n          \\<lparr>nodes = set (nodesL G),\n             edges = set (edgesL G)\\<rparr>\\<rparr> =\n    \\<lparr>nodes =\n              set (nodesL\n                    (FiniteListGraph.add_node v\n                      (FiniteListGraph.add_node v' G)\n                     \\<lparr>edgesL :=\n                               if (v, v') \\<in> set (edgesL G) then edgesL G\n                               else (v, v') # edgesL G\\<rparr>)),\n       edges =\n         set (edgesL\n               (FiniteListGraph.add_node v (FiniteListGraph.add_node v' G)\n                \\<lparr>edgesL :=\n                          if (v, v') \\<in> set (edgesL G) then edgesL G\n                          else (v, v') # edgesL G\\<rparr>))\\<rparr>", "by (auto simp: add_node_set_nodes)"], ["", "lemma add_edge_wf2: \"wf_graph (list_graph_to_graph G) \\<Longrightarrow> wf_graph (list_graph_to_graph (add_edge v v' G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph (list_graph_to_graph G) \\<Longrightarrow>\n    wf_graph (list_graph_to_graph (FiniteListGraph.add_edge v v' G))", "by (subst add_edge_correct[symmetric]) simp\n\n  \\<comment> \\<open>delete node\\<close>"], ["", "lemma delete_node_wf: \"wf_list_graph G \\<Longrightarrow> wf_list_graph (delete_node v G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_list_graph G \\<Longrightarrow>\n    wf_list_graph (FiniteListGraph.delete_node v G)", "unfolding wf_list_graph_def delete_node_def wf_list_graph_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (nodesL G) \\<and>\n    distinct (edgesL G) \\<and>\n    fst ` set (edgesL G) \\<subseteq> set (nodesL G) \\<and>\n    snd ` set (edgesL G) \\<subseteq> set (nodesL G) \\<Longrightarrow>\n    distinct\n     (nodesL\n       \\<lparr>nodesL = remove1 v (nodesL G),\n          edgesL =\n            filter (\\<lambda>(e1, e2). e1 \\<noteq> v \\<and> e2 \\<noteq> v)\n             (edgesL G)\\<rparr>) \\<and>\n    distinct\n     (edgesL\n       \\<lparr>nodesL = remove1 v (nodesL G),\n          edgesL =\n            filter (\\<lambda>(e1, e2). e1 \\<noteq> v \\<and> e2 \\<noteq> v)\n             (edgesL G)\\<rparr>) \\<and>\n    fst `\n    set (edgesL\n          \\<lparr>nodesL = remove1 v (nodesL G),\n             edgesL =\n               filter\n                (\\<lambda>(e1, e2). e1 \\<noteq> v \\<and> e2 \\<noteq> v)\n                (edgesL G)\\<rparr>)\n    \\<subseteq> set (nodesL\n                      \\<lparr>nodesL = remove1 v (nodesL G),\n                         edgesL =\n                           filter\n                            (\\<lambda>(e1, e2).\n                                e1 \\<noteq> v \\<and> e2 \\<noteq> v)\n                            (edgesL G)\\<rparr>) \\<and>\n    snd `\n    set (edgesL\n          \\<lparr>nodesL = remove1 v (nodesL G),\n             edgesL =\n               filter\n                (\\<lambda>(e1, e2). e1 \\<noteq> v \\<and> e2 \\<noteq> v)\n                (edgesL G)\\<rparr>)\n    \\<subseteq> set (nodesL\n                      \\<lparr>nodesL = remove1 v (nodesL G),\n                         edgesL =\n                           filter\n                            (\\<lambda>(e1, e2).\n                                e1 \\<noteq> v \\<and> e2 \\<noteq> v)\n                            (edgesL G)\\<rparr>)", "by auto"], ["", "lemma delete_node_set_edges:\n    \"set (edgesL (delete_node v G)) = {(a,b). (a, b) \\<in> set (edgesL G) \\<and> a \\<noteq> v \\<and> b \\<noteq> v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (edgesL (FiniteListGraph.delete_node v G)) =\n    {(a, b).\n     (a, b) \\<in> set (edgesL G) \\<and> a \\<noteq> v \\<and> b \\<noteq> v}", "unfolding delete_node_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (edgesL\n          \\<lparr>nodesL = remove1 v (nodesL G),\n             edgesL =\n               filter\n                (\\<lambda>(e1, e2). e1 \\<noteq> v \\<and> e2 \\<noteq> v)\n                (edgesL G)\\<rparr>) =\n    {(a, b).\n     (a, b) \\<in> set (edgesL G) \\<and> a \\<noteq> v \\<and> b \\<noteq> v}", "by auto"], ["", "lemma delete_node_correct:\n    assumes \"wf_list_graph G\"\n    shows \"FiniteGraph.delete_node v (list_graph_to_graph G) = list_graph_to_graph (delete_node v G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FiniteGraph.delete_node v (list_graph_to_graph G) =\n    list_graph_to_graph (FiniteListGraph.delete_node v G)", "using assms"], ["proof (prove)\nusing this:\n  wf_list_graph G\n\ngoal (1 subgoal):\n 1. FiniteGraph.delete_node v (list_graph_to_graph G) =\n    list_graph_to_graph (FiniteListGraph.delete_node v G)", "unfolding FiniteGraph.delete_node_def delete_node_def list_graph_to_graph_def wf_list_graph_def"], ["proof (prove)\nusing this:\n  distinct (nodesL G) \\<and>\n  distinct (edgesL G) \\<and> wf_list_graph_axioms G\n\ngoal (1 subgoal):\n 1. \\<lparr>nodes =\n              nodes\n               \\<lparr>nodes = set (nodesL G),\n                  edges = set (edgesL G)\\<rparr> -\n              {v},\n       edges =\n         {(e1, e2).\n          (e1, e2)\n          \\<in> edges\n                 \\<lparr>nodes = set (nodesL G),\n                    edges = set (edgesL G)\\<rparr> \\<and>\n          e1 \\<noteq> v \\<and> e2 \\<noteq> v}\\<rparr> =\n    \\<lparr>nodes =\n              set (nodesL\n                    \\<lparr>nodesL = remove1 v (nodesL G),\n                       edgesL =\n                         filter\n                          (\\<lambda>(e1, e2).\n                              e1 \\<noteq> v \\<and> e2 \\<noteq> v)\n                          (edgesL G)\\<rparr>),\n       edges =\n         set (edgesL\n               \\<lparr>nodesL = remove1 v (nodesL G),\n                  edgesL =\n                    filter\n                     (\\<lambda>(e1, e2). e1 \\<noteq> v \\<and> e2 \\<noteq> v)\n                     (edgesL G)\\<rparr>)\\<rparr>", "by auto\n\n  \\<comment> \\<open>delete edge\\<close>"], ["", "lemma delete_edge_set_nodes: \"set (nodesL (delete_edge v v' G)) = set (nodesL G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (nodesL (FiniteListGraph.delete_edge v v' G)) = set (nodesL G)", "unfolding delete_edge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (nodesL\n          \\<lparr>nodesL = nodesL G,\n             edgesL =\n               filter\n                (\\<lambda>(e1, e2). e1 \\<noteq> v \\<or> e2 \\<noteq> v')\n                (edgesL G)\\<rparr>) =\n    set (nodesL G)", "by simp"], ["", "lemma delete_edge_set_edges:\n    \"set (edgesL (delete_edge v v' G)) = {(a,b). (a,b) \\<in> set (edgesL G) \\<and> (a,b) \\<noteq> (v,v')}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (edgesL (FiniteListGraph.delete_edge v v' G)) =\n    {(a, b). (a, b) \\<in> set (edgesL G) \\<and> (a, b) \\<noteq> (v, v')}", "unfolding delete_edge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (edgesL\n          \\<lparr>nodesL = nodesL G,\n             edgesL =\n               filter\n                (\\<lambda>(e1, e2). e1 \\<noteq> v \\<or> e2 \\<noteq> v')\n                (edgesL G)\\<rparr>) =\n    {(a, b). (a, b) \\<in> set (edgesL G) \\<and> (a, b) \\<noteq> (v, v')}", "by auto"], ["", "lemma delete_edge_set_edges2:\n    \"set (edgesL (delete_edge v v' G)) = set (edgesL G) - {(v,v')}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (edgesL (FiniteListGraph.delete_edge v v' G)) =\n    set (edgesL G) - {(v, v')}", "by (auto simp:delete_edge_set_edges)"], ["", "lemma delete_edge_wf: \"wf_list_graph G \\<Longrightarrow> wf_list_graph (delete_edge v v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_list_graph G \\<Longrightarrow>\n    wf_list_graph (FiniteListGraph.delete_edge v v' G)", "unfolding wf_list_graph_def delete_edge_def wf_list_graph_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (nodesL G) \\<and>\n    distinct (edgesL G) \\<and>\n    fst ` set (edgesL G) \\<subseteq> set (nodesL G) \\<and>\n    snd ` set (edgesL G) \\<subseteq> set (nodesL G) \\<Longrightarrow>\n    distinct\n     (nodesL\n       \\<lparr>nodesL = nodesL G,\n          edgesL =\n            filter (\\<lambda>(e1, e2). e1 \\<noteq> v \\<or> e2 \\<noteq> v')\n             (edgesL G)\\<rparr>) \\<and>\n    distinct\n     (edgesL\n       \\<lparr>nodesL = nodesL G,\n          edgesL =\n            filter (\\<lambda>(e1, e2). e1 \\<noteq> v \\<or> e2 \\<noteq> v')\n             (edgesL G)\\<rparr>) \\<and>\n    fst `\n    set (edgesL\n          \\<lparr>nodesL = nodesL G,\n             edgesL =\n               filter\n                (\\<lambda>(e1, e2). e1 \\<noteq> v \\<or> e2 \\<noteq> v')\n                (edgesL G)\\<rparr>)\n    \\<subseteq> set (nodesL\n                      \\<lparr>nodesL = nodesL G,\n                         edgesL =\n                           filter\n                            (\\<lambda>(e1, e2).\n                                e1 \\<noteq> v \\<or> e2 \\<noteq> v')\n                            (edgesL G)\\<rparr>) \\<and>\n    snd `\n    set (edgesL\n          \\<lparr>nodesL = nodesL G,\n             edgesL =\n               filter\n                (\\<lambda>(e1, e2). e1 \\<noteq> v \\<or> e2 \\<noteq> v')\n                (edgesL G)\\<rparr>)\n    \\<subseteq> set (nodesL\n                      \\<lparr>nodesL = nodesL G,\n                         edgesL =\n                           filter\n                            (\\<lambda>(e1, e2).\n                                e1 \\<noteq> v \\<or> e2 \\<noteq> v')\n                            (edgesL G)\\<rparr>)", "by auto"], ["", "lemma delete_edge_length: \"length (edgesL (delete_edge v v' G)) \\<le> length (edgesL G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (edgesL (FiniteListGraph.delete_edge v v' G))\n    \\<le> length (edgesL G)", "unfolding delete_edge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (edgesL\n       \\<lparr>nodesL = nodesL G,\n          edgesL =\n            filter (\\<lambda>(e1, e2). e1 \\<noteq> v \\<or> e2 \\<noteq> v')\n             (edgesL G)\\<rparr>)\n    \\<le> length (edgesL G)", "by simp"], ["", "lemma delete_edge_commute: \"delete_edge a1 a2 (delete_edge b1 b2 G) = delete_edge b1 b2 (delete_edge a1 a2 G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FiniteListGraph.delete_edge a1 a2\n     (FiniteListGraph.delete_edge b1 b2 G) =\n    FiniteListGraph.delete_edge b1 b2 (FiniteListGraph.delete_edge a1 a2 G)", "unfolding delete_edge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>nodesL =\n              nodesL\n               \\<lparr>nodesL = nodesL G,\n                  edgesL =\n                    filter\n                     (\\<lambda>(e1, e2).\n                         e1 \\<noteq> b1 \\<or> e2 \\<noteq> b2)\n                     (edgesL G)\\<rparr>,\n       edgesL =\n         filter (\\<lambda>(e1, e2). e1 \\<noteq> a1 \\<or> e2 \\<noteq> a2)\n          (edgesL\n            \\<lparr>nodesL = nodesL G,\n               edgesL =\n                 filter\n                  (\\<lambda>(e1, e2). e1 \\<noteq> b1 \\<or> e2 \\<noteq> b2)\n                  (edgesL G)\\<rparr>)\\<rparr> =\n    \\<lparr>nodesL =\n              nodesL\n               \\<lparr>nodesL = nodesL G,\n                  edgesL =\n                    filter\n                     (\\<lambda>(e1, e2).\n                         e1 \\<noteq> a1 \\<or> e2 \\<noteq> a2)\n                     (edgesL G)\\<rparr>,\n       edgesL =\n         filter (\\<lambda>(e1, e2). e1 \\<noteq> b1 \\<or> e2 \\<noteq> b2)\n          (edgesL\n            \\<lparr>nodesL = nodesL G,\n               edgesL =\n                 filter\n                  (\\<lambda>(e1, e2). e1 \\<noteq> a1 \\<or> e2 \\<noteq> a2)\n                  (edgesL G)\\<rparr>)\\<rparr>", "by simp metis"], ["", "(* auto doesn't seem to like filter_cong *)"], ["", "lemma delete_edge_correct: \"FiniteGraph.delete_edge v v' (list_graph_to_graph G) = list_graph_to_graph (delete_edge v v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FiniteGraph.delete_edge v v' (list_graph_to_graph G) =\n    list_graph_to_graph (FiniteListGraph.delete_edge v v' G)", "unfolding FiniteGraph.delete_edge_def delete_edge_def list_graph_to_graph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>nodes =\n              nodes\n               \\<lparr>nodes = set (nodesL G),\n                  edges = set (edgesL G)\\<rparr>,\n       edges =\n         {(e1, e2).\n          (e1, e2)\n          \\<in> edges\n                 \\<lparr>nodes = set (nodesL G),\n                    edges = set (edgesL G)\\<rparr> \\<and>\n          (e1, e2) \\<noteq> (v, v')}\\<rparr> =\n    \\<lparr>nodes =\n              set (nodesL\n                    \\<lparr>nodesL = nodesL G,\n                       edgesL =\n                         filter\n                          (\\<lambda>(e1, e2).\n                              e1 \\<noteq> v \\<or> e2 \\<noteq> v')\n                          (edgesL G)\\<rparr>),\n       edges =\n         set (edgesL\n               \\<lparr>nodesL = nodesL G,\n                  edgesL =\n                    filter\n                     (\\<lambda>(e1, e2). e1 \\<noteq> v \\<or> e2 \\<noteq> v')\n                     (edgesL G)\\<rparr>)\\<rparr>", "by auto"], ["", "lemma delete_edge_wf2: \"wf_graph (list_graph_to_graph G) \\<Longrightarrow> wf_graph (list_graph_to_graph (delete_edge v v' G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph (list_graph_to_graph G) \\<Longrightarrow>\n    wf_graph (list_graph_to_graph (FiniteListGraph.delete_edge v v' G))", "by (subst delete_edge_correct[symmetric]) simp\n\n  \\<comment> \\<open>delete edges\\<close>"], ["", "lemma delete_edges_wf: \"wf_list_graph G \\<Longrightarrow> wf_list_graph (delete_edges G E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_list_graph G \\<Longrightarrow>\n    wf_list_graph (FiniteListGraph.delete_edges G E)", "by (induction E arbitrary: G) (auto simp: delete_edge_wf)"], ["", "lemma delete_edges_set_nodes: \"set (nodesL (delete_edges G E)) = set (nodesL G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (nodesL (FiniteListGraph.delete_edges G E)) = set (nodesL G)", "by (induction E arbitrary: G) (auto simp: delete_edge_set_nodes)"], ["", "lemma delete_edges_nodes: \"nodesL (delete_edges G es) = nodesL G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodesL (FiniteListGraph.delete_edges G es) = nodesL G", "by (induction es arbitrary: G) (auto simp: delete_edge_def)"], ["", "lemma delete_edges_set_edges: \"set (edgesL (delete_edges G E)) = set (edgesL G) - set E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (edgesL (FiniteListGraph.delete_edges G E)) = set (edgesL G) - set E", "by (induction E arbitrary: G) (auto simp: delete_edge_def delete_edge_set_nodes)"], ["", "lemma delete_edges_set_edges2:\n    \"set (edgesL (delete_edges G E)) = {(a,b). (a,b) \\<in> set (edgesL G) \\<and> (a,b) \\<notin> set E}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (edgesL (FiniteListGraph.delete_edges G E)) =\n    {(a, b). (a, b) \\<in> set (edgesL G) \\<and> (a, b) \\<notin> set E}", "by (auto simp: delete_edges_set_edges)"], ["", "lemma delete_edges_length: \"length (edgesL (delete_edges G f)) \\<le> length (edgesL G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (edgesL (FiniteListGraph.delete_edges G f))\n    \\<le> length (edgesL G)", "proof (induction f arbitrary:G)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>G.\n       length (edgesL (FiniteListGraph.delete_edges G []))\n       \\<le> length (edgesL G)\n 2. \\<And>a f G.\n       (\\<And>G.\n           length (edgesL (FiniteListGraph.delete_edges G f))\n           \\<le> length (edgesL G)) \\<Longrightarrow>\n       length (edgesL (FiniteListGraph.delete_edges G (a # f)))\n       \\<le> length (edgesL G)", "case (Cons f fs)"], ["proof (state)\nthis:\n  length (edgesL (FiniteListGraph.delete_edges ?G fs))\n  \\<le> length (edgesL ?G)\n\ngoal (2 subgoals):\n 1. \\<And>G.\n       length (edgesL (FiniteListGraph.delete_edges G []))\n       \\<le> length (edgesL G)\n 2. \\<And>a f G.\n       (\\<And>G.\n           length (edgesL (FiniteListGraph.delete_edges G f))\n           \\<le> length (edgesL G)) \\<Longrightarrow>\n       length (edgesL (FiniteListGraph.delete_edges G (a # f)))\n       \\<le> length (edgesL G)", "thus ?case"], ["proof (prove)\nusing this:\n  length (edgesL (FiniteListGraph.delete_edges ?G fs))\n  \\<le> length (edgesL ?G)\n\ngoal (1 subgoal):\n 1. length (edgesL (FiniteListGraph.delete_edges G (f # fs)))\n    \\<le> length (edgesL G)", "apply (cases f, hypsubst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>G.\n                   length (edgesL (FiniteListGraph.delete_edges G fs))\n                   \\<le> length (edgesL G);\n        \\<And>G.\n           length (edgesL (FiniteListGraph.delete_edges G fs))\n           \\<le> length (edgesL G);\n        f = (a, b)\\<rbrakk>\n       \\<Longrightarrow> length\n                          (edgesL\n                            (FiniteListGraph.delete_edges G ((a, b) # fs)))\n                         \\<le> length (edgesL G)", "apply (subst delete_edges.simps(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>G.\n                   length (edgesL (FiniteListGraph.delete_edges G fs))\n                   \\<le> length (edgesL G);\n        \\<And>G.\n           length (edgesL (FiniteListGraph.delete_edges G fs))\n           \\<le> length (edgesL G);\n        f = (a, b)\\<rbrakk>\n       \\<Longrightarrow> length\n                          (edgesL\n                            (FiniteListGraph.delete_edges\n                              (FiniteListGraph.delete_edge a b G) fs))\n                         \\<le> length (edgesL G)", "apply (metis delete_edge_length le_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  length (edgesL (FiniteListGraph.delete_edges G (f # fs)))\n  \\<le> length (edgesL G)\n\ngoal (1 subgoal):\n 1. \\<And>G.\n       length (edgesL (FiniteListGraph.delete_edges G []))\n       \\<le> length (edgesL G)", "qed simp"], ["", "lemma delete_edges_chain: \"delete_edges G (as @ bs) = delete_edges (delete_edges G as) bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FiniteListGraph.delete_edges G (as @ bs) =\n    FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G as) bs", "proof (induction as arbitrary: bs G)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs G.\n       FiniteListGraph.delete_edges G ([] @ bs) =\n       FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G []) bs\n 2. \\<And>a as bs G.\n       (\\<And>bs G.\n           FiniteListGraph.delete_edges G (as @ bs) =\n           FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G as)\n            bs) \\<Longrightarrow>\n       FiniteListGraph.delete_edges G ((a # as) @ bs) =\n       FiniteListGraph.delete_edges\n        (FiniteListGraph.delete_edges G (a # as)) bs", "case (Cons f fs)"], ["proof (state)\nthis:\n  FiniteListGraph.delete_edges ?G (fs @ ?bs) =\n  FiniteListGraph.delete_edges (FiniteListGraph.delete_edges ?G fs) ?bs\n\ngoal (2 subgoals):\n 1. \\<And>bs G.\n       FiniteListGraph.delete_edges G ([] @ bs) =\n       FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G []) bs\n 2. \\<And>a as bs G.\n       (\\<And>bs G.\n           FiniteListGraph.delete_edges G (as @ bs) =\n           FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G as)\n            bs) \\<Longrightarrow>\n       FiniteListGraph.delete_edges G ((a # as) @ bs) =\n       FiniteListGraph.delete_edges\n        (FiniteListGraph.delete_edges G (a # as)) bs", "thus ?case"], ["proof (prove)\nusing this:\n  FiniteListGraph.delete_edges ?G (fs @ ?bs) =\n  FiniteListGraph.delete_edges (FiniteListGraph.delete_edges ?G fs) ?bs\n\ngoal (1 subgoal):\n 1. FiniteListGraph.delete_edges G ((f # fs) @ bs) =\n    FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G (f # fs))\n     bs", "by (cases f) auto"], ["proof (state)\nthis:\n  FiniteListGraph.delete_edges G ((f # fs) @ bs) =\n  FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G (f # fs)) bs\n\ngoal (1 subgoal):\n 1. \\<And>bs G.\n       FiniteListGraph.delete_edges G ([] @ bs) =\n       FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G []) bs", "qed simp"], ["", "lemma delete_edges_delete_edge_commute:\n    \"delete_edges (delete_edge a1 a2 G) as = delete_edge a1 a2 (delete_edges G as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FiniteListGraph.delete_edges (FiniteListGraph.delete_edge a1 a2 G) as =\n    FiniteListGraph.delete_edge a1 a2 (FiniteListGraph.delete_edges G as)", "proof (induction as arbitrary: G a1 a2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>G a1 a2.\n       FiniteListGraph.delete_edges (FiniteListGraph.delete_edge a1 a2 G)\n        [] =\n       FiniteListGraph.delete_edge a1 a2 (FiniteListGraph.delete_edges G [])\n 2. \\<And>a as G a1 a2.\n       (\\<And>G a1 a2.\n           FiniteListGraph.delete_edges\n            (FiniteListGraph.delete_edge a1 a2 G) as =\n           FiniteListGraph.delete_edge a1 a2\n            (FiniteListGraph.delete_edges G as)) \\<Longrightarrow>\n       FiniteListGraph.delete_edges (FiniteListGraph.delete_edge a1 a2 G)\n        (a # as) =\n       FiniteListGraph.delete_edge a1 a2\n        (FiniteListGraph.delete_edges G (a # as))", "case (Cons f fs)"], ["proof (state)\nthis:\n  FiniteListGraph.delete_edges (FiniteListGraph.delete_edge ?a1.0 ?a2.0 ?G)\n   fs =\n  FiniteListGraph.delete_edge ?a1.0 ?a2.0\n   (FiniteListGraph.delete_edges ?G fs)\n\ngoal (2 subgoals):\n 1. \\<And>G a1 a2.\n       FiniteListGraph.delete_edges (FiniteListGraph.delete_edge a1 a2 G)\n        [] =\n       FiniteListGraph.delete_edge a1 a2 (FiniteListGraph.delete_edges G [])\n 2. \\<And>a as G a1 a2.\n       (\\<And>G a1 a2.\n           FiniteListGraph.delete_edges\n            (FiniteListGraph.delete_edge a1 a2 G) as =\n           FiniteListGraph.delete_edge a1 a2\n            (FiniteListGraph.delete_edges G as)) \\<Longrightarrow>\n       FiniteListGraph.delete_edges (FiniteListGraph.delete_edge a1 a2 G)\n        (a # as) =\n       FiniteListGraph.delete_edge a1 a2\n        (FiniteListGraph.delete_edges G (a # as))", "thus ?case"], ["proof (prove)\nusing this:\n  FiniteListGraph.delete_edges (FiniteListGraph.delete_edge ?a1.0 ?a2.0 ?G)\n   fs =\n  FiniteListGraph.delete_edge ?a1.0 ?a2.0\n   (FiniteListGraph.delete_edges ?G fs)\n\ngoal (1 subgoal):\n 1. FiniteListGraph.delete_edges (FiniteListGraph.delete_edge a1 a2 G)\n     (f # fs) =\n    FiniteListGraph.delete_edge a1 a2\n     (FiniteListGraph.delete_edges G (f # fs))", "by (cases f) (simp add: delete_edge_commute)"], ["proof (state)\nthis:\n  FiniteListGraph.delete_edges (FiniteListGraph.delete_edge a1 a2 G)\n   (f # fs) =\n  FiniteListGraph.delete_edge a1 a2\n   (FiniteListGraph.delete_edges G (f # fs))\n\ngoal (1 subgoal):\n 1. \\<And>G a1 a2.\n       FiniteListGraph.delete_edges (FiniteListGraph.delete_edge a1 a2 G)\n        [] =\n       FiniteListGraph.delete_edge a1 a2 (FiniteListGraph.delete_edges G [])", "qed simp"], ["", "lemma delete_edges_commute:\n    \"delete_edges (delete_edges G as) bs = delete_edges (delete_edges G bs) as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G as) bs =\n    FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G bs) as", "proof (induction as arbitrary: bs G)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs G.\n       FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G []) bs =\n       FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G bs) []\n 2. \\<And>a as bs G.\n       (\\<And>bs G.\n           FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G as)\n            bs =\n           FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G bs)\n            as) \\<Longrightarrow>\n       FiniteListGraph.delete_edges\n        (FiniteListGraph.delete_edges G (a # as)) bs =\n       FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G bs)\n        (a # as)", "case (Cons f fs)"], ["proof (state)\nthis:\n  FiniteListGraph.delete_edges (FiniteListGraph.delete_edges ?G fs) ?bs =\n  FiniteListGraph.delete_edges (FiniteListGraph.delete_edges ?G ?bs) fs\n\ngoal (2 subgoals):\n 1. \\<And>bs G.\n       FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G []) bs =\n       FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G bs) []\n 2. \\<And>a as bs G.\n       (\\<And>bs G.\n           FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G as)\n            bs =\n           FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G bs)\n            as) \\<Longrightarrow>\n       FiniteListGraph.delete_edges\n        (FiniteListGraph.delete_edges G (a # as)) bs =\n       FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G bs)\n        (a # as)", "thus ?case"], ["proof (prove)\nusing this:\n  FiniteListGraph.delete_edges (FiniteListGraph.delete_edges ?G fs) ?bs =\n  FiniteListGraph.delete_edges (FiniteListGraph.delete_edges ?G ?bs) fs\n\ngoal (1 subgoal):\n 1. FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G (f # fs))\n     bs =\n    FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G bs)\n     (f # fs)", "by (cases f) (simp add: delete_edges_delete_edge_commute)"], ["proof (state)\nthis:\n  FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G (f # fs))\n   bs =\n  FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G bs) (f # fs)\n\ngoal (1 subgoal):\n 1. \\<And>bs G.\n       FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G []) bs =\n       FiniteListGraph.delete_edges (FiniteListGraph.delete_edges G bs) []", "qed simp"], ["", "lemma delete_edges_as_filter:\n    \"delete_edges G l = \\<lparr> nodesL = nodesL G,  edgesL = [x \\<leftarrow> edgesL G. x \\<notin> set l] \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FiniteListGraph.delete_edges G l =\n    \\<lparr>nodesL = nodesL G,\n       edgesL = filter (\\<lambda>x. x \\<notin> set l) (edgesL G)\\<rparr>", "proof (induction l)"], ["proof (state)\ngoal (2 subgoals):\n 1. FiniteListGraph.delete_edges G [] =\n    \\<lparr>nodesL = nodesL G,\n       edgesL = filter (\\<lambda>x. x \\<notin> set []) (edgesL G)\\<rparr>\n 2. \\<And>a l.\n       FiniteListGraph.delete_edges G l =\n       \\<lparr>nodesL = nodesL G,\n          edgesL =\n            filter (\\<lambda>x. x \\<notin> set l)\n             (edgesL G)\\<rparr> \\<Longrightarrow>\n       FiniteListGraph.delete_edges G (a # l) =\n       \\<lparr>nodesL = nodesL G,\n          edgesL =\n            filter (\\<lambda>x. x \\<notin> set (a # l)) (edgesL G)\\<rparr>", "case (Cons f fs)"], ["proof (state)\nthis:\n  FiniteListGraph.delete_edges G fs =\n  \\<lparr>nodesL = nodesL G,\n     edgesL = filter (\\<lambda>x. x \\<notin> set fs) (edgesL G)\\<rparr>\n\ngoal (2 subgoals):\n 1. FiniteListGraph.delete_edges G [] =\n    \\<lparr>nodesL = nodesL G,\n       edgesL = filter (\\<lambda>x. x \\<notin> set []) (edgesL G)\\<rparr>\n 2. \\<And>a l.\n       FiniteListGraph.delete_edges G l =\n       \\<lparr>nodesL = nodesL G,\n          edgesL =\n            filter (\\<lambda>x. x \\<notin> set l)\n             (edgesL G)\\<rparr> \\<Longrightarrow>\n       FiniteListGraph.delete_edges G (a # l) =\n       \\<lparr>nodesL = nodesL G,\n          edgesL =\n            filter (\\<lambda>x. x \\<notin> set (a # l)) (edgesL G)\\<rparr>", "thus ?case"], ["proof (prove)\nusing this:\n  FiniteListGraph.delete_edges G fs =\n  \\<lparr>nodesL = nodesL G,\n     edgesL = filter (\\<lambda>x. x \\<notin> set fs) (edgesL G)\\<rparr>\n\ngoal (1 subgoal):\n 1. FiniteListGraph.delete_edges G (f # fs) =\n    \\<lparr>nodesL = nodesL G,\n       edgesL =\n         filter (\\<lambda>x. x \\<notin> set (f # fs)) (edgesL G)\\<rparr>", "apply (cases f)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>FiniteListGraph.delete_edges G fs =\n                \\<lparr>nodesL = nodesL G,\n                   edgesL =\n                     filter (\\<lambda>x. x \\<notin> set fs)\n                      (edgesL G)\\<rparr>;\n        f = (a, b)\\<rbrakk>\n       \\<Longrightarrow> FiniteListGraph.delete_edges G (f # fs) =\n                         \\<lparr>nodesL = nodesL G,\n                            edgesL =\n                              filter (\\<lambda>x. x \\<notin> set (f # fs))\n                               (edgesL G)\\<rparr>", "apply (simp add: delete_edges_delete_edge_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>FiniteListGraph.delete_edges G fs =\n                \\<lparr>nodesL = nodesL G,\n                   edgesL =\n                     filter (\\<lambda>x. x \\<notin> set fs)\n                      (edgesL G)\\<rparr>;\n        f = (a, b)\\<rbrakk>\n       \\<Longrightarrow> FiniteListGraph.delete_edge a b\n                          \\<lparr>nodesL = nodesL G,\n                             edgesL =\n                               filter (\\<lambda>x. x \\<notin> set fs)\n                                (edgesL G)\\<rparr> =\n                         \\<lparr>nodesL = nodesL G,\n                            edgesL =\n                              filter\n                               (\\<lambda>x.\n                                   x \\<noteq> (a, b) \\<and>\n                                   x \\<notin> set fs)\n                               (edgesL G)\\<rparr>", "apply (simp add: delete_edge_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>FiniteListGraph.delete_edges G fs =\n                \\<lparr>nodesL = nodesL G,\n                   edgesL =\n                     filter (\\<lambda>x. x \\<notin> set fs)\n                      (edgesL G)\\<rparr>;\n        f = (a, b)\\<rbrakk>\n       \\<Longrightarrow> filter\n                          (\\<lambda>x.\n                              x \\<notin> set fs \\<and>\n                              (case x of\n                               (e1, e2) \\<Rightarrow>\n                                 e1 = a \\<longrightarrow> e2 \\<noteq> b))\n                          (edgesL G) =\n                         filter\n                          (\\<lambda>x.\n                              x \\<noteq> (a, b) \\<and> x \\<notin> set fs)\n                          (edgesL G)", "apply (metis (lifting, full_types) prod.exhaust case_prodI split_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  FiniteListGraph.delete_edges G (f # fs) =\n  \\<lparr>nodesL = nodesL G,\n     edgesL =\n       filter (\\<lambda>x. x \\<notin> set (f # fs)) (edgesL G)\\<rparr>\n\ngoal (1 subgoal):\n 1. FiniteListGraph.delete_edges G [] =\n    \\<lparr>nodesL = nodesL G,\n       edgesL = filter (\\<lambda>x. x \\<notin> set []) (edgesL G)\\<rparr>", "qed simp"], ["", "declare delete_edges.simps[simp del]"], ["", "(*do not automatically expand definition*)"], ["", "lemma delete_edges_correct:\n    \"FiniteGraph.delete_edges (list_graph_to_graph G) (set E) = list_graph_to_graph (delete_edges G E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FiniteGraph.delete_edges (list_graph_to_graph G) (set E) =\n    list_graph_to_graph (FiniteListGraph.delete_edges G E)", "unfolding list_graph_to_graph_def FiniteGraph.delete_edges_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>nodes =\n              nodes\n               \\<lparr>nodes = set (nodesL G),\n                  edges = set (edgesL G)\\<rparr>,\n       edges =\n         {(e1, e2).\n          (e1, e2)\n          \\<in> edges\n                 \\<lparr>nodes = set (nodesL G),\n                    edges = set (edgesL G)\\<rparr> \\<and>\n          (e1, e2) \\<notin> set E}\\<rparr> =\n    \\<lparr>nodes = set (nodesL (FiniteListGraph.delete_edges G E)),\n       edges = set (edgesL (FiniteListGraph.delete_edges G E))\\<rparr>", "by (auto simp add: delete_edges_as_filter )"], ["", "lemma delete_edges_wf2:\n    \"wf_graph (list_graph_to_graph G) \\<Longrightarrow> wf_graph (list_graph_to_graph (delete_edges G E))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph (list_graph_to_graph G) \\<Longrightarrow>\n    wf_graph (list_graph_to_graph (FiniteListGraph.delete_edges G E))", "by (subst delete_edges_correct[symmetric]) simp\n\n  \\<comment> \\<open>helper about reflexive transitive closure impl\\<close>"], ["", "lemma distinct_relpow_impl:\n    \"distinct L \\<Longrightarrow> distinct new \\<Longrightarrow> distinct have \\<Longrightarrow> distinct (new@have) \\<Longrightarrow> \n     distinct (relpow_impl (\\<lambda>as. remdups (map snd [(a, b)\\<leftarrow>L . a \\<in> set as])) (\\<lambda>xs ys. [x\\<leftarrow>xs . x \\<notin> set ys] @ ys) (\\<lambda>x xs. x \\<in> set xs) new have M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct L; distinct new; distinct have;\n     distinct (new @ have)\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (relpow_impl\n                         (\\<lambda>as.\n                             remdups\n                              (map snd\n                                (filter (\\<lambda>(a, b). a \\<in> set as)\n                                  L)))\n                         (\\<lambda>xs ys.\n                             filter (\\<lambda>x. x \\<notin> set ys) xs @ ys)\n                         (\\<lambda>x xs. x \\<in> set xs) new have M)", "proof (induction M arbitrary: \"new\" \"have\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>new have.\n       \\<lbrakk>distinct L; distinct new; distinct have;\n        distinct (new @ have)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (relpow_impl\n                            (\\<lambda>as.\n                                remdups\n                                 (map snd\n                                   (filter (\\<lambda>(a, b). a \\<in> set as)\n                                     L)))\n                            (\\<lambda>xs ys.\n                                filter (\\<lambda>x. x \\<notin> set ys) xs @\n                                ys)\n                            (\\<lambda>x xs. x \\<in> set xs) new have 0)\n 2. \\<And>M new have.\n       \\<lbrakk>\\<And>new have.\n                   \\<lbrakk>distinct L; distinct new; distinct have;\n                    distinct (new @ have)\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(relpow_impl\n  (\\<lambda>as.\n      remdups (map snd (filter (\\<lambda>(a, b). a \\<in> set as) L)))\n  (\\<lambda>xs ys. filter (\\<lambda>x. x \\<notin> set ys) xs @ ys)\n  (\\<lambda>x xs. x \\<in> set xs) new have M);\n        distinct L; distinct new; distinct have;\n        distinct (new @ have)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (relpow_impl\n                            (\\<lambda>as.\n                                remdups\n                                 (map snd\n                                   (filter (\\<lambda>(a, b). a \\<in> set as)\n                                     L)))\n                            (\\<lambda>xs ys.\n                                filter (\\<lambda>x. x \\<notin> set ys) xs @\n                                ys)\n                            (\\<lambda>x xs. x \\<in> set xs) new have\n                            (Suc M))", "case Suc"], ["proof (state)\nthis:\n  \\<lbrakk>distinct L; distinct ?new; distinct ?have;\n   distinct (?new @ ?have)\\<rbrakk>\n  \\<Longrightarrow> distinct\n                     (relpow_impl\n                       (\\<lambda>as.\n                           remdups\n                            (map snd\n                              (filter\n                                (\\<lambda>a.\n                                    case a of\n                                    (a, b) \\<Rightarrow> a \\<in> set as)\n                                L)))\n                       (\\<lambda>xs ys.\n                           filter (\\<lambda>x. x \\<notin> set ys) xs @ ys)\n                       (\\<lambda>x xs. x \\<in> set xs) ?new ?have M_)\n  distinct L\n  distinct new\n  distinct have\n  distinct (new @ have)\n\ngoal (2 subgoals):\n 1. \\<And>new have.\n       \\<lbrakk>distinct L; distinct new; distinct have;\n        distinct (new @ have)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (relpow_impl\n                            (\\<lambda>as.\n                                remdups\n                                 (map snd\n                                   (filter (\\<lambda>(a, b). a \\<in> set as)\n                                     L)))\n                            (\\<lambda>xs ys.\n                                filter (\\<lambda>x. x \\<notin> set ys) xs @\n                                ys)\n                            (\\<lambda>x xs. x \\<in> set xs) new have 0)\n 2. \\<And>M new have.\n       \\<lbrakk>\\<And>new have.\n                   \\<lbrakk>distinct L; distinct new; distinct have;\n                    distinct (new @ have)\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(relpow_impl\n  (\\<lambda>as.\n      remdups (map snd (filter (\\<lambda>(a, b). a \\<in> set as) L)))\n  (\\<lambda>xs ys. filter (\\<lambda>x. x \\<notin> set ys) xs @ ys)\n  (\\<lambda>x xs. x \\<in> set xs) new have M);\n        distinct L; distinct new; distinct have;\n        distinct (new @ have)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (relpow_impl\n                            (\\<lambda>as.\n                                remdups\n                                 (map snd\n                                   (filter (\\<lambda>(a, b). a \\<in> set as)\n                                     L)))\n                            (\\<lambda>xs ys.\n                                filter (\\<lambda>x. x \\<notin> set ys) xs @\n                                ys)\n                            (\\<lambda>x xs. x \\<in> set xs) new have\n                            (Suc M))", "hence\n      \"distinct ([x\\<leftarrow>new . x \\<notin> set have] @ have)\"\n      \"set ([n\\<leftarrow>remdups (map snd [(a, b)\\<leftarrow>L . a \\<in> set new]) . (n \\<in> set new \\<longrightarrow> n \\<in> set have) \\<and> n \\<notin> set have]) \\<inter> set ([x\\<leftarrow>new . x \\<notin> set have] @ have) = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct L; distinct ?new; distinct ?have;\n   distinct (?new @ ?have)\\<rbrakk>\n  \\<Longrightarrow> distinct\n                     (relpow_impl\n                       (\\<lambda>as.\n                           remdups\n                            (map snd\n                              (filter\n                                (\\<lambda>a.\n                                    case a of\n                                    (a, b) \\<Rightarrow> a \\<in> set as)\n                                L)))\n                       (\\<lambda>xs ys.\n                           filter (\\<lambda>x. x \\<notin> set ys) xs @ ys)\n                       (\\<lambda>x xs. x \\<in> set xs) ?new ?have M_)\n  distinct L\n  distinct new\n  distinct have\n  distinct (new @ have)\n\ngoal (1 subgoal):\n 1. distinct (filter (\\<lambda>x. x \\<notin> set have) new @ have) &&&\n    set (filter\n          (\\<lambda>n.\n              (n \\<in> set new \\<longrightarrow> n \\<in> set have) \\<and>\n              n \\<notin> set have)\n          (remdups\n            (map snd\n              (filter (\\<lambda>(a, b). a \\<in> set new) L)))) \\<inter>\n    set (filter (\\<lambda>x. x \\<notin> set have) new @ have) =\n    {}", "by auto"], ["proof (state)\nthis:\n  distinct (filter (\\<lambda>x. x \\<notin> set have) new @ have)\n  set (filter\n        (\\<lambda>n.\n            (n \\<in> set new \\<longrightarrow> n \\<in> set have) \\<and>\n            n \\<notin> set have)\n        (remdups\n          (map snd (filter (\\<lambda>(a, b). a \\<in> set new) L)))) \\<inter>\n  set (filter (\\<lambda>x. x \\<notin> set have) new @ have) =\n  {}\n\ngoal (2 subgoals):\n 1. \\<And>new have.\n       \\<lbrakk>distinct L; distinct new; distinct have;\n        distinct (new @ have)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (relpow_impl\n                            (\\<lambda>as.\n                                remdups\n                                 (map snd\n                                   (filter (\\<lambda>(a, b). a \\<in> set as)\n                                     L)))\n                            (\\<lambda>xs ys.\n                                filter (\\<lambda>x. x \\<notin> set ys) xs @\n                                ys)\n                            (\\<lambda>x xs. x \\<in> set xs) new have 0)\n 2. \\<And>M new have.\n       \\<lbrakk>\\<And>new have.\n                   \\<lbrakk>distinct L; distinct new; distinct have;\n                    distinct (new @ have)\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(relpow_impl\n  (\\<lambda>as.\n      remdups (map snd (filter (\\<lambda>(a, b). a \\<in> set as) L)))\n  (\\<lambda>xs ys. filter (\\<lambda>x. x \\<notin> set ys) xs @ ys)\n  (\\<lambda>x xs. x \\<in> set xs) new have M);\n        distinct L; distinct new; distinct have;\n        distinct (new @ have)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (relpow_impl\n                            (\\<lambda>as.\n                                remdups\n                                 (map snd\n                                   (filter (\\<lambda>(a, b). a \\<in> set as)\n                                     L)))\n                            (\\<lambda>xs ys.\n                                filter (\\<lambda>x. x \\<notin> set ys) xs @\n                                ys)\n                            (\\<lambda>x xs. x \\<in> set xs) new have\n                            (Suc M))", "with Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct L; distinct ?new; distinct ?have;\n   distinct (?new @ ?have)\\<rbrakk>\n  \\<Longrightarrow> distinct\n                     (relpow_impl\n                       (\\<lambda>as.\n                           remdups\n                            (map snd\n                              (filter\n                                (\\<lambda>a.\n                                    case a of\n                                    (a, b) \\<Rightarrow> a \\<in> set as)\n                                L)))\n                       (\\<lambda>xs ys.\n                           filter (\\<lambda>x. x \\<notin> set ys) xs @ ys)\n                       (\\<lambda>x xs. x \\<in> set xs) ?new ?have M_)\n  distinct L\n  distinct new\n  distinct have\n  distinct (new @ have)\n  distinct (filter (\\<lambda>x. x \\<notin> set have) new @ have)\n  set (filter\n        (\\<lambda>n.\n            (n \\<in> set new \\<longrightarrow> n \\<in> set have) \\<and>\n            n \\<notin> set have)\n        (remdups\n          (map snd (filter (\\<lambda>(a, b). a \\<in> set new) L)))) \\<inter>\n  set (filter (\\<lambda>x. x \\<notin> set have) new @ have) =\n  {}", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct L; distinct ?new; distinct ?have;\n   distinct (?new @ ?have)\\<rbrakk>\n  \\<Longrightarrow> distinct\n                     (relpow_impl\n                       (\\<lambda>as.\n                           remdups\n                            (map snd\n                              (filter\n                                (\\<lambda>a.\n                                    case a of\n                                    (a, b) \\<Rightarrow> a \\<in> set as)\n                                L)))\n                       (\\<lambda>xs ys.\n                           filter (\\<lambda>x. x \\<notin> set ys) xs @ ys)\n                       (\\<lambda>x xs. x \\<in> set xs) ?new ?have M_)\n  distinct L\n  distinct new\n  distinct have\n  distinct (new @ have)\n  distinct (filter (\\<lambda>x. x \\<notin> set have) new @ have)\n  set (filter\n        (\\<lambda>n.\n            (n \\<in> set new \\<longrightarrow> n \\<in> set have) \\<and>\n            n \\<notin> set have)\n        (remdups\n          (map snd (filter (\\<lambda>(a, b). a \\<in> set new) L)))) \\<inter>\n  set (filter (\\<lambda>x. x \\<notin> set have) new @ have) =\n  {}\n\ngoal (1 subgoal):\n 1. distinct\n     (relpow_impl\n       (\\<lambda>as.\n           remdups\n            (map snd\n              (filter\n                (\\<lambda>a. case a of (a, b) \\<Rightarrow> a \\<in> set as)\n                L)))\n       (\\<lambda>xs ys. filter (\\<lambda>x. x \\<notin> set ys) xs @ ys)\n       (\\<lambda>x xs. x \\<in> set xs) new have (Suc M_))", "by auto"], ["proof (state)\nthis:\n  distinct\n   (relpow_impl\n     (\\<lambda>as.\n         remdups\n          (map snd\n            (filter\n              (\\<lambda>a. case a of (a, b) \\<Rightarrow> a \\<in> set as)\n              L)))\n     (\\<lambda>xs ys. filter (\\<lambda>x. x \\<notin> set ys) xs @ ys)\n     (\\<lambda>x xs. x \\<in> set xs) new have (Suc M_))\n\ngoal (1 subgoal):\n 1. \\<And>new have.\n       \\<lbrakk>distinct L; distinct new; distinct have;\n        distinct (new @ have)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (relpow_impl\n                            (\\<lambda>as.\n                                remdups\n                                 (map snd\n                                   (filter (\\<lambda>(a, b). a \\<in> set as)\n                                     L)))\n                            (\\<lambda>xs ys.\n                                filter (\\<lambda>x. x \\<notin> set ys) xs @\n                                ys)\n                            (\\<lambda>x xs. x \\<in> set xs) new have 0)", "qed auto"], ["", "lemma distinct_rtrancl_list_impl: \"distinct L \\<Longrightarrow> distinct ls \\<Longrightarrow> distinct (rtrancl_list_impl L ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct L; distinct ls\\<rbrakk>\n    \\<Longrightarrow> distinct (rtrancl_list_impl L ls)", "unfolding rtrancl_list_impl_def rtrancl_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct L; distinct ls\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       ((let succ =\n                               \\<lambda>as.\n                                  remdups\n                                   (map snd\n                                     (filter\n (\\<lambda>(a, b). a \\<in> set as) L));\n                             n = length L\n                         in (\\<lambda>as.\n                                relpow_impl succ\n                                 (\\<lambda>xs ys.\n                                     filter (\\<lambda>x. x \\<notin> set ys)\nxs @\n                                     ys)\n                                 (\\<lambda>x xs. x \\<in> set xs) as [] n))\n                         ls)", "by (simp add:distinct_relpow_impl)"], ["", "lemma distinct_trancl_list_impl: \"distinct L \\<Longrightarrow> distinct ls \\<Longrightarrow> distinct (trancl_list_impl L ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct L; distinct ls\\<rbrakk>\n    \\<Longrightarrow> distinct (trancl_list_impl L ls)", "unfolding trancl_list_impl_def trancl_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct L; distinct ls\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       ((let succ =\n                               \\<lambda>as.\n                                  remdups\n                                   (map snd\n                                     (filter\n (\\<lambda>(a, b). a \\<in> set as) L));\n                             n = length L\n                         in (\\<lambda>as.\n                                relpow_impl succ\n                                 (\\<lambda>xs ys.\n                                     filter (\\<lambda>x. x \\<notin> set ys)\nxs @\n                                     ys)\n                                 (\\<lambda>x xs. x \\<in> set xs) (succ as)\n                                 [] n))\n                         ls)", "by (simp add:distinct_relpow_impl)\n\n  \\<comment> \\<open>succ rtran\\<close>"], ["", "value \"succ_rtran \\<lparr> nodesL = [1::nat,2,3,4,8,9,10], edgesL = [(1,2), (2,3), (3,4), (8,9),(9,8)] \\<rparr> 1\""], ["", "lemma succ_rtran_correct: \"FiniteGraph.succ_rtran (list_graph_to_graph G) v = set (succ_rtran G v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FiniteGraph.succ_rtran (list_graph_to_graph G) v =\n    set (FiniteListGraph.succ_rtran G v)", "unfolding FiniteGraph.succ_rtran_def succ_rtran_def list_graph_to_graph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {e2.\n     (v, e2)\n     \\<in> (edges\n             \\<lparr>nodes = set (nodesL G),\n                edges = set (edgesL G)\\<rparr>)\\<^sup>*} =\n    set (rtrancl_list_impl (edgesL G) [v])", "by (simp add: rtrancl_list_impl)"], ["", "lemma distinct_succ_rtran: \"wf_list_graph G \\<Longrightarrow> distinct (succ_rtran G v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_list_graph G \\<Longrightarrow>\n    distinct (FiniteListGraph.succ_rtran G v)", "unfolding succ_rtran_def wf_list_graph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (nodesL G) \\<and>\n    distinct (edgesL G) \\<and> wf_list_graph_axioms G \\<Longrightarrow>\n    distinct (rtrancl_list_impl (edgesL G) [v])", "by (auto intro: distinct_rtrancl_list_impl)"], ["", "lemma succ_rtran_set: \"set (succ_rtran G v) = {e2. (v,e2) \\<in> (set (edgesL G))\\<^sup>*}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (FiniteListGraph.succ_rtran G v) =\n    {e2. (v, e2) \\<in> (set (edgesL G))\\<^sup>*}", "unfolding succ_rtran_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rtrancl_list_impl (edgesL G) [v]) =\n    {e2. (v, e2) \\<in> (set (edgesL G))\\<^sup>*}", "by (simp add: rtrancl_list_impl)\n\n  \\<comment> \\<open>succ tran\\<close>"], ["", "lemma distinct_succ_tran: \"wf_list_graph G \\<Longrightarrow> distinct (succ_tran G v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_list_graph G \\<Longrightarrow>\n    distinct (FiniteListGraph.succ_tran G v)", "unfolding succ_tran_def wf_list_graph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (nodesL G) \\<and>\n    distinct (edgesL G) \\<and> wf_list_graph_axioms G \\<Longrightarrow>\n    distinct (trancl_list_impl (edgesL G) [v])", "by (auto intro: distinct_trancl_list_impl)"], ["", "lemma succ_tran_set: \"set (succ_tran G v) = {e2. (v,e2) \\<in> (set (edgesL G))\\<^sup>+}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (FiniteListGraph.succ_tran G v) =\n    {e2. (v, e2) \\<in> (set (edgesL G))\\<^sup>+}", "unfolding succ_tran_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (trancl_list_impl (edgesL G) [v]) =\n    {e2. (v, e2) \\<in> (set (edgesL G))\\<^sup>+}", "by (simp add: trancl_list_impl)"], ["", "value \"succ_tran \\<lparr> nodesL = [1::nat,2,3,4,8,9,10], edgesL = [(1,2), (2,3), (3,4), (8,9),(9,8)] \\<rparr> 1\""], ["", "lemma succ_tran_correct: \"FiniteGraph.succ_tran (list_graph_to_graph G) v = set (succ_tran G v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FiniteGraph.succ_tran (list_graph_to_graph G) v =\n    set (FiniteListGraph.succ_tran G v)", "unfolding FiniteGraph.succ_tran_def succ_tran_def list_graph_to_graph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {e2.\n     (v, e2)\n     \\<in> (edges\n             \\<lparr>nodes = set (nodesL G),\n                edges = set (edgesL G)\\<rparr>)\\<^sup>+} =\n    set (trancl_list_impl (edgesL G) [v])", "by (simp add:trancl_list_impl)\n  \n  \\<comment> \\<open>num_reachable\\<close>"], ["", "lemma num_reachable_correct:\n    \"wf_list_graph G \\<Longrightarrow> FiniteGraph.num_reachable (list_graph_to_graph G) v = num_reachable G v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_list_graph G \\<Longrightarrow>\n    FiniteGraph.num_reachable (list_graph_to_graph G) v =\n    FiniteListGraph.num_reachable G v", "unfolding num_reachable_def FiniteGraph.num_reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_list_graph G \\<Longrightarrow>\n    card (FiniteGraph.succ_tran (list_graph_to_graph G) v) =\n    length (FiniteListGraph.succ_tran G v)", "by (metis List.distinct_card distinct_succ_tran succ_tran_correct)\n\n  \\<comment> \\<open>num_reachable_norefl\\<close>"], ["", "lemma num_reachable_norefl_correct:\n    \"wf_list_graph G \\<Longrightarrow> \n     FiniteGraph.num_reachable_norefl (list_graph_to_graph G) v = num_reachable_norefl G v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_list_graph G \\<Longrightarrow>\n    FiniteGraph.num_reachable_norefl (list_graph_to_graph G) v =\n    FiniteListGraph.num_reachable_norefl G v", "unfolding num_reachable_norefl_def FiniteGraph.num_reachable_norefl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_list_graph G \\<Longrightarrow>\n    card (FiniteGraph.succ_tran (list_graph_to_graph G) v - {v}) =\n    length\n     (filter (\\<lambda>x. x \\<noteq> v) (FiniteListGraph.succ_tran G v))", "by (metis (full_types) List.distinct_card distinct_filter distinct_succ_tran set_minus_filter_out succ_tran_correct)\n\n  \\<comment> \\<open>backlinks, i.e. backflows in formal def\\<close>"], ["", "lemma backlinks_alt: \"backlinks E = [(snd e, fst e). e \\<leftarrow> E]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backlinks E = map (\\<lambda>e. (snd e, fst e)) E", "by (induction E) auto"], ["", "lemma backlinks_set: \"set (backlinks E) = {(e2, e1). (e1, e2) \\<in> set E}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (backlinks E) = {(e2, e1). (e1, e2) \\<in> set E}", "by (induction E) auto"], ["", "lemma undirected_nodes_set: \"set (edgesL (undirected G)) = set (edgesL G) \\<union> {(e2, e1). (e1, e2) \\<in> set (edgesL G)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (edgesL (FiniteListGraph.undirected G)) =\n    set (edgesL G) \\<union> {(e2, e1). (e1, e2) \\<in> set (edgesL G)}", "unfolding undirected_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (edgesL\n          \\<lparr>nodesL = nodesL G,\n             edgesL = remdups (edgesL G @ backlinks (edgesL G))\\<rparr>) =\n    set (edgesL G) \\<union> {(e2, e1). (e1, e2) \\<in> set (edgesL G)}", "by (simp add: backlinks_set)"], ["", "lemma undirected_succ_tran_set: \"set (succ_tran (undirected G) v) = {e2. (v,e2) \\<in> (set (edgesL (undirected G)))\\<^sup>+}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (FiniteListGraph.succ_tran (FiniteListGraph.undirected G) v) =\n    {e2.\n     (v, e2) \\<in> (set (edgesL (FiniteListGraph.undirected G)))\\<^sup>+}", "by (fact succ_tran_set)"], ["", "lemma backlinks_in_nodes_G: \"\\<lbrakk> fst ` set (edgesL G) \\<subseteq> set (nodesL G); snd ` set (edgesL G) \\<subseteq> set (nodesL G) \\<rbrakk> \\<Longrightarrow> \n    fst` set (edgesL (undirected G)) \\<subseteq> set (nodesL (undirected G)) \\<and> snd` set (edgesL (undirected G)) \\<subseteq> set (nodesL (undirected G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst ` set (edgesL G) \\<subseteq> set (nodesL G);\n     snd ` set (edgesL G) \\<subseteq> set (nodesL G)\\<rbrakk>\n    \\<Longrightarrow> fst ` set (edgesL (FiniteListGraph.undirected G))\n                      \\<subseteq> set (nodesL\n  (FiniteListGraph.undirected G)) \\<and>\n                      snd ` set (edgesL (FiniteListGraph.undirected G))\n                      \\<subseteq> set (nodesL\n  (FiniteListGraph.undirected G))", "unfolding undirected_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst ` set (edgesL G) \\<subseteq> set (nodesL G);\n     snd ` set (edgesL G) \\<subseteq> set (nodesL G)\\<rbrakk>\n    \\<Longrightarrow> fst `\n                      set (edgesL\n                            \\<lparr>nodesL = nodesL G,\n                               edgesL =\n                                 remdups\n                                  (edgesL G @ backlinks (edgesL G))\\<rparr>)\n                      \\<subseteq> set (nodesL\n  \\<lparr>nodesL = nodesL G,\n     edgesL = remdups (edgesL G @ backlinks (edgesL G))\\<rparr>) \\<and>\n                      snd `\n                      set (edgesL\n                            \\<lparr>nodesL = nodesL G,\n                               edgesL =\n                                 remdups\n                                  (edgesL G @ backlinks (edgesL G))\\<rparr>)\n                      \\<subseteq> set (nodesL\n  \\<lparr>nodesL = nodesL G,\n     edgesL = remdups (edgesL G @ backlinks (edgesL G))\\<rparr>)", "by(auto simp: backlinks_set)"], ["", "lemma backlinks_distinct: \"distinct E \\<Longrightarrow> distinct (backlinks E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct E \\<Longrightarrow> distinct (backlinks E)", "by (induction E) (auto simp: backlinks_alt)"], ["", "lemma backlinks_subset: \"set (backlinks X) \\<subseteq> set (backlinks Y) \\<longleftrightarrow> set X \\<subseteq> set Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set (backlinks X) \\<subseteq> set (backlinks Y)) =\n    (set X \\<subseteq> set Y)", "by (auto simp: backlinks_set)"], ["", "lemma backlinks_correct: \"FiniteGraph.backflows (set E) = set (backlinks E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backflows (set E) = set (backlinks E)", "unfolding backflows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(r, s). (s, r) \\<in> set E} = set (backlinks E)", "by(simp add: backlinks_set)\n\n  \\<comment> \\<open>undirected\\<close>"], ["", "lemma undirected_wf: \"wf_list_graph G \\<Longrightarrow> wf_list_graph (undirected G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_list_graph G \\<Longrightarrow>\n    wf_list_graph (FiniteListGraph.undirected G)", "unfolding wf_list_graph_def wf_list_graph_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (nodesL G) \\<and>\n    distinct (edgesL G) \\<and>\n    fst ` set (edgesL G) \\<subseteq> set (nodesL G) \\<and>\n    snd ` set (edgesL G) \\<subseteq> set (nodesL G) \\<Longrightarrow>\n    distinct (nodesL (FiniteListGraph.undirected G)) \\<and>\n    distinct (edgesL (FiniteListGraph.undirected G)) \\<and>\n    fst ` set (edgesL (FiniteListGraph.undirected G))\n    \\<subseteq> set (nodesL (FiniteListGraph.undirected G)) \\<and>\n    snd ` set (edgesL (FiniteListGraph.undirected G))\n    \\<subseteq> set (nodesL (FiniteListGraph.undirected G))", "by (simp add:backlinks_in_nodes_G) (simp add: undirected_def)"], ["", "lemma undirected_correct: \n    \"FiniteGraph.undirected (list_graph_to_graph G) = list_graph_to_graph (undirected G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FiniteGraph.undirected (list_graph_to_graph G) =\n    list_graph_to_graph (FiniteListGraph.undirected G)", "unfolding FiniteGraph.undirected_def undirected_def list_graph_to_graph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>nodes =\n              nodes\n               \\<lparr>nodes = set (nodesL G),\n                  edges = set (edgesL G)\\<rparr>,\n       edges =\n         edges\n          \\<lparr>nodes = set (nodesL G),\n             edges = set (edgesL G)\\<rparr> \\<union>\n         {(b, a).\n          (a, b)\n          \\<in> edges\n                 \\<lparr>nodes = set (nodesL G),\n                    edges = set (edgesL G)\\<rparr>}\\<rparr> =\n    \\<lparr>nodes =\n              set (nodesL\n                    \\<lparr>nodesL = nodesL G,\n                       edgesL =\n                         remdups (edgesL G @ backlinks (edgesL G))\\<rparr>),\n       edges =\n         set (edgesL\n               \\<lparr>nodesL = nodesL G,\n                  edgesL =\n                    remdups\n                     (edgesL G @ backlinks (edgesL G))\\<rparr>)\\<rparr>", "by (simp add: backlinks_set)"], ["", "lemmas wf_list_graph_wf =\n  add_node_wf\n  add_edge_wf\n  delete_node_wf\n  delete_edge_wf\n  delete_edges_wf\n  undirected_wf"], ["", "lemmas list_graph_correct =\n  add_node_correct\n  add_edge_correct\n  delete_node_correct\n  delete_edge_correct\n  delete_edges_correct\n  succ_rtran_correct\n  succ_tran_correct\n  num_reachable_correct\n  undirected_correct"], ["", "end"]]}