{"file_name": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification/Network_Security_Policy_Verification.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification", "problem_names": ["lemma wf_list_graph_policy: \"wf_list_graph policy\"", "lemma \"\\<not> wf_list_graph \\<lparr> nodesL = [1,2]::nat list, edgesL = [(1,2), (2,2), (2,3)] \\<rparr>\"", "lemma \"length (edgesL policy) = 3\"", "lemma BLP_m_spec: assumes \"nP = (\\<lambda> v. (case BLP_security_levels v of Some c \\<Rightarrow> c | None \\<Rightarrow> SINVAR_BLPtrusted.default_node_properties))\"\n      shows \"BLP_m_spec = Some \\<lparr> \n              c_sinvar = (\\<lambda>G. SINVAR_BLPtrusted.sinvar G nP),\n              c_offending_flows = (\\<lambda>G. SecurityInvariant_withOffendingFlows.set_offending_flows SINVAR_BLPtrusted.sinvar G nP),\n              c_isIFS = SINVAR_BLPtrusted.receiver_violation\n            \\<rparr>\" (is \"BLP_m_spec = Some ?Spec\")", "lemma valid_reqs_BLP: \"valid_reqs [the BLP_m_spec]\"", "lemma complies_BLP: \"SecurityInvariant_complies_formal_def BLP_m (the BLP_m_spec)\"", "lemma \"\\<not> all_security_requirements_fulfilled security_invariants policy\"", "lemma \"implc_get_offending_flows security_invariants policy = [[(2, 3)]]\"", "lemma \"set ` set (implc_get_offending_flows (get_impl [(BLP_m, the BLP_m_spec)]) policy) = get_offending_flows (get_spec [(BLP_m, the BLP_m_spec)]) (list_graph_to_graph policy)\"", "lemma \"wf_graph G \\<Longrightarrow> max_topo [the BLP_m_spec] (TopoS_Composition_Theory.generate_valid_topology [the BLP_m_spec] (fully_connected G))\"", "lemma \"max_policy = \\<lparr>nodesL = [1, 2, 3], edgesL = [(1, 1), (1, 2), (1, 3), (2, 2), (3, 1), (3, 2), (3, 3)]\\<rparr>\"", "lemma \"all_security_requirements_fulfilled security_invariants max_policy\"", "lemma \"stateful_policy = \\<lparr>hostsL = [1, 2, 3], flows_fixL = [(1, 2), (2, 2), (2, 3)], flows_stateL = []\\<rparr>\""], "translations": [["", "lemma wf_list_graph_policy: \"wf_list_graph policy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_list_graph policy", "by eval"], ["", "text\\<open>In contrast, this is not a syntactically well-formed graph.\\<close>"], ["", "lemma \"\\<not> wf_list_graph \\<lparr> nodesL = [1,2]::nat list, edgesL = [(1,2), (2,2), (2,3)] \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> wf_list_graph\n            \\<lparr>nodesL = [1, 2],\n               edgesL = [(1, 2), (2, 2), (2, 3)]\\<rparr>", "by eval"], ["", "text\\<open>Our @{const policy} has three rules.\\<close>"], ["", "lemma \"length (edgesL policy) = 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (edgesL policy) = 3", "by eval"], ["", "subsection\\<open>Security Invariants\\<close>"], ["", "text\\<open>We construct a security invariant. Node @{term \"2::nat\"} has confidential data\\<close>"], ["", "definition BLP_security_levels :: \"nat \\<rightharpoonup> SINVAR_BLPtrusted.node_config\"where\n  \"BLP_security_levels \\<equiv> [2 \\<mapsto> \\<lparr> security_level = 1, trusted = False \\<rparr>]\""], ["", "definition BLP_m::\"(nat SecurityInvariant)\" where\n    \"BLP_m \\<equiv> new_configured_list_SecurityInvariant SINVAR_LIB_BLPtrusted \\<lparr> \n          node_properties = BLP_security_levels\n          \\<rparr> ''Two has confidential information''\""], ["", "text\\<open>Interlude: @{const BLP_m} is a valid implementation of a SecurityInvariant\\<close>"], ["", "definition BLP_m_spec :: \"nat SecurityInvariant_configured option\"where\n    \"BLP_m_spec \\<equiv> new_configured_SecurityInvariant (\n        SINVAR_BLPtrusted.sinvar,\n        SINVAR_BLPtrusted.default_node_properties,\n        SINVAR_BLPtrusted.receiver_violation,\n        SecurityInvariant.node_props SINVAR_BLPtrusted.default_node_properties \\<lparr> \n          node_properties = BLP_security_levels\n        \\<rparr>)\""], ["", "text\\<open>Fist, we need to show that the formal definition obeys all requirements, @{const new_configured_SecurityInvariant} verifies this. To double check, we manually give the configuration.\\<close>"], ["", "lemma BLP_m_spec: assumes \"nP = (\\<lambda> v. (case BLP_security_levels v of Some c \\<Rightarrow> c | None \\<Rightarrow> SINVAR_BLPtrusted.default_node_properties))\"\n      shows \"BLP_m_spec = Some \\<lparr> \n              c_sinvar = (\\<lambda>G. SINVAR_BLPtrusted.sinvar G nP),\n              c_offending_flows = (\\<lambda>G. SecurityInvariant_withOffendingFlows.set_offending_flows SINVAR_BLPtrusted.sinvar G nP),\n              c_isIFS = SINVAR_BLPtrusted.receiver_violation\n            \\<rparr>\" (is \"BLP_m_spec = Some ?Spec\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. BLP_m_spec =\n    Some\n     \\<lparr>c_sinvar = \\<lambda>G. SINVAR_BLPtrusted.sinvar G nP,\n        c_offending_flows =\n          \\<lambda>G. SINVAR_BLPtrusted.set_offending_flows G nP,\n        c_isIFS = SINVAR_BLPtrusted.receiver_violation\\<rparr>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. BLP_m_spec =\n    Some\n     \\<lparr>c_sinvar = \\<lambda>G. SINVAR_BLPtrusted.sinvar G nP,\n        c_offending_flows =\n          \\<lambda>G. SINVAR_BLPtrusted.set_offending_flows G nP,\n        c_isIFS = SINVAR_BLPtrusted.receiver_violation\\<rparr>", "have NetModelLib: \"TopoS_modelLibrary SINVAR_LIB_BLPtrusted SINVAR_BLPtrusted.sinvar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TopoS_modelLibrary SINVAR_LIB_BLPtrusted SINVAR_BLPtrusted.sinvar", "by(unfold_locales)"], ["proof (state)\nthis:\n  TopoS_modelLibrary SINVAR_LIB_BLPtrusted SINVAR_BLPtrusted.sinvar\n\ngoal (1 subgoal):\n 1. BLP_m_spec =\n    Some\n     \\<lparr>c_sinvar = \\<lambda>G. SINVAR_BLPtrusted.sinvar G nP,\n        c_offending_flows =\n          \\<lambda>G. SINVAR_BLPtrusted.set_offending_flows G nP,\n        c_isIFS = SINVAR_BLPtrusted.receiver_violation\\<rparr>", "from assms"], ["proof (chain)\npicking this:\n  nP =\n  (\\<lambda>v.\n      case BLP_security_levels v of\n      None \\<Rightarrow> SINVAR_BLPtrusted.default_node_properties\n      | Some c \\<Rightarrow> c)", "have nP: \"nP = nm_node_props SINVAR_LIB_BLPtrusted \\<lparr> \n              node_properties = BLP_security_levels\n            \\<rparr>\""], ["proof (prove)\nusing this:\n  nP =\n  (\\<lambda>v.\n      case BLP_security_levels v of\n      None \\<Rightarrow> SINVAR_BLPtrusted.default_node_properties\n      | Some c \\<Rightarrow> c)\n\ngoal (1 subgoal):\n 1. nP =\n    nm_node_props SINVAR_LIB_BLPtrusted\n     \\<lparr>node_properties = BLP_security_levels\\<rparr>", "by(simp add: fun_eq_iff SINVAR_LIB_BLPtrusted_def SINVAR_BLPtrusted_impl.NetModel_node_props_def)"], ["proof (state)\nthis:\n  nP =\n  nm_node_props SINVAR_LIB_BLPtrusted\n   \\<lparr>node_properties = BLP_security_levels\\<rparr>\n\ngoal (1 subgoal):\n 1. BLP_m_spec =\n    Some\n     \\<lparr>c_sinvar = \\<lambda>G. SINVAR_BLPtrusted.sinvar G nP,\n        c_offending_flows =\n          \\<lambda>G. SINVAR_BLPtrusted.set_offending_flows G nP,\n        c_isIFS = SINVAR_BLPtrusted.receiver_violation\\<rparr>", "have \"BLP_m_spec = new_configured_SecurityInvariant (SINVAR_BLPtrusted.sinvar, SINVAR_BLPtrusted.default_node_properties, SINVAR_BLPtrusted.receiver_violation, nP)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BLP_m_spec =\n    new_configured_SecurityInvariant\n     (SINVAR_BLPtrusted.sinvar, SINVAR_BLPtrusted.default_node_properties,\n      SINVAR_BLPtrusted.receiver_violation, nP)", "unfolding BLP_m_spec_def nP"], ["proof (prove)\ngoal (1 subgoal):\n 1. new_configured_SecurityInvariant\n     (SINVAR_BLPtrusted.sinvar, SINVAR_BLPtrusted.default_node_properties,\n      SINVAR_BLPtrusted.receiver_violation,\n      BLPtrusted.node_props\n       \\<lparr>node_properties = BLP_security_levels\\<rparr>) =\n    new_configured_SecurityInvariant\n     (SINVAR_BLPtrusted.sinvar, SINVAR_BLPtrusted.default_node_properties,\n      SINVAR_BLPtrusted.receiver_violation,\n      nm_node_props SINVAR_LIB_BLPtrusted\n       \\<lparr>node_properties = BLP_security_levels\\<rparr>)", "by(simp add: SINVAR_BLPtrusted_impl.NetModel_node_props_def SINVAR_LIB_BLPtrusted_def)"], ["proof (state)\nthis:\n  BLP_m_spec =\n  new_configured_SecurityInvariant\n   (SINVAR_BLPtrusted.sinvar, SINVAR_BLPtrusted.default_node_properties,\n    SINVAR_BLPtrusted.receiver_violation, nP)\n\ngoal (1 subgoal):\n 1. BLP_m_spec =\n    Some\n     \\<lparr>c_sinvar = \\<lambda>G. SINVAR_BLPtrusted.sinvar G nP,\n        c_offending_flows =\n          \\<lambda>G. SINVAR_BLPtrusted.set_offending_flows G nP,\n        c_isIFS = SINVAR_BLPtrusted.receiver_violation\\<rparr>", "also"], ["proof (state)\nthis:\n  BLP_m_spec =\n  new_configured_SecurityInvariant\n   (SINVAR_BLPtrusted.sinvar, SINVAR_BLPtrusted.default_node_properties,\n    SINVAR_BLPtrusted.receiver_violation, nP)\n\ngoal (1 subgoal):\n 1. BLP_m_spec =\n    Some\n     \\<lparr>c_sinvar = \\<lambda>G. SINVAR_BLPtrusted.sinvar G nP,\n        c_offending_flows =\n          \\<lambda>G. SINVAR_BLPtrusted.set_offending_flows G nP,\n        c_isIFS = SINVAR_BLPtrusted.receiver_violation\\<rparr>", "with TopoS_modelLibrary_yields_new_configured_SecurityInvariant[OF NetModelLib nP]"], ["proof (chain)\npicking this:\n  ?Spec =\n  \\<lparr>c_sinvar = \\<lambda>G. SINVAR_BLPtrusted.sinvar G nP,\n     c_offending_flows =\n       \\<lambda>G. SINVAR_BLPtrusted.set_offending_flows G nP,\n     c_isIFS =\n       nm_receiver_violation SINVAR_LIB_BLPtrusted\\<rparr> \\<Longrightarrow>\n  new_configured_SecurityInvariant\n   (SINVAR_BLPtrusted.sinvar, nm_default SINVAR_LIB_BLPtrusted,\n    nm_receiver_violation SINVAR_LIB_BLPtrusted, nP) =\n  Some ?Spec\n  BLP_m_spec =\n  new_configured_SecurityInvariant\n   (SINVAR_BLPtrusted.sinvar, SINVAR_BLPtrusted.default_node_properties,\n    SINVAR_BLPtrusted.receiver_violation, nP)", "have \"\\<dots> = Some ?Spec\""], ["proof (prove)\nusing this:\n  ?Spec =\n  \\<lparr>c_sinvar = \\<lambda>G. SINVAR_BLPtrusted.sinvar G nP,\n     c_offending_flows =\n       \\<lambda>G. SINVAR_BLPtrusted.set_offending_flows G nP,\n     c_isIFS =\n       nm_receiver_violation SINVAR_LIB_BLPtrusted\\<rparr> \\<Longrightarrow>\n  new_configured_SecurityInvariant\n   (SINVAR_BLPtrusted.sinvar, nm_default SINVAR_LIB_BLPtrusted,\n    nm_receiver_violation SINVAR_LIB_BLPtrusted, nP) =\n  Some ?Spec\n  BLP_m_spec =\n  new_configured_SecurityInvariant\n   (SINVAR_BLPtrusted.sinvar, SINVAR_BLPtrusted.default_node_properties,\n    SINVAR_BLPtrusted.receiver_violation, nP)\n\ngoal (1 subgoal):\n 1. new_configured_SecurityInvariant\n     (SINVAR_BLPtrusted.sinvar, SINVAR_BLPtrusted.default_node_properties,\n      SINVAR_BLPtrusted.receiver_violation, nP) =\n    Some\n     \\<lparr>c_sinvar = \\<lambda>G. SINVAR_BLPtrusted.sinvar G nP,\n        c_offending_flows =\n          \\<lambda>G. SINVAR_BLPtrusted.set_offending_flows G nP,\n        c_isIFS = SINVAR_BLPtrusted.receiver_violation\\<rparr>", "by (simp add: SINVAR_LIB_BLPtrusted_def)"], ["proof (state)\nthis:\n  new_configured_SecurityInvariant\n   (SINVAR_BLPtrusted.sinvar, SINVAR_BLPtrusted.default_node_properties,\n    SINVAR_BLPtrusted.receiver_violation, nP) =\n  Some\n   \\<lparr>c_sinvar = \\<lambda>G. SINVAR_BLPtrusted.sinvar G nP,\n      c_offending_flows =\n        \\<lambda>G. SINVAR_BLPtrusted.set_offending_flows G nP,\n      c_isIFS = SINVAR_BLPtrusted.receiver_violation\\<rparr>\n\ngoal (1 subgoal):\n 1. BLP_m_spec =\n    Some\n     \\<lparr>c_sinvar = \\<lambda>G. SINVAR_BLPtrusted.sinvar G nP,\n        c_offending_flows =\n          \\<lambda>G. SINVAR_BLPtrusted.set_offending_flows G nP,\n        c_isIFS = SINVAR_BLPtrusted.receiver_violation\\<rparr>", "finally"], ["proof (chain)\npicking this:\n  BLP_m_spec =\n  Some\n   \\<lparr>c_sinvar = \\<lambda>G. SINVAR_BLPtrusted.sinvar G nP,\n      c_offending_flows =\n        \\<lambda>G. SINVAR_BLPtrusted.set_offending_flows G nP,\n      c_isIFS = SINVAR_BLPtrusted.receiver_violation\\<rparr>", "show ?thesis"], ["proof (prove)\nusing this:\n  BLP_m_spec =\n  Some\n   \\<lparr>c_sinvar = \\<lambda>G. SINVAR_BLPtrusted.sinvar G nP,\n      c_offending_flows =\n        \\<lambda>G. SINVAR_BLPtrusted.set_offending_flows G nP,\n      c_isIFS = SINVAR_BLPtrusted.receiver_violation\\<rparr>\n\ngoal (1 subgoal):\n 1. BLP_m_spec =\n    Some\n     \\<lparr>c_sinvar = \\<lambda>G. SINVAR_BLPtrusted.sinvar G nP,\n        c_offending_flows =\n          \\<lambda>G. SINVAR_BLPtrusted.set_offending_flows G nP,\n        c_isIFS = SINVAR_BLPtrusted.receiver_violation\\<rparr>", "by blast"], ["proof (state)\nthis:\n  BLP_m_spec =\n  Some\n   \\<lparr>c_sinvar = \\<lambda>G. SINVAR_BLPtrusted.sinvar G nP,\n      c_offending_flows =\n        \\<lambda>G. SINVAR_BLPtrusted.set_offending_flows G nP,\n      c_isIFS = SINVAR_BLPtrusted.receiver_violation\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_reqs_BLP: \"valid_reqs [the BLP_m_spec]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_reqs [the BLP_m_spec]", "by(simp add: valid_reqs_def)(metis BLP_m_spec_def BLPtrusted_impl.spec new_configured_SecurityInvariant.simps new_configured_SecurityInvariant_sound option.distinct(1) option.exhaust_sel)"], ["", "text\\<open>Interlude: While @{const BLP_m} is executable code, we will now show that this executable code complies with its formal definition.\\<close>"], ["", "lemma complies_BLP: \"SecurityInvariant_complies_formal_def BLP_m (the BLP_m_spec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_complies_formal_def BLP_m (the BLP_m_spec)", "unfolding BLP_m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_complies_formal_def\n     (new_configured_list_SecurityInvariant SINVAR_LIB_BLPtrusted\n       \\<lparr>node_properties = BLP_security_levels\\<rparr>\n       ''Two has confidential information'')\n     (the BLP_m_spec)", "apply(rule new_configured_list_SecurityInvariant_complies)"], ["proof (prove)\ngoal (4 subgoals):\n 1. TopoS_modelLibrary ?m ?sinvar_spec\n 2. ?nP = nm_node_props ?m ?C\n 3. BLP_m_spec =\n    new_configured_SecurityInvariant\n     (?sinvar_spec, nm_default ?m, nm_receiver_violation ?m, ?nP)\n 4. new_configured_list_SecurityInvariant SINVAR_LIB_BLPtrusted\n     \\<lparr>node_properties = BLP_security_levels\\<rparr>\n     ''Two has confidential information'' =\n    new_configured_list_SecurityInvariant ?m ?C ?description", "apply(simp_all add: BLP_m_spec_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. TopoS_modelLibrary SINVAR_LIB_BLPtrusted ?sinvar_spec\n 2. new_configured_SecurityInvariant\n     (SINVAR_BLPtrusted.sinvar, SINVAR_BLPtrusted.default_node_properties,\n      SINVAR_BLPtrusted.receiver_violation,\n      \\<lambda>i.\n         case BLP_security_levels i of\n         None \\<Rightarrow> SINVAR_BLPtrusted.default_node_properties\n         | Some property \\<Rightarrow> property) =\n    new_configured_SecurityInvariant\n     (?sinvar_spec, nm_default SINVAR_LIB_BLPtrusted,\n      nm_receiver_violation SINVAR_LIB_BLPtrusted,\n      nm_node_props SINVAR_LIB_BLPtrusted\n       \\<lparr>node_properties = BLP_security_levels\\<rparr>)", "apply(unfold_locales)"], ["proof (prove)\ngoal (1 subgoal):\n 1. new_configured_SecurityInvariant\n     (SINVAR_BLPtrusted.sinvar, SINVAR_BLPtrusted.default_node_properties,\n      SINVAR_BLPtrusted.receiver_violation,\n      \\<lambda>i.\n         case BLP_security_levels i of\n         None \\<Rightarrow> SINVAR_BLPtrusted.default_node_properties\n         | Some property \\<Rightarrow> property) =\n    new_configured_SecurityInvariant\n     (SINVAR_BLPtrusted.sinvar, nm_default SINVAR_LIB_BLPtrusted,\n      nm_receiver_violation SINVAR_LIB_BLPtrusted,\n      nm_node_props SINVAR_LIB_BLPtrusted\n       \\<lparr>node_properties = BLP_security_levels\\<rparr>)", "by(simp add: fun_eq_iff SINVAR_LIB_BLPtrusted_def SINVAR_BLPtrusted_impl.NetModel_node_props_def)"], ["", "text\\<open>We define the list of all security invariants of type @{typ \"nat SecurityInvariant list\"}.\n     The type @{typ nat} is because the policy's nodes are of type @{typ nat}.\\<close>"], ["", "definition \"security_invariants = [BLP_m]\""], ["", "text\\<open>We can see that the policy does not fulfill the security invariants.\\<close>"], ["", "lemma \"\\<not> all_security_requirements_fulfilled security_invariants policy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> TopoS_Composition_Theory_impl.all_security_requirements_fulfilled\n            security_invariants policy", "by eval"], ["", "text\\<open>We ask why. Obviously, node 2 leaks confidential data to node 3.\\<close>"], ["", "value \"implc_get_offending_flows security_invariants policy\""], ["", "lemma \"implc_get_offending_flows security_invariants policy = [[(2, 3)]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implc_get_offending_flows security_invariants policy = [[(2, 3)]]", "by eval"], ["", "text\\<open>Interlude: the implementation @{const implc_get_offending_flows} corresponds to the formal definition @{const get_offending_flows}\\<close>"], ["", "lemma \"set ` set (implc_get_offending_flows (get_impl [(BLP_m, the BLP_m_spec)]) policy) = get_offending_flows (get_spec [(BLP_m, the BLP_m_spec)]) (list_graph_to_graph policy)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set `\n    set (implc_get_offending_flows (get_impl [(BLP_m, the BLP_m_spec)])\n          policy) =\n    get_offending_flows (get_spec [(BLP_m, the BLP_m_spec)])\n     (list_graph_to_graph policy)", "apply(rule implc_get_offending_flows_complies)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>(m_impl, m_spec)\\<in>set [(BLP_m, the BLP_m_spec)].\n       SecurityInvariant_complies_formal_def m_impl m_spec\n 2. wf_list_graph policy", "by(simp_all add: complies_BLP wf_list_graph_policy)"], ["", "text\\<open>\nVisualization of the violation (only in interactive mode)\n\\<close>"], ["", "ML_val\\<open>\nvisualize_graph @{context} @{term \"security_invariants\"} @{term \"policy\"};\n\\<close>"], ["", "text\\<open>Experimental: the config (only one) can be added to the end.\\<close>"], ["", "ML_val\\<open>\nvisualize_graph_header @{context} @{term \"security_invariants\"} @{term \"policy\"} @{term \"BLP_security_levels\"};\n\\<close>"], ["", "text\\<open>\nThe policy has a flaw. We throw it away and generate a new one which fulfills the invariants.\n\\<close>"], ["", "definition \"max_policy = generate_valid_topology security_invariants \\<lparr>nodesL = nodesL policy, edgesL = List.product (nodesL policy) (nodesL policy) \\<rparr>\""], ["", "text\\<open>Interlude: the implementation @{const implc_get_offending_flows} corresponds to the formal definition @{const get_offending_flows}\\<close>"], ["", "thm generate_valid_topology_complies"], ["", "text\\<open>Interlude: the formal definition is sound\\<close>"], ["", "thm generate_valid_topology_sound"], ["", "text\\<open>Here, it is also complete\\<close>"], ["", "lemma \"wf_graph G \\<Longrightarrow> max_topo [the BLP_m_spec] (TopoS_Composition_Theory.generate_valid_topology [the BLP_m_spec] (fully_connected G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow>\n    max_topo [the BLP_m_spec]\n     (TopoS_Composition_Theory.generate_valid_topology [the BLP_m_spec]\n       (fully_connected G))", "apply(rule generate_valid_topology_max_topo[OF valid_reqs_BLP])"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf_graph G \\<Longrightarrow> wf_graph G\n 2. wf_graph G \\<Longrightarrow>\n    \\<forall>m\\<in>set [the BLP_m_spec].\n       \\<exists>P. \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)", "apply(assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow>\n    \\<forall>m\\<in>set [the BLP_m_spec].\n       \\<exists>P. \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)", "apply(simp add: BLP_m_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow>\n    \\<exists>P.\n       \\<forall>G.\n          (\\<forall>x\\<in>edges G.\n              case x of\n              (e1, e2) \\<Rightarrow>\n                \\<not> trusted\n                        (case BLP_security_levels e2 of\n                         None \\<Rightarrow>\n                           SINVAR_BLPtrusted.default_node_properties\n                         | Some c \\<Rightarrow> c) \\<longrightarrow>\n                security_level\n                 (case BLP_security_levels e1 of\n                  None \\<Rightarrow>\n                    SINVAR_BLPtrusted.default_node_properties\n                  | Some c \\<Rightarrow> c)\n                \\<le> security_level\n                       (case BLP_security_levels e2 of\n                        None \\<Rightarrow>\n                          SINVAR_BLPtrusted.default_node_properties\n                        | Some c \\<Rightarrow> c)) =\n          (\\<forall>x\\<in>edges G. P x)", "by blast"], ["", "text\\<open>Calculating the maximum policy\\<close>"], ["", "value \"max_policy\""], ["", "lemma \"max_policy = \\<lparr>nodesL = [1, 2, 3], edgesL = [(1, 1), (1, 2), (1, 3), (2, 2), (3, 1), (3, 2), (3, 3)]\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_policy =\n    \\<lparr>nodesL = [1, 2, 3],\n       edgesL =\n         [(1, 1), (1, 2), (1, 3), (2, 2), (3, 1), (3, 2), (3, 3)]\\<rparr>", "by eval"], ["", "text\\<open>\nVisualizing the maximum policy (only in interactive mode)\n\\<close>"], ["", "ML\\<open>\nvisualize_graph @{context} @{term \"security_invariants\"} @{term \"max_policy\"};\n\\<close>"], ["", "text\\<open>Of course, all security invariants hold for the maximum policy.\\<close>"], ["", "lemma \"all_security_requirements_fulfilled security_invariants max_policy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TopoS_Composition_Theory_impl.all_security_requirements_fulfilled\n     security_invariants max_policy", "by eval"], ["", "subsection\\<open>A stateful implementation\\<close>"], ["", "text\\<open>We generate a stateful policy\\<close>"], ["", "definition \"stateful_policy = generate_valid_stateful_policy_IFSACS_2 policy security_invariants\""], ["", "text\\<open>When thinking about it carefully, no flow can be stateful without introducing an information leakage here!\\<close>"], ["", "value \"stateful_policy\""], ["", "lemma \"stateful_policy = \\<lparr>hostsL = [1, 2, 3], flows_fixL = [(1, 2), (2, 2), (2, 3)], flows_stateL = []\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stateful_policy =\n    \\<lparr>hostsL = [1, 2, 3], flows_fixL = [(1, 2), (2, 2), (2, 3)],\n       flows_stateL = []\\<rparr>", "by eval"], ["", "text\\<open>Interlude: the stateful policy we are computing fulfills all the necessary properties\\<close>"], ["", "thm generate_valid_stateful_policy_IFSACS_2_complies"], ["", "(*the individual algorithms fir IFS/ACS return a maximum policy*)"], ["", "thm filter_compliant_stateful_ACS_correct filter_compliant_stateful_ACS_maximal"], ["", "thm filter_IFS_no_violations_correct filter_IFS_no_violations_maximal"], ["", "text\\<open>\nVisualizing the stateful policy (only in interactive mode)\n\\<close>"], ["", "ML_val\\<open>\nvisualize_edges @{context} @{term \"flows_fixL stateful_policy\"} \n    [(\"edge [dir=\\\"arrow\\\", style=dashed, color=\\\"#FF8822\\\", constraint=false]\", @{term \"flows_stateL stateful_policy\"})] \"\"; \n\\<close>"], ["", "text\\<open>This is how it would look like if @{term \"(3,1)\"} were a stateful flow\\<close>"], ["", "ML_val\\<open>\nvisualize_edges @{context} @{term \"flows_fixL stateful_policy\"} \n    [(\"edge [dir=\\\"arrow\\\", style=dashed, color=\\\"#FF8822\\\", constraint=false]\", @{term \"[(3::nat,1::nat)]\"})] \"\"; \n\\<close>"], ["", "hide_const policy security_invariants max_policy stateful_policy"], ["", "end"]]}