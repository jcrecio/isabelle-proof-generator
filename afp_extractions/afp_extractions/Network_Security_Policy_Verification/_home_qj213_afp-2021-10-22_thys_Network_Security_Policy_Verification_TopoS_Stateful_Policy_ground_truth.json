{"file_name": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification/TopoS_Stateful_Policy.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification", "problem_names": ["lemma E_wfD: assumes \"(v,v') \\<in> flows_fix \\<T>\"\n    shows \"v \\<in> hosts \\<T>\" \"v' \\<in> hosts \\<T>\"", "lemma E_state_valid: \"fst ` (flows_state \\<T>) \\<subseteq> (hosts \\<T>)\"\n                       \"snd ` (flows_state \\<T>) \\<subseteq> (hosts \\<T>)\"", "lemma E_state_validD: assumes \"(v,v') \\<in> flows_state \\<T>\"\n    shows \"v \\<in> hosts \\<T>\" \"v' \\<in> hosts \\<T>\"", "lemma finite_fix: \"finite (flows_fix \\<T>)\"", "lemma finite_state: \"finite (flows_state \\<T>)\"", "lemma finite_backflows_state: \"finite (backflows (flows_state \\<T>))\"", "lemma E_state_backflows_wf: \"fst ` backflows (flows_state \\<T>) \\<subseteq> (hosts \\<T>)\"\n                         \"snd ` backflows (flows_state \\<T>) \\<subseteq> (hosts \\<T>)\"", "lemma filternew_subseteq_flows_state: \"filternew_flows_state \\<T> \\<subseteq> flows_state \\<T>\"", "lemma filternew_flows_state_alt: \"filternew_flows_state \\<T>  = flows_state \\<T> - (backflows (flows_fix \\<T>))\"", "lemma filternew_flows_state_alt2: \"filternew_flows_state \\<T>  = {e \\<in> flows_state \\<T>. e \\<notin> backflows (flows_fix \\<T>)}\"", "lemma backflows_filternew_flows_state: \"backflows (filternew_flows_state \\<T>) = (backflows (flows_state \\<T>)) - (flows_fix \\<T>)\"", "lemma stateful_policy_to_network_graph_filternew: \"\\<lbrakk> wf_stateful_policy \\<T> \\<rbrakk> \\<Longrightarrow> \n    stateful_policy_to_network_graph \\<T> = \n    stateful_policy_to_network_graph \\<lparr>hosts = hosts \\<T>, flows_fix = flows_fix \\<T>, flows_state = filternew_flows_state \\<T> \\<rparr>\"", "lemma backflows_filternew_disjunct_flows_fix: \n    \"\\<forall> b \\<in> (backflows (filternew_flows_state \\<T>)). b \\<notin> flows_fix \\<T>\"", "lemma \"wf_graph G \\<Longrightarrow> wf_stateful_policy \\<lparr> hosts = nodes G, flows_fix = nodes G \\<times> nodes G, flows_state = nodes G \\<times> nodes G \\<rparr>\"", "lemma wf_stateful_policy_is_wf_graph: \"wf_stateful_policy \\<T> \\<Longrightarrow> wf_graph \\<lparr>nodes = hosts \\<T>, edges = all_flows \\<T>\\<rparr>\"", "lemma \"(\\<forall>F \\<in> get_offending_flows (get_ACS M) (stateful_policy_to_network_graph \\<T> ). F \\<subseteq> backflows (filternew_flows_state \\<T>)) \\<longleftrightarrow>\n    \\<Union>(get_offending_flows (get_ACS M) (stateful_policy_to_network_graph \\<T>)) \\<subseteq> (backflows (flows_state \\<T>)) - (flows_fix \\<T>)\"", "lemma compliant_stateful_ACS_no_side_effects_filternew_helper: \n      \"\\<forall> E \\<subseteq> backflows (filternew_flows_state \\<T>). \\<forall> F \\<in> get_offending_flows (get_ACS M) \\<lparr> nodes = hosts \\<T>, edges = flows_fix \\<T> \\<union> E \\<rparr>. F \\<subseteq> E\"", "theorem compliant_stateful_ACS_no_side_effects:\n      \"\\<forall> E \\<subseteq> backflows (flows_state \\<T>). \\<forall> F \\<in> get_offending_flows(get_ACS M) \\<lparr> nodes = hosts \\<T>, edges = flows_fix \\<T> \\<union> E \\<rparr>. F \\<subseteq> E\"", "lemma valid_stateful_policy: \"wf_graph \\<lparr>nodes = hosts \\<T>, edges = all_flows \\<T>\\<rparr>\"", "lemma compliant_stateful_ACS_static_valid: \"all_security_requirements_fulfilled (get_ACS M) \\<lparr> nodes = hosts \\<T>, edges = flows_fix \\<T>  \\<rparr>\"", "theorem compliant_stateful_ACS_static_valid':\n      \"all_security_requirements_fulfilled M \\<lparr> nodes = hosts \\<T>, edges = flows_fix \\<T> \\<union> flows_state \\<T>  \\<rparr>\"", "theorem flows_state_edges: \"flows_state \\<T> \\<subseteq> edges G\"", "lemma compliant_stateful_ACS_only_state_violations:\n      \"\\<forall>F \\<in> get_offending_flows (get_ACS M) (stateful_policy_to_network_graph \\<T>). F \\<subseteq> backflows (flows_state \\<T>)\"", "theorem compliant_stateful_ACS_only_state_violations': \"\\<forall>F \\<in> get_offending_flows M (stateful_policy_to_network_graph \\<T>). F \\<subseteq> backflows (flows_state \\<T>)\"", "lemma  compliant_stateful_ACS_no_state_singleflow_side_effect:\n      \"\\<forall> (v\\<^sub>1, v\\<^sub>2) \\<in> backflows (flows_state \\<T>). \n       \\<Union>(get_offending_flows(get_ACS M) \\<lparr> nodes = hosts \\<T>, edges = flows_fix \\<T> \\<union> flows_state \\<T> \\<union> {(v\\<^sub>1, v\\<^sub>2)} \\<rparr>) \\<subseteq> {(v\\<^sub>1, v\\<^sub>2)}\""], "translations": [["", "lemma E_wfD: assumes \"(v,v') \\<in> flows_fix \\<T>\"\n    shows \"v \\<in> hosts \\<T>\" \"v' \\<in> hosts \\<T>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> hosts \\<T> &&& v' \\<in> hosts \\<T>", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. v \\<in> hosts \\<T>\n 2. v' \\<in> hosts \\<T>", "apply (rule subsetD[OF E_wf(1)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. v \\<in> fst ` flows_fix \\<T>\n 2. v' \\<in> hosts \\<T>", "using assms"], ["proof (prove)\nusing this:\n  (v, v') \\<in> flows_fix \\<T>\n\ngoal (2 subgoals):\n 1. v \\<in> fst ` flows_fix \\<T>\n 2. v' \\<in> hosts \\<T>", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. v' \\<in> hosts \\<T>", "apply (rule subsetD[OF E_wf(2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. v' \\<in> snd ` flows_fix \\<T>", "using assms"], ["proof (prove)\nusing this:\n  (v, v') \\<in> flows_fix \\<T>\n\ngoal (1 subgoal):\n 1. v' \\<in> snd ` flows_fix \\<T>", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma E_state_valid: \"fst ` (flows_state \\<T>) \\<subseteq> (hosts \\<T>)\"\n                       \"snd ` (flows_state \\<T>) \\<subseteq> (hosts \\<T>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` flows_state \\<T> \\<subseteq> hosts \\<T> &&&\n    snd ` flows_state \\<T> \\<subseteq> hosts \\<T>", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. fst ` flows_state \\<T> \\<subseteq> hosts \\<T>\n 2. snd ` flows_state \\<T> \\<subseteq> hosts \\<T>", "using E_wf(1) E_state_fix"], ["proof (prove)\nusing this:\n  fst ` flows_fix \\<T> \\<subseteq> hosts \\<T>\n  flows_state \\<T> \\<subseteq> flows_fix \\<T>\n\ngoal (2 subgoals):\n 1. fst ` flows_state \\<T> \\<subseteq> hosts \\<T>\n 2. snd ` flows_state \\<T> \\<subseteq> hosts \\<T>", "apply(blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` flows_state \\<T> \\<subseteq> hosts \\<T>", "using E_wf(2) E_state_fix"], ["proof (prove)\nusing this:\n  snd ` flows_fix \\<T> \\<subseteq> hosts \\<T>\n  flows_state \\<T> \\<subseteq> flows_fix \\<T>\n\ngoal (1 subgoal):\n 1. snd ` flows_state \\<T> \\<subseteq> hosts \\<T>", "apply(blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma E_state_validD: assumes \"(v,v') \\<in> flows_state \\<T>\"\n    shows \"v \\<in> hosts \\<T>\" \"v' \\<in> hosts \\<T>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> hosts \\<T> &&& v' \\<in> hosts \\<T>", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. v \\<in> hosts \\<T>\n 2. v' \\<in> hosts \\<T>", "apply (rule subsetD[OF E_state_valid(1)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. v \\<in> fst ` flows_state \\<T>\n 2. v' \\<in> hosts \\<T>", "using assms"], ["proof (prove)\nusing this:\n  (v, v') \\<in> flows_state \\<T>\n\ngoal (2 subgoals):\n 1. v \\<in> fst ` flows_state \\<T>\n 2. v' \\<in> hosts \\<T>", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. v' \\<in> hosts \\<T>", "apply (rule subsetD[OF E_state_valid(2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. v' \\<in> snd ` flows_state \\<T>", "using assms"], ["proof (prove)\nusing this:\n  (v, v') \\<in> flows_state \\<T>\n\ngoal (1 subgoal):\n 1. v' \\<in> snd ` flows_state \\<T>", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma finite_fix: \"finite (flows_fix \\<T>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (flows_fix \\<T>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (flows_fix \\<T>)", "from finite_subset[OF E_wf(1) finite_Hosts]"], ["proof (chain)\npicking this:\n  finite (fst ` flows_fix \\<T>)", "have 1: \"finite (fst ` flows_fix \\<T>)\""], ["proof (prove)\nusing this:\n  finite (fst ` flows_fix \\<T>)\n\ngoal (1 subgoal):\n 1. finite (fst ` flows_fix \\<T>)", "."], ["proof (state)\nthis:\n  finite (fst ` flows_fix \\<T>)\n\ngoal (1 subgoal):\n 1. finite (flows_fix \\<T>)", "from finite_subset[OF E_wf(2) finite_Hosts]"], ["proof (chain)\npicking this:\n  finite (snd ` flows_fix \\<T>)", "have 2: \"finite (snd ` flows_fix \\<T>)\""], ["proof (prove)\nusing this:\n  finite (snd ` flows_fix \\<T>)\n\ngoal (1 subgoal):\n 1. finite (snd ` flows_fix \\<T>)", "."], ["proof (state)\nthis:\n  finite (snd ` flows_fix \\<T>)\n\ngoal (1 subgoal):\n 1. finite (flows_fix \\<T>)", "have s: \"flows_fix \\<T> \\<subseteq> (fst ` flows_fix \\<T> \\<times> snd ` flows_fix \\<T>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flows_fix \\<T>\n    \\<subseteq> fst ` flows_fix \\<T> \\<times> snd ` flows_fix \\<T>", "by force"], ["proof (state)\nthis:\n  flows_fix \\<T>\n  \\<subseteq> fst ` flows_fix \\<T> \\<times> snd ` flows_fix \\<T>\n\ngoal (1 subgoal):\n 1. finite (flows_fix \\<T>)", "from finite_cartesian_product[OF 1 2]"], ["proof (chain)\npicking this:\n  finite (fst ` flows_fix \\<T> \\<times> snd ` flows_fix \\<T>)", "have \"finite (fst ` flows_fix \\<T> \\<times> snd ` flows_fix \\<T>)\""], ["proof (prove)\nusing this:\n  finite (fst ` flows_fix \\<T> \\<times> snd ` flows_fix \\<T>)\n\ngoal (1 subgoal):\n 1. finite (fst ` flows_fix \\<T> \\<times> snd ` flows_fix \\<T>)", "."], ["proof (state)\nthis:\n  finite (fst ` flows_fix \\<T> \\<times> snd ` flows_fix \\<T>)\n\ngoal (1 subgoal):\n 1. finite (flows_fix \\<T>)", "from finite_subset[OF s this]"], ["proof (chain)\npicking this:\n  finite (flows_fix \\<T>)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (flows_fix \\<T>)\n\ngoal (1 subgoal):\n 1. finite (flows_fix \\<T>)", "."], ["proof (state)\nthis:\n  finite (flows_fix \\<T>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_state: \"finite (flows_state \\<T>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (flows_state \\<T>)", "using finite_subset[OF E_state_fix finite_fix]"], ["proof (prove)\nusing this:\n  finite (flows_state \\<T>)\n\ngoal (1 subgoal):\n 1. finite (flows_state \\<T>)", "by assumption"], ["", "lemma finite_backflows_state: \"finite (backflows (flows_state \\<T>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (backflows (flows_state \\<T>))", "using [[simproc add: finite_Collect]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (backflows (flows_state \\<T>))", "by(simp add: backflows_def finite_state)"], ["", "lemma E_state_backflows_wf: \"fst ` backflows (flows_state \\<T>) \\<subseteq> (hosts \\<T>)\"\n                         \"snd ` backflows (flows_state \\<T>) \\<subseteq> (hosts \\<T>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` backflows (flows_state \\<T>) \\<subseteq> hosts \\<T> &&&\n    snd ` backflows (flows_state \\<T>) \\<subseteq> hosts \\<T>", "by(auto simp add: backflows_def E_state_valid E_state_validD)"], ["", "end"], ["", "text\\<open>Minimizing stateful flows such that only newly added backflows remain\\<close>"], ["", "definition filternew_flows_state :: \"'v stateful_policy \\<Rightarrow> ('v \\<times> 'v) set\" where\n    \"filternew_flows_state \\<T> \\<equiv> {(s, r) \\<in> flows_state \\<T>. (r, s) \\<notin> flows_fix \\<T>}\""], ["", "lemma filternew_subseteq_flows_state: \"filternew_flows_state \\<T> \\<subseteq> flows_state \\<T>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filternew_flows_state \\<T> \\<subseteq> flows_state \\<T>", "by(auto simp add: filternew_flows_state_def)\n\n  \\<comment> \\<open>alternative definitions, all are equal\\<close>"], ["", "lemma filternew_flows_state_alt: \"filternew_flows_state \\<T>  = flows_state \\<T> - (backflows (flows_fix \\<T>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filternew_flows_state \\<T> =\n    flows_state \\<T> - backflows (flows_fix \\<T>)", "apply(simp add: backflows_def filternew_flows_state_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(s, r).\n     (s, r) \\<in> flows_state \\<T> \\<and> (r, s) \\<notin> flows_fix \\<T>} =\n    flows_state \\<T> - {(r, s). (s, r) \\<in> flows_fix \\<T>}", "apply(rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {(s, r).\n     (s, r) \\<in> flows_state \\<T> \\<and> (r, s) \\<notin> flows_fix \\<T>}\n    \\<subseteq> flows_state \\<T> - {(r, s). (s, r) \\<in> flows_fix \\<T>}\n 2. flows_state \\<T> - {(r, s). (s, r) \\<in> flows_fix \\<T>}\n    \\<subseteq> {(s, r).\n                 (s, r) \\<in> flows_state \\<T> \\<and>\n                 (r, s) \\<notin> flows_fix \\<T>}", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma filternew_flows_state_alt2: \"filternew_flows_state \\<T>  = {e \\<in> flows_state \\<T>. e \\<notin> backflows (flows_fix \\<T>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filternew_flows_state \\<T> =\n    {e \\<in> flows_state \\<T>. e \\<notin> backflows (flows_fix \\<T>)}", "apply(simp add: backflows_def filternew_flows_state_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(s, r).\n     (s, r) \\<in> flows_state \\<T> \\<and> (r, s) \\<notin> flows_fix \\<T>} =\n    {e \\<in> flows_state \\<T>.\n     \\<not> (case e of (r, s) \\<Rightarrow> (s, r) \\<in> flows_fix \\<T>)}", "apply(rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {(s, r).\n     (s, r) \\<in> flows_state \\<T> \\<and> (r, s) \\<notin> flows_fix \\<T>}\n    \\<subseteq> {e \\<in> flows_state \\<T>.\n                 \\<not> (case e of\n                         (r, s) \\<Rightarrow> (s, r) \\<in> flows_fix \\<T>)}\n 2. {e \\<in> flows_state \\<T>.\n     \\<not> (case e of (r, s) \\<Rightarrow> (s, r) \\<in> flows_fix \\<T>)}\n    \\<subseteq> {(s, r).\n                 (s, r) \\<in> flows_state \\<T> \\<and>\n                 (r, s) \\<notin> flows_fix \\<T>}", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma backflows_filternew_flows_state: \"backflows (filternew_flows_state \\<T>) = (backflows (flows_state \\<T>)) - (flows_fix \\<T>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backflows (filternew_flows_state \\<T>) =\n    backflows (flows_state \\<T>) - flows_fix \\<T>", "by(simp add: filternew_flows_state_alt backflows_minus_backflows)"], ["", "lemma stateful_policy_to_network_graph_filternew: \"\\<lbrakk> wf_stateful_policy \\<T> \\<rbrakk> \\<Longrightarrow> \n    stateful_policy_to_network_graph \\<T> = \n    stateful_policy_to_network_graph \\<lparr>hosts = hosts \\<T>, flows_fix = flows_fix \\<T>, flows_state = filternew_flows_state \\<T> \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_stateful_policy \\<T> \\<Longrightarrow>\n    stateful_policy_to_network_graph \\<T> =\n    stateful_policy_to_network_graph\n     \\<lparr>hosts = hosts \\<T>, flows_fix = flows_fix \\<T>,\n        flows_state = filternew_flows_state \\<T>\\<rparr>", "apply(drule wf_stateful_policy.E_state_fix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. flows_state \\<T> \\<subseteq> flows_fix \\<T> \\<Longrightarrow>\n    stateful_policy_to_network_graph \\<T> =\n    stateful_policy_to_network_graph\n     \\<lparr>hosts = hosts \\<T>, flows_fix = flows_fix \\<T>,\n        flows_state = filternew_flows_state \\<T>\\<rparr>", "apply(simp add: stateful_policy_to_network_graph_def all_flows_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. flows_state \\<T> \\<subseteq> flows_fix \\<T> \\<Longrightarrow>\n    flows_fix \\<T> \\<union> flows_state \\<T> \\<union>\n    backflows (flows_state \\<T>) =\n    flows_fix \\<T> \\<union> filternew_flows_state \\<T> \\<union>\n    backflows (filternew_flows_state \\<T>)", "apply(rule Set.equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. flows_state \\<T> \\<subseteq> flows_fix \\<T> \\<Longrightarrow>\n    flows_fix \\<T> \\<union> flows_state \\<T> \\<union>\n    backflows (flows_state \\<T>)\n    \\<subseteq> flows_fix \\<T> \\<union> filternew_flows_state \\<T> \\<union>\n                backflows (filternew_flows_state \\<T>)\n 2. flows_state \\<T> \\<subseteq> flows_fix \\<T> \\<Longrightarrow>\n    flows_fix \\<T> \\<union> filternew_flows_state \\<T> \\<union>\n    backflows (filternew_flows_state \\<T>)\n    \\<subseteq> flows_fix \\<T> \\<union> flows_state \\<T> \\<union>\n                backflows (flows_state \\<T>)", "apply(simp add: filternew_flows_state_def backflows_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. flows_state \\<T> \\<subseteq> flows_fix \\<T> \\<Longrightarrow>\n    flows_fix \\<T>\n    \\<subseteq> flows_fix \\<T> \\<union>\n                {(s, r).\n                 (s, r) \\<in> flows_state \\<T> \\<and>\n                 (r, s) \\<notin> flows_fix \\<T>} \\<union>\n                {(r, s).\n                 (s, r) \\<in> flows_state \\<T> \\<and>\n                 (r, s) \\<notin> flows_fix \\<T>} \\<and>\n    flows_state \\<T>\n    \\<subseteq> flows_fix \\<T> \\<union>\n                {(s, r).\n                 (s, r) \\<in> flows_state \\<T> \\<and>\n                 (r, s) \\<notin> flows_fix \\<T>} \\<union>\n                {(r, s).\n                 (s, r) \\<in> flows_state \\<T> \\<and>\n                 (r, s) \\<notin> flows_fix \\<T>} \\<and>\n    {(r, s). (s, r) \\<in> flows_state \\<T>}\n    \\<subseteq> flows_fix \\<T> \\<union>\n                {(s, r).\n                 (s, r) \\<in> flows_state \\<T> \\<and>\n                 (r, s) \\<notin> flows_fix \\<T>} \\<union>\n                {(r, s).\n                 (s, r) \\<in> flows_state \\<T> \\<and>\n                 (r, s) \\<notin> flows_fix \\<T>}\n 2. flows_state \\<T> \\<subseteq> flows_fix \\<T> \\<Longrightarrow>\n    flows_fix \\<T> \\<union> filternew_flows_state \\<T> \\<union>\n    backflows (filternew_flows_state \\<T>)\n    \\<subseteq> flows_fix \\<T> \\<union> flows_state \\<T> \\<union>\n                backflows (flows_state \\<T>)", "apply(rule, blast)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. flows_state \\<T> \\<subseteq> flows_fix \\<T> \\<Longrightarrow>\n    flows_fix \\<T> \\<union> filternew_flows_state \\<T> \\<union>\n    backflows (filternew_flows_state \\<T>)\n    \\<subseteq> flows_fix \\<T> \\<union> flows_state \\<T> \\<union>\n                backflows (flows_state \\<T>)", "apply(simp add: filternew_flows_state_def backflows_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. flows_state \\<T> \\<subseteq> flows_fix \\<T> \\<Longrightarrow>\n    flows_fix \\<T>\n    \\<subseteq> flows_fix \\<T> \\<union> flows_state \\<T> \\<union>\n                {(r, s). (s, r) \\<in> flows_state \\<T>} \\<and>\n    {(s, r).\n     (s, r) \\<in> flows_state \\<T> \\<and> (r, s) \\<notin> flows_fix \\<T>}\n    \\<subseteq> flows_fix \\<T> \\<union> flows_state \\<T> \\<union>\n                {(r, s). (s, r) \\<in> flows_state \\<T>} \\<and>\n    {(r, s).\n     (s, r) \\<in> flows_state \\<T> \\<and> (r, s) \\<notin> flows_fix \\<T>}\n    \\<subseteq> flows_fix \\<T> \\<union> flows_state \\<T> \\<union>\n                {(r, s). (s, r) \\<in> flows_state \\<T>}", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma backflows_filternew_disjunct_flows_fix: \n    \"\\<forall> b \\<in> (backflows (filternew_flows_state \\<T>)). b \\<notin> flows_fix \\<T>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>backflows (filternew_flows_state \\<T>).\n       b \\<notin> flows_fix \\<T>", "by(simp add: filternew_flows_state_def backflows_def)"], ["", "text\\<open>Given a high-level policy, we can construct a pretty large syntactically valid low level policy. However, the stateful policy will\n       almost certainly violate security requirements!\\<close>"], ["", "lemma \"wf_graph G \\<Longrightarrow> wf_stateful_policy \\<lparr> hosts = nodes G, flows_fix = nodes G \\<times> nodes G, flows_state = nodes G \\<times> nodes G \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow>\n    wf_stateful_policy\n     \\<lparr>hosts = nodes G, flows_fix = nodes G \\<times> nodes G,\n        flows_state = nodes G \\<times> nodes G\\<rparr>", "by(simp add: wf_stateful_policy_def wf_graph_def)"], ["", "text\\<open>@{const wf_stateful_policy} implies @{term wf_graph}\\<close>"], ["", "lemma wf_stateful_policy_is_wf_graph: \"wf_stateful_policy \\<T> \\<Longrightarrow> wf_graph \\<lparr>nodes = hosts \\<T>, edges = all_flows \\<T>\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_stateful_policy \\<T> \\<Longrightarrow>\n    wf_graph \\<lparr>nodes = hosts \\<T>, edges = all_flows \\<T>\\<rparr>", "apply(frule wf_stateful_policy.E_state_backflows_wf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_stateful_policy \\<T>;\n     fst ` backflows (flows_state \\<T>) \\<subseteq> hosts \\<T>\\<rbrakk>\n    \\<Longrightarrow> wf_graph\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = all_flows \\<T>\\<rparr>", "apply(frule wf_stateful_policy.E_state_backflows_wf(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_stateful_policy \\<T>;\n     fst ` backflows (flows_state \\<T>) \\<subseteq> hosts \\<T>;\n     snd ` backflows (flows_state \\<T>) \\<subseteq> hosts \\<T>\\<rbrakk>\n    \\<Longrightarrow> wf_graph\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = all_flows \\<T>\\<rparr>", "apply(frule wf_stateful_policy.E_state_valid)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_stateful_policy \\<T>;\n     fst ` backflows (flows_state \\<T>) \\<subseteq> hosts \\<T>;\n     snd ` backflows (flows_state \\<T>) \\<subseteq> hosts \\<T>;\n     fst ` flows_state \\<T> \\<subseteq> hosts \\<T>\\<rbrakk>\n    \\<Longrightarrow> wf_graph\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = all_flows \\<T>\\<rparr>", "apply(frule wf_stateful_policy.E_state_valid(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_stateful_policy \\<T>;\n     fst ` backflows (flows_state \\<T>) \\<subseteq> hosts \\<T>;\n     snd ` backflows (flows_state \\<T>) \\<subseteq> hosts \\<T>;\n     fst ` flows_state \\<T> \\<subseteq> hosts \\<T>;\n     snd ` flows_state \\<T> \\<subseteq> hosts \\<T>\\<rbrakk>\n    \\<Longrightarrow> wf_graph\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = all_flows \\<T>\\<rparr>", "apply(frule wf_stateful_policy.E_wf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_stateful_policy \\<T>;\n     fst ` backflows (flows_state \\<T>) \\<subseteq> hosts \\<T>;\n     snd ` backflows (flows_state \\<T>) \\<subseteq> hosts \\<T>;\n     fst ` flows_state \\<T> \\<subseteq> hosts \\<T>;\n     snd ` flows_state \\<T> \\<subseteq> hosts \\<T>;\n     fst ` flows_fix \\<T> \\<subseteq> hosts \\<T>\\<rbrakk>\n    \\<Longrightarrow> wf_graph\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = all_flows \\<T>\\<rparr>", "apply(frule wf_stateful_policy.E_wf(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_stateful_policy \\<T>;\n     fst ` backflows (flows_state \\<T>) \\<subseteq> hosts \\<T>;\n     snd ` backflows (flows_state \\<T>) \\<subseteq> hosts \\<T>;\n     fst ` flows_state \\<T> \\<subseteq> hosts \\<T>;\n     snd ` flows_state \\<T> \\<subseteq> hosts \\<T>;\n     fst ` flows_fix \\<T> \\<subseteq> hosts \\<T>;\n     snd ` flows_fix \\<T> \\<subseteq> hosts \\<T>\\<rbrakk>\n    \\<Longrightarrow> wf_graph\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = all_flows \\<T>\\<rparr>", "apply(simp add: all_flows_def wf_graph_def wf_stateful_policy_def \n          wf_stateful_policy.finite_fix wf_stateful_policy.finite_state wf_stateful_policy.finite_backflows_state)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>flows_state \\<T> \\<subseteq> flows_fix \\<T> \\<and>\n             finite (hosts \\<T>);\n     fst ` backflows (flows_state \\<T>) \\<subseteq> hosts \\<T>;\n     snd ` backflows (flows_state \\<T>) \\<subseteq> hosts \\<T>;\n     fst ` flows_state \\<T> \\<subseteq> hosts \\<T>;\n     snd ` flows_state \\<T> \\<subseteq> hosts \\<T>;\n     fst ` flows_fix \\<T> \\<subseteq> hosts \\<T>;\n     snd ` flows_fix \\<T> \\<subseteq> hosts \\<T>\\<rbrakk>\n    \\<Longrightarrow> fst `\n                      (flows_fix \\<T> \\<union> flows_state \\<T> \\<union>\n                       backflows (flows_state \\<T>))\n                      \\<subseteq> hosts \\<T> \\<and>\n                      snd `\n                      (flows_fix \\<T> \\<union> flows_state \\<T> \\<union>\n                       backflows (flows_state \\<T>))\n                      \\<subseteq> hosts \\<T>", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>flows_state \\<T> \\<subseteq> flows_fix \\<T> \\<and>\n             finite (hosts \\<T>);\n     fst ` backflows (flows_state \\<T>) \\<subseteq> hosts \\<T>;\n     snd ` backflows (flows_state \\<T>) \\<subseteq> hosts \\<T>;\n     fst ` flows_state \\<T> \\<subseteq> hosts \\<T>;\n     snd ` flows_state \\<T> \\<subseteq> hosts \\<T>;\n     fst ` flows_fix \\<T> \\<subseteq> hosts \\<T>;\n     snd ` flows_fix \\<T> \\<subseteq> hosts \\<T>\\<rbrakk>\n    \\<Longrightarrow> fst `\n                      (flows_fix \\<T> \\<union> flows_state \\<T> \\<union>\n                       backflows (flows_state \\<T>))\n                      \\<subseteq> hosts \\<T>\n 2. \\<lbrakk>flows_state \\<T> \\<subseteq> flows_fix \\<T> \\<and>\n             finite (hosts \\<T>);\n     fst ` backflows (flows_state \\<T>) \\<subseteq> hosts \\<T>;\n     snd ` backflows (flows_state \\<T>) \\<subseteq> hosts \\<T>;\n     fst ` flows_state \\<T> \\<subseteq> hosts \\<T>;\n     snd ` flows_state \\<T> \\<subseteq> hosts \\<T>;\n     fst ` flows_fix \\<T> \\<subseteq> hosts \\<T>;\n     snd ` flows_fix \\<T> \\<subseteq> hosts \\<T>\\<rbrakk>\n    \\<Longrightarrow> snd `\n                      (flows_fix \\<T> \\<union> flows_state \\<T> \\<union>\n                       backflows (flows_state \\<T>))\n                      \\<subseteq> hosts \\<T>", "apply (metis image_Un sup.bounded_iff)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*we use the second way of writing it in the paper*)"], ["", "lemma \"(\\<forall>F \\<in> get_offending_flows (get_ACS M) (stateful_policy_to_network_graph \\<T> ). F \\<subseteq> backflows (filternew_flows_state \\<T>)) \\<longleftrightarrow>\n    \\<Union>(get_offending_flows (get_ACS M) (stateful_policy_to_network_graph \\<T>)) \\<subseteq> (backflows (flows_state \\<T>)) - (flows_fix \\<T>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>F\\<in>get_offending_flows (get_ACS M)\n                     (stateful_policy_to_network_graph \\<T>).\n        F \\<subseteq> backflows (filternew_flows_state \\<T>)) =\n    (\\<Union>\n      (get_offending_flows (get_ACS M)\n        (stateful_policy_to_network_graph \\<T>))\n     \\<subseteq> backflows (flows_state \\<T>) - flows_fix \\<T>)", "by(simp add: filternew_flows_state_alt backflows_minus_backflows, blast)"], ["", "text\\<open>When is a stateful policy @{term \"\\<T>\"} compliant with a high-level policy @{term \"G\"} and the security requirements @{term \"M\"}?\\<close>"], ["", "locale stateful_policy_compliance =  \n  fixes \\<T> :: \"('v::vertex) stateful_policy\"\n  fixes G :: \"'v graph\"\n  fixes M :: \"('v) SecurityInvariant_configured list\"\n  assumes\n    \\<comment> \\<open>the graph must be syntactically valid\\<close>\n    wfG: \"wf_graph G\"\n    and\n    \\<comment> \\<open>security requirements must be valid\\<close>\n    validReqs: \"valid_reqs M\"\n    and\n    \\<comment> \\<open>the high-level policy must be valid\\<close>\n    high_level_policy_valid: \"all_security_requirements_fulfilled M G\"\n    and\n    \\<comment> \\<open>the stateful policy must be syntactically valid\\<close>\n    stateful_policy_wf:\n    \"wf_stateful_policy \\<T>\"\n    and\n    \\<comment> \\<open>the stateful policy must talk about the same nodes as the high-level policy\\<close>\n    hosts_nodes:\n    \"hosts \\<T> = nodes G\"\n    and\n    \\<comment> \\<open>only flows that are allowed in the high-level policy are allowed in the stateful policy\\<close>\n    flows_edges:\n    \"flows_fix \\<T> \\<subseteq> edges G\"\n    and\n    \\<comment> \\<open>the low level policy must comply with the high-level policy\\<close>\n      \\<comment> \\<open>all information flow strategy requirements must be fulfilled, i.e. no leaks!\\<close>\n      compliant_stateful_IFS: \n        \"all_security_requirements_fulfilled (get_IFS M) (stateful_policy_to_network_graph \\<T>)\"\n      and\n      \\<comment> \\<open>No Access Control side effects must occur\\<close>\n      compliant_stateful_ACS: \n        \"\\<forall>F \\<in> get_offending_flows (get_ACS M) (stateful_policy_to_network_graph \\<T> ). F \\<subseteq> backflows (filternew_flows_state \\<T>)\"\n        \n  begin"], ["", "lemma compliant_stateful_ACS_no_side_effects_filternew_helper: \n      \"\\<forall> E \\<subseteq> backflows (filternew_flows_state \\<T>). \\<forall> F \\<in> get_offending_flows (get_ACS M) \\<lparr> nodes = hosts \\<T>, edges = flows_fix \\<T> \\<union> E \\<rparr>. F \\<subseteq> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>E\\<subseteq>backflows (filternew_flows_state \\<T>).\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "proof(rule, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows\n                      (filternew_flows_state \\<T>) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "fix E"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows\n                      (filternew_flows_state \\<T>) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "assume a1: \"E \\<subseteq> backflows (filternew_flows_state \\<T>)\""], ["proof (state)\nthis:\n  E \\<subseteq> backflows (filternew_flows_state \\<T>)\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows\n                      (filternew_flows_state \\<T>) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "from validReqs"], ["proof (chain)\npicking this:\n  valid_reqs M", "have valid_ReqsACS: \"valid_reqs (get_ACS M)\""], ["proof (prove)\nusing this:\n  valid_reqs M\n\ngoal (1 subgoal):\n 1. valid_reqs (get_ACS M)", "by(simp add: get_ACS_def valid_reqs_def)"], ["proof (state)\nthis:\n  valid_reqs (get_ACS M)\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows\n                      (filternew_flows_state \\<T>) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "from compliant_stateful_ACS stateful_policy_to_network_graph_filternew[OF stateful_policy_wf]"], ["proof (chain)\npicking this:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  (stateful_policy_to_network_graph \\<T>).\n     F \\<subseteq> backflows (filternew_flows_state \\<T>)\n  stateful_policy_to_network_graph \\<T> =\n  stateful_policy_to_network_graph\n   \\<lparr>hosts = hosts \\<T>, flows_fix = flows_fix \\<T>,\n      flows_state = filternew_flows_state \\<T>\\<rparr>", "have compliant_stateful_ACS_only_state_violations_filternew: \n      \"\\<forall>F \\<in> get_offending_flows (get_ACS M) (stateful_policy_to_network_graph \\<lparr>hosts = hosts \\<T>, flows_fix = flows_fix \\<T>, flows_state = filternew_flows_state \\<T> \\<rparr>). F \\<subseteq> backflows (filternew_flows_state \\<T>)\""], ["proof (prove)\nusing this:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  (stateful_policy_to_network_graph \\<T>).\n     F \\<subseteq> backflows (filternew_flows_state \\<T>)\n  stateful_policy_to_network_graph \\<T> =\n  stateful_policy_to_network_graph\n   \\<lparr>hosts = hosts \\<T>, flows_fix = flows_fix \\<T>,\n      flows_state = filternew_flows_state \\<T>\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                    (stateful_policy_to_network_graph\n                      \\<lparr>hosts = hosts \\<T>,\n                         flows_fix = flows_fix \\<T>,\n                         flows_state = filternew_flows_state \\<T>\\<rparr>).\n       F \\<subseteq> backflows (filternew_flows_state \\<T>)", "by simp"], ["proof (state)\nthis:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  (stateful_policy_to_network_graph\n                    \\<lparr>hosts = hosts \\<T>, flows_fix = flows_fix \\<T>,\n                       flows_state = filternew_flows_state \\<T>\\<rparr>).\n     F \\<subseteq> backflows (filternew_flows_state \\<T>)\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows\n                      (filternew_flows_state \\<T>) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "from wf_stateful_policy_is_wf_graph[OF stateful_policy_wf]"], ["proof (chain)\npicking this:\n  wf_graph \\<lparr>nodes = hosts \\<T>, edges = all_flows \\<T>\\<rparr>", "have wfGfilternew: \n        \"wf_graph \\<lparr>nodes = hosts \\<T>, edges = flows_fix \\<T> \\<union> filternew_flows_state \\<T> \\<union> backflows (filternew_flows_state \\<T>)\\<rparr>\""], ["proof (prove)\nusing this:\n  wf_graph \\<lparr>nodes = hosts \\<T>, edges = all_flows \\<T>\\<rparr>\n\ngoal (1 subgoal):\n 1. wf_graph\n     \\<lparr>nodes = hosts \\<T>,\n        edges =\n          flows_fix \\<T> \\<union> filternew_flows_state \\<T> \\<union>\n          backflows (filternew_flows_state \\<T>)\\<rparr>", "apply(simp add: all_flows_def filternew_flows_state_alt backflows_minus_backflows)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph\n     \\<lparr>nodes = hosts \\<T>,\n        edges =\n          flows_fix \\<T> \\<union> flows_state \\<T> \\<union>\n          backflows (flows_state \\<T>)\\<rparr> \\<Longrightarrow>\n    wf_graph\n     \\<lparr>nodes = hosts \\<T>,\n        edges =\n          flows_fix \\<T> \\<union>\n          (flows_state \\<T> - backflows (flows_fix \\<T>)) \\<union>\n          (backflows (flows_state \\<T>) - flows_fix \\<T>)\\<rparr>", "by(auto simp add: wf_graph_def)"], ["proof (state)\nthis:\n  wf_graph\n   \\<lparr>nodes = hosts \\<T>,\n      edges =\n        flows_fix \\<T> \\<union> filternew_flows_state \\<T> \\<union>\n        backflows (filternew_flows_state \\<T>)\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows\n                      (filternew_flows_state \\<T>) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "from wf_stateful_policy.E_state_fix[OF stateful_policy_wf] filternew_subseteq_flows_state"], ["proof (chain)\npicking this:\n  flows_state \\<T> \\<subseteq> flows_fix \\<T>\n  filternew_flows_state ?\\<T> \\<subseteq> flows_state ?\\<T>", "have flows_fix_un_filternew_simp: \"flows_fix \\<T> \\<union> filternew_flows_state \\<T> = flows_fix \\<T>\""], ["proof (prove)\nusing this:\n  flows_state \\<T> \\<subseteq> flows_fix \\<T>\n  filternew_flows_state ?\\<T> \\<subseteq> flows_state ?\\<T>\n\ngoal (1 subgoal):\n 1. flows_fix \\<T> \\<union> filternew_flows_state \\<T> = flows_fix \\<T>", "by blast"], ["proof (state)\nthis:\n  flows_fix \\<T> \\<union> filternew_flows_state \\<T> = flows_fix \\<T>\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows\n                      (filternew_flows_state \\<T>) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "from compliant_stateful_ACS_only_state_violations_filternew"], ["proof (chain)\npicking this:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  (stateful_policy_to_network_graph\n                    \\<lparr>hosts = hosts \\<T>, flows_fix = flows_fix \\<T>,\n                       flows_state = filternew_flows_state \\<T>\\<rparr>).\n     F \\<subseteq> backflows (filternew_flows_state \\<T>)", "have \n        \"\\<And>m. m \\<in> set (get_ACS M) \\<Longrightarrow> \n        \\<Union>(c_offending_flows m \\<lparr>nodes = hosts \\<T>, edges = flows_fix \\<T> \\<union> filternew_flows_state \\<T> \\<union> backflows (filternew_flows_state \\<T>)\\<rparr>) \\<subseteq> backflows (filternew_flows_state \\<T>)\""], ["proof (prove)\nusing this:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  (stateful_policy_to_network_graph\n                    \\<lparr>hosts = hosts \\<T>, flows_fix = flows_fix \\<T>,\n                       flows_state = filternew_flows_state \\<T>\\<rparr>).\n     F \\<subseteq> backflows (filternew_flows_state \\<T>)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<in> set (get_ACS M) \\<Longrightarrow>\n       \\<Union>\n        (c_offending_flows m\n          \\<lparr>nodes = hosts \\<T>,\n             edges =\n               flows_fix \\<T> \\<union> filternew_flows_state \\<T> \\<union>\n               backflows (filternew_flows_state \\<T>)\\<rparr>)\n       \\<subseteq> backflows (filternew_flows_state \\<T>)", "by(simp add: stateful_policy_to_network_graph_def all_flows_def get_offending_flows_def, blast)\n    \n      \\<comment> \\<open>idea: use @{thm compliant_stateful_ACS} with the @{thm configured_SecurityInvariant.Un_set_offending_flows_bound_minus_subseteq} \n        lemma and substract @{term \"backflows (filternew_flows_state \\<T>) - E\"}, on the right hand side @{term E} remains, as Graph's edges @{term \"flows_fix \\<T>  \\<union> E\"} remains\\<close>"], ["proof (state)\nthis:\n  ?m \\<in> set (get_ACS M) \\<Longrightarrow>\n  \\<Union>\n   (c_offending_flows ?m\n     \\<lparr>nodes = hosts \\<T>,\n        edges =\n          flows_fix \\<T> \\<union> filternew_flows_state \\<T> \\<union>\n          backflows (filternew_flows_state \\<T>)\\<rparr>)\n  \\<subseteq> backflows (filternew_flows_state \\<T>)\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows\n                      (filternew_flows_state \\<T>) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "from configured_SecurityInvariant.Un_set_offending_flows_bound_minus_subseteq[where X=\"backflows (filternew_flows_state \\<T>)\", OF _ wfGfilternew this]\n        \\<open>valid_reqs (get_ACS M)\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>configured_SecurityInvariant ?m;\n   ?m \\<in> set (get_ACS M)\\<rbrakk>\n  \\<Longrightarrow> \\<Union>\n                     (c_offending_flows ?m\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges =\n                            flows_fix \\<T> \\<union>\n                            filternew_flows_state \\<T> \\<union>\n                            backflows (filternew_flows_state \\<T>) -\n                            ?E'\\<rparr>)\n                    \\<subseteq> backflows (filternew_flows_state \\<T>) - ?E'\n  valid_reqs (get_ACS M)", "have\n        \"\\<And> m E. m \\<in> set (get_ACS M) \\<Longrightarrow>\n        \\<forall>F\\<in>c_offending_flows m \\<lparr>nodes = hosts \\<T>, edges = flows_fix \\<T> \\<union> filternew_flows_state \\<T> \\<union> backflows (filternew_flows_state \\<T>) - E\\<rparr>. F \\<subseteq> backflows (filternew_flows_state \\<T>) - E\""], ["proof (prove)\nusing this:\n  \\<lbrakk>configured_SecurityInvariant ?m;\n   ?m \\<in> set (get_ACS M)\\<rbrakk>\n  \\<Longrightarrow> \\<Union>\n                     (c_offending_flows ?m\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges =\n                            flows_fix \\<T> \\<union>\n                            filternew_flows_state \\<T> \\<union>\n                            backflows (filternew_flows_state \\<T>) -\n                            ?E'\\<rparr>)\n                    \\<subseteq> backflows (filternew_flows_state \\<T>) - ?E'\n  valid_reqs (get_ACS M)\n\ngoal (1 subgoal):\n 1. \\<And>m E.\n       m \\<in> set (get_ACS M) \\<Longrightarrow>\n       \\<forall>F\\<in>c_offending_flows m\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges =\n                            flows_fix \\<T> \\<union>\n                            filternew_flows_state \\<T> \\<union>\n                            backflows (filternew_flows_state \\<T>) -\n                            E\\<rparr>.\n          F \\<subseteq> backflows (filternew_flows_state \\<T>) - E", "by(auto simp add: all_flows_def valid_reqs_def)"], ["proof (state)\nthis:\n  ?m \\<in> set (get_ACS M) \\<Longrightarrow>\n  \\<forall>F\\<in>c_offending_flows ?m\n                  \\<lparr>nodes = hosts \\<T>,\n                     edges =\n                       flows_fix \\<T> \\<union>\n                       filternew_flows_state \\<T> \\<union>\n                       backflows (filternew_flows_state \\<T>) -\n                       ?E\\<rparr>.\n     F \\<subseteq> backflows (filternew_flows_state \\<T>) - ?E\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows\n                      (filternew_flows_state \\<T>) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "from this flows_fix_un_filternew_simp"], ["proof (chain)\npicking this:\n  ?m \\<in> set (get_ACS M) \\<Longrightarrow>\n  \\<forall>F\\<in>c_offending_flows ?m\n                  \\<lparr>nodes = hosts \\<T>,\n                     edges =\n                       flows_fix \\<T> \\<union>\n                       filternew_flows_state \\<T> \\<union>\n                       backflows (filternew_flows_state \\<T>) -\n                       ?E\\<rparr>.\n     F \\<subseteq> backflows (filternew_flows_state \\<T>) - ?E\n  flows_fix \\<T> \\<union> filternew_flows_state \\<T> = flows_fix \\<T>", "have rule:\n        \"\\<And> m E. m \\<in> set (get_ACS M) \\<Longrightarrow>\n        \\<forall>F\\<in>c_offending_flows m \\<lparr>nodes = hosts \\<T>, edges = flows_fix \\<T> \\<union> backflows (filternew_flows_state \\<T>) - E\\<rparr>. F \\<subseteq> backflows (filternew_flows_state \\<T>) - E\""], ["proof (prove)\nusing this:\n  ?m \\<in> set (get_ACS M) \\<Longrightarrow>\n  \\<forall>F\\<in>c_offending_flows ?m\n                  \\<lparr>nodes = hosts \\<T>,\n                     edges =\n                       flows_fix \\<T> \\<union>\n                       filternew_flows_state \\<T> \\<union>\n                       backflows (filternew_flows_state \\<T>) -\n                       ?E\\<rparr>.\n     F \\<subseteq> backflows (filternew_flows_state \\<T>) - ?E\n  flows_fix \\<T> \\<union> filternew_flows_state \\<T> = flows_fix \\<T>\n\ngoal (1 subgoal):\n 1. \\<And>m E.\n       m \\<in> set (get_ACS M) \\<Longrightarrow>\n       \\<forall>F\\<in>c_offending_flows m\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges =\n                            flows_fix \\<T> \\<union>\n                            backflows (filternew_flows_state \\<T>) -\n                            E\\<rparr>.\n          F \\<subseteq> backflows (filternew_flows_state \\<T>) - E", "by simp"], ["proof (state)\nthis:\n  ?m \\<in> set (get_ACS M) \\<Longrightarrow>\n  \\<forall>F\\<in>c_offending_flows ?m\n                  \\<lparr>nodes = hosts \\<T>,\n                     edges =\n                       flows_fix \\<T> \\<union>\n                       backflows (filternew_flows_state \\<T>) -\n                       ?E\\<rparr>.\n     F \\<subseteq> backflows (filternew_flows_state \\<T>) - ?E\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows\n                      (filternew_flows_state \\<T>) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "from  backflows_finite rev_finite_subset[OF wf_stateful_policy.finite_state[OF stateful_policy_wf] filternew_subseteq_flows_state]"], ["proof (chain)\npicking this:\n  finite ?E \\<Longrightarrow> finite (backflows ?E)\n  finite (filternew_flows_state \\<T>)", "have\n        \"finite (backflows (filternew_flows_state \\<T>))\""], ["proof (prove)\nusing this:\n  finite ?E \\<Longrightarrow> finite (backflows ?E)\n  finite (filternew_flows_state \\<T>)\n\ngoal (1 subgoal):\n 1. finite (backflows (filternew_flows_state \\<T>))", "by blast"], ["proof (state)\nthis:\n  finite (backflows (filternew_flows_state \\<T>))\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows\n                      (filternew_flows_state \\<T>) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "from a1 this"], ["proof (chain)\npicking this:\n  E \\<subseteq> backflows (filternew_flows_state \\<T>)\n  finite (backflows (filternew_flows_state \\<T>))", "have \"finite E\""], ["proof (prove)\nusing this:\n  E \\<subseteq> backflows (filternew_flows_state \\<T>)\n  finite (backflows (filternew_flows_state \\<T>))\n\ngoal (1 subgoal):\n 1. finite E", "by (metis rev_finite_subset)"], ["proof (state)\nthis:\n  finite E\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows\n                      (filternew_flows_state \\<T>) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "from a1"], ["proof (chain)\npicking this:\n  E \\<subseteq> backflows (filternew_flows_state \\<T>)", "obtain E' where E'_prop1: \"backflows (filternew_flows_state \\<T>) - E' = E\" and E'_prop2: \"E' = backflows (filternew_flows_state \\<T>) - E\""], ["proof (prove)\nusing this:\n  E \\<subseteq> backflows (filternew_flows_state \\<T>)\n\ngoal (1 subgoal):\n 1. (\\<And>E'.\n        \\<lbrakk>backflows (filternew_flows_state \\<T>) - E' = E;\n         E' = backflows (filternew_flows_state \\<T>) - E\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  backflows (filternew_flows_state \\<T>) - E' = E\n  E' = backflows (filternew_flows_state \\<T>) - E\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows\n                      (filternew_flows_state \\<T>) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "from E'_prop2 \\<open>finite (backflows (filternew_flows_state \\<T>))\\<close> \\<open>finite E\\<close>"], ["proof (chain)\npicking this:\n  E' = backflows (filternew_flows_state \\<T>) - E\n  finite (backflows (filternew_flows_state \\<T>))\n  finite E", "have \"finite E'\""], ["proof (prove)\nusing this:\n  E' = backflows (filternew_flows_state \\<T>) - E\n  finite (backflows (filternew_flows_state \\<T>))\n  finite E\n\ngoal (1 subgoal):\n 1. finite E'", "by blast"], ["proof (state)\nthis:\n  finite E'\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows\n                      (filternew_flows_state \\<T>) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "from Set.double_diff[where B=\"backflows (filternew_flows_state \\<T>)\" and C=\"backflows (filternew_flows_state \\<T>)\" and A=\"E\", OF a1, simplified]"], ["proof (chain)\npicking this:\n  backflows (filternew_flows_state \\<T>) -\n  (backflows (filternew_flows_state \\<T>) - E) =\n  E", "have Ebackflowssimp:\n        \"backflows (filternew_flows_state \\<T>) - (backflows (filternew_flows_state \\<T>) - E) = E\""], ["proof (prove)\nusing this:\n  backflows (filternew_flows_state \\<T>) -\n  (backflows (filternew_flows_state \\<T>) - E) =\n  E\n\ngoal (1 subgoal):\n 1. backflows (filternew_flows_state \\<T>) -\n    (backflows (filternew_flows_state \\<T>) - E) =\n    E", "."], ["proof (state)\nthis:\n  backflows (filternew_flows_state \\<T>) -\n  (backflows (filternew_flows_state \\<T>) - E) =\n  E\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows\n                      (filternew_flows_state \\<T>) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "have \"flows_fix \\<T> \\<union> backflows (filternew_flows_state \\<T>) - (backflows (filternew_flows_state \\<T>) - E) = \n          (flows_fix \\<T> - (backflows (filternew_flows_state \\<T>))) \\<union> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flows_fix \\<T> \\<union> backflows (filternew_flows_state \\<T>) -\n    (backflows (filternew_flows_state \\<T>) - E) =\n    flows_fix \\<T> - backflows (filternew_flows_state \\<T>) \\<union> E", "apply(simp add: Set.Un_Diff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. flows_fix \\<T> - (backflows (filternew_flows_state \\<T>) - E) \\<union>\n    (backflows (filternew_flows_state \\<T>) -\n     (backflows (filternew_flows_state \\<T>) - E)) =\n    flows_fix \\<T> - backflows (filternew_flows_state \\<T>) \\<union> E", "apply(simp add: Ebackflowssimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. flows_fix \\<T> - (backflows (filternew_flows_state \\<T>) - E) \\<union>\n    E =\n    flows_fix \\<T> - backflows (filternew_flows_state \\<T>) \\<union> E", "by blast"], ["proof (state)\nthis:\n  flows_fix \\<T> \\<union> backflows (filternew_flows_state \\<T>) -\n  (backflows (filternew_flows_state \\<T>) - E) =\n  flows_fix \\<T> - backflows (filternew_flows_state \\<T>) \\<union> E\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows\n                      (filternew_flows_state \\<T>) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "also"], ["proof (state)\nthis:\n  flows_fix \\<T> \\<union> backflows (filternew_flows_state \\<T>) -\n  (backflows (filternew_flows_state \\<T>) - E) =\n  flows_fix \\<T> - backflows (filternew_flows_state \\<T>) \\<union> E\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows\n                      (filternew_flows_state \\<T>) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "have \"(flows_fix \\<T> - (backflows (filternew_flows_state \\<T>))) \\<union> E = flows_fix \\<T>  \\<union> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flows_fix \\<T> - backflows (filternew_flows_state \\<T>) \\<union> E =\n    flows_fix \\<T> \\<union> E", "using backflows_filternew_disjunct_flows_fix"], ["proof (prove)\nusing this:\n  \\<forall>b\\<in>backflows (filternew_flows_state ?\\<T>).\n     b \\<notin> flows_fix ?\\<T>\n\ngoal (1 subgoal):\n 1. flows_fix \\<T> - backflows (filternew_flows_state \\<T>) \\<union> E =\n    flows_fix \\<T> \\<union> E", "by blast"], ["proof (state)\nthis:\n  flows_fix \\<T> - backflows (filternew_flows_state \\<T>) \\<union> E =\n  flows_fix \\<T> \\<union> E\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows\n                      (filternew_flows_state \\<T>) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "finally"], ["proof (chain)\npicking this:\n  flows_fix \\<T> \\<union> backflows (filternew_flows_state \\<T>) -\n  (backflows (filternew_flows_state \\<T>) - E) =\n  flows_fix \\<T> \\<union> E", "have flows_E_simp: \"flows_fix \\<T> \\<union> backflows (filternew_flows_state \\<T>) - (backflows (filternew_flows_state \\<T>) - E) = flows_fix \\<T>  \\<union> E\""], ["proof (prove)\nusing this:\n  flows_fix \\<T> \\<union> backflows (filternew_flows_state \\<T>) -\n  (backflows (filternew_flows_state \\<T>) - E) =\n  flows_fix \\<T> \\<union> E\n\ngoal (1 subgoal):\n 1. flows_fix \\<T> \\<union> backflows (filternew_flows_state \\<T>) -\n    (backflows (filternew_flows_state \\<T>) - E) =\n    flows_fix \\<T> \\<union> E", "."], ["proof (state)\nthis:\n  flows_fix \\<T> \\<union> backflows (filternew_flows_state \\<T>) -\n  (backflows (filternew_flows_state \\<T>) - E) =\n  flows_fix \\<T> \\<union> E\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows\n                      (filternew_flows_state \\<T>) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "from rule[simplified E'_prop1 E'_prop2]"], ["proof (chain)\npicking this:\n  ?m \\<in> set (get_ACS M) \\<Longrightarrow>\n  \\<forall>F\\<in>c_offending_flows ?m\n                  \\<lparr>nodes = hosts \\<T>,\n                     edges =\n                       flows_fix \\<T> \\<union>\n                       backflows (filternew_flows_state \\<T>) -\n                       ?E\\<rparr>.\n     F \\<subseteq> backflows (filternew_flows_state \\<T>) - ?E", "have\n      \"\\<And>m. m \\<in> set (get_ACS M) \\<Longrightarrow>\n      \\<forall>F\\<in>c_offending_flows m \\<lparr>nodes = hosts \\<T>, edges = flows_fix \\<T> \\<union> backflows (filternew_flows_state \\<T>) - (backflows (filternew_flows_state \\<T>) - E)\\<rparr>.\n       F \\<subseteq> backflows (filternew_flows_state \\<T>) - (backflows (filternew_flows_state \\<T>) - E)\""], ["proof (prove)\nusing this:\n  ?m \\<in> set (get_ACS M) \\<Longrightarrow>\n  \\<forall>F\\<in>c_offending_flows ?m\n                  \\<lparr>nodes = hosts \\<T>,\n                     edges =\n                       flows_fix \\<T> \\<union>\n                       backflows (filternew_flows_state \\<T>) -\n                       ?E\\<rparr>.\n     F \\<subseteq> backflows (filternew_flows_state \\<T>) - ?E\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<in> set (get_ACS M) \\<Longrightarrow>\n       \\<forall>F\\<in>c_offending_flows m\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges =\n                            flows_fix \\<T> \\<union>\n                            backflows (filternew_flows_state \\<T>) -\n                            (backflows (filternew_flows_state \\<T>) -\n                             E)\\<rparr>.\n          F \\<subseteq> backflows (filternew_flows_state \\<T>) -\n                        (backflows (filternew_flows_state \\<T>) - E)", "by(simp)"], ["proof (state)\nthis:\n  ?m \\<in> set (get_ACS M) \\<Longrightarrow>\n  \\<forall>F\\<in>c_offending_flows ?m\n                  \\<lparr>nodes = hosts \\<T>,\n                     edges =\n                       flows_fix \\<T> \\<union>\n                       backflows (filternew_flows_state \\<T>) -\n                       (backflows (filternew_flows_state \\<T>) - E)\\<rparr>.\n     F \\<subseteq> backflows (filternew_flows_state \\<T>) -\n                   (backflows (filternew_flows_state \\<T>) - E)\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows\n                      (filternew_flows_state \\<T>) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "from this Ebackflowssimp flows_E_simp"], ["proof (chain)\npicking this:\n  ?m \\<in> set (get_ACS M) \\<Longrightarrow>\n  \\<forall>F\\<in>c_offending_flows ?m\n                  \\<lparr>nodes = hosts \\<T>,\n                     edges =\n                       flows_fix \\<T> \\<union>\n                       backflows (filternew_flows_state \\<T>) -\n                       (backflows (filternew_flows_state \\<T>) - E)\\<rparr>.\n     F \\<subseteq> backflows (filternew_flows_state \\<T>) -\n                   (backflows (filternew_flows_state \\<T>) - E)\n  backflows (filternew_flows_state \\<T>) -\n  (backflows (filternew_flows_state \\<T>) - E) =\n  E\n  flows_fix \\<T> \\<union> backflows (filternew_flows_state \\<T>) -\n  (backflows (filternew_flows_state \\<T>) - E) =\n  flows_fix \\<T> \\<union> E", "have\n      \"\\<And>m. m \\<in> set (get_ACS M) \\<Longrightarrow>\n        \\<forall>F\\<in>c_offending_flows m \\<lparr>nodes = hosts \\<T>, edges = flows_fix \\<T> \\<union> E\\<rparr>. F \\<subseteq> E\""], ["proof (prove)\nusing this:\n  ?m \\<in> set (get_ACS M) \\<Longrightarrow>\n  \\<forall>F\\<in>c_offending_flows ?m\n                  \\<lparr>nodes = hosts \\<T>,\n                     edges =\n                       flows_fix \\<T> \\<union>\n                       backflows (filternew_flows_state \\<T>) -\n                       (backflows (filternew_flows_state \\<T>) - E)\\<rparr>.\n     F \\<subseteq> backflows (filternew_flows_state \\<T>) -\n                   (backflows (filternew_flows_state \\<T>) - E)\n  backflows (filternew_flows_state \\<T>) -\n  (backflows (filternew_flows_state \\<T>) - E) =\n  E\n  flows_fix \\<T> \\<union> backflows (filternew_flows_state \\<T>) -\n  (backflows (filternew_flows_state \\<T>) - E) =\n  flows_fix \\<T> \\<union> E\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<in> set (get_ACS M) \\<Longrightarrow>\n       \\<forall>F\\<in>c_offending_flows m\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "by simp"], ["proof (state)\nthis:\n  ?m \\<in> set (get_ACS M) \\<Longrightarrow>\n  \\<forall>F\\<in>c_offending_flows ?m\n                  \\<lparr>nodes = hosts \\<T>,\n                     edges = flows_fix \\<T> \\<union> E\\<rparr>.\n     F \\<subseteq> E\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows\n                      (filternew_flows_state \\<T>) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "thus  \"\\<forall>F\\<in>get_offending_flows (get_ACS M) \\<lparr>nodes = hosts \\<T>, edges = flows_fix \\<T> \\<union> E\\<rparr>. F \\<subseteq> E\""], ["proof (prove)\nusing this:\n  ?m \\<in> set (get_ACS M) \\<Longrightarrow>\n  \\<forall>F\\<in>c_offending_flows ?m\n                  \\<lparr>nodes = hosts \\<T>,\n                     edges = flows_fix \\<T> \\<union> E\\<rparr>.\n     F \\<subseteq> E\n\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                    \\<lparr>nodes = hosts \\<T>,\n                       edges = flows_fix \\<T> \\<union> E\\<rparr>.\n       F \\<subseteq> E", "by(simp add: get_offending_flows_def)"], ["proof (state)\nthis:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  \\<lparr>nodes = hosts \\<T>,\n                     edges = flows_fix \\<T> \\<union> E\\<rparr>.\n     F \\<subseteq> E\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem compliant_stateful_ACS_no_side_effects:\n      \"\\<forall> E \\<subseteq> backflows (flows_state \\<T>). \\<forall> F \\<in> get_offending_flows(get_ACS M) \\<lparr> nodes = hosts \\<T>, edges = flows_fix \\<T> \\<union> E \\<rparr>. F \\<subseteq> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>E\\<subseteq>backflows (flows_state \\<T>).\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>E\\<subseteq>backflows (flows_state \\<T>).\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "from compliant_stateful_ACS stateful_policy_to_network_graph_filternew[OF stateful_policy_wf]"], ["proof (chain)\npicking this:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  (stateful_policy_to_network_graph \\<T>).\n     F \\<subseteq> backflows (filternew_flows_state \\<T>)\n  stateful_policy_to_network_graph \\<T> =\n  stateful_policy_to_network_graph\n   \\<lparr>hosts = hosts \\<T>, flows_fix = flows_fix \\<T>,\n      flows_state = filternew_flows_state \\<T>\\<rparr>", "have a1: \n      \"\\<forall>F \\<in> get_offending_flows (get_ACS M) (stateful_policy_to_network_graph \\<lparr>hosts = hosts \\<T>, flows_fix = flows_fix \\<T>, flows_state = filternew_flows_state \\<T> \\<rparr>). F \\<subseteq> backflows (filternew_flows_state \\<T>)\""], ["proof (prove)\nusing this:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  (stateful_policy_to_network_graph \\<T>).\n     F \\<subseteq> backflows (filternew_flows_state \\<T>)\n  stateful_policy_to_network_graph \\<T> =\n  stateful_policy_to_network_graph\n   \\<lparr>hosts = hosts \\<T>, flows_fix = flows_fix \\<T>,\n      flows_state = filternew_flows_state \\<T>\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                    (stateful_policy_to_network_graph\n                      \\<lparr>hosts = hosts \\<T>,\n                         flows_fix = flows_fix \\<T>,\n                         flows_state = filternew_flows_state \\<T>\\<rparr>).\n       F \\<subseteq> backflows (filternew_flows_state \\<T>)", "by simp"], ["proof (state)\nthis:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  (stateful_policy_to_network_graph\n                    \\<lparr>hosts = hosts \\<T>, flows_fix = flows_fix \\<T>,\n                       flows_state = filternew_flows_state \\<T>\\<rparr>).\n     F \\<subseteq> backflows (filternew_flows_state \\<T>)\n\ngoal (1 subgoal):\n 1. \\<forall>E\\<subseteq>backflows (flows_state \\<T>).\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "have backflows_split: \"backflows (filternew_flows_state \\<T>) \\<union> (backflows (flows_state \\<T>) - backflows (filternew_flows_state \\<T>)) = backflows (flows_state \\<T>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backflows (filternew_flows_state \\<T>) \\<union>\n    (backflows (flows_state \\<T>) -\n     backflows (filternew_flows_state \\<T>)) =\n    backflows (flows_state \\<T>)", "by (metis Diff_subset Un_Diff_cancel Un_absorb1 backflows_minus_backflows filternew_flows_state_alt)"], ["proof (state)\nthis:\n  backflows (filternew_flows_state \\<T>) \\<union>\n  (backflows (flows_state \\<T>) - backflows (filternew_flows_state \\<T>)) =\n  backflows (flows_state \\<T>)\n\ngoal (1 subgoal):\n 1. \\<forall>E\\<subseteq>backflows (flows_state \\<T>).\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "have \n        \"\\<forall>E\\<subseteq>backflows (filternew_flows_state \\<T>) \\<union> (backflows (flows_state \\<T>) - backflows (filternew_flows_state \\<T>)). \n             \\<forall>F\\<in>get_offending_flows (get_ACS M) \\<lparr>nodes = hosts \\<T>, edges = flows_fix \\<T> \\<union> E\\<rparr>. F \\<subseteq> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>E\\<subseteq>backflows (filternew_flows_state \\<T>) \\<union>\n                         (backflows (flows_state \\<T>) -\n                          backflows (filternew_flows_state \\<T>)).\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "proof(rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows (filternew_flows_state \\<T>) \\<union>\n                     (backflows (flows_state \\<T>) -\n                      backflows\n                       (filternew_flows_state \\<T>)) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "fix E"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows (filternew_flows_state \\<T>) \\<union>\n                     (backflows (flows_state \\<T>) -\n                      backflows\n                       (filternew_flows_state \\<T>)) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "assume h1: \"E \\<subseteq> backflows (filternew_flows_state \\<T>) \\<union> (backflows (flows_state \\<T>) - backflows (filternew_flows_state \\<T>))\""], ["proof (state)\nthis:\n  E \\<subseteq> backflows (filternew_flows_state \\<T>) \\<union>\n                (backflows (flows_state \\<T>) -\n                 backflows (filternew_flows_state \\<T>))\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows (filternew_flows_state \\<T>) \\<union>\n                     (backflows (flows_state \\<T>) -\n                      backflows\n                       (filternew_flows_state \\<T>)) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "have \"\\<exists> E1 E2. E1 \\<subseteq> backflows (filternew_flows_state \\<T>) \\<and> E2 \\<subseteq> (backflows (flows_state \\<T>) - backflows (filternew_flows_state \\<T>)) \\<and> E1 \\<union> E2 = E \\<and> E1 \\<inter> E2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>E1 E2.\n       E1 \\<subseteq> backflows (filternew_flows_state \\<T>) \\<and>\n       E2 \\<subseteq> backflows (flows_state \\<T>) -\n                      backflows (filternew_flows_state \\<T>) \\<and>\n       E1 \\<union> E2 = E \\<and> E1 \\<inter> E2 = {}", "apply(rule_tac x=\"{e \\<in> E. e \\<in> backflows (filternew_flows_state \\<T>)}\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>E2.\n       {e \\<in> E. e \\<in> backflows (filternew_flows_state \\<T>)}\n       \\<subseteq> backflows (filternew_flows_state \\<T>) \\<and>\n       E2 \\<subseteq> backflows (flows_state \\<T>) -\n                      backflows (filternew_flows_state \\<T>) \\<and>\n       {e \\<in> E. e \\<in> backflows (filternew_flows_state \\<T>)} \\<union>\n       E2 =\n       E \\<and>\n       {e \\<in> E. e \\<in> backflows (filternew_flows_state \\<T>)} \\<inter>\n       E2 =\n       {}", "apply(rule_tac x=\"{e \\<in> E. e \\<in>(backflows (flows_state \\<T>) - backflows (filternew_flows_state \\<T>))}\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {e \\<in> E. e \\<in> backflows (filternew_flows_state \\<T>)}\n    \\<subseteq> backflows (filternew_flows_state \\<T>) \\<and>\n    {e \\<in> E.\n     e \\<in> backflows (flows_state \\<T>) -\n             backflows (filternew_flows_state \\<T>)}\n    \\<subseteq> backflows (flows_state \\<T>) -\n                backflows (filternew_flows_state \\<T>) \\<and>\n    {e \\<in> E. e \\<in> backflows (filternew_flows_state \\<T>)} \\<union>\n    {e \\<in> E.\n     e \\<in> backflows (flows_state \\<T>) -\n             backflows (filternew_flows_state \\<T>)} =\n    E \\<and>\n    {e \\<in> E. e \\<in> backflows (filternew_flows_state \\<T>)} \\<inter>\n    {e \\<in> E.\n     e \\<in> backflows (flows_state \\<T>) -\n             backflows (filternew_flows_state \\<T>)} =\n    {}", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {e \\<in> E. e \\<in> backflows (filternew_flows_state \\<T>)}\n    \\<subseteq> backflows (filternew_flows_state \\<T>) \\<and>\n    {e \\<in> E.\n     e \\<in> backflows (flows_state \\<T>) \\<and>\n     e \\<notin> backflows (filternew_flows_state \\<T>)}\n    \\<subseteq> backflows (flows_state \\<T>) -\n                backflows (filternew_flows_state \\<T>) \\<and>\n    {e \\<in> E. e \\<in> backflows (filternew_flows_state \\<T>)} \\<union>\n    {e \\<in> E.\n     e \\<in> backflows (flows_state \\<T>) \\<and>\n     e \\<notin> backflows (filternew_flows_state \\<T>)} =\n    E \\<and>\n    {e \\<in> E. e \\<in> backflows (filternew_flows_state \\<T>)} \\<inter>\n    {e \\<in> E.\n     e \\<in> backflows (flows_state \\<T>) \\<and>\n     e \\<notin> backflows (filternew_flows_state \\<T>)} =\n    {}", "apply(rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {e \\<in> E. e \\<in> backflows (filternew_flows_state \\<T>)}\n    \\<subseteq> backflows (filternew_flows_state \\<T>)\n 2. {e \\<in> E.\n     e \\<in> backflows (flows_state \\<T>) \\<and>\n     e \\<notin> backflows (filternew_flows_state \\<T>)}\n    \\<subseteq> backflows (flows_state \\<T>) -\n                backflows (filternew_flows_state \\<T>) \\<and>\n    {e \\<in> E. e \\<in> backflows (filternew_flows_state \\<T>)} \\<union>\n    {e \\<in> E.\n     e \\<in> backflows (flows_state \\<T>) \\<and>\n     e \\<notin> backflows (filternew_flows_state \\<T>)} =\n    E \\<and>\n    {e \\<in> E. e \\<in> backflows (filternew_flows_state \\<T>)} \\<inter>\n    {e \\<in> E.\n     e \\<in> backflows (flows_state \\<T>) \\<and>\n     e \\<notin> backflows (filternew_flows_state \\<T>)} =\n    {}", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. {e \\<in> E.\n     e \\<in> backflows (flows_state \\<T>) \\<and>\n     e \\<notin> backflows (filternew_flows_state \\<T>)}\n    \\<subseteq> backflows (flows_state \\<T>) -\n                backflows (filternew_flows_state \\<T>) \\<and>\n    {e \\<in> E. e \\<in> backflows (filternew_flows_state \\<T>)} \\<union>\n    {e \\<in> E.\n     e \\<in> backflows (flows_state \\<T>) \\<and>\n     e \\<notin> backflows (filternew_flows_state \\<T>)} =\n    E \\<and>\n    {e \\<in> E. e \\<in> backflows (filternew_flows_state \\<T>)} \\<inter>\n    {e \\<in> E.\n     e \\<in> backflows (flows_state \\<T>) \\<and>\n     e \\<notin> backflows (filternew_flows_state \\<T>)} =\n    {}", "apply(rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {e \\<in> E.\n     e \\<in> backflows (flows_state \\<T>) \\<and>\n     e \\<notin> backflows (filternew_flows_state \\<T>)}\n    \\<subseteq> backflows (flows_state \\<T>) -\n                backflows (filternew_flows_state \\<T>)\n 2. {e \\<in> E. e \\<in> backflows (filternew_flows_state \\<T>)} \\<union>\n    {e \\<in> E.\n     e \\<in> backflows (flows_state \\<T>) \\<and>\n     e \\<notin> backflows (filternew_flows_state \\<T>)} =\n    E \\<and>\n    {e \\<in> E. e \\<in> backflows (filternew_flows_state \\<T>)} \\<inter>\n    {e \\<in> E.\n     e \\<in> backflows (flows_state \\<T>) \\<and>\n     e \\<notin> backflows (filternew_flows_state \\<T>)} =\n    {}", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. {e \\<in> E. e \\<in> backflows (filternew_flows_state \\<T>)} \\<union>\n    {e \\<in> E.\n     e \\<in> backflows (flows_state \\<T>) \\<and>\n     e \\<notin> backflows (filternew_flows_state \\<T>)} =\n    E \\<and>\n    {e \\<in> E. e \\<in> backflows (filternew_flows_state \\<T>)} \\<inter>\n    {e \\<in> E.\n     e \\<in> backflows (flows_state \\<T>) \\<and>\n     e \\<notin> backflows (filternew_flows_state \\<T>)} =\n    {}", "apply(rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {e \\<in> E. e \\<in> backflows (filternew_flows_state \\<T>)} \\<union>\n    {e \\<in> E.\n     e \\<in> backflows (flows_state \\<T>) \\<and>\n     e \\<notin> backflows (filternew_flows_state \\<T>)} =\n    E\n 2. {e \\<in> E. e \\<in> backflows (filternew_flows_state \\<T>)} \\<inter>\n    {e \\<in> E.\n     e \\<in> backflows (flows_state \\<T>) \\<and>\n     e \\<notin> backflows (filternew_flows_state \\<T>)} =\n    {}", "using h1"], ["proof (prove)\nusing this:\n  E \\<subseteq> backflows (filternew_flows_state \\<T>) \\<union>\n                (backflows (flows_state \\<T>) -\n                 backflows (filternew_flows_state \\<T>))\n\ngoal (2 subgoals):\n 1. {e \\<in> E. e \\<in> backflows (filternew_flows_state \\<T>)} \\<union>\n    {e \\<in> E.\n     e \\<in> backflows (flows_state \\<T>) \\<and>\n     e \\<notin> backflows (filternew_flows_state \\<T>)} =\n    E\n 2. {e \\<in> E. e \\<in> backflows (filternew_flows_state \\<T>)} \\<inter>\n    {e \\<in> E.\n     e \\<in> backflows (flows_state \\<T>) \\<and>\n     e \\<notin> backflows (filternew_flows_state \\<T>)} =\n    {}", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. {e \\<in> E. e \\<in> backflows (filternew_flows_state \\<T>)} \\<inter>\n    {e \\<in> E.\n     e \\<in> backflows (flows_state \\<T>) \\<and>\n     e \\<notin> backflows (filternew_flows_state \\<T>)} =\n    {}", "using backflows_filternew_disjunct_flows_fix"], ["proof (prove)\nusing this:\n  \\<forall>b\\<in>backflows (filternew_flows_state ?\\<T>).\n     b \\<notin> flows_fix ?\\<T>\n\ngoal (1 subgoal):\n 1. {e \\<in> E. e \\<in> backflows (filternew_flows_state \\<T>)} \\<inter>\n    {e \\<in> E.\n     e \\<in> backflows (flows_state \\<T>) \\<and>\n     e \\<notin> backflows (filternew_flows_state \\<T>)} =\n    {}", "by blast"], ["proof (state)\nthis:\n  \\<exists>E1 E2.\n     E1 \\<subseteq> backflows (filternew_flows_state \\<T>) \\<and>\n     E2 \\<subseteq> backflows (flows_state \\<T>) -\n                    backflows (filternew_flows_state \\<T>) \\<and>\n     E1 \\<union> E2 = E \\<and> E1 \\<inter> E2 = {}\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows (filternew_flows_state \\<T>) \\<union>\n                     (backflows (flows_state \\<T>) -\n                      backflows\n                       (filternew_flows_state \\<T>)) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "from this"], ["proof (chain)\npicking this:\n  \\<exists>E1 E2.\n     E1 \\<subseteq> backflows (filternew_flows_state \\<T>) \\<and>\n     E2 \\<subseteq> backflows (flows_state \\<T>) -\n                    backflows (filternew_flows_state \\<T>) \\<and>\n     E1 \\<union> E2 = E \\<and> E1 \\<inter> E2 = {}", "obtain E1 E2 where E1_prop: \"E1 \\<subseteq> backflows (filternew_flows_state \\<T>)\" and E2_prop: \"E2 \\<subseteq> (backflows (flows_state \\<T>) - backflows (filternew_flows_state \\<T>))\" and \"E = E1 \\<union> E2\" and \"E1 \\<inter> E2 = {}\""], ["proof (prove)\nusing this:\n  \\<exists>E1 E2.\n     E1 \\<subseteq> backflows (filternew_flows_state \\<T>) \\<and>\n     E2 \\<subseteq> backflows (flows_state \\<T>) -\n                    backflows (filternew_flows_state \\<T>) \\<and>\n     E1 \\<union> E2 = E \\<and> E1 \\<inter> E2 = {}\n\ngoal (1 subgoal):\n 1. (\\<And>E1 E2.\n        \\<lbrakk>E1 \\<subseteq> backflows (filternew_flows_state \\<T>);\n         E2 \\<subseteq> backflows (flows_state \\<T>) -\n                        backflows (filternew_flows_state \\<T>);\n         E = E1 \\<union> E2; E1 \\<inter> E2 = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast\n    \n          \\<comment> \\<open>the stateful flows are @{text \"\\<subseteq>\"} fix flows. If substracting the new stateful flows, onyly the existing fix flows remain\\<close>"], ["proof (state)\nthis:\n  E1 \\<subseteq> backflows (filternew_flows_state \\<T>)\n  E2 \\<subseteq> backflows (flows_state \\<T>) -\n                 backflows (filternew_flows_state \\<T>)\n  E = E1 \\<union> E2\n  E1 \\<inter> E2 = {}\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows (filternew_flows_state \\<T>) \\<union>\n                     (backflows (flows_state \\<T>) -\n                      backflows\n                       (filternew_flows_state \\<T>)) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "from E2_prop filternew_flows_state_alt"], ["proof (chain)\npicking this:\n  E2 \\<subseteq> backflows (flows_state \\<T>) -\n                 backflows (filternew_flows_state \\<T>)\n  filternew_flows_state ?\\<T> =\n  flows_state ?\\<T> - backflows (flows_fix ?\\<T>)", "have \"E2 \\<subseteq> flows_fix \\<T>\""], ["proof (prove)\nusing this:\n  E2 \\<subseteq> backflows (flows_state \\<T>) -\n                 backflows (filternew_flows_state \\<T>)\n  filternew_flows_state ?\\<T> =\n  flows_state ?\\<T> - backflows (flows_fix ?\\<T>)\n\ngoal (1 subgoal):\n 1. E2 \\<subseteq> flows_fix \\<T>", "by (metis (hide_lams, no_types) Diff_subset_conv Un_Diff_cancel2 backflows_minus_backflows inf_sup_ord(3) order.trans)\n          \\<comment> \\<open>hence, E2 disappears\\<close>"], ["proof (state)\nthis:\n  E2 \\<subseteq> flows_fix \\<T>\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows (filternew_flows_state \\<T>) \\<union>\n                     (backflows (flows_state \\<T>) -\n                      backflows\n                       (filternew_flows_state \\<T>)) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "from Set.Un_absorb1[OF this]"], ["proof (chain)\npicking this:\n  E2 \\<union> flows_fix \\<T> = flows_fix \\<T>", "have E2_absorb: \"flows_fix \\<T> \\<union> E2 = flows_fix \\<T>\""], ["proof (prove)\nusing this:\n  E2 \\<union> flows_fix \\<T> = flows_fix \\<T>\n\ngoal (1 subgoal):\n 1. flows_fix \\<T> \\<union> E2 = flows_fix \\<T>", "by blast"], ["proof (state)\nthis:\n  flows_fix \\<T> \\<union> E2 = flows_fix \\<T>\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows (filternew_flows_state \\<T>) \\<union>\n                     (backflows (flows_state \\<T>) -\n                      backflows\n                       (filternew_flows_state \\<T>)) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "from \\<open>E = E1 \\<union> E2\\<close>"], ["proof (chain)\npicking this:\n  E = E1 \\<union> E2", "have E2E1eq: \"E2 \\<union> E1 = E\""], ["proof (prove)\nusing this:\n  E = E1 \\<union> E2\n\ngoal (1 subgoal):\n 1. E2 \\<union> E1 = E", "by blast"], ["proof (state)\nthis:\n  E2 \\<union> E1 = E\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows (filternew_flows_state \\<T>) \\<union>\n                     (backflows (flows_state \\<T>) -\n                      backflows\n                       (filternew_flows_state \\<T>)) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "from \\<open>E = E1 \\<union> E2\\<close> \\<open>E1 \\<inter> E2 = {}\\<close>"], ["proof (chain)\npicking this:\n  E = E1 \\<union> E2\n  E1 \\<inter> E2 = {}", "have \"E1 \\<subseteq> E\""], ["proof (prove)\nusing this:\n  E = E1 \\<union> E2\n  E1 \\<inter> E2 = {}\n\ngoal (1 subgoal):\n 1. E1 \\<subseteq> E", "by simp"], ["proof (state)\nthis:\n  E1 \\<subseteq> E\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows (filternew_flows_state \\<T>) \\<union>\n                     (backflows (flows_state \\<T>) -\n                      backflows\n                       (filternew_flows_state \\<T>)) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "from compliant_stateful_ACS_no_side_effects_filternew_helper E1_prop"], ["proof (chain)\npicking this:\n  \\<forall>E\\<subseteq>backflows (filternew_flows_state \\<T>).\n     \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                     \\<lparr>nodes = hosts \\<T>,\n                        edges = flows_fix \\<T> \\<union> E\\<rparr>.\n        F \\<subseteq> E\n  E1 \\<subseteq> backflows (filternew_flows_state \\<T>)", "have \"\\<forall>F\\<in>get_offending_flows (get_ACS M) \\<lparr>nodes = hosts \\<T>, edges = flows_fix \\<T> \\<union> E1 \\<rparr>. F \\<subseteq> E1\""], ["proof (prove)\nusing this:\n  \\<forall>E\\<subseteq>backflows (filternew_flows_state \\<T>).\n     \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                     \\<lparr>nodes = hosts \\<T>,\n                        edges = flows_fix \\<T> \\<union> E\\<rparr>.\n        F \\<subseteq> E\n  E1 \\<subseteq> backflows (filternew_flows_state \\<T>)\n\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                    \\<lparr>nodes = hosts \\<T>,\n                       edges = flows_fix \\<T> \\<union> E1\\<rparr>.\n       F \\<subseteq> E1", "by simp"], ["proof (state)\nthis:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  \\<lparr>nodes = hosts \\<T>,\n                     edges = flows_fix \\<T> \\<union> E1\\<rparr>.\n     F \\<subseteq> E1\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows (filternew_flows_state \\<T>) \\<union>\n                     (backflows (flows_state \\<T>) -\n                      backflows\n                       (filternew_flows_state \\<T>)) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "hence \"\\<forall>F\\<in>get_offending_flows (get_ACS M) \\<lparr>nodes = hosts \\<T>, edges = flows_fix \\<T> \\<union> E2 \\<union> E1 \\<rparr>. F \\<subseteq> E1\""], ["proof (prove)\nusing this:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  \\<lparr>nodes = hosts \\<T>,\n                     edges = flows_fix \\<T> \\<union> E1\\<rparr>.\n     F \\<subseteq> E1\n\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                    \\<lparr>nodes = hosts \\<T>,\n                       edges =\n                         flows_fix \\<T> \\<union> E2 \\<union> E1\\<rparr>.\n       F \\<subseteq> E1", "using E2_absorb[symmetric]"], ["proof (prove)\nusing this:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  \\<lparr>nodes = hosts \\<T>,\n                     edges = flows_fix \\<T> \\<union> E1\\<rparr>.\n     F \\<subseteq> E1\n  flows_fix \\<T> = flows_fix \\<T> \\<union> E2\n\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                    \\<lparr>nodes = hosts \\<T>,\n                       edges =\n                         flows_fix \\<T> \\<union> E2 \\<union> E1\\<rparr>.\n       F \\<subseteq> E1", "by simp"], ["proof (state)\nthis:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  \\<lparr>nodes = hosts \\<T>,\n                     edges = flows_fix \\<T> \\<union> E2 \\<union> E1\\<rparr>.\n     F \\<subseteq> E1\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows (filternew_flows_state \\<T>) \\<union>\n                     (backflows (flows_state \\<T>) -\n                      backflows\n                       (filternew_flows_state \\<T>)) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "hence \"\\<forall>F\\<in>get_offending_flows (get_ACS M) \\<lparr>nodes = hosts \\<T>, edges = flows_fix \\<T> \\<union> E \\<rparr>. F \\<subseteq> E1\""], ["proof (prove)\nusing this:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  \\<lparr>nodes = hosts \\<T>,\n                     edges = flows_fix \\<T> \\<union> E2 \\<union> E1\\<rparr>.\n     F \\<subseteq> E1\n\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                    \\<lparr>nodes = hosts \\<T>,\n                       edges = flows_fix \\<T> \\<union> E\\<rparr>.\n       F \\<subseteq> E1", "using E2E1eq"], ["proof (prove)\nusing this:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  \\<lparr>nodes = hosts \\<T>,\n                     edges = flows_fix \\<T> \\<union> E2 \\<union> E1\\<rparr>.\n     F \\<subseteq> E1\n  E2 \\<union> E1 = E\n\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                    \\<lparr>nodes = hosts \\<T>,\n                       edges = flows_fix \\<T> \\<union> E\\<rparr>.\n       F \\<subseteq> E1", "by (metis Un_assoc)"], ["proof (state)\nthis:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  \\<lparr>nodes = hosts \\<T>,\n                     edges = flows_fix \\<T> \\<union> E\\<rparr>.\n     F \\<subseteq> E1\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       E \\<subseteq> backflows (filternew_flows_state \\<T>) \\<union>\n                     (backflows (flows_state \\<T>) -\n                      backflows\n                       (filternew_flows_state \\<T>)) \\<Longrightarrow>\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "from this \\<open>E1 \\<subseteq> E\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  \\<lparr>nodes = hosts \\<T>,\n                     edges = flows_fix \\<T> \\<union> E\\<rparr>.\n     F \\<subseteq> E1\n  E1 \\<subseteq> E", "show \"\\<forall>F\\<in>get_offending_flows (get_ACS M) \\<lparr>nodes = hosts \\<T>, edges = flows_fix \\<T> \\<union> E\\<rparr>. F \\<subseteq> E\""], ["proof (prove)\nusing this:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  \\<lparr>nodes = hosts \\<T>,\n                     edges = flows_fix \\<T> \\<union> E\\<rparr>.\n     F \\<subseteq> E1\n  E1 \\<subseteq> E\n\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                    \\<lparr>nodes = hosts \\<T>,\n                       edges = flows_fix \\<T> \\<union> E\\<rparr>.\n       F \\<subseteq> E", "by blast"], ["proof (state)\nthis:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  \\<lparr>nodes = hosts \\<T>,\n                     edges = flows_fix \\<T> \\<union> E\\<rparr>.\n     F \\<subseteq> E\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>E\\<subseteq>backflows (filternew_flows_state \\<T>) \\<union>\n                       (backflows (flows_state \\<T>) -\n                        backflows (filternew_flows_state \\<T>)).\n     \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                     \\<lparr>nodes = hosts \\<T>,\n                        edges = flows_fix \\<T> \\<union> E\\<rparr>.\n        F \\<subseteq> E\n\ngoal (1 subgoal):\n 1. \\<forall>E\\<subseteq>backflows (flows_state \\<T>).\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "from this backflows_split"], ["proof (chain)\npicking this:\n  \\<forall>E\\<subseteq>backflows (filternew_flows_state \\<T>) \\<union>\n                       (backflows (flows_state \\<T>) -\n                        backflows (filternew_flows_state \\<T>)).\n     \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                     \\<lparr>nodes = hosts \\<T>,\n                        edges = flows_fix \\<T> \\<union> E\\<rparr>.\n        F \\<subseteq> E\n  backflows (filternew_flows_state \\<T>) \\<union>\n  (backflows (flows_state \\<T>) - backflows (filternew_flows_state \\<T>)) =\n  backflows (flows_state \\<T>)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>E\\<subseteq>backflows (filternew_flows_state \\<T>) \\<union>\n                       (backflows (flows_state \\<T>) -\n                        backflows (filternew_flows_state \\<T>)).\n     \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                     \\<lparr>nodes = hosts \\<T>,\n                        edges = flows_fix \\<T> \\<union> E\\<rparr>.\n        F \\<subseteq> E\n  backflows (filternew_flows_state \\<T>) \\<union>\n  (backflows (flows_state \\<T>) - backflows (filternew_flows_state \\<T>)) =\n  backflows (flows_state \\<T>)\n\ngoal (1 subgoal):\n 1. \\<forall>E\\<subseteq>backflows (flows_state \\<T>).\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges = flows_fix \\<T> \\<union> E\\<rparr>.\n          F \\<subseteq> E", "by presburger"], ["proof (state)\nthis:\n  \\<forall>E\\<subseteq>backflows (flows_state \\<T>).\n     \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                     \\<lparr>nodes = hosts \\<T>,\n                        edges = flows_fix \\<T> \\<union> E\\<rparr>.\n        F \\<subseteq> E\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary compliant_stateful_ACS_no_side_effects': \"\\<forall> E \\<subseteq> backflows (flows_state \\<T>). \\<forall> F \\<in> get_offending_flows(get_ACS M) \\<lparr> nodes = hosts \\<T>, edges = flows_fix \\<T> \\<union> flows_state \\<T> \\<union> E \\<rparr>. F \\<subseteq> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>E\\<subseteq>backflows (flows_state \\<T>).\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges =\n                            flows_fix \\<T> \\<union>\n                            flows_state \\<T> \\<union>\n                            E\\<rparr>.\n          F \\<subseteq> E", "using compliant_stateful_ACS_no_side_effects wf_stateful_policy.E_state_fix[OF stateful_policy_wf]"], ["proof (prove)\nusing this:\n  \\<forall>E\\<subseteq>backflows (flows_state \\<T>).\n     \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                     \\<lparr>nodes = hosts \\<T>,\n                        edges = flows_fix \\<T> \\<union> E\\<rparr>.\n        F \\<subseteq> E\n  flows_state \\<T> \\<subseteq> flows_fix \\<T>\n\ngoal (1 subgoal):\n 1. \\<forall>E\\<subseteq>backflows (flows_state \\<T>).\n       \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                       \\<lparr>nodes = hosts \\<T>,\n                          edges =\n                            flows_fix \\<T> \\<union>\n                            flows_state \\<T> \\<union>\n                            E\\<rparr>.\n          F \\<subseteq> E", "by (metis Un_absorb2)"], ["", "text\\<open>The high level graph generated from the low level policy is a valid graph\\<close>"], ["", "lemma valid_stateful_policy: \"wf_graph \\<lparr>nodes = hosts \\<T>, edges = all_flows \\<T>\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph \\<lparr>nodes = hosts \\<T>, edges = all_flows \\<T>\\<rparr>", "by(rule wf_stateful_policy_is_wf_graph,fact stateful_policy_wf)"], ["", "text\\<open>The security requirements are definitely fulfilled if we consider only the fixed flows and the\n           normal direction of the stateful flows (i.e. no backflows).\n           I.e. considering no states, everything must be fulfilled\\<close>"], ["", "lemma compliant_stateful_ACS_static_valid: \"all_security_requirements_fulfilled (get_ACS M) \\<lparr> nodes = hosts \\<T>, edges = flows_fix \\<T>  \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled (get_ACS M)\n     \\<lparr>nodes = hosts \\<T>, edges = flows_fix \\<T>\\<rparr>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled (get_ACS M)\n     \\<lparr>nodes = hosts \\<T>, edges = flows_fix \\<T>\\<rparr>", "from validReqs"], ["proof (chain)\npicking this:\n  valid_reqs M", "have valid_ReqsACS: \"valid_reqs (get_ACS M)\""], ["proof (prove)\nusing this:\n  valid_reqs M\n\ngoal (1 subgoal):\n 1. valid_reqs (get_ACS M)", "by(simp add: get_ACS_def valid_reqs_def)"], ["proof (state)\nthis:\n  valid_reqs (get_ACS M)\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled (get_ACS M)\n     \\<lparr>nodes = hosts \\<T>, edges = flows_fix \\<T>\\<rparr>", "from wfG hosts_nodes[symmetric]"], ["proof (chain)\npicking this:\n  wf_graph G\n  nodes G = hosts \\<T>", "have wfG': \"wf_graph \\<lparr> nodes = hosts \\<T>, edges = edges G  \\<rparr>\""], ["proof (prove)\nusing this:\n  wf_graph G\n  nodes G = hosts \\<T>\n\ngoal (1 subgoal):\n 1. wf_graph \\<lparr>nodes = hosts \\<T>, edges = edges G\\<rparr>", "by(case_tac G, simp)"], ["proof (state)\nthis:\n  wf_graph \\<lparr>nodes = hosts \\<T>, edges = edges G\\<rparr>\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled (get_ACS M)\n     \\<lparr>nodes = hosts \\<T>, edges = flows_fix \\<T>\\<rparr>", "from high_level_policy_valid"], ["proof (chain)\npicking this:\n  all_security_requirements_fulfilled M G", "have \"all_security_requirements_fulfilled (get_ACS M) G\""], ["proof (prove)\nusing this:\n  all_security_requirements_fulfilled M G\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled (get_ACS M) G", "by(simp add: get_ACS_def all_security_requirements_fulfilled_def)"], ["proof (state)\nthis:\n  all_security_requirements_fulfilled (get_ACS M) G\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled (get_ACS M)\n     \\<lparr>nodes = hosts \\<T>, edges = flows_fix \\<T>\\<rparr>", "from this hosts_nodes[symmetric]"], ["proof (chain)\npicking this:\n  all_security_requirements_fulfilled (get_ACS M) G\n  nodes G = hosts \\<T>", "have \"all_security_requirements_fulfilled (get_ACS M) \\<lparr> nodes = hosts \\<T>, edges = edges G  \\<rparr>\""], ["proof (prove)\nusing this:\n  all_security_requirements_fulfilled (get_ACS M) G\n  nodes G = hosts \\<T>\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled (get_ACS M)\n     \\<lparr>nodes = hosts \\<T>, edges = edges G\\<rparr>", "by(case_tac G, simp)"], ["proof (state)\nthis:\n  all_security_requirements_fulfilled (get_ACS M)\n   \\<lparr>nodes = hosts \\<T>, edges = edges G\\<rparr>\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled (get_ACS M)\n     \\<lparr>nodes = hosts \\<T>, edges = flows_fix \\<T>\\<rparr>", "from all_security_requirements_fulfilled_mono[OF valid_ReqsACS flows_edges wfG' this]"], ["proof (chain)\npicking this:\n  all_security_requirements_fulfilled (get_ACS M)\n   \\<lparr>nodes = hosts \\<T>, edges = flows_fix \\<T>\\<rparr>", "show ?thesis"], ["proof (prove)\nusing this:\n  all_security_requirements_fulfilled (get_ACS M)\n   \\<lparr>nodes = hosts \\<T>, edges = flows_fix \\<T>\\<rparr>\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled (get_ACS M)\n     \\<lparr>nodes = hosts \\<T>, edges = flows_fix \\<T>\\<rparr>", "."], ["proof (state)\nthis:\n  all_security_requirements_fulfilled (get_ACS M)\n   \\<lparr>nodes = hosts \\<T>, edges = flows_fix \\<T>\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem compliant_stateful_ACS_static_valid':\n      \"all_security_requirements_fulfilled M \\<lparr> nodes = hosts \\<T>, edges = flows_fix \\<T> \\<union> flows_state \\<T>  \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled M\n     \\<lparr>nodes = hosts \\<T>,\n        edges = flows_fix \\<T> \\<union> flows_state \\<T>\\<rparr>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled M\n     \\<lparr>nodes = hosts \\<T>,\n        edges = flows_fix \\<T> \\<union> flows_state \\<T>\\<rparr>", "from validReqs"], ["proof (chain)\npicking this:\n  valid_reqs M", "have valid_ReqsIFS: \"valid_reqs (get_IFS M)\""], ["proof (prove)\nusing this:\n  valid_reqs M\n\ngoal (1 subgoal):\n 1. valid_reqs (get_IFS M)", "by(simp add: get_IFS_def valid_reqs_def)\n    \n        \\<comment> \\<open>show that it holds for IFS, by monotonicity as it holds for more in IFS\\<close>"], ["proof (state)\nthis:\n  valid_reqs (get_IFS M)\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled M\n     \\<lparr>nodes = hosts \\<T>,\n        edges = flows_fix \\<T> \\<union> flows_state \\<T>\\<rparr>", "from all_security_requirements_fulfilled_mono[OF valid_ReqsIFS _ valid_stateful_policy compliant_stateful_IFS[unfolded stateful_policy_to_network_graph_def]]"], ["proof (chain)\npicking this:\n  ?E' \\<subseteq> all_flows \\<T> \\<Longrightarrow>\n  all_security_requirements_fulfilled (get_IFS M)\n   \\<lparr>nodes = hosts \\<T>, edges = ?E'\\<rparr>", "have\n          goalIFS: \"all_security_requirements_fulfilled (get_IFS M) \\<lparr> nodes = hosts \\<T>, edges = flows_fix \\<T> \\<union> flows_state \\<T>  \\<rparr>\""], ["proof (prove)\nusing this:\n  ?E' \\<subseteq> all_flows \\<T> \\<Longrightarrow>\n  all_security_requirements_fulfilled (get_IFS M)\n   \\<lparr>nodes = hosts \\<T>, edges = ?E'\\<rparr>\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled (get_IFS M)\n     \\<lparr>nodes = hosts \\<T>,\n        edges = flows_fix \\<T> \\<union> flows_state \\<T>\\<rparr>", "by(simp add: all_flows_def)"], ["proof (state)\nthis:\n  all_security_requirements_fulfilled (get_IFS M)\n   \\<lparr>nodes = hosts \\<T>,\n      edges = flows_fix \\<T> \\<union> flows_state \\<T>\\<rparr>\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled M\n     \\<lparr>nodes = hosts \\<T>,\n        edges = flows_fix \\<T> \\<union> flows_state \\<T>\\<rparr>", "from wf_stateful_policy.E_state_fix[OF stateful_policy_wf]"], ["proof (chain)\npicking this:\n  flows_state \\<T> \\<subseteq> flows_fix \\<T>", "have \"flows_fix \\<T> \\<union> flows_state \\<T> =  flows_fix \\<T>\""], ["proof (prove)\nusing this:\n  flows_state \\<T> \\<subseteq> flows_fix \\<T>\n\ngoal (1 subgoal):\n 1. flows_fix \\<T> \\<union> flows_state \\<T> = flows_fix \\<T>", "by blast"], ["proof (state)\nthis:\n  flows_fix \\<T> \\<union> flows_state \\<T> = flows_fix \\<T>\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled M\n     \\<lparr>nodes = hosts \\<T>,\n        edges = flows_fix \\<T> \\<union> flows_state \\<T>\\<rparr>", "from this compliant_stateful_ACS_static_valid"], ["proof (chain)\npicking this:\n  flows_fix \\<T> \\<union> flows_state \\<T> = flows_fix \\<T>\n  all_security_requirements_fulfilled (get_ACS M)\n   \\<lparr>nodes = hosts \\<T>, edges = flows_fix \\<T>\\<rparr>", "have goalACS:\n          \"all_security_requirements_fulfilled (get_ACS M) \\<lparr> nodes = hosts \\<T>, edges = flows_fix \\<T> \\<union> flows_state \\<T>  \\<rparr>\""], ["proof (prove)\nusing this:\n  flows_fix \\<T> \\<union> flows_state \\<T> = flows_fix \\<T>\n  all_security_requirements_fulfilled (get_ACS M)\n   \\<lparr>nodes = hosts \\<T>, edges = flows_fix \\<T>\\<rparr>\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled (get_ACS M)\n     \\<lparr>nodes = hosts \\<T>,\n        edges = flows_fix \\<T> \\<union> flows_state \\<T>\\<rparr>", "by simp\n          \n        \\<comment> \\<open>ACS and IFS together form M, we know it holds for ACS\\<close>"], ["proof (state)\nthis:\n  all_security_requirements_fulfilled (get_ACS M)\n   \\<lparr>nodes = hosts \\<T>,\n      edges = flows_fix \\<T> \\<union> flows_state \\<T>\\<rparr>\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled M\n     \\<lparr>nodes = hosts \\<T>,\n        edges = flows_fix \\<T> \\<union> flows_state \\<T>\\<rparr>", "from goalACS goalIFS"], ["proof (chain)\npicking this:\n  all_security_requirements_fulfilled (get_ACS M)\n   \\<lparr>nodes = hosts \\<T>,\n      edges = flows_fix \\<T> \\<union> flows_state \\<T>\\<rparr>\n  all_security_requirements_fulfilled (get_IFS M)\n   \\<lparr>nodes = hosts \\<T>,\n      edges = flows_fix \\<T> \\<union> flows_state \\<T>\\<rparr>", "show ?thesis"], ["proof (prove)\nusing this:\n  all_security_requirements_fulfilled (get_ACS M)\n   \\<lparr>nodes = hosts \\<T>,\n      edges = flows_fix \\<T> \\<union> flows_state \\<T>\\<rparr>\n  all_security_requirements_fulfilled (get_IFS M)\n   \\<lparr>nodes = hosts \\<T>,\n      edges = flows_fix \\<T> \\<union> flows_state \\<T>\\<rparr>\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled M\n     \\<lparr>nodes = hosts \\<T>,\n        edges = flows_fix \\<T> \\<union> flows_state \\<T>\\<rparr>", "apply(simp add: all_security_requirements_fulfilled_def get_IFS_def get_ACS_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>m.\n                m \\<in> set M \\<and> \\<not> c_isIFS m \\<longrightarrow>\n                c_sinvar m\n                 \\<lparr>nodes = hosts \\<T>,\n                    edges =\n                      flows_fix \\<T> \\<union> flows_state \\<T>\\<rparr>;\n     \\<forall>m.\n        m \\<in> set M \\<and> c_isIFS m \\<longrightarrow>\n        c_sinvar m\n         \\<lparr>nodes = hosts \\<T>,\n            edges =\n              flows_fix \\<T> \\<union> flows_state \\<T>\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>m\\<in>set M.\n                         c_sinvar m\n                          \\<lparr>nodes = hosts \\<T>,\n                             edges =\n                               flows_fix \\<T> \\<union>\n                               flows_state \\<T>\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  all_security_requirements_fulfilled M\n   \\<lparr>nodes = hosts \\<T>,\n      edges = flows_fix \\<T> \\<union> flows_state \\<T>\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The flows with state are a subset of the flows allowed by the policy\\<close>"], ["", "theorem flows_state_edges: \"flows_state \\<T> \\<subseteq> edges G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flows_state \\<T> \\<subseteq> edges G", "using wf_stateful_policy.E_state_fix[OF stateful_policy_wf] flows_edges"], ["proof (prove)\nusing this:\n  flows_state \\<T> \\<subseteq> flows_fix \\<T>\n  flows_fix \\<T> \\<subseteq> edges G\n\ngoal (1 subgoal):\n 1. flows_state \\<T> \\<subseteq> edges G", "by simp"], ["", "text\\<open>All offending flows are subsets of the reveres stateful flows\\<close>"], ["", "lemma compliant_stateful_ACS_only_state_violations:\n      \"\\<forall>F \\<in> get_offending_flows (get_ACS M) (stateful_policy_to_network_graph \\<T>). F \\<subseteq> backflows (flows_state \\<T>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                    (stateful_policy_to_network_graph \\<T>).\n       F \\<subseteq> backflows (flows_state \\<T>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                    (stateful_policy_to_network_graph \\<T>).\n       F \\<subseteq> backflows (flows_state \\<T>)", "have \"backflows (filternew_flows_state \\<T>) \\<subseteq> backflows (flows_state \\<T>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backflows (filternew_flows_state \\<T>)\n    \\<subseteq> backflows (flows_state \\<T>)", "by (metis Diff_subset backflows_minus_backflows filternew_flows_state_alt)"], ["proof (state)\nthis:\n  backflows (filternew_flows_state \\<T>)\n  \\<subseteq> backflows (flows_state \\<T>)\n\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                    (stateful_policy_to_network_graph \\<T>).\n       F \\<subseteq> backflows (flows_state \\<T>)", "from compliant_stateful_ACS this"], ["proof (chain)\npicking this:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  (stateful_policy_to_network_graph \\<T>).\n     F \\<subseteq> backflows (filternew_flows_state \\<T>)\n  backflows (filternew_flows_state \\<T>)\n  \\<subseteq> backflows (flows_state \\<T>)", "have \n          \"\\<forall> F \\<in> get_offending_flows (get_ACS M) (stateful_policy_to_network_graph \\<T>). F \\<subseteq> backflows (flows_state \\<T>)\""], ["proof (prove)\nusing this:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  (stateful_policy_to_network_graph \\<T>).\n     F \\<subseteq> backflows (filternew_flows_state \\<T>)\n  backflows (filternew_flows_state \\<T>)\n  \\<subseteq> backflows (flows_state \\<T>)\n\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                    (stateful_policy_to_network_graph \\<T>).\n       F \\<subseteq> backflows (flows_state \\<T>)", "by (metis subset_trans)"], ["proof (state)\nthis:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  (stateful_policy_to_network_graph \\<T>).\n     F \\<subseteq> backflows (flows_state \\<T>)\n\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                    (stateful_policy_to_network_graph \\<T>).\n       F \\<subseteq> backflows (flows_state \\<T>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  (stateful_policy_to_network_graph \\<T>).\n     F \\<subseteq> backflows (flows_state \\<T>)\n\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                    (stateful_policy_to_network_graph \\<T>).\n       F \\<subseteq> backflows (flows_state \\<T>)", "."], ["proof (state)\nthis:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  (stateful_policy_to_network_graph \\<T>).\n     F \\<subseteq> backflows (flows_state \\<T>)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem compliant_stateful_ACS_only_state_violations': \"\\<forall>F \\<in> get_offending_flows M (stateful_policy_to_network_graph \\<T>). F \\<subseteq> backflows (flows_state \\<T>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>get_offending_flows M\n                    (stateful_policy_to_network_graph \\<T>).\n       F \\<subseteq> backflows (flows_state \\<T>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>get_offending_flows M\n                    (stateful_policy_to_network_graph \\<T>).\n       F \\<subseteq> backflows (flows_state \\<T>)", "from validReqs"], ["proof (chain)\npicking this:\n  valid_reqs M", "have valid_ReqsIFS: \"valid_reqs (get_IFS M)\""], ["proof (prove)\nusing this:\n  valid_reqs M\n\ngoal (1 subgoal):\n 1. valid_reqs (get_IFS M)", "by(simp add: get_IFS_def valid_reqs_def)"], ["proof (state)\nthis:\n  valid_reqs (get_IFS M)\n\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>get_offending_flows M\n                    (stateful_policy_to_network_graph \\<T>).\n       F \\<subseteq> backflows (flows_state \\<T>)", "have offending_split: \"\\<And>G. get_offending_flows M G = (get_offending_flows (get_IFS M) G \\<union> get_offending_flows (get_ACS M) G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G.\n       get_offending_flows M G =\n       get_offending_flows (get_IFS M) G \\<union>\n       get_offending_flows (get_ACS M) G", "apply(simp add: get_offending_flows_def get_IFS_def get_ACS_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G.\n       (\\<Union>m\\<in>set M. c_offending_flows m G) =\n       (\\<Union>x\\<in>{x \\<in> set M. c_isIFS x}.\n           c_offending_flows x G) \\<union>\n       (\\<Union>x\\<in>{x \\<in> set M. \\<not> c_isIFS x}.\n           c_offending_flows x G)", "by blast"], ["proof (state)\nthis:\n  get_offending_flows M ?G =\n  get_offending_flows (get_IFS M) ?G \\<union>\n  get_offending_flows (get_ACS M) ?G\n\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>get_offending_flows M\n                    (stateful_policy_to_network_graph \\<T>).\n       F \\<subseteq> backflows (flows_state \\<T>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>get_offending_flows M\n                    (stateful_policy_to_network_graph \\<T>).\n       F \\<subseteq> backflows (flows_state \\<T>)", "apply(subst offending_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>get_offending_flows (get_IFS M)\n                    (stateful_policy_to_network_graph \\<T>) \\<union>\n                   get_offending_flows (get_ACS M)\n                    (stateful_policy_to_network_graph \\<T>).\n       F \\<subseteq> backflows (flows_state \\<T>)", "using compliant_stateful_ACS_only_state_violations \n              all_security_requirements_fulfilled_imp_get_offending_empty[OF valid_ReqsIFS compliant_stateful_IFS]"], ["proof (prove)\nusing this:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  (stateful_policy_to_network_graph \\<T>).\n     F \\<subseteq> backflows (flows_state \\<T>)\n  get_offending_flows (get_IFS M) (stateful_policy_to_network_graph \\<T>) =\n  {}\n\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>get_offending_flows (get_IFS M)\n                    (stateful_policy_to_network_graph \\<T>) \\<union>\n                   get_offending_flows (get_ACS M)\n                    (stateful_policy_to_network_graph \\<T>).\n       F \\<subseteq> backflows (flows_state \\<T>)", "by auto"], ["proof (state)\nthis:\n  \\<forall>F\\<in>get_offending_flows M\n                  (stateful_policy_to_network_graph \\<T>).\n     F \\<subseteq> backflows (flows_state \\<T>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>All violations are backflows of valid flows\\<close>"], ["", "corollary compliant_stateful_ACS_only_state_violations_union: \"\\<Union>(get_offending_flows (get_ACS M) (stateful_policy_to_network_graph \\<T>)) \\<subseteq> backflows (flows_state \\<T>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (get_offending_flows (get_ACS M)\n       (stateful_policy_to_network_graph \\<T>))\n    \\<subseteq> backflows (flows_state \\<T>)", "using compliant_stateful_ACS_only_state_violations"], ["proof (prove)\nusing this:\n  \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                  (stateful_policy_to_network_graph \\<T>).\n     F \\<subseteq> backflows (flows_state \\<T>)\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (get_offending_flows (get_ACS M)\n       (stateful_policy_to_network_graph \\<T>))\n    \\<subseteq> backflows (flows_state \\<T>)", "by fastforce"], ["", "corollary compliant_stateful_ACS_only_state_violations_union': \"\\<Union>(get_offending_flows M (stateful_policy_to_network_graph \\<T>)) \\<subseteq> backflows (flows_state \\<T>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (get_offending_flows M (stateful_policy_to_network_graph \\<T>))\n    \\<subseteq> backflows (flows_state \\<T>)", "using compliant_stateful_ACS_only_state_violations'"], ["proof (prove)\nusing this:\n  \\<forall>F\\<in>get_offending_flows M\n                  (stateful_policy_to_network_graph \\<T>).\n     F \\<subseteq> backflows (flows_state \\<T>)\n\ngoal (1 subgoal):\n 1. \\<Union> (get_offending_flows M (stateful_policy_to_network_graph \\<T>))\n    \\<subseteq> backflows (flows_state \\<T>)", "by fastforce"], ["", "text\\<open>All individual flows cause no side effects, i.e. each backflow causes at most itself as violation, no other\n           side-effect violations are induced.\\<close>"], ["", "lemma  compliant_stateful_ACS_no_state_singleflow_side_effect:\n      \"\\<forall> (v\\<^sub>1, v\\<^sub>2) \\<in> backflows (flows_state \\<T>). \n       \\<Union>(get_offending_flows(get_ACS M) \\<lparr> nodes = hosts \\<T>, edges = flows_fix \\<T> \\<union> flows_state \\<T> \\<union> {(v\\<^sub>1, v\\<^sub>2)} \\<rparr>) \\<subseteq> {(v\\<^sub>1, v\\<^sub>2)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(v\\<^sub>1, v\\<^sub>2)\\<in>backflows (flows_state \\<T>).\n       \\<Union>\n        (get_offending_flows (get_ACS M)\n          \\<lparr>nodes = hosts \\<T>,\n             edges =\n               flows_fix \\<T> \\<union> flows_state \\<T> \\<union>\n               {(v\\<^sub>1, v\\<^sub>2)}\\<rparr>)\n       \\<subseteq> {(v\\<^sub>1, v\\<^sub>2)}", "using compliant_stateful_ACS_no_side_effects'"], ["proof (prove)\nusing this:\n  \\<forall>E\\<subseteq>backflows (flows_state \\<T>).\n     \\<forall>F\\<in>get_offending_flows (get_ACS M)\n                     \\<lparr>nodes = hosts \\<T>,\n                        edges =\n                          flows_fix \\<T> \\<union> flows_state \\<T> \\<union>\n                          E\\<rparr>.\n        F \\<subseteq> E\n\ngoal (1 subgoal):\n 1. \\<forall>(v\\<^sub>1, v\\<^sub>2)\\<in>backflows (flows_state \\<T>).\n       \\<Union>\n        (get_offending_flows (get_ACS M)\n          \\<lparr>nodes = hosts \\<T>,\n             edges =\n               flows_fix \\<T> \\<union> flows_state \\<T> \\<union>\n               {(v\\<^sub>1, v\\<^sub>2)}\\<rparr>)\n       \\<subseteq> {(v\\<^sub>1, v\\<^sub>2)}", "by blast"], ["", "end"], ["", "subsection\\<open>Summarizing the important theorems\\<close>"], ["", "text\\<open>No information flow security requirements are violated (including all added stateful flows)\\<close>"], ["", "thm stateful_policy_compliance.compliant_stateful_IFS"], ["", "text\\<open>There are not access control side effects when allowing stateful backflows. \n          I.e. for all possible subsets of the to-allow backflows, the violations they cause are only these backflows themselves\\<close>"], ["", "thm stateful_policy_compliance.compliant_stateful_ACS_no_side_effects'"], ["", "text\\<open>Also, considering all backflows individually, they cause no side effect, i.e. the only violation added is the backflow itself\\<close>"], ["", "thm stateful_policy_compliance.compliant_stateful_ACS_no_state_singleflow_side_effect"], ["", "text\\<open>In particular, all introduced offending flows for access control strategies are at most the stateful backflows\\<close>"], ["", "thm stateful_policy_compliance.compliant_stateful_ACS_only_state_violations_union"], ["", "text\\<open>Which implies: all introduced offending flows are at most the stateful backflows\\<close>"], ["", "thm stateful_policy_compliance.compliant_stateful_ACS_only_state_violations_union'"], ["", "text\\<open>Disregarding the backflows of stateful flows, all security requirements are fulfilled.\\<close>"], ["", "thm stateful_policy_compliance.compliant_stateful_ACS_static_valid'"], ["", "end"]]}