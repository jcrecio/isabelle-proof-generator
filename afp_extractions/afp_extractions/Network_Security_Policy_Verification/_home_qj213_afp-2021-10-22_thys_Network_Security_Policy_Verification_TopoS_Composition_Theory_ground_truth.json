{"file_name": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification/TopoS_Composition_Theory.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Network_Security_Policy_Verification", "problem_names": ["lemma new_configured_TopoS_sinvar_correct:\n   \"SecurityInvariant sinvar defbot receiver_violation \\<Longrightarrow> \n   c_sinvar (the (new_configured_SecurityInvariant (sinvar, defbot, receiver_violation, nP))) = (\\<lambda>G. sinvar G nP)\"", "lemma new_configured_TopoS_offending_flows_correct:\n   \"SecurityInvariant sinvar defbot receiver_violation \\<Longrightarrow> \n   c_offending_flows (the (new_configured_SecurityInvariant (sinvar, defbot, receiver_violation, nP))) = \n   (\\<lambda>G. SecurityInvariant_withOffendingFlows.set_offending_flows sinvar G nP)\"", "lemma sinvar_monoI: \n    \"SecurityInvariant_withOffendingFlows.sinvar_mono (\\<lambda> (G::('v::vertex) graph) (nP::'v \\<Rightarrow> 'a). c_sinvar m G)\"", "lemma defined_offending': \n      \"\\<lbrakk> wf_graph G; \\<not> c_sinvar m G \\<rbrakk> \\<Longrightarrow> c_offending_flows m G \\<noteq> {}\"", "lemma subst_offending_flows: \"\\<And> nP. SecurityInvariant_withOffendingFlows.set_offending_flows (\\<lambda>G nP. c_sinvar m G) G nP = c_offending_flows m G\"", "lemma SecurityInvariant_preliminariesD:\n      \"SecurityInvariant_preliminaries (\\<lambda> (G::('v::vertex) graph) (nP::'v \\<Rightarrow> 'a). c_sinvar m G)\"", "lemma negative_mono:\n     \"\\<And> N E' E. wf_graph \\<lparr> nodes = N, edges = E \\<rparr> \\<Longrightarrow> \n        E' \\<subseteq> E \\<Longrightarrow> \\<not> c_sinvar m \\<lparr> nodes = N, edges = E' \\<rparr> \\<Longrightarrow> \\<not> c_sinvar m \\<lparr> nodes = N, edges = E \\<rparr>\"", "lemmas mono_extend_set_offending_flows =\n      SecurityInvariant_preliminaries.mono_extend_set_offending_flows[OF SecurityInvariant_preliminariesD, simplified subst_offending_flows]", "lemmas offending_flows_union_mono =\n      SecurityInvariant_preliminaries.offending_flows_union_mono[OF SecurityInvariant_preliminariesD, simplified subst_offending_flows]", "lemmas sinvar_valid_remove_flattened_offending_flows =\n      SecurityInvariant_preliminaries.sinvar_valid_remove_flattened_offending_flows[OF SecurityInvariant_preliminariesD, simplified subst_offending_flows]", "lemmas sinvar_valid_remove_SOME_offending_flows =\n      SecurityInvariant_preliminaries.sinvar_valid_remove_SOME_offending_flows[OF SecurityInvariant_preliminariesD, simplified subst_offending_flows]", "lemmas sinvar_valid_remove_minimalize_offending_overapprox =\n      SecurityInvariant_preliminaries.sinvar_valid_remove_minimalize_offending_overapprox[OF SecurityInvariant_preliminariesD, simplified subst_offending_flows]", "lemmas empty_offending_contra =\n      SecurityInvariant_withOffendingFlows.empty_offending_contra[where sinvar=\"(\\<lambda>G nP. c_sinvar m G)\", simplified subst_offending_flows]", "lemmas Un_set_offending_flows_bound_minus_subseteq = \n      SecurityInvariant_preliminaries.Un_set_offending_flows_bound_minus_subseteq[OF SecurityInvariant_preliminariesD, simplified subst_offending_flows]", "lemmas Un_set_offending_flows_bound_minus_subseteq' = \n      SecurityInvariant_preliminaries.Un_set_offending_flows_bound_minus_subseteq'[OF SecurityInvariant_preliminariesD, simplified subst_offending_flows]", "theorem new_configured_SecurityInvariant_sound: \n  \"\\<lbrakk> new_configured_SecurityInvariant (sinvar, defbot, receiver_violation, nP) = Some m \\<rbrakk> \\<Longrightarrow>\n    configured_SecurityInvariant m\"", "lemma get_ACS_union_get_IFS: \"set (get_ACS M) \\<union> set (get_IFS M) = set M\"", "lemma valid_reqs1: \"valid_reqs (m # M) \\<Longrightarrow> configured_SecurityInvariant m\"", "lemma valid_reqs2: \"valid_reqs (m # M) \\<Longrightarrow> valid_reqs M\"", "lemma get_offending_flows_alt1: \"get_offending_flows M G = \\<Union> {c_offending_flows m G | m. m \\<in> set M}\"", "lemma get_offending_flows_un: \"\\<Union>(get_offending_flows M G) = (\\<Union>m\\<in>set M. \\<Union>(c_offending_flows m G))\"", "lemma all_security_requirements_fulfilled_mono:\n      \"\\<lbrakk> valid_reqs M; E' \\<subseteq> E; wf_graph \\<lparr> nodes = V, edges = E \\<rparr> \\<rbrakk> \\<Longrightarrow>  \n        all_security_requirements_fulfilled M \\<lparr> nodes = V, edges = E \\<rparr> \\<Longrightarrow>\n        all_security_requirements_fulfilled M \\<lparr> nodes = V, edges = E' \\<rparr>\"", "lemma generate_valid_topology_nodes:\n      \"nodes (generate_valid_topology M G) = (nodes G)\"", "lemma generate_valid_topology_def_alt:\n        \"generate_valid_topology M G = delete_edges G (\\<Union> (get_offending_flows M G))\"", "lemma wf_graph_generate_valid_topology: \"wf_graph G \\<Longrightarrow> wf_graph (generate_valid_topology M G)\"", "lemma generate_valid_topology_mono_models:\n      \"edges (generate_valid_topology (m#M) \\<lparr> nodes = V, edges = E \\<rparr>) \\<subseteq> edges (generate_valid_topology M \\<lparr> nodes = V, edges = E \\<rparr>)\"", "lemma generate_valid_topology_subseteq_edges:\n      \"edges (generate_valid_topology M G) \\<subseteq> (edges G)\"", "theorem generate_valid_topology_sound:\n      \"\\<lbrakk> valid_reqs M; wf_graph \\<lparr>nodes = V, edges = E\\<rparr> \\<rbrakk> \\<Longrightarrow> \n      all_security_requirements_fulfilled M (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>)\"", "lemma generate_valid_topology_as_set: \n  \"generate_valid_topology M G = delete_edges G (\\<Union>m \\<in> set M. (\\<Union> (c_offending_flows m G)))\"", "lemma c_offending_flows_subseteq_edges: \"configured_SecurityInvariant m \\<Longrightarrow> \\<Union>(c_offending_flows m G) \\<subseteq> edges G\"", "lemma unique_offending_obtain: \n    assumes m: \"configured_SecurityInvariant m\" and unique: \"c_offending_flows m G = {F}\"\n    obtains P where \"F = {(v1, v2) \\<in> edges G. \\<not> P (v1, v2)}\" and \"c_sinvar m G = (\\<forall>(v1,v2) \\<in> edges G. P (v1, v2))\" and \n                    \"(\\<forall>(v1,v2) \\<in> edges G - F. P (v1, v2))\"", "lemma enf_offending_flows:\n    assumes vm: \"configured_SecurityInvariant m\" and enf: \"\\<forall>G. c_sinvar m G = (\\<forall>e \\<in> edges G. P e)\"\n    shows \"\\<forall>G. c_offending_flows m G = (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})\"", "lemma enf_not_fulfilled_if_in_offending:\n  assumes validRs: \"valid_reqs M\"\n    and   wfG:     \"wf_graph G\"\n    and   enf:     \"\\<forall>m \\<in> set M. \\<exists>P. \\<forall>G. c_sinvar m G = (\\<forall>e \\<in> edges G. P e)\"\n    shows \"\\<forall>x \\<in> (\\<Union>m\\<in>set M. \\<Union>(c_offending_flows m (fully_connected G))).\n                \\<not> all_security_requirements_fulfilled M \\<lparr> nodes = V, edges = insert x E\\<rparr>\"", "theorem generate_valid_topology_max_topo: \"\\<lbrakk> valid_reqs M; wf_graph G;\n      \\<forall>m \\<in> set M. \\<exists>P. \\<forall>G. c_sinvar m G = (\\<forall>e \\<in> edges G. P e)\\<rbrakk> \\<Longrightarrow> \n      max_topo M (generate_valid_topology M (fully_connected G))\"", "lemma enf_all_valid_policy_subset_of_max:\n    assumes validRs: \"valid_reqs M\"\n    and     wfG:     \"wf_graph G\"\n    and     enf:     \"\\<forall>m \\<in> set M. \\<exists>P. \\<forall>G. c_sinvar m G = (\\<forall>e \\<in> edges G. P e)\"\n    and     nodesG': \"nodes G = nodes G'\"\n    shows \"\\<lbrakk> wf_graph G';\n        all_security_requirements_fulfilled M G'\\<rbrakk> \\<Longrightarrow> \n        edges G' \\<subseteq> edges (generate_valid_topology M (fully_connected G))\"", "lemma (in configured_SecurityInvariant) c_sinvar_valid_imp_no_offending_flows: \n      \"c_sinvar m G \\<Longrightarrow> c_offending_flows m G = {}\"", "lemma all_security_requirements_fulfilled_imp_no_offending_flows:\n        \"valid_reqs M \\<Longrightarrow> all_security_requirements_fulfilled M G \\<Longrightarrow> (\\<Union>m\\<in>set M. \\<Union>(c_offending_flows m G)) = {}\"", "lemma mono_extend_get_offending_flows: \"\\<lbrakk> valid_reqs M;\n         wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n         E' \\<subseteq> E;\n         F' \\<in> get_offending_flows M \\<lparr>nodes = V, edges = E'\\<rparr> \\<rbrakk> \\<Longrightarrow>\n       \\<exists>F\\<in>get_offending_flows M \\<lparr>nodes = V, edges = E\\<rparr>. F' \\<subseteq> F\"", "lemma get_offending_flows_subseteq_edges: \"valid_reqs M \\<Longrightarrow> F \\<in> get_offending_flows M \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow> F \\<subseteq> E\"", "lemma get_offending_flows_union_mono: \"\\<lbrakk>valid_reqs M; \n      wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; E' \\<subseteq> E \\<rbrakk> \\<Longrightarrow>\n      \\<Union>(get_offending_flows M \\<lparr>nodes = V, edges = E'\\<rparr>) \\<subseteq> \\<Union>(get_offending_flows M \\<lparr>nodes = V, edges = E\\<rparr>)\"", "lemma Un_set_offending_flows_bound_minus_subseteq':\"\\<lbrakk>valid_reqs M; \n      wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; E' \\<subseteq> E;\n      \\<Union>(get_offending_flows M \\<lparr>nodes = V, edges = E\\<rparr>) \\<subseteq> X \\<rbrakk> \\<Longrightarrow> \\<Union>(get_offending_flows M \\<lparr>nodes = V, edges = E - E'\\<rparr>) \\<subseteq> X - E'\"", "lemma ENF_uniquely_defined_offedning: \"valid_reqs M \\<Longrightarrow> wf_graph G \\<Longrightarrow> \n      \\<forall>m \\<in> set M. \\<exists>P. \\<forall>G. c_sinvar m G = (\\<forall>e \\<in> edges G. P e) \\<Longrightarrow> \n      \\<forall>m \\<in> set M. \\<forall>G. \\<not> c_sinvar m G \\<longrightarrow>  (\\<exists>OFF. c_offending_flows m G = {OFF})\"", "lemma assumes \"configured_SecurityInvariant m\"\n       and \"\\<forall>G. \\<not> c_sinvar m G \\<longrightarrow> (\\<exists>OFF. c_offending_flows m G = {OFF})\"\n       shows \"\\<exists>OFF_P. \\<forall>G. c_offending_flows m G = (if c_sinvar m G then {} else {OFF_P G})\"", "lemma \"(SOME x. x : {1::nat, 2, 3}) = x \\<Longrightarrow> x = 1 \\<or> x = 2 \\<or> x = 3\"", "lemma generate_valid_topology_SOME_nodes: \"nodes (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>) = V\"", "theorem generate_valid_topology_SOME_sound:\n    \"\\<lbrakk> valid_reqs M; wf_graph \\<lparr>nodes = V, edges = E\\<rparr> \\<rbrakk> \\<Longrightarrow> \n    all_security_requirements_fulfilled M (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\"", "lemma generate_valid_topology_SOME_def_alt:\n      \"generate_valid_topology_SOME M G = delete_edges G (\\<Union>m \\<in> set M. if c_sinvar m G then {} else (SOME F. F \\<in> c_offending_flows m G))\"", "lemma generate_valid_topology_SOME_superset:\n      \"\\<lbrakk> valid_reqs M; wf_graph G \\<rbrakk> \\<Longrightarrow> \n      edges (generate_valid_topology M G) \\<subseteq> edges (generate_valid_topology_SOME M G)\"", "theorem generate_valid_topology_some_sound:\n    \"\\<lbrakk> valid_reqs M; wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E; distinct Es \\<rbrakk> \\<Longrightarrow> \n    all_security_requirements_fulfilled M (generate_valid_topology_some M Es \\<lparr>nodes = V, edges = E\\<rparr>)\""], "translations": [["", "lemma new_configured_TopoS_sinvar_correct:\n   \"SecurityInvariant sinvar defbot receiver_violation \\<Longrightarrow> \n   c_sinvar (the (new_configured_SecurityInvariant (sinvar, defbot, receiver_violation, nP))) = (\\<lambda>G. sinvar G nP)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant sinvar defbot receiver_violation \\<Longrightarrow>\n    c_sinvar\n     (the (new_configured_SecurityInvariant\n            (sinvar, defbot, receiver_violation, nP))) =\n    (\\<lambda>G. sinvar G nP)", "by(simp add: Let_def new_configured_SecurityInvariant.simps)"], ["", "lemma new_configured_TopoS_offending_flows_correct:\n   \"SecurityInvariant sinvar defbot receiver_violation \\<Longrightarrow> \n   c_offending_flows (the (new_configured_SecurityInvariant (sinvar, defbot, receiver_violation, nP))) = \n   (\\<lambda>G. SecurityInvariant_withOffendingFlows.set_offending_flows sinvar G nP)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant sinvar defbot receiver_violation \\<Longrightarrow>\n    c_offending_flows\n     (the (new_configured_SecurityInvariant\n            (sinvar, defbot, receiver_violation, nP))) =\n    (\\<lambda>G.\n        SecurityInvariant_withOffendingFlows.set_offending_flows sinvar G\n         nP)", "by(simp add: Let_def new_configured_SecurityInvariant.simps)"], ["", "text\\<open>We now collect all the core properties of a security invariant, but without the @{typ \"'a\"} @{typ \"'b\"} \n      types, so it is instantiated with a concrete configuration.\\<close>"], ["", "locale configured_SecurityInvariant =\n  fixes m :: \"('v::vertex) SecurityInvariant_configured\"\n  assumes\n    \\<comment> \\<open>As in SecurityInvariant definition\\<close>\n    valid_c_offending_flows:\n    \"c_offending_flows m G = {F. F \\<subseteq> (edges G) \\<and> \\<not> c_sinvar m G \\<and> c_sinvar m (delete_edges G F) \\<and> \n      (\\<forall> (e1, e2) \\<in> F. \\<not> c_sinvar m (add_edge e1 e2 (delete_edges G F)))}\"\n  and\n    \\<comment> \\<open>A empty network can have no security violations\\<close>\n    defined_offending:\n    \"\\<lbrakk> wf_graph \\<lparr> nodes = N, edges = {} \\<rparr> \\<rbrakk> \\<Longrightarrow> c_sinvar m \\<lparr> nodes = N, edges = {}\\<rparr>\"\n  and\n    \\<comment> \\<open>prohibiting more does not decrease security\\<close>\n    mono_sinvar:\n    \"\\<lbrakk> wf_graph \\<lparr> nodes = N, edges = E \\<rparr>; E' \\<subseteq> E; c_sinvar m \\<lparr> nodes = N, edges = E \\<rparr> \\<rbrakk> \\<Longrightarrow> \n      c_sinvar m \\<lparr> nodes = N, edges = E' \\<rparr>\"\n  begin"], ["", "(*compatibility with other definitions*)"], ["", "lemma sinvar_monoI: \n    \"SecurityInvariant_withOffendingFlows.sinvar_mono (\\<lambda> (G::('v::vertex) graph) (nP::'v \\<Rightarrow> 'a). c_sinvar m G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.sinvar_mono\n     (\\<lambda>G nP. c_sinvar m G)", "apply(simp add: SecurityInvariant_withOffendingFlows.sinvar_mono_def, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N E' E.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        c_sinvar m \\<lparr>nodes = N, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> c_sinvar m \\<lparr>nodes = N, edges = E'\\<rparr>", "by(fact mono_sinvar)"], ["", "text\\<open>if the network where nobody communicates with anyone fulfilles its security requirement,\n          the offending flows are always defined.\\<close>"], ["", "lemma defined_offending': \n      \"\\<lbrakk> wf_graph G; \\<not> c_sinvar m G \\<rbrakk> \\<Longrightarrow> c_offending_flows m G \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G; \\<not> c_sinvar m G\\<rbrakk>\n    \\<Longrightarrow> c_offending_flows m G \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G; \\<not> c_sinvar m G\\<rbrakk>\n    \\<Longrightarrow> c_offending_flows m G \\<noteq> {}", "assume a1: \"wf_graph G\"\n        and    a2: \"\\<not> c_sinvar m G\""], ["proof (state)\nthis:\n  wf_graph G\n  \\<not> c_sinvar m G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G; \\<not> c_sinvar m G\\<rbrakk>\n    \\<Longrightarrow> c_offending_flows m G \\<noteq> {}", "have subst_set_offending_flows: \n        \"\\<And>nP. SecurityInvariant_withOffendingFlows.set_offending_flows (\\<lambda>G nP. c_sinvar m G) G nP = c_offending_flows m G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nP.\n       SecurityInvariant_withOffendingFlows.set_offending_flows\n        (\\<lambda>G nP. c_sinvar m G) G nP =\n       c_offending_flows m G", "by(simp add: valid_c_offending_flows fun_eq_iff \n            SecurityInvariant_withOffendingFlows.set_offending_flows_def\n            SecurityInvariant_withOffendingFlows.is_offending_flows_min_set_def\n            SecurityInvariant_withOffendingFlows.is_offending_flows_def)"], ["proof (state)\nthis:\n  SecurityInvariant_withOffendingFlows.set_offending_flows\n   (\\<lambda>G nP. c_sinvar m G) G ?nP =\n  c_offending_flows m G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G; \\<not> c_sinvar m G\\<rbrakk>\n    \\<Longrightarrow> c_offending_flows m G \\<noteq> {}", "from a1"], ["proof (chain)\npicking this:\n  wf_graph G", "have wfG_empty: \"wf_graph \\<lparr>nodes = nodes G, edges = {}\\<rparr>\""], ["proof (prove)\nusing this:\n  wf_graph G\n\ngoal (1 subgoal):\n 1. wf_graph \\<lparr>nodes = nodes G, edges = {}\\<rparr>", "by(simp add:wf_graph_def)"], ["proof (state)\nthis:\n  wf_graph \\<lparr>nodes = nodes G, edges = {}\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G; \\<not> c_sinvar m G\\<rbrakk>\n    \\<Longrightarrow> c_offending_flows m G \\<noteq> {}", "from a1"], ["proof (chain)\npicking this:\n  wf_graph G", "have \"\\<And>nP. \\<not> c_sinvar m G \\<Longrightarrow> SecurityInvariant_withOffendingFlows.set_offending_flows (\\<lambda>G nP. c_sinvar m G) G nP \\<noteq> {}\""], ["proof (prove)\nusing this:\n  wf_graph G\n\ngoal (1 subgoal):\n 1. \\<And>nP.\n       \\<not> c_sinvar m G \\<Longrightarrow>\n       SecurityInvariant_withOffendingFlows.set_offending_flows\n        (\\<lambda>G nP. c_sinvar m G) G nP \\<noteq>\n       {}", "apply(frule_tac finite_distinct_list[OF wf_graph.finiteE])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nP.\n       \\<lbrakk>\\<not> c_sinvar m G; wf_graph G;\n        \\<exists>xs. set xs = edges G \\<and> distinct xs\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.set_offending_flows\n                          (\\<lambda>G nP. c_sinvar m G) G nP \\<noteq>\n                         {}", "apply(erule_tac exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nP xs.\n       \\<lbrakk>\\<not> c_sinvar m G; wf_graph G;\n        set xs = edges G \\<and> distinct xs\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.set_offending_flows\n                          (\\<lambda>G nP. c_sinvar m G) G nP \\<noteq>\n                         {}", "apply(rename_tac list_edges)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nP list_edges.\n       \\<lbrakk>\\<not> c_sinvar m G; wf_graph G;\n        set list_edges = edges G \\<and> distinct list_edges\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.set_offending_flows\n                          (\\<lambda>G nP. c_sinvar m G) G nP \\<noteq>\n                         {}", "apply(rule_tac ff=\"list_edges\" in SecurityInvariant_withOffendingFlows.mono_imp_set_offending_flows_not_empty[OF sinvar_monoI])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>nP list_edges.\n       \\<lbrakk>\\<not> c_sinvar m G; wf_graph G;\n        set list_edges = edges G \\<and> distinct list_edges\\<rbrakk>\n       \\<Longrightarrow> wf_graph G\n 2. \\<And>nP list_edges.\n       \\<lbrakk>\\<not> c_sinvar m G; wf_graph G;\n        set list_edges = edges G \\<and> distinct list_edges\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          (\\<lambda>G nP. c_sinvar m G) (set list_edges) G\n                          nP\n 3. \\<And>nP list_edges.\n       \\<lbrakk>\\<not> c_sinvar m G; wf_graph G;\n        set list_edges = edges G \\<and> distinct list_edges\\<rbrakk>\n       \\<Longrightarrow> set list_edges \\<subseteq> edges G\n 4. \\<And>nP list_edges.\n       \\<lbrakk>\\<not> c_sinvar m G; wf_graph G;\n        set list_edges = edges G \\<and> distinct list_edges\\<rbrakk>\n       \\<Longrightarrow> distinct list_edges", "by(auto simp add: SecurityInvariant_withOffendingFlows.is_offending_flows_def delete_edges_simp2 defined_offending[OF wfG_empty])"], ["proof (state)\nthis:\n  \\<not> c_sinvar m G \\<Longrightarrow>\n  SecurityInvariant_withOffendingFlows.set_offending_flows\n   (\\<lambda>G nP. c_sinvar m G) G ?nP1 \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G; \\<not> c_sinvar m G\\<rbrakk>\n    \\<Longrightarrow> c_offending_flows m G \\<noteq> {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> c_sinvar m G \\<Longrightarrow>\n  SecurityInvariant_withOffendingFlows.set_offending_flows\n   (\\<lambda>G nP. c_sinvar m G) G ?nP1 \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. c_offending_flows m G \\<noteq> {}", "by(simp add: a2 subst_set_offending_flows)"], ["proof (state)\nthis:\n  c_offending_flows m G \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "(* The offending flows definitions are equal, compatibility *)"], ["", "lemma subst_offending_flows: \"\\<And> nP. SecurityInvariant_withOffendingFlows.set_offending_flows (\\<lambda>G nP. c_sinvar m G) G nP = c_offending_flows m G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nP.\n       SecurityInvariant_withOffendingFlows.set_offending_flows\n        (\\<lambda>G nP. c_sinvar m G) G nP =\n       c_offending_flows m G", "apply (unfold SecurityInvariant_withOffendingFlows.set_offending_flows_def\n            SecurityInvariant_withOffendingFlows.is_offending_flows_min_set_def\n            SecurityInvariant_withOffendingFlows.is_offending_flows_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nP.\n       {F. F \\<subseteq> edges G \\<and>\n           (\\<not> c_sinvar m G \\<and> c_sinvar m (delete_edges G F)) \\<and>\n           (\\<forall>(e1, e2)\\<in>F.\n               \\<not> c_sinvar m (add_edge e1 e2 (delete_edges G F)))} =\n       c_offending_flows m G", "by(simp add: valid_c_offending_flows)"], ["", "text\\<open>all the @{term SecurityInvariant_preliminaries} stuff must hold, for an arbitrary @{term nP}\\<close>"], ["", "lemma SecurityInvariant_preliminariesD:\n      \"SecurityInvariant_preliminaries (\\<lambda> (G::('v::vertex) graph) (nP::'v \\<Rightarrow> 'a). c_sinvar m G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_preliminaries (\\<lambda>G nP. c_sinvar m G)", "proof(unfold_locales, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>G nP.\n       \\<lbrakk>wf_graph G; \\<not> c_sinvar m G\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.set_offending_flows\n                          (\\<lambda>G nP. c_sinvar m G) G nP \\<noteq>\n                         {}\n 2. \\<And>N E E' nP.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        c_sinvar m \\<lparr>nodes = N, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> c_sinvar m \\<lparr>nodes = N, edges = E'\\<rparr>\n 3. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows\n         (\\<lambda>G nP. c_sinvar m G) ff G nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          (\\<lambda>G nP. c_sinvar m G) (ff \\<union> f') G\n                          nP", "case 1"], ["proof (state)\nthis:\n  wf_graph G_\n  \\<not> c_sinvar m G_\n\ngoal (3 subgoals):\n 1. \\<And>G nP.\n       \\<lbrakk>wf_graph G; \\<not> c_sinvar m G\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.set_offending_flows\n                          (\\<lambda>G nP. c_sinvar m G) G nP \\<noteq>\n                         {}\n 2. \\<And>N E E' nP.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        c_sinvar m \\<lparr>nodes = N, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> c_sinvar m \\<lparr>nodes = N, edges = E'\\<rparr>\n 3. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows\n         (\\<lambda>G nP. c_sinvar m G) ff G nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          (\\<lambda>G nP. c_sinvar m G) (ff \\<union> f') G\n                          nP", "thus ?case"], ["proof (prove)\nusing this:\n  wf_graph G_\n  \\<not> c_sinvar m G_\n\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.set_offending_flows\n     (\\<lambda>G nP. c_sinvar m G) G_ nP_ \\<noteq>\n    {}", "using defined_offending'"], ["proof (prove)\nusing this:\n  wf_graph G_\n  \\<not> c_sinvar m G_\n  \\<lbrakk>wf_graph ?G; \\<not> c_sinvar m ?G\\<rbrakk>\n  \\<Longrightarrow> c_offending_flows m ?G \\<noteq> {}\n\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.set_offending_flows\n     (\\<lambda>G nP. c_sinvar m G) G_ nP_ \\<noteq>\n    {}", "by(simp add: subst_offending_flows)"], ["proof (state)\nthis:\n  SecurityInvariant_withOffendingFlows.set_offending_flows\n   (\\<lambda>G nP. c_sinvar m G) G_ nP_ \\<noteq>\n  {}\n\ngoal (2 subgoals):\n 1. \\<And>N E E' nP.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        c_sinvar m \\<lparr>nodes = N, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> c_sinvar m \\<lparr>nodes = N, edges = E'\\<rparr>\n 2. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows\n         (\\<lambda>G nP. c_sinvar m G) ff G nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          (\\<lambda>G nP. c_sinvar m G) (ff \\<union> f') G\n                          nP", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>N E E' nP.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        c_sinvar m \\<lparr>nodes = N, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> c_sinvar m \\<lparr>nodes = N, edges = E'\\<rparr>\n 2. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows\n         (\\<lambda>G nP. c_sinvar m G) ff G nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          (\\<lambda>G nP. c_sinvar m G) (ff \\<union> f') G\n                          nP", "case 2"], ["proof (state)\nthis:\n  wf_graph \\<lparr>nodes = N_, edges = E_\\<rparr>\n  E'_ \\<subseteq> E_\n  c_sinvar m \\<lparr>nodes = N_, edges = E_\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<And>N E E' nP.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        c_sinvar m \\<lparr>nodes = N, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> c_sinvar m \\<lparr>nodes = N, edges = E'\\<rparr>\n 2. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows\n         (\\<lambda>G nP. c_sinvar m G) ff G nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          (\\<lambda>G nP. c_sinvar m G) (ff \\<union> f') G\n                          nP", "thus ?case"], ["proof (prove)\nusing this:\n  wf_graph \\<lparr>nodes = N_, edges = E_\\<rparr>\n  E'_ \\<subseteq> E_\n  c_sinvar m \\<lparr>nodes = N_, edges = E_\\<rparr>\n\ngoal (1 subgoal):\n 1. c_sinvar m \\<lparr>nodes = N_, edges = E'_\\<rparr>", "by(fact mono_sinvar)"], ["proof (state)\nthis:\n  c_sinvar m \\<lparr>nodes = N_, edges = E'_\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows\n         (\\<lambda>G nP. c_sinvar m G) ff G nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          (\\<lambda>G nP. c_sinvar m G) (ff \\<union> f') G\n                          nP", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows\n         (\\<lambda>G nP. c_sinvar m G) ff G nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          (\\<lambda>G nP. c_sinvar m G) (ff \\<union> f') G\n                          nP", "case 3"], ["proof (state)\nthis:\n  wf_graph G_\n  SecurityInvariant_withOffendingFlows.is_offending_flows\n   (\\<lambda>G nP. c_sinvar m G) ff_ G_ nP_\n\ngoal (1 subgoal):\n 1. \\<And>G ff nP f'.\n       \\<lbrakk>wf_graph G;\n        SecurityInvariant_withOffendingFlows.is_offending_flows\n         (\\<lambda>G nP. c_sinvar m G) ff G nP\\<rbrakk>\n       \\<Longrightarrow> SecurityInvariant_withOffendingFlows.is_offending_flows\n                          (\\<lambda>G nP. c_sinvar m G) (ff \\<union> f') G\n                          nP", "thus ?case"], ["proof (prove)\nusing this:\n  wf_graph G_\n  SecurityInvariant_withOffendingFlows.is_offending_flows\n   (\\<lambda>G nP. c_sinvar m G) ff_ G_ nP_\n\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.is_offending_flows\n     (\\<lambda>G nP. c_sinvar m G) (ff_ \\<union> f'_) G_ nP_", "by(fact SecurityInvariant_withOffendingFlows.sinvar_mono_imp_is_offending_flows_mono[OF sinvar_monoI])"], ["proof (state)\nthis:\n  SecurityInvariant_withOffendingFlows.is_offending_flows\n   (\\<lambda>G nP. c_sinvar m G) (ff_ \\<union> f'_) G_ nP_\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma negative_mono:\n     \"\\<And> N E' E. wf_graph \\<lparr> nodes = N, edges = E \\<rparr> \\<Longrightarrow> \n        E' \\<subseteq> E \\<Longrightarrow> \\<not> c_sinvar m \\<lparr> nodes = N, edges = E' \\<rparr> \\<Longrightarrow> \\<not> c_sinvar m \\<lparr> nodes = N, edges = E \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N E' E.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        \\<not> c_sinvar m \\<lparr>nodes = N, edges = E'\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<not> c_sinvar m\n                                 \\<lparr>nodes = N, edges = E\\<rparr>", "by(blast dest: mono_sinvar)"], ["", "subsection\\<open>Reusing Lemmata\\<close>"], ["", "lemmas mono_extend_set_offending_flows =\n      SecurityInvariant_preliminaries.mono_extend_set_offending_flows[OF SecurityInvariant_preliminariesD, simplified subst_offending_flows]"], ["", "text\\<open>@{thm mono_extend_set_offending_flows [no_vars]}\\<close>"], ["", "lemmas offending_flows_union_mono =\n      SecurityInvariant_preliminaries.offending_flows_union_mono[OF SecurityInvariant_preliminariesD, simplified subst_offending_flows]"], ["", "text\\<open>@{thm offending_flows_union_mono [no_vars]}\\<close>"], ["", "lemmas sinvar_valid_remove_flattened_offending_flows =\n      SecurityInvariant_preliminaries.sinvar_valid_remove_flattened_offending_flows[OF SecurityInvariant_preliminariesD, simplified subst_offending_flows]"], ["", "text\\<open>@{thm sinvar_valid_remove_flattened_offending_flows [no_vars]}\\<close>"], ["", "lemmas sinvar_valid_remove_SOME_offending_flows =\n      SecurityInvariant_preliminaries.sinvar_valid_remove_SOME_offending_flows[OF SecurityInvariant_preliminariesD, simplified subst_offending_flows]"], ["", "text\\<open>@{thm sinvar_valid_remove_SOME_offending_flows [no_vars]}\\<close>"], ["", "lemmas sinvar_valid_remove_minimalize_offending_overapprox =\n      SecurityInvariant_preliminaries.sinvar_valid_remove_minimalize_offending_overapprox[OF SecurityInvariant_preliminariesD, simplified subst_offending_flows]"], ["", "text\\<open>@{thm sinvar_valid_remove_minimalize_offending_overapprox [no_vars]}\\<close>"], ["", "lemmas empty_offending_contra =\n      SecurityInvariant_withOffendingFlows.empty_offending_contra[where sinvar=\"(\\<lambda>G nP. c_sinvar m G)\", simplified subst_offending_flows]"], ["", "text\\<open>@{thm empty_offending_contra [no_vars]}\\<close>"], ["", "lemmas Un_set_offending_flows_bound_minus_subseteq = \n      SecurityInvariant_preliminaries.Un_set_offending_flows_bound_minus_subseteq[OF SecurityInvariant_preliminariesD, simplified subst_offending_flows]"], ["", "text\\<open>@{thm Un_set_offending_flows_bound_minus_subseteq [no_vars]}\\<close>"], ["", "lemmas Un_set_offending_flows_bound_minus_subseteq' = \n      SecurityInvariant_preliminaries.Un_set_offending_flows_bound_minus_subseteq'[OF SecurityInvariant_preliminariesD, simplified subst_offending_flows]"], ["", "text\\<open>@{thm Un_set_offending_flows_bound_minus_subseteq' [no_vars]}\\<close>"], ["", "end"], ["", "thm configured_SecurityInvariant_def"], ["", "text\\<open>@{thm configured_SecurityInvariant_def [no_vars]}\\<close>"], ["", "thm configured_SecurityInvariant.mono_sinvar"], ["", "text\\<open>@{thm configured_SecurityInvariant.mono_sinvar [no_vars]}\\<close>"], ["", "text\\<open>\n  Naming convention:\n    m :: network security requirement\n    M :: network security requirement list\n\\<close>"], ["", "text\\<open>The function @{term new_configured_SecurityInvariant} takes some tuple and if it returns a result,\n         the locale assumptions are automatically fulfilled.\\<close>"], ["", "theorem new_configured_SecurityInvariant_sound: \n  \"\\<lbrakk> new_configured_SecurityInvariant (sinvar, defbot, receiver_violation, nP) = Some m \\<rbrakk> \\<Longrightarrow>\n    configured_SecurityInvariant m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_configured_SecurityInvariant\n     (sinvar, defbot, receiver_violation, nP) =\n    Some m \\<Longrightarrow>\n    configured_SecurityInvariant m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. new_configured_SecurityInvariant\n     (sinvar, defbot, receiver_violation, nP) =\n    Some m \\<Longrightarrow>\n    configured_SecurityInvariant m", "assume a: \"new_configured_SecurityInvariant (sinvar, defbot, receiver_violation, nP) = Some m\""], ["proof (state)\nthis:\n  new_configured_SecurityInvariant\n   (sinvar, defbot, receiver_violation, nP) =\n  Some m\n\ngoal (1 subgoal):\n 1. new_configured_SecurityInvariant\n     (sinvar, defbot, receiver_violation, nP) =\n    Some m \\<Longrightarrow>\n    configured_SecurityInvariant m", "hence NetModel: \"SecurityInvariant sinvar defbot receiver_violation\""], ["proof (prove)\nusing this:\n  new_configured_SecurityInvariant\n   (sinvar, defbot, receiver_violation, nP) =\n  Some m\n\ngoal (1 subgoal):\n 1. SecurityInvariant sinvar defbot receiver_violation", "by(simp add: new_configured_SecurityInvariant.simps split: if_split_asm)"], ["proof (state)\nthis:\n  SecurityInvariant sinvar defbot receiver_violation\n\ngoal (1 subgoal):\n 1. new_configured_SecurityInvariant\n     (sinvar, defbot, receiver_violation, nP) =\n    Some m \\<Longrightarrow>\n    configured_SecurityInvariant m", "hence NetModel_p: \"SecurityInvariant_preliminaries sinvar\""], ["proof (prove)\nusing this:\n  SecurityInvariant sinvar defbot receiver_violation\n\ngoal (1 subgoal):\n 1. SecurityInvariant_preliminaries sinvar", "by(simp add: SecurityInvariant_def)"], ["proof (state)\nthis:\n  SecurityInvariant_preliminaries sinvar\n\ngoal (1 subgoal):\n 1. new_configured_SecurityInvariant\n     (sinvar, defbot, receiver_violation, nP) =\n    Some m \\<Longrightarrow>\n    configured_SecurityInvariant m", "from a"], ["proof (chain)\npicking this:\n  new_configured_SecurityInvariant\n   (sinvar, defbot, receiver_violation, nP) =\n  Some m", "have c_eval: \"c_sinvar m = (\\<lambda>G. sinvar G nP)\"\n         and c_offending: \"c_offending_flows m = (\\<lambda>G. SecurityInvariant_withOffendingFlows.set_offending_flows sinvar G nP)\"\n         and \"c_isIFS m = receiver_violation\""], ["proof (prove)\nusing this:\n  new_configured_SecurityInvariant\n   (sinvar, defbot, receiver_violation, nP) =\n  Some m\n\ngoal (1 subgoal):\n 1. c_sinvar m = (\\<lambda>G. sinvar G nP) &&&\n    c_offending_flows m =\n    (\\<lambda>G.\n        SecurityInvariant_withOffendingFlows.set_offending_flows sinvar G\n         nP) &&&\n    c_isIFS m = receiver_violation", "by(auto simp add: new_configured_SecurityInvariant.simps NetModel split: if_split_asm)"], ["proof (state)\nthis:\n  c_sinvar m = (\\<lambda>G. sinvar G nP)\n  c_offending_flows m =\n  (\\<lambda>G.\n      SecurityInvariant_withOffendingFlows.set_offending_flows sinvar G nP)\n  c_isIFS m = receiver_violation\n\ngoal (1 subgoal):\n 1. new_configured_SecurityInvariant\n     (sinvar, defbot, receiver_violation, nP) =\n    Some m \\<Longrightarrow>\n    configured_SecurityInvariant m", "have monoI: \"SecurityInvariant_withOffendingFlows.sinvar_mono sinvar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SecurityInvariant_withOffendingFlows.sinvar_mono sinvar", "apply(simp add: SecurityInvariant_withOffendingFlows.sinvar_mono_def, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nP N E' E.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        sinvar \\<lparr>nodes = N, edges = E\\<rparr> nP\\<rbrakk>\n       \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = E'\\<rparr> nP", "by(fact SecurityInvariant_preliminaries.mono_sinvar[OF NetModel_p])"], ["proof (state)\nthis:\n  SecurityInvariant_withOffendingFlows.sinvar_mono sinvar\n\ngoal (1 subgoal):\n 1. new_configured_SecurityInvariant\n     (sinvar, defbot, receiver_violation, nP) =\n    Some m \\<Longrightarrow>\n    configured_SecurityInvariant m", "from SecurityInvariant_withOffendingFlows.valid_empty_edges_iff_exists_offending_flows[OF monoI, symmetric]\n            SecurityInvariant_preliminaries.defined_offending[OF NetModel_p]"], ["proof (chain)\npicking this:\n  \\<lbrakk>wf_graph ?G; \\<not> sinvar ?G ?nP\\<rbrakk>\n  \\<Longrightarrow> (SecurityInvariant_withOffendingFlows.set_offending_flows\n                      sinvar ?G ?nP \\<noteq>\n                     {}) =\n                    sinvar \\<lparr>nodes = nodes ?G, edges = {}\\<rparr> ?nP\n  \\<lbrakk>wf_graph ?G; \\<not> sinvar ?G ?nP\\<rbrakk>\n  \\<Longrightarrow> SecurityInvariant_withOffendingFlows.set_offending_flows\n                     sinvar ?G ?nP \\<noteq>\n                    {}", "have eval_empty_graph: \"\\<And> N nP. wf_graph \\<lparr>nodes = N, edges = {}\\<rparr> \\<Longrightarrow> sinvar \\<lparr>nodes = N, edges = {}\\<rparr> nP\""], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_graph ?G; \\<not> sinvar ?G ?nP\\<rbrakk>\n  \\<Longrightarrow> (SecurityInvariant_withOffendingFlows.set_offending_flows\n                      sinvar ?G ?nP \\<noteq>\n                     {}) =\n                    sinvar \\<lparr>nodes = nodes ?G, edges = {}\\<rparr> ?nP\n  \\<lbrakk>wf_graph ?G; \\<not> sinvar ?G ?nP\\<rbrakk>\n  \\<Longrightarrow> SecurityInvariant_withOffendingFlows.set_offending_flows\n                     sinvar ?G ?nP \\<noteq>\n                    {}\n\ngoal (1 subgoal):\n 1. \\<And>N nP.\n       wf_graph \\<lparr>nodes = N, edges = {}\\<rparr> \\<Longrightarrow>\n       sinvar \\<lparr>nodes = N, edges = {}\\<rparr> nP", "by fastforce"], ["proof (state)\nthis:\n  wf_graph \\<lparr>nodes = ?N, edges = {}\\<rparr> \\<Longrightarrow>\n  sinvar \\<lparr>nodes = ?N, edges = {}\\<rparr> ?nP\n\ngoal (1 subgoal):\n 1. new_configured_SecurityInvariant\n     (sinvar, defbot, receiver_violation, nP) =\n    Some m \\<Longrightarrow>\n    configured_SecurityInvariant m", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. configured_SecurityInvariant m", "apply(unfold_locales)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G.\n       c_offending_flows m G =\n       {F. F \\<subseteq> edges G \\<and>\n           \\<not> c_sinvar m G \\<and>\n           c_sinvar m (delete_edges G F) \\<and>\n           (\\<forall>(e1, e2)\\<in>F.\n               \\<not> c_sinvar m (add_edge e1 e2 (delete_edges G F)))}\n 2. \\<And>N.\n       wf_graph \\<lparr>nodes = N, edges = {}\\<rparr> \\<Longrightarrow>\n       c_sinvar m \\<lparr>nodes = N, edges = {}\\<rparr>\n 3. \\<And>N E E'.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        c_sinvar m \\<lparr>nodes = N, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> c_sinvar m \\<lparr>nodes = N, edges = E'\\<rparr>", "apply(simp add: c_eval c_offending SecurityInvariant_withOffendingFlows.set_offending_flows_def SecurityInvariant_withOffendingFlows.is_offending_flows_min_set_def SecurityInvariant_withOffendingFlows.is_offending_flows_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>N.\n       wf_graph \\<lparr>nodes = N, edges = {}\\<rparr> \\<Longrightarrow>\n       c_sinvar m \\<lparr>nodes = N, edges = {}\\<rparr>\n 2. \\<And>N E E'.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        c_sinvar m \\<lparr>nodes = N, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> c_sinvar m \\<lparr>nodes = N, edges = E'\\<rparr>", "apply(simp add: c_eval eval_empty_graph)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N E E'.\n       \\<lbrakk>wf_graph \\<lparr>nodes = N, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        c_sinvar m \\<lparr>nodes = N, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> c_sinvar m \\<lparr>nodes = N, edges = E'\\<rparr>", "apply(simp add: c_eval,drule(3) SecurityInvariant_preliminaries.mono_sinvar[OF NetModel_p])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  configured_SecurityInvariant m\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>All security invariants are valid according to the definition\\<close>"], ["", "definition valid_reqs :: \"('v::vertex) SecurityInvariant_configured list \\<Rightarrow> bool\" where\n  \"valid_reqs M \\<equiv> \\<forall> m \\<in> set M. configured_SecurityInvariant m\""], ["", "subsection \\<open>Algorithms\\<close>"], ["", "text\\<open>A (generic) security invariant corresponds to a type of security requirements (type: @{typ \"'v graph \\<Rightarrow> ('v \\<Rightarrow> 'a) \\<Rightarrow> bool\"}).\n          A configured security invariant is a security requirement in a scenario specific setting (type: @{typ \"'v graph \\<Rightarrow> bool\"}).\n          I.e., it is a security requirement as listed in the requirements document.\n          All security requirements are fulfilled for a fixed policy @{term G} if all security requirements are fulfilled for @{term G}.\\<close>"], ["", "text\\<open>Get all possible offending flows from all security requirements\\<close>"], ["", "definition get_offending_flows :: \"'v SecurityInvariant_configured list \\<Rightarrow> 'v graph \\<Rightarrow> (('v \\<times> 'v) set set)\" where\n      \"get_offending_flows M G = (\\<Union>m\\<in>set M. c_offending_flows m G)\""], ["", "(*Note: only checks sinvar, not eval!! No 'a 'b type variables here*)"], ["", "definition all_security_requirements_fulfilled :: \"('v::vertex) SecurityInvariant_configured list \\<Rightarrow> 'v graph \\<Rightarrow> bool\" where\n      \"all_security_requirements_fulfilled M G \\<equiv> \\<forall>m \\<in> set M. (c_sinvar m) G\""], ["", "text\\<open>Generate a valid topology from the security requirements\\<close>"], ["", "(*constant G, remove after algorithm*)"], ["", "fun generate_valid_topology :: \"'v SecurityInvariant_configured list \\<Rightarrow> 'v graph \\<Rightarrow> 'v graph\" where\n      \"generate_valid_topology [] G = G\" |\n      \"generate_valid_topology (m#Ms) G = delete_edges (generate_valid_topology Ms G) (\\<Union> (c_offending_flows m G))\"\n\n     \\<comment> \\<open>return all Access Control Strategy models from a list of models\\<close>"], ["", "definition get_ACS :: \"('v::vertex) SecurityInvariant_configured list \\<Rightarrow> 'v SecurityInvariant_configured list\" where\n      \"get_ACS M \\<equiv> [m \\<leftarrow> M. \\<not> c_isIFS m]\"\n     \\<comment> \\<open>return all Information Flows Strategy models from a list of models\\<close>"], ["", "definition get_IFS :: \"('v::vertex) SecurityInvariant_configured list \\<Rightarrow> 'v SecurityInvariant_configured list\" where\n      \"get_IFS M \\<equiv> [m \\<leftarrow> M. c_isIFS m]\""], ["", "lemma get_ACS_union_get_IFS: \"set (get_ACS M) \\<union> set (get_IFS M) = set M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (get_ACS M) \\<union> set (get_IFS M) = set M", "by(auto simp add: get_ACS_def get_IFS_def)"], ["", "subsection\\<open>Lemmata\\<close>"], ["", "lemma valid_reqs1: \"valid_reqs (m # M) \\<Longrightarrow> configured_SecurityInvariant m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_reqs (m # M) \\<Longrightarrow> configured_SecurityInvariant m", "by(simp add: valid_reqs_def)"], ["", "lemma valid_reqs2: \"valid_reqs (m # M) \\<Longrightarrow> valid_reqs M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_reqs (m # M) \\<Longrightarrow> valid_reqs M", "by(simp add: valid_reqs_def)"], ["", "lemma get_offending_flows_alt1: \"get_offending_flows M G = \\<Union> {c_offending_flows m G | m. m \\<in> set M}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_offending_flows M G =\n    \\<Union> {c_offending_flows m G |m. m \\<in> set M}", "apply(simp add: get_offending_flows_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>m\\<in>set M. c_offending_flows m G) =\n    \\<Union> {c_offending_flows m G |m. m \\<in> set M}", "by fastforce"], ["", "lemma get_offending_flows_un: \"\\<Union>(get_offending_flows M G) = (\\<Union>m\\<in>set M. \\<Union>(c_offending_flows m G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (get_offending_flows M G) =\n    (\\<Union>m\\<in>set M. \\<Union> (c_offending_flows m G))", "apply(simp add: get_offending_flows_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (\\<Union>m\\<in>set M. c_offending_flows m G) =\n    (\\<Union>m\\<in>set M. \\<Union> (c_offending_flows m G))", "by blast"], ["", "lemma all_security_requirements_fulfilled_mono:\n      \"\\<lbrakk> valid_reqs M; E' \\<subseteq> E; wf_graph \\<lparr> nodes = V, edges = E \\<rparr> \\<rbrakk> \\<Longrightarrow>  \n        all_security_requirements_fulfilled M \\<lparr> nodes = V, edges = E \\<rparr> \\<Longrightarrow>\n        all_security_requirements_fulfilled M \\<lparr> nodes = V, edges = E' \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; E' \\<subseteq> E;\n     wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     all_security_requirements_fulfilled M\n      \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> all_security_requirements_fulfilled M\n                       \\<lparr>nodes = V, edges = E'\\<rparr>", "apply(induction M arbitrary: E' E)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>E' E.\n       \\<lbrakk>valid_reqs []; E' \\<subseteq> E;\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        all_security_requirements_fulfilled []\n         \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled []\n                          \\<lparr>nodes = V, edges = E'\\<rparr>\n 2. \\<And>a M E' E.\n       \\<lbrakk>\\<And>E' E.\n                   \\<lbrakk>valid_reqs M; E' \\<subseteq> E;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                    all_security_requirements_fulfilled M\n                     \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> all_security_requirements_fulfilled M\n\\<lparr>nodes = V, edges = E'\\<rparr>;\n        valid_reqs (a # M); E' \\<subseteq> E;\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        all_security_requirements_fulfilled (a # M)\n         \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          \\<lparr>nodes = V, edges = E'\\<rparr>", "apply(simp_all add: all_security_requirements_fulfilled_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M E' E.\n       \\<lbrakk>\\<And>E' E.\n                   \\<lbrakk>valid_reqs M; E' \\<subseteq> E;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                    \\<forall>m\\<in>set M.\n                       c_sinvar m\n                        \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>m\\<in>set M.\n  c_sinvar m \\<lparr>nodes = V, edges = E'\\<rparr>;\n        valid_reqs (a # M); E' \\<subseteq> E;\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        c_sinvar a \\<lparr>nodes = V, edges = E\\<rparr> \\<and>\n        (\\<forall>m\\<in>set M.\n            c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> c_sinvar a\n                          \\<lparr>nodes = V, edges = E'\\<rparr> \\<and>\n                         (\\<forall>m\\<in>set M.\n                             c_sinvar m\n                              \\<lparr>nodes = V, edges = E'\\<rparr>)", "apply(rename_tac m M E' E)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m M E' E.\n       \\<lbrakk>\\<And>E' E.\n                   \\<lbrakk>valid_reqs M; E' \\<subseteq> E;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                    \\<forall>m\\<in>set M.\n                       c_sinvar m\n                        \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>m\\<in>set M.\n  c_sinvar m \\<lparr>nodes = V, edges = E'\\<rparr>;\n        valid_reqs (m # M); E' \\<subseteq> E;\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<and>\n        (\\<forall>m\\<in>set M.\n            c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> c_sinvar m\n                          \\<lparr>nodes = V, edges = E'\\<rparr> \\<and>\n                         (\\<forall>m\\<in>set M.\n                             c_sinvar m\n                              \\<lparr>nodes = V, edges = E'\\<rparr>)", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m M E' E.\n       \\<lbrakk>\\<And>E' E.\n                   \\<lbrakk>valid_reqs M; E' \\<subseteq> E;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                    \\<forall>m\\<in>set M.\n                       c_sinvar m\n                        \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>m\\<in>set M.\n  c_sinvar m \\<lparr>nodes = V, edges = E'\\<rparr>;\n        valid_reqs (m # M); E' \\<subseteq> E;\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<and>\n        (\\<forall>m\\<in>set M.\n            c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> c_sinvar m \\<lparr>nodes = V, edges = E'\\<rparr>\n 2. \\<And>m M E' E.\n       \\<lbrakk>\\<And>E' E.\n                   \\<lbrakk>valid_reqs M; E' \\<subseteq> E;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                    \\<forall>m\\<in>set M.\n                       c_sinvar m\n                        \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>m\\<in>set M.\n  c_sinvar m \\<lparr>nodes = V, edges = E'\\<rparr>;\n        valid_reqs (m # M); E' \\<subseteq> E;\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<and>\n        (\\<forall>m\\<in>set M.\n            c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m\\<in>set M.\n                            c_sinvar m \\<lparr>nodes = V, edges = E'\\<rparr>", "apply(erule(2) configured_SecurityInvariant.mono_sinvar[OF valid_reqs1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m M E' E.\n       \\<lbrakk>\\<And>E' E.\n                   \\<lbrakk>valid_reqs M; E' \\<subseteq> E;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                    \\<forall>m\\<in>set M.\n                       c_sinvar m\n                        \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>m\\<in>set M.\n  c_sinvar m \\<lparr>nodes = V, edges = E'\\<rparr>;\n        E' \\<subseteq> E; wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<and>\n        (\\<forall>m\\<in>set M.\n            c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr>\n 2. \\<And>m M E' E.\n       \\<lbrakk>\\<And>E' E.\n                   \\<lbrakk>valid_reqs M; E' \\<subseteq> E;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                    \\<forall>m\\<in>set M.\n                       c_sinvar m\n                        \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>m\\<in>set M.\n  c_sinvar m \\<lparr>nodes = V, edges = E'\\<rparr>;\n        valid_reqs (m # M); E' \\<subseteq> E;\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<and>\n        (\\<forall>m\\<in>set M.\n            c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m\\<in>set M.\n                            c_sinvar m \\<lparr>nodes = V, edges = E'\\<rparr>", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m M E' E.\n       \\<lbrakk>\\<And>E' E.\n                   \\<lbrakk>valid_reqs M; E' \\<subseteq> E;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                    \\<forall>m\\<in>set M.\n                       c_sinvar m\n                        \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>m\\<in>set M.\n  c_sinvar m \\<lparr>nodes = V, edges = E'\\<rparr>;\n        valid_reqs (m # M); E' \\<subseteq> E;\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<and>\n        (\\<forall>m\\<in>set M.\n            c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m\\<in>set M.\n                            c_sinvar m \\<lparr>nodes = V, edges = E'\\<rparr>", "apply(drule valid_reqs2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m M E' E.\n       \\<lbrakk>\\<And>E' E.\n                   \\<lbrakk>valid_reqs M; E' \\<subseteq> E;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                    \\<forall>m\\<in>set M.\n                       c_sinvar m\n                        \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>m\\<in>set M.\n  c_sinvar m \\<lparr>nodes = V, edges = E'\\<rparr>;\n        E' \\<subseteq> E; wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<and>\n        (\\<forall>m\\<in>set M.\n            c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs M\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m\\<in>set M.\n                            c_sinvar m \\<lparr>nodes = V, edges = E'\\<rparr>", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>generate valid topology\\<close>"], ["", "(*\n      lemma generate_valid_topology_def_delete_multiple: \n        \"generate_valid_topology M G = delete_edges (generate_valid_topology M G) (\\<Union> (get_offending_flows M G))\"\n        proof(induction M arbitrary: G)\n          case Nil\n            thus ?case by(simp add: get_offending_flows_def)\n          next\n          case (Cons m M)\n            from Cons[simplified delete_edges_simp2 get_offending_flows_def] \n            have \"edges (generate_valid_topology M G) = edges (generate_valid_topology M G) - \\<Union>(\\<Union>m\\<in>set M. c_offending_flows m G)\"\n              by (metis graph.select_convs(2))\n            thus ?case\n              apply(simp add: get_offending_flows_def delete_edges_simp2)\n              by blast\n        qed*)"], ["", "lemma generate_valid_topology_nodes:\n      \"nodes (generate_valid_topology M G) = (nodes G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (generate_valid_topology M G) = nodes G", "apply(induction M arbitrary: G)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>G. nodes (generate_valid_topology [] G) = nodes G\n 2. \\<And>a M G.\n       (\\<And>G.\n           nodes (generate_valid_topology M G) = nodes G) \\<Longrightarrow>\n       nodes (generate_valid_topology (a # M) G) = nodes G", "by(simp_all add: graph_ops)"], ["", "lemma generate_valid_topology_def_alt:\n        \"generate_valid_topology M G = delete_edges G (\\<Union> (get_offending_flows M G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate_valid_topology M G =\n    delete_edges G (\\<Union> (get_offending_flows M G))", "proof(induction M arbitrary: G)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>G.\n       generate_valid_topology [] G =\n       delete_edges G (\\<Union> (get_offending_flows [] G))\n 2. \\<And>a M G.\n       (\\<And>G.\n           generate_valid_topology M G =\n           delete_edges G\n            (\\<Union> (get_offending_flows M G))) \\<Longrightarrow>\n       generate_valid_topology (a # M) G =\n       delete_edges G (\\<Union> (get_offending_flows (a # M) G))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>G.\n       generate_valid_topology [] G =\n       delete_edges G (\\<Union> (get_offending_flows [] G))\n 2. \\<And>a M G.\n       (\\<And>G.\n           generate_valid_topology M G =\n           delete_edges G\n            (\\<Union> (get_offending_flows M G))) \\<Longrightarrow>\n       generate_valid_topology (a # M) G =\n       delete_edges G (\\<Union> (get_offending_flows (a # M) G))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. generate_valid_topology [] G =\n    delete_edges G (\\<Union> (get_offending_flows [] G))", "by(simp add: get_offending_flows_def)"], ["proof (state)\nthis:\n  generate_valid_topology [] G =\n  delete_edges G (\\<Union> (get_offending_flows [] G))\n\ngoal (1 subgoal):\n 1. \\<And>a M G.\n       (\\<And>G.\n           generate_valid_topology M G =\n           delete_edges G\n            (\\<Union> (get_offending_flows M G))) \\<Longrightarrow>\n       generate_valid_topology (a # M) G =\n       delete_edges G (\\<Union> (get_offending_flows (a # M) G))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a M G.\n       (\\<And>G.\n           generate_valid_topology M G =\n           delete_edges G\n            (\\<Union> (get_offending_flows M G))) \\<Longrightarrow>\n       generate_valid_topology (a # M) G =\n       delete_edges G (\\<Union> (get_offending_flows (a # M) G))", "case (Cons m M)"], ["proof (state)\nthis:\n  generate_valid_topology M ?G =\n  delete_edges ?G (\\<Union> (get_offending_flows M ?G))\n\ngoal (1 subgoal):\n 1. \\<And>a M G.\n       (\\<And>G.\n           generate_valid_topology M G =\n           delete_edges G\n            (\\<Union> (get_offending_flows M G))) \\<Longrightarrow>\n       generate_valid_topology (a # M) G =\n       delete_edges G (\\<Union> (get_offending_flows (a # M) G))", "from Cons[simplified delete_edges_simp2 get_offending_flows_def]"], ["proof (chain)\npicking this:\n  generate_valid_topology M ?G =\n  \\<lparr>nodes = nodes ?G,\n     edges =\n       edges ?G -\n       \\<Union> (\\<Union>m\\<in>set M. c_offending_flows m ?G)\\<rparr>", "have \"edges (generate_valid_topology M G) = edges G - \\<Union>(\\<Union>m\\<in>set M. c_offending_flows m G)\""], ["proof (prove)\nusing this:\n  generate_valid_topology M ?G =\n  \\<lparr>nodes = nodes ?G,\n     edges =\n       edges ?G -\n       \\<Union> (\\<Union>m\\<in>set M. c_offending_flows m ?G)\\<rparr>\n\ngoal (1 subgoal):\n 1. edges (generate_valid_topology M G) =\n    edges G - \\<Union> (\\<Union>m\\<in>set M. c_offending_flows m G)", "by (metis graph.select_convs(2))"], ["proof (state)\nthis:\n  edges (generate_valid_topology M G) =\n  edges G - \\<Union> (\\<Union>m\\<in>set M. c_offending_flows m G)\n\ngoal (1 subgoal):\n 1. \\<And>a M G.\n       (\\<And>G.\n           generate_valid_topology M G =\n           delete_edges G\n            (\\<Union> (get_offending_flows M G))) \\<Longrightarrow>\n       generate_valid_topology (a # M) G =\n       delete_edges G (\\<Union> (get_offending_flows (a # M) G))", "thus ?case"], ["proof (prove)\nusing this:\n  edges (generate_valid_topology M G) =\n  edges G - \\<Union> (\\<Union>m\\<in>set M. c_offending_flows m G)\n\ngoal (1 subgoal):\n 1. generate_valid_topology (m # M) G =\n    delete_edges G (\\<Union> (get_offending_flows (m # M) G))", "apply(simp add: get_offending_flows_def delete_edges_simp2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. edges (generate_valid_topology M G) =\n    edges G -\n    \\<Union> (\\<Union>m\\<in>set M. c_offending_flows m G) \\<Longrightarrow>\n    nodes (generate_valid_topology M G) = nodes G \\<and>\n    edges G - \\<Union> (\\<Union>m\\<in>set M. c_offending_flows m G) -\n    \\<Union> (c_offending_flows m G) =\n    edges G -\n    (\\<Union> (c_offending_flows m G) \\<union>\n     \\<Union> (\\<Union>x\\<in>set M. c_offending_flows x G))", "apply(rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. edges (generate_valid_topology M G) =\n    edges G -\n    \\<Union> (\\<Union>m\\<in>set M. c_offending_flows m G) \\<Longrightarrow>\n    nodes (generate_valid_topology M G) = nodes G\n 2. edges (generate_valid_topology M G) =\n    edges G -\n    \\<Union> (\\<Union>m\\<in>set M. c_offending_flows m G) \\<Longrightarrow>\n    edges G - \\<Union> (\\<Union>m\\<in>set M. c_offending_flows m G) -\n    \\<Union> (c_offending_flows m G) =\n    edges G -\n    (\\<Union> (c_offending_flows m G) \\<union>\n     \\<Union> (\\<Union>x\\<in>set M. c_offending_flows x G))", "apply(simp add: generate_valid_topology_nodes)"], ["proof (prove)\ngoal (1 subgoal):\n 1. edges (generate_valid_topology M G) =\n    edges G -\n    \\<Union> (\\<Union>m\\<in>set M. c_offending_flows m G) \\<Longrightarrow>\n    edges G - \\<Union> (\\<Union>m\\<in>set M. c_offending_flows m G) -\n    \\<Union> (c_offending_flows m G) =\n    edges G -\n    (\\<Union> (c_offending_flows m G) \\<union>\n     \\<Union> (\\<Union>x\\<in>set M. c_offending_flows x G))", "by blast"], ["proof (state)\nthis:\n  generate_valid_topology (m # M) G =\n  delete_edges G (\\<Union> (get_offending_flows (m # M) G))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_graph_generate_valid_topology: \"wf_graph G \\<Longrightarrow> wf_graph (generate_valid_topology M G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> wf_graph (generate_valid_topology M G)", "proof(induction M arbitrary: G)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>G.\n       wf_graph G \\<Longrightarrow> wf_graph (generate_valid_topology [] G)\n 2. \\<And>a M G.\n       \\<lbrakk>\\<And>G.\n                   wf_graph G \\<Longrightarrow>\n                   wf_graph (generate_valid_topology M G);\n        wf_graph G\\<rbrakk>\n       \\<Longrightarrow> wf_graph (generate_valid_topology (a # M) G)", "qed(simp_all)"], ["", "lemma generate_valid_topology_mono_models:\n      \"edges (generate_valid_topology (m#M) \\<lparr> nodes = V, edges = E \\<rparr>) \\<subseteq> edges (generate_valid_topology M \\<lparr> nodes = V, edges = E \\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges\n     (generate_valid_topology (m # M) \\<lparr>nodes = V, edges = E\\<rparr>)\n    \\<subseteq> edges\n                 (generate_valid_topology M\n                   \\<lparr>nodes = V, edges = E\\<rparr>)", "proof(induction M arbitrary: E m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>E m.\n       edges\n        (generate_valid_topology [m] \\<lparr>nodes = V, edges = E\\<rparr>)\n       \\<subseteq> edges\n                    (generate_valid_topology []\n                      \\<lparr>nodes = V, edges = E\\<rparr>)\n 2. \\<And>a M E m.\n       (\\<And>E m.\n           edges\n            (generate_valid_topology (m # M)\n              \\<lparr>nodes = V, edges = E\\<rparr>)\n           \\<subseteq> edges\n                        (generate_valid_topology M\n                          \\<lparr>nodes = V,\n                             edges = E\\<rparr>)) \\<Longrightarrow>\n       edges\n        (generate_valid_topology (m # a # M)\n          \\<lparr>nodes = V, edges = E\\<rparr>)\n       \\<subseteq> edges\n                    (generate_valid_topology (a # M)\n                      \\<lparr>nodes = V, edges = E\\<rparr>)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>E m.\n       edges\n        (generate_valid_topology [m] \\<lparr>nodes = V, edges = E\\<rparr>)\n       \\<subseteq> edges\n                    (generate_valid_topology []\n                      \\<lparr>nodes = V, edges = E\\<rparr>)\n 2. \\<And>a M E m.\n       (\\<And>E m.\n           edges\n            (generate_valid_topology (m # M)\n              \\<lparr>nodes = V, edges = E\\<rparr>)\n           \\<subseteq> edges\n                        (generate_valid_topology M\n                          \\<lparr>nodes = V,\n                             edges = E\\<rparr>)) \\<Longrightarrow>\n       edges\n        (generate_valid_topology (m # a # M)\n          \\<lparr>nodes = V, edges = E\\<rparr>)\n       \\<subseteq> edges\n                    (generate_valid_topology (a # M)\n                      \\<lparr>nodes = V, edges = E\\<rparr>)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. edges (generate_valid_topology [m] \\<lparr>nodes = V, edges = E\\<rparr>)\n    \\<subseteq> edges\n                 (generate_valid_topology []\n                   \\<lparr>nodes = V, edges = E\\<rparr>)", "by(simp add: delete_edges_simp2)"], ["proof (state)\nthis:\n  edges (generate_valid_topology [m] \\<lparr>nodes = V, edges = E\\<rparr>)\n  \\<subseteq> edges\n               (generate_valid_topology []\n                 \\<lparr>nodes = V, edges = E\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>a M E m.\n       (\\<And>E m.\n           edges\n            (generate_valid_topology (m # M)\n              \\<lparr>nodes = V, edges = E\\<rparr>)\n           \\<subseteq> edges\n                        (generate_valid_topology M\n                          \\<lparr>nodes = V,\n                             edges = E\\<rparr>)) \\<Longrightarrow>\n       edges\n        (generate_valid_topology (m # a # M)\n          \\<lparr>nodes = V, edges = E\\<rparr>)\n       \\<subseteq> edges\n                    (generate_valid_topology (a # M)\n                      \\<lparr>nodes = V, edges = E\\<rparr>)", "case Cons"], ["proof (state)\nthis:\n  edges\n   (generate_valid_topology (?m # M_) \\<lparr>nodes = V, edges = ?E\\<rparr>)\n  \\<subseteq> edges\n               (generate_valid_topology M_\n                 \\<lparr>nodes = V, edges = ?E\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>a M E m.\n       (\\<And>E m.\n           edges\n            (generate_valid_topology (m # M)\n              \\<lparr>nodes = V, edges = E\\<rparr>)\n           \\<subseteq> edges\n                        (generate_valid_topology M\n                          \\<lparr>nodes = V,\n                             edges = E\\<rparr>)) \\<Longrightarrow>\n       edges\n        (generate_valid_topology (m # a # M)\n          \\<lparr>nodes = V, edges = E\\<rparr>)\n       \\<subseteq> edges\n                    (generate_valid_topology (a # M)\n                      \\<lparr>nodes = V, edges = E\\<rparr>)", "thus ?case"], ["proof (prove)\nusing this:\n  edges\n   (generate_valid_topology (?m # M_) \\<lparr>nodes = V, edges = ?E\\<rparr>)\n  \\<subseteq> edges\n               (generate_valid_topology M_\n                 \\<lparr>nodes = V, edges = ?E\\<rparr>)\n\ngoal (1 subgoal):\n 1. edges\n     (generate_valid_topology (m # a_ # M_)\n       \\<lparr>nodes = V, edges = E\\<rparr>)\n    \\<subseteq> edges\n                 (generate_valid_topology (a_ # M_)\n                   \\<lparr>nodes = V, edges = E\\<rparr>)", "by(simp add: delete_edges_simp2)"], ["proof (state)\nthis:\n  edges\n   (generate_valid_topology (m # a_ # M_)\n     \\<lparr>nodes = V, edges = E\\<rparr>)\n  \\<subseteq> edges\n               (generate_valid_topology (a_ # M_)\n                 \\<lparr>nodes = V, edges = E\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma generate_valid_topology_subseteq_edges:\n      \"edges (generate_valid_topology M G) \\<subseteq> (edges G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges (generate_valid_topology M G) \\<subseteq> edges G", "proof(induction M arbitrary: G)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>G. edges (generate_valid_topology [] G) \\<subseteq> edges G\n 2. \\<And>a M G.\n       (\\<And>G.\n           edges (generate_valid_topology M G)\n           \\<subseteq> edges G) \\<Longrightarrow>\n       edges (generate_valid_topology (a # M) G) \\<subseteq> edges G", "case Cons"], ["proof (state)\nthis:\n  edges (generate_valid_topology M_ ?G) \\<subseteq> edges ?G\n\ngoal (2 subgoals):\n 1. \\<And>G. edges (generate_valid_topology [] G) \\<subseteq> edges G\n 2. \\<And>a M G.\n       (\\<And>G.\n           edges (generate_valid_topology M G)\n           \\<subseteq> edges G) \\<Longrightarrow>\n       edges (generate_valid_topology (a # M) G) \\<subseteq> edges G", "thus ?case"], ["proof (prove)\nusing this:\n  edges (generate_valid_topology M_ ?G) \\<subseteq> edges ?G\n\ngoal (1 subgoal):\n 1. edges (generate_valid_topology (a_ # M_) G) \\<subseteq> edges G", "by (simp add: delete_edges_simp2) blast"], ["proof (state)\nthis:\n  edges (generate_valid_topology (a_ # M_) G) \\<subseteq> edges G\n\ngoal (1 subgoal):\n 1. \\<And>G. edges (generate_valid_topology [] G) \\<subseteq> edges G", "qed(simp)"], ["", "text\\<open>@{term generate_valid_topology} generates a valid topology (Policy)!\\<close>"], ["", "theorem generate_valid_topology_sound:\n      \"\\<lbrakk> valid_reqs M; wf_graph \\<lparr>nodes = V, edges = E\\<rparr> \\<rbrakk> \\<Longrightarrow> \n      all_security_requirements_fulfilled M (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M;\n     wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> all_security_requirements_fulfilled M\n                       (generate_valid_topology M\n                         \\<lparr>nodes = V, edges = E\\<rparr>)", "proof(induction M arbitrary: V E)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>V E.\n       \\<lbrakk>valid_reqs [];\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled []\n                          (generate_valid_topology []\n                            \\<lparr>nodes = V, edges = E\\<rparr>)\n 2. \\<And>a M V E.\n       \\<lbrakk>\\<And>V E.\n                   \\<lbrakk>valid_reqs M;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> all_security_requirements_fulfilled M\n(generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "case Nil"], ["proof (state)\nthis:\n  valid_reqs []\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<And>V E.\n       \\<lbrakk>valid_reqs [];\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled []\n                          (generate_valid_topology []\n                            \\<lparr>nodes = V, edges = E\\<rparr>)\n 2. \\<And>a M V E.\n       \\<lbrakk>\\<And>V E.\n                   \\<lbrakk>valid_reqs M;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> all_security_requirements_fulfilled M\n(generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "thus ?case"], ["proof (prove)\nusing this:\n  valid_reqs []\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled []\n     (generate_valid_topology [] \\<lparr>nodes = V, edges = E\\<rparr>)", "by(simp add: all_security_requirements_fulfilled_def)"], ["proof (state)\nthis:\n  all_security_requirements_fulfilled []\n   (generate_valid_topology [] \\<lparr>nodes = V, edges = E\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>a M V E.\n       \\<lbrakk>\\<And>V E.\n                   \\<lbrakk>valid_reqs M;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> all_security_requirements_fulfilled M\n(generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a M V E.\n       \\<lbrakk>\\<And>V E.\n                   \\<lbrakk>valid_reqs M;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> all_security_requirements_fulfilled M\n(generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "case (Cons m M)"], ["proof (state)\nthis:\n  \\<lbrakk>valid_reqs M;\n   wf_graph \\<lparr>nodes = ?V, edges = ?E\\<rparr>\\<rbrakk>\n  \\<Longrightarrow> all_security_requirements_fulfilled M\n                     (generate_valid_topology M\n                       \\<lparr>nodes = ?V, edges = ?E\\<rparr>)\n  valid_reqs (m # M)\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a M V E.\n       \\<lbrakk>\\<And>V E.\n                   \\<lbrakk>valid_reqs M;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> all_security_requirements_fulfilled M\n(generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from valid_reqs1[OF Cons(2)]"], ["proof (chain)\npicking this:\n  configured_SecurityInvariant m", "have validReq: \"configured_SecurityInvariant m\""], ["proof (prove)\nusing this:\n  configured_SecurityInvariant m\n\ngoal (1 subgoal):\n 1. configured_SecurityInvariant m", "."], ["proof (state)\nthis:\n  configured_SecurityInvariant m\n\ngoal (1 subgoal):\n 1. \\<And>a M V E.\n       \\<lbrakk>\\<And>V E.\n                   \\<lbrakk>valid_reqs M;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> all_security_requirements_fulfilled M\n(generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from Cons(3)"], ["proof (chain)\npicking this:\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>", "have valid_rmUnOff: \"wf_graph \\<lparr>nodes = V, edges = E - \\<Union>(c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>) \\<rparr>\""], ["proof (prove)\nusing this:\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n\ngoal (1 subgoal):\n 1. wf_graph\n     \\<lparr>nodes = V,\n        edges =\n          E -\n          \\<Union>\n           (c_offending_flows m\n             \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>", "by(simp add: wf_graph_remove_edges)"], ["proof (state)\nthis:\n  wf_graph\n   \\<lparr>nodes = V,\n      edges =\n        E -\n        \\<Union>\n         (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a M V E.\n       \\<lbrakk>\\<And>V E.\n                   \\<lbrakk>valid_reqs M;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> all_security_requirements_fulfilled M\n(generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from configured_SecurityInvariant.sinvar_valid_remove_flattened_offending_flows[OF validReq Cons(3)]"], ["proof (chain)\npicking this:\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        E -\n        \\<Union>\n         (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>", "have valid_eval_rmUnOff: \"c_sinvar m \\<lparr>nodes = V, edges = E - \\<Union>(c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>) \\<rparr>\""], ["proof (prove)\nusing this:\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        E -\n        \\<Union>\n         (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n\ngoal (1 subgoal):\n 1. c_sinvar m\n     \\<lparr>nodes = V,\n        edges =\n          E -\n          \\<Union>\n           (c_offending_flows m\n             \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>", "."], ["proof (state)\nthis:\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        E -\n        \\<Union>\n         (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a M V E.\n       \\<lbrakk>\\<And>V E.\n                   \\<lbrakk>valid_reqs M;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> all_security_requirements_fulfilled M\n(generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from generate_valid_topology_subseteq_edges"], ["proof (chain)\npicking this:\n  edges (generate_valid_topology ?M ?G) \\<subseteq> edges ?G", "have edges_gentopo_subseteq: \n            \"edges (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>) - \\<Union>(c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\n               \\<subseteq>\n            E - \\<Union>(c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\""], ["proof (prove)\nusing this:\n  edges (generate_valid_topology ?M ?G) \\<subseteq> edges ?G\n\ngoal (1 subgoal):\n 1. edges (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>) -\n    \\<Union> (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\n    \\<subseteq> E -\n                \\<Union>\n                 (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)", "by fastforce"], ["proof (state)\nthis:\n  edges (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>) -\n  \\<Union> (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\n  \\<subseteq> E -\n              \\<Union>\n               (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>a M V E.\n       \\<lbrakk>\\<And>V E.\n                   \\<lbrakk>valid_reqs M;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> all_security_requirements_fulfilled M\n(generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from configured_SecurityInvariant.mono_sinvar[OF validReq valid_rmUnOff edges_gentopo_subseteq valid_eval_rmUnOff]"], ["proof (chain)\npicking this:\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        edges\n         (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>) -\n        \\<Union>\n         (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>", "have \"c_sinvar m \\<lparr>nodes = V, edges = (edges (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>)) - \\<Union>(c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>) \\<rparr>\""], ["proof (prove)\nusing this:\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        edges\n         (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>) -\n        \\<Union>\n         (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n\ngoal (1 subgoal):\n 1. c_sinvar m\n     \\<lparr>nodes = V,\n        edges =\n          edges\n           (generate_valid_topology M\n             \\<lparr>nodes = V, edges = E\\<rparr>) -\n          \\<Union>\n           (c_offending_flows m\n             \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>", "."], ["proof (state)\nthis:\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        edges\n         (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>) -\n        \\<Union>\n         (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a M V E.\n       \\<lbrakk>\\<And>V E.\n                   \\<lbrakk>valid_reqs M;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> all_security_requirements_fulfilled M\n(generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from this"], ["proof (chain)\npicking this:\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        edges\n         (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>) -\n        \\<Union>\n         (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>", "have goal1: \n            \"c_sinvar m (delete_edges (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>) (\\<Union>(c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)))\""], ["proof (prove)\nusing this:\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        edges\n         (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>) -\n        \\<Union>\n         (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n\ngoal (1 subgoal):\n 1. c_sinvar m\n     (delete_edges\n       (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>)\n       (\\<Union>\n         (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)))", "by(simp add: delete_edges_simp2 generate_valid_topology_nodes)"], ["proof (state)\nthis:\n  c_sinvar m\n   (delete_edges\n     (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>)\n     (\\<Union> (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)))\n\ngoal (1 subgoal):\n 1. \\<And>a M V E.\n       \\<lbrakk>\\<And>V E.\n                   \\<lbrakk>valid_reqs M;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> all_security_requirements_fulfilled M\n(generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from valid_reqs2[OF Cons(2)]"], ["proof (chain)\npicking this:\n  valid_reqs M", "have \"valid_reqs M\""], ["proof (prove)\nusing this:\n  valid_reqs M\n\ngoal (1 subgoal):\n 1. valid_reqs M", "."], ["proof (state)\nthis:\n  valid_reqs M\n\ngoal (1 subgoal):\n 1. \\<And>a M V E.\n       \\<lbrakk>\\<And>V E.\n                   \\<lbrakk>valid_reqs M;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> all_security_requirements_fulfilled M\n(generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from Cons.IH[OF \\<open>valid_reqs M\\<close> Cons(3)]"], ["proof (chain)\npicking this:\n  all_security_requirements_fulfilled M\n   (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>)", "have IH:\n            \"all_security_requirements_fulfilled M (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>)\""], ["proof (prove)\nusing this:\n  all_security_requirements_fulfilled M\n   (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>)\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled M\n     (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>)", "."], ["proof (state)\nthis:\n  all_security_requirements_fulfilled M\n   (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>a M V E.\n       \\<lbrakk>\\<And>V E.\n                   \\<lbrakk>valid_reqs M;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> all_security_requirements_fulfilled M\n(generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "have generate_valid_topology_EX_graph_record:\n            \"\\<exists> hypE. (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>) = \\<lparr>nodes = V, edges = hypE\\<rparr> \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>hypE.\n       generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr> =\n       \\<lparr>nodes = V, edges = hypE\\<rparr>", "apply(induction M arbitrary: V E)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>V E.\n       \\<exists>hypE.\n          generate_valid_topology [] \\<lparr>nodes = V, edges = E\\<rparr> =\n          \\<lparr>nodes = V, edges = hypE\\<rparr>\n 2. \\<And>a M V E.\n       (\\<And>V E.\n           \\<exists>hypE.\n              generate_valid_topology M\n               \\<lparr>nodes = V, edges = E\\<rparr> =\n              \\<lparr>nodes = V, edges = hypE\\<rparr>) \\<Longrightarrow>\n       \\<exists>hypE.\n          generate_valid_topology (a # M)\n           \\<lparr>nodes = V, edges = E\\<rparr> =\n          \\<lparr>nodes = V, edges = hypE\\<rparr>", "by(simp_all add: delete_edges_simp2 generate_valid_topology_nodes)"], ["proof (state)\nthis:\n  \\<exists>hypE.\n     generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr> =\n     \\<lparr>nodes = V, edges = hypE\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a M V E.\n       \\<lbrakk>\\<And>V E.\n                   \\<lbrakk>valid_reqs M;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> all_security_requirements_fulfilled M\n(generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from generate_valid_topology_EX_graph_record"], ["proof (chain)\npicking this:\n  \\<exists>hypE.\n     generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr> =\n     \\<lparr>nodes = V, edges = hypE\\<rparr>", "obtain E_IH where  E_IH_prop:\n            \"(generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>) = \\<lparr>nodes = V, edges = E_IH\\<rparr>\""], ["proof (prove)\nusing this:\n  \\<exists>hypE.\n     generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr> =\n     \\<lparr>nodes = V, edges = hypE\\<rparr>\n\ngoal (1 subgoal):\n 1. (\\<And>E_IH.\n        generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr> =\n        \\<lparr>nodes = V, edges = E_IH\\<rparr> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr> =\n  \\<lparr>nodes = V, edges = E_IH\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a M V E.\n       \\<lbrakk>\\<And>V E.\n                   \\<lbrakk>valid_reqs M;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> all_security_requirements_fulfilled M\n(generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from wf_graph_generate_valid_topology[OF Cons(3)] E_IH_prop"], ["proof (chain)\npicking this:\n  wf_graph (generate_valid_topology ?M \\<lparr>nodes = V, edges = E\\<rparr>)\n  generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr> =\n  \\<lparr>nodes = V, edges = E_IH\\<rparr>", "have valid_G_E_IH: \"wf_graph \\<lparr>nodes = V, edges = E_IH\\<rparr>\""], ["proof (prove)\nusing this:\n  wf_graph (generate_valid_topology ?M \\<lparr>nodes = V, edges = E\\<rparr>)\n  generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr> =\n  \\<lparr>nodes = V, edges = E_IH\\<rparr>\n\ngoal (1 subgoal):\n 1. wf_graph \\<lparr>nodes = V, edges = E_IH\\<rparr>", "by metis\n    \n          \\<comment> \\<open>@{thm IH[simplified E_IH_prop]}\\<close>\n          \\<comment> \\<open>@{thm all_security_requirements_fulfilled_mono[OF `valid_reqs M` _  valid_G_E_IH IH[simplified E_IH_prop]]}\\<close>"], ["proof (state)\nthis:\n  wf_graph \\<lparr>nodes = V, edges = E_IH\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a M V E.\n       \\<lbrakk>\\<And>V E.\n                   \\<lbrakk>valid_reqs M;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> all_security_requirements_fulfilled M\n(generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from all_security_requirements_fulfilled_mono[OF \\<open>valid_reqs M\\<close> _  valid_G_E_IH IH[simplified E_IH_prop]]"], ["proof (chain)\npicking this:\n  ?E' \\<subseteq> E_IH \\<Longrightarrow>\n  all_security_requirements_fulfilled M\n   \\<lparr>nodes = V, edges = ?E'\\<rparr>", "have mono_rule:\n            \"\\<And> E'. E' \\<subseteq> E_IH \\<Longrightarrow> all_security_requirements_fulfilled M \\<lparr>nodes = V, edges = E'\\<rparr>\""], ["proof (prove)\nusing this:\n  ?E' \\<subseteq> E_IH \\<Longrightarrow>\n  all_security_requirements_fulfilled M\n   \\<lparr>nodes = V, edges = ?E'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>E'.\n       E' \\<subseteq> E_IH \\<Longrightarrow>\n       all_security_requirements_fulfilled M\n        \\<lparr>nodes = V, edges = E'\\<rparr>", "."], ["proof (state)\nthis:\n  ?E' \\<subseteq> E_IH \\<Longrightarrow>\n  all_security_requirements_fulfilled M\n   \\<lparr>nodes = V, edges = ?E'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a M V E.\n       \\<lbrakk>\\<And>V E.\n                   \\<lbrakk>valid_reqs M;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> all_security_requirements_fulfilled M\n(generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "have \"all_security_requirements_fulfilled M \n            (delete_edges (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>) (\\<Union>(c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled M\n     (delete_edges\n       (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>)\n       (\\<Union>\n         (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)))", "apply(subst E_IH_prop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled M\n     (delete_edges \\<lparr>nodes = V, edges = E_IH\\<rparr>\n       (\\<Union>\n         (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)))", "apply(simp add: delete_edges_simp2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled M\n     \\<lparr>nodes = V,\n        edges =\n          E_IH -\n          \\<Union>\n           (c_offending_flows m\n             \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>", "apply(rule mono_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. E_IH -\n    \\<Union> (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\n    \\<subseteq> E_IH", "by fast"], ["proof (state)\nthis:\n  all_security_requirements_fulfilled M\n   (delete_edges\n     (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>)\n     (\\<Union> (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)))\n\ngoal (1 subgoal):\n 1. \\<And>a M V E.\n       \\<lbrakk>\\<And>V E.\n                   \\<lbrakk>valid_reqs M;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> all_security_requirements_fulfilled M\n(generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from this"], ["proof (chain)\npicking this:\n  all_security_requirements_fulfilled M\n   (delete_edges\n     (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>)\n     (\\<Union> (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)))", "have goal2:\n            \"(\\<forall>ma\\<in>set M.\n            c_sinvar ma (delete_edges (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>) (\\<Union>(c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>))))\""], ["proof (prove)\nusing this:\n  all_security_requirements_fulfilled M\n   (delete_edges\n     (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>)\n     (\\<Union> (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)))\n\ngoal (1 subgoal):\n 1. \\<forall>ma\\<in>set M.\n       c_sinvar ma\n        (delete_edges\n          (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>)\n          (\\<Union>\n            (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)))", "by(simp add: all_security_requirements_fulfilled_def)"], ["proof (state)\nthis:\n  \\<forall>ma\\<in>set M.\n     c_sinvar ma\n      (delete_edges\n        (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>)\n        (\\<Union>\n          (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)))\n\ngoal (1 subgoal):\n 1. \\<And>a M V E.\n       \\<lbrakk>\\<And>V E.\n                   \\<lbrakk>valid_reqs M;\n                    wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> all_security_requirements_fulfilled M\n(generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from goal1 goal2"], ["proof (chain)\npicking this:\n  c_sinvar m\n   (delete_edges\n     (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>)\n     (\\<Union> (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)))\n  \\<forall>ma\\<in>set M.\n     c_sinvar ma\n      (delete_edges\n        (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>)\n        (\\<Union>\n          (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)))", "show  \"all_security_requirements_fulfilled (m # M) (generate_valid_topology (m # M) \\<lparr>nodes = V, edges = E\\<rparr>)\""], ["proof (prove)\nusing this:\n  c_sinvar m\n   (delete_edges\n     (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>)\n     (\\<Union> (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)))\n  \\<forall>ma\\<in>set M.\n     c_sinvar ma\n      (delete_edges\n        (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>)\n        (\\<Union>\n          (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)))\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled (m # M)\n     (generate_valid_topology (m # M) \\<lparr>nodes = V, edges = E\\<rparr>)", "by (simp add: all_security_requirements_fulfilled_def)"], ["proof (state)\nthis:\n  all_security_requirements_fulfilled (m # M)\n   (generate_valid_topology (m # M) \\<lparr>nodes = V, edges = E\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma generate_valid_topology_as_set: \n  \"generate_valid_topology M G = delete_edges G (\\<Union>m \\<in> set M. (\\<Union> (c_offending_flows m G)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate_valid_topology M G =\n    delete_edges G (\\<Union>m\\<in>set M. \\<Union> (c_offending_flows m G))", "apply(induction M arbitrary: G)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>G.\n       generate_valid_topology [] G =\n       delete_edges G\n        (\\<Union>m\\<in>set []. \\<Union> (c_offending_flows m G))\n 2. \\<And>a M G.\n       (\\<And>G.\n           generate_valid_topology M G =\n           delete_edges G\n            (\\<Union>m\\<in>set M.\n                \\<Union> (c_offending_flows m G))) \\<Longrightarrow>\n       generate_valid_topology (a # M) G =\n       delete_edges G\n        (\\<Union>m\\<in>set (a # M). \\<Union> (c_offending_flows m G))", "apply(simp_all add: delete_edges_simp2 generate_valid_topology_nodes)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M G.\n       (\\<And>G.\n           generate_valid_topology M G =\n           \\<lparr>nodes = nodes G,\n              edges =\n                edges G -\n                (\\<Union>m\\<in>set M.\n                    \\<Union>\n                     (c_offending_flows m G))\\<rparr>) \\<Longrightarrow>\n       edges G - (\\<Union>m\\<in>set M. \\<Union> (c_offending_flows m G)) -\n       \\<Union> (c_offending_flows a G) =\n       edges G -\n       (\\<Union> (c_offending_flows a G) \\<union>\n        (\\<Union>x\\<in>set M. \\<Union> (c_offending_flows x G)))", "by fastforce"], ["", "lemma c_offending_flows_subseteq_edges: \"configured_SecurityInvariant m \\<Longrightarrow> \\<Union>(c_offending_flows m G) \\<subseteq> edges G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. configured_SecurityInvariant m \\<Longrightarrow>\n    \\<Union> (c_offending_flows m G) \\<subseteq> edges G", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b X.\n       \\<lbrakk>configured_SecurityInvariant m; (a, b) \\<in> X;\n        X \\<in> c_offending_flows m G\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> edges G", "apply(simp only: configured_SecurityInvariant.valid_c_offending_flows)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b X.\n       \\<lbrakk>configured_SecurityInvariant m; (a, b) \\<in> X;\n        X \\<in> {F. F \\<subseteq> edges G \\<and>\n                    \\<not> c_sinvar m G \\<and>\n                    c_sinvar m (delete_edges G F) \\<and>\n                    (\\<forall>(e1, e2)\\<in>F.\n                        \\<not> c_sinvar m\n                                (add_edge e1 e2\n                                  (delete_edges G F)))}\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> edges G", "apply(thin_tac \"configured_SecurityInvariant x\" for x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b X.\n       \\<lbrakk>(a, b) \\<in> X;\n        X \\<in> {F. F \\<subseteq> edges G \\<and>\n                    \\<not> c_sinvar m G \\<and>\n                    c_sinvar m (delete_edges G F) \\<and>\n                    (\\<forall>(e1, e2)\\<in>F.\n                        \\<not> c_sinvar m\n                                (add_edge e1 e2\n                                  (delete_edges G F)))}\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> edges G", "by auto"], ["", "text\\<open>Does it also generate a maximum topology? It does, if the security invariants are in ENF-form. That means, if \n        all security invariants can be expressed as a predicate over the edges, \n        @{term \"\\<exists>P. \\<forall>G. c_sinvar m G = (\\<forall>(v1,v2) \\<in> edges G. P (v1,v2))\"}\\<close>"], ["", "definition max_topo :: \"('v::vertex) SecurityInvariant_configured list \\<Rightarrow> 'v graph \\<Rightarrow> bool\" where\n    \"max_topo M G \\<equiv> all_security_requirements_fulfilled M G \\<and> (\n      \\<forall> (v1, v2) \\<in> (nodes G \\<times> nodes G) - (edges G). \\<not> all_security_requirements_fulfilled M (add_edge v1 v2 G))\""], ["", "lemma unique_offending_obtain: \n    assumes m: \"configured_SecurityInvariant m\" and unique: \"c_offending_flows m G = {F}\"\n    obtains P where \"F = {(v1, v2) \\<in> edges G. \\<not> P (v1, v2)}\" and \"c_sinvar m G = (\\<forall>(v1,v2) \\<in> edges G. P (v1, v2))\" and \n                    \"(\\<forall>(v1,v2) \\<in> edges G - F. P (v1, v2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>F =\n                 {(v1, v2).\n                  (v1, v2) \\<in> edges G \\<and> \\<not> P (v1, v2)};\n         c_sinvar m G = (\\<forall>(v1, v2)\\<in>edges G. P (v1, v2));\n         \\<forall>(v1, v2)\\<in>edges G - F. P (v1, v2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>F =\n                 {(v1, v2).\n                  (v1, v2) \\<in> edges G \\<and> \\<not> P (v1, v2)};\n         c_sinvar m G = (\\<forall>(v1, v2)\\<in>edges G. P (v1, v2));\n         \\<forall>(v1, v2)\\<in>edges G - F. P (v1, v2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume EX: \"(\\<And>P. F = {(v1, v2). (v1, v2) \\<in> edges G \\<and> \\<not> P (v1, v2)} \\<Longrightarrow> c_sinvar m G = (\\<forall>(v1, v2)\\<in>edges G. P (v1, v2)) \\<Longrightarrow> \\<forall>(v1, v2)\\<in>edges G - F. P (v1, v2) \\<Longrightarrow> thesis)\""], ["proof (state)\nthis:\n  \\<lbrakk>F = {(v1, v2). (v1, v2) \\<in> edges G \\<and> \\<not> ?P (v1, v2)};\n   c_sinvar m G = (\\<forall>(v1, v2)\\<in>edges G. ?P (v1, v2));\n   \\<forall>(v1, v2)\\<in>edges G - F. ?P (v1, v2)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>F =\n                 {(v1, v2).\n                  (v1, v2) \\<in> edges G \\<and> \\<not> P (v1, v2)};\n         c_sinvar m G = (\\<forall>(v1, v2)\\<in>edges G. P (v1, v2));\n         \\<forall>(v1, v2)\\<in>edges G - F. P (v1, v2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from unique c_offending_flows_subseteq_edges[OF m]"], ["proof (chain)\npicking this:\n  c_offending_flows m G = {F}\n  \\<Union> (c_offending_flows m ?G) \\<subseteq> edges ?G", "have \"F \\<subseteq> edges G\""], ["proof (prove)\nusing this:\n  c_offending_flows m G = {F}\n  \\<Union> (c_offending_flows m ?G) \\<subseteq> edges ?G\n\ngoal (1 subgoal):\n 1. F \\<subseteq> edges G", "by force"], ["proof (state)\nthis:\n  F \\<subseteq> edges G\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>F =\n                 {(v1, v2).\n                  (v1, v2) \\<in> edges G \\<and> \\<not> P (v1, v2)};\n         c_sinvar m G = (\\<forall>(v1, v2)\\<in>edges G. P (v1, v2));\n         \\<forall>(v1, v2)\\<in>edges G - F. P (v1, v2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this"], ["proof (chain)\npicking this:\n  F \\<subseteq> edges G", "obtain P where \"F = {e \\<in> edges G. \\<not> P e}\""], ["proof (prove)\nusing this:\n  F \\<subseteq> edges G\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        F = {e \\<in> edges G. \\<not> P e} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis double_diff set_diff_eq subset_refl)"], ["proof (state)\nthis:\n  F = {e \\<in> edges G. \\<not> P e}\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>F =\n                 {(v1, v2).\n                  (v1, v2) \\<in> edges G \\<and> \\<not> P (v1, v2)};\n         c_sinvar m G = (\\<forall>(v1, v2)\\<in>edges G. P (v1, v2));\n         \\<forall>(v1, v2)\\<in>edges G - F. P (v1, v2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence 1: \"F = {(v1, v2) \\<in> edges G. \\<not> P (v1, v2)}\""], ["proof (prove)\nusing this:\n  F = {e \\<in> edges G. \\<not> P e}\n\ngoal (1 subgoal):\n 1. F = {(v1, v2). (v1, v2) \\<in> edges G \\<and> \\<not> P (v1, v2)}", "by auto"], ["proof (state)\nthis:\n  F = {(v1, v2). (v1, v2) \\<in> edges G \\<and> \\<not> P (v1, v2)}\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>F =\n                 {(v1, v2).\n                  (v1, v2) \\<in> edges G \\<and> \\<not> P (v1, v2)};\n         c_sinvar m G = (\\<forall>(v1, v2)\\<in>edges G. P (v1, v2));\n         \\<forall>(v1, v2)\\<in>edges G - F. P (v1, v2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from configured_SecurityInvariant.valid_c_offending_flows[OF m]"], ["proof (chain)\npicking this:\n  c_offending_flows m ?G =\n  {F. F \\<subseteq> edges ?G \\<and>\n      \\<not> c_sinvar m ?G \\<and>\n      c_sinvar m (delete_edges ?G F) \\<and>\n      (\\<forall>(e1, e2)\\<in>F.\n          \\<not> c_sinvar m (add_edge e1 e2 (delete_edges ?G F)))}", "have \"c_offending_flows m G =\n          {F. F \\<subseteq> edges G \\<and> \\<not> c_sinvar m G \\<and> c_sinvar m (delete_edges G F) \\<and> \n              (\\<forall>(e1, e2)\\<in>F. \\<not> c_sinvar m (add_edge e1 e2 (delete_edges G F)))}\""], ["proof (prove)\nusing this:\n  c_offending_flows m ?G =\n  {F. F \\<subseteq> edges ?G \\<and>\n      \\<not> c_sinvar m ?G \\<and>\n      c_sinvar m (delete_edges ?G F) \\<and>\n      (\\<forall>(e1, e2)\\<in>F.\n          \\<not> c_sinvar m (add_edge e1 e2 (delete_edges ?G F)))}\n\ngoal (1 subgoal):\n 1. c_offending_flows m G =\n    {F. F \\<subseteq> edges G \\<and>\n        \\<not> c_sinvar m G \\<and>\n        c_sinvar m (delete_edges G F) \\<and>\n        (\\<forall>(e1, e2)\\<in>F.\n            \\<not> c_sinvar m (add_edge e1 e2 (delete_edges G F)))}", "."], ["proof (state)\nthis:\n  c_offending_flows m G =\n  {F. F \\<subseteq> edges G \\<and>\n      \\<not> c_sinvar m G \\<and>\n      c_sinvar m (delete_edges G F) \\<and>\n      (\\<forall>(e1, e2)\\<in>F.\n          \\<not> c_sinvar m (add_edge e1 e2 (delete_edges G F)))}\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>F =\n                 {(v1, v2).\n                  (v1, v2) \\<in> edges G \\<and> \\<not> P (v1, v2)};\n         c_sinvar m G = (\\<forall>(v1, v2)\\<in>edges G. P (v1, v2));\n         \\<forall>(v1, v2)\\<in>edges G - F. P (v1, v2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this unique"], ["proof (chain)\npicking this:\n  c_offending_flows m G =\n  {F. F \\<subseteq> edges G \\<and>\n      \\<not> c_sinvar m G \\<and>\n      c_sinvar m (delete_edges G F) \\<and>\n      (\\<forall>(e1, e2)\\<in>F.\n          \\<not> c_sinvar m (add_edge e1 e2 (delete_edges G F)))}\n  c_offending_flows m G = {F}", "have \"\\<not> c_sinvar m G\" and 2: \"c_sinvar m (delete_edges G F)\" and \n                          3: \"(\\<forall>(e1, e2)\\<in>F. \\<not> c_sinvar m (add_edge e1 e2 (delete_edges G F)))\""], ["proof (prove)\nusing this:\n  c_offending_flows m G =\n  {F. F \\<subseteq> edges G \\<and>\n      \\<not> c_sinvar m G \\<and>\n      c_sinvar m (delete_edges G F) \\<and>\n      (\\<forall>(e1, e2)\\<in>F.\n          \\<not> c_sinvar m (add_edge e1 e2 (delete_edges G F)))}\n  c_offending_flows m G = {F}\n\ngoal (1 subgoal):\n 1. \\<not> c_sinvar m G &&&\n    c_sinvar m (delete_edges G F) &&&\n    \\<forall>(e1, e2)\\<in>F.\n       \\<not> c_sinvar m (add_edge e1 e2 (delete_edges G F))", "by auto"], ["proof (state)\nthis:\n  \\<not> c_sinvar m G\n  c_sinvar m (delete_edges G F)\n  \\<forall>(e1, e2)\\<in>F.\n     \\<not> c_sinvar m (add_edge e1 e2 (delete_edges G F))\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>F =\n                 {(v1, v2).\n                  (v1, v2) \\<in> edges G \\<and> \\<not> P (v1, v2)};\n         c_sinvar m G = (\\<forall>(v1, v2)\\<in>edges G. P (v1, v2));\n         \\<forall>(v1, v2)\\<in>edges G - F. P (v1, v2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this \\<open>F = {e \\<in> edges G. \\<not> P e}\\<close>"], ["proof (chain)\npicking this:\n  \\<not> c_sinvar m G\n  c_sinvar m (delete_edges G F)\n  \\<forall>(e1, e2)\\<in>F.\n     \\<not> c_sinvar m (add_edge e1 e2 (delete_edges G F))\n  F = {e \\<in> edges G. \\<not> P e}", "have x3: \"\\<forall> e \\<in> edges G - F. P e\""], ["proof (prove)\nusing this:\n  \\<not> c_sinvar m G\n  c_sinvar m (delete_edges G F)\n  \\<forall>(e1, e2)\\<in>F.\n     \\<not> c_sinvar m (add_edge e1 e2 (delete_edges G F))\n  F = {e \\<in> edges G. \\<not> P e}\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>edges G - F. P e", "by (metis (lifting) mem_Collect_eq set_diff_eq)"], ["proof (state)\nthis:\n  \\<forall>e\\<in>edges G - F. P e\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>F =\n                 {(v1, v2).\n                  (v1, v2) \\<in> edges G \\<and> \\<not> P (v1, v2)};\n         c_sinvar m G = (\\<forall>(v1, v2)\\<in>edges G. P (v1, v2));\n         \\<forall>(v1, v2)\\<in>edges G - F. P (v1, v2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence 4: \"\\<forall>(v1,v2) \\<in> edges G - F. P (v1, v2)\""], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>edges G - F. P e\n\ngoal (1 subgoal):\n 1. \\<forall>(v1, v2)\\<in>edges G - F. P (v1, v2)", "by blast"], ["proof (state)\nthis:\n  \\<forall>(v1, v2)\\<in>edges G - F. P (v1, v2)\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>F =\n                 {(v1, v2).\n                  (v1, v2) \\<in> edges G \\<and> \\<not> P (v1, v2)};\n         c_sinvar m G = (\\<forall>(v1, v2)\\<in>edges G. P (v1, v2));\n         \\<forall>(v1, v2)\\<in>edges G - F. P (v1, v2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"F \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<noteq> {}", "by (metis assms(1) assms(2) configured_SecurityInvariant.empty_offending_contra insertCI)"], ["proof (state)\nthis:\n  F \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>F =\n                 {(v1, v2).\n                  (v1, v2) \\<in> edges G \\<and> \\<not> P (v1, v2)};\n         c_sinvar m G = (\\<forall>(v1, v2)\\<in>edges G. P (v1, v2));\n         \\<forall>(v1, v2)\\<in>edges G - F. P (v1, v2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this \\<open>F = {e \\<in> edges G. \\<not> P e}\\<close> \\<open>\\<not> c_sinvar m G\\<close>"], ["proof (chain)\npicking this:\n  F \\<noteq> {}\n  F = {e \\<in> edges G. \\<not> P e}\n  \\<not> c_sinvar m G", "have 5: \"c_sinvar m G = (\\<forall>(v1,v2) \\<in> edges G. P (v1, v2))\""], ["proof (prove)\nusing this:\n  F \\<noteq> {}\n  F = {e \\<in> edges G. \\<not> P e}\n  \\<not> c_sinvar m G\n\ngoal (1 subgoal):\n 1. c_sinvar m G = (\\<forall>(v1, v2)\\<in>edges G. P (v1, v2))", "apply(simp add: graph_ops)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>a b. (a, b) \\<in> edges G \\<and> \\<not> P (a, b);\n     F = {e \\<in> edges G. \\<not> P e}; \\<not> c_sinvar m G\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>edges G. \\<not> P x", "by(blast)"], ["proof (state)\nthis:\n  c_sinvar m G = (\\<forall>(v1, v2)\\<in>edges G. P (v1, v2))\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>F =\n                 {(v1, v2).\n                  (v1, v2) \\<in> edges G \\<and> \\<not> P (v1, v2)};\n         c_sinvar m G = (\\<forall>(v1, v2)\\<in>edges G. P (v1, v2));\n         \\<forall>(v1, v2)\\<in>edges G - F. P (v1, v2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from EX[of P] unique 1 x3 5"], ["proof (chain)\npicking this:\n  \\<lbrakk>F = {(v1, v2). (v1, v2) \\<in> edges G \\<and> \\<not> P (v1, v2)};\n   c_sinvar m G = (\\<forall>(v1, v2)\\<in>edges G. P (v1, v2));\n   \\<forall>(v1, v2)\\<in>edges G - F. P (v1, v2)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  c_offending_flows m G = {F}\n  F = {(v1, v2). (v1, v2) \\<in> edges G \\<and> \\<not> P (v1, v2)}\n  \\<forall>e\\<in>edges G - F. P e\n  c_sinvar m G = (\\<forall>(v1, v2)\\<in>edges G. P (v1, v2))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>F = {(v1, v2). (v1, v2) \\<in> edges G \\<and> \\<not> P (v1, v2)};\n   c_sinvar m G = (\\<forall>(v1, v2)\\<in>edges G. P (v1, v2));\n   \\<forall>(v1, v2)\\<in>edges G - F. P (v1, v2)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  c_offending_flows m G = {F}\n  F = {(v1, v2). (v1, v2) \\<in> edges G \\<and> \\<not> P (v1, v2)}\n  \\<forall>e\\<in>edges G - F. P e\n  c_sinvar m G = (\\<forall>(v1, v2)\\<in>edges G. P (v1, v2))\n\ngoal (1 subgoal):\n 1. thesis", "by fast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enf_offending_flows:\n    assumes vm: \"configured_SecurityInvariant m\" and enf: \"\\<forall>G. c_sinvar m G = (\\<forall>e \\<in> edges G. P e)\"\n    shows \"\\<forall>G. c_offending_flows m G = (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>G.\n       c_offending_flows m G =\n       (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>G.\n       c_offending_flows m G =\n       (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>G.\n       c_offending_flows m G =\n       (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})", "fix G"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>G.\n       c_offending_flows m G =\n       (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})", "from vm configured_SecurityInvariant.valid_c_offending_flows"], ["proof (chain)\npicking this:\n  configured_SecurityInvariant m\n  configured_SecurityInvariant ?m \\<Longrightarrow>\n  c_offending_flows ?m ?G =\n  {F. F \\<subseteq> edges ?G \\<and>\n      \\<not> c_sinvar ?m ?G \\<and>\n      c_sinvar ?m (delete_edges ?G F) \\<and>\n      (\\<forall>(e1, e2)\\<in>F.\n          \\<not> c_sinvar ?m (add_edge e1 e2 (delete_edges ?G F)))}", "have offending_formaldef:\n          \"c_offending_flows m G =\n            {F. F \\<subseteq> edges G \\<and> \\<not> c_sinvar m G \\<and> c_sinvar m (delete_edges G F) \\<and>\n                (\\<forall>(e1, e2)\\<in>F. \\<not> c_sinvar m (add_edge e1 e2 (delete_edges G F)))}\""], ["proof (prove)\nusing this:\n  configured_SecurityInvariant m\n  configured_SecurityInvariant ?m \\<Longrightarrow>\n  c_offending_flows ?m ?G =\n  {F. F \\<subseteq> edges ?G \\<and>\n      \\<not> c_sinvar ?m ?G \\<and>\n      c_sinvar ?m (delete_edges ?G F) \\<and>\n      (\\<forall>(e1, e2)\\<in>F.\n          \\<not> c_sinvar ?m (add_edge e1 e2 (delete_edges ?G F)))}\n\ngoal (1 subgoal):\n 1. c_offending_flows m G =\n    {F. F \\<subseteq> edges G \\<and>\n        \\<not> c_sinvar m G \\<and>\n        c_sinvar m (delete_edges G F) \\<and>\n        (\\<forall>(e1, e2)\\<in>F.\n            \\<not> c_sinvar m (add_edge e1 e2 (delete_edges G F)))}", "by auto"], ["proof (state)\nthis:\n  c_offending_flows m G =\n  {F. F \\<subseteq> edges G \\<and>\n      \\<not> c_sinvar m G \\<and>\n      c_sinvar m (delete_edges G F) \\<and>\n      (\\<forall>(e1, e2)\\<in>F.\n          \\<not> c_sinvar m (add_edge e1 e2 (delete_edges G F)))}\n\ngoal (1 subgoal):\n 1. \\<forall>G.\n       c_offending_flows m G =\n       (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})", "have \"c_offending_flows m G = (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_offending_flows m G =\n    (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})", "proof(cases \"c_sinvar m G\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c_sinvar m G \\<Longrightarrow>\n    c_offending_flows m G =\n    (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})\n 2. \\<not> c_sinvar m G \\<Longrightarrow>\n    c_offending_flows m G =\n    (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})", "case True"], ["proof (state)\nthis:\n  c_sinvar m G\n\ngoal (2 subgoals):\n 1. c_sinvar m G \\<Longrightarrow>\n    c_offending_flows m G =\n    (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})\n 2. \\<not> c_sinvar m G \\<Longrightarrow>\n    c_offending_flows m G =\n    (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})", "thus ?thesis \\<comment> \\<open>@{term \"{}\"}\\<close>"], ["proof (prove)\nusing this:\n  c_sinvar m G\n\ngoal (1 subgoal):\n 1. c_offending_flows m G =\n    (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})", "by(simp add: offending_formaldef)"], ["proof (state)\nthis:\n  c_offending_flows m G =\n  (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})\n\ngoal (1 subgoal):\n 1. \\<not> c_sinvar m G \\<Longrightarrow>\n    c_offending_flows m G =\n    (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> c_sinvar m G \\<Longrightarrow>\n    c_offending_flows m G =\n    (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})", "case False"], ["proof (state)\nthis:\n  \\<not> c_sinvar m G\n\ngoal (1 subgoal):\n 1. \\<not> c_sinvar m G \\<Longrightarrow>\n    c_offending_flows m G =\n    (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> c_sinvar m G\n\ngoal (1 subgoal):\n 1. c_offending_flows m G =\n    (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})", "by(auto simp add: offending_formaldef graph_ops enf)"], ["proof (state)\nthis:\n  c_offending_flows m G =\n  (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c_offending_flows m G =\n  (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})\n\ngoal (1 subgoal):\n 1. \\<forall>G.\n       c_offending_flows m G =\n       (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})", "}"], ["proof (state)\nthis:\n  c_offending_flows m ?G2 =\n  (if c_sinvar m ?G2 then {} else {{e \\<in> edges ?G2. \\<not> P e}})\n\ngoal (1 subgoal):\n 1. \\<forall>G.\n       c_offending_flows m G =\n       (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})", "thus ?thesis"], ["proof (prove)\nusing this:\n  c_offending_flows m ?G2 =\n  (if c_sinvar m ?G2 then {} else {{e \\<in> edges ?G2. \\<not> P e}})\n\ngoal (1 subgoal):\n 1. \\<forall>G.\n       c_offending_flows m G =\n       (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})", "by simp"], ["proof (state)\nthis:\n  \\<forall>G.\n     c_offending_flows m G =\n     (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enf_not_fulfilled_if_in_offending:\n  assumes validRs: \"valid_reqs M\"\n    and   wfG:     \"wf_graph G\"\n    and   enf:     \"\\<forall>m \\<in> set M. \\<exists>P. \\<forall>G. c_sinvar m G = (\\<forall>e \\<in> edges G. P e)\"\n    shows \"\\<forall>x \\<in> (\\<Union>m\\<in>set M. \\<Union>(c_offending_flows m (fully_connected G))).\n                \\<not> all_security_requirements_fulfilled M \\<lparr> nodes = V, edges = insert x E\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<Union>m\\<in>set M.\n                      \\<Union> (c_offending_flows m (fully_connected G)).\n       \\<not> all_security_requirements_fulfilled M\n               \\<lparr>nodes = V, edges = insert x E\\<rparr>", "unfolding all_security_requirements_fulfilled_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<Union>m\\<in>set M.\n                      \\<Union> (c_offending_flows m (fully_connected G)).\n       \\<not> (\\<forall>m\\<in>set M.\n                  c_sinvar m \\<lparr>nodes = V, edges = insert x E\\<rparr>)", "proof(simp, clarify, rename_tac m F a b)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m F a b.\n       \\<lbrakk>m \\<in> set M;\n        F \\<in> c_offending_flows m (fully_connected G);\n        (a, b) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>set M.\n                            \\<not> c_sinvar m\n                                    \\<lparr>nodes = V,\n edges = insert (a, b) E\\<rparr>", "let ?G=\"(fully_connected G)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m F a b.\n       \\<lbrakk>m \\<in> set M;\n        F \\<in> c_offending_flows m (fully_connected G);\n        (a, b) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>set M.\n                            \\<not> c_sinvar m\n                                    \\<lparr>nodes = V,\n edges = insert (a, b) E\\<rparr>", "fix m F v1 v2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m F a b.\n       \\<lbrakk>m \\<in> set M;\n        F \\<in> c_offending_flows m (fully_connected G);\n        (a, b) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>set M.\n                            \\<not> c_sinvar m\n                                    \\<lparr>nodes = V,\n edges = insert (a, b) E\\<rparr>", "assume \"m \\<in> set M\" and \"F \\<in> c_offending_flows m ?G\" and \"(v1, v2) \\<in> F\""], ["proof (state)\nthis:\n  m \\<in> set M\n  F \\<in> c_offending_flows m (fully_connected G)\n  (v1, v2) \\<in> F\n\ngoal (1 subgoal):\n 1. \\<And>m F a b.\n       \\<lbrakk>m \\<in> set M;\n        F \\<in> c_offending_flows m (fully_connected G);\n        (a, b) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>set M.\n                            \\<not> c_sinvar m\n                                    \\<lparr>nodes = V,\n edges = insert (a, b) E\\<rparr>", "from validRs"], ["proof (chain)\npicking this:\n  valid_reqs M", "have valid_mD:\"\\<And>m. m \\<in> set M \\<Longrightarrow> configured_SecurityInvariant m \""], ["proof (prove)\nusing this:\n  valid_reqs M\n\ngoal (1 subgoal):\n 1. \\<And>m. m \\<in> set M \\<Longrightarrow> configured_SecurityInvariant m", "by(simp add: valid_reqs_def)"], ["proof (state)\nthis:\n  ?m \\<in> set M \\<Longrightarrow> configured_SecurityInvariant ?m\n\ngoal (1 subgoal):\n 1. \\<And>m F a b.\n       \\<lbrakk>m \\<in> set M;\n        F \\<in> c_offending_flows m (fully_connected G);\n        (a, b) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>set M.\n                            \\<not> c_sinvar m\n                                    \\<lparr>nodes = V,\n edges = insert (a, b) E\\<rparr>", "from \\<open>m \\<in> set M\\<close> valid_mD"], ["proof (chain)\npicking this:\n  m \\<in> set M\n  ?m \\<in> set M \\<Longrightarrow> configured_SecurityInvariant ?m", "have \"configured_SecurityInvariant m\""], ["proof (prove)\nusing this:\n  m \\<in> set M\n  ?m \\<in> set M \\<Longrightarrow> configured_SecurityInvariant ?m\n\ngoal (1 subgoal):\n 1. configured_SecurityInvariant m", "by simp"], ["proof (state)\nthis:\n  configured_SecurityInvariant m\n\ngoal (1 subgoal):\n 1. \\<And>m F a b.\n       \\<lbrakk>m \\<in> set M;\n        F \\<in> c_offending_flows m (fully_connected G);\n        (a, b) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>set M.\n                            \\<not> c_sinvar m\n                                    \\<lparr>nodes = V,\n edges = insert (a, b) E\\<rparr>", "from enf \\<open>m \\<in> set M\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>m\\<in>set M.\n     \\<exists>P. \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\n  m \\<in> set M", "obtain P where enf_m: \"\\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>set M.\n     \\<exists>P. \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\n  m \\<in> set M\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<forall>G.\n           c_sinvar m G = (\\<forall>e\\<in>edges G. P e) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\n\ngoal (1 subgoal):\n 1. \\<And>m F a b.\n       \\<lbrakk>m \\<in> set M;\n        F \\<in> c_offending_flows m (fully_connected G);\n        (a, b) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>set M.\n                            \\<not> c_sinvar m\n                                    \\<lparr>nodes = V,\n edges = insert (a, b) E\\<rparr>", "from \\<open>(v1, v2) \\<in> F\\<close>"], ["proof (chain)\npicking this:\n  (v1, v2) \\<in> F", "have \"F \\<noteq> {}\""], ["proof (prove)\nusing this:\n  (v1, v2) \\<in> F\n\ngoal (1 subgoal):\n 1. F \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  F \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>m F a b.\n       \\<lbrakk>m \\<in> set M;\n        F \\<in> c_offending_flows m (fully_connected G);\n        (a, b) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>set M.\n                            \\<not> c_sinvar m\n                                    \\<lparr>nodes = V,\n edges = insert (a, b) E\\<rparr>", "from enf_offending_flows[OF \\<open>configured_SecurityInvariant m\\<close> \\<open>\\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\\<close>]"], ["proof (chain)\npicking this:\n  \\<forall>G.\n     c_offending_flows m G =\n     (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})", "have\n      offending: \"\\<And>G. c_offending_flows m G = (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})\""], ["proof (prove)\nusing this:\n  \\<forall>G.\n     c_offending_flows m G =\n     (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})\n\ngoal (1 subgoal):\n 1. \\<And>G.\n       c_offending_flows m G =\n       (if c_sinvar m G then {} else {{e \\<in> edges G. \\<not> P e}})", "by simp"], ["proof (state)\nthis:\n  c_offending_flows m ?G =\n  (if c_sinvar m ?G then {} else {{e \\<in> edges ?G. \\<not> P e}})\n\ngoal (1 subgoal):\n 1. \\<And>m F a b.\n       \\<lbrakk>m \\<in> set M;\n        F \\<in> c_offending_flows m (fully_connected G);\n        (a, b) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>set M.\n                            \\<not> c_sinvar m\n                                    \\<lparr>nodes = V,\n edges = insert (a, b) E\\<rparr>", "from \\<open>F \\<in> c_offending_flows m ?G\\<close> \\<open>F \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  F \\<in> c_offending_flows m (fully_connected G)\n  F \\<noteq> {}", "have \"F = {e \\<in> edges ?G. \\<not> P e}\""], ["proof (prove)\nusing this:\n  F \\<in> c_offending_flows m (fully_connected G)\n  F \\<noteq> {}\n\ngoal (1 subgoal):\n 1. F = {e \\<in> edges (fully_connected G). \\<not> P e}", "by(simp split: if_split_asm add: offending)"], ["proof (state)\nthis:\n  F = {e \\<in> edges (fully_connected G). \\<not> P e}\n\ngoal (1 subgoal):\n 1. \\<And>m F a b.\n       \\<lbrakk>m \\<in> set M;\n        F \\<in> c_offending_flows m (fully_connected G);\n        (a, b) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>set M.\n                            \\<not> c_sinvar m\n                                    \\<lparr>nodes = V,\n edges = insert (a, b) E\\<rparr>", "from this \\<open>(v1, v2) \\<in> F\\<close>"], ["proof (chain)\npicking this:\n  F = {e \\<in> edges (fully_connected G). \\<not> P e}\n  (v1, v2) \\<in> F", "have \"\\<not> P (v1, v2)\""], ["proof (prove)\nusing this:\n  F = {e \\<in> edges (fully_connected G). \\<not> P e}\n  (v1, v2) \\<in> F\n\ngoal (1 subgoal):\n 1. \\<not> P (v1, v2)", "by simp"], ["proof (state)\nthis:\n  \\<not> P (v1, v2)\n\ngoal (1 subgoal):\n 1. \\<And>m F a b.\n       \\<lbrakk>m \\<in> set M;\n        F \\<in> c_offending_flows m (fully_connected G);\n        (a, b) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>set M.\n                            \\<not> c_sinvar m\n                                    \\<lparr>nodes = V,\n edges = insert (a, b) E\\<rparr>", "from this enf_m"], ["proof (chain)\npicking this:\n  \\<not> P (v1, v2)\n  \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)", "have \"\\<not> c_sinvar m \\<lparr>nodes = V, edges = insert (v1, v2) E\\<rparr>\""], ["proof (prove)\nusing this:\n  \\<not> P (v1, v2)\n  \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\n\ngoal (1 subgoal):\n 1. \\<not> c_sinvar m \\<lparr>nodes = V, edges = insert (v1, v2) E\\<rparr>", "by(simp)"], ["proof (state)\nthis:\n  \\<not> c_sinvar m \\<lparr>nodes = V, edges = insert (v1, v2) E\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>m F a b.\n       \\<lbrakk>m \\<in> set M;\n        F \\<in> c_offending_flows m (fully_connected G);\n        (a, b) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>set M.\n                            \\<not> c_sinvar m\n                                    \\<lparr>nodes = V,\n edges = insert (a, b) E\\<rparr>", "thus \"\\<exists>m\\<in>set M. \\<not> c_sinvar m \\<lparr>nodes = V, edges = insert (v1, v2) E\\<rparr>\""], ["proof (prove)\nusing this:\n  \\<not> c_sinvar m \\<lparr>nodes = V, edges = insert (v1, v2) E\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>set M.\n       \\<not> c_sinvar m\n               \\<lparr>nodes = V, edges = insert (v1, v2) E\\<rparr>", "using \\<open>m \\<in> set M\\<close>"], ["proof (prove)\nusing this:\n  \\<not> c_sinvar m \\<lparr>nodes = V, edges = insert (v1, v2) E\\<rparr>\n  m \\<in> set M\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>set M.\n       \\<not> c_sinvar m\n               \\<lparr>nodes = V, edges = insert (v1, v2) E\\<rparr>", "apply(rule_tac x=\"m\" in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> c_sinvar m\n                     \\<lparr>nodes = V, edges = insert (v1, v2) E\\<rparr>;\n     m \\<in> set M\\<rbrakk>\n    \\<Longrightarrow> \\<not> c_sinvar m\n                              \\<lparr>nodes = V,\n                                 edges = insert (v1, v2) E\\<rparr>\n 2. \\<lbrakk>\\<not> c_sinvar m\n                     \\<lparr>nodes = V, edges = insert (v1, v2) E\\<rparr>;\n     m \\<in> set M\\<rbrakk>\n    \\<Longrightarrow> m \\<in> set M", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>m\\<in>set M.\n     \\<not> c_sinvar m \\<lparr>nodes = V, edges = insert (v1, v2) E\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem generate_valid_topology_max_topo: \"\\<lbrakk> valid_reqs M; wf_graph G;\n      \\<forall>m \\<in> set M. \\<exists>P. \\<forall>G. c_sinvar m G = (\\<forall>e \\<in> edges G. P e)\\<rbrakk> \\<Longrightarrow> \n      max_topo M (generate_valid_topology M (fully_connected G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G;\n     \\<forall>m\\<in>set M.\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\\<rbrakk>\n    \\<Longrightarrow> max_topo M\n                       (generate_valid_topology M (fully_connected G))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G;\n     \\<forall>m\\<in>set M.\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\\<rbrakk>\n    \\<Longrightarrow> max_topo M\n                       (generate_valid_topology M (fully_connected G))", "let ?G=\"(fully_connected G)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G;\n     \\<forall>m\\<in>set M.\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\\<rbrakk>\n    \\<Longrightarrow> max_topo M\n                       (generate_valid_topology M (fully_connected G))", "assume validRs: \"valid_reqs M\"\n    and    wfG:       \"wf_graph G\"\n    and enf: \"\\<forall>m \\<in> set M. \\<exists>P. \\<forall>G. c_sinvar m G = (\\<forall>e \\<in> edges G. P e)\""], ["proof (state)\nthis:\n  valid_reqs M\n  wf_graph G\n  \\<forall>m\\<in>set M.\n     \\<exists>P. \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G;\n     \\<forall>m\\<in>set M.\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\\<rbrakk>\n    \\<Longrightarrow> max_topo M\n                       (generate_valid_topology M (fully_connected G))", "obtain V E where VE_prop: \"\\<lparr> nodes = V, edges = E \\<rparr> = generate_valid_topology M ?G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>V E.\n        \\<lparr>nodes = V, edges = E\\<rparr> =\n        generate_valid_topology M (fully_connected G) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis graph.cases)"], ["proof (state)\nthis:\n  \\<lparr>nodes = V, edges = E\\<rparr> =\n  generate_valid_topology M (fully_connected G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G;\n     \\<forall>m\\<in>set M.\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\\<rbrakk>\n    \\<Longrightarrow> max_topo M\n                       (generate_valid_topology M (fully_connected G))", "hence VE_prop_asset:\n      \"\\<lparr> nodes = V, edges = E \\<rparr> = \\<lparr> nodes = V, edges = V \\<times> V - (\\<Union>m\\<in>set M. \\<Union>(c_offending_flows m ?G))\\<rparr>\""], ["proof (prove)\nusing this:\n  \\<lparr>nodes = V, edges = E\\<rparr> =\n  generate_valid_topology M (fully_connected G)\n\ngoal (1 subgoal):\n 1. \\<lparr>nodes = V, edges = E\\<rparr> =\n    \\<lparr>nodes = V,\n       edges =\n         V \\<times> V -\n         (\\<Union>m\\<in>set M.\n             \\<Union> (c_offending_flows m (fully_connected G)))\\<rparr>", "by(simp add: fully_connected_def generate_valid_topology_as_set delete_edges_simp2)"], ["proof (state)\nthis:\n  \\<lparr>nodes = V, edges = E\\<rparr> =\n  \\<lparr>nodes = V,\n     edges =\n       V \\<times> V -\n       (\\<Union>m\\<in>set M.\n           \\<Union> (c_offending_flows m (fully_connected G)))\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G;\n     \\<forall>m\\<in>set M.\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\\<rbrakk>\n    \\<Longrightarrow> max_topo M\n                       (generate_valid_topology M (fully_connected G))", "from VE_prop_asset"], ["proof (chain)\npicking this:\n  \\<lparr>nodes = V, edges = E\\<rparr> =\n  \\<lparr>nodes = V,\n     edges =\n       V \\<times> V -\n       (\\<Union>m\\<in>set M.\n           \\<Union> (c_offending_flows m (fully_connected G)))\\<rparr>", "have E_prop: \"E =  V \\<times> V - (\\<Union>m\\<in>set M. \\<Union>(c_offending_flows m ?G))\""], ["proof (prove)\nusing this:\n  \\<lparr>nodes = V, edges = E\\<rparr> =\n  \\<lparr>nodes = V,\n     edges =\n       V \\<times> V -\n       (\\<Union>m\\<in>set M.\n           \\<Union> (c_offending_flows m (fully_connected G)))\\<rparr>\n\ngoal (1 subgoal):\n 1. E =\n    V \\<times> V -\n    (\\<Union>m\\<in>set M.\n        \\<Union> (c_offending_flows m (fully_connected G)))", "by fast"], ["proof (state)\nthis:\n  E =\n  V \\<times> V -\n  (\\<Union>m\\<in>set M. \\<Union> (c_offending_flows m (fully_connected G)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G;\n     \\<forall>m\\<in>set M.\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\\<rbrakk>\n    \\<Longrightarrow> max_topo M\n                       (generate_valid_topology M (fully_connected G))", "from VE_prop"], ["proof (chain)\npicking this:\n  \\<lparr>nodes = V, edges = E\\<rparr> =\n  generate_valid_topology M (fully_connected G)", "have V_prop: \"nodes G = V\""], ["proof (prove)\nusing this:\n  \\<lparr>nodes = V, edges = E\\<rparr> =\n  generate_valid_topology M (fully_connected G)\n\ngoal (1 subgoal):\n 1. nodes G = V", "by (simp add: fully_connected_def delete_edges_simp2 generate_valid_topology_def_alt)"], ["proof (state)\nthis:\n  nodes G = V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G;\n     \\<forall>m\\<in>set M.\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\\<rbrakk>\n    \\<Longrightarrow> max_topo M\n                       (generate_valid_topology M (fully_connected G))", "from VE_prop"], ["proof (chain)\npicking this:\n  \\<lparr>nodes = V, edges = E\\<rparr> =\n  generate_valid_topology M (fully_connected G)", "have V_full_prop: \"nodes (generate_valid_topology M ?G) = V\""], ["proof (prove)\nusing this:\n  \\<lparr>nodes = V, edges = E\\<rparr> =\n  generate_valid_topology M (fully_connected G)\n\ngoal (1 subgoal):\n 1. nodes (generate_valid_topology M (fully_connected G)) = V", "by (metis graph.select_convs(1))"], ["proof (state)\nthis:\n  nodes (generate_valid_topology M (fully_connected G)) = V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G;\n     \\<forall>m\\<in>set M.\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\\<rbrakk>\n    \\<Longrightarrow> max_topo M\n                       (generate_valid_topology M (fully_connected G))", "from VE_prop"], ["proof (chain)\npicking this:\n  \\<lparr>nodes = V, edges = E\\<rparr> =\n  generate_valid_topology M (fully_connected G)", "have E_full_prop: \"edges (generate_valid_topology M ?G) = E\""], ["proof (prove)\nusing this:\n  \\<lparr>nodes = V, edges = E\\<rparr> =\n  generate_valid_topology M (fully_connected G)\n\ngoal (1 subgoal):\n 1. edges (generate_valid_topology M (fully_connected G)) = E", "by (metis graph.select_convs(2))"], ["proof (state)\nthis:\n  edges (generate_valid_topology M (fully_connected G)) = E\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G;\n     \\<forall>m\\<in>set M.\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\\<rbrakk>\n    \\<Longrightarrow> max_topo M\n                       (generate_valid_topology M (fully_connected G))", "from VE_prop wf_graph_generate_valid_topology[OF fully_connected_wf[OF wfG]]"], ["proof (chain)\npicking this:\n  \\<lparr>nodes = V, edges = E\\<rparr> =\n  generate_valid_topology M (fully_connected G)\n  wf_graph (generate_valid_topology ?M (fully_connected G))", "have wfG_VE: \"wf_graph \\<lparr> nodes = V, edges = E \\<rparr>\""], ["proof (prove)\nusing this:\n  \\<lparr>nodes = V, edges = E\\<rparr> =\n  generate_valid_topology M (fully_connected G)\n  wf_graph (generate_valid_topology ?M (fully_connected G))\n\ngoal (1 subgoal):\n 1. wf_graph \\<lparr>nodes = V, edges = E\\<rparr>", "by force"], ["proof (state)\nthis:\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G;\n     \\<forall>m\\<in>set M.\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\\<rbrakk>\n    \\<Longrightarrow> max_topo M\n                       (generate_valid_topology M (fully_connected G))", "from generate_valid_topology_sound[OF validRs wfG_VE] fully_connected_wf[OF wfG]"], ["proof (chain)\npicking this:\n  all_security_requirements_fulfilled M\n   (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>)\n  wf_graph (fully_connected G)", "have VE_all_valid: \n      \"all_security_requirements_fulfilled M \\<lparr> nodes = V, edges = V \\<times> V - (\\<Union>m\\<in>set M. \\<Union>(c_offending_flows m ?G))\\<rparr>\""], ["proof (prove)\nusing this:\n  all_security_requirements_fulfilled M\n   (generate_valid_topology M \\<lparr>nodes = V, edges = E\\<rparr>)\n  wf_graph (fully_connected G)\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled M\n     \\<lparr>nodes = V,\n        edges =\n          V \\<times> V -\n          (\\<Union>m\\<in>set M.\n              \\<Union> (c_offending_flows m (fully_connected G)))\\<rparr>", "by (metis VE_prop VE_prop_asset fully_connected_def generate_valid_topology_sound validRs)"], ["proof (state)\nthis:\n  all_security_requirements_fulfilled M\n   \\<lparr>nodes = V,\n      edges =\n        V \\<times> V -\n        (\\<Union>m\\<in>set M.\n            \\<Union> (c_offending_flows m (fully_connected G)))\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G;\n     \\<forall>m\\<in>set M.\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\\<rbrakk>\n    \\<Longrightarrow> max_topo M\n                       (generate_valid_topology M (fully_connected G))", "hence goal1: \"all_security_requirements_fulfilled M (generate_valid_topology M (fully_connected G))\""], ["proof (prove)\nusing this:\n  all_security_requirements_fulfilled M\n   \\<lparr>nodes = V,\n      edges =\n        V \\<times> V -\n        (\\<Union>m\\<in>set M.\n            \\<Union> (c_offending_flows m (fully_connected G)))\\<rparr>\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled M\n     (generate_valid_topology M (fully_connected G))", "by (metis VE_prop VE_prop_asset)"], ["proof (state)\nthis:\n  all_security_requirements_fulfilled M\n   (generate_valid_topology M (fully_connected G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G;\n     \\<forall>m\\<in>set M.\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\\<rbrakk>\n    \\<Longrightarrow> max_topo M\n                       (generate_valid_topology M (fully_connected G))", "from validRs"], ["proof (chain)\npicking this:\n  valid_reqs M", "have valid_mD:\"\\<And>m. m \\<in> set M \\<Longrightarrow> configured_SecurityInvariant m \""], ["proof (prove)\nusing this:\n  valid_reqs M\n\ngoal (1 subgoal):\n 1. \\<And>m. m \\<in> set M \\<Longrightarrow> configured_SecurityInvariant m", "by(simp add: valid_reqs_def)"], ["proof (state)\nthis:\n  ?m \\<in> set M \\<Longrightarrow> configured_SecurityInvariant ?m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G;\n     \\<forall>m\\<in>set M.\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\\<rbrakk>\n    \\<Longrightarrow> max_topo M\n                       (generate_valid_topology M (fully_connected G))", "from c_offending_flows_subseteq_edges[where G=\"?G\"] validRs"], ["proof (chain)\npicking this:\n  configured_SecurityInvariant ?m \\<Longrightarrow>\n  \\<Union> (c_offending_flows ?m (fully_connected G))\n  \\<subseteq> edges (fully_connected G)\n  valid_reqs M", "have hlp1: \"(\\<Union>m\\<in>set M. \\<Union>(c_offending_flows m ?G)) \\<subseteq> V \\<times> V\""], ["proof (prove)\nusing this:\n  configured_SecurityInvariant ?m \\<Longrightarrow>\n  \\<Union> (c_offending_flows ?m (fully_connected G))\n  \\<subseteq> edges (fully_connected G)\n  valid_reqs M\n\ngoal (1 subgoal):\n 1. (\\<Union>m\\<in>set M.\n        \\<Union> (c_offending_flows m (fully_connected G)))\n    \\<subseteq> V \\<times> V", "apply(simp add: fully_connected_def V_prop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m.\n                configured_SecurityInvariant m \\<Longrightarrow>\n                \\<Union>\n                 (c_offending_flows m\n                   \\<lparr>nodes = V, edges = V \\<times> V\\<rparr>)\n                \\<subseteq> V \\<times> V;\n     valid_reqs M\\<rbrakk>\n    \\<Longrightarrow> (\\<Union>x\\<in>set M.\n                          \\<Union>\n                           (c_offending_flows x\n                             \\<lparr>nodes = V,\n                                edges = V \\<times> V\\<rparr>))\n                      \\<subseteq> V \\<times> V", "using valid_reqs_def"], ["proof (prove)\nusing this:\n  valid_reqs ?M \\<equiv>\n  \\<forall>m\\<in>set ?M. configured_SecurityInvariant m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m.\n                configured_SecurityInvariant m \\<Longrightarrow>\n                \\<Union>\n                 (c_offending_flows m\n                   \\<lparr>nodes = V, edges = V \\<times> V\\<rparr>)\n                \\<subseteq> V \\<times> V;\n     valid_reqs M\\<rbrakk>\n    \\<Longrightarrow> (\\<Union>x\\<in>set M.\n                          \\<Union>\n                           (c_offending_flows x\n                             \\<lparr>nodes = V,\n                                edges = V \\<times> V\\<rparr>))\n                      \\<subseteq> V \\<times> V", "by blast"], ["proof (state)\nthis:\n  (\\<Union>m\\<in>set M. \\<Union> (c_offending_flows m (fully_connected G)))\n  \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G;\n     \\<forall>m\\<in>set M.\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\\<rbrakk>\n    \\<Longrightarrow> max_topo M\n                       (generate_valid_topology M (fully_connected G))", "have \"\\<And>A B. A - (A - B) = B \\<inter> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B. A - (A - B) = B \\<inter> A", "by fast"], ["proof (state)\nthis:\n  ?A - (?A - ?B) = ?B \\<inter> ?A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G;\n     \\<forall>m\\<in>set M.\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\\<rbrakk>\n    \\<Longrightarrow> max_topo M\n                       (generate_valid_topology M (fully_connected G))", "from E_prop hlp1"], ["proof (chain)\npicking this:\n  E =\n  V \\<times> V -\n  (\\<Union>m\\<in>set M. \\<Union> (c_offending_flows m (fully_connected G)))\n  (\\<Union>m\\<in>set M. \\<Union> (c_offending_flows m (fully_connected G)))\n  \\<subseteq> V \\<times> V", "have \"V \\<times> V - E = (\\<Union>m\\<in>set M. \\<Union>(c_offending_flows m ?G))\""], ["proof (prove)\nusing this:\n  E =\n  V \\<times> V -\n  (\\<Union>m\\<in>set M. \\<Union> (c_offending_flows m (fully_connected G)))\n  (\\<Union>m\\<in>set M. \\<Union> (c_offending_flows m (fully_connected G)))\n  \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. V \\<times> V - E =\n    (\\<Union>m\\<in>set M.\n        \\<Union> (c_offending_flows m (fully_connected G)))", "by force"], ["proof (state)\nthis:\n  V \\<times> V - E =\n  (\\<Union>m\\<in>set M. \\<Union> (c_offending_flows m (fully_connected G)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G;\n     \\<forall>m\\<in>set M.\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\\<rbrakk>\n    \\<Longrightarrow> max_topo M\n                       (generate_valid_topology M (fully_connected G))", "from enf_not_fulfilled_if_in_offending[OF validRs wfG enf]"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>\\<Union>m\\<in>set M.\n                    \\<Union> (c_offending_flows m (fully_connected G)).\n     \\<not> all_security_requirements_fulfilled M\n             \\<lparr>nodes = ?V, edges = insert x ?E\\<rparr>", "have \"\\<forall>(v1, v2) \\<in> (\\<Union>m\\<in>set M. \\<Union>(c_offending_flows m ?G)).\n       \\<not> all_security_requirements_fulfilled M \\<lparr> nodes = V, edges = E \\<union> {(v1, v2)}\\<rparr>\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>\\<Union>m\\<in>set M.\n                    \\<Union> (c_offending_flows m (fully_connected G)).\n     \\<not> all_security_requirements_fulfilled M\n             \\<lparr>nodes = ?V, edges = insert x ?E\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<forall>(v1, v2)\n             \\<in>\\<Union>m\\<in>set M.\n                     \\<Union> (c_offending_flows m (fully_connected G)).\n       \\<not> all_security_requirements_fulfilled M\n               \\<lparr>nodes = V, edges = E \\<union> {(v1, v2)}\\<rparr>", "by simp"], ["proof (state)\nthis:\n  \\<forall>(v1, v2)\n           \\<in>\\<Union>m\\<in>set M.\n                   \\<Union> (c_offending_flows m (fully_connected G)).\n     \\<not> all_security_requirements_fulfilled M\n             \\<lparr>nodes = V, edges = E \\<union> {(v1, v2)}\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G;\n     \\<forall>m\\<in>set M.\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\\<rbrakk>\n    \\<Longrightarrow> max_topo M\n                       (generate_valid_topology M (fully_connected G))", "from this \\<open>V \\<times> V - E = (\\<Union>m\\<in>set M. \\<Union>(c_offending_flows m ?G))\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>(v1, v2)\n           \\<in>\\<Union>m\\<in>set M.\n                   \\<Union> (c_offending_flows m (fully_connected G)).\n     \\<not> all_security_requirements_fulfilled M\n             \\<lparr>nodes = V, edges = E \\<union> {(v1, v2)}\\<rparr>\n  V \\<times> V - E =\n  (\\<Union>m\\<in>set M. \\<Union> (c_offending_flows m (fully_connected G)))", "have \"\\<forall>(v1, v2) \\<in> V \\<times> V - E.\n         \\<not> all_security_requirements_fulfilled M \\<lparr> nodes = V, edges = E \\<union> {(v1, v2)}\\<rparr>\""], ["proof (prove)\nusing this:\n  \\<forall>(v1, v2)\n           \\<in>\\<Union>m\\<in>set M.\n                   \\<Union> (c_offending_flows m (fully_connected G)).\n     \\<not> all_security_requirements_fulfilled M\n             \\<lparr>nodes = V, edges = E \\<union> {(v1, v2)}\\<rparr>\n  V \\<times> V - E =\n  (\\<Union>m\\<in>set M. \\<Union> (c_offending_flows m (fully_connected G)))\n\ngoal (1 subgoal):\n 1. \\<forall>(v1, v2)\\<in>V \\<times> V - E.\n       \\<not> all_security_requirements_fulfilled M\n               \\<lparr>nodes = V, edges = E \\<union> {(v1, v2)}\\<rparr>", "by simp"], ["proof (state)\nthis:\n  \\<forall>(v1, v2)\\<in>V \\<times> V - E.\n     \\<not> all_security_requirements_fulfilled M\n             \\<lparr>nodes = V, edges = E \\<union> {(v1, v2)}\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G;\n     \\<forall>m\\<in>set M.\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\\<rbrakk>\n    \\<Longrightarrow> max_topo M\n                       (generate_valid_topology M (fully_connected G))", "hence goal2: \"(\\<forall>(v1, v2)\\<in>nodes (generate_valid_topology M ?G) \\<times> nodes (generate_valid_topology M ?G) -\n                edges (generate_valid_topology M ?G).\n        \\<not> all_security_requirements_fulfilled M (add_edge v1 v2 (generate_valid_topology M ?G)))\""], ["proof (prove)\nusing this:\n  \\<forall>(v1, v2)\\<in>V \\<times> V - E.\n     \\<not> all_security_requirements_fulfilled M\n             \\<lparr>nodes = V, edges = E \\<union> {(v1, v2)}\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<forall>(v1, v2)\n             \\<in>nodes\n                   (generate_valid_topology M (fully_connected G)) \\<times>\n                  nodes (generate_valid_topology M (fully_connected G)) -\n                  edges (generate_valid_topology M (fully_connected G)).\n       \\<not> all_security_requirements_fulfilled M\n               (add_edge v1 v2\n                 (generate_valid_topology M (fully_connected G)))", "proof(unfold V_full_prop E_full_prop graph_ops)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>(v1, v2)\\<in>V \\<times> V - E.\n       \\<not> all_security_requirements_fulfilled M\n               \\<lparr>nodes = V,\n                  edges = E \\<union> {(v1, v2)}\\<rparr> \\<Longrightarrow>\n    \\<forall>(v1, v2)\\<in>V \\<times> V - E.\n       \\<not> all_security_requirements_fulfilled M\n               \\<lparr>nodes = V \\<union> {v1, v2},\n                  edges = {(v1, v2)} \\<union> E\\<rparr>", "assume a: \"\\<forall>(v1, v2)\\<in>V \\<times> V - E. \\<not> all_security_requirements_fulfilled M \\<lparr>nodes = V, edges = E \\<union> {(v1, v2)}\\<rparr>\""], ["proof (state)\nthis:\n  \\<forall>(v1, v2)\\<in>V \\<times> V - E.\n     \\<not> all_security_requirements_fulfilled M\n             \\<lparr>nodes = V, edges = E \\<union> {(v1, v2)}\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<forall>(v1, v2)\\<in>V \\<times> V - E.\n       \\<not> all_security_requirements_fulfilled M\n               \\<lparr>nodes = V,\n                  edges = E \\<union> {(v1, v2)}\\<rparr> \\<Longrightarrow>\n    \\<forall>(v1, v2)\\<in>V \\<times> V - E.\n       \\<not> all_security_requirements_fulfilled M\n               \\<lparr>nodes = V \\<union> {v1, v2},\n                  edges = {(v1, v2)} \\<union> E\\<rparr>", "have \"\\<forall>(v1, v2)\\<in>V \\<times> V - E.  V \\<union> {v1, v2} = V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(v1, v2)\\<in>V \\<times> V - E. V \\<union> {v1, v2} = V", "by blast"], ["proof (state)\nthis:\n  \\<forall>(v1, v2)\\<in>V \\<times> V - E. V \\<union> {v1, v2} = V\n\ngoal (1 subgoal):\n 1. \\<forall>(v1, v2)\\<in>V \\<times> V - E.\n       \\<not> all_security_requirements_fulfilled M\n               \\<lparr>nodes = V,\n                  edges = E \\<union> {(v1, v2)}\\<rparr> \\<Longrightarrow>\n    \\<forall>(v1, v2)\\<in>V \\<times> V - E.\n       \\<not> all_security_requirements_fulfilled M\n               \\<lparr>nodes = V \\<union> {v1, v2},\n                  edges = {(v1, v2)} \\<union> E\\<rparr>", "hence \"\\<forall>(v1, v2)\\<in>V \\<times> V - E. \\<lparr>nodes = V \\<union> {v1, v2}, edges = {(v1, v2)} \\<union> E\\<rparr> = \\<lparr>nodes = V, edges = E \\<union> {(v1, v2)}\\<rparr>\""], ["proof (prove)\nusing this:\n  \\<forall>(v1, v2)\\<in>V \\<times> V - E. V \\<union> {v1, v2} = V\n\ngoal (1 subgoal):\n 1. \\<forall>(v1, v2)\\<in>V \\<times> V - E.\n       \\<lparr>nodes = V \\<union> {v1, v2},\n          edges = {(v1, v2)} \\<union> E\\<rparr> =\n       \\<lparr>nodes = V, edges = E \\<union> {(v1, v2)}\\<rparr>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(v1, v2)\\<in>V \\<times> V - E.\n     \\<lparr>nodes = V \\<union> {v1, v2},\n        edges = {(v1, v2)} \\<union> E\\<rparr> =\n     \\<lparr>nodes = V, edges = E \\<union> {(v1, v2)}\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<forall>(v1, v2)\\<in>V \\<times> V - E.\n       \\<not> all_security_requirements_fulfilled M\n               \\<lparr>nodes = V,\n                  edges = E \\<union> {(v1, v2)}\\<rparr> \\<Longrightarrow>\n    \\<forall>(v1, v2)\\<in>V \\<times> V - E.\n       \\<not> all_security_requirements_fulfilled M\n               \\<lparr>nodes = V \\<union> {v1, v2},\n                  edges = {(v1, v2)} \\<union> E\\<rparr>", "from this a"], ["proof (chain)\npicking this:\n  \\<forall>(v1, v2)\\<in>V \\<times> V - E.\n     \\<lparr>nodes = V \\<union> {v1, v2},\n        edges = {(v1, v2)} \\<union> E\\<rparr> =\n     \\<lparr>nodes = V, edges = E \\<union> {(v1, v2)}\\<rparr>\n  \\<forall>(v1, v2)\\<in>V \\<times> V - E.\n     \\<not> all_security_requirements_fulfilled M\n             \\<lparr>nodes = V, edges = E \\<union> {(v1, v2)}\\<rparr>", "show \"\\<forall>(v1, v2)\\<in>V \\<times> V - E. \\<not> all_security_requirements_fulfilled M \\<lparr>nodes = V \\<union> {v1, v2}, edges = {(v1, v2)} \\<union> E\\<rparr>\"\n        \\<comment> \\<open>TODO: this should be trivial ...\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>(v1, v2)\\<in>V \\<times> V - E.\n     \\<lparr>nodes = V \\<union> {v1, v2},\n        edges = {(v1, v2)} \\<union> E\\<rparr> =\n     \\<lparr>nodes = V, edges = E \\<union> {(v1, v2)}\\<rparr>\n  \\<forall>(v1, v2)\\<in>V \\<times> V - E.\n     \\<not> all_security_requirements_fulfilled M\n             \\<lparr>nodes = V, edges = E \\<union> {(v1, v2)}\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<forall>(v1, v2)\\<in>V \\<times> V - E.\n       \\<not> all_security_requirements_fulfilled M\n               \\<lparr>nodes = V \\<union> {v1, v2},\n                  edges = {(v1, v2)} \\<union> E\\<rparr>", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>V \\<times> V - E.\n                case x of\n                (v1, v2) \\<Rightarrow> insert v1 (insert v2 V) = V;\n     \\<forall>x\\<in>V \\<times> V - E.\n        \\<not> all_security_requirements_fulfilled M\n                \\<lparr>nodes = V, edges = insert x E\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>V \\<times> V - E.\n                         case x of\n                         (v1, v2) \\<Rightarrow>\n                           \\<not> all_security_requirements_fulfilled M\n                                   \\<lparr>nodes = insert v1 (insert v2 V),\nedges = insert (v1, v2) E\\<rparr>", "apply(rule ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>V \\<times> V - E.\n                   case x of\n                   (v1, v2) \\<Rightarrow> insert v1 (insert v2 V) = V;\n        \\<forall>x\\<in>V \\<times> V - E.\n           \\<not> all_security_requirements_fulfilled M\n                   \\<lparr>nodes = V, edges = insert x E\\<rparr>;\n        x \\<in> V \\<times> V - E\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (v1, v2) \\<Rightarrow>\n                           \\<not> all_security_requirements_fulfilled M\n                                   \\<lparr>nodes = insert v1 (insert v2 V),\nedges = insert (v1, v2) E\\<rparr>", "apply(erule_tac x=x and A=\"V \\<times> V - E\" in ballE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>V \\<times> V - E.\n                   \\<not> all_security_requirements_fulfilled M\n                           \\<lparr>nodes = V, edges = insert x E\\<rparr>;\n        x \\<in> V \\<times> V - E;\n        case x of\n        (v1, v2) \\<Rightarrow> insert v1 (insert v2 V) = V\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (v1, v2) \\<Rightarrow>\n                           \\<not> all_security_requirements_fulfilled M\n                                   \\<lparr>nodes = insert v1 (insert v2 V),\nedges = insert (v1, v2) E\\<rparr>\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>V \\<times> V - E.\n                   \\<not> all_security_requirements_fulfilled M\n                           \\<lparr>nodes = V, edges = insert x E\\<rparr>;\n        x \\<in> V \\<times> V - E; x \\<notin> V \\<times> V - E\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (v1, v2) \\<Rightarrow>\n                           \\<not> all_security_requirements_fulfilled M\n                                   \\<lparr>nodes = insert v1 (insert v2 V),\nedges = insert (v1, v2) E\\<rparr>", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>V \\<times> V - E.\n                   \\<not> all_security_requirements_fulfilled M\n                           \\<lparr>nodes = V, edges = insert x E\\<rparr>;\n        x \\<in> V \\<times> V - E; x \\<notin> V \\<times> V - E\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (v1, v2) \\<Rightarrow>\n                           \\<not> all_security_requirements_fulfilled M\n                                   \\<lparr>nodes = insert v1 (insert v2 V),\nedges = insert (v1, v2) E\\<rparr>\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>V \\<times> V - E.\n                   \\<not> all_security_requirements_fulfilled M\n                           \\<lparr>nodes = V, edges = insert x E\\<rparr>;\n        x \\<in> V \\<times> V - E;\n        case x of\n        (v1, v2) \\<Rightarrow> insert v1 (insert v2 V) = V\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (v1, v2) \\<Rightarrow>\n                           \\<not> all_security_requirements_fulfilled M\n                                   \\<lparr>nodes = insert v1 (insert v2 V),\nedges = insert (v1, v2) E\\<rparr>", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>V \\<times> V - E.\n                   \\<not> all_security_requirements_fulfilled M\n                           \\<lparr>nodes = V, edges = insert x E\\<rparr>;\n        x \\<in> V \\<times> V - E;\n        case x of\n        (v1, v2) \\<Rightarrow> insert v1 (insert v2 V) = V\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (v1, v2) \\<Rightarrow>\n                           \\<not> all_security_requirements_fulfilled M\n                                   \\<lparr>nodes = insert v1 (insert v2 V),\nedges = insert (v1, v2) E\\<rparr>", "apply(erule_tac x=x and A=\"V \\<times> V - E\" in ballE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> V \\<times> V - E;\n        case x of (v1, v2) \\<Rightarrow> insert v1 (insert v2 V) = V;\n        \\<not> all_security_requirements_fulfilled M\n                \\<lparr>nodes = V, edges = insert x E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (v1, v2) \\<Rightarrow>\n                           \\<not> all_security_requirements_fulfilled M\n                                   \\<lparr>nodes = insert v1 (insert v2 V),\nedges = insert (v1, v2) E\\<rparr>\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> V \\<times> V - E;\n        case x of (v1, v2) \\<Rightarrow> insert v1 (insert v2 V) = V;\n        x \\<notin> V \\<times> V - E\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (v1, v2) \\<Rightarrow>\n                           \\<not> all_security_requirements_fulfilled M\n                                   \\<lparr>nodes = insert v1 (insert v2 V),\nedges = insert (v1, v2) E\\<rparr>", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> V \\<times> V - E;\n        case x of (v1, v2) \\<Rightarrow> insert v1 (insert v2 V) = V;\n        x \\<notin> V \\<times> V - E\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (v1, v2) \\<Rightarrow>\n                           \\<not> all_security_requirements_fulfilled M\n                                   \\<lparr>nodes = insert v1 (insert v2 V),\nedges = insert (v1, v2) E\\<rparr>\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> V \\<times> V - E;\n        case x of (v1, v2) \\<Rightarrow> insert v1 (insert v2 V) = V;\n        \\<not> all_security_requirements_fulfilled M\n                \\<lparr>nodes = V, edges = insert x E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (v1, v2) \\<Rightarrow>\n                           \\<not> all_security_requirements_fulfilled M\n                                   \\<lparr>nodes = insert v1 (insert v2 V),\nedges = insert (v1, v2) E\\<rparr>", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> V \\<times> V - E;\n        case x of (v1, v2) \\<Rightarrow> insert v1 (insert v2 V) = V;\n        \\<not> all_security_requirements_fulfilled M\n                \\<lparr>nodes = V, edges = insert x E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (v1, v2) \\<Rightarrow>\n                           \\<not> all_security_requirements_fulfilled M\n                                   \\<lparr>nodes = insert v1 (insert v2 V),\nedges = insert (v1, v2) E\\<rparr>", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>insert a (insert b V) = V;\n        \\<not> all_security_requirements_fulfilled M\n                \\<lparr>nodes = V, edges = insert (a, b) E\\<rparr>;\n        (a, b) \\<notin> E; a \\<in> V; b \\<in> V;\n        all_security_requirements_fulfilled M\n         \\<lparr>nodes = insert a (insert b V),\n            edges = insert (a, b) E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> False", "by presburger"], ["proof (state)\nthis:\n  \\<forall>(v1, v2)\\<in>V \\<times> V - E.\n     \\<not> all_security_requirements_fulfilled M\n             \\<lparr>nodes = V \\<union> {v1, v2},\n                edges = {(v1, v2)} \\<union> E\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>(v1, v2)\n           \\<in>nodes\n                 (generate_valid_topology M (fully_connected G)) \\<times>\n                nodes (generate_valid_topology M (fully_connected G)) -\n                edges (generate_valid_topology M (fully_connected G)).\n     \\<not> all_security_requirements_fulfilled M\n             (add_edge v1 v2\n               (generate_valid_topology M (fully_connected G)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G;\n     \\<forall>m\\<in>set M.\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\\<rbrakk>\n    \\<Longrightarrow> max_topo M\n                       (generate_valid_topology M (fully_connected G))", "from goal1 goal2"], ["proof (chain)\npicking this:\n  all_security_requirements_fulfilled M\n   (generate_valid_topology M (fully_connected G))\n  \\<forall>(v1, v2)\n           \\<in>nodes\n                 (generate_valid_topology M (fully_connected G)) \\<times>\n                nodes (generate_valid_topology M (fully_connected G)) -\n                edges (generate_valid_topology M (fully_connected G)).\n     \\<not> all_security_requirements_fulfilled M\n             (add_edge v1 v2\n               (generate_valid_topology M (fully_connected G)))", "show ?thesis"], ["proof (prove)\nusing this:\n  all_security_requirements_fulfilled M\n   (generate_valid_topology M (fully_connected G))\n  \\<forall>(v1, v2)\n           \\<in>nodes\n                 (generate_valid_topology M (fully_connected G)) \\<times>\n                nodes (generate_valid_topology M (fully_connected G)) -\n                edges (generate_valid_topology M (fully_connected G)).\n     \\<not> all_security_requirements_fulfilled M\n             (add_edge v1 v2\n               (generate_valid_topology M (fully_connected G)))\n\ngoal (1 subgoal):\n 1. max_topo M (generate_valid_topology M (fully_connected G))", "unfolding max_topo_def"], ["proof (prove)\nusing this:\n  all_security_requirements_fulfilled M\n   (generate_valid_topology M (fully_connected G))\n  \\<forall>(v1, v2)\n           \\<in>nodes\n                 (generate_valid_topology M (fully_connected G)) \\<times>\n                nodes (generate_valid_topology M (fully_connected G)) -\n                edges (generate_valid_topology M (fully_connected G)).\n     \\<not> all_security_requirements_fulfilled M\n             (add_edge v1 v2\n               (generate_valid_topology M (fully_connected G)))\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled M\n     (generate_valid_topology M (fully_connected G)) \\<and>\n    (\\<forall>(v1, v2)\n              \\<in>nodes\n                    (generate_valid_topology M (fully_connected G)) \\<times>\n                   nodes (generate_valid_topology M (fully_connected G)) -\n                   edges (generate_valid_topology M (fully_connected G)).\n        \\<not> all_security_requirements_fulfilled M\n                (add_edge v1 v2\n                  (generate_valid_topology M (fully_connected G))))", "by presburger"], ["proof (state)\nthis:\n  max_topo M (generate_valid_topology M (fully_connected G))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enf_all_valid_policy_subset_of_max:\n    assumes validRs: \"valid_reqs M\"\n    and     wfG:     \"wf_graph G\"\n    and     enf:     \"\\<forall>m \\<in> set M. \\<exists>P. \\<forall>G. c_sinvar m G = (\\<forall>e \\<in> edges G. P e)\"\n    and     nodesG': \"nodes G = nodes G'\"\n    shows \"\\<lbrakk> wf_graph G';\n        all_security_requirements_fulfilled M G'\\<rbrakk> \\<Longrightarrow> \n        edges G' \\<subseteq> edges (generate_valid_topology M (fully_connected G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G'; all_security_requirements_fulfilled M G'\\<rbrakk>\n    \\<Longrightarrow> edges G'\n                      \\<subseteq> edges\n                                   (generate_valid_topology M\n                                     (fully_connected G))", "using nodesG'"], ["proof (prove)\nusing this:\n  nodes G = nodes G'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_graph G'; all_security_requirements_fulfilled M G'\\<rbrakk>\n    \\<Longrightarrow> edges G'\n                      \\<subseteq> edges\n                                   (generate_valid_topology M\n                                     (fully_connected G))", "apply(cases \"generate_valid_topology M (fully_connected G)\", rename_tac V E, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>V E.\n       \\<lbrakk>wf_graph G'; all_security_requirements_fulfilled M G';\n        generate_valid_topology M (fully_connected G) =\n        \\<lparr>nodes = V, edges = E\\<rparr>;\n        nodes G = nodes G'\\<rbrakk>\n       \\<Longrightarrow> edges G' \\<subseteq> E", "apply(cases \"G'\", rename_tac V' E', simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>V E V' E'.\n       \\<lbrakk>wf_graph \\<lparr>nodes = V', edges = E'\\<rparr>;\n        all_security_requirements_fulfilled M\n         \\<lparr>nodes = V', edges = E'\\<rparr>;\n        generate_valid_topology M (fully_connected G) =\n        \\<lparr>nodes = V, edges = E\\<rparr>;\n        nodes G = V'; G' = \\<lparr>nodes = V', edges = E'\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> E' \\<subseteq> E", "apply(subgoal_tac \"nodes G = V\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>V E V' E'.\n       \\<lbrakk>wf_graph \\<lparr>nodes = V', edges = E'\\<rparr>;\n        all_security_requirements_fulfilled M\n         \\<lparr>nodes = V', edges = E'\\<rparr>;\n        generate_valid_topology M (fully_connected G) =\n        \\<lparr>nodes = V, edges = E\\<rparr>;\n        nodes G = V'; G' = \\<lparr>nodes = V', edges = E'\\<rparr>;\n        nodes G = V\\<rbrakk>\n       \\<Longrightarrow> E' \\<subseteq> E\n 2. \\<And>V E V' E'.\n       \\<lbrakk>wf_graph \\<lparr>nodes = V', edges = E'\\<rparr>;\n        all_security_requirements_fulfilled M\n         \\<lparr>nodes = V', edges = E'\\<rparr>;\n        generate_valid_topology M (fully_connected G) =\n        \\<lparr>nodes = V, edges = E\\<rparr>;\n        nodes G = V'; G' = \\<lparr>nodes = V', edges = E'\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> nodes G = V", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>V E V' E'.\n       \\<lbrakk>wf_graph \\<lparr>nodes = V', edges = E'\\<rparr>;\n        all_security_requirements_fulfilled M\n         \\<lparr>nodes = V', edges = E'\\<rparr>;\n        generate_valid_topology M (fully_connected G) =\n        \\<lparr>nodes = V, edges = E\\<rparr>;\n        nodes G = V'; G' = \\<lparr>nodes = V', edges = E'\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> nodes G = V\n 2. \\<And>V E V' E'.\n       \\<lbrakk>wf_graph \\<lparr>nodes = V', edges = E'\\<rparr>;\n        all_security_requirements_fulfilled M\n         \\<lparr>nodes = V', edges = E'\\<rparr>;\n        generate_valid_topology M (fully_connected G) =\n        \\<lparr>nodes = V, edges = E\\<rparr>;\n        nodes G = V'; G' = \\<lparr>nodes = V', edges = E'\\<rparr>;\n        nodes G = V\\<rbrakk>\n       \\<Longrightarrow> E' \\<subseteq> E", "apply (metis fully_connected_def generate_valid_topology_nodes graph.select_convs(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>V E V' E'.\n       \\<lbrakk>wf_graph \\<lparr>nodes = V', edges = E'\\<rparr>;\n        all_security_requirements_fulfilled M\n         \\<lparr>nodes = V', edges = E'\\<rparr>;\n        generate_valid_topology M (fully_connected G) =\n        \\<lparr>nodes = V, edges = E\\<rparr>;\n        nodes G = V'; G' = \\<lparr>nodes = V', edges = E'\\<rparr>;\n        nodes G = V\\<rbrakk>\n       \\<Longrightarrow> E' \\<subseteq> E", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>V E V' E'.\n       \\<lbrakk>wf_graph \\<lparr>nodes = V', edges = E'\\<rparr>;\n        all_security_requirements_fulfilled M\n         \\<lparr>nodes = V', edges = E'\\<rparr>;\n        generate_valid_topology M (fully_connected G) =\n        \\<lparr>nodes = V', edges = E\\<rparr>;\n        V = V'; G' = \\<lparr>nodes = V', edges = E'\\<rparr>;\n        nodes G = V'\\<rbrakk>\n       \\<Longrightarrow> E' \\<subseteq> E", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V E V' E'.\n       \\<lbrakk>wf_graph \\<lparr>nodes = V', edges = E'\\<rparr>;\n        all_security_requirements_fulfilled M\n         \\<lparr>nodes = V', edges = E'\\<rparr>;\n        generate_valid_topology M (fully_connected G) =\n        \\<lparr>nodes = V', edges = E\\<rparr>;\n        V = V'; G' = \\<lparr>nodes = V', edges = E'\\<rparr>; nodes G = V';\n        \\<not> E' \\<subseteq> E\\<rbrakk>\n       \\<Longrightarrow> False", "fix V E V' E'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V E V' E'.\n       \\<lbrakk>wf_graph \\<lparr>nodes = V', edges = E'\\<rparr>;\n        all_security_requirements_fulfilled M\n         \\<lparr>nodes = V', edges = E'\\<rparr>;\n        generate_valid_topology M (fully_connected G) =\n        \\<lparr>nodes = V', edges = E\\<rparr>;\n        V = V'; G' = \\<lparr>nodes = V', edges = E'\\<rparr>; nodes G = V';\n        \\<not> E' \\<subseteq> E\\<rbrakk>\n       \\<Longrightarrow> False", "assume a5: \"all_security_requirements_fulfilled M \\<lparr>nodes = V, edges = E'\\<rparr>\" and\n           a6: \"generate_valid_topology M (fully_connected G) = \\<lparr>nodes = V, edges = E\\<rparr>\" and\n           a10: \"wf_graph \\<lparr>nodes = V, edges = E'\\<rparr>\" and\n           contr: \"\\<not> E' \\<subseteq> E\""], ["proof (state)\nthis:\n  all_security_requirements_fulfilled M\n   \\<lparr>nodes = V, edges = E'\\<rparr>\n  generate_valid_topology M (fully_connected G) =\n  \\<lparr>nodes = V, edges = E\\<rparr>\n  wf_graph \\<lparr>nodes = V, edges = E'\\<rparr>\n  \\<not> E' \\<subseteq> E\n\ngoal (1 subgoal):\n 1. \\<And>V E V' E'.\n       \\<lbrakk>wf_graph \\<lparr>nodes = V', edges = E'\\<rparr>;\n        all_security_requirements_fulfilled M\n         \\<lparr>nodes = V', edges = E'\\<rparr>;\n        generate_valid_topology M (fully_connected G) =\n        \\<lparr>nodes = V', edges = E\\<rparr>;\n        V = V'; G' = \\<lparr>nodes = V', edges = E'\\<rparr>; nodes G = V';\n        \\<not> E' \\<subseteq> E\\<rbrakk>\n       \\<Longrightarrow> False", "from wfG a6"], ["proof (chain)\npicking this:\n  wf_graph G\n  generate_valid_topology M (fully_connected G) =\n  \\<lparr>nodes = V, edges = E\\<rparr>", "have \"wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\""], ["proof (prove)\nusing this:\n  wf_graph G\n  generate_valid_topology M (fully_connected G) =\n  \\<lparr>nodes = V, edges = E\\<rparr>\n\ngoal (1 subgoal):\n 1. wf_graph \\<lparr>nodes = V, edges = E\\<rparr>", "by (metis fully_connected_wf wf_graph_generate_valid_topology)"], ["proof (state)\nthis:\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>V E V' E'.\n       \\<lbrakk>wf_graph \\<lparr>nodes = V', edges = E'\\<rparr>;\n        all_security_requirements_fulfilled M\n         \\<lparr>nodes = V', edges = E'\\<rparr>;\n        generate_valid_topology M (fully_connected G) =\n        \\<lparr>nodes = V', edges = E\\<rparr>;\n        V = V'; G' = \\<lparr>nodes = V', edges = E'\\<rparr>; nodes G = V';\n        \\<not> E' \\<subseteq> E\\<rbrakk>\n       \\<Longrightarrow> False", "with a10"], ["proof (chain)\npicking this:\n  wf_graph \\<lparr>nodes = V, edges = E'\\<rparr>\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>", "have EE'subsets: \"fst ` E \\<subseteq> V \\<and> snd ` E \\<subseteq> V \\<and> fst ` E' \\<subseteq> V \\<and> snd ` E' \\<subseteq> V\""], ["proof (prove)\nusing this:\n  wf_graph \\<lparr>nodes = V, edges = E'\\<rparr>\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n\ngoal (1 subgoal):\n 1. fst ` E \\<subseteq> V \\<and>\n    snd ` E \\<subseteq> V \\<and>\n    fst ` E' \\<subseteq> V \\<and> snd ` E' \\<subseteq> V", "by(simp add: wf_graph_def)"], ["proof (state)\nthis:\n  fst ` E \\<subseteq> V \\<and>\n  snd ` E \\<subseteq> V \\<and>\n  fst ` E' \\<subseteq> V \\<and> snd ` E' \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<And>V E V' E'.\n       \\<lbrakk>wf_graph \\<lparr>nodes = V', edges = E'\\<rparr>;\n        all_security_requirements_fulfilled M\n         \\<lparr>nodes = V', edges = E'\\<rparr>;\n        generate_valid_topology M (fully_connected G) =\n        \\<lparr>nodes = V', edges = E\\<rparr>;\n        V = V'; G' = \\<lparr>nodes = V', edges = E'\\<rparr>; nodes G = V';\n        \\<not> E' \\<subseteq> E\\<rbrakk>\n       \\<Longrightarrow> False", "hence EE'subsets': \"E \\<subseteq> V \\<times> V \\<and> E' \\<subseteq> V \\<times> V\""], ["proof (prove)\nusing this:\n  fst ` E \\<subseteq> V \\<and>\n  snd ` E \\<subseteq> V \\<and>\n  fst ` E' \\<subseteq> V \\<and> snd ` E' \\<subseteq> V\n\ngoal (1 subgoal):\n 1. E \\<subseteq> V \\<times> V \\<and> E' \\<subseteq> V \\<times> V", "by auto"], ["proof (state)\nthis:\n  E \\<subseteq> V \\<times> V \\<and> E' \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. \\<And>V E V' E'.\n       \\<lbrakk>wf_graph \\<lparr>nodes = V', edges = E'\\<rparr>;\n        all_security_requirements_fulfilled M\n         \\<lparr>nodes = V', edges = E'\\<rparr>;\n        generate_valid_topology M (fully_connected G) =\n        \\<lparr>nodes = V', edges = E\\<rparr>;\n        V = V'; G' = \\<lparr>nodes = V', edges = E'\\<rparr>; nodes G = V';\n        \\<not> E' \\<subseteq> E\\<rbrakk>\n       \\<Longrightarrow> False", "from generate_valid_topology_max_topo[OF validRs wfG enf]"], ["proof (chain)\npicking this:\n  max_topo M (generate_valid_topology M (fully_connected G))", "have m1: \"all_security_requirements_fulfilled M \\<lparr>nodes = V, edges = E\\<rparr>\" and\n           m2: \"(\\<forall>x\\<in>V \\<times> V - E. case x of (v1, v2) \\<Rightarrow> \\<not> all_security_requirements_fulfilled M (add_edge v1 v2 \\<lparr>nodes = V, edges = E\\<rparr>))\""], ["proof (prove)\nusing this:\n  max_topo M (generate_valid_topology M (fully_connected G))\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled M\n     \\<lparr>nodes = V, edges = E\\<rparr> &&&\n    \\<forall>x\\<in>V \\<times> V - E.\n       case x of\n       (v1, v2) \\<Rightarrow>\n         \\<not> all_security_requirements_fulfilled M\n                 (add_edge v1 v2 \\<lparr>nodes = V, edges = E\\<rparr>)", "by(simp add: max_topo_def a6)+"], ["proof (state)\nthis:\n  all_security_requirements_fulfilled M \\<lparr>nodes = V, edges = E\\<rparr>\n  \\<forall>x\\<in>V \\<times> V - E.\n     case x of\n     (v1, v2) \\<Rightarrow>\n       \\<not> all_security_requirements_fulfilled M\n               (add_edge v1 v2 \\<lparr>nodes = V, edges = E\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>V E V' E'.\n       \\<lbrakk>wf_graph \\<lparr>nodes = V', edges = E'\\<rparr>;\n        all_security_requirements_fulfilled M\n         \\<lparr>nodes = V', edges = E'\\<rparr>;\n        generate_valid_topology M (fully_connected G) =\n        \\<lparr>nodes = V', edges = E\\<rparr>;\n        V = V'; G' = \\<lparr>nodes = V', edges = E'\\<rparr>; nodes G = V';\n        \\<not> E' \\<subseteq> E\\<rbrakk>\n       \\<Longrightarrow> False", "from m2"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>V \\<times> V - E.\n     case x of\n     (v1, v2) \\<Rightarrow>\n       \\<not> all_security_requirements_fulfilled M\n               (add_edge v1 v2 \\<lparr>nodes = V, edges = E\\<rparr>)", "have m2': \"\\<forall>x\\<in>V \\<times> V - E. \\<not> all_security_requirements_fulfilled M \\<lparr>nodes = V, edges = insert x E\\<rparr>\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>V \\<times> V - E.\n     case x of\n     (v1, v2) \\<Rightarrow>\n       \\<not> all_security_requirements_fulfilled M\n               (add_edge v1 v2 \\<lparr>nodes = V, edges = E\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>V \\<times> V - E.\n       \\<not> all_security_requirements_fulfilled M\n               \\<lparr>nodes = V, edges = insert x E\\<rparr>", "apply(simp add: add_edge_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>V \\<times> V - E.\n       case x of\n       (v1, v2) \\<Rightarrow>\n         \\<not> all_security_requirements_fulfilled M\n                 \\<lparr>nodes = insert v1 (insert v2 V),\n                    edges = insert (v1, v2) E\\<rparr> \\<Longrightarrow>\n    \\<forall>x\\<in>V \\<times> V - E.\n       \\<not> all_security_requirements_fulfilled M\n               \\<lparr>nodes = V, edges = insert x E\\<rparr>", "apply(rule ballI, rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>V \\<times> V - E.\n                   case x of\n                   (v1, v2) \\<Rightarrow>\n                     \\<not> all_security_requirements_fulfilled M\n                             \\<lparr>nodes = insert v1 (insert v2 V),\n                                edges = insert (v1, v2) E\\<rparr>;\n        x \\<in> V \\<times> V - E\\<rbrakk>\n       \\<Longrightarrow> \\<not> all_security_requirements_fulfilled M\n                                 \\<lparr>nodes = V,\n                                    edges = insert x E\\<rparr>", "apply(erule_tac x=x in ballE, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> V \\<times> V \\<and> x \\<notin> E;\n        case x of\n        (v1, v2) \\<Rightarrow>\n          \\<not> all_security_requirements_fulfilled M\n                  \\<lparr>nodes = insert v1 (insert v2 V),\n                     edges = insert (v1, v2) E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<not> all_security_requirements_fulfilled M\n                                 \\<lparr>nodes = V,\n                                    edges = insert x E\\<rparr>", "apply(case_tac x, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>a \\<in> V \\<and> b \\<in> V \\<and> (a, b) \\<notin> E;\n        \\<not> all_security_requirements_fulfilled M\n                \\<lparr>nodes = insert a (insert b V),\n                   edges = insert (a, b) E\\<rparr>;\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<not> all_security_requirements_fulfilled M\n                                 \\<lparr>nodes = V,\n                                    edges = insert (a, b) E\\<rparr>", "by (simp add: insert_absorb)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>V \\<times> V - E.\n     \\<not> all_security_requirements_fulfilled M\n             \\<lparr>nodes = V, edges = insert x E\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>V E V' E'.\n       \\<lbrakk>wf_graph \\<lparr>nodes = V', edges = E'\\<rparr>;\n        all_security_requirements_fulfilled M\n         \\<lparr>nodes = V', edges = E'\\<rparr>;\n        generate_valid_topology M (fully_connected G) =\n        \\<lparr>nodes = V', edges = E\\<rparr>;\n        V = V'; G' = \\<lparr>nodes = V', edges = E'\\<rparr>; nodes G = V';\n        \\<not> E' \\<subseteq> E\\<rbrakk>\n       \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases \"V = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. V = {} \\<Longrightarrow> False\n 2. V \\<noteq> {} \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  V = {}\n\ngoal (2 subgoals):\n 1. V = {} \\<Longrightarrow> False\n 2. V \\<noteq> {} \\<Longrightarrow> False", "with EE'subsets a10"], ["proof (chain)\npicking this:\n  fst ` E \\<subseteq> V \\<and>\n  snd ` E \\<subseteq> V \\<and>\n  fst ` E' \\<subseteq> V \\<and> snd ` E' \\<subseteq> V\n  wf_graph \\<lparr>nodes = V, edges = E'\\<rparr>\n  V = {}", "have \"E = {}\" and \"E' = {}\""], ["proof (prove)\nusing this:\n  fst ` E \\<subseteq> V \\<and>\n  snd ` E \\<subseteq> V \\<and>\n  fst ` E' \\<subseteq> V \\<and> snd ` E' \\<subseteq> V\n  wf_graph \\<lparr>nodes = V, edges = E'\\<rparr>\n  V = {}\n\ngoal (1 subgoal):\n 1. E = {} &&& E' = {}", "by(simp add: wf_graph_def)+"], ["proof (state)\nthis:\n  E = {}\n  E' = {}\n\ngoal (2 subgoals):\n 1. V = {} \\<Longrightarrow> False\n 2. V \\<noteq> {} \\<Longrightarrow> False", "with True contr"], ["proof (chain)\npicking this:\n  V = {}\n  \\<not> E' \\<subseteq> E\n  E = {}\n  E' = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  V = {}\n  \\<not> E' \\<subseteq> E\n  E = {}\n  E' = {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. V \\<noteq> {} \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. V \\<noteq> {} \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  V \\<noteq> {}\n\ngoal (1 subgoal):\n 1. V \\<noteq> {} \\<Longrightarrow> False", "with EE'subsets' contr"], ["proof (chain)\npicking this:\n  E \\<subseteq> V \\<times> V \\<and> E' \\<subseteq> V \\<times> V\n  \\<not> E' \\<subseteq> E\n  V \\<noteq> {}", "obtain x where x: \"x \\<in> E' \\<and> x \\<notin> E \\<and> x \\<in> V \\<times> V\""], ["proof (prove)\nusing this:\n  E \\<subseteq> V \\<times> V \\<and> E' \\<subseteq> V \\<times> V\n  \\<not> E' \\<subseteq> E\n  V \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> E' \\<and>\n        x \\<notin> E \\<and> x \\<in> V \\<times> V \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> E' \\<and> x \\<notin> E \\<and> x \\<in> V \\<times> V\n\ngoal (1 subgoal):\n 1. V \\<noteq> {} \\<Longrightarrow> False", "from m2' x"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>V \\<times> V - E.\n     \\<not> all_security_requirements_fulfilled M\n             \\<lparr>nodes = V, edges = insert x E\\<rparr>\n  x \\<in> E' \\<and> x \\<notin> E \\<and> x \\<in> V \\<times> V", "have \"\\<not> all_security_requirements_fulfilled M \\<lparr>nodes = V, edges = insert x E\\<rparr>\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>V \\<times> V - E.\n     \\<not> all_security_requirements_fulfilled M\n             \\<lparr>nodes = V, edges = insert x E\\<rparr>\n  x \\<in> E' \\<and> x \\<notin> E \\<and> x \\<in> V \\<times> V\n\ngoal (1 subgoal):\n 1. \\<not> all_security_requirements_fulfilled M\n            \\<lparr>nodes = V, edges = insert x E\\<rparr>", "by (simp)"], ["proof (state)\nthis:\n  \\<not> all_security_requirements_fulfilled M\n          \\<lparr>nodes = V, edges = insert x E\\<rparr>\n\ngoal (1 subgoal):\n 1. V \\<noteq> {} \\<Longrightarrow> False", "from a6 x"], ["proof (chain)\npicking this:\n  generate_valid_topology M (fully_connected G) =\n  \\<lparr>nodes = V, edges = E\\<rparr>\n  x \\<in> E' \\<and> x \\<notin> E \\<and> x \\<in> V \\<times> V", "have x_offedning: \"x \\<in> (\\<Union>m\\<in>set M. \\<Union>(c_offending_flows m (fully_connected G)))\""], ["proof (prove)\nusing this:\n  generate_valid_topology M (fully_connected G) =\n  \\<lparr>nodes = V, edges = E\\<rparr>\n  x \\<in> E' \\<and> x \\<notin> E \\<and> x \\<in> V \\<times> V\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>m\\<in>set M.\n                \\<Union> (c_offending_flows m (fully_connected G)))", "apply(simp add: generate_valid_topology_as_set delete_edges_simp2 fully_connected_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nodes G = V \\<and>\n             nodes G \\<times> nodes G -\n             (\\<Union>m\\<in>set M.\n                 \\<Union>\n                  (c_offending_flows m\n                    \\<lparr>nodes = nodes G,\n                       edges = nodes G \\<times> nodes G\\<rparr>)) =\n             E;\n     x \\<in> E' \\<and> x \\<notin> E \\<and> x \\<in> V \\<times> V\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xa\\<in>set M.\n                         \\<exists>X\\<in>c_offending_flows xa\n   \\<lparr>nodes = V, edges = V \\<times> V\\<rparr>.\n                            x \\<in> X", "by blast"], ["proof (state)\nthis:\n  x \\<in> (\\<Union>m\\<in>set M.\n              \\<Union> (c_offending_flows m (fully_connected G)))\n\ngoal (1 subgoal):\n 1. V \\<noteq> {} \\<Longrightarrow> False", "from enf_not_fulfilled_if_in_offending[OF validRs wfG enf] x_offedning"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>\\<Union>m\\<in>set M.\n                    \\<Union> (c_offending_flows m (fully_connected G)).\n     \\<not> all_security_requirements_fulfilled M\n             \\<lparr>nodes = ?V, edges = insert x ?E\\<rparr>\n  x \\<in> (\\<Union>m\\<in>set M.\n              \\<Union> (c_offending_flows m (fully_connected G)))", "have\n           1: \"\\<not> all_security_requirements_fulfilled M \\<lparr>nodes = V, edges = insert x myE\\<rparr>\" for myE"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>\\<Union>m\\<in>set M.\n                    \\<Union> (c_offending_flows m (fully_connected G)).\n     \\<not> all_security_requirements_fulfilled M\n             \\<lparr>nodes = ?V, edges = insert x ?E\\<rparr>\n  x \\<in> (\\<Union>m\\<in>set M.\n              \\<Union> (c_offending_flows m (fully_connected G)))\n\ngoal (1 subgoal):\n 1. \\<not> all_security_requirements_fulfilled M\n            \\<lparr>nodes = V, edges = insert x myE\\<rparr>", "by blast"], ["proof (state)\nthis:\n  \\<not> all_security_requirements_fulfilled M\n          \\<lparr>nodes = V, edges = insert x ?myE\\<rparr>\n\ngoal (1 subgoal):\n 1. V \\<noteq> {} \\<Longrightarrow> False", "from x"], ["proof (chain)\npicking this:\n  x \\<in> E' \\<and> x \\<notin> E \\<and> x \\<in> V \\<times> V", "have insertxE': \"insert x E' = E'\""], ["proof (prove)\nusing this:\n  x \\<in> E' \\<and> x \\<notin> E \\<and> x \\<in> V \\<times> V\n\ngoal (1 subgoal):\n 1. insert x E' = E'", "by blast"], ["proof (state)\nthis:\n  insert x E' = E'\n\ngoal (1 subgoal):\n 1. V \\<noteq> {} \\<Longrightarrow> False", "with a5"], ["proof (chain)\npicking this:\n  all_security_requirements_fulfilled M\n   \\<lparr>nodes = V, edges = E'\\<rparr>\n  insert x E' = E'", "have\n           \"all_security_requirements_fulfilled M \\<lparr>nodes = V, edges = insert x E'\\<rparr>\""], ["proof (prove)\nusing this:\n  all_security_requirements_fulfilled M\n   \\<lparr>nodes = V, edges = E'\\<rparr>\n  insert x E' = E'\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled M\n     \\<lparr>nodes = V, edges = insert x E'\\<rparr>", "by simp"], ["proof (state)\nthis:\n  all_security_requirements_fulfilled M\n   \\<lparr>nodes = V, edges = insert x E'\\<rparr>\n\ngoal (1 subgoal):\n 1. V \\<noteq> {} \\<Longrightarrow> False", "with insertxE' all_security_requirements_fulfilled_mono[OF validRs _ a10 a5]"], ["proof (chain)\npicking this:\n  insert x E' = E'\n  ?E' \\<subseteq> E' \\<Longrightarrow>\n  all_security_requirements_fulfilled M\n   \\<lparr>nodes = V, edges = ?E'\\<rparr>\n  all_security_requirements_fulfilled M\n   \\<lparr>nodes = V, edges = insert x E'\\<rparr>", "have \n           2: \"all_security_requirements_fulfilled M \\<lparr>nodes = V, edges = insert x {}\\<rparr>\""], ["proof (prove)\nusing this:\n  insert x E' = E'\n  ?E' \\<subseteq> E' \\<Longrightarrow>\n  all_security_requirements_fulfilled M\n   \\<lparr>nodes = V, edges = ?E'\\<rparr>\n  all_security_requirements_fulfilled M\n   \\<lparr>nodes = V, edges = insert x E'\\<rparr>\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled M\n     \\<lparr>nodes = V, edges = {x}\\<rparr>", "by blast"], ["proof (state)\nthis:\n  all_security_requirements_fulfilled M\n   \\<lparr>nodes = V, edges = {x}\\<rparr>\n\ngoal (1 subgoal):\n 1. V \\<noteq> {} \\<Longrightarrow> False", "from 1 2"], ["proof (chain)\npicking this:\n  \\<not> all_security_requirements_fulfilled M\n          \\<lparr>nodes = V, edges = insert x ?myE\\<rparr>\n  all_security_requirements_fulfilled M\n   \\<lparr>nodes = V, edges = {x}\\<rparr>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> all_security_requirements_fulfilled M\n          \\<lparr>nodes = V, edges = insert x ?myE\\<rparr>\n  all_security_requirements_fulfilled M\n   \\<lparr>nodes = V, edges = {x}\\<rparr>\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>More Lemmata\\<close>"], ["", "lemma (in configured_SecurityInvariant) c_sinvar_valid_imp_no_offending_flows: \n      \"c_sinvar m G \\<Longrightarrow> c_offending_flows m G = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_sinvar m G \\<Longrightarrow> c_offending_flows m G = {}", "by(simp add: valid_c_offending_flows)"], ["", "lemma all_security_requirements_fulfilled_imp_no_offending_flows:\n        \"valid_reqs M \\<Longrightarrow> all_security_requirements_fulfilled M G \\<Longrightarrow> (\\<Union>m\\<in>set M. \\<Union>(c_offending_flows m G)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; all_security_requirements_fulfilled M G\\<rbrakk>\n    \\<Longrightarrow> (\\<Union>m\\<in>set M.\n                          \\<Union> (c_offending_flows m G)) =\n                      {}", "proof(induction M)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_reqs [];\n     all_security_requirements_fulfilled [] G\\<rbrakk>\n    \\<Longrightarrow> (\\<Union>m\\<in>set [].\n                          \\<Union> (c_offending_flows m G)) =\n                      {}\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 all_security_requirements_fulfilled M G\\<rbrakk>\n                \\<Longrightarrow> (\\<Union>m\\<in>set M.\n\\<Union> (c_offending_flows m G)) =\n                                  {};\n        valid_reqs (a # M);\n        all_security_requirements_fulfilled (a # M) G\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>m\\<in>set (a # M).\n                             \\<Union> (c_offending_flows m G)) =\n                         {}", "case Cons"], ["proof (state)\nthis:\n  \\<lbrakk>valid_reqs M_; all_security_requirements_fulfilled M_ G\\<rbrakk>\n  \\<Longrightarrow> (\\<Union>m\\<in>set M_.\n                        \\<Union> (c_offending_flows m G)) =\n                    {}\n  valid_reqs (a_ # M_)\n  all_security_requirements_fulfilled (a_ # M_) G\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_reqs [];\n     all_security_requirements_fulfilled [] G\\<rbrakk>\n    \\<Longrightarrow> (\\<Union>m\\<in>set [].\n                          \\<Union> (c_offending_flows m G)) =\n                      {}\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 all_security_requirements_fulfilled M G\\<rbrakk>\n                \\<Longrightarrow> (\\<Union>m\\<in>set M.\n\\<Union> (c_offending_flows m G)) =\n                                  {};\n        valid_reqs (a # M);\n        all_security_requirements_fulfilled (a # M) G\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>m\\<in>set (a # M).\n                             \\<Union> (c_offending_flows m G)) =\n                         {}", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_reqs M_; all_security_requirements_fulfilled M_ G\\<rbrakk>\n  \\<Longrightarrow> (\\<Union>m\\<in>set M_.\n                        \\<Union> (c_offending_flows m G)) =\n                    {}\n  valid_reqs (a_ # M_)\n  all_security_requirements_fulfilled (a_ # M_) G\n\ngoal (1 subgoal):\n 1. (\\<Union>m\\<in>set (a_ # M_). \\<Union> (c_offending_flows m G)) = {}", "unfolding all_security_requirements_fulfilled_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_reqs M_; \\<forall>m\\<in>set M_. c_sinvar m G\\<rbrakk>\n  \\<Longrightarrow> (\\<Union>m\\<in>set M_.\n                        \\<Union> (c_offending_flows m G)) =\n                    {}\n  valid_reqs (a_ # M_)\n  \\<forall>m\\<in>set (a_ # M_). c_sinvar m G\n\ngoal (1 subgoal):\n 1. (\\<Union>m\\<in>set (a_ # M_). \\<Union> (c_offending_flows m G)) = {}", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M_ \\<Longrightarrow>\n             \\<forall>x\\<in>set M_.\n                \\<forall>x\\<in>c_offending_flows x G. x = {};\n     valid_reqs (a_ # M_);\n     c_sinvar a_ G \\<and> (\\<forall>m\\<in>set M_. c_sinvar m G)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x\\<in>c_offending_flows a_ G. x = {}) \\<and>\n                      (\\<forall>x\\<in>set M_.\n                          \\<forall>x\\<in>c_offending_flows x G. x = {})", "by(blast dest: valid_reqs2 valid_reqs1 configured_SecurityInvariant.c_sinvar_valid_imp_no_offending_flows)"], ["proof (state)\nthis:\n  (\\<Union>m\\<in>set (a_ # M_). \\<Union> (c_offending_flows m G)) = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs [];\n     all_security_requirements_fulfilled [] G\\<rbrakk>\n    \\<Longrightarrow> (\\<Union>m\\<in>set [].\n                          \\<Union> (c_offending_flows m G)) =\n                      {}", "qed(simp)"], ["", "corollary all_security_requirements_fulfilled_imp_get_offending_empty:\n      \"valid_reqs M \\<Longrightarrow> all_security_requirements_fulfilled M G \\<Longrightarrow> get_offending_flows M G = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; all_security_requirements_fulfilled M G\\<rbrakk>\n    \\<Longrightarrow> get_offending_flows M G = {}", "apply(frule(1) all_security_requirements_fulfilled_imp_no_offending_flows)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; all_security_requirements_fulfilled M G;\n     (\\<Union>m\\<in>set M. \\<Union> (c_offending_flows m G)) = {}\\<rbrakk>\n    \\<Longrightarrow> get_offending_flows M G = {}", "apply(simp add: get_offending_flows_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; all_security_requirements_fulfilled M G;\n     \\<forall>x\\<in>set M.\n        \\<forall>x\\<in>c_offending_flows x G. x = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set M. c_offending_flows x G = {}", "apply(thin_tac \"all_security_requirements_fulfilled M G\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M;\n     \\<forall>x\\<in>set M.\n        \\<forall>x\\<in>c_offending_flows x G. x = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set M. c_offending_flows x G = {}", "apply(simp add: valid_reqs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>m\\<in>set M. configured_SecurityInvariant m;\n     \\<forall>x\\<in>set M.\n        \\<forall>x\\<in>c_offending_flows x G. x = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set M. c_offending_flows x G = {}", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>m\\<in>set M. configured_SecurityInvariant m;\n        \\<forall>x\\<in>set M. \\<forall>x\\<in>c_offending_flows x G. x = {};\n        x \\<in> set M\\<rbrakk>\n       \\<Longrightarrow> c_offending_flows x G = {}", "using configured_SecurityInvariant.empty_offending_contra"], ["proof (prove)\nusing this:\n  \\<lbrakk>configured_SecurityInvariant ?m;\n   ?F \\<in> c_offending_flows ?m ?G; ?F = {}\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>m\\<in>set M. configured_SecurityInvariant m;\n        \\<forall>x\\<in>set M. \\<forall>x\\<in>c_offending_flows x G. x = {};\n        x \\<in> set M\\<rbrakk>\n       \\<Longrightarrow> c_offending_flows x G = {}", "by fastforce"], ["", "corollary generate_valid_topology_does_nothing_if_valid:\n      \"\\<lbrakk> valid_reqs M; all_security_requirements_fulfilled M G\\<rbrakk> \\<Longrightarrow> \n          generate_valid_topology M G = G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; all_security_requirements_fulfilled M G\\<rbrakk>\n    \\<Longrightarrow> generate_valid_topology M G = G", "by(simp add: generate_valid_topology_as_set graph_ops all_security_requirements_fulfilled_imp_no_offending_flows)"], ["", "lemma mono_extend_get_offending_flows: \"\\<lbrakk> valid_reqs M;\n         wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n         E' \\<subseteq> E;\n         F' \\<in> get_offending_flows M \\<lparr>nodes = V, edges = E'\\<rparr> \\<rbrakk> \\<Longrightarrow>\n       \\<exists>F\\<in>get_offending_flows M \\<lparr>nodes = V, edges = E\\<rparr>. F' \\<subseteq> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     F' \\<in> get_offending_flows M\n               \\<lparr>nodes = V, edges = E'\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F\\<in>get_offending_flows M\n\\<lparr>nodes = V, edges = E\\<rparr>.\n                         F' \\<subseteq> F", "proof(induction M)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_reqs []; wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     F' \\<in> get_offending_flows []\n               \\<lparr>nodes = V, edges = E'\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> Bex (get_offending_flows []\n                            \\<lparr>nodes = V, edges = E\\<rparr>)\n                       ((\\<subseteq>) F')\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                 E' \\<subseteq> E;\n                 F' \\<in> get_offending_flows M\n                           \\<lparr>nodes = V, edges = E'\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> Bex (get_offending_flows M\n  \\<lparr>nodes = V, edges = E\\<rparr>)\n                                   ((\\<subseteq>) F');\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        F' \\<in> get_offending_flows (a # M)\n                  \\<lparr>nodes = V, edges = E'\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Bex (get_offending_flows (a # M)\n                               \\<lparr>nodes = V, edges = E\\<rparr>)\n                          ((\\<subseteq>) F')", "case Nil"], ["proof (state)\nthis:\n  valid_reqs []\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n  E' \\<subseteq> E\n  F' \\<in> get_offending_flows [] \\<lparr>nodes = V, edges = E'\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_reqs []; wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     F' \\<in> get_offending_flows []\n               \\<lparr>nodes = V, edges = E'\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> Bex (get_offending_flows []\n                            \\<lparr>nodes = V, edges = E\\<rparr>)\n                       ((\\<subseteq>) F')\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                 E' \\<subseteq> E;\n                 F' \\<in> get_offending_flows M\n                           \\<lparr>nodes = V, edges = E'\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> Bex (get_offending_flows M\n  \\<lparr>nodes = V, edges = E\\<rparr>)\n                                   ((\\<subseteq>) F');\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        F' \\<in> get_offending_flows (a # M)\n                  \\<lparr>nodes = V, edges = E'\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Bex (get_offending_flows (a # M)\n                               \\<lparr>nodes = V, edges = E\\<rparr>)\n                          ((\\<subseteq>) F')", "thus ?case"], ["proof (prove)\nusing this:\n  valid_reqs []\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n  E' \\<subseteq> E\n  F' \\<in> get_offending_flows [] \\<lparr>nodes = V, edges = E'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>get_offending_flows []\n                    \\<lparr>nodes = V, edges = E\\<rparr>.\n       F' \\<subseteq> a", "by(simp add: get_offending_flows_def)"], ["proof (state)\nthis:\n  \\<exists>a\\<in>get_offending_flows []\n                  \\<lparr>nodes = V, edges = E\\<rparr>.\n     F' \\<subseteq> a\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                 E' \\<subseteq> E;\n                 F' \\<in> get_offending_flows M\n                           \\<lparr>nodes = V, edges = E'\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> Bex (get_offending_flows M\n  \\<lparr>nodes = V, edges = E\\<rparr>)\n                                   ((\\<subseteq>) F');\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        F' \\<in> get_offending_flows (a # M)\n                  \\<lparr>nodes = V, edges = E'\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Bex (get_offending_flows (a # M)\n                               \\<lparr>nodes = V, edges = E\\<rparr>)\n                          ((\\<subseteq>) F')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                 E' \\<subseteq> E;\n                 F' \\<in> get_offending_flows M\n                           \\<lparr>nodes = V, edges = E'\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> Bex (get_offending_flows M\n  \\<lparr>nodes = V, edges = E\\<rparr>)\n                                   ((\\<subseteq>) F');\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        F' \\<in> get_offending_flows (a # M)\n                  \\<lparr>nodes = V, edges = E'\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Bex (get_offending_flows (a # M)\n                               \\<lparr>nodes = V, edges = E\\<rparr>)\n                          ((\\<subseteq>) F')", "case (Cons m M)"], ["proof (state)\nthis:\n  \\<lbrakk>valid_reqs M; wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n   E' \\<subseteq> E;\n   F' \\<in> get_offending_flows M\n             \\<lparr>nodes = V, edges = E'\\<rparr>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a\\<in>get_offending_flows M\n                                    \\<lparr>nodes = V, edges = E\\<rparr>.\n                       F' \\<subseteq> a\n  valid_reqs (m # M)\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n  E' \\<subseteq> E\n  F' \\<in> get_offending_flows (m # M) \\<lparr>nodes = V, edges = E'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                 E' \\<subseteq> E;\n                 F' \\<in> get_offending_flows M\n                           \\<lparr>nodes = V, edges = E'\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> Bex (get_offending_flows M\n  \\<lparr>nodes = V, edges = E\\<rparr>)\n                                   ((\\<subseteq>) F');\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        F' \\<in> get_offending_flows (a # M)\n                  \\<lparr>nodes = V, edges = E'\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Bex (get_offending_flows (a # M)\n                               \\<lparr>nodes = V, edges = E\\<rparr>)\n                          ((\\<subseteq>) F')", "from Cons.prems"], ["proof (chain)\npicking this:\n  valid_reqs (m # M)\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n  E' \\<subseteq> E\n  F' \\<in> get_offending_flows (m # M) \\<lparr>nodes = V, edges = E'\\<rparr>", "have \"configured_SecurityInvariant m\"\n                       and \"valid_reqs M\""], ["proof (prove)\nusing this:\n  valid_reqs (m # M)\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n  E' \\<subseteq> E\n  F' \\<in> get_offending_flows (m # M) \\<lparr>nodes = V, edges = E'\\<rparr>\n\ngoal (1 subgoal):\n 1. configured_SecurityInvariant m &&& valid_reqs M", "using valid_reqs2 valid_reqs1"], ["proof (prove)\nusing this:\n  valid_reqs (m # M)\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n  E' \\<subseteq> E\n  F' \\<in> get_offending_flows (m # M) \\<lparr>nodes = V, edges = E'\\<rparr>\n  valid_reqs (?m # ?M) \\<Longrightarrow> valid_reqs ?M\n  valid_reqs (?m # ?M) \\<Longrightarrow> configured_SecurityInvariant ?m\n\ngoal (1 subgoal):\n 1. configured_SecurityInvariant m &&& valid_reqs M", "by blast+"], ["proof (state)\nthis:\n  configured_SecurityInvariant m\n  valid_reqs M\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                 E' \\<subseteq> E;\n                 F' \\<in> get_offending_flows M\n                           \\<lparr>nodes = V, edges = E'\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> Bex (get_offending_flows M\n  \\<lparr>nodes = V, edges = E\\<rparr>)\n                                   ((\\<subseteq>) F');\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        F' \\<in> get_offending_flows (a # M)\n                  \\<lparr>nodes = V, edges = E'\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Bex (get_offending_flows (a # M)\n                               \\<lparr>nodes = V, edges = E\\<rparr>)\n                          ((\\<subseteq>) F')", "from Cons.prems(4)"], ["proof (chain)\npicking this:\n  F' \\<in> get_offending_flows (m # M) \\<lparr>nodes = V, edges = E'\\<rparr>", "have\n        \"F' \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E'\\<rparr> \\<or>\n         (F' \\<in> get_offending_flows M \\<lparr>nodes = V, edges = E'\\<rparr>)\""], ["proof (prove)\nusing this:\n  F' \\<in> get_offending_flows (m # M) \\<lparr>nodes = V, edges = E'\\<rparr>\n\ngoal (1 subgoal):\n 1. F' \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E'\\<rparr> \\<or>\n    F' \\<in> get_offending_flows M \\<lparr>nodes = V, edges = E'\\<rparr>", "by(simp add: get_offending_flows_def)"], ["proof (state)\nthis:\n  F' \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E'\\<rparr> \\<or>\n  F' \\<in> get_offending_flows M \\<lparr>nodes = V, edges = E'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                 E' \\<subseteq> E;\n                 F' \\<in> get_offending_flows M\n                           \\<lparr>nodes = V, edges = E'\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> Bex (get_offending_flows M\n  \\<lparr>nodes = V, edges = E\\<rparr>)\n                                   ((\\<subseteq>) F');\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        F' \\<in> get_offending_flows (a # M)\n                  \\<lparr>nodes = V, edges = E'\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> Bex (get_offending_flows (a # M)\n                               \\<lparr>nodes = V, edges = E\\<rparr>)\n                          ((\\<subseteq>) F')", "from this"], ["proof (chain)\npicking this:\n  F' \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E'\\<rparr> \\<or>\n  F' \\<in> get_offending_flows M \\<lparr>nodes = V, edges = E'\\<rparr>", "show ?case"], ["proof (prove)\nusing this:\n  F' \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E'\\<rparr> \\<or>\n  F' \\<in> get_offending_flows M \\<lparr>nodes = V, edges = E'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>get_offending_flows (m # M)\n                    \\<lparr>nodes = V, edges = E\\<rparr>.\n       F' \\<subseteq> a", "proof(elim disjE, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. F' \\<in> c_offending_flows m\n              \\<lparr>nodes = V, edges = E'\\<rparr> \\<Longrightarrow>\n    \\<exists>a\\<in>get_offending_flows (m # M)\n                    \\<lparr>nodes = V, edges = E\\<rparr>.\n       F' \\<subseteq> a\n 2. F' \\<in> get_offending_flows M\n              \\<lparr>nodes = V, edges = E'\\<rparr> \\<Longrightarrow>\n    \\<exists>a\\<in>get_offending_flows (m # M)\n                    \\<lparr>nodes = V, edges = E\\<rparr>.\n       F' \\<subseteq> a", "case 1"], ["proof (state)\nthis:\n  F' \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E'\\<rparr>\n\ngoal (2 subgoals):\n 1. F' \\<in> c_offending_flows m\n              \\<lparr>nodes = V, edges = E'\\<rparr> \\<Longrightarrow>\n    \\<exists>a\\<in>get_offending_flows (m # M)\n                    \\<lparr>nodes = V, edges = E\\<rparr>.\n       F' \\<subseteq> a\n 2. F' \\<in> get_offending_flows M\n              \\<lparr>nodes = V, edges = E'\\<rparr> \\<Longrightarrow>\n    \\<exists>a\\<in>get_offending_flows (m # M)\n                    \\<lparr>nodes = V, edges = E\\<rparr>.\n       F' \\<subseteq> a", "with \\<open>configured_SecurityInvariant m\\<close> Cons.prems(2,3,4)"], ["proof (chain)\npicking this:\n  configured_SecurityInvariant m\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n  E' \\<subseteq> E\n  F' \\<in> get_offending_flows (m # M) \\<lparr>nodes = V, edges = E'\\<rparr>\n  F' \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E'\\<rparr>", "obtain F where\n           \"F\\<in>c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>\" and \"F' \\<subseteq> F\""], ["proof (prove)\nusing this:\n  configured_SecurityInvariant m\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n  E' \\<subseteq> E\n  F' \\<in> get_offending_flows (m # M) \\<lparr>nodes = V, edges = E'\\<rparr>\n  F' \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E'\\<rparr>\n\ngoal (1 subgoal):\n 1. (\\<And>F.\n        \\<lbrakk>F \\<in> c_offending_flows m\n                          \\<lparr>nodes = V, edges = E\\<rparr>;\n         F' \\<subseteq> F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(blast dest: configured_SecurityInvariant.mono_extend_set_offending_flows)"], ["proof (state)\nthis:\n  F \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>\n  F' \\<subseteq> F\n\ngoal (2 subgoals):\n 1. F' \\<in> c_offending_flows m\n              \\<lparr>nodes = V, edges = E'\\<rparr> \\<Longrightarrow>\n    \\<exists>a\\<in>get_offending_flows (m # M)\n                    \\<lparr>nodes = V, edges = E\\<rparr>.\n       F' \\<subseteq> a\n 2. F' \\<in> get_offending_flows M\n              \\<lparr>nodes = V, edges = E'\\<rparr> \\<Longrightarrow>\n    \\<exists>a\\<in>get_offending_flows (m # M)\n                    \\<lparr>nodes = V, edges = E\\<rparr>.\n       F' \\<subseteq> a", "hence \"F\\<in>get_offending_flows (m # M) \\<lparr>nodes = V, edges = E\\<rparr>\""], ["proof (prove)\nusing this:\n  F \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>\n  F' \\<subseteq> F\n\ngoal (1 subgoal):\n 1. F \\<in> get_offending_flows (m # M) \\<lparr>nodes = V, edges = E\\<rparr>", "by (simp add: get_offending_flows_def)"], ["proof (state)\nthis:\n  F \\<in> get_offending_flows (m # M) \\<lparr>nodes = V, edges = E\\<rparr>\n\ngoal (2 subgoals):\n 1. F' \\<in> c_offending_flows m\n              \\<lparr>nodes = V, edges = E'\\<rparr> \\<Longrightarrow>\n    \\<exists>a\\<in>get_offending_flows (m # M)\n                    \\<lparr>nodes = V, edges = E\\<rparr>.\n       F' \\<subseteq> a\n 2. F' \\<in> get_offending_flows M\n              \\<lparr>nodes = V, edges = E'\\<rparr> \\<Longrightarrow>\n    \\<exists>a\\<in>get_offending_flows (m # M)\n                    \\<lparr>nodes = V, edges = E\\<rparr>.\n       F' \\<subseteq> a", "with \\<open>F' \\<subseteq> F\\<close>"], ["proof (chain)\npicking this:\n  F' \\<subseteq> F\n  F \\<in> get_offending_flows (m # M) \\<lparr>nodes = V, edges = E\\<rparr>", "show ?case"], ["proof (prove)\nusing this:\n  F' \\<subseteq> F\n  F \\<in> get_offending_flows (m # M) \\<lparr>nodes = V, edges = E\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>get_offending_flows (m # M)\n                    \\<lparr>nodes = V, edges = E\\<rparr>.\n       F' \\<subseteq> a", "by blast"], ["proof (state)\nthis:\n  \\<exists>a\\<in>get_offending_flows (m # M)\n                  \\<lparr>nodes = V, edges = E\\<rparr>.\n     F' \\<subseteq> a\n\ngoal (1 subgoal):\n 1. F' \\<in> get_offending_flows M\n              \\<lparr>nodes = V, edges = E'\\<rparr> \\<Longrightarrow>\n    \\<exists>a\\<in>get_offending_flows (m # M)\n                    \\<lparr>nodes = V, edges = E\\<rparr>.\n       F' \\<subseteq> a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. F' \\<in> get_offending_flows M\n              \\<lparr>nodes = V, edges = E'\\<rparr> \\<Longrightarrow>\n    \\<exists>a\\<in>get_offending_flows (m # M)\n                    \\<lparr>nodes = V, edges = E\\<rparr>.\n       F' \\<subseteq> a", "case 2"], ["proof (state)\nthis:\n  F' \\<in> get_offending_flows M \\<lparr>nodes = V, edges = E'\\<rparr>\n\ngoal (1 subgoal):\n 1. F' \\<in> get_offending_flows M\n              \\<lparr>nodes = V, edges = E'\\<rparr> \\<Longrightarrow>\n    \\<exists>a\\<in>get_offending_flows (m # M)\n                    \\<lparr>nodes = V, edges = E\\<rparr>.\n       F' \\<subseteq> a", "with Cons \\<open>valid_reqs M\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>valid_reqs M; wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n   E' \\<subseteq> E;\n   F' \\<in> get_offending_flows M\n             \\<lparr>nodes = V, edges = E'\\<rparr>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a\\<in>get_offending_flows M\n                                    \\<lparr>nodes = V, edges = E\\<rparr>.\n                       F' \\<subseteq> a\n  valid_reqs (m # M)\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n  E' \\<subseteq> E\n  F' \\<in> get_offending_flows (m # M) \\<lparr>nodes = V, edges = E'\\<rparr>\n  valid_reqs M\n  F' \\<in> get_offending_flows M \\<lparr>nodes = V, edges = E'\\<rparr>", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_reqs M; wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n   E' \\<subseteq> E;\n   F' \\<in> get_offending_flows M\n             \\<lparr>nodes = V, edges = E'\\<rparr>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a\\<in>get_offending_flows M\n                                    \\<lparr>nodes = V, edges = E\\<rparr>.\n                       F' \\<subseteq> a\n  valid_reqs (m # M)\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n  E' \\<subseteq> E\n  F' \\<in> get_offending_flows (m # M) \\<lparr>nodes = V, edges = E'\\<rparr>\n  valid_reqs M\n  F' \\<in> get_offending_flows M \\<lparr>nodes = V, edges = E'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>get_offending_flows (m # M)\n                    \\<lparr>nodes = V, edges = E\\<rparr>.\n       F' \\<subseteq> a", "by(simp add: get_offending_flows_def) blast"], ["proof (state)\nthis:\n  \\<exists>a\\<in>get_offending_flows (m # M)\n                  \\<lparr>nodes = V, edges = E\\<rparr>.\n     F' \\<subseteq> a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a\\<in>get_offending_flows (m # M)\n                  \\<lparr>nodes = V, edges = E\\<rparr>.\n     F' \\<subseteq> a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma get_offending_flows_subseteq_edges: \"valid_reqs M \\<Longrightarrow> F \\<in> get_offending_flows M \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow> F \\<subseteq> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M;\n     F \\<in> get_offending_flows M\n              \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> F \\<subseteq> E", "apply(induction M)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_reqs [];\n     F \\<in> get_offending_flows []\n              \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> F \\<subseteq> E\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 F \\<in> get_offending_flows M\n                          \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> F \\<subseteq> E;\n        valid_reqs (a # M);\n        F \\<in> get_offending_flows (a # M)\n                 \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> F \\<subseteq> E", "apply(simp add: get_offending_flows_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 F \\<in> get_offending_flows M\n                          \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> F \\<subseteq> E;\n        valid_reqs (a # M);\n        F \\<in> get_offending_flows (a # M)\n                 \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> F \\<subseteq> E", "apply(simp add: get_offending_flows_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 \\<exists>x\\<in>set M.\n                    F \\<in> c_offending_flows x\n                             \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> F \\<subseteq> E;\n        valid_reqs (a # M);\n        F \\<in> c_offending_flows a\n                 \\<lparr>nodes = V, edges = E\\<rparr> \\<or>\n        (\\<exists>x\\<in>set M.\n            F \\<in> c_offending_flows x\n                     \\<lparr>nodes = V, edges = E\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> F \\<subseteq> E", "apply(frule valid_reqs2, drule valid_reqs1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 \\<exists>x\\<in>set M.\n                    F \\<in> c_offending_flows x\n                             \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> F \\<subseteq> E;\n        F \\<in> c_offending_flows a\n                 \\<lparr>nodes = V, edges = E\\<rparr> \\<or>\n        (\\<exists>x\\<in>set M.\n            F \\<in> c_offending_flows x\n                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs M; configured_SecurityInvariant a\\<rbrakk>\n       \\<Longrightarrow> F \\<subseteq> E", "apply(simp add: configured_SecurityInvariant.valid_c_offending_flows)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<exists>x\\<in>set M.\n                   F \\<in> c_offending_flows x\n                            \\<lparr>nodes = V,\n                               edges = E\\<rparr> \\<Longrightarrow>\n                F \\<subseteq> E;\n        F \\<subseteq> E \\<and>\n        \\<not> c_sinvar a \\<lparr>nodes = V, edges = E\\<rparr> \\<and>\n        c_sinvar a\n         (delete_edges \\<lparr>nodes = V, edges = E\\<rparr> F) \\<and>\n        (\\<forall>x\\<in>F.\n            case x of\n            (e1, e2) \\<Rightarrow>\n              \\<not> c_sinvar a\n                      (add_edge e1 e2\n                        (delete_edges \\<lparr>nodes = V, edges = E\\<rparr>\n                          F))) \\<or>\n        (\\<exists>x\\<in>set M.\n            F \\<in> c_offending_flows x\n                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs M; configured_SecurityInvariant a\\<rbrakk>\n       \\<Longrightarrow> F \\<subseteq> E", "by blast"], ["", "thm configured_SecurityInvariant.offending_flows_union_mono"], ["", "lemma get_offending_flows_union_mono: \"\\<lbrakk>valid_reqs M; \n      wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; E' \\<subseteq> E \\<rbrakk> \\<Longrightarrow>\n      \\<Union>(get_offending_flows M \\<lparr>nodes = V, edges = E'\\<rparr>) \\<subseteq> \\<Union>(get_offending_flows M \\<lparr>nodes = V, edges = E\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E\\<rbrakk>\n    \\<Longrightarrow> \\<Union>\n                       (get_offending_flows M\n                         \\<lparr>nodes = V, edges = E'\\<rparr>)\n                      \\<subseteq> \\<Union>\n                                   (get_offending_flows M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>)", "apply(induction M)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_reqs []; wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E\\<rbrakk>\n    \\<Longrightarrow> \\<Union>\n                       (get_offending_flows []\n                         \\<lparr>nodes = V, edges = E'\\<rparr>)\n                      \\<subseteq> \\<Union>\n                                   (get_offending_flows []\n                                     \\<lparr>nodes = V, edges = E\\<rparr>)\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                 E' \\<subseteq> E\\<rbrakk>\n                \\<Longrightarrow> \\<Union>\n                                   (get_offending_flows M\n                                     \\<lparr>nodes = V, edges = E'\\<rparr>)\n                                  \\<subseteq> \\<Union>\n         (get_offending_flows M \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        E' \\<subseteq> E\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (get_offending_flows (a # M)\n                            \\<lparr>nodes = V, edges = E'\\<rparr>)\n                         \\<subseteq> \\<Union>\n(get_offending_flows (a # M) \\<lparr>nodes = V, edges = E\\<rparr>)", "apply(simp add: get_offending_flows_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                 E' \\<subseteq> E\\<rbrakk>\n                \\<Longrightarrow> \\<Union>\n                                   (get_offending_flows M\n                                     \\<lparr>nodes = V, edges = E'\\<rparr>)\n                                  \\<subseteq> \\<Union>\n         (get_offending_flows M \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        E' \\<subseteq> E\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (get_offending_flows (a # M)\n                            \\<lparr>nodes = V, edges = E'\\<rparr>)\n                         \\<subseteq> \\<Union>\n(get_offending_flows (a # M) \\<lparr>nodes = V, edges = E\\<rparr>)", "apply(frule valid_reqs2, drule valid_reqs1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                 E' \\<subseteq> E\\<rbrakk>\n                \\<Longrightarrow> \\<Union>\n                                   (get_offending_flows M\n                                     \\<lparr>nodes = V, edges = E'\\<rparr>)\n                                  \\<subseteq> \\<Union>\n         (get_offending_flows M \\<lparr>nodes = V, edges = E\\<rparr>);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; E' \\<subseteq> E;\n        valid_reqs M; configured_SecurityInvariant a\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (get_offending_flows (a # M)\n                            \\<lparr>nodes = V, edges = E'\\<rparr>)\n                         \\<subseteq> \\<Union>\n(get_offending_flows (a # M) \\<lparr>nodes = V, edges = E\\<rparr>)", "apply(drule(2) configured_SecurityInvariant.offending_flows_union_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                 E' \\<subseteq> E\\<rbrakk>\n                \\<Longrightarrow> \\<Union>\n                                   (get_offending_flows M\n                                     \\<lparr>nodes = V, edges = E'\\<rparr>)\n                                  \\<subseteq> \\<Union>\n         (get_offending_flows M \\<lparr>nodes = V, edges = E\\<rparr>);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; E' \\<subseteq> E;\n        valid_reqs M;\n        \\<Union> (c_offending_flows a \\<lparr>nodes = V, edges = E'\\<rparr>)\n        \\<subseteq> \\<Union>\n                     (c_offending_flows a\n                       \\<lparr>nodes = V, edges = E\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (get_offending_flows (a # M)\n                            \\<lparr>nodes = V, edges = E'\\<rparr>)\n                         \\<subseteq> \\<Union>\n(get_offending_flows (a # M) \\<lparr>nodes = V, edges = E\\<rparr>)", "apply(simp add: get_offending_flows_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<Union>\n                 (\\<Union>m\\<in>set M.\n                     c_offending_flows m\n                      \\<lparr>nodes = V, edges = E'\\<rparr>)\n                \\<subseteq> \\<Union>\n                             (\\<Union>m\\<in>set M.\n                                 c_offending_flows m\n                                  \\<lparr>nodes = V, edges = E\\<rparr>);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; E' \\<subseteq> E;\n        valid_reqs M;\n        \\<Union> (c_offending_flows a \\<lparr>nodes = V, edges = E'\\<rparr>)\n        \\<subseteq> \\<Union>\n                     (c_offending_flows a\n                       \\<lparr>nodes = V, edges = E\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (c_offending_flows a\n                            \\<lparr>nodes = V, edges = E'\\<rparr>)\n                         \\<subseteq> \\<Union>\n(c_offending_flows a \\<lparr>nodes = V, edges = E\\<rparr>) \\<union>\n                                     \\<Union>\n(\\<Union>x\\<in>set M.\n    c_offending_flows x \\<lparr>nodes = V, edges = E\\<rparr>) \\<and>\n                         \\<Union>\n                          (\\<Union>x\\<in>set M.\n                              c_offending_flows x\n                               \\<lparr>nodes = V, edges = E'\\<rparr>)\n                         \\<subseteq> \\<Union>\n(c_offending_flows a \\<lparr>nodes = V, edges = E\\<rparr>) \\<union>\n                                     \\<Union>\n(\\<Union>x\\<in>set M.\n    c_offending_flows x \\<lparr>nodes = V, edges = E\\<rparr>)", "by auto"], ["", "thm configured_SecurityInvariant.Un_set_offending_flows_bound_minus_subseteq'"], ["", "lemma Un_set_offending_flows_bound_minus_subseteq':\"\\<lbrakk>valid_reqs M; \n      wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; E' \\<subseteq> E;\n      \\<Union>(get_offending_flows M \\<lparr>nodes = V, edges = E\\<rparr>) \\<subseteq> X \\<rbrakk> \\<Longrightarrow> \\<Union>(get_offending_flows M \\<lparr>nodes = V, edges = E - E'\\<rparr>) \\<subseteq> X - E'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     \\<Union> (get_offending_flows M \\<lparr>nodes = V, edges = E\\<rparr>)\n     \\<subseteq> X\\<rbrakk>\n    \\<Longrightarrow> \\<Union>\n                       (get_offending_flows M\n                         \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n                      \\<subseteq> X - E'", "proof(induction M)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_reqs []; wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     \\<Union> (get_offending_flows [] \\<lparr>nodes = V, edges = E\\<rparr>)\n     \\<subseteq> X\\<rbrakk>\n    \\<Longrightarrow> \\<Union>\n                       (get_offending_flows []\n                         \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n                      \\<subseteq> X - E'\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                 E' \\<subseteq> E;\n                 \\<Union>\n                  (get_offending_flows M\n                    \\<lparr>nodes = V, edges = E\\<rparr>)\n                 \\<subseteq> X\\<rbrakk>\n                \\<Longrightarrow> \\<Union>\n                                   (get_offending_flows M\n                                     \\<lparr>nodes = V,\n  edges = E - E'\\<rparr>)\n                                  \\<subseteq> X - E';\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        \\<Union>\n         (get_offending_flows (a # M) \\<lparr>nodes = V, edges = E\\<rparr>)\n        \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (get_offending_flows (a # M)\n                            \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n                         \\<subseteq> X - E'", "case Nil"], ["proof (state)\nthis:\n  valid_reqs []\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n  E' \\<subseteq> E\n  \\<Union> (get_offending_flows [] \\<lparr>nodes = V, edges = E\\<rparr>)\n  \\<subseteq> X\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_reqs []; wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     E' \\<subseteq> E;\n     \\<Union> (get_offending_flows [] \\<lparr>nodes = V, edges = E\\<rparr>)\n     \\<subseteq> X\\<rbrakk>\n    \\<Longrightarrow> \\<Union>\n                       (get_offending_flows []\n                         \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n                      \\<subseteq> X - E'\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                 E' \\<subseteq> E;\n                 \\<Union>\n                  (get_offending_flows M\n                    \\<lparr>nodes = V, edges = E\\<rparr>)\n                 \\<subseteq> X\\<rbrakk>\n                \\<Longrightarrow> \\<Union>\n                                   (get_offending_flows M\n                                     \\<lparr>nodes = V,\n  edges = E - E'\\<rparr>)\n                                  \\<subseteq> X - E';\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        \\<Union>\n         (get_offending_flows (a # M) \\<lparr>nodes = V, edges = E\\<rparr>)\n        \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (get_offending_flows (a # M)\n                            \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n                         \\<subseteq> X - E'", "thus ?case"], ["proof (prove)\nusing this:\n  valid_reqs []\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n  E' \\<subseteq> E\n  \\<Union> (get_offending_flows [] \\<lparr>nodes = V, edges = E\\<rparr>)\n  \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (get_offending_flows [] \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n    \\<subseteq> X - E'", "by (simp add: get_offending_flows_def)"], ["proof (state)\nthis:\n  \\<Union>\n   (get_offending_flows [] \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n  \\<subseteq> X - E'\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                 E' \\<subseteq> E;\n                 \\<Union>\n                  (get_offending_flows M\n                    \\<lparr>nodes = V, edges = E\\<rparr>)\n                 \\<subseteq> X\\<rbrakk>\n                \\<Longrightarrow> \\<Union>\n                                   (get_offending_flows M\n                                     \\<lparr>nodes = V,\n  edges = E - E'\\<rparr>)\n                                  \\<subseteq> X - E';\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        \\<Union>\n         (get_offending_flows (a # M) \\<lparr>nodes = V, edges = E\\<rparr>)\n        \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (get_offending_flows (a # M)\n                            \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n                         \\<subseteq> X - E'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                 E' \\<subseteq> E;\n                 \\<Union>\n                  (get_offending_flows M\n                    \\<lparr>nodes = V, edges = E\\<rparr>)\n                 \\<subseteq> X\\<rbrakk>\n                \\<Longrightarrow> \\<Union>\n                                   (get_offending_flows M\n                                     \\<lparr>nodes = V,\n  edges = E - E'\\<rparr>)\n                                  \\<subseteq> X - E';\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        \\<Union>\n         (get_offending_flows (a # M) \\<lparr>nodes = V, edges = E\\<rparr>)\n        \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (get_offending_flows (a # M)\n                            \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n                         \\<subseteq> X - E'", "case (Cons m M)"], ["proof (state)\nthis:\n  \\<lbrakk>valid_reqs M; wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n   E' \\<subseteq> E;\n   \\<Union> (get_offending_flows M \\<lparr>nodes = V, edges = E\\<rparr>)\n   \\<subseteq> X\\<rbrakk>\n  \\<Longrightarrow> \\<Union>\n                     (get_offending_flows M\n                       \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n                    \\<subseteq> X - E'\n  valid_reqs (m # M)\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n  E' \\<subseteq> E\n  \\<Union>\n   (get_offending_flows (m # M) \\<lparr>nodes = V, edges = E\\<rparr>)\n  \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                 E' \\<subseteq> E;\n                 \\<Union>\n                  (get_offending_flows M\n                    \\<lparr>nodes = V, edges = E\\<rparr>)\n                 \\<subseteq> X\\<rbrakk>\n                \\<Longrightarrow> \\<Union>\n                                   (get_offending_flows M\n                                     \\<lparr>nodes = V,\n  edges = E - E'\\<rparr>)\n                                  \\<subseteq> X - E';\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        \\<Union>\n         (get_offending_flows (a # M) \\<lparr>nodes = V, edges = E\\<rparr>)\n        \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (get_offending_flows (a # M)\n                            \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n                         \\<subseteq> X - E'", "from Cons.prems(1) valid_reqs2"], ["proof (chain)\npicking this:\n  valid_reqs (m # M)\n  valid_reqs (?m # ?M) \\<Longrightarrow> valid_reqs ?M", "have \"valid_reqs M\""], ["proof (prove)\nusing this:\n  valid_reqs (m # M)\n  valid_reqs (?m # ?M) \\<Longrightarrow> valid_reqs ?M\n\ngoal (1 subgoal):\n 1. valid_reqs M", "by force"], ["proof (state)\nthis:\n  valid_reqs M\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                 E' \\<subseteq> E;\n                 \\<Union>\n                  (get_offending_flows M\n                    \\<lparr>nodes = V, edges = E\\<rparr>)\n                 \\<subseteq> X\\<rbrakk>\n                \\<Longrightarrow> \\<Union>\n                                   (get_offending_flows M\n                                     \\<lparr>nodes = V,\n  edges = E - E'\\<rparr>)\n                                  \\<subseteq> X - E';\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        \\<Union>\n         (get_offending_flows (a # M) \\<lparr>nodes = V, edges = E\\<rparr>)\n        \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (get_offending_flows (a # M)\n                            \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n                         \\<subseteq> X - E'", "from Cons.prems(1) valid_reqs1"], ["proof (chain)\npicking this:\n  valid_reqs (m # M)\n  valid_reqs (?m # ?M) \\<Longrightarrow> configured_SecurityInvariant ?m", "have \"configured_SecurityInvariant m\""], ["proof (prove)\nusing this:\n  valid_reqs (m # M)\n  valid_reqs (?m # ?M) \\<Longrightarrow> configured_SecurityInvariant ?m\n\ngoal (1 subgoal):\n 1. configured_SecurityInvariant m", "by force"], ["proof (state)\nthis:\n  configured_SecurityInvariant m\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                 E' \\<subseteq> E;\n                 \\<Union>\n                  (get_offending_flows M\n                    \\<lparr>nodes = V, edges = E\\<rparr>)\n                 \\<subseteq> X\\<rbrakk>\n                \\<Longrightarrow> \\<Union>\n                                   (get_offending_flows M\n                                     \\<lparr>nodes = V,\n  edges = E - E'\\<rparr>)\n                                  \\<subseteq> X - E';\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        \\<Union>\n         (get_offending_flows (a # M) \\<lparr>nodes = V, edges = E\\<rparr>)\n        \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (get_offending_flows (a # M)\n                            \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n                         \\<subseteq> X - E'", "from Cons.prems(4)"], ["proof (chain)\npicking this:\n  \\<Union>\n   (get_offending_flows (m # M) \\<lparr>nodes = V, edges = E\\<rparr>)\n  \\<subseteq> X", "have \"\\<Union>(get_offending_flows M \\<lparr>nodes = V, edges = E\\<rparr>) \\<subseteq> X\""], ["proof (prove)\nusing this:\n  \\<Union>\n   (get_offending_flows (m # M) \\<lparr>nodes = V, edges = E\\<rparr>)\n  \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<Union> (get_offending_flows M \\<lparr>nodes = V, edges = E\\<rparr>)\n    \\<subseteq> X", "by(simp add: get_offending_flows_def)"], ["proof (state)\nthis:\n  \\<Union> (get_offending_flows M \\<lparr>nodes = V, edges = E\\<rparr>)\n  \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                 E' \\<subseteq> E;\n                 \\<Union>\n                  (get_offending_flows M\n                    \\<lparr>nodes = V, edges = E\\<rparr>)\n                 \\<subseteq> X\\<rbrakk>\n                \\<Longrightarrow> \\<Union>\n                                   (get_offending_flows M\n                                     \\<lparr>nodes = V,\n  edges = E - E'\\<rparr>)\n                                  \\<subseteq> X - E';\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        \\<Union>\n         (get_offending_flows (a # M) \\<lparr>nodes = V, edges = E\\<rparr>)\n        \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (get_offending_flows (a # M)\n                            \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n                         \\<subseteq> X - E'", "from Cons.IH[OF \\<open>valid_reqs M\\<close> Cons.prems(2) Cons.prems(3) \\<open>\\<Union>(get_offending_flows M \\<lparr>nodes = V, edges = E\\<rparr>) \\<subseteq> X\\<close>]"], ["proof (chain)\npicking this:\n  \\<Union> (get_offending_flows M \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n  \\<subseteq> X - E'", "have IH: \"\\<Union>(get_offending_flows M \\<lparr>nodes = V, edges = E - E'\\<rparr>) \\<subseteq> X - E'\""], ["proof (prove)\nusing this:\n  \\<Union> (get_offending_flows M \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n  \\<subseteq> X - E'\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (get_offending_flows M \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n    \\<subseteq> X - E'", "."], ["proof (state)\nthis:\n  \\<Union> (get_offending_flows M \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n  \\<subseteq> X - E'\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                 E' \\<subseteq> E;\n                 \\<Union>\n                  (get_offending_flows M\n                    \\<lparr>nodes = V, edges = E\\<rparr>)\n                 \\<subseteq> X\\<rbrakk>\n                \\<Longrightarrow> \\<Union>\n                                   (get_offending_flows M\n                                     \\<lparr>nodes = V,\n  edges = E - E'\\<rparr>)\n                                  \\<subseteq> X - E';\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        \\<Union>\n         (get_offending_flows (a # M) \\<lparr>nodes = V, edges = E\\<rparr>)\n        \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (get_offending_flows (a # M)\n                            \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n                         \\<subseteq> X - E'", "from Cons.prems(4)"], ["proof (chain)\npicking this:\n  \\<Union>\n   (get_offending_flows (m # M) \\<lparr>nodes = V, edges = E\\<rparr>)\n  \\<subseteq> X", "have \"\\<Union>(c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>) \\<subseteq> X\""], ["proof (prove)\nusing this:\n  \\<Union>\n   (get_offending_flows (m # M) \\<lparr>nodes = V, edges = E\\<rparr>)\n  \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<Union> (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\n    \\<subseteq> X", "by(simp add: get_offending_flows_def)"], ["proof (state)\nthis:\n  \\<Union> (c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\n  \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                 E' \\<subseteq> E;\n                 \\<Union>\n                  (get_offending_flows M\n                    \\<lparr>nodes = V, edges = E\\<rparr>)\n                 \\<subseteq> X\\<rbrakk>\n                \\<Longrightarrow> \\<Union>\n                                   (get_offending_flows M\n                                     \\<lparr>nodes = V,\n  edges = E - E'\\<rparr>)\n                                  \\<subseteq> X - E';\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        \\<Union>\n         (get_offending_flows (a # M) \\<lparr>nodes = V, edges = E\\<rparr>)\n        \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (get_offending_flows (a # M)\n                            \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n                         \\<subseteq> X - E'", "from configured_SecurityInvariant.Un_set_offending_flows_bound_minus_subseteq'[OF \\<open>configured_SecurityInvariant m\\<close> Cons.prems(2) \\<open>\\<Union>(c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>) \\<subseteq> X\\<close>]"], ["proof (chain)\npicking this:\n  \\<Union> (c_offending_flows m \\<lparr>nodes = V, edges = E - ?E'\\<rparr>)\n  \\<subseteq> X - ?E'", "have \"\\<Union>(c_offending_flows m \\<lparr>nodes = V, edges = E - E'\\<rparr>) \\<subseteq> X - E'\""], ["proof (prove)\nusing this:\n  \\<Union> (c_offending_flows m \\<lparr>nodes = V, edges = E - ?E'\\<rparr>)\n  \\<subseteq> X - ?E'\n\ngoal (1 subgoal):\n 1. \\<Union> (c_offending_flows m \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n    \\<subseteq> X - E'", "."], ["proof (state)\nthis:\n  \\<Union> (c_offending_flows m \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n  \\<subseteq> X - E'\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n                 E' \\<subseteq> E;\n                 \\<Union>\n                  (get_offending_flows M\n                    \\<lparr>nodes = V, edges = E\\<rparr>)\n                 \\<subseteq> X\\<rbrakk>\n                \\<Longrightarrow> \\<Union>\n                                   (get_offending_flows M\n                                     \\<lparr>nodes = V,\n  edges = E - E'\\<rparr>)\n                                  \\<subseteq> X - E';\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        E' \\<subseteq> E;\n        \\<Union>\n         (get_offending_flows (a # M) \\<lparr>nodes = V, edges = E\\<rparr>)\n        \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (get_offending_flows (a # M)\n                            \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n                         \\<subseteq> X - E'", "from this IH"], ["proof (chain)\npicking this:\n  \\<Union> (c_offending_flows m \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n  \\<subseteq> X - E'\n  \\<Union> (get_offending_flows M \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n  \\<subseteq> X - E'", "show ?case"], ["proof (prove)\nusing this:\n  \\<Union> (c_offending_flows m \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n  \\<subseteq> X - E'\n  \\<Union> (get_offending_flows M \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n  \\<subseteq> X - E'\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (get_offending_flows (m # M) \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n    \\<subseteq> X - E'", "by(simp add: get_offending_flows_def)"], ["proof (state)\nthis:\n  \\<Union>\n   (get_offending_flows (m # M) \\<lparr>nodes = V, edges = E - E'\\<rparr>)\n  \\<subseteq> X - E'\n\ngoal:\nNo subgoals!", "qed"], ["", "(*ENF has uniquely defined offending flows*)"], ["", "lemma ENF_uniquely_defined_offedning: \"valid_reqs M \\<Longrightarrow> wf_graph G \\<Longrightarrow> \n      \\<forall>m \\<in> set M. \\<exists>P. \\<forall>G. c_sinvar m G = (\\<forall>e \\<in> edges G. P e) \\<Longrightarrow> \n      \\<forall>m \\<in> set M. \\<forall>G. \\<not> c_sinvar m G \\<longrightarrow>  (\\<exists>OFF. c_offending_flows m G = {OFF})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G;\n     \\<forall>m\\<in>set M.\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>m\\<in>set M.\n                         \\<forall>G.\n                            \\<not> c_sinvar m G \\<longrightarrow>\n                            (\\<exists>OFF. c_offending_flows m G = {OFF})", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G;\n     \\<forall>m\\<in>set M.\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>m\\<in>set M.\n                         \\<forall>G.\n                            \\<not> c_sinvar m G \\<longrightarrow>\n                            (\\<exists>OFF. c_offending_flows m G = {OFF})", "apply(induction M)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_reqs []; wf_graph G;\n     \\<forall>m\\<in>set [].\n        \\<exists>P. \\<forall>G. c_sinvar m G = Ball (edges G) P\\<rbrakk>\n    \\<Longrightarrow> \\<forall>m\\<in>set [].\n                         \\<forall>G.\n                            \\<not> c_sinvar m G \\<longrightarrow>\n                            (\\<exists>OFF. c_offending_flows m G = {OFF})\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M; wf_graph G;\n                 \\<forall>m\\<in>set M.\n                    \\<exists>P.\n                       \\<forall>G. c_sinvar m G = Ball (edges G) P\\<rbrakk>\n                \\<Longrightarrow> \\<forall>m\\<in>set M.\n                                     \\<forall>G.\n  \\<not> c_sinvar m G \\<longrightarrow>\n  (\\<exists>OFF. c_offending_flows m G = {OFF});\n        valid_reqs (a # M); wf_graph G;\n        \\<forall>m\\<in>set (a # M).\n           \\<exists>P. \\<forall>G. c_sinvar m G = Ball (edges G) P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m\\<in>set (a # M).\n                            \\<forall>G.\n                               \\<not> c_sinvar m G \\<longrightarrow>\n                               (\\<exists>OFF. c_offending_flows m G = {OFF})", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M; wf_graph G;\n                 \\<forall>m\\<in>set M.\n                    \\<exists>P.\n                       \\<forall>G. c_sinvar m G = Ball (edges G) P\\<rbrakk>\n                \\<Longrightarrow> \\<forall>m\\<in>set M.\n                                     \\<forall>G.\n  \\<not> c_sinvar m G \\<longrightarrow>\n  (\\<exists>OFF. c_offending_flows m G = {OFF});\n        valid_reqs (a # M); wf_graph G;\n        \\<forall>m\\<in>set (a # M).\n           \\<exists>P. \\<forall>G. c_sinvar m G = Ball (edges G) P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m\\<in>set (a # M).\n                            \\<forall>G.\n                               \\<not> c_sinvar m G \\<longrightarrow>\n                               (\\<exists>OFF. c_offending_flows m G = {OFF})", "apply(rename_tac m M)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M; wf_graph G;\n                 \\<forall>m\\<in>set M.\n                    \\<exists>P.\n                       \\<forall>G. c_sinvar m G = Ball (edges G) P\\<rbrakk>\n                \\<Longrightarrow> \\<forall>m\\<in>set M.\n                                     \\<forall>G.\n  \\<not> c_sinvar m G \\<longrightarrow>\n  (\\<exists>OFF. c_offending_flows m G = {OFF});\n        valid_reqs (m # M); wf_graph G;\n        \\<forall>m\\<in>set (m # M).\n           \\<exists>P. \\<forall>G. c_sinvar m G = Ball (edges G) P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m\\<in>set (m # M).\n                            \\<forall>G.\n                               \\<not> c_sinvar m G \\<longrightarrow>\n                               (\\<exists>OFF. c_offending_flows m G = {OFF})", "apply(frule valid_reqs1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M; wf_graph G;\n                 \\<forall>m\\<in>set M.\n                    \\<exists>P.\n                       \\<forall>G. c_sinvar m G = Ball (edges G) P\\<rbrakk>\n                \\<Longrightarrow> \\<forall>m\\<in>set M.\n                                     \\<forall>G.\n  \\<not> c_sinvar m G \\<longrightarrow>\n  (\\<exists>OFF. c_offending_flows m G = {OFF});\n        valid_reqs (m # M); wf_graph G;\n        \\<forall>m\\<in>set (m # M).\n           \\<exists>P. \\<forall>G. c_sinvar m G = Ball (edges G) P;\n        configured_SecurityInvariant m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m\\<in>set (m # M).\n                            \\<forall>G.\n                               \\<not> c_sinvar m G \\<longrightarrow>\n                               (\\<exists>OFF. c_offending_flows m G = {OFF})", "apply(drule valid_reqs2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M; wf_graph G;\n                 \\<forall>m\\<in>set M.\n                    \\<exists>P.\n                       \\<forall>G. c_sinvar m G = Ball (edges G) P\\<rbrakk>\n                \\<Longrightarrow> \\<forall>m\\<in>set M.\n                                     \\<forall>G.\n  \\<not> c_sinvar m G \\<longrightarrow>\n  (\\<exists>OFF. c_offending_flows m G = {OFF});\n        wf_graph G;\n        \\<forall>m\\<in>set (m # M).\n           \\<exists>P. \\<forall>G. c_sinvar m G = Ball (edges G) P;\n        configured_SecurityInvariant m; valid_reqs M\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m\\<in>set (m # M).\n                            \\<forall>G.\n                               \\<not> c_sinvar m G \\<longrightarrow>\n                               (\\<exists>OFF. c_offending_flows m G = {OFF})", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m M.\n       \\<lbrakk>\\<forall>m\\<in>set M.\n                   \\<forall>G.\n                      \\<not> c_sinvar m G \\<longrightarrow>\n                      (\\<exists>OFF. c_offending_flows m G = {OFF});\n        wf_graph G;\n        (\\<exists>P.\n            \\<forall>G. c_sinvar m G = (\\<forall>x\\<in>edges G. P x)) \\<and>\n        (\\<forall>m\\<in>set M.\n            \\<exists>P.\n               \\<forall>G. c_sinvar m G = (\\<forall>x\\<in>edges G. P x));\n        configured_SecurityInvariant m; valid_reqs M\\<rbrakk>\n       \\<Longrightarrow> \\<forall>G.\n                            \\<not> c_sinvar m G \\<longrightarrow>\n                            (\\<exists>OFF. c_offending_flows m G = {OFF})", "apply(elim conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m M.\n       \\<lbrakk>\\<forall>m\\<in>set M.\n                   \\<forall>G.\n                      \\<not> c_sinvar m G \\<longrightarrow>\n                      (\\<exists>OFF. c_offending_flows m G = {OFF});\n        wf_graph G; configured_SecurityInvariant m; valid_reqs M;\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>x\\<in>edges G. P x);\n        \\<forall>m\\<in>set M.\n           \\<exists>P.\n              \\<forall>G.\n                 c_sinvar m G = (\\<forall>x\\<in>edges G. P x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>G.\n                            \\<not> c_sinvar m G \\<longrightarrow>\n                            (\\<exists>OFF. c_offending_flows m G = {OFF})", "apply(erule_tac x=m in ballE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m M.\n       \\<lbrakk>wf_graph G; configured_SecurityInvariant m; valid_reqs M;\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>x\\<in>edges G. P x);\n        \\<forall>m\\<in>set M.\n           \\<exists>P.\n              \\<forall>G. c_sinvar m G = (\\<forall>x\\<in>edges G. P x);\n        \\<forall>G.\n           \\<not> c_sinvar m G \\<longrightarrow>\n           (\\<exists>OFF. c_offending_flows m G = {OFF})\\<rbrakk>\n       \\<Longrightarrow> \\<forall>G.\n                            \\<not> c_sinvar m G \\<longrightarrow>\n                            (\\<exists>OFF. c_offending_flows m G = {OFF})\n 2. \\<And>m M.\n       \\<lbrakk>wf_graph G; configured_SecurityInvariant m; valid_reqs M;\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>x\\<in>edges G. P x);\n        \\<forall>m\\<in>set M.\n           \\<exists>P.\n              \\<forall>G. c_sinvar m G = (\\<forall>x\\<in>edges G. P x);\n        m \\<notin> set M\\<rbrakk>\n       \\<Longrightarrow> \\<forall>G.\n                            \\<not> c_sinvar m G \\<longrightarrow>\n                            (\\<exists>OFF. c_offending_flows m G = {OFF})", "apply(simp_all; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m M.\n       \\<lbrakk>wf_graph G; configured_SecurityInvariant m; valid_reqs M;\n        \\<exists>P.\n           \\<forall>G. c_sinvar m G = (\\<forall>x\\<in>edges G. P x);\n        \\<forall>m\\<in>set M.\n           \\<exists>P.\n              \\<forall>G. c_sinvar m G = (\\<forall>x\\<in>edges G. P x);\n        m \\<notin> set M\\<rbrakk>\n       \\<Longrightarrow> \\<forall>G.\n                            \\<not> c_sinvar m G \\<longrightarrow>\n                            (\\<exists>OFF. c_offending_flows m G = {OFF})", "apply(erule exE, rename_tac P)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m M P.\n       \\<lbrakk>wf_graph G; configured_SecurityInvariant m; valid_reqs M;\n        \\<forall>m\\<in>set M.\n           \\<exists>P.\n              \\<forall>G. c_sinvar m G = (\\<forall>x\\<in>edges G. P x);\n        m \\<notin> set M;\n        \\<forall>G. c_sinvar m G = (\\<forall>x\\<in>edges G. P x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>G.\n                            \\<not> c_sinvar m G \\<longrightarrow>\n                            (\\<exists>OFF. c_offending_flows m G = {OFF})", "apply(drule_tac P=P in enf_offending_flows)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m M P.\n       \\<lbrakk>wf_graph G; valid_reqs M;\n        \\<forall>m\\<in>set M.\n           \\<exists>P.\n              \\<forall>G. c_sinvar m G = (\\<forall>x\\<in>edges G. P x);\n        m \\<notin> set M;\n        \\<forall>G. c_sinvar m G = (\\<forall>x\\<in>edges G. P x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>G.\n                            c_sinvar m G = (\\<forall>e\\<in>edges G. P e)\n 2. \\<And>m M P.\n       \\<lbrakk>wf_graph G; valid_reqs M;\n        \\<forall>m\\<in>set M.\n           \\<exists>P.\n              \\<forall>G. c_sinvar m G = (\\<forall>x\\<in>edges G. P x);\n        m \\<notin> set M;\n        \\<forall>G. c_sinvar m G = (\\<forall>x\\<in>edges G. P x);\n        \\<forall>G.\n           c_offending_flows m G =\n           (if c_sinvar m G then {}\n            else {{e \\<in> edges G. \\<not> P e}})\\<rbrakk>\n       \\<Longrightarrow> \\<forall>G.\n                            \\<not> c_sinvar m G \\<longrightarrow>\n                            (\\<exists>OFF. c_offending_flows m G = {OFF})", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m M P.\n       \\<lbrakk>wf_graph G; valid_reqs M;\n        \\<forall>m\\<in>set M.\n           \\<exists>P.\n              \\<forall>G. c_sinvar m G = (\\<forall>x\\<in>edges G. P x);\n        m \\<notin> set M;\n        \\<forall>G. c_sinvar m G = (\\<forall>x\\<in>edges G. P x);\n        \\<forall>G.\n           c_offending_flows m G =\n           (if c_sinvar m G then {}\n            else {{e \\<in> edges G. \\<not> P e}})\\<rbrakk>\n       \\<Longrightarrow> \\<forall>G.\n                            \\<not> c_sinvar m G \\<longrightarrow>\n                            (\\<exists>OFF. c_offending_flows m G = {OFF})", "apply(simp; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma assumes \"configured_SecurityInvariant m\"\n       and \"\\<forall>G. \\<not> c_sinvar m G \\<longrightarrow> (\\<exists>OFF. c_offending_flows m G = {OFF})\"\n       shows \"\\<exists>OFF_P. \\<forall>G. c_offending_flows m G = (if c_sinvar m G then {} else {OFF_P G})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>OFF_P.\n       \\<forall>G.\n          c_offending_flows m G = (if c_sinvar m G then {} else {OFF_P G})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>OFF_P.\n       \\<forall>G.\n          c_offending_flows m G = (if c_sinvar m G then {} else {OFF_P G})", "from assms"], ["proof (chain)\npicking this:\n  configured_SecurityInvariant m\n  \\<forall>G.\n     \\<not> c_sinvar m G \\<longrightarrow>\n     (\\<exists>OFF. c_offending_flows m G = {OFF})", "have \"\\<exists>OFF_P. \n          c_offending_flows m G = (if c_sinvar m G then {} else {OFF_P G})\" for G"], ["proof (prove)\nusing this:\n  configured_SecurityInvariant m\n  \\<forall>G.\n     \\<not> c_sinvar m G \\<longrightarrow>\n     (\\<exists>OFF. c_offending_flows m G = {OFF})\n\ngoal (1 subgoal):\n 1. \\<exists>OFF_P.\n       c_offending_flows m G = (if c_sinvar m G then {} else {OFF_P G})", "apply(erule_tac x=G in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>configured_SecurityInvariant m;\n     \\<not> c_sinvar m G \\<longrightarrow>\n     (\\<exists>OFF. c_offending_flows m G = {OFF})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>OFF_P.\n                         c_offending_flows m G =\n                         (if c_sinvar m G then {} else {OFF_P G})", "apply(cases \"c_sinvar m G\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>configured_SecurityInvariant m;\n     \\<not> c_sinvar m G \\<longrightarrow>\n     (\\<exists>OFF. c_offending_flows m G = {OFF});\n     c_sinvar m G\\<rbrakk>\n    \\<Longrightarrow> \\<exists>OFF_P.\n                         c_offending_flows m G =\n                         (if c_sinvar m G then {} else {OFF_P G})\n 2. \\<lbrakk>configured_SecurityInvariant m;\n     \\<not> c_sinvar m G \\<longrightarrow>\n     (\\<exists>OFF. c_offending_flows m G = {OFF});\n     \\<not> c_sinvar m G\\<rbrakk>\n    \\<Longrightarrow> \\<exists>OFF_P.\n                         c_offending_flows m G =\n                         (if c_sinvar m G then {} else {OFF_P G})", "apply(drule configured_SecurityInvariant.c_sinvar_valid_imp_no_offending_flows, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> c_sinvar m G \\<longrightarrow>\n             (\\<exists>OFF. c_offending_flows m G = {OFF});\n     c_sinvar m G; c_offending_flows m G = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>OFF_P.\n                         c_offending_flows m G =\n                         (if c_sinvar m G then {} else {OFF_P G})\n 2. \\<lbrakk>configured_SecurityInvariant m;\n     \\<not> c_sinvar m G \\<longrightarrow>\n     (\\<exists>OFF. c_offending_flows m G = {OFF});\n     \\<not> c_sinvar m G\\<rbrakk>\n    \\<Longrightarrow> \\<exists>OFF_P.\n                         c_offending_flows m G =\n                         (if c_sinvar m G then {} else {OFF_P G})", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>configured_SecurityInvariant m;\n     \\<not> c_sinvar m G \\<longrightarrow>\n     (\\<exists>OFF. c_offending_flows m G = {OFF});\n     \\<not> c_sinvar m G\\<rbrakk>\n    \\<Longrightarrow> \\<exists>OFF_P.\n                         c_offending_flows m G =\n                         (if c_sinvar m G then {} else {OFF_P G})", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>configured_SecurityInvariant m;\n     \\<exists>OFF. c_offending_flows m G = {OFF};\n     \\<not> c_sinvar m G\\<rbrakk>\n    \\<Longrightarrow> \\<exists>OFF_P. c_offending_flows m G = {OFF_P G}", "by meson"], ["proof (state)\nthis:\n  \\<exists>OFF_P.\n     c_offending_flows m ?G = (if c_sinvar m ?G then {} else {OFF_P ?G})\n\ngoal (1 subgoal):\n 1. \\<exists>OFF_P.\n       \\<forall>G.\n          c_offending_flows m G = (if c_sinvar m G then {} else {OFF_P G})", "with assms"], ["proof (chain)\npicking this:\n  configured_SecurityInvariant m\n  \\<forall>G.\n     \\<not> c_sinvar m G \\<longrightarrow>\n     (\\<exists>OFF. c_offending_flows m G = {OFF})\n  \\<exists>OFF_P.\n     c_offending_flows m ?G = (if c_sinvar m ?G then {} else {OFF_P ?G})", "show ?thesis"], ["proof (prove)\nusing this:\n  configured_SecurityInvariant m\n  \\<forall>G.\n     \\<not> c_sinvar m G \\<longrightarrow>\n     (\\<exists>OFF. c_offending_flows m G = {OFF})\n  \\<exists>OFF_P.\n     c_offending_flows m ?G = (if c_sinvar m ?G then {} else {OFF_P ?G})\n\ngoal (1 subgoal):\n 1. \\<exists>OFF_P.\n       \\<forall>G.\n          c_offending_flows m G = (if c_sinvar m G then {} else {OFF_P G})", "by metis"], ["proof (state)\nthis:\n  \\<exists>OFF_P.\n     \\<forall>G.\n        c_offending_flows m G = (if c_sinvar m G then {} else {OFF_P G})\n\ngoal:\nNo subgoals!", "qed"], ["", "(*TODO: generate_valid_topology_max_topo for sinvars with unique offending flows in general*)"], ["", "text\\<open>Hilber's eps operator example\\<close>"], ["", "lemma \"(SOME x. x : {1::nat, 2, 3}) = x \\<Longrightarrow> x = 1 \\<or> x = 2 \\<or> x = 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME x. x \\<in> {1, 2, 3}) = x \\<Longrightarrow>\n    x = 1 \\<or> x = 2 \\<or> x = 3", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (SOME x. x \\<in> {1, 2, 3}) = x \\<Longrightarrow>\n    x = 1 \\<or> x = 2 \\<or> x = 3", "have \"(SOME x. x \\<in> {1::nat, 2, 3}) \\<in> {1::nat, 2, 3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME x. x \\<in> {1, 2, 3}) \\<in> {1, 2, 3}", "unfolding some_in_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. {1, 2, 3} \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  (SOME x. x \\<in> {1, 2, 3}) \\<in> {1, 2, 3}\n\ngoal (1 subgoal):\n 1. (SOME x. x \\<in> {1, 2, 3}) = x \\<Longrightarrow>\n    x = 1 \\<or> x = 2 \\<or> x = 3", "thus \"(SOME x. x : {1::nat, 2, 3}) = x \\<Longrightarrow> x = 1 \\<or> x = 2 \\<or> x = 3\""], ["proof (prove)\nusing this:\n  (SOME x. x \\<in> {1, 2, 3}) \\<in> {1, 2, 3}\n\ngoal (1 subgoal):\n 1. (SOME x. x \\<in> {1, 2, 3}) = x \\<Longrightarrow>\n    x = 1 \\<or> x = 2 \\<or> x = 3", "by fast"], ["proof (state)\nthis:\n  (SOME x. x \\<in> {1, 2, 3}) = x \\<Longrightarrow>\n  x = 1 \\<or> x = 2 \\<or> x = 3\n\ngoal:\nNo subgoals!", "qed"], ["", "(*TODO: remove the offending flows from the graph for each iteration. requires proof arbitrary: G\n          allows to put expensive invariants at back of list and hope that sinvar is true until the are evaluated*)"], ["", "text\\<open>Only removing one offending flow should be enough\\<close>"], ["", "fun generate_valid_topology_SOME :: \"'v SecurityInvariant_configured list \\<Rightarrow> 'v graph \\<Rightarrow> 'v graph\" where\n    \"generate_valid_topology_SOME [] G = G\" |\n    \"generate_valid_topology_SOME (m#Ms) G = (if c_sinvar m G\n      then generate_valid_topology_SOME Ms G\n      else delete_edges (generate_valid_topology_SOME Ms G) (SOME F. F \\<in> c_offending_flows m G)\n      )\""], ["", "lemma generate_valid_topology_SOME_nodes: \"nodes (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>) = V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes\n     (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>) =\n    V", "proof(induction M)"], ["proof (state)\ngoal (2 subgoals):\n 1. nodes\n     (generate_valid_topology_SOME []\n       \\<lparr>nodes = V, edges = E\\<rparr>) =\n    V\n 2. \\<And>a M.\n       nodes\n        (generate_valid_topology_SOME M\n          \\<lparr>nodes = V, edges = E\\<rparr>) =\n       V \\<Longrightarrow>\n       nodes\n        (generate_valid_topology_SOME (a # M)\n          \\<lparr>nodes = V, edges = E\\<rparr>) =\n       V", "qed(simp_all add: delete_edges_simp2)"], ["", "theorem generate_valid_topology_SOME_sound:\n    \"\\<lbrakk> valid_reqs M; wf_graph \\<lparr>nodes = V, edges = E\\<rparr> \\<rbrakk> \\<Longrightarrow> \n    all_security_requirements_fulfilled M (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M;\n     wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> all_security_requirements_fulfilled M\n                       (generate_valid_topology_SOME M\n                         \\<lparr>nodes = V, edges = E\\<rparr>)", "proof(induction M)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_reqs [];\n     wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> all_security_requirements_fulfilled []\n                       (generate_valid_topology_SOME []\n                         \\<lparr>nodes = V, edges = E\\<rparr>)\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "case Nil"], ["proof (state)\nthis:\n  valid_reqs []\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_reqs [];\n     wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> all_security_requirements_fulfilled []\n                       (generate_valid_topology_SOME []\n                         \\<lparr>nodes = V, edges = E\\<rparr>)\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "thus ?case"], ["proof (prove)\nusing this:\n  valid_reqs []\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled []\n     (generate_valid_topology_SOME [] \\<lparr>nodes = V, edges = E\\<rparr>)", "by(simp add: all_security_requirements_fulfilled_def)"], ["proof (state)\nthis:\n  all_security_requirements_fulfilled []\n   (generate_valid_topology_SOME [] \\<lparr>nodes = V, edges = E\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "case (Cons m M)"], ["proof (state)\nthis:\n  \\<lbrakk>valid_reqs M;\n   wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n  \\<Longrightarrow> all_security_requirements_fulfilled M\n                     (generate_valid_topology_SOME M\n                       \\<lparr>nodes = V, edges = E\\<rparr>)\n  valid_reqs (m # M)\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from valid_reqs1[OF Cons(2)]"], ["proof (chain)\npicking this:\n  configured_SecurityInvariant m", "have validReq: \"configured_SecurityInvariant m\""], ["proof (prove)\nusing this:\n  configured_SecurityInvariant m\n\ngoal (1 subgoal):\n 1. configured_SecurityInvariant m", "."], ["proof (state)\nthis:\n  configured_SecurityInvariant m\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from configured_SecurityInvariant.sinvar_valid_remove_SOME_offending_flows[OF validReq]"], ["proof (chain)\npicking this:\n  c_offending_flows m\n   \\<lparr>nodes = ?nodesG, edges = ?edgesG\\<rparr> \\<noteq>\n  {} \\<Longrightarrow>\n  c_sinvar m\n   \\<lparr>nodes = ?nodesG,\n      edges =\n        ?edgesG -\n        (SOME F.\n            F \\<in> c_offending_flows m\n                     \\<lparr>nodes = ?nodesG,\n                        edges = ?edgesG\\<rparr>)\\<rparr>", "have\n         \"c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {} \\<Longrightarrow>\n           c_sinvar m \\<lparr>nodes = V, edges = E - (SOME F. F \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\""], ["proof (prove)\nusing this:\n  c_offending_flows m\n   \\<lparr>nodes = ?nodesG, edges = ?edgesG\\<rparr> \\<noteq>\n  {} \\<Longrightarrow>\n  c_sinvar m\n   \\<lparr>nodes = ?nodesG,\n      edges =\n        ?edgesG -\n        (SOME F.\n            F \\<in> c_offending_flows m\n                     \\<lparr>nodes = ?nodesG,\n                        edges = ?edgesG\\<rparr>)\\<rparr>\n\ngoal (1 subgoal):\n 1. c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq>\n    {} \\<Longrightarrow>\n    c_sinvar m\n     \\<lparr>nodes = V,\n        edges =\n          E -\n          (SOME F.\n              F \\<in> c_offending_flows m\n                       \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>", "."], ["proof (state)\nthis:\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq>\n  {} \\<Longrightarrow>\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        E -\n        (SOME F.\n            F \\<in> c_offending_flows m\n                     \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "have generate_valid_topology_SOME_edges: \"edges (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>) \\<subseteq> E\"\n          for M::\"'a SecurityInvariant_configured list\" and V E"], ["proof (prove)\ngoal (1 subgoal):\n 1. edges\n     (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n    \\<subseteq> E", "proof(induction M)"], ["proof (state)\ngoal (2 subgoals):\n 1. edges\n     (generate_valid_topology_SOME [] \\<lparr>nodes = V, edges = E\\<rparr>)\n    \\<subseteq> E\n 2. \\<And>a M.\n       edges\n        (generate_valid_topology_SOME M\n          \\<lparr>nodes = V, edges = E\\<rparr>)\n       \\<subseteq> E \\<Longrightarrow>\n       edges\n        (generate_valid_topology_SOME (a # M)\n          \\<lparr>nodes = V, edges = E\\<rparr>)\n       \\<subseteq> E", "qed(auto simp add: delete_edges_simp2)"], ["proof (state)\nthis:\n  edges\n   (generate_valid_topology_SOME ?M \\<lparr>nodes = ?V, edges = ?E\\<rparr>)\n  \\<subseteq> ?E\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from configured_SecurityInvariant.mono_sinvar[OF validReq Cons.prems(2),\n              of \"edges (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\"]\n            generate_valid_topology_SOME_edges"], ["proof (chain)\npicking this:\n  \\<lbrakk>edges\n            (generate_valid_topology_SOME M\n              \\<lparr>nodes = V, edges = E\\<rparr>)\n           \\<subseteq> E;\n   c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n  \\<Longrightarrow> c_sinvar m\n                     \\<lparr>nodes = V,\n                        edges =\n                          edges\n                           (generate_valid_topology_SOME M\n                             \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n  edges\n   (generate_valid_topology_SOME ?M \\<lparr>nodes = ?V, edges = ?E\\<rparr>)\n  \\<subseteq> ?E", "have \"c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n            c_sinvar m \\<lparr>nodes = V, edges = edges (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>edges\n            (generate_valid_topology_SOME M\n              \\<lparr>nodes = V, edges = E\\<rparr>)\n           \\<subseteq> E;\n   c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n  \\<Longrightarrow> c_sinvar m\n                     \\<lparr>nodes = V,\n                        edges =\n                          edges\n                           (generate_valid_topology_SOME M\n                             \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n  edges\n   (generate_valid_topology_SOME ?M \\<lparr>nodes = ?V, edges = ?E\\<rparr>)\n  \\<subseteq> ?E\n\ngoal (1 subgoal):\n 1. c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    c_sinvar m\n     \\<lparr>nodes = V,\n        edges =\n          edges\n           (generate_valid_topology_SOME M\n             \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>", "by simp"], ["proof (state)\nthis:\n  c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        edges\n         (generate_valid_topology_SOME M\n           \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "moreover"], ["proof (state)\nthis:\n  c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        edges\n         (generate_valid_topology_SOME M\n           \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from configured_SecurityInvariant.defined_offending'[OF validReq Cons.prems(2)]"], ["proof (chain)\npicking this:\n  \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}", "have not_sinvar_off:\n          \"\\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "ultimately"], ["proof (chain)\npicking this:\n  c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        edges\n         (generate_valid_topology_SOME M\n           \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n  \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}", "have goal_sinvar_m:\n          \"c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> = {} \\<Longrightarrow> \n              c_sinvar m (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\""], ["proof (prove)\nusing this:\n  c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        edges\n         (generate_valid_topology_SOME M\n           \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n  \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> =\n    {} \\<Longrightarrow>\n    c_sinvar m\n     (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)", "using generate_valid_topology_SOME_nodes"], ["proof (prove)\nusing this:\n  c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        edges\n         (generate_valid_topology_SOME M\n           \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n  \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}\n  nodes\n   (generate_valid_topology_SOME ?M\n     \\<lparr>nodes = ?V, edges = ?E\\<rparr>) =\n  ?V\n\ngoal (1 subgoal):\n 1. c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> =\n    {} \\<Longrightarrow>\n    c_sinvar m\n     (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)", "by (metis graph.select_convs(1) graph.select_convs(2) graph_eq_intro)"], ["proof (state)\nthis:\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> =\n  {} \\<Longrightarrow>\n  c_sinvar m\n   (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from valid_reqs2[OF Cons(2)]"], ["proof (chain)\npicking this:\n  valid_reqs M", "have \"valid_reqs M\""], ["proof (prove)\nusing this:\n  valid_reqs M\n\ngoal (1 subgoal):\n 1. valid_reqs M", "."], ["proof (state)\nthis:\n  valid_reqs M\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from Cons.IH[OF \\<open>valid_reqs M\\<close> Cons(3)]"], ["proof (chain)\npicking this:\n  all_security_requirements_fulfilled M\n   (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)", "have IH:\n          \"all_security_requirements_fulfilled M (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\""], ["proof (prove)\nusing this:\n  all_security_requirements_fulfilled M\n   (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled M\n     (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)", "."], ["proof (state)\nthis:\n  all_security_requirements_fulfilled M\n   (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "have goal_rm_SOME_m: \"c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {} \\<Longrightarrow>\n            c_sinvar m (delete_edges (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n                                      (SOME F. F \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq>\n    {} \\<Longrightarrow>\n    c_sinvar m\n     (delete_edges\n       (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n       (SOME F.\n           F \\<in> c_offending_flows m\n                    \\<lparr>nodes = V, edges = E\\<rparr>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq>\n    {} \\<Longrightarrow>\n    c_sinvar m\n     (delete_edges\n       (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n       (SOME F.\n           F \\<in> c_offending_flows m\n                    \\<lparr>nodes = V, edges = E\\<rparr>))", "(*sledgehammered*)"], ["proof (state)\ngoal (1 subgoal):\n 1. c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq>\n    {} \\<Longrightarrow>\n    c_sinvar m\n     (delete_edges\n       (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n       (SOME F.\n           F \\<in> c_offending_flows m\n                    \\<lparr>nodes = V, edges = E\\<rparr>))", "assume a1: \"c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}\""], ["proof (state)\nthis:\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq>\n    {} \\<Longrightarrow>\n    c_sinvar m\n     (delete_edges\n       (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n       (SOME F.\n           F \\<in> c_offending_flows m\n                    \\<lparr>nodes = V, edges = E\\<rparr>))", "have f2: \"(\\<forall>r ra p. \\<not> r \\<subseteq> ra \\<or> (p::'a \\<times> 'a) \\<notin> r \\<or> p \\<in> ra) = (\\<forall>r ra p. \\<not> r \\<subseteq> ra \\<or> (p::'a \\<times> 'a) \\<notin> r \\<or> p \\<in> ra)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>r ra p.\n        \\<not> r \\<subseteq> ra \\<or> p \\<notin> r \\<or> p \\<in> ra) =\n    (\\<forall>r ra p.\n        \\<not> r \\<subseteq> ra \\<or> p \\<notin> r \\<or> p \\<in> ra)", "by meson"], ["proof (state)\nthis:\n  (\\<forall>r ra p.\n      \\<not> r \\<subseteq> ra \\<or> p \\<notin> r \\<or> p \\<in> ra) =\n  (\\<forall>r ra p.\n      \\<not> r \\<subseteq> ra \\<or> p \\<notin> r \\<or> p \\<in> ra)\n\ngoal (1 subgoal):\n 1. c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq>\n    {} \\<Longrightarrow>\n    c_sinvar m\n     (delete_edges\n       (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n       (SOME F.\n           F \\<in> c_offending_flows m\n                    \\<lparr>nodes = V, edges = E\\<rparr>))", "have f3: \"wf_graph \\<lparr>nodes = V, edges = E - (SOME r. r \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph\n     \\<lparr>nodes = V,\n        edges =\n          E -\n          (SOME r.\n              r \\<in> c_offending_flows m\n                       \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>", "by (simp add: Cons.prems(2) wf_graph_remove_edges)"], ["proof (state)\nthis:\n  wf_graph\n   \\<lparr>nodes = V,\n      edges =\n        E -\n        (SOME r.\n            r \\<in> c_offending_flows m\n                     \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n\ngoal (1 subgoal):\n 1. c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq>\n    {} \\<Longrightarrow>\n    c_sinvar m\n     (delete_edges\n       (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n       (SOME F.\n           F \\<in> c_offending_flows m\n                    \\<lparr>nodes = V, edges = E\\<rparr>))", "have \"edges (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>) - (SOME r. r \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>) \\<subseteq> E - (SOME r. r \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges\n     (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>) -\n    (SOME r.\n        r \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\n    \\<subseteq> E -\n                (SOME r.\n                    r \\<in> c_offending_flows m\n                             \\<lparr>nodes = V, edges = E\\<rparr>)", "using f2 generate_valid_topology_SOME_edges[of M V E]"], ["proof (prove)\nusing this:\n  (\\<forall>r ra p.\n      \\<not> r \\<subseteq> ra \\<or> p \\<notin> r \\<or> p \\<in> ra) =\n  (\\<forall>r ra p.\n      \\<not> r \\<subseteq> ra \\<or> p \\<notin> r \\<or> p \\<in> ra)\n  edges\n   (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n  \\<subseteq> E\n\ngoal (1 subgoal):\n 1. edges\n     (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>) -\n    (SOME r.\n        r \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\n    \\<subseteq> E -\n                (SOME r.\n                    r \\<in> c_offending_flows m\n                             \\<lparr>nodes = V, edges = E\\<rparr>)", "by blast"], ["proof (state)\nthis:\n  edges\n   (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>) -\n  (SOME r. r \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\n  \\<subseteq> E -\n              (SOME r.\n                  r \\<in> c_offending_flows m\n                           \\<lparr>nodes = V, edges = E\\<rparr>)\n\ngoal (1 subgoal):\n 1. c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq>\n    {} \\<Longrightarrow>\n    c_sinvar m\n     (delete_edges\n       (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n       (SOME F.\n           F \\<in> c_offending_flows m\n                    \\<lparr>nodes = V, edges = E\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  edges\n   (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>) -\n  (SOME r. r \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\n  \\<subseteq> E -\n              (SOME r.\n                  r \\<in> c_offending_flows m\n                           \\<lparr>nodes = V, edges = E\\<rparr>)", "have \"c_sinvar m \\<lparr>nodes = V, edges = edges (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>) - (SOME r. r \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\""], ["proof (prove)\nusing this:\n  edges\n   (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>) -\n  (SOME r. r \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\n  \\<subseteq> E -\n              (SOME r.\n                  r \\<in> c_offending_flows m\n                           \\<lparr>nodes = V, edges = E\\<rparr>)\n\ngoal (1 subgoal):\n 1. c_sinvar m\n     \\<lparr>nodes = V,\n        edges =\n          edges\n           (generate_valid_topology_SOME M\n             \\<lparr>nodes = V, edges = E\\<rparr>) -\n          (SOME r.\n              r \\<in> c_offending_flows m\n                       \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>", "using f3 a1 \\<open>c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {} \\<Longrightarrow> c_sinvar m \\<lparr>nodes = V, edges = E - (SOME F. F \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\\<close> configured_SecurityInvariant.negative_mono validReq"], ["proof (prove)\nusing this:\n  edges\n   (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>) -\n  (SOME r. r \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>)\n  \\<subseteq> E -\n              (SOME r.\n                  r \\<in> c_offending_flows m\n                           \\<lparr>nodes = V, edges = E\\<rparr>)\n  wf_graph\n   \\<lparr>nodes = V,\n      edges =\n        E -\n        (SOME r.\n            r \\<in> c_offending_flows m\n                     \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq>\n  {} \\<Longrightarrow>\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        E -\n        (SOME F.\n            F \\<in> c_offending_flows m\n                     \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n  \\<lbrakk>configured_SecurityInvariant ?m;\n   wf_graph \\<lparr>nodes = ?N, edges = ?E\\<rparr>; ?E' \\<subseteq> ?E;\n   \\<not> c_sinvar ?m \\<lparr>nodes = ?N, edges = ?E'\\<rparr>\\<rbrakk>\n  \\<Longrightarrow> \\<not> c_sinvar ?m\n                            \\<lparr>nodes = ?N, edges = ?E\\<rparr>\n  configured_SecurityInvariant m\n\ngoal (1 subgoal):\n 1. c_sinvar m\n     \\<lparr>nodes = V,\n        edges =\n          edges\n           (generate_valid_topology_SOME M\n             \\<lparr>nodes = V, edges = E\\<rparr>) -\n          (SOME r.\n              r \\<in> c_offending_flows m\n                       \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>", "by blast"], ["proof (state)\nthis:\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        edges\n         (generate_valid_topology_SOME M\n           \\<lparr>nodes = V, edges = E\\<rparr>) -\n        (SOME r.\n            r \\<in> c_offending_flows m\n                     \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n\ngoal (1 subgoal):\n 1. c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq>\n    {} \\<Longrightarrow>\n    c_sinvar m\n     (delete_edges\n       (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n       (SOME F.\n           F \\<in> c_offending_flows m\n                    \\<lparr>nodes = V, edges = E\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        edges\n         (generate_valid_topology_SOME M\n           \\<lparr>nodes = V, edges = E\\<rparr>) -\n        (SOME r.\n            r \\<in> c_offending_flows m\n                     \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>", "show \"c_sinvar m (delete_edges (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>) (SOME r. r \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>))\""], ["proof (prove)\nusing this:\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        edges\n         (generate_valid_topology_SOME M\n           \\<lparr>nodes = V, edges = E\\<rparr>) -\n        (SOME r.\n            r \\<in> c_offending_flows m\n                     \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n\ngoal (1 subgoal):\n 1. c_sinvar m\n     (delete_edges\n       (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n       (SOME r.\n           r \\<in> c_offending_flows m\n                    \\<lparr>nodes = V, edges = E\\<rparr>))", "by (simp add: generate_valid_topology_SOME_nodes graph_ops(5))"], ["proof (state)\nthis:\n  c_sinvar m\n   (delete_edges\n     (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n     (SOME r.\n         r \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq>\n  {} \\<Longrightarrow>\n  c_sinvar m\n   (delete_edges\n     (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n     (SOME F.\n         F \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "have wf_graph_generate_valid_topology_SOME: \"wf_graph G \\<Longrightarrow> wf_graph (generate_valid_topology_SOME M G)\"\n          for G"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> wf_graph (generate_valid_topology_SOME M G)", "(*TODO: tune*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow> wf_graph (generate_valid_topology_SOME M G)", "apply(cases G)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nodes edges.\n       \\<lbrakk>wf_graph G;\n        G = \\<lparr>nodes = nodes, edges = edges\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> wf_graph (generate_valid_topology_SOME M G)", "apply(simp add: wf_graph_def generate_valid_topology_SOME_nodes)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nodes edgesa.\n       \\<lbrakk>fst ` edgesa \\<subseteq> nodes \\<and>\n                snd ` edgesa \\<subseteq> nodes \\<and>\n                finite edgesa \\<and> finite nodes;\n        G = \\<lparr>nodes = nodes, edges = edgesa\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> fst `\n                         edges\n                          (generate_valid_topology_SOME M\n                            \\<lparr>nodes = nodes, edges = edgesa\\<rparr>)\n                         \\<subseteq> nodes \\<and>\n                         snd `\n                         edges\n                          (generate_valid_topology_SOME M\n                            \\<lparr>nodes = nodes, edges = edgesa\\<rparr>)\n                         \\<subseteq> nodes \\<and>\n                         finite\n                          (edges\n                            (generate_valid_topology_SOME M\n                              \\<lparr>nodes = nodes,\n                                 edges = edgesa\\<rparr>))", "using generate_valid_topology_SOME_edges"], ["proof (prove)\nusing this:\n  edges\n   (generate_valid_topology_SOME ?M \\<lparr>nodes = ?V, edges = ?E\\<rparr>)\n  \\<subseteq> ?E\n\ngoal (1 subgoal):\n 1. \\<And>nodes edgesa.\n       \\<lbrakk>fst ` edgesa \\<subseteq> nodes \\<and>\n                snd ` edgesa \\<subseteq> nodes \\<and>\n                finite edgesa \\<and> finite nodes;\n        G = \\<lparr>nodes = nodes, edges = edgesa\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> fst `\n                         edges\n                          (generate_valid_topology_SOME M\n                            \\<lparr>nodes = nodes, edges = edgesa\\<rparr>)\n                         \\<subseteq> nodes \\<and>\n                         snd `\n                         edges\n                          (generate_valid_topology_SOME M\n                            \\<lparr>nodes = nodes, edges = edgesa\\<rparr>)\n                         \\<subseteq> nodes \\<and>\n                         finite\n                          (edges\n                            (generate_valid_topology_SOME M\n                              \\<lparr>nodes = nodes,\n                                 edges = edgesa\\<rparr>))", "by (meson dual_order.trans image_mono rev_finite_subset)"], ["proof (state)\nthis:\n  wf_graph ?G \\<Longrightarrow> wf_graph (generate_valid_topology_SOME M ?G)\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "{"], ["proof (state)\nthis:\n  wf_graph ?G \\<Longrightarrow> wf_graph (generate_valid_topology_SOME M ?G)\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "assume notempty: \"c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}\""], ["proof (state)\nthis:\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "hence \"\\<exists> hypE. (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>) = \\<lparr>nodes = V, edges = hypE\\<rparr>\""], ["proof (prove)\nusing this:\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>hypE.\n       generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr> =\n       \\<lparr>nodes = V, edges = hypE\\<rparr>", "proof(induction M arbitrary: V E)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>V E.\n       c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq>\n       {} \\<Longrightarrow>\n       \\<exists>hypE.\n          generate_valid_topology_SOME []\n           \\<lparr>nodes = V, edges = E\\<rparr> =\n          \\<lparr>nodes = V, edges = hypE\\<rparr>\n 2. \\<And>a M V E.\n       \\<lbrakk>\\<And>V E.\n                   c_offending_flows m\n                    \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq>\n                   {} \\<Longrightarrow>\n                   \\<exists>hypE.\n                      generate_valid_topology_SOME M\n                       \\<lparr>nodes = V, edges = E\\<rparr> =\n                      \\<lparr>nodes = V, edges = hypE\\<rparr>;\n        c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq>\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>hypE.\n                            generate_valid_topology_SOME (a # M)\n                             \\<lparr>nodes = V, edges = E\\<rparr> =\n                            \\<lparr>nodes = V, edges = hypE\\<rparr>", "qed(simp_all add: delete_edges_simp2 generate_valid_topology_SOME_nodes)"], ["proof (state)\nthis:\n  \\<exists>hypE.\n     generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr> =\n     \\<lparr>nodes = V, edges = hypE\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>hypE.\n     generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr> =\n     \\<lparr>nodes = V, edges = hypE\\<rparr>", "obtain E_IH where E_IH_prop:\n            \"(generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>) = \\<lparr>nodes = V, edges = E_IH\\<rparr>\""], ["proof (prove)\nusing this:\n  \\<exists>hypE.\n     generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr> =\n     \\<lparr>nodes = V, edges = hypE\\<rparr>\n\ngoal (1 subgoal):\n 1. (\\<And>E_IH.\n        generate_valid_topology_SOME M\n         \\<lparr>nodes = V, edges = E\\<rparr> =\n        \\<lparr>nodes = V, edges = E_IH\\<rparr> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr> =\n  \\<lparr>nodes = V, edges = E_IH\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from wf_graph_generate_valid_topology_SOME[OF Cons(3)] E_IH_prop"], ["proof (chain)\npicking this:\n  wf_graph\n   (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n  generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr> =\n  \\<lparr>nodes = V, edges = E_IH\\<rparr>", "have valid_G_E_IH: \"wf_graph \\<lparr>nodes = V, edges = E_IH\\<rparr>\""], ["proof (prove)\nusing this:\n  wf_graph\n   (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n  generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr> =\n  \\<lparr>nodes = V, edges = E_IH\\<rparr>\n\ngoal (1 subgoal):\n 1. wf_graph \\<lparr>nodes = V, edges = E_IH\\<rparr>", "by simp"], ["proof (state)\nthis:\n  wf_graph \\<lparr>nodes = V, edges = E_IH\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from all_security_requirements_fulfilled_mono[OF \\<open>valid_reqs M\\<close> _ valid_G_E_IH ] IH E_IH_prop"], ["proof (chain)\npicking this:\n  \\<lbrakk>?E' \\<subseteq> E_IH;\n   all_security_requirements_fulfilled M\n    \\<lparr>nodes = V, edges = E_IH\\<rparr>\\<rbrakk>\n  \\<Longrightarrow> all_security_requirements_fulfilled M\n                     \\<lparr>nodes = V, edges = ?E'\\<rparr>\n  all_security_requirements_fulfilled M\n   (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n  generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr> =\n  \\<lparr>nodes = V, edges = E_IH\\<rparr>", "have mono_rule: \"E' \\<subseteq> E_IH \\<Longrightarrow> all_security_requirements_fulfilled M \\<lparr>nodes = V, edges = E'\\<rparr>\" for E'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?E' \\<subseteq> E_IH;\n   all_security_requirements_fulfilled M\n    \\<lparr>nodes = V, edges = E_IH\\<rparr>\\<rbrakk>\n  \\<Longrightarrow> all_security_requirements_fulfilled M\n                     \\<lparr>nodes = V, edges = ?E'\\<rparr>\n  all_security_requirements_fulfilled M\n   (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n  generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr> =\n  \\<lparr>nodes = V, edges = E_IH\\<rparr>\n\ngoal (1 subgoal):\n 1. E' \\<subseteq> E_IH \\<Longrightarrow>\n    all_security_requirements_fulfilled M\n     \\<lparr>nodes = V, edges = E'\\<rparr>", "by simp"], ["proof (state)\nthis:\n  ?E' \\<subseteq> E_IH \\<Longrightarrow>\n  all_security_requirements_fulfilled M\n   \\<lparr>nodes = V, edges = ?E'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "have \"all_security_requirements_fulfilled M\n            (delete_edges (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n                          (SOME F. F \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled M\n     (delete_edges\n       (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n       (SOME F.\n           F \\<in> c_offending_flows m\n                    \\<lparr>nodes = V, edges = E\\<rparr>))", "unfolding E_IH_prop"], ["proof (prove)\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled M\n     (delete_edges \\<lparr>nodes = V, edges = E_IH\\<rparr>\n       (SOME F.\n           F \\<in> c_offending_flows m\n                    \\<lparr>nodes = V, edges = E\\<rparr>))", "by(auto simp add: delete_edges_simp2 intro:mono_rule)"], ["proof (state)\nthis:\n  all_security_requirements_fulfilled M\n   (delete_edges\n     (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n     (SOME F.\n         F \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "}"], ["proof (state)\nthis:\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq>\n  {} \\<Longrightarrow>\n  all_security_requirements_fulfilled M\n   (delete_edges\n     (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n     (SOME F.\n         F \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "note goal_fulfilled_M=this"], ["proof (state)\nthis:\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq>\n  {} \\<Longrightarrow>\n  all_security_requirements_fulfilled M\n   (delete_edges\n     (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n     (SOME F.\n         F \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "have no_offending: \"c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> = {}", "by (simp add: configured_SecurityInvariant.c_sinvar_valid_imp_no_offending_flows validReq)"], ["proof (state)\nthis:\n  c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> = {}\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_SOME M\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M);\n        wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_SOME (a # M)\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "show \"all_security_requirements_fulfilled (m # M) (generate_valid_topology_SOME (m # M) \\<lparr>nodes = V, edges = E\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled (m # M)\n     (generate_valid_topology_SOME (m # M)\n       \\<lparr>nodes = V, edges = E\\<rparr>)", "apply(simp add: all_security_requirements_fulfilled_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<longrightarrow>\n     c_sinvar m\n      (generate_valid_topology_SOME M\n        \\<lparr>nodes = V, edges = E\\<rparr>) \\<and>\n     (\\<forall>m\\<in>set M.\n         c_sinvar m\n          (generate_valid_topology_SOME M\n            \\<lparr>nodes = V, edges = E\\<rparr>))) \\<and>\n    (\\<not> c_sinvar m\n             \\<lparr>nodes = V, edges = E\\<rparr> \\<longrightarrow>\n     c_sinvar m\n      (delete_edges\n        (generate_valid_topology_SOME M\n          \\<lparr>nodes = V, edges = E\\<rparr>)\n        (SOME F.\n            F \\<in> c_offending_flows m\n                     \\<lparr>nodes = V, edges = E\\<rparr>)) \\<and>\n     (\\<forall>ma\\<in>set M.\n         c_sinvar ma\n          (delete_edges\n            (generate_valid_topology_SOME M\n              \\<lparr>nodes = V, edges = E\\<rparr>)\n            (SOME F.\n                F \\<in> c_offending_flows m\n                         \\<lparr>nodes = V, edges = E\\<rparr>))))", "apply(intro conjI impI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    c_sinvar m\n     (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n 2. c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    \\<forall>m\\<in>set M.\n       c_sinvar m\n        (generate_valid_topology_SOME M\n          \\<lparr>nodes = V, edges = E\\<rparr>)\n 3. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    c_sinvar m\n     (delete_edges\n       (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n       (SOME F.\n           F \\<in> c_offending_flows m\n                    \\<lparr>nodes = V, edges = E\\<rparr>))\n 4. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    \\<forall>ma\\<in>set M.\n       c_sinvar ma\n        (delete_edges\n          (generate_valid_topology_SOME M\n            \\<lparr>nodes = V, edges = E\\<rparr>)\n          (SOME F.\n              F \\<in> c_offending_flows m\n                       \\<lparr>nodes = V, edges = E\\<rparr>))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    c_sinvar m\n     (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)", "using goal_sinvar_m no_offending"], ["proof (prove)\nusing this:\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> =\n  {} \\<Longrightarrow>\n  c_sinvar m\n   (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n  c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> = {}\n\ngoal (1 subgoal):\n 1. c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    c_sinvar m\n     (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)", "by blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    \\<forall>m\\<in>set M.\n       c_sinvar m\n        (generate_valid_topology_SOME M\n          \\<lparr>nodes = V, edges = E\\<rparr>)\n 2. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    c_sinvar m\n     (delete_edges\n       (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n       (SOME F.\n           F \\<in> c_offending_flows m\n                    \\<lparr>nodes = V, edges = E\\<rparr>))\n 3. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    \\<forall>ma\\<in>set M.\n       c_sinvar ma\n        (delete_edges\n          (generate_valid_topology_SOME M\n            \\<lparr>nodes = V, edges = E\\<rparr>)\n          (SOME F.\n              F \\<in> c_offending_flows m\n                       \\<lparr>nodes = V, edges = E\\<rparr>))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    \\<forall>m\\<in>set M.\n       c_sinvar m\n        (generate_valid_topology_SOME M\n          \\<lparr>nodes = V, edges = E\\<rparr>)", "using IH"], ["proof (prove)\nusing this:\n  all_security_requirements_fulfilled M\n   (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n\ngoal (1 subgoal):\n 1. c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    \\<forall>m\\<in>set M.\n       c_sinvar m\n        (generate_valid_topology_SOME M\n          \\<lparr>nodes = V, edges = E\\<rparr>)", "by(simp add: all_security_requirements_fulfilled_def; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    c_sinvar m\n     (delete_edges\n       (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n       (SOME F.\n           F \\<in> c_offending_flows m\n                    \\<lparr>nodes = V, edges = E\\<rparr>))\n 2. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    \\<forall>ma\\<in>set M.\n       c_sinvar ma\n        (delete_edges\n          (generate_valid_topology_SOME M\n            \\<lparr>nodes = V, edges = E\\<rparr>)\n          (SOME F.\n              F \\<in> c_offending_flows m\n                       \\<lparr>nodes = V, edges = E\\<rparr>))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    c_sinvar m\n     (delete_edges\n       (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n       (SOME F.\n           F \\<in> c_offending_flows m\n                    \\<lparr>nodes = V, edges = E\\<rparr>))", "using goal_rm_SOME_m not_sinvar_off"], ["proof (prove)\nusing this:\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq>\n  {} \\<Longrightarrow>\n  c_sinvar m\n   (delete_edges\n     (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n     (SOME F.\n         F \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>))\n  \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    c_sinvar m\n     (delete_edges\n       (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n       (SOME F.\n           F \\<in> c_offending_flows m\n                    \\<lparr>nodes = V, edges = E\\<rparr>))", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    \\<forall>ma\\<in>set M.\n       c_sinvar ma\n        (delete_edges\n          (generate_valid_topology_SOME M\n            \\<lparr>nodes = V, edges = E\\<rparr>)\n          (SOME F.\n              F \\<in> c_offending_flows m\n                       \\<lparr>nodes = V, edges = E\\<rparr>))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    \\<forall>ma\\<in>set M.\n       c_sinvar ma\n        (delete_edges\n          (generate_valid_topology_SOME M\n            \\<lparr>nodes = V, edges = E\\<rparr>)\n          (SOME F.\n              F \\<in> c_offending_flows m\n                       \\<lparr>nodes = V, edges = E\\<rparr>))", "using goal_fulfilled_M not_sinvar_off"], ["proof (prove)\nusing this:\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq>\n  {} \\<Longrightarrow>\n  all_security_requirements_fulfilled M\n   (delete_edges\n     (generate_valid_topology_SOME M \\<lparr>nodes = V, edges = E\\<rparr>)\n     (SOME F.\n         F \\<in> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr>))\n  \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    \\<forall>ma\\<in>set M.\n       c_sinvar ma\n        (delete_edges\n          (generate_valid_topology_SOME M\n            \\<lparr>nodes = V, edges = E\\<rparr>)\n          (SOME F.\n              F \\<in> c_offending_flows m\n                       \\<lparr>nodes = V, edges = E\\<rparr>))", "by(simp add: all_security_requirements_fulfilled_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  all_security_requirements_fulfilled (m # M)\n   (generate_valid_topology_SOME (m # M)\n     \\<lparr>nodes = V, edges = E\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma generate_valid_topology_SOME_def_alt:\n      \"generate_valid_topology_SOME M G = delete_edges G (\\<Union>m \\<in> set M. if c_sinvar m G then {} else (SOME F. F \\<in> c_offending_flows m G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate_valid_topology_SOME M G =\n    delete_edges G\n     (\\<Union>m\\<in>set M.\n         if c_sinvar m G then {} else SOME F. F \\<in> c_offending_flows m G)", "proof(induction M arbitrary: G)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>G.\n       generate_valid_topology_SOME [] G =\n       delete_edges G\n        (\\<Union>m\\<in>set [].\n            if c_sinvar m G then {}\n            else SOME F. F \\<in> c_offending_flows m G)\n 2. \\<And>a M G.\n       (\\<And>G.\n           generate_valid_topology_SOME M G =\n           delete_edges G\n            (\\<Union>m\\<in>set M.\n                if c_sinvar m G then {}\n                else SOME F.\n                        F \\<in> c_offending_flows m G)) \\<Longrightarrow>\n       generate_valid_topology_SOME (a # M) G =\n       delete_edges G\n        (\\<Union>m\\<in>set (a # M).\n            if c_sinvar m G then {}\n            else SOME F. F \\<in> c_offending_flows m G)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>G.\n       generate_valid_topology_SOME [] G =\n       delete_edges G\n        (\\<Union>m\\<in>set [].\n            if c_sinvar m G then {}\n            else SOME F. F \\<in> c_offending_flows m G)\n 2. \\<And>a M G.\n       (\\<And>G.\n           generate_valid_topology_SOME M G =\n           delete_edges G\n            (\\<Union>m\\<in>set M.\n                if c_sinvar m G then {}\n                else SOME F.\n                        F \\<in> c_offending_flows m G)) \\<Longrightarrow>\n       generate_valid_topology_SOME (a # M) G =\n       delete_edges G\n        (\\<Union>m\\<in>set (a # M).\n            if c_sinvar m G then {}\n            else SOME F. F \\<in> c_offending_flows m G)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. generate_valid_topology_SOME [] G =\n    delete_edges G\n     (\\<Union>m\\<in>set [].\n         if c_sinvar m G then {} else SOME F. F \\<in> c_offending_flows m G)", "by(simp add: get_offending_flows_def)"], ["proof (state)\nthis:\n  generate_valid_topology_SOME [] G =\n  delete_edges G\n   (\\<Union>m\\<in>set [].\n       if c_sinvar m G then {} else SOME F. F \\<in> c_offending_flows m G)\n\ngoal (1 subgoal):\n 1. \\<And>a M G.\n       (\\<And>G.\n           generate_valid_topology_SOME M G =\n           delete_edges G\n            (\\<Union>m\\<in>set M.\n                if c_sinvar m G then {}\n                else SOME F.\n                        F \\<in> c_offending_flows m G)) \\<Longrightarrow>\n       generate_valid_topology_SOME (a # M) G =\n       delete_edges G\n        (\\<Union>m\\<in>set (a # M).\n            if c_sinvar m G then {}\n            else SOME F. F \\<in> c_offending_flows m G)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a M G.\n       (\\<And>G.\n           generate_valid_topology_SOME M G =\n           delete_edges G\n            (\\<Union>m\\<in>set M.\n                if c_sinvar m G then {}\n                else SOME F.\n                        F \\<in> c_offending_flows m G)) \\<Longrightarrow>\n       generate_valid_topology_SOME (a # M) G =\n       delete_edges G\n        (\\<Union>m\\<in>set (a # M).\n            if c_sinvar m G then {}\n            else SOME F. F \\<in> c_offending_flows m G)", "case (Cons m M)"], ["proof (state)\nthis:\n  generate_valid_topology_SOME M ?G =\n  delete_edges ?G\n   (\\<Union>m\\<in>set M.\n       if c_sinvar m ?G then {} else SOME F. F \\<in> c_offending_flows m ?G)\n\ngoal (1 subgoal):\n 1. \\<And>a M G.\n       (\\<And>G.\n           generate_valid_topology_SOME M G =\n           delete_edges G\n            (\\<Union>m\\<in>set M.\n                if c_sinvar m G then {}\n                else SOME F.\n                        F \\<in> c_offending_flows m G)) \\<Longrightarrow>\n       generate_valid_topology_SOME (a # M) G =\n       delete_edges G\n        (\\<Union>m\\<in>set (a # M).\n            if c_sinvar m G then {}\n            else SOME F. F \\<in> c_offending_flows m G)", "from Cons[simplified delete_edges_simp2 get_offending_flows_def]"], ["proof (chain)\npicking this:\n  generate_valid_topology_SOME M ?G =\n  \\<lparr>nodes = nodes ?G,\n     edges =\n       edges ?G -\n       (\\<Union>m\\<in>set M.\n           if c_sinvar m ?G then {}\n           else SOME F. F \\<in> c_offending_flows m ?G)\\<rparr>", "have IH :\"edges (generate_valid_topology_SOME M G) =\n                   edges G - (\\<Union>m\\<in>set M. if c_sinvar m G then {} else SOME F. F \\<in> c_offending_flows m G)\""], ["proof (prove)\nusing this:\n  generate_valid_topology_SOME M ?G =\n  \\<lparr>nodes = nodes ?G,\n     edges =\n       edges ?G -\n       (\\<Union>m\\<in>set M.\n           if c_sinvar m ?G then {}\n           else SOME F. F \\<in> c_offending_flows m ?G)\\<rparr>\n\ngoal (1 subgoal):\n 1. edges (generate_valid_topology_SOME M G) =\n    edges G -\n    (\\<Union>m\\<in>set M.\n        if c_sinvar m G then {} else SOME F. F \\<in> c_offending_flows m G)", "by simp"], ["proof (state)\nthis:\n  edges (generate_valid_topology_SOME M G) =\n  edges G -\n  (\\<Union>m\\<in>set M.\n      if c_sinvar m G then {} else SOME F. F \\<in> c_offending_flows m G)\n\ngoal (1 subgoal):\n 1. \\<And>a M G.\n       (\\<And>G.\n           generate_valid_topology_SOME M G =\n           delete_edges G\n            (\\<Union>m\\<in>set M.\n                if c_sinvar m G then {}\n                else SOME F.\n                        F \\<in> c_offending_flows m G)) \\<Longrightarrow>\n       generate_valid_topology_SOME (a # M) G =\n       delete_edges G\n        (\\<Union>m\\<in>set (a # M).\n            if c_sinvar m G then {}\n            else SOME F. F \\<in> c_offending_flows m G)", "hence \"\\<not> c_sinvar m G \\<Longrightarrow> \n                    edges (generate_valid_topology_SOME (m # M) G) =\n                    (edges G) - (\\<Union>m\\<in>set (m#M). if c_sinvar m G then {} else SOME F. F \\<in> c_offending_flows m G)\""], ["proof (prove)\nusing this:\n  edges (generate_valid_topology_SOME M G) =\n  edges G -\n  (\\<Union>m\\<in>set M.\n      if c_sinvar m G then {} else SOME F. F \\<in> c_offending_flows m G)\n\ngoal (1 subgoal):\n 1. \\<not> c_sinvar m G \\<Longrightarrow>\n    edges (generate_valid_topology_SOME (m # M) G) =\n    edges G -\n    (\\<Union>m\\<in>set (m # M).\n        if c_sinvar m G then {} else SOME F. F \\<in> c_offending_flows m G)", "apply(simp add: get_offending_flows_def delete_edges_simp2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> c_sinvar m G;\n     edges (generate_valid_topology_SOME M G) =\n     edges G -\n     (\\<Union>x\\<in>set M \\<inter> {m. \\<not> c_sinvar m G}.\n         SOME F. F \\<in> c_offending_flows x G)\\<rbrakk>\n    \\<Longrightarrow> edges G -\n                      (\\<Union>x\\<in>set M \\<inter>\n                                     {m. \\<not> c_sinvar m G}.\n                          SOME F. F \\<in> c_offending_flows x G) -\n                      (SOME F. F \\<in> c_offending_flows m G) =\n                      edges G -\n                      ((SOME F. F \\<in> c_offending_flows m G) \\<union>\n                       (\\<Union>x\\<in>set M \\<inter>\n{x. \\<not> c_sinvar x G}.\n                           SOME F. F \\<in> c_offending_flows x G))", "by blast"], ["proof (state)\nthis:\n  \\<not> c_sinvar m G \\<Longrightarrow>\n  edges (generate_valid_topology_SOME (m # M) G) =\n  edges G -\n  (\\<Union>m\\<in>set (m # M).\n      if c_sinvar m G then {} else SOME F. F \\<in> c_offending_flows m G)\n\ngoal (1 subgoal):\n 1. \\<And>a M G.\n       (\\<And>G.\n           generate_valid_topology_SOME M G =\n           delete_edges G\n            (\\<Union>m\\<in>set M.\n                if c_sinvar m G then {}\n                else SOME F.\n                        F \\<in> c_offending_flows m G)) \\<Longrightarrow>\n       generate_valid_topology_SOME (a # M) G =\n       delete_edges G\n        (\\<Union>m\\<in>set (a # M).\n            if c_sinvar m G then {}\n            else SOME F. F \\<in> c_offending_flows m G)", "with Cons.IH"], ["proof (chain)\npicking this:\n  generate_valid_topology_SOME M ?G =\n  delete_edges ?G\n   (\\<Union>m\\<in>set M.\n       if c_sinvar m ?G then {} else SOME F. F \\<in> c_offending_flows m ?G)\n  \\<not> c_sinvar m G \\<Longrightarrow>\n  edges (generate_valid_topology_SOME (m # M) G) =\n  edges G -\n  (\\<Union>m\\<in>set (m # M).\n      if c_sinvar m G then {} else SOME F. F \\<in> c_offending_flows m G)", "show ?case"], ["proof (prove)\nusing this:\n  generate_valid_topology_SOME M ?G =\n  delete_edges ?G\n   (\\<Union>m\\<in>set M.\n       if c_sinvar m ?G then {} else SOME F. F \\<in> c_offending_flows m ?G)\n  \\<not> c_sinvar m G \\<Longrightarrow>\n  edges (generate_valid_topology_SOME (m # M) G) =\n  edges G -\n  (\\<Union>m\\<in>set (m # M).\n      if c_sinvar m G then {} else SOME F. F \\<in> c_offending_flows m G)\n\ngoal (1 subgoal):\n 1. generate_valid_topology_SOME (m # M) G =\n    delete_edges G\n     (\\<Union>m\\<in>set (m # M).\n         if c_sinvar m G then {} else SOME F. F \\<in> c_offending_flows m G)", "by(simp add: get_offending_flows_def delete_edges_simp2)"], ["proof (state)\nthis:\n  generate_valid_topology_SOME (m # M) G =\n  delete_edges G\n   (\\<Union>m\\<in>set (m # M).\n       if c_sinvar m G then {} else SOME F. F \\<in> c_offending_flows m G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma generate_valid_topology_SOME_superset:\n      \"\\<lbrakk> valid_reqs M; wf_graph G \\<rbrakk> \\<Longrightarrow> \n      edges (generate_valid_topology M G) \\<subseteq> edges (generate_valid_topology_SOME M G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G\\<rbrakk>\n    \\<Longrightarrow> edges (generate_valid_topology M G)\n                      \\<subseteq> edges (generate_valid_topology_SOME M G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G\\<rbrakk>\n    \\<Longrightarrow> edges (generate_valid_topology M G)\n                      \\<subseteq> edges (generate_valid_topology_SOME M G)", "have isabelle2016_1_helper:\n        \"x \\<in> (\\<Union>m\\<in>set M. if c_sinvar m G then {} else SOME F. F \\<in> c_offending_flows m G) \\<longleftrightarrow>\n          (\\<exists>m\\<in>set M. \\<not> c_sinvar m G \\<and> (c_sinvar m G \\<or> x \\<in> (SOME F. F \\<in> c_offending_flows m G)))\"\n        for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> (\\<Union>m\\<in>set M.\n                 if c_sinvar m G then {}\n                 else SOME F. F \\<in> c_offending_flows m G)) =\n    (\\<exists>m\\<in>set M.\n        \\<not> c_sinvar m G \\<and>\n        (c_sinvar m G \\<or>\n         x \\<in> (SOME F. F \\<in> c_offending_flows m G)))", "by auto"], ["proof (state)\nthis:\n  (?x \\<in> (\\<Union>m\\<in>set M.\n                if c_sinvar m G then {}\n                else SOME F. F \\<in> c_offending_flows m G)) =\n  (\\<exists>m\\<in>set M.\n      \\<not> c_sinvar m G \\<and>\n      (c_sinvar m G \\<or> ?x \\<in> (SOME F. F \\<in> c_offending_flows m G)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G\\<rbrakk>\n    \\<Longrightarrow> edges (generate_valid_topology M G)\n                      \\<subseteq> edges (generate_valid_topology_SOME M G)", "have 1: \"m\\<in>set M \\<Longrightarrow> \\<not> c_sinvar m G \\<and> (c_sinvar m G \\<or> x \\<in> (SOME F. F \\<in> c_offending_flows m G)) \\<Longrightarrow>\n            c_offending_flows m G \\<noteq> {} \\<Longrightarrow>\n            x \\<in> \\<Union>(\\<Union>m\\<in>set M. c_offending_flows m G)\"\n      for x m"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<in> set M;\n     \\<not> c_sinvar m G \\<and>\n     (c_sinvar m G \\<or> x \\<in> (SOME F. F \\<in> c_offending_flows m G));\n     c_offending_flows m G \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<Union>\n                               (\\<Union>m\\<in>set M. c_offending_flows m G)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<in> set M;\n     \\<not> c_sinvar m G \\<and>\n     (c_sinvar m G \\<or> x \\<in> (SOME F. F \\<in> c_offending_flows m G));\n     c_offending_flows m G \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y\\<in>set M.\n                         \\<exists>xa\\<in>c_offending_flows y G. x \\<in> xa", "apply(rule_tac x=m in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<in> set M;\n     \\<not> c_sinvar m G \\<and>\n     (c_sinvar m G \\<or> x \\<in> (SOME F. F \\<in> c_offending_flows m G));\n     c_offending_flows m G \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xa\\<in>c_offending_flows m G. x \\<in> xa\n 2. \\<lbrakk>m \\<in> set M;\n     \\<not> c_sinvar m G \\<and>\n     (c_sinvar m G \\<or> x \\<in> (SOME F. F \\<in> c_offending_flows m G));\n     c_offending_flows m G \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> m \\<in> set M", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<in> set M;\n     \\<not> c_sinvar m G \\<and>\n     (c_sinvar m G \\<or> x \\<in> (SOME F. F \\<in> c_offending_flows m G));\n     c_offending_flows m G \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xa\\<in>c_offending_flows m G. x \\<in> xa", "using some_in_eq"], ["proof (prove)\nusing this:\n  ((SOME x. x \\<in> ?A) \\<in> ?A) = (?A \\<noteq> {})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<in> set M;\n     \\<not> c_sinvar m G \\<and>\n     (c_sinvar m G \\<or> x \\<in> (SOME F. F \\<in> c_offending_flows m G));\n     c_offending_flows m G \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xa\\<in>c_offending_flows m G. x \\<in> xa", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?m \\<in> set M;\n   \\<not> c_sinvar ?m G \\<and>\n   (c_sinvar ?m G \\<or> ?x \\<in> (SOME F. F \\<in> c_offending_flows ?m G));\n   c_offending_flows ?m G \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> \\<Union>\n                              (\\<Union>m\\<in>set M. c_offending_flows m G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G\\<rbrakk>\n    \\<Longrightarrow> edges (generate_valid_topology M G)\n                      \\<subseteq> edges (generate_valid_topology_SOME M G)", "show \"valid_reqs M \\<Longrightarrow> wf_graph G \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G\\<rbrakk>\n    \\<Longrightarrow> edges (generate_valid_topology M G)\n                      \\<subseteq> edges (generate_valid_topology_SOME M G)", "unfolding generate_valid_topology_SOME_def_alt generate_valid_topology_def_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G\\<rbrakk>\n    \\<Longrightarrow> edges\n                       (delete_edges G (\\<Union> (get_offending_flows M G)))\n                      \\<subseteq> edges\n                                   (delete_edges G\n                                     (\\<Union>m\\<in>set M.\n   if c_sinvar m G then {} else SOME F. F \\<in> c_offending_flows m G))", "apply (rule delete_edges_edges_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph G\\<rbrakk>\n    \\<Longrightarrow> (\\<Union>m\\<in>set M.\n                          if c_sinvar m G then {}\n                          else SOME F. F \\<in> c_offending_flows m G)\n                      \\<subseteq> \\<Union> (get_offending_flows M G)", "apply (auto simp add: delete_edges_simp2 get_offending_flows_def valid_reqs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>\\<forall>x\\<in>set M. configured_SecurityInvariant x;\n        wf_graph G; (a, b) \\<in> (SOME F. F \\<in> c_offending_flows x G);\n        x \\<in> set M; \\<not> c_sinvar x G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>set M.\n                            \\<exists>x\\<in>c_offending_flows y G.\n                               (a, b) \\<in> x", "apply (metis (full_types) configured_SecurityInvariant.defined_offending' some_in_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>valid_reqs M; wf_graph G\\<rbrakk>\n  \\<Longrightarrow> edges (generate_valid_topology M G)\n                    \\<subseteq> edges (generate_valid_topology_SOME M G)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Notation:\n    @{const generate_valid_topology_SOME}: non-deterministic choice\n    \\<open>generate_valid_topology_some\\<close>: executable which selects always the same\n\\<close>"], ["", "fun generate_valid_topology_some :: \"'v SecurityInvariant_configured list \\<Rightarrow> ('v\\<times>'v) list \\<Rightarrow> 'v graph \\<Rightarrow> 'v graph\" where\n    \"generate_valid_topology_some [] _ G = G\" |\n    \"generate_valid_topology_some (m#Ms) Es G = (if c_sinvar m G\n      then generate_valid_topology_some Ms Es G\n      else delete_edges (generate_valid_topology_some Ms Es G) (set (minimalize_offending_overapprox (c_sinvar m) Es [] G))\n      )\""], ["", "theorem generate_valid_topology_some_sound:\n    \"\\<lbrakk> valid_reqs M; wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E; distinct Es \\<rbrakk> \\<Longrightarrow> \n    all_security_requirements_fulfilled M (generate_valid_topology_some M Es \\<lparr>nodes = V, edges = E\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_reqs M; wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     set Es = E; distinct Es\\<rbrakk>\n    \\<Longrightarrow> all_security_requirements_fulfilled M\n                       (generate_valid_topology_some M Es\n                         \\<lparr>nodes = V, edges = E\\<rparr>)", "proof(induction M)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_reqs []; wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     set Es = E; distinct Es\\<rbrakk>\n    \\<Longrightarrow> all_security_requirements_fulfilled []\n                       (generate_valid_topology_some [] Es\n                         \\<lparr>nodes = V, edges = E\\<rparr>)\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "case Nil"], ["proof (state)\nthis:\n  valid_reqs []\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n  set Es = E\n  distinct Es\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_reqs []; wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n     set Es = E; distinct Es\\<rbrakk>\n    \\<Longrightarrow> all_security_requirements_fulfilled []\n                       (generate_valid_topology_some [] Es\n                         \\<lparr>nodes = V, edges = E\\<rparr>)\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "thus ?case"], ["proof (prove)\nusing this:\n  valid_reqs []\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n  set Es = E\n  distinct Es\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled []\n     (generate_valid_topology_some [] Es\n       \\<lparr>nodes = V, edges = E\\<rparr>)", "by(simp add: all_security_requirements_fulfilled_def)"], ["proof (state)\nthis:\n  all_security_requirements_fulfilled []\n   (generate_valid_topology_some [] Es \\<lparr>nodes = V, edges = E\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "case (Cons m M)"], ["proof (state)\nthis:\n  \\<lbrakk>valid_reqs M; wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n   set Es = E; distinct Es\\<rbrakk>\n  \\<Longrightarrow> all_security_requirements_fulfilled M\n                     (generate_valid_topology_some M Es\n                       \\<lparr>nodes = V, edges = E\\<rparr>)\n  valid_reqs (m # M)\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n  set Es = E\n  distinct Es\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from valid_reqs1[OF Cons(2)]"], ["proof (chain)\npicking this:\n  configured_SecurityInvariant m", "have validReq: \"configured_SecurityInvariant m\""], ["proof (prove)\nusing this:\n  configured_SecurityInvariant m\n\ngoal (1 subgoal):\n 1. configured_SecurityInvariant m", "."], ["proof (state)\nthis:\n  configured_SecurityInvariant m\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from configured_SecurityInvariant.sinvar_valid_remove_minimalize_offending_overapprox[OF\n          validReq Cons.prems(2) _  Cons.prems(3) Cons.prems(4)]"], ["proof (chain)\npicking this:\n  \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        E -\n        set (SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox\n              (\\<lambda>G nP. c_sinvar m G) Es []\n              \\<lparr>nodes = V, edges = E\\<rparr> ?nP)\\<rparr>", "have rm_off_valid:\n         \"\\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr>\\<Longrightarrow>\n           c_sinvar m \\<lparr>nodes = V, edges = E - (set (minimalize_offending_overapprox (c_sinvar m) Es [] \\<lparr>nodes = V, edges = E\\<rparr>))\\<rparr>\""], ["proof (prove)\nusing this:\n  \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        E -\n        set (SecurityInvariant_withOffendingFlows.minimalize_offending_overapprox\n              (\\<lambda>G nP. c_sinvar m G) Es []\n              \\<lparr>nodes = V, edges = E\\<rparr> ?nP)\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    c_sinvar m\n     \\<lparr>nodes = V,\n        edges =\n          E -\n          set (minimalize_offending_overapprox (c_sinvar m) Es []\n                \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>", "apply(subst(asm) minimalize_offending_overapprox_boundnP[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr>;\n     \\<And>nP.\n        \\<not> c_sinvar m\n                \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n        c_sinvar m\n         \\<lparr>nodes = V,\n            edges =\n              E -\n              set (minimalize_offending_overapprox (c_sinvar m) Es []\n                    \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> c_sinvar m\n                       \\<lparr>nodes = V,\n                          edges =\n                            E -\n                            set (minimalize_offending_overapprox\n                                  (c_sinvar m) Es []\n                                  \\<lparr>nodes = V,\n                                     edges = E\\<rparr>)\\<rparr>", "(*TODO: type for nP unspecified!*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr>;\n     \\<And>nP.\n        \\<not> c_sinvar m\n                \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n        c_sinvar m\n         \\<lparr>nodes = V,\n            edges =\n              E -\n              set (minimalize_offending_overapprox (c_sinvar m) Es []\n                    \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> c_sinvar m\n                       \\<lparr>nodes = V,\n                          edges =\n                            E -\n                            set (minimalize_offending_overapprox\n                                  (c_sinvar m) Es []\n                                  \\<lparr>nodes = V,\n                                     edges = E\\<rparr>)\\<rparr>", "by blast"], ["proof (state)\nthis:\n  \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        E -\n        set (minimalize_offending_overapprox (c_sinvar m) Es []\n              \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "have generate_valid_topology_some_nodes: \"nodes (generate_valid_topology_some M Es \\<lparr>nodes = V, edges = E\\<rparr>) = V\"\n          for M::\"'a SecurityInvariant_configured list\" and V E"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes\n     (generate_valid_topology_some M Es\n       \\<lparr>nodes = V, edges = E\\<rparr>) =\n    V", "proof(induction M)"], ["proof (state)\ngoal (2 subgoals):\n 1. nodes\n     (generate_valid_topology_some [] Es\n       \\<lparr>nodes = V, edges = E\\<rparr>) =\n    V\n 2. \\<And>a M.\n       nodes\n        (generate_valid_topology_some M Es\n          \\<lparr>nodes = V, edges = E\\<rparr>) =\n       V \\<Longrightarrow>\n       nodes\n        (generate_valid_topology_some (a # M) Es\n          \\<lparr>nodes = V, edges = E\\<rparr>) =\n       V", "qed(simp_all add: delete_edges_simp2)"], ["proof (state)\nthis:\n  nodes\n   (generate_valid_topology_some ?M Es\n     \\<lparr>nodes = ?V, edges = ?E\\<rparr>) =\n  ?V\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "have generate_valid_topology_some_edges: \"edges (generate_valid_topology_some M Es \\<lparr>nodes = V, edges = E\\<rparr>) \\<subseteq> E\"\n          for M::\"'a SecurityInvariant_configured list\" and V E"], ["proof (prove)\ngoal (1 subgoal):\n 1. edges\n     (generate_valid_topology_some M Es\n       \\<lparr>nodes = V, edges = E\\<rparr>)\n    \\<subseteq> E", "proof(induction M)"], ["proof (state)\ngoal (2 subgoals):\n 1. edges\n     (generate_valid_topology_some [] Es\n       \\<lparr>nodes = V, edges = E\\<rparr>)\n    \\<subseteq> E\n 2. \\<And>a M.\n       edges\n        (generate_valid_topology_some M Es\n          \\<lparr>nodes = V, edges = E\\<rparr>)\n       \\<subseteq> E \\<Longrightarrow>\n       edges\n        (generate_valid_topology_some (a # M) Es\n          \\<lparr>nodes = V, edges = E\\<rparr>)\n       \\<subseteq> E", "qed(auto simp add: delete_edges_simp2)"], ["proof (state)\nthis:\n  edges\n   (generate_valid_topology_some ?M Es\n     \\<lparr>nodes = ?V, edges = ?E\\<rparr>)\n  \\<subseteq> ?E\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from configured_SecurityInvariant.mono_sinvar[OF validReq Cons.prems(2),\n              of \"edges (generate_valid_topology_some M Es \\<lparr>nodes = V, edges = E\\<rparr>)\"]\n            generate_valid_topology_some_edges"], ["proof (chain)\npicking this:\n  \\<lbrakk>edges\n            (generate_valid_topology_some M Es\n              \\<lparr>nodes = V, edges = E\\<rparr>)\n           \\<subseteq> E;\n   c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n  \\<Longrightarrow> c_sinvar m\n                     \\<lparr>nodes = V,\n                        edges =\n                          edges\n                           (generate_valid_topology_some M Es\n                             \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n  edges\n   (generate_valid_topology_some ?M Es\n     \\<lparr>nodes = ?V, edges = ?E\\<rparr>)\n  \\<subseteq> ?E", "have \"c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n            c_sinvar m \\<lparr>nodes = V, edges = edges (generate_valid_topology_some M Es \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>edges\n            (generate_valid_topology_some M Es\n              \\<lparr>nodes = V, edges = E\\<rparr>)\n           \\<subseteq> E;\n   c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr>\\<rbrakk>\n  \\<Longrightarrow> c_sinvar m\n                     \\<lparr>nodes = V,\n                        edges =\n                          edges\n                           (generate_valid_topology_some M Es\n                             \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n  edges\n   (generate_valid_topology_some ?M Es\n     \\<lparr>nodes = ?V, edges = ?E\\<rparr>)\n  \\<subseteq> ?E\n\ngoal (1 subgoal):\n 1. c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    c_sinvar m\n     \\<lparr>nodes = V,\n        edges =\n          edges\n           (generate_valid_topology_some M Es\n             \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>", "by simp"], ["proof (state)\nthis:\n  c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        edges\n         (generate_valid_topology_some M Es\n           \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "moreover"], ["proof (state)\nthis:\n  c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        edges\n         (generate_valid_topology_some M Es\n           \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from configured_SecurityInvariant.defined_offending'[OF validReq Cons.prems(2)]"], ["proof (chain)\npicking this:\n  \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}", "have not_sinvar_off:\n          \"\\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "ultimately"], ["proof (chain)\npicking this:\n  c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        edges\n         (generate_valid_topology_some M Es\n           \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n  \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}", "have goal_sinvar_m:\n          \"c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> = {} \\<Longrightarrow> \n              c_sinvar m (generate_valid_topology_some M Es \\<lparr>nodes = V, edges = E\\<rparr>)\""], ["proof (prove)\nusing this:\n  c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        edges\n         (generate_valid_topology_some M Es\n           \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n  \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> =\n    {} \\<Longrightarrow>\n    c_sinvar m\n     (generate_valid_topology_some M Es\n       \\<lparr>nodes = V, edges = E\\<rparr>)", "using generate_valid_topology_some_nodes"], ["proof (prove)\nusing this:\n  c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        edges\n         (generate_valid_topology_some M Es\n           \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n  \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}\n  nodes\n   (generate_valid_topology_some ?M Es\n     \\<lparr>nodes = ?V, edges = ?E\\<rparr>) =\n  ?V\n\ngoal (1 subgoal):\n 1. c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> =\n    {} \\<Longrightarrow>\n    c_sinvar m\n     (generate_valid_topology_some M Es\n       \\<lparr>nodes = V, edges = E\\<rparr>)", "by (metis graph.select_convs(1) graph.select_convs(2) graph_eq_intro)"], ["proof (state)\nthis:\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> =\n  {} \\<Longrightarrow>\n  c_sinvar m\n   (generate_valid_topology_some M Es \\<lparr>nodes = V, edges = E\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from valid_reqs2[OF Cons(2)]"], ["proof (chain)\npicking this:\n  valid_reqs M", "have \"valid_reqs M\""], ["proof (prove)\nusing this:\n  valid_reqs M\n\ngoal (1 subgoal):\n 1. valid_reqs M", "."], ["proof (state)\nthis:\n  valid_reqs M\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from Cons.IH[OF \\<open>valid_reqs M\\<close> Cons(3)] Cons.prems"], ["proof (chain)\npicking this:\n  \\<lbrakk>set Es = E; distinct Es\\<rbrakk>\n  \\<Longrightarrow> all_security_requirements_fulfilled M\n                     (generate_valid_topology_some M Es\n                       \\<lparr>nodes = V, edges = E\\<rparr>)\n  valid_reqs (m # M)\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n  set Es = E\n  distinct Es", "have IH:\n          \"all_security_requirements_fulfilled M (generate_valid_topology_some M Es \\<lparr>nodes = V, edges = E\\<rparr>)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>set Es = E; distinct Es\\<rbrakk>\n  \\<Longrightarrow> all_security_requirements_fulfilled M\n                     (generate_valid_topology_some M Es\n                       \\<lparr>nodes = V, edges = E\\<rparr>)\n  valid_reqs (m # M)\n  wf_graph \\<lparr>nodes = V, edges = E\\<rparr>\n  set Es = E\n  distinct Es\n\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled M\n     (generate_valid_topology_some M Es\n       \\<lparr>nodes = V, edges = E\\<rparr>)", "by simp"], ["proof (state)\nthis:\n  all_security_requirements_fulfilled M\n   (generate_valid_topology_some M Es \\<lparr>nodes = V, edges = E\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "have wf_graph_generate_valid_topology_some: \"wf_graph G \\<Longrightarrow> wf_graph (generate_valid_topology_some M Es G)\"\n          for G"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow>\n    wf_graph (generate_valid_topology_some M Es G)", "(*TODO: tune*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_graph G \\<Longrightarrow>\n    wf_graph (generate_valid_topology_some M Es G)", "apply(cases G)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nodes edges.\n       \\<lbrakk>wf_graph G;\n        G = \\<lparr>nodes = nodes, edges = edges\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> wf_graph (generate_valid_topology_some M Es G)", "apply(simp add: wf_graph_def generate_valid_topology_some_nodes)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nodes edgesa.\n       \\<lbrakk>fst ` edgesa \\<subseteq> nodes \\<and>\n                snd ` edgesa \\<subseteq> nodes \\<and>\n                finite edgesa \\<and> finite nodes;\n        G = \\<lparr>nodes = nodes, edges = edgesa\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> fst `\n                         edges\n                          (generate_valid_topology_some M Es\n                            \\<lparr>nodes = nodes, edges = edgesa\\<rparr>)\n                         \\<subseteq> nodes \\<and>\n                         snd `\n                         edges\n                          (generate_valid_topology_some M Es\n                            \\<lparr>nodes = nodes, edges = edgesa\\<rparr>)\n                         \\<subseteq> nodes \\<and>\n                         finite\n                          (edges\n                            (generate_valid_topology_some M Es\n                              \\<lparr>nodes = nodes,\n                                 edges = edgesa\\<rparr>))", "using generate_valid_topology_some_edges"], ["proof (prove)\nusing this:\n  edges\n   (generate_valid_topology_some ?M Es\n     \\<lparr>nodes = ?V, edges = ?E\\<rparr>)\n  \\<subseteq> ?E\n\ngoal (1 subgoal):\n 1. \\<And>nodes edgesa.\n       \\<lbrakk>fst ` edgesa \\<subseteq> nodes \\<and>\n                snd ` edgesa \\<subseteq> nodes \\<and>\n                finite edgesa \\<and> finite nodes;\n        G = \\<lparr>nodes = nodes, edges = edgesa\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> fst `\n                         edges\n                          (generate_valid_topology_some M Es\n                            \\<lparr>nodes = nodes, edges = edgesa\\<rparr>)\n                         \\<subseteq> nodes \\<and>\n                         snd `\n                         edges\n                          (generate_valid_topology_some M Es\n                            \\<lparr>nodes = nodes, edges = edgesa\\<rparr>)\n                         \\<subseteq> nodes \\<and>\n                         finite\n                          (edges\n                            (generate_valid_topology_some M Es\n                              \\<lparr>nodes = nodes,\n                                 edges = edgesa\\<rparr>))", "by (meson dual_order.trans image_mono rev_finite_subset)"], ["proof (state)\nthis:\n  wf_graph ?G \\<Longrightarrow>\n  wf_graph (generate_valid_topology_some M Es ?G)\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "{"], ["proof (state)\nthis:\n  wf_graph ?G \\<Longrightarrow>\n  wf_graph (generate_valid_topology_some M Es ?G)\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "assume notempty: \"c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}\""], ["proof (state)\nthis:\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "hence \"\\<exists> hypE. (generate_valid_topology_some M Es \\<lparr>nodes = V, edges = E\\<rparr>) = \\<lparr>nodes = V, edges = hypE\\<rparr>\""], ["proof (prove)\nusing this:\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>hypE.\n       generate_valid_topology_some M Es\n        \\<lparr>nodes = V, edges = E\\<rparr> =\n       \\<lparr>nodes = V, edges = hypE\\<rparr>", "proof(induction M arbitrary: V E)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>V E.\n       c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq>\n       {} \\<Longrightarrow>\n       \\<exists>hypE.\n          generate_valid_topology_some [] Es\n           \\<lparr>nodes = V, edges = E\\<rparr> =\n          \\<lparr>nodes = V, edges = hypE\\<rparr>\n 2. \\<And>a M V E.\n       \\<lbrakk>\\<And>V E.\n                   c_offending_flows m\n                    \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq>\n                   {} \\<Longrightarrow>\n                   \\<exists>hypE.\n                      generate_valid_topology_some M Es\n                       \\<lparr>nodes = V, edges = E\\<rparr> =\n                      \\<lparr>nodes = V, edges = hypE\\<rparr>;\n        c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq>\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>hypE.\n                            generate_valid_topology_some (a # M) Es\n                             \\<lparr>nodes = V, edges = E\\<rparr> =\n                            \\<lparr>nodes = V, edges = hypE\\<rparr>", "qed(simp_all add: delete_edges_simp2 generate_valid_topology_some_nodes)"], ["proof (state)\nthis:\n  \\<exists>hypE.\n     generate_valid_topology_some M Es\n      \\<lparr>nodes = V, edges = E\\<rparr> =\n     \\<lparr>nodes = V, edges = hypE\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>hypE.\n     generate_valid_topology_some M Es\n      \\<lparr>nodes = V, edges = E\\<rparr> =\n     \\<lparr>nodes = V, edges = hypE\\<rparr>", "obtain E_IH where E_IH_prop:\n            \"(generate_valid_topology_some M Es \\<lparr>nodes = V, edges = E\\<rparr>) = \\<lparr>nodes = V, edges = E_IH\\<rparr>\""], ["proof (prove)\nusing this:\n  \\<exists>hypE.\n     generate_valid_topology_some M Es\n      \\<lparr>nodes = V, edges = E\\<rparr> =\n     \\<lparr>nodes = V, edges = hypE\\<rparr>\n\ngoal (1 subgoal):\n 1. (\\<And>E_IH.\n        generate_valid_topology_some M Es\n         \\<lparr>nodes = V, edges = E\\<rparr> =\n        \\<lparr>nodes = V, edges = E_IH\\<rparr> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  generate_valid_topology_some M Es \\<lparr>nodes = V, edges = E\\<rparr> =\n  \\<lparr>nodes = V, edges = E_IH\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from wf_graph_generate_valid_topology_some[OF Cons(3)] E_IH_prop"], ["proof (chain)\npicking this:\n  wf_graph\n   (generate_valid_topology_some M Es \\<lparr>nodes = V, edges = E\\<rparr>)\n  generate_valid_topology_some M Es \\<lparr>nodes = V, edges = E\\<rparr> =\n  \\<lparr>nodes = V, edges = E_IH\\<rparr>", "have valid_G_E_IH: \"wf_graph \\<lparr>nodes = V, edges = E_IH\\<rparr>\""], ["proof (prove)\nusing this:\n  wf_graph\n   (generate_valid_topology_some M Es \\<lparr>nodes = V, edges = E\\<rparr>)\n  generate_valid_topology_some M Es \\<lparr>nodes = V, edges = E\\<rparr> =\n  \\<lparr>nodes = V, edges = E_IH\\<rparr>\n\ngoal (1 subgoal):\n 1. wf_graph \\<lparr>nodes = V, edges = E_IH\\<rparr>", "by simp"], ["proof (state)\nthis:\n  wf_graph \\<lparr>nodes = V, edges = E_IH\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "from all_security_requirements_fulfilled_mono[OF \\<open>valid_reqs M\\<close> _ valid_G_E_IH ] IH E_IH_prop"], ["proof (chain)\npicking this:\n  \\<lbrakk>?E' \\<subseteq> E_IH;\n   all_security_requirements_fulfilled M\n    \\<lparr>nodes = V, edges = E_IH\\<rparr>\\<rbrakk>\n  \\<Longrightarrow> all_security_requirements_fulfilled M\n                     \\<lparr>nodes = V, edges = ?E'\\<rparr>\n  all_security_requirements_fulfilled M\n   (generate_valid_topology_some M Es \\<lparr>nodes = V, edges = E\\<rparr>)\n  generate_valid_topology_some M Es \\<lparr>nodes = V, edges = E\\<rparr> =\n  \\<lparr>nodes = V, edges = E_IH\\<rparr>", "have mono_rule: \"E' \\<subseteq> E_IH \\<Longrightarrow> all_security_requirements_fulfilled M \\<lparr>nodes = V, edges = E'\\<rparr>\" for E'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?E' \\<subseteq> E_IH;\n   all_security_requirements_fulfilled M\n    \\<lparr>nodes = V, edges = E_IH\\<rparr>\\<rbrakk>\n  \\<Longrightarrow> all_security_requirements_fulfilled M\n                     \\<lparr>nodes = V, edges = ?E'\\<rparr>\n  all_security_requirements_fulfilled M\n   (generate_valid_topology_some M Es \\<lparr>nodes = V, edges = E\\<rparr>)\n  generate_valid_topology_some M Es \\<lparr>nodes = V, edges = E\\<rparr> =\n  \\<lparr>nodes = V, edges = E_IH\\<rparr>\n\ngoal (1 subgoal):\n 1. E' \\<subseteq> E_IH \\<Longrightarrow>\n    all_security_requirements_fulfilled M\n     \\<lparr>nodes = V, edges = E'\\<rparr>", "by simp"], ["proof (state)\nthis:\n  ?E' \\<subseteq> E_IH \\<Longrightarrow>\n  all_security_requirements_fulfilled M\n   \\<lparr>nodes = V, edges = ?E'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "have \"all_security_requirements_fulfilled M\n            (delete_edges (generate_valid_topology_some M Es \\<lparr>nodes = V, edges = E\\<rparr>)\n                          (set (minimalize_offending_overapprox (c_sinvar m) Es [] \\<lparr>nodes = V, edges = E\\<rparr>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled M\n     (delete_edges\n       (generate_valid_topology_some M Es\n         \\<lparr>nodes = V, edges = E\\<rparr>)\n       (set (minimalize_offending_overapprox (c_sinvar m) Es []\n              \\<lparr>nodes = V, edges = E\\<rparr>)))", "unfolding E_IH_prop"], ["proof (prove)\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled M\n     (delete_edges \\<lparr>nodes = V, edges = E_IH\\<rparr>\n       (set (minimalize_offending_overapprox (c_sinvar m) Es []\n              \\<lparr>nodes = V, edges = E\\<rparr>)))", "by(auto simp add: delete_edges_simp2 intro:mono_rule)"], ["proof (state)\nthis:\n  all_security_requirements_fulfilled M\n   (delete_edges\n     (generate_valid_topology_some M Es\n       \\<lparr>nodes = V, edges = E\\<rparr>)\n     (set (minimalize_offending_overapprox (c_sinvar m) Es []\n            \\<lparr>nodes = V, edges = E\\<rparr>)))\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "}"], ["proof (state)\nthis:\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq>\n  {} \\<Longrightarrow>\n  all_security_requirements_fulfilled M\n   (delete_edges\n     (generate_valid_topology_some M Es\n       \\<lparr>nodes = V, edges = E\\<rparr>)\n     (set (minimalize_offending_overapprox (c_sinvar m) Es []\n            \\<lparr>nodes = V, edges = E\\<rparr>)))\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "note goal_fulfilled_M=this"], ["proof (state)\nthis:\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq>\n  {} \\<Longrightarrow>\n  all_security_requirements_fulfilled M\n   (delete_edges\n     (generate_valid_topology_some M Es\n       \\<lparr>nodes = V, edges = E\\<rparr>)\n     (set (minimalize_offending_overapprox (c_sinvar m) Es []\n            \\<lparr>nodes = V, edges = E\\<rparr>)))\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "have no_offending: \"c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow> c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> = {}", "by (simp add: configured_SecurityInvariant.c_sinvar_valid_imp_no_offending_flows validReq)"], ["proof (state)\nthis:\n  c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> = {}\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>valid_reqs M;\n                 wf_graph \\<lparr>nodes = V, edges = E\\<rparr>; set Es = E;\n                 distinct Es\\<rbrakk>\n                \\<Longrightarrow> all_security_requirements_fulfilled M\n                                   (generate_valid_topology_some M Es\n                                     \\<lparr>nodes = V, edges = E\\<rparr>);\n        valid_reqs (a # M); wf_graph \\<lparr>nodes = V, edges = E\\<rparr>;\n        set Es = E; distinct Es\\<rbrakk>\n       \\<Longrightarrow> all_security_requirements_fulfilled (a # M)\n                          (generate_valid_topology_some (a # M) Es\n                            \\<lparr>nodes = V, edges = E\\<rparr>)", "show \"all_security_requirements_fulfilled (m # M) (generate_valid_topology_some (m # M) Es \\<lparr>nodes = V, edges = E\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_security_requirements_fulfilled (m # M)\n     (generate_valid_topology_some (m # M) Es\n       \\<lparr>nodes = V, edges = E\\<rparr>)", "apply(simp add: all_security_requirements_fulfilled_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<longrightarrow>\n     c_sinvar m\n      (generate_valid_topology_some M Es\n        \\<lparr>nodes = V, edges = E\\<rparr>) \\<and>\n     (\\<forall>m\\<in>set M.\n         c_sinvar m\n          (generate_valid_topology_some M Es\n            \\<lparr>nodes = V, edges = E\\<rparr>))) \\<and>\n    (\\<not> c_sinvar m\n             \\<lparr>nodes = V, edges = E\\<rparr> \\<longrightarrow>\n     c_sinvar m\n      (delete_edges\n        (generate_valid_topology_some M Es\n          \\<lparr>nodes = V, edges = E\\<rparr>)\n        (set (minimalize_offending_overapprox (c_sinvar m) Es []\n               \\<lparr>nodes = V, edges = E\\<rparr>))) \\<and>\n     (\\<forall>ma\\<in>set M.\n         c_sinvar ma\n          (delete_edges\n            (generate_valid_topology_some M Es\n              \\<lparr>nodes = V, edges = E\\<rparr>)\n            (set (minimalize_offending_overapprox (c_sinvar m) Es []\n                   \\<lparr>nodes = V, edges = E\\<rparr>)))))", "apply(intro conjI impI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    c_sinvar m\n     (generate_valid_topology_some M Es\n       \\<lparr>nodes = V, edges = E\\<rparr>)\n 2. c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    \\<forall>m\\<in>set M.\n       c_sinvar m\n        (generate_valid_topology_some M Es\n          \\<lparr>nodes = V, edges = E\\<rparr>)\n 3. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    c_sinvar m\n     (delete_edges\n       (generate_valid_topology_some M Es\n         \\<lparr>nodes = V, edges = E\\<rparr>)\n       (set (minimalize_offending_overapprox (c_sinvar m) Es []\n              \\<lparr>nodes = V, edges = E\\<rparr>)))\n 4. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    \\<forall>ma\\<in>set M.\n       c_sinvar ma\n        (delete_edges\n          (generate_valid_topology_some M Es\n            \\<lparr>nodes = V, edges = E\\<rparr>)\n          (set (minimalize_offending_overapprox (c_sinvar m) Es []\n                 \\<lparr>nodes = V, edges = E\\<rparr>)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    c_sinvar m\n     (generate_valid_topology_some M Es\n       \\<lparr>nodes = V, edges = E\\<rparr>)", "using goal_sinvar_m no_offending"], ["proof (prove)\nusing this:\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> =\n  {} \\<Longrightarrow>\n  c_sinvar m\n   (generate_valid_topology_some M Es \\<lparr>nodes = V, edges = E\\<rparr>)\n  c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> = {}\n\ngoal (1 subgoal):\n 1. c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    c_sinvar m\n     (generate_valid_topology_some M Es\n       \\<lparr>nodes = V, edges = E\\<rparr>)", "by blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    \\<forall>m\\<in>set M.\n       c_sinvar m\n        (generate_valid_topology_some M Es\n          \\<lparr>nodes = V, edges = E\\<rparr>)\n 2. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    c_sinvar m\n     (delete_edges\n       (generate_valid_topology_some M Es\n         \\<lparr>nodes = V, edges = E\\<rparr>)\n       (set (minimalize_offending_overapprox (c_sinvar m) Es []\n              \\<lparr>nodes = V, edges = E\\<rparr>)))\n 3. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    \\<forall>ma\\<in>set M.\n       c_sinvar ma\n        (delete_edges\n          (generate_valid_topology_some M Es\n            \\<lparr>nodes = V, edges = E\\<rparr>)\n          (set (minimalize_offending_overapprox (c_sinvar m) Es []\n                 \\<lparr>nodes = V, edges = E\\<rparr>)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    \\<forall>m\\<in>set M.\n       c_sinvar m\n        (generate_valid_topology_some M Es\n          \\<lparr>nodes = V, edges = E\\<rparr>)", "using IH"], ["proof (prove)\nusing this:\n  all_security_requirements_fulfilled M\n   (generate_valid_topology_some M Es \\<lparr>nodes = V, edges = E\\<rparr>)\n\ngoal (1 subgoal):\n 1. c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    \\<forall>m\\<in>set M.\n       c_sinvar m\n        (generate_valid_topology_some M Es\n          \\<lparr>nodes = V, edges = E\\<rparr>)", "by(simp add: all_security_requirements_fulfilled_def; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    c_sinvar m\n     (delete_edges\n       (generate_valid_topology_some M Es\n         \\<lparr>nodes = V, edges = E\\<rparr>)\n       (set (minimalize_offending_overapprox (c_sinvar m) Es []\n              \\<lparr>nodes = V, edges = E\\<rparr>)))\n 2. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    \\<forall>ma\\<in>set M.\n       c_sinvar ma\n        (delete_edges\n          (generate_valid_topology_some M Es\n            \\<lparr>nodes = V, edges = E\\<rparr>)\n          (set (minimalize_offending_overapprox (c_sinvar m) Es []\n                 \\<lparr>nodes = V, edges = E\\<rparr>)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    c_sinvar m\n     (delete_edges\n       (generate_valid_topology_some M Es\n         \\<lparr>nodes = V, edges = E\\<rparr>)\n       (set (minimalize_offending_overapprox (c_sinvar m) Es []\n              \\<lparr>nodes = V, edges = E\\<rparr>)))", "using rm_off_valid"], ["proof (prove)\nusing this:\n  \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_sinvar m\n   \\<lparr>nodes = V,\n      edges =\n        E -\n        set (minimalize_offending_overapprox (c_sinvar m) Es []\n              \\<lparr>nodes = V, edges = E\\<rparr>)\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    c_sinvar m\n     (delete_edges\n       (generate_valid_topology_some M Es\n         \\<lparr>nodes = V, edges = E\\<rparr>)\n       (set (minimalize_offending_overapprox (c_sinvar m) Es []\n              \\<lparr>nodes = V, edges = E\\<rparr>)))", "by (metis (no_types, lifting) Cons.prems(2) Diff_mono \n            configured_SecurityInvariant.mono_sinvar delete_edges_simp2 generate_valid_topology_some_edges\n            generate_valid_topology_some_nodes order_refl validReq wf_graph_remove_edges)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    \\<forall>ma\\<in>set M.\n       c_sinvar ma\n        (delete_edges\n          (generate_valid_topology_some M Es\n            \\<lparr>nodes = V, edges = E\\<rparr>)\n          (set (minimalize_offending_overapprox (c_sinvar m) Es []\n                 \\<lparr>nodes = V, edges = E\\<rparr>)))", "(*TODO!*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    \\<forall>ma\\<in>set M.\n       c_sinvar ma\n        (delete_edges\n          (generate_valid_topology_some M Es\n            \\<lparr>nodes = V, edges = E\\<rparr>)\n          (set (minimalize_offending_overapprox (c_sinvar m) Es []\n                 \\<lparr>nodes = V, edges = E\\<rparr>)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    \\<forall>ma\\<in>set M.\n       c_sinvar ma\n        (delete_edges\n          (generate_valid_topology_some M Es\n            \\<lparr>nodes = V, edges = E\\<rparr>)\n          (set (minimalize_offending_overapprox (c_sinvar m) Es []\n                 \\<lparr>nodes = V, edges = E\\<rparr>)))", "using goal_fulfilled_M not_sinvar_off"], ["proof (prove)\nusing this:\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq>\n  {} \\<Longrightarrow>\n  all_security_requirements_fulfilled M\n   (delete_edges\n     (generate_valid_topology_some M Es\n       \\<lparr>nodes = V, edges = E\\<rparr>)\n     (set (minimalize_offending_overapprox (c_sinvar m) Es []\n            \\<lparr>nodes = V, edges = E\\<rparr>)))\n  \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n  c_offending_flows m \\<lparr>nodes = V, edges = E\\<rparr> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> c_sinvar m \\<lparr>nodes = V, edges = E\\<rparr> \\<Longrightarrow>\n    \\<forall>ma\\<in>set M.\n       c_sinvar ma\n        (delete_edges\n          (generate_valid_topology_some M Es\n            \\<lparr>nodes = V, edges = E\\<rparr>)\n          (set (minimalize_offending_overapprox (c_sinvar m) Es []\n                 \\<lparr>nodes = V, edges = E\\<rparr>)))", "by(simp add: all_security_requirements_fulfilled_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  all_security_requirements_fulfilled (m # M)\n   (generate_valid_topology_some (m # M) Es\n     \\<lparr>nodes = V, edges = E\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}