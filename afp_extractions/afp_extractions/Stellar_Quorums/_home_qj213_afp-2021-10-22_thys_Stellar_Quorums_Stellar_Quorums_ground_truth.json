{"file_name": "/home/qj213/afp-2021-10-22/thys/Stellar_Quorums/Stellar_Quorums.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Stellar_Quorums", "problem_names": ["lemma blocked_blocked_subset_blocked:\n  \"blocked_by (blocked_by R) \\<subseteq> blocked_by R\"", "lemma l2: \"p \\<in> L \\<Longrightarrow> \\<exists> Q  \\<subseteq> W. quorum_of p Q\"", "lemma l3: \\<comment>  \\<open>If a participant is not blocked by the malicious participants, then it has a quorum consisting exclusively of correct \nparticipants which are not blocked by the malicious participants.\\<close>\n  assumes \"p \\<in> L\" shows \"\\<exists> Q \\<subseteq> L . quorum_of p Q\"", "lemma strong_consensus_cluster_imp_cons_cluster:\n\\<comment> \\<open>Every intact set is a consensus cluster\\<close>\n  shows \"strong_consensus_cluster I \\<Longrightarrow> is_cons_cluster I\"", "lemma cons_cluster_neq_cons_cluster:\n  \\<comment> \\<open>Some consensus clusters are not strong consensus clusters and have no superset that is a strong consensus cluster.\\<close>\n  shows \"is_cons_cluster I \\<and> (\\<forall> J . I \\<subseteq> J \\<longrightarrow> \\<not>strong_consensus_cluster J)\"", "theorem cluster_union:\n  assumes \"is_cons_cluster C\\<^sub>1\" and \"is_cons_cluster C\\<^sub>2\" and \"C\\<^sub>1 \\<inter> C\\<^sub>2 \\<noteq> {}\"\n  shows \"is_cons_cluster (C\\<^sub>1\\<union> C\\<^sub>2)\"", "lemma strong_cluster_union:\n  assumes \"strong_consensus_cluster C\\<^sub>1\" and \"strong_consensus_cluster C\\<^sub>2\" and \"C\\<^sub>1 \\<inter> C\\<^sub>2 \\<noteq> {}\"\n  shows \"strong_consensus_cluster (C\\<^sub>1\\<union> C\\<^sub>2)\"", "lemma quorum_union:\"quorum Q \\<Longrightarrow> quorum Q' \\<Longrightarrow> quorum (Q \\<union> Q')\"", "lemma l1:\n  assumes \"\\<And> p . p \\<in> S \\<Longrightarrow> \\<exists> Q \\<subseteq> S . quorum_of p Q\" and \"p\\<in> S\"\n  shows \"quorum_of p S\"", "lemma is_pbqs:\n  assumes \"quorum_of p Q\" and \"p' \\<in> Q\"\n  shows \"quorum_of p' Q\" \n  \\<comment> \\<open>This is the property required of a PBQS.\\<close>", "lemma quorum_is_quorum_of_some_slice:\n  assumes \"quorum_of p Q\" and \"p \\<in> W\"\n  obtains S where \"S \\<in> slices p\" and \"S \\<subseteq> Q\"\n    and \"\\<And> p' . p' \\<in> S \\<inter> W \\<Longrightarrow> quorum_of p' Q\"", "lemma \"is_cons_cluster C \\<Longrightarrow> quorum C\" \n  \\<comment> \\<open>Every consensus cluster is a quorum.\\<close>", "lemma cons_cluster_wb:\"p \\<in> C \\<Longrightarrow> is_cons_cluster C \\<Longrightarrow> p\\<in>W\"", "lemma cons_cluster_has_ne_slices:\n  assumes \"is_cons_cluster C\" and \"p\\<in>C\"\n    and \"Sl \\<in> slices p\" \n  shows \"Sl \\<noteq> {}\"", "lemma cons_cluster_has_cons_cluster_slice:\n  assumes \"is_cons_cluster C\" and \"p\\<in>C\"\n  obtains Sl where \"Sl \\<in> slices p\" and \"Sl \\<subseteq> C\"", "theorem blocking_max_intersects_intact:\n  \\<comment> \\<open>if @{term \\<open>R\\<close>} blocks @{term \\<open>p\\<close>} when malicious participants help epidemic propagation, \nand @{term p} belongs to a consensus cluster @{term C}, then @{term \\<open>R \\<inter> C \\<noteq> {}\\<close>}\\<close>\n  assumes  \"blocking_max R p\" and \"is_cons_cluster C\" and \"p \\<in> C\"\n  shows \"R \\<inter> C \\<noteq> {}\"", "lemma l4:\n  fixes Q p R\n  defines \"Q \\<equiv> {q . not_blocked p R q}\"\n  shows \"quorum Q\"", "lemma l5:\n  fixes Q p R\n  defines \"Q \\<equiv> {q . not_blocked p R q}\"\n  assumes  \"\\<not>blocking_min R p\" and \\<open>p\\<in>C\\<close> and \\<open>is_cons_cluster C\\<close>\n  shows \"quorum_of p Q\"", "lemma cons_cluster_ne_slices:\n  assumes \"is_cons_cluster C\" and \"p\\<in>C\" and \"Sl \\<in> slices p\"\n  shows \"Sl\\<noteq>{}\"", "lemma l6:\n  fixes Q p R\n  defines \"Q \\<equiv> {q . not_blocked p R q}\"\n  shows \"Q \\<inter> R \\<inter> W = {}\"", "theorem quorum_blocks_cons_cluster:\n  assumes \"quorum_of_set C Q\" and \"p\\<in>C\" and \"is_cons_cluster C\"\n  shows \"blocking_min (Q \\<inter> W) p\"", "lemma l13:\n  assumes \"quorum_of p Q\" and \"p \\<in> W\" and \"reachable_through p Q p'\"\n  shows \"quorum_of p' Q\"", "lemma l14:\n  assumes \"quorum_of p Q\" and \"p \\<in> W\"\n  shows \"quorum (truncation p Q)\"", "lemma l15:\n  assumes \"is_cons_cluster I\" and \"quorum_of p Q\" and \"quorum_of p' Q'\" and \"p \\<in> I\" and \"p' \\<in> I\" and \"Q \\<inter> Q' \\<inter> W \\<noteq> {}\"\n  shows \"W \\<inter> (truncation p Q) \\<inter> (truncation p' Q') \\<noteq> {}\"", "lemma finite_subset_wf:\n  shows \"wf {(X, Y). X \\<subset> Y \\<and> finite Y}\"", "lemma quorum_contains_elementary:\n  assumes \"finite s\" and  \"\\<not> elementary s\" and \"quorum s\" \n  shows \"\\<exists> s' . s' \\<subset> s \\<and> elementary s'\"", "theorem elementary_connected:\n  assumes \"elementary s\" and \"n\\<^sub>1 \\<in> s\" and \"n\\<^sub>2 \\<in> s\" and \"n\\<^sub>1 \\<in> W\" and \"n\\<^sub>2 \\<in> W\"\n  shows \"\\<exists> l . hd (rev l) = n\\<^sub>1 \\<and> hd l = n\\<^sub>2 \\<and> path l\" (is ?P)", "theorem blocking_safe: \\<comment> \\<open>A set that blocks an intact node contains an intact node. \nIf this were not the case, quorum availability would trivially be violated.\\<close>\n  fixes S n\n  assumes \"n\\<in>I\" and \"\\<forall> Sl\\<in> slices n .Sl\\<inter>S \\<noteq> {}\"\n  shows \"S \\<inter> I \\<noteq> {}\"", "theorem cascade:\n\\<comment> \\<open>If @{term U} is a quorum of an intact node and @{term S} is a super-set of @{term U}, then either @{term S} includes \nall intact nodes or there is an intact node outside of @{term S} which is blocked by the intact members of @{term S}.\nThis shows that, in SCP, once the intact members of a quorum accept a statement, \na cascading effect occurs and all intact nodes eventually accept it regardless of what befouled and faulty nodes do.\\<close>\n  fixes U S\n  assumes \"orig.quorum U\" and \"U \\<inter> I \\<noteq> {}\" and \"U \\<subseteq> S\"\n  obtains \"I \\<subseteq> S\" | \"\\<exists> n \\<in> I - S . \\<forall> Sl \\<in> slices n . Sl \\<inter> S \\<inter> I \\<noteq> {}\"", "theorem union_quorum: \"i1.orig.quorum (I\\<^sub>1\\<union>I\\<^sub>2)\" \\<comment> \\<open>@{term \\<open>I\\<^sub>1\\<union>I\\<^sub>2\\<close>} is a quorum in the original system.\\<close>", "theorem union_quorum_intersection: \n  assumes \"proj.quorum Q\\<^sub>1\" and \"proj.quorum Q\\<^sub>2\" and \"Q\\<^sub>1 \\<inter> (I\\<^sub>1\\<union>I\\<^sub>2) \\<noteq> {}\" and \"Q\\<^sub>2 \\<inter> (I\\<^sub>1\\<union>I\\<^sub>2) \\<noteq> {}\"\n  shows \"Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter> (I\\<^sub>1\\<union>I\\<^sub>2) \\<noteq> {}\"\n    \\<comment> \\<open>Any two sets that intersect @{term \\<open>I\\<^sub>1\\<union>I\\<^sub>2\\<close>} and that are quorums in the system projected on @{term \\<open>I\\<^sub>1\\<union>I\\<^sub>2\\<close>} intersect in @{term \\<open>I\\<^sub>1\\<union>I\\<^sub>2\\<close>}.\\<close>"], "translations": [["", "lemma blocked_blocked_subset_blocked:\n  \"blocked_by (blocked_by R) \\<subseteq> blocked_by R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blocked_by (blocked_by R) \\<subseteq> blocked_by R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. blocked_by (blocked_by R) \\<subseteq> blocked_by R", "have False if \"p \\<in> blocked_by (blocked_by R)\" and \"p \\<notin> blocked_by R\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"Q \\<inter> blocked_by R \\<noteq> {}\" if \"quorum_of p Q\" for Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<inter> blocked_by R \\<noteq> {}", "using \\<open>p \\<in> blocked_by (blocked_by R)\\<close> that"], ["proof (prove)\nusing this:\n  p \\<in> blocked_by (blocked_by R)\n  quorum_of p Q\n\ngoal (1 subgoal):\n 1. Q \\<inter> blocked_by R \\<noteq> {}", "unfolding blocks_def"], ["proof (prove)\nusing this:\n  p \\<in> {p. \\<forall>Q.\n                 quorum_of p Q \\<longrightarrow>\n                 Q \\<inter>\n                 {p. \\<forall>Q.\n                        quorum_of p Q \\<longrightarrow>\n                        Q \\<inter> R \\<noteq> {}} \\<noteq>\n                 {}}\n  quorum_of p Q\n\ngoal (1 subgoal):\n 1. Q \\<inter>\n    {p. \\<forall>Q.\n           quorum_of p Q \\<longrightarrow>\n           Q \\<inter> R \\<noteq> {}} \\<noteq>\n    {}", "by auto"], ["proof (state)\nthis:\n  quorum_of p ?Q \\<Longrightarrow> ?Q \\<inter> blocked_by R \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "have \"Q \\<inter> R \\<noteq> {}\" if \" quorum_of p Q\" for Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<inter> R \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Q \\<inter> R \\<noteq> {}", "obtain p' where \"p' \\<in> blocked_by R\" and \"p' \\<in> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>p' \\<in> blocked_by R; p' \\<in> Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson Int_emptyI \\<open>\\<And>Q. quorum_of p Q \\<Longrightarrow> Q \\<inter> blocked_by R \\<noteq> {}\\<close> \\<open>quorum_of p Q\\<close>)"], ["proof (state)\nthis:\n  p' \\<in> blocked_by R\n  p' \\<in> Q\n\ngoal (1 subgoal):\n 1. Q \\<inter> R \\<noteq> {}", "hence \"quorum_of p' Q\""], ["proof (prove)\nusing this:\n  p' \\<in> blocked_by R\n  p' \\<in> Q\n\ngoal (1 subgoal):\n 1. quorum_of p' Q", "using quorum_assm that"], ["proof (prove)\nusing this:\n  p' \\<in> blocked_by R\n  p' \\<in> Q\n  \\<lbrakk>quorum_of ?p ?Q; ?p' \\<in> ?Q\\<rbrakk>\n  \\<Longrightarrow> quorum_of ?p' ?Q\n  quorum_of p Q\n\ngoal (1 subgoal):\n 1. quorum_of p' Q", "by blast"], ["proof (state)\nthis:\n  quorum_of p' Q\n\ngoal (1 subgoal):\n 1. Q \\<inter> R \\<noteq> {}", "with \\<open>p' \\<in> blocked_by R\\<close>"], ["proof (chain)\npicking this:\n  p' \\<in> blocked_by R\n  quorum_of p' Q", "show \"Q \\<inter> R \\<noteq> {}\""], ["proof (prove)\nusing this:\n  p' \\<in> blocked_by R\n  quorum_of p' Q\n\ngoal (1 subgoal):\n 1. Q \\<inter> R \\<noteq> {}", "using blocks_def"], ["proof (prove)\nusing this:\n  p' \\<in> blocked_by R\n  quorum_of p' Q\n  blocks ?R ?p \\<equiv>\n  \\<forall>Q. quorum_of ?p Q \\<longrightarrow> Q \\<inter> ?R \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Q \\<inter> R \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  Q \\<inter> R \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  quorum_of p ?Q \\<Longrightarrow> ?Q \\<inter> R \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "hence \"p \\<in> blocked_by R\""], ["proof (prove)\nusing this:\n  quorum_of p ?Q \\<Longrightarrow> ?Q \\<inter> R \\<noteq> {}\n\ngoal (1 subgoal):\n 1. p \\<in> blocked_by R", "by (simp add: blocks_def)"], ["proof (state)\nthis:\n  p \\<in> blocked_by R\n\ngoal (1 subgoal):\n 1. False", "thus False"], ["proof (prove)\nusing this:\n  p \\<in> blocked_by R\n\ngoal (1 subgoal):\n 1. False", "using that(2)"], ["proof (prove)\nusing this:\n  p \\<in> blocked_by R\n  p \\<notin> blocked_by R\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?p \\<in> blocked_by (blocked_by R);\n   ?p \\<notin> blocked_by R\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. blocked_by (blocked_by R) \\<subseteq> blocked_by R", "thus \"blocked_by (blocked_by R) \\<subseteq> blocked_by R\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<in> blocked_by (blocked_by R);\n   ?p \\<notin> blocked_by R\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. blocked_by (blocked_by R) \\<subseteq> blocked_by R", "by blast"], ["proof (state)\nthis:\n  blocked_by (blocked_by R) \\<subseteq> blocked_by R\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>We now add the set of correct participants to the model.\\<close>"], ["", "locale with_w = personal_quorums quorum_of for quorum_of  :: \"'node \\<Rightarrow> 'node set \\<Rightarrow> bool\" +\n  fixes W::\"'node set\" \\<comment> \\<open>@{term W} is the set of correct participants\\<close>\nbegin"], ["", "abbreviation B where \"B \\<equiv> -W\"\n  \\<comment> \\<open>@{term B} is the set of malicious participants.\\<close>"], ["", "definition quorum_of_set where \"quorum_of_set S Q \\<equiv> \\<exists> p \\<in> S . quorum_of p Q\""], ["", "subsection \"The set of participants not blocked by malicious participants\""], ["", "definition L where \"L \\<equiv> W - (blocked_by B)\""], ["", "lemma l2: \"p \\<in> L \\<Longrightarrow> \\<exists> Q  \\<subseteq> W. quorum_of p Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> L \\<Longrightarrow> \\<exists>Q\\<subseteq>W. quorum_of p Q", "unfolding L_def blocks_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> W -\n            {p. \\<forall>Q.\n                   quorum_of p Q \\<longrightarrow>\n                   Q \\<inter> B \\<noteq> {}} \\<Longrightarrow>\n    \\<exists>Q\\<subseteq>W. quorum_of p Q", "using DiffD2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?c \\<in> ?A - ?B; ?c \\<in> ?B\\<rbrakk> \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. p \\<in> W -\n            {p. \\<forall>Q.\n                   quorum_of p Q \\<longrightarrow>\n                   Q \\<inter> B \\<noteq> {}} \\<Longrightarrow>\n    \\<exists>Q\\<subseteq>W. quorum_of p Q", "by auto"], ["", "lemma l3: \\<comment>  \\<open>If a participant is not blocked by the malicious participants, then it has a quorum consisting exclusively of correct \nparticipants which are not blocked by the malicious participants.\\<close>\n  assumes \"p \\<in> L\" shows \"\\<exists> Q \\<subseteq> L . quorum_of p Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q\\<subseteq>L. quorum_of p Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>Q\\<subseteq>L. quorum_of p Q", "have False if \"\\<And> Q . quorum_of p Q \\<Longrightarrow> Q \\<inter> (-L) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "obtain Q where \"quorum_of p Q\" and \"Q \\<subseteq> W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>quorum_of p Q; Q \\<subseteq> W\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using l2 \\<open>p \\<in> L\\<close>"], ["proof (prove)\nusing this:\n  ?p \\<in> L \\<Longrightarrow> \\<exists>Q\\<subseteq>W. quorum_of ?p Q\n  p \\<in> L\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>quorum_of p Q; Q \\<subseteq> W\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  quorum_of p Q\n  Q \\<subseteq> W\n\ngoal (1 subgoal):\n 1. False", "have \"Q \\<inter> (-L) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<inter> - L \\<noteq> {}", "using that \\<open>quorum_of p Q\\<close>"], ["proof (prove)\nusing this:\n  quorum_of p ?Q \\<Longrightarrow> ?Q \\<inter> - L \\<noteq> {}\n  quorum_of p Q\n\ngoal (1 subgoal):\n 1. Q \\<inter> - L \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  Q \\<inter> - L \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "obtain p' where \"p' \\<in> Q \\<inter> (-L)\" and \"quorum_of p' Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>p' \\<in> Q \\<inter> - L; quorum_of p' Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>Q \\<inter> - L \\<noteq> {}\\<close> \\<open>quorum_of p Q\\<close> inf.left_idem quorum_assm"], ["proof (prove)\nusing this:\n  Q \\<inter> - L \\<noteq> {}\n  quorum_of p Q\n  inf ?a (inf ?a ?b) = inf ?a ?b\n  \\<lbrakk>quorum_of ?p ?Q; ?p' \\<in> ?Q\\<rbrakk>\n  \\<Longrightarrow> quorum_of ?p' ?Q\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>p' \\<in> Q \\<inter> - L; quorum_of p' Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  p' \\<in> Q \\<inter> - L\n  quorum_of p' Q\n\ngoal (1 subgoal):\n 1. False", "hence \"Q \\<inter> B \\<noteq> {}\""], ["proof (prove)\nusing this:\n  p' \\<in> Q \\<inter> - L\n  quorum_of p' Q\n\ngoal (1 subgoal):\n 1. Q \\<inter> B \\<noteq> {}", "unfolding L_def"], ["proof (prove)\nusing this:\n  p' \\<in> Q \\<inter> - (W - blocked_by B)\n  quorum_of p' Q\n\ngoal (1 subgoal):\n 1. Q \\<inter> B \\<noteq> {}", "using CollectD Compl_Diff_eq Int_iff inf_le1 personal_quorums.blocks_def personal_quorums_axioms subset_empty"], ["proof (prove)\nusing this:\n  p' \\<in> Q \\<inter> - (W - blocked_by B)\n  quorum_of p' Q\n  ?a \\<in> {x. ?P x} \\<Longrightarrow> ?P ?a\n  - (?A - ?B) = - ?A \\<union> ?B\n  (?c \\<in> ?A \\<inter> ?B) = (?c \\<in> ?A \\<and> ?c \\<in> ?B)\n  inf ?x ?y \\<le> ?x\n  personal_quorums ?quorum_of \\<Longrightarrow>\n  personal_quorums.blocks ?quorum_of ?R ?p \\<equiv>\n  \\<forall>Q. ?quorum_of ?p Q \\<longrightarrow> Q \\<inter> ?R \\<noteq> {}\n  personal_quorums quorum_of\n  (?A \\<subseteq> {}) = (?A = {})\n\ngoal (1 subgoal):\n 1. Q \\<inter> B \\<noteq> {}", "by fastforce"], ["proof (state)\nthis:\n  Q \\<inter> B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "thus False"], ["proof (prove)\nusing this:\n  Q \\<inter> B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "using \\<open>Q \\<subseteq> W\\<close>"], ["proof (prove)\nusing this:\n  Q \\<inter> B \\<noteq> {}\n  Q \\<subseteq> W\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<And>Q.\n      quorum_of p Q \\<Longrightarrow>\n      Q \\<inter> - L \\<noteq> {}) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>Q\\<subseteq>L. quorum_of p Q", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>Q.\n      quorum_of p Q \\<Longrightarrow>\n      Q \\<inter> - L \\<noteq> {}) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>Q\\<subseteq>L. quorum_of p Q", "by (metis disjoint_eq_subset_Compl double_complement)"], ["proof (state)\nthis:\n  \\<exists>Q\\<subseteq>L. quorum_of p Q\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Consensus clusters and intact sets\""], ["", "definition is_intertwined where\n  \\<comment> \\<open>This definition is not used in this theory,\n    but we include it to formalize the notion of intertwined set appearing in the DISC paper.\\<close>\n  \"is_intertwined S \\<equiv> S \\<subseteq> W \n    \\<and> (\\<forall> Q Q' . quorum_of_set S Q \\<and> quorum_of_set S Q' \\<longrightarrow> W \\<inter> Q \\<inter> Q' \\<noteq> {})\""], ["", "definition is_cons_cluster where\n  \\<comment> \\<open>Consensus clusters\\<close>\n  \"is_cons_cluster C \\<equiv> C \\<subseteq> W \\<and> (\\<forall> p \\<in> C . \\<exists> Q \\<subseteq> C . quorum_of p Q)\n      \\<and> (\\<forall> Q Q' . quorum_of_set C Q \\<and> quorum_of_set C Q' \\<longrightarrow> W \\<inter> Q \\<inter> Q' \\<noteq> {})\""], ["", "definition strong_consensus_cluster where\n  \"strong_consensus_cluster I \\<equiv> I \\<subseteq> W \\<and> (\\<forall> p \\<in> I . \\<exists> Q \\<subseteq> I . quorum_of p Q)\n      \\<and> (\\<forall> Q Q' . quorum_of_set I Q \\<and> quorum_of_set I Q' \\<longrightarrow> I \\<inter> Q \\<inter> Q' \\<noteq> {})\""], ["", "lemma strong_consensus_cluster_imp_cons_cluster:\n\\<comment> \\<open>Every intact set is a consensus cluster\\<close>\n  shows \"strong_consensus_cluster I \\<Longrightarrow> is_cons_cluster I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strong_consensus_cluster I \\<Longrightarrow> is_cons_cluster I", "unfolding strong_consensus_cluster_def is_cons_cluster_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<subseteq> W \\<and>\n    (\\<forall>p\\<in>I. \\<exists>Q\\<subseteq>I. quorum_of p Q) \\<and>\n    (\\<forall>Q Q'.\n        quorum_of_set I Q \\<and> quorum_of_set I Q' \\<longrightarrow>\n        I \\<inter> Q \\<inter> Q' \\<noteq> {}) \\<Longrightarrow>\n    I \\<subseteq> W \\<and>\n    (\\<forall>p\\<in>I. \\<exists>Q\\<subseteq>I. quorum_of p Q) \\<and>\n    (\\<forall>Q Q'.\n        quorum_of_set I Q \\<and> quorum_of_set I Q' \\<longrightarrow>\n        W \\<inter> Q \\<inter> Q' \\<noteq> {})", "by blast"], ["", "lemma cons_cluster_neq_cons_cluster:\n  \\<comment> \\<open>Some consensus clusters are not strong consensus clusters and have no superset that is a strong consensus cluster.\\<close>\n  shows \"is_cons_cluster I \\<and> (\\<forall> J . I \\<subseteq> J \\<longrightarrow> \\<not>strong_consensus_cluster J)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cons_cluster I \\<and>\n    (\\<forall>J.\n        I \\<subseteq> J \\<longrightarrow> \\<not> strong_consensus_cluster J)", "nitpick[falsify=false, card 'node=3, expect=genuine]"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cons_cluster I \\<and>\n    (\\<forall>J.\n        I \\<subseteq> J \\<longrightarrow> \\<not> strong_consensus_cluster J)", "oops"], ["", "text \\<open>Next we show that the union of two consensus clusters that intersect is a consensus cluster.\\<close>"], ["", "theorem cluster_union:\n  assumes \"is_cons_cluster C\\<^sub>1\" and \"is_cons_cluster C\\<^sub>2\" and \"C\\<^sub>1 \\<inter> C\\<^sub>2 \\<noteq> {}\"\n  shows \"is_cons_cluster (C\\<^sub>1\\<union> C\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cons_cluster (C\\<^sub>1 \\<union> C\\<^sub>2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cons_cluster (C\\<^sub>1 \\<union> C\\<^sub>2)", "have \"C\\<^sub>1 \\<union> C\\<^sub>2 \\<subseteq> W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C\\<^sub>1 \\<union> C\\<^sub>2 \\<subseteq> W", "using assms(1) assms(2) is_cons_cluster_def"], ["proof (prove)\nusing this:\n  is_cons_cluster C\\<^sub>1\n  is_cons_cluster C\\<^sub>2\n  is_cons_cluster ?C \\<equiv>\n  ?C \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>?C. \\<exists>Q\\<subseteq>?C. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      quorum_of_set ?C Q \\<and> quorum_of_set ?C Q' \\<longrightarrow>\n      W \\<inter> Q \\<inter> Q' \\<noteq> {})\n\ngoal (1 subgoal):\n 1. C\\<^sub>1 \\<union> C\\<^sub>2 \\<subseteq> W", "by auto"], ["proof (state)\nthis:\n  C\\<^sub>1 \\<union> C\\<^sub>2 \\<subseteq> W\n\ngoal (1 subgoal):\n 1. is_cons_cluster (C\\<^sub>1 \\<union> C\\<^sub>2)", "moreover"], ["proof (state)\nthis:\n  C\\<^sub>1 \\<union> C\\<^sub>2 \\<subseteq> W\n\ngoal (1 subgoal):\n 1. is_cons_cluster (C\\<^sub>1 \\<union> C\\<^sub>2)", "have \"\\<forall> p \\<in> (C\\<^sub>1\\<union>C\\<^sub>2) . \\<exists> Q \\<subseteq> (C\\<^sub>1\\<union>C\\<^sub>2) . quorum_of p Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2.\n       \\<exists>Q\\<subseteq>C\\<^sub>1 \\<union> C\\<^sub>2. quorum_of p Q", "using \\<open>is_cons_cluster C\\<^sub>1\\<close> \\<open>is_cons_cluster C\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  is_cons_cluster C\\<^sub>1\n  is_cons_cluster C\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2.\n       \\<exists>Q\\<subseteq>C\\<^sub>1 \\<union> C\\<^sub>2. quorum_of p Q", "unfolding is_cons_cluster_def"], ["proof (prove)\nusing this:\n  C\\<^sub>1 \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>C\\<^sub>1.\n      \\<exists>Q\\<subseteq>C\\<^sub>1. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      quorum_of_set C\\<^sub>1 Q \\<and>\n      quorum_of_set C\\<^sub>1 Q' \\<longrightarrow>\n      W \\<inter> Q \\<inter> Q' \\<noteq> {})\n  C\\<^sub>2 \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>C\\<^sub>2.\n      \\<exists>Q\\<subseteq>C\\<^sub>2. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      quorum_of_set C\\<^sub>2 Q \\<and>\n      quorum_of_set C\\<^sub>2 Q' \\<longrightarrow>\n      W \\<inter> Q \\<inter> Q' \\<noteq> {})\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2.\n       \\<exists>Q\\<subseteq>C\\<^sub>1 \\<union> C\\<^sub>2. quorum_of p Q", "by (meson UnE le_supI1 le_supI2)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2.\n     \\<exists>Q\\<subseteq>C\\<^sub>1 \\<union> C\\<^sub>2. quorum_of p Q\n\ngoal (1 subgoal):\n 1. is_cons_cluster (C\\<^sub>1 \\<union> C\\<^sub>2)", "moreover"], ["proof (state)\nthis:\n  \\<forall>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2.\n     \\<exists>Q\\<subseteq>C\\<^sub>1 \\<union> C\\<^sub>2. quorum_of p Q\n\ngoal (1 subgoal):\n 1. is_cons_cluster (C\\<^sub>1 \\<union> C\\<^sub>2)", "have \"W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}\"\n    if \"quorum_of_set (C\\<^sub>1\\<union>C\\<^sub>2) Q\\<^sub>1\" and \"quorum_of_set (C\\<^sub>1\\<union>C\\<^sub>2) Q\\<^sub>2\" \n    for Q\\<^sub>1 Q\\<^sub>2"], ["proof (prove)\ngoal (1 subgoal):\n 1. W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}", "have \"W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}\" if \"quorum_of_set C Q\\<^sub>1\" and \"quorum_of_set C Q\\<^sub>2\" and \"C = C\\<^sub>1 \\<or> C = C\\<^sub>2\" for C"], ["proof (prove)\ngoal (1 subgoal):\n 1. W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}", "using \\<open>is_cons_cluster C\\<^sub>1\\<close> \\<open>is_cons_cluster C\\<^sub>2\\<close> \\<open>quorum_of_set (C\\<^sub>1\\<union>C\\<^sub>2) Q\\<^sub>1\\<close> \\<open>quorum_of_set (C\\<^sub>1\\<union>C\\<^sub>2) Q\\<^sub>2\\<close> that"], ["proof (prove)\nusing this:\n  is_cons_cluster C\\<^sub>1\n  is_cons_cluster C\\<^sub>2\n  quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) Q\\<^sub>1\n  quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) Q\\<^sub>2\n  quorum_of_set C Q\\<^sub>1\n  quorum_of_set C Q\\<^sub>2\n  C = C\\<^sub>1 \\<or> C = C\\<^sub>2\n\ngoal (1 subgoal):\n 1. W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}", "unfolding quorum_of_set_def is_cons_cluster_def"], ["proof (prove)\nusing this:\n  C\\<^sub>1 \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>C\\<^sub>1.\n      \\<exists>Q\\<subseteq>C\\<^sub>1. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      (\\<exists>p\\<in>C\\<^sub>1. quorum_of p Q) \\<and>\n      (\\<exists>p\\<in>C\\<^sub>1. quorum_of p Q') \\<longrightarrow>\n      W \\<inter> Q \\<inter> Q' \\<noteq> {})\n  C\\<^sub>2 \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>C\\<^sub>2.\n      \\<exists>Q\\<subseteq>C\\<^sub>2. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      (\\<exists>p\\<in>C\\<^sub>2. quorum_of p Q) \\<and>\n      (\\<exists>p\\<in>C\\<^sub>2. quorum_of p Q') \\<longrightarrow>\n      W \\<inter> Q \\<inter> Q' \\<noteq> {})\n  \\<exists>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2. quorum_of p Q\\<^sub>1\n  \\<exists>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2. quorum_of p Q\\<^sub>2\n  \\<exists>p\\<in>C. quorum_of p Q\\<^sub>1\n  \\<exists>p\\<in>C. quorum_of p Q\\<^sub>2\n  C = C\\<^sub>1 \\<or> C = C\\<^sub>2\n\ngoal (1 subgoal):\n 1. W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}", "by metis"], ["proof (state)\nthis:\n  \\<lbrakk>quorum_of_set ?C Q\\<^sub>1; quorum_of_set ?C Q\\<^sub>2;\n   ?C = C\\<^sub>1 \\<or> ?C = C\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>quorum_of_set ?C Q\\<^sub>1; quorum_of_set ?C Q\\<^sub>2;\n   ?C = C\\<^sub>1 \\<or> ?C = C\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}", "have \\<open>W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}\\<close>  if \"is_cons_cluster C\\<^sub>1\" and \"is_cons_cluster C\\<^sub>2\"\n      and \"C\\<^sub>1 \\<inter> C\\<^sub>2 \\<noteq> {}\" and \"quorum_of_set C\\<^sub>1 Q\\<^sub>1\" and \"quorum_of_set C\\<^sub>2 Q\\<^sub>2\"\n    for C\\<^sub>1 C\\<^sub>2 \\<comment> \\<open>We generalize to avoid repeating the argument twice\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}", "obtain p Q where \"quorum_of p Q\" and \"p \\<in> C\\<^sub>1 \\<inter> C\\<^sub>2\" and \"Q \\<subseteq> C\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p Q.\n        \\<lbrakk>quorum_of p Q; p \\<in> C\\<^sub>1 \\<inter> C\\<^sub>2;\n         Q \\<subseteq> C\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>C\\<^sub>1 \\<inter> C\\<^sub>2 \\<noteq> {}\\<close> \\<open>is_cons_cluster C\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  C\\<^sub>1 \\<inter> C\\<^sub>2 \\<noteq> {}\n  is_cons_cluster C\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>p Q.\n        \\<lbrakk>quorum_of p Q; p \\<in> C\\<^sub>1 \\<inter> C\\<^sub>2;\n         Q \\<subseteq> C\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_cons_cluster_def"], ["proof (prove)\nusing this:\n  C\\<^sub>1 \\<inter> C\\<^sub>2 \\<noteq> {}\n  C\\<^sub>2 \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>C\\<^sub>2.\n      \\<exists>Q\\<subseteq>C\\<^sub>2. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      quorum_of_set C\\<^sub>2 Q \\<and>\n      quorum_of_set C\\<^sub>2 Q' \\<longrightarrow>\n      W \\<inter> Q \\<inter> Q' \\<noteq> {})\n\ngoal (1 subgoal):\n 1. (\\<And>p Q.\n        \\<lbrakk>quorum_of p Q; p \\<in> C\\<^sub>1 \\<inter> C\\<^sub>2;\n         Q \\<subseteq> C\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  quorum_of p Q\n  p \\<in> C\\<^sub>1 \\<inter> C\\<^sub>2\n  Q \\<subseteq> C\\<^sub>2\n\ngoal (1 subgoal):\n 1. W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}", "have \"Q \\<inter> Q\\<^sub>1 \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<inter> Q\\<^sub>1 \\<noteq> {}", "using \\<open>is_cons_cluster C\\<^sub>1\\<close> \\<open>quorum_of_set C\\<^sub>1 Q\\<^sub>1\\<close> \\<open>quorum_of p Q\\<close> \\<open>p \\<in> C\\<^sub>1 \\<inter> C\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  is_cons_cluster C\\<^sub>1\n  quorum_of_set C\\<^sub>1 Q\\<^sub>1\n  quorum_of p Q\n  p \\<in> C\\<^sub>1 \\<inter> C\\<^sub>2\n\ngoal (1 subgoal):\n 1. Q \\<inter> Q\\<^sub>1 \\<noteq> {}", "unfolding is_cons_cluster_def quorum_of_set_def"], ["proof (prove)\nusing this:\n  C\\<^sub>1 \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>C\\<^sub>1.\n      \\<exists>Q\\<subseteq>C\\<^sub>1. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      (\\<exists>p\\<in>C\\<^sub>1. quorum_of p Q) \\<and>\n      (\\<exists>p\\<in>C\\<^sub>1. quorum_of p Q') \\<longrightarrow>\n      W \\<inter> Q \\<inter> Q' \\<noteq> {})\n  \\<exists>p\\<in>C\\<^sub>1. quorum_of p Q\\<^sub>1\n  quorum_of p Q\n  p \\<in> C\\<^sub>1 \\<inter> C\\<^sub>2\n\ngoal (1 subgoal):\n 1. Q \\<inter> Q\\<^sub>1 \\<noteq> {}", "by (metis Int_assoc Int_iff inf_bot_right)"], ["proof (state)\nthis:\n  Q \\<inter> Q\\<^sub>1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}", "hence \"quorum_of_set C\\<^sub>2 Q\\<^sub>1\""], ["proof (prove)\nusing this:\n  Q \\<inter> Q\\<^sub>1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. quorum_of_set C\\<^sub>2 Q\\<^sub>1", "using \\<open>Q \\<subseteq> C\\<^sub>2\\<close> \\<open>quorum_of_set C\\<^sub>1 Q\\<^sub>1\\<close> quorum_assm"], ["proof (prove)\nusing this:\n  Q \\<inter> Q\\<^sub>1 \\<noteq> {}\n  Q \\<subseteq> C\\<^sub>2\n  quorum_of_set C\\<^sub>1 Q\\<^sub>1\n  \\<lbrakk>quorum_of ?p ?Q; ?p' \\<in> ?Q\\<rbrakk>\n  \\<Longrightarrow> quorum_of ?p' ?Q\n\ngoal (1 subgoal):\n 1. quorum_of_set C\\<^sub>2 Q\\<^sub>1", "unfolding quorum_of_set_def"], ["proof (prove)\nusing this:\n  Q \\<inter> Q\\<^sub>1 \\<noteq> {}\n  Q \\<subseteq> C\\<^sub>2\n  \\<exists>p\\<in>C\\<^sub>1. quorum_of p Q\\<^sub>1\n  \\<lbrakk>quorum_of ?p ?Q; ?p' \\<in> ?Q\\<rbrakk>\n  \\<Longrightarrow> quorum_of ?p' ?Q\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>C\\<^sub>2. quorum_of p Q\\<^sub>1", "by blast"], ["proof (state)\nthis:\n  quorum_of_set C\\<^sub>2 Q\\<^sub>1\n\ngoal (1 subgoal):\n 1. W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}", "thus \"W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}\""], ["proof (prove)\nusing this:\n  quorum_of_set C\\<^sub>2 Q\\<^sub>1\n\ngoal (1 subgoal):\n 1. W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}", "using \\<open>is_cons_cluster C\\<^sub>2\\<close> \\<open>quorum_of_set C\\<^sub>2 Q\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  quorum_of_set C\\<^sub>2 Q\\<^sub>1\n  is_cons_cluster C\\<^sub>2\n  quorum_of_set C\\<^sub>2 Q\\<^sub>2\n\ngoal (1 subgoal):\n 1. W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}", "unfolding is_cons_cluster_def"], ["proof (prove)\nusing this:\n  quorum_of_set C\\<^sub>2 Q\\<^sub>1\n  C\\<^sub>2 \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>C\\<^sub>2.\n      \\<exists>Q\\<subseteq>C\\<^sub>2. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      quorum_of_set C\\<^sub>2 Q \\<and>\n      quorum_of_set C\\<^sub>2 Q' \\<longrightarrow>\n      W \\<inter> Q \\<inter> Q' \\<noteq> {})\n  quorum_of_set C\\<^sub>2 Q\\<^sub>2\n\ngoal (1 subgoal):\n 1. W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>is_cons_cluster ?C\\<^sub>1; is_cons_cluster ?C\\<^sub>2;\n   ?C\\<^sub>1 \\<inter> ?C\\<^sub>2 \\<noteq> {};\n   quorum_of_set ?C\\<^sub>1 Q\\<^sub>1;\n   quorum_of_set ?C\\<^sub>2 Q\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>quorum_of_set ?C Q\\<^sub>1; quorum_of_set ?C Q\\<^sub>2;\n   ?C = C\\<^sub>1 \\<or> ?C = C\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}\n  \\<lbrakk>is_cons_cluster ?C\\<^sub>1; is_cons_cluster ?C\\<^sub>2;\n   ?C\\<^sub>1 \\<inter> ?C\\<^sub>2 \\<noteq> {};\n   quorum_of_set ?C\\<^sub>1 Q\\<^sub>1;\n   quorum_of_set ?C\\<^sub>2 Q\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>quorum_of_set ?C Q\\<^sub>1; quorum_of_set ?C Q\\<^sub>2;\n   ?C = C\\<^sub>1 \\<or> ?C = C\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}\n  \\<lbrakk>is_cons_cluster ?C\\<^sub>1; is_cons_cluster ?C\\<^sub>2;\n   ?C\\<^sub>1 \\<inter> ?C\\<^sub>2 \\<noteq> {};\n   quorum_of_set ?C\\<^sub>1 Q\\<^sub>1;\n   quorum_of_set ?C\\<^sub>2 Q\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}", "using assms that"], ["proof (prove)\nusing this:\n  \\<lbrakk>quorum_of_set ?C Q\\<^sub>1; quorum_of_set ?C Q\\<^sub>2;\n   ?C = C\\<^sub>1 \\<or> ?C = C\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}\n  \\<lbrakk>is_cons_cluster ?C\\<^sub>1; is_cons_cluster ?C\\<^sub>2;\n   ?C\\<^sub>1 \\<inter> ?C\\<^sub>2 \\<noteq> {};\n   quorum_of_set ?C\\<^sub>1 Q\\<^sub>1;\n   quorum_of_set ?C\\<^sub>2 Q\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}\n  is_cons_cluster C\\<^sub>1\n  is_cons_cluster C\\<^sub>2\n  C\\<^sub>1 \\<inter> C\\<^sub>2 \\<noteq> {}\n  quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) Q\\<^sub>1\n  quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) Q\\<^sub>2\n\ngoal (1 subgoal):\n 1. W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}", "unfolding quorum_of_set_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<exists>p\\<in>?C. quorum_of p Q\\<^sub>1;\n   \\<exists>p\\<in>?C. quorum_of p Q\\<^sub>2;\n   ?C = C\\<^sub>1 \\<or> ?C = C\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}\n  \\<lbrakk>is_cons_cluster ?C\\<^sub>1; is_cons_cluster ?C\\<^sub>2;\n   ?C\\<^sub>1 \\<inter> ?C\\<^sub>2 \\<noteq> {};\n   \\<exists>p\\<in>?C\\<^sub>1. quorum_of p Q\\<^sub>1;\n   \\<exists>p\\<in>?C\\<^sub>2. quorum_of p Q\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}\n  is_cons_cluster C\\<^sub>1\n  is_cons_cluster C\\<^sub>2\n  C\\<^sub>1 \\<inter> C\\<^sub>2 \\<noteq> {}\n  \\<exists>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2. quorum_of p Q\\<^sub>1\n  \\<exists>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2. quorum_of p Q\\<^sub>2\n\ngoal (1 subgoal):\n 1. W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  W \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) ?Q\\<^sub>1;\n   quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) ?Q\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> W \\<inter> ?Q\\<^sub>1 \\<inter> ?Q\\<^sub>2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. is_cons_cluster (C\\<^sub>1 \\<union> C\\<^sub>2)", "ultimately"], ["proof (chain)\npicking this:\n  C\\<^sub>1 \\<union> C\\<^sub>2 \\<subseteq> W\n  \\<forall>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2.\n     \\<exists>Q\\<subseteq>C\\<^sub>1 \\<union> C\\<^sub>2. quorum_of p Q\n  \\<lbrakk>quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) ?Q\\<^sub>1;\n   quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) ?Q\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> W \\<inter> ?Q\\<^sub>1 \\<inter> ?Q\\<^sub>2 \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  C\\<^sub>1 \\<union> C\\<^sub>2 \\<subseteq> W\n  \\<forall>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2.\n     \\<exists>Q\\<subseteq>C\\<^sub>1 \\<union> C\\<^sub>2. quorum_of p Q\n  \\<lbrakk>quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) ?Q\\<^sub>1;\n   quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) ?Q\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> W \\<inter> ?Q\\<^sub>1 \\<inter> ?Q\\<^sub>2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. is_cons_cluster (C\\<^sub>1 \\<union> C\\<^sub>2)", "using assms"], ["proof (prove)\nusing this:\n  C\\<^sub>1 \\<union> C\\<^sub>2 \\<subseteq> W\n  \\<forall>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2.\n     \\<exists>Q\\<subseteq>C\\<^sub>1 \\<union> C\\<^sub>2. quorum_of p Q\n  \\<lbrakk>quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) ?Q\\<^sub>1;\n   quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) ?Q\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> W \\<inter> ?Q\\<^sub>1 \\<inter> ?Q\\<^sub>2 \\<noteq> {}\n  is_cons_cluster C\\<^sub>1\n  is_cons_cluster C\\<^sub>2\n  C\\<^sub>1 \\<inter> C\\<^sub>2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. is_cons_cluster (C\\<^sub>1 \\<union> C\\<^sub>2)", "unfolding is_cons_cluster_def"], ["proof (prove)\nusing this:\n  C\\<^sub>1 \\<union> C\\<^sub>2 \\<subseteq> W\n  \\<forall>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2.\n     \\<exists>Q\\<subseteq>C\\<^sub>1 \\<union> C\\<^sub>2. quorum_of p Q\n  \\<lbrakk>quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) ?Q\\<^sub>1;\n   quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) ?Q\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> W \\<inter> ?Q\\<^sub>1 \\<inter> ?Q\\<^sub>2 \\<noteq> {}\n  C\\<^sub>1 \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>C\\<^sub>1.\n      \\<exists>Q\\<subseteq>C\\<^sub>1. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      quorum_of_set C\\<^sub>1 Q \\<and>\n      quorum_of_set C\\<^sub>1 Q' \\<longrightarrow>\n      W \\<inter> Q \\<inter> Q' \\<noteq> {})\n  C\\<^sub>2 \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>C\\<^sub>2.\n      \\<exists>Q\\<subseteq>C\\<^sub>2. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      quorum_of_set C\\<^sub>2 Q \\<and>\n      quorum_of_set C\\<^sub>2 Q' \\<longrightarrow>\n      W \\<inter> Q \\<inter> Q' \\<noteq> {})\n  C\\<^sub>1 \\<inter> C\\<^sub>2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. C\\<^sub>1 \\<union> C\\<^sub>2 \\<subseteq> W \\<and>\n    (\\<forall>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2.\n        \\<exists>Q\\<subseteq>C\\<^sub>1 \\<union> C\\<^sub>2.\n           quorum_of p Q) \\<and>\n    (\\<forall>Q Q'.\n        quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) Q \\<and>\n        quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) Q' \\<longrightarrow>\n        W \\<inter> Q \\<inter> Q' \\<noteq> {})", "by simp"], ["proof (state)\nthis:\n  is_cons_cluster (C\\<^sub>1 \\<union> C\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Similarly, the union of two strong consensus clusters is a strong consensus cluster.\\<close>"], ["", "lemma strong_cluster_union:\n  assumes \"strong_consensus_cluster C\\<^sub>1\" and \"strong_consensus_cluster C\\<^sub>2\" and \"C\\<^sub>1 \\<inter> C\\<^sub>2 \\<noteq> {}\"\n  shows \"strong_consensus_cluster (C\\<^sub>1\\<union> C\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strong_consensus_cluster (C\\<^sub>1 \\<union> C\\<^sub>2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. strong_consensus_cluster (C\\<^sub>1 \\<union> C\\<^sub>2)", "have \"C\\<^sub>1 \\<union> C\\<^sub>2 \\<subseteq> W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C\\<^sub>1 \\<union> C\\<^sub>2 \\<subseteq> W", "using assms(1) assms(2) strong_consensus_cluster_def"], ["proof (prove)\nusing this:\n  strong_consensus_cluster C\\<^sub>1\n  strong_consensus_cluster C\\<^sub>2\n  strong_consensus_cluster ?I \\<equiv>\n  ?I \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>?I. \\<exists>Q\\<subseteq>?I. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      quorum_of_set ?I Q \\<and> quorum_of_set ?I Q' \\<longrightarrow>\n      ?I \\<inter> Q \\<inter> Q' \\<noteq> {})\n\ngoal (1 subgoal):\n 1. C\\<^sub>1 \\<union> C\\<^sub>2 \\<subseteq> W", "by auto"], ["proof (state)\nthis:\n  C\\<^sub>1 \\<union> C\\<^sub>2 \\<subseteq> W\n\ngoal (1 subgoal):\n 1. strong_consensus_cluster (C\\<^sub>1 \\<union> C\\<^sub>2)", "moreover"], ["proof (state)\nthis:\n  C\\<^sub>1 \\<union> C\\<^sub>2 \\<subseteq> W\n\ngoal (1 subgoal):\n 1. strong_consensus_cluster (C\\<^sub>1 \\<union> C\\<^sub>2)", "have \"\\<forall> p \\<in> (C\\<^sub>1\\<union>C\\<^sub>2) . \\<exists> Q \\<subseteq> (C\\<^sub>1\\<union>C\\<^sub>2) . quorum_of p Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2.\n       \\<exists>Q\\<subseteq>C\\<^sub>1 \\<union> C\\<^sub>2. quorum_of p Q", "using \\<open>strong_consensus_cluster C\\<^sub>1\\<close> \\<open>strong_consensus_cluster C\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  strong_consensus_cluster C\\<^sub>1\n  strong_consensus_cluster C\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2.\n       \\<exists>Q\\<subseteq>C\\<^sub>1 \\<union> C\\<^sub>2. quorum_of p Q", "unfolding strong_consensus_cluster_def"], ["proof (prove)\nusing this:\n  C\\<^sub>1 \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>C\\<^sub>1.\n      \\<exists>Q\\<subseteq>C\\<^sub>1. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      quorum_of_set C\\<^sub>1 Q \\<and>\n      quorum_of_set C\\<^sub>1 Q' \\<longrightarrow>\n      C\\<^sub>1 \\<inter> Q \\<inter> Q' \\<noteq> {})\n  C\\<^sub>2 \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>C\\<^sub>2.\n      \\<exists>Q\\<subseteq>C\\<^sub>2. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      quorum_of_set C\\<^sub>2 Q \\<and>\n      quorum_of_set C\\<^sub>2 Q' \\<longrightarrow>\n      C\\<^sub>2 \\<inter> Q \\<inter> Q' \\<noteq> {})\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2.\n       \\<exists>Q\\<subseteq>C\\<^sub>1 \\<union> C\\<^sub>2. quorum_of p Q", "by (meson UnE le_supI1 le_supI2)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2.\n     \\<exists>Q\\<subseteq>C\\<^sub>1 \\<union> C\\<^sub>2. quorum_of p Q\n\ngoal (1 subgoal):\n 1. strong_consensus_cluster (C\\<^sub>1 \\<union> C\\<^sub>2)", "moreover"], ["proof (state)\nthis:\n  \\<forall>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2.\n     \\<exists>Q\\<subseteq>C\\<^sub>1 \\<union> C\\<^sub>2. quorum_of p Q\n\ngoal (1 subgoal):\n 1. strong_consensus_cluster (C\\<^sub>1 \\<union> C\\<^sub>2)", "have \"(C\\<^sub>1\\<union>C\\<^sub>2) \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}\"\n    if \"quorum_of_set (C\\<^sub>1\\<union>C\\<^sub>2) Q\\<^sub>1\" and \"quorum_of_set (C\\<^sub>1\\<union>C\\<^sub>2) Q\\<^sub>2\" \n    for Q\\<^sub>1 Q\\<^sub>2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter> Q\\<^sub>1 \\<inter>\n    Q\\<^sub>2 \\<noteq>\n    {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter> Q\\<^sub>1 \\<inter>\n    Q\\<^sub>2 \\<noteq>\n    {}", "have \"C \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}\" if \"quorum_of_set C Q\\<^sub>1\" and \"quorum_of_set C Q\\<^sub>2\" and \"C = C\\<^sub>1 \\<or> C = C\\<^sub>2\" for C"], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}", "using \\<open>strong_consensus_cluster C\\<^sub>1\\<close> \\<open>strong_consensus_cluster C\\<^sub>2\\<close> that"], ["proof (prove)\nusing this:\n  strong_consensus_cluster C\\<^sub>1\n  strong_consensus_cluster C\\<^sub>2\n  quorum_of_set C Q\\<^sub>1\n  quorum_of_set C Q\\<^sub>2\n  C = C\\<^sub>1 \\<or> C = C\\<^sub>2\n\ngoal (1 subgoal):\n 1. C \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}", "unfolding quorum_of_set_def strong_consensus_cluster_def"], ["proof (prove)\nusing this:\n  C\\<^sub>1 \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>C\\<^sub>1.\n      \\<exists>Q\\<subseteq>C\\<^sub>1. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      (\\<exists>p\\<in>C\\<^sub>1. quorum_of p Q) \\<and>\n      (\\<exists>p\\<in>C\\<^sub>1. quorum_of p Q') \\<longrightarrow>\n      C\\<^sub>1 \\<inter> Q \\<inter> Q' \\<noteq> {})\n  C\\<^sub>2 \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>C\\<^sub>2.\n      \\<exists>Q\\<subseteq>C\\<^sub>2. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      (\\<exists>p\\<in>C\\<^sub>2. quorum_of p Q) \\<and>\n      (\\<exists>p\\<in>C\\<^sub>2. quorum_of p Q') \\<longrightarrow>\n      C\\<^sub>2 \\<inter> Q \\<inter> Q' \\<noteq> {})\n  \\<exists>p\\<in>C. quorum_of p Q\\<^sub>1\n  \\<exists>p\\<in>C. quorum_of p Q\\<^sub>2\n  C = C\\<^sub>1 \\<or> C = C\\<^sub>2\n\ngoal (1 subgoal):\n 1. C \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}", "by metis"], ["proof (state)\nthis:\n  \\<lbrakk>quorum_of_set ?C Q\\<^sub>1; quorum_of_set ?C Q\\<^sub>2;\n   ?C = C\\<^sub>1 \\<or> ?C = C\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?C \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter> Q\\<^sub>1 \\<inter>\n    Q\\<^sub>2 \\<noteq>\n    {}", "hence \"(C\\<^sub>1\\<union>C\\<^sub>2) \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}\" if \"quorum_of_set C Q\\<^sub>1\" and \"quorum_of_set C Q\\<^sub>2\" and \"C = C\\<^sub>1 \\<or> C = C\\<^sub>2\" for C"], ["proof (prove)\nusing this:\n  \\<lbrakk>quorum_of_set ?C Q\\<^sub>1; quorum_of_set ?C Q\\<^sub>2;\n   ?C = C\\<^sub>1 \\<or> ?C = C\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?C \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter> Q\\<^sub>1 \\<inter>\n    Q\\<^sub>2 \\<noteq>\n    {}", "by (metis Int_Un_distrib2 disjoint_eq_subset_Compl sup.boundedE that)"], ["proof (state)\nthis:\n  \\<lbrakk>quorum_of_set ?C Q\\<^sub>1; quorum_of_set ?C Q\\<^sub>2;\n   ?C = C\\<^sub>1 \\<or> ?C = C\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter>\n                    Q\\<^sub>1 \\<inter>\n                    Q\\<^sub>2 \\<noteq>\n                    {}\n\ngoal (1 subgoal):\n 1. (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter> Q\\<^sub>1 \\<inter>\n    Q\\<^sub>2 \\<noteq>\n    {}", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>quorum_of_set ?C Q\\<^sub>1; quorum_of_set ?C Q\\<^sub>2;\n   ?C = C\\<^sub>1 \\<or> ?C = C\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter>\n                    Q\\<^sub>1 \\<inter>\n                    Q\\<^sub>2 \\<noteq>\n                    {}\n\ngoal (1 subgoal):\n 1. (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter> Q\\<^sub>1 \\<inter>\n    Q\\<^sub>2 \\<noteq>\n    {}", "have \\<open>(C\\<^sub>1\\<union>C\\<^sub>2) \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}\\<close>  if \"strong_consensus_cluster C\\<^sub>1\" and \"strong_consensus_cluster C\\<^sub>2\"\n      and \"C\\<^sub>1 \\<inter> C\\<^sub>2 \\<noteq> {}\" and \"quorum_of_set C\\<^sub>1 Q\\<^sub>1\" and \"quorum_of_set C\\<^sub>2 Q\\<^sub>2\"\n    for C\\<^sub>1 C\\<^sub>2 \\<comment> \\<open>We generalize to avoid repeating the argument twice\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter> Q\\<^sub>1 \\<inter>\n    Q\\<^sub>2 \\<noteq>\n    {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter> Q\\<^sub>1 \\<inter>\n    Q\\<^sub>2 \\<noteq>\n    {}", "obtain p Q where \"quorum_of p Q\" and \"p \\<in> C\\<^sub>1 \\<inter> C\\<^sub>2\" and \"Q \\<subseteq> C\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p Q.\n        \\<lbrakk>quorum_of p Q; p \\<in> C\\<^sub>1 \\<inter> C\\<^sub>2;\n         Q \\<subseteq> C\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>C\\<^sub>1 \\<inter> C\\<^sub>2 \\<noteq> {}\\<close> \\<open>strong_consensus_cluster C\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  C\\<^sub>1 \\<inter> C\\<^sub>2 \\<noteq> {}\n  strong_consensus_cluster C\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>p Q.\n        \\<lbrakk>quorum_of p Q; p \\<in> C\\<^sub>1 \\<inter> C\\<^sub>2;\n         Q \\<subseteq> C\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding strong_consensus_cluster_def"], ["proof (prove)\nusing this:\n  C\\<^sub>1 \\<inter> C\\<^sub>2 \\<noteq> {}\n  C\\<^sub>2 \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>C\\<^sub>2.\n      \\<exists>Q\\<subseteq>C\\<^sub>2. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      quorum_of_set C\\<^sub>2 Q \\<and>\n      quorum_of_set C\\<^sub>2 Q' \\<longrightarrow>\n      C\\<^sub>2 \\<inter> Q \\<inter> Q' \\<noteq> {})\n\ngoal (1 subgoal):\n 1. (\\<And>p Q.\n        \\<lbrakk>quorum_of p Q; p \\<in> C\\<^sub>1 \\<inter> C\\<^sub>2;\n         Q \\<subseteq> C\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  quorum_of p Q\n  p \\<in> C\\<^sub>1 \\<inter> C\\<^sub>2\n  Q \\<subseteq> C\\<^sub>2\n\ngoal (1 subgoal):\n 1. (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter> Q\\<^sub>1 \\<inter>\n    Q\\<^sub>2 \\<noteq>\n    {}", "have \"Q \\<inter> Q\\<^sub>1 \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<inter> Q\\<^sub>1 \\<noteq> {}", "using \\<open>strong_consensus_cluster C\\<^sub>1\\<close> \\<open>quorum_of_set C\\<^sub>1 Q\\<^sub>1\\<close> \\<open>quorum_of p Q\\<close> \\<open>p \\<in> C\\<^sub>1 \\<inter> C\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  strong_consensus_cluster C\\<^sub>1\n  quorum_of_set C\\<^sub>1 Q\\<^sub>1\n  quorum_of p Q\n  p \\<in> C\\<^sub>1 \\<inter> C\\<^sub>2\n\ngoal (1 subgoal):\n 1. Q \\<inter> Q\\<^sub>1 \\<noteq> {}", "unfolding strong_consensus_cluster_def quorum_of_set_def"], ["proof (prove)\nusing this:\n  C\\<^sub>1 \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>C\\<^sub>1.\n      \\<exists>Q\\<subseteq>C\\<^sub>1. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      (\\<exists>p\\<in>C\\<^sub>1. quorum_of p Q) \\<and>\n      (\\<exists>p\\<in>C\\<^sub>1. quorum_of p Q') \\<longrightarrow>\n      C\\<^sub>1 \\<inter> Q \\<inter> Q' \\<noteq> {})\n  \\<exists>p\\<in>C\\<^sub>1. quorum_of p Q\\<^sub>1\n  quorum_of p Q\n  p \\<in> C\\<^sub>1 \\<inter> C\\<^sub>2\n\ngoal (1 subgoal):\n 1. Q \\<inter> Q\\<^sub>1 \\<noteq> {}", "by (metis Int_assoc Int_iff inf_bot_right)"], ["proof (state)\nthis:\n  Q \\<inter> Q\\<^sub>1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter> Q\\<^sub>1 \\<inter>\n    Q\\<^sub>2 \\<noteq>\n    {}", "hence \"quorum_of_set C\\<^sub>2 Q\\<^sub>1\""], ["proof (prove)\nusing this:\n  Q \\<inter> Q\\<^sub>1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. quorum_of_set C\\<^sub>2 Q\\<^sub>1", "using \\<open>Q \\<subseteq> C\\<^sub>2\\<close> \\<open>quorum_of_set C\\<^sub>1 Q\\<^sub>1\\<close> quorum_assm"], ["proof (prove)\nusing this:\n  Q \\<inter> Q\\<^sub>1 \\<noteq> {}\n  Q \\<subseteq> C\\<^sub>2\n  quorum_of_set C\\<^sub>1 Q\\<^sub>1\n  \\<lbrakk>quorum_of ?p ?Q; ?p' \\<in> ?Q\\<rbrakk>\n  \\<Longrightarrow> quorum_of ?p' ?Q\n\ngoal (1 subgoal):\n 1. quorum_of_set C\\<^sub>2 Q\\<^sub>1", "unfolding quorum_of_set_def"], ["proof (prove)\nusing this:\n  Q \\<inter> Q\\<^sub>1 \\<noteq> {}\n  Q \\<subseteq> C\\<^sub>2\n  \\<exists>p\\<in>C\\<^sub>1. quorum_of p Q\\<^sub>1\n  \\<lbrakk>quorum_of ?p ?Q; ?p' \\<in> ?Q\\<rbrakk>\n  \\<Longrightarrow> quorum_of ?p' ?Q\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>C\\<^sub>2. quorum_of p Q\\<^sub>1", "by blast"], ["proof (state)\nthis:\n  quorum_of_set C\\<^sub>2 Q\\<^sub>1\n\ngoal (1 subgoal):\n 1. (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter> Q\\<^sub>1 \\<inter>\n    Q\\<^sub>2 \\<noteq>\n    {}", "thus \"(C\\<^sub>1\\<union>C\\<^sub>2) \\<inter> Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<noteq> {}\""], ["proof (prove)\nusing this:\n  quorum_of_set C\\<^sub>2 Q\\<^sub>1\n\ngoal (1 subgoal):\n 1. (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter> Q\\<^sub>1 \\<inter>\n    Q\\<^sub>2 \\<noteq>\n    {}", "using \\<open>strong_consensus_cluster C\\<^sub>2\\<close> \\<open>quorum_of_set C\\<^sub>2 Q\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  quorum_of_set C\\<^sub>2 Q\\<^sub>1\n  strong_consensus_cluster C\\<^sub>2\n  quorum_of_set C\\<^sub>2 Q\\<^sub>2\n\ngoal (1 subgoal):\n 1. (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter> Q\\<^sub>1 \\<inter>\n    Q\\<^sub>2 \\<noteq>\n    {}", "unfolding strong_consensus_cluster_def"], ["proof (prove)\nusing this:\n  quorum_of_set C\\<^sub>2 Q\\<^sub>1\n  C\\<^sub>2 \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>C\\<^sub>2.\n      \\<exists>Q\\<subseteq>C\\<^sub>2. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      quorum_of_set C\\<^sub>2 Q \\<and>\n      quorum_of_set C\\<^sub>2 Q' \\<longrightarrow>\n      C\\<^sub>2 \\<inter> Q \\<inter> Q' \\<noteq> {})\n  quorum_of_set C\\<^sub>2 Q\\<^sub>2\n\ngoal (1 subgoal):\n 1. (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter> Q\\<^sub>1 \\<inter>\n    Q\\<^sub>2 \\<noteq>\n    {}", "by blast"], ["proof (state)\nthis:\n  (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter> Q\\<^sub>1 \\<inter>\n  Q\\<^sub>2 \\<noteq>\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>strong_consensus_cluster ?C\\<^sub>1;\n   strong_consensus_cluster ?C\\<^sub>2;\n   ?C\\<^sub>1 \\<inter> ?C\\<^sub>2 \\<noteq> {};\n   quorum_of_set ?C\\<^sub>1 Q\\<^sub>1;\n   quorum_of_set ?C\\<^sub>2 Q\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (?C\\<^sub>1 \\<union> ?C\\<^sub>2) \\<inter>\n                    Q\\<^sub>1 \\<inter>\n                    Q\\<^sub>2 \\<noteq>\n                    {}\n\ngoal (1 subgoal):\n 1. (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter> Q\\<^sub>1 \\<inter>\n    Q\\<^sub>2 \\<noteq>\n    {}", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>quorum_of_set ?C Q\\<^sub>1; quorum_of_set ?C Q\\<^sub>2;\n   ?C = C\\<^sub>1 \\<or> ?C = C\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter>\n                    Q\\<^sub>1 \\<inter>\n                    Q\\<^sub>2 \\<noteq>\n                    {}\n  \\<lbrakk>strong_consensus_cluster ?C\\<^sub>1;\n   strong_consensus_cluster ?C\\<^sub>2;\n   ?C\\<^sub>1 \\<inter> ?C\\<^sub>2 \\<noteq> {};\n   quorum_of_set ?C\\<^sub>1 Q\\<^sub>1;\n   quorum_of_set ?C\\<^sub>2 Q\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (?C\\<^sub>1 \\<union> ?C\\<^sub>2) \\<inter>\n                    Q\\<^sub>1 \\<inter>\n                    Q\\<^sub>2 \\<noteq>\n                    {}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>quorum_of_set ?C Q\\<^sub>1; quorum_of_set ?C Q\\<^sub>2;\n   ?C = C\\<^sub>1 \\<or> ?C = C\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter>\n                    Q\\<^sub>1 \\<inter>\n                    Q\\<^sub>2 \\<noteq>\n                    {}\n  \\<lbrakk>strong_consensus_cluster ?C\\<^sub>1;\n   strong_consensus_cluster ?C\\<^sub>2;\n   ?C\\<^sub>1 \\<inter> ?C\\<^sub>2 \\<noteq> {};\n   quorum_of_set ?C\\<^sub>1 Q\\<^sub>1;\n   quorum_of_set ?C\\<^sub>2 Q\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (?C\\<^sub>1 \\<union> ?C\\<^sub>2) \\<inter>\n                    Q\\<^sub>1 \\<inter>\n                    Q\\<^sub>2 \\<noteq>\n                    {}\n\ngoal (1 subgoal):\n 1. (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter> Q\\<^sub>1 \\<inter>\n    Q\\<^sub>2 \\<noteq>\n    {}", "using assms that"], ["proof (prove)\nusing this:\n  \\<lbrakk>quorum_of_set ?C Q\\<^sub>1; quorum_of_set ?C Q\\<^sub>2;\n   ?C = C\\<^sub>1 \\<or> ?C = C\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter>\n                    Q\\<^sub>1 \\<inter>\n                    Q\\<^sub>2 \\<noteq>\n                    {}\n  \\<lbrakk>strong_consensus_cluster ?C\\<^sub>1;\n   strong_consensus_cluster ?C\\<^sub>2;\n   ?C\\<^sub>1 \\<inter> ?C\\<^sub>2 \\<noteq> {};\n   quorum_of_set ?C\\<^sub>1 Q\\<^sub>1;\n   quorum_of_set ?C\\<^sub>2 Q\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (?C\\<^sub>1 \\<union> ?C\\<^sub>2) \\<inter>\n                    Q\\<^sub>1 \\<inter>\n                    Q\\<^sub>2 \\<noteq>\n                    {}\n  strong_consensus_cluster C\\<^sub>1\n  strong_consensus_cluster C\\<^sub>2\n  C\\<^sub>1 \\<inter> C\\<^sub>2 \\<noteq> {}\n  quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) Q\\<^sub>1\n  quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) Q\\<^sub>2\n\ngoal (1 subgoal):\n 1. (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter> Q\\<^sub>1 \\<inter>\n    Q\\<^sub>2 \\<noteq>\n    {}", "unfolding quorum_of_set_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<exists>p\\<in>?C. quorum_of p Q\\<^sub>1;\n   \\<exists>p\\<in>?C. quorum_of p Q\\<^sub>2;\n   ?C = C\\<^sub>1 \\<or> ?C = C\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter>\n                    Q\\<^sub>1 \\<inter>\n                    Q\\<^sub>2 \\<noteq>\n                    {}\n  \\<lbrakk>strong_consensus_cluster ?C\\<^sub>1;\n   strong_consensus_cluster ?C\\<^sub>2;\n   ?C\\<^sub>1 \\<inter> ?C\\<^sub>2 \\<noteq> {};\n   \\<exists>p\\<in>?C\\<^sub>1. quorum_of p Q\\<^sub>1;\n   \\<exists>p\\<in>?C\\<^sub>2. quorum_of p Q\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (?C\\<^sub>1 \\<union> ?C\\<^sub>2) \\<inter>\n                    Q\\<^sub>1 \\<inter>\n                    Q\\<^sub>2 \\<noteq>\n                    {}\n  strong_consensus_cluster C\\<^sub>1\n  strong_consensus_cluster C\\<^sub>2\n  C\\<^sub>1 \\<inter> C\\<^sub>2 \\<noteq> {}\n  \\<exists>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2. quorum_of p Q\\<^sub>1\n  \\<exists>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2. quorum_of p Q\\<^sub>2\n\ngoal (1 subgoal):\n 1. (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter> Q\\<^sub>1 \\<inter>\n    Q\\<^sub>2 \\<noteq>\n    {}", "by auto"], ["proof (state)\nthis:\n  (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter> Q\\<^sub>1 \\<inter>\n  Q\\<^sub>2 \\<noteq>\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) ?Q\\<^sub>1;\n   quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) ?Q\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter>\n                    ?Q\\<^sub>1 \\<inter>\n                    ?Q\\<^sub>2 \\<noteq>\n                    {}\n\ngoal (1 subgoal):\n 1. strong_consensus_cluster (C\\<^sub>1 \\<union> C\\<^sub>2)", "ultimately"], ["proof (chain)\npicking this:\n  C\\<^sub>1 \\<union> C\\<^sub>2 \\<subseteq> W\n  \\<forall>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2.\n     \\<exists>Q\\<subseteq>C\\<^sub>1 \\<union> C\\<^sub>2. quorum_of p Q\n  \\<lbrakk>quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) ?Q\\<^sub>1;\n   quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) ?Q\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter>\n                    ?Q\\<^sub>1 \\<inter>\n                    ?Q\\<^sub>2 \\<noteq>\n                    {}", "show ?thesis"], ["proof (prove)\nusing this:\n  C\\<^sub>1 \\<union> C\\<^sub>2 \\<subseteq> W\n  \\<forall>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2.\n     \\<exists>Q\\<subseteq>C\\<^sub>1 \\<union> C\\<^sub>2. quorum_of p Q\n  \\<lbrakk>quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) ?Q\\<^sub>1;\n   quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) ?Q\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter>\n                    ?Q\\<^sub>1 \\<inter>\n                    ?Q\\<^sub>2 \\<noteq>\n                    {}\n\ngoal (1 subgoal):\n 1. strong_consensus_cluster (C\\<^sub>1 \\<union> C\\<^sub>2)", "using assms"], ["proof (prove)\nusing this:\n  C\\<^sub>1 \\<union> C\\<^sub>2 \\<subseteq> W\n  \\<forall>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2.\n     \\<exists>Q\\<subseteq>C\\<^sub>1 \\<union> C\\<^sub>2. quorum_of p Q\n  \\<lbrakk>quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) ?Q\\<^sub>1;\n   quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) ?Q\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter>\n                    ?Q\\<^sub>1 \\<inter>\n                    ?Q\\<^sub>2 \\<noteq>\n                    {}\n  strong_consensus_cluster C\\<^sub>1\n  strong_consensus_cluster C\\<^sub>2\n  C\\<^sub>1 \\<inter> C\\<^sub>2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. strong_consensus_cluster (C\\<^sub>1 \\<union> C\\<^sub>2)", "unfolding strong_consensus_cluster_def"], ["proof (prove)\nusing this:\n  C\\<^sub>1 \\<union> C\\<^sub>2 \\<subseteq> W\n  \\<forall>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2.\n     \\<exists>Q\\<subseteq>C\\<^sub>1 \\<union> C\\<^sub>2. quorum_of p Q\n  \\<lbrakk>quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) ?Q\\<^sub>1;\n   quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) ?Q\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter>\n                    ?Q\\<^sub>1 \\<inter>\n                    ?Q\\<^sub>2 \\<noteq>\n                    {}\n  C\\<^sub>1 \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>C\\<^sub>1.\n      \\<exists>Q\\<subseteq>C\\<^sub>1. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      quorum_of_set C\\<^sub>1 Q \\<and>\n      quorum_of_set C\\<^sub>1 Q' \\<longrightarrow>\n      C\\<^sub>1 \\<inter> Q \\<inter> Q' \\<noteq> {})\n  C\\<^sub>2 \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>C\\<^sub>2.\n      \\<exists>Q\\<subseteq>C\\<^sub>2. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      quorum_of_set C\\<^sub>2 Q \\<and>\n      quorum_of_set C\\<^sub>2 Q' \\<longrightarrow>\n      C\\<^sub>2 \\<inter> Q \\<inter> Q' \\<noteq> {})\n  C\\<^sub>1 \\<inter> C\\<^sub>2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. C\\<^sub>1 \\<union> C\\<^sub>2 \\<subseteq> W \\<and>\n    (\\<forall>p\\<in>C\\<^sub>1 \\<union> C\\<^sub>2.\n        \\<exists>Q\\<subseteq>C\\<^sub>1 \\<union> C\\<^sub>2.\n           quorum_of p Q) \\<and>\n    (\\<forall>Q Q'.\n        quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) Q \\<and>\n        quorum_of_set (C\\<^sub>1 \\<union> C\\<^sub>2) Q' \\<longrightarrow>\n        (C\\<^sub>1 \\<union> C\\<^sub>2) \\<inter> Q \\<inter> Q' \\<noteq> {})", "by simp"], ["proof (state)\nthis:\n  strong_consensus_cluster (C\\<^sub>1 \\<union> C\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "section \"Stellar quorum systems\""], ["", "locale stellar =\n  fixes slices :: \"'node \\<Rightarrow> 'node set set\" \\<comment> \\<open>the quorum slices\\<close>\n    and W :: \"'node set\" \\<comment> \\<open>the well-behaved nodes\\<close>\n  assumes slices_ne:\"\\<And>p . p \\<in> W \\<Longrightarrow> slices p \\<noteq> {}\"\nbegin"], ["", "definition quorum where\n  \"quorum Q \\<equiv> \\<forall> p \\<in> Q \\<inter> W . (\\<exists> Sl \\<in> slices p . Sl \\<subseteq> Q)\""], ["", "definition quorum_of where \"quorum_of p Q \\<equiv> quorum Q \\<and> (p \\<notin> W \\<or> (\\<exists> Sl \\<in> slices p . Sl \\<subseteq> Q))\"\n  \\<comment> \\<open>TODO: @{term \"p\\<notin>W\"} needed?\\<close>"], ["", "lemma quorum_union:\"quorum Q \\<Longrightarrow> quorum Q' \\<Longrightarrow> quorum (Q \\<union> Q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>quorum Q; quorum Q'\\<rbrakk>\n    \\<Longrightarrow> quorum (Q \\<union> Q')", "unfolding quorum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p\\<in>Q \\<inter> W.\n                \\<exists>Sl\\<in>slices p. Sl \\<subseteq> Q;\n     \\<forall>p\\<in>Q' \\<inter> W.\n        \\<exists>Sl\\<in>slices p. Sl \\<subseteq> Q'\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>(Q \\<union> Q') \\<inter> W.\n                         \\<exists>Sl\\<in>slices p.\n                            Sl \\<subseteq> Q \\<union> Q'", "by (metis IntE Int_iff UnE inf_sup_aci(1) sup.coboundedI1 sup.coboundedI2)"], ["", "lemma l1:\n  assumes \"\\<And> p . p \\<in> S \\<Longrightarrow> \\<exists> Q \\<subseteq> S . quorum_of p Q\" and \"p\\<in> S\"\n  shows \"quorum_of p S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quorum_of p S", "using assms"], ["proof (prove)\nusing this:\n  ?p \\<in> S \\<Longrightarrow> \\<exists>Q\\<subseteq>S. quorum_of ?p Q\n  p \\<in> S\n\ngoal (1 subgoal):\n 1. quorum_of p S", "unfolding quorum_of_def quorum_def"], ["proof (prove)\nusing this:\n  ?p \\<in> S \\<Longrightarrow>\n  \\<exists>Q\\<subseteq>S.\n     (\\<forall>p\\<in>Q \\<inter> W.\n         \\<exists>Sl\\<in>slices p. Sl \\<subseteq> Q) \\<and>\n     (?p \\<notin> W \\<or> (\\<exists>Sl\\<in>slices ?p. Sl \\<subseteq> Q))\n  p \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<forall>p\\<in>S \\<inter> W.\n        \\<exists>Sl\\<in>slices p. Sl \\<subseteq> S) \\<and>\n    (p \\<notin> W \\<or> (\\<exists>Sl\\<in>slices p. Sl \\<subseteq> S))", "by (meson Int_iff subset_trans)"], ["", "lemma is_pbqs:\n  assumes \"quorum_of p Q\" and \"p' \\<in> Q\"\n  shows \"quorum_of p' Q\" \n  \\<comment> \\<open>This is the property required of a PBQS.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. quorum_of p' Q", "using assms"], ["proof (prove)\nusing this:\n  quorum_of p Q\n  p' \\<in> Q\n\ngoal (1 subgoal):\n 1. quorum_of p' Q", "by (simp add: quorum_def quorum_of_def)"], ["", "interpretation with_w quorum_of \n  \\<comment> \\<open>Stellar quorums form a personal quorum system.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. with_w quorum_of", "unfolding with_w_def personal_quorums_def \n  quorum_def quorum_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q p p'.\n       (\\<forall>p\\<in>Q \\<inter> W.\n           \\<exists>Sl\\<in>slices p. Sl \\<subseteq> Q) \\<and>\n       (p \\<notin> W \\<or>\n        (\\<exists>Sl\\<in>slices p. Sl \\<subseteq> Q)) \\<longrightarrow>\n       p' \\<in> Q \\<longrightarrow>\n       (\\<forall>p\\<in>Q \\<inter> W.\n           \\<exists>Sl\\<in>slices p. Sl \\<subseteq> Q) \\<and>\n       (p' \\<notin> W \\<or> (\\<exists>Sl\\<in>slices p'. Sl \\<subseteq> Q))", "by simp"], ["", "lemma quorum_is_quorum_of_some_slice:\n  assumes \"quorum_of p Q\" and \"p \\<in> W\"\n  obtains S where \"S \\<in> slices p\" and \"S \\<subseteq> Q\"\n    and \"\\<And> p' . p' \\<in> S \\<inter> W \\<Longrightarrow> quorum_of p' Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>S \\<in> slices p; S \\<subseteq> Q;\n         \\<And>p'.\n            p' \\<in> S \\<inter> W \\<Longrightarrow> quorum_of p' Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  quorum_of p Q\n  p \\<in> W\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>S \\<in> slices p; S \\<subseteq> Q;\n         \\<And>p'.\n            p' \\<in> S \\<inter> W \\<Longrightarrow> quorum_of p' Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding quorum_def quorum_of_def"], ["proof (prove)\nusing this:\n  (\\<forall>p\\<in>Q \\<inter> W.\n      \\<exists>Sl\\<in>slices p. Sl \\<subseteq> Q) \\<and>\n  (p \\<notin> W \\<or> (\\<exists>Sl\\<in>slices p. Sl \\<subseteq> Q))\n  p \\<in> W\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>S \\<in> slices p; S \\<subseteq> Q;\n         \\<And>p'.\n            p' \\<in> S \\<inter> W \\<Longrightarrow>\n            (\\<forall>p\\<in>Q \\<inter> W.\n                \\<exists>Sl\\<in>slices p. Sl \\<subseteq> Q) \\<and>\n            (p' \\<notin> W \\<or>\n             (\\<exists>Sl\\<in>slices p'. Sl \\<subseteq> Q))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["", "lemma \"is_cons_cluster C \\<Longrightarrow> quorum C\" \n  \\<comment> \\<open>Every consensus cluster is a quorum.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cons_cluster C \\<Longrightarrow> quorum C", "unfolding is_cons_cluster_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<subseteq> W \\<and>\n    (\\<forall>p\\<in>C. \\<exists>Q\\<subseteq>C. quorum_of p Q) \\<and>\n    (\\<forall>Q Q'.\n        quorum_of_set C Q \\<and> quorum_of_set C Q' \\<longrightarrow>\n        W \\<inter> Q \\<inter> Q' \\<noteq> {}) \\<Longrightarrow>\n    quorum C", "by (metis inf.order_iff l1 quorum_of_def stellar.quorum_def stellar_axioms)"], ["", "subsection \\<open>Properties of blocking sets\\<close>"], ["", "inductive blocking_min where\n  \\<comment> \\<open>This is the set of correct participants that are eventually blocked by a set @{term R} when byzantine processors do not take steps.\\<close>\n  \"\\<lbrakk>p \\<in> W; \\<forall> Sl \\<in> slices p . \\<exists> q \\<in> Sl\\<inter>W . q \\<in> R \\<or> blocking_min R q\\<rbrakk> \\<Longrightarrow> blocking_min R p\""], ["", "inductive_cases blocking_min_elim:\"blocking_min R p\""], ["", "inductive blocking_max where\n  \\<comment> \\<open>This is the set of participants that are eventually blocked by a set @{term R} when byzantine processors help epidemic propagation.\\<close>\n  \"\\<lbrakk>p \\<in> W; \\<forall> Sl \\<in> slices p . \\<exists> q \\<in> Sl . q \\<in> R\\<union>B \\<or> blocking_max R q\\<rbrakk> \\<Longrightarrow> blocking_max R p\""], ["", "inductive_cases \"blocking_max R p\""], ["", "text \\<open>Next we show that if @{term \\<open>R\\<close>} blocks @{term \\<open>p\\<close>} and @{term p} belongs to a consensus cluster @{term S}, then @{term \\<open>R \\<inter> S \\<noteq> {}\\<close>}.\\<close>"], ["", "text \\<open>We first prove two auxiliary lemmas:\\<close>"], ["", "lemma cons_cluster_wb:\"p \\<in> C \\<Longrightarrow> is_cons_cluster C \\<Longrightarrow> p\\<in>W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<in> C; is_cons_cluster C\\<rbrakk>\n    \\<Longrightarrow> p \\<in> W", "using is_cons_cluster_def"], ["proof (prove)\nusing this:\n  is_cons_cluster ?C \\<equiv>\n  ?C \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>?C. \\<exists>Q\\<subseteq>?C. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      quorum_of_set ?C Q \\<and> quorum_of_set ?C Q' \\<longrightarrow>\n      W \\<inter> Q \\<inter> Q' \\<noteq> {})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<in> C; is_cons_cluster C\\<rbrakk>\n    \\<Longrightarrow> p \\<in> W", "by fastforce"], ["", "lemma cons_cluster_has_ne_slices:\n  assumes \"is_cons_cluster C\" and \"p\\<in>C\"\n    and \"Sl \\<in> slices p\" \n  shows \"Sl \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sl \\<noteq> {}", "using assms"], ["proof (prove)\nusing this:\n  is_cons_cluster C\n  p \\<in> C\n  Sl \\<in> slices p\n\ngoal (1 subgoal):\n 1. Sl \\<noteq> {}", "unfolding is_cons_cluster_def quorum_of_set_def quorum_of_def quorum_def"], ["proof (prove)\nusing this:\n  C \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>C.\n      \\<exists>Q\\<subseteq>C.\n         (\\<forall>p\\<in>Q \\<inter> W.\n             \\<exists>Sl\\<in>slices p. Sl \\<subseteq> Q) \\<and>\n         (p \\<notin> W \\<or>\n          (\\<exists>Sl\\<in>slices p. Sl \\<subseteq> Q))) \\<and>\n  (\\<forall>Q Q'.\n      (\\<exists>p\\<in>C.\n          (\\<forall>p\\<in>Q \\<inter> W.\n              \\<exists>Sl\\<in>slices p. Sl \\<subseteq> Q) \\<and>\n          (p \\<notin> W \\<or>\n           (\\<exists>Sl\\<in>slices p. Sl \\<subseteq> Q))) \\<and>\n      (\\<exists>p\\<in>C.\n          (\\<forall>p\\<in>Q' \\<inter> W.\n              \\<exists>Sl\\<in>slices p. Sl \\<subseteq> Q') \\<and>\n          (p \\<notin> W \\<or>\n           (\\<exists>Sl\\<in>slices p. Sl \\<subseteq> Q'))) \\<longrightarrow>\n      W \\<inter> Q \\<inter> Q' \\<noteq> {})\n  p \\<in> C\n  Sl \\<in> slices p\n\ngoal (1 subgoal):\n 1. Sl \\<noteq> {}", "by (metis empty_iff inf_bot_left inf_bot_right subset_refl)"], ["", "lemma cons_cluster_has_cons_cluster_slice:\n  assumes \"is_cons_cluster C\" and \"p\\<in>C\"\n  obtains Sl where \"Sl \\<in> slices p\" and \"Sl \\<subseteq> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Sl.\n        \\<lbrakk>Sl \\<in> slices p; Sl \\<subseteq> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  is_cons_cluster C\n  p \\<in> C\n\ngoal (1 subgoal):\n 1. (\\<And>Sl.\n        \\<lbrakk>Sl \\<in> slices p; Sl \\<subseteq> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_cons_cluster_def quorum_of_set_def quorum_of_def quorum_def"], ["proof (prove)\nusing this:\n  C \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>C.\n      \\<exists>Q\\<subseteq>C.\n         (\\<forall>p\\<in>Q \\<inter> W.\n             \\<exists>Sl\\<in>slices p. Sl \\<subseteq> Q) \\<and>\n         (p \\<notin> W \\<or>\n          (\\<exists>Sl\\<in>slices p. Sl \\<subseteq> Q))) \\<and>\n  (\\<forall>Q Q'.\n      (\\<exists>p\\<in>C.\n          (\\<forall>p\\<in>Q \\<inter> W.\n              \\<exists>Sl\\<in>slices p. Sl \\<subseteq> Q) \\<and>\n          (p \\<notin> W \\<or>\n           (\\<exists>Sl\\<in>slices p. Sl \\<subseteq> Q))) \\<and>\n      (\\<exists>p\\<in>C.\n          (\\<forall>p\\<in>Q' \\<inter> W.\n              \\<exists>Sl\\<in>slices p. Sl \\<subseteq> Q') \\<and>\n          (p \\<notin> W \\<or>\n           (\\<exists>Sl\\<in>slices p. Sl \\<subseteq> Q'))) \\<longrightarrow>\n      W \\<inter> Q \\<inter> Q' \\<noteq> {})\n  p \\<in> C\n\ngoal (1 subgoal):\n 1. (\\<And>Sl.\n        \\<lbrakk>Sl \\<in> slices p; Sl \\<subseteq> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Int_commute  empty_iff inf.order_iff  inf_bot_right le_infI1)"], ["", "theorem blocking_max_intersects_intact:\n  \\<comment> \\<open>if @{term \\<open>R\\<close>} blocks @{term \\<open>p\\<close>} when malicious participants help epidemic propagation, \nand @{term p} belongs to a consensus cluster @{term C}, then @{term \\<open>R \\<inter> C \\<noteq> {}\\<close>}\\<close>\n  assumes  \"blocking_max R p\" and \"is_cons_cluster C\" and \"p \\<in> C\"\n  shows \"R \\<inter> C \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<inter> C \\<noteq> {}", "using assms"], ["proof (prove)\nusing this:\n  blocking_max R p\n  is_cons_cluster C\n  p \\<in> C\n\ngoal (1 subgoal):\n 1. R \\<inter> C \\<noteq> {}", "proof (induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p R.\n       \\<lbrakk>p \\<in> W;\n        \\<forall>Sl\\<in>slices p.\n           \\<exists>q\\<in>Sl.\n              q \\<in> R \\<union> B \\<or>\n              blocking_max R q \\<and>\n              (is_cons_cluster C \\<longrightarrow>\n               q \\<in> C \\<longrightarrow> R \\<inter> C \\<noteq> {});\n        is_cons_cluster C; p \\<in> C\\<rbrakk>\n       \\<Longrightarrow> R \\<inter> C \\<noteq> {}", "case (1 p R)"], ["proof (state)\nthis:\n  p \\<in> W\n  \\<forall>Sl\\<in>slices p.\n     \\<exists>q\\<in>Sl.\n        q \\<in> R \\<union> B \\<or>\n        blocking_max R q \\<and>\n        (is_cons_cluster C \\<longrightarrow>\n         q \\<in> C \\<longrightarrow> R \\<inter> C \\<noteq> {})\n  is_cons_cluster C\n  p \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>p R.\n       \\<lbrakk>p \\<in> W;\n        \\<forall>Sl\\<in>slices p.\n           \\<exists>q\\<in>Sl.\n              q \\<in> R \\<union> B \\<or>\n              blocking_max R q \\<and>\n              (is_cons_cluster C \\<longrightarrow>\n               q \\<in> C \\<longrightarrow> R \\<inter> C \\<noteq> {});\n        is_cons_cluster C; p \\<in> C\\<rbrakk>\n       \\<Longrightarrow> R \\<inter> C \\<noteq> {}", "obtain Sl where \"Sl \\<in> slices p\" and \"Sl \\<subseteq> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Sl.\n        \\<lbrakk>Sl \\<in> slices p; Sl \\<subseteq> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cons_cluster_has_cons_cluster_slice"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_cons_cluster ?C; ?p \\<in> ?C;\n   \\<And>Sl.\n      \\<lbrakk>Sl \\<in> slices ?p; Sl \\<subseteq> ?C\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>Sl.\n        \\<lbrakk>Sl \\<in> slices p; Sl \\<subseteq> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \"1.prems\""], ["proof (prove)\nusing this:\n  \\<lbrakk>is_cons_cluster ?C; ?p \\<in> ?C;\n   \\<And>Sl.\n      \\<lbrakk>Sl \\<in> slices ?p; Sl \\<subseteq> ?C\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  is_cons_cluster C\n  p \\<in> C\n\ngoal (1 subgoal):\n 1. (\\<And>Sl.\n        \\<lbrakk>Sl \\<in> slices p; Sl \\<subseteq> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Sl \\<in> slices p\n  Sl \\<subseteq> C\n\ngoal (1 subgoal):\n 1. \\<And>p R.\n       \\<lbrakk>p \\<in> W;\n        \\<forall>Sl\\<in>slices p.\n           \\<exists>q\\<in>Sl.\n              q \\<in> R \\<union> B \\<or>\n              blocking_max R q \\<and>\n              (is_cons_cluster C \\<longrightarrow>\n               q \\<in> C \\<longrightarrow> R \\<inter> C \\<noteq> {});\n        is_cons_cluster C; p \\<in> C\\<rbrakk>\n       \\<Longrightarrow> R \\<inter> C \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  Sl \\<in> slices p\n  Sl \\<subseteq> C\n\ngoal (1 subgoal):\n 1. \\<And>p R.\n       \\<lbrakk>p \\<in> W;\n        \\<forall>Sl\\<in>slices p.\n           \\<exists>q\\<in>Sl.\n              q \\<in> R \\<union> B \\<or>\n              blocking_max R q \\<and>\n              (is_cons_cluster C \\<longrightarrow>\n               q \\<in> C \\<longrightarrow> R \\<inter> C \\<noteq> {});\n        is_cons_cluster C; p \\<in> C\\<rbrakk>\n       \\<Longrightarrow> R \\<inter> C \\<noteq> {}", "have \"Sl \\<subseteq> W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sl \\<subseteq> W", "using assms(2) calculation(2) is_cons_cluster_def"], ["proof (prove)\nusing this:\n  is_cons_cluster C\n  Sl \\<subseteq> C\n  is_cons_cluster ?C \\<equiv>\n  ?C \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>?C. \\<exists>Q\\<subseteq>?C. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      quorum_of_set ?C Q \\<and> quorum_of_set ?C Q' \\<longrightarrow>\n      W \\<inter> Q \\<inter> Q' \\<noteq> {})\n\ngoal (1 subgoal):\n 1. Sl \\<subseteq> W", "by auto"], ["proof (state)\nthis:\n  Sl \\<subseteq> W\n\ngoal (1 subgoal):\n 1. \\<And>p R.\n       \\<lbrakk>p \\<in> W;\n        \\<forall>Sl\\<in>slices p.\n           \\<exists>q\\<in>Sl.\n              q \\<in> R \\<union> B \\<or>\n              blocking_max R q \\<and>\n              (is_cons_cluster C \\<longrightarrow>\n               q \\<in> C \\<longrightarrow> R \\<inter> C \\<noteq> {});\n        is_cons_cluster C; p \\<in> C\\<rbrakk>\n       \\<Longrightarrow> R \\<inter> C \\<noteq> {}", "ultimately"], ["proof (chain)\npicking this:\n  Sl \\<in> slices p\n  Sl \\<subseteq> C\n  Sl \\<subseteq> W", "show ?case"], ["proof (prove)\nusing this:\n  Sl \\<in> slices p\n  Sl \\<subseteq> C\n  Sl \\<subseteq> W\n\ngoal (1 subgoal):\n 1. R \\<inter> C \\<noteq> {}", "using \"1.hyps\" assms(2)"], ["proof (prove)\nusing this:\n  Sl \\<in> slices p\n  Sl \\<subseteq> C\n  Sl \\<subseteq> W\n  p \\<in> W\n  \\<forall>Sl\\<in>slices p.\n     \\<exists>q\\<in>Sl.\n        q \\<in> R \\<union> B \\<or>\n        blocking_max R q \\<and>\n        (is_cons_cluster C \\<longrightarrow>\n         q \\<in> C \\<longrightarrow> R \\<inter> C \\<noteq> {})\n  is_cons_cluster C\n\ngoal (1 subgoal):\n 1. R \\<inter> C \\<noteq> {}", "by fastforce"], ["proof (state)\nthis:\n  R \\<inter> C \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Now we show that if @{term \\<open>p \\<in> C\\<close>}, @{term C} is a consensus cluster, and quorum @{term Q} is such that @{term \\<open>Q \\<inter> C \\<noteq> {}\\<close>},\n    then @{term \\<open>Q \\<inter> W\\<close>} blocks @{term p}. \n\nWe start by defining the set of participants reachable from a participant through correct participants.\nTheir union trivially forms a quorum. \nMoreover, if @{term p} is not blocked by a set @{term R}, \nthen we show that the set of participants reachable from @{term p} and not blocked by @{term R} forms a quorum disjoint from @{term R}.\nIt follows that if @{term p } is a member of a consensus cluster @{term C} and @{term Q} is a quorum of a member of @{term C}, then @{term \"Q\\<inter>W\"}\n must block @{term p}, as otherwise quorum intersection would be violated. \\<close>"], ["", "inductive not_blocked for p R where\n  \"\\<lbrakk>Sl \\<in> slices p; \\<forall> q \\<in> Sl\\<inter>W . q \\<notin> R \\<and> \\<not>blocking_min R q; q \\<in> Sl\\<rbrakk> \\<Longrightarrow> not_blocked p R q\"\n| \"\\<lbrakk>not_blocked p R p'; p' \\<in> W; Sl \\<in> slices p'; \\<forall> q \\<in> Sl\\<inter>W . q \\<notin> R \\<and> \\<not>blocking_min R q; q \\<in> Sl\\<rbrakk> \\<Longrightarrow> not_blocked p R q\""], ["", "inductive_cases not_blocked_cases:\"not_blocked p R q\""], ["", "lemma l4:\n  fixes Q p R\n  defines \"Q \\<equiv> {q . not_blocked p R q}\"\n  shows \"quorum Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quorum Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. quorum Q", "have \"\\<exists> S \\<in> slices n . S \\<subseteq> Q\" if \"n\\<in>Q\\<inter>W\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>S\\<in>slices n. S \\<subseteq> Q", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>S\\<in>slices n. S \\<subseteq> Q", "have \"not_blocked p R n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_blocked p R n", "using assms that"], ["proof (prove)\nusing this:\n  Q \\<equiv> {q. not_blocked p R q}\n  n \\<in> Q \\<inter> W\n\ngoal (1 subgoal):\n 1. not_blocked p R n", "by blast"], ["proof (state)\nthis:\n  not_blocked p R n\n\ngoal (1 subgoal):\n 1. \\<exists>S\\<in>slices n. S \\<subseteq> Q", "hence \"n \\<notin> R\" and \"\\<not>blocking_min R n\""], ["proof (prove)\nusing this:\n  not_blocked p R n\n\ngoal (1 subgoal):\n 1. n \\<notin> R &&& \\<not> blocking_min R n", "by (metis Int_iff not_blocked.simps that)+"], ["proof (state)\nthis:\n  n \\<notin> R\n  \\<not> blocking_min R n\n\ngoal (1 subgoal):\n 1. \\<exists>S\\<in>slices n. S \\<subseteq> Q", "thus ?thesis"], ["proof (prove)\nusing this:\n  n \\<notin> R\n  \\<not> blocking_min R n\n\ngoal (1 subgoal):\n 1. \\<exists>S\\<in>slices n. S \\<subseteq> Q", "using blocking_min.intros not_blocked.intros(2) that"], ["proof (prove)\nusing this:\n  n \\<notin> R\n  \\<not> blocking_min R n\n  \\<lbrakk>?p \\<in> W;\n   \\<forall>Sl\\<in>slices ?p.\n      \\<exists>q\\<in>Sl \\<inter> W.\n         q \\<in> ?R \\<or> blocking_min ?R q\\<rbrakk>\n  \\<Longrightarrow> blocking_min ?R ?p\n  \\<lbrakk>not_blocked ?p ?R ?p'; ?p' \\<in> W; ?Sl \\<in> slices ?p';\n   \\<forall>q\\<in>?Sl \\<inter> W.\n      q \\<notin> ?R \\<and> \\<not> blocking_min ?R q;\n   ?q \\<in> ?Sl\\<rbrakk>\n  \\<Longrightarrow> not_blocked ?p ?R ?q\n  n \\<in> Q \\<inter> W\n\ngoal (1 subgoal):\n 1. \\<exists>S\\<in>slices n. S \\<subseteq> Q", "unfolding Q_def"], ["proof (prove)\nusing this:\n  n \\<notin> R\n  \\<not> blocking_min R n\n  \\<lbrakk>?p \\<in> W;\n   \\<forall>Sl\\<in>slices ?p.\n      \\<exists>q\\<in>Sl \\<inter> W.\n         q \\<in> ?R \\<or> blocking_min ?R q\\<rbrakk>\n  \\<Longrightarrow> blocking_min ?R ?p\n  \\<lbrakk>not_blocked ?p ?R ?p'; ?p' \\<in> W; ?Sl \\<in> slices ?p';\n   \\<forall>q\\<in>?Sl \\<inter> W.\n      q \\<notin> ?R \\<and> \\<not> blocking_min ?R q;\n   ?q \\<in> ?Sl\\<rbrakk>\n  \\<Longrightarrow> not_blocked ?p ?R ?q\n  n \\<in> {q. not_blocked p R q} \\<inter> W\n\ngoal (1 subgoal):\n 1. \\<exists>S\\<in>slices n. S \\<subseteq> {q. not_blocked p R q}", "by (simp; metis mem_Collect_eq subsetI)"], ["proof (state)\nthis:\n  \\<exists>S\\<in>slices n. S \\<subseteq> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?n \\<in> Q \\<inter> W \\<Longrightarrow>\n  \\<exists>S\\<in>slices ?n. S \\<subseteq> Q\n\ngoal (1 subgoal):\n 1. quorum Q", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?n \\<in> Q \\<inter> W \\<Longrightarrow>\n  \\<exists>S\\<in>slices ?n. S \\<subseteq> Q\n\ngoal (1 subgoal):\n 1. quorum Q", "by (simp add: quorum_def)"], ["proof (state)\nthis:\n  quorum Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma l5:\n  fixes Q p R\n  defines \"Q \\<equiv> {q . not_blocked p R q}\"\n  assumes  \"\\<not>blocking_min R p\" and \\<open>p\\<in>C\\<close> and \\<open>is_cons_cluster C\\<close>\n  shows \"quorum_of p Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quorum_of p Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. quorum_of p Q", "have \"p\\<in>W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> W", "using assms(3,4) cons_cluster_wb"], ["proof (prove)\nusing this:\n  p \\<in> C\n  is_cons_cluster C\n  \\<lbrakk>?p \\<in> ?C; is_cons_cluster ?C\\<rbrakk>\n  \\<Longrightarrow> ?p \\<in> W\n\ngoal (1 subgoal):\n 1. p \\<in> W", "by blast"], ["proof (state)\nthis:\n  p \\<in> W\n\ngoal (1 subgoal):\n 1. quorum_of p Q", "obtain Sl where \"Sl \\<in> slices p\" and \"\\<forall> q \\<in> Sl\\<inter>W . q \\<notin> R \\<and> \\<not>blocking_min R q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Sl.\n        \\<lbrakk>Sl \\<in> slices p;\n         \\<forall>q\\<in>Sl \\<inter> W.\n            q \\<notin> R \\<and> \\<not> blocking_min R q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson \\<open>p \\<in> W\\<close> assms(2) blocking_min.intros)"], ["proof (state)\nthis:\n  Sl \\<in> slices p\n  \\<forall>q\\<in>Sl \\<inter> W. q \\<notin> R \\<and> \\<not> blocking_min R q\n\ngoal (1 subgoal):\n 1. quorum_of p Q", "hence \"Sl \\<subseteq> Q\""], ["proof (prove)\nusing this:\n  Sl \\<in> slices p\n  \\<forall>q\\<in>Sl \\<inter> W. q \\<notin> R \\<and> \\<not> blocking_min R q\n\ngoal (1 subgoal):\n 1. Sl \\<subseteq> Q", "unfolding Q_def"], ["proof (prove)\nusing this:\n  Sl \\<in> slices p\n  \\<forall>q\\<in>Sl \\<inter> W. q \\<notin> R \\<and> \\<not> blocking_min R q\n\ngoal (1 subgoal):\n 1. Sl \\<subseteq> {q. not_blocked p R q}", "using not_blocked.intros(1)"], ["proof (prove)\nusing this:\n  Sl \\<in> slices p\n  \\<forall>q\\<in>Sl \\<inter> W. q \\<notin> R \\<and> \\<not> blocking_min R q\n  \\<lbrakk>?Sl \\<in> slices ?p;\n   \\<forall>q\\<in>?Sl \\<inter> W.\n      q \\<notin> ?R \\<and> \\<not> blocking_min ?R q;\n   ?q \\<in> ?Sl\\<rbrakk>\n  \\<Longrightarrow> not_blocked ?p ?R ?q\n\ngoal (1 subgoal):\n 1. Sl \\<subseteq> {q. not_blocked p R q}", "by blast"], ["proof (state)\nthis:\n  Sl \\<subseteq> Q\n\ngoal (1 subgoal):\n 1. quorum_of p Q", "with l4 \\<open>Sl \\<in> slices p\\<close>"], ["proof (chain)\npicking this:\n  quorum {q. not_blocked ?p ?R q}\n  Sl \\<in> slices p\n  Sl \\<subseteq> Q", "show \"quorum_of p Q\""], ["proof (prove)\nusing this:\n  quorum {q. not_blocked ?p ?R q}\n  Sl \\<in> slices p\n  Sl \\<subseteq> Q\n\ngoal (1 subgoal):\n 1. quorum_of p Q", "using Q_def  quorum_of_def"], ["proof (prove)\nusing this:\n  quorum {q. not_blocked ?p ?R q}\n  Sl \\<in> slices p\n  Sl \\<subseteq> Q\n  Q \\<equiv> {q. not_blocked p R q}\n  quorum_of ?p ?Q \\<equiv>\n  quorum ?Q \\<and>\n  (?p \\<notin> W \\<or> (\\<exists>Sl\\<in>slices ?p. Sl \\<subseteq> ?Q))\n\ngoal (1 subgoal):\n 1. quorum_of p Q", "by blast"], ["proof (state)\nthis:\n  quorum_of p Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cons_cluster_ne_slices:\n  assumes \"is_cons_cluster C\" and \"p\\<in>C\" and \"Sl \\<in> slices p\"\n  shows \"Sl\\<noteq>{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sl \\<noteq> {}", "using assms cons_cluster_has_ne_slices cons_cluster_wb stellar.quorum_of_def stellar_axioms"], ["proof (prove)\nusing this:\n  is_cons_cluster C\n  p \\<in> C\n  Sl \\<in> slices p\n  \\<lbrakk>is_cons_cluster ?C; ?p \\<in> ?C; ?Sl \\<in> slices ?p\\<rbrakk>\n  \\<Longrightarrow> ?Sl \\<noteq> {}\n  \\<lbrakk>?p \\<in> ?C; is_cons_cluster ?C\\<rbrakk>\n  \\<Longrightarrow> ?p \\<in> W\n  stellar ?slices ?W \\<Longrightarrow>\n  stellar.quorum_of ?slices ?W ?p ?Q \\<equiv>\n  stellar.quorum ?slices ?W ?Q \\<and>\n  (?p \\<notin> ?W \\<or> (\\<exists>Sl\\<in>?slices ?p. Sl \\<subseteq> ?Q))\n  stellar slices W\n\ngoal (1 subgoal):\n 1. Sl \\<noteq> {}", "by fastforce"], ["", "lemma l6:\n  fixes Q p R\n  defines \"Q \\<equiv> {q . not_blocked p R q}\"\n  shows \"Q \\<inter> R \\<inter> W = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<inter> R \\<inter> W = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Q \\<inter> R \\<inter> W = {}", "have \"q \\<notin> R\" if \"not_blocked p R q\" and \"q\\<in> W\" for q"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<notin> R", "using that"], ["proof (prove)\nusing this:\n  not_blocked p R q\n  q \\<in> W\n\ngoal (1 subgoal):\n 1. q \\<notin> R", "by (metis Int_iff not_blocked.simps)"], ["proof (state)\nthis:\n  \\<lbrakk>not_blocked p R ?q; ?q \\<in> W\\<rbrakk>\n  \\<Longrightarrow> ?q \\<notin> R\n\ngoal (1 subgoal):\n 1. Q \\<inter> R \\<inter> W = {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>not_blocked p R ?q; ?q \\<in> W\\<rbrakk>\n  \\<Longrightarrow> ?q \\<notin> R\n\ngoal (1 subgoal):\n 1. Q \\<inter> R \\<inter> W = {}", "unfolding Q_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>not_blocked p R ?q; ?q \\<in> W\\<rbrakk>\n  \\<Longrightarrow> ?q \\<notin> R\n\ngoal (1 subgoal):\n 1. {q. not_blocked p R q} \\<inter> R \\<inter> W = {}", "by auto"], ["proof (state)\nthis:\n  Q \\<inter> R \\<inter> W = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem quorum_blocks_cons_cluster:\n  assumes \"quorum_of_set C Q\" and \"p\\<in>C\" and \"is_cons_cluster C\"\n  shows \"blocking_min (Q \\<inter> W) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blocking_min (Q \\<inter> W) p", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> blocking_min (Q \\<inter> W) p \\<Longrightarrow> False", "assume \"\\<not> blocking_min (Q \\<inter> W) p\""], ["proof (state)\nthis:\n  \\<not> blocking_min (Q \\<inter> W) p\n\ngoal (1 subgoal):\n 1. \\<not> blocking_min (Q \\<inter> W) p \\<Longrightarrow> False", "have \"p\\<in>W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> W", "using assms(2,3) is_cons_cluster_def"], ["proof (prove)\nusing this:\n  p \\<in> C\n  is_cons_cluster C\n  is_cons_cluster ?C \\<equiv>\n  ?C \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>?C. \\<exists>Q\\<subseteq>?C. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      quorum_of_set ?C Q \\<and> quorum_of_set ?C Q' \\<longrightarrow>\n      W \\<inter> Q \\<inter> Q' \\<noteq> {})\n\ngoal (1 subgoal):\n 1. p \\<in> W", "by auto"], ["proof (state)\nthis:\n  p \\<in> W\n\ngoal (1 subgoal):\n 1. \\<not> blocking_min (Q \\<inter> W) p \\<Longrightarrow> False", "define Q' where \"Q' \\<equiv> {q . not_blocked p (Q\\<inter>W) q}\""], ["proof (state)\nthis:\n  Q' \\<equiv> {q. not_blocked p (Q \\<inter> W) q}\n\ngoal (1 subgoal):\n 1. \\<not> blocking_min (Q \\<inter> W) p \\<Longrightarrow> False", "have \"quorum_of p Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quorum_of p Q'", "using Q'_def \\<open>\\<not> blocking_min (Q \\<inter> W) p\\<close> assms(2) assms(3) l5(1)"], ["proof (prove)\nusing this:\n  Q' \\<equiv> {q. not_blocked p (Q \\<inter> W) q}\n  \\<not> blocking_min (Q \\<inter> W) p\n  p \\<in> C\n  is_cons_cluster C\n  \\<lbrakk>\\<not> blocking_min ?R ?p; ?p \\<in> ?C;\n   is_cons_cluster ?C\\<rbrakk>\n  \\<Longrightarrow> quorum_of ?p {q. not_blocked ?p ?R q}\n\ngoal (1 subgoal):\n 1. quorum_of p Q'", "by blast"], ["proof (state)\nthis:\n  quorum_of p Q'\n\ngoal (1 subgoal):\n 1. \\<not> blocking_min (Q \\<inter> W) p \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  quorum_of p Q'\n\ngoal (1 subgoal):\n 1. \\<not> blocking_min (Q \\<inter> W) p \\<Longrightarrow> False", "have \"Q' \\<inter> Q \\<inter> W = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q' \\<inter> Q \\<inter> W = {}", "using Q'_def l6"], ["proof (prove)\nusing this:\n  Q' \\<equiv> {q. not_blocked p (Q \\<inter> W) q}\n  {q. not_blocked ?p ?R q} \\<inter> ?R \\<inter> W = {}\n\ngoal (1 subgoal):\n 1. Q' \\<inter> Q \\<inter> W = {}", "by fastforce"], ["proof (state)\nthis:\n  Q' \\<inter> Q \\<inter> W = {}\n\ngoal (1 subgoal):\n 1. \\<not> blocking_min (Q \\<inter> W) p \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  quorum_of p Q'\n  Q' \\<inter> Q \\<inter> W = {}", "show False"], ["proof (prove)\nusing this:\n  quorum_of p Q'\n  Q' \\<inter> Q \\<inter> W = {}\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  quorum_of p Q'\n  Q' \\<inter> Q \\<inter> W = {}\n  quorum_of_set C Q\n  p \\<in> C\n  is_cons_cluster C\n\ngoal (1 subgoal):\n 1. False", "unfolding is_cons_cluster_def"], ["proof (prove)\nusing this:\n  quorum_of p Q'\n  Q' \\<inter> Q \\<inter> W = {}\n  quorum_of_set C Q\n  p \\<in> C\n  C \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>C. \\<exists>Q\\<subseteq>C. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      quorum_of_set C Q \\<and> quorum_of_set C Q' \\<longrightarrow>\n      W \\<inter> Q \\<inter> Q' \\<noteq> {})\n\ngoal (1 subgoal):\n 1. False", "by (metis Int_commute inf_sup_aci(2) quorum_of_set_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Reachability through a set\\<close>"], ["", "text \\<open>Here we define the part of a quorum @{term Q} of @{term p} that is reachable through correct\nparticipants from @{term p}. We show that if @{term p} and @{term p'} are members of the same consensus cluster and @{term Q} is a quorum of @{term p}\n and @{term Q'} is a quorum of @{term p'},\nthen the intersection @{term \"Q\\<inter>Q'\\<inter>W\"} is reachable from both @{term p} and @{term p'} through the consensus cluster.\\<close>"], ["", "inductive reachable_through for p S where\n  \"reachable_through p S p\"\n| \"\\<lbrakk>reachable_through p S p'; p' \\<in> W; Sl \\<in> slices p'; Sl \\<subseteq> S; p'' \\<in> Sl\\<rbrakk> \\<Longrightarrow> reachable_through p S p''\""], ["", "definition truncation where \"truncation p S \\<equiv> {p' . reachable_through p S p'}\""], ["", "lemma l13:\n  assumes \"quorum_of p Q\" and \"p \\<in> W\" and \"reachable_through p Q p'\"\n  shows \"quorum_of p' Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quorum_of p' Q", "using assms"], ["proof (prove)\nusing this:\n  quorum_of p Q\n  p \\<in> W\n  reachable_through p Q p'\n\ngoal (1 subgoal):\n 1. quorum_of p' Q", "using quorum_assm reachable_through.cases"], ["proof (prove)\nusing this:\n  quorum_of p Q\n  p \\<in> W\n  reachable_through p Q p'\n  \\<lbrakk>quorum_of ?p ?Q; ?p' \\<in> ?Q\\<rbrakk>\n  \\<Longrightarrow> quorum_of ?p' ?Q\n  \\<lbrakk>reachable_through ?p ?S ?a; ?a = ?p \\<Longrightarrow> ?P;\n   \\<And>p' Sl p''.\n      \\<lbrakk>?a = p''; reachable_through ?p ?S p'; p' \\<in> W;\n       Sl \\<in> slices p'; Sl \\<subseteq> ?S; p'' \\<in> Sl\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. quorum_of p' Q", "by (metis is_pbqs subset_iff)"], ["", "lemma l14:\n  assumes \"quorum_of p Q\" and \"p \\<in> W\"\n  shows \"quorum (truncation p Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quorum (truncation p Q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. quorum (truncation p Q)", "have \"\\<exists> S \\<in> slices p' . \\<forall> q \\<in> S . reachable_through p Q q\" if \"reachable_through p Q p'\" and \"p' \\<in> W\" for p'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>S\\<in>slices p'. \\<forall>q\\<in>S. reachable_through p Q q", "by (meson assms l13 quorum_is_quorum_of_some_slice stellar.reachable_through.intros(2) stellar_axioms that)"], ["proof (state)\nthis:\n  \\<lbrakk>reachable_through p Q ?p'; ?p' \\<in> W\\<rbrakk>\n  \\<Longrightarrow> \\<exists>S\\<in>slices ?p'.\n                       \\<forall>q\\<in>S. reachable_through p Q q\n\ngoal (1 subgoal):\n 1. quorum (truncation p Q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>reachable_through p Q ?p'; ?p' \\<in> W\\<rbrakk>\n  \\<Longrightarrow> \\<exists>S\\<in>slices ?p'.\n                       \\<forall>q\\<in>S. reachable_through p Q q\n\ngoal (1 subgoal):\n 1. quorum (truncation p Q)", "by (metis IntE mem_Collect_eq stellar.quorum_def stellar_axioms subsetI truncation_def)"], ["proof (state)\nthis:\n  quorum (truncation p Q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma l15:\n  assumes \"is_cons_cluster I\" and \"quorum_of p Q\" and \"quorum_of p' Q'\" and \"p \\<in> I\" and \"p' \\<in> I\" and \"Q \\<inter> Q' \\<inter> W \\<noteq> {}\"\n  shows \"W \\<inter> (truncation p Q) \\<inter> (truncation p' Q') \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W \\<inter> truncation p Q \\<inter> truncation p' Q' \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. W \\<inter> truncation p Q \\<inter> truncation p' Q' \\<noteq> {}", "have \"quorum (truncation p Q)\" and \"quorum (truncation p' Q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quorum (truncation p Q) &&& quorum (truncation p' Q')", "using l14 assms is_cons_cluster_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>quorum_of ?p ?Q; ?p \\<in> W\\<rbrakk>\n  \\<Longrightarrow> quorum (truncation ?p ?Q)\n  is_cons_cluster I\n  quorum_of p Q\n  quorum_of p' Q'\n  p \\<in> I\n  p' \\<in> I\n  Q \\<inter> Q' \\<inter> W \\<noteq> {}\n  is_cons_cluster ?C \\<equiv>\n  ?C \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>?C. \\<exists>Q\\<subseteq>?C. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      quorum_of_set ?C Q \\<and> quorum_of_set ?C Q' \\<longrightarrow>\n      W \\<inter> Q \\<inter> Q' \\<noteq> {})\n\ngoal (1 subgoal):\n 1. quorum (truncation p Q) &&& quorum (truncation p' Q')", "by auto"], ["proof (state)\nthis:\n  quorum (truncation p Q)\n  quorum (truncation p' Q')\n\ngoal (1 subgoal):\n 1. W \\<inter> truncation p Q \\<inter> truncation p' Q' \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  quorum (truncation p Q)\n  quorum (truncation p' Q')\n\ngoal (1 subgoal):\n 1. W \\<inter> truncation p Q \\<inter> truncation p' Q' \\<noteq> {}", "have \"quorum_of_set I (truncation p Q)\" and \"quorum_of_set I (truncation p' Q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quorum_of_set I (truncation p Q) &&& quorum_of_set I (truncation p' Q')", "by (metis IntI assms(4,5) calculation mem_Collect_eq quorum_def quorum_of_def quorum_of_set_def reachable_through.intros(1) truncation_def)+"], ["proof (state)\nthis:\n  quorum_of_set I (truncation p Q)\n  quorum_of_set I (truncation p' Q')\n\ngoal (1 subgoal):\n 1. W \\<inter> truncation p Q \\<inter> truncation p' Q' \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  quorum_of_set I (truncation p Q)\n  quorum_of_set I (truncation p' Q')\n\ngoal (1 subgoal):\n 1. W \\<inter> truncation p Q \\<inter> truncation p' Q' \\<noteq> {}", "note \\<open>is_cons_cluster I\\<close>"], ["proof (state)\nthis:\n  is_cons_cluster I\n\ngoal (1 subgoal):\n 1. W \\<inter> truncation p Q \\<inter> truncation p' Q' \\<noteq> {}", "ultimately"], ["proof (chain)\npicking this:\n  quorum (truncation p Q)\n  quorum (truncation p' Q')\n  quorum_of_set I (truncation p Q)\n  quorum_of_set I (truncation p' Q')\n  is_cons_cluster I", "show ?thesis"], ["proof (prove)\nusing this:\n  quorum (truncation p Q)\n  quorum (truncation p' Q')\n  quorum_of_set I (truncation p Q)\n  quorum_of_set I (truncation p' Q')\n  is_cons_cluster I\n\ngoal (1 subgoal):\n 1. W \\<inter> truncation p Q \\<inter> truncation p' Q' \\<noteq> {}", "unfolding is_cons_cluster_def"], ["proof (prove)\nusing this:\n  quorum (truncation p Q)\n  quorum (truncation p' Q')\n  quorum_of_set I (truncation p Q)\n  quorum_of_set I (truncation p' Q')\n  I \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>I. \\<exists>Q\\<subseteq>I. quorum_of p Q) \\<and>\n  (\\<forall>Q Q'.\n      quorum_of_set I Q \\<and> quorum_of_set I Q' \\<longrightarrow>\n      W \\<inter> Q \\<inter> Q' \\<noteq> {})\n\ngoal (1 subgoal):\n 1. W \\<inter> truncation p Q \\<inter> truncation p' Q' \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  W \\<inter> truncation p Q \\<inter> truncation p' Q' \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \"Elementary quorums\""], ["", "text \\<open>In this section we define the notion of elementary quorum, which is a quorum that has no strict subset that is a quorum.\n  It follows directly from the definition that every finite quorum contains an elementary quorum. Moreover, we show \nthat if @{term Q} is an elementary quorum and @{term n\\<^sub>1} and @{term n\\<^sub>2} are members of @{term Q}, then @{term n\\<^sub>2} is reachable from @{term n\\<^sub>1} \nin the directed graph over participants defined as the set of edges @{term \"(n,m)\"} such that @{term m} is a member of a slice of @{term n}.\nThis lemma is used in the companion paper to show that probabilistic leader-election is feasible.\\<close>"], ["", "locale elementary = stellar\nbegin"], ["", "definition elementary where\n  \"elementary s \\<equiv> quorum s \\<and> (\\<forall> s' . s' \\<subset> s \\<longrightarrow> \\<not>quorum s')\""], ["", "lemma finite_subset_wf:\n  shows \"wf {(X, Y). X \\<subset> Y \\<and> finite Y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(X, Y). X \\<subset> Y \\<and> finite Y}", "by (metis finite_psubset_def wf_finite_psubset)"], ["", "lemma quorum_contains_elementary:\n  assumes \"finite s\" and  \"\\<not> elementary s\" and \"quorum s\" \n  shows \"\\<exists> s' . s' \\<subset> s \\<and> elementary s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'\\<subset>s. local.elementary s'", "using assms"], ["proof (prove)\nusing this:\n  finite s\n  \\<not> local.elementary s\n  quorum s\n\ngoal (1 subgoal):\n 1. \\<exists>s'\\<subset>s. local.elementary s'", "proof (induct s rule:wf_induct[where ?r=\"{(X, Y). X \\<subset> Y \\<and> finite Y}\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. wf {(X, Y). X \\<subset> Y \\<and> finite Y}\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x)\n                   \\<in> {(X, Y).\n                          X \\<subset> Y \\<and> finite Y} \\<longrightarrow>\n                   finite y \\<longrightarrow>\n                   \\<not> local.elementary y \\<longrightarrow>\n                   quorum y \\<longrightarrow>\n                   (\\<exists>s'\\<subset>y. local.elementary s');\n        finite x; \\<not> local.elementary x; quorum x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'\\<subset>x. local.elementary s'", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. wf {(X, Y). X \\<subset> Y \\<and> finite Y}\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x)\n                   \\<in> {(X, Y).\n                          X \\<subset> Y \\<and> finite Y} \\<longrightarrow>\n                   finite y \\<longrightarrow>\n                   \\<not> local.elementary y \\<longrightarrow>\n                   quorum y \\<longrightarrow>\n                   (\\<exists>s'\\<subset>y. local.elementary s');\n        finite x; \\<not> local.elementary x; quorum x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'\\<subset>x. local.elementary s'", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(X, Y). X \\<subset> Y \\<and> finite Y}", "using finite_subset_wf"], ["proof (prove)\nusing this:\n  wf {(X, Y). X \\<subset> Y \\<and> finite Y}\n\ngoal (1 subgoal):\n 1. wf {(X, Y). X \\<subset> Y \\<and> finite Y}", "by simp"], ["proof (state)\nthis:\n  wf {(X, Y). X \\<subset> Y \\<and> finite Y}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x)\n                   \\<in> {(X, Y).\n                          X \\<subset> Y \\<and> finite Y} \\<longrightarrow>\n                   finite y \\<longrightarrow>\n                   \\<not> local.elementary y \\<longrightarrow>\n                   quorum y \\<longrightarrow>\n                   (\\<exists>s'\\<subset>y. local.elementary s');\n        finite x; \\<not> local.elementary x; quorum x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'\\<subset>x. local.elementary s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x)\n                   \\<in> {(X, Y).\n                          X \\<subset> Y \\<and> finite Y} \\<longrightarrow>\n                   finite y \\<longrightarrow>\n                   \\<not> local.elementary y \\<longrightarrow>\n                   quorum y \\<longrightarrow>\n                   (\\<exists>s'\\<subset>y. local.elementary s');\n        finite x; \\<not> local.elementary x; quorum x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'\\<subset>x. local.elementary s'", "case (2 x)"], ["proof (state)\nthis:\n  \\<forall>y.\n     (y, x) \\<in> {(X, Y). X \\<subset> Y \\<and> finite Y} \\<longrightarrow>\n     finite y \\<longrightarrow>\n     \\<not> local.elementary y \\<longrightarrow>\n     quorum y \\<longrightarrow> (\\<exists>s'\\<subset>y. local.elementary s')\n  finite x\n  \\<not> local.elementary x\n  quorum x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x)\n                   \\<in> {(X, Y).\n                          X \\<subset> Y \\<and> finite Y} \\<longrightarrow>\n                   finite y \\<longrightarrow>\n                   \\<not> local.elementary y \\<longrightarrow>\n                   quorum y \\<longrightarrow>\n                   (\\<exists>s'\\<subset>y. local.elementary s');\n        finite x; \\<not> local.elementary x; quorum x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'\\<subset>x. local.elementary s'", "then"], ["proof (chain)\npicking this:\n  \\<forall>y.\n     (y, x) \\<in> {(X, Y). X \\<subset> Y \\<and> finite Y} \\<longrightarrow>\n     finite y \\<longrightarrow>\n     \\<not> local.elementary y \\<longrightarrow>\n     quorum y \\<longrightarrow> (\\<exists>s'\\<subset>y. local.elementary s')\n  finite x\n  \\<not> local.elementary x\n  quorum x", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, x) \\<in> {(X, Y). X \\<subset> Y \\<and> finite Y} \\<longrightarrow>\n     finite y \\<longrightarrow>\n     \\<not> local.elementary y \\<longrightarrow>\n     quorum y \\<longrightarrow> (\\<exists>s'\\<subset>y. local.elementary s')\n  finite x\n  \\<not> local.elementary x\n  quorum x\n\ngoal (1 subgoal):\n 1. \\<exists>s'\\<subset>x. local.elementary s'", "by (metis (full_types) elementary_def finite_psubset_def finite_subset in_finite_psubset less_le psubset_trans)"], ["proof (state)\nthis:\n  \\<exists>s'\\<subset>x. local.elementary s'\n\ngoal:\nNo subgoals!", "qed"], ["", "inductive path where\n  \"path []\"\n| \"\\<And> x . path [x]\"\n| \"\\<And> l n . \\<lbrakk>path l; S \\<in> Q (hd l); n \\<in> S\\<rbrakk> \\<Longrightarrow> path (n#l)\""], ["", "theorem elementary_connected:\n  assumes \"elementary s\" and \"n\\<^sub>1 \\<in> s\" and \"n\\<^sub>2 \\<in> s\" and \"n\\<^sub>1 \\<in> W\" and \"n\\<^sub>2 \\<in> W\"\n  shows \"\\<exists> l . hd (rev l) = n\\<^sub>1 \\<and> hd l = n\\<^sub>2 \\<and> path l\" (is ?P)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l. hd (rev l) = n\\<^sub>1 \\<and> hd l = n\\<^sub>2 \\<and> path l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>l. hd (rev l) = n\\<^sub>1 \\<and> hd l = n\\<^sub>2 \\<and> path l", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>l. hd (rev l) = n\\<^sub>1 \\<and> hd l = n\\<^sub>2 \\<and> path l", "assume \"\\<not>?P\""], ["proof (state)\nthis:\n  \\<nexists>l. hd (rev l) = n\\<^sub>1 \\<and> hd l = n\\<^sub>2 \\<and> path l\n\ngoal (1 subgoal):\n 1. \\<exists>l. hd (rev l) = n\\<^sub>1 \\<and> hd l = n\\<^sub>2 \\<and> path l", "define x where \"x \\<equiv> {n \\<in> s . \\<exists> l . l \\<noteq> [] \\<and> hd (rev l) = n\\<^sub>1 \\<and> hd l = n \\<and> path l}\""], ["proof (state)\nthis:\n  x \\<equiv>\n  {n \\<in> s.\n   \\<exists>l.\n      l \\<noteq> [] \\<and>\n      hd (rev l) = n\\<^sub>1 \\<and> hd l = n \\<and> path l}\n\ngoal (1 subgoal):\n 1. \\<exists>l. hd (rev l) = n\\<^sub>1 \\<and> hd l = n\\<^sub>2 \\<and> path l", "have \"n\\<^sub>2 \\<notin> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n\\<^sub>2 \\<notin> x", "using \\<open>\\<not>?P\\<close> x_def"], ["proof (prove)\nusing this:\n  \\<nexists>l. hd (rev l) = n\\<^sub>1 \\<and> hd l = n\\<^sub>2 \\<and> path l\n  x \\<equiv>\n  {n \\<in> s.\n   \\<exists>l.\n      l \\<noteq> [] \\<and>\n      hd (rev l) = n\\<^sub>1 \\<and> hd l = n \\<and> path l}\n\ngoal (1 subgoal):\n 1. n\\<^sub>2 \\<notin> x", "by auto"], ["proof (state)\nthis:\n  n\\<^sub>2 \\<notin> x\n\ngoal (1 subgoal):\n 1. \\<exists>l. hd (rev l) = n\\<^sub>1 \\<and> hd l = n\\<^sub>2 \\<and> path l", "have \"n\\<^sub>1 \\<in> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n\\<^sub>1 \\<in> x", "unfolding x_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n\\<^sub>1\n    \\<in> {n \\<in> s.\n           \\<exists>l.\n              l \\<noteq> [] \\<and>\n              hd (rev l) = n\\<^sub>1 \\<and> hd l = n \\<and> path l}", "using assms(2) path.intros(2)"], ["proof (prove)\nusing this:\n  n\\<^sub>1 \\<in> s\n  path [?x]\n\ngoal (1 subgoal):\n 1. n\\<^sub>1\n    \\<in> {n \\<in> s.\n           \\<exists>l.\n              l \\<noteq> [] \\<and>\n              hd (rev l) = n\\<^sub>1 \\<and> hd l = n \\<and> path l}", "by force"], ["proof (state)\nthis:\n  n\\<^sub>1 \\<in> x\n\ngoal (1 subgoal):\n 1. \\<exists>l. hd (rev l) = n\\<^sub>1 \\<and> hd l = n\\<^sub>2 \\<and> path l", "have \"quorum x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quorum x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. quorum x", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. quorum x", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. quorum x", "assume \"n \\<in> x\""], ["proof (state)\nthis:\n  n \\<in> x\n\ngoal (1 subgoal):\n 1. quorum x", "have \"\\<exists> S . S \\<in> slices n \\<and> S \\<subseteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>S. S \\<in> slices n \\<and> S \\<subseteq> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>S. S \\<in> slices n \\<and> S \\<subseteq> x", "obtain S where \"S \\<in> slices n\" and \"S \\<subseteq> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>S \\<in> slices n; S \\<subseteq> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>elementary s\\<close> \\<open>n \\<in> x\\<close>"], ["proof (prove)\nusing this:\n  local.elementary s\n  n \\<in> x\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>S \\<in> slices n; S \\<subseteq> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding x_def"], ["proof (prove)\nusing this:\n  local.elementary s\n  n \\<in> {n \\<in> s.\n           \\<exists>l.\n              l \\<noteq> [] \\<and>\n              hd (rev l) = n\\<^sub>1 \\<and> hd l = n \\<and> path l}\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>S \\<in> slices n; S \\<subseteq> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (force simp add:elementary_def quorum_def)"], ["proof (state)\nthis:\n  S \\<in> slices n\n  S \\<subseteq> s\n\ngoal (1 subgoal):\n 1. \\<exists>S. S \\<in> slices n \\<and> S \\<subseteq> x", "have \"S \\<subseteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. S \\<subseteq> x", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. S \\<subseteq> x", "assume \"\\<not> S \\<subseteq> x\""], ["proof (state)\nthis:\n  \\<not> S \\<subseteq> x\n\ngoal (1 subgoal):\n 1. S \\<subseteq> x", "obtain m where \"m \\<in> S\" and \"m \\<notin> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>m \\<in> S; m \\<notin> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>\\<not> S \\<subseteq> x\\<close>"], ["proof (prove)\nusing this:\n  \\<not> S \\<subseteq> x\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>m \\<in> S; m \\<notin> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  m \\<in> S\n  m \\<notin> x\n\ngoal (1 subgoal):\n 1. S \\<subseteq> x", "obtain l' where \"hd (rev l') = n\\<^sub>1\" and \"hd l' = n\" and \"path l'\" and \"l' \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>hd (rev l') = n\\<^sub>1; hd l' = n; path l';\n         l' \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>n \\<in> x\\<close> x_def"], ["proof (prove)\nusing this:\n  n \\<in> x\n  x \\<equiv>\n  {n \\<in> s.\n   \\<exists>l.\n      l \\<noteq> [] \\<and>\n      hd (rev l) = n\\<^sub>1 \\<and> hd l = n \\<and> path l}\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>hd (rev l') = n\\<^sub>1; hd l' = n; path l';\n         l' \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  hd (rev l') = n\\<^sub>1\n  hd l' = n\n  path l'\n  l' \\<noteq> []\n\ngoal (1 subgoal):\n 1. S \\<subseteq> x", "have \"path (m # l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (m # l')", "using \\<open>path l'\\<close> \\<open>m\\<in> S\\<close> \\<open>S \\<in> slices n\\<close> \\<open>hd l' = n\\<close>"], ["proof (prove)\nusing this:\n  path l'\n  m \\<in> S\n  S \\<in> slices n\n  hd l' = n\n\ngoal (1 subgoal):\n 1. path (m # l')", "using path.intros(3)"], ["proof (prove)\nusing this:\n  path l'\n  m \\<in> S\n  S \\<in> slices n\n  hd l' = n\n  \\<lbrakk>path ?l; ?S \\<in> ?Q (hd ?l); ?n \\<in> ?S\\<rbrakk>\n  \\<Longrightarrow> path (?n # ?l)\n\ngoal (1 subgoal):\n 1. path (m # l')", "by fastforce"], ["proof (state)\nthis:\n  path (m # l')\n\ngoal (1 subgoal):\n 1. S \\<subseteq> x", "moreover"], ["proof (state)\nthis:\n  path (m # l')\n\ngoal (1 subgoal):\n 1. S \\<subseteq> x", "have \"hd (rev (m # l')) = n\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (rev (m # l')) = n\\<^sub>1", "using \\<open>hd (rev l') = n\\<^sub>1\\<close> \\<open>l' \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  hd (rev l') = n\\<^sub>1\n  l' \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (rev (m # l')) = n\\<^sub>1", "by auto"], ["proof (state)\nthis:\n  hd (rev (m # l')) = n\\<^sub>1\n\ngoal (1 subgoal):\n 1. S \\<subseteq> x", "ultimately"], ["proof (chain)\npicking this:\n  path (m # l')\n  hd (rev (m # l')) = n\\<^sub>1", "have \"m \\<in> x\""], ["proof (prove)\nusing this:\n  path (m # l')\n  hd (rev (m # l')) = n\\<^sub>1\n\ngoal (1 subgoal):\n 1. m \\<in> x", "using \\<open>m \\<in> S\\<close> \\<open>S \\<subseteq> s\\<close> x_def"], ["proof (prove)\nusing this:\n  path (m # l')\n  hd (rev (m # l')) = n\\<^sub>1\n  m \\<in> S\n  S \\<subseteq> s\n  x \\<equiv>\n  {n \\<in> s.\n   \\<exists>l.\n      l \\<noteq> [] \\<and>\n      hd (rev l) = n\\<^sub>1 \\<and> hd l = n \\<and> path l}\n\ngoal (1 subgoal):\n 1. m \\<in> x", "by auto"], ["proof (state)\nthis:\n  m \\<in> x\n\ngoal (1 subgoal):\n 1. S \\<subseteq> x", "hence False"], ["proof (prove)\nusing this:\n  m \\<in> x\n\ngoal (1 subgoal):\n 1. False", "using \\<open>m \\<notin> x\\<close>"], ["proof (prove)\nusing this:\n  m \\<in> x\n  m \\<notin> x\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. S \\<subseteq> x", "}"], ["proof (state)\nthis:\n  \\<not> S \\<subseteq> x \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. S \\<subseteq> x", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> S \\<subseteq> x \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. S \\<subseteq> x", "by blast"], ["proof (state)\nthis:\n  S \\<subseteq> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S \\<subseteq> x\n\ngoal (1 subgoal):\n 1. \\<exists>S. S \\<in> slices n \\<and> S \\<subseteq> x", "thus ?thesis"], ["proof (prove)\nusing this:\n  S \\<subseteq> x\n\ngoal (1 subgoal):\n 1. \\<exists>S. S \\<in> slices n \\<and> S \\<subseteq> x", "using \\<open>S \\<in> slices n\\<close>"], ["proof (prove)\nusing this:\n  S \\<subseteq> x\n  S \\<in> slices n\n\ngoal (1 subgoal):\n 1. \\<exists>S. S \\<in> slices n \\<and> S \\<subseteq> x", "by blast"], ["proof (state)\nthis:\n  \\<exists>S. S \\<in> slices n \\<and> S \\<subseteq> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>S. S \\<in> slices n \\<and> S \\<subseteq> x\n\ngoal (1 subgoal):\n 1. quorum x", "}"], ["proof (state)\nthis:\n  ?n2 \\<in> x \\<Longrightarrow>\n  \\<exists>S. S \\<in> slices ?n2 \\<and> S \\<subseteq> x\n\ngoal (1 subgoal):\n 1. quorum x", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?n2 \\<in> x \\<Longrightarrow>\n  \\<exists>S. S \\<in> slices ?n2 \\<and> S \\<subseteq> x\n\ngoal (1 subgoal):\n 1. quorum x", "by (meson Int_iff quorum_def)"], ["proof (state)\nthis:\n  quorum x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  quorum x\n\ngoal (1 subgoal):\n 1. \\<exists>l. hd (rev l) = n\\<^sub>1 \\<and> hd l = n\\<^sub>2 \\<and> path l", "moreover"], ["proof (state)\nthis:\n  quorum x\n\ngoal (1 subgoal):\n 1. \\<exists>l. hd (rev l) = n\\<^sub>1 \\<and> hd l = n\\<^sub>2 \\<and> path l", "have \"x \\<subset> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<subset> s", "using \\<open>n\\<^sub>2 \\<notin> x\\<close> assms(3) x_def"], ["proof (prove)\nusing this:\n  n\\<^sub>2 \\<notin> x\n  n\\<^sub>2 \\<in> s\n  x \\<equiv>\n  {n \\<in> s.\n   \\<exists>l.\n      l \\<noteq> [] \\<and>\n      hd (rev l) = n\\<^sub>1 \\<and> hd l = n \\<and> path l}\n\ngoal (1 subgoal):\n 1. x \\<subset> s", "by blast"], ["proof (state)\nthis:\n  x \\<subset> s\n\ngoal (1 subgoal):\n 1. \\<exists>l. hd (rev l) = n\\<^sub>1 \\<and> hd l = n\\<^sub>2 \\<and> path l", "ultimately"], ["proof (chain)\npicking this:\n  quorum x\n  x \\<subset> s", "have False"], ["proof (prove)\nusing this:\n  quorum x\n  x \\<subset> s\n\ngoal (1 subgoal):\n 1. False", "using \\<open>elementary s\\<close>"], ["proof (prove)\nusing this:\n  quorum x\n  x \\<subset> s\n  local.elementary s\n\ngoal (1 subgoal):\n 1. False", "using elementary_def"], ["proof (prove)\nusing this:\n  quorum x\n  x \\<subset> s\n  local.elementary s\n  local.elementary ?s \\<equiv>\n  quorum ?s \\<and> (\\<forall>s'\\<subset>?s. \\<not> quorum s')\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>l. hd (rev l) = n\\<^sub>1 \\<and> hd l = n\\<^sub>2 \\<and> path l", "}"], ["proof (state)\nthis:\n  \\<nexists>l.\n     hd (rev l) = n\\<^sub>1 \\<and>\n     hd l = n\\<^sub>2 \\<and> path l \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>l. hd (rev l) = n\\<^sub>1 \\<and> hd l = n\\<^sub>2 \\<and> path l", "thus ?P"], ["proof (prove)\nusing this:\n  \\<nexists>l.\n     hd (rev l) = n\\<^sub>1 \\<and>\n     hd l = n\\<^sub>2 \\<and> path l \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>l. hd (rev l) = n\\<^sub>1 \\<and> hd l = n\\<^sub>2 \\<and> path l", "by blast"], ["proof (state)\nthis:\n  \\<exists>l. hd (rev l) = n\\<^sub>1 \\<and> hd l = n\\<^sub>2 \\<and> path l\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>The intact sets of the Stellar Whitepaper\\<close>"], ["", "definition project where \n  \"project slices S n \\<equiv> {Sl \\<inter> S | Sl . Sl \\<in> slices n}\" \n  \\<comment> \\<open>Projecting on @{term S} is the same as deleting the complement of @{term S}, where deleting is understood as in the Stellar Whitepaper.\\<close>"], ["", "subsubsection \\<open>Intact and the Cascade Theorem\\<close>"], ["", "locale intact = \\<comment> \\<open>Here we fix an intact set @{term I} and prove the cascade theorem.\\<close>\n  orig:stellar slices W \n  + proj:stellar \"project slices I\" W \\<comment> \\<open>We consider the projection of the system on @{term I}.\\<close>\n  for slices W I +  \\<comment> \\<open>An intact set is a set @{term I} satisfying the three assumptions below:\\<close>\n  assumes intact_wb:\"I \\<subseteq> W\"\n    and q_avail:\"orig.quorum I\" \\<comment> \\<open>@{term I} is a quorum in the original system.\\<close>\n    and q_inter:\"\\<And> Q Q' . \\<lbrakk>proj.quorum Q; proj.quorum Q'; Q \\<inter> I \\<noteq> {}; Q' \\<inter> I \\<noteq> {}\\<rbrakk>  \\<Longrightarrow> Q \\<inter> Q' \\<inter> I \\<noteq> {}\" \n    \\<comment> \\<open>Any two sets that intersect @{term I} and that are quorums in the projected system intersect in @{term I}.\nNote that requiring that @{text \\<open>Q \\<inter> Q' \\<noteq> {}\\<close>} instead of @{text \\<open>Q \\<inter> Q' \\<inter> I \\<noteq> {}\\<close>} would be equivalent.\\<close>\nbegin"], ["", "theorem blocking_safe: \\<comment> \\<open>A set that blocks an intact node contains an intact node. \nIf this were not the case, quorum availability would trivially be violated.\\<close>\n  fixes S n\n  assumes \"n\\<in>I\" and \"\\<forall> Sl\\<in> slices n .Sl\\<inter>S \\<noteq> {}\"\n  shows \"S \\<inter> I \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<inter> I \\<noteq> {}", "using assms q_avail intact_wb"], ["proof (prove)\nusing this:\n  n \\<in> I\n  \\<forall>Sl\\<in>slices n. Sl \\<inter> S \\<noteq> {}\n  orig.quorum I\n  I \\<subseteq> W\n\ngoal (1 subgoal):\n 1. S \\<inter> I \\<noteq> {}", "unfolding orig.quorum_def"], ["proof (prove)\nusing this:\n  n \\<in> I\n  \\<forall>Sl\\<in>slices n. Sl \\<inter> S \\<noteq> {}\n  \\<forall>p\\<in>I \\<inter> W. \\<exists>Sl\\<in>slices p. Sl \\<subseteq> I\n  I \\<subseteq> W\n\ngoal (1 subgoal):\n 1. S \\<inter> I \\<noteq> {}", "by auto (metis inf.absorb_iff2 inf_assoc inf_bot_right inf_sup_aci(1))"], ["", "theorem cascade:\n\\<comment> \\<open>If @{term U} is a quorum of an intact node and @{term S} is a super-set of @{term U}, then either @{term S} includes \nall intact nodes or there is an intact node outside of @{term S} which is blocked by the intact members of @{term S}.\nThis shows that, in SCP, once the intact members of a quorum accept a statement, \na cascading effect occurs and all intact nodes eventually accept it regardless of what befouled and faulty nodes do.\\<close>\n  fixes U S\n  assumes \"orig.quorum U\" and \"U \\<inter> I \\<noteq> {}\" and \"U \\<subseteq> S\"\n  obtains \"I \\<subseteq> S\" | \"\\<exists> n \\<in> I - S . \\<forall> Sl \\<in> slices n . Sl \\<inter> S \\<inter> I \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<subseteq> S \\<Longrightarrow> thesis;\n     \\<exists>n\\<in>I - S.\n        \\<forall>Sl\\<in>slices n.\n           Sl \\<inter> S \\<inter> I \\<noteq> {} \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<subseteq> S \\<Longrightarrow> thesis;\n     \\<exists>n\\<in>I - S.\n        \\<forall>Sl\\<in>slices n.\n           Sl \\<inter> S \\<inter> I \\<noteq> {} \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "have False if 1:\"\\<forall> n \\<in> I - S . \\<exists> Sl \\<in> slices n . Sl \\<inter> S \\<inter> I = {}\" and 2:\"\\<not>(I \\<subseteq> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "text \\<open>First we show that @{term \\<open>I-S\\<close>} is a quorum in the projected system. This is immediate from the definition of quorum and assumption 1.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"proj.quorum (I-S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj.quorum (I - S)", "using 1"], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>I - S.\n     \\<exists>Sl\\<in>slices n. Sl \\<inter> S \\<inter> I = {}\n\ngoal (1 subgoal):\n 1. proj.quorum (I - S)", "unfolding proj.quorum_def project_def"], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>I - S.\n     \\<exists>Sl\\<in>slices n. Sl \\<inter> S \\<inter> I = {}\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>(I - S) \\<inter> W.\n       \\<exists>Sl\\<in>{Sl \\<inter> I |Sl. Sl \\<in> slices p}.\n          Sl \\<subseteq> I - S", "by (auto; smt DiffI Diff_Compl Diff_Int_distrib Diff_eq Diff_eq_empty_iff Int_commute)"], ["proof (state)\nthis:\n  proj.quorum (I - S)\n\ngoal (1 subgoal):\n 1. False", "text \\<open>Then we show that U is also a quorum in the projected system:\\<close>"], ["proof (state)\nthis:\n  proj.quorum (I - S)\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  proj.quorum (I - S)\n\ngoal (1 subgoal):\n 1. False", "have \"proj.quorum U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj.quorum U", "using \\<open>orig.quorum U\\<close>"], ["proof (prove)\nusing this:\n  orig.quorum U\n\ngoal (1 subgoal):\n 1. proj.quorum U", "unfolding proj.quorum_def orig.quorum_def project_def"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>U \\<inter> W. \\<exists>Sl\\<in>slices p. Sl \\<subseteq> U\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>U \\<inter> W.\n       \\<exists>Sl\\<in>{Sl \\<inter> I |Sl. Sl \\<in> slices p}.\n          Sl \\<subseteq> U", "by (simp; meson Int_commute inf.coboundedI2)"], ["proof (state)\nthis:\n  proj.quorum U\n\ngoal (1 subgoal):\n 1. False", "text \\<open>Since quorums of @{term I} must intersect, we get a contradiction:\\<close>"], ["proof (state)\nthis:\n  proj.quorum U\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  proj.quorum (I - S)\n  proj.quorum U", "show False"], ["proof (prove)\nusing this:\n  proj.quorum (I - S)\n  proj.quorum U\n\ngoal (1 subgoal):\n 1. False", "using \\<open>U \\<subseteq> S\\<close> \\<open>U \\<inter> I \\<noteq> {}\\<close> \\<open>\\<not>(I\\<subseteq>S)\\<close> q_inter"], ["proof (prove)\nusing this:\n  proj.quorum (I - S)\n  proj.quorum U\n  U \\<subseteq> S\n  U \\<inter> I \\<noteq> {}\n  \\<not> I \\<subseteq> S\n  \\<lbrakk>proj.quorum ?Q; proj.quorum ?Q'; ?Q \\<inter> I \\<noteq> {};\n   ?Q' \\<inter> I \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?Q \\<inter> ?Q' \\<inter> I \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>n\\<in>I - S.\n              \\<exists>Sl\\<in>slices n. Sl \\<inter> S \\<inter> I = {};\n   \\<not> I \\<subseteq> S\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<subseteq> S \\<Longrightarrow> thesis;\n     \\<exists>n\\<in>I - S.\n        \\<forall>Sl\\<in>slices n.\n           Sl \\<inter> S \\<inter> I \\<noteq> {} \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>n\\<in>I - S.\n              \\<exists>Sl\\<in>slices n. Sl \\<inter> S \\<inter> I = {};\n   \\<not> I \\<subseteq> S\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>n\\<in>I - S.\n              \\<exists>Sl\\<in>slices n. Sl \\<inter> S \\<inter> I = {};\n   \\<not> I \\<subseteq> S\\<rbrakk>\n  \\<Longrightarrow> False\n  I \\<subseteq> S \\<Longrightarrow> thesis\n  \\<exists>n\\<in>I - S.\n     \\<forall>Sl\\<in>slices n.\n        Sl \\<inter> S \\<inter> I \\<noteq> {} \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \"The Union Theorem\""], ["", "text \\<open>Here we prove that the union of two intact sets that intersect is intact.\nThis implies that maximal intact sets are disjoint.\\<close>"], ["", "locale intersecting_intact = \n  i1:intact slices W I\\<^sub>1 + i2:intact slices W I\\<^sub>2 \\<comment> \\<open>We fix two intersecting intact sets @{term I\\<^sub>1} and @{term I\\<^sub>2}.\\<close>\n  + proj:stellar \"project slices (I\\<^sub>1\\<union>I\\<^sub>2)\" W \\<comment> \\<open>We consider the projection of the system on @{term \\<open>I\\<^sub>1\\<union>I\\<^sub>2\\<close>}.\\<close>\n  for slices W I\\<^sub>1 I\\<^sub>2 +\nassumes inter:\"I\\<^sub>1 \\<inter> I\\<^sub>2 \\<noteq> {}\"\nbegin"], ["", "theorem union_quorum: \"i1.orig.quorum (I\\<^sub>1\\<union>I\\<^sub>2)\" \\<comment> \\<open>@{term \\<open>I\\<^sub>1\\<union>I\\<^sub>2\\<close>} is a quorum in the original system.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. i1.orig.quorum (I\\<^sub>1 \\<union> I\\<^sub>2)", "using i1.intact_axioms i2.intact_axioms"], ["proof (prove)\nusing this:\n  intact slices W I\\<^sub>1\n  intact slices W I\\<^sub>2\n\ngoal (1 subgoal):\n 1. i1.orig.quorum (I\\<^sub>1 \\<union> I\\<^sub>2)", "unfolding  intact_def stellar_def intact_axioms_def i1.orig.quorum_def"], ["proof (prove)\nusing this:\n  (\\<forall>p. p \\<in> W \\<longrightarrow> slices p \\<noteq> {}) \\<and>\n  (\\<forall>p.\n      p \\<in> W \\<longrightarrow>\n      project slices I\\<^sub>1 p \\<noteq> {}) \\<and>\n  I\\<^sub>1 \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>I\\<^sub>1 \\<inter> W.\n      \\<exists>Sl\\<in>slices p. Sl \\<subseteq> I\\<^sub>1) \\<and>\n  (\\<forall>Q Q'.\n      i1.proj.quorum Q \\<longrightarrow>\n      i1.proj.quorum Q' \\<longrightarrow>\n      Q \\<inter> I\\<^sub>1 \\<noteq> {} \\<longrightarrow>\n      Q' \\<inter> I\\<^sub>1 \\<noteq> {} \\<longrightarrow>\n      Q \\<inter> Q' \\<inter> I\\<^sub>1 \\<noteq> {})\n  (\\<forall>p. p \\<in> W \\<longrightarrow> slices p \\<noteq> {}) \\<and>\n  (\\<forall>p.\n      p \\<in> W \\<longrightarrow>\n      project slices I\\<^sub>2 p \\<noteq> {}) \\<and>\n  I\\<^sub>2 \\<subseteq> W \\<and>\n  (\\<forall>p\\<in>I\\<^sub>2 \\<inter> W.\n      \\<exists>Sl\\<in>slices p. Sl \\<subseteq> I\\<^sub>2) \\<and>\n  (\\<forall>Q Q'.\n      i2.proj.quorum Q \\<longrightarrow>\n      i2.proj.quorum Q' \\<longrightarrow>\n      Q \\<inter> I\\<^sub>2 \\<noteq> {} \\<longrightarrow>\n      Q' \\<inter> I\\<^sub>2 \\<noteq> {} \\<longrightarrow>\n      Q \\<inter> Q' \\<inter> I\\<^sub>2 \\<noteq> {})\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>(I\\<^sub>1 \\<union> I\\<^sub>2) \\<inter> W.\n       \\<exists>Sl\\<in>slices p. Sl \\<subseteq> I\\<^sub>1 \\<union> I\\<^sub>2", "by (metis Int_iff Un_iff le_supI1 le_supI2)"], ["", "theorem union_quorum_intersection: \n  assumes \"proj.quorum Q\\<^sub>1\" and \"proj.quorum Q\\<^sub>2\" and \"Q\\<^sub>1 \\<inter> (I\\<^sub>1\\<union>I\\<^sub>2) \\<noteq> {}\" and \"Q\\<^sub>2 \\<inter> (I\\<^sub>1\\<union>I\\<^sub>2) \\<noteq> {}\"\n  shows \"Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter> (I\\<^sub>1\\<union>I\\<^sub>2) \\<noteq> {}\"\n    \\<comment> \\<open>Any two sets that intersect @{term \\<open>I\\<^sub>1\\<union>I\\<^sub>2\\<close>} and that are quorums in the system projected on @{term \\<open>I\\<^sub>1\\<union>I\\<^sub>2\\<close>} intersect in @{term \\<open>I\\<^sub>1\\<union>I\\<^sub>2\\<close>}.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "text \\<open>First we show that @{term Q\\<^sub>1} and @{term Q\\<^sub>2} are quorums in the projections on @{term I\\<^sub>1} and @{term I\\<^sub>2}.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "have \"i1.proj.quorum Q\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i1.proj.quorum Q\\<^sub>1", "using \\<open>proj.quorum Q\\<^sub>1\\<close>"], ["proof (prove)\nusing this:\n  proj.quorum Q\\<^sub>1\n\ngoal (1 subgoal):\n 1. i1.proj.quorum Q\\<^sub>1", "unfolding i1.proj.quorum_def proj.quorum_def project_def"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>Q\\<^sub>1 \\<inter> W.\n     \\<exists>Sl\\<in>{Sl \\<inter> (I\\<^sub>1 \\<union> I\\<^sub>2) |Sl.\n                      Sl \\<in> slices p}.\n        Sl \\<subseteq> Q\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>Q\\<^sub>1 \\<inter> W.\n       \\<exists>Sl\\<in>{Sl \\<inter> I\\<^sub>1 |Sl. Sl \\<in> slices p}.\n          Sl \\<subseteq> Q\\<^sub>1", "by auto (metis Int_Un_distrib Int_iff Un_subset_iff)"], ["proof (state)\nthis:\n  i1.proj.quorum Q\\<^sub>1\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "moreover"], ["proof (state)\nthis:\n  i1.proj.quorum Q\\<^sub>1\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "have \"i2.proj.quorum Q\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i2.proj.quorum Q\\<^sub>2", "using \\<open>proj.quorum Q\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  proj.quorum Q\\<^sub>2\n\ngoal (1 subgoal):\n 1. i2.proj.quorum Q\\<^sub>2", "unfolding i2.proj.quorum_def proj.quorum_def project_def"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>Q\\<^sub>2 \\<inter> W.\n     \\<exists>Sl\\<in>{Sl \\<inter> (I\\<^sub>1 \\<union> I\\<^sub>2) |Sl.\n                      Sl \\<in> slices p}.\n        Sl \\<subseteq> Q\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>Q\\<^sub>2 \\<inter> W.\n       \\<exists>Sl\\<in>{Sl \\<inter> I\\<^sub>2 |Sl. Sl \\<in> slices p}.\n          Sl \\<subseteq> Q\\<^sub>2", "by auto (metis Int_Un_distrib Int_iff Un_subset_iff)"], ["proof (state)\nthis:\n  i2.proj.quorum Q\\<^sub>2\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "moreover"], ["proof (state)\nthis:\n  i2.proj.quorum Q\\<^sub>2\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "have \"i2.proj.quorum Q\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i2.proj.quorum Q\\<^sub>1", "using \\<open>proj.quorum Q\\<^sub>1\\<close>"], ["proof (prove)\nusing this:\n  proj.quorum Q\\<^sub>1\n\ngoal (1 subgoal):\n 1. i2.proj.quorum Q\\<^sub>1", "unfolding proj.quorum_def i2.proj.quorum_def project_def"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>Q\\<^sub>1 \\<inter> W.\n     \\<exists>Sl\\<in>{Sl \\<inter> (I\\<^sub>1 \\<union> I\\<^sub>2) |Sl.\n                      Sl \\<in> slices p}.\n        Sl \\<subseteq> Q\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>Q\\<^sub>1 \\<inter> W.\n       \\<exists>Sl\\<in>{Sl \\<inter> I\\<^sub>2 |Sl. Sl \\<in> slices p}.\n          Sl \\<subseteq> Q\\<^sub>1", "by auto (metis Int_Un_distrib Int_iff Un_subset_iff)"], ["proof (state)\nthis:\n  i2.proj.quorum Q\\<^sub>1\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "moreover"], ["proof (state)\nthis:\n  i2.proj.quorum Q\\<^sub>1\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "have \"i1.proj.quorum Q\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i1.proj.quorum Q\\<^sub>2", "using \\<open>proj.quorum Q\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  proj.quorum Q\\<^sub>2\n\ngoal (1 subgoal):\n 1. i1.proj.quorum Q\\<^sub>2", "unfolding proj.quorum_def i1.proj.quorum_def project_def"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>Q\\<^sub>2 \\<inter> W.\n     \\<exists>Sl\\<in>{Sl \\<inter> (I\\<^sub>1 \\<union> I\\<^sub>2) |Sl.\n                      Sl \\<in> slices p}.\n        Sl \\<subseteq> Q\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>Q\\<^sub>2 \\<inter> W.\n       \\<exists>Sl\\<in>{Sl \\<inter> I\\<^sub>1 |Sl. Sl \\<in> slices p}.\n          Sl \\<subseteq> Q\\<^sub>2", "by auto (metis Int_Un_distrib Int_iff Un_subset_iff)"], ["proof (state)\nthis:\n  i1.proj.quorum Q\\<^sub>2\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "text \\<open>Next we show that @{term Q\\<^sub>1} and @{term Q\\<^sub>2} intersect if they are quorums of, respectively, @{term I\\<^sub>1} and @{term I\\<^sub>2}. \nThis is the only interesting part of the proof.\\<close>"], ["proof (state)\nthis:\n  i1.proj.quorum Q\\<^sub>2\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "moreover"], ["proof (state)\nthis:\n  i1.proj.quorum Q\\<^sub>2\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "have \"Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter> (I\\<^sub>1\\<union>I\\<^sub>2) \\<noteq> {}\" \n    if \"i1.proj.quorum Q\\<^sub>1\" and \"i2.proj.quorum Q\\<^sub>2\" and \"i2.proj.quorum Q\\<^sub>1\"\n      and \"Q\\<^sub>1 \\<inter> I\\<^sub>1 \\<noteq> {}\" and \"Q\\<^sub>2 \\<inter> I\\<^sub>2 \\<noteq> {}\"\n    for Q\\<^sub>1 Q\\<^sub>2"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "have \"i1.proj.quorum I\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i1.proj.quorum I\\<^sub>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i1.proj.quorum I\\<^sub>2", "have \"i1.orig.quorum I\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i1.orig.quorum I\\<^sub>2", "by (simp add: i2.q_avail)"], ["proof (state)\nthis:\n  i1.orig.quorum I\\<^sub>2\n\ngoal (1 subgoal):\n 1. i1.proj.quorum I\\<^sub>2", "thus ?thesis"], ["proof (prove)\nusing this:\n  i1.orig.quorum I\\<^sub>2\n\ngoal (1 subgoal):\n 1. i1.proj.quorum I\\<^sub>2", "unfolding i1.orig.quorum_def i1.proj.quorum_def project_def"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>I\\<^sub>2 \\<inter> W.\n     \\<exists>Sl\\<in>slices p. Sl \\<subseteq> I\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>I\\<^sub>2 \\<inter> W.\n       \\<exists>Sl\\<in>{Sl \\<inter> I\\<^sub>1 |Sl. Sl \\<in> slices p}.\n          Sl \\<subseteq> I\\<^sub>2", "by auto (meson Int_commute Int_iff inf_le2 subset_trans)"], ["proof (state)\nthis:\n  i1.proj.quorum I\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i1.proj.quorum I\\<^sub>2\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "moreover"], ["proof (state)\nthis:\n  i1.proj.quorum I\\<^sub>2\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "note \\<open>i1.proj.quorum Q\\<^sub>1\\<close>"], ["proof (state)\nthis:\n  i1.proj.quorum Q\\<^sub>1\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "ultimately"], ["proof (chain)\npicking this:\n  i1.proj.quorum I\\<^sub>2\n  i1.proj.quorum Q\\<^sub>1", "have \"Q\\<^sub>1 \\<inter> I\\<^sub>2 \\<noteq> {}\""], ["proof (prove)\nusing this:\n  i1.proj.quorum I\\<^sub>2\n  i1.proj.quorum Q\\<^sub>1\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> I\\<^sub>2 \\<noteq> {}", "using i1.q_inter inter \\<open>Q\\<^sub>1 \\<inter> I\\<^sub>1 \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  i1.proj.quorum I\\<^sub>2\n  i1.proj.quorum Q\\<^sub>1\n  \\<lbrakk>i1.proj.quorum ?Q; i1.proj.quorum ?Q';\n   ?Q \\<inter> I\\<^sub>1 \\<noteq> {};\n   ?Q' \\<inter> I\\<^sub>1 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?Q \\<inter> ?Q' \\<inter> I\\<^sub>1 \\<noteq> {}\n  I\\<^sub>1 \\<inter> I\\<^sub>2 \\<noteq> {}\n  Q\\<^sub>1 \\<inter> I\\<^sub>1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> I\\<^sub>2 \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  Q\\<^sub>1 \\<inter> I\\<^sub>2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "moreover"], ["proof (state)\nthis:\n  Q\\<^sub>1 \\<inter> I\\<^sub>2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "note \\<open>i2.proj.quorum Q\\<^sub>2\\<close>"], ["proof (state)\nthis:\n  i2.proj.quorum Q\\<^sub>2\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "moreover"], ["proof (state)\nthis:\n  i2.proj.quorum Q\\<^sub>2\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "note \\<open>i2.proj.quorum Q\\<^sub>1\\<close>"], ["proof (state)\nthis:\n  i2.proj.quorum Q\\<^sub>1\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "ultimately"], ["proof (chain)\npicking this:\n  Q\\<^sub>1 \\<inter> I\\<^sub>2 \\<noteq> {}\n  i2.proj.quorum Q\\<^sub>2\n  i2.proj.quorum Q\\<^sub>1", "have \"Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter> I\\<^sub>2 \\<noteq> {}\""], ["proof (prove)\nusing this:\n  Q\\<^sub>1 \\<inter> I\\<^sub>2 \\<noteq> {}\n  i2.proj.quorum Q\\<^sub>2\n  i2.proj.quorum Q\\<^sub>1\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter> I\\<^sub>2 \\<noteq> {}", "using i2.q_inter \\<open>Q\\<^sub>2 \\<inter> I\\<^sub>2 \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  Q\\<^sub>1 \\<inter> I\\<^sub>2 \\<noteq> {}\n  i2.proj.quorum Q\\<^sub>2\n  i2.proj.quorum Q\\<^sub>1\n  \\<lbrakk>i2.proj.quorum ?Q; i2.proj.quorum ?Q';\n   ?Q \\<inter> I\\<^sub>2 \\<noteq> {};\n   ?Q' \\<inter> I\\<^sub>2 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?Q \\<inter> ?Q' \\<inter> I\\<^sub>2 \\<noteq> {}\n  Q\\<^sub>2 \\<inter> I\\<^sub>2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter> I\\<^sub>2 \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter> I\\<^sub>2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter> I\\<^sub>2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "by (simp add: inf_sup_distrib1)"], ["proof (state)\nthis:\n  Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n  (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>i1.proj.quorum ?Q\\<^sub>1; i2.proj.quorum ?Q\\<^sub>2;\n   i2.proj.quorum ?Q\\<^sub>1; ?Q\\<^sub>1 \\<inter> I\\<^sub>1 \\<noteq> {};\n   ?Q\\<^sub>2 \\<inter> I\\<^sub>2 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?Q\\<^sub>1 \\<inter> ?Q\\<^sub>2 \\<inter>\n                    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n                    {}\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "text \\<open>Next  we show that @{term Q\\<^sub>1} and @{term Q\\<^sub>2} intersect if they are quorums of the same intact set. This is obvious.\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>i1.proj.quorum ?Q\\<^sub>1; i2.proj.quorum ?Q\\<^sub>2;\n   i2.proj.quorum ?Q\\<^sub>1; ?Q\\<^sub>1 \\<inter> I\\<^sub>1 \\<noteq> {};\n   ?Q\\<^sub>2 \\<inter> I\\<^sub>2 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?Q\\<^sub>1 \\<inter> ?Q\\<^sub>2 \\<inter>\n                    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n                    {}\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>i1.proj.quorum ?Q\\<^sub>1; i2.proj.quorum ?Q\\<^sub>2;\n   i2.proj.quorum ?Q\\<^sub>1; ?Q\\<^sub>1 \\<inter> I\\<^sub>1 \\<noteq> {};\n   ?Q\\<^sub>2 \\<inter> I\\<^sub>2 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?Q\\<^sub>1 \\<inter> ?Q\\<^sub>2 \\<inter>\n                    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n                    {}\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "have \"Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter> (I\\<^sub>1\\<union>I\\<^sub>2) \\<noteq> {}\" \n    if \"i1.proj.quorum Q\\<^sub>1\" and \"i1.proj.quorum Q\\<^sub>2\" and \"Q\\<^sub>1 \\<inter> I\\<^sub>1 \\<noteq> {}\" and \"Q\\<^sub>2 \\<inter> I\\<^sub>1 \\<noteq> {}\"\n    for Q\\<^sub>1 Q\\<^sub>2"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "by (simp add: Int_Un_distrib i1.q_inter that)"], ["proof (state)\nthis:\n  \\<lbrakk>i1.proj.quorum ?Q\\<^sub>1; i1.proj.quorum ?Q\\<^sub>2;\n   ?Q\\<^sub>1 \\<inter> I\\<^sub>1 \\<noteq> {};\n   ?Q\\<^sub>2 \\<inter> I\\<^sub>1 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?Q\\<^sub>1 \\<inter> ?Q\\<^sub>2 \\<inter>\n                    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n                    {}\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>i1.proj.quorum ?Q\\<^sub>1; i1.proj.quorum ?Q\\<^sub>2;\n   ?Q\\<^sub>1 \\<inter> I\\<^sub>1 \\<noteq> {};\n   ?Q\\<^sub>2 \\<inter> I\\<^sub>1 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?Q\\<^sub>1 \\<inter> ?Q\\<^sub>2 \\<inter>\n                    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n                    {}\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "have \"Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter> (I\\<^sub>1\\<union>I\\<^sub>2) \\<noteq> {}\"\n    if \"i2.proj.quorum Q\\<^sub>1\" and \"i2.proj.quorum Q\\<^sub>2\" and \"Q\\<^sub>1 \\<inter> I\\<^sub>2 \\<noteq> {}\" and \"Q\\<^sub>2 \\<inter> I\\<^sub>2 \\<noteq> {}\"\n    for Q\\<^sub>1 Q\\<^sub>2"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "by (simp add: Int_Un_distrib i2.q_inter that)"], ["proof (state)\nthis:\n  \\<lbrakk>i2.proj.quorum ?Q\\<^sub>1; i2.proj.quorum ?Q\\<^sub>2;\n   ?Q\\<^sub>1 \\<inter> I\\<^sub>2 \\<noteq> {};\n   ?Q\\<^sub>2 \\<inter> I\\<^sub>2 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?Q\\<^sub>1 \\<inter> ?Q\\<^sub>2 \\<inter>\n                    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n                    {}\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "text \\<open>Finally we have covered all the cases and get the final result:\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>i2.proj.quorum ?Q\\<^sub>1; i2.proj.quorum ?Q\\<^sub>2;\n   ?Q\\<^sub>1 \\<inter> I\\<^sub>2 \\<noteq> {};\n   ?Q\\<^sub>2 \\<inter> I\\<^sub>2 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?Q\\<^sub>1 \\<inter> ?Q\\<^sub>2 \\<inter>\n                    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n                    {}\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "ultimately"], ["proof (chain)\npicking this:\n  i1.proj.quorum Q\\<^sub>1\n  i2.proj.quorum Q\\<^sub>2\n  i2.proj.quorum Q\\<^sub>1\n  i1.proj.quorum Q\\<^sub>2\n  \\<lbrakk>i1.proj.quorum ?Q\\<^sub>1; i2.proj.quorum ?Q\\<^sub>2;\n   i2.proj.quorum ?Q\\<^sub>1; ?Q\\<^sub>1 \\<inter> I\\<^sub>1 \\<noteq> {};\n   ?Q\\<^sub>2 \\<inter> I\\<^sub>2 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?Q\\<^sub>1 \\<inter> ?Q\\<^sub>2 \\<inter>\n                    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n                    {}\n  \\<lbrakk>i1.proj.quorum ?Q\\<^sub>1; i1.proj.quorum ?Q\\<^sub>2;\n   ?Q\\<^sub>1 \\<inter> I\\<^sub>1 \\<noteq> {};\n   ?Q\\<^sub>2 \\<inter> I\\<^sub>1 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?Q\\<^sub>1 \\<inter> ?Q\\<^sub>2 \\<inter>\n                    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n                    {}\n  \\<lbrakk>i2.proj.quorum ?Q\\<^sub>1; i2.proj.quorum ?Q\\<^sub>2;\n   ?Q\\<^sub>1 \\<inter> I\\<^sub>2 \\<noteq> {};\n   ?Q\\<^sub>2 \\<inter> I\\<^sub>2 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?Q\\<^sub>1 \\<inter> ?Q\\<^sub>2 \\<inter>\n                    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n                    {}", "show ?thesis"], ["proof (prove)\nusing this:\n  i1.proj.quorum Q\\<^sub>1\n  i2.proj.quorum Q\\<^sub>2\n  i2.proj.quorum Q\\<^sub>1\n  i1.proj.quorum Q\\<^sub>2\n  \\<lbrakk>i1.proj.quorum ?Q\\<^sub>1; i2.proj.quorum ?Q\\<^sub>2;\n   i2.proj.quorum ?Q\\<^sub>1; ?Q\\<^sub>1 \\<inter> I\\<^sub>1 \\<noteq> {};\n   ?Q\\<^sub>2 \\<inter> I\\<^sub>2 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?Q\\<^sub>1 \\<inter> ?Q\\<^sub>2 \\<inter>\n                    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n                    {}\n  \\<lbrakk>i1.proj.quorum ?Q\\<^sub>1; i1.proj.quorum ?Q\\<^sub>2;\n   ?Q\\<^sub>1 \\<inter> I\\<^sub>1 \\<noteq> {};\n   ?Q\\<^sub>2 \\<inter> I\\<^sub>1 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?Q\\<^sub>1 \\<inter> ?Q\\<^sub>2 \\<inter>\n                    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n                    {}\n  \\<lbrakk>i2.proj.quorum ?Q\\<^sub>1; i2.proj.quorum ?Q\\<^sub>2;\n   ?Q\\<^sub>1 \\<inter> I\\<^sub>2 \\<noteq> {};\n   ?Q\\<^sub>2 \\<inter> I\\<^sub>2 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?Q\\<^sub>1 \\<inter> ?Q\\<^sub>2 \\<inter>\n                    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n                    {}\n\ngoal (1 subgoal):\n 1. Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n    (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n    {}", "by (smt Int_Un_distrib Int_commute assms(3,4) sup_bot.right_neutral)"], ["proof (state)\nthis:\n  Q\\<^sub>1 \\<inter> Q\\<^sub>2 \\<inter>\n  (I\\<^sub>1 \\<union> I\\<^sub>2) \\<noteq>\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}