{"file_name": "/home/qj213/afp-2021-10-22/thys/CryptHOL/GPV_Expectation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CryptHOL", "problem_names": ["lemma le_enn2realI: \"\\<lbrakk> ennreal x \\<le> y; y = \\<top> \\<Longrightarrow> x \\<le> 0 \\<rbrakk> \\<Longrightarrow> x \\<le> enn2real y\"", "lemma enn2real_leD: \"\\<lbrakk> enn2real x < y; x \\<noteq> \\<top> \\<rbrakk> \\<Longrightarrow> x < ennreal y\"", "lemma ennreal_mult_le_self2I: \"\\<lbrakk> y > 0 \\<Longrightarrow> x \\<le> 1 \\<rbrakk> \\<Longrightarrow> x * y \\<le> y\" for x y :: ennreal", "lemma ennreal_leI: \"x \\<le> enn2real y \\<Longrightarrow> ennreal x \\<le> y\"", "lemma enn2real_INF: \"\\<lbrakk> A \\<noteq> {}; \\<forall>x\\<in>A. f x < \\<top> \\<rbrakk> \\<Longrightarrow> enn2real (INF x\\<in>A. f x) = (INF x\\<in>A. enn2real (f x))\"", "lemma monotone_times_ennreal1: \"monotone (\\<le>) (\\<le>) (\\<lambda>x. x * y :: ennreal)\"", "lemma monotone_times_ennreal2: \"monotone (\\<le>) (\\<le>) (\\<lambda>x. y * x :: ennreal)\"", "lemma mono2mono_times_ennreal[THEN lfp.mono2mono2, cont_intro, simp]:\n  shows monotone_times_ennreal: \"monotone (rel_prod (\\<le>) (\\<le>)) (\\<le>) (\\<lambda>(x, y). x * y :: ennreal)\"", "lemma mcont_times_ennreal1: \"mcont Sup (\\<le>) Sup (\\<le>) (\\<lambda>y. x * y :: ennreal)\"", "lemma mcont_times_ennreal2: \"mcont Sup (\\<le>) Sup (\\<le>) (\\<lambda>y. y * x :: ennreal)\"", "lemma mcont2mcont_times_ennreal [cont_intro, simp]:\n  \"\\<lbrakk> mcont lub ord Sup (\\<le>) (\\<lambda>x. f x);\n    mcont lub ord Sup (\\<le>) (\\<lambda>x. g x) \\<rbrakk>\n  \\<Longrightarrow> mcont lub ord Sup (\\<le>) (\\<lambda>x. f x * g x :: ennreal)\"", "lemma ereal_INF_cmult: \"0 < c \\<Longrightarrow> (INF i\\<in>I. c * f i) = ereal c * (INF i\\<in>I. f i)\"", "lemma ereal_INF_multc: \"0 < c \\<Longrightarrow> (INF i\\<in>I. f i * c) = (INF i\\<in>I. f i) * ereal c\"", "lemma INF_mult_left_ennreal: \n  assumes \"I = {} \\<Longrightarrow> c \\<noteq> 0\"\n  and \"\\<lbrakk> c = \\<top>; \\<exists>i\\<in>I. f i > 0 \\<rbrakk> \\<Longrightarrow> \\<exists>p>0. \\<forall>i\\<in>I. f i \\<ge> p\"\n  shows \"c * (INF i\\<in>I. f i) = (INF i\\<in>I. c * f i ::ennreal)\"", "lemma pmf_map_spmf_None: \"pmf (map_spmf f p) None = pmf p None\"", "lemma nn_integral_try_spmf:\n  \"nn_integral (measure_spmf (try_spmf p q)) f = nn_integral (measure_spmf p) f + nn_integral (measure_spmf q) f * pmf p None\"", "lemma INF_UNION: \"(INF z \\<in> \\<Union>x\\<in>A. B x. f z) = (INF x\\<in>A. INF z\\<in>B x. f z)\" for f :: \"_ \\<Rightarrow> 'b::complete_lattice\"", "lemma nn_integral_spmf_parametric [transfer_rule]:\n  includes lifting_syntax\n  shows \"(rel_spmf A ===> (A ===> (=)) ===> (=)) nn_integral_spmf nn_integral_spmf\"", "lemma weight_spmf_mcont2mcont [THEN lfp.mcont2mcont, cont_intro]:\n  shows weight_spmf_mcont: \"mcont (lub_spmf) (ord_spmf (=)) Sup (\\<le>) (\\<lambda>p. ennreal (weight_spmf p))\"", "lemma mono2mono_nn_integral_spmf [THEN lfp.mono2mono, cont_intro]:\n  shows monotone_nn_integral_spmf: \"monotone (ord_spmf (=)) (\\<le>) (\\<lambda>p. integral\\<^sup>N (measure_spmf p) f)\"", "lemma cont_nn_integral_spmf:\n  \"cont lub_spmf (ord_spmf (=)) Sup (\\<le>) (\\<lambda>p :: 'a spmf. nn_integral (measure_spmf p) f)\"", "lemma mcont2mcont_nn_integral_spmf [THEN lfp.mcont2mcont, cont_intro]:\n  shows mcont_nn_integral_spmf:\n  \"mcont lub_spmf (ord_spmf (=)) Sup (\\<le>) (\\<lambda>p :: 'a spmf. nn_integral (measure_spmf p) f)\"", "lemma nn_integral_mono2mono:\n  assumes \"\\<And>x. x \\<in> space M \\<Longrightarrow> monotone ord (\\<le>) (\\<lambda>f. F f x)\"\n  shows \"monotone ord (\\<le>) (\\<lambda>f. nn_integral M (F f))\"", "lemma nn_integral_mono_lfp [partial_function_mono]:\n  \\<comment> \\<open>@{ML Partial_Function.mono_tac} does not like conditional assumptions (more precisely the case splitter)\\<close>\n  \"(\\<And>x. lfp.mono_body (\\<lambda>f. F f x)) \\<Longrightarrow> lfp.mono_body (\\<lambda>f. nn_integral M (F f))\"", "lemma INF_mono_lfp [partial_function_mono]:\n  \"(\\<And>x. lfp.mono_body (\\<lambda>f. F f x)) \\<Longrightarrow> lfp.mono_body (\\<lambda>f. INF x\\<in>M. F f x)\"", "lemmas parallel_fixp_induct_1_2 = parallel_fixp_induct_uc[\n  of _ _ _ _ \"\\<lambda>x. x\" _ \"\\<lambda>x. x\" \"case_prod\" _ \"curry\",\n  where P=\"\\<lambda>f g. P f (curry g)\",\n  unfolded case_prod_curry curry_case_prod curry_K,\n  OF _ _ _ _ _ _ refl refl]\n  for P", "lemma monotone_ennreal_add1: \"monotone (\\<le>) (\\<le>) (\\<lambda>x. x + y :: ennreal)\"", "lemma monotone_ennreal_add2: \"monotone (\\<le>) (\\<le>) (\\<lambda>y. x + y :: ennreal)\"", "lemma mono2mono_ennreal_add[THEN lfp.mono2mono2, cont_intro, simp]:\n  shows monotone_eadd: \"monotone (rel_prod (\\<le>) (\\<le>)) (\\<le>) (\\<lambda>(x, y). x + y :: ennreal)\"", "lemma ennreal_add_partial_function_mono [partial_function_mono]:\n  \"\\<lbrakk> monotone (fun_ord (\\<le>)) (\\<le>) f; monotone (fun_ord (\\<le>)) (\\<le>) g \\<rbrakk>\n  \\<Longrightarrow> monotone (fun_ord (\\<le>)) (\\<le>) (\\<lambda>x. f x + g x :: ennreal)\"", "lemma expectation_gpv_fixp_induct [case_names adm bottom step]:\n  assumes \"lfp.admissible P\"\n    and \"P (\\<lambda>_. 0)\"\n    and \"\\<And>expectation_gpv'. \\<lbrakk> \\<And>gpv. expectation_gpv' gpv \\<le> expectation_gpv gpv; P expectation_gpv' \\<rbrakk> \\<Longrightarrow>\n         P (\\<lambda>gpv. (\\<integral>\\<^sup>+ generat. (case generat of Pure x \\<Rightarrow> f x | IO out c \\<Rightarrow> INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) \\<partial>measure_spmf (the_gpv gpv)) + fail * pmf (the_gpv gpv) None)\"\n  shows \"P expectation_gpv\"", "lemma expectation_gpv_Done [simp]: \"expectation_gpv (Done x) = f x\"", "lemma expectation_gpv_Fail [simp]: \"expectation_gpv Fail = fail\"", "lemma expectation_gpv_lift_spmf [simp]: \n  \"expectation_gpv (lift_spmf p) = (\\<integral>\\<^sup>+ x. f x \\<partial>measure_spmf p) + fail * pmf p None\"", "lemma expectation_gpv_Pause [simp]:\n  \"expectation_gpv (Pause out c) = (INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv (c r))\"", "lemmas weight_spmf'_parametric = weight_spmf_parametric[folded weight_spmf'_def]", "lemma expectation_gpv_parametric':\n  includes lifting_syntax notes weight_spmf'_parametric[transfer_rule]\n  shows \"((=) ===> rel_\\<I> C R ===> (A ===> (=)) ===> rel_gpv'' A C R ===> (=)) expectation_gpv expectation_gpv\"", "lemma expectation_gpv_parametric [transfer_rule]:\n  includes lifting_syntax\n  shows \"((=) ===> rel_\\<I> C (=) ===> (A ===> (=)) ===> rel_gpv A C ===> (=)) expectation_gpv expectation_gpv\"", "lemma expectation_gpv_cong:\n  fixes fail fail'\n  assumes fail: \"fail = fail'\"\n  and \\<I>: \"\\<I> = \\<I>'\"\n  and gpv: \"gpv = gpv'\"\n  and f: \"\\<And>x. x \\<in> results_gpv \\<I>' gpv' \\<Longrightarrow> f x = g x\"\n  shows \"expectation_gpv fail \\<I> f gpv = expectation_gpv fail' \\<I>' g gpv'\"", "lemma expectation_gpv_cong_fail:\n  \"colossless_gpv \\<I> gpv \\<Longrightarrow> expectation_gpv fail \\<I> f gpv = expectation_gpv fail' \\<I> f gpv\" for fail", "lemma expectation_gpv_mono:\n  fixes fail fail'\n  assumes fail: \"fail \\<le> fail'\"\n  and fg: \"f \\<le> g\"\n  shows \"expectation_gpv fail \\<I> f gpv \\<le> expectation_gpv fail' \\<I> g gpv\"", "lemma expectation_gpv_mono_strong:\n  fixes fail fail'\n  assumes fail: \"\\<not> colossless_gpv \\<I> gpv \\<Longrightarrow> fail \\<le> fail'\"\n  and fg: \"\\<And>x. x \\<in> results_gpv \\<I> gpv \\<Longrightarrow> f x \\<le> g x\"\n  shows \"expectation_gpv fail \\<I> f gpv \\<le> expectation_gpv fail' \\<I> g gpv\"", "lemma expectation_gpv_bind [simp]:\n  fixes \\<I> f g fail\n  defines \"expectation_gpv1 \\<equiv> expectation_gpv fail \\<I> f\"\n  and \"expectation_gpv2 \\<equiv> expectation_gpv fail \\<I> (expectation_gpv fail \\<I> f \\<circ> g)\"\n  shows \"expectation_gpv1 (bind_gpv gpv g) = expectation_gpv2 gpv\" (is \"?lhs = ?rhs\")", "lemma expectation_gpv_try_gpv [simp]:\n  fixes fail \\<I> f gpv'\n  defines \"expectation_gpv1 \\<equiv> expectation_gpv fail \\<I> f\"\n    and \"expectation_gpv2 \\<equiv> expectation_gpv (expectation_gpv fail \\<I> f gpv') \\<I> f\"\n  shows \"expectation_gpv1 (try_gpv gpv gpv') = expectation_gpv2 gpv\"", "lemma expectation_gpv_restrict_gpv:\n  \"\\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow> expectation_gpv fail \\<I> f (restrict_gpv \\<I> gpv) = expectation_gpv fail \\<I> f gpv\" for fail", "lemma expectation_gpv_const_le: \"\\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow> expectation_gpv fail \\<I> (\\<lambda>_. c) gpv \\<le> max c fail\" for fail", "lemma expectation_gpv_no_results:\n   \"\\<lbrakk> results_gpv \\<I> gpv = {}; \\<I> \\<turnstile>g gpv \\<surd> \\<rbrakk> \\<Longrightarrow> expectation_gpv 0 \\<I> f gpv = 0\"", "lemma expectation_gpv_cmult:\n  fixes fail\n  assumes \"0 < c\" and \"c \\<noteq> \\<top>\"\n  shows \"c * expectation_gpv fail \\<I> f gpv = expectation_gpv (c * fail) \\<I> (\\<lambda>x. c * f x) gpv\"", "lemma expectation_gpv_le_exec_gpv:\n  assumes callee: \"\\<And>s x. x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> lossless_spmf (callee s x)\"\n    and WT_gpv: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and WT_callee: \"\\<And>s. \\<I> \\<turnstile>c callee s \\<surd>\"\n  shows \"expectation_gpv 0 \\<I> f gpv \\<le> \\<integral>\\<^sup>+ (x, s). f x \\<partial>measure_spmf (exec_gpv callee gpv s)\"", "lemma weight_gpv_Done [simp]: \"weight_gpv \\<I> (Done x) = 1\"", "lemma weight_gpv_Fail [simp]: \"weight_gpv \\<I> Fail = 0\"", "lemma weight_gpv_lift_spmf [simp]: \"weight_gpv \\<I> (lift_spmf p) = weight_spmf p\"", "lemma weight_gpv_Pause [simp]:\n  \"(\\<And>r. r \\<in> responses_\\<I> \\<I> out \\<Longrightarrow> \\<I> \\<turnstile>g c r \\<surd>)\n   \\<Longrightarrow> weight_gpv \\<I> (Pause out c) = (if out \\<in> outs_\\<I> \\<I> then INF r\\<in>responses_\\<I> \\<I> out. weight_gpv \\<I> (c r) else 0)\"", "lemma weight_gpv_nonneg: \"0 \\<le> weight_gpv \\<I> gpv\"", "lemma weight_gpv_le_1: \"\\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow> weight_gpv \\<I> gpv \\<le> 1\"", "theorem weight_exec_gpv:\n  assumes callee: \"\\<And>s x. x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> lossless_spmf (callee s x)\"\n    and WT_gpv: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and WT_callee: \"\\<And>s. \\<I> \\<turnstile>c callee s \\<surd>\"\n  shows \"weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)\"", "lemma (in callee_invariant_on) weight_exec_gpv:\n  assumes callee: \"\\<And>s x. \\<lbrakk> x \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> lossless_spmf (callee s x)\"\n  and WT_gpv: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n  and I: \"I s\"\n  shows \"weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)\"", "lemma pgen_lossless_gpvI [intro?]: \"expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv = 1 \\<Longrightarrow> pgen_lossless_gpv fail \\<I> gpv\" for fail", "lemma pgen_lossless_gpvD: \"pgen_lossless_gpv fail \\<I> gpv \\<Longrightarrow> expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv = 1\" for fail", "lemma lossless_imp_plossless_gpv:\n  assumes \"lossless_gpv \\<I> gpv\" \"\\<I> \\<turnstile>g gpv \\<surd>\"\n  shows \"plossless_gpv \\<I> gpv\"", "lemma finite_imp_pfinite_gpv:\n  assumes \"finite_gpv \\<I> gpv\" \"\\<I> \\<turnstile>g gpv \\<surd>\"\n  shows \"pfinite_gpv \\<I> gpv\"", "lemma plossless_gpv_lossless_spmfD:\n  assumes lossless: \"plossless_gpv \\<I> gpv\"\n  and WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n  shows \"lossless_spmf (the_gpv gpv)\"", "lemma\n  shows plossless_gpv_ContD:\n  \"\\<lbrakk> plossless_gpv \\<I> gpv; IO out c \\<in> set_spmf (the_gpv gpv); input \\<in> responses_\\<I> \\<I> out; \\<I> \\<turnstile>g gpv \\<surd> \\<rbrakk>\n  \\<Longrightarrow> plossless_gpv \\<I> (c input)\"\n  and pfinite_gpv_ContD:\n  \"\\<lbrakk> pfinite_gpv \\<I> gpv; IO out c \\<in> set_spmf (the_gpv gpv); input \\<in> responses_\\<I> \\<I> out; \\<I> \\<turnstile>g gpv \\<surd> \\<rbrakk>\n  \\<Longrightarrow> pfinite_gpv \\<I> (c input)\"", "lemma plossless_iff_colossless_pfinite:\n  assumes WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n  shows \"plossless_gpv \\<I> gpv \\<longleftrightarrow> colossless_gpv \\<I> gpv \\<and> pfinite_gpv \\<I> gpv\"", "lemma pgen_lossless_gpv_Done [simp]: \"pgen_lossless_gpv fail \\<I> (Done x)\" for fail", "lemma pgen_lossless_gpv_Fail [simp]: \"pgen_lossless_gpv fail \\<I> Fail \\<longleftrightarrow> fail = 1\" for fail", "lemma pgen_lossless_gpv_PauseI [simp, intro!]: \n  \"\\<lbrakk> out \\<in> outs_\\<I> \\<I>; \\<And>r. r \\<in> responses_\\<I> \\<I> out \\<Longrightarrow> pgen_lossless_gpv fail \\<I> (c r) \\<rbrakk>\n   \\<Longrightarrow> pgen_lossless_gpv fail \\<I> (Pause out c)\" for fail", "lemma pgen_lossless_gpv_bindI [simp, intro!]:\n  \"\\<lbrakk> pgen_lossless_gpv fail \\<I> gpv; \\<And>x. x \\<in> results_gpv \\<I> gpv \\<Longrightarrow> pgen_lossless_gpv fail \\<I> (f x) \\<rbrakk>\n  \\<Longrightarrow> pgen_lossless_gpv fail \\<I> (bind_gpv gpv f)\" for fail", "lemma pgen_lossless_gpv_lift_spmf [simp]: \n  \"pgen_lossless_gpv fail \\<I> (lift_spmf p) \\<longleftrightarrow> lossless_spmf p \\<or> fail = 1\" for fail", "lemma expectation_gpv_top_pfinite:\n  assumes \"pfinite_gpv \\<I> gpv\"\n  shows \"expectation_gpv \\<top> \\<I> (\\<lambda>_. \\<top>) gpv = \\<top>\"", "lemma pfinite_INF_le_expectation_gpv:\n  fixes fail \\<I> gpv f\n  defines \"c \\<equiv> min (INF x\\<in>results_gpv \\<I> gpv. f x) fail\"\n  assumes fin: \"pfinite_gpv \\<I> gpv\"\n  shows \"c \\<le> expectation_gpv fail \\<I> f gpv\" (is \"?lhs \\<le> ?rhs\")", "lemma plossless_INF_le_expectation_gpv:\n  fixes fail\n  assumes \"plossless_gpv \\<I> gpv\" and \"\\<I> \\<turnstile>g gpv \\<surd>\"\n  shows \"(INF x\\<in>results_gpv \\<I> gpv. f x) \\<le> expectation_gpv fail \\<I> f gpv\" (is \"?lhs \\<le> ?rhs\")", "lemma expectation_gpv_le_inline:\n  fixes \\<I>'\n  defines \"expectation_gpv2 \\<equiv> expectation_gpv 0 \\<I>'\"\n  assumes callee: \"\\<And>s x. x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> plossless_gpv \\<I>' (callee s x)\"\n    and callee': \"\\<And>s x. x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> results_gpv \\<I>' (callee s x) \\<subseteq> responses_\\<I> \\<I> x \\<times> UNIV\"\n    and WT_gpv: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and WT_callee: \"\\<And>s x. x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> \\<I>' \\<turnstile>g callee s x \\<surd>\"\n  shows \"expectation_gpv 0 \\<I> f gpv \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee gpv s)\"", "lemma plossless_inline:\n  assumes lossless: \"plossless_gpv \\<I> gpv\"\n    and WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and callee: \"\\<And>s x. x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> plossless_gpv \\<I>' (callee s x)\"\n    and callee': \"\\<And>s x. x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> results_gpv \\<I>' (callee s x) \\<subseteq> responses_\\<I> \\<I> x \\<times> UNIV\"\n    and WT_callee: \"\\<And>s x. x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> \\<I>' \\<turnstile>g callee s x \\<surd>\"\n  shows \"plossless_gpv \\<I>' (inline callee gpv s)\"", "lemma plossless_exec_gpv:\n  assumes lossless: \"plossless_gpv \\<I> gpv\"\n    and WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and callee: \"\\<And>s x. x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> lossless_spmf (callee s x)\"\n    and callee': \"\\<And>s x. x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> set_spmf (callee s x) \\<subseteq> responses_\\<I> \\<I> x \\<times> UNIV\"\n  shows \"lossless_spmf (exec_gpv callee gpv s)\"", "lemma expectation_gpv_\\<I>_mono:\n  defines \"expectation_gpv' \\<equiv> expectation_gpv\"\n  assumes le: \"\\<I> \\<le> \\<I>'\"\n    and WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n  shows \"expectation_gpv fail \\<I> f gpv \\<le> expectation_gpv' fail \\<I>' f gpv\"", "lemma pgen_lossless_gpv_mono:\n  assumes *: \"pgen_lossless_gpv fail \\<I> gpv\"\n    and le: \"\\<I> \\<le> \\<I>'\"\n    and WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and fail: \"fail \\<le> 1\"\n  shows \"pgen_lossless_gpv fail \\<I>' gpv\"", "lemma plossless_gpv_mono:\n  \"\\<lbrakk> plossless_gpv \\<I> gpv; \\<I> \\<le> \\<I>'; \\<I> \\<turnstile>g gpv \\<surd> \\<rbrakk> \\<Longrightarrow> plossless_gpv \\<I>' gpv\"", "lemma pfinite_gpv_mono:\n  \"\\<lbrakk> pfinite_gpv \\<I> gpv; \\<I> \\<le> \\<I>'; \\<I> \\<turnstile>g gpv \\<surd> \\<rbrakk> \\<Longrightarrow> pfinite_gpv \\<I>' gpv\"", "lemma pgen_lossless_gpv_parametric': includes lifting_syntax shows\n  \"((=) ===> rel_\\<I> C R ===> rel_gpv'' A C R ===> (=)) pgen_lossless_gpv pgen_lossless_gpv\"", "lemma pgen_lossless_gpv_parametric: includes lifting_syntax shows\n  \"((=) ===> rel_\\<I> C (=) ===> rel_gpv A C ===> (=)) pgen_lossless_gpv pgen_lossless_gpv\"", "lemma pgen_lossless_gpv_map_gpv_id [simp]:\n  \"pgen_lossless_gpv fail \\<I> (map_gpv f id gpv) = pgen_lossless_gpv fail \\<I> gpv\"", "lemma expectation_gpv_le_inline:\n  defines \"expectation_gpv2 \\<equiv> expectation_gpv 0 \\<I>'\"\n  assumes callee: \"\\<And>s x. \\<lbrakk> x \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> plossless_gpv \\<I>' (callee s x)\"\n    and WT_gpv: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and I: \"I s\"\n  shows \"expectation_gpv 0 \\<I> f gpv \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee gpv s)\"", "lemma plossless_inline:\n  assumes lossless: \"plossless_gpv \\<I> gpv\"\n    and WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and callee: \"\\<And>s x. \\<lbrakk> I s; x \\<in> outs_\\<I> \\<I> \\<rbrakk> \\<Longrightarrow> plossless_gpv \\<I>' (callee s x)\"\n    and I: \"I s\"\n  shows \"plossless_gpv \\<I>' (inline callee gpv s)\"", "lemma expectation_left_gpv [simp]:\n  \"expectation_gpv fail (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') f (left_gpv gpv) = expectation_gpv fail \\<I> f gpv\"", "lemma expectation_right_gpv [simp]:\n  \"expectation_gpv fail (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') f (right_gpv gpv) = expectation_gpv fail \\<I>' f gpv\"", "lemma pgen_lossless_left_gpv [simp]: \"pgen_lossless_gpv fail (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') (left_gpv gpv) = pgen_lossless_gpv fail \\<I> gpv\"", "lemma pgen_lossless_right_gpv [simp]: \"pgen_lossless_gpv fail (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') (right_gpv gpv) = pgen_lossless_gpv fail \\<I>' gpv\"", "lemma (in raw_converter_invariant) expectation_gpv_le_inline_invariant:\n  defines \"expectation_gpv2 \\<equiv> expectation_gpv 0 \\<I>'\"\n  assumes callee: \"\\<And>s x. \\<lbrakk> x \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> plossless_gpv \\<I>' (callee s x)\"\n    and WT_gpv: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and I: \"I s\"\n  shows \"expectation_gpv 0 \\<I> f gpv \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee gpv s)\"", "lemma (in raw_converter_invariant) plossless_inline_invariant:\n  assumes lossless: \"plossless_gpv \\<I> gpv\"\n    and WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and callee: \"\\<And>s x. \\<lbrakk> x \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> plossless_gpv \\<I>' (callee s x)\"\n    and I: \"I s\"\n  shows \"plossless_gpv \\<I>' (inline callee gpv s)\"", "lemma raw_converter_invariant: \"raw_converter_invariant \\<I> \\<I>' (\\<lambda>s x. lift_spmf (callee s x)) I\"", "lemma (in callee_invariant_on) plossless_exec_gpv:\n  assumes lossless: \"plossless_gpv \\<I> gpv\"\n    and WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and callee: \"\\<And>s x. \\<lbrakk> x \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> lossless_spmf (callee s x)\"\n    and I: \"I s\"\n  shows \"lossless_spmf (exec_gpv callee gpv s)\"", "lemma expectation_gpv_mk_lossless_gpv:\n  fixes \\<I> y\n  defines \"rhs \\<equiv> expectation_gpv 0 \\<I> (\\<lambda>_. y)\"\n  assumes WT: \"\\<I>' \\<turnstile>g gpv \\<surd>\"\n    and outs: \"outs_\\<I> \\<I> = outs_\\<I> \\<I>'\"\n  shows \"expectation_gpv 0 \\<I>' (\\<lambda>_. y) gpv \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x gpv)\"", "lemma plossless_gpv_mk_lossless_gpv:\n  assumes \"plossless_gpv \\<I> gpv\"\n    and \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and \"outs_\\<I> \\<I> = outs_\\<I> \\<I>'\"\n  shows \"plossless_gpv \\<I>' (mk_lossless_gpv (responses_\\<I> \\<I>) x gpv)\"", "lemma (in callee_invariant_on) exec_gpv_mk_lossless_gpv:\n  assumes \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and \"I s\"\n  shows \"exec_gpv callee (mk_lossless_gpv (responses_\\<I> \\<I>) x gpv) s = exec_gpv callee gpv s\"", "lemma expectation_gpv_map_gpv' [simp]:\n  \"expectation_gpv fail \\<I> f (map_gpv' g h k gpv) =\n   expectation_gpv fail (map_\\<I> h k \\<I>) (f \\<circ> g) gpv\"", "lemma plossless_gpv_map_gpv' [simp]:\n  \"pgen_lossless_gpv b \\<I> (map_gpv' f g h gpv) \\<longleftrightarrow> pgen_lossless_gpv b (map_\\<I> g h \\<I>) gpv\""], "translations": [["", "lemma le_enn2realI: \"\\<lbrakk> ennreal x \\<le> y; y = \\<top> \\<Longrightarrow> x \\<le> 0 \\<rbrakk> \\<Longrightarrow> x \\<le> enn2real y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ennreal x \\<le> y;\n     y = \\<top> \\<Longrightarrow> x \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x \\<le> enn2real y", "by(cases y) simp_all"], ["", "lemma enn2real_leD: \"\\<lbrakk> enn2real x < y; x \\<noteq> \\<top> \\<rbrakk> \\<Longrightarrow> x < ennreal y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>enn2real x < y; x \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> x < ennreal y", "by(cases x)(simp_all add: ennreal_lessI)"], ["", "lemma ennreal_mult_le_self2I: \"\\<lbrakk> y > 0 \\<Longrightarrow> x \\<le> 1 \\<rbrakk> \\<Longrightarrow> x * y \\<le> y\" for x y :: ennreal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < y \\<Longrightarrow> x \\<le> 1) \\<Longrightarrow> x * y \\<le> y", "apply(cases x; cases y)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>r ra.\n       \\<lbrakk>0 < y \\<Longrightarrow> x \\<le> 1; 0 \\<le> r; x = ennreal r;\n        0 \\<le> ra; y = ennreal ra\\<rbrakk>\n       \\<Longrightarrow> x * y \\<le> y\n 2. \\<And>r.\n       \\<lbrakk>0 < y \\<Longrightarrow> x \\<le> 1; 0 \\<le> r; x = ennreal r;\n        y = \\<top>\\<rbrakk>\n       \\<Longrightarrow> x * y \\<le> y\n 3. \\<And>r.\n       \\<lbrakk>0 < y \\<Longrightarrow> x \\<le> 1; x = \\<top>; 0 \\<le> r;\n        y = ennreal r\\<rbrakk>\n       \\<Longrightarrow> x * y \\<le> y\n 4. \\<lbrakk>0 < y \\<Longrightarrow> x \\<le> 1; x = \\<top>;\n     y = \\<top>\\<rbrakk>\n    \\<Longrightarrow> x * y \\<le> y", "apply(auto simp add: top_unique ennreal_top_mult ennreal_mult[symmetric] intro: ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r ra.\n       \\<lbrakk>0 < ra \\<Longrightarrow> r \\<le> 1; 0 \\<le> r;\n        x = ennreal r; 0 \\<le> ra; y = ennreal ra\\<rbrakk>\n       \\<Longrightarrow> r * ra \\<le> ra", "using mult_left_le_one_le"], ["proof (prove)\nusing this:\n  \\<lbrakk>(0::?'a) \\<le> ?x; (0::?'a) \\<le> ?y; ?y \\<le> (1::?'a)\\<rbrakk>\n  \\<Longrightarrow> ?y * ?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<And>r ra.\n       \\<lbrakk>0 < ra \\<Longrightarrow> r \\<le> 1; 0 \\<le> r;\n        x = ennreal r; 0 \\<le> ra; y = ennreal ra\\<rbrakk>\n       \\<Longrightarrow> r * ra \\<le> ra", "by force"], ["", "lemma ennreal_leI: \"x \\<le> enn2real y \\<Longrightarrow> ennreal x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> enn2real y \\<Longrightarrow> ennreal x \\<le> y", "by(cases y) simp_all"], ["", "lemma enn2real_INF: \"\\<lbrakk> A \\<noteq> {}; \\<forall>x\\<in>A. f x < \\<top> \\<rbrakk> \\<Longrightarrow> enn2real (INF x\\<in>A. f x) = (INF x\\<in>A. enn2real (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {}; \\<forall>x\\<in>A. f x < \\<top>\\<rbrakk>\n    \\<Longrightarrow> enn2real (\\<Sqinter> (f ` A)) =\n                      (\\<Sqinter>x\\<in>A. enn2real (f x))", "apply(rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<noteq> {}; \\<forall>x\\<in>A. f x < \\<top>\\<rbrakk>\n    \\<Longrightarrow> enn2real (\\<Sqinter> (f ` A))\n                      \\<le> (\\<Sqinter>x\\<in>A. enn2real (f x))\n 2. \\<lbrakk>A \\<noteq> {}; \\<forall>x\\<in>A. f x < \\<top>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sqinter>x\\<in>A. enn2real (f x))\n                      \\<le> enn2real (\\<Sqinter> (f ` A))", "apply(rule cINF_greatest)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>A \\<noteq> {}; \\<forall>x\\<in>A. f x < \\<top>\\<rbrakk>\n    \\<Longrightarrow> A \\<noteq> {}\n 2. \\<And>x.\n       \\<lbrakk>A \\<noteq> {}; \\<forall>x\\<in>A. f x < \\<top>;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> enn2real (\\<Sqinter> (f ` A)) \\<le> enn2real (f x)\n 3. \\<lbrakk>A \\<noteq> {}; \\<forall>x\\<in>A. f x < \\<top>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sqinter>x\\<in>A. enn2real (f x))\n                      \\<le> enn2real (\\<Sqinter> (f ` A))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A \\<noteq> {}; \\<forall>x\\<in>A. f x < \\<top>;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> enn2real (\\<Sqinter> (f ` A)) \\<le> enn2real (f x)\n 2. \\<lbrakk>A \\<noteq> {}; \\<forall>x\\<in>A. f x < \\<top>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sqinter>x\\<in>A. enn2real (f x))\n                      \\<le> enn2real (\\<Sqinter> (f ` A))", "apply(rule enn2real_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A \\<noteq> {}; \\<forall>x\\<in>A. f x < \\<top>;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<Sqinter> (f ` A) \\<le> f x\n 2. \\<And>x.\n       \\<lbrakk>A \\<noteq> {}; \\<forall>x\\<in>A. f x < \\<top>;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> f x < \\<top>\n 3. \\<lbrakk>A \\<noteq> {}; \\<forall>x\\<in>A. f x < \\<top>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sqinter>x\\<in>A. enn2real (f x))\n                      \\<le> enn2real (\\<Sqinter> (f ` A))", "apply(erule INF_lower)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A \\<noteq> {}; \\<forall>x\\<in>A. f x < \\<top>;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> f x < \\<top>\n 2. \\<lbrakk>A \\<noteq> {}; \\<forall>x\\<in>A. f x < \\<top>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sqinter>x\\<in>A. enn2real (f x))\n                      \\<le> enn2real (\\<Sqinter> (f ` A))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {}; \\<forall>x\\<in>A. f x < \\<top>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sqinter>x\\<in>A. enn2real (f x))\n                      \\<le> enn2real (\\<Sqinter> (f ` A))", "apply(rule le_enn2realI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<noteq> {}; \\<forall>x\\<in>A. f x < \\<top>\\<rbrakk>\n    \\<Longrightarrow> ennreal (\\<Sqinter>x\\<in>A. enn2real (f x))\n                      \\<le> \\<Sqinter> (f ` A)\n 2. \\<lbrakk>A \\<noteq> {}; \\<forall>x\\<in>A. f x < \\<top>;\n     \\<Sqinter> (f ` A) = \\<top>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sqinter>x\\<in>A. enn2real (f x)) \\<le> 0", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {}; \\<forall>x\\<in>A. f x < \\<top>\\<rbrakk>\n    \\<Longrightarrow> ennreal (\\<Sqinter>x\\<in>A. enn2real (f x))\n                      \\<le> \\<Sqinter> (f ` A)", "apply(rule INF_greatest)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>A \\<noteq> {}; \\<forall>x\\<in>A. f x < \\<top>;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> ennreal (\\<Sqinter>x\\<in>A. enn2real (f x))\n                         \\<le> f x", "apply(rule ennreal_leI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>A \\<noteq> {}; \\<forall>x\\<in>A. f x < \\<top>;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>x\\<in>A. enn2real (f x))\n                         \\<le> enn2real (f x)", "apply(rule cINF_lower)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A \\<noteq> {}; \\<forall>x\\<in>A. f x < \\<top>;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> bdd_below ((\\<lambda>x. enn2real (f x)) ` A)\n 2. \\<And>x.\n       \\<lbrakk>A \\<noteq> {}; \\<forall>x\\<in>A. f x < \\<top>;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "apply(rule bdd_belowI[where m=0])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>A \\<noteq> {}; \\<forall>x\\<in>A. f x < \\<top>; x \\<in> A;\n        xa \\<in> (\\<lambda>x. enn2real (f x)) ` A\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> xa\n 2. \\<And>x.\n       \\<lbrakk>A \\<noteq> {}; \\<forall>x\\<in>A. f x < \\<top>;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma monotone_times_ennreal1: \"monotone (\\<le>) (\\<le>) (\\<lambda>x. x * y :: ennreal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<le>) (\\<le>) (\\<lambda>x. x * y)", "by(auto intro!: monotoneI mult_right_mono)"], ["", "lemma monotone_times_ennreal2: \"monotone (\\<le>) (\\<le>) (\\<lambda>x. y * x :: ennreal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<le>) (\\<le>) ((*) y)", "by(auto intro!: monotoneI mult_left_mono)"], ["", "lemma mono2mono_times_ennreal[THEN lfp.mono2mono2, cont_intro, simp]:\n  shows monotone_times_ennreal: \"monotone (rel_prod (\\<le>) (\\<le>)) (\\<le>) (\\<lambda>(x, y). x * y :: ennreal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (rel_prod (\\<le>) (\\<le>)) (\\<le>) (\\<lambda>(x, y). x * y)", "by(simp add: monotone_times_ennreal1 monotone_times_ennreal2)"], ["", "lemma mcont_times_ennreal1: \"mcont Sup (\\<le>) Sup (\\<le>) (\\<lambda>y. x * y :: ennreal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont Sup (\\<le>) Sup (\\<le>) ((*) x)", "by(auto intro!: mcontI contI simp add: SUP_mult_left_ennreal[symmetric])"], ["", "lemma mcont_times_ennreal2: \"mcont Sup (\\<le>) Sup (\\<le>) (\\<lambda>y. y * x :: ennreal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont Sup (\\<le>) Sup (\\<le>) (\\<lambda>y. y * x)", "by(subst mult.commute)(rule mcont_times_ennreal1)"], ["", "lemma mcont2mcont_times_ennreal [cont_intro, simp]:\n  \"\\<lbrakk> mcont lub ord Sup (\\<le>) (\\<lambda>x. f x);\n    mcont lub ord Sup (\\<le>) (\\<lambda>x. g x) \\<rbrakk>\n  \\<Longrightarrow> mcont lub ord Sup (\\<le>) (\\<lambda>x. f x * g x :: ennreal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mcont lub ord Sup (\\<le>) f;\n     mcont lub ord Sup (\\<le>) g\\<rbrakk>\n    \\<Longrightarrow> mcont lub ord Sup (\\<le>) (\\<lambda>x. f x * g x)", "by(best intro: ccpo.mcont2mcont'[OF complete_lattice_ccpo] mcont_times_ennreal1 mcont_times_ennreal2 ccpo.mcont_const[OF complete_lattice_ccpo])"], ["", "lemma ereal_INF_cmult: \"0 < c \\<Longrightarrow> (INF i\\<in>I. c * f i) = ereal c * (INF i\\<in>I. f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < c \\<Longrightarrow>\n    (\\<Sqinter>i\\<in>I. ereal c * f i) = ereal c * \\<Sqinter> (f ` I)", "using ereal_Inf_cmult[where P=\"\\<lambda>x. \\<exists>i\\<in>I. x = f i\", of c]"], ["proof (prove)\nusing this:\n  0 < c \\<Longrightarrow>\n  \\<Sqinter> {ereal c * x |x. \\<exists>i\\<in>I. x = f i} =\n  ereal c * \\<Sqinter> {x. \\<exists>i\\<in>I. x = f i}\n\ngoal (1 subgoal):\n 1. 0 < c \\<Longrightarrow>\n    (\\<Sqinter>i\\<in>I. ereal c * f i) = ereal c * \\<Sqinter> (f ` I)", "by(rule box_equals)(auto intro!: arg_cong[where f=\"Inf\"] arg_cong2[where f=\"(*)\"])"], ["", "lemma ereal_INF_multc: \"0 < c \\<Longrightarrow> (INF i\\<in>I. f i * c) = (INF i\\<in>I. f i) * ereal c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < c \\<Longrightarrow>\n    (\\<Sqinter>i\\<in>I. f i * ereal c) = \\<Sqinter> (f ` I) * ereal c", "using ereal_INF_cmult[of c f I]"], ["proof (prove)\nusing this:\n  0 < c \\<Longrightarrow>\n  (\\<Sqinter>i\\<in>I. ereal c * f i) = ereal c * \\<Sqinter> (f ` I)\n\ngoal (1 subgoal):\n 1. 0 < c \\<Longrightarrow>\n    (\\<Sqinter>i\\<in>I. f i * ereal c) = \\<Sqinter> (f ` I) * ereal c", "by(simp add: mult.commute)"], ["", "lemma INF_mult_left_ennreal: \n  assumes \"I = {} \\<Longrightarrow> c \\<noteq> 0\"\n  and \"\\<lbrakk> c = \\<top>; \\<exists>i\\<in>I. f i > 0 \\<rbrakk> \\<Longrightarrow> \\<exists>p>0. \\<forall>i\\<in>I. f i \\<ge> p\"\n  shows \"c * (INF i\\<in>I. f i) = (INF i\\<in>I. c * f i ::ennreal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "consider (empty) \"I = {}\" | (top) \"c = \\<top>\" | (zero) \"c = 0\" | (normal) \"I \\<noteq> {}\" \"c \\<noteq> \\<top>\" \"c \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I = {} \\<Longrightarrow> thesis;\n     c = \\<top> \\<Longrightarrow> thesis; c = 0 \\<Longrightarrow> thesis;\n     \\<lbrakk>I \\<noteq> {}; c \\<noteq> \\<top>; c \\<noteq> 0\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>I = {} \\<Longrightarrow> ?thesis;\n   c = \\<top> \\<Longrightarrow> ?thesis; c = 0 \\<Longrightarrow> ?thesis;\n   \\<lbrakk>I \\<noteq> {}; c \\<noteq> \\<top>; c \\<noteq> 0\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>I = {} \\<Longrightarrow> ?thesis;\n   c = \\<top> \\<Longrightarrow> ?thesis; c = 0 \\<Longrightarrow> ?thesis;\n   \\<lbrakk>I \\<noteq> {}; c \\<noteq> \\<top>; c \\<noteq> 0\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>I = {} \\<Longrightarrow> ?thesis;\n   c = \\<top> \\<Longrightarrow> ?thesis; c = 0 \\<Longrightarrow> ?thesis;\n   \\<lbrakk>I \\<noteq> {}; c \\<noteq> \\<top>; c \\<noteq> 0\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. I = {} \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n 2. c = \\<top> \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n 3. c = 0 \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n 4. \\<lbrakk>I \\<noteq> {}; c \\<noteq> \\<top>; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "case empty"], ["proof (state)\nthis:\n  I = {}\n\ngoal (4 subgoals):\n 1. I = {} \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n 2. c = \\<top> \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n 3. c = 0 \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n 4. \\<lbrakk>I \\<noteq> {}; c \\<noteq> \\<top>; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "then"], ["proof (chain)\npicking this:\n  I = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  I = {}\n\ngoal (1 subgoal):\n 1. c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "by(simp add: ennreal_mult_top assms(1))"], ["proof (state)\nthis:\n  c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n\ngoal (3 subgoals):\n 1. c = \\<top> \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n 2. c = 0 \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n 3. \\<lbrakk>I \\<noteq> {}; c \\<noteq> \\<top>; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. c = \\<top> \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n 2. c = 0 \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n 3. \\<lbrakk>I \\<noteq> {}; c \\<noteq> \\<top>; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "case top"], ["proof (state)\nthis:\n  c = \\<top>\n\ngoal (3 subgoals):\n 1. c = \\<top> \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n 2. c = 0 \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n 3. \\<lbrakk>I \\<noteq> {}; c \\<noteq> \\<top>; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "proof(cases \"\\<exists>i\\<in>I. f i > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>I. 0 < f i \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n 2. \\<not> (\\<exists>i\\<in>I. 0 < f i) \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "case True"], ["proof (state)\nthis:\n  \\<exists>i\\<in>I. 0 < f i\n\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>I. 0 < f i \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n 2. \\<not> (\\<exists>i\\<in>I. 0 < f i) \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "with assms(2) top"], ["proof (chain)\npicking this:\n  \\<lbrakk>c = \\<top>; \\<exists>i\\<in>I. 0 < f i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p>0. \\<forall>i\\<in>I. p \\<le> f i\n  c = \\<top>\n  \\<exists>i\\<in>I. 0 < f i", "obtain p where \"p > 0\" and p: \"\\<And>i. i \\<in> I \\<Longrightarrow> f i \\<ge> p\""], ["proof (prove)\nusing this:\n  \\<lbrakk>c = \\<top>; \\<exists>i\\<in>I. 0 < f i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p>0. \\<forall>i\\<in>I. p \\<le> f i\n  c = \\<top>\n  \\<exists>i\\<in>I. 0 < f i\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>0 < p;\n         \\<And>i. i \\<in> I \\<Longrightarrow> p \\<le> f i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < p\n  ?i \\<in> I \\<Longrightarrow> p \\<le> f ?i\n\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>I. 0 < f i \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n 2. \\<not> (\\<exists>i\\<in>I. 0 < f i) \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "then"], ["proof (chain)\npicking this:\n  0 < p\n  ?i \\<in> I \\<Longrightarrow> p \\<le> f ?i", "have *: \"\\<And>i. i \\<in> I \\<Longrightarrow> f i > 0\""], ["proof (prove)\nusing this:\n  0 < p\n  ?i \\<in> I \\<Longrightarrow> p \\<le> f ?i\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> I \\<Longrightarrow> 0 < f i", "by(auto intro: less_le_trans)"], ["proof (state)\nthis:\n  ?i \\<in> I \\<Longrightarrow> 0 < f ?i\n\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>I. 0 < f i \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n 2. \\<not> (\\<exists>i\\<in>I. 0 < f i) \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "note \\<open>0 < p\\<close>"], ["proof (state)\nthis:\n  0 < p\n\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>I. 0 < f i \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n 2. \\<not> (\\<exists>i\\<in>I. 0 < f i) \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "also"], ["proof (state)\nthis:\n  0 < p\n\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>I. 0 < f i \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n 2. \\<not> (\\<exists>i\\<in>I. 0 < f i) \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "from p"], ["proof (chain)\npicking this:\n  ?i \\<in> I \\<Longrightarrow> p \\<le> f ?i", "have \"p \\<le> (INF i\\<in>I. f i)\""], ["proof (prove)\nusing this:\n  ?i \\<in> I \\<Longrightarrow> p \\<le> f ?i\n\ngoal (1 subgoal):\n 1. p \\<le> \\<Sqinter> (f ` I)", "by(rule INF_greatest)"], ["proof (state)\nthis:\n  p \\<le> \\<Sqinter> (f ` I)\n\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>I. 0 < f i \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n 2. \\<not> (\\<exists>i\\<in>I. 0 < f i) \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "finally"], ["proof (chain)\npicking this:\n  0 < \\<Sqinter> (f ` I)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < \\<Sqinter> (f ` I)\n\ngoal (1 subgoal):\n 1. c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "using top"], ["proof (prove)\nusing this:\n  0 < \\<Sqinter> (f ` I)\n  c = \\<top>\n\ngoal (1 subgoal):\n 1. c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "by(auto simp add: ennreal_top_mult dest: *)"], ["proof (state)\nthis:\n  c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>I. 0 < f i) \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>I. 0 < f i) \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>i\\<in>I. 0 < f i)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>I. 0 < f i) \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "hence \"f i = 0\" if \"i \\<in> I\" for i"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>I. 0 < f i)\n\ngoal (1 subgoal):\n 1. f i = 0", "using that"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>I. 0 < f i)\n  i \\<in> I\n\ngoal (1 subgoal):\n 1. f i = 0", "by auto"], ["proof (state)\nthis:\n  ?i \\<in> I \\<Longrightarrow> f ?i = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>I. 0 < f i) \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?i \\<in> I \\<Longrightarrow> f ?i = 0\n\ngoal (1 subgoal):\n 1. c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "using top"], ["proof (prove)\nusing this:\n  ?i \\<in> I \\<Longrightarrow> f ?i = 0\n  c = \\<top>\n\ngoal (1 subgoal):\n 1. c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "by(simp add: INF_constant ennreal_mult_top)"], ["proof (state)\nthis:\n  c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n 2. \\<lbrakk>I \\<noteq> {}; c \\<noteq> \\<top>; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n 2. \\<lbrakk>I \\<noteq> {}; c \\<noteq> \\<top>; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "case zero"], ["proof (state)\nthis:\n  c = 0\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n 2. \\<lbrakk>I \\<noteq> {}; c \\<noteq> \\<top>; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "then"], ["proof (chain)\npicking this:\n  c = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  c = 0\n\ngoal (1 subgoal):\n 1. c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "using assms(1)"], ["proof (prove)\nusing this:\n  c = 0\n  I = {} \\<Longrightarrow> c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "by(auto simp add: INF_constant)"], ["proof (state)\nthis:\n  c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; c \\<noteq> \\<top>; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; c \\<noteq> \\<top>; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "case normal"], ["proof (state)\nthis:\n  I \\<noteq> {}\n  c \\<noteq> \\<top>\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; c \\<noteq> \\<top>; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "then"], ["proof (chain)\npicking this:\n  I \\<noteq> {}\n  c \\<noteq> \\<top>\n  c \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  I \\<noteq> {}\n  c \\<noteq> \\<top>\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "including ennreal.lifting"], ["proof (prove)\nusing this:\n  I \\<noteq> {}\n  c \\<noteq> \\<top>\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I c f.\n       \\<lbrakk>I \\<noteq> {}; 0 \\<le> c; c \\<noteq> \\<top>; c \\<noteq> 0;\n        pred_fun \\<top> ((\\<le>) 0) f\\<rbrakk>\n       \\<Longrightarrow> c * \\<Sqinter> (f ` I) =\n                         (\\<Sqinter>i\\<in>I. c * f i)", "subgoal for I c f"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; 0 \\<le> c; c \\<noteq> \\<top>; c \\<noteq> 0;\n     pred_fun \\<top> ((\\<le>) 0) f\\<rbrakk>\n    \\<Longrightarrow> c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)", "by(cases c)(simp_all add: top_ereal_def ereal_INF_cmult)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c * \\<Sqinter> (f ` I) = (\\<Sqinter>i\\<in>I. c * f i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pmf_map_spmf_None: \"pmf (map_spmf f p) None = pmf p None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (map_spmf f p) None = pmf p None", "by(simp add: pmf_None_eq_weight_spmf)"], ["", "lemma nn_integral_try_spmf:\n  \"nn_integral (measure_spmf (try_spmf p q)) f = nn_integral (measure_spmf p) f + nn_integral (measure_spmf q) f * pmf p None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (measure_spmf (TRY p ELSE q)) f =\n    integral\\<^sup>N (measure_spmf p) f +\n    integral\\<^sup>N (measure_spmf q) f * ennreal (pmf p None)", "by(simp add: nn_integral_measure_spmf spmf_try_spmf distrib_right nn_integral_add ennreal_mult mult.assoc nn_integral_cmult)\n  (simp add: mult.commute)"], ["", "lemma INF_UNION: \"(INF z \\<in> \\<Union>x\\<in>A. B x. f z) = (INF x\\<in>A. INF z\\<in>B x. f z)\" for f :: \"_ \\<Rightarrow> 'b::complete_lattice\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> (f ` \\<Union> (B ` A)) =\n    (\\<Sqinter>x\\<in>A. \\<Sqinter> (f ` B x))", "by(auto intro!: antisym INF_greatest intro: INF_lower2)"], ["", "definition nn_integral_spmf :: \"'a spmf \\<Rightarrow> ('a \\<Rightarrow> ennreal) \\<Rightarrow> ennreal\" where\n  \"nn_integral_spmf p = nn_integral (measure_spmf p)\""], ["", "lemma nn_integral_spmf_parametric [transfer_rule]:\n  includes lifting_syntax\n  shows \"(rel_spmf A ===> (A ===> (=)) ===> (=)) nn_integral_spmf nn_integral_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_spmf A ===> (A ===> (=)) ===> (=)) nn_integral_spmf\n     nn_integral_spmf", "unfolding nn_integral_spmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_spmf A ===> (A ===> (=)) ===> (=))\n     (\\<lambda>p. integral\\<^sup>N (measure_spmf p))\n     (\\<lambda>p. integral\\<^sup>N (measure_spmf p))", "proof(rule rel_funI)+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_spmf A x y; (A ===> (=)) xa ya\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf x) xa =\n                         integral\\<^sup>N (measure_spmf y) ya", "fix p q and f g :: \"_ \\<Rightarrow> ennreal\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_spmf A x y; (A ===> (=)) xa ya\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf x) xa =\n                         integral\\<^sup>N (measure_spmf y) ya", "assume pq: \"rel_spmf A p q\" and fg: \"(A ===> (=)) f g\""], ["proof (state)\nthis:\n  rel_spmf A p q\n  (A ===> (=)) f g\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_spmf A x y; (A ===> (=)) xa ya\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf x) xa =\n                         integral\\<^sup>N (measure_spmf y) ya", "from pq"], ["proof (chain)\npicking this:\n  rel_spmf A p q", "obtain pq where pq [rule_format]: \"\\<forall>(x, y)\\<in>set_spmf pq. A x y\"\n    and p: \"p = map_spmf fst pq\" and q: \"q = map_spmf snd pq\""], ["proof (prove)\nusing this:\n  rel_spmf A p q\n\ngoal (1 subgoal):\n 1. (\\<And>pq.\n        \\<lbrakk>\\<forall>(x, y)\\<in>set_spmf pq. A x y;\n         p = map_spmf fst pq; q = map_spmf snd pq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases rule: rel_spmfE) auto"], ["proof (state)\nthis:\n  ?x \\<in> set_spmf pq \\<Longrightarrow>\n  case ?x of (x, xa) \\<Rightarrow> A x xa\n  p = map_spmf fst pq\n  q = map_spmf snd pq\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_spmf A x y; (A ===> (=)) xa ya\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf x) xa =\n                         integral\\<^sup>N (measure_spmf y) ya", "show \"nn_integral (measure_spmf p) f = nn_integral (measure_spmf q) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (measure_spmf p) f =\n    integral\\<^sup>N (measure_spmf q) g", "by(simp add: p q)(auto simp add: nn_integral_measure_spmf spmf_eq_0_set_spmf dest!: pq rel_funD[OF fg] intro: ennreal_mult_left_cong intro!: nn_integral_cong)"], ["proof (state)\nthis:\n  integral\\<^sup>N (measure_spmf p) f = integral\\<^sup>N (measure_spmf q) g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma weight_spmf_mcont2mcont [THEN lfp.mcont2mcont, cont_intro]:\n  shows weight_spmf_mcont: \"mcont (lub_spmf) (ord_spmf (=)) Sup (\\<le>) (\\<lambda>p. ennreal (weight_spmf p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lub_spmf (ord_spmf (=)) Sup (\\<le>)\n     (\\<lambda>p. ennreal (weight_spmf p))", "apply(simp add: mcont_def cont_def weight_spmf_def measure_spmf.emeasure_eq_measure[symmetric] emeasure_lub_spmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (ord_spmf (=)) (\\<le>)\n     (\\<lambda>p. emeasure (measure_spmf p) UNIV)", "apply(rule call_mono[THEN lfp.mono2mono])"], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (ord_spmf (=)) lfp.le_fun\n     (\\<lambda>p. emeasure (measure_spmf p))", "apply(unfold fun_ord_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (ord_spmf (=)) (\\<lambda>f g. \\<forall>x. f x \\<le> g x)\n     (\\<lambda>p. emeasure (measure_spmf p))", "apply(rule monotone_emeasure_spmf[unfolded le_fun_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mono2mono_nn_integral_spmf [THEN lfp.mono2mono, cont_intro]:\n  shows monotone_nn_integral_spmf: \"monotone (ord_spmf (=)) (\\<le>) (\\<lambda>p. integral\\<^sup>N (measure_spmf p) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (ord_spmf (=)) (\\<le>)\n     (\\<lambda>p. integral\\<^sup>N (measure_spmf p) f)", "by(rule monotoneI)(auto simp add: nn_integral_measure_spmf intro!: nn_integral_mono mult_right_mono dest: monotone_spmf[THEN monotoneD])"], ["", "lemma cont_nn_integral_spmf:\n  \"cont lub_spmf (ord_spmf (=)) Sup (\\<le>) (\\<lambda>p :: 'a spmf. nn_integral (measure_spmf p) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont lub_spmf (ord_spmf (=)) Sup (\\<le>)\n     (\\<lambda>p. integral\\<^sup>N (measure_spmf p) f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (ord_spmf (=)) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (lub_spmf Y)) f =\n                         (\\<Squnion>p\\<in>Y.\n                             integral\\<^sup>N (measure_spmf p) f)", "fix Y :: \"'a spmf set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (ord_spmf (=)) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (lub_spmf Y)) f =\n                         (\\<Squnion>p\\<in>Y.\n                             integral\\<^sup>N (measure_spmf p) f)", "assume Y: \"Complete_Partial_Order.chain (ord_spmf (=)) Y\" \"Y \\<noteq> {}\""], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (ord_spmf (=)) Y\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (ord_spmf (=)) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (lub_spmf Y)) f =\n                         (\\<Squnion>p\\<in>Y.\n                             integral\\<^sup>N (measure_spmf p) f)", "let ?M = \"count_space (set_spmf (lub_spmf Y))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (ord_spmf (=)) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (lub_spmf Y)) f =\n                         (\\<Squnion>p\\<in>Y.\n                             integral\\<^sup>N (measure_spmf p) f)", "have \"nn_integral (measure_spmf (lub_spmf Y)) f = \\<integral>\\<^sup>+ x. ennreal (spmf (lub_spmf Y) x) * f x \\<partial>?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (measure_spmf (lub_spmf Y)) f =\n    (\\<Sum>\\<^sup>+ x\\<in>set_spmf (lub_spmf Y).\n       ennreal (spmf (lub_spmf Y) x) * f x)", "by(simp add: nn_integral_measure_spmf')"], ["proof (state)\nthis:\n  integral\\<^sup>N (measure_spmf (lub_spmf Y)) f =\n  (\\<Sum>\\<^sup>+ x\\<in>set_spmf (lub_spmf Y).\n     ennreal (spmf (lub_spmf Y) x) * f x)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (ord_spmf (=)) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (lub_spmf Y)) f =\n                         (\\<Squnion>p\\<in>Y.\n                             integral\\<^sup>N (measure_spmf p) f)", "also"], ["proof (state)\nthis:\n  integral\\<^sup>N (measure_spmf (lub_spmf Y)) f =\n  (\\<Sum>\\<^sup>+ x\\<in>set_spmf (lub_spmf Y).\n     ennreal (spmf (lub_spmf Y) x) * f x)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (ord_spmf (=)) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (lub_spmf Y)) f =\n                         (\\<Squnion>p\\<in>Y.\n                             integral\\<^sup>N (measure_spmf p) f)", "have \"\\<dots> = \\<integral>\\<^sup>+ x. (SUP p\\<in>Y. ennreal (spmf p x) * f x) \\<partial>?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x\\<in>set_spmf (lub_spmf Y).\n       ennreal (spmf (lub_spmf Y) x) * f x) =\n    (\\<Sum>\\<^sup>+ x\\<in>set_spmf (lub_spmf Y).\n       \\<Squnion>p\\<in>Y. ennreal (spmf p x) * f x)", "by(simp add: spmf_lub_spmf Y ennreal_SUP[OF SUP_spmf_neq_top'] SUP_mult_right_ennreal)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x\\<in>set_spmf (lub_spmf Y).\n     ennreal (spmf (lub_spmf Y) x) * f x) =\n  (\\<Sum>\\<^sup>+ x\\<in>set_spmf (lub_spmf Y).\n     \\<Squnion>p\\<in>Y. ennreal (spmf p x) * f x)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (ord_spmf (=)) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (lub_spmf Y)) f =\n                         (\\<Squnion>p\\<in>Y.\n                             integral\\<^sup>N (measure_spmf p) f)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x\\<in>set_spmf (lub_spmf Y).\n     ennreal (spmf (lub_spmf Y) x) * f x) =\n  (\\<Sum>\\<^sup>+ x\\<in>set_spmf (lub_spmf Y).\n     \\<Squnion>p\\<in>Y. ennreal (spmf p x) * f x)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (ord_spmf (=)) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (lub_spmf Y)) f =\n                         (\\<Squnion>p\\<in>Y.\n                             integral\\<^sup>N (measure_spmf p) f)", "have \"\\<dots> = (SUP p\\<in>Y. \\<integral>\\<^sup>+ x. ennreal (spmf p x) * f x \\<partial>?M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x\\<in>set_spmf (lub_spmf Y).\n       \\<Squnion>p\\<in>Y. ennreal (spmf p x) * f x) =\n    (\\<Squnion>p\\<in>Y.\n        \\<Sum>\\<^sup>+ x\\<in>set_spmf (lub_spmf Y).\n          ennreal (spmf p x) * f x)", "proof(rule nn_integral_monotone_convergence_SUP_countable)"], ["proof (state)\ngoal (3 subgoals):\n 1. Y \\<noteq> {}\n 2. Complete_Partial_Order.chain (\\<le>)\n     ((\\<lambda>i x. ennreal (spmf i x) * f x) ` Y)\n 3. countable (set_spmf (lub_spmf Y))", "show \"Complete_Partial_Order.chain (\\<le>) ((\\<lambda>i x. ennreal (spmf i x) * f x) ` Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<le>)\n     ((\\<lambda>i x. ennreal (spmf i x) * f x) ` Y)", "using Y(1)"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (ord_spmf (=)) Y\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<le>)\n     ((\\<lambda>i x. ennreal (spmf i x) * f x) ` Y)", "by(rule chain_imageI)(auto simp add: le_fun_def intro!: mult_right_mono dest: monotone_spmf[THEN monotoneD])"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<le>)\n   ((\\<lambda>i x. ennreal (spmf i x) * f x) ` Y)\n\ngoal (2 subgoals):\n 1. Y \\<noteq> {}\n 2. countable (set_spmf (lub_spmf Y))", "qed(simp_all add: Y(2))"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x\\<in>set_spmf (lub_spmf Y).\n     \\<Squnion>p\\<in>Y. ennreal (spmf p x) * f x) =\n  (\\<Squnion>p\\<in>Y.\n      \\<Sum>\\<^sup>+ x\\<in>set_spmf (lub_spmf Y). ennreal (spmf p x) * f x)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (ord_spmf (=)) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (lub_spmf Y)) f =\n                         (\\<Squnion>p\\<in>Y.\n                             integral\\<^sup>N (measure_spmf p) f)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x\\<in>set_spmf (lub_spmf Y).\n     \\<Squnion>p\\<in>Y. ennreal (spmf p x) * f x) =\n  (\\<Squnion>p\\<in>Y.\n      \\<Sum>\\<^sup>+ x\\<in>set_spmf (lub_spmf Y). ennreal (spmf p x) * f x)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (ord_spmf (=)) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (lub_spmf Y)) f =\n                         (\\<Squnion>p\\<in>Y.\n                             integral\\<^sup>N (measure_spmf p) f)", "have \"\\<dots> = (SUP p\\<in>Y. nn_integral (measure_spmf p) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>p\\<in>Y.\n        \\<Sum>\\<^sup>+ x\\<in>set_spmf (lub_spmf Y).\n          ennreal (spmf p x) * f x) =\n    (\\<Squnion>p\\<in>Y. integral\\<^sup>N (measure_spmf p) f)", "by(auto simp add: nn_integral_measure_spmf Y nn_integral_count_space_indicator set_lub_spmf spmf_eq_0_set_spmf split: split_indicator intro!: SUP_cong nn_integral_cong)"], ["proof (state)\nthis:\n  (\\<Squnion>p\\<in>Y.\n      \\<Sum>\\<^sup>+ x\\<in>set_spmf (lub_spmf Y).\n        ennreal (spmf p x) * f x) =\n  (\\<Squnion>p\\<in>Y. integral\\<^sup>N (measure_spmf p) f)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (ord_spmf (=)) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (lub_spmf Y)) f =\n                         (\\<Squnion>p\\<in>Y.\n                             integral\\<^sup>N (measure_spmf p) f)", "finally"], ["proof (chain)\npicking this:\n  integral\\<^sup>N (measure_spmf (lub_spmf Y)) f =\n  (\\<Squnion>p\\<in>Y. integral\\<^sup>N (measure_spmf p) f)", "show \"nn_integral (measure_spmf (lub_spmf Y)) f = (SUP p\\<in>Y. nn_integral (measure_spmf p) f)\""], ["proof (prove)\nusing this:\n  integral\\<^sup>N (measure_spmf (lub_spmf Y)) f =\n  (\\<Squnion>p\\<in>Y. integral\\<^sup>N (measure_spmf p) f)\n\ngoal (1 subgoal):\n 1. integral\\<^sup>N (measure_spmf (lub_spmf Y)) f =\n    (\\<Squnion>p\\<in>Y. integral\\<^sup>N (measure_spmf p) f)", "."], ["proof (state)\nthis:\n  integral\\<^sup>N (measure_spmf (lub_spmf Y)) f =\n  (\\<Squnion>p\\<in>Y. integral\\<^sup>N (measure_spmf p) f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mcont2mcont_nn_integral_spmf [THEN lfp.mcont2mcont, cont_intro]:\n  shows mcont_nn_integral_spmf:\n  \"mcont lub_spmf (ord_spmf (=)) Sup (\\<le>) (\\<lambda>p :: 'a spmf. nn_integral (measure_spmf p) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lub_spmf (ord_spmf (=)) Sup (\\<le>)\n     (\\<lambda>p. integral\\<^sup>N (measure_spmf p) f)", "by(rule mcontI)(simp_all add: cont_nn_integral_spmf)"], ["", "lemma nn_integral_mono2mono:\n  assumes \"\\<And>x. x \\<in> space M \\<Longrightarrow> monotone ord (\\<le>) (\\<lambda>f. F f x)\"\n  shows \"monotone ord (\\<le>) (\\<lambda>f. nn_integral M (F f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone ord (\\<le>) (\\<lambda>f. integral\\<^sup>N M (F f))", "by(rule monotoneI nn_integral_mono monotoneD[OF assms])+"], ["", "lemma nn_integral_mono_lfp [partial_function_mono]:\n  \\<comment> \\<open>@{ML Partial_Function.mono_tac} does not like conditional assumptions (more precisely the case splitter)\\<close>\n  \"(\\<And>x. lfp.mono_body (\\<lambda>f. F f x)) \\<Longrightarrow> lfp.mono_body (\\<lambda>f. nn_integral M (F f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. lfp.mono_body (\\<lambda>f. F f x)) \\<Longrightarrow>\n    lfp.mono_body (\\<lambda>f. integral\\<^sup>N M (F f))", "by(rule nn_integral_mono2mono)"], ["", "lemma INF_mono_lfp [partial_function_mono]:\n  \"(\\<And>x. lfp.mono_body (\\<lambda>f. F f x)) \\<Longrightarrow> lfp.mono_body (\\<lambda>f. INF x\\<in>M. F f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. lfp.mono_body (\\<lambda>f. F f x)) \\<Longrightarrow>\n    lfp.mono_body (\\<lambda>f. \\<Sqinter> (F f ` M))", "by(rule monotoneI)(blast dest: monotoneD intro: INF_mono)"], ["", "lemmas parallel_fixp_induct_1_2 = parallel_fixp_induct_uc[\n  of _ _ _ _ \"\\<lambda>x. x\" _ \"\\<lambda>x. x\" \"case_prod\" _ \"curry\",\n  where P=\"\\<lambda>f g. P f (curry g)\",\n  unfolded case_prod_curry curry_case_prod curry_K,\n  OF _ _ _ _ _ _ refl refl]\n  for P"], ["", "lemma monotone_ennreal_add1: \"monotone (\\<le>) (\\<le>) (\\<lambda>x. x + y :: ennreal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<le>) (\\<le>) (\\<lambda>x. x + y)", "by(auto intro!: monotoneI)"], ["", "lemma monotone_ennreal_add2: \"monotone (\\<le>) (\\<le>) (\\<lambda>y. x + y :: ennreal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<le>) (\\<le>) ((+) x)", "by(auto intro!: monotoneI)"], ["", "lemma mono2mono_ennreal_add[THEN lfp.mono2mono2, cont_intro, simp]:\n  shows monotone_eadd: \"monotone (rel_prod (\\<le>) (\\<le>)) (\\<le>) (\\<lambda>(x, y). x + y :: ennreal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (rel_prod (\\<le>) (\\<le>)) (\\<le>) (\\<lambda>(x, y). x + y)", "by(simp add: monotone_ennreal_add1 monotone_ennreal_add2)"], ["", "lemma ennreal_add_partial_function_mono [partial_function_mono]:\n  \"\\<lbrakk> monotone (fun_ord (\\<le>)) (\\<le>) f; monotone (fun_ord (\\<le>)) (\\<le>) g \\<rbrakk>\n  \\<Longrightarrow> monotone (fun_ord (\\<le>)) (\\<le>) (\\<lambda>x. f x + g x :: ennreal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>monotone (fun_ord (\\<le>)) (\\<le>) f;\n     monotone (fun_ord (\\<le>)) (\\<le>) g\\<rbrakk>\n    \\<Longrightarrow> monotone (fun_ord (\\<le>)) (\\<le>)\n                       (\\<lambda>x. f x + g x)", "by(rule mono2mono_ennreal_add)"], ["", "context\n  fixes fail :: ennreal\n  and \\<I> :: \"('out, 'ret) \\<I>\"\n  and f :: \"'a \\<Rightarrow> ennreal\"\n  notes [[function_internals]]\nbegin"], ["", "partial_function (lfp_strong) expectation_gpv :: \"('a, 'out, 'ret) gpv \\<Rightarrow> ennreal\" where\n  \"expectation_gpv gpv = \n  (\\<integral>\\<^sup>+ generat. (case generat of Pure x \\<Rightarrow> f x \n              | IO out c \\<Rightarrow> INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv (c r)) \\<partial>measure_spmf (the_gpv gpv))\n   + fail * pmf (the_gpv gpv) None\""], ["", "lemma expectation_gpv_fixp_induct [case_names adm bottom step]:\n  assumes \"lfp.admissible P\"\n    and \"P (\\<lambda>_. 0)\"\n    and \"\\<And>expectation_gpv'. \\<lbrakk> \\<And>gpv. expectation_gpv' gpv \\<le> expectation_gpv gpv; P expectation_gpv' \\<rbrakk> \\<Longrightarrow>\n         P (\\<lambda>gpv. (\\<integral>\\<^sup>+ generat. (case generat of Pure x \\<Rightarrow> f x | IO out c \\<Rightarrow> INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) \\<partial>measure_spmf (the_gpv gpv)) + fail * pmf (the_gpv gpv) None)\"\n  shows \"P expectation_gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P local.expectation_gpv", "by(rule expectation_gpv.fixp_induct)(simp_all add: bot_ennreal_def assms fun_ord_def)"], ["", "lemma expectation_gpv_Done [simp]: \"expectation_gpv (Done x) = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.expectation_gpv (Generative_Probabilistic_Value.Done x) = f x", "by(subst expectation_gpv.simps)(simp add: measure_spmf_return_spmf nn_integral_return)"], ["", "lemma expectation_gpv_Fail [simp]: \"expectation_gpv Fail = fail\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.expectation_gpv Fail = fail", "by(subst expectation_gpv.simps) simp"], ["", "lemma expectation_gpv_lift_spmf [simp]: \n  \"expectation_gpv (lift_spmf p) = (\\<integral>\\<^sup>+ x. f x \\<partial>measure_spmf p) + fail * pmf p None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.expectation_gpv (lift_spmf p) =\n    integral\\<^sup>N (measure_spmf p) f + fail * ennreal (pmf p None)", "by(subst expectation_gpv.simps)(auto simp add: o_def pmf_map vimage_def measure_pmf_single)"], ["", "lemma expectation_gpv_Pause [simp]:\n  \"expectation_gpv (Pause out c) = (INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv (c r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.expectation_gpv (Generative_Probabilistic_Value.Pause out c) =\n    (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. local.expectation_gpv (c r))", "by(subst expectation_gpv.simps)(simp add: measure_spmf_return_spmf nn_integral_return)"], ["", "end"], ["", "context begin"], ["", "private"], ["", "definition \"weight_spmf' p = weight_spmf p\""], ["", "lemmas weight_spmf'_parametric = weight_spmf_parametric[folded weight_spmf'_def]"], ["", "lemma expectation_gpv_parametric':\n  includes lifting_syntax notes weight_spmf'_parametric[transfer_rule]\n  shows \"((=) ===> rel_\\<I> C R ===> (A ===> (=)) ===> rel_gpv'' A C R ===> (=)) expectation_gpv expectation_gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> rel_\\<I> C R ===> (A ===> (=)) ===> rel_gpv'' A C R ===> (=))\n     expectation_gpv expectation_gpv", "unfolding expectation_gpv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> rel_\\<I> C R ===> (A ===> (=)) ===> rel_gpv'' A C R ===> (=))\n     (\\<lambda>fail \\<I> f.\n         lfp.fixp_fun\n          (\\<lambda>expectation_gpv gpv.\n              \\<integral>\\<^sup>+ generat.\n                                   (case generat of Pure x \\<Rightarrow> f x\n                                    | IO out c \\<Rightarrow>\n  \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv (c r))\n                                 \\<partial>measure_spmf (the_gpv gpv) +\n              fail * ennreal (pmf (the_gpv gpv) None)))\n     (\\<lambda>fail \\<I> f.\n         lfp.fixp_fun\n          (\\<lambda>expectation_gpv gpv.\n              \\<integral>\\<^sup>+ generat.\n                                   (case generat of Pure x \\<Rightarrow> f x\n                                    | IO out c \\<Rightarrow>\n  \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv (c r))\n                                 \\<partial>measure_spmf (the_gpv gpv) +\n              fail * ennreal (pmf (the_gpv gpv) None)))", "apply(rule rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x = y \\<Longrightarrow>\n       (rel_\\<I> C R ===> (A ===> (=)) ===> rel_gpv'' A C R ===> (=))\n        (\\<lambda>\\<I> f.\n            lfp.fixp_fun\n             (\\<lambda>expectation_gpv gpv.\n                 \\<integral>\\<^sup>+ generat.\n(case generat of Pure x \\<Rightarrow> f x\n | IO out c \\<Rightarrow>\n     \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv (c r))\n                                    \\<partial>measure_spmf (the_gpv gpv) +\n                 x * ennreal (pmf (the_gpv gpv) None)))\n        (\\<lambda>\\<I> f.\n            lfp.fixp_fun\n             (\\<lambda>expectation_gpv gpv.\n                 \\<integral>\\<^sup>+ generat.\n(case generat of Pure x \\<Rightarrow> f x\n | IO out c \\<Rightarrow>\n     \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv (c r))\n                                    \\<partial>measure_spmf (the_gpv gpv) +\n                 y * ennreal (pmf (the_gpv gpv) None)))", "apply(rule rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = y; rel_\\<I> C R xa ya\\<rbrakk>\n       \\<Longrightarrow> ((A ===> (=)) ===> rel_gpv'' A C R ===> (=))\n                          (\\<lambda>f.\n                              lfp.fixp_fun\n                               (\\<lambda>expectation_gpv gpv.\n                                   \\<integral>\\<^sup>+ generat.\n                  (case generat of Pure x \\<Rightarrow> f x\n                   | IO out c \\<Rightarrow>\n                       \\<Sqinter>r\\<in>responses_\\<I> xa out.\n                          expectation_gpv (c r))\n                \\<partial>measure_spmf (the_gpv gpv) +\n                                   x * ennreal (pmf (the_gpv gpv) None)))\n                          (\\<lambda>f.\n                              lfp.fixp_fun\n                               (\\<lambda>expectation_gpv gpv.\n                                   \\<integral>\\<^sup>+ generat.\n                  (case generat of Pure x \\<Rightarrow> f x\n                   | IO out c \\<Rightarrow>\n                       \\<Sqinter>r\\<in>responses_\\<I> ya out.\n                          expectation_gpv (c r))\n                \\<partial>measure_spmf (the_gpv gpv) +\n                                   y * ennreal (pmf (the_gpv gpv) None)))", "apply(rule rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>x = y; rel_\\<I> C R xa ya; (A ===> (=)) xb yb\\<rbrakk>\n       \\<Longrightarrow> (rel_gpv'' A C R ===> (=))\n                          (lfp.fixp_fun\n                            (\\<lambda>expectation_gpv gpv.\n                                \\<integral>\\<^sup>+ generat.\n               (case generat of Pure x \\<Rightarrow> xb x\n                | IO out c \\<Rightarrow>\n                    \\<Sqinter>r\\<in>responses_\\<I> xa out.\n                       expectation_gpv (c r))\n             \\<partial>measure_spmf (the_gpv gpv) +\n                                x * ennreal (pmf (the_gpv gpv) None)))\n                          (lfp.fixp_fun\n                            (\\<lambda>expectation_gpv gpv.\n                                \\<integral>\\<^sup>+ generat.\n               (case generat of Pure x \\<Rightarrow> yb x\n                | IO out c \\<Rightarrow>\n                    \\<Sqinter>r\\<in>responses_\\<I> ya out.\n                       expectation_gpv (c r))\n             \\<partial>measure_spmf (the_gpv gpv) +\n                                y * ennreal (pmf (the_gpv gpv) None)))", "apply(rule fixp_lfp_parametric_eq[OF expectation_gpv.mono expectation_gpv.mono])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>x = y; rel_\\<I> C R xa ya; (A ===> (=)) xb yb\\<rbrakk>\n       \\<Longrightarrow> ((rel_gpv'' A C R ===> (=)) ===>\n                          rel_gpv'' A C R ===> (=))\n                          (\\<lambda>expectation_gpv xaa.\n                              \\<integral>\\<^sup>+ generat.\n             (case generat of Pure x \\<Rightarrow> xb x\n              | IO out c \\<Rightarrow>\n                  \\<Sqinter>r\\<in>responses_\\<I> xa out.\n                     expectation_gpv (c r))\n           \\<partial>measure_spmf (the_gpv xaa) +\n                              x * ennreal (pmf (the_gpv xaa) None))\n                          (\\<lambda>expectation_gpv x.\n                              \\<integral>\\<^sup>+ generat.\n             (case generat of Pure x \\<Rightarrow> yb x\n              | IO out c \\<Rightarrow>\n                  \\<Sqinter>r\\<in>responses_\\<I> ya out.\n                     expectation_gpv (c r))\n           \\<partial>measure_spmf (the_gpv x) +\n                              y * ennreal (pmf (the_gpv x) None))", "apply(fold nn_integral_spmf_def Set.is_empty_def pmf_None_eq_weight_spmf[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>x = y; rel_\\<I> C R xa ya; (A ===> (=)) xb yb\\<rbrakk>\n       \\<Longrightarrow> ((rel_gpv'' A C R ===> (=)) ===>\n                          rel_gpv'' A C R ===> (=))\n                          (\\<lambda>expectation_gpv xaa.\n                              nn_integral_spmf (the_gpv xaa)\n                               (\\<lambda>generat.\n                                   case generat of Pure x \\<Rightarrow> xb x\n                                   | IO out c \\<Rightarrow>\n \\<Sqinter>r\\<in>responses_\\<I> xa out. expectation_gpv (c r)) +\n                              x * ennreal (1 - weight_spmf (the_gpv xaa)))\n                          (\\<lambda>expectation_gpv x.\n                              nn_integral_spmf (the_gpv x)\n                               (\\<lambda>generat.\n                                   case generat of Pure x \\<Rightarrow> yb x\n                                   | IO out c \\<Rightarrow>\n \\<Sqinter>r\\<in>responses_\\<I> ya out. expectation_gpv (c r)) +\n                              y * ennreal (1 - weight_spmf (the_gpv x)))", "apply(simp only: weight_spmf'_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>x = y; rel_\\<I> C R xa ya; (A ===> (=)) xb yb\\<rbrakk>\n       \\<Longrightarrow> ((rel_gpv'' A C R ===> (=)) ===>\n                          rel_gpv'' A C R ===> (=))\n                          (\\<lambda>expectation_gpv x.\n                              nn_integral_spmf (the_gpv x)\n                               (\\<lambda>generat.\n                                   case generat of Pure x \\<Rightarrow> xb x\n                                   | IO out c \\<Rightarrow>\n \\<Sqinter>r\\<in>responses_\\<I> xa out. expectation_gpv (c r)) +\n                              y * ennreal (1 - weight_spmf' (the_gpv x)))\n                          (\\<lambda>expectation_gpv x.\n                              nn_integral_spmf (the_gpv x)\n                               (\\<lambda>generat.\n                                   case generat of Pure x \\<Rightarrow> yb x\n                                   | IO out c \\<Rightarrow>\n \\<Sqinter>r\\<in>responses_\\<I> ya out. expectation_gpv (c r)) +\n                              y * ennreal (1 - weight_spmf' (the_gpv x)))", "subgoal premises [transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_gpv'' A C R ===> (=)) ===> rel_gpv'' A C R ===> (=))\n     (\\<lambda>expectation_gpv x.\n         nn_integral_spmf (the_gpv x)\n          (\\<lambda>generat.\n              case generat of Pure x \\<Rightarrow> xb_ x\n              | IO out c \\<Rightarrow>\n                  \\<Sqinter>r\\<in>responses_\\<I> xa_ out.\n                     expectation_gpv (c r)) +\n         y_ * ennreal (1 - weight_spmf' (the_gpv x)))\n     (\\<lambda>expectation_gpv x.\n         nn_integral_spmf (the_gpv x)\n          (\\<lambda>generat.\n              case generat of Pure x \\<Rightarrow> yb_ x\n              | IO out c \\<Rightarrow>\n                  \\<Sqinter>r\\<in>responses_\\<I> ya_ out.\n                     expectation_gpv (c r)) +\n         y_ * ennreal (1 - weight_spmf' (the_gpv x)))", "supply the_gpv_parametric'[transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_gpv'' A C R ===> (=)) ===> rel_gpv'' A C R ===> (=))\n     (\\<lambda>expectation_gpv x.\n         nn_integral_spmf (the_gpv x)\n          (\\<lambda>generat.\n              case generat of Pure x \\<Rightarrow> xb_ x\n              | IO out c \\<Rightarrow>\n                  \\<Sqinter>r\\<in>responses_\\<I> xa_ out.\n                     expectation_gpv (c r)) +\n         y_ * ennreal (1 - weight_spmf' (the_gpv x)))\n     (\\<lambda>expectation_gpv x.\n         nn_integral_spmf (the_gpv x)\n          (\\<lambda>generat.\n              case generat of Pure x \\<Rightarrow> yb_ x\n              | IO out c \\<Rightarrow>\n                  \\<Sqinter>r\\<in>responses_\\<I> ya_ out.\n                     expectation_gpv (c r)) +\n         y_ * ennreal (1 - weight_spmf' (the_gpv x)))", "by transfer_prover"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma expectation_gpv_parametric [transfer_rule]:\n  includes lifting_syntax\n  shows \"((=) ===> rel_\\<I> C (=) ===> (A ===> (=)) ===> rel_gpv A C ===> (=)) expectation_gpv expectation_gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> rel_\\<I> C (=) ===> (A ===> (=)) ===> rel_gpv A C ===> (=))\n     expectation_gpv expectation_gpv", "using expectation_gpv_parametric'[of C \"(=)\" A]"], ["proof (prove)\nusing this:\n  ((=) ===>\n   rel_\\<I> C (=) ===> (A ===> (=)) ===> rel_gpv'' A C (=) ===> (=))\n   expectation_gpv expectation_gpv\n\ngoal (1 subgoal):\n 1. ((=) ===> rel_\\<I> C (=) ===> (A ===> (=)) ===> rel_gpv A C ===> (=))\n     expectation_gpv expectation_gpv", "by(simp add: rel_gpv_conv_rel_gpv'')"], ["", "lemma expectation_gpv_cong:\n  fixes fail fail'\n  assumes fail: \"fail = fail'\"\n  and \\<I>: \"\\<I> = \\<I>'\"\n  and gpv: \"gpv = gpv'\"\n  and f: \"\\<And>x. x \\<in> results_gpv \\<I>' gpv' \\<Longrightarrow> f x = g x\"\n  shows \"expectation_gpv fail \\<I> f gpv = expectation_gpv fail' \\<I>' g gpv'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> f gpv = expectation_gpv fail' \\<I>' g gpv'", "using f"], ["proof (prove)\nusing this:\n  ?x \\<in> results_gpv \\<I>' gpv' \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> f gpv = expectation_gpv fail' \\<I>' g gpv'", "unfolding \\<I>[symmetric] gpv[symmetric] fail[symmetric]"], ["proof (prove)\nusing this:\n  ?x \\<in> results_gpv \\<I> gpv \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> f gpv = expectation_gpv fail \\<I> g gpv", "proof(induction arbitrary: gpv rule: parallel_fixp_induct_1_1[OF complete_lattice_partial_function_definitions complete_lattice_partial_function_definitions expectation_gpv.mono expectation_gpv.mono expectation_gpv_def expectation_gpv_def, case_names adm bottom step])"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa.\n            (\\<forall>x.\n                x \\<in> results_gpv \\<I> xa \\<longrightarrow>\n                f x = g x) \\<longrightarrow>\n            fst x xa = snd x xa)\n 2. \\<And>gpv.\n       (\\<And>x.\n           x \\<in> results_gpv \\<I> gpv \\<Longrightarrow>\n           f x = g x) \\<Longrightarrow>\n       \\<Squnion> {} = \\<Squnion> {}\n 3. \\<And>fa ga gpv.\n       \\<lbrakk>\\<And>gpv.\n                   (\\<And>x.\n                       x \\<in> results_gpv \\<I> gpv \\<Longrightarrow>\n                       f x = g x) \\<Longrightarrow>\n                   fa gpv = ga gpv;\n        \\<And>x.\n           x \\<in> results_gpv \\<I> gpv \\<Longrightarrow> f x = g x\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   fa (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None) =\n                         integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat g\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   ga (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa.\n            (\\<forall>x.\n                x \\<in> results_gpv \\<I> xa \\<longrightarrow>\n                f x = g x) \\<longrightarrow>\n            fst x xa = snd x xa)\n 2. \\<And>gpv.\n       (\\<And>x.\n           x \\<in> results_gpv \\<I> gpv \\<Longrightarrow>\n           f x = g x) \\<Longrightarrow>\n       \\<Squnion> {} = \\<Squnion> {}\n 3. \\<And>fa ga gpv.\n       \\<lbrakk>\\<And>gpv.\n                   (\\<And>x.\n                       x \\<in> results_gpv \\<I> gpv \\<Longrightarrow>\n                       f x = g x) \\<Longrightarrow>\n                   fa gpv = ga gpv;\n        \\<And>x.\n           x \\<in> results_gpv \\<I> gpv \\<Longrightarrow> f x = g x\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   fa (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None) =\n                         integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat g\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   ga (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa.\n            (\\<forall>x.\n                x \\<in> results_gpv \\<I> xa \\<longrightarrow>\n                f x = g x) \\<longrightarrow>\n            fst x xa = snd x xa)", "by simp"], ["proof (state)\nthis:\n  ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n   (rel_prod lfp.le_fun lfp.le_fun)\n   (\\<lambda>x.\n       \\<forall>xa.\n          (\\<forall>x.\n              x \\<in> results_gpv \\<I> xa \\<longrightarrow>\n              f x = g x) \\<longrightarrow>\n          fst x xa = snd x xa)\n\ngoal (2 subgoals):\n 1. \\<And>gpv.\n       (\\<And>x.\n           x \\<in> results_gpv \\<I> gpv \\<Longrightarrow>\n           f x = g x) \\<Longrightarrow>\n       \\<Squnion> {} = \\<Squnion> {}\n 2. \\<And>fa ga gpv.\n       \\<lbrakk>\\<And>gpv.\n                   (\\<And>x.\n                       x \\<in> results_gpv \\<I> gpv \\<Longrightarrow>\n                       f x = g x) \\<Longrightarrow>\n                   fa gpv = ga gpv;\n        \\<And>x.\n           x \\<in> results_gpv \\<I> gpv \\<Longrightarrow> f x = g x\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   fa (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None) =\n                         integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat g\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   ga (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)", "case bottom"], ["proof (state)\nthis:\n  ?x \\<in> results_gpv \\<I> gpv \\<Longrightarrow> f ?x = g ?x\n\ngoal (2 subgoals):\n 1. \\<And>gpv.\n       (\\<And>x.\n           x \\<in> results_gpv \\<I> gpv \\<Longrightarrow>\n           f x = g x) \\<Longrightarrow>\n       \\<Squnion> {} = \\<Squnion> {}\n 2. \\<And>fa ga gpv.\n       \\<lbrakk>\\<And>gpv.\n                   (\\<And>x.\n                       x \\<in> results_gpv \\<I> gpv \\<Longrightarrow>\n                       f x = g x) \\<Longrightarrow>\n                   fa gpv = ga gpv;\n        \\<And>x.\n           x \\<in> results_gpv \\<I> gpv \\<Longrightarrow> f x = g x\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   fa (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None) =\n                         integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat g\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   ga (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> {} = \\<Squnion> {}", "by simp"], ["proof (state)\nthis:\n  \\<Squnion> {} = \\<Squnion> {}\n\ngoal (1 subgoal):\n 1. \\<And>fa ga gpv.\n       \\<lbrakk>\\<And>gpv.\n                   (\\<And>x.\n                       x \\<in> results_gpv \\<I> gpv \\<Longrightarrow>\n                       f x = g x) \\<Longrightarrow>\n                   fa gpv = ga gpv;\n        \\<And>x.\n           x \\<in> results_gpv \\<I> gpv \\<Longrightarrow> f x = g x\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   fa (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None) =\n                         integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat g\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   ga (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)", "case (step expectation_gpv' expectation_gpv'')"], ["proof (state)\nthis:\n  (\\<And>x.\n      x \\<in> results_gpv \\<I> ?gpv \\<Longrightarrow>\n      f x = g x) \\<Longrightarrow>\n  expectation_gpv' ?gpv = expectation_gpv'' ?gpv\n  ?x \\<in> results_gpv \\<I> gpv \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. \\<And>fa ga gpv.\n       \\<lbrakk>\\<And>gpv.\n                   (\\<And>x.\n                       x \\<in> results_gpv \\<I> gpv \\<Longrightarrow>\n                       f x = g x) \\<Longrightarrow>\n                   fa gpv = ga gpv;\n        \\<And>x.\n           x \\<in> results_gpv \\<I> gpv \\<Longrightarrow> f x = g x\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   fa (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None) =\n                         integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat g\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   ga (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail * ennreal (pmf (the_gpv gpv) None) =\n    \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> g x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv'' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail * ennreal (pmf (the_gpv gpv) None)", "by(rule arg_cong2[where f=\"(+)\"] nn_integral_cong_AE)+(clarsimp simp add: step.prems results_gpv.intros split!: generat.split intro!: INF_cong[OF refl] step.IH)+"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> f x\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  fail * ennreal (pmf (the_gpv gpv) None) =\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> g x\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv'' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  fail * ennreal (pmf (the_gpv gpv) None)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma expectation_gpv_cong_fail:\n  \"colossless_gpv \\<I> gpv \\<Longrightarrow> expectation_gpv fail \\<I> f gpv = expectation_gpv fail' \\<I> f gpv\" for fail"], ["proof (prove)\ngoal (1 subgoal):\n 1. colossless_gpv \\<I> gpv \\<Longrightarrow>\n    expectation_gpv fail \\<I> f gpv = expectation_gpv fail' \\<I> f gpv", "proof(induction arbitrary: gpv rule: parallel_fixp_induct_1_1[OF complete_lattice_partial_function_definitions complete_lattice_partial_function_definitions expectation_gpv.mono expectation_gpv.mono expectation_gpv_def expectation_gpv_def, case_names adm bottom step])"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa.\n            colossless_gpv \\<I> xa \\<longrightarrow> fst x xa = snd x xa)\n 2. \\<And>gpv.\n       colossless_gpv \\<I> gpv \\<Longrightarrow>\n       \\<Squnion> {} = \\<Squnion> {}\n 3. \\<And>fa g gpv.\n       \\<lbrakk>\\<And>gpv.\n                   colossless_gpv \\<I> gpv \\<Longrightarrow> fa gpv = g gpv;\n        colossless_gpv \\<I> gpv\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   fa (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None) =\n                         integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   g (c r))) +\n                         fail' * ennreal (pmf (the_gpv gpv) None)", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa.\n            colossless_gpv \\<I> xa \\<longrightarrow> fst x xa = snd x xa)\n 2. \\<And>gpv.\n       colossless_gpv \\<I> gpv \\<Longrightarrow>\n       \\<Squnion> {} = \\<Squnion> {}\n 3. \\<And>fa g gpv.\n       \\<lbrakk>\\<And>gpv.\n                   colossless_gpv \\<I> gpv \\<Longrightarrow> fa gpv = g gpv;\n        colossless_gpv \\<I> gpv\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   fa (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None) =\n                         integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   g (c r))) +\n                         fail' * ennreal (pmf (the_gpv gpv) None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa.\n            colossless_gpv \\<I> xa \\<longrightarrow> fst x xa = snd x xa)", "by simp"], ["proof (state)\nthis:\n  ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n   (rel_prod lfp.le_fun lfp.le_fun)\n   (\\<lambda>x.\n       \\<forall>xa.\n          colossless_gpv \\<I> xa \\<longrightarrow> fst x xa = snd x xa)\n\ngoal (2 subgoals):\n 1. \\<And>gpv.\n       colossless_gpv \\<I> gpv \\<Longrightarrow>\n       \\<Squnion> {} = \\<Squnion> {}\n 2. \\<And>fa g gpv.\n       \\<lbrakk>\\<And>gpv.\n                   colossless_gpv \\<I> gpv \\<Longrightarrow> fa gpv = g gpv;\n        colossless_gpv \\<I> gpv\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   fa (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None) =\n                         integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   g (c r))) +\n                         fail' * ennreal (pmf (the_gpv gpv) None)", "case bottom"], ["proof (state)\nthis:\n  colossless_gpv \\<I> gpv\n\ngoal (2 subgoals):\n 1. \\<And>gpv.\n       colossless_gpv \\<I> gpv \\<Longrightarrow>\n       \\<Squnion> {} = \\<Squnion> {}\n 2. \\<And>fa g gpv.\n       \\<lbrakk>\\<And>gpv.\n                   colossless_gpv \\<I> gpv \\<Longrightarrow> fa gpv = g gpv;\n        colossless_gpv \\<I> gpv\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   fa (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None) =\n                         integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   g (c r))) +\n                         fail' * ennreal (pmf (the_gpv gpv) None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> {} = \\<Squnion> {}", "by simp"], ["proof (state)\nthis:\n  \\<Squnion> {} = \\<Squnion> {}\n\ngoal (1 subgoal):\n 1. \\<And>fa g gpv.\n       \\<lbrakk>\\<And>gpv.\n                   colossless_gpv \\<I> gpv \\<Longrightarrow> fa gpv = g gpv;\n        colossless_gpv \\<I> gpv\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   fa (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None) =\n                         integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   g (c r))) +\n                         fail' * ennreal (pmf (the_gpv gpv) None)", "case (step expectation_gpv' expectation_gpv'')"], ["proof (state)\nthis:\n  colossless_gpv \\<I> ?gpv \\<Longrightarrow>\n  expectation_gpv' ?gpv = expectation_gpv'' ?gpv\n  colossless_gpv \\<I> gpv\n\ngoal (1 subgoal):\n 1. \\<And>fa g gpv.\n       \\<lbrakk>\\<And>gpv.\n                   colossless_gpv \\<I> gpv \\<Longrightarrow> fa gpv = g gpv;\n        colossless_gpv \\<I> gpv\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   fa (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None) =\n                         integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   g (c r))) +\n                         fail' * ennreal (pmf (the_gpv gpv) None)", "from colossless_gpv_lossless_spmfD[OF step.prems]"], ["proof (chain)\npicking this:\n  lossless_spmf (the_gpv gpv)", "show ?case"], ["proof (prove)\nusing this:\n  lossless_spmf (the_gpv gpv)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail * ennreal (pmf (the_gpv gpv) None) =\n    \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv'' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail' * ennreal (pmf (the_gpv gpv) None)", "by(auto simp add: lossless_iff_pmf_None intro!: nn_integral_cong_AE INF_cong step.IH intro: colossless_gpv_continuationD[OF step.prems] split: generat.split)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> f x\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  fail * ennreal (pmf (the_gpv gpv) None) =\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> f x\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv'' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  fail' * ennreal (pmf (the_gpv gpv) None)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma expectation_gpv_mono:\n  fixes fail fail'\n  assumes fail: \"fail \\<le> fail'\"\n  and fg: \"f \\<le> g\"\n  shows \"expectation_gpv fail \\<I> f gpv \\<le> expectation_gpv fail' \\<I> g gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> f gpv \\<le> expectation_gpv fail' \\<I> g gpv", "proof(induction arbitrary: gpv rule: parallel_fixp_induct_1_1[OF complete_lattice_partial_function_definitions complete_lattice_partial_function_definitions expectation_gpv.mono expectation_gpv.mono expectation_gpv_def expectation_gpv_def, case_names adm bottom step])"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x. \\<forall>xa. fst x xa \\<le> snd x xa)\n 2. \\<And>gpv. \\<Squnion> {} \\<le> \\<Squnion> {}\n 3. \\<And>fa ga gpv.\n       (\\<And>gpv. fa gpv \\<le> ga gpv) \\<Longrightarrow>\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. fa (c r))) +\n       fail * ennreal (pmf (the_gpv gpv) None)\n       \\<le> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n              (case_generat g\n                (\\<lambda>out c.\n                    \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. ga (c r))) +\n             fail' * ennreal (pmf (the_gpv gpv) None)", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x. \\<forall>xa. fst x xa \\<le> snd x xa)\n 2. \\<And>gpv. \\<Squnion> {} \\<le> \\<Squnion> {}\n 3. \\<And>fa ga gpv.\n       (\\<And>gpv. fa gpv \\<le> ga gpv) \\<Longrightarrow>\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. fa (c r))) +\n       fail * ennreal (pmf (the_gpv gpv) None)\n       \\<le> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n              (case_generat g\n                (\\<lambda>out c.\n                    \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. ga (c r))) +\n             fail' * ennreal (pmf (the_gpv gpv) None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x. \\<forall>xa. fst x xa \\<le> snd x xa)", "by simp"], ["proof (state)\nthis:\n  ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n   (rel_prod lfp.le_fun lfp.le_fun)\n   (\\<lambda>x. \\<forall>xa. fst x xa \\<le> snd x xa)\n\ngoal (2 subgoals):\n 1. \\<And>gpv. \\<Squnion> {} \\<le> \\<Squnion> {}\n 2. \\<And>fa ga gpv.\n       (\\<And>gpv. fa gpv \\<le> ga gpv) \\<Longrightarrow>\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. fa (c r))) +\n       fail * ennreal (pmf (the_gpv gpv) None)\n       \\<le> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n              (case_generat g\n                (\\<lambda>out c.\n                    \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. ga (c r))) +\n             fail' * ennreal (pmf (the_gpv gpv) None)", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>gpv. \\<Squnion> {} \\<le> \\<Squnion> {}\n 2. \\<And>fa ga gpv.\n       (\\<And>gpv. fa gpv \\<le> ga gpv) \\<Longrightarrow>\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. fa (c r))) +\n       fail * ennreal (pmf (the_gpv gpv) None)\n       \\<le> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n              (case_generat g\n                (\\<lambda>out c.\n                    \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. ga (c r))) +\n             fail' * ennreal (pmf (the_gpv gpv) None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> {} \\<le> \\<Squnion> {}", "by simp"], ["proof (state)\nthis:\n  \\<Squnion> {} \\<le> \\<Squnion> {}\n\ngoal (1 subgoal):\n 1. \\<And>fa ga gpv.\n       (\\<And>gpv. fa gpv \\<le> ga gpv) \\<Longrightarrow>\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. fa (c r))) +\n       fail * ennreal (pmf (the_gpv gpv) None)\n       \\<le> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n              (case_generat g\n                (\\<lambda>out c.\n                    \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. ga (c r))) +\n             fail' * ennreal (pmf (the_gpv gpv) None)", "case (step expectation_gpv' expectation_gpv'')"], ["proof (state)\nthis:\n  expectation_gpv' ?gpv \\<le> expectation_gpv'' ?gpv\n\ngoal (1 subgoal):\n 1. \\<And>fa ga gpv.\n       (\\<And>gpv. fa gpv \\<le> ga gpv) \\<Longrightarrow>\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. fa (c r))) +\n       fail * ennreal (pmf (the_gpv gpv) None)\n       \\<le> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n              (case_generat g\n                (\\<lambda>out c.\n                    \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. ga (c r))) +\n             fail' * ennreal (pmf (the_gpv gpv) None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail * ennreal (pmf (the_gpv gpv) None)\n    \\<le> \\<integral>\\<^sup>+ generat.\n                               (case generat of Pure x \\<Rightarrow> g x\n                                | IO out c \\<Rightarrow>\n                                    \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n expectation_gpv'' (c r))\n                             \\<partial>measure_spmf (the_gpv gpv) +\n          fail' * ennreal (pmf (the_gpv gpv) None)", "by(intro add_mono mult_right_mono fail nn_integral_mono_AE)\n      (auto split: generat.split simp add: fg[THEN le_funD] INF_mono rev_bexI step.IH)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> f x\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  fail * ennreal (pmf (the_gpv gpv) None)\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (case generat of Pure x \\<Rightarrow> g x\n                              | IO out c \\<Rightarrow>\n                                  \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                     expectation_gpv'' (c r))\n                           \\<partial>measure_spmf (the_gpv gpv) +\n        fail' * ennreal (pmf (the_gpv gpv) None)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma expectation_gpv_mono_strong:\n  fixes fail fail'\n  assumes fail: \"\\<not> colossless_gpv \\<I> gpv \\<Longrightarrow> fail \\<le> fail'\"\n  and fg: \"\\<And>x. x \\<in> results_gpv \\<I> gpv \\<Longrightarrow> f x \\<le> g x\"\n  shows \"expectation_gpv fail \\<I> f gpv \\<le> expectation_gpv fail' \\<I> g gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> f gpv \\<le> expectation_gpv fail' \\<I> g gpv", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> f gpv \\<le> expectation_gpv fail' \\<I> g gpv", "let ?fail = \"if colossless_gpv \\<I> gpv then fail' else fail\"\n    and ?f = \"\\<lambda>x. if x \\<in> results_gpv \\<I> gpv then f x else g x\""], ["proof (state)\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> f gpv \\<le> expectation_gpv fail' \\<I> g gpv", "have \"expectation_gpv fail \\<I> f gpv = expectation_gpv ?fail \\<I> f gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> f gpv =\n    expectation_gpv (if colossless_gpv \\<I> gpv then fail' else fail) \\<I> f\n     gpv", "by(simp cong: expectation_gpv_cong_fail)"], ["proof (state)\nthis:\n  expectation_gpv fail \\<I> f gpv =\n  expectation_gpv (if colossless_gpv \\<I> gpv then fail' else fail) \\<I> f\n   gpv\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> f gpv \\<le> expectation_gpv fail' \\<I> g gpv", "also"], ["proof (state)\nthis:\n  expectation_gpv fail \\<I> f gpv =\n  expectation_gpv (if colossless_gpv \\<I> gpv then fail' else fail) \\<I> f\n   gpv\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> f gpv \\<le> expectation_gpv fail' \\<I> g gpv", "have \"\\<dots> = expectation_gpv ?fail \\<I> ?f gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv (if colossless_gpv \\<I> gpv then fail' else fail) \\<I> f\n     gpv =\n    expectation_gpv (if colossless_gpv \\<I> gpv then fail' else fail) \\<I>\n     (\\<lambda>x. if x \\<in> results_gpv \\<I> gpv then f x else g x) gpv", "by(rule expectation_gpv_cong; simp)"], ["proof (state)\nthis:\n  expectation_gpv (if colossless_gpv \\<I> gpv then fail' else fail) \\<I> f\n   gpv =\n  expectation_gpv (if colossless_gpv \\<I> gpv then fail' else fail) \\<I>\n   (\\<lambda>x. if x \\<in> results_gpv \\<I> gpv then f x else g x) gpv\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> f gpv \\<le> expectation_gpv fail' \\<I> g gpv", "also"], ["proof (state)\nthis:\n  expectation_gpv (if colossless_gpv \\<I> gpv then fail' else fail) \\<I> f\n   gpv =\n  expectation_gpv (if colossless_gpv \\<I> gpv then fail' else fail) \\<I>\n   (\\<lambda>x. if x \\<in> results_gpv \\<I> gpv then f x else g x) gpv\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> f gpv \\<le> expectation_gpv fail' \\<I> g gpv", "have \"\\<dots> \\<le> expectation_gpv fail' \\<I> g gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv (if colossless_gpv \\<I> gpv then fail' else fail) \\<I>\n     (\\<lambda>x. if x \\<in> results_gpv \\<I> gpv then f x else g x) gpv\n    \\<le> expectation_gpv fail' \\<I> g gpv", "using assms"], ["proof (prove)\nusing this:\n  \\<not> colossless_gpv \\<I> gpv \\<Longrightarrow> fail \\<le> fail'\n  ?x \\<in> results_gpv \\<I> gpv \\<Longrightarrow> f ?x \\<le> g ?x\n\ngoal (1 subgoal):\n 1. expectation_gpv (if colossless_gpv \\<I> gpv then fail' else fail) \\<I>\n     (\\<lambda>x. if x \\<in> results_gpv \\<I> gpv then f x else g x) gpv\n    \\<le> expectation_gpv fail' \\<I> g gpv", "by(simp add: expectation_gpv_mono le_fun_def)"], ["proof (state)\nthis:\n  expectation_gpv (if colossless_gpv \\<I> gpv then fail' else fail) \\<I>\n   (\\<lambda>x. if x \\<in> results_gpv \\<I> gpv then f x else g x) gpv\n  \\<le> expectation_gpv fail' \\<I> g gpv\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> f gpv \\<le> expectation_gpv fail' \\<I> g gpv", "finally"], ["proof (chain)\npicking this:\n  expectation_gpv fail \\<I> f gpv \\<le> expectation_gpv fail' \\<I> g gpv", "show ?thesis"], ["proof (prove)\nusing this:\n  expectation_gpv fail \\<I> f gpv \\<le> expectation_gpv fail' \\<I> g gpv\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> f gpv \\<le> expectation_gpv fail' \\<I> g gpv", "."], ["proof (state)\nthis:\n  expectation_gpv fail \\<I> f gpv \\<le> expectation_gpv fail' \\<I> g gpv\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma expectation_gpv_bind [simp]:\n  fixes \\<I> f g fail\n  defines \"expectation_gpv1 \\<equiv> expectation_gpv fail \\<I> f\"\n  and \"expectation_gpv2 \\<equiv> expectation_gpv fail \\<I> (expectation_gpv fail \\<I> f \\<circ> g)\"\n  shows \"expectation_gpv1 (bind_gpv gpv g) = expectation_gpv2 gpv\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv1 (gpv \\<bind> g) = expectation_gpv2 gpv", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. expectation_gpv1 (gpv \\<bind> g) \\<le> expectation_gpv2 gpv\n 2. expectation_gpv2 gpv \\<le> expectation_gpv1 (gpv \\<bind> g)", "note [simp] = case_map_generat o_def\n    and [cong del] = generat.case_cong_weak"], ["proof (state)\nthis:\n  (case map_generat ?a ?b ?d ?r of Pure x \\<Rightarrow> pure x\n   | IO x xa \\<Rightarrow> ?io x xa) =\n  (case ?r of Pure x \\<Rightarrow> (pure \\<circ> ?a) x\n   | IO out x \\<Rightarrow> (?io (?b out) \\<circ> ?d) x)\n  ?f \\<circ> ?g = (\\<lambda>x. ?f (?g x))\n  ?generat = ?generat' \\<Longrightarrow>\n  (case ?generat of Pure x \\<Rightarrow> ?f1.0 x\n   | IO x xa \\<Rightarrow> ?f2.0 x xa) =\n  (case ?generat' of Pure x \\<Rightarrow> ?f1.0 x\n   | IO x xa \\<Rightarrow> ?f2.0 x xa)\n\ngoal (2 subgoals):\n 1. expectation_gpv1 (gpv \\<bind> g) \\<le> expectation_gpv2 gpv\n 2. expectation_gpv2 gpv \\<le> expectation_gpv1 (gpv \\<bind> g)", "show \"?lhs \\<le> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv1 (gpv \\<bind> g) \\<le> expectation_gpv2 gpv", "unfolding expectation_gpv1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> f (gpv \\<bind> g) \\<le> expectation_gpv2 gpv", "proof(induction arbitrary: gpv rule: expectation_gpv_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a. \\<forall>x. a (x \\<bind> g) \\<le> expectation_gpv2 x)\n 2. \\<And>gpv. 0 \\<le> expectation_gpv2 gpv\n 3. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> f gpv;\n        \\<And>gpv.\n           expectation_gpv' (gpv \\<bind> g)\n           \\<le> expectation_gpv2 gpv\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N\n                          (measure_spmf (the_gpv (gpv \\<bind> g)))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv (gpv \\<bind> g)) None)\n                         \\<le> expectation_gpv2 gpv", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a. \\<forall>x. a (x \\<bind> g) \\<le> expectation_gpv2 x)\n 2. \\<And>gpv. 0 \\<le> expectation_gpv2 gpv\n 3. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> f gpv;\n        \\<And>gpv.\n           expectation_gpv' (gpv \\<bind> g)\n           \\<le> expectation_gpv2 gpv\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N\n                          (measure_spmf (the_gpv (gpv \\<bind> g)))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv (gpv \\<bind> g)) None)\n                         \\<le> expectation_gpv2 gpv", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp.admissible\n     (\\<lambda>a. \\<forall>x. a (x \\<bind> g) \\<le> expectation_gpv2 x)", "by simp"], ["proof (state)\nthis:\n  lfp.admissible\n   (\\<lambda>a. \\<forall>x. a (x \\<bind> g) \\<le> expectation_gpv2 x)\n\ngoal (2 subgoals):\n 1. \\<And>gpv. 0 \\<le> expectation_gpv2 gpv\n 2. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> f gpv;\n        \\<And>gpv.\n           expectation_gpv' (gpv \\<bind> g)\n           \\<le> expectation_gpv2 gpv\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N\n                          (measure_spmf (the_gpv (gpv \\<bind> g)))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv (gpv \\<bind> g)) None)\n                         \\<le> expectation_gpv2 gpv", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>gpv. 0 \\<le> expectation_gpv2 gpv\n 2. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> f gpv;\n        \\<And>gpv.\n           expectation_gpv' (gpv \\<bind> g)\n           \\<le> expectation_gpv2 gpv\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N\n                          (measure_spmf (the_gpv (gpv \\<bind> g)))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv (gpv \\<bind> g)) None)\n                         \\<le> expectation_gpv2 gpv", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> expectation_gpv2 gpv", "by simp"], ["proof (state)\nthis:\n  0 \\<le> expectation_gpv2 gpv\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> f gpv;\n        \\<And>gpv.\n           expectation_gpv' (gpv \\<bind> g)\n           \\<le> expectation_gpv2 gpv\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N\n                          (measure_spmf (the_gpv (gpv \\<bind> g)))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv (gpv \\<bind> g)) None)\n                         \\<le> expectation_gpv2 gpv", "case (step expectation_gpv')"], ["proof (state)\nthis:\n  expectation_gpv' ?gpv \\<le> expectation_gpv fail \\<I> f ?gpv\n  expectation_gpv' (?gpv \\<bind> g) \\<le> expectation_gpv2 ?gpv\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> f gpv;\n        \\<And>gpv.\n           expectation_gpv' (gpv \\<bind> g)\n           \\<le> expectation_gpv2 gpv\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N\n                          (measure_spmf (the_gpv (gpv \\<bind> g)))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv (gpv \\<bind> g)) None)\n                         \\<le> expectation_gpv2 gpv", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv (gpv \\<bind> g)) +\n    fail * ennreal (pmf (the_gpv (gpv \\<bind> g)) None)\n    \\<le> expectation_gpv2 gpv", "unfolding expectation_gpv2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv (gpv \\<bind> g)) +\n    fail * ennreal (pmf (the_gpv (gpv \\<bind> g)) None)\n    \\<le> expectation_gpv fail \\<I> (expectation_gpv fail \\<I> f \\<circ> g)\n           gpv", "apply(rewrite bind_gpv.sel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf\n                                  (map_spmf\n                                    (map_generat id id\n((\\<circ>) (case_sum id (\\<lambda>r. r \\<bind> g))))\n                                    (the_gpv gpv \\<bind>\n                                     case_generat\n(\\<lambda>x. map_spmf (map_generat id id ((\\<circ>) Inl)) (the_gpv (g x)))\n(\\<lambda>out c. return_spmf (IO out (\\<lambda>input. Inr (c input)))))) +\n    fail * ennreal (pmf (the_gpv (gpv \\<bind> g)) None)\n    \\<le> expectation_gpv fail \\<I> (expectation_gpv fail \\<I> f \\<circ> g)\n           gpv", "apply(simp add: map_spmf_bind_spmf measure_spmf_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) \\<bind>\n                                 (\\<lambda>x.\n                                     measure_spmf\n(map_spmf\n  (map_generat id id ((\\<circ>) (case_sum id (\\<lambda>r. r \\<bind> g))))\n  (case x of\n   Pure x \\<Rightarrow>\n     map_spmf (map_generat id id ((\\<circ>) Inl)) (the_gpv (g x))\n   | IO out c \\<Rightarrow>\n       return_spmf (IO out (\\<lambda>input. Inr (c input)))))) +\n    fail *\n    ennreal\n     (pmf (the_gpv gpv \\<bind>\n           (\\<lambda>generat.\n               if is_Pure generat then the_gpv (g (generat.result generat))\n               else return_spmf\n                     (IO (generat.output generat)\n                       (\\<lambda>input.\n                           continuation generat input \\<bind> g))))\n       None)\n    \\<le> expectation_gpv fail \\<I>\n           (\\<lambda>x. expectation_gpv fail \\<I> f (g x)) gpv", "apply(rewrite nn_integral_bind[where B=\"measure_spmf _\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>generat.\n        case generat of Pure x \\<Rightarrow> f x\n        | IO out c \\<Rightarrow>\n            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<in> borel_measurable (measure_spmf ?uu37)\n 2. (\\<lambda>x.\n        measure_spmf\n         (map_spmf\n           (map_generat id id\n             ((\\<circ>) (case_sum id (\\<lambda>r. r \\<bind> g))))\n           (case x of\n            Pure x \\<Rightarrow>\n              map_spmf (map_generat id id ((\\<circ>) Inl)) (the_gpv (g x))\n            | IO out c \\<Rightarrow>\n                return_spmf (IO out (\\<lambda>input. Inr (c input))))))\n    \\<in> measure_spmf (the_gpv gpv) \\<rightarrow>\\<^sub>M\n          subprob_algebra (measure_spmf ?uu37)\n 3. \\<integral>\\<^sup>+ generat.\n                         \\<integral>\\<^sup>+ y.\n        (case y of Pure x \\<Rightarrow> f x\n         | IO out c \\<Rightarrow>\n             \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                expectation_gpv' (c r))\n      \\<partial>measure_spmf\n                 (map_spmf\n                   (map_generat id id\n                     ((\\<circ>) (case_sum id (\\<lambda>r. r \\<bind> g))))\n                   (case generat of\n                    Pure x \\<Rightarrow>\n                      map_spmf (map_generat id id ((\\<circ>) Inl))\n                       (the_gpv (g x))\n                    | IO out c \\<Rightarrow>\n                        return_spmf\n                         (IO out (\\<lambda>input. Inr (c input)))))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail *\n    ennreal\n     (pmf (the_gpv gpv \\<bind>\n           (\\<lambda>generat.\n               if is_Pure generat then the_gpv (g (generat.result generat))\n               else return_spmf\n                     (IO (generat.output generat)\n                       (\\<lambda>input.\n                           continuation generat input \\<bind> g))))\n       None)\n    \\<le> expectation_gpv fail \\<I>\n           (\\<lambda>x. expectation_gpv fail \\<I> f (g x)) gpv", "apply(simp_all add: space_subprob_algebra)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         \\<integral>\\<^sup>+ x.\n        (case map_generat id id\n               ((\\<circ>) (case_sum id (\\<lambda>r. r \\<bind> g))) x of\n         Pure x \\<Rightarrow> f x\n         | IO out c \\<Rightarrow>\n             \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                expectation_gpv' (c r))\n      \\<partial>measure_spmf\n                 (case generat of\n                  Pure x \\<Rightarrow>\n                    map_spmf (map_generat id id ((\\<circ>) Inl))\n                     (the_gpv (g x))\n                  | IO out c \\<Rightarrow>\n                      return_spmf (IO out (\\<lambda>input. Inr (c input))))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail *\n    ennreal\n     (pmf (the_gpv gpv \\<bind>\n           (\\<lambda>generat.\n               if is_Pure generat then the_gpv (g (generat.result generat))\n               else return_spmf\n                     (IO (generat.output generat)\n                       (\\<lambda>input.\n                           continuation generat input \\<bind> g))))\n       None)\n    \\<le> expectation_gpv fail \\<I>\n           (\\<lambda>x. expectation_gpv fail \\<I> f (g x)) gpv", "apply(rewrite expectation_gpv.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         \\<integral>\\<^sup>+ x.\n        (case map_generat id id\n               ((\\<circ>) (case_sum id (\\<lambda>r. r \\<bind> g))) x of\n         Pure x \\<Rightarrow> f x\n         | IO out c \\<Rightarrow>\n             \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                expectation_gpv' (c r))\n      \\<partial>measure_spmf\n                 (case generat of\n                  Pure x \\<Rightarrow>\n                    map_spmf (map_generat id id ((\\<circ>) Inl))\n                     (the_gpv (g x))\n                  | IO out c \\<Rightarrow>\n                      return_spmf (IO out (\\<lambda>input. Inr (c input))))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail *\n    ennreal\n     (pmf (the_gpv gpv \\<bind>\n           (\\<lambda>generat.\n               if is_Pure generat then the_gpv (g (generat.result generat))\n               else return_spmf\n                     (IO (generat.output generat)\n                       (\\<lambda>input.\n                           continuation generat input \\<bind> g))))\n       None)\n    \\<le> \\<integral>\\<^sup>+ generat.\n                               (case generat of\n                                Pure x \\<Rightarrow>\n                                  expectation_gpv fail \\<I> f (g x)\n                                | IO out c \\<Rightarrow>\n                                    \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n expectation_gpv fail \\<I> (\\<lambda>x. expectation_gpv fail \\<I> f (g x))\n  (c r))\n                             \\<partial>measure_spmf (the_gpv gpv) +\n          fail * ennreal (pmf (the_gpv gpv) None)", "apply(simp add: pmf_bind_spmf_None distrib_left nn_integral_eq_integral[symmetric] measure_spmf.integrable_const_bound[where B=1] pmf_le_1 nn_integral_cmult[symmetric] nn_integral_add[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. fail * ennreal (pmf (the_gpv gpv) None) = \\<top> \\<or>\n    \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ x.\n          (case map_generat id id\n                 ((\\<circ>) (case_sum id (\\<lambda>r. r \\<bind> g))) x of\n           Pure x \\<Rightarrow> f x\n           | IO out c \\<Rightarrow>\n               \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                  expectation_gpv' (c r))\n        \\<partial>measure_spmf\n                   (case x of\n                    Pure x \\<Rightarrow>\n                      map_spmf (map_generat id id ((\\<circ>) Inl))\n                       (the_gpv (g x))\n                    | IO out c \\<Rightarrow>\n                        return_spmf\n                         (IO out (\\<lambda>input. Inr (c input)))) +\n                           fail *\n                           ennreal\n                            (pmf (if is_Pure x\n                                  then the_gpv (g (generat.result x))\n                                  else return_spmf\n  (IO (generat.output x) (\\<lambda>input. continuation x input \\<bind> g)))\n                              None)\n                       \\<partial>measure_spmf (the_gpv gpv)\n    \\<le> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n           (case_generat (\\<lambda>x. expectation_gpv fail \\<I> f (g x))\n             (\\<lambda>out c.\n                 \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                    expectation_gpv fail \\<I>\n                     (\\<lambda>x. expectation_gpv fail \\<I> f (g x)) (c r)))", "apply(rule disjI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ x.\n          (case map_generat id id\n                 ((\\<circ>) (case_sum id (\\<lambda>r. r \\<bind> g))) x of\n           Pure x \\<Rightarrow> f x\n           | IO out c \\<Rightarrow>\n               \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                  expectation_gpv' (c r))\n        \\<partial>measure_spmf\n                   (case x of\n                    Pure x \\<Rightarrow>\n                      map_spmf (map_generat id id ((\\<circ>) Inl))\n                       (the_gpv (g x))\n                    | IO out c \\<Rightarrow>\n                        return_spmf\n                         (IO out (\\<lambda>input. Inr (c input)))) +\n                           fail *\n                           ennreal\n                            (pmf (if is_Pure x\n                                  then the_gpv (g (generat.result x))\n                                  else return_spmf\n  (IO (generat.output x) (\\<lambda>input. continuation x input \\<bind> g)))\n                              None)\n                       \\<partial>measure_spmf (the_gpv gpv)\n    \\<le> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n           (case_generat (\\<lambda>x. expectation_gpv fail \\<I> f (g x))\n             (\\<lambda>out c.\n                 \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                    expectation_gpv fail \\<I>\n                     (\\<lambda>x. expectation_gpv fail \\<I> f (g x)) (c r)))", "apply(rule nn_integral_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. (case map_generat id id\n                                     ((\\<circ>)\n (case_sum id (\\<lambda>r. r \\<bind> g)))\n                                     x of\n                               Pure x \\<Rightarrow> f x\n                               | IO out c \\<Rightarrow>\n                                   \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\nexpectation_gpv' (c r))\n                          \\<partial>measure_spmf\n                                     (case x of\nPure x \\<Rightarrow>\n  map_spmf (map_generat id id ((\\<circ>) Inl)) (the_gpv (g x))\n| IO out c \\<Rightarrow>\n    return_spmf (IO out (\\<lambda>input. Inr (c input)))) +\n       fail *\n       ennreal\n        (pmf (if is_Pure x then the_gpv (g (generat.result x))\n              else return_spmf\n                    (IO (generat.output x)\n                      (\\<lambda>input. continuation x input \\<bind> g)))\n          None)\n       \\<le> (case x of\n              Pure x \\<Rightarrow> expectation_gpv fail \\<I> f (g x)\n              | IO out c \\<Rightarrow>\n                  \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                     expectation_gpv fail \\<I>\n                      (\\<lambda>x. expectation_gpv fail \\<I> f (g x)) (c r))", "apply(clarsimp split!: generat.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       Pure x1 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. (case map_generat id id\n                                     ((\\<circ>)\n (case_sum id (\\<lambda>r. r \\<bind> g)))\n                                     (map_generat id id ((\\<circ>) Inl)\n x) of\n                               Pure x \\<Rightarrow> f x\n                               | IO out c \\<Rightarrow>\n                                   \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\nexpectation_gpv' (c r))\n                          \\<partial>measure_spmf (the_gpv (g x1)) +\n       fail * ennreal (pmf (the_gpv (g x1)) None)\n       \\<le> expectation_gpv fail \\<I> f (g x1)\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. (case map_generat id id\n                                     ((\\<circ>)\n (case_sum id (\\<lambda>r. r \\<bind> g)))\n                                     x of\n                               Pure x \\<Rightarrow> f x\n                               | IO out c \\<Rightarrow>\n                                   \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\nexpectation_gpv' (c r))\n                          \\<partial>measure_spmf\n                                     (return_spmf\n (IO x21 (\\<lambda>input. Inr (x22 input))))\n       \\<le> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                 expectation_gpv fail \\<I>\n                  (\\<lambda>x. expectation_gpv fail \\<I> f (g x)) (x22 r))", "apply(rewrite expectation_gpv.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       Pure x1 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. (case map_generat id id\n                                     ((\\<circ>)\n (case_sum id (\\<lambda>r. r \\<bind> g)))\n                                     (map_generat id id ((\\<circ>) Inl)\n x) of\n                               Pure x \\<Rightarrow> f x\n                               | IO out c \\<Rightarrow>\n                                   \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\nexpectation_gpv' (c r))\n                          \\<partial>measure_spmf (the_gpv (g x1)) +\n       fail * ennreal (pmf (the_gpv (g x1)) None)\n       \\<le> \\<integral>\\<^sup>+ generat.\n                                  (case generat of Pure x \\<Rightarrow> f x\n                                   | IO out c \\<Rightarrow>\n \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv fail \\<I> f (c r))\n                                \\<partial>measure_spmf (the_gpv (g x1)) +\n             fail * ennreal (pmf (the_gpv (g x1)) None)\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. (case map_generat id id\n                                     ((\\<circ>)\n (case_sum id (\\<lambda>r. r \\<bind> g)))\n                                     x of\n                               Pure x \\<Rightarrow> f x\n                               | IO out c \\<Rightarrow>\n                                   \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\nexpectation_gpv' (c r))\n                          \\<partial>measure_spmf\n                                     (return_spmf\n (IO x21 (\\<lambda>input. Inr (x22 input))))\n       \\<le> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                 expectation_gpv fail \\<I>\n                  (\\<lambda>x. expectation_gpv fail \\<I> f (g x)) (x22 r))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       Pure x1 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       fail * ennreal (pmf (the_gpv (g x1)) None) = \\<top> \\<or>\n       \\<integral>\\<^sup>+ x. (case map_generat id id\n                                     ((\\<circ>)\n (case_sum id (\\<lambda>r. r \\<bind> g)))\n                                     (map_generat id id ((\\<circ>) Inl)\n x) of\n                               Pure x \\<Rightarrow> f x\n                               | IO out c \\<Rightarrow>\n                                   \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\nexpectation_gpv' (c r))\n                          \\<partial>measure_spmf (the_gpv (g x1))\n       \\<le> integral\\<^sup>N (measure_spmf (the_gpv (g x1)))\n              (case_generat f\n                (\\<lambda>out c.\n                    \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv fail \\<I> f (c r)))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. (case map_generat id id\n                                     ((\\<circ>)\n (case_sum id (\\<lambda>r. r \\<bind> g)))\n                                     x of\n                               Pure x \\<Rightarrow> f x\n                               | IO out c \\<Rightarrow>\n                                   \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\nexpectation_gpv' (c r))\n                          \\<partial>measure_spmf\n                                     (return_spmf\n (IO x21 (\\<lambda>input. Inr (x22 input))))\n       \\<le> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                 expectation_gpv fail \\<I>\n                  (\\<lambda>x. expectation_gpv fail \\<I> f (g x)) (x22 r))", "apply(rule disjI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       Pure x1 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. (case map_generat id id\n                                     ((\\<circ>)\n (case_sum id (\\<lambda>r. r \\<bind> g)))\n                                     (map_generat id id ((\\<circ>) Inl)\n x) of\n                               Pure x \\<Rightarrow> f x\n                               | IO out c \\<Rightarrow>\n                                   \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\nexpectation_gpv' (c r))\n                          \\<partial>measure_spmf (the_gpv (g x1))\n       \\<le> integral\\<^sup>N (measure_spmf (the_gpv (g x1)))\n              (case_generat f\n                (\\<lambda>out c.\n                    \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv fail \\<I> f (c r)))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. (case map_generat id id\n                                     ((\\<circ>)\n (case_sum id (\\<lambda>r. r \\<bind> g)))\n                                     x of\n                               Pure x \\<Rightarrow> f x\n                               | IO out c \\<Rightarrow>\n                                   \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\nexpectation_gpv' (c r))\n                          \\<partial>measure_spmf\n                                     (return_spmf\n (IO x21 (\\<lambda>input. Inr (x22 input))))\n       \\<le> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                 expectation_gpv fail \\<I>\n                  (\\<lambda>x. expectation_gpv fail \\<I> f (g x)) (x22 r))", "apply(rule nn_integral_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x.\n       \\<lbrakk>Pure x1 \\<in> space (measure_spmf (the_gpv gpv));\n        x \\<in> space (measure_spmf (the_gpv (g x1)))\\<rbrakk>\n       \\<Longrightarrow> (case map_generat id id\n                                ((\\<circ>)\n                                  (case_sum id (\\<lambda>r. r \\<bind> g)))\n                                (map_generat id id ((\\<circ>) Inl) x) of\n                          Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> (case x of Pure x \\<Rightarrow> f x\n                                | IO out c \\<Rightarrow>\n                                    \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n expectation_gpv fail \\<I> f (c r))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. (case map_generat id id\n                                     ((\\<circ>)\n (case_sum id (\\<lambda>r. r \\<bind> g)))\n                                     x of\n                               Pure x \\<Rightarrow> f x\n                               | IO out c \\<Rightarrow>\n                                   \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\nexpectation_gpv' (c r))\n                          \\<partial>measure_spmf\n                                     (return_spmf\n (IO x21 (\\<lambda>input. Inr (x22 input))))\n       \\<le> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                 expectation_gpv fail \\<I>\n                  (\\<lambda>x. expectation_gpv fail \\<I> f (g x)) (x22 r))", "apply(clarsimp split: generat.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x21 x22.\n       \\<lbrakk>Pure x1 \\<in> space (measure_spmf (the_gpv gpv));\n        IO x21 x22 \\<in> space (measure_spmf (the_gpv (g x1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                                   expectation_gpv fail \\<I> f (x22 r))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. (case map_generat id id\n                                     ((\\<circ>)\n (case_sum id (\\<lambda>r. r \\<bind> g)))\n                                     x of\n                               Pure x \\<Rightarrow> f x\n                               | IO out c \\<Rightarrow>\n                                   \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\nexpectation_gpv' (c r))\n                          \\<partial>measure_spmf\n                                     (return_spmf\n (IO x21 (\\<lambda>input. Inr (x22 input))))\n       \\<le> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                 expectation_gpv fail \\<I>\n                  (\\<lambda>x. expectation_gpv fail \\<I> f (g x)) (x22 r))", "apply(rule INF_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x21 x22 m.\n       \\<lbrakk>Pure x1 \\<in> space (measure_spmf (the_gpv gpv));\n        IO x21 x22 \\<in> space (measure_spmf (the_gpv (g x1)));\n        m \\<in> responses_\\<I> \\<I> x21\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r\\<in>responses_\\<I> \\<I> x21.\n                            expectation_gpv' (x22 r)\n                            \\<le> expectation_gpv fail \\<I> f (x22 m)\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. (case map_generat id id\n                                     ((\\<circ>)\n (case_sum id (\\<lambda>r. r \\<bind> g)))\n                                     x of\n                               Pure x \\<Rightarrow> f x\n                               | IO out c \\<Rightarrow>\n                                   \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\nexpectation_gpv' (c r))\n                          \\<partial>measure_spmf\n                                     (return_spmf\n (IO x21 (\\<lambda>input. Inr (x22 input))))\n       \\<le> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                 expectation_gpv fail \\<I>\n                  (\\<lambda>x. expectation_gpv fail \\<I> f (g x)) (x22 r))", "apply(erule rev_bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x21 x22 m.\n       \\<lbrakk>Pure x1 \\<in> space (measure_spmf (the_gpv gpv));\n        IO x21 x22 \\<in> space (measure_spmf (the_gpv (g x1)))\\<rbrakk>\n       \\<Longrightarrow> expectation_gpv' (x22 m)\n                         \\<le> expectation_gpv fail \\<I> f (x22 m)\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. (case map_generat id id\n                                     ((\\<circ>)\n (case_sum id (\\<lambda>r. r \\<bind> g)))\n                                     x of\n                               Pure x \\<Rightarrow> f x\n                               | IO out c \\<Rightarrow>\n                                   \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\nexpectation_gpv' (c r))\n                          \\<partial>measure_spmf\n                                     (return_spmf\n (IO x21 (\\<lambda>input. Inr (x22 input))))\n       \\<le> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                 expectation_gpv fail \\<I>\n                  (\\<lambda>x. expectation_gpv fail \\<I> f (g x)) (x22 r))", "apply(rule step.hyps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. (case map_generat id id\n                                     ((\\<circ>)\n (case_sum id (\\<lambda>r. r \\<bind> g)))\n                                     x of\n                               Pure x \\<Rightarrow> f x\n                               | IO out c \\<Rightarrow>\n                                   \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\nexpectation_gpv' (c r))\n                          \\<partial>measure_spmf\n                                     (return_spmf\n (IO x21 (\\<lambda>input. Inr (x22 input))))\n       \\<le> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                 expectation_gpv fail \\<I>\n                  (\\<lambda>x. expectation_gpv fail \\<I> f (g x)) (x22 r))", "apply(clarsimp simp add: measure_spmf_return_spmf nn_integral_return)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       (\\<Sqinter>x\\<in>responses_\\<I> \\<I> x21.\n           expectation_gpv' (x22 x \\<bind> g))\n       \\<le> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                 expectation_gpv fail \\<I>\n                  (\\<lambda>x. expectation_gpv fail \\<I> f (g x)) (x22 r))", "apply(rule INF_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 m.\n       \\<lbrakk>IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv));\n        m \\<in> responses_\\<I> \\<I> x21\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>responses_\\<I> \\<I> x21.\n                            expectation_gpv' (x22 x \\<bind> g)\n                            \\<le> expectation_gpv fail \\<I>\n                                   (\\<lambda>x.\n expectation_gpv fail \\<I> f (g x))\n                                   (x22 m)", "apply(erule rev_bexI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 m.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       expectation_gpv' (x22 m \\<bind> g)\n       \\<le> expectation_gpv fail \\<I>\n              (\\<lambda>x. expectation_gpv fail \\<I> f (g x)) (x22 m)", "apply(rule step.IH[unfolded expectation_gpv2_def o_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> f x\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv (gpv \\<bind> g)) +\n  fail * ennreal (pmf (the_gpv (gpv \\<bind> g)) None)\n  \\<le> expectation_gpv2 gpv\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  expectation_gpv1 (gpv \\<bind> g) \\<le> expectation_gpv2 gpv\n\ngoal (1 subgoal):\n 1. expectation_gpv2 gpv \\<le> expectation_gpv1 (gpv \\<bind> g)", "show \"?rhs \\<le> ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv2 gpv \\<le> expectation_gpv1 (gpv \\<bind> g)", "unfolding expectation_gpv2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (expectation_gpv fail \\<I> f \\<circ> g) gpv\n    \\<le> expectation_gpv1 (gpv \\<bind> g)", "proof(induction arbitrary: gpv rule: expectation_gpv_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a. \\<forall>x. a x \\<le> expectation_gpv1 (x \\<bind> g))\n 2. \\<And>gpv. 0 \\<le> expectation_gpv1 (gpv \\<bind> g)\n 3. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I>\n                          (expectation_gpv fail \\<I> f \\<circ> g) gpv;\n        \\<And>gpv.\n           expectation_gpv' gpv\n           \\<le> expectation_gpv1 (gpv \\<bind> g)\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat\n                            (expectation_gpv fail \\<I> f \\<circ> g)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv1 (gpv \\<bind> g)", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a. \\<forall>x. a x \\<le> expectation_gpv1 (x \\<bind> g))\n 2. \\<And>gpv. 0 \\<le> expectation_gpv1 (gpv \\<bind> g)\n 3. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I>\n                          (expectation_gpv fail \\<I> f \\<circ> g) gpv;\n        \\<And>gpv.\n           expectation_gpv' gpv\n           \\<le> expectation_gpv1 (gpv \\<bind> g)\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat\n                            (expectation_gpv fail \\<I> f \\<circ> g)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv1 (gpv \\<bind> g)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp.admissible\n     (\\<lambda>a. \\<forall>x. a x \\<le> expectation_gpv1 (x \\<bind> g))", "by simp"], ["proof (state)\nthis:\n  lfp.admissible\n   (\\<lambda>a. \\<forall>x. a x \\<le> expectation_gpv1 (x \\<bind> g))\n\ngoal (2 subgoals):\n 1. \\<And>gpv. 0 \\<le> expectation_gpv1 (gpv \\<bind> g)\n 2. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I>\n                          (expectation_gpv fail \\<I> f \\<circ> g) gpv;\n        \\<And>gpv.\n           expectation_gpv' gpv\n           \\<le> expectation_gpv1 (gpv \\<bind> g)\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat\n                            (expectation_gpv fail \\<I> f \\<circ> g)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv1 (gpv \\<bind> g)", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>gpv. 0 \\<le> expectation_gpv1 (gpv \\<bind> g)\n 2. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I>\n                          (expectation_gpv fail \\<I> f \\<circ> g) gpv;\n        \\<And>gpv.\n           expectation_gpv' gpv\n           \\<le> expectation_gpv1 (gpv \\<bind> g)\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat\n                            (expectation_gpv fail \\<I> f \\<circ> g)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv1 (gpv \\<bind> g)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> expectation_gpv1 (gpv \\<bind> g)", "by simp"], ["proof (state)\nthis:\n  0 \\<le> expectation_gpv1 (gpv \\<bind> g)\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I>\n                          (expectation_gpv fail \\<I> f \\<circ> g) gpv;\n        \\<And>gpv.\n           expectation_gpv' gpv\n           \\<le> expectation_gpv1 (gpv \\<bind> g)\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat\n                            (expectation_gpv fail \\<I> f \\<circ> g)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv1 (gpv \\<bind> g)", "case (step expectation_gpv')"], ["proof (state)\nthis:\n  expectation_gpv' ?gpv\n  \\<le> expectation_gpv fail \\<I> (expectation_gpv fail \\<I> f \\<circ> g)\n         ?gpv\n  expectation_gpv' ?gpv \\<le> expectation_gpv1 (?gpv \\<bind> g)\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I>\n                          (expectation_gpv fail \\<I> f \\<circ> g) gpv;\n        \\<And>gpv.\n           expectation_gpv' gpv\n           \\<le> expectation_gpv1 (gpv \\<bind> g)\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat\n                            (expectation_gpv fail \\<I> f \\<circ> g)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv1 (gpv \\<bind> g)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of\n                          Pure x \\<Rightarrow>\n                            (expectation_gpv fail \\<I> f \\<circ> g) x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail * ennreal (pmf (the_gpv gpv) None)\n    \\<le> expectation_gpv1 (gpv \\<bind> g)", "unfolding expectation_gpv1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of\n                          Pure x \\<Rightarrow>\n                            (expectation_gpv fail \\<I> f \\<circ> g) x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail * ennreal (pmf (the_gpv gpv) None)\n    \\<le> expectation_gpv fail \\<I> f (gpv \\<bind> g)", "apply(rewrite in \"_ \\<le> \\<hole>\" expectation_gpv.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of\n                          Pure x \\<Rightarrow>\n                            (expectation_gpv fail \\<I> f \\<circ> g) x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail * ennreal (pmf (the_gpv gpv) None)\n    \\<le> \\<integral>\\<^sup>+ generat.\n                               (case generat of Pure x \\<Rightarrow> f x\n                                | IO out c \\<Rightarrow>\n                                    \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n expectation_gpv fail \\<I> f (c r))\n                             \\<partial>measure_spmf\n  (the_gpv (gpv \\<bind> g)) +\n          fail * ennreal (pmf (the_gpv (gpv \\<bind> g)) None)", "apply(rewrite bind_gpv.sel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of\n                          Pure x \\<Rightarrow>\n                            (expectation_gpv fail \\<I> f \\<circ> g) x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail * ennreal (pmf (the_gpv gpv) None)\n    \\<le> \\<integral>\\<^sup>+ generat.\n                               (case generat of Pure x \\<Rightarrow> f x\n                                | IO out c \\<Rightarrow>\n                                    \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n expectation_gpv fail \\<I> f (c r))\n                             \\<partial>measure_spmf\n  (map_spmf\n    (map_generat id id ((\\<circ>) (case_sum id (\\<lambda>r. r \\<bind> g))))\n    (the_gpv gpv \\<bind>\n     case_generat\n      (\\<lambda>x.\n          map_spmf (map_generat id id ((\\<circ>) Inl)) (the_gpv (g x)))\n      (\\<lambda>out c.\n          return_spmf (IO out (\\<lambda>input. Inr (c input)))))) +\n          fail * ennreal (pmf (the_gpv (gpv \\<bind> g)) None)", "apply(simp add: measure_spmf_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of\n                          Pure x \\<Rightarrow>\n                            expectation_gpv fail \\<I> f (g x)\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail * ennreal (pmf (the_gpv gpv) None)\n    \\<le> \\<integral>\\<^sup>+ x. (case map_generat id id\n  ((\\<circ>) (case_sum id (\\<lambda>r. r \\<bind> g))) x of\n                                  Pure x \\<Rightarrow> f x\n                                  | IO out c \\<Rightarrow>\n\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv fail \\<I> f (c r))\n                             \\<partial>measure_spmf (the_gpv gpv) \\<bind>\n (\\<lambda>x.\n     measure_spmf\n      (case x of\n       Pure x \\<Rightarrow>\n         map_spmf (map_generat id id ((\\<circ>) Inl)) (the_gpv (g x))\n       | IO out c \\<Rightarrow>\n           return_spmf (IO out (\\<lambda>input. Inr (c input))))) +\n          fail *\n          ennreal\n           (pmf (the_gpv gpv \\<bind>\n                 (\\<lambda>generat.\n                     if is_Pure generat\n                     then the_gpv (g (generat.result generat))\n                     else return_spmf\n                           (IO (generat.output generat)\n                             (\\<lambda>input.\n                                 continuation generat input \\<bind> g))))\n             None)", "apply(rewrite nn_integral_bind[where B=\"measure_spmf _\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>x.\n        case map_generat id id\n              ((\\<circ>) (case_sum id (\\<lambda>r. r \\<bind> g))) x of\n        Pure x \\<Rightarrow> f x\n        | IO out c \\<Rightarrow>\n            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n               expectation_gpv fail \\<I> f (c r))\n    \\<in> borel_measurable (measure_spmf ?uu69)\n 2. (\\<lambda>x.\n        measure_spmf\n         (case x of\n          Pure x \\<Rightarrow>\n            map_spmf (map_generat id id ((\\<circ>) Inl)) (the_gpv (g x))\n          | IO out c \\<Rightarrow>\n              return_spmf (IO out (\\<lambda>input. Inr (c input)))))\n    \\<in> measure_spmf (the_gpv gpv) \\<rightarrow>\\<^sub>M\n          subprob_algebra (measure_spmf ?uu69)\n 3. \\<integral>\\<^sup>+ generat.\n                         (case generat of\n                          Pure x \\<Rightarrow>\n                            expectation_gpv fail \\<I> f (g x)\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail * ennreal (pmf (the_gpv gpv) None)\n    \\<le> \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ y.\n                (case map_generat id id\n                       ((\\<circ>) (case_sum id (\\<lambda>r. r \\<bind> g)))\n                       y of\n                 Pure x \\<Rightarrow> f x\n                 | IO out c \\<Rightarrow>\n                     \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                        expectation_gpv fail \\<I> f (c r))\n              \\<partial>measure_spmf\n                         (case x of\n                          Pure x \\<Rightarrow>\n                            map_spmf (map_generat id id ((\\<circ>) Inl))\n                             (the_gpv (g x))\n                          | IO out c \\<Rightarrow>\n                              return_spmf\n                               (IO out (\\<lambda>input. Inr (c input))))\n                             \\<partial>measure_spmf (the_gpv gpv) +\n          fail *\n          ennreal\n           (pmf (the_gpv gpv \\<bind>\n                 (\\<lambda>generat.\n                     if is_Pure generat\n                     then the_gpv (g (generat.result generat))\n                     else return_spmf\n                           (IO (generat.output generat)\n                             (\\<lambda>input.\n                                 continuation generat input \\<bind> g))))\n             None)", "apply(simp_all add: space_subprob_algebra)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of\n                          Pure x \\<Rightarrow>\n                            expectation_gpv fail \\<I> f (g x)\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail * ennreal (pmf (the_gpv gpv) None)\n    \\<le> \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ y.\n                (case map_generat id id\n                       ((\\<circ>) (case_sum id (\\<lambda>r. r \\<bind> g)))\n                       y of\n                 Pure x \\<Rightarrow> f x\n                 | IO out c \\<Rightarrow>\n                     \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                        expectation_gpv fail \\<I> f (c r))\n              \\<partial>measure_spmf\n                         (case x of\n                          Pure x \\<Rightarrow>\n                            map_spmf (map_generat id id ((\\<circ>) Inl))\n                             (the_gpv (g x))\n                          | IO out c \\<Rightarrow>\n                              return_spmf\n                               (IO out (\\<lambda>input. Inr (c input))))\n                             \\<partial>measure_spmf (the_gpv gpv) +\n          fail *\n          ennreal\n           (pmf (the_gpv gpv \\<bind>\n                 (\\<lambda>generat.\n                     if is_Pure generat\n                     then the_gpv (g (generat.result generat))\n                     else return_spmf\n                           (IO (generat.output generat)\n                             (\\<lambda>input.\n                                 continuation generat input \\<bind> g))))\n             None)", "apply(simp add: pmf_bind_spmf_None distrib_left nn_integral_eq_integral[symmetric] measure_spmf.integrable_const_bound[where B=1] pmf_le_1 nn_integral_cmult[symmetric] nn_integral_add[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. fail * ennreal (pmf (the_gpv gpv) None) = \\<top> \\<or>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat (\\<lambda>x. expectation_gpv fail \\<I> f (g x))\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ y.\n                (case map_generat id id\n                       ((\\<circ>) (case_sum id (\\<lambda>r. r \\<bind> g)))\n                       y of\n                 Pure x \\<Rightarrow> f x\n                 | IO out c \\<Rightarrow>\n                     \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                        expectation_gpv fail \\<I> f (c r))\n              \\<partial>measure_spmf\n                         (case x of\n                          Pure x \\<Rightarrow>\n                            map_spmf (map_generat id id ((\\<circ>) Inl))\n                             (the_gpv (g x))\n                          | IO out c \\<Rightarrow>\n                              return_spmf\n                               (IO out (\\<lambda>input. Inr (c input)))) +\n                                 fail *\n                                 ennreal\n                                  (pmf (if is_Pure x\n  then the_gpv (g (generat.result x))\n  else return_spmf\n        (IO (generat.output x)\n          (\\<lambda>input. continuation x input \\<bind> g)))\n                                    None)\n                             \\<partial>measure_spmf (the_gpv gpv)", "apply(rule disjI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat (\\<lambda>x. expectation_gpv fail \\<I> f (g x))\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ y.\n                (case map_generat id id\n                       ((\\<circ>) (case_sum id (\\<lambda>r. r \\<bind> g)))\n                       y of\n                 Pure x \\<Rightarrow> f x\n                 | IO out c \\<Rightarrow>\n                     \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                        expectation_gpv fail \\<I> f (c r))\n              \\<partial>measure_spmf\n                         (case x of\n                          Pure x \\<Rightarrow>\n                            map_spmf (map_generat id id ((\\<circ>) Inl))\n                             (the_gpv (g x))\n                          | IO out c \\<Rightarrow>\n                              return_spmf\n                               (IO out (\\<lambda>input. Inr (c input)))) +\n                                 fail *\n                                 ennreal\n                                  (pmf (if is_Pure x\n  then the_gpv (g (generat.result x))\n  else return_spmf\n        (IO (generat.output x)\n          (\\<lambda>input. continuation x input \\<bind> g)))\n                                    None)\n                             \\<partial>measure_spmf (the_gpv gpv)", "apply(rule nn_integral_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       (case x of Pure x \\<Rightarrow> expectation_gpv fail \\<I> f (g x)\n        | IO out c \\<Rightarrow>\n            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> \\<integral>\\<^sup>+ y. (case map_generat id id\n     ((\\<circ>) (case_sum id (\\<lambda>r. r \\<bind> g))) y of\n                                     Pure x \\<Rightarrow> f x\n                                     | IO out c \\<Rightarrow>\n   \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n      expectation_gpv fail \\<I> f (c r))\n                                \\<partial>measure_spmf\n     (case x of\n      Pure x \\<Rightarrow>\n        map_spmf (map_generat id id ((\\<circ>) Inl)) (the_gpv (g x))\n      | IO out c \\<Rightarrow>\n          return_spmf (IO out (\\<lambda>input. Inr (c input)))) +\n             fail *\n             ennreal\n              (pmf (if is_Pure x then the_gpv (g (generat.result x))\n                    else return_spmf\n                          (IO (generat.output x)\n                            (\\<lambda>input.\n                                continuation x input \\<bind> g)))\n                None)", "apply(clarsimp split!: generat.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       Pure x1 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       expectation_gpv fail \\<I> f (g x1)\n       \\<le> \\<integral>\\<^sup>+ x. (case map_generat id id\n     ((\\<circ>) (case_sum id (\\<lambda>r. r \\<bind> g)))\n     (map_generat id id ((\\<circ>) Inl) x) of\n                                     Pure x \\<Rightarrow> f x\n                                     | IO out c \\<Rightarrow>\n   \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n      expectation_gpv fail \\<I> f (c r))\n                                \\<partial>measure_spmf (the_gpv (g x1)) +\n             fail * ennreal (pmf (the_gpv (g x1)) None)\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21. expectation_gpv' (x22 r))\n       \\<le> \\<integral>\\<^sup>+ y. (case map_generat id id\n     ((\\<circ>) (case_sum id (\\<lambda>r. r \\<bind> g))) y of\n                                     Pure x \\<Rightarrow> f x\n                                     | IO out c \\<Rightarrow>\n   \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n      expectation_gpv fail \\<I> f (c r))\n                                \\<partial>measure_spmf\n     (return_spmf (IO x21 (\\<lambda>input. Inr (x22 input))))", "apply(rewrite expectation_gpv.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       Pure x1 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ generat.\n                            (case generat of Pure x \\<Rightarrow> f x\n                             | IO out c \\<Rightarrow>\n                                 \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                    expectation_gpv fail \\<I> f (c r))\n                          \\<partial>measure_spmf (the_gpv (g x1)) +\n       fail * ennreal (pmf (the_gpv (g x1)) None)\n       \\<le> \\<integral>\\<^sup>+ x. (case map_generat id id\n     ((\\<circ>) (case_sum id (\\<lambda>r. r \\<bind> g)))\n     (map_generat id id ((\\<circ>) Inl) x) of\n                                     Pure x \\<Rightarrow> f x\n                                     | IO out c \\<Rightarrow>\n   \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n      expectation_gpv fail \\<I> f (c r))\n                                \\<partial>measure_spmf (the_gpv (g x1)) +\n             fail * ennreal (pmf (the_gpv (g x1)) None)\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21. expectation_gpv' (x22 r))\n       \\<le> \\<integral>\\<^sup>+ y. (case map_generat id id\n     ((\\<circ>) (case_sum id (\\<lambda>r. r \\<bind> g))) y of\n                                     Pure x \\<Rightarrow> f x\n                                     | IO out c \\<Rightarrow>\n   \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n      expectation_gpv fail \\<I> f (c r))\n                                \\<partial>measure_spmf\n     (return_spmf (IO x21 (\\<lambda>input. Inr (x22 input))))", "apply(simp cong del: if_weak_cong add: generat.map_comp id_def[symmetric] generat.map_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21. expectation_gpv' (x22 r))\n       \\<le> \\<integral>\\<^sup>+ y. (case map_generat id id\n     ((\\<circ>) (case_sum id (\\<lambda>r. r \\<bind> g))) y of\n                                     Pure x \\<Rightarrow> f x\n                                     | IO out c \\<Rightarrow>\n   \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n      expectation_gpv fail \\<I> f (c r))\n                                \\<partial>measure_spmf\n     (return_spmf (IO x21 (\\<lambda>input. Inr (x22 input))))", "apply(simp add: measure_spmf_return_spmf nn_integral_return)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21. expectation_gpv' (x22 r))\n       \\<le> (\\<Sqinter>x\\<in>responses_\\<I> \\<I> x21.\n                 expectation_gpv fail \\<I> f (x22 x \\<bind> g))", "apply(rule INF_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 m.\n       \\<lbrakk>IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv));\n        m \\<in> responses_\\<I> \\<I> x21\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r\\<in>responses_\\<I> \\<I> x21.\n                            expectation_gpv' (x22 r)\n                            \\<le> expectation_gpv fail \\<I> f\n                                   (x22 m \\<bind> g)", "apply(erule rev_bexI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 m.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       expectation_gpv' (x22 m)\n       \\<le> expectation_gpv fail \\<I> f (x22 m \\<bind> g)", "apply(rule step.IH[unfolded expectation_gpv1_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of\n                        Pure x \\<Rightarrow>\n                          (expectation_gpv fail \\<I> f \\<circ> g) x\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  fail * ennreal (pmf (the_gpv gpv) None)\n  \\<le> expectation_gpv1 (gpv \\<bind> g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  expectation_gpv2 gpv \\<le> expectation_gpv1 (gpv \\<bind> g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma expectation_gpv_try_gpv [simp]:\n  fixes fail \\<I> f gpv'\n  defines \"expectation_gpv1 \\<equiv> expectation_gpv fail \\<I> f\"\n    and \"expectation_gpv2 \\<equiv> expectation_gpv (expectation_gpv fail \\<I> f gpv') \\<I> f\"\n  shows \"expectation_gpv1 (try_gpv gpv gpv') = expectation_gpv2 gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv1 (TRY gpv ELSE gpv') = expectation_gpv2 gpv", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. expectation_gpv1 (TRY gpv ELSE gpv') \\<le> expectation_gpv2 gpv\n 2. expectation_gpv2 gpv \\<le> expectation_gpv1 (TRY gpv ELSE gpv')", "show \"expectation_gpv1 (try_gpv gpv gpv') \\<le> expectation_gpv2 gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv1 (TRY gpv ELSE gpv') \\<le> expectation_gpv2 gpv", "unfolding expectation_gpv1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> f (TRY gpv ELSE gpv')\n    \\<le> expectation_gpv2 gpv", "proof(induction arbitrary: gpv rule: expectation_gpv_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a. \\<forall>x. a (TRY x ELSE gpv') \\<le> expectation_gpv2 x)\n 2. \\<And>gpv. 0 \\<le> expectation_gpv2 gpv\n 3. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> f gpv;\n        \\<And>gpv.\n           expectation_gpv' (TRY gpv ELSE gpv')\n           \\<le> expectation_gpv2 gpv\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N\n                          (measure_spmf (the_gpv (TRY gpv ELSE gpv')))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail *\n                         ennreal (pmf (the_gpv (TRY gpv ELSE gpv')) None)\n                         \\<le> expectation_gpv2 gpv", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a. \\<forall>x. a (TRY x ELSE gpv') \\<le> expectation_gpv2 x)\n 2. \\<And>gpv. 0 \\<le> expectation_gpv2 gpv\n 3. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> f gpv;\n        \\<And>gpv.\n           expectation_gpv' (TRY gpv ELSE gpv')\n           \\<le> expectation_gpv2 gpv\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N\n                          (measure_spmf (the_gpv (TRY gpv ELSE gpv')))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail *\n                         ennreal (pmf (the_gpv (TRY gpv ELSE gpv')) None)\n                         \\<le> expectation_gpv2 gpv", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp.admissible\n     (\\<lambda>a. \\<forall>x. a (TRY x ELSE gpv') \\<le> expectation_gpv2 x)", "by simp"], ["proof (state)\nthis:\n  lfp.admissible\n   (\\<lambda>a. \\<forall>x. a (TRY x ELSE gpv') \\<le> expectation_gpv2 x)\n\ngoal (2 subgoals):\n 1. \\<And>gpv. 0 \\<le> expectation_gpv2 gpv\n 2. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> f gpv;\n        \\<And>gpv.\n           expectation_gpv' (TRY gpv ELSE gpv')\n           \\<le> expectation_gpv2 gpv\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N\n                          (measure_spmf (the_gpv (TRY gpv ELSE gpv')))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail *\n                         ennreal (pmf (the_gpv (TRY gpv ELSE gpv')) None)\n                         \\<le> expectation_gpv2 gpv", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>gpv. 0 \\<le> expectation_gpv2 gpv\n 2. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> f gpv;\n        \\<And>gpv.\n           expectation_gpv' (TRY gpv ELSE gpv')\n           \\<le> expectation_gpv2 gpv\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N\n                          (measure_spmf (the_gpv (TRY gpv ELSE gpv')))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail *\n                         ennreal (pmf (the_gpv (TRY gpv ELSE gpv')) None)\n                         \\<le> expectation_gpv2 gpv", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> expectation_gpv2 gpv", "by simp"], ["proof (state)\nthis:\n  0 \\<le> expectation_gpv2 gpv\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> f gpv;\n        \\<And>gpv.\n           expectation_gpv' (TRY gpv ELSE gpv')\n           \\<le> expectation_gpv2 gpv\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N\n                          (measure_spmf (the_gpv (TRY gpv ELSE gpv')))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail *\n                         ennreal (pmf (the_gpv (TRY gpv ELSE gpv')) None)\n                         \\<le> expectation_gpv2 gpv", "case step [unfolded expectation_gpv2_def]: (step expectation_gpv')"], ["proof (state)\nthis:\n  expectation_gpv' ?gpv \\<le> expectation_gpv fail \\<I> f ?gpv\n  expectation_gpv' (TRY ?gpv ELSE gpv')\n  \\<le> expectation_gpv (expectation_gpv fail \\<I> f gpv') \\<I> f ?gpv\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> f gpv;\n        \\<And>gpv.\n           expectation_gpv' (TRY gpv ELSE gpv')\n           \\<le> expectation_gpv2 gpv\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N\n                          (measure_spmf (the_gpv (TRY gpv ELSE gpv')))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail *\n                         ennreal (pmf (the_gpv (TRY gpv ELSE gpv')) None)\n                         \\<le> expectation_gpv2 gpv", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf\n                                  (the_gpv (TRY gpv ELSE gpv')) +\n    fail * ennreal (pmf (the_gpv (TRY gpv ELSE gpv')) None)\n    \\<le> expectation_gpv2 gpv", "unfolding expectation_gpv2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf\n                                  (the_gpv (TRY gpv ELSE gpv')) +\n    fail * ennreal (pmf (the_gpv (TRY gpv ELSE gpv')) None)\n    \\<le> expectation_gpv (expectation_gpv fail \\<I> f gpv') \\<I> f gpv", "apply(rewrite expectation_gpv.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf\n                                  (the_gpv (TRY gpv ELSE gpv')) +\n    fail * ennreal (pmf (the_gpv (TRY gpv ELSE gpv')) None)\n    \\<le> \\<integral>\\<^sup>+ generat.\n                               (case generat of Pure x \\<Rightarrow> f x\n                                | IO out c \\<Rightarrow>\n                                    \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n expectation_gpv (expectation_gpv fail \\<I> f gpv') \\<I> f (c r))\n                             \\<partial>measure_spmf (the_gpv gpv) +\n          expectation_gpv fail \\<I> f gpv' *\n          ennreal (pmf (the_gpv gpv) None)", "apply(rewrite in \"_ \\<le> _ + \\<hole>\" expectation_gpv.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf\n                                  (the_gpv (TRY gpv ELSE gpv')) +\n    fail * ennreal (pmf (the_gpv (TRY gpv ELSE gpv')) None)\n    \\<le> \\<integral>\\<^sup>+ generat.\n                               (case generat of Pure x \\<Rightarrow> f x\n                                | IO out c \\<Rightarrow>\n                                    \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n expectation_gpv (expectation_gpv fail \\<I> f gpv') \\<I> f (c r))\n                             \\<partial>measure_spmf (the_gpv gpv) +\n          (\\<integral>\\<^sup>+ generat.\n                                (case generat of Pure x \\<Rightarrow> f x\n                                 | IO out c \\<Rightarrow>\n                                     \\<Sqinter>r\\<in>responses_\\<I> \\<I>\n                out.\n  expectation_gpv fail \\<I> f (c r))\n                              \\<partial>measure_spmf (the_gpv gpv') +\n           fail * ennreal (pmf (the_gpv gpv') None)) *\n          ennreal (pmf (the_gpv gpv) None)", "apply(simp add: pmf_map_spmf_None nn_integral_try_spmf o_def generat.map_comp case_map_generat distrib_right cong del: generat.case_cong_weak)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. (case map_generat (\\<lambda>x. x) (\\<lambda>x. x)\n                                  (\\<lambda>x input. TRY x input ELSE gpv')\n                                  x of\n                            Pure x \\<Rightarrow> f x\n                            | IO out c \\<Rightarrow>\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    \\<integral>\\<^sup>+ x. (case map_generat (\\<lambda>x. x) (\\<lambda>x. x)\n                                  (\\<lambda>x. x) x of\n                            Pure x \\<Rightarrow> f x\n                            | IO out c \\<Rightarrow>\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv') *\n    ennreal (pmf (the_gpv gpv) None) +\n    fail * ennreal (pmf (the_gpv gpv) None * pmf (the_gpv gpv') None)\n    \\<le> \\<integral>\\<^sup>+ generat.\n                               (case generat of Pure x \\<Rightarrow> f x\n                                | IO out c \\<Rightarrow>\n                                    \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n expectation_gpv (expectation_gpv fail \\<I> f gpv') \\<I> f (c r))\n                             \\<partial>measure_spmf (the_gpv gpv) +\n          (integral\\<^sup>N (measure_spmf (the_gpv gpv'))\n            (case_generat f\n              (\\<lambda>out c.\n                  \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                     expectation_gpv fail \\<I> f (c r))) *\n           ennreal (pmf (the_gpv gpv) None) +\n           fail * ennreal (pmf (the_gpv gpv') None) *\n           ennreal (pmf (the_gpv gpv) None))", "apply(simp add: mult_ac add.assoc ennreal_mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fail *\n    (ennreal (pmf (the_gpv gpv') None) * ennreal (pmf (the_gpv gpv) None)) =\n    \\<top> \\<or>\n    \\<integral>\\<^sup>+ x. (case map_generat (\\<lambda>x. x) (\\<lambda>x. x)\n                                  (\\<lambda>x input. TRY x input ELSE gpv')\n                                  x of\n                            Pure x \\<Rightarrow> f x\n                            | IO out c \\<Rightarrow>\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    ennreal (pmf (the_gpv gpv) None) *\n    \\<integral>\\<^sup>+ x. (case map_generat (\\<lambda>x. x) (\\<lambda>x. x)\n                                  (\\<lambda>x. x) x of\n                            Pure x \\<Rightarrow> f x\n                            | IO out c \\<Rightarrow>\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv')\n    \\<le> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n           (case_generat f\n             (\\<lambda>out c.\n                 \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                    expectation_gpv (expectation_gpv fail \\<I> f gpv') \\<I>\n                     f (c r))) +\n          ennreal (pmf (the_gpv gpv) None) *\n          integral\\<^sup>N (measure_spmf (the_gpv gpv'))\n           (case_generat f\n             (\\<lambda>out c.\n                 \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                    expectation_gpv fail \\<I> f (c r)))", "apply(intro disjI2 add_mono mult_left_mono nn_integral_mono; clarsimp split: generat.split intro!: INF_mono step elim!: rev_bexI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> f x\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv (TRY gpv ELSE gpv')) +\n  fail * ennreal (pmf (the_gpv (TRY gpv ELSE gpv')) None)\n  \\<le> expectation_gpv2 gpv\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  expectation_gpv1 (TRY gpv ELSE gpv') \\<le> expectation_gpv2 gpv\n\ngoal (1 subgoal):\n 1. expectation_gpv2 gpv \\<le> expectation_gpv1 (TRY gpv ELSE gpv')", "show \"expectation_gpv2 gpv \\<le> expectation_gpv1 (try_gpv gpv gpv')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv2 gpv \\<le> expectation_gpv1 (TRY gpv ELSE gpv')", "unfolding expectation_gpv2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv (expectation_gpv fail \\<I> f gpv') \\<I> f gpv\n    \\<le> expectation_gpv1 (TRY gpv ELSE gpv')", "proof(induction arbitrary: gpv rule: expectation_gpv_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a. \\<forall>x. a x \\<le> expectation_gpv1 (TRY x ELSE gpv'))\n 2. \\<And>gpv. 0 \\<le> expectation_gpv1 (TRY gpv ELSE gpv')\n 3. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv (expectation_gpv fail \\<I> f gpv')\n                          \\<I> f gpv;\n        \\<And>gpv.\n           expectation_gpv' gpv\n           \\<le> expectation_gpv1 (TRY gpv ELSE gpv')\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         expectation_gpv fail \\<I> f gpv' *\n                         ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv1 (TRY gpv ELSE gpv')", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a. \\<forall>x. a x \\<le> expectation_gpv1 (TRY x ELSE gpv'))\n 2. \\<And>gpv. 0 \\<le> expectation_gpv1 (TRY gpv ELSE gpv')\n 3. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv (expectation_gpv fail \\<I> f gpv')\n                          \\<I> f gpv;\n        \\<And>gpv.\n           expectation_gpv' gpv\n           \\<le> expectation_gpv1 (TRY gpv ELSE gpv')\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         expectation_gpv fail \\<I> f gpv' *\n                         ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv1 (TRY gpv ELSE gpv')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp.admissible\n     (\\<lambda>a. \\<forall>x. a x \\<le> expectation_gpv1 (TRY x ELSE gpv'))", "by simp"], ["proof (state)\nthis:\n  lfp.admissible\n   (\\<lambda>a. \\<forall>x. a x \\<le> expectation_gpv1 (TRY x ELSE gpv'))\n\ngoal (2 subgoals):\n 1. \\<And>gpv. 0 \\<le> expectation_gpv1 (TRY gpv ELSE gpv')\n 2. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv (expectation_gpv fail \\<I> f gpv')\n                          \\<I> f gpv;\n        \\<And>gpv.\n           expectation_gpv' gpv\n           \\<le> expectation_gpv1 (TRY gpv ELSE gpv')\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         expectation_gpv fail \\<I> f gpv' *\n                         ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv1 (TRY gpv ELSE gpv')", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>gpv. 0 \\<le> expectation_gpv1 (TRY gpv ELSE gpv')\n 2. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv (expectation_gpv fail \\<I> f gpv')\n                          \\<I> f gpv;\n        \\<And>gpv.\n           expectation_gpv' gpv\n           \\<le> expectation_gpv1 (TRY gpv ELSE gpv')\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         expectation_gpv fail \\<I> f gpv' *\n                         ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv1 (TRY gpv ELSE gpv')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> expectation_gpv1 (TRY gpv ELSE gpv')", "by simp"], ["proof (state)\nthis:\n  0 \\<le> expectation_gpv1 (TRY gpv ELSE gpv')\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv (expectation_gpv fail \\<I> f gpv')\n                          \\<I> f gpv;\n        \\<And>gpv.\n           expectation_gpv' gpv\n           \\<le> expectation_gpv1 (TRY gpv ELSE gpv')\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         expectation_gpv fail \\<I> f gpv' *\n                         ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv1 (TRY gpv ELSE gpv')", "case step [unfolded expectation_gpv1_def]: (step expectation_gpv')"], ["proof (state)\nthis:\n  expectation_gpv' ?gpv\n  \\<le> expectation_gpv (expectation_gpv fail \\<I> f gpv') \\<I> f ?gpv\n  expectation_gpv' ?gpv\n  \\<le> expectation_gpv fail \\<I> f (TRY ?gpv ELSE gpv')\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv (expectation_gpv fail \\<I> f gpv')\n                          \\<I> f gpv;\n        \\<And>gpv.\n           expectation_gpv' gpv\n           \\<le> expectation_gpv1 (TRY gpv ELSE gpv')\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         expectation_gpv fail \\<I> f gpv' *\n                         ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv1 (TRY gpv ELSE gpv')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    expectation_gpv fail \\<I> f gpv' * ennreal (pmf (the_gpv gpv) None)\n    \\<le> expectation_gpv1 (TRY gpv ELSE gpv')", "unfolding expectation_gpv1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    expectation_gpv fail \\<I> f gpv' * ennreal (pmf (the_gpv gpv) None)\n    \\<le> expectation_gpv fail \\<I> f (TRY gpv ELSE gpv')", "apply(rewrite in \"_ \\<le> \\<hole>\" expectation_gpv.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    expectation_gpv fail \\<I> f gpv' * ennreal (pmf (the_gpv gpv) None)\n    \\<le> \\<integral>\\<^sup>+ generat.\n                               (case generat of Pure x \\<Rightarrow> f x\n                                | IO out c \\<Rightarrow>\n                                    \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n expectation_gpv fail \\<I> f (c r))\n                             \\<partial>measure_spmf\n  (the_gpv (TRY gpv ELSE gpv')) +\n          fail * ennreal (pmf (the_gpv (TRY gpv ELSE gpv')) None)", "apply(rewrite in \"\\<hole> \\<le> _\" expectation_gpv.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    (\\<integral>\\<^sup>+ generat.\n                          (case generat of Pure x \\<Rightarrow> f x\n                           | IO out c \\<Rightarrow>\n                               \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                  expectation_gpv fail \\<I> f (c r))\n                        \\<partial>measure_spmf (the_gpv gpv') +\n     fail * ennreal (pmf (the_gpv gpv') None)) *\n    ennreal (pmf (the_gpv gpv) None)\n    \\<le> \\<integral>\\<^sup>+ generat.\n                               (case generat of Pure x \\<Rightarrow> f x\n                                | IO out c \\<Rightarrow>\n                                    \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n expectation_gpv fail \\<I> f (c r))\n                             \\<partial>measure_spmf\n  (the_gpv (TRY gpv ELSE gpv')) +\n          fail * ennreal (pmf (the_gpv (TRY gpv ELSE gpv')) None)", "apply(simp add: pmf_map_spmf_None nn_integral_try_spmf o_def generat.map_comp case_map_generat distrib_left ennreal_mult mult_ac id_def[symmetric] generat.map_id cong del: generat.case_cong_weak)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (pmf (the_gpv gpv) None) *\n    integral\\<^sup>N (measure_spmf (the_gpv gpv'))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n              expectation_gpv fail \\<I> f (c r))) =\n    \\<top> \\<or>\n    fail *\n    (ennreal (pmf (the_gpv gpv') None) * ennreal (pmf (the_gpv gpv) None)) =\n    \\<top> \\<or>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. (case map_generat id id\n  (\\<lambda>x input. TRY x input ELSE gpv') x of\n                                  Pure x \\<Rightarrow> f x\n                                  | IO out c \\<Rightarrow>\n\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv fail \\<I> f (c r))\n                             \\<partial>measure_spmf (the_gpv gpv)", "apply(rule disjI2 nn_integral_mono)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       (case x of Pure x \\<Rightarrow> f x\n        | IO out c \\<Rightarrow>\n            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (case map_generat id id\n                    (\\<lambda>x input. TRY x input ELSE gpv') x of\n              Pure x \\<Rightarrow> f x\n              | IO out c \\<Rightarrow>\n                  \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                     expectation_gpv fail \\<I> f (c r))", "apply(clarsimp split: generat.split intro!: INF_mono step(2) elim!: rev_bexI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> f x\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  expectation_gpv fail \\<I> f gpv' * ennreal (pmf (the_gpv gpv) None)\n  \\<le> expectation_gpv1 (TRY gpv ELSE gpv')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  expectation_gpv2 gpv \\<le> expectation_gpv1 (TRY gpv ELSE gpv')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma expectation_gpv_restrict_gpv:\n  \"\\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow> expectation_gpv fail \\<I> f (restrict_gpv \\<I> gpv) = expectation_gpv fail \\<I> f gpv\" for fail"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n    expectation_gpv fail \\<I> f (restrict_gpv \\<I> gpv) =\n    expectation_gpv fail \\<I> f gpv", "proof(induction arbitrary: gpv rule: expectation_gpv_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            a (restrict_gpv \\<I> x) = a x)\n 2. \\<And>gpv. \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow> 0 = 0\n 3. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> f gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' (restrict_gpv \\<I> gpv) = expectation_gpv' gpv;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N\n                          (measure_spmf (the_gpv (restrict_gpv \\<I> gpv)))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail *\n                         ennreal\n                          (pmf (the_gpv (restrict_gpv \\<I> gpv)) None) =\n                         integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            a (restrict_gpv \\<I> x) = a x)\n 2. \\<And>gpv. \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow> 0 = 0\n 3. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> f gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' (restrict_gpv \\<I> gpv) = expectation_gpv' gpv;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N\n                          (measure_spmf (the_gpv (restrict_gpv \\<I> gpv)))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail *\n                         ennreal\n                          (pmf (the_gpv (restrict_gpv \\<I> gpv)) None) =\n                         integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            a (restrict_gpv \\<I> x) = a x)", "by simp"], ["proof (state)\nthis:\n  lfp.admissible\n   (\\<lambda>a.\n       \\<forall>x.\n          \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n          a (restrict_gpv \\<I> x) = a x)\n\ngoal (2 subgoals):\n 1. \\<And>gpv. \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow> 0 = 0\n 2. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> f gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' (restrict_gpv \\<I> gpv) = expectation_gpv' gpv;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N\n                          (measure_spmf (the_gpv (restrict_gpv \\<I> gpv)))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail *\n                         ennreal\n                          (pmf (the_gpv (restrict_gpv \\<I> gpv)) None) =\n                         integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)", "case bottom"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>gpv. \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow> 0 = 0\n 2. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> f gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' (restrict_gpv \\<I> gpv) = expectation_gpv' gpv;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N\n                          (measure_spmf (the_gpv (restrict_gpv \\<I> gpv)))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail *\n                         ennreal\n                          (pmf (the_gpv (restrict_gpv \\<I> gpv)) None) =\n                         integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = 0", "by simp"], ["proof (state)\nthis:\n  0 = 0\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> f gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' (restrict_gpv \\<I> gpv) = expectation_gpv' gpv;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N\n                          (measure_spmf (the_gpv (restrict_gpv \\<I> gpv)))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail *\n                         ennreal\n                          (pmf (the_gpv (restrict_gpv \\<I> gpv)) None) =\n                         integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)", "case (step expectation_gpv'')"], ["proof (state)\nthis:\n  expectation_gpv'' ?gpv \\<le> expectation_gpv fail \\<I> f ?gpv\n  \\<I> \\<turnstile>g ?gpv \\<surd> \\<Longrightarrow>\n  expectation_gpv'' (restrict_gpv \\<I> ?gpv) = expectation_gpv'' ?gpv\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> f gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' (restrict_gpv \\<I> gpv) = expectation_gpv' gpv;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N\n                          (measure_spmf (the_gpv (restrict_gpv \\<I> gpv)))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail *\n                         ennreal\n                          (pmf (the_gpv (restrict_gpv \\<I> gpv)) None) =\n                         integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv'' (c r))\n                       \\<partial>measure_spmf\n                                  (the_gpv (restrict_gpv \\<I> gpv)) +\n    fail * ennreal (pmf (the_gpv (restrict_gpv \\<I> gpv)) None) =\n    \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv'' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail * ennreal (pmf (the_gpv gpv) None)", "apply(simp add: pmf_map vimage_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv'' (c r))\n                       \\<partial>measure_spmf\n                                  (map_pmf\n                                    (case_option None\n(case_generat (Some \\<circ> Pure)\n  (\\<lambda>out c.\n      if out \\<in> outs_\\<I> \\<I>\n      then Some\n            (IO out\n              (\\<lambda>input.\n                  if input \\<in> responses_\\<I> \\<I> out\n                  then restrict_gpv \\<I> (c input) else Fail))\n      else None)))\n                                    (the_gpv gpv)) +\n    fail *\n    ennreal\n     (measure_pmf.prob (the_gpv gpv)\n       {x. (case x of None \\<Rightarrow> None\n            | Some (Pure xa) \\<Rightarrow> (Some \\<circ> Pure) xa\n            | Some (IO out c) \\<Rightarrow>\n                if out \\<in> outs_\\<I> \\<I>\n                then Some\n                      (IO out\n                        (\\<lambda>input.\n                            if input \\<in> responses_\\<I> \\<I> out\n                            then restrict_gpv \\<I> (c input) else Fail))\n                else None) =\n           None}) =\n    \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv'' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail * ennreal (pmf (the_gpv gpv) None)", "apply(rule arg_cong2[where f=\"(+)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv'' (c r))\n                       \\<partial>measure_spmf\n                                  (map_pmf\n                                    (case_option None\n(case_generat (Some \\<circ> Pure)\n  (\\<lambda>out c.\n      if out \\<in> outs_\\<I> \\<I>\n      then Some\n            (IO out\n              (\\<lambda>input.\n                  if input \\<in> responses_\\<I> \\<I> out\n                  then restrict_gpv \\<I> (c input) else Fail))\n      else None)))\n                                    (the_gpv gpv)) =\n    \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv'' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv)\n 2. fail *\n    ennreal\n     (measure_pmf.prob (the_gpv gpv)\n       {x. (case x of None \\<Rightarrow> None\n            | Some (Pure xa) \\<Rightarrow> (Some \\<circ> Pure) xa\n            | Some (IO out c) \\<Rightarrow>\n                if out \\<in> outs_\\<I> \\<I>\n                then Some\n                      (IO out\n                        (\\<lambda>input.\n                            if input \\<in> responses_\\<I> \\<I> out\n                            then restrict_gpv \\<I> (c input) else Fail))\n                else None) =\n           None}) =\n    fail * ennreal (pmf (the_gpv gpv) None)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv'' (c r))\n                       \\<partial>measure_spmf\n                                  (map_pmf\n                                    (case_option None\n(case_generat (Some \\<circ> Pure)\n  (\\<lambda>out c.\n      if out \\<in> outs_\\<I> \\<I>\n      then Some\n            (IO out\n              (\\<lambda>input.\n                  if input \\<in> responses_\\<I> \\<I> out\n                  then restrict_gpv \\<I> (c input) else Fail))\n      else None)))\n                                    (the_gpv gpv)) =\n    \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv'' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv)", "by(clarsimp simp add: measure_spmf_def nn_integral_distr nn_integral_restrict_space step.IH WT_gpv_ContD[OF step.prems] AE_measure_pmf_iff in_set_spmf[symmetric] WT_gpv_OutD[OF step.prems] split!: option.split generat.split intro!: nn_integral_cong_AE INF_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. fail *\n    ennreal\n     (measure_pmf.prob (the_gpv gpv)\n       {x. (case x of None \\<Rightarrow> None\n            | Some (Pure xa) \\<Rightarrow> (Some \\<circ> Pure) xa\n            | Some (IO out c) \\<Rightarrow>\n                if out \\<in> outs_\\<I> \\<I>\n                then Some\n                      (IO out\n                        (\\<lambda>input.\n                            if input \\<in> responses_\\<I> \\<I> out\n                            then restrict_gpv \\<I> (c input) else Fail))\n                else None) =\n           None}) =\n    fail * ennreal (pmf (the_gpv gpv) None)", "apply(simp add: measure_pmf_single[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. fail *\n    ennreal\n     (measure_pmf.prob (the_gpv gpv)\n       {x. (case x of None \\<Rightarrow> None\n            | Some (Pure xa) \\<Rightarrow> (Some \\<circ> Pure) xa\n            | Some (IO out c) \\<Rightarrow>\n                if out \\<in> outs_\\<I> \\<I>\n                then Some\n                      (IO out\n                        (\\<lambda>input.\n                            if input \\<in> responses_\\<I> \\<I> out\n                            then restrict_gpv \\<I> (c input) else Fail))\n                else None) =\n           None}) =\n    fail * ennreal (measure_pmf.prob (the_gpv gpv) {None})", "apply(rule arg_cong[where f=\"\\<lambda>x. _ * ennreal x\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob (the_gpv gpv)\n     {x. (case x of None \\<Rightarrow> None\n          | Some (Pure xa) \\<Rightarrow> (Some \\<circ> Pure) xa\n          | Some (IO out c) \\<Rightarrow>\n              if out \\<in> outs_\\<I> \\<I>\n              then Some\n                    (IO out\n                      (\\<lambda>input.\n                          if input \\<in> responses_\\<I> \\<I> out\n                          then restrict_gpv \\<I> (c input) else Fail))\n              else None) =\n         None} =\n    measure_pmf.prob (the_gpv gpv) {None}", "apply(rule measure_pmf.finite_measure_eq_AE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. AE x in measure_pmf\n             (the_gpv\n               gpv). (x \\<in> {x. (case x of None \\<Rightarrow> None\n                                   | Some (Pure xa) \\<Rightarrow>\n (Some \\<circ> Pure) xa\n                                   | Some (IO out c) \\<Rightarrow>\n if out \\<in> outs_\\<I> \\<I>\n then Some\n       (IO out\n         (\\<lambda>input.\n             if input \\<in> responses_\\<I> \\<I> out\n             then restrict_gpv \\<I> (c input) else Fail))\n else None) =\n                                  None}) =\n                     (x \\<in> {None})\n 2. {x. (case x of None \\<Rightarrow> None\n         | Some (Pure xa) \\<Rightarrow> (Some \\<circ> Pure) xa\n         | Some (IO out c) \\<Rightarrow>\n             if out \\<in> outs_\\<I> \\<I>\n             then Some\n                   (IO out\n                     (\\<lambda>input.\n                         if input \\<in> responses_\\<I> \\<I> out\n                         then restrict_gpv \\<I> (c input) else Fail))\n             else None) =\n        None}\n    \\<in> measure_pmf.events (the_gpv gpv)\n 3. {None} \\<in> measure_pmf.events (the_gpv gpv)", "apply(auto simp add: AE_measure_pmf_iff in_set_spmf[symmetric] intro: WT_gpv_OutD[OF step.prems] split: option.split_asm generat.split_asm if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> f x\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv'' (c r))\n                     \\<partial>measure_spmf\n                                (the_gpv (restrict_gpv \\<I> gpv)) +\n  fail * ennreal (pmf (the_gpv (restrict_gpv \\<I> gpv)) None) =\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> f x\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv'' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  fail * ennreal (pmf (the_gpv gpv) None)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma expectation_gpv_const_le: \"\\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow> expectation_gpv fail \\<I> (\\<lambda>_. c) gpv \\<le> max c fail\" for fail"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n    expectation_gpv fail \\<I> (\\<lambda>_. c) gpv \\<le> max c fail", "proof(induction arbitrary: gpv rule: expectation_gpv_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            a x \\<le> max c fail)\n 2. \\<And>gpv.\n       \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow> 0 \\<le> max c fail\n 3. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv \\<le> max c fail;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. c)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> max c fail", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            a x \\<le> max c fail)\n 2. \\<And>gpv.\n       \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow> 0 \\<le> max c fail\n 3. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv \\<le> max c fail;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. c)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> max c fail", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            a x \\<le> max c fail)", "by simp"], ["proof (state)\nthis:\n  lfp.admissible\n   (\\<lambda>a.\n       \\<forall>x.\n          \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n          a x \\<le> max c fail)\n\ngoal (2 subgoals):\n 1. \\<And>gpv.\n       \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow> 0 \\<le> max c fail\n 2. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv \\<le> max c fail;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. c)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> max c fail", "case bottom"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>gpv.\n       \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow> 0 \\<le> max c fail\n 2. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv \\<le> max c fail;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. c)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> max c fail", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> max c fail", "by simp"], ["proof (state)\nthis:\n  0 \\<le> max c fail\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv \\<le> max c fail;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. c)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> max c fail", "case (step expectation_gpv')"], ["proof (state)\nthis:\n  expectation_gpv' ?gpv \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) ?gpv\n  \\<I> \\<turnstile>g ?gpv \\<surd> \\<Longrightarrow>\n  expectation_gpv' ?gpv \\<le> max c fail\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv \\<le> max c fail;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. c)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> max c fail", "have \"integral\\<^sup>N (measure_spmf (the_gpv gpv)) (case_generat (\\<lambda>x. c) (\\<lambda>out c. INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))) \\<le> integral\\<^sup>N (measure_spmf (the_gpv gpv)) (\\<lambda>_. max c fail)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat (\\<lambda>x. c)\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ _. max c fail\n                             \\<partial>measure_spmf (the_gpv gpv)", "using step.prems"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat (\\<lambda>x. c)\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ _. max c fail\n                             \\<partial>measure_spmf (the_gpv gpv)", "by(intro nn_integral_mono_AE)(auto 4 4 split: generat.split intro: INF_lower2 step.IH WT_gpv_ContD[OF step.prems] dest!: WT_gpv_OutD simp add: in_outs_\\<I>_iff_responses_\\<I>)"], ["proof (state)\nthis:\n  integral\\<^sup>N (measure_spmf (the_gpv gpv))\n   (case_generat (\\<lambda>x. c)\n     (\\<lambda>out c.\n         \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n  \\<le> \\<integral>\\<^sup>+ _. max c fail\n                           \\<partial>measure_spmf (the_gpv gpv)\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv \\<le> max c fail;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. c)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> max c fail", "also"], ["proof (state)\nthis:\n  integral\\<^sup>N (measure_spmf (the_gpv gpv))\n   (case_generat (\\<lambda>x. c)\n     (\\<lambda>out c.\n         \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n  \\<le> \\<integral>\\<^sup>+ _. max c fail\n                           \\<partial>measure_spmf (the_gpv gpv)\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv \\<le> max c fail;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. c)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> max c fail", "have \"\\<dots> + fail * pmf (the_gpv gpv) None \\<le> \\<dots> + max c fail * pmf (the_gpv gpv) None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ _. max c fail \\<partial>measure_spmf (the_gpv gpv) +\n    fail * ennreal (pmf (the_gpv gpv) None)\n    \\<le> \\<integral>\\<^sup>+ _. max c fail\n                             \\<partial>measure_spmf (the_gpv gpv) +\n          max c fail * ennreal (pmf (the_gpv gpv) None)", "by(intro add_left_mono mult_right_mono) simp_all"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ _. max c fail \\<partial>measure_spmf (the_gpv gpv) +\n  fail * ennreal (pmf (the_gpv gpv) None)\n  \\<le> \\<integral>\\<^sup>+ _. max c fail\n                           \\<partial>measure_spmf (the_gpv gpv) +\n        max c fail * ennreal (pmf (the_gpv gpv) None)\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv \\<le> max c fail;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. c)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> max c fail", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ _. max c fail \\<partial>measure_spmf (the_gpv gpv) +\n  fail * ennreal (pmf (the_gpv gpv) None)\n  \\<le> \\<integral>\\<^sup>+ _. max c fail\n                           \\<partial>measure_spmf (the_gpv gpv) +\n        max c fail * ennreal (pmf (the_gpv gpv) None)\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv \\<le> max c fail;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. c)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> max c fail", "have \"\\<dots> \\<le> max c fail\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ _. max c fail \\<partial>measure_spmf (the_gpv gpv) +\n    max c fail * ennreal (pmf (the_gpv gpv) None)\n    \\<le> max c fail", "by(simp add: measure_spmf.emeasure_eq_measure pmf_None_eq_weight_spmf ennreal_minus[symmetric])\n      (metis (no_types, hide_lams) add_diff_eq_iff_ennreal distrib_left ennreal_le_1 le_max_iff_disj max.cobounded2 mult.commute mult.left_neutral weight_spmf_le_1)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ _. max c fail \\<partial>measure_spmf (the_gpv gpv) +\n  max c fail * ennreal (pmf (the_gpv gpv) None)\n  \\<le> max c fail\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv \\<le> max c fail;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. c)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> max c fail", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + fail * ennreal (pmf (the_gpv gpv) None)\n      \\<le> y + fail * ennreal (pmf (the_gpv gpv) None)) \\<Longrightarrow>\n  integral\\<^sup>N (measure_spmf (the_gpv gpv))\n   (case_generat (\\<lambda>x. c)\n     (\\<lambda>out c.\n         \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))) +\n  fail * ennreal (pmf (the_gpv gpv) None)\n  \\<le> max c fail", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + fail * ennreal (pmf (the_gpv gpv) None)\n      \\<le> y + fail * ennreal (pmf (the_gpv gpv) None)) \\<Longrightarrow>\n  integral\\<^sup>N (measure_spmf (the_gpv gpv))\n   (case_generat (\\<lambda>x. c)\n     (\\<lambda>out c.\n         \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))) +\n  fail * ennreal (pmf (the_gpv gpv) None)\n  \\<le> max c fail\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> c\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail * ennreal (pmf (the_gpv gpv) None)\n    \\<le> max c fail", "by(simp add: add_mono)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> c\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  fail * ennreal (pmf (the_gpv gpv) None)\n  \\<le> max c fail\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma expectation_gpv_no_results:\n   \"\\<lbrakk> results_gpv \\<I> gpv = {}; \\<I> \\<turnstile>g gpv \\<surd> \\<rbrakk> \\<Longrightarrow> expectation_gpv 0 \\<I> f gpv = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>results_gpv \\<I> gpv = {};\n     \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n    \\<Longrightarrow> expectation_gpv 0 \\<I> f gpv = 0", "proof(induction arbitrary: gpv rule: expectation_gpv_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            results_gpv \\<I> x = {} \\<longrightarrow>\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow> a x = 0)\n 2. \\<And>gpv.\n       \\<lbrakk>results_gpv \\<I> gpv = {};\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> 0 = 0\n 3. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv.\n           \\<lbrakk>results_gpv \\<I> gpv = {};\n            \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv = 0;\n        results_gpv \\<I> gpv = {}; \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None) =\n                         0", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            results_gpv \\<I> x = {} \\<longrightarrow>\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow> a x = 0)\n 2. \\<And>gpv.\n       \\<lbrakk>results_gpv \\<I> gpv = {};\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> 0 = 0\n 3. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv.\n           \\<lbrakk>results_gpv \\<I> gpv = {};\n            \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv = 0;\n        results_gpv \\<I> gpv = {}; \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None) =\n                         0", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            results_gpv \\<I> x = {} \\<longrightarrow>\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow> a x = 0)", "by simp"], ["proof (state)\nthis:\n  lfp.admissible\n   (\\<lambda>a.\n       \\<forall>x.\n          results_gpv \\<I> x = {} \\<longrightarrow>\n          \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow> a x = 0)\n\ngoal (2 subgoals):\n 1. \\<And>gpv.\n       \\<lbrakk>results_gpv \\<I> gpv = {};\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> 0 = 0\n 2. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv.\n           \\<lbrakk>results_gpv \\<I> gpv = {};\n            \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv = 0;\n        results_gpv \\<I> gpv = {}; \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None) =\n                         0", "case bottom"], ["proof (state)\nthis:\n  results_gpv \\<I> gpv = {}\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>gpv.\n       \\<lbrakk>results_gpv \\<I> gpv = {};\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> 0 = 0\n 2. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv.\n           \\<lbrakk>results_gpv \\<I> gpv = {};\n            \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv = 0;\n        results_gpv \\<I> gpv = {}; \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None) =\n                         0", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = 0", "by simp"], ["proof (state)\nthis:\n  0 = 0\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv.\n           \\<lbrakk>results_gpv \\<I> gpv = {};\n            \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv = 0;\n        results_gpv \\<I> gpv = {}; \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None) =\n                         0", "case (step expectation_gpv')"], ["proof (state)\nthis:\n  expectation_gpv' ?gpv \\<le> expectation_gpv 0 \\<I> f ?gpv\n  \\<lbrakk>results_gpv \\<I> ?gpv = {};\n   \\<I> \\<turnstile>g ?gpv \\<surd>\\<rbrakk>\n  \\<Longrightarrow> expectation_gpv' ?gpv = 0\n  results_gpv \\<I> gpv = {}\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv.\n           \\<lbrakk>results_gpv \\<I> gpv = {};\n            \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv = 0;\n        results_gpv \\<I> gpv = {}; \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None) =\n                         0", "have \"results_gpv \\<I> (c x) = {}\" if \"IO out c \\<in> set_spmf (the_gpv gpv)\" \"x \\<in> responses_\\<I> \\<I> out\"\n    for out c x"], ["proof (prove)\ngoal (1 subgoal):\n 1. results_gpv \\<I> (c x) = {}", "using that step.prems(1)"], ["proof (prove)\nusing this:\n  IO out c \\<in> set_spmf (the_gpv gpv)\n  x \\<in> responses_\\<I> \\<I> out\n  results_gpv \\<I> gpv = {}\n\ngoal (1 subgoal):\n 1. results_gpv \\<I> (c x) = {}", "by(auto intro: results_gpv.IO)"], ["proof (state)\nthis:\n  \\<lbrakk>IO ?out ?c \\<in> set_spmf (the_gpv gpv);\n   ?x \\<in> responses_\\<I> \\<I> ?out\\<rbrakk>\n  \\<Longrightarrow> results_gpv \\<I> (?c ?x) = {}\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv.\n           \\<lbrakk>results_gpv \\<I> gpv = {};\n            \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv = 0;\n        results_gpv \\<I> gpv = {}; \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None) =\n                         0", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>IO ?out ?c \\<in> set_spmf (the_gpv gpv);\n   ?x \\<in> responses_\\<I> \\<I> ?out\\<rbrakk>\n  \\<Longrightarrow> results_gpv \\<I> (?c ?x) = {}", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>IO ?out ?c \\<in> set_spmf (the_gpv gpv);\n   ?x \\<in> responses_\\<I> \\<I> ?out\\<rbrakk>\n  \\<Longrightarrow> results_gpv \\<I> (?c ?x) = {}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    0 * ennreal (pmf (the_gpv gpv) None) =\n    0", "using step.prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>IO ?out ?c \\<in> set_spmf (the_gpv gpv);\n   ?x \\<in> responses_\\<I> \\<I> ?out\\<rbrakk>\n  \\<Longrightarrow> results_gpv \\<I> (?c ?x) = {}\n  results_gpv \\<I> gpv = {}\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    0 * ennreal (pmf (the_gpv gpv) None) =\n    0", "by(auto 4 4 intro!: nn_integral_zero' split: generat.split intro: results_gpv.Pure cong: INF_cong simp add: step.IH WT_gpv_ContD INF_constant in_outs_\\<I>_iff_responses_\\<I> dest: WT_gpv_OutD)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> f x\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  0 * ennreal (pmf (the_gpv gpv) None) =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma expectation_gpv_cmult:\n  fixes fail\n  assumes \"0 < c\" and \"c \\<noteq> \\<top>\"\n  shows \"c * expectation_gpv fail \\<I> f gpv = expectation_gpv (c * fail) \\<I> (\\<lambda>x. c * f x) gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * expectation_gpv fail \\<I> f gpv =\n    expectation_gpv (c * fail) \\<I> (\\<lambda>x. c * f x) gpv", "proof(induction arbitrary: gpv rule: parallel_fixp_induct_1_1[OF complete_lattice_partial_function_definitions complete_lattice_partial_function_definitions expectation_gpv.mono expectation_gpv.mono expectation_gpv_def expectation_gpv_def, case_names adm bottom step])"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x. \\<forall>xa. c * fst x xa = snd x xa)\n 2. \\<And>gpv. c * \\<Squnion> {} = \\<Squnion> {}\n 3. \\<And>fa g gpv.\n       (\\<And>gpv. c * fa gpv = g gpv) \\<Longrightarrow>\n       c *\n       (integral\\<^sup>N (measure_spmf (the_gpv gpv))\n         (case_generat f\n           (\\<lambda>out c.\n               \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. fa (c r))) +\n        fail * ennreal (pmf (the_gpv gpv) None)) =\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat (\\<lambda>x. c * f x)\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. g (c r))) +\n       c * fail * ennreal (pmf (the_gpv gpv) None)", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x. \\<forall>xa. c * fst x xa = snd x xa)\n 2. \\<And>gpv. c * \\<Squnion> {} = \\<Squnion> {}\n 3. \\<And>fa g gpv.\n       (\\<And>gpv. c * fa gpv = g gpv) \\<Longrightarrow>\n       c *\n       (integral\\<^sup>N (measure_spmf (the_gpv gpv))\n         (case_generat f\n           (\\<lambda>out c.\n               \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. fa (c r))) +\n        fail * ennreal (pmf (the_gpv gpv) None)) =\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat (\\<lambda>x. c * f x)\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. g (c r))) +\n       c * fail * ennreal (pmf (the_gpv gpv) None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x. \\<forall>xa. c * fst x xa = snd x xa)", "by simp"], ["proof (state)\nthis:\n  ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n   (rel_prod lfp.le_fun lfp.le_fun)\n   (\\<lambda>x. \\<forall>xa. c * fst x xa = snd x xa)\n\ngoal (2 subgoals):\n 1. \\<And>gpv. c * \\<Squnion> {} = \\<Squnion> {}\n 2. \\<And>fa g gpv.\n       (\\<And>gpv. c * fa gpv = g gpv) \\<Longrightarrow>\n       c *\n       (integral\\<^sup>N (measure_spmf (the_gpv gpv))\n         (case_generat f\n           (\\<lambda>out c.\n               \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. fa (c r))) +\n        fail * ennreal (pmf (the_gpv gpv) None)) =\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat (\\<lambda>x. c * f x)\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. g (c r))) +\n       c * fail * ennreal (pmf (the_gpv gpv) None)", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>gpv. c * \\<Squnion> {} = \\<Squnion> {}\n 2. \\<And>fa g gpv.\n       (\\<And>gpv. c * fa gpv = g gpv) \\<Longrightarrow>\n       c *\n       (integral\\<^sup>N (measure_spmf (the_gpv gpv))\n         (case_generat f\n           (\\<lambda>out c.\n               \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. fa (c r))) +\n        fail * ennreal (pmf (the_gpv gpv) None)) =\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat (\\<lambda>x. c * f x)\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. g (c r))) +\n       c * fail * ennreal (pmf (the_gpv gpv) None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. c * \\<Squnion> {} = \\<Squnion> {}", "by(simp add: bot_ennreal_def)"], ["proof (state)\nthis:\n  c * \\<Squnion> {} = \\<Squnion> {}\n\ngoal (1 subgoal):\n 1. \\<And>fa g gpv.\n       (\\<And>gpv. c * fa gpv = g gpv) \\<Longrightarrow>\n       c *\n       (integral\\<^sup>N (measure_spmf (the_gpv gpv))\n         (case_generat f\n           (\\<lambda>out c.\n               \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. fa (c r))) +\n        fail * ennreal (pmf (the_gpv gpv) None)) =\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat (\\<lambda>x. c * f x)\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. g (c r))) +\n       c * fail * ennreal (pmf (the_gpv gpv) None)", "case (step expectation_gpv' expectation_gpv'')"], ["proof (state)\nthis:\n  c * expectation_gpv' ?gpv = expectation_gpv'' ?gpv\n\ngoal (1 subgoal):\n 1. \\<And>fa g gpv.\n       (\\<And>gpv. c * fa gpv = g gpv) \\<Longrightarrow>\n       c *\n       (integral\\<^sup>N (measure_spmf (the_gpv gpv))\n         (case_generat f\n           (\\<lambda>out c.\n               \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. fa (c r))) +\n        fail * ennreal (pmf (the_gpv gpv) None)) =\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat (\\<lambda>x. c * f x)\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. g (c r))) +\n       c * fail * ennreal (pmf (the_gpv gpv) None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\n    (\\<integral>\\<^sup>+ generat.\n                          (case generat of Pure x \\<Rightarrow> f x\n                           | IO out c \\<Rightarrow>\n                               \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                  expectation_gpv' (c r))\n                        \\<partial>measure_spmf (the_gpv gpv) +\n     fail * ennreal (pmf (the_gpv gpv) None)) =\n    \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> c * f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv'' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    c * fail * ennreal (pmf (the_gpv gpv) None)", "using assms"], ["proof (prove)\nusing this:\n  0 < c\n  c \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. c *\n    (\\<integral>\\<^sup>+ generat.\n                          (case generat of Pure x \\<Rightarrow> f x\n                           | IO out c \\<Rightarrow>\n                               \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                  expectation_gpv' (c r))\n                        \\<partial>measure_spmf (the_gpv gpv) +\n     fail * ennreal (pmf (the_gpv gpv) None)) =\n    \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> c * f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv'' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    c * fail * ennreal (pmf (the_gpv gpv) None)", "apply(simp add: distrib_left mult_ac nn_integral_cmult[symmetric] generat.case_distrib[where h=\"(*) _\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < c; c \\<noteq> \\<top>\\<rbrakk>\n    \\<Longrightarrow> c * (fail * ennreal (pmf (the_gpv gpv) None)) =\n                      \\<top> \\<or>\n                      integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                       (case_generat (\\<lambda>x. c * f x)\n                         (\\<lambda>x1 x2.\n                             c *\n                             (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x1.\n                                 expectation_gpv' (x2 r)))) =\n                      integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                       (case_generat (\\<lambda>x. c * f x)\n                         (\\<lambda>out c.\n                             \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                expectation_gpv'' (c r)))", "apply(subst INF_mult_left_ennreal, simp_all add: step.IH)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  c *\n  (\\<integral>\\<^sup>+ generat.\n                        (case generat of Pure x \\<Rightarrow> f x\n                         | IO out c \\<Rightarrow>\n                             \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                expectation_gpv' (c r))\n                      \\<partial>measure_spmf (the_gpv gpv) +\n   fail * ennreal (pmf (the_gpv gpv) None)) =\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> c * f x\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv'' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  c * fail * ennreal (pmf (the_gpv gpv) None)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma expectation_gpv_le_exec_gpv:\n  assumes callee: \"\\<And>s x. x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> lossless_spmf (callee s x)\"\n    and WT_gpv: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and WT_callee: \"\\<And>s. \\<I> \\<turnstile>c callee s \\<surd>\"\n  shows \"expectation_gpv 0 \\<I> f gpv \\<le> \\<integral>\\<^sup>+ (x, s). f x \\<partial>measure_spmf (exec_gpv callee gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I> f gpv\n    \\<le> \\<integral>\\<^sup>+ (x, s). f x\n                             \\<partial>measure_spmf (exec_gpv callee gpv s)", "using WT_gpv"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I> f gpv\n    \\<le> \\<integral>\\<^sup>+ (x, s). f x\n                             \\<partial>measure_spmf (exec_gpv callee gpv s)", "proof(induction arbitrary: gpv s rule: parallel_fixp_induct_1_2[OF complete_lattice_partial_function_definitions partial_function_definitions_spmf expectation_gpv.mono exec_gpv.mono expectation_gpv_def exec_gpv_def, case_names adm bottom step])"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub lfp.lub_fun spmf.lub_fun)\n     (rel_prod lfp.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa.\n            \\<I> \\<turnstile>g xa \\<surd> \\<longrightarrow>\n            (\\<forall>xb.\n                fst x xa\n                \\<le> \\<integral>\\<^sup>+ (x, s). f x\n   \\<partial>measure_spmf (curry (snd x) xa xb)))\n 2. \\<And>gpv s.\n       \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n       \\<Squnion> {}\n       \\<le> \\<integral>\\<^sup>+ (x, s). f x\n                                \\<partial>measure_spmf (lub_spmf {})\n 3. \\<And>fa g gpv s.\n       \\<lbrakk>\\<And>gpv s.\n                   \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n                   fa gpv\n                   \\<le> \\<integral>\\<^sup>+ (x, s). f x\n      \\<partial>measure_spmf (g gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   fa (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> \\<integral>\\<^sup>+ (x, s). f x\n            \\<partial>measure_spmf\n                       (the_gpv gpv \\<bind>\n                        case_generat (\\<lambda>x. return_spmf (x, s))\n                         (\\<lambda>out c.\n                             callee s out \\<bind>\n                             (\\<lambda>(x, y). g (c x) y)))", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub lfp.lub_fun spmf.lub_fun)\n     (rel_prod lfp.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa.\n            \\<I> \\<turnstile>g xa \\<surd> \\<longrightarrow>\n            (\\<forall>xb.\n                fst x xa\n                \\<le> \\<integral>\\<^sup>+ (x, s). f x\n   \\<partial>measure_spmf (curry (snd x) xa xb)))\n 2. \\<And>gpv s.\n       \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n       \\<Squnion> {}\n       \\<le> \\<integral>\\<^sup>+ (x, s). f x\n                                \\<partial>measure_spmf (lub_spmf {})\n 3. \\<And>fa g gpv s.\n       \\<lbrakk>\\<And>gpv s.\n                   \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n                   fa gpv\n                   \\<le> \\<integral>\\<^sup>+ (x, s). f x\n      \\<partial>measure_spmf (g gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   fa (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> \\<integral>\\<^sup>+ (x, s). f x\n            \\<partial>measure_spmf\n                       (the_gpv gpv \\<bind>\n                        case_generat (\\<lambda>x. return_spmf (x, s))\n                         (\\<lambda>out c.\n                             callee s out \\<bind>\n                             (\\<lambda>(x, y). g (c x) y)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible (prod_lub lfp.lub_fun spmf.lub_fun)\n     (rel_prod lfp.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa.\n            \\<I> \\<turnstile>g xa \\<surd> \\<longrightarrow>\n            (\\<forall>xaa.\n                fst x xa\n                \\<le> \\<integral>\\<^sup>+ a.\n     (case a of (x, s) \\<Rightarrow> f x)\n   \\<partial>measure_spmf (curry (snd x) xa xaa)))", "by simp"], ["proof (state)\nthis:\n  ccpo.admissible (prod_lub lfp.lub_fun spmf.lub_fun)\n   (rel_prod lfp.le_fun spmf.le_fun)\n   (\\<lambda>x.\n       \\<forall>xa.\n          \\<I> \\<turnstile>g xa \\<surd> \\<longrightarrow>\n          (\\<forall>xaa.\n              fst x xa\n              \\<le> \\<integral>\\<^sup>+ a.\n   (case a of (x, s) \\<Rightarrow> f x)\n \\<partial>measure_spmf (curry (snd x) xa xaa)))\n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n       \\<Squnion> {}\n       \\<le> \\<integral>\\<^sup>+ (x, s). f x\n                                \\<partial>measure_spmf (lub_spmf {})\n 2. \\<And>fa g gpv s.\n       \\<lbrakk>\\<And>gpv s.\n                   \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n                   fa gpv\n                   \\<le> \\<integral>\\<^sup>+ (x, s). f x\n      \\<partial>measure_spmf (g gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   fa (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> \\<integral>\\<^sup>+ (x, s). f x\n            \\<partial>measure_spmf\n                       (the_gpv gpv \\<bind>\n                        case_generat (\\<lambda>x. return_spmf (x, s))\n                         (\\<lambda>out c.\n                             callee s out \\<bind>\n                             (\\<lambda>(x, y). g (c x) y)))", "case bottom"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n       \\<Squnion> {}\n       \\<le> \\<integral>\\<^sup>+ (x, s). f x\n                                \\<partial>measure_spmf (lub_spmf {})\n 2. \\<And>fa g gpv s.\n       \\<lbrakk>\\<And>gpv s.\n                   \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n                   fa gpv\n                   \\<le> \\<integral>\\<^sup>+ (x, s). f x\n      \\<partial>measure_spmf (g gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   fa (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> \\<integral>\\<^sup>+ (x, s). f x\n            \\<partial>measure_spmf\n                       (the_gpv gpv \\<bind>\n                        case_generat (\\<lambda>x. return_spmf (x, s))\n                         (\\<lambda>out c.\n                             callee s out \\<bind>\n                             (\\<lambda>(x, y). g (c x) y)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> {}\n    \\<le> \\<integral>\\<^sup>+ a. (case a of (x, s) \\<Rightarrow> f x)\n                             \\<partial>measure_spmf (lub_spmf {})", "by(simp add: bot_ennreal_def)"], ["proof (state)\nthis:\n  \\<Squnion> {}\n  \\<le> \\<integral>\\<^sup>+ a. (case a of (x, s) \\<Rightarrow> f x)\n                           \\<partial>measure_spmf (lub_spmf {})\n\ngoal (1 subgoal):\n 1. \\<And>fa g gpv s.\n       \\<lbrakk>\\<And>gpv s.\n                   \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n                   fa gpv\n                   \\<le> \\<integral>\\<^sup>+ (x, s). f x\n      \\<partial>measure_spmf (g gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   fa (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> \\<integral>\\<^sup>+ (x, s). f x\n            \\<partial>measure_spmf\n                       (the_gpv gpv \\<bind>\n                        case_generat (\\<lambda>x. return_spmf (x, s))\n                         (\\<lambda>out c.\n                             callee s out \\<bind>\n                             (\\<lambda>(x, y). g (c x) y)))", "case (step expectation_gpv'' exec_gpv')"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>g ?gpv \\<surd> \\<Longrightarrow>\n  expectation_gpv'' ?gpv\n  \\<le> \\<integral>\\<^sup>+ a. (case a of (x, s) \\<Rightarrow> f x)\n                           \\<partial>measure_spmf (exec_gpv' ?gpv ?s)\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>fa g gpv s.\n       \\<lbrakk>\\<And>gpv s.\n                   \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n                   fa gpv\n                   \\<le> \\<integral>\\<^sup>+ (x, s). f x\n      \\<partial>measure_spmf (g gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   fa (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> \\<integral>\\<^sup>+ (x, s). f x\n            \\<partial>measure_spmf\n                       (the_gpv gpv \\<bind>\n                        case_generat (\\<lambda>x. return_spmf (x, s))\n                         (\\<lambda>out c.\n                             callee s out \\<bind>\n                             (\\<lambda>(x, y). g (c x) y)))", "have *: \"(INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv'' (c r)) \\<le> \\<integral>\\<^sup>+ (x, s). f x \\<partial>measure_spmf (bind_spmf (callee s out) (\\<lambda>(r, s'). exec_gpv' (c r) s'))\" (is \"?lhs \\<le> ?rhs\")\n    if \"IO out c \\<in> set_spmf (the_gpv gpv)\" for out c"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv'' (c r))\n    \\<le> \\<integral>\\<^sup>+ (x, s). f x\n                             \\<partial>measure_spmf\n  (callee s out \\<bind> (\\<lambda>(r, s'). exec_gpv' (c r) s'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv'' (c r))\n    \\<le> \\<integral>\\<^sup>+ (x, s). f x\n                             \\<partial>measure_spmf\n  (callee s out \\<bind> (\\<lambda>(r, s'). exec_gpv' (c r) s'))", "from step.prems that"], ["proof (chain)\npicking this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  IO out c \\<in> set_spmf (the_gpv gpv)", "have out: \"out \\<in> outs_\\<I> \\<I>\""], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  IO out c \\<in> set_spmf (the_gpv gpv)\n\ngoal (1 subgoal):\n 1. out \\<in> outs_\\<I> \\<I>", "by(rule WT_gpvD)"], ["proof (state)\nthis:\n  out \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv'' (c r))\n    \\<le> \\<integral>\\<^sup>+ (x, s). f x\n                             \\<partial>measure_spmf\n  (callee s out \\<bind> (\\<lambda>(r, s'). exec_gpv' (c r) s'))", "have \"?lhs = \\<integral>\\<^sup>+ _. ?lhs \\<partial>measure_spmf (callee s out)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv'' (c r)) =\n    \\<integral>\\<^sup>+ _. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv'' (c r))\n                       \\<partial>measure_spmf (callee s out)", "using callee[OF out, THEN lossless_weight_spmfD]"], ["proof (prove)\nusing this:\n  weight_spmf (callee ?s1 out) = 1\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv'' (c r)) =\n    \\<integral>\\<^sup>+ _. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv'' (c r))\n                       \\<partial>measure_spmf (callee s out)", "by(simp add: measure_spmf.emeasure_eq_measure)"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv'' (c r)) =\n  \\<integral>\\<^sup>+ _. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                             expectation_gpv'' (c r))\n                     \\<partial>measure_spmf (callee s out)\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv'' (c r))\n    \\<le> \\<integral>\\<^sup>+ (x, s). f x\n                             \\<partial>measure_spmf\n  (callee s out \\<bind> (\\<lambda>(r, s'). exec_gpv' (c r) s'))", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv'' (c r)) =\n  \\<integral>\\<^sup>+ _. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                             expectation_gpv'' (c r))\n                     \\<partial>measure_spmf (callee s out)\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv'' (c r))\n    \\<le> \\<integral>\\<^sup>+ (x, s). f x\n                             \\<partial>measure_spmf\n  (callee s out \\<bind> (\\<lambda>(r, s'). exec_gpv' (c r) s'))", "have \"\\<dots> \\<le> \\<integral>\\<^sup>+ (r, s'). expectation_gpv'' (c r) \\<partial>measure_spmf (callee s out)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ _. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv'' (c r))\n                       \\<partial>measure_spmf (callee s out)\n    \\<le> \\<integral>\\<^sup>+ (r, s'). expectation_gpv'' (c r)\n                             \\<partial>measure_spmf (callee s out)", "by(rule nn_integral_mono_AE)(auto intro: WT_calleeD[OF WT_callee _ out] INF_lower)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ _. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                             expectation_gpv'' (c r))\n                     \\<partial>measure_spmf (callee s out)\n  \\<le> \\<integral>\\<^sup>+ (r, s'). expectation_gpv'' (c r)\n                           \\<partial>measure_spmf (callee s out)\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv'' (c r))\n    \\<le> \\<integral>\\<^sup>+ (x, s). f x\n                             \\<partial>measure_spmf\n  (callee s out \\<bind> (\\<lambda>(r, s'). exec_gpv' (c r) s'))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ _. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                             expectation_gpv'' (c r))\n                     \\<partial>measure_spmf (callee s out)\n  \\<le> \\<integral>\\<^sup>+ (r, s'). expectation_gpv'' (c r)\n                           \\<partial>measure_spmf (callee s out)\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv'' (c r))\n    \\<le> \\<integral>\\<^sup>+ (x, s). f x\n                             \\<partial>measure_spmf\n  (callee s out \\<bind> (\\<lambda>(r, s'). exec_gpv' (c r) s'))", "have \"\\<dots> \\<le> \\<integral>\\<^sup>+ (r, s'). \\<integral>\\<^sup>+ (x, _). f x \\<partial>measure_spmf (exec_gpv' (c r) s') \\<partial>measure_spmf (callee s out)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ (r, s'). expectation_gpv'' (c r)\n                       \\<partial>measure_spmf (callee s out)\n    \\<le> \\<integral>\\<^sup>+ (r, s').\n                               \\<integral>\\<^sup>+ (x, uu_). f x\n            \\<partial>measure_spmf (exec_gpv' (c r) s')\n                             \\<partial>measure_spmf (callee s out)", "by(rule nn_integral_mono_AE)(auto intro!: step.IH intro: WT_gpv_ContD[OF step.prems that] WT_calleeD[OF WT_callee _ out])"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ (r, s'). expectation_gpv'' (c r)\n                     \\<partial>measure_spmf (callee s out)\n  \\<le> \\<integral>\\<^sup>+ (r, s').\n                             \\<integral>\\<^sup>+ (x, uu_). f x\n          \\<partial>measure_spmf (exec_gpv' (c r) s')\n                           \\<partial>measure_spmf (callee s out)\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv'' (c r))\n    \\<le> \\<integral>\\<^sup>+ (x, s). f x\n                             \\<partial>measure_spmf\n  (callee s out \\<bind> (\\<lambda>(r, s'). exec_gpv' (c r) s'))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ (r, s'). expectation_gpv'' (c r)\n                     \\<partial>measure_spmf (callee s out)\n  \\<le> \\<integral>\\<^sup>+ (r, s').\n                             \\<integral>\\<^sup>+ (x, uu_). f x\n          \\<partial>measure_spmf (exec_gpv' (c r) s')\n                           \\<partial>measure_spmf (callee s out)\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv'' (c r))\n    \\<le> \\<integral>\\<^sup>+ (x, s). f x\n                             \\<partial>measure_spmf\n  (callee s out \\<bind> (\\<lambda>(r, s'). exec_gpv' (c r) s'))", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ (r, s').\n                         \\<integral>\\<^sup>+ (x, uu_). f x\n      \\<partial>measure_spmf (exec_gpv' (c r) s')\n                       \\<partial>measure_spmf (callee s out) =\n    \\<integral>\\<^sup>+ (x, s). f x\n                       \\<partial>measure_spmf\n                                  (callee s out \\<bind>\n                                   (\\<lambda>(r, s'). exec_gpv' (c r) s'))", "by(simp add: measure_spmf_bind split_def nn_integral_bind[where B=\"measure_spmf _\"] o_def space_subprob_algebra)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ (r, s').\n                       \\<integral>\\<^sup>+ (x, uu_). f x\n    \\<partial>measure_spmf (exec_gpv' (c r) s')\n                     \\<partial>measure_spmf (callee s out) =\n  \\<integral>\\<^sup>+ (x, s). f x\n                     \\<partial>measure_spmf\n                                (callee s out \\<bind>\n                                 (\\<lambda>(r, s'). exec_gpv' (c r) s'))\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv'' (c r))\n    \\<le> \\<integral>\\<^sup>+ (x, s). f x\n                             \\<partial>measure_spmf\n  (callee s out \\<bind> (\\<lambda>(r, s'). exec_gpv' (c r) s'))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv'' (c r))\n  \\<le> \\<integral>\\<^sup>+ (x, s). f x\n                           \\<partial>measure_spmf\n(callee s out \\<bind> (\\<lambda>(r, s'). exec_gpv' (c r) s'))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv'' (c r))\n  \\<le> \\<integral>\\<^sup>+ (x, s). f x\n                           \\<partial>measure_spmf\n(callee s out \\<bind> (\\<lambda>(r, s'). exec_gpv' (c r) s'))\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv'' (c r))\n    \\<le> \\<integral>\\<^sup>+ (x, s). f x\n                             \\<partial>measure_spmf\n  (callee s out \\<bind> (\\<lambda>(r, s'). exec_gpv' (c r) s'))", "."], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv'' (c r))\n  \\<le> \\<integral>\\<^sup>+ (x, s). f x\n                           \\<partial>measure_spmf\n(callee s out \\<bind> (\\<lambda>(r, s'). exec_gpv' (c r) s'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  IO ?out ?c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> ?out. expectation_gpv'' (?c r))\n  \\<le> \\<integral>\\<^sup>+ (x, s). f x\n                           \\<partial>measure_spmf\n(callee s ?out \\<bind> (\\<lambda>(r, s'). exec_gpv' (?c r) s'))\n\ngoal (1 subgoal):\n 1. \\<And>fa g gpv s.\n       \\<lbrakk>\\<And>gpv s.\n                   \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n                   fa gpv\n                   \\<le> \\<integral>\\<^sup>+ (x, s). f x\n      \\<partial>measure_spmf (g gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   fa (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> \\<integral>\\<^sup>+ (x, s). f x\n            \\<partial>measure_spmf\n                       (the_gpv gpv \\<bind>\n                        case_generat (\\<lambda>x. return_spmf (x, s))\n                         (\\<lambda>out c.\n                             callee s out \\<bind>\n                             (\\<lambda>(x, y). g (c x) y)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv'' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    0 * ennreal (pmf (the_gpv gpv) None)\n    \\<le> \\<integral>\\<^sup>+ a. (case a of (x, s) \\<Rightarrow> f x)\n                             \\<partial>measure_spmf\n  (the_gpv gpv \\<bind>\n   (\\<lambda>a.\n       case a of Pure x \\<Rightarrow> return_spmf (x, s)\n       | IO out c \\<Rightarrow>\n           callee s out \\<bind>\n           (\\<lambda>a. case a of (x, y) \\<Rightarrow> exec_gpv' (c x) y)))", "by(simp add: measure_spmf_bind nn_integral_bind[where B=\"measure_spmf _\"] space_subprob_algebra)\n      (simp split!: generat.split add: measure_spmf_return_spmf nn_integral_return * nn_integral_mono_AE)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> f x\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv'' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  0 * ennreal (pmf (the_gpv gpv) None)\n  \\<le> \\<integral>\\<^sup>+ a. (case a of (x, s) \\<Rightarrow> f x)\n                           \\<partial>measure_spmf\n(the_gpv gpv \\<bind>\n (\\<lambda>a.\n     case a of Pure x \\<Rightarrow> return_spmf (x, s)\n     | IO out c \\<Rightarrow>\n         callee s out \\<bind>\n         (\\<lambda>a. case a of (x, y) \\<Rightarrow> exec_gpv' (c x) y)))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition weight_gpv :: \"('out, 'ret) \\<I> \\<Rightarrow> ('a, 'out, 'ret) gpv \\<Rightarrow> real\"\n  where \"weight_gpv \\<I> gpv = enn2real (expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv)\""], ["", "lemma weight_gpv_Done [simp]: \"weight_gpv \\<I> (Done x) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight_gpv \\<I> (Generative_Probabilistic_Value.Done x) = 1", "by(simp add: weight_gpv_def)"], ["", "lemma weight_gpv_Fail [simp]: \"weight_gpv \\<I> Fail = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight_gpv \\<I> Fail = 0", "by(simp add: weight_gpv_def)"], ["", "lemma weight_gpv_lift_spmf [simp]: \"weight_gpv \\<I> (lift_spmf p) = weight_spmf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight_gpv \\<I> (lift_spmf p) = weight_spmf p", "by(simp add: weight_gpv_def measure_spmf.emeasure_eq_measure)"], ["", "lemma weight_gpv_Pause [simp]:\n  \"(\\<And>r. r \\<in> responses_\\<I> \\<I> out \\<Longrightarrow> \\<I> \\<turnstile>g c r \\<surd>)\n   \\<Longrightarrow> weight_gpv \\<I> (Pause out c) = (if out \\<in> outs_\\<I> \\<I> then INF r\\<in>responses_\\<I> \\<I> out. weight_gpv \\<I> (c r) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        r \\<in> responses_\\<I> \\<I> out \\<Longrightarrow>\n        \\<I> \\<turnstile>g c r \\<surd>) \\<Longrightarrow>\n    weight_gpv \\<I> (Generative_Probabilistic_Value.Pause out c) =\n    (if out \\<in> outs_\\<I> \\<I>\n     then \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. weight_gpv \\<I> (c r)\n     else 0)", "apply(clarsimp simp add: weight_gpv_def in_outs_\\<I>_iff_responses_\\<I>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r.\n                r \\<in> responses_\\<I> \\<I> out \\<Longrightarrow>\n                \\<I> \\<turnstile>g c r \\<surd>;\n     responses_\\<I> \\<I> out \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> enn2real\n                       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                           expectation_gpv 0 \\<I> (\\<lambda>_. 1) (c r)) =\n                      (\\<Sqinter>x\\<in>responses_\\<I> \\<I> out.\n                          enn2real\n                           (expectation_gpv 0 \\<I> (\\<lambda>_. 1) (c x)))", "apply(erule enn2real_INF)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        r \\<in> responses_\\<I> \\<I> out \\<Longrightarrow>\n        \\<I> \\<turnstile>g c r \\<surd>) \\<Longrightarrow>\n    \\<forall>r\\<in>responses_\\<I> \\<I> out.\n       expectation_gpv 0 \\<I> (\\<lambda>_. 1) (c r) < \\<top>", "apply(clarsimp simp add: expectation_gpv_const_le[THEN le_less_trans])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma weight_gpv_nonneg: \"0 \\<le> weight_gpv \\<I> gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> weight_gpv \\<I> gpv", "by(simp add: weight_gpv_def)"], ["", "lemma weight_gpv_le_1: \"\\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow> weight_gpv \\<I> gpv \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n    weight_gpv \\<I> gpv \\<le> 1", "using expectation_gpv_const_le[of \\<I> gpv 0 1]"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv \\<le> max 1 0\n\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n    weight_gpv \\<I> gpv \\<le> 1", "by(simp add: weight_gpv_def enn2real_leI max_def)"], ["", "theorem weight_exec_gpv:\n  assumes callee: \"\\<And>s x. x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> lossless_spmf (callee s x)\"\n    and WT_gpv: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and WT_callee: \"\\<And>s. \\<I> \\<turnstile>c callee s \\<surd>\"\n  shows \"weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "have \"expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv \\<le> \\<integral>\\<^sup>+ (x, s). 1 \\<partial>measure_spmf (exec_gpv callee gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n    \\<le> \\<integral>\\<^sup>+ (x, s). 1\n                             \\<partial>measure_spmf (exec_gpv callee gpv s)", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> lossless_spmf (callee ?s ?x)\n  \\<I> \\<turnstile>g gpv \\<surd>\n  \\<I> \\<turnstile>c callee ?s \\<surd>\n\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n    \\<le> \\<integral>\\<^sup>+ (x, s). 1\n                             \\<partial>measure_spmf (exec_gpv callee gpv s)", "by(rule expectation_gpv_le_exec_gpv)"], ["proof (state)\nthis:\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n  \\<le> \\<integral>\\<^sup>+ (x, s). 1\n                           \\<partial>measure_spmf (exec_gpv callee gpv s)\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "also"], ["proof (state)\nthis:\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n  \\<le> \\<integral>\\<^sup>+ (x, s). 1\n                           \\<partial>measure_spmf (exec_gpv callee gpv s)\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "have \"\\<dots> = weight_spmf (exec_gpv callee gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ (x, s). 1\n                       \\<partial>measure_spmf (exec_gpv callee gpv s) =\n    ennreal (weight_spmf (exec_gpv callee gpv s))", "by(simp add: split_def measure_spmf.emeasure_eq_measure)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ (x, s). 1\n                     \\<partial>measure_spmf (exec_gpv callee gpv s) =\n  ennreal (weight_spmf (exec_gpv callee gpv s))\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "finally"], ["proof (chain)\npicking this:\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n  \\<le> ennreal (weight_spmf (exec_gpv callee gpv s))", "show ?thesis"], ["proof (prove)\nusing this:\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n  \\<le> ennreal (weight_spmf (exec_gpv callee gpv s))\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "by(simp add: weight_gpv_def enn2real_leI)"], ["proof (state)\nthis:\n  weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in callee_invariant_on) weight_exec_gpv:\n  assumes callee: \"\\<And>s x. \\<lbrakk> x \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> lossless_spmf (callee s x)\"\n  and WT_gpv: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n  and I: \"I s\"\n  shows \"weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "including lifting_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "assume \"\\<exists>(Rep :: 's' \\<Rightarrow> 's) Abs. type_definition Rep Abs {s. I s}\""], ["proof (state)\nthis:\n  \\<exists>Rep Abs. type_definition Rep Abs {s. I s}\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "then"], ["proof (chain)\npicking this:\n  \\<exists>Rep Abs. type_definition Rep Abs {s. I s}", "obtain Rep :: \"'s' \\<Rightarrow> 's\" and Abs where td: \"type_definition Rep Abs {s. I s}\""], ["proof (prove)\nusing this:\n  \\<exists>Rep Abs. type_definition Rep Abs {s. I s}\n\ngoal (1 subgoal):\n 1. (\\<And>Rep Abs.\n        type_definition Rep Abs {s. I s} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  type_definition Rep Abs {s. I s}\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "then"], ["proof (chain)\npicking this:\n  type_definition Rep Abs {s. I s}", "interpret td: type_definition Rep Abs \"{s. I s}\""], ["proof (prove)\nusing this:\n  type_definition Rep Abs {s. I s}\n\ngoal (1 subgoal):\n 1. type_definition Rep Abs {s. I s}", "."], ["proof (state)\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "define cr where \"cr \\<equiv> \\<lambda>x y. x = Rep y\""], ["proof (state)\nthis:\n  cr \\<equiv> \\<lambda>x y. x = Rep y\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "have [transfer_rule]: \"bi_unique cr\" \"right_total cr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique cr &&& right_total cr", "using td cr_def"], ["proof (prove)\nusing this:\n  type_definition Rep Abs {s. I s}\n  cr \\<equiv> \\<lambda>x y. x = Rep y\n\ngoal (1 subgoal):\n 1. bi_unique cr &&& right_total cr", "by(rule typedef_bi_unique typedef_right_total)+"], ["proof (state)\nthis:\n  bi_unique cr\n  right_total cr\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "have [transfer_domain_rule]: \"Domainp cr = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp cr = I", "using type_definition_Domainp[OF td cr_def]"], ["proof (prove)\nusing this:\n  Domainp cr = (\\<lambda>x. x \\<in> {s. I s})\n\ngoal (1 subgoal):\n 1. Domainp cr = I", "by simp"], ["proof (state)\nthis:\n  Domainp cr = I\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "let ?C = \"eq_onp (\\<lambda>x. x \\<in> outs_\\<I> \\<I>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "define callee' where \"callee' \\<equiv> (Rep ---> id ---> map_spmf (map_prod id Abs)) callee\""], ["proof (state)\nthis:\n  callee' \\<equiv> (Rep ---> id ---> map_spmf (map_prod id Abs)) callee\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "have [transfer_rule]: \"(cr ===> ?C ===> rel_spmf (rel_prod (=) cr)) callee callee'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr ===>\n     eq_onp (\\<lambda>x. x \\<in> outs_\\<I> \\<I>) ===>\n     rel_spmf (rel_prod (=) cr))\n     callee callee'", "by(auto simp add: callee'_def rel_fun_def cr_def spmf_rel_map prod.rel_map td.Abs_inverse eq_onp_def intro!: rel_spmf_reflI intro: td.Rep[simplified] dest: callee_invariant)"], ["proof (state)\nthis:\n  (cr ===>\n   eq_onp (\\<lambda>x. x \\<in> outs_\\<I> \\<I>) ===>\n   rel_spmf (rel_prod (=) cr))\n   callee callee'\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "define s' where \"s' \\<equiv> Abs s\""], ["proof (state)\nthis:\n  s' \\<equiv> Abs s\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "have [transfer_rule]: \"cr s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cr s s'", "using I"], ["proof (prove)\nusing this:\n  I s\n\ngoal (1 subgoal):\n 1. cr s s'", "by(simp add: cr_def s'_def td.Abs_inverse)"], ["proof (state)\nthis:\n  cr s s'\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "have [transfer_rule]: \"rel_\\<I> ?C (=) \\<I> \\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_\\<I> (eq_onp (\\<lambda>x. x \\<in> outs_\\<I> \\<I>)) (=) \\<I> \\<I>", "by(rule rel_\\<I>I)(auto simp add: rel_set_eq set_relator_eq_onp eq_onp_same_args dest: eq_onp_to_eq)"], ["proof (state)\nthis:\n  rel_\\<I> (eq_onp (\\<lambda>x. x \\<in> outs_\\<I> \\<I>)) (=) \\<I> \\<I>\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "note [transfer_rule] = bi_unique_eq_onp bi_unique_eq"], ["proof (state)\nthis:\n  bi_unique (eq_onp ?P)\n  bi_unique (=)\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "define gpv' where \"gpv' \\<equiv> restrict_gpv \\<I> gpv\""], ["proof (state)\nthis:\n  gpv' \\<equiv> restrict_gpv \\<I> gpv\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "have [transfer_rule]: \"rel_gpv (=) ?C gpv' gpv'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_gpv (=) (eq_onp (\\<lambda>x. x \\<in> outs_\\<I> \\<I>)) gpv' gpv'", "by(fold eq_onp_top_eq_eq)(auto simp add: gpv.rel_eq_onp eq_onp_same_args pred_gpv_def gpv'_def dest: in_outs'_restrict_gpvD)"], ["proof (state)\nthis:\n  rel_gpv (=) (eq_onp (\\<lambda>x. x \\<in> outs_\\<I> \\<I>)) gpv' gpv'\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "define weight_spmf' :: \"('c \\<times> 's') spmf \\<Rightarrow> real\" where \"weight_spmf' \\<equiv> weight_spmf\""], ["proof (state)\nthis:\n  weight_spmf' \\<equiv> weight_spmf\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "define weight_spmf'' :: \"('c \\<times> 's) spmf \\<Rightarrow> real\" where \"weight_spmf'' \\<equiv> weight_spmf\""], ["proof (state)\nthis:\n  weight_spmf'' \\<equiv> weight_spmf\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "have [transfer_rule]: \"(rel_spmf (rel_prod (=) cr) ===> (=)) weight_spmf'' weight_spmf'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_spmf (rel_prod (=) cr) ===> (=)) weight_spmf'' weight_spmf'", "by(simp add: weight_spmf'_def weight_spmf''_def weight_spmf_parametric)"], ["proof (state)\nthis:\n  (rel_spmf (rel_prod (=) cr) ===> (=)) weight_spmf'' weight_spmf'\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "have [rule_format]: \"\\<And>s. \\<forall>x \\<in> outs_\\<I> \\<I>. lossless_spmf (callee' s x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. \\<forall>x\\<in>outs_\\<I> \\<I>. lossless_spmf (callee' s x)", "by(transfer)(blast intro: callee)"], ["proof (state)\nthis:\n  ?x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> lossless_spmf (callee' ?s ?x)\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> lossless_spmf (callee' ?s ?x)\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "have \"\\<I> \\<turnstile>g gpv' \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>g gpv' \\<surd>", "by(simp add: gpv'_def)"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>g gpv' \\<surd>\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "moreover"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>g gpv' \\<surd>\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "have \"\\<And>s. \\<I> \\<turnstile>c callee' s \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. \\<I> \\<turnstile>c callee' s \\<surd>", "by transfer(rule WT_callee)"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>c callee' ?s1 \\<surd>\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "ultimately"], ["proof (chain)\npicking this:\n  ?x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> lossless_spmf (callee' ?s ?x)\n  \\<I> \\<turnstile>g gpv' \\<surd>\n  \\<I> \\<turnstile>c callee' ?s1 \\<surd>", "have **: \"weight_gpv \\<I> gpv' \\<le> weight_spmf' (exec_gpv callee' gpv' s')\""], ["proof (prove)\nusing this:\n  ?x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> lossless_spmf (callee' ?s ?x)\n  \\<I> \\<turnstile>g gpv' \\<surd>\n  \\<I> \\<turnstile>c callee' ?s1 \\<surd>\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv' \\<le> weight_spmf' (exec_gpv callee' gpv' s')", "unfolding weight_spmf'_def"], ["proof (prove)\nusing this:\n  ?x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> lossless_spmf (callee' ?s ?x)\n  \\<I> \\<turnstile>g gpv' \\<surd>\n  \\<I> \\<turnstile>c callee' ?s1 \\<surd>\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv' \\<le> weight_spmf (exec_gpv callee' gpv' s')", "by(rule weight_exec_gpv)"], ["proof (state)\nthis:\n  weight_gpv \\<I> gpv' \\<le> weight_spmf' (exec_gpv callee' gpv' s')\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "have [transfer_rule]: \"((=) ===> ?C ===> rel_spmf (rel_prod (=) (=))) callee callee\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===>\n     eq_onp (\\<lambda>x. x \\<in> outs_\\<I> \\<I>) ===>\n     rel_spmf (rel_prod (=) (=)))\n     callee callee", "by(simp add: rel_fun_def eq_onp_def prod.rel_eq)"], ["proof (state)\nthis:\n  ((=) ===>\n   eq_onp (\\<lambda>x. x \\<in> outs_\\<I> \\<I>) ===>\n   rel_spmf (rel_prod (=) (=)))\n   callee callee\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "have \"weight_gpv \\<I> gpv' \\<le> weight_spmf'' (exec_gpv callee gpv' s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv' \\<le> weight_spmf'' (exec_gpv callee gpv' s)", "using **"], ["proof (prove)\nusing this:\n  weight_gpv \\<I> gpv' \\<le> weight_spmf' (exec_gpv callee' gpv' s')\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv' \\<le> weight_spmf'' (exec_gpv callee gpv' s)", "by transfer"], ["proof (state)\nthis:\n  weight_gpv \\<I> gpv' \\<le> weight_spmf'' (exec_gpv callee gpv' s)\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "also"], ["proof (state)\nthis:\n  weight_gpv \\<I> gpv' \\<le> weight_spmf'' (exec_gpv callee gpv' s)\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "have \"exec_gpv callee gpv' s = exec_gpv callee gpv s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_gpv callee gpv' s = exec_gpv callee gpv s", "unfolding gpv'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_gpv callee (restrict_gpv \\<I> gpv) s = exec_gpv callee gpv s", "using WT_gpv I"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. exec_gpv callee (restrict_gpv \\<I> gpv) s = exec_gpv callee gpv s", "by(rule exec_gpv_restrict_gpv_invariant)"], ["proof (state)\nthis:\n  exec_gpv callee gpv' s = exec_gpv callee gpv s\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "also"], ["proof (state)\nthis:\n  exec_gpv callee gpv' s = exec_gpv callee gpv s\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "have \"weight_gpv \\<I> gpv' = weight_gpv \\<I> gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv' = weight_gpv \\<I> gpv", "using WT_gpv"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv' = weight_gpv \\<I> gpv", "by(simp add: gpv'_def expectation_gpv_restrict_gpv weight_gpv_def)"], ["proof (state)\nthis:\n  weight_gpv \\<I> gpv' = weight_gpv \\<I> gpv\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "finally"], ["proof (chain)\npicking this:\n  weight_gpv \\<I> gpv \\<le> weight_spmf'' (exec_gpv callee gpv s)", "have ?thesis"], ["proof (prove)\nusing this:\n  weight_gpv \\<I> gpv \\<le> weight_spmf'' (exec_gpv callee gpv s)\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "by(simp add: weight_spmf''_def)"], ["proof (state)\nthis:\n  weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "}"], ["proof (state)\nthis:\n  \\<exists>Rep Abs. type_definition Rep Abs {s. I s} \\<Longrightarrow>\n  weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "from this[cancel_type_definition] I"], ["proof (chain)\npicking this:\n  {s. I s} \\<noteq> {} \\<Longrightarrow>\n  weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)\n  I s", "show ?thesis"], ["proof (prove)\nusing this:\n  {s. I s} \\<noteq> {} \\<Longrightarrow>\n  weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)\n  I s\n\ngoal (1 subgoal):\n 1. weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)", "by blast"], ["proof (state)\nthis:\n  weight_gpv \\<I> gpv \\<le> weight_spmf (exec_gpv callee gpv s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Probabilistic termination\\<close>"], ["", "definition pgen_lossless_gpv :: \"ennreal \\<Rightarrow> ('c, 'r) \\<I> \\<Rightarrow> ('a, 'c, 'r) gpv \\<Rightarrow> bool\"\nwhere \"pgen_lossless_gpv fail \\<I> gpv = (expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv = 1)\" for fail"], ["", "abbreviation plossless_gpv :: \"('c, 'r) \\<I> \\<Rightarrow> ('a, 'c, 'r) gpv \\<Rightarrow> bool\"\nwhere \"plossless_gpv \\<equiv> pgen_lossless_gpv 0\""], ["", "abbreviation pfinite_gpv :: \"('c, 'r) \\<I> \\<Rightarrow> ('a, 'c, 'r) gpv \\<Rightarrow> bool\"\nwhere \"pfinite_gpv \\<equiv> pgen_lossless_gpv 1\""], ["", "lemma pgen_lossless_gpvI [intro?]: \"expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv = 1 \\<Longrightarrow> pgen_lossless_gpv fail \\<I> gpv\" for fail"], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv = 1 \\<Longrightarrow>\n    pgen_lossless_gpv fail \\<I> gpv", "by(simp add: pgen_lossless_gpv_def)"], ["", "lemma pgen_lossless_gpvD: \"pgen_lossless_gpv fail \\<I> gpv \\<Longrightarrow> expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv = 1\" for fail"], ["proof (prove)\ngoal (1 subgoal):\n 1. pgen_lossless_gpv fail \\<I> gpv \\<Longrightarrow>\n    expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv = 1", "by(simp add: pgen_lossless_gpv_def)"], ["", "lemma lossless_imp_plossless_gpv:\n  assumes \"lossless_gpv \\<I> gpv\" \"\\<I> \\<turnstile>g gpv \\<surd>\"\n  shows \"plossless_gpv \\<I> gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_gpv \\<I> gpv", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv = 1", "show \"expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv = 1", "using assms"], ["proof (prove)\nusing this:\n  lossless_gpv \\<I> gpv\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv = 1", "proof(induction rule: lossless_WT_gpv_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>lossless_spmf p;\n        \\<And>out c.\n           IO out c \\<in> set_spmf p \\<Longrightarrow>\n           out \\<in> outs_\\<I> \\<I>;\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf p;\n            out \\<in> outs_\\<I> \\<I> \\<Longrightarrow>\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> lossless_gpv \\<I> (c input);\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf p;\n            out \\<in> outs_\\<I> \\<I> \\<Longrightarrow>\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> \\<I> \\<turnstile>g c input \\<surd>;\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf p;\n            out \\<in> outs_\\<I> \\<I> \\<Longrightarrow>\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv 0 \\<I> (\\<lambda>_. 1)\n                              (c input) =\n                             1\\<rbrakk>\n       \\<Longrightarrow> expectation_gpv 0 \\<I> (\\<lambda>_. 1) (GPV p) = 1", "case (lossless_gpv p)"], ["proof (state)\nthis:\n  lossless_spmf p\n  IO ?out ?c \\<in> set_spmf p \\<Longrightarrow> ?out \\<in> outs_\\<I> \\<I>\n  \\<lbrakk>IO ?out ?c \\<in> set_spmf p;\n   ?out \\<in> outs_\\<I> \\<I> \\<Longrightarrow>\n   ?input \\<in> responses_\\<I> \\<I> ?out\\<rbrakk>\n  \\<Longrightarrow> lossless_gpv \\<I> (?c ?input)\n  \\<lbrakk>IO ?out ?c \\<in> set_spmf p;\n   ?out \\<in> outs_\\<I> \\<I> \\<Longrightarrow>\n   ?input \\<in> responses_\\<I> \\<I> ?out\\<rbrakk>\n  \\<Longrightarrow> \\<I> \\<turnstile>g ?c ?input \\<surd>\n  \\<lbrakk>IO ?out ?c \\<in> set_spmf p;\n   ?out \\<in> outs_\\<I> \\<I> \\<Longrightarrow>\n   ?input \\<in> responses_\\<I> \\<I> ?out\\<rbrakk>\n  \\<Longrightarrow> expectation_gpv 0 \\<I> (\\<lambda>_. 1) (?c ?input) = 1\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>lossless_spmf p;\n        \\<And>out c.\n           IO out c \\<in> set_spmf p \\<Longrightarrow>\n           out \\<in> outs_\\<I> \\<I>;\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf p;\n            out \\<in> outs_\\<I> \\<I> \\<Longrightarrow>\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> lossless_gpv \\<I> (c input);\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf p;\n            out \\<in> outs_\\<I> \\<I> \\<Longrightarrow>\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> \\<I> \\<turnstile>g c input \\<surd>;\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf p;\n            out \\<in> outs_\\<I> \\<I> \\<Longrightarrow>\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv 0 \\<I> (\\<lambda>_. 1)\n                              (c input) =\n                             1\\<rbrakk>\n       \\<Longrightarrow> expectation_gpv 0 \\<I> (\\<lambda>_. 1) (GPV p) = 1", "have \"expectation_gpv 0 \\<I> (\\<lambda>_. 1) (GPV p) = nn_integral (measure_spmf p) (case_generat (\\<lambda>_. 1) (\\<lambda>out c. INF r\\<in>responses_\\<I> \\<I> out. 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I> (\\<lambda>_. 1) (GPV p) =\n    integral\\<^sup>N (measure_spmf p)\n     (case_generat (\\<lambda>_. 1)\n       (\\<lambda>out c. \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. 1))", "by(subst expectation_gpv.simps)(clarsimp split: generat.split cong: INF_cong simp add: lossless_gpv.IH intro!: nn_integral_cong_AE)"], ["proof (state)\nthis:\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) (GPV p) =\n  integral\\<^sup>N (measure_spmf p)\n   (case_generat (\\<lambda>_. 1)\n     (\\<lambda>out c. \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. 1))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>lossless_spmf p;\n        \\<And>out c.\n           IO out c \\<in> set_spmf p \\<Longrightarrow>\n           out \\<in> outs_\\<I> \\<I>;\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf p;\n            out \\<in> outs_\\<I> \\<I> \\<Longrightarrow>\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> lossless_gpv \\<I> (c input);\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf p;\n            out \\<in> outs_\\<I> \\<I> \\<Longrightarrow>\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> \\<I> \\<turnstile>g c input \\<surd>;\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf p;\n            out \\<in> outs_\\<I> \\<I> \\<Longrightarrow>\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv 0 \\<I> (\\<lambda>_. 1)\n                              (c input) =\n                             1\\<rbrakk>\n       \\<Longrightarrow> expectation_gpv 0 \\<I> (\\<lambda>_. 1) (GPV p) = 1", "also"], ["proof (state)\nthis:\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) (GPV p) =\n  integral\\<^sup>N (measure_spmf p)\n   (case_generat (\\<lambda>_. 1)\n     (\\<lambda>out c. \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. 1))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>lossless_spmf p;\n        \\<And>out c.\n           IO out c \\<in> set_spmf p \\<Longrightarrow>\n           out \\<in> outs_\\<I> \\<I>;\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf p;\n            out \\<in> outs_\\<I> \\<I> \\<Longrightarrow>\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> lossless_gpv \\<I> (c input);\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf p;\n            out \\<in> outs_\\<I> \\<I> \\<Longrightarrow>\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> \\<I> \\<turnstile>g c input \\<surd>;\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf p;\n            out \\<in> outs_\\<I> \\<I> \\<Longrightarrow>\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv 0 \\<I> (\\<lambda>_. 1)\n                              (c input) =\n                             1\\<rbrakk>\n       \\<Longrightarrow> expectation_gpv 0 \\<I> (\\<lambda>_. 1) (GPV p) = 1", "have \"\\<dots> = nn_integral (measure_spmf p) (\\<lambda>_. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (measure_spmf p)\n     (case_generat (\\<lambda>_. 1)\n       (\\<lambda>out c. \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. 1)) =\n    \\<integral>\\<^sup>+ _. 1 \\<partial>measure_spmf p", "by(intro nn_integral_cong_AE)(auto split: generat.split dest!: lossless_gpv.hyps(2) simp add: in_outs_\\<I>_iff_responses_\\<I>)"], ["proof (state)\nthis:\n  integral\\<^sup>N (measure_spmf p)\n   (case_generat (\\<lambda>_. 1)\n     (\\<lambda>out c. \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. 1)) =\n  \\<integral>\\<^sup>+ _. 1 \\<partial>measure_spmf p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>lossless_spmf p;\n        \\<And>out c.\n           IO out c \\<in> set_spmf p \\<Longrightarrow>\n           out \\<in> outs_\\<I> \\<I>;\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf p;\n            out \\<in> outs_\\<I> \\<I> \\<Longrightarrow>\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> lossless_gpv \\<I> (c input);\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf p;\n            out \\<in> outs_\\<I> \\<I> \\<Longrightarrow>\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> \\<I> \\<turnstile>g c input \\<surd>;\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf p;\n            out \\<in> outs_\\<I> \\<I> \\<Longrightarrow>\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv 0 \\<I> (\\<lambda>_. 1)\n                              (c input) =\n                             1\\<rbrakk>\n       \\<Longrightarrow> expectation_gpv 0 \\<I> (\\<lambda>_. 1) (GPV p) = 1", "finally"], ["proof (chain)\npicking this:\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) (GPV p) =\n  \\<integral>\\<^sup>+ _. 1 \\<partial>measure_spmf p", "show ?case"], ["proof (prove)\nusing this:\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) (GPV p) =\n  \\<integral>\\<^sup>+ _. 1 \\<partial>measure_spmf p\n\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I> (\\<lambda>_. 1) (GPV p) = 1", "by(simp add: measure_spmf.emeasure_eq_measure lossless_weight_spmfD lossless_gpv.hyps(1))"], ["proof (state)\nthis:\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) (GPV p) = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_imp_pfinite_gpv:\n  assumes \"finite_gpv \\<I> gpv\" \"\\<I> \\<turnstile>g gpv \\<surd>\"\n  shows \"pfinite_gpv \\<I> gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_gpv \\<I> gpv", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv = 1", "show \"expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv = 1", "using assms"], ["proof (prove)\nusing this:\n  finite_gpv \\<I> gpv\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv = 1", "proof(induction rule: finite_gpv_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>gpv.\n       \\<lbrakk>\\<And>out c input.\n                   \\<lbrakk>IO out c \\<in> set_spmf (the_gpv gpv);\n                    input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n                   \\<Longrightarrow> finite_gpv \\<I> (c input);\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf (the_gpv gpv);\n            input \\<in> responses_\\<I> \\<I> out;\n            \\<I> \\<turnstile>g c input \\<surd>\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv 1 \\<I> (\\<lambda>_. 1)\n                              (c input) =\n                             1;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv = 1", "case (finite_gpv gpv)"], ["proof (state)\nthis:\n  \\<lbrakk>IO ?out ?c \\<in> set_spmf (the_gpv gpv);\n   ?input \\<in> responses_\\<I> \\<I> ?out\\<rbrakk>\n  \\<Longrightarrow> finite_gpv \\<I> (?c ?input)\n  \\<lbrakk>IO ?out ?c \\<in> set_spmf (the_gpv gpv);\n   ?input \\<in> responses_\\<I> \\<I> ?out;\n   \\<I> \\<turnstile>g ?c ?input \\<surd>\\<rbrakk>\n  \\<Longrightarrow> expectation_gpv 1 \\<I> (\\<lambda>_. 1) (?c ?input) = 1\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>gpv.\n       \\<lbrakk>\\<And>out c input.\n                   \\<lbrakk>IO out c \\<in> set_spmf (the_gpv gpv);\n                    input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n                   \\<Longrightarrow> finite_gpv \\<I> (c input);\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf (the_gpv gpv);\n            input \\<in> responses_\\<I> \\<I> out;\n            \\<I> \\<turnstile>g c input \\<surd>\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv 1 \\<I> (\\<lambda>_. 1)\n                              (c input) =\n                             1;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv = 1", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>IO ?out ?c \\<in> set_spmf (the_gpv gpv);\n   ?input \\<in> responses_\\<I> \\<I> ?out\\<rbrakk>\n  \\<Longrightarrow> finite_gpv \\<I> (?c ?input)\n  \\<lbrakk>IO ?out ?c \\<in> set_spmf (the_gpv gpv);\n   ?input \\<in> responses_\\<I> \\<I> ?out;\n   \\<I> \\<turnstile>g ?c ?input \\<surd>\\<rbrakk>\n  \\<Longrightarrow> expectation_gpv 1 \\<I> (\\<lambda>_. 1) (?c ?input) = 1\n  \\<I> \\<turnstile>g gpv \\<surd>", "have \"expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv = nn_integral (measure_spmf (the_gpv gpv)) (case_generat (\\<lambda>_. 1) (\\<lambda>out c. INF r\\<in>responses_\\<I> \\<I> out. 1)) + pmf (the_gpv gpv) None\""], ["proof (prove)\nusing this:\n  \\<lbrakk>IO ?out ?c \\<in> set_spmf (the_gpv gpv);\n   ?input \\<in> responses_\\<I> \\<I> ?out\\<rbrakk>\n  \\<Longrightarrow> finite_gpv \\<I> (?c ?input)\n  \\<lbrakk>IO ?out ?c \\<in> set_spmf (the_gpv gpv);\n   ?input \\<in> responses_\\<I> \\<I> ?out;\n   \\<I> \\<turnstile>g ?c ?input \\<surd>\\<rbrakk>\n  \\<Longrightarrow> expectation_gpv 1 \\<I> (\\<lambda>_. 1) (?c ?input) = 1\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv =\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat (\\<lambda>_. 1)\n       (\\<lambda>out c. \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. 1)) +\n    ennreal (pmf (the_gpv gpv) None)", "by(subst expectation_gpv.simps)(clarsimp intro!: nn_integral_cong_AE INF_cong[OF refl] split!: generat.split simp add: WT_gpv_ContD)"], ["proof (state)\nthis:\n  expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv =\n  integral\\<^sup>N (measure_spmf (the_gpv gpv))\n   (case_generat (\\<lambda>_. 1)\n     (\\<lambda>out c. \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. 1)) +\n  ennreal (pmf (the_gpv gpv) None)\n\ngoal (1 subgoal):\n 1. \\<And>gpv.\n       \\<lbrakk>\\<And>out c input.\n                   \\<lbrakk>IO out c \\<in> set_spmf (the_gpv gpv);\n                    input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n                   \\<Longrightarrow> finite_gpv \\<I> (c input);\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf (the_gpv gpv);\n            input \\<in> responses_\\<I> \\<I> out;\n            \\<I> \\<turnstile>g c input \\<surd>\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv 1 \\<I> (\\<lambda>_. 1)\n                              (c input) =\n                             1;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv = 1", "also"], ["proof (state)\nthis:\n  expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv =\n  integral\\<^sup>N (measure_spmf (the_gpv gpv))\n   (case_generat (\\<lambda>_. 1)\n     (\\<lambda>out c. \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. 1)) +\n  ennreal (pmf (the_gpv gpv) None)\n\ngoal (1 subgoal):\n 1. \\<And>gpv.\n       \\<lbrakk>\\<And>out c input.\n                   \\<lbrakk>IO out c \\<in> set_spmf (the_gpv gpv);\n                    input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n                   \\<Longrightarrow> finite_gpv \\<I> (c input);\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf (the_gpv gpv);\n            input \\<in> responses_\\<I> \\<I> out;\n            \\<I> \\<turnstile>g c input \\<surd>\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv 1 \\<I> (\\<lambda>_. 1)\n                              (c input) =\n                             1;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv = 1", "have \"\\<dots> = nn_integral (measure_spmf (the_gpv gpv)) (\\<lambda>_. 1) + pmf (the_gpv gpv) None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat (\\<lambda>_. 1)\n       (\\<lambda>out c. \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. 1)) +\n    ennreal (pmf (the_gpv gpv) None) =\n    \\<integral>\\<^sup>+ _. 1 \\<partial>measure_spmf (the_gpv gpv) +\n    ennreal (pmf (the_gpv gpv) None)", "by(intro arg_cong2[where f=\"(+)\"] nn_integral_cong_AE)\n        (auto split: generat.split dest!: WT_gpv_OutD[OF finite_gpv.prems] simp add: in_outs_\\<I>_iff_responses_\\<I>)"], ["proof (state)\nthis:\n  integral\\<^sup>N (measure_spmf (the_gpv gpv))\n   (case_generat (\\<lambda>_. 1)\n     (\\<lambda>out c. \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. 1)) +\n  ennreal (pmf (the_gpv gpv) None) =\n  \\<integral>\\<^sup>+ _. 1 \\<partial>measure_spmf (the_gpv gpv) +\n  ennreal (pmf (the_gpv gpv) None)\n\ngoal (1 subgoal):\n 1. \\<And>gpv.\n       \\<lbrakk>\\<And>out c input.\n                   \\<lbrakk>IO out c \\<in> set_spmf (the_gpv gpv);\n                    input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n                   \\<Longrightarrow> finite_gpv \\<I> (c input);\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf (the_gpv gpv);\n            input \\<in> responses_\\<I> \\<I> out;\n            \\<I> \\<turnstile>g c input \\<surd>\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv 1 \\<I> (\\<lambda>_. 1)\n                              (c input) =\n                             1;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv = 1", "finally"], ["proof (chain)\npicking this:\n  expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv =\n  \\<integral>\\<^sup>+ _. 1 \\<partial>measure_spmf (the_gpv gpv) +\n  ennreal (pmf (the_gpv gpv) None)", "show ?case"], ["proof (prove)\nusing this:\n  expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv =\n  \\<integral>\\<^sup>+ _. 1 \\<partial>measure_spmf (the_gpv gpv) +\n  ennreal (pmf (the_gpv gpv) None)\n\ngoal (1 subgoal):\n 1. expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv = 1", "by(simp add: measure_spmf.emeasure_eq_measure ennreal_plus[symmetric] del: ennreal_plus)\n        (simp add: pmf_None_eq_weight_spmf)"], ["proof (state)\nthis:\n  expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma plossless_gpv_lossless_spmfD:\n  assumes lossless: \"plossless_gpv \\<I> gpv\"\n  and WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n  shows \"lossless_spmf (the_gpv gpv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (the_gpv gpv)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lossless_spmf (the_gpv gpv)", "have \"1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv", "using lossless"], ["proof (prove)\nusing this:\n  plossless_gpv \\<I> gpv\n\ngoal (1 subgoal):\n 1. 1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv", "by(auto dest: pgen_lossless_gpvD simp add: weight_gpv_def)"], ["proof (state)\nthis:\n  1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n\ngoal (1 subgoal):\n 1. lossless_spmf (the_gpv gpv)", "also"], ["proof (state)\nthis:\n  1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n\ngoal (1 subgoal):\n 1. lossless_spmf (the_gpv gpv)", "have \"\\<dots> = \\<integral>\\<^sup>+ generat. (case generat of Pure x \\<Rightarrow> 1 | IO out c \\<Rightarrow> INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv 0 \\<I> (\\<lambda>_. 1) (c r)) \\<partial>measure_spmf (the_gpv gpv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv =\n    \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> 1\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv 0 \\<I> (\\<lambda>_. 1)\n                                  (c r))\n                       \\<partial>measure_spmf (the_gpv gpv)", "by(subst expectation_gpv.simps)(auto)"], ["proof (state)\nthis:\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv =\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> 1\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv 0 \\<I> (\\<lambda>_. 1) (c r))\n                     \\<partial>measure_spmf (the_gpv gpv)\n\ngoal (1 subgoal):\n 1. lossless_spmf (the_gpv gpv)", "also"], ["proof (state)\nthis:\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv =\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> 1\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv 0 \\<I> (\\<lambda>_. 1) (c r))\n                     \\<partial>measure_spmf (the_gpv gpv)\n\ngoal (1 subgoal):\n 1. lossless_spmf (the_gpv gpv)", "have \"\\<dots> \\<le> \\<integral>\\<^sup>+ generat. (case generat of Pure x \\<Rightarrow> 1 | IO out c \\<Rightarrow> 1) \\<partial>measure_spmf (the_gpv gpv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> 1\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv 0 \\<I> (\\<lambda>_. 1)\n                                  (c r))\n                       \\<partial>measure_spmf (the_gpv gpv)\n    \\<le> \\<integral>\\<^sup>+ generat.\n                               (case generat of Pure x \\<Rightarrow> 1\n                                | _ \\<Rightarrow> 1)\n                             \\<partial>measure_spmf (the_gpv gpv)", "apply(rule nn_integral_mono_AE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x in measure_spmf\n             (the_gpv\n               gpv). (case x of Pure x \\<Rightarrow> 1\n                      | IO out c \\<Rightarrow>\n                          \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                             expectation_gpv 0 \\<I> (\\<lambda>_. 1) (c r))\n                     \\<le> (case x of Pure x \\<Rightarrow> 1\n                            | _ \\<Rightarrow> 1)", "apply(clarsimp split: generat.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n           expectation_gpv 0 \\<I> (\\<lambda>_. 1) (x22 r))\n       \\<le> 1", "apply(frule WT_gpv_OutD[OF WT])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>IO x21 x22 \\<in> set_spmf (the_gpv gpv);\n        x21 \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv 0 \\<I> (\\<lambda>_. 1) (x22 r))\n                         \\<le> 1", "using expectation_gpv_const_le[of \\<I> _ 0 1]"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g ?gpv \\<surd> \\<Longrightarrow>\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) ?gpv \\<le> max 1 0\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>IO x21 x22 \\<in> set_spmf (the_gpv gpv);\n        x21 \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv 0 \\<I> (\\<lambda>_. 1) (x22 r))\n                         \\<le> 1", "apply(auto simp add: in_outs_\\<I>_iff_responses_\\<I> max_def intro: INF_lower2 WT_gpv_ContD[OF WT] dest: WT_gpv_OutD[OF WT])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> 1\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv 0 \\<I> (\\<lambda>_. 1) (c r))\n                     \\<partial>measure_spmf (the_gpv gpv)\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (case generat of Pure x \\<Rightarrow> 1\n                              | _ \\<Rightarrow> 1)\n                           \\<partial>measure_spmf (the_gpv gpv)\n\ngoal (1 subgoal):\n 1. lossless_spmf (the_gpv gpv)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> 1\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv 0 \\<I> (\\<lambda>_. 1) (c r))\n                     \\<partial>measure_spmf (the_gpv gpv)\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (case generat of Pure x \\<Rightarrow> 1\n                              | _ \\<Rightarrow> 1)\n                           \\<partial>measure_spmf (the_gpv gpv)\n\ngoal (1 subgoal):\n 1. lossless_spmf (the_gpv gpv)", "have \"\\<dots> = weight_spmf (the_gpv gpv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> 1\n                          | _ \\<Rightarrow> 1)\n                       \\<partial>measure_spmf (the_gpv gpv) =\n    ennreal (weight_spmf (the_gpv gpv))", "by(auto simp add: weight_spmf_eq_nn_integral_spmf nn_integral_measure_spmf intro!: nn_integral_cong split: generat.split)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> 1\n                        | _ \\<Rightarrow> 1)\n                     \\<partial>measure_spmf (the_gpv gpv) =\n  ennreal (weight_spmf (the_gpv gpv))\n\ngoal (1 subgoal):\n 1. lossless_spmf (the_gpv gpv)", "finally"], ["proof (chain)\npicking this:\n  1 \\<le> ennreal (weight_spmf (the_gpv gpv))", "show ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> ennreal (weight_spmf (the_gpv gpv))\n\ngoal (1 subgoal):\n 1. lossless_spmf (the_gpv gpv)", "using weight_spmf_le_1[of \"the_gpv gpv\"]"], ["proof (prove)\nusing this:\n  1 \\<le> ennreal (weight_spmf (the_gpv gpv))\n  weight_spmf (the_gpv gpv) \\<le> 1\n\ngoal (1 subgoal):\n 1. lossless_spmf (the_gpv gpv)", "by(simp add: lossless_spmf_def)"], ["proof (state)\nthis:\n  lossless_spmf (the_gpv gpv)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  shows plossless_gpv_ContD:\n  \"\\<lbrakk> plossless_gpv \\<I> gpv; IO out c \\<in> set_spmf (the_gpv gpv); input \\<in> responses_\\<I> \\<I> out; \\<I> \\<turnstile>g gpv \\<surd> \\<rbrakk>\n  \\<Longrightarrow> plossless_gpv \\<I> (c input)\"\n  and pfinite_gpv_ContD:\n  \"\\<lbrakk> pfinite_gpv \\<I> gpv; IO out c \\<in> set_spmf (the_gpv gpv); input \\<in> responses_\\<I> \\<I> out; \\<I> \\<turnstile>g gpv \\<surd> \\<rbrakk>\n  \\<Longrightarrow> pfinite_gpv \\<I> (c input)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>plossless_gpv \\<I> gpv; IO out c \\<in> set_spmf (the_gpv gpv);\n      input \\<in> responses_\\<I> \\<I> out;\n      \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n     \\<Longrightarrow> plossless_gpv \\<I> (c input)) &&&\n    (\\<lbrakk>pfinite_gpv \\<I> gpv; IO out c \\<in> set_spmf (the_gpv gpv);\n      input \\<in> responses_\\<I> \\<I> out;\n      \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n     \\<Longrightarrow> pfinite_gpv \\<I> (c input))", "proof(rule_tac [!] pgen_lossless_gpvI, rule_tac [!] antisym[rotated], rule_tac ccontr, rule_tac [3] ccontr)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>plossless_gpv \\<I> gpv; IO out c \\<in> set_spmf (the_gpv gpv);\n     input \\<in> responses_\\<I> \\<I> out; \\<I> \\<turnstile>g gpv \\<surd>;\n     \\<not> 1 \\<le> expectation_gpv 0 \\<I> (\\<lambda>_. 1)\n                     (c input)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>plossless_gpv \\<I> gpv; IO out c \\<in> set_spmf (the_gpv gpv);\n     input \\<in> responses_\\<I> \\<I> out;\n     \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n    \\<Longrightarrow> expectation_gpv 0 \\<I> (\\<lambda>_. 1) (c input)\n                      \\<le> 1\n 3. \\<lbrakk>pfinite_gpv \\<I> gpv; IO out c \\<in> set_spmf (the_gpv gpv);\n     input \\<in> responses_\\<I> \\<I> out; \\<I> \\<turnstile>g gpv \\<surd>;\n     \\<not> 1 \\<le> expectation_gpv 1 \\<I> (\\<lambda>_. 1)\n                     (c input)\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>pfinite_gpv \\<I> gpv; IO out c \\<in> set_spmf (the_gpv gpv);\n     input \\<in> responses_\\<I> \\<I> out;\n     \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n    \\<Longrightarrow> expectation_gpv 1 \\<I> (\\<lambda>_. 1) (c input)\n                      \\<le> 1", "assume IO: \"IO out c \\<in> set_spmf (the_gpv gpv)\"\n    and input: \"input \\<in> responses_\\<I> \\<I> out\"\n    and WT: \"\\<I> \\<turnstile>g gpv \\<surd>\""], ["proof (state)\nthis:\n  IO out c \\<in> set_spmf (the_gpv gpv)\n  input \\<in> responses_\\<I> \\<I> out\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (4 subgoals):\n 1. \\<lbrakk>plossless_gpv \\<I> gpv; IO out c \\<in> set_spmf (the_gpv gpv);\n     input \\<in> responses_\\<I> \\<I> out; \\<I> \\<turnstile>g gpv \\<surd>;\n     \\<not> 1 \\<le> expectation_gpv 0 \\<I> (\\<lambda>_. 1)\n                     (c input)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>plossless_gpv \\<I> gpv; IO out c \\<in> set_spmf (the_gpv gpv);\n     input \\<in> responses_\\<I> \\<I> out;\n     \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n    \\<Longrightarrow> expectation_gpv 0 \\<I> (\\<lambda>_. 1) (c input)\n                      \\<le> 1\n 3. \\<lbrakk>pfinite_gpv \\<I> gpv; IO out c \\<in> set_spmf (the_gpv gpv);\n     input \\<in> responses_\\<I> \\<I> out; \\<I> \\<turnstile>g gpv \\<surd>;\n     \\<not> 1 \\<le> expectation_gpv 1 \\<I> (\\<lambda>_. 1)\n                     (c input)\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>pfinite_gpv \\<I> gpv; IO out c \\<in> set_spmf (the_gpv gpv);\n     input \\<in> responses_\\<I> \\<I> out;\n     \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n    \\<Longrightarrow> expectation_gpv 1 \\<I> (\\<lambda>_. 1) (c input)\n                      \\<le> 1", "from WT IO input"], ["proof (chain)\npicking this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  IO out c \\<in> set_spmf (the_gpv gpv)\n  input \\<in> responses_\\<I> \\<I> out", "have WT': \"\\<I> \\<turnstile>g c input \\<surd>\""], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  IO out c \\<in> set_spmf (the_gpv gpv)\n  input \\<in> responses_\\<I> \\<I> out\n\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>g c input \\<surd>", "by(rule WT_gpv_ContD)"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>g c input \\<surd>\n\ngoal (4 subgoals):\n 1. \\<lbrakk>plossless_gpv \\<I> gpv; IO out c \\<in> set_spmf (the_gpv gpv);\n     input \\<in> responses_\\<I> \\<I> out; \\<I> \\<turnstile>g gpv \\<surd>;\n     \\<not> 1 \\<le> expectation_gpv 0 \\<I> (\\<lambda>_. 1)\n                     (c input)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>plossless_gpv \\<I> gpv; IO out c \\<in> set_spmf (the_gpv gpv);\n     input \\<in> responses_\\<I> \\<I> out;\n     \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n    \\<Longrightarrow> expectation_gpv 0 \\<I> (\\<lambda>_. 1) (c input)\n                      \\<le> 1\n 3. \\<lbrakk>pfinite_gpv \\<I> gpv; IO out c \\<in> set_spmf (the_gpv gpv);\n     input \\<in> responses_\\<I> \\<I> out; \\<I> \\<turnstile>g gpv \\<surd>;\n     \\<not> 1 \\<le> expectation_gpv 1 \\<I> (\\<lambda>_. 1)\n                     (c input)\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>pfinite_gpv \\<I> gpv; IO out c \\<in> set_spmf (the_gpv gpv);\n     input \\<in> responses_\\<I> \\<I> out;\n     \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n    \\<Longrightarrow> expectation_gpv 1 \\<I> (\\<lambda>_. 1) (c input)\n                      \\<le> 1", "from expectation_gpv_const_le[OF this, of 0 1] expectation_gpv_const_le[OF this, of 1 1]"], ["proof (chain)\npicking this:\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) (c input) \\<le> max 1 0\n  expectation_gpv 1 \\<I> (\\<lambda>_. 1) (c input) \\<le> max 1 1", "show \"expectation_gpv 0 \\<I> (\\<lambda>_. 1) (c input) \\<le> 1\"\n    and \"expectation_gpv 1 \\<I> (\\<lambda>_. 1) (c input) \\<le> 1\""], ["proof (prove)\nusing this:\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) (c input) \\<le> max 1 0\n  expectation_gpv 1 \\<I> (\\<lambda>_. 1) (c input) \\<le> max 1 1\n\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I> (\\<lambda>_. 1) (c input) \\<le> 1 &&&\n    expectation_gpv 1 \\<I> (\\<lambda>_. 1) (c input) \\<le> 1", "by(simp_all add: max_def)"], ["proof (state)\nthis:\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) (c input) \\<le> 1\n  expectation_gpv 1 \\<I> (\\<lambda>_. 1) (c input) \\<le> 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>plossless_gpv \\<I> gpv; IO out c \\<in> set_spmf (the_gpv gpv);\n     input \\<in> responses_\\<I> \\<I> out; \\<I> \\<turnstile>g gpv \\<surd>;\n     \\<not> 1 \\<le> expectation_gpv 0 \\<I> (\\<lambda>_. 1)\n                     (c input)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>pfinite_gpv \\<I> gpv; IO out c \\<in> set_spmf (the_gpv gpv);\n     input \\<in> responses_\\<I> \\<I> out; \\<I> \\<turnstile>g gpv \\<surd>;\n     \\<not> 1 \\<le> expectation_gpv 1 \\<I> (\\<lambda>_. 1)\n                     (c input)\\<rbrakk>\n    \\<Longrightarrow> False", "have less: \"expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv < weight_spmf (the_gpv gpv) + fail * pmf (the_gpv gpv) None\"\n    if fail: \"fail \\<le> 1\" and *: \"\\<not> 1 \\<le> expectation_gpv fail \\<I> (\\<lambda>_. 1) (c input)\" for fail :: ennreal"], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n    < ennreal (weight_spmf (the_gpv gpv)) +\n      fail * ennreal (pmf (the_gpv gpv) None)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n    < ennreal (weight_spmf (the_gpv gpv)) +\n      fail * ennreal (pmf (the_gpv gpv) None)", "have \"expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv = (\\<integral>\\<^sup>+ generat. (case generat of Pure x \\<Rightarrow> 1 | IO out c \\<Rightarrow> INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) * spmf (the_gpv gpv) generat * indicator (UNIV - {IO out c}) generat + (INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) * spmf (the_gpv gpv) (IO out c) * indicator {IO out c} generat \\<partial>count_space UNIV) + fail * pmf (the_gpv gpv) None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv =\n    (\\<Sum>\\<^sup>+ generat.\n       (case generat of Pure x \\<Rightarrow> 1\n        | IO out c \\<Rightarrow>\n            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n               expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n       ennreal (spmf (the_gpv gpv) generat) *\n       indicator (UNIV - {IO out c}) generat +\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n           expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n       ennreal (spmf (the_gpv gpv) (IO out c)) *\n       indicator {IO out c} generat) +\n    fail * ennreal (pmf (the_gpv gpv) None)", "by(subst expectation_gpv.simps)(auto simp add: nn_integral_measure_spmf mult.commute intro!: nn_integral_cong split: split_indicator generat.split)"], ["proof (state)\nthis:\n  expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv =\n  (\\<Sum>\\<^sup>+ generat.\n     (case generat of Pure x \\<Rightarrow> 1\n      | IO out c \\<Rightarrow>\n          \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n             expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n     ennreal (spmf (the_gpv gpv) generat) *\n     indicator (UNIV - {IO out c}) generat +\n     (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n         expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n     ennreal (spmf (the_gpv gpv) (IO out c)) *\n     indicator {IO out c} generat) +\n  fail * ennreal (pmf (the_gpv gpv) None)\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n    < ennreal (weight_spmf (the_gpv gpv)) +\n      fail * ennreal (pmf (the_gpv gpv) None)", "also"], ["proof (state)\nthis:\n  expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv =\n  (\\<Sum>\\<^sup>+ generat.\n     (case generat of Pure x \\<Rightarrow> 1\n      | IO out c \\<Rightarrow>\n          \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n             expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n     ennreal (spmf (the_gpv gpv) generat) *\n     indicator (UNIV - {IO out c}) generat +\n     (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n         expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n     ennreal (spmf (the_gpv gpv) (IO out c)) *\n     indicator {IO out c} generat) +\n  fail * ennreal (pmf (the_gpv gpv) None)\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n    < ennreal (weight_spmf (the_gpv gpv)) +\n      fail * ennreal (pmf (the_gpv gpv) None)", "have \"\\<dots> = (\\<integral>\\<^sup>+ generat. (case generat of Pure x \\<Rightarrow> 1 | IO out c \\<Rightarrow> INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) * spmf (the_gpv gpv) generat * indicator (UNIV - {IO out c}) generat \\<partial>count_space UNIV) +\n      (INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) * spmf (the_gpv gpv) (IO out c) + fail * pmf (the_gpv gpv) None\" (is \"_ = ?rest + ?cr + _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ generat.\n       (case generat of Pure x \\<Rightarrow> 1\n        | IO out c \\<Rightarrow>\n            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n               expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n       ennreal (spmf (the_gpv gpv) generat) *\n       indicator (UNIV - {IO out c}) generat +\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n           expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n       ennreal (spmf (the_gpv gpv) (IO out c)) *\n       indicator {IO out c} generat) +\n    fail * ennreal (pmf (the_gpv gpv) None) =\n    (\\<integral>\\<^sup>+generat\\<in>UNIV - {IO out c}.\n                        ((case generat of Pure x \\<Rightarrow> 1\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv fail \\<I> (\\<lambda>_. 1)\n                                  (c r)) *\n                         ennreal (spmf (the_gpv gpv) generat))\n     \\<partial>count_space UNIV) +\n    (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n        expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n    ennreal (spmf (the_gpv gpv) (IO out c)) +\n    fail * ennreal (pmf (the_gpv gpv) None)", "by(subst nn_integral_add) simp_all"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ generat.\n     (case generat of Pure x \\<Rightarrow> 1\n      | IO out c \\<Rightarrow>\n          \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n             expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n     ennreal (spmf (the_gpv gpv) generat) *\n     indicator (UNIV - {IO out c}) generat +\n     (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n         expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n     ennreal (spmf (the_gpv gpv) (IO out c)) *\n     indicator {IO out c} generat) +\n  fail * ennreal (pmf (the_gpv gpv) None) =\n  (\\<integral>\\<^sup>+generat\\<in>UNIV - {IO out c}.\n                      ((case generat of Pure x \\<Rightarrow> 1\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv fail \\<I> (\\<lambda>_. 1)\n                                (c r)) *\n                       ennreal (spmf (the_gpv gpv) generat))\n   \\<partial>count_space UNIV) +\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n      expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n  ennreal (spmf (the_gpv gpv) (IO out c)) +\n  fail * ennreal (pmf (the_gpv gpv) None)\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n    < ennreal (weight_spmf (the_gpv gpv)) +\n      fail * ennreal (pmf (the_gpv gpv) None)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ generat.\n     (case generat of Pure x \\<Rightarrow> 1\n      | IO out c \\<Rightarrow>\n          \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n             expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n     ennreal (spmf (the_gpv gpv) generat) *\n     indicator (UNIV - {IO out c}) generat +\n     (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n         expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n     ennreal (spmf (the_gpv gpv) (IO out c)) *\n     indicator {IO out c} generat) +\n  fail * ennreal (pmf (the_gpv gpv) None) =\n  (\\<integral>\\<^sup>+generat\\<in>UNIV - {IO out c}.\n                      ((case generat of Pure x \\<Rightarrow> 1\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv fail \\<I> (\\<lambda>_. 1)\n                                (c r)) *\n                       ennreal (spmf (the_gpv gpv) generat))\n   \\<partial>count_space UNIV) +\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n      expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n  ennreal (spmf (the_gpv gpv) (IO out c)) +\n  fail * ennreal (pmf (the_gpv gpv) None)\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n    < ennreal (weight_spmf (the_gpv gpv)) +\n      fail * ennreal (pmf (the_gpv gpv) None)", "from calculation expectation_gpv_const_le[OF WT, of fail 1] fail"], ["proof (chain)\npicking this:\n  expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv =\n  (\\<integral>\\<^sup>+generat\\<in>UNIV - {IO out c}.\n                      ((case generat of Pure x \\<Rightarrow> 1\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv fail \\<I> (\\<lambda>_. 1)\n                                (c r)) *\n                       ennreal (spmf (the_gpv gpv) generat))\n   \\<partial>count_space UNIV) +\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n      expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n  ennreal (spmf (the_gpv gpv) (IO out c)) +\n  fail * ennreal (pmf (the_gpv gpv) None)\n  expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv \\<le> max 1 fail\n  fail \\<le> 1", "have fin: \"?rest \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv =\n  (\\<integral>\\<^sup>+generat\\<in>UNIV - {IO out c}.\n                      ((case generat of Pure x \\<Rightarrow> 1\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv fail \\<I> (\\<lambda>_. 1)\n                                (c r)) *\n                       ennreal (spmf (the_gpv gpv) generat))\n   \\<partial>count_space UNIV) +\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n      expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n  ennreal (spmf (the_gpv gpv) (IO out c)) +\n  fail * ennreal (pmf (the_gpv gpv) None)\n  expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv \\<le> max 1 fail\n  fail \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+generat\\<in>UNIV - {IO out c}.\n                       ((case generat of Pure x \\<Rightarrow> 1\n                         | IO out c \\<Rightarrow>\n                             \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                expectation_gpv fail \\<I> (\\<lambda>_. 1)\n                                 (c r)) *\n                        ennreal (spmf (the_gpv gpv) generat))\n    \\<partial>count_space UNIV \\<noteq>\n    \\<infinity>", "by(auto simp add: top_add top_unique max_def split: if_split_asm)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+generat\\<in>UNIV - {IO out c}.\n                     ((case generat of Pure x \\<Rightarrow> 1\n                       | IO out c \\<Rightarrow>\n                           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                              expectation_gpv fail \\<I> (\\<lambda>_. 1)\n                               (c r)) *\n                      ennreal (spmf (the_gpv gpv) generat))\n  \\<partial>count_space UNIV \\<noteq>\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n    < ennreal (weight_spmf (the_gpv gpv)) +\n      fail * ennreal (pmf (the_gpv gpv) None)", "have \"?cr \\<le> expectation_gpv fail \\<I> (\\<lambda>_. 1) (c input) * spmf (the_gpv gpv) (IO out c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n        expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n    ennreal (spmf (the_gpv gpv) (IO out c))\n    \\<le> expectation_gpv fail \\<I> (\\<lambda>_. 1) (c input) *\n          ennreal (spmf (the_gpv gpv) (IO out c))", "by(rule mult_right_mono INF_lower[OF input])+ simp"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n      expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n  ennreal (spmf (the_gpv gpv) (IO out c))\n  \\<le> expectation_gpv fail \\<I> (\\<lambda>_. 1) (c input) *\n        ennreal (spmf (the_gpv gpv) (IO out c))\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n    < ennreal (weight_spmf (the_gpv gpv)) +\n      fail * ennreal (pmf (the_gpv gpv) None)", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n      expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n  ennreal (spmf (the_gpv gpv) (IO out c))\n  \\<le> expectation_gpv fail \\<I> (\\<lambda>_. 1) (c input) *\n        ennreal (spmf (the_gpv gpv) (IO out c))\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n    < ennreal (weight_spmf (the_gpv gpv)) +\n      fail * ennreal (pmf (the_gpv gpv) None)", "have \"?rest + \\<dots> < ?rest + 1 * ennreal (spmf (the_gpv gpv) (IO out c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+generat\\<in>UNIV - {IO out c}.\n                        ((case generat of Pure x \\<Rightarrow> 1\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv fail \\<I> (\\<lambda>_. 1)\n                                  (c r)) *\n                         ennreal (spmf (the_gpv gpv) generat))\n     \\<partial>count_space UNIV) +\n    expectation_gpv fail \\<I> (\\<lambda>_. 1) (c input) *\n    ennreal (spmf (the_gpv gpv) (IO out c))\n    < (\\<integral>\\<^sup>+generat\\<in>UNIV - {IO out c}.\n                          ((case generat of Pure x \\<Rightarrow> 1\n                            | IO out c \\<Rightarrow>\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv fail \\<I> (\\<lambda>_. 1)\n                                    (c r)) *\n                           ennreal (spmf (the_gpv gpv) generat))\n       \\<partial>count_space UNIV) +\n      1 * ennreal (spmf (the_gpv gpv) (IO out c))", "unfolding ennreal_add_left_cancel_less"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+generat\\<in>UNIV - {IO out c}.\n                       ((case generat of Pure x \\<Rightarrow> 1\n                         | IO out c \\<Rightarrow>\n                             \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                expectation_gpv fail \\<I> (\\<lambda>_. 1)\n                                 (c r)) *\n                        ennreal (spmf (the_gpv gpv) generat))\n    \\<partial>count_space UNIV \\<noteq>\n    \\<infinity> \\<and>\n    expectation_gpv fail \\<I> (\\<lambda>_. 1) (c input) *\n    ennreal (spmf (the_gpv gpv) (IO out c))\n    < 1 * ennreal (spmf (the_gpv gpv) (IO out c))", "using * IO"], ["proof (prove)\nusing this:\n  \\<not> 1 \\<le> expectation_gpv fail \\<I> (\\<lambda>_. 1) (c input)\n  IO out c \\<in> set_spmf (the_gpv gpv)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+generat\\<in>UNIV - {IO out c}.\n                       ((case generat of Pure x \\<Rightarrow> 1\n                         | IO out c \\<Rightarrow>\n                             \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                expectation_gpv fail \\<I> (\\<lambda>_. 1)\n                                 (c r)) *\n                        ennreal (spmf (the_gpv gpv) generat))\n    \\<partial>count_space UNIV \\<noteq>\n    \\<infinity> \\<and>\n    expectation_gpv fail \\<I> (\\<lambda>_. 1) (c input) *\n    ennreal (spmf (the_gpv gpv) (IO out c))\n    < 1 * ennreal (spmf (the_gpv gpv) (IO out c))", "by(intro conjI fin ennreal_mult_strict_right_mono)(simp_all add: not_le weight_gpv_def in_set_spmf_iff_spmf)"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+generat\\<in>UNIV - {IO out c}.\n                      ((case generat of Pure x \\<Rightarrow> 1\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv fail \\<I> (\\<lambda>_. 1)\n                                (c r)) *\n                       ennreal (spmf (the_gpv gpv) generat))\n   \\<partial>count_space UNIV) +\n  expectation_gpv fail \\<I> (\\<lambda>_. 1) (c input) *\n  ennreal (spmf (the_gpv gpv) (IO out c))\n  < (\\<integral>\\<^sup>+generat\\<in>UNIV - {IO out c}.\n                        ((case generat of Pure x \\<Rightarrow> 1\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv fail \\<I> (\\<lambda>_. 1)\n                                  (c r)) *\n                         ennreal (spmf (the_gpv gpv) generat))\n     \\<partial>count_space UNIV) +\n    1 * ennreal (spmf (the_gpv gpv) (IO out c))\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n    < ennreal (weight_spmf (the_gpv gpv)) +\n      fail * ennreal (pmf (the_gpv gpv) None)", "also"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+generat\\<in>UNIV - {IO out c}.\n                      ((case generat of Pure x \\<Rightarrow> 1\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv fail \\<I> (\\<lambda>_. 1)\n                                (c r)) *\n                       ennreal (spmf (the_gpv gpv) generat))\n   \\<partial>count_space UNIV) +\n  expectation_gpv fail \\<I> (\\<lambda>_. 1) (c input) *\n  ennreal (spmf (the_gpv gpv) (IO out c))\n  < (\\<integral>\\<^sup>+generat\\<in>UNIV - {IO out c}.\n                        ((case generat of Pure x \\<Rightarrow> 1\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv fail \\<I> (\\<lambda>_. 1)\n                                  (c r)) *\n                         ennreal (spmf (the_gpv gpv) generat))\n     \\<partial>count_space UNIV) +\n    1 * ennreal (spmf (the_gpv gpv) (IO out c))\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n    < ennreal (weight_spmf (the_gpv gpv)) +\n      fail * ennreal (pmf (the_gpv gpv) None)", "have \"?rest \\<le> \\<integral>\\<^sup>+ generat. spmf (the_gpv gpv) generat * indicator (UNIV - {IO out c}) generat \\<partial>count_space UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+generat\\<in>UNIV - {IO out c}.\n                       ((case generat of Pure x \\<Rightarrow> 1\n                         | IO out c \\<Rightarrow>\n                             \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                expectation_gpv fail \\<I> (\\<lambda>_. 1)\n                                 (c r)) *\n                        ennreal (spmf (the_gpv gpv) generat))\n    \\<partial>count_space UNIV\n    \\<le> (\\<Sum>\\<^sup>+ x.\n             ennreal\n              (spmf (the_gpv gpv) x * indicat_real (UNIV - {IO out c}) x))", "apply(rule nn_integral_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (count_space UNIV) \\<Longrightarrow>\n       (case x of Pure x \\<Rightarrow> 1\n        | IO out c \\<Rightarrow>\n            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n               expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n       ennreal (spmf (the_gpv gpv) x) *\n       indicator (UNIV - {IO out c}) x\n       \\<le> ennreal\n              (spmf (the_gpv gpv) x * indicat_real (UNIV - {IO out c}) x)", "apply(clarsimp split: generat.split split_indicator)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       x21 = out \\<longrightarrow> x22 \\<noteq> c \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n           expectation_gpv fail \\<I> (\\<lambda>_. 1) (x22 r)) *\n       ennreal (spmf (the_gpv gpv) (IO x21 x22))\n       \\<le> ennreal (spmf (the_gpv gpv) (IO x21 x22))", "apply(rule ennreal_mult_le_self2I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>x21 = out \\<longrightarrow> x22 \\<noteq> c;\n        0 < ennreal (spmf (the_gpv gpv) (IO x21 x22))\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv fail \\<I> (\\<lambda>_. 1)\n                              (x22 r))\n                         \\<le> 1", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>x21 = out \\<longrightarrow> x22 \\<noteq> c;\n        0 < spmf (the_gpv gpv) (IO x21 x22)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv fail \\<I> (\\<lambda>_. 1)\n                              (x22 r))\n                         \\<le> 1", "subgoal premises prems for out' c'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out'.\n        expectation_gpv fail \\<I> (\\<lambda>_. 1) (c' r))\n    \\<le> 1", "apply(subgoal_tac \"IO out' c' \\<in> set_spmf (the_gpv gpv)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. IO out' c' \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n    (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out'.\n        expectation_gpv fail \\<I> (\\<lambda>_. 1) (c' r))\n    \\<le> 1\n 2. IO out' c' \\<in> set_spmf (the_gpv gpv)", "apply(frule WT_gpv_OutD[OF WT])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n     out' \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out'.\n                          expectation_gpv fail \\<I> (\\<lambda>_. 1) (c' r))\n                      \\<le> 1\n 2. IO out' c' \\<in> set_spmf (the_gpv gpv)", "apply(simp add: in_outs_\\<I>_iff_responses_\\<I>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n     responses_\\<I> \\<I> out' \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out'.\n                          expectation_gpv fail \\<I> (\\<lambda>_. 1) (c' r))\n                      \\<le> 1\n 2. IO out' c' \\<in> set_spmf (the_gpv gpv)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out'.\n                   expectation_gpv fail \\<I> (\\<lambda>_. 1) (c' r))\n               \\<le> 1;\n        x \\<in> responses_\\<I> \\<I> out'\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {}\n 2. IO out' c' \\<in> set_spmf (the_gpv gpv)", "apply(erule notE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        x \\<in> responses_\\<I> \\<I> out'\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out'.\n                             expectation_gpv fail \\<I> (\\<lambda>_. 1)\n                              (c' r))\n                         \\<le> 1\n 2. IO out' c' \\<in> set_spmf (the_gpv gpv)", "apply(rule INF_lower2, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        x \\<in> responses_\\<I> \\<I> out'\\<rbrakk>\n       \\<Longrightarrow> expectation_gpv fail \\<I> (\\<lambda>_. 1) (c' x)\n                         \\<le> 1\n 2. IO out' c' \\<in> set_spmf (the_gpv gpv)", "apply(rule expectation_gpv_const_le[THEN order_trans])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        x \\<in> responses_\\<I> \\<I> out'\\<rbrakk>\n       \\<Longrightarrow> \\<I> \\<turnstile>g c' x \\<surd>\n 2. \\<And>x.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        x \\<in> responses_\\<I> \\<I> out'\\<rbrakk>\n       \\<Longrightarrow> max 1 fail \\<le> 1\n 3. IO out' c' \\<in> set_spmf (the_gpv gpv)", "apply(erule (1) WT_gpv_ContD[OF WT])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        x \\<in> responses_\\<I> \\<I> out'\\<rbrakk>\n       \\<Longrightarrow> max 1 fail \\<le> 1\n 2. IO out' c' \\<in> set_spmf (the_gpv gpv)", "apply(simp add: fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. IO out' c' \\<in> set_spmf (the_gpv gpv)", "using prems"], ["proof (prove)\nusing this:\n  out' = out \\<longrightarrow> c' \\<noteq> c\n  0 < spmf (the_gpv gpv) (IO out' c')\n\ngoal (1 subgoal):\n 1. IO out' c' \\<in> set_spmf (the_gpv gpv)", "by(simp add: in_set_spmf_iff_spmf)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+generat\\<in>UNIV - {IO out c}.\n                     ((case generat of Pure x \\<Rightarrow> 1\n                       | IO out c \\<Rightarrow>\n                           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                              expectation_gpv fail \\<I> (\\<lambda>_. 1)\n                               (c r)) *\n                      ennreal (spmf (the_gpv gpv) generat))\n  \\<partial>count_space UNIV\n  \\<le> (\\<Sum>\\<^sup>+ x.\n           ennreal\n            (spmf (the_gpv gpv) x * indicat_real (UNIV - {IO out c}) x))\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n    < ennreal (weight_spmf (the_gpv gpv)) +\n      fail * ennreal (pmf (the_gpv gpv) None)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+generat\\<in>UNIV - {IO out c}.\n                     ((case generat of Pure x \\<Rightarrow> 1\n                       | IO out c \\<Rightarrow>\n                           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                              expectation_gpv fail \\<I> (\\<lambda>_. 1)\n                               (c r)) *\n                      ennreal (spmf (the_gpv gpv) generat))\n  \\<partial>count_space UNIV\n  \\<le> (\\<Sum>\\<^sup>+ x.\n           ennreal\n            (spmf (the_gpv gpv) x * indicat_real (UNIV - {IO out c}) x))\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n    < ennreal (weight_spmf (the_gpv gpv)) +\n      fail * ennreal (pmf (the_gpv gpv) None)", "have \"\\<dots> + 1 * ennreal (spmf (the_gpv gpv) (IO out c)) = \n      (\\<integral>\\<^sup>+ generat. spmf (the_gpv gpv) generat * indicator (UNIV - {IO out c}) generat + ennreal (spmf (the_gpv gpv) (IO out c)) * indicator {IO out c} generat \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (spmf (the_gpv gpv) x * indicat_real (UNIV - {IO out c}) x)) +\n    1 * ennreal (spmf (the_gpv gpv) (IO out c)) =\n    (\\<Sum>\\<^sup>+ generat.\n       ennreal\n        (spmf (the_gpv gpv) generat *\n         indicat_real (UNIV - {IO out c}) generat) +\n       ennreal (spmf (the_gpv gpv) (IO out c)) *\n       indicator {IO out c} generat)", "by(subst nn_integral_add)(simp_all)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     ennreal (spmf (the_gpv gpv) x * indicat_real (UNIV - {IO out c}) x)) +\n  1 * ennreal (spmf (the_gpv gpv) (IO out c)) =\n  (\\<Sum>\\<^sup>+ generat.\n     ennreal\n      (spmf (the_gpv gpv) generat *\n       indicat_real (UNIV - {IO out c}) generat) +\n     ennreal (spmf (the_gpv gpv) (IO out c)) * indicator {IO out c} generat)\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n    < ennreal (weight_spmf (the_gpv gpv)) +\n      fail * ennreal (pmf (the_gpv gpv) None)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     ennreal (spmf (the_gpv gpv) x * indicat_real (UNIV - {IO out c}) x)) +\n  1 * ennreal (spmf (the_gpv gpv) (IO out c)) =\n  (\\<Sum>\\<^sup>+ generat.\n     ennreal\n      (spmf (the_gpv gpv) generat *\n       indicat_real (UNIV - {IO out c}) generat) +\n     ennreal (spmf (the_gpv gpv) (IO out c)) * indicator {IO out c} generat)\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n    < ennreal (weight_spmf (the_gpv gpv)) +\n      fail * ennreal (pmf (the_gpv gpv) None)", "have \"\\<dots> = \\<integral>\\<^sup>+ generat. spmf (the_gpv gpv) generat \\<partial>count_space UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ generat.\n       ennreal\n        (spmf (the_gpv gpv) generat *\n         indicat_real (UNIV - {IO out c}) generat) +\n       ennreal (spmf (the_gpv gpv) (IO out c)) *\n       indicator {IO out c} generat) =\n    (\\<Sum>\\<^sup>+ x. ennreal (spmf (the_gpv gpv) x))", "by(auto intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ generat.\n     ennreal\n      (spmf (the_gpv gpv) generat *\n       indicat_real (UNIV - {IO out c}) generat) +\n     ennreal (spmf (the_gpv gpv) (IO out c)) *\n     indicator {IO out c} generat) =\n  (\\<Sum>\\<^sup>+ x. ennreal (spmf (the_gpv gpv) x))\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n    < ennreal (weight_spmf (the_gpv gpv)) +\n      fail * ennreal (pmf (the_gpv gpv) None)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ generat.\n     ennreal\n      (spmf (the_gpv gpv) generat *\n       indicat_real (UNIV - {IO out c}) generat) +\n     ennreal (spmf (the_gpv gpv) (IO out c)) *\n     indicator {IO out c} generat) =\n  (\\<Sum>\\<^sup>+ x. ennreal (spmf (the_gpv gpv) x))\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n    < ennreal (weight_spmf (the_gpv gpv)) +\n      fail * ennreal (pmf (the_gpv gpv) None)", "have \"\\<dots> = weight_spmf (the_gpv gpv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (spmf (the_gpv gpv) x)) =\n    ennreal (weight_spmf (the_gpv gpv))", "by(simp add: nn_integral_spmf measure_spmf.emeasure_eq_measure space_measure_spmf)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x. ennreal (spmf (the_gpv gpv) x)) =\n  ennreal (weight_spmf (the_gpv gpv))\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n    < ennreal (weight_spmf (the_gpv gpv)) +\n      fail * ennreal (pmf (the_gpv gpv) None)", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              (\\<integral>\\<^sup>+generat\\<in>UNIV - {IO out c}.\n                                  ((case generat of Pure x \\<Rightarrow> 1\n                                    | IO out c \\<Rightarrow>\n  \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n     expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n                                   ennreal (spmf (the_gpv gpv) generat))\n               \\<partial>count_space UNIV) +\n              x +\n              fail * ennreal (pmf (the_gpv gpv) None)\n              \\<le> (\\<integral>\\<^sup>+generat\\<in>UNIV - {IO out c}.\n  ((case generat of Pure x \\<Rightarrow> 1\n    | IO out c \\<Rightarrow>\n        \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n           expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n   ennreal (spmf (the_gpv gpv) generat))\n                     \\<partial>count_space UNIV) +\n                    y +\n                    fail * ennreal (pmf (the_gpv gpv) None);\n   \\<And>x y.\n      x < y \\<Longrightarrow>\n      x + fail * ennreal (pmf (the_gpv gpv) None)\n      < y + fail * ennreal (pmf (the_gpv gpv) None);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + 1 * ennreal (spmf (the_gpv gpv) (IO out c)) +\n      fail * ennreal (pmf (the_gpv gpv) None)\n      \\<le> y + 1 * ennreal (spmf (the_gpv gpv) (IO out c)) +\n            fail * ennreal (pmf (the_gpv gpv) None)\\<rbrakk>\n  \\<Longrightarrow> expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n                    < ennreal (weight_spmf (the_gpv gpv)) +\n                      fail * ennreal (pmf (the_gpv gpv) None)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              (\\<integral>\\<^sup>+generat\\<in>UNIV - {IO out c}.\n                                  ((case generat of Pure x \\<Rightarrow> 1\n                                    | IO out c \\<Rightarrow>\n  \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n     expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n                                   ennreal (spmf (the_gpv gpv) generat))\n               \\<partial>count_space UNIV) +\n              x +\n              fail * ennreal (pmf (the_gpv gpv) None)\n              \\<le> (\\<integral>\\<^sup>+generat\\<in>UNIV - {IO out c}.\n  ((case generat of Pure x \\<Rightarrow> 1\n    | IO out c \\<Rightarrow>\n        \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n           expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n   ennreal (spmf (the_gpv gpv) generat))\n                     \\<partial>count_space UNIV) +\n                    y +\n                    fail * ennreal (pmf (the_gpv gpv) None);\n   \\<And>x y.\n      x < y \\<Longrightarrow>\n      x + fail * ennreal (pmf (the_gpv gpv) None)\n      < y + fail * ennreal (pmf (the_gpv gpv) None);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + 1 * ennreal (spmf (the_gpv gpv) (IO out c)) +\n      fail * ennreal (pmf (the_gpv gpv) None)\n      \\<le> y + 1 * ennreal (spmf (the_gpv gpv) (IO out c)) +\n            fail * ennreal (pmf (the_gpv gpv) None)\\<rbrakk>\n  \\<Longrightarrow> expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n                    < ennreal (weight_spmf (the_gpv gpv)) +\n                      fail * ennreal (pmf (the_gpv gpv) None)\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n    < ennreal (weight_spmf (the_gpv gpv)) +\n      fail * ennreal (pmf (the_gpv gpv) None)", "using fail"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              (\\<integral>\\<^sup>+generat\\<in>UNIV - {IO out c}.\n                                  ((case generat of Pure x \\<Rightarrow> 1\n                                    | IO out c \\<Rightarrow>\n  \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n     expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n                                   ennreal (spmf (the_gpv gpv) generat))\n               \\<partial>count_space UNIV) +\n              x +\n              fail * ennreal (pmf (the_gpv gpv) None)\n              \\<le> (\\<integral>\\<^sup>+generat\\<in>UNIV - {IO out c}.\n  ((case generat of Pure x \\<Rightarrow> 1\n    | IO out c \\<Rightarrow>\n        \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n           expectation_gpv fail \\<I> (\\<lambda>_. 1) (c r)) *\n   ennreal (spmf (the_gpv gpv) generat))\n                     \\<partial>count_space UNIV) +\n                    y +\n                    fail * ennreal (pmf (the_gpv gpv) None);\n   \\<And>x y.\n      x < y \\<Longrightarrow>\n      x + fail * ennreal (pmf (the_gpv gpv) None)\n      < y + fail * ennreal (pmf (the_gpv gpv) None);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + 1 * ennreal (spmf (the_gpv gpv) (IO out c)) +\n      fail * ennreal (pmf (the_gpv gpv) None)\n      \\<le> y + 1 * ennreal (spmf (the_gpv gpv) (IO out c)) +\n            fail * ennreal (pmf (the_gpv gpv) None)\\<rbrakk>\n  \\<Longrightarrow> expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n                    < ennreal (weight_spmf (the_gpv gpv)) +\n                      fail * ennreal (pmf (the_gpv gpv) None)\n  fail \\<le> 1\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n    < ennreal (weight_spmf (the_gpv gpv)) +\n      fail * ennreal (pmf (the_gpv gpv) None)", "by(fastforce simp add: top_unique add_mono ennreal_plus[symmetric] ennreal_mult_eq_top_iff)"], ["proof (state)\nthis:\n  expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n  < ennreal (weight_spmf (the_gpv gpv)) +\n    fail * ennreal (pmf (the_gpv gpv) None)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?fail \\<le> 1;\n   \\<not> 1 \\<le> expectation_gpv ?fail \\<I> (\\<lambda>_. 1)\n                   (c input)\\<rbrakk>\n  \\<Longrightarrow> expectation_gpv ?fail \\<I> (\\<lambda>_. 1) gpv\n                    < ennreal (weight_spmf (the_gpv gpv)) +\n                      ?fail * ennreal (pmf (the_gpv gpv) None)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>plossless_gpv \\<I> gpv; IO out c \\<in> set_spmf (the_gpv gpv);\n     input \\<in> responses_\\<I> \\<I> out; \\<I> \\<turnstile>g gpv \\<surd>;\n     \\<not> 1 \\<le> expectation_gpv 0 \\<I> (\\<lambda>_. 1)\n                     (c input)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>pfinite_gpv \\<I> gpv; IO out c \\<in> set_spmf (the_gpv gpv);\n     input \\<in> responses_\\<I> \\<I> out; \\<I> \\<turnstile>g gpv \\<surd>;\n     \\<not> 1 \\<le> expectation_gpv 1 \\<I> (\\<lambda>_. 1)\n                     (c input)\\<rbrakk>\n    \\<Longrightarrow> False", "show False if *: \"\\<not> 1 \\<le> expectation_gpv 0 \\<I> (\\<lambda>_. 1) (c input)\" and lossless: \"plossless_gpv \\<I> gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using less[OF _ *] plossless_gpv_lossless_spmfD[OF lossless WT] lossless[THEN pgen_lossless_gpvD]"], ["proof (prove)\nusing this:\n  0 \\<le> 1 \\<Longrightarrow>\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n  < ennreal (weight_spmf (the_gpv gpv)) +\n    0 * ennreal (pmf (the_gpv gpv) None)\n  lossless_spmf (the_gpv gpv)\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv = 1\n\ngoal (1 subgoal):\n 1. False", "by(simp add: lossless_spmf_def)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> 1 \\<le> expectation_gpv 0 \\<I> (\\<lambda>_. 1) (c input);\n   plossless_gpv \\<I> gpv\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>pfinite_gpv \\<I> gpv; IO out c \\<in> set_spmf (the_gpv gpv);\n     input \\<in> responses_\\<I> \\<I> out; \\<I> \\<turnstile>g gpv \\<surd>;\n     \\<not> 1 \\<le> expectation_gpv 1 \\<I> (\\<lambda>_. 1)\n                     (c input)\\<rbrakk>\n    \\<Longrightarrow> False", "show False if *: \"\\<not> 1 \\<le> expectation_gpv 1 \\<I> (\\<lambda>_. 1) (c input)\" and finite: \"pfinite_gpv \\<I> gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using less[OF _ *] finite[THEN pgen_lossless_gpvD]"], ["proof (prove)\nusing this:\n  1 \\<le> 1 \\<Longrightarrow>\n  expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv\n  < ennreal (weight_spmf (the_gpv gpv)) +\n    1 * ennreal (pmf (the_gpv gpv) None)\n  expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv = 1\n\ngoal (1 subgoal):\n 1. False", "by(simp add: ennreal_plus[symmetric] del: ennreal_plus)(simp add: pmf_None_eq_weight_spmf)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> 1 \\<le> expectation_gpv 1 \\<I> (\\<lambda>_. 1) (c input);\n   pfinite_gpv \\<I> gpv\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma plossless_iff_colossless_pfinite:\n  assumes WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n  shows \"plossless_gpv \\<I> gpv \\<longleftrightarrow> colossless_gpv \\<I> gpv \\<and> pfinite_gpv \\<I> gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_gpv \\<I> gpv =\n    (colossless_gpv \\<I> gpv \\<and> pfinite_gpv \\<I> gpv)", "proof(intro iffI conjI; (elim conjE)?)"], ["proof (state)\ngoal (3 subgoals):\n 1. plossless_gpv \\<I> gpv \\<Longrightarrow> colossless_gpv \\<I> gpv\n 2. plossless_gpv \\<I> gpv \\<Longrightarrow> pfinite_gpv \\<I> gpv\n 3. \\<lbrakk>colossless_gpv \\<I> gpv; pfinite_gpv \\<I> gpv\\<rbrakk>\n    \\<Longrightarrow> plossless_gpv \\<I> gpv", "assume *: \"plossless_gpv \\<I> gpv\""], ["proof (state)\nthis:\n  plossless_gpv \\<I> gpv\n\ngoal (3 subgoals):\n 1. plossless_gpv \\<I> gpv \\<Longrightarrow> colossless_gpv \\<I> gpv\n 2. plossless_gpv \\<I> gpv \\<Longrightarrow> pfinite_gpv \\<I> gpv\n 3. \\<lbrakk>colossless_gpv \\<I> gpv; pfinite_gpv \\<I> gpv\\<rbrakk>\n    \\<Longrightarrow> plossless_gpv \\<I> gpv", "show \"colossless_gpv \\<I> gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. colossless_gpv \\<I> gpv", "using * WT"], ["proof (prove)\nusing this:\n  plossless_gpv \\<I> gpv\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. colossless_gpv \\<I> gpv", "proof(coinduction arbitrary: gpv)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>gpva.\n       \\<lbrakk>plossless_gpv \\<I> gpva;\n        \\<I> \\<turnstile>g gpva \\<surd>\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (the_gpv gpva) \\<and>\n                         (\\<forall>out c input.\n                             IO out c\n                             \\<in> set_spmf (the_gpv gpva) \\<longrightarrow>\n                             input\n                             \\<in> responses_\\<I> \\<I> out \\<longrightarrow>\n                             (\\<exists>gpv.\n                                 c input = gpv \\<and>\n                                 plossless_gpv \\<I> gpv \\<and>\n                                 \\<I> \\<turnstile>g gpv \\<surd>) \\<or>\n                             colossless_gpv \\<I> (c input))", "case (colossless_gpv gpv)"], ["proof (state)\nthis:\n  plossless_gpv \\<I> gpv\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>gpva.\n       \\<lbrakk>plossless_gpv \\<I> gpva;\n        \\<I> \\<turnstile>g gpva \\<surd>\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (the_gpv gpva) \\<and>\n                         (\\<forall>out c input.\n                             IO out c\n                             \\<in> set_spmf (the_gpv gpva) \\<longrightarrow>\n                             input\n                             \\<in> responses_\\<I> \\<I> out \\<longrightarrow>\n                             (\\<exists>gpv.\n                                 c input = gpv \\<and>\n                                 plossless_gpv \\<I> gpv \\<and>\n                                 \\<I> \\<turnstile>g gpv \\<surd>) \\<or>\n                             colossless_gpv \\<I> (c input))", "have ?lossless_spmf"], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (the_gpv gpv)", "using colossless_gpv"], ["proof (prove)\nusing this:\n  plossless_gpv \\<I> gpv\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. lossless_spmf (the_gpv gpv)", "by(rule plossless_gpv_lossless_spmfD)"], ["proof (state)\nthis:\n  lossless_spmf (the_gpv gpv)\n\ngoal (1 subgoal):\n 1. \\<And>gpva.\n       \\<lbrakk>plossless_gpv \\<I> gpva;\n        \\<I> \\<turnstile>g gpva \\<surd>\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (the_gpv gpva) \\<and>\n                         (\\<forall>out c input.\n                             IO out c\n                             \\<in> set_spmf (the_gpv gpva) \\<longrightarrow>\n                             input\n                             \\<in> responses_\\<I> \\<I> out \\<longrightarrow>\n                             (\\<exists>gpv.\n                                 c input = gpv \\<and>\n                                 plossless_gpv \\<I> gpv \\<and>\n                                 \\<I> \\<turnstile>g gpv \\<surd>) \\<or>\n                             colossless_gpv \\<I> (c input))", "moreover"], ["proof (state)\nthis:\n  lossless_spmf (the_gpv gpv)\n\ngoal (1 subgoal):\n 1. \\<And>gpva.\n       \\<lbrakk>plossless_gpv \\<I> gpva;\n        \\<I> \\<turnstile>g gpva \\<surd>\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (the_gpv gpva) \\<and>\n                         (\\<forall>out c input.\n                             IO out c\n                             \\<in> set_spmf (the_gpv gpva) \\<longrightarrow>\n                             input\n                             \\<in> responses_\\<I> \\<I> out \\<longrightarrow>\n                             (\\<exists>gpv.\n                                 c input = gpv \\<and>\n                                 plossless_gpv \\<I> gpv \\<and>\n                                 \\<I> \\<turnstile>g gpv \\<surd>) \\<or>\n                             colossless_gpv \\<I> (c input))", "have ?continuation"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>out c input.\n       IO out c \\<in> set_spmf (the_gpv gpv) \\<longrightarrow>\n       input \\<in> responses_\\<I> \\<I> out \\<longrightarrow>\n       (\\<exists>gpv.\n           c input = gpv \\<and>\n           plossless_gpv \\<I> gpv \\<and>\n           \\<I> \\<turnstile>g gpv \\<surd>) \\<or>\n       colossless_gpv \\<I> (c input)", "using colossless_gpv"], ["proof (prove)\nusing this:\n  plossless_gpv \\<I> gpv\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. \\<forall>out c input.\n       IO out c \\<in> set_spmf (the_gpv gpv) \\<longrightarrow>\n       input \\<in> responses_\\<I> \\<I> out \\<longrightarrow>\n       (\\<exists>gpv.\n           c input = gpv \\<and>\n           plossless_gpv \\<I> gpv \\<and>\n           \\<I> \\<turnstile>g gpv \\<surd>) \\<or>\n       colossless_gpv \\<I> (c input)", "by(auto intro: plossless_gpv_ContD WT_gpv_ContD)"], ["proof (state)\nthis:\n  \\<forall>out c input.\n     IO out c \\<in> set_spmf (the_gpv gpv) \\<longrightarrow>\n     input \\<in> responses_\\<I> \\<I> out \\<longrightarrow>\n     (\\<exists>gpv.\n         c input = gpv \\<and>\n         plossless_gpv \\<I> gpv \\<and> \\<I> \\<turnstile>g gpv \\<surd>) \\<or>\n     colossless_gpv \\<I> (c input)\n\ngoal (1 subgoal):\n 1. \\<And>gpva.\n       \\<lbrakk>plossless_gpv \\<I> gpva;\n        \\<I> \\<turnstile>g gpva \\<surd>\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (the_gpv gpva) \\<and>\n                         (\\<forall>out c input.\n                             IO out c\n                             \\<in> set_spmf (the_gpv gpva) \\<longrightarrow>\n                             input\n                             \\<in> responses_\\<I> \\<I> out \\<longrightarrow>\n                             (\\<exists>gpv.\n                                 c input = gpv \\<and>\n                                 plossless_gpv \\<I> gpv \\<and>\n                                 \\<I> \\<turnstile>g gpv \\<surd>) \\<or>\n                             colossless_gpv \\<I> (c input))", "ultimately"], ["proof (chain)\npicking this:\n  lossless_spmf (the_gpv gpv)\n  \\<forall>out c input.\n     IO out c \\<in> set_spmf (the_gpv gpv) \\<longrightarrow>\n     input \\<in> responses_\\<I> \\<I> out \\<longrightarrow>\n     (\\<exists>gpv.\n         c input = gpv \\<and>\n         plossless_gpv \\<I> gpv \\<and> \\<I> \\<turnstile>g gpv \\<surd>) \\<or>\n     colossless_gpv \\<I> (c input)", "show ?case"], ["proof (prove)\nusing this:\n  lossless_spmf (the_gpv gpv)\n  \\<forall>out c input.\n     IO out c \\<in> set_spmf (the_gpv gpv) \\<longrightarrow>\n     input \\<in> responses_\\<I> \\<I> out \\<longrightarrow>\n     (\\<exists>gpv.\n         c input = gpv \\<and>\n         plossless_gpv \\<I> gpv \\<and> \\<I> \\<turnstile>g gpv \\<surd>) \\<or>\n     colossless_gpv \\<I> (c input)\n\ngoal (1 subgoal):\n 1. lossless_spmf (the_gpv gpv) \\<and>\n    (\\<forall>out c input.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<longrightarrow>\n        input \\<in> responses_\\<I> \\<I> out \\<longrightarrow>\n        (\\<exists>gpv.\n            c input = gpv \\<and>\n            plossless_gpv \\<I> gpv \\<and>\n            \\<I> \\<turnstile>g gpv \\<surd>) \\<or>\n        colossless_gpv \\<I> (c input))", ".."], ["proof (state)\nthis:\n  lossless_spmf (the_gpv gpv) \\<and>\n  (\\<forall>out c input.\n      IO out c \\<in> set_spmf (the_gpv gpv) \\<longrightarrow>\n      input \\<in> responses_\\<I> \\<I> out \\<longrightarrow>\n      (\\<exists>gpv.\n          c input = gpv \\<and>\n          plossless_gpv \\<I> gpv \\<and>\n          \\<I> \\<turnstile>g gpv \\<surd>) \\<or>\n      colossless_gpv \\<I> (c input))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  colossless_gpv \\<I> gpv\n\ngoal (2 subgoals):\n 1. plossless_gpv \\<I> gpv \\<Longrightarrow> pfinite_gpv \\<I> gpv\n 2. \\<lbrakk>colossless_gpv \\<I> gpv; pfinite_gpv \\<I> gpv\\<rbrakk>\n    \\<Longrightarrow> plossless_gpv \\<I> gpv", "show \"pfinite_gpv \\<I> gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_gpv \\<I> gpv", "unfolding pgen_lossless_gpv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv = 1", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv \\<le> 1\n 2. 1 \\<le> expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv", "from expectation_gpv_const_le[OF WT, of 1 1]"], ["proof (chain)\npicking this:\n  expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv \\<le> max 1 1", "show \"expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv \\<le> 1\""], ["proof (prove)\nusing this:\n  expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv \\<le> max 1 1\n\ngoal (1 subgoal):\n 1. expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv \\<le> 1", "by simp"], ["proof (state)\nthis:\n  expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv \\<le> 1\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv", "have \"1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv", "using *"], ["proof (prove)\nusing this:\n  plossless_gpv \\<I> gpv\n\ngoal (1 subgoal):\n 1. 1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv", "by(simp add: pgen_lossless_gpv_def)"], ["proof (state)\nthis:\n  1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv", "also"], ["proof (state)\nthis:\n  1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv", "have \"\\<dots> \\<le> expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n    \\<le> expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv", "by(rule expectation_gpv_mono) simp_all"], ["proof (state)\nthis:\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n  \\<le> expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv", "finally"], ["proof (chain)\npicking this:\n  1 \\<le> expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv", "show \"1 \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  1 \\<le> expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv", "."], ["proof (state)\nthis:\n  1 \\<le> expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pfinite_gpv \\<I> gpv\n\ngoal (1 subgoal):\n 1. \\<lbrakk>colossless_gpv \\<I> gpv; pfinite_gpv \\<I> gpv\\<rbrakk>\n    \\<Longrightarrow> plossless_gpv \\<I> gpv", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>colossless_gpv \\<I> gpv; pfinite_gpv \\<I> gpv\\<rbrakk>\n    \\<Longrightarrow> plossless_gpv \\<I> gpv", "show \"plossless_gpv \\<I> gpv\" if \"colossless_gpv \\<I> gpv\" and \"pfinite_gpv \\<I> gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_gpv \\<I> gpv", "using that"], ["proof (prove)\nusing this:\n  colossless_gpv \\<I> gpv\n  pfinite_gpv \\<I> gpv\n\ngoal (1 subgoal):\n 1. plossless_gpv \\<I> gpv", "by(simp add: pgen_lossless_gpv_def cong: expectation_gpv_cong_fail)"], ["proof (state)\nthis:\n  \\<lbrakk>colossless_gpv \\<I> gpv; pfinite_gpv \\<I> gpv\\<rbrakk>\n  \\<Longrightarrow> plossless_gpv \\<I> gpv\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pgen_lossless_gpv_Done [simp]: \"pgen_lossless_gpv fail \\<I> (Done x)\" for fail"], ["proof (prove)\ngoal (1 subgoal):\n 1. pgen_lossless_gpv fail \\<I> (Generative_Probabilistic_Value.Done x)", "by(simp add: pgen_lossless_gpv_def)"], ["", "lemma pgen_lossless_gpv_Fail [simp]: \"pgen_lossless_gpv fail \\<I> Fail \\<longleftrightarrow> fail = 1\" for fail"], ["proof (prove)\ngoal (1 subgoal):\n 1. pgen_lossless_gpv fail \\<I> Fail = (fail = 1)", "by(simp add: pgen_lossless_gpv_def)"], ["", "lemma pgen_lossless_gpv_PauseI [simp, intro!]: \n  \"\\<lbrakk> out \\<in> outs_\\<I> \\<I>; \\<And>r. r \\<in> responses_\\<I> \\<I> out \\<Longrightarrow> pgen_lossless_gpv fail \\<I> (c r) \\<rbrakk>\n   \\<Longrightarrow> pgen_lossless_gpv fail \\<I> (Pause out c)\" for fail"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>out \\<in> outs_\\<I> \\<I>;\n     \\<And>r.\n        r \\<in> responses_\\<I> \\<I> out \\<Longrightarrow>\n        pgen_lossless_gpv fail \\<I> (c r)\\<rbrakk>\n    \\<Longrightarrow> pgen_lossless_gpv fail \\<I>\n                       (Generative_Probabilistic_Value.Pause out c)", "by(simp add: pgen_lossless_gpv_def weight_gpv_def in_outs_\\<I>_iff_responses_\\<I>)"], ["", "lemma pgen_lossless_gpv_bindI [simp, intro!]:\n  \"\\<lbrakk> pgen_lossless_gpv fail \\<I> gpv; \\<And>x. x \\<in> results_gpv \\<I> gpv \\<Longrightarrow> pgen_lossless_gpv fail \\<I> (f x) \\<rbrakk>\n  \\<Longrightarrow> pgen_lossless_gpv fail \\<I> (bind_gpv gpv f)\" for fail"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pgen_lossless_gpv fail \\<I> gpv;\n     \\<And>x.\n        x \\<in> results_gpv \\<I> gpv \\<Longrightarrow>\n        pgen_lossless_gpv fail \\<I> (f x)\\<rbrakk>\n    \\<Longrightarrow> pgen_lossless_gpv fail \\<I> (gpv \\<bind> f)", "by(simp add: pgen_lossless_gpv_def weight_gpv_def o_def cong: expectation_gpv_cong)"], ["", "lemma pgen_lossless_gpv_lift_spmf [simp]: \n  \"pgen_lossless_gpv fail \\<I> (lift_spmf p) \\<longleftrightarrow> lossless_spmf p \\<or> fail = 1\" for fail"], ["proof (prove)\ngoal (1 subgoal):\n 1. pgen_lossless_gpv fail \\<I> (lift_spmf p) =\n    (lossless_spmf p \\<or> fail = 1)", "apply(cases fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; fail = ennreal r\\<rbrakk>\n       \\<Longrightarrow> pgen_lossless_gpv fail \\<I> (lift_spmf p) =\n                         (lossless_spmf p \\<or> fail = 1)\n 2. fail = \\<top> \\<Longrightarrow>\n    pgen_lossless_gpv fail \\<I> (lift_spmf p) =\n    (lossless_spmf p \\<or> fail = 1)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> r_; fail = ennreal r_\\<rbrakk>\n    \\<Longrightarrow> pgen_lossless_gpv fail \\<I> (lift_spmf p) =\n                      (lossless_spmf p \\<or> fail = 1)", "by(simp add: pgen_lossless_gpv_def lossless_spmf_def measure_spmf.emeasure_eq_measure pmf_None_eq_weight_spmf ennreal_minus ennreal_mult[symmetric] weight_spmf_le_1 ennreal_plus[symmetric] del: ennreal_plus)\n    (metis add_diff_cancel_left' diff_add_cancel eq_iff_diff_eq_0 mult_cancel_right1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fail = \\<top> \\<Longrightarrow>\n    pgen_lossless_gpv fail \\<I> (lift_spmf p) =\n    (lossless_spmf p \\<or> fail = 1)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fail = \\<top> \\<Longrightarrow>\n    pgen_lossless_gpv fail \\<I> (lift_spmf p) =\n    (lossless_spmf p \\<or> fail = 1)", "by(simp add: pgen_lossless_gpv_def measure_spmf.emeasure_eq_measure ennreal_top_mult lossless_spmf_def add_top weight_spmf_conv_pmf_None)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma expectation_gpv_top_pfinite:\n  assumes \"pfinite_gpv \\<I> gpv\"\n  shows \"expectation_gpv \\<top> \\<I> (\\<lambda>_. \\<top>) gpv = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv \\<top> \\<I> (\\<lambda>_. \\<top>) gpv = \\<top>", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. expectation_gpv \\<top> \\<I> (\\<lambda>_. \\<top>) gpv \\<noteq>\n    \\<top> \\<Longrightarrow>\n    False", "assume *: \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  expectation_gpv \\<top> \\<I> (\\<lambda>_. \\<top>) gpv \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. expectation_gpv \\<top> \\<I> (\\<lambda>_. \\<top>) gpv \\<noteq>\n    \\<top> \\<Longrightarrow>\n    False", "have \"1 = expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv", "using assms"], ["proof (prove)\nusing this:\n  pfinite_gpv \\<I> gpv\n\ngoal (1 subgoal):\n 1. 1 = expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv", "by(simp add: pgen_lossless_gpv_def)"], ["proof (state)\nthis:\n  1 = expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv\n\ngoal (1 subgoal):\n 1. expectation_gpv \\<top> \\<I> (\\<lambda>_. \\<top>) gpv \\<noteq>\n    \\<top> \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  1 = expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv\n\ngoal (1 subgoal):\n 1. expectation_gpv \\<top> \\<I> (\\<lambda>_. \\<top>) gpv \\<noteq>\n    \\<top> \\<Longrightarrow>\n    False", "have \"\\<dots> \\<le> expectation_gpv \\<top> \\<I> (\\<lambda>_. \\<top>) gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv\n    \\<le> expectation_gpv \\<top> \\<I> (\\<lambda>_. \\<top>) gpv", "by(rule expectation_gpv_mono)(simp_all add: le_fun_def)"], ["proof (state)\nthis:\n  expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv\n  \\<le> expectation_gpv \\<top> \\<I> (\\<lambda>_. \\<top>) gpv\n\ngoal (1 subgoal):\n 1. expectation_gpv \\<top> \\<I> (\\<lambda>_. \\<top>) gpv \\<noteq>\n    \\<top> \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv\n  \\<le> expectation_gpv \\<top> \\<I> (\\<lambda>_. \\<top>) gpv\n\ngoal (1 subgoal):\n 1. expectation_gpv \\<top> \\<I> (\\<lambda>_. \\<top>) gpv \\<noteq>\n    \\<top> \\<Longrightarrow>\n    False", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv \\<top> \\<I> (\\<lambda>_. \\<top>) gpv = 0", "using expectation_gpv_cmult[of \"2\" \\<top> \\<I> \"\\<lambda>_. \\<top>\" gpv] *"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < 2; 2 \\<noteq> \\<top>\\<rbrakk>\n  \\<Longrightarrow> 2 *\n                    expectation_gpv \\<top> \\<I> (\\<lambda>_. \\<top>) gpv =\n                    expectation_gpv (2 * \\<top>) \\<I>\n                     (\\<lambda>x. 2 * \\<top>) gpv\n  expectation_gpv \\<top> \\<I> (\\<lambda>_. \\<top>) gpv \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. expectation_gpv \\<top> \\<I> (\\<lambda>_. \\<top>) gpv = 0", "by(simp add: ennreal_mult_top) (metis ennreal_mult_cancel_left mult.commute mult_numeral_1_right not_gr_zero numeral_eq_one_iff semiring_norm(85) zero_neq_numeral)"], ["proof (state)\nthis:\n  expectation_gpv \\<top> \\<I> (\\<lambda>_. \\<top>) gpv = 0\n\ngoal (1 subgoal):\n 1. expectation_gpv \\<top> \\<I> (\\<lambda>_. \\<top>) gpv \\<noteq>\n    \\<top> \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  1 \\<le> 0", "show False"], ["proof (prove)\nusing this:\n  1 \\<le> 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pfinite_INF_le_expectation_gpv:\n  fixes fail \\<I> gpv f\n  defines \"c \\<equiv> min (INF x\\<in>results_gpv \\<I> gpv. f x) fail\"\n  assumes fin: \"pfinite_gpv \\<I> gpv\"\n  shows \"c \\<le> expectation_gpv fail \\<I> f gpv\" (is \"?lhs \\<le> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<le> expectation_gpv fail \\<I> f gpv", "proof(cases \"c > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < c \\<Longrightarrow> c \\<le> expectation_gpv fail \\<I> f gpv\n 2. \\<not> 0 < c \\<Longrightarrow> c \\<le> expectation_gpv fail \\<I> f gpv", "case True"], ["proof (state)\nthis:\n  0 < c\n\ngoal (2 subgoals):\n 1. 0 < c \\<Longrightarrow> c \\<le> expectation_gpv fail \\<I> f gpv\n 2. \\<not> 0 < c \\<Longrightarrow> c \\<le> expectation_gpv fail \\<I> f gpv", "have \"c = c * expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c = c * expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv", "using assms"], ["proof (prove)\nusing this:\n  c \\<equiv> min (\\<Sqinter> (f ` results_gpv \\<I> gpv)) fail\n  pfinite_gpv \\<I> gpv\n\ngoal (1 subgoal):\n 1. c = c * expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv", "by(simp add: pgen_lossless_gpv_def)"], ["proof (state)\nthis:\n  c = c * expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv\n\ngoal (2 subgoals):\n 1. 0 < c \\<Longrightarrow> c \\<le> expectation_gpv fail \\<I> f gpv\n 2. \\<not> 0 < c \\<Longrightarrow> c \\<le> expectation_gpv fail \\<I> f gpv", "also"], ["proof (state)\nthis:\n  c = c * expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv\n\ngoal (2 subgoals):\n 1. 0 < c \\<Longrightarrow> c \\<le> expectation_gpv fail \\<I> f gpv\n 2. \\<not> 0 < c \\<Longrightarrow> c \\<le> expectation_gpv fail \\<I> f gpv", "have \"\\<dots> = expectation_gpv c \\<I> (\\<lambda>_. c) gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv =\n    expectation_gpv c \\<I> (\\<lambda>_. c) gpv", "using fin True"], ["proof (prove)\nusing this:\n  pfinite_gpv \\<I> gpv\n  0 < c\n\ngoal (1 subgoal):\n 1. c * expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv =\n    expectation_gpv c \\<I> (\\<lambda>_. c) gpv", "by(cases \"c = \\<top>\")(simp_all add: expectation_gpv_top_pfinite ennreal_top_mult expectation_gpv_cmult, simp add: pgen_lossless_gpv_def)"], ["proof (state)\nthis:\n  c * expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv =\n  expectation_gpv c \\<I> (\\<lambda>_. c) gpv\n\ngoal (2 subgoals):\n 1. 0 < c \\<Longrightarrow> c \\<le> expectation_gpv fail \\<I> f gpv\n 2. \\<not> 0 < c \\<Longrightarrow> c \\<le> expectation_gpv fail \\<I> f gpv", "also"], ["proof (state)\nthis:\n  c * expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv =\n  expectation_gpv c \\<I> (\\<lambda>_. c) gpv\n\ngoal (2 subgoals):\n 1. 0 < c \\<Longrightarrow> c \\<le> expectation_gpv fail \\<I> f gpv\n 2. \\<not> 0 < c \\<Longrightarrow> c \\<le> expectation_gpv fail \\<I> f gpv", "have \"\\<dots> \\<le> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv c \\<I> (\\<lambda>_. c) gpv\n    \\<le> expectation_gpv fail \\<I> f gpv", "by(rule expectation_gpv_mono_strong)(auto simp add: c_def min_def intro: INF_lower2)"], ["proof (state)\nthis:\n  expectation_gpv c \\<I> (\\<lambda>_. c) gpv\n  \\<le> expectation_gpv fail \\<I> f gpv\n\ngoal (2 subgoals):\n 1. 0 < c \\<Longrightarrow> c \\<le> expectation_gpv fail \\<I> f gpv\n 2. \\<not> 0 < c \\<Longrightarrow> c \\<le> expectation_gpv fail \\<I> f gpv", "finally"], ["proof (chain)\npicking this:\n  c \\<le> expectation_gpv fail \\<I> f gpv", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<le> expectation_gpv fail \\<I> f gpv\n\ngoal (1 subgoal):\n 1. c \\<le> expectation_gpv fail \\<I> f gpv", "."], ["proof (state)\nthis:\n  c \\<le> expectation_gpv fail \\<I> f gpv\n\ngoal (1 subgoal):\n 1. \\<not> 0 < c \\<Longrightarrow> c \\<le> expectation_gpv fail \\<I> f gpv", "qed simp"], ["", "lemma plossless_INF_le_expectation_gpv:\n  fixes fail\n  assumes \"plossless_gpv \\<I> gpv\" and \"\\<I> \\<turnstile>g gpv \\<surd>\"\n  shows \"(INF x\\<in>results_gpv \\<I> gpv. f x) \\<le> expectation_gpv fail \\<I> f gpv\" (is \"?lhs \\<le> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> (f ` results_gpv \\<I> gpv)\n    \\<le> expectation_gpv fail \\<I> f gpv", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Sqinter> (f ` results_gpv \\<I> gpv)\n    \\<le> expectation_gpv fail \\<I> f gpv", "from assms"], ["proof (chain)\npicking this:\n  plossless_gpv \\<I> gpv\n  \\<I> \\<turnstile>g gpv \\<surd>", "have fin: \"pfinite_gpv \\<I> gpv\" and co: \"colossless_gpv \\<I> gpv\""], ["proof (prove)\nusing this:\n  plossless_gpv \\<I> gpv\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. pfinite_gpv \\<I> gpv &&& colossless_gpv \\<I> gpv", "by(simp_all add: plossless_iff_colossless_pfinite)"], ["proof (state)\nthis:\n  pfinite_gpv \\<I> gpv\n  colossless_gpv \\<I> gpv\n\ngoal (1 subgoal):\n 1. \\<Sqinter> (f ` results_gpv \\<I> gpv)\n    \\<le> expectation_gpv fail \\<I> f gpv", "have \"?lhs \\<le> min ?lhs \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> (f ` results_gpv \\<I> gpv)\n    \\<le> min (\\<Sqinter> (f ` results_gpv \\<I> gpv)) \\<top>", "by(simp add: min_def)"], ["proof (state)\nthis:\n  \\<Sqinter> (f ` results_gpv \\<I> gpv)\n  \\<le> min (\\<Sqinter> (f ` results_gpv \\<I> gpv)) \\<top>\n\ngoal (1 subgoal):\n 1. \\<Sqinter> (f ` results_gpv \\<I> gpv)\n    \\<le> expectation_gpv fail \\<I> f gpv", "also"], ["proof (state)\nthis:\n  \\<Sqinter> (f ` results_gpv \\<I> gpv)\n  \\<le> min (\\<Sqinter> (f ` results_gpv \\<I> gpv)) \\<top>\n\ngoal (1 subgoal):\n 1. \\<Sqinter> (f ` results_gpv \\<I> gpv)\n    \\<le> expectation_gpv fail \\<I> f gpv", "have \"\\<dots> \\<le> expectation_gpv \\<top> \\<I> f gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (\\<Sqinter> (f ` results_gpv \\<I> gpv)) \\<top>\n    \\<le> expectation_gpv \\<top> \\<I> f gpv", "using fin"], ["proof (prove)\nusing this:\n  pfinite_gpv \\<I> gpv\n\ngoal (1 subgoal):\n 1. min (\\<Sqinter> (f ` results_gpv \\<I> gpv)) \\<top>\n    \\<le> expectation_gpv \\<top> \\<I> f gpv", "by(rule pfinite_INF_le_expectation_gpv)"], ["proof (state)\nthis:\n  min (\\<Sqinter> (f ` results_gpv \\<I> gpv)) \\<top>\n  \\<le> expectation_gpv \\<top> \\<I> f gpv\n\ngoal (1 subgoal):\n 1. \\<Sqinter> (f ` results_gpv \\<I> gpv)\n    \\<le> expectation_gpv fail \\<I> f gpv", "also"], ["proof (state)\nthis:\n  min (\\<Sqinter> (f ` results_gpv \\<I> gpv)) \\<top>\n  \\<le> expectation_gpv \\<top> \\<I> f gpv\n\ngoal (1 subgoal):\n 1. \\<Sqinter> (f ` results_gpv \\<I> gpv)\n    \\<le> expectation_gpv fail \\<I> f gpv", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv \\<top> \\<I> f gpv = expectation_gpv fail \\<I> f gpv", "using co"], ["proof (prove)\nusing this:\n  colossless_gpv \\<I> gpv\n\ngoal (1 subgoal):\n 1. expectation_gpv \\<top> \\<I> f gpv = expectation_gpv fail \\<I> f gpv", "by(simp add: expectation_gpv_cong_fail)"], ["proof (state)\nthis:\n  expectation_gpv \\<top> \\<I> f gpv = expectation_gpv fail \\<I> f gpv\n\ngoal (1 subgoal):\n 1. \\<Sqinter> (f ` results_gpv \\<I> gpv)\n    \\<le> expectation_gpv fail \\<I> f gpv", "finally"], ["proof (chain)\npicking this:\n  \\<Sqinter> (f ` results_gpv \\<I> gpv)\n  \\<le> expectation_gpv fail \\<I> f gpv", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Sqinter> (f ` results_gpv \\<I> gpv)\n  \\<le> expectation_gpv fail \\<I> f gpv\n\ngoal (1 subgoal):\n 1. \\<Sqinter> (f ` results_gpv \\<I> gpv)\n    \\<le> expectation_gpv fail \\<I> f gpv", "."], ["proof (state)\nthis:\n  \\<Sqinter> (f ` results_gpv \\<I> gpv)\n  \\<le> expectation_gpv fail \\<I> f gpv\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma expectation_gpv_le_inline:\n  fixes \\<I>'\n  defines \"expectation_gpv2 \\<equiv> expectation_gpv 0 \\<I>'\"\n  assumes callee: \"\\<And>s x. x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> plossless_gpv \\<I>' (callee s x)\"\n    and callee': \"\\<And>s x. x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> results_gpv \\<I>' (callee s x) \\<subseteq> responses_\\<I> \\<I> x \\<times> UNIV\"\n    and WT_gpv: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and WT_callee: \"\\<And>s x. x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> \\<I>' \\<turnstile>g callee s x \\<surd>\"\n  shows \"expectation_gpv 0 \\<I> f gpv \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I> f gpv\n    \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee gpv s)", "using WT_gpv"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I> f gpv\n    \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee gpv s)", "proof(induction arbitrary: gpv s rule: expectation_gpv_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            (\\<forall>xa.\n                a x\n                \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                       (inline callee x xa)))\n 2. \\<And>gpv s.\n       \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n       0 \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee gpv s)\n 3. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv\n           \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                  (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            (\\<forall>xa.\n                a x\n                \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                       (inline callee x xa)))\n 2. \\<And>gpv s.\n       \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n       0 \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee gpv s)\n 3. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv\n           \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                  (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            (\\<forall>xa.\n                a x\n                \\<le> expectation_gpv2\n                       (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n                       (inline callee x xa)))", "by simp"], ["proof (state)\nthis:\n  lfp.admissible\n   (\\<lambda>a.\n       \\<forall>x.\n          \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n          (\\<forall>xa.\n              a x\n              \\<le> expectation_gpv2\n                     (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n                     (inline callee x xa)))\n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n       0 \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee gpv s)\n 2. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv\n           \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                  (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "case bottom"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n       0 \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee gpv s)\n 2. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv\n           \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                  (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> expectation_gpv2\n             (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n             (inline callee gpv s)", "by simp"], ["proof (state)\nthis:\n  0 \\<le> expectation_gpv2 (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n           (inline callee gpv s)\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv\n           \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                  (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "case (step expectation_gpv')"], ["proof (state)\nthis:\n  expectation_gpv' ?gpv \\<le> expectation_gpv 0 \\<I> f ?gpv\n  \\<I> \\<turnstile>g ?gpv \\<surd> \\<Longrightarrow>\n  expectation_gpv' ?gpv\n  \\<le> expectation_gpv2 (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n         (inline callee ?gpv ?s)\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv\n           \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                  (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "{"], ["proof (state)\nthis:\n  expectation_gpv' ?gpv \\<le> expectation_gpv 0 \\<I> f ?gpv\n  \\<I> \\<turnstile>g ?gpv \\<surd> \\<Longrightarrow>\n  expectation_gpv' ?gpv\n  \\<le> expectation_gpv2 (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n         (inline callee ?gpv ?s)\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv\n           \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                  (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "fix out c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv\n           \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                  (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "assume IO: \"IO out c \\<in> set_spmf (the_gpv gpv)\""], ["proof (state)\nthis:\n  IO out c \\<in> set_spmf (the_gpv gpv)\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv\n           \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                  (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "with step.prems"], ["proof (chain)\npicking this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  IO out c \\<in> set_spmf (the_gpv gpv)", "have out: \"out \\<in> outs_\\<I> \\<I>\""], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  IO out c \\<in> set_spmf (the_gpv gpv)\n\ngoal (1 subgoal):\n 1. out \\<in> outs_\\<I> \\<I>", "by(rule WT_gpv_OutD)"], ["proof (state)\nthis:\n  out \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv\n           \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                  (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "have \"(INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) = \\<integral>\\<^sup>+ generat. (INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) \\<partial>measure_spmf (the_gpv (callee s out))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) =\n    \\<integral>\\<^sup>+ generat.\n                         (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                             expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv (callee s out))", "using WT_callee[OF out, of s] callee[OF out, of s]"], ["proof (prove)\nusing this:\n  \\<I>' \\<turnstile>g callee s out \\<surd>\n  plossless_gpv \\<I>' (callee s out)\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) =\n    \\<integral>\\<^sup>+ generat.\n                         (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                             expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv (callee s out))", "by(clarsimp simp add: measure_spmf.emeasure_eq_measure plossless_iff_colossless_pfinite colossless_gpv_lossless_spmfD lossless_weight_spmfD)"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) =\n  \\<integral>\\<^sup>+ generat.\n                       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                           expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv\n           \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                  (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) =\n  \\<integral>\\<^sup>+ generat.\n                       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                           expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv\n           \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                  (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "have \"\\<dots> \\<le> \\<integral>\\<^sup>+ generat. (case generat of Pure (x, s') \\<Rightarrow>\n            \\<integral>\\<^sup>+ xx. (case xx of Inl (x, _) \\<Rightarrow> f x \n               | Inr (out', callee', rpv) \\<Rightarrow> INF r'\\<in>responses_\\<I> \\<I>' out'. expectation_gpv 0 \\<I>' (\\<lambda>(r, s'). expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv r) s')) (callee' r'))\n            \\<partial>measure_spmf (inline1 callee (c x) s')\n         | IO out' rpv \\<Rightarrow> INF r'\\<in>responses_\\<I> \\<I>' out'. expectation_gpv 0 \\<I>' (\\<lambda>(r', s'). expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s')) (rpv r'))\n       \\<partial>measure_spmf (the_gpv (callee s out))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                             expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv (callee s out))\n    \\<le> \\<integral>\\<^sup>+ generat.\n                               (case generat of\n                                Pure (x, s') \\<Rightarrow>\n                                  \\<integral>\\<^sup>+ xx.\n                 (case xx of Inl (x, xa) \\<Rightarrow> f x\n                  | Inr (out', callee', rpv) \\<Rightarrow>\n                      \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                         expectation_gpv 0 \\<I>'\n                          (\\<lambda>(r, s').\n                              expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                               (inline callee (rpv r) s'))\n                          (callee' r'))\n               \\<partial>measure_spmf (inline1 callee (c x) s')\n                                | IO out' rpv \\<Rightarrow>\n                                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n                out'.\n expectation_gpv 0 \\<I>'\n  (\\<lambda>(r', s').\n      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c r') s'))\n  (rpv r'))\n                             \\<partial>measure_spmf (the_gpv (callee s out))", "proof(rule nn_integral_mono_AE; simp split!: generat.split)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "fix x s'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "assume Pure: \"Pure (x, s') \\<in> set_spmf (the_gpv (callee s out))\""], ["proof (state)\nthis:\n  Pure (x, s') \\<in> set_spmf (the_gpv (callee s out))\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "hence \"(x, s') \\<in> results_gpv \\<I>' (callee s out)\""], ["proof (prove)\nusing this:\n  Pure (x, s') \\<in> set_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. (x, s') \\<in> results_gpv \\<I>' (callee s out)", "by(rule results_gpv.Pure)"], ["proof (state)\nthis:\n  (x, s') \\<in> results_gpv \\<I>' (callee s out)\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "with callee'[OF out, of s]"], ["proof (chain)\npicking this:\n  results_gpv \\<I>' (callee s out)\n  \\<subseteq> responses_\\<I> \\<I> out \\<times> UNIV\n  (x, s') \\<in> results_gpv \\<I>' (callee s out)", "have x: \"x \\<in> responses_\\<I> \\<I> out\""], ["proof (prove)\nusing this:\n  results_gpv \\<I>' (callee s out)\n  \\<subseteq> responses_\\<I> \\<I> out \\<times> UNIV\n  (x, s') \\<in> results_gpv \\<I>' (callee s out)\n\ngoal (1 subgoal):\n 1. x \\<in> responses_\\<I> \\<I> out", "by blast"], ["proof (state)\nthis:\n  x \\<in> responses_\\<I> \\<I> out\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "hence \"(INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) \\<le> expectation_gpv' (c x)\""], ["proof (prove)\nusing this:\n  x \\<in> responses_\\<I> \\<I> out\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> expectation_gpv' (c x)", "by(rule INF_lower)"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> expectation_gpv' (c x)\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> expectation_gpv' (c x)\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "have \"\\<dots> \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x) s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv' (c x)\n    \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x) s')", "by(rule step.IH)(rule WT_gpv_ContD[OF step.prems(1) IO x] step.prems|assumption)+"], ["proof (state)\nthis:\n  expectation_gpv' (c x)\n  \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x) s')\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "also"], ["proof (state)\nthis:\n  expectation_gpv' (c x)\n  \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x) s')\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "have \"\\<dots> = \\<integral>\\<^sup>+ xx. (case xx of Inl (x, _) \\<Rightarrow> f x \n               | Inr (out', callee', rpv) \\<Rightarrow> INF r'\\<in>responses_\\<I> \\<I>' out'. expectation_gpv 0 \\<I>' (\\<lambda>(r, s'). expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv r) s')) (callee' r'))\n            \\<partial>measure_spmf (inline1 callee (c x) s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x) s') =\n    \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                             | Inr (out', callee', rpv) \\<Rightarrow>\n                                 \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                    expectation_gpv 0 \\<I>'\n                                     (\\<lambda>(r, s').\n   expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n    (inline callee (rpv r) s'))\n                                     (callee' r'))\n                       \\<partial>measure_spmf (inline1 callee (c x) s')", "unfolding expectation_gpv2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n     (inline callee (c x) s') =\n    \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                             | Inr (out', callee', rpv) \\<Rightarrow>\n                                 \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                    expectation_gpv 0 \\<I>'\n                                     (\\<lambda>(r, s').\n   expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n    (inline callee (rpv r) s'))\n                                     (callee' r'))\n                       \\<partial>measure_spmf (inline1 callee (c x) s')", "by(subst expectation_gpv.simps)(auto simp add: inline_sel split_def o_def intro!: nn_integral_cong split: generat.split sum.split)"], ["proof (state)\nthis:\n  expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x) s') =\n  \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                           | Inr (out', callee', rpv) \\<Rightarrow>\n                               \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                  expectation_gpv 0 \\<I>'\n                                   (\\<lambda>(r, s').\n expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                   (callee' r'))\n                     \\<partial>measure_spmf (inline1 callee (c x) s')\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                                 | Inr (out', callee', rpv) \\<Rightarrow>\n                                     \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n                 out'.\n  expectation_gpv 0 \\<I>'\n   (\\<lambda>(r, s').\n       expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n        (inline callee (rpv r) s'))\n   (callee' r'))\n                           \\<partial>measure_spmf (inline1 callee (c x) s')", "show \"(INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                                 | Inr (out', callee', rpv) \\<Rightarrow>\n                                     \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n                 out'.\n  expectation_gpv 0 \\<I>'\n   (\\<lambda>(r, s').\n       expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n        (inline callee (rpv r) s'))\n   (callee' r'))\n                           \\<partial>measure_spmf (inline1 callee (c x) s')\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                                   | Inr (out', callee', rpv) \\<Rightarrow>\n \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n    expectation_gpv 0 \\<I>'\n     (\\<lambda>(r, s').\n         expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n          (inline callee (rpv r) s'))\n     (callee' r'))\n                             \\<partial>measure_spmf\n  (inline1 callee (c x) s')", "."], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                                 | Inr (out', callee', rpv) \\<Rightarrow>\n                                     \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n                 out'.\n  expectation_gpv 0 \\<I>'\n   (\\<lambda>(r, s').\n       expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n        (inline callee (rpv r) s'))\n   (callee' r'))\n                           \\<partial>measure_spmf (inline1 callee (c x) s')\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "fix out' rpv"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "assume IO': \"IO out' rpv \\<in> set_spmf (the_gpv (callee s out))\""], ["proof (state)\nthis:\n  IO out' rpv \\<in> set_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "have \"(INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) \\<le> (INF (r, s')\\<in>(\\<Union>r'\\<in>responses_\\<I> \\<I>' out'. results_gpv \\<I>' (rpv r')). expectation_gpv' (c r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> (\\<Sqinter>(r,\n              s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                         results_gpv \\<I>' (rpv r').\n              expectation_gpv' (c r))", "using IO' callee'[OF out, of s]"], ["proof (prove)\nusing this:\n  IO out' rpv \\<in> set_spmf (the_gpv (callee s out))\n  results_gpv \\<I>' (callee s out)\n  \\<subseteq> responses_\\<I> \\<I> out \\<times> UNIV\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> (\\<Sqinter>(r,\n              s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                         results_gpv \\<I>' (rpv r').\n              expectation_gpv' (c r))", "by(intro INF_mono)(auto intro: results_gpv.IO)"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>(r,\n            s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                       results_gpv \\<I>' (rpv r').\n            expectation_gpv' (c r))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>(r,\n            s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                       results_gpv \\<I>' (rpv r').\n            expectation_gpv' (c r))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "have \"\\<dots> = (INF r'\\<in>responses_\\<I> \\<I>' out'. INF (r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv' (c r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>(r,\n        s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                   results_gpv \\<I>' (rpv r').\n        expectation_gpv' (c r)) =\n    (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n        \\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n           expectation_gpv' (c r))", "by(simp add: INF_UNION)"], ["proof (state)\nthis:\n  (\\<Sqinter>(r,\n      s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                 results_gpv \\<I>' (rpv r').\n      expectation_gpv' (c r)) =\n  (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n      \\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n         expectation_gpv' (c r))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>(r,\n      s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                 results_gpv \\<I>' (rpv r').\n      expectation_gpv' (c r)) =\n  (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n      \\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n         expectation_gpv' (c r))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "have \"\\<dots> \\<le> (INF r'\\<in>responses_\\<I> \\<I>' out'. expectation_gpv 0 \\<I>' (\\<lambda>(r', s'). expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s')) (rpv r'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n        \\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n           expectation_gpv' (c r))\n    \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n              expectation_gpv 0 \\<I>'\n               (\\<lambda>(r', s').\n                   expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                    (inline callee (c r') s'))\n               (rpv r'))", "proof(rule INF_mono, rule bexI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv (?r'2 m)).\n           expectation_gpv' (c r))\n       \\<le> expectation_gpv 0 \\<I>'\n              (\\<lambda>(r', s').\n                  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c r') s'))\n              (rpv m)\n 2. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       ?r'2 m \\<in> responses_\\<I> \\<I>' out'", "fix r'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv (?r'2 m)).\n           expectation_gpv' (c r))\n       \\<le> expectation_gpv 0 \\<I>'\n              (\\<lambda>(r', s').\n                  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c r') s'))\n              (rpv m)\n 2. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       ?r'2 m \\<in> responses_\\<I> \\<I>' out'", "assume r': \"r' \\<in> responses_\\<I> \\<I>' out'\""], ["proof (state)\nthis:\n  r' \\<in> responses_\\<I> \\<I>' out'\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv (?r'2 m)).\n           expectation_gpv' (c r))\n       \\<le> expectation_gpv 0 \\<I>'\n              (\\<lambda>(r', s').\n                  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c r') s'))\n              (rpv m)\n 2. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       ?r'2 m \\<in> responses_\\<I> \\<I>' out'", "have \"(INF (r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv' (c r)) \\<le> (INF (r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c r) s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n        expectation_gpv' (c r))\n    \\<le> (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n              expectation_gpv2 (\\<lambda>(x, s). f x)\n               (inline callee (c r) s'))", "using IO IO' step.prems out callee'[OF out, of s] r'"], ["proof (prove)\nusing this:\n  IO out c \\<in> set_spmf (the_gpv gpv)\n  IO out' rpv \\<in> set_spmf (the_gpv (callee s out))\n  \\<I> \\<turnstile>g gpv \\<surd>\n  out \\<in> outs_\\<I> \\<I>\n  results_gpv \\<I>' (callee s out)\n  \\<subseteq> responses_\\<I> \\<I> out \\<times> UNIV\n  r' \\<in> responses_\\<I> \\<I>' out'\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n        expectation_gpv' (c r))\n    \\<le> (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n              expectation_gpv2 (\\<lambda>(x, s). f x)\n               (inline callee (c r) s'))", "by(auto intro!: INF_mono rev_bexI step.IH dest: WT_gpv_ContD intro: results_gpv.IO)"], ["proof (state)\nthis:\n  (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n            expectation_gpv2 (\\<lambda>(x, s). f x)\n             (inline callee (c r) s'))\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv (?r'2 m)).\n           expectation_gpv' (c r))\n       \\<le> expectation_gpv 0 \\<I>'\n              (\\<lambda>(r', s').\n                  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c r') s'))\n              (rpv m)\n 2. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       ?r'2 m \\<in> responses_\\<I> \\<I>' out'", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n            expectation_gpv2 (\\<lambda>(x, s). f x)\n             (inline callee (c r) s'))\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv (?r'2 m)).\n           expectation_gpv' (c r))\n       \\<le> expectation_gpv 0 \\<I>'\n              (\\<lambda>(r', s').\n                  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c r') s'))\n              (rpv m)\n 2. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       ?r'2 m \\<in> responses_\\<I> \\<I>' out'", "have \"\\<dots> \\<le>  expectation_gpv 0 \\<I>' (\\<lambda>(r', s'). expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s')) (rpv r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n        expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c r) s'))\n    \\<le> expectation_gpv 0 \\<I>'\n           (\\<lambda>(r', s').\n               expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                (inline callee (c r') s'))\n           (rpv r')", "unfolding expectation_gpv2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (c r) s'))\n    \\<le> expectation_gpv 0 \\<I>'\n           (\\<lambda>(r', s').\n               expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                (inline callee (c r') s'))\n           (rpv r')", "using plossless_gpv_ContD[OF callee, OF out IO' r'] WT_callee[OF out, of s] IO' r'"], ["proof (prove)\nusing this:\n  \\<I>' \\<turnstile>g callee s out \\<surd> \\<Longrightarrow>\n  plossless_gpv \\<I>' (rpv r')\n  \\<I>' \\<turnstile>g callee s out \\<surd>\n  IO out' rpv \\<in> set_spmf (the_gpv (callee s out))\n  r' \\<in> responses_\\<I> \\<I>' out'\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (c r) s'))\n    \\<le> expectation_gpv 0 \\<I>'\n           (\\<lambda>(r', s').\n               expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                (inline callee (c r') s'))\n           (rpv r')", "by(intro plossless_INF_le_expectation_gpv)(auto intro: WT_gpv_ContD)"], ["proof (state)\nthis:\n  (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n      expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c r) s'))\n  \\<le> expectation_gpv 0 \\<I>'\n         (\\<lambda>(r', s').\n             expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (c r') s'))\n         (rpv r')\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv (?r'2 m)).\n           expectation_gpv' (c r))\n       \\<le> expectation_gpv 0 \\<I>'\n              (\\<lambda>(r', s').\n                  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c r') s'))\n              (rpv m)\n 2. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       ?r'2 m \\<in> responses_\\<I> \\<I>' out'", "finally"], ["proof (chain)\npicking this:\n  (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv' (c r))\n  \\<le> expectation_gpv 0 \\<I>'\n         (\\<lambda>(r', s').\n             expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (c r') s'))\n         (rpv r')", "show \"(INF (r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv' (c r)) \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv' (c r))\n  \\<le> expectation_gpv 0 \\<I>'\n         (\\<lambda>(r', s').\n             expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (c r') s'))\n         (rpv r')\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n        expectation_gpv' (c r))\n    \\<le> expectation_gpv 0 \\<I>'\n           (\\<lambda>(r', s').\n               expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                (inline callee (c r') s'))\n           (rpv r')", "."], ["proof (state)\nthis:\n  (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv' (c r))\n  \\<le> expectation_gpv 0 \\<I>'\n         (\\<lambda>(r', s').\n             expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (c r') s'))\n         (rpv r')\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       m \\<in> responses_\\<I> \\<I>' out'", "qed"], ["proof (state)\nthis:\n  (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n      \\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n         expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n            expectation_gpv 0 \\<I>'\n             (\\<lambda>(r', s').\n                 expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                  (inline callee (c r') s'))\n             (rpv r'))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n            expectation_gpv 0 \\<I>'\n             (\\<lambda>(r', s').\n                 expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                  (inline callee (c r') s'))\n             (rpv r'))", "show \"(INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n            expectation_gpv 0 \\<I>'\n             (\\<lambda>(r', s').\n                 expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                  (inline callee (c r') s'))\n             (rpv r'))\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n              expectation_gpv 0 \\<I>'\n               (\\<lambda>(r', s').\n                   expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                    (inline callee (c r') s'))\n               (rpv r'))", "."], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n            expectation_gpv 0 \\<I>'\n             (\\<lambda>(r', s').\n                 expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                  (inline callee (c r') s'))\n             (rpv r'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                           expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv (callee s out))\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (case generat of\n                              Pure (x, s') \\<Rightarrow>\n                                \\<integral>\\<^sup>+ xx.\n               (case xx of Inl (x, xa) \\<Rightarrow> f x\n                | Inr (out', callee', rpv) \\<Rightarrow>\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r'))\n             \\<partial>measure_spmf (inline1 callee (c x) s')\n                              | IO out' rpv \\<Rightarrow>\n                                  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n              out'.\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(r', s').\n    expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n     (inline callee (c r') s'))\n(rpv r'))\n                           \\<partial>measure_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv\n           \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                  (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                           expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv (callee s out))\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (case generat of\n                              Pure (x, s') \\<Rightarrow>\n                                \\<integral>\\<^sup>+ xx.\n               (case xx of Inl (x, xa) \\<Rightarrow> f x\n                | Inr (out', callee', rpv) \\<Rightarrow>\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r'))\n             \\<partial>measure_spmf (inline1 callee (c x) s')\n                              | IO out' rpv \\<Rightarrow>\n                                  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n              out'.\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(r', s').\n    expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n     (inline callee (c r') s'))\n(rpv r'))\n                           \\<partial>measure_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv\n           \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                  (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "note calculation"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (case generat of\n                              Pure (x, s') \\<Rightarrow>\n                                \\<integral>\\<^sup>+ xx.\n               (case xx of Inl (x, xa) \\<Rightarrow> f x\n                | Inr (out', callee', rpv) \\<Rightarrow>\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r'))\n             \\<partial>measure_spmf (inline1 callee (c x) s')\n                              | IO out' rpv \\<Rightarrow>\n                                  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n              out'.\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(r', s').\n    expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n     (inline callee (c r') s'))\n(rpv r'))\n                           \\<partial>measure_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv\n           \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                  (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "}"], ["proof (state)\nthis:\n  IO ?out2 ?c2 \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> ?out2. expectation_gpv' (?c2 r))\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (case generat of\n                              Pure (x, s') \\<Rightarrow>\n                                \\<integral>\\<^sup>+ xx.\n               (case xx of Inl (x, xa) \\<Rightarrow> f x\n                | Inr (out', callee', rpv) \\<Rightarrow>\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r'))\n             \\<partial>measure_spmf (inline1 callee (?c2 x) s')\n                              | IO out' rpv \\<Rightarrow>\n                                  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n              out'.\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(r', s').\n    expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n     (inline callee (?c2 r') s'))\n(rpv r'))\n                           \\<partial>measure_spmf (the_gpv (callee s ?out2))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv\n           \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                  (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "then"], ["proof (chain)\npicking this:\n  IO ?out2 ?c2 \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> ?out2. expectation_gpv' (?c2 r))\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (case generat of\n                              Pure (x, s') \\<Rightarrow>\n                                \\<integral>\\<^sup>+ xx.\n               (case xx of Inl (x, xa) \\<Rightarrow> f x\n                | Inr (out', callee', rpv) \\<Rightarrow>\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r'))\n             \\<partial>measure_spmf (inline1 callee (?c2 x) s')\n                              | IO out' rpv \\<Rightarrow>\n                                  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n              out'.\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(r', s').\n    expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n     (inline callee (?c2 r') s'))\n(rpv r'))\n                           \\<partial>measure_spmf (the_gpv (callee s ?out2))", "show ?case"], ["proof (prove)\nusing this:\n  IO ?out2 ?c2 \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> ?out2. expectation_gpv' (?c2 r))\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (case generat of\n                              Pure (x, s') \\<Rightarrow>\n                                \\<integral>\\<^sup>+ xx.\n               (case xx of Inl (x, xa) \\<Rightarrow> f x\n                | Inr (out', callee', rpv) \\<Rightarrow>\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r'))\n             \\<partial>measure_spmf (inline1 callee (?c2 x) s')\n                              | IO out' rpv \\<Rightarrow>\n                                  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n              out'.\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(r', s').\n    expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n     (inline callee (?c2 r') s'))\n(rpv r'))\n                           \\<partial>measure_spmf (the_gpv (callee s ?out2))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    0 * ennreal (pmf (the_gpv gpv) None)\n    \\<le> expectation_gpv2 (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n           (inline callee gpv s)", "unfolding expectation_gpv2_def"], ["proof (prove)\nusing this:\n  IO ?out2 ?c2 \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> ?out2. expectation_gpv' (?c2 r))\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (case generat of\n                              Pure (x, s') \\<Rightarrow>\n                                \\<integral>\\<^sup>+ xx.\n               (case xx of Inl (x, xa) \\<Rightarrow> f x\n                | Inr (out', callee', rpv) \\<Rightarrow>\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r'))\n             \\<partial>measure_spmf (inline1 callee (?c2 x) s')\n                              | IO out' rpv \\<Rightarrow>\n                                  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n              out'.\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(r', s').\n    expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n     (inline callee (?c2 r') s'))\n(rpv r'))\n                           \\<partial>measure_spmf (the_gpv (callee s ?out2))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    0 * ennreal (pmf (the_gpv gpv) None)\n    \\<le> expectation_gpv 0 \\<I>'\n           (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n           (inline callee gpv s)", "apply(rewrite expectation_gpv.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    0 * ennreal (pmf (the_gpv gpv) None)\n    \\<le> \\<integral>\\<^sup>+ generat.\n                               (case generat of\n                                Pure (xa, s) \\<Rightarrow> f xa\n                                | IO out c \\<Rightarrow>\n                                    \\<Sqinter>r\\<in>responses_\\<I> \\<I>'\n               out.\n expectation_gpv 0 \\<I>' (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n  (c r))\n                             \\<partial>measure_spmf\n  (the_gpv (inline callee gpv s)) +\n          0 * ennreal (pmf (the_gpv (inline callee gpv s)) None)", "apply(rewrite inline_sel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    0 * ennreal (pmf (the_gpv gpv) None)\n    \\<le> \\<integral>\\<^sup>+ generat.\n                               (case generat of\n                                Pure (xa, s) \\<Rightarrow> f xa\n                                | IO out c \\<Rightarrow>\n                                    \\<Sqinter>r\\<in>responses_\\<I> \\<I>'\n               out.\n expectation_gpv 0 \\<I>' (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n  (c r))\n                             \\<partial>measure_spmf\n  (map_spmf\n    (\\<lambda>result.\n        case result of Inl xs \\<Rightarrow> Pure xs\n        | Inr (out, oracle, rpv) \\<Rightarrow>\n            IO out\n             (\\<lambda>input.\n                 oracle input \\<bind>\n                 (\\<lambda>(x, s'). inline callee (rpv x) s')))\n    (inline1 callee gpv s)) +\n          0 * ennreal (pmf (the_gpv (inline callee gpv s)) None)", "apply(simp add: o_def pmf_map_spmf_None)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. (case case x of Inl x \\<Rightarrow> Pure x\n | Inr (out, oracle, rpv) \\<Rightarrow>\n     IO out\n      (\\<lambda>input.\n          oracle input \\<bind>\n          (\\<lambda>(x, y). inline callee (rpv x) y)) of\n                                  Pure (xa, s) \\<Rightarrow> f xa\n                                  | IO out c \\<Rightarrow>\n\\<Sqinter>r\\<in>responses_\\<I> \\<I>' out.\n   expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (c r))\n                             \\<partial>measure_spmf (inline1 callee gpv s)", "apply(rewrite sum.case_distrib[where h=\"case_generat _ _\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. (case x of\n                                  Inl x \\<Rightarrow>\n                                    case Pure x of\n                                    Pure (xa, s) \\<Rightarrow> f xa\n                                    | IO out c \\<Rightarrow>\n  \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out.\n     expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (c r)\n                                  | Inr x \\<Rightarrow>\ncase case x of\n     (out, oracle, rpv) \\<Rightarrow>\n       IO out\n        (\\<lambda>input.\n            oracle input \\<bind>\n            (\\<lambda>(x, y). inline callee (rpv x) y)) of\nPure (xa, s) \\<Rightarrow> f xa\n| IO out c \\<Rightarrow>\n    \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out.\n       expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (c r))\n                             \\<partial>measure_spmf (inline1 callee gpv s)", "apply(simp cong del: sum.case_cong_weak)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. (case x of Inl (xa, s) \\<Rightarrow> f xa\n                                  | Inr x \\<Rightarrow>\ncase case x of\n     (out, oracle, rpv) \\<Rightarrow>\n       IO out\n        (\\<lambda>input.\n            oracle input \\<bind>\n            (\\<lambda>(x, y). inline callee (rpv x) y)) of\nPure (xa, s) \\<Rightarrow> f xa\n| IO out c \\<Rightarrow>\n    \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out.\n       expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (c r))\n                             \\<partial>measure_spmf (inline1 callee gpv s)", "apply(simp add: split_beta o_def cong del: sum.case_cong_weak)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. (case x of Inl x \\<Rightarrow> f (fst x)\n                                  | Inr x \\<Rightarrow>\n\\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n   expectation_gpv 0 \\<I>'\n    (\\<lambda>xa.\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (snd (snd x) (fst xa)) (snd xa)))\n    (fst (snd x) xa))\n                             \\<partial>measure_spmf (inline1 callee gpv s)", "apply(rewrite inline1.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. (case x of Inl x \\<Rightarrow> f (fst x)\n                                  | Inr x \\<Rightarrow>\n\\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n   expectation_gpv 0 \\<I>'\n    (\\<lambda>xa.\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (snd (snd x) (fst xa)) (snd xa)))\n    (fst (snd x) xa))\n                             \\<partial>measure_spmf\n  (the_gpv gpv \\<bind>\n   case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n    (\\<lambda>out rpv.\n        the_gpv (callee s out) \\<bind>\n        case_generat (\\<lambda>(x, y). inline1 callee (rpv x) y)\n         (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))", "apply(rewrite measure_spmf_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. (case x of Inl x \\<Rightarrow> f (fst x)\n                                  | Inr x \\<Rightarrow>\n\\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n   expectation_gpv 0 \\<I>'\n    (\\<lambda>xa.\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (snd (snd x) (fst xa)) (snd xa)))\n    (fst (snd x) xa))\n                             \\<partial>measure_spmf (the_gpv gpv) \\<bind>\n measure_spmf \\<circ>\n case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n  (\\<lambda>out rpv.\n      the_gpv (callee s out) \\<bind>\n      case_generat (\\<lambda>(x, y). inline1 callee (rpv x) y)\n       (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))", "apply(rewrite nn_integral_bind[where B=\"measure_spmf _\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    (\\<lambda>x.\n        case x of Inl x \\<Rightarrow> f (fst x)\n        | Inr x \\<Rightarrow>\n            \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n               expectation_gpv 0 \\<I>'\n                (\\<lambda>xa.\n                    expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (snd (snd x) (fst xa)) (snd xa)))\n                (fst (snd x) xa))\n    \\<in> borel_measurable (measure_spmf ?uu1339)\n 2. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    measure_spmf \\<circ>\n    case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n     (\\<lambda>out rpv.\n         the_gpv (callee s out) \\<bind>\n         case_generat (\\<lambda>(x, y). inline1 callee (rpv x) y)\n          (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))\n    \\<in> measure_spmf (the_gpv gpv) \\<rightarrow>\\<^sub>M\n          subprob_algebra (measure_spmf ?uu1339)\n 3. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ y.\n                (case y of Inl x \\<Rightarrow> f (fst x)\n                 | Inr x \\<Rightarrow>\n                     \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n                        expectation_gpv 0 \\<I>'\n                         (\\<lambda>xa.\n                             expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                              (inline callee (snd (snd x) (fst xa))\n                                (snd xa)))\n                         (fst (snd x) xa))\n              \\<partial>(measure_spmf \\<circ>\n                         case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n                          (\\<lambda>out rpv.\n                              the_gpv (callee s out) \\<bind>\n                              case_generat\n                               (\\<lambda>(x, y). inline1 callee (rpv x) y)\n                               (\\<lambda>out rpv'.\n                                   return_spmf (Inr (out, rpv', rpv)))))\n                         x\n                             \\<partial>measure_spmf (the_gpv gpv)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    measure_spmf \\<circ>\n    case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n     (\\<lambda>out rpv.\n         the_gpv (callee s out) \\<bind>\n         case_generat (\\<lambda>(x, y). inline1 callee (rpv x) y)\n          (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))\n    \\<in> measure_spmf (the_gpv gpv) \\<rightarrow>\\<^sub>M\n          subprob_algebra (measure_spmf ?uu1339)\n 2. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ y.\n                (case y of Inl x \\<Rightarrow> f (fst x)\n                 | Inr x \\<Rightarrow>\n                     \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n                        expectation_gpv 0 \\<I>'\n                         (\\<lambda>xa.\n                             expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                              (inline callee (snd (snd x) (fst xa))\n                                (snd xa)))\n                         (fst (snd x) xa))\n              \\<partial>(measure_spmf \\<circ>\n                         case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n                          (\\<lambda>out rpv.\n                              the_gpv (callee s out) \\<bind>\n                              case_generat\n                               (\\<lambda>(x, y). inline1 callee (rpv x) y)\n                               (\\<lambda>out rpv'.\n                                   return_spmf (Inr (out, rpv', rpv)))))\n                         x\n                             \\<partial>measure_spmf (the_gpv gpv)", "apply(simp add: space_subprob_algebra)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ y.\n                (case y of Inl x \\<Rightarrow> f (fst x)\n                 | Inr x \\<Rightarrow>\n                     \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n                        expectation_gpv 0 \\<I>'\n                         (\\<lambda>xa.\n                             expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                              (inline callee (snd (snd x) (fst xa))\n                                (snd xa)))\n                         (fst (snd x) xa))\n              \\<partial>(measure_spmf \\<circ>\n                         case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n                          (\\<lambda>out rpv.\n                              the_gpv (callee s out) \\<bind>\n                              case_generat\n                               (\\<lambda>(x, y). inline1 callee (rpv x) y)\n                               (\\<lambda>out rpv'.\n                                   return_spmf (Inr (out, rpv', rpv)))))\n                         x\n                             \\<partial>measure_spmf (the_gpv gpv)", "apply(rule nn_integral_mono_AE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    AE x in measure_spmf\n             (the_gpv\n               gpv). (case x of Pure x \\<Rightarrow> f x\n                      | IO out c \\<Rightarrow>\n                          \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                             expectation_gpv' (c r))\n                     \\<le> \\<integral>\\<^sup>+ y.\n          (case y of Inl x \\<Rightarrow> f (fst x)\n           | Inr x \\<Rightarrow>\n               \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n                  expectation_gpv 0 \\<I>'\n                   (\\<lambda>xa.\n                       expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                        (inline callee (snd (snd x) (fst xa)) (snd xa)))\n                   (fst (snd x) xa))\n        \\<partial>(measure_spmf \\<circ>\n                   case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n                    (\\<lambda>out rpv.\n                        the_gpv (callee s out) \\<bind>\n                        case_generat\n                         (\\<lambda>(x, y). inline1 callee (rpv x) y)\n                         (\\<lambda>out rpv'.\n                             return_spmf (Inr (out, rpv', rpv)))))\n                   x", "apply(clarsimp split!: generat.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> integral\\<^sup>N\n                          (measure_spmf (the_gpv (callee s out)))\n                          (case_generat\n                            (\\<lambda>(x, s').\n                                integral\\<^sup>N\n                                 (measure_spmf (inline1 callee (c x) s'))\n                                 (case_sum (\\<lambda>(x, xa). f x)\n                                   (\\<lambda>(out', callee', rpv).\n \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n    expectation_gpv 0 \\<I>'\n     (\\<lambda>(r, s').\n         expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n          (inline callee (rpv r) s'))\n     (callee' r'))))\n                            (\\<lambda>out' rpv.\n                                \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                   expectation_gpv 0 \\<I>'\n                                    (\\<lambda>(r', s').\n  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s'))\n                                    (rpv r')));\n        Pure x1 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> f x1\n                         \\<le> integral\\<^sup>N\n                                (measure_spmf (return_spmf (Inl (x1, s))))\n                                (case_sum (\\<lambda>x. f (fst x))\n                                  (\\<lambda>x.\n\\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n   expectation_gpv 0 \\<I>'\n    (\\<lambda>xa.\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (snd (snd x) (fst xa)) (snd xa)))\n    (fst (snd x) xa)))\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> integral\\<^sup>N\n                          (measure_spmf (the_gpv (callee s out)))\n                          (case_generat\n                            (\\<lambda>(x, s').\n                                integral\\<^sup>N\n                                 (measure_spmf (inline1 callee (c x) s'))\n                                 (case_sum (\\<lambda>(x, xa). f x)\n                                   (\\<lambda>(out', callee', rpv).\n \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n    expectation_gpv 0 \\<I>'\n     (\\<lambda>(r, s').\n         expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n          (inline callee (rpv r) s'))\n     (callee' r'))))\n                            (\\<lambda>out' rpv.\n                                \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                   expectation_gpv 0 \\<I>'\n                                    (\\<lambda>(r', s').\n  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s'))\n                                    (rpv r')));\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> integral\\<^sup>N\n                                (measure_spmf\n                                  (the_gpv (callee s x21) \\<bind>\n                                   case_generat\n                                    (\\<lambda>(x, y).\n  inline1 callee (x22 x) y)\n                                    (\\<lambda>out rpv'.\n  return_spmf (Inr (out, rpv', x22)))))\n                                (case_sum (\\<lambda>x. f (fst x))\n                                  (\\<lambda>x.\n\\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n   expectation_gpv 0 \\<I>'\n    (\\<lambda>xa.\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (snd (snd x) (fst xa)) (snd xa)))\n    (fst (snd x) xa)))", "apply(simp add: measure_spmf_return_spmf nn_integral_return)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> integral\\<^sup>N\n                          (measure_spmf (the_gpv (callee s out)))\n                          (case_generat\n                            (\\<lambda>(x, s').\n                                integral\\<^sup>N\n                                 (measure_spmf (inline1 callee (c x) s'))\n                                 (case_sum (\\<lambda>(x, xa). f x)\n                                   (\\<lambda>(out', callee', rpv).\n \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n    expectation_gpv 0 \\<I>'\n     (\\<lambda>(r, s').\n         expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n          (inline callee (rpv r) s'))\n     (callee' r'))))\n                            (\\<lambda>out' rpv.\n                                \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                   expectation_gpv 0 \\<I>'\n                                    (\\<lambda>(r', s').\n  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s'))\n                                    (rpv r')));\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> integral\\<^sup>N\n                                (measure_spmf\n                                  (the_gpv (callee s x21) \\<bind>\n                                   case_generat\n                                    (\\<lambda>(x, y).\n  inline1 callee (x22 x) y)\n                                    (\\<lambda>out rpv'.\n  return_spmf (Inr (out, rpv', x22)))))\n                                (case_sum (\\<lambda>x. f (fst x))\n                                  (\\<lambda>x.\n\\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n   expectation_gpv 0 \\<I>'\n    (\\<lambda>xa.\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (snd (snd x) (fst xa)) (snd xa)))\n    (fst (snd x) xa)))", "apply(rewrite measure_spmf_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> integral\\<^sup>N\n                          (measure_spmf (the_gpv (callee s out)))\n                          (case_generat\n                            (\\<lambda>(x, s').\n                                integral\\<^sup>N\n                                 (measure_spmf (inline1 callee (c x) s'))\n                                 (case_sum (\\<lambda>(x, xa). f x)\n                                   (\\<lambda>(out', callee', rpv).\n \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n    expectation_gpv 0 \\<I>'\n     (\\<lambda>(r, s').\n         expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n          (inline callee (rpv r) s'))\n     (callee' r'))))\n                            (\\<lambda>out' rpv.\n                                \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                   expectation_gpv 0 \\<I>'\n                                    (\\<lambda>(r', s').\n  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s'))\n                                    (rpv r')));\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> integral\\<^sup>N\n                                (measure_spmf\n                                  (the_gpv (callee s x21)) \\<bind>\n                                 measure_spmf \\<circ>\n                                 case_generat\n                                  (\\<lambda>(x, y).\ninline1 callee (x22 x) y)\n                                  (\\<lambda>out rpv'.\nreturn_spmf (Inr (out, rpv', x22))))\n                                (case_sum (\\<lambda>x. f (fst x))\n                                  (\\<lambda>x.\n\\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n   expectation_gpv 0 \\<I>'\n    (\\<lambda>xa.\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (snd (snd x) (fst xa)) (snd xa)))\n    (fst (snd x) xa)))", "apply(simp add: nn_integral_bind[where B=\"measure_spmf _\"] space_subprob_algebra)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> integral\\<^sup>N\n                          (measure_spmf (the_gpv (callee s out)))\n                          (case_generat\n                            (\\<lambda>(x, s').\n                                integral\\<^sup>N\n                                 (measure_spmf (inline1 callee (c x) s'))\n                                 (case_sum (\\<lambda>(x, xa). f x)\n                                   (\\<lambda>(out', callee', rpv).\n \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n    expectation_gpv 0 \\<I>'\n     (\\<lambda>(r, s').\n         expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n          (inline callee (rpv r) s'))\n     (callee' r'))))\n                            (\\<lambda>out' rpv.\n                                \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                   expectation_gpv 0 \\<I>'\n                                    (\\<lambda>(r', s').\n  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s'))\n                                    (rpv r')));\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> \\<integral>\\<^sup>+ x.\n              \\<integral>\\<^sup>+ y. (case y of\nInl x \\<Rightarrow> f (fst x)\n| Inr x \\<Rightarrow>\n    \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n       expectation_gpv 0 \\<I>'\n        (\\<lambda>xa.\n            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n             (inline callee (snd (snd x) (fst xa)) (snd xa)))\n        (fst (snd x) xa))\n                                 \\<partial>measure_spmf\n      (case x of Pure (xa, xb) \\<Rightarrow> inline1 callee (x22 xa) xb\n       | IO out rpv' \\<Rightarrow> return_spmf (Inr (out, rpv', x22)))\n            \\<partial>measure_spmf (the_gpv (callee s x21))", "apply(subst generat.case_distrib[where h=\"measure_spmf\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> integral\\<^sup>N\n                          (measure_spmf (the_gpv (callee s out)))\n                          (case_generat\n                            (\\<lambda>(x, s').\n                                integral\\<^sup>N\n                                 (measure_spmf (inline1 callee (c x) s'))\n                                 (case_sum (\\<lambda>(x, xa). f x)\n                                   (\\<lambda>(out', callee', rpv).\n \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n    expectation_gpv 0 \\<I>'\n     (\\<lambda>(r, s').\n         expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n          (inline callee (rpv r) s'))\n     (callee' r'))))\n                            (\\<lambda>out' rpv.\n                                \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                   expectation_gpv 0 \\<I>'\n                                    (\\<lambda>(r', s').\n  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s'))\n                                    (rpv r')));\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> \\<integral>\\<^sup>+ x.\n              integral\\<^sup>N\n               (case x of\n                Pure x \\<Rightarrow>\n                  measure_spmf\n                   (case x of\n                    (x, xa) \\<Rightarrow> inline1 callee (x22 x) xa)\n                | IO x1 x2 \\<Rightarrow>\n                    measure_spmf (return_spmf (Inr (x1, x2, x22))))\n               (case_sum (\\<lambda>x. f (fst x))\n                 (\\<lambda>x.\n                     \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n                        expectation_gpv 0 \\<I>'\n                         (\\<lambda>xa.\n                             expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                              (inline callee (snd (snd x) (fst xa))\n                                (snd xa)))\n                         (fst (snd x) xa)))\n            \\<partial>measure_spmf (the_gpv (callee s x21))", "apply(subst generat.case_distrib[where h=\"\\<lambda>x. nn_integral x _\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> integral\\<^sup>N\n                          (measure_spmf (the_gpv (callee s out)))\n                          (case_generat\n                            (\\<lambda>(x, s').\n                                integral\\<^sup>N\n                                 (measure_spmf (inline1 callee (c x) s'))\n                                 (case_sum (\\<lambda>(x, xa). f x)\n                                   (\\<lambda>(out', callee', rpv).\n \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n    expectation_gpv 0 \\<I>'\n     (\\<lambda>(r, s').\n         expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n          (inline callee (rpv r) s'))\n     (callee' r'))))\n                            (\\<lambda>out' rpv.\n                                \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                   expectation_gpv 0 \\<I>'\n                                    (\\<lambda>(r', s').\n  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s'))\n                                    (rpv r')));\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> integral\\<^sup>N\n                                (measure_spmf (the_gpv (callee s x21)))\n                                (case_generat\n                                  (\\<lambda>x.\nintegral\\<^sup>N\n (measure_spmf (case x of (x, xa) \\<Rightarrow> inline1 callee (x22 x) xa))\n (case_sum (\\<lambda>x. f (fst x))\n   (\\<lambda>x.\n       \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n          expectation_gpv 0 \\<I>'\n           (\\<lambda>xa.\n               expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                (inline callee (snd (snd x) (fst xa)) (snd xa)))\n           (fst (snd x) xa))))\n                                  (\\<lambda>x1 x2.\nintegral\\<^sup>N (measure_spmf (return_spmf (Inr (x1, x2, x22))))\n (case_sum (\\<lambda>x. f (fst x))\n   (\\<lambda>x.\n       \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n          expectation_gpv 0 \\<I>'\n           (\\<lambda>xa.\n               expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                (inline callee (snd (snd x) (fst xa)) (snd xa)))\n           (fst (snd x) xa)))))", "apply(simp add: measure_spmf_return_spmf nn_integral_return split_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> f x\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  0 * ennreal (pmf (the_gpv gpv) None)\n  \\<le> expectation_gpv2 (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n         (inline callee gpv s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma plossless_inline:\n  assumes lossless: \"plossless_gpv \\<I> gpv\"\n    and WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and callee: \"\\<And>s x. x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> plossless_gpv \\<I>' (callee s x)\"\n    and callee': \"\\<And>s x. x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> results_gpv \\<I>' (callee s x) \\<subseteq> responses_\\<I> \\<I> x \\<times> UNIV\"\n    and WT_callee: \"\\<And>s x. x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> \\<I>' \\<turnstile>g callee s x \\<surd>\"\n  shows \"plossless_gpv \\<I>' (inline callee gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_gpv \\<I>' (inline callee gpv s)", "unfolding pgen_lossless_gpv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s) = 1", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s) \\<le> 1\n 2. 1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "have WT': \"\\<I>' \\<turnstile>g inline callee gpv s \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>' \\<turnstile>g inline callee gpv s \\<surd>", "using callee' WT_callee WT"], ["proof (prove)\nusing this:\n  ?x \\<in> outs_\\<I> \\<I> \\<Longrightarrow>\n  results_gpv \\<I>' (callee ?s ?x)\n  \\<subseteq> responses_\\<I> \\<I> ?x \\<times> UNIV\n  ?x \\<in> outs_\\<I> \\<I> \\<Longrightarrow>\n  \\<I>' \\<turnstile>g callee ?s ?x \\<surd>\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. \\<I>' \\<turnstile>g inline callee gpv s \\<surd>", "by(rule WT_gpv_inline)"], ["proof (state)\nthis:\n  \\<I>' \\<turnstile>g inline callee gpv s \\<surd>\n\ngoal (2 subgoals):\n 1. expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s) \\<le> 1\n 2. 1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "from expectation_gpv_const_le[OF WT', of 0 1]"], ["proof (chain)\npicking this:\n  expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)\n  \\<le> max 1 0", "show \"expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s) \\<le> 1\""], ["proof (prove)\nusing this:\n  expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)\n  \\<le> max 1 0\n\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s) \\<le> 1", "by(simp add: max_def)"], ["proof (state)\nthis:\n  expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s) \\<le> 1\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "have \"1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv", "using lossless"], ["proof (prove)\nusing this:\n  plossless_gpv \\<I> gpv\n\ngoal (1 subgoal):\n 1. 1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv", "by(simp add: pgen_lossless_gpv_def)"], ["proof (state)\nthis:\n  1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "also"], ["proof (state)\nthis:\n  1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "have \"\\<dots> \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n    \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "by(rule expectation_gpv_le_inline[unfolded split_def]; rule callee callee' WT WT_callee)"], ["proof (state)\nthis:\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n  \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "finally"], ["proof (chain)\npicking this:\n  1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "show \"1 \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "."], ["proof (state)\nthis:\n  1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma plossless_exec_gpv:\n  assumes lossless: \"plossless_gpv \\<I> gpv\"\n    and WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and callee: \"\\<And>s x. x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> lossless_spmf (callee s x)\"\n    and callee': \"\\<And>s x. x \\<in> outs_\\<I> \\<I> \\<Longrightarrow> set_spmf (callee s x) \\<subseteq> responses_\\<I> \\<I> x \\<times> UNIV\"\n  shows \"lossless_spmf (exec_gpv callee gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (exec_gpv callee gpv s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lossless_spmf (exec_gpv callee gpv s)", "have \"plossless_gpv \\<I>_full (inline (\\<lambda>s x. lift_spmf (callee s x)) gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_gpv \\<I>_full\n     (inline (\\<lambda>s x. lift_spmf (callee s x)) gpv s)", "using lossless WT"], ["proof (prove)\nusing this:\n  plossless_gpv \\<I> gpv\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. plossless_gpv \\<I>_full\n     (inline (\\<lambda>s x. lift_spmf (callee s x)) gpv s)", "by(rule plossless_inline)(simp_all add: callee callee')"], ["proof (state)\nthis:\n  plossless_gpv \\<I>_full\n   (inline (\\<lambda>s x. lift_spmf (callee s x)) gpv s)\n\ngoal (1 subgoal):\n 1. lossless_spmf (exec_gpv callee gpv s)", "from this[THEN plossless_gpv_lossless_spmfD]"], ["proof (chain)\npicking this:\n  \\<I>_full\n  \\<turnstile>g inline (\\<lambda>s x. lift_spmf (callee s x)) gpv\n                 s \\<surd> \\<Longrightarrow>\n  lossless_spmf\n   (the_gpv (inline (\\<lambda>s x. lift_spmf (callee s x)) gpv s))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<I>_full\n  \\<turnstile>g inline (\\<lambda>s x. lift_spmf (callee s x)) gpv\n                 s \\<surd> \\<Longrightarrow>\n  lossless_spmf\n   (the_gpv (inline (\\<lambda>s x. lift_spmf (callee s x)) gpv s))\n\ngoal (1 subgoal):\n 1. lossless_spmf (exec_gpv callee gpv s)", "unfolding exec_gpv_conv_inline1"], ["proof (prove)\nusing this:\n  \\<I>_full\n  \\<turnstile>g inline (\\<lambda>s x. lift_spmf (callee s x)) gpv\n                 s \\<surd> \\<Longrightarrow>\n  lossless_spmf\n   (the_gpv (inline (\\<lambda>s x. lift_spmf (callee s x)) gpv s))\n\ngoal (1 subgoal):\n 1. lossless_spmf\n     (map_spmf projl (inline1 (\\<lambda>s c. lift_spmf (callee s c)) gpv s))", "by(simp add: inline_sel)"], ["proof (state)\nthis:\n  lossless_spmf (exec_gpv callee gpv s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma expectation_gpv_\\<I>_mono:\n  defines \"expectation_gpv' \\<equiv> expectation_gpv\"\n  assumes le: \"\\<I> \\<le> \\<I>'\"\n    and WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n  shows \"expectation_gpv fail \\<I> f gpv \\<le> expectation_gpv' fail \\<I>' f gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> f gpv \\<le> expectation_gpv' fail \\<I>' f gpv", "using WT"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> f gpv \\<le> expectation_gpv' fail \\<I>' f gpv", "proof(induction arbitrary: gpv rule: expectation_gpv_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            a x \\<le> expectation_gpv' fail \\<I>' f x)\n 2. \\<And>gpv.\n       \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n       0 \\<le> expectation_gpv' fail \\<I>' f gpv\n 3. \\<And>expectation_gpv'a gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv'a gpv\n                   \\<le> expectation_gpv fail \\<I> f gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv'a gpv \\<le> expectation_gpv' fail \\<I>' f gpv;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv'a (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv' fail \\<I>' f gpv", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            a x \\<le> expectation_gpv' fail \\<I>' f x)\n 2. \\<And>gpv.\n       \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n       0 \\<le> expectation_gpv' fail \\<I>' f gpv\n 3. \\<And>expectation_gpv'a gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv'a gpv\n                   \\<le> expectation_gpv fail \\<I> f gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv'a gpv \\<le> expectation_gpv' fail \\<I>' f gpv;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv'a (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv' fail \\<I>' f gpv", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            a x \\<le> expectation_gpv' fail \\<I>' f x)", "by simp"], ["proof (state)\nthis:\n  lfp.admissible\n   (\\<lambda>a.\n       \\<forall>x.\n          \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n          a x \\<le> expectation_gpv' fail \\<I>' f x)\n\ngoal (2 subgoals):\n 1. \\<And>gpv.\n       \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n       0 \\<le> expectation_gpv' fail \\<I>' f gpv\n 2. \\<And>expectation_gpv'a gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv'a gpv\n                   \\<le> expectation_gpv fail \\<I> f gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv'a gpv \\<le> expectation_gpv' fail \\<I>' f gpv;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv'a (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv' fail \\<I>' f gpv", "case bottom"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>gpv.\n       \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n       0 \\<le> expectation_gpv' fail \\<I>' f gpv\n 2. \\<And>expectation_gpv'a gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv'a gpv\n                   \\<le> expectation_gpv fail \\<I> f gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv'a gpv \\<le> expectation_gpv' fail \\<I>' f gpv;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv'a (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv' fail \\<I>' f gpv", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> expectation_gpv' fail \\<I>' f gpv", "by simp"], ["proof (state)\nthis:\n  0 \\<le> expectation_gpv' fail \\<I>' f gpv\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv'a gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv'a gpv\n                   \\<le> expectation_gpv fail \\<I> f gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv'a gpv \\<le> expectation_gpv' fail \\<I>' f gpv;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv'a (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv' fail \\<I>' f gpv", "case step [unfolded expectation_gpv'_def]: (step expectation_gpv')"], ["proof (state)\nthis:\n  expectation_gpv' ?gpv \\<le> expectation_gpv fail \\<I> f ?gpv\n  \\<I> \\<turnstile>g ?gpv \\<surd> \\<Longrightarrow>\n  expectation_gpv' ?gpv \\<le> expectation_gpv fail \\<I>' f ?gpv\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv'a gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv'a gpv\n                   \\<le> expectation_gpv fail \\<I> f gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv'a gpv \\<le> expectation_gpv' fail \\<I>' f gpv;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv'a (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv' fail \\<I>' f gpv", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail * ennreal (pmf (the_gpv gpv) None)\n    \\<le> expectation_gpv' fail \\<I>' f gpv", "unfolding expectation_gpv'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail * ennreal (pmf (the_gpv gpv) None)\n    \\<le> expectation_gpv fail \\<I>' f gpv", "by(subst expectation_gpv.simps)\n      (clarsimp intro!: add_mono nn_integral_mono_AE INF_mono split: generat.split\n        , auto intro!: bexI step add_mono nn_integral_mono_AE INF_mono split: generat.split dest: WT_gpvD[OF step.prems] intro!: step dest: responses_\\<I>_mono[OF le])"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> f x\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  fail * ennreal (pmf (the_gpv gpv) None)\n  \\<le> expectation_gpv' fail \\<I>' f gpv\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pgen_lossless_gpv_mono:\n  assumes *: \"pgen_lossless_gpv fail \\<I> gpv\"\n    and le: \"\\<I> \\<le> \\<I>'\"\n    and WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and fail: \"fail \\<le> 1\"\n  shows \"pgen_lossless_gpv fail \\<I>' gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pgen_lossless_gpv fail \\<I>' gpv", "unfolding pgen_lossless_gpv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I>' (\\<lambda>_. 1) gpv = 1", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. expectation_gpv fail \\<I>' (\\<lambda>_. 1) gpv \\<le> 1\n 2. 1 \\<le> expectation_gpv fail \\<I>' (\\<lambda>_. 1) gpv", "from WT le"], ["proof (chain)\npicking this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  \\<I> \\<le> \\<I>'", "have \"\\<I>' \\<turnstile>g gpv \\<surd>\""], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  \\<I> \\<le> \\<I>'\n\ngoal (1 subgoal):\n 1. \\<I>' \\<turnstile>g gpv \\<surd>", "by(rule WT_gpv_\\<I>_mono)"], ["proof (state)\nthis:\n  \\<I>' \\<turnstile>g gpv \\<surd>\n\ngoal (2 subgoals):\n 1. expectation_gpv fail \\<I>' (\\<lambda>_. 1) gpv \\<le> 1\n 2. 1 \\<le> expectation_gpv fail \\<I>' (\\<lambda>_. 1) gpv", "from expectation_gpv_const_le[OF this, of fail 1] fail"], ["proof (chain)\npicking this:\n  expectation_gpv fail \\<I>' (\\<lambda>_. 1) gpv \\<le> max 1 fail\n  fail \\<le> 1", "show \"expectation_gpv fail \\<I>' (\\<lambda>_. 1) gpv \\<le> 1\""], ["proof (prove)\nusing this:\n  expectation_gpv fail \\<I>' (\\<lambda>_. 1) gpv \\<le> max 1 fail\n  fail \\<le> 1\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I>' (\\<lambda>_. 1) gpv \\<le> 1", "by(simp add: max_def split: if_split_asm)"], ["proof (state)\nthis:\n  expectation_gpv fail \\<I>' (\\<lambda>_. 1) gpv \\<le> 1\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv fail \\<I>' (\\<lambda>_. 1) gpv", "from expectation_gpv_\\<I>_mono[OF le WT, of fail \"\\<lambda>_. 1\"] *"], ["proof (chain)\npicking this:\n  expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n  \\<le> expectation_gpv fail \\<I>' (\\<lambda>_. 1) gpv\n  pgen_lossless_gpv fail \\<I> gpv", "show \"expectation_gpv fail \\<I>' (\\<lambda>_. 1) gpv \\<ge> 1\""], ["proof (prove)\nusing this:\n  expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv\n  \\<le> expectation_gpv fail \\<I>' (\\<lambda>_. 1) gpv\n  pgen_lossless_gpv fail \\<I> gpv\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv fail \\<I>' (\\<lambda>_. 1) gpv", "by(simp add: pgen_lossless_gpv_def)"], ["proof (state)\nthis:\n  1 \\<le> expectation_gpv fail \\<I>' (\\<lambda>_. 1) gpv\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma plossless_gpv_mono:\n  \"\\<lbrakk> plossless_gpv \\<I> gpv; \\<I> \\<le> \\<I>'; \\<I> \\<turnstile>g gpv \\<surd> \\<rbrakk> \\<Longrightarrow> plossless_gpv \\<I>' gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>plossless_gpv \\<I> gpv; \\<I> \\<le> \\<I>';\n     \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n    \\<Longrightarrow> plossless_gpv \\<I>' gpv", "by(erule pgen_lossless_gpv_mono; simp)"], ["", "lemma pfinite_gpv_mono:\n  \"\\<lbrakk> pfinite_gpv \\<I> gpv; \\<I> \\<le> \\<I>'; \\<I> \\<turnstile>g gpv \\<surd> \\<rbrakk> \\<Longrightarrow> pfinite_gpv \\<I>' gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pfinite_gpv \\<I> gpv; \\<I> \\<le> \\<I>';\n     \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n    \\<Longrightarrow> pfinite_gpv \\<I>' gpv", "by(erule pgen_lossless_gpv_mono; simp)"], ["", "lemma pgen_lossless_gpv_parametric': includes lifting_syntax shows\n  \"((=) ===> rel_\\<I> C R ===> rel_gpv'' A C R ===> (=)) pgen_lossless_gpv pgen_lossless_gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> rel_\\<I> C R ===> rel_gpv'' A C R ===> (=)) pgen_lossless_gpv\n     pgen_lossless_gpv", "unfolding pgen_lossless_gpv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> rel_\\<I> C R ===> rel_gpv'' A C R ===> (=))\n     (\\<lambda>fail \\<I> gpv.\n         expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv = 1)\n     (\\<lambda>fail \\<I> gpv.\n         expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv = 1)", "supply expectation_gpv_parametric'[transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> rel_\\<I> C R ===> rel_gpv'' A C R ===> (=))\n     (\\<lambda>fail \\<I> gpv.\n         expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv = 1)\n     (\\<lambda>fail \\<I> gpv.\n         expectation_gpv fail \\<I> (\\<lambda>_. 1) gpv = 1)", "by transfer_prover"], ["", "lemma pgen_lossless_gpv_parametric: includes lifting_syntax shows\n  \"((=) ===> rel_\\<I> C (=) ===> rel_gpv A C ===> (=)) pgen_lossless_gpv pgen_lossless_gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> rel_\\<I> C (=) ===> rel_gpv A C ===> (=)) pgen_lossless_gpv\n     pgen_lossless_gpv", "using pgen_lossless_gpv_parametric'[of C \"(=)\" A]"], ["proof (prove)\nusing this:\n  ((=) ===> rel_\\<I> C (=) ===> rel_gpv'' A C (=) ===> (=))\n   pgen_lossless_gpv pgen_lossless_gpv\n\ngoal (1 subgoal):\n 1. ((=) ===> rel_\\<I> C (=) ===> rel_gpv A C ===> (=)) pgen_lossless_gpv\n     pgen_lossless_gpv", "by(simp add: rel_gpv_conv_rel_gpv'')"], ["", "lemma pgen_lossless_gpv_map_gpv_id [simp]:\n  \"pgen_lossless_gpv fail \\<I> (map_gpv f id gpv) = pgen_lossless_gpv fail \\<I> gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pgen_lossless_gpv fail \\<I> (map_gpv f id gpv) =\n    pgen_lossless_gpv fail \\<I> gpv", "using pgen_lossless_gpv_parametric[of \"BNF_Def.Grp UNIV id\" \"BNF_Def.Grp UNIV f\"]"], ["proof (prove)\nusing this:\n  rel_fun (=)\n   (rel_fun (rel_\\<I> (BNF_Def.Grp UNIV id) (=))\n     (rel_fun (rel_gpv (BNF_Def.Grp UNIV f) (BNF_Def.Grp UNIV id)) (=)))\n   pgen_lossless_gpv pgen_lossless_gpv\n\ngoal (1 subgoal):\n 1. pgen_lossless_gpv fail \\<I> (map_gpv f id gpv) =\n    pgen_lossless_gpv fail \\<I> gpv", "unfolding gpv.rel_Grp"], ["proof (prove)\nusing this:\n  rel_fun (=)\n   (rel_fun (rel_\\<I> (BNF_Def.Grp UNIV id) (=))\n     (rel_fun\n       (BNF_Def.Grp\n         {x. results'_gpv x \\<subseteq> UNIV \\<and>\n             outs'_gpv x \\<subseteq> UNIV}\n         (map_gpv f id))\n       (=)))\n   pgen_lossless_gpv pgen_lossless_gpv\n\ngoal (1 subgoal):\n 1. pgen_lossless_gpv fail \\<I> (map_gpv f id gpv) =\n    pgen_lossless_gpv fail \\<I> gpv", "by(auto simp add: eq_alt[symmetric] rel_\\<I>_eq rel_fun_def Grp_iff)"], ["", "context raw_converter_invariant begin"], ["", "lemma expectation_gpv_le_inline:\n  defines \"expectation_gpv2 \\<equiv> expectation_gpv 0 \\<I>'\"\n  assumes callee: \"\\<And>s x. \\<lbrakk> x \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> plossless_gpv \\<I>' (callee s x)\"\n    and WT_gpv: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and I: \"I s\"\n  shows \"expectation_gpv 0 \\<I> f gpv \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I> f gpv\n    \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee gpv s)", "using WT_gpv I"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I> f gpv\n    \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee gpv s)", "proof(induction arbitrary: gpv s rule: expectation_gpv_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            (\\<forall>xa.\n                I xa \\<longrightarrow>\n                a x\n                \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                       (inline callee x xa)))\n 2. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                  (inline callee gpv s)\n 3. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            (\\<forall>xa.\n                I xa \\<longrightarrow>\n                a x\n                \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                       (inline callee x xa)))\n 2. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                  (inline callee gpv s)\n 3. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            (\\<forall>xa.\n                I xa \\<longrightarrow>\n                a x\n                \\<le> expectation_gpv2\n                       (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n                       (inline callee x xa)))", "by simp"], ["proof (state)\nthis:\n  lfp.admissible\n   (\\<lambda>a.\n       \\<forall>x.\n          \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n          (\\<forall>xa.\n              I xa \\<longrightarrow>\n              a x\n              \\<le> expectation_gpv2\n                     (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n                     (inline callee x xa)))\n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                  (inline callee gpv s)\n 2. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "case bottom"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                  (inline callee gpv s)\n 2. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> expectation_gpv2\n             (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n             (inline callee gpv s)", "by simp"], ["proof (state)\nthis:\n  0 \\<le> expectation_gpv2 (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n           (inline callee gpv s)\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "case (step expectation_gpv')"], ["proof (state)\nthis:\n  expectation_gpv' ?gpv \\<le> expectation_gpv 0 \\<I> f ?gpv\n  \\<lbrakk>\\<I> \\<turnstile>g ?gpv \\<surd>; I ?s\\<rbrakk>\n  \\<Longrightarrow> expectation_gpv' ?gpv\n                    \\<le> expectation_gpv2\n                           (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n                           (inline callee ?gpv ?s)\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "{"], ["proof (state)\nthis:\n  expectation_gpv' ?gpv \\<le> expectation_gpv 0 \\<I> f ?gpv\n  \\<lbrakk>\\<I> \\<turnstile>g ?gpv \\<surd>; I ?s\\<rbrakk>\n  \\<Longrightarrow> expectation_gpv' ?gpv\n                    \\<le> expectation_gpv2\n                           (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n                           (inline callee ?gpv ?s)\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "fix out c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "assume IO: \"IO out c \\<in> set_spmf (the_gpv gpv)\""], ["proof (state)\nthis:\n  IO out c \\<in> set_spmf (the_gpv gpv)\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "with step.prems (1)"], ["proof (chain)\npicking this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  IO out c \\<in> set_spmf (the_gpv gpv)", "have out: \"out \\<in> outs_\\<I> \\<I>\""], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  IO out c \\<in> set_spmf (the_gpv gpv)\n\ngoal (1 subgoal):\n 1. out \\<in> outs_\\<I> \\<I>", "by(rule WT_gpv_OutD)"], ["proof (state)\nthis:\n  out \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "have \"(INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) = \\<integral>\\<^sup>+ generat. (INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) \\<partial>measure_spmf (the_gpv (callee s out))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) =\n    \\<integral>\\<^sup>+ generat.\n                         (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                             expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv (callee s out))", "using WT_callee[OF out, of s] callee[OF out, of s] \\<open>I s\\<close>"], ["proof (prove)\nusing this:\n  I s \\<Longrightarrow> \\<I>' \\<turnstile>g callee s out \\<surd>\n  I s \\<Longrightarrow> plossless_gpv \\<I>' (callee s out)\n  I s\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) =\n    \\<integral>\\<^sup>+ generat.\n                         (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                             expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv (callee s out))", "by(clarsimp simp add: measure_spmf.emeasure_eq_measure plossless_iff_colossless_pfinite colossless_gpv_lossless_spmfD lossless_weight_spmfD)"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) =\n  \\<integral>\\<^sup>+ generat.\n                       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                           expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) =\n  \\<integral>\\<^sup>+ generat.\n                       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                           expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "have \"\\<dots> \\<le> \\<integral>\\<^sup>+ generat. (case generat of Pure (x, s') \\<Rightarrow>\n            \\<integral>\\<^sup>+ xx. (case xx of Inl (x, _) \\<Rightarrow> f x \n               | Inr (out', callee', rpv) \\<Rightarrow> INF r'\\<in>responses_\\<I> \\<I>' out'. expectation_gpv 0 \\<I>' (\\<lambda>(r, s'). expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv r) s')) (callee' r'))\n            \\<partial>measure_spmf (inline1 callee (c x) s')\n         | IO out' rpv \\<Rightarrow> INF r'\\<in>responses_\\<I> \\<I>' out'. expectation_gpv 0 \\<I>' (\\<lambda>(r', s'). expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s')) (rpv r'))\n       \\<partial>measure_spmf (the_gpv (callee s out))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                             expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv (callee s out))\n    \\<le> \\<integral>\\<^sup>+ generat.\n                               (case generat of\n                                Pure (x, s') \\<Rightarrow>\n                                  \\<integral>\\<^sup>+ xx.\n                 (case xx of Inl (x, xa) \\<Rightarrow> f x\n                  | Inr (out', callee', rpv) \\<Rightarrow>\n                      \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                         expectation_gpv 0 \\<I>'\n                          (\\<lambda>(r, s').\n                              expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                               (inline callee (rpv r) s'))\n                          (callee' r'))\n               \\<partial>measure_spmf (inline1 callee (c x) s')\n                                | IO out' rpv \\<Rightarrow>\n                                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n                out'.\n expectation_gpv 0 \\<I>'\n  (\\<lambda>(r', s').\n      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c r') s'))\n  (rpv r'))\n                             \\<partial>measure_spmf (the_gpv (callee s out))", "proof(rule nn_integral_mono_AE; simp split!: generat.split)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "fix x s'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "assume Pure: \"Pure (x, s') \\<in> set_spmf (the_gpv (callee s out))\""], ["proof (state)\nthis:\n  Pure (x, s') \\<in> set_spmf (the_gpv (callee s out))\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "hence \"(x, s') \\<in> results_gpv \\<I>' (callee s out)\""], ["proof (prove)\nusing this:\n  Pure (x, s') \\<in> set_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. (x, s') \\<in> results_gpv \\<I>' (callee s out)", "by(rule results_gpv.Pure)"], ["proof (state)\nthis:\n  (x, s') \\<in> results_gpv \\<I>' (callee s out)\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "with results_callee[OF out, of s] \\<open>I s\\<close>"], ["proof (chain)\npicking this:\n  I s \\<Longrightarrow>\n  results_gpv \\<I>' (callee s out)\n  \\<subseteq> responses_\\<I> \\<I> out \\<times> {s. I s}\n  I s\n  (x, s') \\<in> results_gpv \\<I>' (callee s out)", "have x: \"x \\<in> responses_\\<I> \\<I> out\" and \"I s'\""], ["proof (prove)\nusing this:\n  I s \\<Longrightarrow>\n  results_gpv \\<I>' (callee s out)\n  \\<subseteq> responses_\\<I> \\<I> out \\<times> {s. I s}\n  I s\n  (x, s') \\<in> results_gpv \\<I>' (callee s out)\n\ngoal (1 subgoal):\n 1. x \\<in> responses_\\<I> \\<I> out &&& I s'", "by blast+"], ["proof (state)\nthis:\n  x \\<in> responses_\\<I> \\<I> out\n  I s'\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "from x"], ["proof (chain)\npicking this:\n  x \\<in> responses_\\<I> \\<I> out", "have \"(INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) \\<le> expectation_gpv' (c x)\""], ["proof (prove)\nusing this:\n  x \\<in> responses_\\<I> \\<I> out\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> expectation_gpv' (c x)", "by(rule INF_lower)"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> expectation_gpv' (c x)\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> expectation_gpv' (c x)\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "have \"\\<dots> \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x) s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv' (c x)\n    \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x) s')", "by(rule step.IH)(rule WT_gpv_ContD[OF step.prems(1) IO x] step.prems \\<open>I s'\\<close>|assumption)+"], ["proof (state)\nthis:\n  expectation_gpv' (c x)\n  \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x) s')\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "also"], ["proof (state)\nthis:\n  expectation_gpv' (c x)\n  \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x) s')\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "have \"\\<dots> = \\<integral>\\<^sup>+ xx. (case xx of Inl (x, _) \\<Rightarrow> f x \n               | Inr (out', callee', rpv) \\<Rightarrow> INF r'\\<in>responses_\\<I> \\<I>' out'. expectation_gpv 0 \\<I>' (\\<lambda>(r, s'). expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv r) s')) (callee' r'))\n            \\<partial>measure_spmf (inline1 callee (c x) s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x) s') =\n    \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                             | Inr (out', callee', rpv) \\<Rightarrow>\n                                 \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                    expectation_gpv 0 \\<I>'\n                                     (\\<lambda>(r, s').\n   expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n    (inline callee (rpv r) s'))\n                                     (callee' r'))\n                       \\<partial>measure_spmf (inline1 callee (c x) s')", "unfolding expectation_gpv2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n     (inline callee (c x) s') =\n    \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                             | Inr (out', callee', rpv) \\<Rightarrow>\n                                 \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                    expectation_gpv 0 \\<I>'\n                                     (\\<lambda>(r, s').\n   expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n    (inline callee (rpv r) s'))\n                                     (callee' r'))\n                       \\<partial>measure_spmf (inline1 callee (c x) s')", "by(subst expectation_gpv.simps)(auto simp add: inline_sel split_def o_def intro!: nn_integral_cong split: generat.split sum.split)"], ["proof (state)\nthis:\n  expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x) s') =\n  \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                           | Inr (out', callee', rpv) \\<Rightarrow>\n                               \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                  expectation_gpv 0 \\<I>'\n                                   (\\<lambda>(r, s').\n expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                   (callee' r'))\n                     \\<partial>measure_spmf (inline1 callee (c x) s')\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                                 | Inr (out', callee', rpv) \\<Rightarrow>\n                                     \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n                 out'.\n  expectation_gpv 0 \\<I>'\n   (\\<lambda>(r, s').\n       expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n        (inline callee (rpv r) s'))\n   (callee' r'))\n                           \\<partial>measure_spmf (inline1 callee (c x) s')", "show \"(INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                                 | Inr (out', callee', rpv) \\<Rightarrow>\n                                     \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n                 out'.\n  expectation_gpv 0 \\<I>'\n   (\\<lambda>(r, s').\n       expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n        (inline callee (rpv r) s'))\n   (callee' r'))\n                           \\<partial>measure_spmf (inline1 callee (c x) s')\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                                   | Inr (out', callee', rpv) \\<Rightarrow>\n \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n    expectation_gpv 0 \\<I>'\n     (\\<lambda>(r, s').\n         expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n          (inline callee (rpv r) s'))\n     (callee' r'))\n                             \\<partial>measure_spmf\n  (inline1 callee (c x) s')", "."], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                                 | Inr (out', callee', rpv) \\<Rightarrow>\n                                     \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n                 out'.\n  expectation_gpv 0 \\<I>'\n   (\\<lambda>(r, s').\n       expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n        (inline callee (rpv r) s'))\n   (callee' r'))\n                           \\<partial>measure_spmf (inline1 callee (c x) s')\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "fix out' rpv"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "assume IO': \"IO out' rpv \\<in> set_spmf (the_gpv (callee s out))\""], ["proof (state)\nthis:\n  IO out' rpv \\<in> set_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "have \"(INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) \\<le> (INF (r, s')\\<in>(\\<Union>r'\\<in>responses_\\<I> \\<I>' out'. results_gpv \\<I>' (rpv r')). expectation_gpv' (c r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> (\\<Sqinter>(r,\n              s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                         results_gpv \\<I>' (rpv r').\n              expectation_gpv' (c r))", "using IO' results_callee[OF out, of s] \\<open>I s\\<close>"], ["proof (prove)\nusing this:\n  IO out' rpv \\<in> set_spmf (the_gpv (callee s out))\n  I s \\<Longrightarrow>\n  results_gpv \\<I>' (callee s out)\n  \\<subseteq> responses_\\<I> \\<I> out \\<times> {s. I s}\n  I s\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> (\\<Sqinter>(r,\n              s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                         results_gpv \\<I>' (rpv r').\n              expectation_gpv' (c r))", "by(intro INF_mono)(auto intro: results_gpv.IO)"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>(r,\n            s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                       results_gpv \\<I>' (rpv r').\n            expectation_gpv' (c r))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>(r,\n            s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                       results_gpv \\<I>' (rpv r').\n            expectation_gpv' (c r))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "have \"\\<dots> = (INF r'\\<in>responses_\\<I> \\<I>' out'. INF (r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv' (c r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>(r,\n        s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                   results_gpv \\<I>' (rpv r').\n        expectation_gpv' (c r)) =\n    (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n        \\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n           expectation_gpv' (c r))", "by(simp add: INF_UNION)"], ["proof (state)\nthis:\n  (\\<Sqinter>(r,\n      s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                 results_gpv \\<I>' (rpv r').\n      expectation_gpv' (c r)) =\n  (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n      \\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n         expectation_gpv' (c r))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>(r,\n      s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                 results_gpv \\<I>' (rpv r').\n      expectation_gpv' (c r)) =\n  (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n      \\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n         expectation_gpv' (c r))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "have \"\\<dots> \\<le> (INF r'\\<in>responses_\\<I> \\<I>' out'. expectation_gpv 0 \\<I>' (\\<lambda>(r', s'). expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s')) (rpv r'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n        \\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n           expectation_gpv' (c r))\n    \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n              expectation_gpv 0 \\<I>'\n               (\\<lambda>(r', s').\n                   expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                    (inline callee (c r') s'))\n               (rpv r'))", "proof(rule INF_mono, rule bexI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv (?r'2 m)).\n           expectation_gpv' (c r))\n       \\<le> expectation_gpv 0 \\<I>'\n              (\\<lambda>(r', s').\n                  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c r') s'))\n              (rpv m)\n 2. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       ?r'2 m \\<in> responses_\\<I> \\<I>' out'", "fix r'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv (?r'2 m)).\n           expectation_gpv' (c r))\n       \\<le> expectation_gpv 0 \\<I>'\n              (\\<lambda>(r', s').\n                  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c r') s'))\n              (rpv m)\n 2. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       ?r'2 m \\<in> responses_\\<I> \\<I>' out'", "assume r': \"r' \\<in> responses_\\<I> \\<I>' out'\""], ["proof (state)\nthis:\n  r' \\<in> responses_\\<I> \\<I>' out'\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv (?r'2 m)).\n           expectation_gpv' (c r))\n       \\<le> expectation_gpv 0 \\<I>'\n              (\\<lambda>(r', s').\n                  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c r') s'))\n              (rpv m)\n 2. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       ?r'2 m \\<in> responses_\\<I> \\<I>' out'", "have \"(INF (r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv' (c r)) \\<le> (INF (r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c r) s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n        expectation_gpv' (c r))\n    \\<le> (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n              expectation_gpv2 (\\<lambda>(x, s). f x)\n               (inline callee (c r) s'))", "using IO IO' step.prems out results_callee[OF out, of s] r'"], ["proof (prove)\nusing this:\n  IO out c \\<in> set_spmf (the_gpv gpv)\n  IO out' rpv \\<in> set_spmf (the_gpv (callee s out))\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n  out \\<in> outs_\\<I> \\<I>\n  I s \\<Longrightarrow>\n  results_gpv \\<I>' (callee s out)\n  \\<subseteq> responses_\\<I> \\<I> out \\<times> {s. I s}\n  r' \\<in> responses_\\<I> \\<I>' out'\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n        expectation_gpv' (c r))\n    \\<le> (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n              expectation_gpv2 (\\<lambda>(x, s). f x)\n               (inline callee (c r) s'))", "by(auto intro!: INF_mono rev_bexI step.IH dest: WT_gpv_ContD intro: results_gpv.IO)"], ["proof (state)\nthis:\n  (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n            expectation_gpv2 (\\<lambda>(x, s). f x)\n             (inline callee (c r) s'))\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv (?r'2 m)).\n           expectation_gpv' (c r))\n       \\<le> expectation_gpv 0 \\<I>'\n              (\\<lambda>(r', s').\n                  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c r') s'))\n              (rpv m)\n 2. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       ?r'2 m \\<in> responses_\\<I> \\<I>' out'", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n            expectation_gpv2 (\\<lambda>(x, s). f x)\n             (inline callee (c r) s'))\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv (?r'2 m)).\n           expectation_gpv' (c r))\n       \\<le> expectation_gpv 0 \\<I>'\n              (\\<lambda>(r', s').\n                  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c r') s'))\n              (rpv m)\n 2. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       ?r'2 m \\<in> responses_\\<I> \\<I>' out'", "have \"\\<dots> \\<le>  expectation_gpv 0 \\<I>' (\\<lambda>(r', s'). expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s')) (rpv r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n        expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c r) s'))\n    \\<le> expectation_gpv 0 \\<I>'\n           (\\<lambda>(r', s').\n               expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                (inline callee (c r') s'))\n           (rpv r')", "unfolding expectation_gpv2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (c r) s'))\n    \\<le> expectation_gpv 0 \\<I>'\n           (\\<lambda>(r', s').\n               expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                (inline callee (c r') s'))\n           (rpv r')", "using plossless_gpv_ContD[OF callee, OF out \\<open>I s\\<close> IO' r'] WT_callee[OF out \\<open>I s\\<close>] IO' r'"], ["proof (prove)\nusing this:\n  \\<I>' \\<turnstile>g callee s out \\<surd> \\<Longrightarrow>\n  plossless_gpv \\<I>' (rpv r')\n  \\<I>' \\<turnstile>g callee s out \\<surd>\n  IO out' rpv \\<in> set_spmf (the_gpv (callee s out))\n  r' \\<in> responses_\\<I> \\<I>' out'\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (c r) s'))\n    \\<le> expectation_gpv 0 \\<I>'\n           (\\<lambda>(r', s').\n               expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                (inline callee (c r') s'))\n           (rpv r')", "by(intro plossless_INF_le_expectation_gpv)(auto intro: WT_gpv_ContD)"], ["proof (state)\nthis:\n  (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n      expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c r) s'))\n  \\<le> expectation_gpv 0 \\<I>'\n         (\\<lambda>(r', s').\n             expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (c r') s'))\n         (rpv r')\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv (?r'2 m)).\n           expectation_gpv' (c r))\n       \\<le> expectation_gpv 0 \\<I>'\n              (\\<lambda>(r', s').\n                  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c r') s'))\n              (rpv m)\n 2. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       ?r'2 m \\<in> responses_\\<I> \\<I>' out'", "finally"], ["proof (chain)\npicking this:\n  (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv' (c r))\n  \\<le> expectation_gpv 0 \\<I>'\n         (\\<lambda>(r', s').\n             expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (c r') s'))\n         (rpv r')", "show \"(INF (r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv' (c r)) \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv' (c r))\n  \\<le> expectation_gpv 0 \\<I>'\n         (\\<lambda>(r', s').\n             expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (c r') s'))\n         (rpv r')\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n        expectation_gpv' (c r))\n    \\<le> expectation_gpv 0 \\<I>'\n           (\\<lambda>(r', s').\n               expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                (inline callee (c r') s'))\n           (rpv r')", "."], ["proof (state)\nthis:\n  (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv' (c r))\n  \\<le> expectation_gpv 0 \\<I>'\n         (\\<lambda>(r', s').\n             expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (c r') s'))\n         (rpv r')\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       m \\<in> responses_\\<I> \\<I>' out'", "qed"], ["proof (state)\nthis:\n  (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n      \\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n         expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n            expectation_gpv 0 \\<I>'\n             (\\<lambda>(r', s').\n                 expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                  (inline callee (c r') s'))\n             (rpv r'))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n            expectation_gpv 0 \\<I>'\n             (\\<lambda>(r', s').\n                 expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                  (inline callee (c r') s'))\n             (rpv r'))", "show \"(INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n            expectation_gpv 0 \\<I>'\n             (\\<lambda>(r', s').\n                 expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                  (inline callee (c r') s'))\n             (rpv r'))\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n              expectation_gpv 0 \\<I>'\n               (\\<lambda>(r', s').\n                   expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                    (inline callee (c r') s'))\n               (rpv r'))", "."], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n            expectation_gpv 0 \\<I>'\n             (\\<lambda>(r', s').\n                 expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                  (inline callee (c r') s'))\n             (rpv r'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                           expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv (callee s out))\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (case generat of\n                              Pure (x, s') \\<Rightarrow>\n                                \\<integral>\\<^sup>+ xx.\n               (case xx of Inl (x, xa) \\<Rightarrow> f x\n                | Inr (out', callee', rpv) \\<Rightarrow>\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r'))\n             \\<partial>measure_spmf (inline1 callee (c x) s')\n                              | IO out' rpv \\<Rightarrow>\n                                  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n              out'.\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(r', s').\n    expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n     (inline callee (c r') s'))\n(rpv r'))\n                           \\<partial>measure_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                           expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv (callee s out))\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (case generat of\n                              Pure (x, s') \\<Rightarrow>\n                                \\<integral>\\<^sup>+ xx.\n               (case xx of Inl (x, xa) \\<Rightarrow> f x\n                | Inr (out', callee', rpv) \\<Rightarrow>\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r'))\n             \\<partial>measure_spmf (inline1 callee (c x) s')\n                              | IO out' rpv \\<Rightarrow>\n                                  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n              out'.\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(r', s').\n    expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n     (inline callee (c r') s'))\n(rpv r'))\n                           \\<partial>measure_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "note calculation"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (case generat of\n                              Pure (x, s') \\<Rightarrow>\n                                \\<integral>\\<^sup>+ xx.\n               (case xx of Inl (x, xa) \\<Rightarrow> f x\n                | Inr (out', callee', rpv) \\<Rightarrow>\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r'))\n             \\<partial>measure_spmf (inline1 callee (c x) s')\n                              | IO out' rpv \\<Rightarrow>\n                                  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n              out'.\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(r', s').\n    expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n     (inline callee (c r') s'))\n(rpv r'))\n                           \\<partial>measure_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "}"], ["proof (state)\nthis:\n  IO ?out2 ?c2 \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> ?out2. expectation_gpv' (?c2 r))\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (case generat of\n                              Pure (x, s') \\<Rightarrow>\n                                \\<integral>\\<^sup>+ xx.\n               (case xx of Inl (x, xa) \\<Rightarrow> f x\n                | Inr (out', callee', rpv) \\<Rightarrow>\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r'))\n             \\<partial>measure_spmf (inline1 callee (?c2 x) s')\n                              | IO out' rpv \\<Rightarrow>\n                                  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n              out'.\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(r', s').\n    expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n     (inline callee (?c2 r') s'))\n(rpv r'))\n                           \\<partial>measure_spmf (the_gpv (callee s ?out2))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "then"], ["proof (chain)\npicking this:\n  IO ?out2 ?c2 \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> ?out2. expectation_gpv' (?c2 r))\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (case generat of\n                              Pure (x, s') \\<Rightarrow>\n                                \\<integral>\\<^sup>+ xx.\n               (case xx of Inl (x, xa) \\<Rightarrow> f x\n                | Inr (out', callee', rpv) \\<Rightarrow>\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r'))\n             \\<partial>measure_spmf (inline1 callee (?c2 x) s')\n                              | IO out' rpv \\<Rightarrow>\n                                  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n              out'.\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(r', s').\n    expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n     (inline callee (?c2 r') s'))\n(rpv r'))\n                           \\<partial>measure_spmf (the_gpv (callee s ?out2))", "show ?case"], ["proof (prove)\nusing this:\n  IO ?out2 ?c2 \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> ?out2. expectation_gpv' (?c2 r))\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (case generat of\n                              Pure (x, s') \\<Rightarrow>\n                                \\<integral>\\<^sup>+ xx.\n               (case xx of Inl (x, xa) \\<Rightarrow> f x\n                | Inr (out', callee', rpv) \\<Rightarrow>\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r'))\n             \\<partial>measure_spmf (inline1 callee (?c2 x) s')\n                              | IO out' rpv \\<Rightarrow>\n                                  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n              out'.\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(r', s').\n    expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n     (inline callee (?c2 r') s'))\n(rpv r'))\n                           \\<partial>measure_spmf (the_gpv (callee s ?out2))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    0 * ennreal (pmf (the_gpv gpv) None)\n    \\<le> expectation_gpv2 (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n           (inline callee gpv s)", "unfolding expectation_gpv2_def"], ["proof (prove)\nusing this:\n  IO ?out2 ?c2 \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> ?out2. expectation_gpv' (?c2 r))\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (case generat of\n                              Pure (x, s') \\<Rightarrow>\n                                \\<integral>\\<^sup>+ xx.\n               (case xx of Inl (x, xa) \\<Rightarrow> f x\n                | Inr (out', callee', rpv) \\<Rightarrow>\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r'))\n             \\<partial>measure_spmf (inline1 callee (?c2 x) s')\n                              | IO out' rpv \\<Rightarrow>\n                                  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n              out'.\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(r', s').\n    expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n     (inline callee (?c2 r') s'))\n(rpv r'))\n                           \\<partial>measure_spmf (the_gpv (callee s ?out2))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    0 * ennreal (pmf (the_gpv gpv) None)\n    \\<le> expectation_gpv 0 \\<I>'\n           (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n           (inline callee gpv s)", "apply(rewrite expectation_gpv.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    0 * ennreal (pmf (the_gpv gpv) None)\n    \\<le> \\<integral>\\<^sup>+ generat.\n                               (case generat of\n                                Pure (xa, s) \\<Rightarrow> f xa\n                                | IO out c \\<Rightarrow>\n                                    \\<Sqinter>r\\<in>responses_\\<I> \\<I>'\n               out.\n expectation_gpv 0 \\<I>' (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n  (c r))\n                             \\<partial>measure_spmf\n  (the_gpv (inline callee gpv s)) +\n          0 * ennreal (pmf (the_gpv (inline callee gpv s)) None)", "apply(rewrite inline_sel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    0 * ennreal (pmf (the_gpv gpv) None)\n    \\<le> \\<integral>\\<^sup>+ generat.\n                               (case generat of\n                                Pure (xa, s) \\<Rightarrow> f xa\n                                | IO out c \\<Rightarrow>\n                                    \\<Sqinter>r\\<in>responses_\\<I> \\<I>'\n               out.\n expectation_gpv 0 \\<I>' (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n  (c r))\n                             \\<partial>measure_spmf\n  (map_spmf\n    (\\<lambda>result.\n        case result of Inl xs \\<Rightarrow> Pure xs\n        | Inr (out, oracle, rpv) \\<Rightarrow>\n            IO out\n             (\\<lambda>input.\n                 oracle input \\<bind>\n                 (\\<lambda>(x, s'). inline callee (rpv x) s')))\n    (inline1 callee gpv s)) +\n          0 * ennreal (pmf (the_gpv (inline callee gpv s)) None)", "apply(simp add: o_def pmf_map_spmf_None)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. (case case x of Inl x \\<Rightarrow> Pure x\n | Inr (out, oracle, rpv) \\<Rightarrow>\n     IO out\n      (\\<lambda>input.\n          oracle input \\<bind>\n          (\\<lambda>(x, y). inline callee (rpv x) y)) of\n                                  Pure (xa, s) \\<Rightarrow> f xa\n                                  | IO out c \\<Rightarrow>\n\\<Sqinter>r\\<in>responses_\\<I> \\<I>' out.\n   expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (c r))\n                             \\<partial>measure_spmf (inline1 callee gpv s)", "apply(rewrite sum.case_distrib[where h=\"case_generat _ _\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. (case x of\n                                  Inl x \\<Rightarrow>\n                                    case Pure x of\n                                    Pure (xa, s) \\<Rightarrow> f xa\n                                    | IO out c \\<Rightarrow>\n  \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out.\n     expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (c r)\n                                  | Inr x \\<Rightarrow>\ncase case x of\n     (out, oracle, rpv) \\<Rightarrow>\n       IO out\n        (\\<lambda>input.\n            oracle input \\<bind>\n            (\\<lambda>(x, y). inline callee (rpv x) y)) of\nPure (xa, s) \\<Rightarrow> f xa\n| IO out c \\<Rightarrow>\n    \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out.\n       expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (c r))\n                             \\<partial>measure_spmf (inline1 callee gpv s)", "apply(simp cong del: sum.case_cong_weak)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. (case x of Inl (xa, s) \\<Rightarrow> f xa\n                                  | Inr x \\<Rightarrow>\ncase case x of\n     (out, oracle, rpv) \\<Rightarrow>\n       IO out\n        (\\<lambda>input.\n            oracle input \\<bind>\n            (\\<lambda>(x, y). inline callee (rpv x) y)) of\nPure (xa, s) \\<Rightarrow> f xa\n| IO out c \\<Rightarrow>\n    \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out.\n       expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (c r))\n                             \\<partial>measure_spmf (inline1 callee gpv s)", "apply(simp add: split_beta o_def cong del: sum.case_cong_weak)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. (case x of Inl x \\<Rightarrow> f (fst x)\n                                  | Inr x \\<Rightarrow>\n\\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n   expectation_gpv 0 \\<I>'\n    (\\<lambda>xa.\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (snd (snd x) (fst xa)) (snd xa)))\n    (fst (snd x) xa))\n                             \\<partial>measure_spmf (inline1 callee gpv s)", "apply(rewrite inline1.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. (case x of Inl x \\<Rightarrow> f (fst x)\n                                  | Inr x \\<Rightarrow>\n\\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n   expectation_gpv 0 \\<I>'\n    (\\<lambda>xa.\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (snd (snd x) (fst xa)) (snd xa)))\n    (fst (snd x) xa))\n                             \\<partial>measure_spmf\n  (the_gpv gpv \\<bind>\n   case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n    (\\<lambda>out rpv.\n        the_gpv (callee s out) \\<bind>\n        case_generat (\\<lambda>(x, y). inline1 callee (rpv x) y)\n         (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))", "apply(rewrite measure_spmf_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. (case x of Inl x \\<Rightarrow> f (fst x)\n                                  | Inr x \\<Rightarrow>\n\\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n   expectation_gpv 0 \\<I>'\n    (\\<lambda>xa.\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (snd (snd x) (fst xa)) (snd xa)))\n    (fst (snd x) xa))\n                             \\<partial>measure_spmf (the_gpv gpv) \\<bind>\n measure_spmf \\<circ>\n case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n  (\\<lambda>out rpv.\n      the_gpv (callee s out) \\<bind>\n      case_generat (\\<lambda>(x, y). inline1 callee (rpv x) y)\n       (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))", "apply(rewrite nn_integral_bind[where B=\"measure_spmf _\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    (\\<lambda>x.\n        case x of Inl x \\<Rightarrow> f (fst x)\n        | Inr x \\<Rightarrow>\n            \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n               expectation_gpv 0 \\<I>'\n                (\\<lambda>xa.\n                    expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (snd (snd x) (fst xa)) (snd xa)))\n                (fst (snd x) xa))\n    \\<in> borel_measurable (measure_spmf ?uu1339)\n 2. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    measure_spmf \\<circ>\n    case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n     (\\<lambda>out rpv.\n         the_gpv (callee s out) \\<bind>\n         case_generat (\\<lambda>(x, y). inline1 callee (rpv x) y)\n          (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))\n    \\<in> measure_spmf (the_gpv gpv) \\<rightarrow>\\<^sub>M\n          subprob_algebra (measure_spmf ?uu1339)\n 3. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ y.\n                (case y of Inl x \\<Rightarrow> f (fst x)\n                 | Inr x \\<Rightarrow>\n                     \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n                        expectation_gpv 0 \\<I>'\n                         (\\<lambda>xa.\n                             expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                              (inline callee (snd (snd x) (fst xa))\n                                (snd xa)))\n                         (fst (snd x) xa))\n              \\<partial>(measure_spmf \\<circ>\n                         case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n                          (\\<lambda>out rpv.\n                              the_gpv (callee s out) \\<bind>\n                              case_generat\n                               (\\<lambda>(x, y). inline1 callee (rpv x) y)\n                               (\\<lambda>out rpv'.\n                                   return_spmf (Inr (out, rpv', rpv)))))\n                         x\n                             \\<partial>measure_spmf (the_gpv gpv)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    measure_spmf \\<circ>\n    case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n     (\\<lambda>out rpv.\n         the_gpv (callee s out) \\<bind>\n         case_generat (\\<lambda>(x, y). inline1 callee (rpv x) y)\n          (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))\n    \\<in> measure_spmf (the_gpv gpv) \\<rightarrow>\\<^sub>M\n          subprob_algebra (measure_spmf ?uu1339)\n 2. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ y.\n                (case y of Inl x \\<Rightarrow> f (fst x)\n                 | Inr x \\<Rightarrow>\n                     \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n                        expectation_gpv 0 \\<I>'\n                         (\\<lambda>xa.\n                             expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                              (inline callee (snd (snd x) (fst xa))\n                                (snd xa)))\n                         (fst (snd x) xa))\n              \\<partial>(measure_spmf \\<circ>\n                         case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n                          (\\<lambda>out rpv.\n                              the_gpv (callee s out) \\<bind>\n                              case_generat\n                               (\\<lambda>(x, y). inline1 callee (rpv x) y)\n                               (\\<lambda>out rpv'.\n                                   return_spmf (Inr (out, rpv', rpv)))))\n                         x\n                             \\<partial>measure_spmf (the_gpv gpv)", "apply(simp add: space_subprob_algebra)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ y.\n                (case y of Inl x \\<Rightarrow> f (fst x)\n                 | Inr x \\<Rightarrow>\n                     \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n                        expectation_gpv 0 \\<I>'\n                         (\\<lambda>xa.\n                             expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                              (inline callee (snd (snd x) (fst xa))\n                                (snd xa)))\n                         (fst (snd x) xa))\n              \\<partial>(measure_spmf \\<circ>\n                         case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n                          (\\<lambda>out rpv.\n                              the_gpv (callee s out) \\<bind>\n                              case_generat\n                               (\\<lambda>(x, y). inline1 callee (rpv x) y)\n                               (\\<lambda>out rpv'.\n                                   return_spmf (Inr (out, rpv', rpv)))))\n                         x\n                             \\<partial>measure_spmf (the_gpv gpv)", "apply(rule nn_integral_mono_AE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    AE x in measure_spmf\n             (the_gpv\n               gpv). (case x of Pure x \\<Rightarrow> f x\n                      | IO out c \\<Rightarrow>\n                          \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                             expectation_gpv' (c r))\n                     \\<le> \\<integral>\\<^sup>+ y.\n          (case y of Inl x \\<Rightarrow> f (fst x)\n           | Inr x \\<Rightarrow>\n               \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n                  expectation_gpv 0 \\<I>'\n                   (\\<lambda>xa.\n                       expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                        (inline callee (snd (snd x) (fst xa)) (snd xa)))\n                   (fst (snd x) xa))\n        \\<partial>(measure_spmf \\<circ>\n                   case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n                    (\\<lambda>out rpv.\n                        the_gpv (callee s out) \\<bind>\n                        case_generat\n                         (\\<lambda>(x, y). inline1 callee (rpv x) y)\n                         (\\<lambda>out rpv'.\n                             return_spmf (Inr (out, rpv', rpv)))))\n                   x", "apply(clarsimp split!: generat.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> integral\\<^sup>N\n                          (measure_spmf (the_gpv (callee s out)))\n                          (case_generat\n                            (\\<lambda>(x, s').\n                                integral\\<^sup>N\n                                 (measure_spmf (inline1 callee (c x) s'))\n                                 (case_sum (\\<lambda>(x, xa). f x)\n                                   (\\<lambda>(out', callee', rpv).\n \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n    expectation_gpv 0 \\<I>'\n     (\\<lambda>(r, s').\n         expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n          (inline callee (rpv r) s'))\n     (callee' r'))))\n                            (\\<lambda>out' rpv.\n                                \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                   expectation_gpv 0 \\<I>'\n                                    (\\<lambda>(r', s').\n  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s'))\n                                    (rpv r')));\n        Pure x1 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> f x1\n                         \\<le> integral\\<^sup>N\n                                (measure_spmf (return_spmf (Inl (x1, s))))\n                                (case_sum (\\<lambda>x. f (fst x))\n                                  (\\<lambda>x.\n\\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n   expectation_gpv 0 \\<I>'\n    (\\<lambda>xa.\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (snd (snd x) (fst xa)) (snd xa)))\n    (fst (snd x) xa)))\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> integral\\<^sup>N\n                          (measure_spmf (the_gpv (callee s out)))\n                          (case_generat\n                            (\\<lambda>(x, s').\n                                integral\\<^sup>N\n                                 (measure_spmf (inline1 callee (c x) s'))\n                                 (case_sum (\\<lambda>(x, xa). f x)\n                                   (\\<lambda>(out', callee', rpv).\n \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n    expectation_gpv 0 \\<I>'\n     (\\<lambda>(r, s').\n         expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n          (inline callee (rpv r) s'))\n     (callee' r'))))\n                            (\\<lambda>out' rpv.\n                                \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                   expectation_gpv 0 \\<I>'\n                                    (\\<lambda>(r', s').\n  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s'))\n                                    (rpv r')));\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> integral\\<^sup>N\n                                (measure_spmf\n                                  (the_gpv (callee s x21) \\<bind>\n                                   case_generat\n                                    (\\<lambda>(x, y).\n  inline1 callee (x22 x) y)\n                                    (\\<lambda>out rpv'.\n  return_spmf (Inr (out, rpv', x22)))))\n                                (case_sum (\\<lambda>x. f (fst x))\n                                  (\\<lambda>x.\n\\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n   expectation_gpv 0 \\<I>'\n    (\\<lambda>xa.\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (snd (snd x) (fst xa)) (snd xa)))\n    (fst (snd x) xa)))", "apply(simp add: measure_spmf_return_spmf nn_integral_return)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> integral\\<^sup>N\n                          (measure_spmf (the_gpv (callee s out)))\n                          (case_generat\n                            (\\<lambda>(x, s').\n                                integral\\<^sup>N\n                                 (measure_spmf (inline1 callee (c x) s'))\n                                 (case_sum (\\<lambda>(x, xa). f x)\n                                   (\\<lambda>(out', callee', rpv).\n \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n    expectation_gpv 0 \\<I>'\n     (\\<lambda>(r, s').\n         expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n          (inline callee (rpv r) s'))\n     (callee' r'))))\n                            (\\<lambda>out' rpv.\n                                \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                   expectation_gpv 0 \\<I>'\n                                    (\\<lambda>(r', s').\n  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s'))\n                                    (rpv r')));\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> integral\\<^sup>N\n                                (measure_spmf\n                                  (the_gpv (callee s x21) \\<bind>\n                                   case_generat\n                                    (\\<lambda>(x, y).\n  inline1 callee (x22 x) y)\n                                    (\\<lambda>out rpv'.\n  return_spmf (Inr (out, rpv', x22)))))\n                                (case_sum (\\<lambda>x. f (fst x))\n                                  (\\<lambda>x.\n\\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n   expectation_gpv 0 \\<I>'\n    (\\<lambda>xa.\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (snd (snd x) (fst xa)) (snd xa)))\n    (fst (snd x) xa)))", "apply(rewrite measure_spmf_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> integral\\<^sup>N\n                          (measure_spmf (the_gpv (callee s out)))\n                          (case_generat\n                            (\\<lambda>(x, s').\n                                integral\\<^sup>N\n                                 (measure_spmf (inline1 callee (c x) s'))\n                                 (case_sum (\\<lambda>(x, xa). f x)\n                                   (\\<lambda>(out', callee', rpv).\n \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n    expectation_gpv 0 \\<I>'\n     (\\<lambda>(r, s').\n         expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n          (inline callee (rpv r) s'))\n     (callee' r'))))\n                            (\\<lambda>out' rpv.\n                                \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                   expectation_gpv 0 \\<I>'\n                                    (\\<lambda>(r', s').\n  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s'))\n                                    (rpv r')));\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> integral\\<^sup>N\n                                (measure_spmf\n                                  (the_gpv (callee s x21)) \\<bind>\n                                 measure_spmf \\<circ>\n                                 case_generat\n                                  (\\<lambda>(x, y).\ninline1 callee (x22 x) y)\n                                  (\\<lambda>out rpv'.\nreturn_spmf (Inr (out, rpv', x22))))\n                                (case_sum (\\<lambda>x. f (fst x))\n                                  (\\<lambda>x.\n\\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n   expectation_gpv 0 \\<I>'\n    (\\<lambda>xa.\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (snd (snd x) (fst xa)) (snd xa)))\n    (fst (snd x) xa)))", "apply(simp add: nn_integral_bind[where B=\"measure_spmf _\"] space_subprob_algebra)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> integral\\<^sup>N\n                          (measure_spmf (the_gpv (callee s out)))\n                          (case_generat\n                            (\\<lambda>(x, s').\n                                integral\\<^sup>N\n                                 (measure_spmf (inline1 callee (c x) s'))\n                                 (case_sum (\\<lambda>(x, xa). f x)\n                                   (\\<lambda>(out', callee', rpv).\n \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n    expectation_gpv 0 \\<I>'\n     (\\<lambda>(r, s').\n         expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n          (inline callee (rpv r) s'))\n     (callee' r'))))\n                            (\\<lambda>out' rpv.\n                                \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                   expectation_gpv 0 \\<I>'\n                                    (\\<lambda>(r', s').\n  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s'))\n                                    (rpv r')));\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> \\<integral>\\<^sup>+ x.\n              \\<integral>\\<^sup>+ y. (case y of\nInl x \\<Rightarrow> f (fst x)\n| Inr x \\<Rightarrow>\n    \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n       expectation_gpv 0 \\<I>'\n        (\\<lambda>xa.\n            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n             (inline callee (snd (snd x) (fst xa)) (snd xa)))\n        (fst (snd x) xa))\n                                 \\<partial>measure_spmf\n      (case x of Pure (xa, xb) \\<Rightarrow> inline1 callee (x22 xa) xb\n       | IO out rpv' \\<Rightarrow> return_spmf (Inr (out, rpv', x22)))\n            \\<partial>measure_spmf (the_gpv (callee s x21))", "apply(subst generat.case_distrib[where h=\"measure_spmf\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> integral\\<^sup>N\n                          (measure_spmf (the_gpv (callee s out)))\n                          (case_generat\n                            (\\<lambda>(x, s').\n                                integral\\<^sup>N\n                                 (measure_spmf (inline1 callee (c x) s'))\n                                 (case_sum (\\<lambda>(x, xa). f x)\n                                   (\\<lambda>(out', callee', rpv).\n \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n    expectation_gpv 0 \\<I>'\n     (\\<lambda>(r, s').\n         expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n          (inline callee (rpv r) s'))\n     (callee' r'))))\n                            (\\<lambda>out' rpv.\n                                \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                   expectation_gpv 0 \\<I>'\n                                    (\\<lambda>(r', s').\n  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s'))\n                                    (rpv r')));\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> \\<integral>\\<^sup>+ x.\n              integral\\<^sup>N\n               (case x of\n                Pure x \\<Rightarrow>\n                  measure_spmf\n                   (case x of\n                    (x, xa) \\<Rightarrow> inline1 callee (x22 x) xa)\n                | IO x1 x2 \\<Rightarrow>\n                    measure_spmf (return_spmf (Inr (x1, x2, x22))))\n               (case_sum (\\<lambda>x. f (fst x))\n                 (\\<lambda>x.\n                     \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n                        expectation_gpv 0 \\<I>'\n                         (\\<lambda>xa.\n                             expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                              (inline callee (snd (snd x) (fst xa))\n                                (snd xa)))\n                         (fst (snd x) xa)))\n            \\<partial>measure_spmf (the_gpv (callee s x21))", "apply(subst generat.case_distrib[where h=\"\\<lambda>x. nn_integral x _\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> integral\\<^sup>N\n                          (measure_spmf (the_gpv (callee s out)))\n                          (case_generat\n                            (\\<lambda>(x, s').\n                                integral\\<^sup>N\n                                 (measure_spmf (inline1 callee (c x) s'))\n                                 (case_sum (\\<lambda>(x, xa). f x)\n                                   (\\<lambda>(out', callee', rpv).\n \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n    expectation_gpv 0 \\<I>'\n     (\\<lambda>(r, s').\n         expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n          (inline callee (rpv r) s'))\n     (callee' r'))))\n                            (\\<lambda>out' rpv.\n                                \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                   expectation_gpv 0 \\<I>'\n                                    (\\<lambda>(r', s').\n  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s'))\n                                    (rpv r')));\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> integral\\<^sup>N\n                                (measure_spmf (the_gpv (callee s x21)))\n                                (case_generat\n                                  (\\<lambda>x.\nintegral\\<^sup>N\n (measure_spmf (case x of (x, xa) \\<Rightarrow> inline1 callee (x22 x) xa))\n (case_sum (\\<lambda>x. f (fst x))\n   (\\<lambda>x.\n       \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n          expectation_gpv 0 \\<I>'\n           (\\<lambda>xa.\n               expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                (inline callee (snd (snd x) (fst xa)) (snd xa)))\n           (fst (snd x) xa))))\n                                  (\\<lambda>x1 x2.\nintegral\\<^sup>N (measure_spmf (return_spmf (Inr (x1, x2, x22))))\n (case_sum (\\<lambda>x. f (fst x))\n   (\\<lambda>x.\n       \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n          expectation_gpv 0 \\<I>'\n           (\\<lambda>xa.\n               expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                (inline callee (snd (snd x) (fst xa)) (snd xa)))\n           (fst (snd x) xa)))))", "apply(simp add: measure_spmf_return_spmf nn_integral_return split_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> f x\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  0 * ennreal (pmf (the_gpv gpv) None)\n  \\<le> expectation_gpv2 (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n         (inline callee gpv s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma plossless_inline:\n  assumes lossless: \"plossless_gpv \\<I> gpv\"\n    and WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and callee: \"\\<And>s x. \\<lbrakk> I s; x \\<in> outs_\\<I> \\<I> \\<rbrakk> \\<Longrightarrow> plossless_gpv \\<I>' (callee s x)\"\n    and I: \"I s\"\n  shows \"plossless_gpv \\<I>' (inline callee gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_gpv \\<I>' (inline callee gpv s)", "unfolding pgen_lossless_gpv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s) = 1", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s) \\<le> 1\n 2. 1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "have WT': \"\\<I>' \\<turnstile>g inline callee gpv s \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>' \\<turnstile>g inline callee gpv s \\<surd>", "using WT I"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. \\<I>' \\<turnstile>g inline callee gpv s \\<surd>", "by(rule WT_gpv_inline_invar)"], ["proof (state)\nthis:\n  \\<I>' \\<turnstile>g inline callee gpv s \\<surd>\n\ngoal (2 subgoals):\n 1. expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s) \\<le> 1\n 2. 1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "from expectation_gpv_const_le[OF WT', of 0 1]"], ["proof (chain)\npicking this:\n  expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)\n  \\<le> max 1 0", "show \"expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s) \\<le> 1\""], ["proof (prove)\nusing this:\n  expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)\n  \\<le> max 1 0\n\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s) \\<le> 1", "by(simp add: max_def)"], ["proof (state)\nthis:\n  expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s) \\<le> 1\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "have \"1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv", "using lossless"], ["proof (prove)\nusing this:\n  plossless_gpv \\<I> gpv\n\ngoal (1 subgoal):\n 1. 1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv", "by(simp add: pgen_lossless_gpv_def)"], ["proof (state)\nthis:\n  1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "also"], ["proof (state)\nthis:\n  1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "have \"\\<dots> \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n    \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "by(rule expectation_gpv_le_inline[unfolded split_def]; rule callee I WT)"], ["proof (state)\nthis:\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n  \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "finally"], ["proof (chain)\npicking this:\n  1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "show \"1 \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "."], ["proof (state)\nthis:\n  1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma expectation_left_gpv [simp]:\n  \"expectation_gpv fail (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') f (left_gpv gpv) = expectation_gpv fail \\<I> f gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv fail (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') f (left_gpv gpv) =\n    expectation_gpv fail \\<I> f gpv", "proof(induction arbitrary: gpv rule: parallel_fixp_induct_1_1[OF complete_lattice_partial_function_definitions complete_lattice_partial_function_definitions expectation_gpv.mono expectation_gpv.mono expectation_gpv_def expectation_gpv_def, case_names adm bottom step])"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x. \\<forall>xa. fst x (left_gpv xa) = snd x xa)\n 2. \\<And>gpv. \\<Squnion> {} = \\<Squnion> {}\n 3. \\<And>fa g gpv.\n       (\\<And>gpv. fa (left_gpv gpv) = g gpv) \\<Longrightarrow>\n       integral\\<^sup>N (measure_spmf (the_gpv (left_gpv gpv)))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I>\n                               (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') out.\n                 fa (c r))) +\n       fail * ennreal (pmf (the_gpv (left_gpv gpv)) None) =\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. g (c r))) +\n       fail * ennreal (pmf (the_gpv gpv) None)", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x. \\<forall>xa. fst x (left_gpv xa) = snd x xa)\n 2. \\<And>gpv. \\<Squnion> {} = \\<Squnion> {}\n 3. \\<And>fa g gpv.\n       (\\<And>gpv. fa (left_gpv gpv) = g gpv) \\<Longrightarrow>\n       integral\\<^sup>N (measure_spmf (the_gpv (left_gpv gpv)))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I>\n                               (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') out.\n                 fa (c r))) +\n       fail * ennreal (pmf (the_gpv (left_gpv gpv)) None) =\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. g (c r))) +\n       fail * ennreal (pmf (the_gpv gpv) None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x. \\<forall>xa. fst x (left_gpv xa) = snd x xa)", "by simp"], ["proof (state)\nthis:\n  ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n   (rel_prod lfp.le_fun lfp.le_fun)\n   (\\<lambda>x. \\<forall>xa. fst x (left_gpv xa) = snd x xa)\n\ngoal (2 subgoals):\n 1. \\<And>gpv. \\<Squnion> {} = \\<Squnion> {}\n 2. \\<And>fa g gpv.\n       (\\<And>gpv. fa (left_gpv gpv) = g gpv) \\<Longrightarrow>\n       integral\\<^sup>N (measure_spmf (the_gpv (left_gpv gpv)))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I>\n                               (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') out.\n                 fa (c r))) +\n       fail * ennreal (pmf (the_gpv (left_gpv gpv)) None) =\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. g (c r))) +\n       fail * ennreal (pmf (the_gpv gpv) None)", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>gpv. \\<Squnion> {} = \\<Squnion> {}\n 2. \\<And>fa g gpv.\n       (\\<And>gpv. fa (left_gpv gpv) = g gpv) \\<Longrightarrow>\n       integral\\<^sup>N (measure_spmf (the_gpv (left_gpv gpv)))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I>\n                               (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') out.\n                 fa (c r))) +\n       fail * ennreal (pmf (the_gpv (left_gpv gpv)) None) =\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. g (c r))) +\n       fail * ennreal (pmf (the_gpv gpv) None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> {} = \\<Squnion> {}", "by simp"], ["proof (state)\nthis:\n  \\<Squnion> {} = \\<Squnion> {}\n\ngoal (1 subgoal):\n 1. \\<And>fa g gpv.\n       (\\<And>gpv. fa (left_gpv gpv) = g gpv) \\<Longrightarrow>\n       integral\\<^sup>N (measure_spmf (the_gpv (left_gpv gpv)))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I>\n                               (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') out.\n                 fa (c r))) +\n       fail * ennreal (pmf (the_gpv (left_gpv gpv)) None) =\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. g (c r))) +\n       fail * ennreal (pmf (the_gpv gpv) None)", "case (step expectation_gpv' expectation_gpv'')"], ["proof (state)\nthis:\n  expectation_gpv' (left_gpv ?gpv) = expectation_gpv'' ?gpv\n\ngoal (1 subgoal):\n 1. \\<And>fa g gpv.\n       (\\<And>gpv. fa (left_gpv gpv) = g gpv) \\<Longrightarrow>\n       integral\\<^sup>N (measure_spmf (the_gpv (left_gpv gpv)))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I>\n                               (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') out.\n                 fa (c r))) +\n       fail * ennreal (pmf (the_gpv (left_gpv gpv)) None) =\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. g (c r))) +\n       fail * ennreal (pmf (the_gpv gpv) None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I>\n         (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv (left_gpv gpv)) +\n    fail * ennreal (pmf (the_gpv (left_gpv gpv)) None) =\n    \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv'' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail * ennreal (pmf (the_gpv gpv) None)", "by (auto simp add: pmf_map_spmf_None o_def case_map_generat image_comp\n      split: generat.split intro!: nn_integral_cong_AE INF_cong step.IH)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> f x\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I>\n       (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') out.\n                               expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv (left_gpv gpv)) +\n  fail * ennreal (pmf (the_gpv (left_gpv gpv)) None) =\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> f x\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv'' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  fail * ennreal (pmf (the_gpv gpv) None)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma expectation_right_gpv [simp]:\n  \"expectation_gpv fail (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') f (right_gpv gpv) = expectation_gpv fail \\<I>' f gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv fail (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') f\n     (right_gpv gpv) =\n    expectation_gpv fail \\<I>' f gpv", "proof(induction arbitrary: gpv rule: parallel_fixp_induct_1_1[OF complete_lattice_partial_function_definitions complete_lattice_partial_function_definitions expectation_gpv.mono expectation_gpv.mono expectation_gpv_def expectation_gpv_def, case_names adm bottom step])"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x. \\<forall>xa. fst x (right_gpv xa) = snd x xa)\n 2. \\<And>gpv. \\<Squnion> {} = \\<Squnion> {}\n 3. \\<And>fa g gpv.\n       (\\<And>gpv. fa (right_gpv gpv) = g gpv) \\<Longrightarrow>\n       integral\\<^sup>N (measure_spmf (the_gpv (right_gpv gpv)))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I>\n                               (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') out.\n                 fa (c r))) +\n       fail * ennreal (pmf (the_gpv (right_gpv gpv)) None) =\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out. g (c r))) +\n       fail * ennreal (pmf (the_gpv gpv) None)", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x. \\<forall>xa. fst x (right_gpv xa) = snd x xa)\n 2. \\<And>gpv. \\<Squnion> {} = \\<Squnion> {}\n 3. \\<And>fa g gpv.\n       (\\<And>gpv. fa (right_gpv gpv) = g gpv) \\<Longrightarrow>\n       integral\\<^sup>N (measure_spmf (the_gpv (right_gpv gpv)))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I>\n                               (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') out.\n                 fa (c r))) +\n       fail * ennreal (pmf (the_gpv (right_gpv gpv)) None) =\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out. g (c r))) +\n       fail * ennreal (pmf (the_gpv gpv) None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x. \\<forall>xa. fst x (right_gpv xa) = snd x xa)", "by simp"], ["proof (state)\nthis:\n  ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n   (rel_prod lfp.le_fun lfp.le_fun)\n   (\\<lambda>x. \\<forall>xa. fst x (right_gpv xa) = snd x xa)\n\ngoal (2 subgoals):\n 1. \\<And>gpv. \\<Squnion> {} = \\<Squnion> {}\n 2. \\<And>fa g gpv.\n       (\\<And>gpv. fa (right_gpv gpv) = g gpv) \\<Longrightarrow>\n       integral\\<^sup>N (measure_spmf (the_gpv (right_gpv gpv)))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I>\n                               (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') out.\n                 fa (c r))) +\n       fail * ennreal (pmf (the_gpv (right_gpv gpv)) None) =\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out. g (c r))) +\n       fail * ennreal (pmf (the_gpv gpv) None)", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>gpv. \\<Squnion> {} = \\<Squnion> {}\n 2. \\<And>fa g gpv.\n       (\\<And>gpv. fa (right_gpv gpv) = g gpv) \\<Longrightarrow>\n       integral\\<^sup>N (measure_spmf (the_gpv (right_gpv gpv)))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I>\n                               (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') out.\n                 fa (c r))) +\n       fail * ennreal (pmf (the_gpv (right_gpv gpv)) None) =\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out. g (c r))) +\n       fail * ennreal (pmf (the_gpv gpv) None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> {} = \\<Squnion> {}", "by simp"], ["proof (state)\nthis:\n  \\<Squnion> {} = \\<Squnion> {}\n\ngoal (1 subgoal):\n 1. \\<And>fa g gpv.\n       (\\<And>gpv. fa (right_gpv gpv) = g gpv) \\<Longrightarrow>\n       integral\\<^sup>N (measure_spmf (the_gpv (right_gpv gpv)))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I>\n                               (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') out.\n                 fa (c r))) +\n       fail * ennreal (pmf (the_gpv (right_gpv gpv)) None) =\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out. g (c r))) +\n       fail * ennreal (pmf (the_gpv gpv) None)", "case (step expectation_gpv' expectation_gpv'')"], ["proof (state)\nthis:\n  expectation_gpv' (right_gpv ?gpv) = expectation_gpv'' ?gpv\n\ngoal (1 subgoal):\n 1. \\<And>fa g gpv.\n       (\\<And>gpv. fa (right_gpv gpv) = g gpv) \\<Longrightarrow>\n       integral\\<^sup>N (measure_spmf (the_gpv (right_gpv gpv)))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I>\n                               (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') out.\n                 fa (c r))) +\n       fail * ennreal (pmf (the_gpv (right_gpv gpv)) None) =\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out. g (c r))) +\n       fail * ennreal (pmf (the_gpv gpv) None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I>\n         (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv (right_gpv gpv)) +\n    fail * ennreal (pmf (the_gpv (right_gpv gpv)) None) =\n    \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out.\n                                 expectation_gpv'' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail * ennreal (pmf (the_gpv gpv) None)", "by (auto simp add: pmf_map_spmf_None o_def case_map_generat image_comp\n      split: generat.split intro!: nn_integral_cong_AE INF_cong step.IH)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> f x\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I>\n       (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') out.\n                               expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv (right_gpv gpv)) +\n  fail * ennreal (pmf (the_gpv (right_gpv gpv)) None) =\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> f x\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out.\n                               expectation_gpv'' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  fail * ennreal (pmf (the_gpv gpv) None)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pgen_lossless_left_gpv [simp]: \"pgen_lossless_gpv fail (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') (left_gpv gpv) = pgen_lossless_gpv fail \\<I> gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pgen_lossless_gpv fail (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') (left_gpv gpv) =\n    pgen_lossless_gpv fail \\<I> gpv", "by(simp add: pgen_lossless_gpv_def)"], ["", "lemma pgen_lossless_right_gpv [simp]: \"pgen_lossless_gpv fail (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') (right_gpv gpv) = pgen_lossless_gpv fail \\<I>' gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pgen_lossless_gpv fail (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n     (right_gpv gpv) =\n    pgen_lossless_gpv fail \\<I>' gpv", "by(simp add: pgen_lossless_gpv_def)"], ["", "lemma (in raw_converter_invariant) expectation_gpv_le_inline_invariant:\n  defines \"expectation_gpv2 \\<equiv> expectation_gpv 0 \\<I>'\"\n  assumes callee: \"\\<And>s x. \\<lbrakk> x \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> plossless_gpv \\<I>' (callee s x)\"\n    and WT_gpv: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and I: \"I s\"\n  shows \"expectation_gpv 0 \\<I> f gpv \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I> f gpv\n    \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee gpv s)", "using WT_gpv I"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I> f gpv\n    \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee gpv s)", "proof(induction arbitrary: gpv s rule: expectation_gpv_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            (\\<forall>xa.\n                I xa \\<longrightarrow>\n                a x\n                \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                       (inline callee x xa)))\n 2. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                  (inline callee gpv s)\n 3. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            (\\<forall>xa.\n                I xa \\<longrightarrow>\n                a x\n                \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                       (inline callee x xa)))\n 2. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                  (inline callee gpv s)\n 3. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            (\\<forall>xa.\n                I xa \\<longrightarrow>\n                a x\n                \\<le> expectation_gpv2\n                       (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n                       (inline callee x xa)))", "by simp"], ["proof (state)\nthis:\n  lfp.admissible\n   (\\<lambda>a.\n       \\<forall>x.\n          \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n          (\\<forall>xa.\n              I xa \\<longrightarrow>\n              a x\n              \\<le> expectation_gpv2\n                     (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n                     (inline callee x xa)))\n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                  (inline callee gpv s)\n 2. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "case bottom"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                  (inline callee gpv s)\n 2. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> expectation_gpv2\n             (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n             (inline callee gpv s)", "by simp"], ["proof (state)\nthis:\n  0 \\<le> expectation_gpv2 (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n           (inline callee gpv s)\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "case (step expectation_gpv')"], ["proof (state)\nthis:\n  expectation_gpv' ?gpv \\<le> expectation_gpv 0 \\<I> f ?gpv\n  \\<lbrakk>\\<I> \\<turnstile>g ?gpv \\<surd>; I ?s\\<rbrakk>\n  \\<Longrightarrow> expectation_gpv' ?gpv\n                    \\<le> expectation_gpv2\n                           (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n                           (inline callee ?gpv ?s)\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "{"], ["proof (state)\nthis:\n  expectation_gpv' ?gpv \\<le> expectation_gpv 0 \\<I> f ?gpv\n  \\<lbrakk>\\<I> \\<turnstile>g ?gpv \\<surd>; I ?s\\<rbrakk>\n  \\<Longrightarrow> expectation_gpv' ?gpv\n                    \\<le> expectation_gpv2\n                           (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n                           (inline callee ?gpv ?s)\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "fix out c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "assume IO: \"IO out c \\<in> set_spmf (the_gpv gpv)\""], ["proof (state)\nthis:\n  IO out c \\<in> set_spmf (the_gpv gpv)\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "with step.prems(1)"], ["proof (chain)\npicking this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  IO out c \\<in> set_spmf (the_gpv gpv)", "have out: \"out \\<in> outs_\\<I> \\<I>\""], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  IO out c \\<in> set_spmf (the_gpv gpv)\n\ngoal (1 subgoal):\n 1. out \\<in> outs_\\<I> \\<I>", "by(rule WT_gpv_OutD)"], ["proof (state)\nthis:\n  out \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "have \"(INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) = \\<integral>\\<^sup>+ generat. (INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) \\<partial>measure_spmf (the_gpv (callee s out))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) =\n    \\<integral>\\<^sup>+ generat.\n                         (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                             expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv (callee s out))", "using WT_callee[OF out, of s] callee[OF out, of s] step.prems(2)"], ["proof (prove)\nusing this:\n  I s \\<Longrightarrow> \\<I>' \\<turnstile>g callee s out \\<surd>\n  I s \\<Longrightarrow> plossless_gpv \\<I>' (callee s out)\n  I s\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) =\n    \\<integral>\\<^sup>+ generat.\n                         (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                             expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv (callee s out))", "by(clarsimp simp add: measure_spmf.emeasure_eq_measure plossless_iff_colossless_pfinite colossless_gpv_lossless_spmfD lossless_weight_spmfD)"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) =\n  \\<integral>\\<^sup>+ generat.\n                       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                           expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) =\n  \\<integral>\\<^sup>+ generat.\n                       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                           expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "have \"\\<dots> \\<le> \\<integral>\\<^sup>+ generat. (case generat of Pure (x, s') \\<Rightarrow>\n            \\<integral>\\<^sup>+ xx. (case xx of Inl (x, _) \\<Rightarrow> f x \n               | Inr (out', callee', rpv) \\<Rightarrow> INF r'\\<in>responses_\\<I> \\<I>' out'. expectation_gpv 0 \\<I>' (\\<lambda>(r, s'). expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv r) s')) (callee' r'))\n            \\<partial>measure_spmf (inline1 callee (c x) s')\n         | IO out' rpv \\<Rightarrow> INF r'\\<in>responses_\\<I> \\<I>' out'. expectation_gpv 0 \\<I>' (\\<lambda>(r', s'). expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s')) (rpv r'))\n       \\<partial>measure_spmf (the_gpv (callee s out))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                             expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv (callee s out))\n    \\<le> \\<integral>\\<^sup>+ generat.\n                               (case generat of\n                                Pure (x, s') \\<Rightarrow>\n                                  \\<integral>\\<^sup>+ xx.\n                 (case xx of Inl (x, xa) \\<Rightarrow> f x\n                  | Inr (out', callee', rpv) \\<Rightarrow>\n                      \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                         expectation_gpv 0 \\<I>'\n                          (\\<lambda>(r, s').\n                              expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                               (inline callee (rpv r) s'))\n                          (callee' r'))\n               \\<partial>measure_spmf (inline1 callee (c x) s')\n                                | IO out' rpv \\<Rightarrow>\n                                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n                out'.\n expectation_gpv 0 \\<I>'\n  (\\<lambda>(r', s').\n      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c r') s'))\n  (rpv r'))\n                             \\<partial>measure_spmf (the_gpv (callee s out))", "proof(rule nn_integral_mono_AE; simp split!: generat.split)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "fix x s'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "assume Pure: \"Pure (x, s') \\<in> set_spmf (the_gpv (callee s out))\""], ["proof (state)\nthis:\n  Pure (x, s') \\<in> set_spmf (the_gpv (callee s out))\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "hence \"(x, s') \\<in> results_gpv \\<I>' (callee s out)\""], ["proof (prove)\nusing this:\n  Pure (x, s') \\<in> set_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. (x, s') \\<in> results_gpv \\<I>' (callee s out)", "by(rule results_gpv.Pure)"], ["proof (state)\nthis:\n  (x, s') \\<in> results_gpv \\<I>' (callee s out)\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "with results_callee[OF out step.prems(2)]"], ["proof (chain)\npicking this:\n  results_gpv \\<I>' (callee s out)\n  \\<subseteq> responses_\\<I> \\<I> out \\<times> {s. I s}\n  (x, s') \\<in> results_gpv \\<I>' (callee s out)", "have x: \"x \\<in> responses_\\<I> \\<I> out\" and s': \"I s'\""], ["proof (prove)\nusing this:\n  results_gpv \\<I>' (callee s out)\n  \\<subseteq> responses_\\<I> \\<I> out \\<times> {s. I s}\n  (x, s') \\<in> results_gpv \\<I>' (callee s out)\n\ngoal (1 subgoal):\n 1. x \\<in> responses_\\<I> \\<I> out &&& I s'", "by blast+"], ["proof (state)\nthis:\n  x \\<in> responses_\\<I> \\<I> out\n  I s'\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "from this(1)"], ["proof (chain)\npicking this:\n  x \\<in> responses_\\<I> \\<I> out", "have \"(INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) \\<le> expectation_gpv' (c x)\""], ["proof (prove)\nusing this:\n  x \\<in> responses_\\<I> \\<I> out\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> expectation_gpv' (c x)", "by(rule INF_lower)"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> expectation_gpv' (c x)\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> expectation_gpv' (c x)\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "have \"\\<dots> \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x) s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv' (c x)\n    \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x) s')", "by(rule step.IH)(rule WT_gpv_ContD[OF step.prems(1) IO x] step.prems s'|assumption)+"], ["proof (state)\nthis:\n  expectation_gpv' (c x)\n  \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x) s')\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "also"], ["proof (state)\nthis:\n  expectation_gpv' (c x)\n  \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x) s')\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "have \"\\<dots> = \\<integral>\\<^sup>+ xx. (case xx of Inl (x, _) \\<Rightarrow> f x \n               | Inr (out', callee', rpv) \\<Rightarrow> INF r'\\<in>responses_\\<I> \\<I>' out'. expectation_gpv 0 \\<I>' (\\<lambda>(r, s'). expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv r) s')) (callee' r'))\n            \\<partial>measure_spmf (inline1 callee (c x) s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x) s') =\n    \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                             | Inr (out', callee', rpv) \\<Rightarrow>\n                                 \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                    expectation_gpv 0 \\<I>'\n                                     (\\<lambda>(r, s').\n   expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n    (inline callee (rpv r) s'))\n                                     (callee' r'))\n                       \\<partial>measure_spmf (inline1 callee (c x) s')", "unfolding expectation_gpv2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n     (inline callee (c x) s') =\n    \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                             | Inr (out', callee', rpv) \\<Rightarrow>\n                                 \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                    expectation_gpv 0 \\<I>'\n                                     (\\<lambda>(r, s').\n   expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n    (inline callee (rpv r) s'))\n                                     (callee' r'))\n                       \\<partial>measure_spmf (inline1 callee (c x) s')", "by(subst expectation_gpv.simps)(auto simp add: inline_sel split_def o_def intro!: nn_integral_cong split: generat.split sum.split)"], ["proof (state)\nthis:\n  expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x) s') =\n  \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                           | Inr (out', callee', rpv) \\<Rightarrow>\n                               \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                  expectation_gpv 0 \\<I>'\n                                   (\\<lambda>(r, s').\n expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                   (callee' r'))\n                     \\<partial>measure_spmf (inline1 callee (c x) s')\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> integral\\<^sup>N (measure_spmf (inline1 callee (c a) b))\n              (case_sum (\\<lambda>(x, xa). f x)\n                (\\<lambda>(out', callee', rpv).\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r')))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                                 | Inr (out', callee', rpv) \\<Rightarrow>\n                                     \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n                 out'.\n  expectation_gpv 0 \\<I>'\n   (\\<lambda>(r, s').\n       expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n        (inline callee (rpv r) s'))\n   (callee' r'))\n                           \\<partial>measure_spmf (inline1 callee (c x) s')", "show \"(INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                                 | Inr (out', callee', rpv) \\<Rightarrow>\n                                     \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n                 out'.\n  expectation_gpv 0 \\<I>'\n   (\\<lambda>(r, s').\n       expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n        (inline callee (rpv r) s'))\n   (callee' r'))\n                           \\<partial>measure_spmf (inline1 callee (c x) s')\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                                   | Inr (out', callee', rpv) \\<Rightarrow>\n \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n    expectation_gpv 0 \\<I>'\n     (\\<lambda>(r, s').\n         expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n          (inline callee (rpv r) s'))\n     (callee' r'))\n                             \\<partial>measure_spmf\n  (inline1 callee (c x) s')", "."], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                                 | Inr (out', callee', rpv) \\<Rightarrow>\n                                     \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n                 out'.\n  expectation_gpv 0 \\<I>'\n   (\\<lambda>(r, s').\n       expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n        (inline callee (rpv r) s'))\n   (callee' r'))\n                           \\<partial>measure_spmf (inline1 callee (c x) s')\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "fix out' rpv"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "assume IO': \"IO out' rpv \\<in> set_spmf (the_gpv (callee s out))\""], ["proof (state)\nthis:\n  IO out' rpv \\<in> set_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "have \"(INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) \\<le> (INF (r, s')\\<in>(\\<Union>r'\\<in>responses_\\<I> \\<I>' out'. results_gpv \\<I>' (rpv r')). expectation_gpv' (c r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> (\\<Sqinter>(r,\n              s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                         results_gpv \\<I>' (rpv r').\n              expectation_gpv' (c r))", "using IO' results_callee[OF out step.prems(2)]"], ["proof (prove)\nusing this:\n  IO out' rpv \\<in> set_spmf (the_gpv (callee s out))\n  results_gpv \\<I>' (callee s out)\n  \\<subseteq> responses_\\<I> \\<I> out \\<times> {s. I s}\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> (\\<Sqinter>(r,\n              s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                         results_gpv \\<I>' (rpv r').\n              expectation_gpv' (c r))", "by(intro INF_mono)(auto intro: results_gpv.IO)"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>(r,\n            s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                       results_gpv \\<I>' (rpv r').\n            expectation_gpv' (c r))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>(r,\n            s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                       results_gpv \\<I>' (rpv r').\n            expectation_gpv' (c r))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "have \"\\<dots> = (INF r'\\<in>responses_\\<I> \\<I>' out'. INF (r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv' (c r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>(r,\n        s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                   results_gpv \\<I>' (rpv r').\n        expectation_gpv' (c r)) =\n    (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n        \\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n           expectation_gpv' (c r))", "by(simp add: INF_UNION)"], ["proof (state)\nthis:\n  (\\<Sqinter>(r,\n      s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                 results_gpv \\<I>' (rpv r').\n      expectation_gpv' (c r)) =\n  (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n      \\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n         expectation_gpv' (c r))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>(r,\n      s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                 results_gpv \\<I>' (rpv r').\n      expectation_gpv' (c r)) =\n  (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n      \\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n         expectation_gpv' (c r))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "have \"\\<dots> \\<le> (INF r'\\<in>responses_\\<I> \\<I>' out'. expectation_gpv 0 \\<I>' (\\<lambda>(r', s'). expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s')) (rpv r'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n        \\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n           expectation_gpv' (c r))\n    \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n              expectation_gpv 0 \\<I>'\n               (\\<lambda>(r', s').\n                   expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                    (inline callee (c r') s'))\n               (rpv r'))", "proof(rule INF_mono, rule bexI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv (?r'2 m)).\n           expectation_gpv' (c r))\n       \\<le> expectation_gpv 0 \\<I>'\n              (\\<lambda>(r', s').\n                  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c r') s'))\n              (rpv m)\n 2. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       ?r'2 m \\<in> responses_\\<I> \\<I>' out'", "fix r'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv (?r'2 m)).\n           expectation_gpv' (c r))\n       \\<le> expectation_gpv 0 \\<I>'\n              (\\<lambda>(r', s').\n                  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c r') s'))\n              (rpv m)\n 2. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       ?r'2 m \\<in> responses_\\<I> \\<I>' out'", "assume r': \"r' \\<in> responses_\\<I> \\<I>' out'\""], ["proof (state)\nthis:\n  r' \\<in> responses_\\<I> \\<I>' out'\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv (?r'2 m)).\n           expectation_gpv' (c r))\n       \\<le> expectation_gpv 0 \\<I>'\n              (\\<lambda>(r', s').\n                  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c r') s'))\n              (rpv m)\n 2. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       ?r'2 m \\<in> responses_\\<I> \\<I>' out'", "have \"(INF (r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv' (c r)) \\<le> (INF (r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c r) s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n        expectation_gpv' (c r))\n    \\<le> (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n              expectation_gpv2 (\\<lambda>(x, s). f x)\n               (inline callee (c r) s'))", "using IO IO' step.prems out results_callee[OF out, of s] r'"], ["proof (prove)\nusing this:\n  IO out c \\<in> set_spmf (the_gpv gpv)\n  IO out' rpv \\<in> set_spmf (the_gpv (callee s out))\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n  out \\<in> outs_\\<I> \\<I>\n  I s \\<Longrightarrow>\n  results_gpv \\<I>' (callee s out)\n  \\<subseteq> responses_\\<I> \\<I> out \\<times> {s. I s}\n  r' \\<in> responses_\\<I> \\<I>' out'\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n        expectation_gpv' (c r))\n    \\<le> (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n              expectation_gpv2 (\\<lambda>(x, s). f x)\n               (inline callee (c r) s'))", "by(auto intro!: INF_mono rev_bexI step.IH dest: WT_gpv_ContD intro: results_gpv.IO)"], ["proof (state)\nthis:\n  (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n            expectation_gpv2 (\\<lambda>(x, s). f x)\n             (inline callee (c r) s'))\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv (?r'2 m)).\n           expectation_gpv' (c r))\n       \\<le> expectation_gpv 0 \\<I>'\n              (\\<lambda>(r', s').\n                  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c r') s'))\n              (rpv m)\n 2. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       ?r'2 m \\<in> responses_\\<I> \\<I>' out'", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n            expectation_gpv2 (\\<lambda>(x, s). f x)\n             (inline callee (c r) s'))\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv (?r'2 m)).\n           expectation_gpv' (c r))\n       \\<le> expectation_gpv 0 \\<I>'\n              (\\<lambda>(r', s').\n                  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c r') s'))\n              (rpv m)\n 2. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       ?r'2 m \\<in> responses_\\<I> \\<I>' out'", "have \"\\<dots> \\<le>  expectation_gpv 0 \\<I>' (\\<lambda>(r', s'). expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s')) (rpv r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n        expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c r) s'))\n    \\<le> expectation_gpv 0 \\<I>'\n           (\\<lambda>(r', s').\n               expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                (inline callee (c r') s'))\n           (rpv r')", "unfolding expectation_gpv2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (c r) s'))\n    \\<le> expectation_gpv 0 \\<I>'\n           (\\<lambda>(r', s').\n               expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                (inline callee (c r') s'))\n           (rpv r')", "using plossless_gpv_ContD[OF callee, OF out step.prems(2) IO' r'] WT_callee[OF out step.prems(2)] IO' r'"], ["proof (prove)\nusing this:\n  \\<I>' \\<turnstile>g callee s out \\<surd> \\<Longrightarrow>\n  plossless_gpv \\<I>' (rpv r')\n  \\<I>' \\<turnstile>g callee s out \\<surd>\n  IO out' rpv \\<in> set_spmf (the_gpv (callee s out))\n  r' \\<in> responses_\\<I> \\<I>' out'\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (c r) s'))\n    \\<le> expectation_gpv 0 \\<I>'\n           (\\<lambda>(r', s').\n               expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                (inline callee (c r') s'))\n           (rpv r')", "by(intro plossless_INF_le_expectation_gpv)(auto intro: WT_gpv_ContD)"], ["proof (state)\nthis:\n  (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n      expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c r) s'))\n  \\<le> expectation_gpv 0 \\<I>'\n         (\\<lambda>(r', s').\n             expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (c r') s'))\n         (rpv r')\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv (?r'2 m)).\n           expectation_gpv' (c r))\n       \\<le> expectation_gpv 0 \\<I>'\n              (\\<lambda>(r', s').\n                  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c r') s'))\n              (rpv m)\n 2. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       ?r'2 m \\<in> responses_\\<I> \\<I>' out'", "finally"], ["proof (chain)\npicking this:\n  (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv' (c r))\n  \\<le> expectation_gpv 0 \\<I>'\n         (\\<lambda>(r', s').\n             expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (c r') s'))\n         (rpv r')", "show \"(INF (r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv' (c r)) \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv' (c r))\n  \\<le> expectation_gpv 0 \\<I>'\n         (\\<lambda>(r', s').\n             expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (c r') s'))\n         (rpv r')\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n        expectation_gpv' (c r))\n    \\<le> expectation_gpv 0 \\<I>'\n           (\\<lambda>(r', s').\n               expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                (inline callee (c r') s'))\n           (rpv r')", "."], ["proof (state)\nthis:\n  (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r'). expectation_gpv' (c r))\n  \\<le> expectation_gpv 0 \\<I>'\n         (\\<lambda>(r', s').\n             expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (c r') s'))\n         (rpv r')\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       m \\<in> responses_\\<I> \\<I>' out'", "qed"], ["proof (state)\nthis:\n  (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n      \\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (rpv r').\n         expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n            expectation_gpv 0 \\<I>'\n             (\\<lambda>(r', s').\n                 expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                  (inline callee (c r') s'))\n             (rpv r'))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' x21.\n                 expectation_gpv 0 \\<I>'\n                  (\\<lambda>(r', s').\n                      expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (c r') s'))\n                  (x22 r'))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n            expectation_gpv 0 \\<I>'\n             (\\<lambda>(r', s').\n                 expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                  (inline callee (c r') s'))\n             (rpv r'))", "show \"(INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n            expectation_gpv 0 \\<I>'\n             (\\<lambda>(r', s').\n                 expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                  (inline callee (c r') s'))\n             (rpv r'))\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n              expectation_gpv 0 \\<I>'\n               (\\<lambda>(r', s').\n                   expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                    (inline callee (c r') s'))\n               (rpv r'))", "."], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n            expectation_gpv 0 \\<I>'\n             (\\<lambda>(r', s').\n                 expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                  (inline callee (c r') s'))\n             (rpv r'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                           expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv (callee s out))\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (case generat of\n                              Pure (x, s') \\<Rightarrow>\n                                \\<integral>\\<^sup>+ xx.\n               (case xx of Inl (x, xa) \\<Rightarrow> f x\n                | Inr (out', callee', rpv) \\<Rightarrow>\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r'))\n             \\<partial>measure_spmf (inline1 callee (c x) s')\n                              | IO out' rpv \\<Rightarrow>\n                                  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n              out'.\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(r', s').\n    expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n     (inline callee (c r') s'))\n(rpv r'))\n                           \\<partial>measure_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                           expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv (callee s out))\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (case generat of\n                              Pure (x, s') \\<Rightarrow>\n                                \\<integral>\\<^sup>+ xx.\n               (case xx of Inl (x, xa) \\<Rightarrow> f x\n                | Inr (out', callee', rpv) \\<Rightarrow>\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r'))\n             \\<partial>measure_spmf (inline1 callee (c x) s')\n                              | IO out' rpv \\<Rightarrow>\n                                  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n              out'.\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(r', s').\n    expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n     (inline callee (c r') s'))\n(rpv r'))\n                           \\<partial>measure_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "note calculation"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (case generat of\n                              Pure (x, s') \\<Rightarrow>\n                                \\<integral>\\<^sup>+ xx.\n               (case xx of Inl (x, xa) \\<Rightarrow> f x\n                | Inr (out', callee', rpv) \\<Rightarrow>\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r'))\n             \\<partial>measure_spmf (inline1 callee (c x) s')\n                              | IO out' rpv \\<Rightarrow>\n                                  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n              out'.\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(r', s').\n    expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n     (inline callee (c r') s'))\n(rpv r'))\n                           \\<partial>measure_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "}"], ["proof (state)\nthis:\n  IO ?out2 ?c2 \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> ?out2. expectation_gpv' (?c2 r))\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (case generat of\n                              Pure (x, s') \\<Rightarrow>\n                                \\<integral>\\<^sup>+ xx.\n               (case xx of Inl (x, xa) \\<Rightarrow> f x\n                | Inr (out', callee', rpv) \\<Rightarrow>\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r'))\n             \\<partial>measure_spmf (inline1 callee (?c2 x) s')\n                              | IO out' rpv \\<Rightarrow>\n                                  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n              out'.\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(r', s').\n    expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n     (inline callee (?c2 r') s'))\n(rpv r'))\n                           \\<partial>measure_spmf (the_gpv (callee s ?out2))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 0 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "then"], ["proof (chain)\npicking this:\n  IO ?out2 ?c2 \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> ?out2. expectation_gpv' (?c2 r))\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (case generat of\n                              Pure (x, s') \\<Rightarrow>\n                                \\<integral>\\<^sup>+ xx.\n               (case xx of Inl (x, xa) \\<Rightarrow> f x\n                | Inr (out', callee', rpv) \\<Rightarrow>\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r'))\n             \\<partial>measure_spmf (inline1 callee (?c2 x) s')\n                              | IO out' rpv \\<Rightarrow>\n                                  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n              out'.\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(r', s').\n    expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n     (inline callee (?c2 r') s'))\n(rpv r'))\n                           \\<partial>measure_spmf (the_gpv (callee s ?out2))", "show ?case"], ["proof (prove)\nusing this:\n  IO ?out2 ?c2 \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> ?out2. expectation_gpv' (?c2 r))\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (case generat of\n                              Pure (x, s') \\<Rightarrow>\n                                \\<integral>\\<^sup>+ xx.\n               (case xx of Inl (x, xa) \\<Rightarrow> f x\n                | Inr (out', callee', rpv) \\<Rightarrow>\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r'))\n             \\<partial>measure_spmf (inline1 callee (?c2 x) s')\n                              | IO out' rpv \\<Rightarrow>\n                                  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n              out'.\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(r', s').\n    expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n     (inline callee (?c2 r') s'))\n(rpv r'))\n                           \\<partial>measure_spmf (the_gpv (callee s ?out2))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    0 * ennreal (pmf (the_gpv gpv) None)\n    \\<le> expectation_gpv2 (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n           (inline callee gpv s)", "unfolding expectation_gpv2_def"], ["proof (prove)\nusing this:\n  IO ?out2 ?c2 \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> ?out2. expectation_gpv' (?c2 r))\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (case generat of\n                              Pure (x, s') \\<Rightarrow>\n                                \\<integral>\\<^sup>+ xx.\n               (case xx of Inl (x, xa) \\<Rightarrow> f x\n                | Inr (out', callee', rpv) \\<Rightarrow>\n                    \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 0 \\<I>'\n                        (\\<lambda>(r, s').\n                            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv r) s'))\n                        (callee' r'))\n             \\<partial>measure_spmf (inline1 callee (?c2 x) s')\n                              | IO out' rpv \\<Rightarrow>\n                                  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>'\n              out'.\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(r', s').\n    expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n     (inline callee (?c2 r') s'))\n(rpv r'))\n                           \\<partial>measure_spmf (the_gpv (callee s ?out2))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    0 * ennreal (pmf (the_gpv gpv) None)\n    \\<le> expectation_gpv 0 \\<I>'\n           (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n           (inline callee gpv s)", "apply(rewrite expectation_gpv.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    0 * ennreal (pmf (the_gpv gpv) None)\n    \\<le> \\<integral>\\<^sup>+ generat.\n                               (case generat of\n                                Pure (xa, s) \\<Rightarrow> f xa\n                                | IO out c \\<Rightarrow>\n                                    \\<Sqinter>r\\<in>responses_\\<I> \\<I>'\n               out.\n expectation_gpv 0 \\<I>' (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n  (c r))\n                             \\<partial>measure_spmf\n  (the_gpv (inline callee gpv s)) +\n          0 * ennreal (pmf (the_gpv (inline callee gpv s)) None)", "apply(rewrite inline_sel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    0 * ennreal (pmf (the_gpv gpv) None)\n    \\<le> \\<integral>\\<^sup>+ generat.\n                               (case generat of\n                                Pure (xa, s) \\<Rightarrow> f xa\n                                | IO out c \\<Rightarrow>\n                                    \\<Sqinter>r\\<in>responses_\\<I> \\<I>'\n               out.\n expectation_gpv 0 \\<I>' (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n  (c r))\n                             \\<partial>measure_spmf\n  (map_spmf\n    (\\<lambda>result.\n        case result of Inl xs \\<Rightarrow> Pure xs\n        | Inr (out, oracle, rpv) \\<Rightarrow>\n            IO out\n             (\\<lambda>input.\n                 oracle input \\<bind>\n                 (\\<lambda>(x, s'). inline callee (rpv x) s')))\n    (inline1 callee gpv s)) +\n          0 * ennreal (pmf (the_gpv (inline callee gpv s)) None)", "apply(simp add: o_def pmf_map_spmf_None)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. (case case x of Inl x \\<Rightarrow> Pure x\n | Inr (out, oracle, rpv) \\<Rightarrow>\n     IO out\n      (\\<lambda>input.\n          oracle input \\<bind>\n          (\\<lambda>(x, y). inline callee (rpv x) y)) of\n                                  Pure (xa, s) \\<Rightarrow> f xa\n                                  | IO out c \\<Rightarrow>\n\\<Sqinter>r\\<in>responses_\\<I> \\<I>' out.\n   expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (c r))\n                             \\<partial>measure_spmf (inline1 callee gpv s)", "apply(rewrite sum.case_distrib[where h=\"case_generat _ _\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. (case x of\n                                  Inl x \\<Rightarrow>\n                                    case Pure x of\n                                    Pure (xa, s) \\<Rightarrow> f xa\n                                    | IO out c \\<Rightarrow>\n  \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out.\n     expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (c r)\n                                  | Inr x \\<Rightarrow>\ncase case x of\n     (out, oracle, rpv) \\<Rightarrow>\n       IO out\n        (\\<lambda>input.\n            oracle input \\<bind>\n            (\\<lambda>(x, y). inline callee (rpv x) y)) of\nPure (xa, s) \\<Rightarrow> f xa\n| IO out c \\<Rightarrow>\n    \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out.\n       expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (c r))\n                             \\<partial>measure_spmf (inline1 callee gpv s)", "apply(simp cong del: sum.case_cong_weak)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. (case x of Inl (xa, s) \\<Rightarrow> f xa\n                                  | Inr x \\<Rightarrow>\ncase case x of\n     (out, oracle, rpv) \\<Rightarrow>\n       IO out\n        (\\<lambda>input.\n            oracle input \\<bind>\n            (\\<lambda>(x, y). inline callee (rpv x) y)) of\nPure (xa, s) \\<Rightarrow> f xa\n| IO out c \\<Rightarrow>\n    \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out.\n       expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (c r))\n                             \\<partial>measure_spmf (inline1 callee gpv s)", "apply(simp add: split_beta o_def cong del: sum.case_cong_weak)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. (case x of Inl x \\<Rightarrow> f (fst x)\n                                  | Inr x \\<Rightarrow>\n\\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n   expectation_gpv 0 \\<I>'\n    (\\<lambda>xa.\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (snd (snd x) (fst xa)) (snd xa)))\n    (fst (snd x) xa))\n                             \\<partial>measure_spmf (inline1 callee gpv s)", "apply(rewrite inline1.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. (case x of Inl x \\<Rightarrow> f (fst x)\n                                  | Inr x \\<Rightarrow>\n\\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n   expectation_gpv 0 \\<I>'\n    (\\<lambda>xa.\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (snd (snd x) (fst xa)) (snd xa)))\n    (fst (snd x) xa))\n                             \\<partial>measure_spmf\n  (the_gpv gpv \\<bind>\n   case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n    (\\<lambda>out rpv.\n        the_gpv (callee s out) \\<bind>\n        case_generat (\\<lambda>(x, y). inline1 callee (rpv x) y)\n         (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))", "apply(rewrite measure_spmf_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. (case x of Inl x \\<Rightarrow> f (fst x)\n                                  | Inr x \\<Rightarrow>\n\\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n   expectation_gpv 0 \\<I>'\n    (\\<lambda>xa.\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (snd (snd x) (fst xa)) (snd xa)))\n    (fst (snd x) xa))\n                             \\<partial>measure_spmf (the_gpv gpv) \\<bind>\n measure_spmf \\<circ>\n case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n  (\\<lambda>out rpv.\n      the_gpv (callee s out) \\<bind>\n      case_generat (\\<lambda>(x, y). inline1 callee (rpv x) y)\n       (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))", "apply(rewrite nn_integral_bind[where B=\"measure_spmf _\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    (\\<lambda>x.\n        case x of Inl x \\<Rightarrow> f (fst x)\n        | Inr x \\<Rightarrow>\n            \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n               expectation_gpv 0 \\<I>'\n                (\\<lambda>xa.\n                    expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (snd (snd x) (fst xa)) (snd xa)))\n                (fst (snd x) xa))\n    \\<in> borel_measurable (measure_spmf ?uu1339)\n 2. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    measure_spmf \\<circ>\n    case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n     (\\<lambda>out rpv.\n         the_gpv (callee s out) \\<bind>\n         case_generat (\\<lambda>(x, y). inline1 callee (rpv x) y)\n          (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))\n    \\<in> measure_spmf (the_gpv gpv) \\<rightarrow>\\<^sub>M\n          subprob_algebra (measure_spmf ?uu1339)\n 3. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ y.\n                (case y of Inl x \\<Rightarrow> f (fst x)\n                 | Inr x \\<Rightarrow>\n                     \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n                        expectation_gpv 0 \\<I>'\n                         (\\<lambda>xa.\n                             expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                              (inline callee (snd (snd x) (fst xa))\n                                (snd xa)))\n                         (fst (snd x) xa))\n              \\<partial>(measure_spmf \\<circ>\n                         case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n                          (\\<lambda>out rpv.\n                              the_gpv (callee s out) \\<bind>\n                              case_generat\n                               (\\<lambda>(x, y). inline1 callee (rpv x) y)\n                               (\\<lambda>out rpv'.\n                                   return_spmf (Inr (out, rpv', rpv)))))\n                         x\n                             \\<partial>measure_spmf (the_gpv gpv)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    measure_spmf \\<circ>\n    case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n     (\\<lambda>out rpv.\n         the_gpv (callee s out) \\<bind>\n         case_generat (\\<lambda>(x, y). inline1 callee (rpv x) y)\n          (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))\n    \\<in> measure_spmf (the_gpv gpv) \\<rightarrow>\\<^sub>M\n          subprob_algebra (measure_spmf ?uu1339)\n 2. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ y.\n                (case y of Inl x \\<Rightarrow> f (fst x)\n                 | Inr x \\<Rightarrow>\n                     \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n                        expectation_gpv 0 \\<I>'\n                         (\\<lambda>xa.\n                             expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                              (inline callee (snd (snd x) (fst xa))\n                                (snd xa)))\n                         (fst (snd x) xa))\n              \\<partial>(measure_spmf \\<circ>\n                         case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n                          (\\<lambda>out rpv.\n                              the_gpv (callee s out) \\<bind>\n                              case_generat\n                               (\\<lambda>(x, y). inline1 callee (rpv x) y)\n                               (\\<lambda>out rpv'.\n                                   return_spmf (Inr (out, rpv', rpv)))))\n                         x\n                             \\<partial>measure_spmf (the_gpv gpv)", "apply(simp add: space_subprob_algebra)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    integral\\<^sup>N (measure_spmf (the_gpv gpv))\n     (case_generat f\n       (\\<lambda>out c.\n           \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n    \\<le> \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ y.\n                (case y of Inl x \\<Rightarrow> f (fst x)\n                 | Inr x \\<Rightarrow>\n                     \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n                        expectation_gpv 0 \\<I>'\n                         (\\<lambda>xa.\n                             expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                              (inline callee (snd (snd x) (fst xa))\n                                (snd xa)))\n                         (fst (snd x) xa))\n              \\<partial>(measure_spmf \\<circ>\n                         case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n                          (\\<lambda>out rpv.\n                              the_gpv (callee s out) \\<bind>\n                              case_generat\n                               (\\<lambda>(x, y). inline1 callee (rpv x) y)\n                               (\\<lambda>out rpv'.\n                                   return_spmf (Inr (out, rpv', rpv)))))\n                         x\n                             \\<partial>measure_spmf (the_gpv gpv)", "apply(rule nn_integral_mono_AE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n        \\<le> \\<integral>\\<^sup>+ generat.\n                                   (case generat of\n                                    Pure (x, s') \\<Rightarrow>\n\\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                         | Inr (out', callee', rpv) \\<Rightarrow>\n                             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                expectation_gpv 0 \\<I>'\n                                 (\\<lambda>(r, s').\n                                     expectation_gpv 0 \\<I>'\n(\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                 (callee' r'))\n                   \\<partial>measure_spmf (inline1 callee (c x) s')\n                                    | IO out' rpv \\<Rightarrow>\n  \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n     expectation_gpv 0 \\<I>'\n      (\\<lambda>(r', s').\n          expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n           (inline callee (c r') s'))\n      (rpv r'))\n                                 \\<partial>measure_spmf\n      (the_gpv (callee s out))) \\<Longrightarrow>\n    AE x in measure_spmf\n             (the_gpv\n               gpv). (case x of Pure x \\<Rightarrow> f x\n                      | IO out c \\<Rightarrow>\n                          \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                             expectation_gpv' (c r))\n                     \\<le> \\<integral>\\<^sup>+ y.\n          (case y of Inl x \\<Rightarrow> f (fst x)\n           | Inr x \\<Rightarrow>\n               \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n                  expectation_gpv 0 \\<I>'\n                   (\\<lambda>xa.\n                       expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                        (inline callee (snd (snd x) (fst xa)) (snd xa)))\n                   (fst (snd x) xa))\n        \\<partial>(measure_spmf \\<circ>\n                   case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n                    (\\<lambda>out rpv.\n                        the_gpv (callee s out) \\<bind>\n                        case_generat\n                         (\\<lambda>(x, y). inline1 callee (rpv x) y)\n                         (\\<lambda>out rpv'.\n                             return_spmf (Inr (out, rpv', rpv)))))\n                   x", "apply(clarsimp split!: generat.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> integral\\<^sup>N\n                          (measure_spmf (the_gpv (callee s out)))\n                          (case_generat\n                            (\\<lambda>(x, s').\n                                integral\\<^sup>N\n                                 (measure_spmf (inline1 callee (c x) s'))\n                                 (case_sum (\\<lambda>(x, xa). f x)\n                                   (\\<lambda>(out', callee', rpv).\n \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n    expectation_gpv 0 \\<I>'\n     (\\<lambda>(r, s').\n         expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n          (inline callee (rpv r) s'))\n     (callee' r'))))\n                            (\\<lambda>out' rpv.\n                                \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                   expectation_gpv 0 \\<I>'\n                                    (\\<lambda>(r', s').\n  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s'))\n                                    (rpv r')));\n        Pure x1 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> f x1\n                         \\<le> integral\\<^sup>N\n                                (measure_spmf (return_spmf (Inl (x1, s))))\n                                (case_sum (\\<lambda>x. f (fst x))\n                                  (\\<lambda>x.\n\\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n   expectation_gpv 0 \\<I>'\n    (\\<lambda>xa.\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (snd (snd x) (fst xa)) (snd xa)))\n    (fst (snd x) xa)))\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> integral\\<^sup>N\n                          (measure_spmf (the_gpv (callee s out)))\n                          (case_generat\n                            (\\<lambda>(x, s').\n                                integral\\<^sup>N\n                                 (measure_spmf (inline1 callee (c x) s'))\n                                 (case_sum (\\<lambda>(x, xa). f x)\n                                   (\\<lambda>(out', callee', rpv).\n \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n    expectation_gpv 0 \\<I>'\n     (\\<lambda>(r, s').\n         expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n          (inline callee (rpv r) s'))\n     (callee' r'))))\n                            (\\<lambda>out' rpv.\n                                \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                   expectation_gpv 0 \\<I>'\n                                    (\\<lambda>(r', s').\n  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s'))\n                                    (rpv r')));\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> integral\\<^sup>N\n                                (measure_spmf\n                                  (the_gpv (callee s x21) \\<bind>\n                                   case_generat\n                                    (\\<lambda>(x, y).\n  inline1 callee (x22 x) y)\n                                    (\\<lambda>out rpv'.\n  return_spmf (Inr (out, rpv', x22)))))\n                                (case_sum (\\<lambda>x. f (fst x))\n                                  (\\<lambda>x.\n\\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n   expectation_gpv 0 \\<I>'\n    (\\<lambda>xa.\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (snd (snd x) (fst xa)) (snd xa)))\n    (fst (snd x) xa)))", "apply(simp add: measure_spmf_return_spmf nn_integral_return)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> integral\\<^sup>N\n                          (measure_spmf (the_gpv (callee s out)))\n                          (case_generat\n                            (\\<lambda>(x, s').\n                                integral\\<^sup>N\n                                 (measure_spmf (inline1 callee (c x) s'))\n                                 (case_sum (\\<lambda>(x, xa). f x)\n                                   (\\<lambda>(out', callee', rpv).\n \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n    expectation_gpv 0 \\<I>'\n     (\\<lambda>(r, s').\n         expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n          (inline callee (rpv r) s'))\n     (callee' r'))))\n                            (\\<lambda>out' rpv.\n                                \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                   expectation_gpv 0 \\<I>'\n                                    (\\<lambda>(r', s').\n  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s'))\n                                    (rpv r')));\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> integral\\<^sup>N\n                                (measure_spmf\n                                  (the_gpv (callee s x21) \\<bind>\n                                   case_generat\n                                    (\\<lambda>(x, y).\n  inline1 callee (x22 x) y)\n                                    (\\<lambda>out rpv'.\n  return_spmf (Inr (out, rpv', x22)))))\n                                (case_sum (\\<lambda>x. f (fst x))\n                                  (\\<lambda>x.\n\\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n   expectation_gpv 0 \\<I>'\n    (\\<lambda>xa.\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (snd (snd x) (fst xa)) (snd xa)))\n    (fst (snd x) xa)))", "apply(rewrite measure_spmf_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> integral\\<^sup>N\n                          (measure_spmf (the_gpv (callee s out)))\n                          (case_generat\n                            (\\<lambda>(x, s').\n                                integral\\<^sup>N\n                                 (measure_spmf (inline1 callee (c x) s'))\n                                 (case_sum (\\<lambda>(x, xa). f x)\n                                   (\\<lambda>(out', callee', rpv).\n \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n    expectation_gpv 0 \\<I>'\n     (\\<lambda>(r, s').\n         expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n          (inline callee (rpv r) s'))\n     (callee' r'))))\n                            (\\<lambda>out' rpv.\n                                \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                   expectation_gpv 0 \\<I>'\n                                    (\\<lambda>(r', s').\n  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s'))\n                                    (rpv r')));\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> integral\\<^sup>N\n                                (measure_spmf\n                                  (the_gpv (callee s x21)) \\<bind>\n                                 measure_spmf \\<circ>\n                                 case_generat\n                                  (\\<lambda>(x, y).\ninline1 callee (x22 x) y)\n                                  (\\<lambda>out rpv'.\nreturn_spmf (Inr (out, rpv', x22))))\n                                (case_sum (\\<lambda>x. f (fst x))\n                                  (\\<lambda>x.\n\\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n   expectation_gpv 0 \\<I>'\n    (\\<lambda>xa.\n        expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n         (inline callee (snd (snd x) (fst xa)) (snd xa)))\n    (fst (snd x) xa)))", "apply(simp add: nn_integral_bind[where B=\"measure_spmf _\"] space_subprob_algebra)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> integral\\<^sup>N\n                          (measure_spmf (the_gpv (callee s out)))\n                          (case_generat\n                            (\\<lambda>(x, s').\n                                integral\\<^sup>N\n                                 (measure_spmf (inline1 callee (c x) s'))\n                                 (case_sum (\\<lambda>(x, xa). f x)\n                                   (\\<lambda>(out', callee', rpv).\n \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n    expectation_gpv 0 \\<I>'\n     (\\<lambda>(r, s').\n         expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n          (inline callee (rpv r) s'))\n     (callee' r'))))\n                            (\\<lambda>out' rpv.\n                                \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                   expectation_gpv 0 \\<I>'\n                                    (\\<lambda>(r', s').\n  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s'))\n                                    (rpv r')));\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> \\<integral>\\<^sup>+ x.\n              \\<integral>\\<^sup>+ y. (case y of\nInl x \\<Rightarrow> f (fst x)\n| Inr x \\<Rightarrow>\n    \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n       expectation_gpv 0 \\<I>'\n        (\\<lambda>xa.\n            expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n             (inline callee (snd (snd x) (fst xa)) (snd xa)))\n        (fst (snd x) xa))\n                                 \\<partial>measure_spmf\n      (case x of Pure (xa, xb) \\<Rightarrow> inline1 callee (x22 xa) xb\n       | IO out rpv' \\<Rightarrow> return_spmf (Inr (out, rpv', x22)))\n            \\<partial>measure_spmf (the_gpv (callee s x21))", "apply(subst generat.case_distrib[where h=\"measure_spmf\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> integral\\<^sup>N\n                          (measure_spmf (the_gpv (callee s out)))\n                          (case_generat\n                            (\\<lambda>(x, s').\n                                integral\\<^sup>N\n                                 (measure_spmf (inline1 callee (c x) s'))\n                                 (case_sum (\\<lambda>(x, xa). f x)\n                                   (\\<lambda>(out', callee', rpv).\n \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n    expectation_gpv 0 \\<I>'\n     (\\<lambda>(r, s').\n         expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n          (inline callee (rpv r) s'))\n     (callee' r'))))\n                            (\\<lambda>out' rpv.\n                                \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                   expectation_gpv 0 \\<I>'\n                                    (\\<lambda>(r', s').\n  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s'))\n                                    (rpv r')));\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> \\<integral>\\<^sup>+ x.\n              integral\\<^sup>N\n               (case x of\n                Pure x \\<Rightarrow>\n                  measure_spmf\n                   (case x of\n                    (x, xa) \\<Rightarrow> inline1 callee (x22 x) xa)\n                | IO x1 x2 \\<Rightarrow>\n                    measure_spmf (return_spmf (Inr (x1, x2, x22))))\n               (case_sum (\\<lambda>x. f (fst x))\n                 (\\<lambda>x.\n                     \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n                        expectation_gpv 0 \\<I>'\n                         (\\<lambda>xa.\n                             expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                              (inline callee (snd (snd x) (fst xa))\n                                (snd xa)))\n                         (fst (snd x) xa)))\n            \\<partial>measure_spmf (the_gpv (callee s x21))", "apply(subst generat.case_distrib[where h=\"\\<lambda>x. nn_integral x _\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> integral\\<^sup>N\n                          (measure_spmf (the_gpv (callee s out)))\n                          (case_generat\n                            (\\<lambda>(x, s').\n                                integral\\<^sup>N\n                                 (measure_spmf (inline1 callee (c x) s'))\n                                 (case_sum (\\<lambda>(x, xa). f x)\n                                   (\\<lambda>(out', callee', rpv).\n \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n    expectation_gpv 0 \\<I>'\n     (\\<lambda>(r, s').\n         expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n          (inline callee (rpv r) s'))\n     (callee' r'))))\n                            (\\<lambda>out' rpv.\n                                \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                   expectation_gpv 0 \\<I>'\n                                    (\\<lambda>(r', s').\n  expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s'))\n                                    (rpv r')));\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> integral\\<^sup>N\n                                (measure_spmf (the_gpv (callee s x21)))\n                                (case_generat\n                                  (\\<lambda>x.\nintegral\\<^sup>N\n (measure_spmf (case x of (x, xa) \\<Rightarrow> inline1 callee (x22 x) xa))\n (case_sum (\\<lambda>x. f (fst x))\n   (\\<lambda>x.\n       \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n          expectation_gpv 0 \\<I>'\n           (\\<lambda>xa.\n               expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                (inline callee (snd (snd x) (fst xa)) (snd xa)))\n           (fst (snd x) xa))))\n                                  (\\<lambda>x1 x2.\nintegral\\<^sup>N (measure_spmf (return_spmf (Inr (x1, x2, x22))))\n (case_sum (\\<lambda>x. f (fst x))\n   (\\<lambda>x.\n       \\<Sqinter>xa\\<in>responses_\\<I> \\<I>' (fst x).\n          expectation_gpv 0 \\<I>'\n           (\\<lambda>xa.\n               expectation_gpv 0 \\<I>' (\\<lambda>(x, s). f x)\n                (inline callee (snd (snd x) (fst xa)) (snd xa)))\n           (fst (snd x) xa)))))", "apply(simp add: measure_spmf_return_spmf nn_integral_return split_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> f x\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  0 * ennreal (pmf (the_gpv gpv) None)\n  \\<le> expectation_gpv2 (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n         (inline callee gpv s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in raw_converter_invariant) plossless_inline_invariant:\n  assumes lossless: \"plossless_gpv \\<I> gpv\"\n    and WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and callee: \"\\<And>s x. \\<lbrakk> x \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> plossless_gpv \\<I>' (callee s x)\"\n    and I: \"I s\"\n  shows \"plossless_gpv \\<I>' (inline callee gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_gpv \\<I>' (inline callee gpv s)", "unfolding pgen_lossless_gpv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s) = 1", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s) \\<le> 1\n 2. 1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "have WT': \"\\<I>' \\<turnstile>g inline callee gpv s \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>' \\<turnstile>g inline callee gpv s \\<surd>", "using WT I"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. \\<I>' \\<turnstile>g inline callee gpv s \\<surd>", "by(rule WT_gpv_inline_invar)"], ["proof (state)\nthis:\n  \\<I>' \\<turnstile>g inline callee gpv s \\<surd>\n\ngoal (2 subgoals):\n 1. expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s) \\<le> 1\n 2. 1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "from expectation_gpv_const_le[OF WT', of 0 1]"], ["proof (chain)\npicking this:\n  expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)\n  \\<le> max 1 0", "show \"expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s) \\<le> 1\""], ["proof (prove)\nusing this:\n  expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)\n  \\<le> max 1 0\n\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s) \\<le> 1", "by(simp add: max_def)"], ["proof (state)\nthis:\n  expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s) \\<le> 1\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "have \"1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv", "using lossless"], ["proof (prove)\nusing this:\n  plossless_gpv \\<I> gpv\n\ngoal (1 subgoal):\n 1. 1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv", "by(simp add: pgen_lossless_gpv_def)"], ["proof (state)\nthis:\n  1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "also"], ["proof (state)\nthis:\n  1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "have \"\\<dots> \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n    \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "by(rule expectation_gpv_le_inline[unfolded split_def]; rule callee WT WT_callee I)"], ["proof (state)\nthis:\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n  \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "finally"], ["proof (chain)\npicking this:\n  1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "show \"1 \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "."], ["proof (state)\nthis:\n  1 \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)\n\ngoal:\nNo subgoals!", "qed"], ["", "context callee_invariant_on begin"], ["", "lemma raw_converter_invariant: \"raw_converter_invariant \\<I> \\<I>' (\\<lambda>s x. lift_spmf (callee s x)) I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. raw_converter_invariant \\<I> \\<I>'\n     (\\<lambda>s x. lift_spmf (callee s x)) I", "by(unfold_locales)(auto dest: callee_invariant WT_callee WT_calleeD)"], ["", "lemma (in callee_invariant_on) plossless_exec_gpv:\n  assumes lossless: \"plossless_gpv \\<I> gpv\"\n    and WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and callee: \"\\<And>s x. \\<lbrakk> x \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> lossless_spmf (callee s x)\"\n    and I: \"I s\"\n  shows \"lossless_spmf (exec_gpv callee gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (exec_gpv callee gpv s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lossless_spmf (exec_gpv callee gpv s)", "interpret raw_converter_invariant \\<I> \\<I>' \"\\<lambda>s x. lift_spmf (callee s x)\" I for \\<I>'"], ["proof (prove)\ngoal (1 subgoal):\n 1. raw_converter_invariant \\<I> \\<I>'\n     (\\<lambda>s x. lift_spmf (callee s x)) I", "by(rule raw_converter_invariant)"], ["proof (state)\ngoal (1 subgoal):\n 1. lossless_spmf (exec_gpv callee gpv s)", "have \"plossless_gpv \\<I>_full (inline (\\<lambda>s x. lift_spmf (callee s x)) gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_gpv \\<I>_full\n     (inline (\\<lambda>s x. lift_spmf (callee s x)) gpv s)", "using lossless WT"], ["proof (prove)\nusing this:\n  plossless_gpv \\<I> gpv\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. plossless_gpv \\<I>_full\n     (inline (\\<lambda>s x. lift_spmf (callee s x)) gpv s)", "by(rule plossless_inline)(simp_all add: callee I)"], ["proof (state)\nthis:\n  plossless_gpv \\<I>_full\n   (inline (\\<lambda>s x. lift_spmf (callee s x)) gpv s)\n\ngoal (1 subgoal):\n 1. lossless_spmf (exec_gpv callee gpv s)", "from this[THEN plossless_gpv_lossless_spmfD]"], ["proof (chain)\npicking this:\n  \\<I>_full\n  \\<turnstile>g inline (\\<lambda>s x. lift_spmf (callee s x)) gpv\n                 s \\<surd> \\<Longrightarrow>\n  lossless_spmf\n   (the_gpv (inline (\\<lambda>s x. lift_spmf (callee s x)) gpv s))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<I>_full\n  \\<turnstile>g inline (\\<lambda>s x. lift_spmf (callee s x)) gpv\n                 s \\<surd> \\<Longrightarrow>\n  lossless_spmf\n   (the_gpv (inline (\\<lambda>s x. lift_spmf (callee s x)) gpv s))\n\ngoal (1 subgoal):\n 1. lossless_spmf (exec_gpv callee gpv s)", "unfolding exec_gpv_conv_inline1"], ["proof (prove)\nusing this:\n  \\<I>_full\n  \\<turnstile>g inline (\\<lambda>s x. lift_spmf (callee s x)) gpv\n                 s \\<surd> \\<Longrightarrow>\n  lossless_spmf\n   (the_gpv (inline (\\<lambda>s x. lift_spmf (callee s x)) gpv s))\n\ngoal (1 subgoal):\n 1. lossless_spmf\n     (map_spmf projl (inline1 (\\<lambda>s c. lift_spmf (callee s c)) gpv s))", "by(simp add: inline_sel)"], ["proof (state)\nthis:\n  lossless_spmf (exec_gpv callee gpv s)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma expectation_gpv_mk_lossless_gpv:\n  fixes \\<I> y\n  defines \"rhs \\<equiv> expectation_gpv 0 \\<I> (\\<lambda>_. y)\"\n  assumes WT: \"\\<I>' \\<turnstile>g gpv \\<surd>\"\n    and outs: \"outs_\\<I> \\<I> = outs_\\<I> \\<I>'\"\n  shows \"expectation_gpv 0 \\<I>' (\\<lambda>_. y) gpv \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x gpv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I>' (\\<lambda>_. y) gpv\n    \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x gpv)", "using WT"], ["proof (prove)\nusing this:\n  \\<I>' \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I>' (\\<lambda>_. y) gpv\n    \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x gpv)", "proof(induction arbitrary: gpv rule: expectation_gpv_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>xa.\n            \\<I>' \\<turnstile>g xa \\<surd> \\<longrightarrow>\n            a xa \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x xa))\n 2. \\<And>gpv.\n       \\<I>' \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n       0 \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x gpv)\n 3. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv 0 \\<I>' (\\<lambda>a. y) gpv;\n        \\<And>gpv.\n           \\<I>' \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv\n           \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x gpv);\n        \\<I>' \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. y)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x\n                                     gpv)", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>xa.\n            \\<I>' \\<turnstile>g xa \\<surd> \\<longrightarrow>\n            a xa \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x xa))\n 2. \\<And>gpv.\n       \\<I>' \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n       0 \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x gpv)\n 3. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv 0 \\<I>' (\\<lambda>a. y) gpv;\n        \\<And>gpv.\n           \\<I>' \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv\n           \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x gpv);\n        \\<I>' \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. y)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x\n                                     gpv)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>xa.\n            \\<I>' \\<turnstile>g xa \\<surd> \\<longrightarrow>\n            a xa \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x xa))", "by simp"], ["proof (state)\nthis:\n  lfp.admissible\n   (\\<lambda>a.\n       \\<forall>xa.\n          \\<I>' \\<turnstile>g xa \\<surd> \\<longrightarrow>\n          a xa \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x xa))\n\ngoal (2 subgoals):\n 1. \\<And>gpv.\n       \\<I>' \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n       0 \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x gpv)\n 2. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv 0 \\<I>' (\\<lambda>a. y) gpv;\n        \\<And>gpv.\n           \\<I>' \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv\n           \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x gpv);\n        \\<I>' \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. y)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x\n                                     gpv)", "case bottom"], ["proof (state)\nthis:\n  \\<I>' \\<turnstile>g gpv \\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>gpv.\n       \\<I>' \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n       0 \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x gpv)\n 2. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv 0 \\<I>' (\\<lambda>a. y) gpv;\n        \\<And>gpv.\n           \\<I>' \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv\n           \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x gpv);\n        \\<I>' \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. y)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x\n                                     gpv)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x gpv)", "by simp"], ["proof (state)\nthis:\n  0 \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x gpv)\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv 0 \\<I>' (\\<lambda>a. y) gpv;\n        \\<And>gpv.\n           \\<I>' \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv\n           \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x gpv);\n        \\<I>' \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. y)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x\n                                     gpv)", "case step [unfolded rhs_def]: (step expectation_gpv')"], ["proof (state)\nthis:\n  expectation_gpv' ?gpv \\<le> expectation_gpv 0 \\<I>' (\\<lambda>a. y) ?gpv\n  \\<I>' \\<turnstile>g ?gpv \\<surd> \\<Longrightarrow>\n  expectation_gpv' ?gpv\n  \\<le> expectation_gpv 0 \\<I> (\\<lambda>_. y)\n         (mk_lossless_gpv (responses_\\<I> \\<I>') x ?gpv)\n  \\<I>' \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv 0 \\<I>' (\\<lambda>a. y) gpv;\n        \\<And>gpv.\n           \\<I>' \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv\n           \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x gpv);\n        \\<I>' \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. y)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x\n                                     gpv)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> y\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    0 * ennreal (pmf (the_gpv gpv) None)\n    \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x gpv)", "using step.prems outs"], ["proof (prove)\nusing this:\n  \\<I>' \\<turnstile>g gpv \\<surd>\n  outs_\\<I> \\<I> = outs_\\<I> \\<I>'\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> y\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    0 * ennreal (pmf (the_gpv gpv) None)\n    \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x gpv)", "unfolding rhs_def"], ["proof (prove)\nusing this:\n  \\<I>' \\<turnstile>g gpv \\<surd>\n  outs_\\<I> \\<I> = outs_\\<I> \\<I>'\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> y\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    0 * ennreal (pmf (the_gpv gpv) None)\n    \\<le> expectation_gpv 0 \\<I> (\\<lambda>_. y)\n           (mk_lossless_gpv (responses_\\<I> \\<I>') x gpv)", "apply(subst expectation_gpv.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>' \\<turnstile>g gpv \\<surd>;\n     outs_\\<I> \\<I> = outs_\\<I> \\<I>'\\<rbrakk>\n    \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                       (case_generat (\\<lambda>x. y)\n                         (\\<lambda>out c.\n                             \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out.\n                                expectation_gpv' (c r))) +\n                      0 * ennreal (pmf (the_gpv gpv) None)\n                      \\<le> integral\\<^sup>N\n                             (measure_spmf\n                               (the_gpv\n                                 (mk_lossless_gpv (responses_\\<I> \\<I>') x\n                                   gpv)))\n                             (case_generat (\\<lambda>x. y)\n                               (\\<lambda>out c.\n                                   \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\nexpectation_gpv 0 \\<I> (\\<lambda>_. y) (c r))) +\n                            0 *\n                            ennreal\n                             (pmf (the_gpv\n                                    (mk_lossless_gpv (responses_\\<I> \\<I>')\nx gpv))\n                               None)", "apply(clarsimp intro!: nn_integral_mono_AE INF_mono split!: generat.split if_split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22a m.\n       \\<lbrakk>\\<I>' \\<turnstile>g gpv \\<surd>;\n        outs_\\<I> \\<I> = outs_\\<I> \\<I>';\n        IO x21 x22a \\<in> set_spmf (the_gpv gpv);\n        m \\<in> responses_\\<I> \\<I> x21;\n        m \\<in> responses_\\<I> \\<I>' x21\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r\\<in>responses_\\<I> \\<I>' x21.\n                            expectation_gpv' (x22a r)\n                            \\<le> expectation_gpv 0 \\<I> (\\<lambda>_. y)\n                                   (mk_lossless_gpv (responses_\\<I> \\<I>') x\n                                     (x22a m))\n 2. \\<And>x21 x22a m.\n       \\<lbrakk>\\<I>' \\<turnstile>g gpv \\<surd>;\n        outs_\\<I> \\<I> = outs_\\<I> \\<I>';\n        IO x21 x22a \\<in> set_spmf (the_gpv gpv);\n        m \\<in> responses_\\<I> \\<I> x21;\n        m \\<notin> responses_\\<I> \\<I>' x21\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r\\<in>responses_\\<I> \\<I>' x21.\n                            expectation_gpv' (x22a r) \\<le> y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>' \\<turnstile>g gpv \\<surd>;\n     outs_\\<I> \\<I> = outs_\\<I> \\<I>';\n     IO x21_ x22a_ \\<in> set_spmf (the_gpv gpv);\n     m_ \\<in> responses_\\<I> \\<I> x21_;\n     m_ \\<in> responses_\\<I> \\<I>' x21_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r\\<in>responses_\\<I> \\<I>' x21_.\n                         expectation_gpv' (x22a_ r)\n                         \\<le> expectation_gpv 0 \\<I> (\\<lambda>_. y)\n                                (mk_lossless_gpv (responses_\\<I> \\<I>') x\n                                  (x22a_ m_))", "by(frule (1) WT_gpv_OutD)(auto simp add: in_outs_\\<I>_iff_responses_\\<I> intro!: bexI step.IH[unfolded rhs_def] dest: WT_gpv_ContD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22a m.\n       \\<lbrakk>\\<I>' \\<turnstile>g gpv \\<surd>;\n        outs_\\<I> \\<I> = outs_\\<I> \\<I>';\n        IO x21 x22a \\<in> set_spmf (the_gpv gpv);\n        m \\<in> responses_\\<I> \\<I> x21;\n        m \\<notin> responses_\\<I> \\<I>' x21\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r\\<in>responses_\\<I> \\<I>' x21.\n                            expectation_gpv' (x22a r) \\<le> y", "apply(frule (1) WT_gpv_OutD; clarsimp simp add: in_outs_\\<I>_iff_responses_\\<I> ex_in_conv[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22a m x.\n       \\<lbrakk>\\<I>' \\<turnstile>g gpv \\<surd>;\n        outs_\\<I> \\<I> = outs_\\<I> \\<I>';\n        IO x21 x22a \\<in> set_spmf (the_gpv gpv);\n        m \\<in> responses_\\<I> \\<I> x21;\n        m \\<notin> responses_\\<I> \\<I>' x21;\n        x \\<in> responses_\\<I> \\<I>' x21\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r\\<in>responses_\\<I> \\<I>' x21.\n                            expectation_gpv' (x22a r) \\<le> y", "subgoal for out c input input'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>' \\<turnstile>g gpv \\<surd>;\n     outs_\\<I> \\<I> = outs_\\<I> \\<I>';\n     IO out c \\<in> set_spmf (the_gpv gpv);\n     input \\<in> responses_\\<I> \\<I> out;\n     input \\<notin> responses_\\<I> \\<I>' out;\n     input' \\<in> responses_\\<I> \\<I>' out\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r\\<in>responses_\\<I> \\<I>' out.\n                         expectation_gpv' (c r) \\<le> y", "using step.hyps[of \"c input'\"] expectation_gpv_const_le[of \\<I>' \"c input'\" 0 y]"], ["proof (prove)\nusing this:\n  expectation_gpv' (c input')\n  \\<le> expectation_gpv 0 \\<I>' (\\<lambda>a. y) (c input')\n  \\<I>' \\<turnstile>g c input' \\<surd> \\<Longrightarrow>\n  expectation_gpv 0 \\<I>' (\\<lambda>_. y) (c input') \\<le> max y 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>' \\<turnstile>g gpv \\<surd>;\n     outs_\\<I> \\<I> = outs_\\<I> \\<I>';\n     IO out c \\<in> set_spmf (the_gpv gpv);\n     input \\<in> responses_\\<I> \\<I> out;\n     input \\<notin> responses_\\<I> \\<I>' out;\n     input' \\<in> responses_\\<I> \\<I>' out\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r\\<in>responses_\\<I> \\<I>' out.\n                         expectation_gpv' (c r) \\<le> y", "by- (drule (2) WT_gpv_ContD, fastforce intro: rev_bexI simp add: max_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> y\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I>' out.\n                               expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  0 * ennreal (pmf (the_gpv gpv) None)\n  \\<le> rhs (mk_lossless_gpv (responses_\\<I> \\<I>') x gpv)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma plossless_gpv_mk_lossless_gpv:\n  assumes \"plossless_gpv \\<I> gpv\"\n    and \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and \"outs_\\<I> \\<I> = outs_\\<I> \\<I>'\"\n  shows \"plossless_gpv \\<I>' (mk_lossless_gpv (responses_\\<I> \\<I>) x gpv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_gpv \\<I>' (mk_lossless_gpv (responses_\\<I> \\<I>) x gpv)", "using assms expectation_gpv_mk_lossless_gpv[OF assms(2), of \\<I>' 1 x]"], ["proof (prove)\nusing this:\n  plossless_gpv \\<I> gpv\n  \\<I> \\<turnstile>g gpv \\<surd>\n  outs_\\<I> \\<I> = outs_\\<I> \\<I>'\n  outs_\\<I> \\<I>' = outs_\\<I> \\<I> \\<Longrightarrow>\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n  \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1)\n         (mk_lossless_gpv (responses_\\<I> \\<I>) x gpv)\n\ngoal (1 subgoal):\n 1. plossless_gpv \\<I>' (mk_lossless_gpv (responses_\\<I> \\<I>) x gpv)", "unfolding pgen_lossless_gpv_def"], ["proof (prove)\nusing this:\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv = 1\n  \\<I> \\<turnstile>g gpv \\<surd>\n  outs_\\<I> \\<I> = outs_\\<I> \\<I>'\n  outs_\\<I> \\<I>' = outs_\\<I> \\<I> \\<Longrightarrow>\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n  \\<le> expectation_gpv 0 \\<I>' (\\<lambda>_. 1)\n         (mk_lossless_gpv (responses_\\<I> \\<I>) x gpv)\n\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I>' (\\<lambda>_. 1)\n     (mk_lossless_gpv (responses_\\<I> \\<I>) x gpv) =\n    1", "by -(rule antisym[OF expectation_gpv_const_le[THEN order_trans]]; simp add: WT_gpv_mk_lossless_gpv)"], ["", "lemma (in callee_invariant_on) exec_gpv_mk_lossless_gpv:\n  assumes \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and \"I s\"\n  shows \"exec_gpv callee (mk_lossless_gpv (responses_\\<I> \\<I>) x gpv) s = exec_gpv callee gpv s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_gpv callee (mk_lossless_gpv (responses_\\<I> \\<I>) x gpv) s =\n    exec_gpv callee gpv s", "using assms"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. exec_gpv callee (mk_lossless_gpv (responses_\\<I> \\<I>) x gpv) s =\n    exec_gpv callee gpv s", "proof(induction arbitrary: gpv s rule: exec_gpv_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>f.\n         \\<forall>xa.\n            \\<I> \\<turnstile>g xa \\<surd> \\<longrightarrow>\n            (\\<forall>xb.\n                I xb \\<longrightarrow>\n                f (mk_lossless_gpv (responses_\\<I> \\<I>) x xa, xb) =\n                f (xa, xb)))\n 2. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> return_pmf None = return_pmf None\n 3. \\<And>exec_gpv gpv s.\n       \\<lbrakk>\\<And>gpv s.\n                   \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n                   \\<Longrightarrow> exec_gpv\n(mk_lossless_gpv (responses_\\<I> \\<I>) x gpv) s =\n                                     exec_gpv gpv s;\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> the_gpv\n                          (mk_lossless_gpv (responses_\\<I> \\<I>) x\n                            gpv) \\<bind>\n                         case_generat (\\<lambda>x. return_spmf (x, s))\n                          (\\<lambda>out c.\n                              callee s out \\<bind>\n                              (\\<lambda>(x, y). exec_gpv (c x) y)) =\n                         the_gpv gpv \\<bind>\n                         case_generat (\\<lambda>x. return_spmf (x, s))\n                          (\\<lambda>out c.\n                              callee s out \\<bind>\n                              (\\<lambda>(x, y). exec_gpv (c x) y))", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>f.\n         \\<forall>xa.\n            \\<I> \\<turnstile>g xa \\<surd> \\<longrightarrow>\n            (\\<forall>xb.\n                I xb \\<longrightarrow>\n                f (mk_lossless_gpv (responses_\\<I> \\<I>) x xa, xb) =\n                f (xa, xb)))\n 2. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> return_pmf None = return_pmf None\n 3. \\<And>exec_gpv gpv s.\n       \\<lbrakk>\\<And>gpv s.\n                   \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n                   \\<Longrightarrow> exec_gpv\n(mk_lossless_gpv (responses_\\<I> \\<I>) x gpv) s =\n                                     exec_gpv gpv s;\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> the_gpv\n                          (mk_lossless_gpv (responses_\\<I> \\<I>) x\n                            gpv) \\<bind>\n                         case_generat (\\<lambda>x. return_spmf (x, s))\n                          (\\<lambda>out c.\n                              callee s out \\<bind>\n                              (\\<lambda>(x, y). exec_gpv (c x) y)) =\n                         the_gpv gpv \\<bind>\n                         case_generat (\\<lambda>x. return_spmf (x, s))\n                          (\\<lambda>out c.\n                              callee s out \\<bind>\n                              (\\<lambda>(x, y). exec_gpv (c x) y))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf.admissible\n     (\\<lambda>f.\n         \\<forall>xa.\n            \\<I> \\<turnstile>g xa \\<surd> \\<longrightarrow>\n            (\\<forall>xb.\n                I xb \\<longrightarrow>\n                f (mk_lossless_gpv (responses_\\<I> \\<I>) x xa, xb) =\n                f (xa, xb)))", "by simp"], ["proof (state)\nthis:\n  spmf.admissible\n   (\\<lambda>f.\n       \\<forall>xa.\n          \\<I> \\<turnstile>g xa \\<surd> \\<longrightarrow>\n          (\\<forall>xb.\n              I xb \\<longrightarrow>\n              f (mk_lossless_gpv (responses_\\<I> \\<I>) x xa, xb) =\n              f (xa, xb)))\n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> return_pmf None = return_pmf None\n 2. \\<And>exec_gpv gpv s.\n       \\<lbrakk>\\<And>gpv s.\n                   \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n                   \\<Longrightarrow> exec_gpv\n(mk_lossless_gpv (responses_\\<I> \\<I>) x gpv) s =\n                                     exec_gpv gpv s;\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> the_gpv\n                          (mk_lossless_gpv (responses_\\<I> \\<I>) x\n                            gpv) \\<bind>\n                         case_generat (\\<lambda>x. return_spmf (x, s))\n                          (\\<lambda>out c.\n                              callee s out \\<bind>\n                              (\\<lambda>(x, y). exec_gpv (c x) y)) =\n                         the_gpv gpv \\<bind>\n                         case_generat (\\<lambda>x. return_spmf (x, s))\n                          (\\<lambda>out c.\n                              callee s out \\<bind>\n                              (\\<lambda>(x, y). exec_gpv (c x) y))", "case bottom"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> return_pmf None = return_pmf None\n 2. \\<And>exec_gpv gpv s.\n       \\<lbrakk>\\<And>gpv s.\n                   \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n                   \\<Longrightarrow> exec_gpv\n(mk_lossless_gpv (responses_\\<I> \\<I>) x gpv) s =\n                                     exec_gpv gpv s;\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> the_gpv\n                          (mk_lossless_gpv (responses_\\<I> \\<I>) x\n                            gpv) \\<bind>\n                         case_generat (\\<lambda>x. return_spmf (x, s))\n                          (\\<lambda>out c.\n                              callee s out \\<bind>\n                              (\\<lambda>(x, y). exec_gpv (c x) y)) =\n                         the_gpv gpv \\<bind>\n                         case_generat (\\<lambda>x. return_spmf (x, s))\n                          (\\<lambda>out c.\n                              callee s out \\<bind>\n                              (\\<lambda>(x, y). exec_gpv (c x) y))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. return_pmf None = return_pmf None", "by simp"], ["proof (state)\nthis:\n  return_pmf None = return_pmf None\n\ngoal (1 subgoal):\n 1. \\<And>exec_gpv gpv s.\n       \\<lbrakk>\\<And>gpv s.\n                   \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n                   \\<Longrightarrow> exec_gpv\n(mk_lossless_gpv (responses_\\<I> \\<I>) x gpv) s =\n                                     exec_gpv gpv s;\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> the_gpv\n                          (mk_lossless_gpv (responses_\\<I> \\<I>) x\n                            gpv) \\<bind>\n                         case_generat (\\<lambda>x. return_spmf (x, s))\n                          (\\<lambda>out c.\n                              callee s out \\<bind>\n                              (\\<lambda>(x, y). exec_gpv (c x) y)) =\n                         the_gpv gpv \\<bind>\n                         case_generat (\\<lambda>x. return_spmf (x, s))\n                          (\\<lambda>out c.\n                              callee s out \\<bind>\n                              (\\<lambda>(x, y). exec_gpv (c x) y))", "case (step exec_gpv')"], ["proof (state)\nthis:\n  \\<lbrakk>\\<I> \\<turnstile>g ?gpv \\<surd>; I ?s\\<rbrakk>\n  \\<Longrightarrow> exec_gpv' (mk_lossless_gpv (responses_\\<I> \\<I>) x ?gpv)\n                     ?s =\n                    exec_gpv' ?gpv ?s\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. \\<And>exec_gpv gpv s.\n       \\<lbrakk>\\<And>gpv s.\n                   \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n                   \\<Longrightarrow> exec_gpv\n(mk_lossless_gpv (responses_\\<I> \\<I>) x gpv) s =\n                                     exec_gpv gpv s;\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> the_gpv\n                          (mk_lossless_gpv (responses_\\<I> \\<I>) x\n                            gpv) \\<bind>\n                         case_generat (\\<lambda>x. return_spmf (x, s))\n                          (\\<lambda>out c.\n                              callee s out \\<bind>\n                              (\\<lambda>(x, y). exec_gpv (c x) y)) =\n                         the_gpv gpv \\<bind>\n                         case_generat (\\<lambda>x. return_spmf (x, s))\n                          (\\<lambda>out c.\n                              callee s out \\<bind>\n                              (\\<lambda>(x, y). exec_gpv (c x) y))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. the_gpv (mk_lossless_gpv (responses_\\<I> \\<I>) x gpv) \\<bind>\n    case_generat (\\<lambda>x. return_spmf (x, s))\n     (\\<lambda>out c.\n         callee s out \\<bind> (\\<lambda>(x, y). exec_gpv' (c x) y)) =\n    the_gpv gpv \\<bind>\n    case_generat (\\<lambda>x. return_spmf (x, s))\n     (\\<lambda>out c.\n         callee s out \\<bind> (\\<lambda>(x, y). exec_gpv' (c x) y))", "using step.prems WT_gpv_OutD[OF step.prems(1)]"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n  IO ?out ?c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n  ?out \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. the_gpv (mk_lossless_gpv (responses_\\<I> \\<I>) x gpv) \\<bind>\n    case_generat (\\<lambda>x. return_spmf (x, s))\n     (\\<lambda>out c.\n         callee s out \\<bind> (\\<lambda>(x, y). exec_gpv' (c x) y)) =\n    the_gpv gpv \\<bind>\n    case_generat (\\<lambda>x. return_spmf (x, s))\n     (\\<lambda>out c.\n         callee s out \\<bind> (\\<lambda>(x, y). exec_gpv' (c x) y))", "by(clarsimp simp add: bind_map_spmf intro!: bind_spmf_cong[OF refl] split!: generat.split if_split)\n      (force intro!: step.IH dest: WT_callee[THEN WT_calleeD] WT_gpv_OutD callee_invariant WT_gpv_ContD)+"], ["proof (state)\nthis:\n  the_gpv (mk_lossless_gpv (responses_\\<I> \\<I>) x gpv) \\<bind>\n  case_generat (\\<lambda>x. return_spmf (x, s))\n   (\\<lambda>out c.\n       callee s out \\<bind> (\\<lambda>(x, y). exec_gpv' (c x) y)) =\n  the_gpv gpv \\<bind>\n  case_generat (\\<lambda>x. return_spmf (x, s))\n   (\\<lambda>out c.\n       callee s out \\<bind> (\\<lambda>(x, y). exec_gpv' (c x) y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma expectation_gpv_map_gpv' [simp]:\n  \"expectation_gpv fail \\<I> f (map_gpv' g h k gpv) =\n   expectation_gpv fail (map_\\<I> h k \\<I>) (f \\<circ> g) gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> f (map_gpv' g h k gpv) =\n    expectation_gpv fail (map_\\<I> h k \\<I>) (f \\<circ> g) gpv", "proof(induction arbitrary: gpv rule: parallel_fixp_induct_1_1[OF complete_lattice_partial_function_definitions complete_lattice_partial_function_definitions expectation_gpv.mono expectation_gpv.mono expectation_gpv_def expectation_gpv_def, case_names adm bottom step])"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x. \\<forall>xa. fst x (map_gpv' g h k xa) = snd x xa)\n 2. \\<And>gpv. \\<Squnion> {} = \\<Squnion> {}\n 3. \\<And>fa ga gpv.\n       (\\<And>gpv. fa (map_gpv' g h k gpv) = ga gpv) \\<Longrightarrow>\n       integral\\<^sup>N (measure_spmf (the_gpv (map_gpv' g h k gpv)))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. fa (c r))) +\n       fail * ennreal (pmf (the_gpv (map_gpv' g h k gpv)) None) =\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat (f \\<circ> g)\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> (map_\\<I> h k \\<I>) out.\n                 ga (c r))) +\n       fail * ennreal (pmf (the_gpv gpv) None)", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x. \\<forall>xa. fst x (map_gpv' g h k xa) = snd x xa)\n 2. \\<And>gpv. \\<Squnion> {} = \\<Squnion> {}\n 3. \\<And>fa ga gpv.\n       (\\<And>gpv. fa (map_gpv' g h k gpv) = ga gpv) \\<Longrightarrow>\n       integral\\<^sup>N (measure_spmf (the_gpv (map_gpv' g h k gpv)))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. fa (c r))) +\n       fail * ennreal (pmf (the_gpv (map_gpv' g h k gpv)) None) =\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat (f \\<circ> g)\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> (map_\\<I> h k \\<I>) out.\n                 ga (c r))) +\n       fail * ennreal (pmf (the_gpv gpv) None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x. \\<forall>xa. fst x (map_gpv' g h k xa) = snd x xa)", "by simp"], ["proof (state)\nthis:\n  ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n   (rel_prod lfp.le_fun lfp.le_fun)\n   (\\<lambda>x. \\<forall>xa. fst x (map_gpv' g h k xa) = snd x xa)\n\ngoal (2 subgoals):\n 1. \\<And>gpv. \\<Squnion> {} = \\<Squnion> {}\n 2. \\<And>fa ga gpv.\n       (\\<And>gpv. fa (map_gpv' g h k gpv) = ga gpv) \\<Longrightarrow>\n       integral\\<^sup>N (measure_spmf (the_gpv (map_gpv' g h k gpv)))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. fa (c r))) +\n       fail * ennreal (pmf (the_gpv (map_gpv' g h k gpv)) None) =\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat (f \\<circ> g)\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> (map_\\<I> h k \\<I>) out.\n                 ga (c r))) +\n       fail * ennreal (pmf (the_gpv gpv) None)", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>gpv. \\<Squnion> {} = \\<Squnion> {}\n 2. \\<And>fa ga gpv.\n       (\\<And>gpv. fa (map_gpv' g h k gpv) = ga gpv) \\<Longrightarrow>\n       integral\\<^sup>N (measure_spmf (the_gpv (map_gpv' g h k gpv)))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. fa (c r))) +\n       fail * ennreal (pmf (the_gpv (map_gpv' g h k gpv)) None) =\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat (f \\<circ> g)\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> (map_\\<I> h k \\<I>) out.\n                 ga (c r))) +\n       fail * ennreal (pmf (the_gpv gpv) None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> {} = \\<Squnion> {}", "by simp"], ["proof (state)\nthis:\n  \\<Squnion> {} = \\<Squnion> {}\n\ngoal (1 subgoal):\n 1. \\<And>fa ga gpv.\n       (\\<And>gpv. fa (map_gpv' g h k gpv) = ga gpv) \\<Longrightarrow>\n       integral\\<^sup>N (measure_spmf (the_gpv (map_gpv' g h k gpv)))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. fa (c r))) +\n       fail * ennreal (pmf (the_gpv (map_gpv' g h k gpv)) None) =\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat (f \\<circ> g)\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> (map_\\<I> h k \\<I>) out.\n                 ga (c r))) +\n       fail * ennreal (pmf (the_gpv gpv) None)", "case (step exp1 exp2)"], ["proof (state)\nthis:\n  exp1 (map_gpv' g h k ?gpv) = exp2 ?gpv\n\ngoal (1 subgoal):\n 1. \\<And>fa ga gpv.\n       (\\<And>gpv. fa (map_gpv' g h k gpv) = ga gpv) \\<Longrightarrow>\n       integral\\<^sup>N (measure_spmf (the_gpv (map_gpv' g h k gpv)))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. fa (c r))) +\n       fail * ennreal (pmf (the_gpv (map_gpv' g h k gpv)) None) =\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat (f \\<circ> g)\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> (map_\\<I> h k \\<I>) out.\n                 ga (c r))) +\n       fail * ennreal (pmf (the_gpv gpv) None)", "have \"pmf (the_gpv (map_gpv' g h k gpv)) None = pmf (the_gpv gpv) None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (the_gpv (map_gpv' g h k gpv)) None = pmf (the_gpv gpv) None", "by(simp add: pmf_map_spmf_None)"], ["proof (state)\nthis:\n  pmf (the_gpv (map_gpv' g h k gpv)) None = pmf (the_gpv gpv) None\n\ngoal (1 subgoal):\n 1. \\<And>fa ga gpv.\n       (\\<And>gpv. fa (map_gpv' g h k gpv) = ga gpv) \\<Longrightarrow>\n       integral\\<^sup>N (measure_spmf (the_gpv (map_gpv' g h k gpv)))\n        (case_generat f\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. fa (c r))) +\n       fail * ennreal (pmf (the_gpv (map_gpv' g h k gpv)) None) =\n       integral\\<^sup>N (measure_spmf (the_gpv gpv))\n        (case_generat (f \\<circ> g)\n          (\\<lambda>out c.\n              \\<Sqinter>r\\<in>responses_\\<I> (map_\\<I> h k \\<I>) out.\n                 ga (c r))) +\n       fail * ennreal (pmf (the_gpv gpv) None)", "then"], ["proof (chain)\npicking this:\n  pmf (the_gpv (map_gpv' g h k gpv)) None = pmf (the_gpv gpv) None", "show ?case"], ["proof (prove)\nusing this:\n  pmf (the_gpv (map_gpv' g h k gpv)) None = pmf (the_gpv gpv) None\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 exp1 (c r))\n                       \\<partial>measure_spmf\n                                  (the_gpv (map_gpv' g h k gpv)) +\n    fail * ennreal (pmf (the_gpv (map_gpv' g h k gpv)) None) =\n    \\<integral>\\<^sup>+ generat.\n                         (case generat of\n                          Pure x \\<Rightarrow> (f \\<circ> g) x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I>\n         (map_\\<I> h k \\<I>) out.\n                                 exp2 (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail * ennreal (pmf (the_gpv gpv) None)", "by simp\n      (auto simp add: nn_integral_measure_spmf step.IH image_comp\n        split: generat.split intro!: nn_integral_cong)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> f x\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               exp1 (c r))\n                     \\<partial>measure_spmf (the_gpv (map_gpv' g h k gpv)) +\n  fail * ennreal (pmf (the_gpv (map_gpv' g h k gpv)) None) =\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> (f \\<circ> g) x\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I>\n       (map_\\<I> h k \\<I>) out.\n                               exp2 (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  fail * ennreal (pmf (the_gpv gpv) None)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma plossless_gpv_map_gpv' [simp]:\n  \"pgen_lossless_gpv b \\<I> (map_gpv' f g h gpv) \\<longleftrightarrow> pgen_lossless_gpv b (map_\\<I> g h \\<I>) gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pgen_lossless_gpv b \\<I> (map_gpv' f g h gpv) =\n    pgen_lossless_gpv b (map_\\<I> g h \\<I>) gpv", "unfolding pgen_lossless_gpv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (expectation_gpv b \\<I> (\\<lambda>_. 1) (map_gpv' f g h gpv) = 1) =\n    (expectation_gpv b (map_\\<I> g h \\<I>) (\\<lambda>_. 1) gpv = 1)", "by(simp add: o_def)"], ["", "end"]]}