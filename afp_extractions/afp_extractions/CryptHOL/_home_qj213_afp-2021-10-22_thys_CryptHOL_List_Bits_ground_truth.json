{"file_name": "/home/qj213/afp-2021-10-22/thys/CryptHOL/List_Bits.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CryptHOL", "problem_names": ["lemma xor_bool_def [iff]: fixes x y :: bool shows \"x \\<oplus> y \\<longleftrightarrow> x \\<noteq> y\"", "lemma xor_commute:\n  fixes x y :: \"'a :: {semilattice_sup,semilattice_inf,uminus}\"\n  shows \"x \\<oplus> y = y \\<oplus> x\"", "lemma xor_assoc:\n  fixes x y :: \"'a :: boolean_algebra\"\n  shows \"(x \\<oplus> y) \\<oplus> z = x \\<oplus> (y \\<oplus> z)\"", "lemma xor_left_commute:\n  fixes x y :: \"'a :: boolean_algebra\"\n  shows \"x \\<oplus> (y \\<oplus> z) = y \\<oplus> (x \\<oplus> z)\"", "lemma [simp]:\n  fixes x :: \"'a :: boolean_algebra\"\n  shows xor_bot: \"x \\<oplus> bot = x\"\n  and bot_xor: \"bot \\<oplus> x = x\"\n  and xor_top: \"x \\<oplus> top = - x\"\n  and top_xor: \"top \\<oplus> x = - x\"", "lemma xor_inverse [simp]:\n  fixes x :: \"'a :: boolean_algebra\"\n  shows \"x \\<oplus> x = bot\"", "lemma xor_left_inverse [simp]:\n  fixes x :: \"'a :: boolean_algebra\"\n  shows \"x \\<oplus> x \\<oplus> y = y\"", "lemmas xor_ac = xor_assoc xor_commute xor_left_commute", "lemma xor_list_unfold:\n  \"xs [\\<oplus>] ys = (case xs of [] \\<Rightarrow> [] | x # xs' \\<Rightarrow> (case ys of [] \\<Rightarrow> [] | y # ys' \\<Rightarrow> x \\<oplus> y # xs' [\\<oplus>] ys'))\"", "lemma xor_list_commute: fixes xs ys :: \"'a :: {semilattice_sup,semilattice_inf,uminus} list\"\n  shows \"xs [\\<oplus>] ys = ys [\\<oplus>] xs\"", "lemma xor_list_assoc [simp]: \n  fixes xs ys :: \"'a :: boolean_algebra list\"\n  shows \"(xs [\\<oplus>] ys) [\\<oplus>] zs = xs [\\<oplus>] (ys [\\<oplus>] zs)\"", "lemma xor_list_left_commute:\n  fixes xs ys zs :: \"'a :: boolean_algebra list\"\n  shows \"xs [\\<oplus>] (ys [\\<oplus>] zs) = ys [\\<oplus>] (xs [\\<oplus>] zs)\"", "lemmas xor_list_ac = xor_list_assoc xor_list_commute xor_list_left_commute", "lemma xor_list_inverse [simp]: \n  fixes xs :: \"'a :: boolean_algebra list\"\n  shows \"xs [\\<oplus>] xs = replicate (length xs) bot\"", "lemma xor_replicate_bot_right [simp]:\n  fixes xs :: \"'a :: boolean_algebra list\"\n  shows \"\\<lbrakk> length xs \\<le> n; x = bot \\<rbrakk> \\<Longrightarrow> xs [\\<oplus>] replicate n x = xs\"", "lemma xor_replicate_bot_left [simp]:\n  fixes xs :: \"'a :: boolean_algebra list\"\n  shows \"\\<lbrakk> length xs \\<le> n; x = bot \\<rbrakk> \\<Longrightarrow> replicate n x [\\<oplus>] xs = xs\"", "lemma xor_list_left_inverse [simp]:\n  fixes xs :: \"'a :: boolean_algebra list\"\n  shows \"length ys \\<le> length xs \\<Longrightarrow> xs [\\<oplus>] (xs [\\<oplus>] ys) = ys\"", "lemma length_xor_list [simp]: \"length (xor_list xs ys) = min (length xs) (length ys)\"", "lemma inj_on_xor_list_nlists [simp]:\n  fixes xs :: \"'a :: boolean_algebra list\"\n  shows \"n \\<le> length xs \\<Longrightarrow> inj_on (xor_list xs) (nlists UNIV n)\"", "lemma one_time_pad:\n  fixes xs :: \"_ :: boolean_algebra list\"\n  shows \"length xs \\<ge> n \\<Longrightarrow> map_spmf (xor_list xs) (spmf_of_set (nlists UNIV n)) = spmf_of_set (nlists UNIV n)\""], "translations": [["", "lemma xor_bool_def [iff]: fixes x y :: bool shows \"x \\<oplus> y \\<longleftrightarrow> x \\<noteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<oplus> y = (x \\<noteq> y)", "by(auto simp add: xor_def)"], ["", "lemma xor_commute:\n  fixes x y :: \"'a :: {semilattice_sup,semilattice_inf,uminus}\"\n  shows \"x \\<oplus> y = y \\<oplus> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<oplus> y = y \\<oplus> x", "by(simp add: xor_def sup.commute inf.commute)"], ["", "lemma xor_assoc:\n  fixes x y :: \"'a :: boolean_algebra\"\n  shows \"(x \\<oplus> y) \\<oplus> z = x \\<oplus> (y \\<oplus> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<oplus> y) \\<oplus> z = x \\<oplus> y \\<oplus> z", "by(simp add: xor_def inf_sup_aci inf_sup_distrib1 inf_sup_distrib2)"], ["", "lemma xor_left_commute:\n  fixes x y :: \"'a :: boolean_algebra\"\n  shows \"x \\<oplus> (y \\<oplus> z) = y \\<oplus> (x \\<oplus> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<oplus> y \\<oplus> z = y \\<oplus> x \\<oplus> z", "by (metis xor_assoc xor_commute)"], ["", "lemma [simp]:\n  fixes x :: \"'a :: boolean_algebra\"\n  shows xor_bot: \"x \\<oplus> bot = x\"\n  and bot_xor: \"bot \\<oplus> x = x\"\n  and xor_top: \"x \\<oplus> top = - x\"\n  and top_xor: \"top \\<oplus> x = - x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<oplus> \\<bottom> = x &&& \\<bottom> \\<oplus> x = x) &&&\n    x \\<oplus> \\<top> = - x &&& \\<top> \\<oplus> x = - x", "by(simp_all add: xor_def)"], ["", "lemma xor_inverse [simp]:\n  fixes x :: \"'a :: boolean_algebra\"\n  shows \"x \\<oplus> x = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<oplus> x = \\<bottom>", "by(simp add: xor_def)"], ["", "lemma xor_left_inverse [simp]:\n  fixes x :: \"'a :: boolean_algebra\"\n  shows \"x \\<oplus> x \\<oplus> y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<oplus> x \\<oplus> y = y", "by(metis xor_left_commute xor_inverse xor_bot)"], ["", "lemmas xor_ac = xor_assoc xor_commute xor_left_commute"], ["", "definition xor_list :: \"'a :: {uminus,inf,sup} list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"  (infixr \"[\\<oplus>]\" 67)\nwhere \"xor_list xs ys = map (case_prod (\\<oplus>)) (zip xs ys)\""], ["", "lemma xor_list_unfold:\n  \"xs [\\<oplus>] ys = (case xs of [] \\<Rightarrow> [] | x # xs' \\<Rightarrow> (case ys of [] \\<Rightarrow> [] | y # ys' \\<Rightarrow> x \\<oplus> y # xs' [\\<oplus>] ys'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs [\\<oplus>] ys =\n    (case xs of [] \\<Rightarrow> []\n     | x # xs' \\<Rightarrow>\n         case ys of [] \\<Rightarrow> []\n         | y # ys' \\<Rightarrow> x \\<oplus> y # xs' [\\<oplus>] ys')", "by(simp add: xor_list_def split: list.split)"], ["", "lemma xor_list_commute: fixes xs ys :: \"'a :: {semilattice_sup,semilattice_inf,uminus} list\"\n  shows \"xs [\\<oplus>] ys = ys [\\<oplus>] xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs [\\<oplus>] ys = ys [\\<oplus>] xs", "unfolding xor_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 (\\<oplus>) xs ys = map2 (\\<oplus>) ys xs", "by(subst zip_commute)(auto simp add: split_def xor_commute)"], ["", "lemma xor_list_assoc [simp]: \n  fixes xs ys :: \"'a :: boolean_algebra list\"\n  shows \"(xs [\\<oplus>] ys) [\\<oplus>] zs = xs [\\<oplus>] (ys [\\<oplus>] zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs [\\<oplus>] ys) [\\<oplus>] zs = xs [\\<oplus>] ys [\\<oplus>] zs", "unfolding xor_list_def zip_map1 zip_map2"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>(x, y). x \\<oplus> y)\n     (map2\n       (\\<lambda>x. Pair (case x of (x, xa) \\<Rightarrow> x \\<oplus> xa))\n       (zip xs ys) zs) =\n    map (\\<lambda>(x, y). x \\<oplus> y)\n     (map2\n       (\\<lambda>x y. (x, case y of (x, xa) \\<Rightarrow> x \\<oplus> xa)) xs\n       (zip ys zs))", "apply(subst (2) zip_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>(x, y). x \\<oplus> y)\n     (map (\\<lambda>(x, y).\n              (case x of (x, xa) \\<Rightarrow> x \\<oplus> xa, y))\n       (map2 (\\<lambda>x y. (y, x)) zs (zip xs ys))) =\n    map (\\<lambda>(x, y). x \\<oplus> y)\n     (map2\n       (\\<lambda>x y. (x, case y of (x, xa) \\<Rightarrow> x \\<oplus> xa)) xs\n       (zip ys zs))", "apply(subst zip_left_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>(x, y). x \\<oplus> y)\n     (map (\\<lambda>(x, y).\n              (case x of (x, xa) \\<Rightarrow> x \\<oplus> xa, y))\n       (map (\\<lambda>(x, y). (y, x))\n         (map2 (\\<lambda>y (x, z). (x, y, z)) xs (zip zs ys)))) =\n    map (\\<lambda>(x, y). x \\<oplus> y)\n     (map2\n       (\\<lambda>x y. (x, case y of (x, xa) \\<Rightarrow> x \\<oplus> xa)) xs\n       (zip ys zs))", "apply(subst (2) zip_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>(x, y). x \\<oplus> y)\n     (map (\\<lambda>(x, y).\n              (case x of (x, xa) \\<Rightarrow> x \\<oplus> xa, y))\n       (map (\\<lambda>(x, y). (y, x))\n         (map2 (\\<lambda>y (x, z). (x, y, z)) xs\n           (map2 (\\<lambda>x y. (y, x)) ys zs)))) =\n    map (\\<lambda>(x, y). x \\<oplus> y)\n     (map2\n       (\\<lambda>x y. (x, case y of (x, xa) \\<Rightarrow> x \\<oplus> xa)) xs\n       (zip ys zs))", "apply(auto simp add: zip_map2 split_def xor_assoc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma xor_list_left_commute:\n  fixes xs ys zs :: \"'a :: boolean_algebra list\"\n  shows \"xs [\\<oplus>] (ys [\\<oplus>] zs) = ys [\\<oplus>] (xs [\\<oplus>] zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs [\\<oplus>] ys [\\<oplus>] zs = ys [\\<oplus>] xs [\\<oplus>] zs", "by(metis xor_list_assoc xor_list_commute)"], ["", "lemmas xor_list_ac = xor_list_assoc xor_list_commute xor_list_left_commute"], ["", "lemma xor_list_inverse [simp]: \n  fixes xs :: \"'a :: boolean_algebra list\"\n  shows \"xs [\\<oplus>] xs = replicate (length xs) bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs [\\<oplus>] xs = replicate (length xs) \\<bottom>", "by(simp add: xor_list_def zip_same_conv_map o_def map_replicate_const)"], ["", "lemma xor_replicate_bot_right [simp]:\n  fixes xs :: \"'a :: boolean_algebra list\"\n  shows \"\\<lbrakk> length xs \\<le> n; x = bot \\<rbrakk> \\<Longrightarrow> xs [\\<oplus>] replicate n x = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs \\<le> n; x = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> xs [\\<oplus>] replicate n x = xs", "by(simp add: xor_list_def zip_replicate2 o_def)"], ["", "lemma xor_replicate_bot_left [simp]:\n  fixes xs :: \"'a :: boolean_algebra list\"\n  shows \"\\<lbrakk> length xs \\<le> n; x = bot \\<rbrakk> \\<Longrightarrow> replicate n x [\\<oplus>] xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs \\<le> n; x = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> replicate n x [\\<oplus>] xs = xs", "by(simp add: xor_list_commute)"], ["", "lemma xor_list_left_inverse [simp]:\n  fixes xs :: \"'a :: boolean_algebra list\"\n  shows \"length ys \\<le> length xs \\<Longrightarrow> xs [\\<oplus>] (xs [\\<oplus>] ys) = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ys \\<le> length xs \\<Longrightarrow>\n    xs [\\<oplus>] xs [\\<oplus>] ys = ys", "by(subst xor_list_assoc[symmetric])(simp)"], ["", "lemma length_xor_list [simp]: \"length (xor_list xs ys) = min (length xs) (length ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (xs [\\<oplus>] ys) = min (length xs) (length ys)", "by(simp add: xor_list_def)"], ["", "lemma inj_on_xor_list_nlists [simp]:\n  fixes xs :: \"'a :: boolean_algebra list\"\n  shows \"n \\<le> length xs \\<Longrightarrow> inj_on (xor_list xs) (nlists UNIV n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    inj_on (([\\<oplus>]) xs) (nlists UNIV n)", "apply(clarsimp simp add: inj_on_def in_nlists_UNIV)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>length x \\<le> length xs; length y = length x;\n        xs [\\<oplus>] x = xs [\\<oplus>] y; n = length x\\<rbrakk>\n       \\<Longrightarrow> x = y", "using xor_list_left_inverse"], ["proof (prove)\nusing this:\n  length ?ys \\<le> length ?xs \\<Longrightarrow>\n  ?xs [\\<oplus>] ?xs [\\<oplus>] ?ys = ?ys\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>length x \\<le> length xs; length y = length x;\n        xs [\\<oplus>] x = xs [\\<oplus>] y; n = length x\\<rbrakk>\n       \\<Longrightarrow> x = y", "by fastforce"], ["", "lemma one_time_pad:\n  fixes xs :: \"_ :: boolean_algebra list\"\n  shows \"length xs \\<ge> n \\<Longrightarrow> map_spmf (xor_list xs) (spmf_of_set (nlists UNIV n)) = spmf_of_set (nlists UNIV n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    map_spmf (([\\<oplus>]) xs) (spmf_of_set (nlists UNIV n)) =\n    spmf_of_set (nlists UNIV n)", "by(auto 4 3 simp add: in_nlists_UNIV intro: xor_list_left_inverse[symmetric] rev_image_eqI intro!: arg_cong[where f=spmf_of_set])"], ["", "end"]]}