{"file_name": "/home/qj213/afp-2021-10-22/thys/CryptHOL/Generat.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CryptHOL", "problem_names": ["lemma IO_code_cong: \"out = out' \\<Longrightarrow> IO out c = IO out' c\"", "lemma is_Pure_map_generat [simp]: \"is_Pure (map_generat f g h x) = is_Pure x\"", "lemma result_map_generat [simp]: \"is_Pure x \\<Longrightarrow> result (map_generat f g h x) = f (result x)\"", "lemma output_map_generat [simp]: \"\\<not> is_Pure x \\<Longrightarrow> output (map_generat f g h x) = g (output x)\"", "lemma continuation_map_generat [simp]: \"\\<not> is_Pure x \\<Longrightarrow> continuation (map_generat f g h x) = h (continuation x)\"", "lemma [simp]:\n  shows map_generat_eq_Pure:\n  \"map_generat f g h generat = Pure x \\<longleftrightarrow> (\\<exists>x'. generat = Pure x' \\<and> x = f x')\"\n  and Pure_eq_map_generat:\n  \"Pure x = map_generat f g h generat \\<longleftrightarrow> (\\<exists>x'. generat = Pure x' \\<and> x = f x')\"", "lemma [simp]:\n  shows map_generat_eq_IO:\n  \"map_generat f g h generat = IO out c \\<longleftrightarrow> (\\<exists>out' c'. generat = IO out' c' \\<and> out = g out' \\<and> c = h c')\"\n  and IO_eq_map_generat:\n  \"IO out c = map_generat f g h generat \\<longleftrightarrow> (\\<exists>out' c'. generat = IO out' c' \\<and> out = g out' \\<and> c = h c')\"", "lemma is_PureE [cases pred]:\n  assumes \"is_Pure generat\"\n  obtains (Pure) x where \"generat = Pure x\"", "lemma not_is_PureE:\n  assumes \"\\<not> is_Pure generat\"\n  obtains (IO) out c where \"generat = IO out c\"", "lemma rel_generatI:\n  \"\\<lbrakk> is_Pure x \\<longleftrightarrow> is_Pure y;\n     \\<lbrakk> is_Pure x; is_Pure y \\<rbrakk> \\<Longrightarrow> A (result x) (result y);\n     \\<lbrakk> \\<not> is_Pure x; \\<not> is_Pure y \\<rbrakk> \\<Longrightarrow> Out (output x) (output y) \\<and> R (continuation x) (continuation y) \\<rbrakk>\n  \\<Longrightarrow> rel_generat A Out R x y\"", "lemma rel_generatD':\n  \"rel_generat A Out R x y\n  \\<Longrightarrow> (is_Pure x \\<longleftrightarrow> is_Pure y) \\<and> \n     (is_Pure x \\<longrightarrow> is_Pure y \\<longrightarrow> A (result x) (result y)) \\<and> \n     (\\<not> is_Pure x \\<longrightarrow> \\<not> is_Pure y \\<longrightarrow> Out (output x) (output y) \\<and> R (continuation x) (continuation y))\"", "lemma rel_generatD:\n  assumes \"rel_generat A Out R x y\"\n  shows rel_generat_is_PureD: \"is_Pure x \\<longleftrightarrow> is_Pure y\"\n  and rel_generat_resultD: \"is_Pure x \\<or> is_Pure y \\<Longrightarrow> A (result x) (result y)\"\n  and rel_generat_outputD: \"\\<not> is_Pure x \\<or> \\<not> is_Pure y \\<Longrightarrow> Out (output x) (output y)\"\n  and rel_generat_continuationD: \"\\<not> is_Pure x \\<or> \\<not> is_Pure y \\<Longrightarrow> R (continuation x) (continuation y)\"", "lemma rel_generat_mono:\n  \"\\<lbrakk> rel_generat A B C x y; \\<And>x y. A x y \\<Longrightarrow> A' x y; \\<And>x y. B x y \\<Longrightarrow> B' x y; \\<And>x y. C x y \\<Longrightarrow> C' x y \\<rbrakk>\n  \\<Longrightarrow> rel_generat A' B' C' x y\"", "lemma rel_generat_mono' [mono]:\n  \"\\<lbrakk> \\<And>x y. A x y \\<longrightarrow> A' x y; \\<And>x y. B x y \\<longrightarrow> B' x y; \\<And>x y. C x y \\<longrightarrow> C' x y \\<rbrakk>\n  \\<Longrightarrow> rel_generat A B C x y \\<longrightarrow> rel_generat A' B' C' x y\"", "lemma rel_generat_same:\n  \"rel_generat A B C r r \\<longleftrightarrow> \n  (\\<forall>x \\<in> generat_pures r. A x x) \\<and>\n  (\\<forall>out \\<in> generat_outs r. B out out) \\<and>\n  (\\<forall>c \\<in>generat_conts r. C c c)\"", "lemma rel_generat_reflI:\n  \"\\<lbrakk> \\<And>y. y \\<in> generat_pures x \\<Longrightarrow> A y y; \n     \\<And>out. out \\<in> generat_outs x \\<Longrightarrow> B out out;\n     \\<And>cont. cont \\<in> generat_conts x \\<Longrightarrow> C cont cont \\<rbrakk>\n  \\<Longrightarrow> rel_generat A B C x x\"", "lemma reflp_rel_generat [simp]: \"reflp (rel_generat A B C) \\<longleftrightarrow> reflp A \\<and> reflp B \\<and> reflp C\"", "lemma transp_rel_generatI:\n  assumes \"transp A\" \"transp B\" \"transp C\"\n  shows \"transp (rel_generat A B C)\"", "lemma rel_generat_inf:\n  \"inf (rel_generat A B C) (rel_generat A' B' C') = rel_generat (inf A A') (inf B B') (inf C C')\"\n  (is \"?lhs = ?rhs\")", "lemma rel_generat_Pure1: \"rel_generat A B C (Pure x) = (\\<lambda>r. \\<exists>y. r = Pure y \\<and> A x y)\"", "lemma rel_generat_IO1: \"rel_generat A B C (IO out c) = (\\<lambda>r. \\<exists>out' c'. r = IO out' c' \\<and> B out out' \\<and> C c c')\"", "lemma not_is_Pure_conv: \"\\<not> is_Pure r \\<longleftrightarrow> (\\<exists>out c. r = IO out c)\"", "lemma finite_generat_outs [simp]: \"finite (generat_outs generat)\"", "lemma countable_generat_outs [simp]: \"countable (generat_outs generat)\"", "lemma case_map_generat:\n  \"case_generat pure io (map_generat a b d r) = \n   case_generat (pure \\<circ> a) (\\<lambda>out. io (b out) \\<circ> d) r\"", "lemma continuation_in_generat_conts:\n  \"\\<not> is_Pure r \\<Longrightarrow> continuation r \\<in> generat_conts r\"", "lemma dest_IO_eq_Some_iff [simp]: \"dest_IO generat = Some (out, c) \\<longleftrightarrow> generat = IO out c\"", "lemma dest_IO_eq_None_iff [simp]: \"dest_IO generat = None \\<longleftrightarrow> is_Pure generat\"", "lemma dest_IO_comp_Pure [simp]: \"dest_IO \\<circ> Pure = (\\<lambda>_. None)\"", "lemma dom_dest_IO: \"dom dest_IO = {x. \\<not> is_Pure x}\"", "lemma is_Pure_generat_lub [simp]:\n  \"is_Pure (generat_lub lub1 lub2 lub3 A) \\<longleftrightarrow> (\\<exists>x\\<in>A. is_Pure x)\"", "lemma result_generat_lub [simp]:\n  \"\\<exists>x\\<in>A. is_Pure x \\<Longrightarrow> result (generat_lub lub1 lub2 lub3 A) = lub1 (result ` (A \\<inter> {f. is_Pure f}))\"", "lemma output_generat_lub: \n  \"\\<forall>x\\<in>A. \\<not> is_Pure x \\<Longrightarrow> output (generat_lub lub1 lub2 lub3 A) = lub2 (output ` (A \\<inter> {f. \\<not> is_Pure f}))\"", "lemma continuation_generat_lub:\n  \"\\<forall>x\\<in>A. \\<not> is_Pure x \\<Longrightarrow> continuation (generat_lub lub1 lub2 lub3 A) = lub3 (continuation ` (A \\<inter> {f. \\<not> is_Pure f}))\"", "lemma generat_lub_map [simp]:\n  \"generat_lub lub1 lub2 lub3 (map_generat f g h ` A) = generat_lub (lub1 \\<circ> (`) f) (lub2 \\<circ> (`) g) (lub3 \\<circ> (`) h) A\"", "lemma map_generat_lub [simp]:\n  \"map_generat f g h (generat_lub lub1 lub2 lub3 A) = generat_lub (f \\<circ> lub1) (g \\<circ> lub2) (h \\<circ> lub3) A\"", "lemma rel_witness_generat: \n  assumes \"rel_generat A C R x y\"\n  shows pures_rel_witness_generat: \"generat_pures (rel_witness_generat (x, y)) \\<subseteq> {(a, b). A a b}\"\n    and outs_rel_witness_generat: \"generat_outs (rel_witness_generat (x, y)) \\<subseteq> {(c, d). C c d}\"\n    and conts_rel_witness_generat: \"generat_conts (rel_witness_generat (x, y)) \\<subseteq> {(e, f). R e f}\"\n    and map1_rel_witness_generat: \"map_generat fst fst fst (rel_witness_generat (x, y)) = x\"\n    and map2_rel_witness_generat: \"map_generat snd snd snd (rel_witness_generat (x, y)) = y\"", "lemmas set_rel_witness_generat = pures_rel_witness_generat outs_rel_witness_generat conts_rel_witness_generat", "lemma rel_witness_generat1:\n  assumes \"rel_generat A C R x y\"\n  shows \"rel_generat (\\<lambda>a (a', b). a = a' \\<and> A a' b) (\\<lambda>c (c', d). c = c' \\<and> C c' d) (\\<lambda>r (r', s). r = r' \\<and> R r' s) x (rel_witness_generat (x, y))\"", "lemma rel_witness_generat2:\n  assumes \"rel_generat A C R x y\"\n  shows \"rel_generat (\\<lambda>(a, b') b. b = b' \\<and> A a b') (\\<lambda>(c, d') d. d = d' \\<and> C c d') (\\<lambda>(r, s') s. s = s' \\<and> R r s') (rel_witness_generat (x, y)) y\""], "translations": [["", "lemma IO_code_cong: \"out = out' \\<Longrightarrow> IO out c = IO out' c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out = out' \\<Longrightarrow> IO out c = IO out' c", "by simp"], ["", "setup \\<open>Code_Simp.map_ss (Simplifier.add_cong @{thm IO_code_cong})\\<close>"], ["", "lemma is_Pure_map_generat [simp]: \"is_Pure (map_generat f g h x) = is_Pure x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Pure (map_generat f g h x) = is_Pure x", "by(cases x) simp_all"], ["", "lemma result_map_generat [simp]: \"is_Pure x \\<Longrightarrow> result (map_generat f g h x) = f (result x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Pure x \\<Longrightarrow>\n    generat.result (map_generat f g h x) = f (generat.result x)", "by(cases x) simp_all"], ["", "lemma output_map_generat [simp]: \"\\<not> is_Pure x \\<Longrightarrow> output (map_generat f g h x) = g (output x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_Pure x \\<Longrightarrow>\n    generat.output (map_generat f g h x) = g (generat.output x)", "by(cases x) simp_all"], ["", "lemma continuation_map_generat [simp]: \"\\<not> is_Pure x \\<Longrightarrow> continuation (map_generat f g h x) = h (continuation x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_Pure x \\<Longrightarrow>\n    continuation (map_generat f g h x) = h (continuation x)", "by(cases x) simp_all"], ["", "lemma [simp]:\n  shows map_generat_eq_Pure:\n  \"map_generat f g h generat = Pure x \\<longleftrightarrow> (\\<exists>x'. generat = Pure x' \\<and> x = f x')\"\n  and Pure_eq_map_generat:\n  \"Pure x = map_generat f g h generat \\<longleftrightarrow> (\\<exists>x'. generat = Pure x' \\<and> x = f x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_generat f g h generat = Pure x) =\n    (\\<exists>x'. generat = Pure x' \\<and> x = f x') &&&\n    (Pure x = map_generat f g h generat) =\n    (\\<exists>x'. generat = Pure x' \\<and> x = f x')", "by(cases generat; auto; fail)+"], ["", "lemma [simp]:\n  shows map_generat_eq_IO:\n  \"map_generat f g h generat = IO out c \\<longleftrightarrow> (\\<exists>out' c'. generat = IO out' c' \\<and> out = g out' \\<and> c = h c')\"\n  and IO_eq_map_generat:\n  \"IO out c = map_generat f g h generat \\<longleftrightarrow> (\\<exists>out' c'. generat = IO out' c' \\<and> out = g out' \\<and> c = h c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_generat f g h generat = IO out c) =\n    (\\<exists>out' c'.\n        generat = IO out' c' \\<and> out = g out' \\<and> c = h c') &&&\n    (IO out c = map_generat f g h generat) =\n    (\\<exists>out' c'.\n        generat = IO out' c' \\<and> out = g out' \\<and> c = h c')", "by(cases generat; auto; fail)+"], ["", "lemma is_PureE [cases pred]:\n  assumes \"is_Pure generat\"\n  obtains (Pure) x where \"generat = Pure x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. generat = Pure x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  is_Pure generat\n\ngoal (1 subgoal):\n 1. (\\<And>x. generat = Pure x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: is_Pure_def)"], ["", "lemma not_is_PureE:\n  assumes \"\\<not> is_Pure generat\"\n  obtains (IO) out c where \"generat = IO out c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        generat = IO out c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<not> is_Pure generat\n\ngoal (1 subgoal):\n 1. (\\<And>out c.\n        generat = IO out c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases generat) auto"], ["", "lemma rel_generatI:\n  \"\\<lbrakk> is_Pure x \\<longleftrightarrow> is_Pure y;\n     \\<lbrakk> is_Pure x; is_Pure y \\<rbrakk> \\<Longrightarrow> A (result x) (result y);\n     \\<lbrakk> \\<not> is_Pure x; \\<not> is_Pure y \\<rbrakk> \\<Longrightarrow> Out (output x) (output y) \\<and> R (continuation x) (continuation y) \\<rbrakk>\n  \\<Longrightarrow> rel_generat A Out R x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_Pure x = is_Pure y;\n     \\<lbrakk>is_Pure x; is_Pure y\\<rbrakk>\n     \\<Longrightarrow> A (generat.result x) (generat.result y);\n     \\<lbrakk>\\<not> is_Pure x; \\<not> is_Pure y\\<rbrakk>\n     \\<Longrightarrow> Out (generat.output x) (generat.output y) \\<and>\n                       R (continuation x) (continuation y)\\<rbrakk>\n    \\<Longrightarrow> rel_generat A Out R x y", "by(cases x y rule: generat.exhaust[case_product generat.exhaust]) simp_all"], ["", "lemma rel_generatD':\n  \"rel_generat A Out R x y\n  \\<Longrightarrow> (is_Pure x \\<longleftrightarrow> is_Pure y) \\<and> \n     (is_Pure x \\<longrightarrow> is_Pure y \\<longrightarrow> A (result x) (result y)) \\<and> \n     (\\<not> is_Pure x \\<longrightarrow> \\<not> is_Pure y \\<longrightarrow> Out (output x) (output y) \\<and> R (continuation x) (continuation y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_generat A Out R x y \\<Longrightarrow>\n    is_Pure x = is_Pure y \\<and>\n    (is_Pure x \\<longrightarrow>\n     is_Pure y \\<longrightarrow>\n     A (generat.result x) (generat.result y)) \\<and>\n    (\\<not> is_Pure x \\<longrightarrow>\n     \\<not> is_Pure y \\<longrightarrow>\n     Out (generat.output x) (generat.output y) \\<and>\n     R (continuation x) (continuation y))", "by(cases x y rule: generat.exhaust[case_product generat.exhaust]) simp_all"], ["", "lemma rel_generatD:\n  assumes \"rel_generat A Out R x y\"\n  shows rel_generat_is_PureD: \"is_Pure x \\<longleftrightarrow> is_Pure y\"\n  and rel_generat_resultD: \"is_Pure x \\<or> is_Pure y \\<Longrightarrow> A (result x) (result y)\"\n  and rel_generat_outputD: \"\\<not> is_Pure x \\<or> \\<not> is_Pure y \\<Longrightarrow> Out (output x) (output y)\"\n  and rel_generat_continuationD: \"\\<not> is_Pure x \\<or> \\<not> is_Pure y \\<Longrightarrow> R (continuation x) (continuation y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_Pure x = is_Pure y &&&\n     (is_Pure x \\<or> is_Pure y \\<Longrightarrow>\n      A (generat.result x) (generat.result y))) &&&\n    (\\<not> is_Pure x \\<or> \\<not> is_Pure y \\<Longrightarrow>\n     Out (generat.output x) (generat.output y)) &&&\n    (\\<not> is_Pure x \\<or> \\<not> is_Pure y \\<Longrightarrow>\n     R (continuation x) (continuation y))", "using rel_generatD'[OF assms]"], ["proof (prove)\nusing this:\n  is_Pure x = is_Pure y \\<and>\n  (is_Pure x \\<longrightarrow>\n   is_Pure y \\<longrightarrow>\n   A (generat.result x) (generat.result y)) \\<and>\n  (\\<not> is_Pure x \\<longrightarrow>\n   \\<not> is_Pure y \\<longrightarrow>\n   Out (generat.output x) (generat.output y) \\<and>\n   R (continuation x) (continuation y))\n\ngoal (1 subgoal):\n 1. (is_Pure x = is_Pure y &&&\n     (is_Pure x \\<or> is_Pure y \\<Longrightarrow>\n      A (generat.result x) (generat.result y))) &&&\n    (\\<not> is_Pure x \\<or> \\<not> is_Pure y \\<Longrightarrow>\n     Out (generat.output x) (generat.output y)) &&&\n    (\\<not> is_Pure x \\<or> \\<not> is_Pure y \\<Longrightarrow>\n     R (continuation x) (continuation y))", "by simp_all"], ["", "lemma rel_generat_mono:\n  \"\\<lbrakk> rel_generat A B C x y; \\<And>x y. A x y \\<Longrightarrow> A' x y; \\<And>x y. B x y \\<Longrightarrow> B' x y; \\<And>x y. C x y \\<Longrightarrow> C' x y \\<rbrakk>\n  \\<Longrightarrow> rel_generat A' B' C' x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel_generat A B C x y;\n     \\<And>x y. A x y \\<Longrightarrow> A' x y;\n     \\<And>x y. B x y \\<Longrightarrow> B' x y;\n     \\<And>x y. C x y \\<Longrightarrow> C' x y\\<rbrakk>\n    \\<Longrightarrow> rel_generat A' B' C' x y", "using generat.rel_mono[of A A' B B' C C']"], ["proof (prove)\nusing this:\n  \\<lbrakk>A \\<le> A'; B \\<le> B'; C \\<le> C'\\<rbrakk>\n  \\<Longrightarrow> rel_generat A B C \\<le> rel_generat A' B' C'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rel_generat A B C x y;\n     \\<And>x y. A x y \\<Longrightarrow> A' x y;\n     \\<And>x y. B x y \\<Longrightarrow> B' x y;\n     \\<And>x y. C x y \\<Longrightarrow> C' x y\\<rbrakk>\n    \\<Longrightarrow> rel_generat A' B' C' x y", "by(auto simp add: le_fun_def)"], ["", "lemma rel_generat_mono' [mono]:\n  \"\\<lbrakk> \\<And>x y. A x y \\<longrightarrow> A' x y; \\<And>x y. B x y \\<longrightarrow> B' x y; \\<And>x y. C x y \\<longrightarrow> C' x y \\<rbrakk>\n  \\<Longrightarrow> rel_generat A B C x y \\<longrightarrow> rel_generat A' B' C' x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y. A x y \\<longrightarrow> A' x y;\n     \\<And>x y. B x y \\<longrightarrow> B' x y;\n     \\<And>x y. C x y \\<longrightarrow> C' x y\\<rbrakk>\n    \\<Longrightarrow> rel_generat A B C x y \\<longrightarrow>\n                      rel_generat A' B' C' x y", "by(blast intro: rel_generat_mono)"], ["", "lemma rel_generat_same:\n  \"rel_generat A B C r r \\<longleftrightarrow> \n  (\\<forall>x \\<in> generat_pures r. A x x) \\<and>\n  (\\<forall>out \\<in> generat_outs r. B out out) \\<and>\n  (\\<forall>c \\<in>generat_conts r. C c c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_generat A B C r r =\n    ((\\<forall>x\\<in>generat_pures r. A x x) \\<and>\n     (\\<forall>out\\<in>generat_outs r. B out out) \\<and>\n     (\\<forall>c\\<in>generat_conts r. C c c))", "by(cases r)(auto simp add: rel_fun_def)"], ["", "lemma rel_generat_reflI:\n  \"\\<lbrakk> \\<And>y. y \\<in> generat_pures x \\<Longrightarrow> A y y; \n     \\<And>out. out \\<in> generat_outs x \\<Longrightarrow> B out out;\n     \\<And>cont. cont \\<in> generat_conts x \\<Longrightarrow> C cont cont \\<rbrakk>\n  \\<Longrightarrow> rel_generat A B C x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y. y \\<in> generat_pures x \\<Longrightarrow> A y y;\n     \\<And>out. out \\<in> generat_outs x \\<Longrightarrow> B out out;\n     \\<And>cont.\n        cont \\<in> generat_conts x \\<Longrightarrow> C cont cont\\<rbrakk>\n    \\<Longrightarrow> rel_generat A B C x x", "by(cases x) auto"], ["", "lemma reflp_rel_generat [simp]: \"reflp (rel_generat A B C) \\<longleftrightarrow> reflp A \\<and> reflp B \\<and> reflp C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflp (rel_generat A B C) = (reflp A \\<and> reflp B \\<and> reflp C)", "by(auto 4 3 intro!: reflpI rel_generatI dest: reflpD reflpD[where x=\"Pure _\"] reflpD[where x=\"IO _ _\"])"], ["", "lemma transp_rel_generatI:\n  assumes \"transp A\" \"transp B\" \"transp C\"\n  shows \"transp (rel_generat A B C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transp (rel_generat A B C)", "by(rule transpI)(auto 6 5 dest: rel_generatD' intro!: rel_generatI intro: assms[THEN transpD] simp add: rel_fun_def)"], ["", "lemma rel_generat_inf:\n  \"inf (rel_generat A B C) (rel_generat A' B' C') = rel_generat (inf A A') (inf B B') (inf C C')\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_generat A B C \\<sqinter> rel_generat A' B' C' =\n    rel_generat (A \\<sqinter> A') (B \\<sqinter> B') (C \\<sqinter> C')", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. rel_generat A B C \\<sqinter> rel_generat A' B' C'\n    \\<le> rel_generat (A \\<sqinter> A') (B \\<sqinter> B') (C \\<sqinter> C')\n 2. rel_generat (A \\<sqinter> A') (B \\<sqinter> B') (C \\<sqinter> C')\n    \\<le> rel_generat A B C \\<sqinter> rel_generat A' B' C'", "show \"?lhs \\<le> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_generat A B C \\<sqinter> rel_generat A' B' C'\n    \\<le> rel_generat (A \\<sqinter> A') (B \\<sqinter> B') (C \\<sqinter> C')", "by(auto elim!: generat.rel_cases simp add: rel_fun_def)"], ["proof (state)\nthis:\n  rel_generat A B C \\<sqinter> rel_generat A' B' C'\n  \\<le> rel_generat (A \\<sqinter> A') (B \\<sqinter> B') (C \\<sqinter> C')\n\ngoal (1 subgoal):\n 1. rel_generat (A \\<sqinter> A') (B \\<sqinter> B') (C \\<sqinter> C')\n    \\<le> rel_generat A B C \\<sqinter> rel_generat A' B' C'", "qed(auto elim: rel_generat_mono)"], ["", "lemma rel_generat_Pure1: \"rel_generat A B C (Pure x) = (\\<lambda>r. \\<exists>y. r = Pure y \\<and> A x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_generat A B C (Pure x) =\n    (\\<lambda>r. \\<exists>y. r = Pure y \\<and> A x y)", "by(rule ext)(case_tac r, simp_all)"], ["", "lemma rel_generat_IO1: \"rel_generat A B C (IO out c) = (\\<lambda>r. \\<exists>out' c'. r = IO out' c' \\<and> B out out' \\<and> C c c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_generat A B C (IO out c) =\n    (\\<lambda>r.\n        \\<exists>out' c'. r = IO out' c' \\<and> B out out' \\<and> C c c')", "by(rule ext)(case_tac r, simp_all)"], ["", "lemma not_is_Pure_conv: \"\\<not> is_Pure r \\<longleftrightarrow> (\\<exists>out c. r = IO out c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> is_Pure r) = (\\<exists>out c. r = IO out c)", "by(cases r) auto"], ["", "lemma finite_generat_outs [simp]: \"finite (generat_outs generat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (generat_outs generat)", "by(cases generat) auto"], ["", "lemma countable_generat_outs [simp]: \"countable (generat_outs generat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (generat_outs generat)", "by(simp add: countable_finite)"], ["", "lemma case_map_generat:\n  \"case_generat pure io (map_generat a b d r) = \n   case_generat (pure \\<circ> a) (\\<lambda>out. io (b out) \\<circ> d) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case map_generat a b d r of Pure x \\<Rightarrow> pure x\n     | IO x xa \\<Rightarrow> io x xa) =\n    (case r of Pure x \\<Rightarrow> (pure \\<circ> a) x\n     | IO out x \\<Rightarrow> (io (b out) \\<circ> d) x)", "by(cases r) simp_all"], ["", "lemma continuation_in_generat_conts:\n  \"\\<not> is_Pure r \\<Longrightarrow> continuation r \\<in> generat_conts r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_Pure r \\<Longrightarrow> continuation r \\<in> generat_conts r", "by(cases r) auto"], ["", "fun dest_IO :: \"('a, 'out, 'c) generat \\<Rightarrow> ('out \\<times> 'c) option\"\nwhere\n  \"dest_IO (Pure _) = None\"\n| \"dest_IO (IO out c) = Some (out, c)\""], ["", "lemma dest_IO_eq_Some_iff [simp]: \"dest_IO generat = Some (out, c) \\<longleftrightarrow> generat = IO out c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dest_IO generat = Some (out, c)) = (generat = IO out c)", "by(cases generat) simp_all"], ["", "lemma dest_IO_eq_None_iff [simp]: \"dest_IO generat = None \\<longleftrightarrow> is_Pure generat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dest_IO generat = None) = is_Pure generat", "by(cases generat) simp_all"], ["", "lemma dest_IO_comp_Pure [simp]: \"dest_IO \\<circ> Pure = (\\<lambda>_. None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dest_IO \\<circ> Pure = Map.empty", "by(simp add: fun_eq_iff)"], ["", "lemma dom_dest_IO: \"dom dest_IO = {x. \\<not> is_Pure x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom dest_IO = {x. \\<not> is_Pure x}", "by(auto simp add: not_is_Pure_conv)"], ["", "definition generat_lub :: \"('a set \\<Rightarrow> 'b) \\<Rightarrow> ('out set \\<Rightarrow> 'out') \\<Rightarrow> ('cont set \\<Rightarrow> 'cont') \n  \\<Rightarrow> ('a, 'out, 'cont) generat set \\<Rightarrow> ('b, 'out', 'cont') generat\"\nwhere\n  \"generat_lub lub1 lub2 lub3 A =\n  (if \\<exists>x\\<in>A. is_Pure x then Pure (lub1 (result ` (A \\<inter> {f. is_Pure f})))\n   else IO (lub2 (output ` (A \\<inter> {f. \\<not> is_Pure f}))) (lub3 (continuation ` (A \\<inter> {f. \\<not> is_Pure f}))))\""], ["", "lemma is_Pure_generat_lub [simp]:\n  \"is_Pure (generat_lub lub1 lub2 lub3 A) \\<longleftrightarrow> (\\<exists>x\\<in>A. is_Pure x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Pure (generat_lub lub1 lub2 lub3 A) = (\\<exists>x\\<in>A. is_Pure x)", "by(simp add: generat_lub_def)"], ["", "lemma result_generat_lub [simp]:\n  \"\\<exists>x\\<in>A. is_Pure x \\<Longrightarrow> result (generat_lub lub1 lub2 lub3 A) = lub1 (result ` (A \\<inter> {f. is_Pure f}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>A. is_Pure x \\<Longrightarrow>\n    generat.result (generat_lub lub1 lub2 lub3 A) =\n    lub1 (generat.result ` (A \\<inter> {f. is_Pure f}))", "by(simp add: generat_lub_def)"], ["", "lemma output_generat_lub: \n  \"\\<forall>x\\<in>A. \\<not> is_Pure x \\<Longrightarrow> output (generat_lub lub1 lub2 lub3 A) = lub2 (output ` (A \\<inter> {f. \\<not> is_Pure f}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A. \\<not> is_Pure x \\<Longrightarrow>\n    generat.output (generat_lub lub1 lub2 lub3 A) =\n    lub2 (generat.output ` (A \\<inter> {f. \\<not> is_Pure f}))", "by(simp add: generat_lub_def)"], ["", "lemma continuation_generat_lub:\n  \"\\<forall>x\\<in>A. \\<not> is_Pure x \\<Longrightarrow> continuation (generat_lub lub1 lub2 lub3 A) = lub3 (continuation ` (A \\<inter> {f. \\<not> is_Pure f}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A. \\<not> is_Pure x \\<Longrightarrow>\n    continuation (generat_lub lub1 lub2 lub3 A) =\n    lub3 (continuation ` (A \\<inter> {f. \\<not> is_Pure f}))", "by(simp add: generat_lub_def)"], ["", "lemma generat_lub_map [simp]:\n  \"generat_lub lub1 lub2 lub3 (map_generat f g h ` A) = generat_lub (lub1 \\<circ> (`) f) (lub2 \\<circ> (`) g) (lub3 \\<circ> (`) h) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generat_lub lub1 lub2 lub3 (map_generat f g h ` A) =\n    generat_lub (lub1 \\<circ> (`) f) (lub2 \\<circ> (`) g)\n     (lub3 \\<circ> (`) h) A", "by(auto 4 3 simp add: generat_lub_def intro: arg_cong[where f=lub1] arg_cong[where f=lub2] arg_cong[where f=lub3] rev_image_eqI del: ext intro!: ext)"], ["", "lemma map_generat_lub [simp]:\n  \"map_generat f g h (generat_lub lub1 lub2 lub3 A) = generat_lub (f \\<circ> lub1) (g \\<circ> lub2) (h \\<circ> lub3) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_generat f g h (generat_lub lub1 lub2 lub3 A) =\n    generat_lub (f \\<circ> lub1) (g \\<circ> lub2) (h \\<circ> lub3) A", "by(simp add: generat_lub_def o_def)"], ["", "abbreviation generat_lub' :: \"('cont set \\<Rightarrow> 'cont') \\<Rightarrow> ('a, 'out, 'cont) generat set \\<Rightarrow> ('a, 'out, 'cont') generat\"\nwhere \"generat_lub' \\<equiv> generat_lub (\\<lambda>A. THE x. x \\<in> A) (\\<lambda>A. THE x. x \\<in> A)\""], ["", "fun rel_witness_generat :: \"('a, 'c, 'e) generat \\<times> ('b, 'd, 'f) generat \\<Rightarrow> ('a \\<times> 'b, 'c \\<times> 'd, 'e \\<times> 'f) generat\" where\n  \"rel_witness_generat (Pure x, Pure y) = Pure (x, y)\"\n| \"rel_witness_generat (IO out c, IO out' c') = IO (out, out') (c, c')\""], ["", "lemma rel_witness_generat: \n  assumes \"rel_generat A C R x y\"\n  shows pures_rel_witness_generat: \"generat_pures (rel_witness_generat (x, y)) \\<subseteq> {(a, b). A a b}\"\n    and outs_rel_witness_generat: \"generat_outs (rel_witness_generat (x, y)) \\<subseteq> {(c, d). C c d}\"\n    and conts_rel_witness_generat: \"generat_conts (rel_witness_generat (x, y)) \\<subseteq> {(e, f). R e f}\"\n    and map1_rel_witness_generat: \"map_generat fst fst fst (rel_witness_generat (x, y)) = x\"\n    and map2_rel_witness_generat: \"map_generat snd snd snd (rel_witness_generat (x, y)) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (generat_pures (rel_witness_generat (x, y))\n     \\<subseteq> {(a, b). A a b} &&&\n     generat_outs (rel_witness_generat (x, y))\n     \\<subseteq> {(c, d). C c d}) &&&\n    generat_conts (rel_witness_generat (x, y))\n    \\<subseteq> {(e, f). R e f} &&&\n    map_generat fst fst fst (rel_witness_generat (x, y)) = x &&&\n    map_generat snd snd snd (rel_witness_generat (x, y)) = y", "using assms"], ["proof (prove)\nusing this:\n  rel_generat A C R x y\n\ngoal (1 subgoal):\n 1. (generat_pures (rel_witness_generat (x, y))\n     \\<subseteq> {(a, b). A a b} &&&\n     generat_outs (rel_witness_generat (x, y))\n     \\<subseteq> {(c, d). C c d}) &&&\n    generat_conts (rel_witness_generat (x, y))\n    \\<subseteq> {(e, f). R e f} &&&\n    map_generat fst fst fst (rel_witness_generat (x, y)) = x &&&\n    map_generat snd snd snd (rel_witness_generat (x, y)) = y", "by(cases; simp; fail)+"], ["", "lemmas set_rel_witness_generat = pures_rel_witness_generat outs_rel_witness_generat conts_rel_witness_generat"], ["", "lemma rel_witness_generat1:\n  assumes \"rel_generat A C R x y\"\n  shows \"rel_generat (\\<lambda>a (a', b). a = a' \\<and> A a' b) (\\<lambda>c (c', d). c = c' \\<and> C c' d) (\\<lambda>r (r', s). r = r' \\<and> R r' s) x (rel_witness_generat (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_generat (\\<lambda>a (a', b). a = a' \\<and> A a' b)\n     (\\<lambda>c (c', d). c = c' \\<and> C c' d)\n     (\\<lambda>r (r', s). r = r' \\<and> R r' s) x\n     (rel_witness_generat (x, y))", "using map1_rel_witness_generat[OF assms, symmetric]"], ["proof (prove)\nusing this:\n  x = map_generat fst fst fst (rel_witness_generat (x, y))\n\ngoal (1 subgoal):\n 1. rel_generat (\\<lambda>a (a', b). a = a' \\<and> A a' b)\n     (\\<lambda>c (c', d). c = c' \\<and> C c' d)\n     (\\<lambda>r (r', s). r = r' \\<and> R r' s) x\n     (rel_witness_generat (x, y))", "unfolding generat.rel_eq[symmetric] generat.rel_map"], ["proof (prove)\nusing this:\n  rel_generat (\\<lambda>x y. x = fst y) (\\<lambda>x y. x = fst y)\n   (\\<lambda>x y. x = fst y) x (rel_witness_generat (x, y))\n\ngoal (1 subgoal):\n 1. rel_generat (\\<lambda>a (a', b). a = a' \\<and> A a' b)\n     (\\<lambda>c (c', d). c = c' \\<and> C c' d)\n     (\\<lambda>r (r', s). r = r' \\<and> R r' s) x\n     (rel_witness_generat (x, y))", "by(rule generat.rel_mono_strong)(auto dest: set_rel_witness_generat[OF assms, THEN subsetD])"], ["", "lemma rel_witness_generat2:\n  assumes \"rel_generat A C R x y\"\n  shows \"rel_generat (\\<lambda>(a, b') b. b = b' \\<and> A a b') (\\<lambda>(c, d') d. d = d' \\<and> C c d') (\\<lambda>(r, s') s. s = s' \\<and> R r s') (rel_witness_generat (x, y)) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_generat (\\<lambda>(a, b') b. b = b' \\<and> A a b')\n     (\\<lambda>(c, d') d. d = d' \\<and> C c d')\n     (\\<lambda>(r, s') s. s = s' \\<and> R r s') (rel_witness_generat (x, y))\n     y", "using map2_rel_witness_generat[OF assms]"], ["proof (prove)\nusing this:\n  map_generat snd snd snd (rel_witness_generat (x, y)) = y\n\ngoal (1 subgoal):\n 1. rel_generat (\\<lambda>(a, b') b. b = b' \\<and> A a b')\n     (\\<lambda>(c, d') d. d = d' \\<and> C c d')\n     (\\<lambda>(r, s') s. s = s' \\<and> R r s') (rel_witness_generat (x, y))\n     y", "unfolding generat.rel_eq[symmetric] generat.rel_map"], ["proof (prove)\nusing this:\n  rel_generat (\\<lambda>x. (=) (snd x)) (\\<lambda>x. (=) (snd x))\n   (\\<lambda>x. (=) (snd x)) (rel_witness_generat (x, y)) y\n\ngoal (1 subgoal):\n 1. rel_generat (\\<lambda>(a, b') b. b = b' \\<and> A a b')\n     (\\<lambda>(c, d') d. d = d' \\<and> C c d')\n     (\\<lambda>(r, s') s. s = s' \\<and> R r s') (rel_witness_generat (x, y))\n     y", "by(rule generat.rel_mono_strong)(auto dest: set_rel_witness_generat[OF assms, THEN subsetD])"], ["", "end"]]}