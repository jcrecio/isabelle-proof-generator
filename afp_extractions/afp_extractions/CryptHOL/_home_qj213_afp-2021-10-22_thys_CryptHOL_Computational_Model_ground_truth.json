{"file_name": "/home/qj213/afp-2021-10-22/thys/CryptHOL/Computational_Model.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CryptHOL", "problem_names": ["lemma plus_\\<I>_sel [simp]:\n  shows outs_plus_\\<I>: \"outs_\\<I> (plus_\\<I> \\<I>l \\<I>r) = outs_\\<I> \\<I>l <+> outs_\\<I> \\<I>r\"\n  and responses_plus_\\<I>_Inl: \"responses_\\<I> (plus_\\<I> \\<I>l \\<I>r) (Inl x) = Inl ` responses_\\<I> \\<I>l x\"\n  and responses_plus_\\<I>_Inr: \"responses_\\<I> (plus_\\<I> \\<I>l \\<I>r) (Inr y) = Inr ` responses_\\<I> \\<I>r y\"", "lemma vimage_Inl_Plus [simp]: \"Inl -` (A <+> B) = A\" \n  and vimage_Inr_Plus [simp]: \"Inr -` (A <+> B) = B\"", "lemma vimage_Inl_image_Inr: \"Inl -` Inr ` A = {}\"\n  and vimage_Inr_image_Inl: \"Inr -` Inl ` A = {}\"", "lemma plus_\\<I>_parametric [transfer_rule]:\n  \"(rel_\\<I> C R ===> rel_\\<I> C' R' ===> rel_\\<I> (rel_sum C C') (rel_sum R R')) plus_\\<I> plus_\\<I>\"", "lemma \\<I>_trivial_plus_\\<I> [simp]: \"\\<I>_trivial (\\<I>\\<^sub>1 \\<oplus>\\<^sub>\\<I> \\<I>\\<^sub>2) \\<longleftrightarrow> \\<I>_trivial \\<I>\\<^sub>1 \\<and> \\<I>_trivial \\<I>\\<^sub>2\"", "lemma map_\\<I>_plus_\\<I> [simp]: \n  \"map_\\<I> (map_sum f1 f2) (map_sum g1 g2) (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) = map_\\<I> f1 g1 \\<I>1 \\<oplus>\\<^sub>\\<I> map_\\<I> f2 g2 \\<I>2\"", "lemma le_plus_\\<I>_iff [simp]:\n  \"\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2 \\<le> \\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2' \\<longleftrightarrow> \\<I>1 \\<le> \\<I>1' \\<and> \\<I>2 \\<le> \\<I>2'\"", "lemma \\<I>_full_le_plus_\\<I>: \"\\<I>_full \\<le> plus_\\<I> \\<I>1 \\<I>2\" if \"\\<I>_full \\<le> \\<I>1\" \"\\<I>_full \\<le> \\<I>2\"", "lemma plus_\\<I>_mono: \"plus_\\<I> \\<I>1 \\<I>2 \\<le> plus_\\<I> \\<I>1' \\<I>2'\" if \"\\<I>1 \\<le> \\<I>1'\" \"\\<I>2 \\<le> \\<I>2'\"", "lemma lossless_plus_oracleI [intro, simp]:\n  \"\\<lbrakk> \\<And>a. x = Inl a \\<Longrightarrow> lossless_spmf (left s a); \n     \\<And>b. x = Inr b \\<Longrightarrow> lossless_spmf (right s b) \\<rbrakk>\n  \\<Longrightarrow> lossless_spmf (plus_oracle x)\"", "lemma plus_oracle_split:\n  \"P (plus_oracle lr) \\<longleftrightarrow>\n  (\\<forall>x. lr = Inl x \\<longrightarrow> P (map_spmf (apfst Inl) (left s x))) \\<and>\n  (\\<forall>y. lr = Inr y \\<longrightarrow> P (map_spmf (apfst Inr) (right s y)))\"", "lemma plus_oracle_split_asm:\n  \"P (plus_oracle lr) \\<longleftrightarrow>\n  \\<not> ((\\<exists>x. lr = Inl x \\<and> \\<not> P (map_spmf (apfst Inl) (left s x))) \\<or>\n     (\\<exists>y. lr = Inr y \\<and> \\<not> P (map_spmf (apfst Inr) (right s y))))\"", "lemma WT_plus_oracleI [intro!]:\n  \"\\<lbrakk> \\<I>l \\<turnstile>c left s \\<surd>; \\<I>r \\<turnstile>c right s \\<surd> \\<rbrakk> \\<Longrightarrow> \\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c (left \\<oplus>\\<^sub>O right) s \\<surd>\"", "lemma WT_plus_oracleD1:\n  assumes \"\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c (left \\<oplus>\\<^sub>O right) s \\<surd> \" (is \"?\\<I> \\<turnstile>c ?callee s \\<surd>\")\n  shows \"\\<I>l \\<turnstile>c left s \\<surd>\"", "lemma WT_plus_oracleD2:\n  assumes \"\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c (left \\<oplus>\\<^sub>O right) s \\<surd> \" (is \"?\\<I> \\<turnstile>c ?callee s \\<surd>\")\n  shows \"\\<I>r \\<turnstile>c right s \\<surd>\"", "lemma WT_plus_oracle_iff [simp]: \"\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c (left \\<oplus>\\<^sub>O right) s \\<surd> \\<longleftrightarrow> \\<I>l \\<turnstile>c left s \\<surd> \\<and> \\<I>r \\<turnstile>c right s \\<surd>\"", "lemma callee_invariant_on_plus_oracle [simp]:\n  \"callee_invariant_on (left \\<oplus>\\<^sub>O right) I (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r) \\<longleftrightarrow>\n   callee_invariant_on left I \\<I>l \\<and> callee_invariant_on right I \\<I>r\"\n   (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma callee_invariant_plus_oracle [simp]:\n  \"callee_invariant (left \\<oplus>\\<^sub>O right) I \\<longleftrightarrow>\n   callee_invariant left I \\<and> callee_invariant right I\"\n  (is \"?lhs \\<longleftrightarrow>  ?rhs\")", "lemma plus_oracle_parametric [transfer_rule]:\n  includes lifting_syntax shows\n  \"((S ===> A ===> rel_spmf (rel_prod B S))\n   ===> (S ===> C ===> rel_spmf (rel_prod D S))\n   ===> S ===> rel_sum A C ===> rel_spmf (rel_prod (rel_sum B D) S))\n   plus_oracle plus_oracle\"", "lemma rel_spmf_plus_oracle:\n  \"\\<lbrakk> \\<And>q1' q2'. \\<lbrakk> q1 = Inl q1'; q2 = Inl q2' \\<rbrakk> \\<Longrightarrow> rel_spmf (rel_prod B S) (left1 s1 q1') (left2 s2 q2');\n    \\<And>q1' q2'. \\<lbrakk> q1 = Inr q1'; q2 = Inr q2' \\<rbrakk> \\<Longrightarrow> rel_spmf (rel_prod D S) (right1 s1 q1') (right2 s2 q2');\n    S s1 s2; rel_sum A C q1 q2 \\<rbrakk>\n  \\<Longrightarrow> rel_spmf (rel_prod (rel_sum B D) S) ((left1 \\<oplus>\\<^sub>O right1) s1 q1) ((left2 \\<oplus>\\<^sub>O right2) s2 q2)\"", "lemma lossless_plus_oracle_stopI [intro, simp]:\n  \"\\<lbrakk> \\<And>a. x = Inl a \\<Longrightarrow> lossless_spmf (left s a); \n     \\<And>b. x = Inr b \\<Longrightarrow> lossless_spmf (right s b) \\<rbrakk>\n  \\<Longrightarrow> lossless_spmf (plus_oracle_stop x)\"", "lemma plus_oracle_stop_split:\n  \"P (plus_oracle_stop lr) \\<longleftrightarrow>\n  (\\<forall>x. lr = Inl x \\<longrightarrow> P (map_spmf (apfst (map_option Inl)) (left s x))) \\<and>\n  (\\<forall>y. lr = Inr y \\<longrightarrow> P (map_spmf (apfst (map_option Inr)) (right s y)))\"", "lemma plus_oracle_stop_split_asm:\n  \"P (plus_oracle_stop lr) \\<longleftrightarrow>\n  \\<not> ((\\<exists>x. lr = Inl x \\<and> \\<not> P (map_spmf (apfst (map_option Inl)) (left s x))) \\<or>\n     (\\<exists>y. lr = Inr y \\<and> \\<not> P (map_spmf (apfst (map_option Inr)) (right s y))))\"", "lemma parallel_oracle_def:\n  \"parallel_oracle = (\\<lambda>(s1, s2). case_sum (\\<lambda>a. map_spmf (map_prod Inl (\\<lambda>s1'. (s1', s2))) (left s1 a)) (\\<lambda>b. map_spmf (map_prod Inr (Pair s1)) (right s2 b)))\"", "lemma lossless_parallel_oracle [simp]:\n  \"lossless_spmf (parallel_oracle s12 xy) \\<longleftrightarrow>\n   (\\<forall>x. xy = Inl x \\<longrightarrow> lossless_spmf (left (fst s12) x)) \\<and>\n   (\\<forall>y. xy = Inr y \\<longrightarrow> lossless_spmf (right (snd s12) y))\"", "lemma parallel_oracle_split:\n  \"P (parallel_oracle s1s2 lr) \\<longleftrightarrow>\n  (\\<forall>s1 s2 x. s1s2 = (s1, s2) \\<longrightarrow> lr = Inl x \\<longrightarrow> P (map_spmf (map_prod Inl (\\<lambda>s1'. (s1', s2))) (left s1 x))) \\<and>\n  (\\<forall>s1 s2 y. s1s2 = (s1, s2) \\<longrightarrow> lr = Inr y \\<longrightarrow> P (map_spmf (map_prod Inr (Pair s1)) (right s2 y)))\"", "lemma parallel_oracle_split_asm:\n  \"P (parallel_oracle s1s2 lr) \\<longleftrightarrow>\n  \\<not> ((\\<exists>s1 s2 x. s1s2 = (s1, s2) \\<and> lr = Inl x \\<and> \\<not> P (map_spmf (map_prod Inl (\\<lambda>s1'. (s1', s2))) (left s1 x))) \\<or>\n     (\\<exists>s1 s2 y. s1s2 = (s1, s2) \\<and> lr = Inr y \\<and> \\<not> P (map_spmf (map_prod Inr (Pair s1)) (right s2 y))))\"", "lemma WT_parallel_oracle [intro!, simp]:\n  \"\\<lbrakk> \\<I>l \\<turnstile>c left sl \\<surd>; \\<I>r \\<turnstile>c right sr \\<surd> \\<rbrakk> \\<Longrightarrow> plus_\\<I> \\<I>l \\<I>r \\<turnstile>c parallel_oracle (sl, sr) \\<surd>\"", "lemma callee_invariant_parallel_oracleI [simp, intro]:\n  assumes \"callee_invariant_on left Il \\<I>l\" \"callee_invariant_on right Ir \\<I>r\"\n  shows \"callee_invariant_on parallel_oracle (pred_prod Il Ir) (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)\"", "lemma parallel_oracle_parametric:\n  includes lifting_syntax shows\n  \"((S1 ===> CALL1 ===> rel_spmf (rel_prod (=) S1)) \n  ===> (S2 ===> CALL2 ===> rel_spmf (rel_prod (=) S2))\n  ===> rel_prod S1 S2 ===> rel_sum CALL1 CALL2 ===> rel_spmf (rel_prod (=) (rel_prod S1 S2)))\n  parallel_oracle parallel_oracle\"", "lemma family_oracle_apply [simp]:\n  \"family_oracle f s (i, x) = map_spmf (apsnd (fun_upd s i)) (f i (s i) x)\"", "lemma lossless_family_oracle:\n  \"lossless_spmf (family_oracle f s ix) \\<longleftrightarrow> lossless_spmf (f (fst ix) (s (fst ix)) (snd ix))\"", "lemma extend_state_oracle_simps [simp]:\n  \"extend_state_oracle callee (s', s) x = map_spmf (\\<lambda>(y, s). (y, (s', s))) (callee s x)\"", "lemma extend_state_oracle_parametric [transfer_rule]:\n  \"((S ===> C ===> rel_spmf (rel_prod R S)) ===> rel_prod S' S ===> C ===> rel_spmf (rel_prod R (rel_prod S' S)))\n  extend_state_oracle extend_state_oracle\"", "lemma extend_state_oracle_transfer:\n  \"((S ===> C ===> rel_spmf (rel_prod R S)) \n  ===> rel_prod2 S ===> C ===> rel_spmf (rel_prod R (rel_prod2 S)))\n  (\\<lambda>oracle. oracle) extend_state_oracle\"", "lemma callee_invariant_extend_state_oracle_const [simp]:\n  \"callee_invariant \\<dagger>oracle (\\<lambda>(s', s). I s')\"", "lemma callee_invariant_extend_state_oracle_const':\n  \"callee_invariant \\<dagger>oracle (\\<lambda>s. I (fst s))\"", "lemma lift_stop_oracle_apply [simp]: \"lift_stop_oracle  oracle s x = map_spmf (apfst Some) (oracle s x)\"", "lemma lift_stop_oracle_transfer:\n  \"((S ===> C ===> rel_spmf (rel_prod R S)) ===> (S ===> C ===> rel_spmf (rel_prod (pcr_Some R) S)))\n   (\\<lambda>x. x) lift_stop_oracle\"", "lemma extend_state_oracle2_simps [simp]:\n  \"extend_state_oracle2 callee (s, s') x = map_spmf (\\<lambda>(y, s). (y, (s, s'))) (callee s x)\"", "lemma extend_state_oracle2_parametric [transfer_rule]: includes lifting_syntax shows\n  \"((S ===> C ===> rel_spmf (rel_prod R S)) ===> rel_prod S S' ===> C ===> rel_spmf (rel_prod R (rel_prod S S')))\n  extend_state_oracle2 extend_state_oracle2\"", "lemma callee_invariant_extend_state_oracle2_const [simp]:\n  \"callee_invariant oracle\\<dagger> (\\<lambda>(s, s'). I s')\"", "lemma callee_invariant_extend_state_oracle2_const':\n  \"callee_invariant oracle\\<dagger> (\\<lambda>s. I (snd s))\"", "lemma extend_state_oracle2_plus_oracle: \n  \"extend_state_oracle2 (plus_oracle oracle1 oracle2) = plus_oracle (extend_state_oracle2 oracle1) (extend_state_oracle2 oracle2)\"", "lemma parallel_oracle_conv_plus_oracle:\n  \"parallel_oracle oracle1 oracle2 = plus_oracle (oracle1\\<dagger>) (\\<dagger>oracle2)\"", "lemma map_sum_parallel_oracle: includes lifting_syntax shows\n  \"(id ---> map_sum f g ---> map_spmf (map_prod (map_sum h k) id)) (parallel_oracle oracle1 oracle2)\n  = parallel_oracle ((id ---> f ---> map_spmf (map_prod h id)) oracle1) ((id ---> g ---> map_spmf (map_prod k id)) oracle2)\"", "lemma map_sum_plus_oracle: includes lifting_syntax shows\n  \"(id ---> map_sum f g ---> map_spmf (map_prod (map_sum h k) id)) (plus_oracle oracle1 oracle2)\n  = plus_oracle ((id ---> f ---> map_spmf (map_prod h id)) oracle1) ((id ---> g ---> map_spmf (map_prod k id)) oracle2)\"", "lemma map_rsuml_plus_oracle: includes lifting_syntax shows\n  \"(id ---> rsuml ---> (map_spmf (map_prod lsumr id))) (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)) =\n   ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3)\"", "lemma map_lsumr_plus_oracle: includes lifting_syntax shows\n  \"(id ---> lsumr ---> (map_spmf (map_prod rsuml id))) ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3) =\n   (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3))\"", "lemma lift_state_oracle_simps [simp]:\n  \"lift_state_oracle F oracle (t, s') a = map_spmf rprodl (F ((Pair t ---> id ---> map_spmf lprodr) oracle) s' a)\"", "lemma lift_state_oracle_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(((S ===> A ===> rel_spmf (rel_prod (rel_prod B T) S)) ===> S' ===> A ===> rel_spmf (rel_prod (rel_prod B T) S'))\n  ===> (rel_prod T S ===> A ===> rel_spmf (rel_prod B (rel_prod T S)))\n  ===> rel_prod T S' ===> A ===> rel_spmf (rel_prod B (rel_prod T S')))\n  lift_state_oracle lift_state_oracle\"", "lemma lift_state_oracle_extend_state_oracle:\n  includes lifting_syntax\n  assumes \"\\<And>B. Transfer.Rel (((=) ===> (=) ===> rel_spmf (rel_prod B (=))) ===> (=) ===> (=) ===> rel_spmf (rel_prod B (=))) G F\"\n    (* TODO: implement simproc to discharge parametricity assumptions like this one *)\n  shows \"lift_state_oracle F (extend_state_oracle oracle) = extend_state_oracle (G oracle)\"", "lemma lift_state_oracle_compose: \n  \"lift_state_oracle F (lift_state_oracle G oracle) = lift_state_oracle (F \\<circ> G) oracle\"", "lemma lift_state_oracle_id [simp]: \"lift_state_oracle id = id\"", "lemma rprodl_extend_state_oracle: includes lifting_syntax shows\n  \"(rprodl ---> id ---> map_spmf (map_prod id lprodr)) (extend_state_oracle (extend_state_oracle oracle)) = \n  extend_state_oracle oracle\"", "lemma plus_intercept_parametric [transfer_rule]:\n  includes lifting_syntax shows\n  \"((S ===> X1 ===> rel_gpv (rel_prod Y1 S) C)\n  ===> (S ===> X2 ===> rel_gpv (rel_prod Y2 S) C)\n  ===> S ===> rel_sum X1 X2 ===> rel_gpv (rel_prod (rel_sum Y1 Y2) S) C)\n  plus_intercept plus_intercept\"", "lemma interaction_bounded_by_plus_intercept [interaction_bound]:\n  fixes left right\n  shows \"\\<lbrakk> \\<And>x'. x = Inl x' \\<Longrightarrow> interaction_bounded_by P (left s x') (n x');\n    \\<And>y. x = Inr y \\<Longrightarrow> interaction_bounded_by P (right s y) (m y) \\<rbrakk>\n  \\<Longrightarrow> interaction_bounded_by P (plus_intercept left right s x) (case x of Inl x \\<Rightarrow> n x | Inr y \\<Rightarrow> m y)\"", "lemma plus_intercept_stop_parametric [transfer_rule]:\n  includes lifting_syntax shows\n  \"((S ===> X1 ===> rel_gpv (rel_prod (rel_option Y1) S) C)\n  ===> (S ===> X2 ===> rel_gpv (rel_prod (rel_option Y2) S) C)\n  ===> S ===> rel_sum X1 X2 ===> rel_gpv (rel_prod (rel_option (rel_sum Y1 Y2)) S) C)\n  plus_intercept_stop plus_intercept_stop\"", "lemmas left_gpv_parametric = left_gpv.transfer", "lemma left_gpv_parametric':\n  \"(rel_gpv'' A C R ===> rel_gpv'' A (rel_sum C C') (rel_sum R R')) left_gpv left_gpv\"", "lemmas right_gpv_parametric = right_gpv.transfer", "lemma right_gpv_parametric':\n  \"(rel_gpv'' A C' R' ===> rel_gpv'' A (rel_sum C C') (rel_sum R R')) right_gpv right_gpv\"", "lemma left_gpv_Done [simp]: \"left_gpv (Done x) = Done x\"", "lemma right_gpv_Done [simp]: \"right_gpv (Done x) = Done x\"", "lemma left_gpv_Pause [simp]:\n  \"left_gpv (Pause x rpv) = Pause (Inl x) (\\<lambda>input. case input of Inl input' \\<Rightarrow> left_gpv (rpv input') | _ \\<Rightarrow> Fail)\"", "lemma right_gpv_Pause [simp]:\n  \"right_gpv (Pause x rpv) = Pause (Inr x) (\\<lambda>input. case input of Inr input' \\<Rightarrow> right_gpv (rpv input') | _ \\<Rightarrow> Fail)\"", "lemma left_gpv_map: \"left_gpv (map_gpv f g gpv) = map_gpv f (map_sum g h) (left_gpv gpv)\"", "lemma right_gpv_map: \"right_gpv (map_gpv f g gpv) = map_gpv f (map_sum h g) (right_gpv gpv)\"", "lemma results'_gpv_left_gpv [simp]: \n  \"results'_gpv (left_gpv gpv :: ('a, 'out + 'out', 'in + 'in') gpv) = results'_gpv gpv\" (is \"?lhs = ?rhs\")", "lemma results'_gpv_right_gpv [simp]: \n  \"results'_gpv (right_gpv gpv :: ('a, 'out' + 'out, 'in' + 'in) gpv) = results'_gpv gpv\" (is \"?lhs = ?rhs\")", "lemma left_gpv_Inl_transfer: \"rel_gpv'' (=) (\\<lambda>l r. l = Inl r) (\\<lambda>l r. l = Inl r) (left_gpv gpv) gpv\"", "lemma right_gpv_Inr_transfer: \"rel_gpv'' (=) (\\<lambda>l r. l = Inr r) (\\<lambda>l r. l = Inr r) (right_gpv gpv) gpv\"", "lemma exec_gpv_plus_oracle_left: \"exec_gpv (plus_oracle oracle1 oracle2) (left_gpv gpv) s = exec_gpv oracle1 gpv s\"", "lemma exec_gpv_plus_oracle_right: \"exec_gpv (plus_oracle oracle1 oracle2) (right_gpv gpv) s = exec_gpv oracle2 gpv s\"", "lemma left_gpv_bind_gpv: \"left_gpv (bind_gpv gpv f) = bind_gpv (left_gpv gpv) (left_gpv \\<circ> f)\"", "lemma inline1_left_gpv:\n  \"inline1 (\\<lambda>s q. left_gpv (callee s q)) gpv s = \n   map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id))) (inline1 callee gpv s)\"", "lemma left_gpv_inline: \"left_gpv (inline callee gpv s) = inline (\\<lambda>s q. left_gpv (callee s q)) gpv s\"", "lemma right_gpv_bind_gpv: \"right_gpv (bind_gpv gpv f) = bind_gpv (right_gpv gpv) (right_gpv \\<circ> f)\"", "lemma inline1_right_gpv:\n  \"inline1 (\\<lambda>s q. right_gpv (callee s q)) gpv s = \n   map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id))) (inline1 callee gpv s)\"", "lemma right_gpv_inline: \"right_gpv (inline callee gpv s) = inline (\\<lambda>s q. right_gpv (callee s q)) gpv s\"", "lemma WT_gpv_left_gpv: \"\\<I>1 \\<turnstile>g gpv \\<surd> \\<Longrightarrow> \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2 \\<turnstile>g left_gpv gpv \\<surd>\"", "lemma WT_gpv_right_gpv: \"\\<I>2 \\<turnstile>g gpv \\<surd> \\<Longrightarrow> \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2 \\<turnstile>g right_gpv gpv \\<surd>\"", "lemma results_gpv_left_gpv [simp]: \"results_gpv (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (left_gpv gpv) = results_gpv \\<I>1 gpv\"\n  (is \"?lhs = ?rhs\")", "lemma results_gpv_right_gpv [simp]: \"results_gpv (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (right_gpv gpv) = results_gpv \\<I>2 gpv\"\n  (is \"?lhs = ?rhs\")", "lemma left_gpv_Fail [simp]: \"left_gpv Fail = Fail\"", "lemma right_gpv_Fail [simp]: \"right_gpv Fail = Fail\"", "lemma rsuml_lsumr_left_gpv_left_gpv:\"map_gpv' id rsuml lsumr (left_gpv (left_gpv gpv)) = left_gpv gpv\"", "lemma rsuml_lsumr_left_gpv_right_gpv: \"map_gpv' id rsuml lsumr (left_gpv (right_gpv gpv)) = right_gpv (left_gpv gpv)\"", "lemma rsuml_lsumr_right_gpv: \"map_gpv' id rsuml lsumr (right_gpv gpv) = right_gpv (right_gpv gpv)\"", "lemma map_gpv'_map_gpv_swap:\n  \"map_gpv' f g h (map_gpv f' id gpv) = map_gpv (f \\<circ> f') id (map_gpv' id g h gpv)\"", "lemma lsumr_rsuml_left_gpv: \"map_gpv' id lsumr rsuml (left_gpv gpv) = left_gpv (left_gpv gpv)\"", "lemma lsumr_rsuml_right_gpv_left_gpv:\n  \"map_gpv' id lsumr rsuml (right_gpv (left_gpv gpv)) = left_gpv (right_gpv gpv)\"", "lemma lsumr_rsuml_right_gpv_right_gpv:\n  \"map_gpv' id lsumr rsuml (right_gpv (right_gpv gpv)) = right_gpv gpv\"", "lemma in_set_spmf_extend_state_oracle [simp]:\n  \"x \\<in> set_spmf (extend_state_oracle oracle s y) \\<longleftrightarrow>\n   fst (snd x) = fst s \\<and> (fst x, snd (snd x)) \\<in> set_spmf (oracle (snd s) y)\"", "lemma extend_state_oracle_plus_oracle: \n  \"extend_state_oracle (plus_oracle oracle1 oracle2) = plus_oracle (extend_state_oracle oracle1) (extend_state_oracle oracle2)\"", "lemma stateless_callee_parametric': \n  includes lifting_syntax notes [transfer_rule] = map_gpv_parametric' shows\n    \"((A ===> rel_gpv'' B C R) ===> S ===> A ===> (rel_gpv'' (rel_prod B S) C R))\n   stateless_callee stateless_callee\"", "lemma id_oralce_alt_def: \"id_oracle = stateless_callee (\\<lambda>x. Pause x Done)\""], "translations": [["", "lemma plus_\\<I>_sel [simp]:\n  shows outs_plus_\\<I>: \"outs_\\<I> (plus_\\<I> \\<I>l \\<I>r) = outs_\\<I> \\<I>l <+> outs_\\<I> \\<I>r\"\n  and responses_plus_\\<I>_Inl: \"responses_\\<I> (plus_\\<I> \\<I>l \\<I>r) (Inl x) = Inl ` responses_\\<I> \\<I>l x\"\n  and responses_plus_\\<I>_Inr: \"responses_\\<I> (plus_\\<I> \\<I>l \\<I>r) (Inr y) = Inr ` responses_\\<I> \\<I>r y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outs_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r) =\n    outs_\\<I> \\<I>l <+> outs_\\<I> \\<I>r &&&\n    responses_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r) (Inl x) =\n    Inl ` responses_\\<I> \\<I>l x &&&\n    responses_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r) (Inr y) =\n    Inr ` responses_\\<I> \\<I>r y", "by(transfer; auto split: sum.split_asm; fail)+"], ["", "lemma vimage_Inl_Plus [simp]: \"Inl -` (A <+> B) = A\" \n  and vimage_Inr_Plus [simp]: \"Inr -` (A <+> B) = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inl -` (A <+> B) = A &&& Inr -` (A <+> B) = B", "by auto"], ["", "lemma vimage_Inl_image_Inr: \"Inl -` Inr ` A = {}\"\n  and vimage_Inr_image_Inl: \"Inr -` Inl ` A = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inl -` Inr ` A = {} &&& Inr -` Inl ` A = {}", "by auto"], ["", "lemma plus_\\<I>_parametric [transfer_rule]:\n  \"(rel_\\<I> C R ===> rel_\\<I> C' R' ===> rel_\\<I> (rel_sum C C') (rel_sum R R')) plus_\\<I> plus_\\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_\\<I> C R ===>\n     rel_\\<I> C' R' ===> rel_\\<I> (rel_sum C C') (rel_sum R R'))\n     (\\<oplus>\\<^sub>\\<I>) (\\<oplus>\\<^sub>\\<I>)", "apply(rule rel_funI rel_\\<I>I)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_\\<I> C R x y; rel_\\<I> C' R' xa ya\\<rbrakk>\n       \\<Longrightarrow> rel_set (rel_sum C C')\n                          (outs_\\<I> (x \\<oplus>\\<^sub>\\<I> xa))\n                          (outs_\\<I> (y \\<oplus>\\<^sub>\\<I> ya))\n 2. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_\\<I> C R x y; rel_\\<I> C' R' xa ya;\n        rel_sum C C' xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set (rel_sum R R')\n                          (responses_\\<I> (x \\<oplus>\\<^sub>\\<I> xa) xb)\n                          (responses_\\<I> (y \\<oplus>\\<^sub>\\<I> ya) yb)", "subgoal premises [transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_set (rel_sum C C') (outs_\\<I> (x_ \\<oplus>\\<^sub>\\<I> xa_))\n     (outs_\\<I> (y_ \\<oplus>\\<^sub>\\<I> ya_))", "by(simp; rule conjI; transfer_prover)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_\\<I> C R x y; rel_\\<I> C' R' xa ya;\n        rel_sum C C' xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set (rel_sum R R')\n                          (responses_\\<I> (x \\<oplus>\\<^sub>\\<I> xa) xb)\n                          (responses_\\<I> (y \\<oplus>\\<^sub>\\<I> ya) yb)", "apply(erule rel_sum.cases; clarsimp simp add: inj_vimage_image_eq vimage_Inl_image_Inr empty_transfer vimage_Inr_image_Inl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya a c.\n       \\<lbrakk>rel_\\<I> C R x y; rel_\\<I> C' R' xa ya; C a c\\<rbrakk>\n       \\<Longrightarrow> rel_set R (responses_\\<I> x a) (responses_\\<I> y c)\n 2. \\<And>x y xa ya b d.\n       \\<lbrakk>rel_\\<I> C R x y; rel_\\<I> C' R' xa ya; C' b d\\<rbrakk>\n       \\<Longrightarrow> rel_set R' (responses_\\<I> xa b)\n                          (responses_\\<I> ya d)", "subgoal premises [transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_set R (responses_\\<I> x_ a_) (responses_\\<I> y_ c_)", "by transfer_prover"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya b d.\n       \\<lbrakk>rel_\\<I> C R x y; rel_\\<I> C' R' xa ya; C' b d\\<rbrakk>\n       \\<Longrightarrow> rel_set R' (responses_\\<I> xa b)\n                          (responses_\\<I> ya d)", "subgoal premises [transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_set R' (responses_\\<I> xa_ b_) (responses_\\<I> ya_ d_)", "by transfer_prover"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lifting_update \\<I>.lifting"], ["", "lifting_forget \\<I>.lifting"], ["", "lemma \\<I>_trivial_plus_\\<I> [simp]: \"\\<I>_trivial (\\<I>\\<^sub>1 \\<oplus>\\<^sub>\\<I> \\<I>\\<^sub>2) \\<longleftrightarrow> \\<I>_trivial \\<I>\\<^sub>1 \\<and> \\<I>_trivial \\<I>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_trivial (\\<I>\\<^sub>1 \\<oplus>\\<^sub>\\<I> \\<I>\\<^sub>2) =\n    (\\<I>_trivial \\<I>\\<^sub>1 \\<and> \\<I>_trivial \\<I>\\<^sub>2)", "by(auto simp add: \\<I>_trivial_def)"], ["", "end"], ["", "lemma map_\\<I>_plus_\\<I> [simp]: \n  \"map_\\<I> (map_sum f1 f2) (map_sum g1 g2) (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) = map_\\<I> f1 g1 \\<I>1 \\<oplus>\\<^sub>\\<I> map_\\<I> f2 g2 \\<I>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_\\<I> (map_sum f1 f2) (map_sum g1 g2)\n     (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) =\n    map_\\<I> f1 g1 \\<I>1 \\<oplus>\\<^sub>\\<I> map_\\<I> f2 g2 \\<I>2", "proof(rule \\<I>_eqI[OF Set.set_eqI], goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       (x \\<in> outs_\\<I>\n                 (map_\\<I> (map_sum f1 f2) (map_sum g1 g2)\n                   (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2))) =\n       (x \\<in> outs_\\<I>\n                 (map_\\<I> f1 g1 \\<I>1 \\<oplus>\\<^sub>\\<I>\n                  map_\\<I> f2 g2 \\<I>2))\n 2. \\<And>x.\n       x \\<in> outs_\\<I>\n                (map_\\<I> f1 g1 \\<I>1 \\<oplus>\\<^sub>\\<I>\n                 map_\\<I> f2 g2 \\<I>2) \\<Longrightarrow>\n       responses_\\<I>\n        (map_\\<I> (map_sum f1 f2) (map_sum g1 g2)\n          (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2))\n        x =\n       responses_\\<I>\n        (map_\\<I> f1 g1 \\<I>1 \\<oplus>\\<^sub>\\<I> map_\\<I> f2 g2 \\<I>2) x", "case (1 x)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (x \\<in> outs_\\<I>\n                 (map_\\<I> (map_sum f1 f2) (map_sum g1 g2)\n                   (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2))) =\n       (x \\<in> outs_\\<I>\n                 (map_\\<I> f1 g1 \\<I>1 \\<oplus>\\<^sub>\\<I>\n                  map_\\<I> f2 g2 \\<I>2))\n 2. \\<And>x.\n       x \\<in> outs_\\<I>\n                (map_\\<I> f1 g1 \\<I>1 \\<oplus>\\<^sub>\\<I>\n                 map_\\<I> f2 g2 \\<I>2) \\<Longrightarrow>\n       responses_\\<I>\n        (map_\\<I> (map_sum f1 f2) (map_sum g1 g2)\n          (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2))\n        x =\n       responses_\\<I>\n        (map_\\<I> f1 g1 \\<I>1 \\<oplus>\\<^sub>\\<I> map_\\<I> f2 g2 \\<I>2) x", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> outs_\\<I>\n              (map_\\<I> (map_sum f1 f2) (map_sum g1 g2)\n                (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2))) =\n    (x \\<in> outs_\\<I>\n              (map_\\<I> f1 g1 \\<I>1 \\<oplus>\\<^sub>\\<I>\n               map_\\<I> f2 g2 \\<I>2))", "by(cases x) auto"], ["proof (state)\nthis:\n  (x \\<in> outs_\\<I>\n            (map_\\<I> (map_sum f1 f2) (map_sum g1 g2)\n              (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2))) =\n  (x \\<in> outs_\\<I>\n            (map_\\<I> f1 g1 \\<I>1 \\<oplus>\\<^sub>\\<I> map_\\<I> f2 g2 \\<I>2))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> outs_\\<I>\n                (map_\\<I> f1 g1 \\<I>1 \\<oplus>\\<^sub>\\<I>\n                 map_\\<I> f2 g2 \\<I>2) \\<Longrightarrow>\n       responses_\\<I>\n        (map_\\<I> (map_sum f1 f2) (map_sum g1 g2)\n          (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2))\n        x =\n       responses_\\<I>\n        (map_\\<I> f1 g1 \\<I>1 \\<oplus>\\<^sub>\\<I> map_\\<I> f2 g2 \\<I>2) x", "qed (auto simp add: image_image)"], ["", "lemma le_plus_\\<I>_iff [simp]:\n  \"\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2 \\<le> \\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2' \\<longleftrightarrow> \\<I>1 \\<le> \\<I>1' \\<and> \\<I>2 \\<le> \\<I>2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2\n     \\<le> \\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') =\n    (\\<I>1 \\<le> \\<I>1' \\<and> \\<I>2 \\<le> \\<I>2')", "by(auto 4 4 simp add: le_\\<I>_def dest: bspec[where x=\"Inl _\"] bspec[where x=\"Inr _\"])"], ["", "lemma \\<I>_full_le_plus_\\<I>: \"\\<I>_full \\<le> plus_\\<I> \\<I>1 \\<I>2\" if \"\\<I>_full \\<le> \\<I>1\" \"\\<I>_full \\<le> \\<I>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_full \\<le> \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2", "using that"], ["proof (prove)\nusing this:\n  \\<I>_full \\<le> \\<I>1\n  \\<I>_full \\<le> \\<I>2\n\ngoal (1 subgoal):\n 1. \\<I>_full \\<le> \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2", "by(auto simp add: le_\\<I>_def top_unique)"], ["", "lemma plus_\\<I>_mono: \"plus_\\<I> \\<I>1 \\<I>2 \\<le> plus_\\<I> \\<I>1' \\<I>2'\" if \"\\<I>1 \\<le> \\<I>1'\" \"\\<I>2 \\<le> \\<I>2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2 \\<le> \\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2'", "using that"], ["proof (prove)\nusing this:\n  \\<I>1 \\<le> \\<I>1'\n  \\<I>2 \\<le> \\<I>2'\n\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2 \\<le> \\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2'", "by(fastforce simp add: le_\\<I>_def)"], ["", "context\n  fixes left :: \"('s, 'a, 'b) oracle'\"\n  and right :: \"('s,'c, 'd) oracle'\"\n  and s :: \"'s\"\nbegin"], ["", "primrec plus_oracle :: \"'a + 'c \\<Rightarrow> (('b + 'd) \\<times> 's) spmf\"\nwhere\n  \"plus_oracle (Inl a) = map_spmf (apfst Inl) (left s a)\"\n| \"plus_oracle (Inr b) = map_spmf (apfst Inr) (right s b)\""], ["", "lemma lossless_plus_oracleI [intro, simp]:\n  \"\\<lbrakk> \\<And>a. x = Inl a \\<Longrightarrow> lossless_spmf (left s a); \n     \\<And>b. x = Inr b \\<Longrightarrow> lossless_spmf (right s b) \\<rbrakk>\n  \\<Longrightarrow> lossless_spmf (plus_oracle x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a. x = Inl a \\<Longrightarrow> lossless_spmf (left s a);\n     \\<And>b. x = Inr b \\<Longrightarrow> lossless_spmf (right s b)\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf (local.plus_oracle x)", "by(cases x) simp_all"], ["", "lemma plus_oracle_split:\n  \"P (plus_oracle lr) \\<longleftrightarrow>\n  (\\<forall>x. lr = Inl x \\<longrightarrow> P (map_spmf (apfst Inl) (left s x))) \\<and>\n  (\\<forall>y. lr = Inr y \\<longrightarrow> P (map_spmf (apfst Inr) (right s y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (local.plus_oracle lr) =\n    ((\\<forall>x.\n         lr = Inl x \\<longrightarrow>\n         P (map_spmf (apfst Inl) (left s x))) \\<and>\n     (\\<forall>y.\n         lr = Inr y \\<longrightarrow> P (map_spmf (apfst Inr) (right s y))))", "by(cases lr) auto"], ["", "lemma plus_oracle_split_asm:\n  \"P (plus_oracle lr) \\<longleftrightarrow>\n  \\<not> ((\\<exists>x. lr = Inl x \\<and> \\<not> P (map_spmf (apfst Inl) (left s x))) \\<or>\n     (\\<exists>y. lr = Inr y \\<and> \\<not> P (map_spmf (apfst Inr) (right s y))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (local.plus_oracle lr) =\n    (\\<not> ((\\<exists>x.\n                 lr = Inl x \\<and>\n                 \\<not> P (map_spmf (apfst Inl) (left s x))) \\<or>\n             (\\<exists>y.\n                 lr = Inr y \\<and>\n                 \\<not> P (map_spmf (apfst Inr) (right s y)))))", "by(cases lr) auto"], ["", "end"], ["", "notation plus_oracle (infix \"\\<oplus>\\<^sub>O\" 500)"], ["", "context\n  fixes left :: \"('s, 'a, 'b) oracle'\"\n  and right :: \"('s,'c, 'd) oracle'\"\nbegin"], ["", "lemma WT_plus_oracleI [intro!]:\n  \"\\<lbrakk> \\<I>l \\<turnstile>c left s \\<surd>; \\<I>r \\<turnstile>c right s \\<surd> \\<rbrakk> \\<Longrightarrow> \\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c (left \\<oplus>\\<^sub>O right) s \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>l \\<turnstile>c left s \\<surd>;\n     \\<I>r \\<turnstile>c right s \\<surd>\\<rbrakk>\n    \\<Longrightarrow> \\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c\n                      (left \\<oplus>\\<^sub>O right) s \\<surd>", "by(rule WT_calleeI)(auto elim!: WT_calleeD simp add: inj_image_mem_iff)"], ["", "lemma WT_plus_oracleD1:\n  assumes \"\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c (left \\<oplus>\\<^sub>O right) s \\<surd> \" (is \"?\\<I> \\<turnstile>c ?callee s \\<surd>\")\n  shows \"\\<I>l \\<turnstile>c left s \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>l \\<turnstile>c left s \\<surd>", "proof(rule WT_calleeI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>call ret sa.\n       \\<lbrakk>call \\<in> outs_\\<I> \\<I>l;\n        (ret, sa) \\<in> set_spmf (left s call)\\<rbrakk>\n       \\<Longrightarrow> ret \\<in> responses_\\<I> \\<I>l call", "fix call ret s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>call ret sa.\n       \\<lbrakk>call \\<in> outs_\\<I> \\<I>l;\n        (ret, sa) \\<in> set_spmf (left s call)\\<rbrakk>\n       \\<Longrightarrow> ret \\<in> responses_\\<I> \\<I>l call", "assume \"call \\<in> outs_\\<I> \\<I>l\" \"(ret, s') \\<in> set_spmf (left s call)\""], ["proof (state)\nthis:\n  call \\<in> outs_\\<I> \\<I>l\n  (ret, s') \\<in> set_spmf (left s call)\n\ngoal (1 subgoal):\n 1. \\<And>call ret sa.\n       \\<lbrakk>call \\<in> outs_\\<I> \\<I>l;\n        (ret, sa) \\<in> set_spmf (left s call)\\<rbrakk>\n       \\<Longrightarrow> ret \\<in> responses_\\<I> \\<I>l call", "hence \"(Inl ret, s') \\<in> set_spmf (?callee s (Inl call))\" \"Inl call \\<in> outs_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)\""], ["proof (prove)\nusing this:\n  call \\<in> outs_\\<I> \\<I>l\n  (ret, s') \\<in> set_spmf (left s call)\n\ngoal (1 subgoal):\n 1. (Inl ret, s')\n    \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s (Inl call)) &&&\n    Inl call \\<in> outs_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)", "by(auto intro: rev_image_eqI)"], ["proof (state)\nthis:\n  (Inl ret, s') \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s (Inl call))\n  Inl call \\<in> outs_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)\n\ngoal (1 subgoal):\n 1. \\<And>call ret sa.\n       \\<lbrakk>call \\<in> outs_\\<I> \\<I>l;\n        (ret, sa) \\<in> set_spmf (left s call)\\<rbrakk>\n       \\<Longrightarrow> ret \\<in> responses_\\<I> \\<I>l call", "hence \"Inl ret \\<in> responses_\\<I> ?\\<I> (Inl call)\""], ["proof (prove)\nusing this:\n  (Inl ret, s') \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s (Inl call))\n  Inl call \\<in> outs_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)\n\ngoal (1 subgoal):\n 1. Inl ret\n    \\<in> responses_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r) (Inl call)", "by(rule WT_calleeD[OF assms])"], ["proof (state)\nthis:\n  Inl ret \\<in> responses_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r) (Inl call)\n\ngoal (1 subgoal):\n 1. \\<And>call ret sa.\n       \\<lbrakk>call \\<in> outs_\\<I> \\<I>l;\n        (ret, sa) \\<in> set_spmf (left s call)\\<rbrakk>\n       \\<Longrightarrow> ret \\<in> responses_\\<I> \\<I>l call", "then"], ["proof (chain)\npicking this:\n  Inl ret \\<in> responses_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r) (Inl call)", "show \"ret \\<in> responses_\\<I> \\<I>l call\""], ["proof (prove)\nusing this:\n  Inl ret \\<in> responses_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r) (Inl call)\n\ngoal (1 subgoal):\n 1. ret \\<in> responses_\\<I> \\<I>l call", "by(simp add: inj_image_mem_iff)"], ["proof (state)\nthis:\n  ret \\<in> responses_\\<I> \\<I>l call\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma WT_plus_oracleD2:\n  assumes \"\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c (left \\<oplus>\\<^sub>O right) s \\<surd> \" (is \"?\\<I> \\<turnstile>c ?callee s \\<surd>\")\n  shows \"\\<I>r \\<turnstile>c right s \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>r \\<turnstile>c right s \\<surd>", "proof(rule WT_calleeI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>call ret sa.\n       \\<lbrakk>call \\<in> outs_\\<I> \\<I>r;\n        (ret, sa) \\<in> set_spmf (right s call)\\<rbrakk>\n       \\<Longrightarrow> ret \\<in> responses_\\<I> \\<I>r call", "fix call ret s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>call ret sa.\n       \\<lbrakk>call \\<in> outs_\\<I> \\<I>r;\n        (ret, sa) \\<in> set_spmf (right s call)\\<rbrakk>\n       \\<Longrightarrow> ret \\<in> responses_\\<I> \\<I>r call", "assume \"call \\<in> outs_\\<I> \\<I>r\" \"(ret, s') \\<in> set_spmf (right s call)\""], ["proof (state)\nthis:\n  call \\<in> outs_\\<I> \\<I>r\n  (ret, s') \\<in> set_spmf (right s call)\n\ngoal (1 subgoal):\n 1. \\<And>call ret sa.\n       \\<lbrakk>call \\<in> outs_\\<I> \\<I>r;\n        (ret, sa) \\<in> set_spmf (right s call)\\<rbrakk>\n       \\<Longrightarrow> ret \\<in> responses_\\<I> \\<I>r call", "hence \"(Inr ret, s') \\<in> set_spmf (?callee s (Inr call))\" \"Inr call \\<in> outs_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)\""], ["proof (prove)\nusing this:\n  call \\<in> outs_\\<I> \\<I>r\n  (ret, s') \\<in> set_spmf (right s call)\n\ngoal (1 subgoal):\n 1. (Inr ret, s')\n    \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s (Inr call)) &&&\n    Inr call \\<in> outs_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)", "by(auto intro: rev_image_eqI)"], ["proof (state)\nthis:\n  (Inr ret, s') \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s (Inr call))\n  Inr call \\<in> outs_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)\n\ngoal (1 subgoal):\n 1. \\<And>call ret sa.\n       \\<lbrakk>call \\<in> outs_\\<I> \\<I>r;\n        (ret, sa) \\<in> set_spmf (right s call)\\<rbrakk>\n       \\<Longrightarrow> ret \\<in> responses_\\<I> \\<I>r call", "hence \"Inr ret \\<in> responses_\\<I> ?\\<I> (Inr call)\""], ["proof (prove)\nusing this:\n  (Inr ret, s') \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s (Inr call))\n  Inr call \\<in> outs_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)\n\ngoal (1 subgoal):\n 1. Inr ret\n    \\<in> responses_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r) (Inr call)", "by(rule WT_calleeD[OF assms])"], ["proof (state)\nthis:\n  Inr ret \\<in> responses_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r) (Inr call)\n\ngoal (1 subgoal):\n 1. \\<And>call ret sa.\n       \\<lbrakk>call \\<in> outs_\\<I> \\<I>r;\n        (ret, sa) \\<in> set_spmf (right s call)\\<rbrakk>\n       \\<Longrightarrow> ret \\<in> responses_\\<I> \\<I>r call", "then"], ["proof (chain)\npicking this:\n  Inr ret \\<in> responses_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r) (Inr call)", "show \"ret \\<in> responses_\\<I> \\<I>r call\""], ["proof (prove)\nusing this:\n  Inr ret \\<in> responses_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r) (Inr call)\n\ngoal (1 subgoal):\n 1. ret \\<in> responses_\\<I> \\<I>r call", "by(simp add: inj_image_mem_iff)"], ["proof (state)\nthis:\n  ret \\<in> responses_\\<I> \\<I>r call\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma WT_plus_oracle_iff [simp]: \"\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c (left \\<oplus>\\<^sub>O right) s \\<surd> \\<longleftrightarrow> \\<I>l \\<turnstile>c left s \\<surd> \\<and> \\<I>r \\<turnstile>c right s \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c\n    (left \\<oplus>\\<^sub>O right) s \\<surd> =\n    (\\<I>l \\<turnstile>c left s \\<surd> \\<and> \\<I>r \\<turnstile>c\n     right s \\<surd>)", "by(blast dest: WT_plus_oracleD1 WT_plus_oracleD2)"], ["", "lemma callee_invariant_on_plus_oracle [simp]:\n  \"callee_invariant_on (left \\<oplus>\\<^sub>O right) I (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r) \\<longleftrightarrow>\n   callee_invariant_on left I \\<I>l \\<and> callee_invariant_on right I \\<I>r\"\n   (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n     (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r) =\n    (callee_invariant_on left I \\<I>l \\<and>\n     callee_invariant_on right I \\<I>r)", "proof(intro iffI conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n     (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r) \\<Longrightarrow>\n    callee_invariant_on left I \\<I>l\n 2. callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n     (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r) \\<Longrightarrow>\n    callee_invariant_on right I \\<I>r\n 3. callee_invariant_on left I \\<I>l \\<and>\n    callee_invariant_on right I \\<I>r \\<Longrightarrow>\n    callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n     (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)", "assume ?lhs"], ["proof (state)\nthis:\n  callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n   (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)\n\ngoal (3 subgoals):\n 1. callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n     (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r) \\<Longrightarrow>\n    callee_invariant_on left I \\<I>l\n 2. callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n     (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r) \\<Longrightarrow>\n    callee_invariant_on right I \\<I>r\n 3. callee_invariant_on left I \\<I>l \\<and>\n    callee_invariant_on right I \\<I>r \\<Longrightarrow>\n    callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n     (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)", "then"], ["proof (chain)\npicking this:\n  callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n   (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)", "interpret plus: callee_invariant_on \"left \\<oplus>\\<^sub>O right\" I \"\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r\""], ["proof (prove)\nusing this:\n  callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n   (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)\n\ngoal (1 subgoal):\n 1. callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n     (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)", "."], ["proof (state)\ngoal (3 subgoals):\n 1. callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n     (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r) \\<Longrightarrow>\n    callee_invariant_on left I \\<I>l\n 2. callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n     (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r) \\<Longrightarrow>\n    callee_invariant_on right I \\<I>r\n 3. callee_invariant_on left I \\<I>l \\<and>\n    callee_invariant_on right I \\<I>r \\<Longrightarrow>\n    callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n     (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)", "show \"callee_invariant_on left I \\<I>l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on left I \\<I>l", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (left s x); I s;\n        x \\<in> outs_\\<I> \\<I>l\\<rbrakk>\n       \\<Longrightarrow> I s'\n 2. \\<And>s. I s \\<Longrightarrow> \\<I>l \\<turnstile>c left s \\<surd>", "fix s x y s'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (left s x); I s;\n        x \\<in> outs_\\<I> \\<I>l\\<rbrakk>\n       \\<Longrightarrow> I s'\n 2. \\<And>s. I s \\<Longrightarrow> \\<I>l \\<turnstile>c left s \\<surd>", "assume \"(y, s') \\<in> set_spmf (left s x)\" and \"I s\" and \"x \\<in> outs_\\<I> \\<I>l\""], ["proof (state)\nthis:\n  (y, s') \\<in> set_spmf (left s x)\n  I s\n  x \\<in> outs_\\<I> \\<I>l\n\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (left s x); I s;\n        x \\<in> outs_\\<I> \\<I>l\\<rbrakk>\n       \\<Longrightarrow> I s'\n 2. \\<And>s. I s \\<Longrightarrow> \\<I>l \\<turnstile>c left s \\<surd>", "then"], ["proof (chain)\npicking this:\n  (y, s') \\<in> set_spmf (left s x)\n  I s\n  x \\<in> outs_\\<I> \\<I>l", "have \"(Inl y, s') \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s (Inl x))\""], ["proof (prove)\nusing this:\n  (y, s') \\<in> set_spmf (left s x)\n  I s\n  x \\<in> outs_\\<I> \\<I>l\n\ngoal (1 subgoal):\n 1. (Inl y, s') \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s (Inl x))", "by(auto intro: rev_image_eqI)"], ["proof (state)\nthis:\n  (Inl y, s') \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s (Inl x))\n\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (left s x); I s;\n        x \\<in> outs_\\<I> \\<I>l\\<rbrakk>\n       \\<Longrightarrow> I s'\n 2. \\<And>s. I s \\<Longrightarrow> \\<I>l \\<turnstile>c left s \\<surd>", "then"], ["proof (chain)\npicking this:\n  (Inl y, s') \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s (Inl x))", "show \"I s'\""], ["proof (prove)\nusing this:\n  (Inl y, s') \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s (Inl x))\n\ngoal (1 subgoal):\n 1. I s'", "using \\<open>I s\\<close>"], ["proof (prove)\nusing this:\n  (Inl y, s') \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s (Inl x))\n  I s\n\ngoal (1 subgoal):\n 1. I s'", "by(rule plus.callee_invariant)(simp add: \\<open>x \\<in> outs_\\<I> \\<I>l\\<close>)"], ["proof (state)\nthis:\n  I s'\n\ngoal (1 subgoal):\n 1. \\<And>s. I s \\<Longrightarrow> \\<I>l \\<turnstile>c left s \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. I s \\<Longrightarrow> \\<I>l \\<turnstile>c left s \\<surd>", "show \"\\<I>l \\<turnstile>c left s \\<surd>\" if \"I s\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>l \\<turnstile>c left s \\<surd>", "using plus.WT_callee[OF that]"], ["proof (prove)\nusing this:\n  \\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c\n  (left \\<oplus>\\<^sub>O right) s \\<surd>\n\ngoal (1 subgoal):\n 1. \\<I>l \\<turnstile>c left s \\<surd>", "by simp"], ["proof (state)\nthis:\n  I ?s \\<Longrightarrow> \\<I>l \\<turnstile>c left ?s \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  callee_invariant_on left I \\<I>l\n\ngoal (2 subgoals):\n 1. callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n     (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r) \\<Longrightarrow>\n    callee_invariant_on right I \\<I>r\n 2. callee_invariant_on left I \\<I>l \\<and>\n    callee_invariant_on right I \\<I>r \\<Longrightarrow>\n    callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n     (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)", "show \"callee_invariant_on right I \\<I>r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on right I \\<I>r", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (right s x); I s;\n        x \\<in> outs_\\<I> \\<I>r\\<rbrakk>\n       \\<Longrightarrow> I s'\n 2. \\<And>s. I s \\<Longrightarrow> \\<I>r \\<turnstile>c right s \\<surd>", "fix s x y s'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (right s x); I s;\n        x \\<in> outs_\\<I> \\<I>r\\<rbrakk>\n       \\<Longrightarrow> I s'\n 2. \\<And>s. I s \\<Longrightarrow> \\<I>r \\<turnstile>c right s \\<surd>", "assume \"(y, s') \\<in> set_spmf (right s x)\" and \"I s\" and \"x \\<in> outs_\\<I> \\<I>r\""], ["proof (state)\nthis:\n  (y, s') \\<in> set_spmf (right s x)\n  I s\n  x \\<in> outs_\\<I> \\<I>r\n\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (right s x); I s;\n        x \\<in> outs_\\<I> \\<I>r\\<rbrakk>\n       \\<Longrightarrow> I s'\n 2. \\<And>s. I s \\<Longrightarrow> \\<I>r \\<turnstile>c right s \\<surd>", "then"], ["proof (chain)\npicking this:\n  (y, s') \\<in> set_spmf (right s x)\n  I s\n  x \\<in> outs_\\<I> \\<I>r", "have \"(Inr y, s') \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s (Inr x))\""], ["proof (prove)\nusing this:\n  (y, s') \\<in> set_spmf (right s x)\n  I s\n  x \\<in> outs_\\<I> \\<I>r\n\ngoal (1 subgoal):\n 1. (Inr y, s') \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s (Inr x))", "by(auto intro: rev_image_eqI)"], ["proof (state)\nthis:\n  (Inr y, s') \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s (Inr x))\n\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (right s x); I s;\n        x \\<in> outs_\\<I> \\<I>r\\<rbrakk>\n       \\<Longrightarrow> I s'\n 2. \\<And>s. I s \\<Longrightarrow> \\<I>r \\<turnstile>c right s \\<surd>", "then"], ["proof (chain)\npicking this:\n  (Inr y, s') \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s (Inr x))", "show \"I s'\""], ["proof (prove)\nusing this:\n  (Inr y, s') \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s (Inr x))\n\ngoal (1 subgoal):\n 1. I s'", "using \\<open>I s\\<close>"], ["proof (prove)\nusing this:\n  (Inr y, s') \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s (Inr x))\n  I s\n\ngoal (1 subgoal):\n 1. I s'", "by(rule plus.callee_invariant)(simp add: \\<open>x \\<in> outs_\\<I> \\<I>r\\<close>)"], ["proof (state)\nthis:\n  I s'\n\ngoal (1 subgoal):\n 1. \\<And>s. I s \\<Longrightarrow> \\<I>r \\<turnstile>c right s \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. I s \\<Longrightarrow> \\<I>r \\<turnstile>c right s \\<surd>", "show \"\\<I>r \\<turnstile>c right s \\<surd>\" if \"I s\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>r \\<turnstile>c right s \\<surd>", "using plus.WT_callee[OF that]"], ["proof (prove)\nusing this:\n  \\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c\n  (left \\<oplus>\\<^sub>O right) s \\<surd>\n\ngoal (1 subgoal):\n 1. \\<I>r \\<turnstile>c right s \\<surd>", "by simp"], ["proof (state)\nthis:\n  I ?s \\<Longrightarrow> \\<I>r \\<turnstile>c right ?s \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  callee_invariant_on right I \\<I>r\n\ngoal (1 subgoal):\n 1. callee_invariant_on left I \\<I>l \\<and>\n    callee_invariant_on right I \\<I>r \\<Longrightarrow>\n    callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n     (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. callee_invariant_on left I \\<I>l \\<and>\n    callee_invariant_on right I \\<I>r \\<Longrightarrow>\n    callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n     (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)", "assume ?rhs"], ["proof (state)\nthis:\n  callee_invariant_on left I \\<I>l \\<and> callee_invariant_on right I \\<I>r\n\ngoal (1 subgoal):\n 1. callee_invariant_on left I \\<I>l \\<and>\n    callee_invariant_on right I \\<I>r \\<Longrightarrow>\n    callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n     (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)", "interpret left: callee_invariant_on left I \\<I>l"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on left I \\<I>l", "using \\<open>?rhs\\<close>"], ["proof (prove)\nusing this:\n  callee_invariant_on left I \\<I>l \\<and> callee_invariant_on right I \\<I>r\n\ngoal (1 subgoal):\n 1. callee_invariant_on left I \\<I>l", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. callee_invariant_on left I \\<I>l \\<and>\n    callee_invariant_on right I \\<I>r \\<Longrightarrow>\n    callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n     (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)", "interpret right: callee_invariant_on right I \\<I>r"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on right I \\<I>r", "using \\<open>?rhs\\<close>"], ["proof (prove)\nusing this:\n  callee_invariant_on left I \\<I>l \\<and> callee_invariant_on right I \\<I>r\n\ngoal (1 subgoal):\n 1. callee_invariant_on right I \\<I>r", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. callee_invariant_on left I \\<I>l \\<and>\n    callee_invariant_on right I \\<I>r \\<Longrightarrow>\n    callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n     (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)", "show ?lhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n     (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s x);\n        I s; x \\<in> outs_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)\\<rbrakk>\n       \\<Longrightarrow> I s'\n 2. \\<And>s.\n       I s \\<Longrightarrow>\n       \\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c\n       (left \\<oplus>\\<^sub>O right) s \\<surd>", "fix s x y s'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s x);\n        I s; x \\<in> outs_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)\\<rbrakk>\n       \\<Longrightarrow> I s'\n 2. \\<And>s.\n       I s \\<Longrightarrow>\n       \\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c\n       (left \\<oplus>\\<^sub>O right) s \\<surd>", "assume \"(y, s') \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s x)\" and \"I s\" and \"x \\<in> outs_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)\""], ["proof (state)\nthis:\n  (y, s') \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s x)\n  I s\n  x \\<in> outs_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)\n\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s x);\n        I s; x \\<in> outs_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)\\<rbrakk>\n       \\<Longrightarrow> I s'\n 2. \\<And>s.\n       I s \\<Longrightarrow>\n       \\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c\n       (left \\<oplus>\\<^sub>O right) s \\<surd>", "then"], ["proof (chain)\npicking this:\n  (y, s') \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s x)\n  I s\n  x \\<in> outs_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)", "have \"(projl y, s') \\<in> set_spmf (left s (projl x)) \\<and> projl x \\<in> outs_\\<I> \\<I>l \\<or>\n      (projr y, s') \\<in> set_spmf (right s (projr x)) \\<and> projr x \\<in> outs_\\<I> \\<I>r\""], ["proof (prove)\nusing this:\n  (y, s') \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s x)\n  I s\n  x \\<in> outs_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)\n\ngoal (1 subgoal):\n 1. (projl y, s') \\<in> set_spmf (left s (projl x)) \\<and>\n    projl x \\<in> outs_\\<I> \\<I>l \\<or>\n    (projr y, s') \\<in> set_spmf (right s (projr x)) \\<and>\n    projr x \\<in> outs_\\<I> \\<I>r", "by (cases x)  auto"], ["proof (state)\nthis:\n  (projl y, s') \\<in> set_spmf (left s (projl x)) \\<and>\n  projl x \\<in> outs_\\<I> \\<I>l \\<or>\n  (projr y, s') \\<in> set_spmf (right s (projr x)) \\<and>\n  projr x \\<in> outs_\\<I> \\<I>r\n\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf ((left \\<oplus>\\<^sub>O right) s x);\n        I s; x \\<in> outs_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)\\<rbrakk>\n       \\<Longrightarrow> I s'\n 2. \\<And>s.\n       I s \\<Longrightarrow>\n       \\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c\n       (left \\<oplus>\\<^sub>O right) s \\<surd>", "then"], ["proof (chain)\npicking this:\n  (projl y, s') \\<in> set_spmf (left s (projl x)) \\<and>\n  projl x \\<in> outs_\\<I> \\<I>l \\<or>\n  (projr y, s') \\<in> set_spmf (right s (projr x)) \\<and>\n  projr x \\<in> outs_\\<I> \\<I>r", "show \"I s'\""], ["proof (prove)\nusing this:\n  (projl y, s') \\<in> set_spmf (left s (projl x)) \\<and>\n  projl x \\<in> outs_\\<I> \\<I>l \\<or>\n  (projr y, s') \\<in> set_spmf (right s (projr x)) \\<and>\n  projr x \\<in> outs_\\<I> \\<I>r\n\ngoal (1 subgoal):\n 1. I s'", "using \\<open>I s\\<close>"], ["proof (prove)\nusing this:\n  (projl y, s') \\<in> set_spmf (left s (projl x)) \\<and>\n  projl x \\<in> outs_\\<I> \\<I>l \\<or>\n  (projr y, s') \\<in> set_spmf (right s (projr x)) \\<and>\n  projr x \\<in> outs_\\<I> \\<I>r\n  I s\n\ngoal (1 subgoal):\n 1. I s'", "by (auto dest: left.callee_invariant right.callee_invariant)"], ["proof (state)\nthis:\n  I s'\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       I s \\<Longrightarrow>\n       \\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c\n       (left \\<oplus>\\<^sub>O right) s \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       I s \\<Longrightarrow>\n       \\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c\n       (left \\<oplus>\\<^sub>O right) s \\<surd>", "show \"\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c (left \\<oplus>\\<^sub>O right) s \\<surd>\" if \"I s\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c\n    (left \\<oplus>\\<^sub>O right) s \\<surd>", "using left.WT_callee[OF that] right.WT_callee[OF that]"], ["proof (prove)\nusing this:\n  \\<I>l \\<turnstile>c left s \\<surd>\n  \\<I>r \\<turnstile>c right s \\<surd>\n\ngoal (1 subgoal):\n 1. \\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c\n    (left \\<oplus>\\<^sub>O right) s \\<surd>", "by simp"], ["proof (state)\nthis:\n  I ?s \\<Longrightarrow>\n  \\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c\n  (left \\<oplus>\\<^sub>O right) ?s \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n   (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma callee_invariant_plus_oracle [simp]:\n  \"callee_invariant (left \\<oplus>\\<^sub>O right) I \\<longleftrightarrow>\n   callee_invariant left I \\<and> callee_invariant right I\"\n  (is \"?lhs \\<longleftrightarrow>  ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant (left \\<oplus>\\<^sub>O right) I =\n    (callee_invariant left I \\<and> callee_invariant right I)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. callee_invariant (left \\<oplus>\\<^sub>O right) I =\n    (callee_invariant left I \\<and> callee_invariant right I)", "have \"?lhs \\<longleftrightarrow> callee_invariant_on (left \\<oplus>\\<^sub>O right) I (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant (left \\<oplus>\\<^sub>O right) I =\n    callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n     (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)", "by(rule callee_invariant_on_cong)(auto split: plus_oracle_split_asm)"], ["proof (state)\nthis:\n  callee_invariant (left \\<oplus>\\<^sub>O right) I =\n  callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n   (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)\n\ngoal (1 subgoal):\n 1. callee_invariant (left \\<oplus>\\<^sub>O right) I =\n    (callee_invariant left I \\<and> callee_invariant right I)", "also"], ["proof (state)\nthis:\n  callee_invariant (left \\<oplus>\\<^sub>O right) I =\n  callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n   (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)\n\ngoal (1 subgoal):\n 1. callee_invariant (left \\<oplus>\\<^sub>O right) I =\n    (callee_invariant left I \\<and> callee_invariant right I)", "have \"\\<dots> \\<longleftrightarrow> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n     (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) =\n    (callee_invariant left I \\<and> callee_invariant right I)", "by(rule callee_invariant_on_plus_oracle)"], ["proof (state)\nthis:\n  callee_invariant_on (left \\<oplus>\\<^sub>O right) I\n   (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) =\n  (callee_invariant left I \\<and> callee_invariant right I)\n\ngoal (1 subgoal):\n 1. callee_invariant (left \\<oplus>\\<^sub>O right) I =\n    (callee_invariant left I \\<and> callee_invariant right I)", "finally"], ["proof (chain)\npicking this:\n  callee_invariant (left \\<oplus>\\<^sub>O right) I =\n  (callee_invariant left I \\<and> callee_invariant right I)", "show ?thesis"], ["proof (prove)\nusing this:\n  callee_invariant (left \\<oplus>\\<^sub>O right) I =\n  (callee_invariant left I \\<and> callee_invariant right I)\n\ngoal (1 subgoal):\n 1. callee_invariant (left \\<oplus>\\<^sub>O right) I =\n    (callee_invariant left I \\<and> callee_invariant right I)", "."], ["proof (state)\nthis:\n  callee_invariant (left \\<oplus>\\<^sub>O right) I =\n  (callee_invariant left I \\<and> callee_invariant right I)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma plus_oracle_parametric [transfer_rule]:\n  includes lifting_syntax shows\n  \"((S ===> A ===> rel_spmf (rel_prod B S))\n   ===> (S ===> C ===> rel_spmf (rel_prod D S))\n   ===> S ===> rel_sum A C ===> rel_spmf (rel_prod (rel_sum B D) S))\n   plus_oracle plus_oracle\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> A ===> rel_spmf (rel_prod B S)) ===>\n     (S ===> C ===> rel_spmf (rel_prod D S)) ===>\n     S ===> rel_sum A C ===> rel_spmf (rel_prod (rel_sum B D) S))\n     (\\<oplus>\\<^sub>O) (\\<oplus>\\<^sub>O)", "unfolding plus_oracle_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> A ===> rel_spmf (rel_prod B S)) ===>\n     (S ===> C ===> rel_spmf (rel_prod D S)) ===>\n     S ===> rel_sum A C ===> rel_spmf (rel_prod (rel_sum B D) S))\n     (\\<lambda>left right s uu.\n         case uu of Inl a \\<Rightarrow> map_spmf (apfst Inl) (left s a)\n         | Inr b \\<Rightarrow> map_spmf (apfst Inr) (right s b))\n     (\\<lambda>left right s uu.\n         case uu of Inl a \\<Rightarrow> map_spmf (apfst Inl) (left s a)\n         | Inr b \\<Rightarrow> map_spmf (apfst Inr) (right s b))", "by transfer_prover"], ["", "lemma rel_spmf_plus_oracle:\n  \"\\<lbrakk> \\<And>q1' q2'. \\<lbrakk> q1 = Inl q1'; q2 = Inl q2' \\<rbrakk> \\<Longrightarrow> rel_spmf (rel_prod B S) (left1 s1 q1') (left2 s2 q2');\n    \\<And>q1' q2'. \\<lbrakk> q1 = Inr q1'; q2 = Inr q2' \\<rbrakk> \\<Longrightarrow> rel_spmf (rel_prod D S) (right1 s1 q1') (right2 s2 q2');\n    S s1 s2; rel_sum A C q1 q2 \\<rbrakk>\n  \\<Longrightarrow> rel_spmf (rel_prod (rel_sum B D) S) ((left1 \\<oplus>\\<^sub>O right1) s1 q1) ((left2 \\<oplus>\\<^sub>O right2) s2 q2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q1' q2'.\n                \\<lbrakk>q1 = Inl q1'; q2 = Inl q2'\\<rbrakk>\n                \\<Longrightarrow> rel_spmf (rel_prod B S) (left1 s1 q1')\n                                   (left2 s2 q2');\n     \\<And>q1' q2'.\n        \\<lbrakk>q1 = Inr q1'; q2 = Inr q2'\\<rbrakk>\n        \\<Longrightarrow> rel_spmf (rel_prod D S) (right1 s1 q1')\n                           (right2 s2 q2');\n     S s1 s2; rel_sum A C q1 q2\\<rbrakk>\n    \\<Longrightarrow> rel_spmf (rel_prod (rel_sum B D) S)\n                       ((left1 \\<oplus>\\<^sub>O right1) s1 q1)\n                       ((left2 \\<oplus>\\<^sub>O right2) s2 q2)", "apply(erule rel_sum.cases; clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a c.\n       \\<lbrakk>\\<And>q1' q2'.\n                   \\<lbrakk>a = q1'; c = q2'\\<rbrakk>\n                   \\<Longrightarrow> rel_spmf (rel_prod B S) (left1 s1 q1')\n(left2 s2 q2');\n        S s1 s2; q1 = Inl a; q2 = Inl c; A a c\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod (rel_sum B D) S)\n                          (map_spmf (apfst Inl) (left1 s1 a))\n                          (map_spmf (apfst Inl) (left2 s2 c))\n 2. \\<And>b d.\n       \\<lbrakk>\\<And>q1' q2'.\n                   \\<lbrakk>b = q1'; d = q2'\\<rbrakk>\n                   \\<Longrightarrow> rel_spmf (rel_prod D S) (right1 s1 q1')\n(right2 s2 q2');\n        S s1 s2; q1 = Inr b; q2 = Inr d; C b d\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod (rel_sum B D) S)\n                          (map_spmf (apfst Inr) (right1 s1 b))\n                          (map_spmf (apfst Inr) (right2 s2 d))", "apply(erule meta_allE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a c.\n       \\<lbrakk>S s1 s2; q1 = Inl a; q2 = Inl c; A a c;\n        \\<lbrakk>a = ?q1'9 a c; c = ?q2'11 a c\\<rbrakk>\n        \\<Longrightarrow> rel_spmf (rel_prod B S) (left1 s1 (?q1'9 a c))\n                           (left2 s2 (?q2'11 a c))\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod (rel_sum B D) S)\n                          (map_spmf (apfst Inl) (left1 s1 a))\n                          (map_spmf (apfst Inl) (left2 s2 c))\n 2. \\<And>b d.\n       \\<lbrakk>\\<And>q1' q2'.\n                   \\<lbrakk>b = q1'; d = q2'\\<rbrakk>\n                   \\<Longrightarrow> rel_spmf (rel_prod D S) (right1 s1 q1')\n(right2 s2 q2');\n        S s1 s2; q1 = Inr b; q2 = Inr d; C b d\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod (rel_sum B D) S)\n                          (map_spmf (apfst Inr) (right1 s1 b))\n                          (map_spmf (apfst Inr) (right2 s2 d))", "apply(erule meta_impE, rule refl)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a c.\n       \\<lbrakk>S s1 s2; q1 = Inl a; q2 = Inl c; A a c;\n        rel_spmf (rel_prod B S) (left1 s1 a) (left2 s2 c)\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod (rel_sum B D) S)\n                          (map_spmf (apfst Inl) (left1 s1 a))\n                          (map_spmf (apfst Inl) (left2 s2 c))\n 2. \\<And>b d.\n       \\<lbrakk>\\<And>q1' q2'.\n                   \\<lbrakk>b = q1'; d = q2'\\<rbrakk>\n                   \\<Longrightarrow> rel_spmf (rel_prod D S) (right1 s1 q1')\n(right2 s2 q2');\n        S s1 s2; q1 = Inr b; q2 = Inr d; C b d\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod (rel_sum B D) S)\n                          (map_spmf (apfst Inr) (right1 s1 b))\n                          (map_spmf (apfst Inr) (right2 s2 d))", "subgoal premises [transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (rel_prod (rel_sum B D) S) (map_spmf (apfst Inl) (left1 s1 a_))\n     (map_spmf (apfst Inl) (left2 s2 c_))", "by transfer_prover"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b d.\n       \\<lbrakk>\\<And>q1' q2'.\n                   \\<lbrakk>b = q1'; d = q2'\\<rbrakk>\n                   \\<Longrightarrow> rel_spmf (rel_prod D S) (right1 s1 q1')\n(right2 s2 q2');\n        S s1 s2; q1 = Inr b; q2 = Inr d; C b d\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod (rel_sum B D) S)\n                          (map_spmf (apfst Inr) (right1 s1 b))\n                          (map_spmf (apfst Inr) (right2 s2 d))", "apply(erule meta_allE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b d.\n       \\<lbrakk>S s1 s2; q1 = Inr b; q2 = Inr d; C b d;\n        \\<lbrakk>b = ?q1'21 b d; d = ?q2'23 b d\\<rbrakk>\n        \\<Longrightarrow> rel_spmf (rel_prod D S) (right1 s1 (?q1'21 b d))\n                           (right2 s2 (?q2'23 b d))\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod (rel_sum B D) S)\n                          (map_spmf (apfst Inr) (right1 s1 b))\n                          (map_spmf (apfst Inr) (right2 s2 d))", "apply(erule meta_impE, rule refl)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b d.\n       \\<lbrakk>S s1 s2; q1 = Inr b; q2 = Inr d; C b d;\n        rel_spmf (rel_prod D S) (right1 s1 b) (right2 s2 d)\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod (rel_sum B D) S)\n                          (map_spmf (apfst Inr) (right1 s1 b))\n                          (map_spmf (apfst Inr) (right2 s2 d))", "subgoal premises [transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (rel_prod (rel_sum B D) S)\n     (map_spmf (apfst Inr) (right1 s1 b_))\n     (map_spmf (apfst Inr) (right2 s2 d_))", "by transfer_prover"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \\<open>Shared state with aborts\\<close>"], ["", "context\n  fixes left :: \"('s, 'a, 'b option) oracle'\"\n  and right :: \"('s,'c, 'd option) oracle'\"\n  and s :: \"'s\"\nbegin"], ["", "primrec plus_oracle_stop :: \"'a + 'c \\<Rightarrow> (('b + 'd) option \\<times> 's) spmf\"\nwhere\n  \"plus_oracle_stop (Inl a) = map_spmf (apfst (map_option Inl)) (left s a)\"\n| \"plus_oracle_stop (Inr b) = map_spmf (apfst (map_option Inr)) (right s b)\""], ["", "lemma lossless_plus_oracle_stopI [intro, simp]:\n  \"\\<lbrakk> \\<And>a. x = Inl a \\<Longrightarrow> lossless_spmf (left s a); \n     \\<And>b. x = Inr b \\<Longrightarrow> lossless_spmf (right s b) \\<rbrakk>\n  \\<Longrightarrow> lossless_spmf (plus_oracle_stop x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a. x = Inl a \\<Longrightarrow> lossless_spmf (left s a);\n     \\<And>b. x = Inr b \\<Longrightarrow> lossless_spmf (right s b)\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf (local.plus_oracle_stop x)", "by(cases x) simp_all"], ["", "lemma plus_oracle_stop_split:\n  \"P (plus_oracle_stop lr) \\<longleftrightarrow>\n  (\\<forall>x. lr = Inl x \\<longrightarrow> P (map_spmf (apfst (map_option Inl)) (left s x))) \\<and>\n  (\\<forall>y. lr = Inr y \\<longrightarrow> P (map_spmf (apfst (map_option Inr)) (right s y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (local.plus_oracle_stop lr) =\n    ((\\<forall>x.\n         lr = Inl x \\<longrightarrow>\n         P (map_spmf (apfst (map_option Inl)) (left s x))) \\<and>\n     (\\<forall>y.\n         lr = Inr y \\<longrightarrow>\n         P (map_spmf (apfst (map_option Inr)) (right s y))))", "by(cases lr) auto"], ["", "lemma plus_oracle_stop_split_asm:\n  \"P (plus_oracle_stop lr) \\<longleftrightarrow>\n  \\<not> ((\\<exists>x. lr = Inl x \\<and> \\<not> P (map_spmf (apfst (map_option Inl)) (left s x))) \\<or>\n     (\\<exists>y. lr = Inr y \\<and> \\<not> P (map_spmf (apfst (map_option Inr)) (right s y))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (local.plus_oracle_stop lr) =\n    (\\<not> ((\\<exists>x.\n                 lr = Inl x \\<and>\n                 \\<not> P (map_spmf (apfst (map_option Inl))\n                            (left s x))) \\<or>\n             (\\<exists>y.\n                 lr = Inr y \\<and>\n                 \\<not> P (map_spmf (apfst (map_option Inr)) (right s y)))))", "by(cases lr) auto"], ["", "end"], ["", "notation plus_oracle_stop (infix \"\\<oplus>\\<^sub>O\\<^sup>S\" 500)"], ["", "subsection \\<open>Disjoint state\\<close>"], ["", "context\n  fixes left :: \"('s1, 'a, 'b) oracle'\"\n  and right :: \"('s2, 'c, 'd) oracle'\"\nbegin"], ["", "fun parallel_oracle :: \"('s1 \\<times> 's2, 'a + 'c, 'b + 'd) oracle'\"\nwhere\n  \"parallel_oracle (s1, s2) (Inl a) = map_spmf (map_prod Inl (\\<lambda>s1'. (s1', s2))) (left s1 a)\"\n| \"parallel_oracle (s1, s2) (Inr b) = map_spmf (map_prod Inr (Pair s1)) (right s2 b)\""], ["", "lemma parallel_oracle_def:\n  \"parallel_oracle = (\\<lambda>(s1, s2). case_sum (\\<lambda>a. map_spmf (map_prod Inl (\\<lambda>s1'. (s1', s2))) (left s1 a)) (\\<lambda>b. map_spmf (map_prod Inr (Pair s1)) (right s2 b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.parallel_oracle =\n    (\\<lambda>(s1, s2).\n        case_sum\n         (\\<lambda>a.\n             map_spmf (map_prod Inl (\\<lambda>s1'. (s1', s2))) (left s1 a))\n         (\\<lambda>b. map_spmf (map_prod Inr (Pair s1)) (right s2 b)))", "by(auto intro!: ext split: sum.split)"], ["", "lemma lossless_parallel_oracle [simp]:\n  \"lossless_spmf (parallel_oracle s12 xy) \\<longleftrightarrow>\n   (\\<forall>x. xy = Inl x \\<longrightarrow> lossless_spmf (left (fst s12) x)) \\<and>\n   (\\<forall>y. xy = Inr y \\<longrightarrow> lossless_spmf (right (snd s12) y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (local.parallel_oracle s12 xy) =\n    ((\\<forall>x.\n         xy = Inl x \\<longrightarrow>\n         lossless_spmf (left (fst s12) x)) \\<and>\n     (\\<forall>y.\n         xy = Inr y \\<longrightarrow> lossless_spmf (right (snd s12) y)))", "by(cases s12; cases xy) simp_all"], ["", "lemma parallel_oracle_split:\n  \"P (parallel_oracle s1s2 lr) \\<longleftrightarrow>\n  (\\<forall>s1 s2 x. s1s2 = (s1, s2) \\<longrightarrow> lr = Inl x \\<longrightarrow> P (map_spmf (map_prod Inl (\\<lambda>s1'. (s1', s2))) (left s1 x))) \\<and>\n  (\\<forall>s1 s2 y. s1s2 = (s1, s2) \\<longrightarrow> lr = Inr y \\<longrightarrow> P (map_spmf (map_prod Inr (Pair s1)) (right s2 y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (local.parallel_oracle s1s2 lr) =\n    ((\\<forall>s1 s2 x.\n         s1s2 = (s1, s2) \\<longrightarrow>\n         lr = Inl x \\<longrightarrow>\n         P (map_spmf (map_prod Inl (\\<lambda>s1'. (s1', s2)))\n             (left s1 x))) \\<and>\n     (\\<forall>s1 s2 y.\n         s1s2 = (s1, s2) \\<longrightarrow>\n         lr = Inr y \\<longrightarrow>\n         P (map_spmf (map_prod Inr (Pair s1)) (right s2 y))))", "by(cases s1s2; cases lr) auto"], ["", "lemma parallel_oracle_split_asm:\n  \"P (parallel_oracle s1s2 lr) \\<longleftrightarrow>\n  \\<not> ((\\<exists>s1 s2 x. s1s2 = (s1, s2) \\<and> lr = Inl x \\<and> \\<not> P (map_spmf (map_prod Inl (\\<lambda>s1'. (s1', s2))) (left s1 x))) \\<or>\n     (\\<exists>s1 s2 y. s1s2 = (s1, s2) \\<and> lr = Inr y \\<and> \\<not> P (map_spmf (map_prod Inr (Pair s1)) (right s2 y))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (local.parallel_oracle s1s2 lr) =\n    (\\<not> ((\\<exists>s1 s2 x.\n                 s1s2 = (s1, s2) \\<and>\n                 lr = Inl x \\<and>\n                 \\<not> P (map_spmf (map_prod Inl (\\<lambda>s1'. (s1', s2)))\n                            (left s1 x))) \\<or>\n             (\\<exists>s1 s2 y.\n                 s1s2 = (s1, s2) \\<and>\n                 lr = Inr y \\<and>\n                 \\<not> P (map_spmf (map_prod Inr (Pair s1))\n                            (right s2 y)))))", "by(cases s1s2; cases lr) auto"], ["", "lemma WT_parallel_oracle [intro!, simp]:\n  \"\\<lbrakk> \\<I>l \\<turnstile>c left sl \\<surd>; \\<I>r \\<turnstile>c right sr \\<surd> \\<rbrakk> \\<Longrightarrow> plus_\\<I> \\<I>l \\<I>r \\<turnstile>c parallel_oracle (sl, sr) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>l \\<turnstile>c left sl \\<surd>;\n     \\<I>r \\<turnstile>c right sr \\<surd>\\<rbrakk>\n    \\<Longrightarrow> \\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c\n                      local.parallel_oracle (sl, sr) \\<surd>", "by(rule WT_calleeI)(auto elim!: WT_calleeD simp add: inj_image_mem_iff)"], ["", "lemma callee_invariant_parallel_oracleI [simp, intro]:\n  assumes \"callee_invariant_on left Il \\<I>l\" \"callee_invariant_on right Ir \\<I>r\"\n  shows \"callee_invariant_on parallel_oracle (pred_prod Il Ir) (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on local.parallel_oracle (pred_prod Il Ir)\n     (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (local.parallel_oracle s x);\n        pred_prod Il Ir s;\n        x \\<in> outs_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)\\<rbrakk>\n       \\<Longrightarrow> pred_prod Il Ir s'\n 2. \\<And>s.\n       pred_prod Il Ir s \\<Longrightarrow>\n       \\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c\n       local.parallel_oracle s \\<surd>", "interpret left: callee_invariant_on left Il \\<I>l"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on left Il \\<I>l", "by fact"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (local.parallel_oracle s x);\n        pred_prod Il Ir s;\n        x \\<in> outs_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)\\<rbrakk>\n       \\<Longrightarrow> pred_prod Il Ir s'\n 2. \\<And>s.\n       pred_prod Il Ir s \\<Longrightarrow>\n       \\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c\n       local.parallel_oracle s \\<surd>", "interpret right: callee_invariant_on right Ir \\<I>r"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on right Ir \\<I>r", "by fact"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (local.parallel_oracle s x);\n        pred_prod Il Ir s;\n        x \\<in> outs_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)\\<rbrakk>\n       \\<Longrightarrow> pred_prod Il Ir s'\n 2. \\<And>s.\n       pred_prod Il Ir s \\<Longrightarrow>\n       \\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c\n       local.parallel_oracle s \\<surd>", "show \"pred_prod Il Ir s12'\"\n    if \"(y, s12') \\<in> set_spmf (parallel_oracle s12 x)\" and \"pred_prod Il Ir s12\" and \"x \\<in> outs_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)\"\n    for s12 x y s12'"], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_prod Il Ir s12'", "using that"], ["proof (prove)\nusing this:\n  (y, s12') \\<in> set_spmf (local.parallel_oracle s12 x)\n  pred_prod Il Ir s12\n  x \\<in> outs_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)\n\ngoal (1 subgoal):\n 1. pred_prod Il Ir s12'", "by(cases s12; cases s12; cases x)(auto dest: left.callee_invariant right.callee_invariant)"], ["proof (state)\nthis:\n  \\<lbrakk>(?y, ?s12') \\<in> set_spmf (local.parallel_oracle ?s12.0 ?x);\n   pred_prod Il Ir ?s12.0;\n   ?x \\<in> outs_\\<I> (\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r)\\<rbrakk>\n  \\<Longrightarrow> pred_prod Il Ir ?s12'\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       pred_prod Il Ir s \\<Longrightarrow>\n       \\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c\n       local.parallel_oracle s \\<surd>", "show \"\\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c local.parallel_oracle s \\<surd>\" if \"pred_prod Il Ir s\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c\n    local.parallel_oracle s \\<surd>", "using that"], ["proof (prove)\nusing this:\n  pred_prod Il Ir s\n\ngoal (1 subgoal):\n 1. \\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c\n    local.parallel_oracle s \\<surd>", "by(cases s)(simp add: left.WT_callee right.WT_callee)"], ["proof (state)\nthis:\n  pred_prod Il Ir ?s \\<Longrightarrow>\n  \\<I>l \\<oplus>\\<^sub>\\<I> \\<I>r \\<turnstile>c\n  local.parallel_oracle ?s \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma parallel_oracle_parametric:\n  includes lifting_syntax shows\n  \"((S1 ===> CALL1 ===> rel_spmf (rel_prod (=) S1)) \n  ===> (S2 ===> CALL2 ===> rel_spmf (rel_prod (=) S2))\n  ===> rel_prod S1 S2 ===> rel_sum CALL1 CALL2 ===> rel_spmf (rel_prod (=) (rel_prod S1 S2)))\n  parallel_oracle parallel_oracle\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S1 ===> CALL1 ===> rel_spmf (rel_prod (=) S1)) ===>\n     (S2 ===> CALL2 ===> rel_spmf (rel_prod (=) S2)) ===>\n     rel_prod S1 S2 ===>\n     rel_sum CALL1 CALL2 ===> rel_spmf (rel_prod (=) (rel_prod S1 S2)))\n     parallel_oracle parallel_oracle", "unfolding parallel_oracle_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S1 ===> CALL1 ===> rel_spmf (rel_prod (=) S1)) ===>\n     (S2 ===> CALL2 ===> rel_spmf (rel_prod (=) S2)) ===>\n     rel_prod S1 S2 ===>\n     rel_sum CALL1 CALL2 ===> rel_spmf (rel_prod (=) (rel_prod S1 S2)))\n     (\\<lambda>left right (s1, s2).\n         case_sum\n          (\\<lambda>a.\n              map_spmf (map_prod Inl (\\<lambda>s1'. (s1', s2))) (left s1 a))\n          (\\<lambda>b. map_spmf (map_prod Inr (Pair s1)) (right s2 b)))\n     (\\<lambda>left right (s1, s2).\n         case_sum\n          (\\<lambda>a.\n              map_spmf (map_prod Inl (\\<lambda>s1'. (s1', s2))) (left s1 a))\n          (\\<lambda>b. map_spmf (map_prod Inr (Pair s1)) (right s2 b)))", "by (fold relator_eq)transfer_prover"], ["", "subsection \\<open>Indexed oracles\\<close>"], ["", "definition family_oracle :: \"('i \\<Rightarrow> ('s, 'a, 'b) oracle') \\<Rightarrow> ('i \\<Rightarrow> 's, 'i \\<times> 'a, 'b) oracle'\"\nwhere \"family_oracle f s = (\\<lambda>(i, x). map_spmf (\\<lambda>(y, s'). (y, s(i := s'))) (f i (s i) x))\""], ["", "lemma family_oracle_apply [simp]:\n  \"family_oracle f s (i, x) = map_spmf (apsnd (fun_upd s i)) (f i (s i) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. family_oracle f s (i, x) = map_spmf (apsnd (fun_upd s i)) (f i (s i) x)", "by(simp add: family_oracle_def apsnd_def map_prod_def)"], ["", "lemma lossless_family_oracle:\n  \"lossless_spmf (family_oracle f s ix) \\<longleftrightarrow> lossless_spmf (f (fst ix) (s (fst ix)) (snd ix))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (family_oracle f s ix) =\n    lossless_spmf (f (fst ix) (s (fst ix)) (snd ix))", "by(simp add: family_oracle_def split_beta)"], ["", "subsection \\<open>State extension\\<close>"], ["", "definition extend_state_oracle :: \"('call, 'ret, 's) callee \\<Rightarrow> ('call, 'ret, 's' \\<times> 's) callee\" (\"\\<dagger>_\" [1000] 1000)\nwhere \"extend_state_oracle callee = (\\<lambda>(s', s) x. map_spmf (\\<lambda>(y, s). (y, (s', s))) (callee s x))\""], ["", "lemma extend_state_oracle_simps [simp]:\n  \"extend_state_oracle callee (s', s) x = map_spmf (\\<lambda>(y, s). (y, (s', s))) (callee s x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<dagger>callee (s', s) x =\n    map_spmf (\\<lambda>(y, s). (y, s', s)) (callee s x)", "by(simp add: extend_state_oracle_def)"], ["", "context includes lifting_syntax begin"], ["", "lemma extend_state_oracle_parametric [transfer_rule]:\n  \"((S ===> C ===> rel_spmf (rel_prod R S)) ===> rel_prod S' S ===> C ===> rel_spmf (rel_prod R (rel_prod S' S)))\n  extend_state_oracle extend_state_oracle\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> C ===> rel_spmf (rel_prod R S)) ===>\n     rel_prod S' S ===> C ===> rel_spmf (rel_prod R (rel_prod S' S)))\n     extend_state_oracle extend_state_oracle", "unfolding extend_state_oracle_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> C ===> rel_spmf (rel_prod R S)) ===>\n     rel_prod S' S ===> C ===> rel_spmf (rel_prod R (rel_prod S' S)))\n     (\\<lambda>callee (s', s) x.\n         map_spmf (\\<lambda>(y, s). (y, s', s)) (callee s x))\n     (\\<lambda>callee (s', s) x.\n         map_spmf (\\<lambda>(y, s). (y, s', s)) (callee s x))", "by transfer_prover"], ["", "lemma extend_state_oracle_transfer:\n  \"((S ===> C ===> rel_spmf (rel_prod R S)) \n  ===> rel_prod2 S ===> C ===> rel_spmf (rel_prod R (rel_prod2 S)))\n  (\\<lambda>oracle. oracle) extend_state_oracle\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> C ===> rel_spmf (rel_prod R S)) ===>\n     rel_prod2 S ===> C ===> rel_spmf (rel_prod R (rel_prod2 S)))\n     (\\<lambda>oracle. oracle) extend_state_oracle", "unfolding extend_state_oracle_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> C ===> rel_spmf (rel_prod R S)) ===>\n     rel_prod2 S ===> C ===> rel_spmf (rel_prod R (rel_prod2 S)))\n     (\\<lambda>oracle. oracle)\n     (\\<lambda>callee (s', s) x.\n         map_spmf (\\<lambda>(y, s). (y, s', s)) (callee s x))", "apply(rule rel_funI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(S ===> C ===> rel_spmf (rel_prod R S)) x y;\n        rel_prod2 S xa ya; C xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod R (rel_prod2 S)) (x xa xb)\n                          ((case ya of\n                            (s', s) \\<Rightarrow>\n                              \\<lambda>x.\n                                 map_spmf (\\<lambda>(y, s). (y, s', s))\n                                  (y s x))\n                            yb)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa a b xb yb.\n       \\<lbrakk>(S ===> C ===> rel_spmf (rel_prod R S)) x y; S xa b;\n        C xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod R (rel_prod2 S)) (x xa xb)\n                          (map_spmf (\\<lambda>(y, s). (y, a, s)) (y b yb))", "apply(drule (1) rel_funD)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa a b xb yb.\n       \\<lbrakk>S xa b; C xb yb;\n        rel_spmf (rel_prod R S) (x xa xb) (y b yb)\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod R (rel_prod2 S)) (x xa xb)\n                          (map_spmf (\\<lambda>(y, s). (y, a, s)) (y b yb))", "apply(auto simp add: spmf_rel_map split_def dest: rel_funD intro: rel_spmf_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma callee_invariant_extend_state_oracle_const [simp]:\n  \"callee_invariant \\<dagger>oracle (\\<lambda>(s', s). I s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant \\<dagger>oracle (\\<lambda>(s', s). I s')", "by unfold_locales auto"], ["", "lemma callee_invariant_extend_state_oracle_const':\n  \"callee_invariant \\<dagger>oracle (\\<lambda>s. I (fst s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant \\<dagger>oracle (\\<lambda>s. I (fst s))", "by unfold_locales auto"], ["", "definition lift_stop_oracle :: \"('call, 'ret, 's) callee \\<Rightarrow> ('call, 'ret option, 's) callee\"\nwhere \"lift_stop_oracle oracle s x = map_spmf (apfst Some) (oracle s x)\""], ["", "lemma lift_stop_oracle_apply [simp]: \"lift_stop_oracle  oracle s x = map_spmf (apfst Some) (oracle s x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_stop_oracle oracle s x = map_spmf (apfst Some) (oracle s x)", "by(fact lift_stop_oracle_def)"], ["", "context includes lifting_syntax begin"], ["", "lemma lift_stop_oracle_transfer:\n  \"((S ===> C ===> rel_spmf (rel_prod R S)) ===> (S ===> C ===> rel_spmf (rel_prod (pcr_Some R) S)))\n   (\\<lambda>x. x) lift_stop_oracle\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> C ===> rel_spmf (rel_prod R S)) ===>\n     S ===> C ===> rel_spmf (rel_prod (pcr_Some R) S))\n     (\\<lambda>x. x) lift_stop_oracle", "unfolding lift_stop_oracle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> C ===> rel_spmf (rel_prod R S)) ===>\n     S ===> C ===> rel_spmf (rel_prod (pcr_Some R) S))\n     (\\<lambda>x. x)\n     (\\<lambda>oracle s x. map_spmf (apfst Some) (oracle s x))", "apply(rule rel_funI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(S ===> C ===> rel_spmf (rel_prod R S)) x y; S xa ya;\n        C xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod (pcr_Some R) S) (x xa xb)\n                          (map_spmf (apfst Some) (y ya yb))", "apply(drule (1) rel_funD)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>S xa ya; C xb yb;\n        rel_spmf (rel_prod R S) (x xa xb) (y ya yb)\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod (pcr_Some R) S) (x xa xb)\n                          (map_spmf (apfst Some) (y ya yb))", "apply(simp add: spmf_rel_map apfst_def prod.rel_map)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "definition extend_state_oracle2 :: \"('call, 'ret, 's) callee \\<Rightarrow> ('call, 'ret, 's \\<times> 's') callee\" (\"_\\<dagger>\" [1000] 1000)\n  where \"extend_state_oracle2 callee = (\\<lambda>(s, s') x. map_spmf (\\<lambda>(y, s). (y, (s, s'))) (callee s x))\""], ["", "lemma extend_state_oracle2_simps [simp]:\n  \"extend_state_oracle2 callee (s, s') x = map_spmf (\\<lambda>(y, s). (y, (s, s'))) (callee s x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee\\<dagger> (s, s') x =\n    map_spmf (\\<lambda>(y, s). (y, s, s')) (callee s x)", "by(simp add: extend_state_oracle2_def)"], ["", "lemma extend_state_oracle2_parametric [transfer_rule]: includes lifting_syntax shows\n  \"((S ===> C ===> rel_spmf (rel_prod R S)) ===> rel_prod S S' ===> C ===> rel_spmf (rel_prod R (rel_prod S S')))\n  extend_state_oracle2 extend_state_oracle2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> C ===> rel_spmf (rel_prod R S)) ===>\n     rel_prod S S' ===> C ===> rel_spmf (rel_prod R (rel_prod S S')))\n     extend_state_oracle2 extend_state_oracle2", "unfolding extend_state_oracle2_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> C ===> rel_spmf (rel_prod R S)) ===>\n     rel_prod S S' ===> C ===> rel_spmf (rel_prod R (rel_prod S S')))\n     (\\<lambda>callee (s, s') x.\n         map_spmf (\\<lambda>(y, s). (y, s, s')) (callee s x))\n     (\\<lambda>callee (s, s') x.\n         map_spmf (\\<lambda>(y, s). (y, s, s')) (callee s x))", "by transfer_prover"], ["", "lemma callee_invariant_extend_state_oracle2_const [simp]:\n  \"callee_invariant oracle\\<dagger> (\\<lambda>(s, s'). I s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant oracle\\<dagger> (\\<lambda>(s, s'). I s')", "by unfold_locales auto"], ["", "lemma callee_invariant_extend_state_oracle2_const':\n  \"callee_invariant oracle\\<dagger> (\\<lambda>s. I (snd s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant oracle\\<dagger> (\\<lambda>s. I (snd s))", "by unfold_locales auto"], ["", "lemma extend_state_oracle2_plus_oracle: \n  \"extend_state_oracle2 (plus_oracle oracle1 oracle2) = plus_oracle (extend_state_oracle2 oracle1) (extend_state_oracle2 oracle2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (oracle1 \\<oplus>\\<^sub>O oracle2)\\<dagger> =\n    oracle1\\<dagger> \\<oplus>\\<^sub>O oracle2\\<dagger>", "proof((rule ext)+; goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (oracle1 \\<oplus>\\<^sub>O oracle2)\\<dagger> x xa =\n       (oracle1\\<dagger> \\<oplus>\\<^sub>O oracle2\\<dagger>) x xa", "case (1 s q)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (oracle1 \\<oplus>\\<^sub>O oracle2)\\<dagger> x xa =\n       (oracle1\\<dagger> \\<oplus>\\<^sub>O oracle2\\<dagger>) x xa", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (oracle1 \\<oplus>\\<^sub>O oracle2)\\<dagger> s q =\n    (oracle1\\<dagger> \\<oplus>\\<^sub>O oracle2\\<dagger>) s q", "by (cases s; cases q) (simp_all add: apfst_def spmf.map_comp o_def split_def)"], ["proof (state)\nthis:\n  (oracle1 \\<oplus>\\<^sub>O oracle2)\\<dagger> s q =\n  (oracle1\\<dagger> \\<oplus>\\<^sub>O oracle2\\<dagger>) s q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma parallel_oracle_conv_plus_oracle:\n  \"parallel_oracle oracle1 oracle2 = plus_oracle (oracle1\\<dagger>) (\\<dagger>oracle2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parallel_oracle oracle1 oracle2 =\n    oracle1\\<dagger> \\<oplus>\\<^sub>O \\<dagger>oracle2", "proof((rule ext)+; goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       parallel_oracle oracle1 oracle2 x xa =\n       (oracle1\\<dagger> \\<oplus>\\<^sub>O \\<dagger>oracle2) x xa", "case (1 s q)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       parallel_oracle oracle1 oracle2 x xa =\n       (oracle1\\<dagger> \\<oplus>\\<^sub>O \\<dagger>oracle2) x xa", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. parallel_oracle oracle1 oracle2 s q =\n    (oracle1\\<dagger> \\<oplus>\\<^sub>O \\<dagger>oracle2) s q", "by (cases s; cases q) (auto simp add: spmf.map_comp apfst_def o_def split_def map_prod_def)"], ["proof (state)\nthis:\n  parallel_oracle oracle1 oracle2 s q =\n  (oracle1\\<dagger> \\<oplus>\\<^sub>O \\<dagger>oracle2) s q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_sum_parallel_oracle: includes lifting_syntax shows\n  \"(id ---> map_sum f g ---> map_spmf (map_prod (map_sum h k) id)) (parallel_oracle oracle1 oracle2)\n  = parallel_oracle ((id ---> f ---> map_spmf (map_prod h id)) oracle1) ((id ---> g ---> map_spmf (map_prod k id)) oracle2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (id ---> map_sum f g ---> map_spmf (map_prod (map_sum h k) id))\n     (parallel_oracle oracle1 oracle2) =\n    parallel_oracle ((id ---> f ---> map_spmf (map_prod h id)) oracle1)\n     ((id ---> g ---> map_spmf (map_prod k id)) oracle2)", "proof((rule ext)+; goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (id ---> map_sum f g ---> map_spmf (map_prod (map_sum h k) id))\n        (parallel_oracle oracle1 oracle2) x xa =\n       parallel_oracle ((id ---> f ---> map_spmf (map_prod h id)) oracle1)\n        ((id ---> g ---> map_spmf (map_prod k id)) oracle2) x xa", "case (1 s q)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (id ---> map_sum f g ---> map_spmf (map_prod (map_sum h k) id))\n        (parallel_oracle oracle1 oracle2) x xa =\n       parallel_oracle ((id ---> f ---> map_spmf (map_prod h id)) oracle1)\n        ((id ---> g ---> map_spmf (map_prod k id)) oracle2) x xa", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (id ---> map_sum f g ---> map_spmf (map_prod (map_sum h k) id))\n     (parallel_oracle oracle1 oracle2) s q =\n    parallel_oracle ((id ---> f ---> map_spmf (map_prod h id)) oracle1)\n     ((id ---> g ---> map_spmf (map_prod k id)) oracle2) s q", "by (cases s; cases q) (simp_all add: spmf.map_comp o_def apfst_def prod.map_comp)"], ["proof (state)\nthis:\n  (id ---> map_sum f g ---> map_spmf (map_prod (map_sum h k) id))\n   (parallel_oracle oracle1 oracle2) s q =\n  parallel_oracle ((id ---> f ---> map_spmf (map_prod h id)) oracle1)\n   ((id ---> g ---> map_spmf (map_prod k id)) oracle2) s q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_sum_plus_oracle: includes lifting_syntax shows\n  \"(id ---> map_sum f g ---> map_spmf (map_prod (map_sum h k) id)) (plus_oracle oracle1 oracle2)\n  = plus_oracle ((id ---> f ---> map_spmf (map_prod h id)) oracle1) ((id ---> g ---> map_spmf (map_prod k id)) oracle2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (id ---> map_sum f g ---> map_spmf (map_prod (map_sum h k) id))\n     (oracle1 \\<oplus>\\<^sub>O oracle2) =\n    (id ---> f ---> map_spmf (map_prod h id)) oracle1 \\<oplus>\\<^sub>O\n    (id ---> g ---> map_spmf (map_prod k id)) oracle2", "proof((rule ext)+; goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (id ---> map_sum f g ---> map_spmf (map_prod (map_sum h k) id))\n        (oracle1 \\<oplus>\\<^sub>O oracle2) x xa =\n       ((id ---> f ---> map_spmf (map_prod h id)) oracle1 \\<oplus>\\<^sub>O\n        (id ---> g ---> map_spmf (map_prod k id)) oracle2)\n        x xa", "case (1 s q)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (id ---> map_sum f g ---> map_spmf (map_prod (map_sum h k) id))\n        (oracle1 \\<oplus>\\<^sub>O oracle2) x xa =\n       ((id ---> f ---> map_spmf (map_prod h id)) oracle1 \\<oplus>\\<^sub>O\n        (id ---> g ---> map_spmf (map_prod k id)) oracle2)\n        x xa", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (id ---> map_sum f g ---> map_spmf (map_prod (map_sum h k) id))\n     (oracle1 \\<oplus>\\<^sub>O oracle2) s q =\n    ((id ---> f ---> map_spmf (map_prod h id)) oracle1 \\<oplus>\\<^sub>O\n     (id ---> g ---> map_spmf (map_prod k id)) oracle2)\n     s q", "by (cases q) (simp_all add: spmf.map_comp o_def apfst_def prod.map_comp)"], ["proof (state)\nthis:\n  (id ---> map_sum f g ---> map_spmf (map_prod (map_sum h k) id))\n   (oracle1 \\<oplus>\\<^sub>O oracle2) s q =\n  ((id ---> f ---> map_spmf (map_prod h id)) oracle1 \\<oplus>\\<^sub>O\n   (id ---> g ---> map_spmf (map_prod k id)) oracle2)\n   s q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_rsuml_plus_oracle: includes lifting_syntax shows\n  \"(id ---> rsuml ---> (map_spmf (map_prod lsumr id))) (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)) =\n   ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (id ---> rsuml ---> map_spmf (map_prod lsumr id))\n     (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)) =\n    (oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3", "proof((rule ext)+; goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (id ---> rsuml ---> map_spmf (map_prod lsumr id))\n        (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)) x xa =\n       ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3) x xa", "case (1 s q)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (id ---> rsuml ---> map_spmf (map_prod lsumr id))\n        (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)) x xa =\n       ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3) x xa", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (id ---> rsuml ---> map_spmf (map_prod lsumr id))\n     (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)) s q =\n    ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3) s q", "proof(cases q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       q = Inl a \\<Longrightarrow>\n       (id ---> rsuml ---> map_spmf (map_prod lsumr id))\n        (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)) s q =\n       ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3) s q\n 2. \\<And>b.\n       q = Inr b \\<Longrightarrow>\n       (id ---> rsuml ---> map_spmf (map_prod lsumr id))\n        (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)) s q =\n       ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3) s q", "case (Inl ql)"], ["proof (state)\nthis:\n  q = Inl ql\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       q = Inl a \\<Longrightarrow>\n       (id ---> rsuml ---> map_spmf (map_prod lsumr id))\n        (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)) s q =\n       ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3) s q\n 2. \\<And>b.\n       q = Inr b \\<Longrightarrow>\n       (id ---> rsuml ---> map_spmf (map_prod lsumr id))\n        (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)) s q =\n       ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3) s q", "then"], ["proof (chain)\npicking this:\n  q = Inl ql", "show ?thesis"], ["proof (prove)\nusing this:\n  q = Inl ql\n\ngoal (1 subgoal):\n 1. (id ---> rsuml ---> map_spmf (map_prod lsumr id))\n     (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)) s q =\n    ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3) s q", "by(cases ql)(simp_all add: spmf.map_comp o_def apfst_def prod.map_comp)"], ["proof (state)\nthis:\n  (id ---> rsuml ---> map_spmf (map_prod lsumr id))\n   (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)) s q =\n  ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3) s q\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       q = Inr b \\<Longrightarrow>\n       (id ---> rsuml ---> map_spmf (map_prod lsumr id))\n        (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)) s q =\n       ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3) s q", "qed (simp add: spmf.map_comp o_def apfst_def prod.map_comp id_def)"], ["proof (state)\nthis:\n  (id ---> rsuml ---> map_spmf (map_prod lsumr id))\n   (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)) s q =\n  ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3) s q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_lsumr_plus_oracle: includes lifting_syntax shows\n  \"(id ---> lsumr ---> (map_spmf (map_prod rsuml id))) ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3) =\n   (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (id ---> lsumr ---> map_spmf (map_prod rsuml id))\n     ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3) =\n    oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)", "proof((rule ext)+; goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (id ---> lsumr ---> map_spmf (map_prod rsuml id))\n        ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3) x xa =\n       (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)) x xa", "case (1 s q)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (id ---> lsumr ---> map_spmf (map_prod rsuml id))\n        ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3) x xa =\n       (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)) x xa", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (id ---> lsumr ---> map_spmf (map_prod rsuml id))\n     ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3) s q =\n    (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)) s q", "proof(cases q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       q = Inl a \\<Longrightarrow>\n       (id ---> lsumr ---> map_spmf (map_prod rsuml id))\n        ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3) s q =\n       (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)) s q\n 2. \\<And>b.\n       q = Inr b \\<Longrightarrow>\n       (id ---> lsumr ---> map_spmf (map_prod rsuml id))\n        ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3) s q =\n       (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)) s q", "case (Inr qr)"], ["proof (state)\nthis:\n  q = Inr qr\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       q = Inl a \\<Longrightarrow>\n       (id ---> lsumr ---> map_spmf (map_prod rsuml id))\n        ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3) s q =\n       (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)) s q\n 2. \\<And>b.\n       q = Inr b \\<Longrightarrow>\n       (id ---> lsumr ---> map_spmf (map_prod rsuml id))\n        ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3) s q =\n       (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)) s q", "then"], ["proof (chain)\npicking this:\n  q = Inr qr", "show ?thesis"], ["proof (prove)\nusing this:\n  q = Inr qr\n\ngoal (1 subgoal):\n 1. (id ---> lsumr ---> map_spmf (map_prod rsuml id))\n     ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3) s q =\n    (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)) s q", "by(cases qr)(simp_all add: spmf.map_comp o_def apfst_def prod.map_comp)"], ["proof (state)\nthis:\n  (id ---> lsumr ---> map_spmf (map_prod rsuml id))\n   ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3) s q =\n  (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)) s q\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       q = Inl a \\<Longrightarrow>\n       (id ---> lsumr ---> map_spmf (map_prod rsuml id))\n        ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3) s q =\n       (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)) s q", "qed (simp add: spmf.map_comp o_def apfst_def prod.map_comp id_def)"], ["proof (state)\nthis:\n  (id ---> lsumr ---> map_spmf (map_prod rsuml id))\n   ((oracle1 \\<oplus>\\<^sub>O oracle2) \\<oplus>\\<^sub>O oracle3) s q =\n  (oracle1 \\<oplus>\\<^sub>O (oracle2 \\<oplus>\\<^sub>O oracle3)) s q\n\ngoal:\nNo subgoals!", "qed"], ["", "context includes lifting_syntax begin"], ["", "definition lift_state_oracle\n  :: \"(('s \\<Rightarrow> 'a \\<Rightarrow> (('b \\<times> 't) \\<times> 's) spmf) \\<Rightarrow> ('s' \\<Rightarrow> 'a \\<Rightarrow> (('b \\<times> 't) \\<times> 's') spmf)) \n  \\<Rightarrow> ('t \\<times> 's \\<Rightarrow> 'a \\<Rightarrow> ('b \\<times> 't \\<times> 's) spmf) \\<Rightarrow> ('t \\<times> 's' \\<Rightarrow> 'a \\<Rightarrow> ('b \\<times> 't \\<times> 's') spmf)\" where\n  \"lift_state_oracle F oracle = \n   (\\<lambda>(t, s') a. map_spmf rprodl (F ((Pair t ---> id ---> map_spmf lprodr) oracle) s' a))\""], ["", "lemma lift_state_oracle_simps [simp]:\n  \"lift_state_oracle F oracle (t, s') a = map_spmf rprodl (F ((Pair t ---> id ---> map_spmf lprodr) oracle) s' a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_state_oracle F oracle (t, s') a =\n    map_spmf rprodl (F ((Pair t ---> id ---> map_spmf lprodr) oracle) s' a)", "by(simp add: lift_state_oracle_def)"], ["", "lemma lift_state_oracle_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(((S ===> A ===> rel_spmf (rel_prod (rel_prod B T) S)) ===> S' ===> A ===> rel_spmf (rel_prod (rel_prod B T) S'))\n  ===> (rel_prod T S ===> A ===> rel_spmf (rel_prod B (rel_prod T S)))\n  ===> rel_prod T S' ===> A ===> rel_spmf (rel_prod B (rel_prod T S')))\n  lift_state_oracle lift_state_oracle\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((S ===> A ===> rel_spmf (rel_prod (rel_prod B T) S)) ===>\n      S' ===> A ===> rel_spmf (rel_prod (rel_prod B T) S')) ===>\n     (rel_prod T S ===> A ===> rel_spmf (rel_prod B (rel_prod T S))) ===>\n     rel_prod T S' ===> A ===> rel_spmf (rel_prod B (rel_prod T S')))\n     lift_state_oracle lift_state_oracle", "unfolding lift_state_oracle_def map_fun_def o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((S ===> A ===> rel_spmf (rel_prod (rel_prod B T) S)) ===>\n      S' ===> A ===> rel_spmf (rel_prod (rel_prod B T) S')) ===>\n     (rel_prod T S ===> A ===> rel_spmf (rel_prod B (rel_prod T S))) ===>\n     rel_prod T S' ===> A ===> rel_spmf (rel_prod B (rel_prod T S')))\n     (\\<lambda>F oracle (t, s') a.\n         map_spmf rprodl\n          (F (\\<lambda>x xa. map_spmf lprodr (oracle (t, x) (id xa))) s' a))\n     (\\<lambda>F oracle (t, s') a.\n         map_spmf rprodl\n          (F (\\<lambda>x xa. map_spmf lprodr (oracle (t, x) (id xa))) s' a))", "by transfer_prover"], ["", "lemma lift_state_oracle_extend_state_oracle:\n  includes lifting_syntax\n  assumes \"\\<And>B. Transfer.Rel (((=) ===> (=) ===> rel_spmf (rel_prod B (=))) ===> (=) ===> (=) ===> rel_spmf (rel_prod B (=))) G F\"\n    (* TODO: implement simproc to discharge parametricity assumptions like this one *)\n  shows \"lift_state_oracle F (extend_state_oracle oracle) = extend_state_oracle (G oracle)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_state_oracle F \\<dagger>oracle = \\<dagger>(G oracle)", "unfolding lift_state_oracle_def extend_state_oracle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(t, s') a.\n        map_spmf rprodl\n         (F ((Pair t ---> id ---> map_spmf lprodr)\n              (\\<lambda>(s', s) x.\n                  map_spmf (\\<lambda>(y, s). (y, s', s)) (oracle s x)))\n           s' a)) =\n    (\\<lambda>(s', s) x.\n        map_spmf (\\<lambda>(y, s). (y, s', s)) (G oracle s x))", "apply(clarsimp simp add: fun_eq_iff map_fun_def o_def spmf.map_comp split_def rprodl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       map_spmf (\\<lambda>p. (fst (fst p), snd (fst p), snd p))\n        (F (\\<lambda>x xa.\n               map_spmf (\\<lambda>x. ((fst x, a), snd x)) (oracle x xa))\n          b x) =\n       map_spmf (\\<lambda>p. (fst p, a, snd p)) (G oracle b x)", "subgoal for t s a"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>p. (fst (fst p), snd (fst p), snd p))\n     (F (\\<lambda>x xa.\n            map_spmf (\\<lambda>x. ((fst x, t), snd x)) (oracle x xa))\n       s a) =\n    map_spmf (\\<lambda>p. (fst p, t, snd p)) (G oracle s a)", "apply(rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>p. (fst p, t, snd p)) (G oracle s a) =\n    map_spmf (\\<lambda>p. (fst (fst p), snd (fst p), snd p))\n     (F (\\<lambda>x xa.\n            map_spmf (\\<lambda>x. ((fst x, t), snd x)) (oracle x xa))\n       s a)", "apply(fold spmf_rel_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (=) (map_spmf (\\<lambda>p. (fst p, t, snd p)) (G oracle s a))\n     (map_spmf (\\<lambda>p. (fst (fst p), snd (fst p), snd p))\n       (F (\\<lambda>x xa.\n              map_spmf (\\<lambda>x. ((fst x, t), snd x)) (oracle x xa))\n         s a))", "apply(simp add: spmf_rel_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>x y.\n         fst x = fst (fst y) \\<and> t = snd (fst y) \\<and> snd x = snd y)\n     (G oracle s a)\n     (F (\\<lambda>x xa.\n            map_spmf (\\<lambda>x. ((fst x, t), snd x)) (oracle x xa))\n       s a)", "apply(rule rel_spmf_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rel_spmf ?A2 (G oracle s a)\n     (F (\\<lambda>x xa.\n            map_spmf (\\<lambda>x. ((fst x, t), snd x)) (oracle x xa))\n       s a)\n 2. \\<And>x y.\n       ?A2 x y \\<Longrightarrow>\n       fst x = fst (fst y) \\<and> t = snd (fst y) \\<and> snd x = snd y", "apply(rule assms[unfolded Rel_def, where B=\"\\<lambda>x (y, z). x = y \\<and> z = t\", THEN rel_funD, THEN rel_funD, THEN rel_funD])"], ["proof (prove)\ngoal (4 subgoals):\n 1. ((=) ===>\n     (=) ===>\n     rel_spmf (rel_prod (\\<lambda>x (y, z). x = y \\<and> z = t) (=)))\n     oracle\n     (\\<lambda>x xa.\n         map_spmf (\\<lambda>x. ((fst x, t), snd x)) (oracle x xa))\n 2. s = s\n 3. a = a\n 4. \\<And>x y.\n       rel_prod (\\<lambda>x (y, z). x = y \\<and> z = t) (=) x\n        y \\<Longrightarrow>\n       fst x = fst (fst y) \\<and> t = snd (fst y) \\<and> snd x = snd y", "apply(auto simp add: rel_fun_def spmf_rel_map intro!: rel_spmf_reflI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lift_state_oracle_compose: \n  \"lift_state_oracle F (lift_state_oracle G oracle) = lift_state_oracle (F \\<circ> G) oracle\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_state_oracle F (lift_state_oracle G oracle) =\n    lift_state_oracle (F \\<circ> G) oracle", "by(simp add: lift_state_oracle_def map_fun_def o_def split_def spmf.map_comp)"], ["", "lemma lift_state_oracle_id [simp]: \"lift_state_oracle id = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_state_oracle id = id", "by(simp add: fun_eq_iff spmf.map_comp o_def)"], ["", "lemma rprodl_extend_state_oracle: includes lifting_syntax shows\n  \"(rprodl ---> id ---> map_spmf (map_prod id lprodr)) (extend_state_oracle (extend_state_oracle oracle)) = \n  extend_state_oracle oracle\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rprodl ---> id ---> map_spmf (map_prod id lprodr))\n     \\<dagger>\\<dagger>oracle =\n    \\<dagger>oracle", "by(simp add: fun_eq_iff spmf.map_comp o_def split_def)"], ["", "end"], ["", "section \\<open>Combining GPVs\\<close>"], ["", "subsection \\<open>Shared state without interrupts\\<close>"], ["", "context\n  fixes left :: \"'s \\<Rightarrow> 'x1 \\<Rightarrow> ('y1 \\<times> 's, 'call, 'ret) gpv\"\n  and right :: \"'s \\<Rightarrow> 'x2 \\<Rightarrow> ('y2 \\<times> 's, 'call, 'ret) gpv\"\nbegin"], ["", "primrec plus_intercept :: \"'s \\<Rightarrow> 'x1 + 'x2 \\<Rightarrow> (('y1 + 'y2) \\<times> 's, 'call, 'ret) gpv\"\nwhere\n  \"plus_intercept s (Inl x) = map_gpv (apfst Inl) id (left s x)\"\n| \"plus_intercept s (Inr x) = map_gpv (apfst Inr) id (right s x)\""], ["", "end"], ["", "lemma plus_intercept_parametric [transfer_rule]:\n  includes lifting_syntax shows\n  \"((S ===> X1 ===> rel_gpv (rel_prod Y1 S) C)\n  ===> (S ===> X2 ===> rel_gpv (rel_prod Y2 S) C)\n  ===> S ===> rel_sum X1 X2 ===> rel_gpv (rel_prod (rel_sum Y1 Y2) S) C)\n  plus_intercept plus_intercept\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> X1 ===> rel_gpv (rel_prod Y1 S) C) ===>\n     (S ===> X2 ===> rel_gpv (rel_prod Y2 S) C) ===>\n     S ===> rel_sum X1 X2 ===> rel_gpv (rel_prod (rel_sum Y1 Y2) S) C)\n     plus_intercept plus_intercept", "unfolding plus_intercept_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> X1 ===> rel_gpv (rel_prod Y1 S) C) ===>\n     (S ===> X2 ===> rel_gpv (rel_prod Y2 S) C) ===>\n     S ===> rel_sum X1 X2 ===> rel_gpv (rel_prod (rel_sum Y1 Y2) S) C)\n     (\\<lambda>left right uu uua.\n         (case uua of\n          Inl x \\<Rightarrow> \\<lambda>s. map_gpv (apfst Inl) id (left s x)\n          | Inr x \\<Rightarrow>\n              \\<lambda>s. map_gpv (apfst Inr) id (right s x))\n          uu)\n     (\\<lambda>left right uu uua.\n         (case uua of\n          Inl x \\<Rightarrow> \\<lambda>s. map_gpv (apfst Inl) id (left s x)\n          | Inr x \\<Rightarrow>\n              \\<lambda>s. map_gpv (apfst Inr) id (right s x))\n          uu)", "by transfer_prover"], ["", "lemma interaction_bounded_by_plus_intercept [interaction_bound]:\n  fixes left right\n  shows \"\\<lbrakk> \\<And>x'. x = Inl x' \\<Longrightarrow> interaction_bounded_by P (left s x') (n x');\n    \\<And>y. x = Inr y \\<Longrightarrow> interaction_bounded_by P (right s y) (m y) \\<rbrakk>\n  \\<Longrightarrow> interaction_bounded_by P (plus_intercept left right s x) (case x of Inl x \\<Rightarrow> n x | Inr y \\<Rightarrow> m y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x'.\n                x = Inl x' \\<Longrightarrow>\n                interaction_bounded_by P (left s x') (n x');\n     \\<And>y.\n        x = Inr y \\<Longrightarrow>\n        interaction_bounded_by P (right s y) (m y)\\<rbrakk>\n    \\<Longrightarrow> interaction_bounded_by P\n                       (plus_intercept left right s x)\n                       (case x of Inl x \\<Rightarrow> n x\n                        | Inr y \\<Rightarrow> m y)", "by(simp split!: sum.split add: interaction_bounded_by_map_gpv_id)"], ["", "subsection \\<open>Shared state with interrupts\\<close>"], ["", "context \n  fixes left :: \"'s \\<Rightarrow> 'x1 \\<Rightarrow> ('y1 option \\<times> 's, 'call, 'ret) gpv\"\n  and right :: \"'s \\<Rightarrow> 'x2 \\<Rightarrow> ('y2 option \\<times> 's, 'call, 'ret) gpv\"\nbegin"], ["", "primrec plus_intercept_stop :: \"'s \\<Rightarrow> 'x1 + 'x2 \\<Rightarrow> (('y1 + 'y2) option \\<times> 's, 'call, 'ret) gpv\"\nwhere\n  \"plus_intercept_stop s (Inl x) = map_gpv (apfst (map_option Inl)) id (left s x)\"\n| \"plus_intercept_stop s (Inr x) = map_gpv (apfst (map_option Inr)) id (right s x)\""], ["", "end"], ["", "lemma plus_intercept_stop_parametric [transfer_rule]:\n  includes lifting_syntax shows\n  \"((S ===> X1 ===> rel_gpv (rel_prod (rel_option Y1) S) C)\n  ===> (S ===> X2 ===> rel_gpv (rel_prod (rel_option Y2) S) C)\n  ===> S ===> rel_sum X1 X2 ===> rel_gpv (rel_prod (rel_option (rel_sum Y1 Y2)) S) C)\n  plus_intercept_stop plus_intercept_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> X1 ===> rel_gpv (rel_prod (rel_option Y1) S) C) ===>\n     (S ===> X2 ===> rel_gpv (rel_prod (rel_option Y2) S) C) ===>\n     S ===>\n     rel_sum X1 X2 ===> rel_gpv (rel_prod (rel_option (rel_sum Y1 Y2)) S) C)\n     plus_intercept_stop plus_intercept_stop", "unfolding plus_intercept_stop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> X1 ===> rel_gpv (rel_prod (rel_option Y1) S) C) ===>\n     (S ===> X2 ===> rel_gpv (rel_prod (rel_option Y2) S) C) ===>\n     S ===>\n     rel_sum X1 X2 ===> rel_gpv (rel_prod (rel_option (rel_sum Y1 Y2)) S) C)\n     (\\<lambda>left right uu uua.\n         (case uua of\n          Inl x \\<Rightarrow>\n            \\<lambda>s. map_gpv (apfst (map_option Inl)) id (left s x)\n          | Inr x \\<Rightarrow>\n              \\<lambda>s. map_gpv (apfst (map_option Inr)) id (right s x))\n          uu)\n     (\\<lambda>left right uu uua.\n         (case uua of\n          Inl x \\<Rightarrow>\n            \\<lambda>s. map_gpv (apfst (map_option Inl)) id (left s x)\n          | Inr x \\<Rightarrow>\n              \\<lambda>s. map_gpv (apfst (map_option Inr)) id (right s x))\n          uu)", "by transfer_prover"], ["", "subsection \\<open>One-sided shifts\\<close>"], ["", "primcorec (transfer) left_gpv :: \"('a, 'out, 'in) gpv \\<Rightarrow> ('a, 'out + 'out', 'in + 'in') gpv\" where\n  \"the_gpv (left_gpv gpv) = \n   map_spmf (map_generat id Inl (\\<lambda>rpv input. case input of Inl input' \\<Rightarrow> left_gpv (rpv input') | _ \\<Rightarrow> Fail)) (the_gpv gpv)\""], ["", "abbreviation left_rpv :: \"('a, 'out, 'in) rpv \\<Rightarrow> ('a, 'out + 'out', 'in + 'in') rpv\" where\n  \"left_rpv rpv \\<equiv> \\<lambda>input. case input of Inl input' \\<Rightarrow> left_gpv (rpv input') | _ \\<Rightarrow> Fail\""], ["", "primcorec (transfer) right_gpv :: \"('a, 'out, 'in) gpv \\<Rightarrow> ('a, 'out' + 'out, 'in' + 'in) gpv\" where\n  \"the_gpv (right_gpv gpv) =\n   map_spmf (map_generat id Inr (\\<lambda>rpv input. case input of Inr input' \\<Rightarrow> right_gpv (rpv input') | _ \\<Rightarrow> Fail)) (the_gpv gpv)\""], ["", "abbreviation right_rpv :: \"('a, 'out, 'in) rpv \\<Rightarrow> ('a, 'out' + 'out, 'in' + 'in) rpv\" where\n  \"right_rpv rpv \\<equiv> \\<lambda>input. case input of Inr input' \\<Rightarrow> right_gpv (rpv input') | _ \\<Rightarrow> Fail\""], ["", "context \n  includes lifting_syntax\n  notes [transfer_rule] = corec_gpv_parametric' Fail_parametric' the_gpv_parametric'\nbegin"], ["", "lemmas left_gpv_parametric = left_gpv.transfer"], ["", "lemma left_gpv_parametric':\n  \"(rel_gpv'' A C R ===> rel_gpv'' A (rel_sum C C') (rel_sum R R')) left_gpv left_gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_gpv'' A C R ===> rel_gpv'' A (rel_sum C C') (rel_sum R R'))\n     left_gpv left_gpv", "unfolding left_gpv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_gpv'' A C R ===> rel_gpv'' A (rel_sum C C') (rel_sum R R'))\n     (corec_gpv\n       (\\<lambda>gpv.\n           map_spmf\n            (map_generat id Inl\n              (\\<lambda>uu input.\n                  case input of Inl input' \\<Rightarrow> Inr (uu input')\n                  | Inr b \\<Rightarrow> Inl Fail))\n            (the_gpv gpv)))\n     (corec_gpv\n       (\\<lambda>gpv.\n           map_spmf\n            (map_generat id Inl\n              (\\<lambda>uu input.\n                  case input of Inl input' \\<Rightarrow> Inr (uu input')\n                  | Inr b \\<Rightarrow> Inl Fail))\n            (the_gpv gpv)))", "by transfer_prover"], ["", "lemmas right_gpv_parametric = right_gpv.transfer"], ["", "lemma right_gpv_parametric':\n  \"(rel_gpv'' A C' R' ===> rel_gpv'' A (rel_sum C C') (rel_sum R R')) right_gpv right_gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_gpv'' A C' R' ===> rel_gpv'' A (rel_sum C C') (rel_sum R R'))\n     right_gpv right_gpv", "unfolding right_gpv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_gpv'' A C' R' ===> rel_gpv'' A (rel_sum C C') (rel_sum R R'))\n     (corec_gpv\n       (\\<lambda>gpv.\n           map_spmf\n            (map_generat id Inr\n              (\\<lambda>uu input.\n                  case input of Inl a \\<Rightarrow> Inl Fail\n                  | Inr input' \\<Rightarrow> Inr (uu input')))\n            (the_gpv gpv)))\n     (corec_gpv\n       (\\<lambda>gpv.\n           map_spmf\n            (map_generat id Inr\n              (\\<lambda>uu input.\n                  case input of Inl a \\<Rightarrow> Inl Fail\n                  | Inr input' \\<Rightarrow> Inr (uu input')))\n            (the_gpv gpv)))", "by transfer_prover"], ["", "end"], ["", "lemma left_gpv_Done [simp]: \"left_gpv (Done x) = Done x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_gpv (Generative_Probabilistic_Value.Done x) =\n    Generative_Probabilistic_Value.Done x", "by(rule gpv.expand) simp"], ["", "lemma right_gpv_Done [simp]: \"right_gpv (Done x) = Done x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_gpv (Generative_Probabilistic_Value.Done x) =\n    Generative_Probabilistic_Value.Done x", "by(rule gpv.expand) simp"], ["", "lemma left_gpv_Pause [simp]:\n  \"left_gpv (Pause x rpv) = Pause (Inl x) (\\<lambda>input. case input of Inl input' \\<Rightarrow> left_gpv (rpv input') | _ \\<Rightarrow> Fail)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_gpv (Generative_Probabilistic_Value.Pause x rpv) =\n    Generative_Probabilistic_Value.Pause (Inl x) (left_rpv rpv)", "by(rule gpv.expand) simp"], ["", "lemma right_gpv_Pause [simp]:\n  \"right_gpv (Pause x rpv) = Pause (Inr x) (\\<lambda>input. case input of Inr input' \\<Rightarrow> right_gpv (rpv input') | _ \\<Rightarrow> Fail)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_gpv (Generative_Probabilistic_Value.Pause x rpv) =\n    Generative_Probabilistic_Value.Pause (Inr x) (right_rpv rpv)", "by(rule gpv.expand) simp"], ["", "lemma left_gpv_map: \"left_gpv (map_gpv f g gpv) = map_gpv f (map_sum g h) (left_gpv gpv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_gpv (map_gpv f g gpv) = map_gpv f (map_sum g h) (left_gpv gpv)", "using left_gpv.transfer[of \"BNF_Def.Grp UNIV f\" \"BNF_Def.Grp UNIV g\" \"BNF_Def.Grp UNIV h\"]"], ["proof (prove)\nusing this:\n  rel_fun (rel_gpv (BNF_Def.Grp UNIV f) (BNF_Def.Grp UNIV g))\n   (rel_gpv (BNF_Def.Grp UNIV f)\n     (rel_sum (BNF_Def.Grp UNIV g) (BNF_Def.Grp UNIV h)))\n   left_gpv left_gpv\n\ngoal (1 subgoal):\n 1. left_gpv (map_gpv f g gpv) = map_gpv f (map_sum g h) (left_gpv gpv)", "unfolding sum.rel_Grp gpv.rel_Grp"], ["proof (prove)\nusing this:\n  rel_fun\n   (BNF_Def.Grp\n     {x. results'_gpv x \\<subseteq> UNIV \\<and>\n         outs'_gpv x \\<subseteq> UNIV}\n     (map_gpv f g))\n   (BNF_Def.Grp\n     {x. results'_gpv x \\<subseteq> UNIV \\<and>\n         outs'_gpv x\n         \\<subseteq> {x. Basic_BNFs.setl x \\<subseteq> UNIV \\<and>\n                         Basic_BNFs.setr x \\<subseteq> UNIV}}\n     (map_gpv f (map_sum g h)))\n   left_gpv left_gpv\n\ngoal (1 subgoal):\n 1. left_gpv (map_gpv f g gpv) = map_gpv f (map_sum g h) (left_gpv gpv)", "by(auto simp add: rel_fun_def Grp_def)"], ["", "lemma right_gpv_map: \"right_gpv (map_gpv f g gpv) = map_gpv f (map_sum h g) (right_gpv gpv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_gpv (map_gpv f g gpv) = map_gpv f (map_sum h g) (right_gpv gpv)", "using right_gpv.transfer[of \"BNF_Def.Grp UNIV f\" \"BNF_Def.Grp UNIV g\" \"BNF_Def.Grp UNIV h\"]"], ["proof (prove)\nusing this:\n  rel_fun (rel_gpv (BNF_Def.Grp UNIV f) (BNF_Def.Grp UNIV g))\n   (rel_gpv (BNF_Def.Grp UNIV f)\n     (rel_sum (BNF_Def.Grp UNIV h) (BNF_Def.Grp UNIV g)))\n   right_gpv right_gpv\n\ngoal (1 subgoal):\n 1. right_gpv (map_gpv f g gpv) = map_gpv f (map_sum h g) (right_gpv gpv)", "unfolding sum.rel_Grp gpv.rel_Grp"], ["proof (prove)\nusing this:\n  rel_fun\n   (BNF_Def.Grp\n     {x. results'_gpv x \\<subseteq> UNIV \\<and>\n         outs'_gpv x \\<subseteq> UNIV}\n     (map_gpv f g))\n   (BNF_Def.Grp\n     {x. results'_gpv x \\<subseteq> UNIV \\<and>\n         outs'_gpv x\n         \\<subseteq> {x. Basic_BNFs.setl x \\<subseteq> UNIV \\<and>\n                         Basic_BNFs.setr x \\<subseteq> UNIV}}\n     (map_gpv f (map_sum h g)))\n   right_gpv right_gpv\n\ngoal (1 subgoal):\n 1. right_gpv (map_gpv f g gpv) = map_gpv f (map_sum h g) (right_gpv gpv)", "by(auto simp add: rel_fun_def Grp_def)"], ["", "lemma results'_gpv_left_gpv [simp]: \n  \"results'_gpv (left_gpv gpv :: ('a, 'out + 'out', 'in + 'in') gpv) = results'_gpv gpv\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. results'_gpv (left_gpv gpv) = results'_gpv gpv", "proof(rule Set.set_eqI iffI)+"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> results'_gpv (left_gpv gpv) \\<Longrightarrow>\n       x \\<in> results'_gpv gpv\n 2. \\<And>x.\n       x \\<in> results'_gpv gpv \\<Longrightarrow>\n       x \\<in> results'_gpv (left_gpv gpv)", "show \"x \\<in> ?rhs\" if \"x \\<in> ?lhs\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> results'_gpv gpv", "using that"], ["proof (prove)\nusing this:\n  x \\<in> results'_gpv (left_gpv gpv)\n\ngoal (1 subgoal):\n 1. x \\<in> results'_gpv gpv", "by(induction gpv'\\<equiv>\"left_gpv gpv :: ('a, 'out + 'out', 'in + 'in') gpv\" arbitrary: gpv)\n      (fastforce simp add: elim!: generat.set_cases intro: results'_gpvI split: sum.splits)+"], ["proof (state)\nthis:\n  ?x \\<in> results'_gpv (left_gpv gpv) \\<Longrightarrow>\n  ?x \\<in> results'_gpv gpv\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> results'_gpv gpv \\<Longrightarrow>\n       x \\<in> results'_gpv (left_gpv gpv)", "show \"x \\<in> ?lhs\" if \"x \\<in> ?rhs\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> results'_gpv (left_gpv gpv)", "using that"], ["proof (prove)\nusing this:\n  x \\<in> results'_gpv gpv\n\ngoal (1 subgoal):\n 1. x \\<in> results'_gpv (left_gpv gpv)", "by(induction)\n      (auto 4 3 elim!: generat.set_cases intro: results'_gpv_Pure rev_image_eqI results'_gpv_Cont[where input=\"Inl _\"])"], ["proof (state)\nthis:\n  ?x \\<in> results'_gpv gpv \\<Longrightarrow>\n  ?x \\<in> results'_gpv (left_gpv gpv)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma results'_gpv_right_gpv [simp]: \n  \"results'_gpv (right_gpv gpv :: ('a, 'out' + 'out, 'in' + 'in) gpv) = results'_gpv gpv\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. results'_gpv (right_gpv gpv) = results'_gpv gpv", "proof(rule Set.set_eqI iffI)+"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> results'_gpv (right_gpv gpv) \\<Longrightarrow>\n       x \\<in> results'_gpv gpv\n 2. \\<And>x.\n       x \\<in> results'_gpv gpv \\<Longrightarrow>\n       x \\<in> results'_gpv (right_gpv gpv)", "show \"x \\<in> ?rhs\" if \"x \\<in> ?lhs\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> results'_gpv gpv", "using that"], ["proof (prove)\nusing this:\n  x \\<in> results'_gpv (right_gpv gpv)\n\ngoal (1 subgoal):\n 1. x \\<in> results'_gpv gpv", "by(induction gpv'\\<equiv>\"right_gpv gpv :: ('a, 'out' + 'out, 'in' + 'in) gpv\" arbitrary: gpv)\n      (fastforce simp add: elim!: generat.set_cases intro: results'_gpvI split: sum.splits)+"], ["proof (state)\nthis:\n  ?x \\<in> results'_gpv (right_gpv gpv) \\<Longrightarrow>\n  ?x \\<in> results'_gpv gpv\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> results'_gpv gpv \\<Longrightarrow>\n       x \\<in> results'_gpv (right_gpv gpv)", "show \"x \\<in> ?lhs\" if \"x \\<in> ?rhs\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> results'_gpv (right_gpv gpv)", "using that"], ["proof (prove)\nusing this:\n  x \\<in> results'_gpv gpv\n\ngoal (1 subgoal):\n 1. x \\<in> results'_gpv (right_gpv gpv)", "by(induction)\n      (auto 4 3 elim!: generat.set_cases intro: results'_gpv_Pure rev_image_eqI results'_gpv_Cont[where input=\"Inr _\"])"], ["proof (state)\nthis:\n  ?x \\<in> results'_gpv gpv \\<Longrightarrow>\n  ?x \\<in> results'_gpv (right_gpv gpv)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma left_gpv_Inl_transfer: \"rel_gpv'' (=) (\\<lambda>l r. l = Inl r) (\\<lambda>l r. l = Inl r) (left_gpv gpv) gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_gpv'' (=) (\\<lambda>l r. l = Inl r) (\\<lambda>l r. l = Inl r)\n     (left_gpv gpv) gpv", "by(coinduction arbitrary: gpv)\n    (auto simp add: spmf_rel_map generat.rel_map del: rel_funI intro!: rel_spmf_reflI generat.rel_refl_strong rel_funI)"], ["", "lemma right_gpv_Inr_transfer: \"rel_gpv'' (=) (\\<lambda>l r. l = Inr r) (\\<lambda>l r. l = Inr r) (right_gpv gpv) gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_gpv'' (=) (\\<lambda>l r. l = Inr r) (\\<lambda>l r. l = Inr r)\n     (right_gpv gpv) gpv", "by(coinduction arbitrary: gpv)\n    (auto simp add: spmf_rel_map generat.rel_map del: rel_funI intro!: rel_spmf_reflI generat.rel_refl_strong rel_funI)"], ["", "lemma exec_gpv_plus_oracle_left: \"exec_gpv (plus_oracle oracle1 oracle2) (left_gpv gpv) s = exec_gpv oracle1 gpv s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_gpv (oracle1 \\<oplus>\\<^sub>O oracle2) (left_gpv gpv) s =\n    exec_gpv oracle1 gpv s", "unfolding spmf_rel_eq[symmetric] prod.rel_eq[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (rel_prod (=) (=))\n     (exec_gpv (oracle1 \\<oplus>\\<^sub>O oracle2) (left_gpv gpv) s)\n     (exec_gpv oracle1 gpv s)", "by(rule exec_gpv_parametric'[where A=\"(=)\" and S=\"(=)\" and CALL=\"\\<lambda>l r. l = Inl r\" and R=\"\\<lambda>l r. l = Inl r\", THEN rel_funD, THEN rel_funD, THEN rel_funD])\n    (auto intro!: rel_funI simp add: spmf_rel_map apfst_def map_prod_def rel_prod_conv intro: rel_spmf_reflI left_gpv_Inl_transfer)"], ["", "lemma exec_gpv_plus_oracle_right: \"exec_gpv (plus_oracle oracle1 oracle2) (right_gpv gpv) s = exec_gpv oracle2 gpv s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_gpv (oracle1 \\<oplus>\\<^sub>O oracle2) (right_gpv gpv) s =\n    exec_gpv oracle2 gpv s", "unfolding spmf_rel_eq[symmetric] prod.rel_eq[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (rel_prod (=) (=))\n     (exec_gpv (oracle1 \\<oplus>\\<^sub>O oracle2) (right_gpv gpv) s)\n     (exec_gpv oracle2 gpv s)", "by(rule exec_gpv_parametric'[where A=\"(=)\" and S=\"(=)\" and CALL=\"\\<lambda>l r. l = Inr r\" and R=\"\\<lambda>l r. l = Inr r\", THEN rel_funD, THEN rel_funD, THEN rel_funD])\n    (auto intro!: rel_funI simp add: spmf_rel_map apfst_def map_prod_def rel_prod_conv intro: rel_spmf_reflI right_gpv_Inr_transfer)"], ["", "lemma left_gpv_bind_gpv: \"left_gpv (bind_gpv gpv f) = bind_gpv (left_gpv gpv) (left_gpv \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_gpv (gpv \\<bind> f) = left_gpv gpv \\<bind> left_gpv \\<circ> f", "by(coinduction arbitrary:gpv f rule: gpv.coinduct_strong)\n    (auto 4 4 simp add: bind_map_spmf spmf_rel_map intro!: rel_spmf_reflI rel_spmf_bindI[of \"(=)\"] generat.rel_refl rel_funI split: sum.splits)"], ["", "lemma inline1_left_gpv:\n  \"inline1 (\\<lambda>s q. left_gpv (callee s q)) gpv s = \n   map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id))) (inline1 callee gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inline1 (\\<lambda>s q. left_gpv (callee s q)) gpv s =\n    map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n     (inline1 callee gpv s)", "proof(induction arbitrary: gpv s rule: parallel_fixp_induct_2_2[OF partial_function_definitions_spmf partial_function_definitions_spmf inline1.mono inline1.mono inline1_def inline1_def, unfolded lub_spmf_empty, case_names adm bottom step])"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb.\n            curry (fst x) xa xb =\n            map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n             (curry (snd x) xa xb))\n 2. \\<And>gpv s.\n       return_pmf None =\n       map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n        (return_pmf None)\n 3. \\<And>f g gpv s.\n       (\\<And>gpv s.\n           f gpv s =\n           map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n            (g gpv s)) \\<Longrightarrow>\n       the_gpv gpv \\<bind>\n       case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n        (\\<lambda>out rpv.\n            the_gpv (left_gpv (callee s out)) \\<bind>\n            case_generat (\\<lambda>(x, y). f (rpv x) y)\n             (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))) =\n       map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n        (the_gpv gpv \\<bind>\n         case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n          (\\<lambda>out rpv.\n              the_gpv (callee s out) \\<bind>\n              case_generat (\\<lambda>(x, y). g (rpv x) y)\n               (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb.\n            curry (fst x) xa xb =\n            map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n             (curry (snd x) xa xb))\n 2. \\<And>gpv s.\n       return_pmf None =\n       map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n        (return_pmf None)\n 3. \\<And>f g gpv s.\n       (\\<And>gpv s.\n           f gpv s =\n           map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n            (g gpv s)) \\<Longrightarrow>\n       the_gpv gpv \\<bind>\n       case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n        (\\<lambda>out rpv.\n            the_gpv (left_gpv (callee s out)) \\<bind>\n            case_generat (\\<lambda>(x, y). f (rpv x) y)\n             (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))) =\n       map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n        (the_gpv gpv \\<bind>\n         case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n          (\\<lambda>out rpv.\n              the_gpv (callee s out) \\<bind>\n              case_generat (\\<lambda>(x, y). g (rpv x) y)\n               (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb.\n            curry (fst x) xa xb =\n            map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n             (curry (snd x) xa xb))", "by simp"], ["proof (state)\nthis:\n  ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n   (rel_prod spmf.le_fun spmf.le_fun)\n   (\\<lambda>x.\n       \\<forall>xa xb.\n          curry (fst x) xa xb =\n          map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n           (curry (snd x) xa xb))\n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       return_pmf None =\n       map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n        (return_pmf None)\n 2. \\<And>f g gpv s.\n       (\\<And>gpv s.\n           f gpv s =\n           map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n            (g gpv s)) \\<Longrightarrow>\n       the_gpv gpv \\<bind>\n       case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n        (\\<lambda>out rpv.\n            the_gpv (left_gpv (callee s out)) \\<bind>\n            case_generat (\\<lambda>(x, y). f (rpv x) y)\n             (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))) =\n       map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n        (the_gpv gpv \\<bind>\n         case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n          (\\<lambda>out rpv.\n              the_gpv (callee s out) \\<bind>\n              case_generat (\\<lambda>(x, y). g (rpv x) y)\n               (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       return_pmf None =\n       map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n        (return_pmf None)\n 2. \\<And>f g gpv s.\n       (\\<And>gpv s.\n           f gpv s =\n           map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n            (g gpv s)) \\<Longrightarrow>\n       the_gpv gpv \\<bind>\n       case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n        (\\<lambda>out rpv.\n            the_gpv (left_gpv (callee s out)) \\<bind>\n            case_generat (\\<lambda>(x, y). f (rpv x) y)\n             (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))) =\n       map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n        (the_gpv gpv \\<bind>\n         case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n          (\\<lambda>out rpv.\n              the_gpv (callee s out) \\<bind>\n              case_generat (\\<lambda>(x, y). g (rpv x) y)\n               (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. return_pmf None =\n    map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n     (return_pmf None)", "by simp"], ["proof (state)\nthis:\n  return_pmf None =\n  map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n   (return_pmf None)\n\ngoal (1 subgoal):\n 1. \\<And>f g gpv s.\n       (\\<And>gpv s.\n           f gpv s =\n           map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n            (g gpv s)) \\<Longrightarrow>\n       the_gpv gpv \\<bind>\n       case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n        (\\<lambda>out rpv.\n            the_gpv (left_gpv (callee s out)) \\<bind>\n            case_generat (\\<lambda>(x, y). f (rpv x) y)\n             (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))) =\n       map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n        (the_gpv gpv \\<bind>\n         case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n          (\\<lambda>out rpv.\n              the_gpv (callee s out) \\<bind>\n              case_generat (\\<lambda>(x, y). g (rpv x) y)\n               (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))", "case (step inline1' inline1'')"], ["proof (state)\nthis:\n  inline1' ?gpv ?s =\n  map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n   (inline1'' ?gpv ?s)\n\ngoal (1 subgoal):\n 1. \\<And>f g gpv s.\n       (\\<And>gpv s.\n           f gpv s =\n           map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n            (g gpv s)) \\<Longrightarrow>\n       the_gpv gpv \\<bind>\n       case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n        (\\<lambda>out rpv.\n            the_gpv (left_gpv (callee s out)) \\<bind>\n            case_generat (\\<lambda>(x, y). f (rpv x) y)\n             (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))) =\n       map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n        (the_gpv gpv \\<bind>\n         case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n          (\\<lambda>out rpv.\n              the_gpv (callee s out) \\<bind>\n              case_generat (\\<lambda>(x, y). g (rpv x) y)\n               (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))", "then"], ["proof (chain)\npicking this:\n  inline1' ?gpv ?s =\n  map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n   (inline1'' ?gpv ?s)", "show ?case"], ["proof (prove)\nusing this:\n  inline1' ?gpv ?s =\n  map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n   (inline1'' ?gpv ?s)\n\ngoal (1 subgoal):\n 1. the_gpv gpv \\<bind>\n    (\\<lambda>a.\n        case a of Pure x \\<Rightarrow> return_spmf (Inl (x, s))\n        | IO out rpv \\<Rightarrow>\n            the_gpv (left_gpv (callee s out)) \\<bind>\n            (\\<lambda>a.\n                case a of Pure (x, y) \\<Rightarrow> inline1' (rpv x) y\n                | IO out rpv' \\<Rightarrow>\n                    return_spmf (Inr (out, rpv', rpv)))) =\n    map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n     (the_gpv gpv \\<bind>\n      (\\<lambda>a.\n          case a of Pure x \\<Rightarrow> return_spmf (Inl (x, s))\n          | IO out rpv \\<Rightarrow>\n              the_gpv (callee s out) \\<bind>\n              (\\<lambda>a.\n                  case a of Pure (x, y) \\<Rightarrow> inline1'' (rpv x) y\n                  | IO out rpv' \\<Rightarrow>\n                      return_spmf (Inr (out, rpv', rpv)))))", "by(auto simp add: map_spmf_bind_spmf o_def bind_map_spmf intro!: ext bind_spmf_cong split: generat.split)"], ["proof (state)\nthis:\n  the_gpv gpv \\<bind>\n  (\\<lambda>a.\n      case a of Pure x \\<Rightarrow> return_spmf (Inl (x, s))\n      | IO out rpv \\<Rightarrow>\n          the_gpv (left_gpv (callee s out)) \\<bind>\n          (\\<lambda>a.\n              case a of Pure (x, y) \\<Rightarrow> inline1' (rpv x) y\n              | IO out rpv' \\<Rightarrow>\n                  return_spmf (Inr (out, rpv', rpv)))) =\n  map_spmf (map_sum id (map_prod Inl (map_prod left_rpv id)))\n   (the_gpv gpv \\<bind>\n    (\\<lambda>a.\n        case a of Pure x \\<Rightarrow> return_spmf (Inl (x, s))\n        | IO out rpv \\<Rightarrow>\n            the_gpv (callee s out) \\<bind>\n            (\\<lambda>a.\n                case a of Pure (x, y) \\<Rightarrow> inline1'' (rpv x) y\n                | IO out rpv' \\<Rightarrow>\n                    return_spmf (Inr (out, rpv', rpv)))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma left_gpv_inline: \"left_gpv (inline callee gpv s) = inline (\\<lambda>s q. left_gpv (callee s q)) gpv s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_gpv (inline callee gpv s) =\n    inline (\\<lambda>s q. left_gpv (callee s q)) gpv s", "by(coinduction arbitrary: callee gpv s rule: gpv_coinduct_bind)\n    (fastforce simp add: inline_sel spmf_rel_map inline1_left_gpv left_gpv_bind_gpv o_def split_def intro!: rel_spmf_reflI split: sum.split intro!: rel_funI gpv.rel_refl_strong)"], ["", "lemma right_gpv_bind_gpv: \"right_gpv (bind_gpv gpv f) = bind_gpv (right_gpv gpv) (right_gpv \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_gpv (gpv \\<bind> f) = right_gpv gpv \\<bind> right_gpv \\<circ> f", "by(coinduction arbitrary:gpv f rule: gpv.coinduct_strong)\n    (auto 4 4 simp add: bind_map_spmf spmf_rel_map intro!: rel_spmf_reflI rel_spmf_bindI[of \"(=)\"] generat.rel_refl rel_funI split: sum.splits)"], ["", "lemma inline1_right_gpv:\n  \"inline1 (\\<lambda>s q. right_gpv (callee s q)) gpv s = \n   map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id))) (inline1 callee gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inline1 (\\<lambda>s q. right_gpv (callee s q)) gpv s =\n    map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n     (inline1 callee gpv s)", "proof(induction arbitrary: gpv s rule: parallel_fixp_induct_2_2[OF partial_function_definitions_spmf partial_function_definitions_spmf inline1.mono inline1.mono inline1_def inline1_def, unfolded lub_spmf_empty, case_names adm bottom step])"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb.\n            curry (fst x) xa xb =\n            map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n             (curry (snd x) xa xb))\n 2. \\<And>gpv s.\n       return_pmf None =\n       map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n        (return_pmf None)\n 3. \\<And>f g gpv s.\n       (\\<And>gpv s.\n           f gpv s =\n           map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n            (g gpv s)) \\<Longrightarrow>\n       the_gpv gpv \\<bind>\n       case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n        (\\<lambda>out rpv.\n            the_gpv (right_gpv (callee s out)) \\<bind>\n            case_generat (\\<lambda>(x, y). f (rpv x) y)\n             (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))) =\n       map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n        (the_gpv gpv \\<bind>\n         case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n          (\\<lambda>out rpv.\n              the_gpv (callee s out) \\<bind>\n              case_generat (\\<lambda>(x, y). g (rpv x) y)\n               (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb.\n            curry (fst x) xa xb =\n            map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n             (curry (snd x) xa xb))\n 2. \\<And>gpv s.\n       return_pmf None =\n       map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n        (return_pmf None)\n 3. \\<And>f g gpv s.\n       (\\<And>gpv s.\n           f gpv s =\n           map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n            (g gpv s)) \\<Longrightarrow>\n       the_gpv gpv \\<bind>\n       case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n        (\\<lambda>out rpv.\n            the_gpv (right_gpv (callee s out)) \\<bind>\n            case_generat (\\<lambda>(x, y). f (rpv x) y)\n             (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))) =\n       map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n        (the_gpv gpv \\<bind>\n         case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n          (\\<lambda>out rpv.\n              the_gpv (callee s out) \\<bind>\n              case_generat (\\<lambda>(x, y). g (rpv x) y)\n               (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb.\n            curry (fst x) xa xb =\n            map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n             (curry (snd x) xa xb))", "by simp"], ["proof (state)\nthis:\n  ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n   (rel_prod spmf.le_fun spmf.le_fun)\n   (\\<lambda>x.\n       \\<forall>xa xb.\n          curry (fst x) xa xb =\n          map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n           (curry (snd x) xa xb))\n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       return_pmf None =\n       map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n        (return_pmf None)\n 2. \\<And>f g gpv s.\n       (\\<And>gpv s.\n           f gpv s =\n           map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n            (g gpv s)) \\<Longrightarrow>\n       the_gpv gpv \\<bind>\n       case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n        (\\<lambda>out rpv.\n            the_gpv (right_gpv (callee s out)) \\<bind>\n            case_generat (\\<lambda>(x, y). f (rpv x) y)\n             (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))) =\n       map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n        (the_gpv gpv \\<bind>\n         case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n          (\\<lambda>out rpv.\n              the_gpv (callee s out) \\<bind>\n              case_generat (\\<lambda>(x, y). g (rpv x) y)\n               (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       return_pmf None =\n       map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n        (return_pmf None)\n 2. \\<And>f g gpv s.\n       (\\<And>gpv s.\n           f gpv s =\n           map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n            (g gpv s)) \\<Longrightarrow>\n       the_gpv gpv \\<bind>\n       case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n        (\\<lambda>out rpv.\n            the_gpv (right_gpv (callee s out)) \\<bind>\n            case_generat (\\<lambda>(x, y). f (rpv x) y)\n             (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))) =\n       map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n        (the_gpv gpv \\<bind>\n         case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n          (\\<lambda>out rpv.\n              the_gpv (callee s out) \\<bind>\n              case_generat (\\<lambda>(x, y). g (rpv x) y)\n               (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. return_pmf None =\n    map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n     (return_pmf None)", "by simp"], ["proof (state)\nthis:\n  return_pmf None =\n  map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n   (return_pmf None)\n\ngoal (1 subgoal):\n 1. \\<And>f g gpv s.\n       (\\<And>gpv s.\n           f gpv s =\n           map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n            (g gpv s)) \\<Longrightarrow>\n       the_gpv gpv \\<bind>\n       case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n        (\\<lambda>out rpv.\n            the_gpv (right_gpv (callee s out)) \\<bind>\n            case_generat (\\<lambda>(x, y). f (rpv x) y)\n             (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))) =\n       map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n        (the_gpv gpv \\<bind>\n         case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n          (\\<lambda>out rpv.\n              the_gpv (callee s out) \\<bind>\n              case_generat (\\<lambda>(x, y). g (rpv x) y)\n               (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))", "case (step inline1' inline1'')"], ["proof (state)\nthis:\n  inline1' ?gpv ?s =\n  map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n   (inline1'' ?gpv ?s)\n\ngoal (1 subgoal):\n 1. \\<And>f g gpv s.\n       (\\<And>gpv s.\n           f gpv s =\n           map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n            (g gpv s)) \\<Longrightarrow>\n       the_gpv gpv \\<bind>\n       case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n        (\\<lambda>out rpv.\n            the_gpv (right_gpv (callee s out)) \\<bind>\n            case_generat (\\<lambda>(x, y). f (rpv x) y)\n             (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))) =\n       map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n        (the_gpv gpv \\<bind>\n         case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n          (\\<lambda>out rpv.\n              the_gpv (callee s out) \\<bind>\n              case_generat (\\<lambda>(x, y). g (rpv x) y)\n               (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))", "then"], ["proof (chain)\npicking this:\n  inline1' ?gpv ?s =\n  map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n   (inline1'' ?gpv ?s)", "show ?case"], ["proof (prove)\nusing this:\n  inline1' ?gpv ?s =\n  map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n   (inline1'' ?gpv ?s)\n\ngoal (1 subgoal):\n 1. the_gpv gpv \\<bind>\n    (\\<lambda>a.\n        case a of Pure x \\<Rightarrow> return_spmf (Inl (x, s))\n        | IO out rpv \\<Rightarrow>\n            the_gpv (right_gpv (callee s out)) \\<bind>\n            (\\<lambda>a.\n                case a of Pure (x, y) \\<Rightarrow> inline1' (rpv x) y\n                | IO out rpv' \\<Rightarrow>\n                    return_spmf (Inr (out, rpv', rpv)))) =\n    map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n     (the_gpv gpv \\<bind>\n      (\\<lambda>a.\n          case a of Pure x \\<Rightarrow> return_spmf (Inl (x, s))\n          | IO out rpv \\<Rightarrow>\n              the_gpv (callee s out) \\<bind>\n              (\\<lambda>a.\n                  case a of Pure (x, y) \\<Rightarrow> inline1'' (rpv x) y\n                  | IO out rpv' \\<Rightarrow>\n                      return_spmf (Inr (out, rpv', rpv)))))", "by(auto simp add: map_spmf_bind_spmf o_def bind_map_spmf intro!: ext bind_spmf_cong split: generat.split)"], ["proof (state)\nthis:\n  the_gpv gpv \\<bind>\n  (\\<lambda>a.\n      case a of Pure x \\<Rightarrow> return_spmf (Inl (x, s))\n      | IO out rpv \\<Rightarrow>\n          the_gpv (right_gpv (callee s out)) \\<bind>\n          (\\<lambda>a.\n              case a of Pure (x, y) \\<Rightarrow> inline1' (rpv x) y\n              | IO out rpv' \\<Rightarrow>\n                  return_spmf (Inr (out, rpv', rpv)))) =\n  map_spmf (map_sum id (map_prod Inr (map_prod right_rpv id)))\n   (the_gpv gpv \\<bind>\n    (\\<lambda>a.\n        case a of Pure x \\<Rightarrow> return_spmf (Inl (x, s))\n        | IO out rpv \\<Rightarrow>\n            the_gpv (callee s out) \\<bind>\n            (\\<lambda>a.\n                case a of Pure (x, y) \\<Rightarrow> inline1'' (rpv x) y\n                | IO out rpv' \\<Rightarrow>\n                    return_spmf (Inr (out, rpv', rpv)))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma right_gpv_inline: \"right_gpv (inline callee gpv s) = inline (\\<lambda>s q. right_gpv (callee s q)) gpv s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_gpv (inline callee gpv s) =\n    inline (\\<lambda>s q. right_gpv (callee s q)) gpv s", "by(coinduction arbitrary: callee gpv s rule: gpv_coinduct_bind)\n    (fastforce simp add: inline_sel spmf_rel_map inline1_right_gpv right_gpv_bind_gpv o_def split_def intro!: rel_spmf_reflI split: sum.split intro!: rel_funI gpv.rel_refl_strong)"], ["", "lemma WT_gpv_left_gpv: \"\\<I>1 \\<turnstile>g gpv \\<surd> \\<Longrightarrow> \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2 \\<turnstile>g left_gpv gpv \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>1 \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n    \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2 \\<turnstile>g left_gpv gpv \\<surd>", "by(coinduction arbitrary: gpv)(auto 4 4 dest: WT_gpvD)"], ["", "lemma WT_gpv_right_gpv: \"\\<I>2 \\<turnstile>g gpv \\<surd> \\<Longrightarrow> \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2 \\<turnstile>g right_gpv gpv \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>2 \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n    \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2 \\<turnstile>g right_gpv gpv \\<surd>", "by(coinduction arbitrary: gpv)(auto 4 4 dest: WT_gpvD)"], ["", "lemma results_gpv_left_gpv [simp]: \"results_gpv (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (left_gpv gpv) = results_gpv \\<I>1 gpv\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. results_gpv (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (left_gpv gpv) =\n    results_gpv \\<I>1 gpv", "proof(rule Set.set_eqI iffI)+"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> results_gpv (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n                (left_gpv gpv) \\<Longrightarrow>\n       x \\<in> results_gpv \\<I>1 gpv\n 2. \\<And>x.\n       x \\<in> results_gpv \\<I>1 gpv \\<Longrightarrow>\n       x \\<in> results_gpv (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (left_gpv gpv)", "show \"x \\<in> ?rhs\" if \"x \\<in> ?lhs\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> results_gpv \\<I>1 gpv", "using that"], ["proof (prove)\nusing this:\n  x \\<in> results_gpv (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (left_gpv gpv)\n\ngoal (1 subgoal):\n 1. x \\<in> results_gpv \\<I>1 gpv", "by(induction gpv'\\<equiv>\"left_gpv gpv :: ('a, 'b + 'c, 'd + 'e) gpv\" arbitrary: gpv rule: results_gpv.induct)\n      (fastforce intro: results_gpv.intros)+"], ["proof (state)\nthis:\n  ?x \\<in> results_gpv (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n            (left_gpv gpv) \\<Longrightarrow>\n  ?x \\<in> results_gpv \\<I>1 gpv\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> results_gpv \\<I>1 gpv \\<Longrightarrow>\n       x \\<in> results_gpv (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (left_gpv gpv)", "show \"x \\<in> ?lhs\" if \"x \\<in> ?rhs\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> results_gpv (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (left_gpv gpv)", "using that"], ["proof (prove)\nusing this:\n  x \\<in> results_gpv \\<I>1 gpv\n\ngoal (1 subgoal):\n 1. x \\<in> results_gpv (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (left_gpv gpv)", "by(induction)(fastforce intro: results_gpv.intros)+"], ["proof (state)\nthis:\n  ?x \\<in> results_gpv \\<I>1 gpv \\<Longrightarrow>\n  ?x \\<in> results_gpv (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (left_gpv gpv)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma results_gpv_right_gpv [simp]: \"results_gpv (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (right_gpv gpv) = results_gpv \\<I>2 gpv\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. results_gpv (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (right_gpv gpv) =\n    results_gpv \\<I>2 gpv", "proof(rule Set.set_eqI iffI)+"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> results_gpv (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n                (right_gpv gpv) \\<Longrightarrow>\n       x \\<in> results_gpv \\<I>2 gpv\n 2. \\<And>x.\n       x \\<in> results_gpv \\<I>2 gpv \\<Longrightarrow>\n       x \\<in> results_gpv (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (right_gpv gpv)", "show \"x \\<in> ?rhs\" if \"x \\<in> ?lhs\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> results_gpv \\<I>2 gpv", "using that"], ["proof (prove)\nusing this:\n  x \\<in> results_gpv (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (right_gpv gpv)\n\ngoal (1 subgoal):\n 1. x \\<in> results_gpv \\<I>2 gpv", "by(induction gpv'\\<equiv>\"right_gpv gpv :: ('a, 'b + 'c, 'd + 'e) gpv\" arbitrary: gpv rule: results_gpv.induct)\n      (fastforce intro: results_gpv.intros)+"], ["proof (state)\nthis:\n  ?x \\<in> results_gpv (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n            (right_gpv gpv) \\<Longrightarrow>\n  ?x \\<in> results_gpv \\<I>2 gpv\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> results_gpv \\<I>2 gpv \\<Longrightarrow>\n       x \\<in> results_gpv (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (right_gpv gpv)", "show \"x \\<in> ?lhs\" if \"x \\<in> ?rhs\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> results_gpv (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (right_gpv gpv)", "using that"], ["proof (prove)\nusing this:\n  x \\<in> results_gpv \\<I>2 gpv\n\ngoal (1 subgoal):\n 1. x \\<in> results_gpv (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (right_gpv gpv)", "by(induction)(fastforce intro: results_gpv.intros)+"], ["proof (state)\nthis:\n  ?x \\<in> results_gpv \\<I>2 gpv \\<Longrightarrow>\n  ?x \\<in> results_gpv (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (right_gpv gpv)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma left_gpv_Fail [simp]: \"left_gpv Fail = Fail\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_gpv Fail = Fail", "by(rule gpv.expand) auto"], ["", "lemma right_gpv_Fail [simp]: \"right_gpv Fail = Fail\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_gpv Fail = Fail", "by(rule gpv.expand) auto"], ["", "lemma rsuml_lsumr_left_gpv_left_gpv:\"map_gpv' id rsuml lsumr (left_gpv (left_gpv gpv)) = left_gpv gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_gpv' id rsuml lsumr (left_gpv (left_gpv gpv)) = left_gpv gpv", "by(coinduction arbitrary: gpv)\n    (auto 4 3 simp add: spmf_rel_map generat.rel_map intro!: rel_spmf_reflI rel_generat_reflI rel_funI split!: sum.split elim!: lsumr.elims intro: exI[where x=Fail])"], ["", "lemma rsuml_lsumr_left_gpv_right_gpv: \"map_gpv' id rsuml lsumr (left_gpv (right_gpv gpv)) = right_gpv (left_gpv gpv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_gpv' id rsuml lsumr (left_gpv (right_gpv gpv)) =\n    right_gpv (left_gpv gpv)", "by(coinduction arbitrary: gpv)\n    (auto 4 3 simp add: spmf_rel_map generat.rel_map intro!: rel_spmf_reflI rel_generat_reflI rel_funI split!: sum.split elim!: lsumr.elims intro: exI[where x=Fail])"], ["", "lemma rsuml_lsumr_right_gpv: \"map_gpv' id rsuml lsumr (right_gpv gpv) = right_gpv (right_gpv gpv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_gpv' id rsuml lsumr (right_gpv gpv) = right_gpv (right_gpv gpv)", "by(coinduction arbitrary: gpv)\n    (auto 4 3 simp add: spmf_rel_map generat.rel_map intro!: rel_spmf_reflI rel_generat_reflI rel_funI split!: sum.split elim!: lsumr.elims intro: exI[where x=Fail])"], ["", "lemma map_gpv'_map_gpv_swap:\n  \"map_gpv' f g h (map_gpv f' id gpv) = map_gpv (f \\<circ> f') id (map_gpv' id g h gpv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_gpv' f g h (map_gpv f' id gpv) =\n    map_gpv (f \\<circ> f') id (map_gpv' id g h gpv)", "by(simp add: map_gpv_conv_map_gpv' map_gpv'_comp)"], ["", "lemma lsumr_rsuml_left_gpv: \"map_gpv' id lsumr rsuml (left_gpv gpv) = left_gpv (left_gpv gpv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_gpv' id lsumr rsuml (left_gpv gpv) = left_gpv (left_gpv gpv)", "by(coinduction arbitrary: gpv)\n    (auto 4 3 simp add: spmf_rel_map generat.rel_map intro!: rel_spmf_reflI rel_generat_reflI rel_funI split!: sum.split intro: exI[where x=Fail])"], ["", "lemma lsumr_rsuml_right_gpv_left_gpv:\n  \"map_gpv' id lsumr rsuml (right_gpv (left_gpv gpv)) = left_gpv (right_gpv gpv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_gpv' id lsumr rsuml (right_gpv (left_gpv gpv)) =\n    left_gpv (right_gpv gpv)", "by(coinduction arbitrary: gpv)\n    (auto 4 3 simp add: spmf_rel_map generat.rel_map intro!: rel_spmf_reflI rel_generat_reflI rel_funI split!: sum.split intro: exI[where x=Fail])"], ["", "lemma lsumr_rsuml_right_gpv_right_gpv:\n  \"map_gpv' id lsumr rsuml (right_gpv (right_gpv gpv)) = right_gpv gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_gpv' id lsumr rsuml (right_gpv (right_gpv gpv)) = right_gpv gpv", "by(coinduction arbitrary: gpv)\n    (auto 4 3 simp add: spmf_rel_map generat.rel_map intro!: rel_spmf_reflI rel_generat_reflI rel_funI split!: sum.split elim!: rsuml.elims intro: exI[where x=Fail])"], ["", "lemma in_set_spmf_extend_state_oracle [simp]:\n  \"x \\<in> set_spmf (extend_state_oracle oracle s y) \\<longleftrightarrow>\n   fst (snd x) = fst s \\<and> (fst x, snd (snd x)) \\<in> set_spmf (oracle (snd s) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set_spmf (\\<dagger>oracle s y)) =\n    (fst (snd x) = fst s \\<and>\n     (fst x, snd (snd x)) \\<in> set_spmf (oracle (snd s) y))", "by(auto 4 4 simp add: extend_state_oracle_def split_beta intro: rev_image_eqI prod.expand)"], ["", "lemma extend_state_oracle_plus_oracle: \n  \"extend_state_oracle (plus_oracle oracle1 oracle2) = plus_oracle (extend_state_oracle oracle1) (extend_state_oracle oracle2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<dagger>(oracle1 \\<oplus>\\<^sub>O oracle2) =\n    \\<dagger>oracle1 \\<oplus>\\<^sub>O \\<dagger>oracle2", "proof ((rule ext)+; goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<dagger>(oracle1 \\<oplus>\\<^sub>O oracle2) x xa =\n       (\\<dagger>oracle1 \\<oplus>\\<^sub>O \\<dagger>oracle2) x xa", "case (1 s q)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<dagger>(oracle1 \\<oplus>\\<^sub>O oracle2) x xa =\n       (\\<dagger>oracle1 \\<oplus>\\<^sub>O \\<dagger>oracle2) x xa", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<dagger>(oracle1 \\<oplus>\\<^sub>O oracle2) s q =\n    (\\<dagger>oracle1 \\<oplus>\\<^sub>O \\<dagger>oracle2) s q", "by (cases s; cases q) (simp_all add: apfst_def spmf.map_comp o_def split_def)"], ["proof (state)\nthis:\n  \\<dagger>(oracle1 \\<oplus>\\<^sub>O oracle2) s q =\n  (\\<dagger>oracle1 \\<oplus>\\<^sub>O \\<dagger>oracle2) s q\n\ngoal:\nNo subgoals!", "qed"], ["", "definition stateless_callee :: \"('a \\<Rightarrow> ('b, 'out, 'in) gpv) \\<Rightarrow> ('s \\<Rightarrow> 'a \\<Rightarrow> ('b \\<times> 's, 'out, 'in) gpv)\" where\n  \"stateless_callee callee s = map_gpv (\\<lambda>b. (b, s)) id \\<circ> callee\""], ["", "lemma stateless_callee_parametric': \n  includes lifting_syntax notes [transfer_rule] = map_gpv_parametric' shows\n    \"((A ===> rel_gpv'' B C R) ===> S ===> A ===> (rel_gpv'' (rel_prod B S) C R))\n   stateless_callee stateless_callee\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> rel_gpv'' B C R) ===>\n     S ===> A ===> rel_gpv'' (rel_prod B S) C R)\n     stateless_callee stateless_callee", "unfolding stateless_callee_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> rel_gpv'' B C R) ===>\n     S ===> A ===> rel_gpv'' (rel_prod B S) C R)\n     (\\<lambda>callee s. map_gpv (\\<lambda>b. (b, s)) id \\<circ> callee)\n     (\\<lambda>callee s. map_gpv (\\<lambda>b. (b, s)) id \\<circ> callee)", "by transfer_prover"], ["", "lemma id_oralce_alt_def: \"id_oracle = stateless_callee (\\<lambda>x. Pause x Done)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id_oracle =\n    stateless_callee\n     (\\<lambda>x.\n         Generative_Probabilistic_Value.Pause x\n          Generative_Probabilistic_Value.Done)", "by(simp add: id_oracle_def fun_eq_iff stateless_callee_def)"], ["", "context\n  fixes left :: \"'s1 \\<Rightarrow> 'x1 \\<Rightarrow> ('y1 \\<times> 's1, 'call1, 'ret1) gpv\"\n    and right :: \"'s2 \\<Rightarrow> 'x2 \\<Rightarrow> ('y2 \\<times> 's2, 'call2, 'ret2) gpv\"\nbegin"], ["", "fun parallel_intercept :: \"'s1 \\<times> 's2 \\<Rightarrow> 'x1 + 'x2 \\<Rightarrow> (('y1 + 'y2) \\<times> ('s1 \\<times> 's2), 'call1 + 'call2, 'ret1 + 'ret2) gpv\"\n  where\n    \"parallel_intercept (s1, s2) (Inl a) = left_gpv (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', s2))) id (left s1 a))\"\n  | \"parallel_intercept (s1, s2) (Inr b) = right_gpv (map_gpv (map_prod Inr (Pair s1)) id (right s2 b))\""], ["", "end"], ["", "end"]]}