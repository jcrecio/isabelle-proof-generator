{"file_name": "/home/qj213/afp-2021-10-22/thys/CryptHOL/Cyclic_Group.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CryptHOL", "problem_names": ["lemma generatorE [elim?]:\n  assumes \"x \\<in> carrier G\"\n  obtains n :: nat where \"x = generator G [^] n\"", "lemma inj_on_generator: \"inj_on (([^]) \\<^bold>g) {..<order G}\"", "lemma finite_carrier: \"finite (carrier G)\"", "lemma carrier_conv_generator: \"carrier G = (\\<lambda>n. \\<^bold>g [^] n) ` {..<order G}\"", "lemma bij_betw_generator_carrier:\n  \"bij_betw (\\<lambda>n :: nat. \\<^bold>g [^] n) {..<order G} (carrier G)\"", "lemma order_gt_0: \"order G > 0\"", "lemma (in monoid) order_in_range_Suc: \"order G \\<in> range Suc \\<longleftrightarrow> finite (carrier G)\""], "translations": [["", "lemma generatorE [elim?]:\n  assumes \"x \\<in> carrier G\"\n  obtains n :: nat where \"x = generator G [^] n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        x = \\<^bold>g [^] n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using generator assms"], ["proof (prove)\nusing this:\n  carrier G \\<subseteq> range (([^]) \\<^bold>g)\n  x \\<in> carrier G\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        x = \\<^bold>g [^] n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "lemma inj_on_generator: \"inj_on (([^]) \\<^bold>g) {..<order G}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (([^]) \\<^bold>g) {..<order G}", "proof(rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {..<order G}; y \\<in> {..<order G};\n        \\<^bold>g [^] x = \\<^bold>g [^] y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix n m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {..<order G}; y \\<in> {..<order G};\n        \\<^bold>g [^] x = \\<^bold>g [^] y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"n \\<in> {..<order G}\" \"m \\<in> {..<order G}\""], ["proof (state)\nthis:\n  n \\<in> {..<order G}\n  m \\<in> {..<order G}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {..<order G}; y \\<in> {..<order G};\n        \\<^bold>g [^] x = \\<^bold>g [^] y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence n: \"n < order G\" and m: \"m < order G\""], ["proof (prove)\nusing this:\n  n \\<in> {..<order G}\n  m \\<in> {..<order G}\n\ngoal (1 subgoal):\n 1. n < order G &&& m < order G", "by simp_all"], ["proof (state)\nthis:\n  n < order G\n  m < order G\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {..<order G}; y \\<in> {..<order G};\n        \\<^bold>g [^] x = \\<^bold>g [^] y\\<rbrakk>\n       \\<Longrightarrow> x = y", "moreover"], ["proof (state)\nthis:\n  n < order G\n  m < order G\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {..<order G}; y \\<in> {..<order G};\n        \\<^bold>g [^] x = \\<^bold>g [^] y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"\\<^bold>g [^] n = \\<^bold>g [^] m\""], ["proof (state)\nthis:\n  \\<^bold>g [^] n = \\<^bold>g [^] m\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {..<order G}; y \\<in> {..<order G};\n        \\<^bold>g [^] x = \\<^bold>g [^] y\\<rbrakk>\n       \\<Longrightarrow> x = y", "ultimately"], ["proof (chain)\npicking this:\n  n < order G\n  m < order G\n  \\<^bold>g [^] n = \\<^bold>g [^] m", "show \"n = m\""], ["proof (prove)\nusing this:\n  n < order G\n  m < order G\n  \\<^bold>g [^] n = \\<^bold>g [^] m\n\ngoal (1 subgoal):\n 1. n = m", "proof(induction n m rule: linorder_wlog)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; a < order G; b < order G;\n        \\<^bold>g [^] a = \\<^bold>g [^] b\\<rbrakk>\n       \\<Longrightarrow> a = b\n 2. \\<And>a b.\n       \\<lbrakk>\\<lbrakk>b < order G; a < order G;\n                 \\<^bold>g [^] b = \\<^bold>g [^] a\\<rbrakk>\n                \\<Longrightarrow> b = a;\n        a < order G; b < order G; \\<^bold>g [^] a = \\<^bold>g [^] b\\<rbrakk>\n       \\<Longrightarrow> a = b", "case sym"], ["proof (state)\nthis:\n  \\<lbrakk>b_ < order G; a_ < order G;\n   \\<^bold>g [^] b_ = \\<^bold>g [^] a_\\<rbrakk>\n  \\<Longrightarrow> b_ = a_\n  a_ < order G\n  b_ < order G\n  \\<^bold>g [^] a_ = \\<^bold>g [^] b_\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; a < order G; b < order G;\n        \\<^bold>g [^] a = \\<^bold>g [^] b\\<rbrakk>\n       \\<Longrightarrow> a = b\n 2. \\<And>a b.\n       \\<lbrakk>\\<lbrakk>b < order G; a < order G;\n                 \\<^bold>g [^] b = \\<^bold>g [^] a\\<rbrakk>\n                \\<Longrightarrow> b = a;\n        a < order G; b < order G; \\<^bold>g [^] a = \\<^bold>g [^] b\\<rbrakk>\n       \\<Longrightarrow> a = b", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>b_ < order G; a_ < order G;\n   \\<^bold>g [^] b_ = \\<^bold>g [^] a_\\<rbrakk>\n  \\<Longrightarrow> b_ = a_\n  a_ < order G\n  b_ < order G\n  \\<^bold>g [^] a_ = \\<^bold>g [^] b_\n\ngoal (1 subgoal):\n 1. a_ = b_", "by simp"], ["proof (state)\nthis:\n  a_ = b_\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; a < order G; b < order G;\n        \\<^bold>g [^] a = \\<^bold>g [^] b\\<rbrakk>\n       \\<Longrightarrow> a = b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; a < order G; b < order G;\n        \\<^bold>g [^] a = \\<^bold>g [^] b\\<rbrakk>\n       \\<Longrightarrow> a = b", "case (le n m)"], ["proof (state)\nthis:\n  n \\<le> m\n  n < order G\n  m < order G\n  \\<^bold>g [^] n = \\<^bold>g [^] m\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; a < order G; b < order G;\n        \\<^bold>g [^] a = \\<^bold>g [^] b\\<rbrakk>\n       \\<Longrightarrow> a = b", "let ?d = \"m - n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; a < order G; b < order G;\n        \\<^bold>g [^] a = \\<^bold>g [^] b\\<rbrakk>\n       \\<Longrightarrow> a = b", "have \"\\<^bold>g [^] (int m - int n) = \\<^bold>g [^] int m \\<otimes> inv (\\<^bold>g [^] int n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (int m - int n) =\n    \\<^bold>g [^] int m \\<otimes> inv (\\<^bold>g [^] int n)", "by(simp add: int_pow_diff)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (int m - int n) =\n  \\<^bold>g [^] int m \\<otimes> inv (\\<^bold>g [^] int n)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; a < order G; b < order G;\n        \\<^bold>g [^] a = \\<^bold>g [^] b\\<rbrakk>\n       \\<Longrightarrow> a = b", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] (int m - int n) =\n  \\<^bold>g [^] int m \\<otimes> inv (\\<^bold>g [^] int n)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; a < order G; b < order G;\n        \\<^bold>g [^] a = \\<^bold>g [^] b\\<rbrakk>\n       \\<Longrightarrow> a = b", "have \"\\<^bold>g [^] int m = \\<^bold>g [^] int n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] int m = \\<^bold>g [^] int n", "by(simp add: le.prems int_pow_int)"], ["proof (state)\nthis:\n  \\<^bold>g [^] int m = \\<^bold>g [^] int n\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; a < order G; b < order G;\n        \\<^bold>g [^] a = \\<^bold>g [^] b\\<rbrakk>\n       \\<Longrightarrow> a = b", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] int m = \\<^bold>g [^] int n\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; a < order G; b < order G;\n        \\<^bold>g [^] a = \\<^bold>g [^] b\\<rbrakk>\n       \\<Longrightarrow> a = b", "have \"\\<dots> \\<otimes> inv (\\<^bold>g [^] (int n)) = \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] int n \\<otimes> inv (\\<^bold>g [^] int n) = \\<one>", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] int n \\<otimes> inv (\\<^bold>g [^] int n) = \\<one>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; a < order G; b < order G;\n        \\<^bold>g [^] a = \\<^bold>g [^] b\\<rbrakk>\n       \\<Longrightarrow> a = b", "finally"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] (int m - int n) = \\<one>", "have \"\\<^bold>g [^] ?d = \\<one>\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (int m - int n) = \\<one>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (m - n) = \\<one>", "using le.hyps"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (int m - int n) = \\<one>\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (m - n) = \\<one>", "by(simp add: of_nat_diff[symmetric] int_pow_int)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (m - n) = \\<one>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; a < order G; b < order G;\n        \\<^bold>g [^] a = \\<^bold>g [^] b\\<rbrakk>\n       \\<Longrightarrow> a = b", "{"], ["proof (state)\nthis:\n  \\<^bold>g [^] (m - n) = \\<one>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; a < order G; b < order G;\n        \\<^bold>g [^] a = \\<^bold>g [^] b\\<rbrakk>\n       \\<Longrightarrow> a = b", "assume \"n < m\""], ["proof (state)\nthis:\n  n < m\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; a < order G; b < order G;\n        \\<^bold>g [^] a = \\<^bold>g [^] b\\<rbrakk>\n       \\<Longrightarrow> a = b", "have \"carrier G \\<subseteq> (\\<lambda>n. \\<^bold>g [^] n) ` {..<?d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier G \\<subseteq> ([^]) \\<^bold>g ` {..<m - n}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       x \\<in> ([^]) \\<^bold>g ` {..<m - n}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       x \\<in> ([^]) \\<^bold>g ` {..<m - n}", "assume \"x \\<in> carrier G\""], ["proof (state)\nthis:\n  x \\<in> carrier G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       x \\<in> ([^]) \\<^bold>g ` {..<m - n}", "then"], ["proof (chain)\npicking this:\n  x \\<in> carrier G", "obtain k :: nat where \"x = \\<^bold>g [^] k\""], ["proof (prove)\nusing this:\n  x \\<in> carrier G\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        x = \\<^bold>g [^] k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  x = \\<^bold>g [^] k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       x \\<in> ([^]) \\<^bold>g ` {..<m - n}", "also"], ["proof (state)\nthis:\n  x = \\<^bold>g [^] k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       x \\<in> ([^]) \\<^bold>g ` {..<m - n}", "have \"\\<dots> = (\\<^bold>g [^] ?d) [^] (k div ?d) \\<otimes> \\<^bold>g [^] (k mod ?d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] k =\n    (\\<^bold>g [^] (m - n)) [^] (k div (m - n)) \\<otimes>\n    \\<^bold>g [^] (k mod (m - n))", "by(simp add: nat_pow_pow nat_pow_mult div_mult_mod_eq)"], ["proof (state)\nthis:\n  \\<^bold>g [^] k =\n  (\\<^bold>g [^] (m - n)) [^] (k div (m - n)) \\<otimes>\n  \\<^bold>g [^] (k mod (m - n))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       x \\<in> ([^]) \\<^bold>g ` {..<m - n}", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] k =\n  (\\<^bold>g [^] (m - n)) [^] (k div (m - n)) \\<otimes>\n  \\<^bold>g [^] (k mod (m - n))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       x \\<in> ([^]) \\<^bold>g ` {..<m - n}", "have \"\\<dots> = \\<^bold>g [^] (k mod ?d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (m - n)) [^] (k div (m - n)) \\<otimes>\n    \\<^bold>g [^] (k mod (m - n)) =\n    \\<^bold>g [^] (k mod (m - n))", "using \\<open>\\<^bold>g [^] ?d = \\<one>\\<close>"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (m - n) = \\<one>\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (m - n)) [^] (k div (m - n)) \\<otimes>\n    \\<^bold>g [^] (k mod (m - n)) =\n    \\<^bold>g [^] (k mod (m - n))", "by simp"], ["proof (state)\nthis:\n  (\\<^bold>g [^] (m - n)) [^] (k div (m - n)) \\<otimes>\n  \\<^bold>g [^] (k mod (m - n)) =\n  \\<^bold>g [^] (k mod (m - n))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier G \\<Longrightarrow>\n       x \\<in> ([^]) \\<^bold>g ` {..<m - n}", "finally"], ["proof (chain)\npicking this:\n  x = \\<^bold>g [^] (k mod (m - n))", "show \"x \\<in> (\\<lambda>n. \\<^bold>g [^] n) ` {..<?d}\""], ["proof (prove)\nusing this:\n  x = \\<^bold>g [^] (k mod (m - n))\n\ngoal (1 subgoal):\n 1. x \\<in> ([^]) \\<^bold>g ` {..<m - n}", "using \\<open>n < m\\<close>"], ["proof (prove)\nusing this:\n  x = \\<^bold>g [^] (k mod (m - n))\n  n < m\n\ngoal (1 subgoal):\n 1. x \\<in> ([^]) \\<^bold>g ` {..<m - n}", "by auto"], ["proof (state)\nthis:\n  x \\<in> ([^]) \\<^bold>g ` {..<m - n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  carrier G \\<subseteq> ([^]) \\<^bold>g ` {..<m - n}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; a < order G; b < order G;\n        \\<^bold>g [^] a = \\<^bold>g [^] b\\<rbrakk>\n       \\<Longrightarrow> a = b", "hence \"order G \\<le> card ((\\<lambda>n. \\<^bold>g [^] n) ` {..<?d})\""], ["proof (prove)\nusing this:\n  carrier G \\<subseteq> ([^]) \\<^bold>g ` {..<m - n}\n\ngoal (1 subgoal):\n 1. order G \\<le> card (([^]) \\<^bold>g ` {..<m - n})", "by(simp add: order_def card_mono)"], ["proof (state)\nthis:\n  order G \\<le> card (([^]) \\<^bold>g ` {..<m - n})\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; a < order G; b < order G;\n        \\<^bold>g [^] a = \\<^bold>g [^] b\\<rbrakk>\n       \\<Longrightarrow> a = b", "also"], ["proof (state)\nthis:\n  order G \\<le> card (([^]) \\<^bold>g ` {..<m - n})\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; a < order G; b < order G;\n        \\<^bold>g [^] a = \\<^bold>g [^] b\\<rbrakk>\n       \\<Longrightarrow> a = b", "have \"\\<dots> \\<le> card {..<?d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (([^]) \\<^bold>g ` {..<m - n}) \\<le> card {..<m - n}", "by(rule card_image_le) simp"], ["proof (state)\nthis:\n  card (([^]) \\<^bold>g ` {..<m - n}) \\<le> card {..<m - n}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; a < order G; b < order G;\n        \\<^bold>g [^] a = \\<^bold>g [^] b\\<rbrakk>\n       \\<Longrightarrow> a = b", "also"], ["proof (state)\nthis:\n  card (([^]) \\<^bold>g ` {..<m - n}) \\<le> card {..<m - n}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; a < order G; b < order G;\n        \\<^bold>g [^] a = \\<^bold>g [^] b\\<rbrakk>\n       \\<Longrightarrow> a = b", "have \"\\<dots> < order G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {..<m - n} < order G", "using \\<open>m < order G\\<close>"], ["proof (prove)\nusing this:\n  m < order G\n\ngoal (1 subgoal):\n 1. card {..<m - n} < order G", "by simp"], ["proof (state)\nthis:\n  card {..<m - n} < order G\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; a < order G; b < order G;\n        \\<^bold>g [^] a = \\<^bold>g [^] b\\<rbrakk>\n       \\<Longrightarrow> a = b", "finally"], ["proof (chain)\npicking this:\n  order G < order G", "have False"], ["proof (prove)\nusing this:\n  order G < order G\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; a < order G; b < order G;\n        \\<^bold>g [^] a = \\<^bold>g [^] b\\<rbrakk>\n       \\<Longrightarrow> a = b", "}"], ["proof (state)\nthis:\n  n < m \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; a < order G; b < order G;\n        \\<^bold>g [^] a = \\<^bold>g [^] b\\<rbrakk>\n       \\<Longrightarrow> a = b", "with \\<open>n \\<le> m\\<close>"], ["proof (chain)\npicking this:\n  n \\<le> m\n  n < m \\<Longrightarrow> False", "show \"n = m\""], ["proof (prove)\nusing this:\n  n \\<le> m\n  n < m \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. n = m", "by(auto simp add: order.order_iff_strict)"], ["proof (state)\nthis:\n  n = m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n = m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_carrier: \"finite (carrier G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (carrier G)", "(* contributed by Dominique Unruh *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (carrier G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (carrier G)", "from generator"], ["proof (chain)\npicking this:\n  carrier G \\<subseteq> range (([^]) \\<^bold>g)", "obtain n :: nat where \"\\<^bold>g [^] n = inv \\<^bold>g\""], ["proof (prove)\nusing this:\n  carrier G \\<subseteq> range (([^]) \\<^bold>g)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<^bold>g [^] n = inv \\<^bold>g \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(metis generatorE generator_closed inv_closed)"], ["proof (state)\nthis:\n  \\<^bold>g [^] n = inv \\<^bold>g\n\ngoal (1 subgoal):\n 1. finite (carrier G)", "then"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] n = inv \\<^bold>g", "have g1: \"\\<^bold>g [^] (Suc n) = \\<one>\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] n = inv \\<^bold>g\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] Suc n = \\<one>", "by auto"], ["proof (state)\nthis:\n  \\<^bold>g [^] Suc n = \\<one>\n\ngoal (1 subgoal):\n 1. finite (carrier G)", "have mod: \"\\<^bold>g [^] m = \\<^bold>g [^] (m mod Suc n)\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] m = \\<^bold>g [^] (m mod Suc n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] m = \\<^bold>g [^] (m mod Suc n)", "obtain k where \"m mod Suc n + Suc n * k = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        m mod Suc n + Suc n * k = m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis mod_less_eq_dividend mod_mod_trivial nat_mod_eq_lemma)"], ["proof (state)\nthis:\n  m mod Suc n + Suc n * k = m\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] m = \\<^bold>g [^] (m mod Suc n)", "then"], ["proof (chain)\npicking this:\n  m mod Suc n + Suc n * k = m", "have \"\\<^bold>g [^] m = \\<^bold>g [^] (m mod Suc n + Suc n * k)\""], ["proof (prove)\nusing this:\n  m mod Suc n + Suc n * k = m\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] m = \\<^bold>g [^] (m mod Suc n + Suc n * k)", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] m = \\<^bold>g [^] (m mod Suc n + Suc n * k)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] m = \\<^bold>g [^] (m mod Suc n)", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] m = \\<^bold>g [^] (m mod Suc n + Suc n * k)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] m = \\<^bold>g [^] (m mod Suc n)", "have \"\\<dots> = \\<^bold>g [^] (m mod Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (m mod Suc n + Suc n * k) = \\<^bold>g [^] (m mod Suc n)", "unfolding nat_pow_mult[symmetric, OF generator_closed] nat_pow_pow[symmetric, OF generator_closed] g1"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (m mod Suc n) \\<otimes> \\<one> [^] k =\n    \\<^bold>g [^] (m mod Suc n)", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] (m mod Suc n + Suc n * k) = \\<^bold>g [^] (m mod Suc n)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] m = \\<^bold>g [^] (m mod Suc n)", "finally"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] m = \\<^bold>g [^] (m mod Suc n)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] m = \\<^bold>g [^] (m mod Suc n)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] m = \\<^bold>g [^] (m mod Suc n)", "."], ["proof (state)\nthis:\n  \\<^bold>g [^] m = \\<^bold>g [^] (m mod Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<^bold>g [^] ?m = \\<^bold>g [^] (?m mod Suc n)\n\ngoal (1 subgoal):\n 1. finite (carrier G)", "have \"\\<^bold>g [^] x \\<in> ([^]) \\<^bold>g ` {..<Suc n}\" for x :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] x \\<in> ([^]) \\<^bold>g ` {..<Suc n}", "by (subst mod) auto"], ["proof (state)\nthis:\n  \\<^bold>g [^] ?x \\<in> ([^]) \\<^bold>g ` {..<Suc n}\n\ngoal (1 subgoal):\n 1. finite (carrier G)", "then"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] ?x \\<in> ([^]) \\<^bold>g ` {..<Suc n}", "have \"range (([^]) \\<^bold>g :: nat \\<Rightarrow> _) \\<subseteq> (([^]) \\<^bold>g) ` {..<Suc n}\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] ?x \\<in> ([^]) \\<^bold>g ` {..<Suc n}\n\ngoal (1 subgoal):\n 1. range (([^]) \\<^bold>g) \\<subseteq> ([^]) \\<^bold>g ` {..<Suc n}", "by auto"], ["proof (state)\nthis:\n  range (([^]) \\<^bold>g) \\<subseteq> ([^]) \\<^bold>g ` {..<Suc n}\n\ngoal (1 subgoal):\n 1. finite (carrier G)", "then"], ["proof (chain)\npicking this:\n  range (([^]) \\<^bold>g) \\<subseteq> ([^]) \\<^bold>g ` {..<Suc n}", "have \"finite (range (([^]) \\<^bold>g :: nat \\<Rightarrow> _))\""], ["proof (prove)\nusing this:\n  range (([^]) \\<^bold>g) \\<subseteq> ([^]) \\<^bold>g ` {..<Suc n}\n\ngoal (1 subgoal):\n 1. finite (range (([^]) \\<^bold>g))", "by(rule finite_surj[rotated]) simp"], ["proof (state)\nthis:\n  finite (range (([^]) \\<^bold>g))\n\ngoal (1 subgoal):\n 1. finite (carrier G)", "with generator"], ["proof (chain)\npicking this:\n  carrier G \\<subseteq> range (([^]) \\<^bold>g)\n  finite (range (([^]) \\<^bold>g))", "show ?thesis"], ["proof (prove)\nusing this:\n  carrier G \\<subseteq> range (([^]) \\<^bold>g)\n  finite (range (([^]) \\<^bold>g))\n\ngoal (1 subgoal):\n 1. finite (carrier G)", "by(rule finite_subset)"], ["proof (state)\nthis:\n  finite (carrier G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma carrier_conv_generator: \"carrier G = (\\<lambda>n. \\<^bold>g [^] n) ` {..<order G}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier G = ([^]) \\<^bold>g ` {..<order G}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. carrier G = ([^]) \\<^bold>g ` {..<order G}", "have \"(\\<lambda>n. \\<^bold>g [^] n) ` {..<order G} \\<subseteq> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([^]) \\<^bold>g ` {..<order G} \\<subseteq> carrier G", "by auto"], ["proof (state)\nthis:\n  ([^]) \\<^bold>g ` {..<order G} \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. carrier G = ([^]) \\<^bold>g ` {..<order G}", "moreover"], ["proof (state)\nthis:\n  ([^]) \\<^bold>g ` {..<order G} \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. carrier G = ([^]) \\<^bold>g ` {..<order G}", "have \"card ((\\<lambda>n. \\<^bold>g [^] n) ` {..<order G}) \\<ge> order G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order G \\<le> card (([^]) \\<^bold>g ` {..<order G})", "using inj_on_generator"], ["proof (prove)\nusing this:\n  inj_on (([^]) \\<^bold>g) {..<order G}\n\ngoal (1 subgoal):\n 1. order G \\<le> card (([^]) \\<^bold>g ` {..<order G})", "by(simp add: card_image)"], ["proof (state)\nthis:\n  order G \\<le> card (([^]) \\<^bold>g ` {..<order G})\n\ngoal (1 subgoal):\n 1. carrier G = ([^]) \\<^bold>g ` {..<order G}", "ultimately"], ["proof (chain)\npicking this:\n  ([^]) \\<^bold>g ` {..<order G} \\<subseteq> carrier G\n  order G \\<le> card (([^]) \\<^bold>g ` {..<order G})", "show ?thesis"], ["proof (prove)\nusing this:\n  ([^]) \\<^bold>g ` {..<order G} \\<subseteq> carrier G\n  order G \\<le> card (([^]) \\<^bold>g ` {..<order G})\n\ngoal (1 subgoal):\n 1. carrier G = ([^]) \\<^bold>g ` {..<order G}", "using finite_carrier"], ["proof (prove)\nusing this:\n  ([^]) \\<^bold>g ` {..<order G} \\<subseteq> carrier G\n  order G \\<le> card (([^]) \\<^bold>g ` {..<order G})\n  finite (carrier G)\n\ngoal (1 subgoal):\n 1. carrier G = ([^]) \\<^bold>g ` {..<order G}", "unfolding order_def"], ["proof (prove)\nusing this:\n  ([^]) \\<^bold>g ` {..<card (carrier G)} \\<subseteq> carrier G\n  card (carrier G) \\<le> card (([^]) \\<^bold>g ` {..<card (carrier G)})\n  finite (carrier G)\n\ngoal (1 subgoal):\n 1. carrier G = ([^]) \\<^bold>g ` {..<card (carrier G)}", "by(rule card_seteq[symmetric, rotated])"], ["proof (state)\nthis:\n  carrier G = ([^]) \\<^bold>g ` {..<order G}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bij_betw_generator_carrier:\n  \"bij_betw (\\<lambda>n :: nat. \\<^bold>g [^] n) {..<order G} (carrier G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (([^]) \\<^bold>g) {..<order G} (carrier G)", "by(simp add: bij_betw_def inj_on_generator carrier_conv_generator)"], ["", "lemma order_gt_0: \"order G > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < order G", "using order_gt_0_iff_finite"], ["proof (prove)\nusing this:\n  (0 < order G) = finite (carrier G)\n\ngoal (1 subgoal):\n 1. 0 < order G", "by(simp add: finite_carrier)"], ["", "end"], ["", "lemma (in monoid) order_in_range_Suc: \"order G \\<in> range Suc \\<longleftrightarrow> finite (carrier G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (order G \\<in> range Suc) = finite (carrier G)", "by(cases \"order G\")(auto simp add: order_def carrier_not_empty intro: card_ge_0_finite)"], ["", "end"]]}