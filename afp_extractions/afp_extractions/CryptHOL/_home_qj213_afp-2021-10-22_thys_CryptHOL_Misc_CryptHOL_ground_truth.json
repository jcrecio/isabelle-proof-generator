{"file_name": "/home/qj213/afp-2021-10-22/thys/CryptHOL/Misc_CryptHOL.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CryptHOL", "problem_names": ["lemma asm_rl_conv: \"(PROP P \\<Longrightarrow> PROP P) \\<equiv> Trueprop True\"", "lemma if_mono_cong: \"\\<lbrakk>b \\<Longrightarrow> x \\<le> x'; \\<not> b \\<Longrightarrow> y \\<le> y' \\<rbrakk> \\<Longrightarrow> If b x y \\<le> If b x' y'\"", "lemma if_cong_then: \"\\<lbrakk> b = b'; b' \\<Longrightarrow> t = t'; e = e' \\<rbrakk> \\<Longrightarrow> If b t e = If b' t' e'\"", "lemma if_False_eq: \"\\<lbrakk> b \\<Longrightarrow> False; e = e' \\<rbrakk> \\<Longrightarrow> If b t e = e'\"", "lemma imp_OO_imp [simp]: \"(\\<longrightarrow>) OO (\\<longrightarrow>) = (\\<longrightarrow>)\"", "lemma inj_on_fun_updD: \"\\<lbrakk> inj_on (f(x := y)) A; x \\<notin> A \\<rbrakk> \\<Longrightarrow> inj_on f A\"", "lemma disjoint_notin1: \"\\<lbrakk> A \\<inter> B = {}; x \\<in> B \\<rbrakk> \\<Longrightarrow> x \\<notin> A\"", "lemma Least_le_Least:\n  fixes x :: \"'a :: wellorder\"\n  assumes \"Q x\"\n  and Q: \"\\<And>x. Q x \\<Longrightarrow> \\<exists>y\\<le>x. P y\"\n  shows \"Least P \\<le> Least Q\"", "lemma is_empty_image [simp]: \"Set.is_empty (f ` A) = Set.is_empty A\"", "lemma r_r_into_tranclp: \"\\<lbrakk> r x y; r y z \\<rbrakk> \\<Longrightarrow> r^++ x z\"", "lemma transp_tranclp_id:\n  assumes \"transp R\"\n  shows \"tranclp R = R\"", "lemma transp_inv_image: \"transp r \\<Longrightarrow> transp (\\<lambda>x y. r (f x) (f y))\"", "lemma Domainp_conversep: \"Domainp R\\<inverse>\\<inverse> = Rangep R\"", "lemma bi_unique_rel_set_bij_betw:\n  assumes unique: \"bi_unique R\"\n  and rel: \"rel_set R A B\"\n  shows \"\\<exists>f. bij_betw f A B \\<and> (\\<forall>x\\<in>A. R x (f x))\"", "lemma restrict_relp_apply [simp]: \"(R \\<upharpoonleft> P \\<otimes> Q) x y \\<longleftrightarrow> R x y \\<and> P x \\<and> Q y\"", "lemma restrict_relpI [intro?]: \"\\<lbrakk> R x y; P x; Q y \\<rbrakk> \\<Longrightarrow> (R \\<upharpoonleft> P \\<otimes> Q) x y\"", "lemma restrict_relpE [elim?, cases pred]:\n  assumes \"(R \\<upharpoonleft> P \\<otimes> Q) x y\"\n  obtains (restrict_relp) \"R x y\" \"P x\" \"Q y\"", "lemma conversep_restrict_relp [simp]: \"(R \\<upharpoonleft> P \\<otimes> Q)\\<inverse>\\<inverse> = R\\<inverse>\\<inverse> \\<upharpoonleft> Q \\<otimes> P\"", "lemma restrict_relp_restrict_relp [simp]: \"R \\<upharpoonleft> P \\<otimes> Q \\<upharpoonleft> P' \\<otimes> Q' = R \\<upharpoonleft> inf P P' \\<otimes> inf Q Q'\"", "lemma restrict_relp_cong:\n  \"\\<lbrakk> P = P'; Q = Q'; \\<And>x y. \\<lbrakk> P x; Q y \\<rbrakk> \\<Longrightarrow> R x y = R' x y \\<rbrakk> \\<Longrightarrow> R \\<upharpoonleft> P \\<otimes> Q = R' \\<upharpoonleft> P' \\<otimes> Q'\"", "lemma restrict_relp_cong_simp:\n  \"\\<lbrakk> P = P'; Q = Q'; \\<And>x y. P x =simp=> Q y =simp=> R x y = R' x y \\<rbrakk> \\<Longrightarrow> R \\<upharpoonleft> P \\<otimes> Q = R' \\<upharpoonleft> P' \\<otimes> Q'\"", "lemma restrict_relp_parametric [transfer_rule]:\n  includes lifting_syntax shows\n  \"((A ===> B ===> (=)) ===> (A ===> (=)) ===> (B ===> (=)) ===> A ===> B ===> (=)) restrict_relp restrict_relp\"", "lemma restrict_relp_mono: \"\\<lbrakk> R \\<le> R'; P \\<le> P'; Q \\<le> Q' \\<rbrakk> \\<Longrightarrow> R \\<upharpoonleft> P \\<otimes> Q \\<le> R' \\<upharpoonleft> P' \\<otimes> Q'\"", "lemma restrict_relp_mono': \n  \"\\<lbrakk> (R \\<upharpoonleft> P \\<otimes> Q) x y; \\<lbrakk> R x y; P x; Q y \\<rbrakk> \\<Longrightarrow> R' x y &&& P' x &&& Q' y \\<rbrakk>\n  \\<Longrightarrow> (R' \\<upharpoonleft> P' \\<otimes> Q') x y\"", "lemma restrict_relp_DomainpD: \"Domainp (R \\<upharpoonleft> P \\<otimes> Q) x \\<Longrightarrow> Domainp R x \\<and> P x\"", "lemma restrict_relp_True: \"R \\<upharpoonleft> (\\<lambda>_. True) \\<otimes> (\\<lambda>_. True) = R\"", "lemma restrict_relp_False1: \"R \\<upharpoonleft> (\\<lambda>_. False) \\<otimes> Q = bot\"", "lemma restrict_relp_False2: \"R \\<upharpoonleft> P \\<otimes> (\\<lambda>_. False) = bot\"", "lemma rel_prod2_simps [simp]: \"rel_prod2 R a (c, b) \\<longleftrightarrow> R a b\"", "lemma restrict_rel_prod:\n  \"rel_prod (R \\<upharpoonleft> I1 \\<otimes> I2) (S \\<upharpoonleft> I1' \\<otimes> I2') = rel_prod R S \\<upharpoonleft> pred_prod I1 I1' \\<otimes> pred_prod I2 I2'\"", "lemma restrict_rel_prod1:\n  \"rel_prod (R \\<upharpoonleft> I1 \\<otimes> I2) S = rel_prod R S \\<upharpoonleft> pred_prod I1 (\\<lambda>_. True) \\<otimes> pred_prod I2 (\\<lambda>_. True)\"", "lemma restrict_rel_prod2:\n  \"rel_prod R (S \\<upharpoonleft> I1 \\<otimes> I2) = rel_prod R S \\<upharpoonleft> pred_prod (\\<lambda>_. True) I1 \\<otimes> pred_prod (\\<lambda>_. True) I2\"", "lemmas relcompp_witness[of _ _ \"(x, y)\" for x y, simplified] = relcompp_witness1 relcompp_witness2", "lemma relcompp_witness_eq [simp]: \"relcompp_witness (=) (=) (x, x) = x\"", "lemma split_apfst [simp]: \"case_prod h (apfst f xy) = case_prod (h \\<circ> f) xy\"", "lemma corec_prod_apply: \"corec_prod f g s = (f s, g s)\"", "lemma corec_prod_sel [simp]:\n  shows fst_corec_prod: \"fst (corec_prod f g s) = f s\"\n  and snd_corec_prod: \"snd (corec_prod f g s) = g s\"", "lemma apfst_corec_prod [simp]: \"apfst h (corec_prod f g s) = corec_prod (h \\<circ> f) g s\"", "lemma apsnd_corec_prod [simp]: \"apsnd h (corec_prod f g s) = corec_prod f (h \\<circ> g) s\"", "lemma map_corec_prod [simp]: \"map_prod f g (corec_prod h k s) = corec_prod (f \\<circ> h) (g \\<circ> k) s\"", "lemma split_corec_prod [simp]: \"case_prod h (corec_prod f g s) = h (f s) (g s)\"", "lemma Pair_fst_Unity: \"(fst x, ()) = x\"", "lemma rprodl_simps [simp]: \"rprodl ((a, b), c) = (a, (b, c))\"", "lemma rprodl_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_prod (rel_prod A B) C ===> rel_prod A (rel_prod B C)) rprodl rprodl\"", "lemma lprodr_simps [simp]: \"lprodr (a, b, c) = ((a, b), c)\"", "lemma lprodr_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_prod A (rel_prod B C) ===> rel_prod (rel_prod A B) C) lprodr lprodr\"", "lemma lprodr_inverse [simp]: \"rprodl (lprodr x) = x\"", "lemma rprodl_inverse [simp]: \"lprodr (rprodl x) = x\"", "lemma pred_prod_mono' [mono]:\n  \"pred_prod A B xy \\<longrightarrow> pred_prod A' B' xy\"\n  if \"\\<And>x. A x \\<longrightarrow> A' x\" \"\\<And>y. B y \\<longrightarrow> B' y\"", "lemma islE:\n  assumes \"isl x\"\n  obtains l where \"x = Inl l\"", "lemma Inl_in_Plus [simp]: \"Inl x \\<in> A <+> B \\<longleftrightarrow> x \\<in> A\"", "lemma Inr_in_Plus [simp]: \"Inr x \\<in> A <+> B \\<longleftrightarrow> x \\<in> B\"", "lemma Inl_eq_map_sum_iff: \"Inl x = map_sum f g y \\<longleftrightarrow> (\\<exists>z. y = Inl z \\<and> x = f z)\"", "lemma Inr_eq_map_sum_iff: \"Inr x = map_sum f g y \\<longleftrightarrow> (\\<exists>z. y = Inr z \\<and> x = g z)\"", "lemma inj_on_map_sum [simp]:\n  \"\\<lbrakk> inj_on f A; inj_on g B \\<rbrakk> \\<Longrightarrow> inj_on (map_sum f g) (A <+> B)\"", "lemma inv_into_map_sum:\n  \"inv_into (A <+> B) (map_sum f g) x = map_sum (inv_into A f) (inv_into B g) x\"\n  if \"x \\<in> f ` A <+> g ` B\" \"inj_on f A\" \"inj_on g B\"", "lemma rsuml_lsumr [simp]: \"rsuml (lsumr x) = x\"", "lemma lsumr_rsuml [simp]: \"lsumr (rsuml x) = x\"", "lemma case_option_collapse: \"case_option x (\\<lambda>_. x) y = x\"", "lemma indicator_single_Some: \"indicator {Some x} (Some y) = indicator {x} y\"", "lemma option_pred_mono_strong:\n  \"\\<lbrakk> pred_option P x; \\<And>a. \\<lbrakk> a \\<in> set_option x; P a \\<rbrakk> \\<Longrightarrow> P' a \\<rbrakk> \\<Longrightarrow> pred_option P' x\"", "lemma option_pred_map [simp]: \"pred_option P (map_option f x) = pred_option (P \\<circ> f) x\"", "lemma option_pred_o_map [simp]: \"pred_option P \\<circ> map_option f = pred_option (P \\<circ> f)\"", "lemma option_pred_bind [simp]: \"pred_option P (Option.bind x f) = pred_option (pred_option P \\<circ> f) x\"", "lemma pred_option_conj [simp]:\n  \"pred_option (\\<lambda>x. P x \\<and> Q x) = (\\<lambda>x. pred_option P x \\<and> pred_option Q x)\"", "lemma pred_option_top [simp]:\n  \"pred_option (\\<lambda>_. True) = (\\<lambda>_. True)\"", "lemma rel_option_restrict_relpI [intro?]:\n  \"\\<lbrakk> rel_option R x y; pred_option P x; pred_option Q y \\<rbrakk> \\<Longrightarrow> rel_option (R \\<upharpoonleft> P \\<otimes> Q) x y\"", "lemma rel_option_restrict_relpE [elim?]:\n  assumes \"rel_option (R \\<upharpoonleft> P \\<otimes> Q) x y\"\n  obtains \"rel_option R x y\" \"pred_option P x\" \"pred_option Q y\"", "lemma rel_option_restrict_relp_iff:\n  \"rel_option (R \\<upharpoonleft> P \\<otimes> Q) x y \\<longleftrightarrow> rel_option R x y \\<and> pred_option P x \\<and> pred_option Q y\"", "lemma option_rel_map_restrict_relp:\n  shows option_rel_map_restrict_relp1:\n  \"rel_option (R \\<upharpoonleft> P \\<otimes> Q) (map_option f x) = rel_option (R \\<circ> f \\<upharpoonleft> P \\<circ> f \\<otimes> Q) x\"\n  and option_rel_map_restrict_relp2:\n  \"rel_option (R \\<upharpoonleft> P \\<otimes> Q) x (map_option g y) = rel_option ((\\<lambda>x. R x \\<circ> g) \\<upharpoonleft> P \\<otimes> Q \\<circ> g) x y\"", "lemma rel_witness_option:\n  shows set_rel_witness_option: \"\\<lbrakk> rel_option A x y; (a, b) \\<in> set_option (rel_witness_option (x, y)) \\<rbrakk> \\<Longrightarrow> A a b\"\n    and map1_rel_witness_option: \"rel_option A x y \\<Longrightarrow> map_option fst (rel_witness_option (x, y)) = x\"\n    and map2_rel_witness_option: \"rel_option A x y \\<Longrightarrow> map_option snd (rel_witness_option (x, y)) = y\"", "lemma rel_witness_option1:\n  assumes \"rel_option A x y\"\n  shows \"rel_option (\\<lambda>a (a', b). a = a' \\<and> A a' b) x (rel_witness_option (x, y))\"", "lemma rel_witness_option2:\n  assumes \"rel_option A x y\"\n  shows \"rel_option (\\<lambda>(a, b') b. b = b' \\<and> A a b') (rel_witness_option (x, y)) y\"", "lemma le_option_bind_mono:\n  \"\\<lbrakk> le_option x y; \\<And>a. a \\<in> set_option x \\<Longrightarrow> le_option (f a) (g a) \\<rbrakk>\n  \\<Longrightarrow> le_option (Option.bind x f) (Option.bind y g)\"", "lemma le_option_refl [simp]: \"le_option x x\"", "lemma le_option_conv_option_ord: \"le_option = option_ord\"", "lemma pcr_Some_simps [simp]: \"pcr_Some R x (Some y) \\<longleftrightarrow> R x y\"", "lemma pcr_SomeE [cases pred]:\n  assumes \"pcr_Some R x y\"\n  obtains (pcr_Some) z where \"y = Some z\" \"R x z\"", "lemma set_filter_option [simp]: \"set_option (filter_option P x) = {y \\<in> set_option x. P y}\"", "lemma filter_map_option: \"filter_option P (map_option f x) = map_option f (filter_option (P \\<circ> f) x)\"", "lemma is_none_filter_option [simp]: \"Option.is_none (filter_option P x) \\<longleftrightarrow> Option.is_none x \\<or> \\<not> P (the x)\"", "lemma filter_option_eq_Some_iff [simp]: \"filter_option P x = Some y \\<longleftrightarrow> x = Some y \\<and> P y\"", "lemma Some_eq_filter_option_iff [simp]: \"Some y = filter_option P x \\<longleftrightarrow> x = Some y \\<and> P y\"", "lemma filter_conv_bind_option: \"filter_option P x = Option.bind x (\\<lambda>y. if P y then Some y else None)\"", "lemma set_assert_option_conv: \"set_option (assert_option b) = (if b then {()} else {})\"", "lemma in_set_assert_option [simp]: \"x \\<in> set_option (assert_option b) \\<longleftrightarrow> b\"", "lemma set_join_option [simp]: \"set_option (join_option x) = \\<Union>(set_option ` set_option x)\"", "lemma in_set_join_option: \"x \\<in> set_option (join_option (Some (Some x)))\"", "lemma map_join_option: \"map_option f (join_option x) = join_option (map_option (map_option f) x)\"", "lemma bind_conv_join_option: \"Option.bind x f = join_option (map_option f x)\"", "lemma join_conv_bind_option: \"join_option x = Option.bind x id\"", "lemma join_option_parametric [transfer_rule]:\n  includes lifting_syntax shows\n  \"(rel_option (rel_option R) ===> rel_option R) join_option join_option\"", "lemma join_option_eq_Some [simp]: \"join_option x = Some y \\<longleftrightarrow> x = Some (Some y)\"", "lemma Some_eq_join_option [simp]: \"Some y = join_option x \\<longleftrightarrow> x = Some (Some y)\"", "lemma join_option_eq_None: \"join_option x = None \\<longleftrightarrow> x = None \\<or> x = Some None\"", "lemma None_eq_join_option: \"None = join_option x \\<longleftrightarrow> x = None \\<or> x = Some None\"", "lemma zip_option_eq_Some_iff [iff]:\n  \"zip_option x y = Some (a, b) \\<longleftrightarrow> x = Some a \\<and> y = Some b\"", "lemma set_zip_option [simp]:\n  \"set_option (zip_option x y) = set_option x \\<times> set_option y\"", "lemma zip_map_option1: \"zip_option (map_option f x) y = map_option (apfst f) (zip_option x y)\"", "lemma zip_map_option2: \"zip_option x (map_option g y) = map_option (apsnd g) (zip_option x y)\"", "lemma map_zip_option:\n  \"map_option (map_prod f g) (zip_option x y) = zip_option (map_option f x) (map_option g y)\"", "lemma zip_conv_bind_option:\n  \"zip_option x y = Option.bind x (\\<lambda>x. Option.bind y (\\<lambda>y. Some (x, y)))\"", "lemma zip_option_parametric [transfer_rule]:\n  includes lifting_syntax shows\n  \"(rel_option R ===> rel_option Q ===> rel_option (rel_prod R Q)) zip_option zip_option\"", "lemma rel_option_eqI [simp]: \"rel_option (=) x x\"", "lemma sup_option_idem [simp]: \"sup_option x x = x\"", "lemma sup_option_assoc: \"sup_option (sup_option x y) z = sup_option x (sup_option y z)\"", "lemma sup_option_left_idem: \"sup_option x (sup_option x y) = sup_option x y\"", "lemmas sup_option_ai = sup_option_assoc sup_option_left_idem", "lemma sup_option_None [simp]: \"sup_option None y = y\"", "lemma set_enforce_option [simp]: \"set_option (enforce_option P x) = {a \\<in> set_option x. P a}\"", "lemma enforce_map_option: \"enforce_option P (map_option f x) = map_option f (enforce_option (P \\<circ> f) x)\"", "lemma enforce_bind_option [simp]:\n  \"enforce_option P (Option.bind x f) = Option.bind x (enforce_option P \\<circ> f)\"", "lemma enforce_option_alt_def:\n  \"enforce_option P x = Option.bind x (\\<lambda>a. Option.bind (assert_option (P a)) (\\<lambda>_ :: unit. Some a))\"", "lemma enforce_option_eq_None_iff [simp]:\n  \"enforce_option P x = None \\<longleftrightarrow> (\\<forall>a. x = Some a \\<longrightarrow> \\<not> P a)\"", "lemma enforce_option_eq_Some_iff [simp]:\n  \"enforce_option P x = Some y \\<longleftrightarrow> x = Some y \\<and> P y\"", "lemma Some_eq_enforce_option_iff [simp]:\n  \"Some y = enforce_option P x \\<longleftrightarrow> x = Some y \\<and> P y\"", "lemma enforce_option_top [simp]: \"enforce_option \\<top> = id\"", "lemma enforce_option_K_True [simp]: \"enforce_option (\\<lambda>_. True) x = x\"", "lemma enforce_option_bot [simp]: \"enforce_option \\<bottom> = (\\<lambda>_. None)\"", "lemma enforce_option_K_False [simp]: \"enforce_option (\\<lambda>_. False) x = None\"", "lemma enforce_pred_id_option: \"pred_option P x \\<Longrightarrow> enforce_option P x = x\"", "lemma map_add_apply: \"(m1 ++ m2) x = sup_option (m1 x) (m2 x)\"", "lemma map_le_map_upd2: \"\\<lbrakk> f \\<subseteq>\\<^sub>m g; \\<And>y'. f x = Some y' \\<Longrightarrow> y' = y \\<rbrakk> \\<Longrightarrow> f \\<subseteq>\\<^sub>m g(x \\<mapsto> y)\"", "lemma eq_None_iff_not_dom: \"f x = None \\<longleftrightarrow> x \\<notin> dom f\"", "lemma card_ran_le_dom: \"finite (dom m) \\<Longrightarrow> card (ran m) \\<le> card (dom m)\"", "lemma dom_subset_ran_iff:\n  assumes \"finite (ran m)\"\n  shows \"dom m \\<subseteq> ran m \\<longleftrightarrow> dom m = ran m\"", "lemma map_le_Some1D: \"\\<lbrakk> m \\<subseteq>\\<^sub>m m'; m x = Some y \\<rbrakk> \\<Longrightarrow> m' x = Some y\"", "lemma map_le_fun_upd2: \"\\<lbrakk> f \\<subseteq>\\<^sub>m g; x \\<notin> dom f \\<rbrakk> \\<Longrightarrow> f \\<subseteq>\\<^sub>m g(x := y)\"", "lemma map_eqI: \"\\<forall>x\\<in>dom m \\<union> dom m'. m x = m' x \\<Longrightarrow> m = m'\"", "lemma countable_lfp:\n  assumes step: \"\\<And>Y. countable Y \\<Longrightarrow> countable (F Y)\"\n  and cont: \"Order_Continuity.sup_continuous F\"\n  shows \"countable (lfp F)\"", "lemma countable_lfp_apply:\n  assumes step: \"\\<And>Y x. (\\<And>x. countable (Y x)) \\<Longrightarrow> countable (F Y x)\"\n  and cont: \"Order_Continuity.sup_continuous F\"\n  shows \"countable (lfp F x)\"", "lemma idiff_enat_eq_enat_iff: \"x - enat n = enat m \\<longleftrightarrow> (\\<exists>k. x = enat k \\<and> k - n = m)\"", "lemma eSuc_SUP: \"A \\<noteq> {} \\<Longrightarrow> eSuc (\\<Squnion> (f ` A)) = (\\<Squnion>x\\<in>A. eSuc (f x))\"", "lemma ereal_of_enat_1: \"ereal_of_enat 1 = ereal 1\"", "lemma ennreal_real_conv_ennreal_of_enat: \"ennreal (real n) = ennreal_of_enat n\"", "lemma enat_add_sub_same2: \"b \\<noteq> \\<infinity> \\<Longrightarrow> a + b - b = (a :: enat)\"", "lemma enat_sub_add: \"y \\<le> x \\<Longrightarrow> x - y + z = x + z - (y :: enat)\"", "lemma SUP_enat_eq_0_iff [simp]: \"\\<Squnion> (f ` A) = (0 :: enat) \\<longleftrightarrow> (\\<forall>x\\<in>A. f x = 0)\"", "lemma SUP_enat_add_left:\n  assumes \"I \\<noteq> {}\"\n  shows \"(SUP i\\<in>I. f i + c :: enat) = (SUP i\\<in>I. f i) + c\" (is \"?lhs = ?rhs\")", "lemma SUP_enat_add_right:\n  assumes \"I \\<noteq> {}\"\n  shows \"(SUP i\\<in>I. c + f i :: enat) = c + (SUP i\\<in>I. f i)\"", "lemma iadd_SUP_le_iff: \"n + (SUP x\\<in>A. f x :: enat) \\<le> y \\<longleftrightarrow> (if A = {} then n \\<le> y else \\<forall>x\\<in>A. n + f x \\<le> y)\"", "lemma SUP_iadd_le_iff: \"(SUP x\\<in>A. f x :: enat) + n \\<le> y \\<longleftrightarrow> (if A = {} then n \\<le> y else \\<forall>x\\<in>A. f x + n \\<le> y)\"", "lemma (in finite_measure) nn_integral_indicator_neq_infty: \n  \"f -` A \\<in> sets M \\<Longrightarrow> (\\<integral>\\<^sup>+ x. indicator A (f x) \\<partial>M) \\<noteq> \\<infinity>\"", "lemma (in finite_measure) nn_integral_indicator_neq_top: \n  \"f -` A \\<in> sets M \\<Longrightarrow> (\\<integral>\\<^sup>+ x. indicator A (f x) \\<partial>M) \\<noteq> \\<top>\"", "lemma nn_integral_indicator_map:\n  assumes [measurable]: \"f \\<in> measurable M N\" \"{x\\<in>space N. P x} \\<in> sets N\"\n  shows \"(\\<integral>\\<^sup>+x. indicator {x\\<in>space N. P x} (f x) \\<partial>M) = emeasure M {x\\<in>space M. P (f x)}\"", "lemma transp_rel_fun: \"\\<lbrakk> is_equality Q; transp R \\<rbrakk> \\<Longrightarrow> transp (rel_fun Q R)\"", "lemma rel_fun_inf: \"inf (rel_fun Q R) (rel_fun Q R') = rel_fun Q (inf R R')\"", "lemma reflp_fun1: includes lifting_syntax shows \"\\<lbrakk> is_equality A; reflp B \\<rbrakk> \\<Longrightarrow> reflp (A ===> B)\"", "lemma type_copy_id': \"type_definition (\\<lambda>x. x) (\\<lambda>x. x) UNIV\"", "lemma type_copy_id: \"type_definition id id UNIV\"", "lemma GrpE [cases pred]:\n  assumes \"BNF_Def.Grp A f x y\"\n  obtains (Grp) \"y = f x\" \"x \\<in> A\"", "lemma rel_fun_Grp_copy_Abs:\n  includes lifting_syntax\n  assumes \"type_definition Rep Abs A\"\n  shows \"rel_fun (BNF_Def.Grp A Abs) (BNF_Def.Grp B g) = BNF_Def.Grp {f. f ` A \\<subseteq> B} (Rep ---> g)\"", "lemma rel_set_Grp:\n  \"rel_set (BNF_Def.Grp A f) = BNF_Def.Grp {B. B \\<subseteq> A} (image f)\"", "lemma rel_set_comp_Grp:\n  \"rel_set R = (BNF_Def.Grp {x. x \\<subseteq> {(x, y). R x y}} ((`) fst))\\<inverse>\\<inverse> OO BNF_Def.Grp {x. x \\<subseteq> {(x, y). R x y}} ((`) snd)\"", "lemma Domainp_Grp: \"Domainp (BNF_Def.Grp A f) = (\\<lambda>x. x \\<in> A)\"", "lemma pred_prod_conj [simp]:\n  shows pred_prod_conj1: \"\\<And>P Q R. pred_prod (\\<lambda>x. P x \\<and> Q x) R = (\\<lambda>x. pred_prod P R x \\<and> pred_prod Q R x)\"\n  and pred_prod_conj2: \"\\<And>P Q R. pred_prod P (\\<lambda>x. Q x \\<and> R x) = (\\<lambda>x. pred_prod P Q x \\<and> pred_prod P R x)\"", "lemma pred_sum_conj [simp]:\n  shows pred_sum_conj1: \"\\<And>P Q R. pred_sum (\\<lambda>x. P x \\<and> Q x) R = (\\<lambda>x. pred_sum P R x \\<and> pred_sum Q R x)\"\n  and pred_sum_conj2: \"\\<And>P Q R. pred_sum P (\\<lambda>x. Q x \\<and> R x) = (\\<lambda>x. pred_sum P Q x \\<and> pred_sum P R x)\"", "lemma pred_list_conj [simp]: \"list_all (\\<lambda>x. P x \\<and> Q x) = (\\<lambda>x. list_all P x \\<and> list_all Q x)\"", "lemma pred_prod_top [simp]:\n  \"pred_prod (\\<lambda>_. True) (\\<lambda>_. True) = (\\<lambda>_. True)\"", "lemma rel_fun_conversep: includes lifting_syntax shows\n  \"(A^--1 ===> B^--1) = (A ===> B)^--1\"", "lemma left_unique_Grp [iff]:\n  \"left_unique (BNF_Def.Grp A f) \\<longleftrightarrow> inj_on f A\"", "lemma right_unique_Grp [simp, intro!]: \"right_unique (BNF_Def.Grp A f)\"", "lemma bi_unique_Grp [iff]:\n  \"bi_unique (BNF_Def.Grp A f) \\<longleftrightarrow> inj_on f A\"", "lemma left_total_Grp [iff]:\n  \"left_total (BNF_Def.Grp A f) \\<longleftrightarrow> A = UNIV\"", "lemma right_total_Grp [iff]:\n  \"right_total (BNF_Def.Grp A f) \\<longleftrightarrow> f ` A = UNIV\"", "lemma bi_total_Grp [iff]:\n  \"bi_total (BNF_Def.Grp A f) \\<longleftrightarrow> A = UNIV \\<and> surj f\"", "lemma left_unique_vimage2p [simp]:\n  \"\\<lbrakk> left_unique P; inj f \\<rbrakk> \\<Longrightarrow> left_unique (BNF_Def.vimage2p f g P)\"", "lemma right_unique_vimage2p [simp]:\n  \"\\<lbrakk> right_unique P; inj g \\<rbrakk> \\<Longrightarrow> right_unique (BNF_Def.vimage2p f g P)\"", "lemma bi_unique_vimage2p [simp]:\n  \"\\<lbrakk> bi_unique P; inj f; inj g \\<rbrakk> \\<Longrightarrow> bi_unique (BNF_Def.vimage2p f g P)\"", "lemma left_total_vimage2p [simp]:\n  \"\\<lbrakk> left_total P; surj g \\<rbrakk> \\<Longrightarrow> left_total (BNF_Def.vimage2p f g P)\"", "lemma right_total_vimage2p [simp]:\n  \"\\<lbrakk> right_total P; surj f \\<rbrakk> \\<Longrightarrow> right_total (BNF_Def.vimage2p f g P)\"", "lemma bi_total_vimage2p [simp]:\n  \"\\<lbrakk> bi_total P; surj f; surj g \\<rbrakk> \\<Longrightarrow> bi_total (BNF_Def.vimage2p f g P)\"", "lemma vimage2p_eq [simp]:\n  \"inj f \\<Longrightarrow> BNF_Def.vimage2p f f (=) = (=)\"", "lemma vimage2p_conversep: \"BNF_Def.vimage2p f g R^--1 = (BNF_Def.vimage2p g f R)^--1\"", "lemma rel_fun_refl: \"\\<lbrakk> A \\<le> (=); (=) \\<le> B \\<rbrakk> \\<Longrightarrow> (=) \\<le> rel_fun A B\"", "lemma rel_fun_mono_strong:\n  \"\\<lbrakk> rel_fun A B f g; A' \\<le> A; \\<And>x y. \\<lbrakk> x \\<in> f ` {x. Domainp A' x}; y \\<in> g ` {x. Rangep A' x}; B x y \\<rbrakk> \\<Longrightarrow> B' x y \\<rbrakk> \\<Longrightarrow> rel_fun A' B' f g\"", "lemma rel_fun_refl_strong: \n  assumes \"A \\<le> (=)\" \"\\<And>x. x \\<in> f ` {x. Domainp A x} \\<Longrightarrow> B x x\"\n  shows \"rel_fun A B f f\"", "lemma Grp_iff: \"BNF_Def.Grp B g x y \\<longleftrightarrow> y = g x \\<and> x \\<in> B\"", "lemma Rangep_Grp: \"Rangep (BNF_Def.Grp A f) = (\\<lambda>x. x \\<in> f ` A)\"", "lemma rel_fun_Grp:\n  \"rel_fun (BNF_Def.Grp UNIV h)\\<inverse>\\<inverse> (BNF_Def.Grp A g) = BNF_Def.Grp {f. f ` range h \\<subseteq> A} (map_fun h g)\"", "lemma monotone_parametric [transfer_rule]:\n  assumes [transfer_rule]: \"bi_total A\"\n  shows \"((A ===> A ===> (=)) ===> (B ===> B ===> (=)) ===> (A ===> B) ===> (=)) monotone monotone\"", "lemma fun_ord_parametric [transfer_rule]:\n  assumes [transfer_rule]: \"bi_total C\"\n  shows \"((A ===> B ===> (=)) ===> (C ===> A) ===> (C ===> B) ===> (=)) fun_ord fun_ord\"", "lemma Plus_parametric [transfer_rule]:\n  \"(rel_set A ===> rel_set B ===> rel_set (rel_sum A B)) (<+>) (<+>)\"", "lemma pred_fun_parametric [transfer_rule]:\n  assumes [transfer_rule]: \"bi_total A\"\n  shows \"((A ===> (=)) ===> (B ===> (=)) ===> (A ===> B) ===> (=)) pred_fun pred_fun\"", "lemma rel_fun_eq_OO: \"((=) ===> A) OO ((=) ===> B) = ((=) ===> A OO B)\"", "lemma Quotient_set_rel_eq:\n  includes lifting_syntax\n  assumes \"Quotient R Abs Rep T\"\n  shows \"(rel_set T ===> rel_set T ===> (=)) (rel_set R) (=)\"", "lemma Domainp_eq: \"Domainp (=) = (\\<lambda>_. True)\"", "lemma rel_fun_eq_onpI: \"eq_onp (pred_fun P Q) f g \\<Longrightarrow> rel_fun (eq_onp P) (eq_onp Q) f g\"", "lemma bi_unique_eq_onp: \"bi_unique (eq_onp P)\"", "lemma rel_fun_eq_conversep: includes lifting_syntax shows \"(A\\<inverse>\\<inverse> ===> (=)) = (A ===> (=))\\<inverse>\\<inverse>\"", "lemma rel_fun_comp:\n  \"\\<And>f g h. rel_fun A B (f \\<circ> g) h = rel_fun A (\\<lambda>x. B (f x)) g h\"\n  \"\\<And>f g h. rel_fun A B f (g \\<circ> h) = rel_fun A (\\<lambda>x y. B x (g y)) f h\"", "lemma rel_fun_map_fun1: \"rel_fun (BNF_Def.Grp UNIV h)\\<inverse>\\<inverse> A f g \\<Longrightarrow> rel_fun (=) A (map_fun h id f) g\"", "lemma map_fun2_id: \"map_fun f g x = g \\<circ> map_fun f id x\"", "lemma map_fun_id2_in: \"map_fun g h f = map_fun g id (h \\<circ> f)\"", "lemma Domainp_rel_fun_le: \"Domainp (rel_fun A B) \\<le> pred_fun (Domainp A) (Domainp B)\"", "lemma\n  assumes fg: \"rel_fun (A OO A') B f g\"\n    and A: \"left_unique A\" \"right_total A\"\n    and A': \"right_unique A'\" \"left_total A'\"\n  shows rel_witness_fun1: \"rel_fun A (\\<lambda>x (x', y). x = x' \\<and> B x' y) f (rel_witness_fun A A' (f, g))\"\n    and rel_witness_fun2: \"rel_fun A' (\\<lambda>(x, y') y. y = y' \\<and> B x y') (rel_witness_fun A A' (f, g)) g\"", "lemma rel_witness_fun_eq [simp]: \"rel_witness_fun (=) (=) (f, g) = (\\<lambda>x. (f x, g x))\"", "lemma abs_diff_triangle_ineq2: \"\\<bar>a - b :: _ :: ordered_ab_group_add_abs\\<bar> \\<le> \\<bar>a - c\\<bar> + \\<bar>c - b\\<bar>\"", "lemma (in ordered_ab_semigroup_add) add_left_mono_trans:\n  \"\\<lbrakk> x \\<le> a + b; b \\<le> c \\<rbrakk> \\<Longrightarrow> x \\<le> a + c\"", "lemma of_nat_le_one_cancel_iff [simp]:\n  fixes n :: nat shows \"real n \\<le> 1 \\<longleftrightarrow> n \\<le> 1\"", "lemma (in linordered_semidom) mult_right_le: \"c \\<le> 1 \\<Longrightarrow> 0 \\<le> a \\<Longrightarrow> c * a \\<le> a\"", "lemma fun_ordD: \"fun_ord ord f g \\<Longrightarrow> ord (f x) (g x)\"", "lemma parallel_fixp_induct_strong:\n  assumes ccpo1: \"class.ccpo luba orda (mk_less orda)\"\n  and ccpo2: \"class.ccpo lubb ordb (mk_less ordb)\"\n  and adm: \"ccpo.admissible (prod_lub luba lubb) (rel_prod orda ordb) (\\<lambda>x. P (fst x) (snd x))\"\n  and f: \"monotone orda orda f\"\n  and g: \"monotone ordb ordb g\"\n  and bot: \"P (luba {}) (lubb {})\"\n  and step: \"\\<And>x y. \\<lbrakk> orda x (ccpo.fixp luba orda f); ordb y (ccpo.fixp lubb ordb g); P x y \\<rbrakk> \\<Longrightarrow> P (f x) (g y)\"\n  shows \"P (ccpo.fixp luba orda f) (ccpo.fixp lubb ordb g)\"", "lemma parallel_fixp_induct_strong_uc:\n  assumes a: \"partial_function_definitions orda luba\"\n  and b: \"partial_function_definitions ordb lubb\"\n  and F: \"\\<And>x. monotone (fun_ord orda) orda (\\<lambda>f. U1 (F (C1 f)) x)\"\n  and G: \"\\<And>y. monotone (fun_ord ordb) ordb (\\<lambda>g. U2 (G (C2 g)) y)\"\n  and eq1: \"f \\<equiv> C1 (ccpo.fixp (fun_lub luba) (fun_ord orda) (\\<lambda>f. U1 (F (C1 f))))\"\n  and eq2: \"g \\<equiv> C2 (ccpo.fixp (fun_lub lubb) (fun_ord ordb) (\\<lambda>g. U2 (G (C2 g))))\"\n  and inverse: \"\\<And>f. U1 (C1 f) = f\"\n  and inverse2: \"\\<And>g. U2 (C2 g) = g\"\n  and adm: \"ccpo.admissible (prod_lub (fun_lub luba) (fun_lub lubb)) (rel_prod (fun_ord orda) (fun_ord ordb)) (\\<lambda>x. P (fst x) (snd x))\"\n  and bot: \"P (\\<lambda>_. luba {}) (\\<lambda>_. lubb {})\"\n  and step: \"\\<And>f' g'. \\<lbrakk> \\<And>x. orda (U1 f' x) (U1 f x); \\<And>y. ordb (U2 g' y) (U2 g y); P (U1 f') (U2 g') \\<rbrakk> \\<Longrightarrow> P (U1 (F f')) (U2 (G g'))\"\n  shows \"P (U1 f) (U2 g)\"", "lemmas parallel_fixp_induct_strong_1_1 = parallel_fixp_induct_strong_uc[\n  of _ _ _ _ \"\\<lambda>x. x\" _ \"\\<lambda>x. x\" \"\\<lambda>x. x\" _ \"\\<lambda>x. x\",\n  OF _ _ _ _ _ _ refl refl]", "lemmas parallel_fixp_induct_strong_2_2 = parallel_fixp_induct_strong_uc[\n  of _ _ _ _ \"case_prod\" _ \"curry\" \"case_prod\" _ \"curry\",\n  where P=\"\\<lambda>f g. P (curry f) (curry g)\",\n  unfolded case_prod_curry curry_case_prod curry_K,\n  OF _ _ _ _ _ _ refl refl,\n  split_format (complete), unfolded prod.case]\n  for P", "lemma fixp_induct_option': \\<comment> \\<open>Stronger induction rule\\<close>\n  fixes F :: \"'c \\<Rightarrow> 'c\" and\n    U :: \"'c \\<Rightarrow> 'b \\<Rightarrow> 'a option\" and\n    C :: \"('b \\<Rightarrow> 'a option) \\<Rightarrow> 'c\" and\n    P :: \"'b \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  assumes mono: \"\\<And>x. mono_option (\\<lambda>f. U (F (C f)) x)\"\n  assumes eq: \"f \\<equiv> C (ccpo.fixp (fun_lub (flat_lub None)) (fun_ord option_ord) (\\<lambda>f. U (F (C f))))\"\n  assumes inverse2: \"\\<And>f. U (C f) = f\"\n  assumes step: \"\\<And>g x y. \\<lbrakk> \\<And>x y. U g x = Some y \\<Longrightarrow> P x y; U (F g) x = Some y; \\<And>x. option_ord (U g x) (U f x) \\<rbrakk> \\<Longrightarrow> P x y\"\n  assumes defined: \"U f x = Some y\"\n  shows \"P x y\"", "lemma bot_fun_least [simp]: \"(\\<lambda>_. bot :: 'a :: order_bot) \\<le> x\"", "lemma fun_ord_conv_rel_fun: \"fun_ord = rel_fun (=)\"", "lemma finite_chainsD: \"\\<lbrakk> finite_chains ord; Complete_Partial_Order.chain ord Y \\<rbrakk> \\<Longrightarrow> finite Y\"", "lemma finite_chains_flat_ord [simp, intro!]: \"finite_chains (flat_ord x)\"", "lemma mcont_finite_chains:\n  assumes finite: \"finite_chains ord\"\n  and mono: \"monotone ord ord' f\"\n  and ccpo: \"class.ccpo lub ord (mk_less ord)\"\n  and ccpo': \"class.ccpo lub' ord' (mk_less ord')\"\n  shows \"mcont lub ord lub' ord' f\"", "lemma rel_fun_curry: includes lifting_syntax shows\n  \"(A ===> B ===> C) f g \\<longleftrightarrow> (rel_prod A B ===> C) (case_prod f) (case_prod g)\"", "lemma (in ccpo) Sup_image_mono:\n  assumes ccpo: \"class.ccpo luba orda lessa\"\n  and mono: \"monotone orda (\\<le>) f\"\n  and chain: \"Complete_Partial_Order.chain orda A\"\n  and \"A \\<noteq> {}\"\n  shows \"Sup (f ` A) \\<le> (f (luba A))\"", "lemma (in ccpo) admissible_le_mono:\n  assumes \"monotone (\\<le>) (\\<le>) f\"\n  shows \"ccpo.admissible Sup (\\<le>) (\\<lambda>x. x \\<le> f x)\"", "lemma (in ccpo) fixp_induct_strong2:\n  assumes adm: \"ccpo.admissible Sup (\\<le>) P\"\n  and mono: \"monotone (\\<le>) (\\<le>) f\"\n  and bot: \"P (\\<Squnion>{})\"\n  and step: \"\\<And>x. \\<lbrakk> x \\<le> ccpo_class.fixp f; x \\<le> f x; P x \\<rbrakk> \\<Longrightarrow> P (f x)\"\n  shows \"P (ccpo_class.fixp f)\"", "lemma fixp_induct_strong2_uc:\n  fixes F :: \"'c \\<Rightarrow> 'c\"\n    and U :: \"'c \\<Rightarrow> 'b \\<Rightarrow> 'a\"\n    and C :: \"('b \\<Rightarrow> 'a) \\<Rightarrow> 'c\"\n    and P :: \"('b \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n  assumes mono: \"\\<And>x. mono_body (\\<lambda>f. U (F (C f)) x)\"\n    and eq: \"f \\<equiv> C (fixp_fun (\\<lambda>f. U (F (C f))))\"\n    and inverse: \"\\<And>f. U (C f) = f\"\n    and adm: \"ccpo.admissible lub_fun le_fun P\"\n    and bot: \"P (\\<lambda>_. lub {})\"\n    and step: \"\\<And>f'. \\<lbrakk> le_fun (U f') (U f); le_fun (U f') (U (F f')); P (U f') \\<rbrakk> \\<Longrightarrow> P (U (F f'))\"\n  shows \"P (U f)\"", "lemmas parallel_fixp_induct_2_4 = parallel_fixp_induct_uc[\n  of _ _ _ _ \"case_prod\" _ \"curry\" \"\\<lambda>f. case_prod (case_prod (case_prod f))\" _ \"\\<lambda>f. curry (curry (curry f))\",\n  where P=\"\\<lambda>f g. P (curry f) (curry (curry (curry g)))\",\n  unfolded case_prod_curry curry_case_prod curry_K,\n  OF _ _ _ _ _ _ refl refl]\n  for P", "lemma (in ccpo) fixp_greatest:\n  assumes f: \"monotone (\\<le>) (\\<le>) f\"\n    and ge: \"\\<And>y. f y \\<le> y \\<Longrightarrow> x \\<le> y\"\n  shows \"x \\<le> ccpo.fixp Sup (\\<le>) f\"", "lemma fixp_rolling:\n  assumes \"class.ccpo lub1 leq1 (mk_less leq1)\"\n    and \"class.ccpo lub2 leq2 (mk_less leq2)\"\n    and f: \"monotone leq1 leq2 f\"\n    and g: \"monotone leq2 leq1 g\"\n  shows \"ccpo.fixp lub1 leq1 (\\<lambda>x. g (f x)) = g (ccpo.fixp lub2 leq2 (\\<lambda>x. f (g x)))\"", "lemma fixp_lfp_parametric_eq:\n  includes lifting_syntax\n  assumes f: \"\\<And>x. lfp.mono_body (\\<lambda>f. F f x)\"\n  and g: \"\\<And>x. lfp.mono_body (\\<lambda>f. G f x)\"\n  and param: \"((A ===> (=)) ===> A ===> (=)) F G\"\n  shows \"(A ===> (=)) (lfp.fixp_fun F) (lfp.fixp_fun G)\"", "lemma mono2mono_map_option[THEN option.mono2mono, simp, cont_intro]:\n  shows monotone_map_option: \"monotone option_ord option_ord (map_option f)\"", "lemma mcont2mcont_map_option[THEN option.mcont2mcont, simp, cont_intro]:\n  shows mcont_map_option: \"mcont (flat_lub None) option_ord (flat_lub None) option_ord (map_option f)\"", "lemma mono2mono_set_option [THEN lfp.mono2mono]:\n  shows monotone_set_option: \"monotone option_ord (\\<subseteq>) set_option\"", "lemma mcont2mcont_set_option [THEN lfp.mcont2mcont, cont_intro, simp]:\n  shows mcont_set_option: \"mcont (flat_lub None) option_ord Union (\\<subseteq>) set_option\"", "lemma eadd_gfp_partial_function_mono [partial_function_mono]:\n  \"\\<lbrakk> monotone (fun_ord (\\<ge>)) (\\<ge>) f; monotone (fun_ord (\\<ge>)) (\\<ge>) g \\<rbrakk>\n  \\<Longrightarrow> monotone (fun_ord (\\<ge>)) (\\<ge>) (\\<lambda>x. f x + g x :: enat)\"", "lemma map_option_mono [partial_function_mono]:\n  \"mono_option B \\<Longrightarrow> mono_option (\\<lambda>f. map_option g (B f))\"", "lemma (in comp_fun_commute) fold_invariant_remove [consumes 1, case_names start step]:\n  assumes fin: \"finite A\"\n  and start: \"I A s\"\n  and step: \"\\<And>x s A'. \\<lbrakk> x \\<in> A'; I A' s; A' \\<subseteq> A \\<rbrakk> \\<Longrightarrow> I (A' - {x}) (f x s)\"\n  shows \"I {} (Finite_Set.fold f s A)\"", "lemma (in comp_fun_commute) fold_invariant_insert [consumes 1, case_names start step]:\n  assumes fin: \"finite A\"\n  and start: \"I {} s\"\n  and step: \"\\<And>x s A'. \\<lbrakk> I A' s; x \\<notin> A'; x \\<in> A; A' \\<subseteq> A \\<rbrakk> \\<Longrightarrow> I (insert x A') (f x s)\"\n  shows \"I A (Finite_Set.fold f s A)\"", "lemma (in comp_fun_idem) fold_set_union:\n  assumes \"finite A\" \"finite B\"\n  shows \"Finite_Set.fold f z (A \\<union> B) = Finite_Set.fold f (Finite_Set.fold f z A) B\"", "lemma nth_eq_tlI: \"xs ! n = z \\<Longrightarrow> (x # xs) ! Suc n = z\"", "lemma list_all2_append':\n  \"length us = length vs \\<Longrightarrow> list_all2 P (xs @ us) (ys @ vs) \\<longleftrightarrow> list_all2 P xs ys \\<and> list_all2 P us vs\"", "lemma disjointpD:\n  \"\\<lbrakk> disjointp xs; (xs ! n) x; (xs ! m) x; n < length xs; m < length xs \\<rbrakk> \\<Longrightarrow> n = m\"", "lemma disjointpD':\n  \"\\<lbrakk> disjointp xs; P x; Q x; xs ! n = P; xs ! m = Q; n < length xs; m < length xs \\<rbrakk> \\<Longrightarrow> n = m\"", "lemma wf_strict_prefix: \"wfP strict_prefix\"", "lemma strict_prefix_setD:\n  \"strict_prefix xs ys \\<Longrightarrow> set xs \\<subseteq> set ys\"", "lemma nlists_alt_def: \"nlists A n = {xs. set xs \\<subseteq> A \\<and> length xs = n}\"", "lemma nlists_empty: \"nlists {} n = (if n = 0 then {[]} else {})\"", "lemma nlists_empty_gt0 [simp]: \"n > 0 \\<Longrightarrow> nlists {} n = {}\"", "lemma nlists_0 [simp]: \"nlists A 0 = {[]}\"", "lemma Cons_in_nlists_Suc [simp]: \"x # xs \\<in> nlists A (Suc n) \\<longleftrightarrow> x \\<in> A \\<and> xs \\<in> nlists A n\"", "lemma Nil_in_nlists [simp]: \"[] \\<in> nlists A n \\<longleftrightarrow> n = 0\"", "lemma Cons_in_nlists_iff: \"x # xs \\<in> nlists A n \\<longleftrightarrow> (\\<exists>n'. n = Suc n' \\<and> x \\<in> A \\<and> xs \\<in> nlists A n')\"", "lemma in_nlists_Suc_iff: \"xs \\<in> nlists A (Suc n) \\<longleftrightarrow> (\\<exists>x xs'. xs = x # xs' \\<and> x \\<in> A \\<and> xs' \\<in> nlists A n)\"", "lemma nlists_Suc: \"nlists A (Suc n) = (\\<Union>x\\<in>A. (#) x ` nlists A n)\"", "lemma replicate_in_nlists [simp, intro]: \"x \\<in> A \\<Longrightarrow> replicate n x \\<in> nlists A n\"", "lemma nlists_eq_empty_iff [simp]: \"nlists A n = {} \\<longleftrightarrow> n > 0 \\<and> A = {}\"", "lemma finite_nlists [simp]: \"finite A \\<Longrightarrow> finite (nlists A n)\"", "lemma finite_nlistsD: \n  assumes \"finite (nlists A n)\"\n  shows \"finite A \\<or> n = 0\"", "lemma finite_nlists_iff: \"finite (nlists A n) \\<longleftrightarrow> finite A \\<or> n = 0\"", "lemma card_nlists: \"card (nlists A n) = card A ^ n\"", "lemma in_nlists_UNIV: \"xs \\<in> nlists UNIV n \\<longleftrightarrow> length xs = n\"", "lemma sprefix_append: \"sprefix (xs @ ys) zs \\<longleftrightarrow> sprefix xs zs \\<and> sprefix ys (sdrop (length xs) zs)\"", "lemma sprefix_stake_same [simp]: \"sprefix (stake n xs) xs\"", "lemma sprefix_same_imp_eq:\n  assumes \"sprefix xs ys\" \"sprefix xs' ys\"\n  and \"length xs = length xs'\"\n  shows \"xs = xs'\"", "lemma sprefix_shift_same [simp]:\n  \"sprefix xs (xs @- ys)\"", "lemma sprefix_shift [simp]:\n  \"length xs \\<le> length ys \\<Longrightarrow> sprefix xs (ys @- zs) \\<longleftrightarrow> prefix xs ys\"", "lemma prefixeq_stake2 [simp]: \"prefix xs (stake n ys) \\<longleftrightarrow> length xs \\<le> n \\<and> sprefix xs ys\"", "lemma tlength_eq_infinity_iff: \"tlength xs = \\<infinity> \\<longleftrightarrow> \\<not> tfinite xs\"", "lemma bind_option_parametric [transfer_rule]:\n  \"(M ===> rel_option B ===> (B ===> M) ===> M) bind_option bind_option\"", "lemma bind_option_K:\n  \"\\<And>monad. (x = None \\<Longrightarrow> m = fail) \\<Longrightarrow> bind_option fail x (\\<lambda>_. m) = m\"", "lemma bind_option_option [simp]: \"monad.bind_option None = Option.bind\"", "lemma hom_bind_option: \"h (monad.bind_option fail1 x f) = monad.bind_option fail2 x (h \\<circ> f)\"", "lemma bind_option_set [simp]: \"monad.bind_option fail_set = (\\<lambda>x f. \\<Union> (f ` set_option x))\"", "lemma run_bind_option_stateT [simp]:\n  \"\\<And>more. run_state (monad.bind_option (fail_state fail) x f) s = \n  monad.bind_option fail x (\\<lambda>y. run_state (f y) s)\"", "lemma run_bind_option_envT [simp]:\n  \"\\<And>more. run_env (monad.bind_option (fail_env fail) x f) s = \n  monad.bind_option fail x (\\<lambda>y. run_env (f y) s)\"", "lemma (in sigma_algebra) sets_Collect_countable_Ex1:\n  \"(\\<And>i :: 'i :: countable. {x \\<in> \\<Omega>. P i x} \\<in> M) \\<Longrightarrow> {x \\<in> \\<Omega>. \\<exists>!i. P i x} \\<in> M\"", "lemma pred_countable_Ex1 [measurable]:\n  \"(\\<And>i :: _ :: countable. Measurable.pred M (\\<lambda>x. P i x))\n  \\<Longrightarrow> Measurable.pred M (\\<lambda>x. \\<exists>!i. P i x)\"", "lemma measurable_snd_count_space [measurable]: \n  \"A \\<subseteq> B \\<Longrightarrow> snd \\<in> measurable (M1 \\<Otimes>\\<^sub>M count_space A) (count_space B)\"", "lemma integrable_scale_measure [simp]:\n  \"\\<lbrakk> integrable M f; r < \\<top> \\<rbrakk> \\<Longrightarrow> integrable (scale_measure r M) f\" \n  for f :: \"'a \\<Rightarrow> 'b::{banach, second_countable_topology}\"", "lemma integral_scale_measure:\n  assumes \"integrable M f\" \"r < \\<top>\"\n  shows \"integral\\<^sup>L (scale_measure r M) f = enn2real r * integral\\<^sup>L M f\"", "lemma (in sequence_space) nn_integral_split:\n  assumes f[measurable]: \"f \\<in> borel_measurable S\"\n  shows \"(\\<integral>\\<^sup>+\\<omega>. f \\<omega> \\<partial>S) = (\\<integral>\\<^sup>+\\<omega>. (\\<integral>\\<^sup>+\\<omega>'. f (comb_seq i \\<omega> \\<omega>') \\<partial>S) \\<partial>S)\"", "lemma (in sequence_space) prob_Collect_split:\n  assumes f[measurable]: \"{x\\<in>space S. P x} \\<in> sets S\"\n  shows \"\\<P>(x in S. P x) = (\\<integral>\\<^sup>+x. \\<P>(x' in S. P (comb_seq i x x')) \\<partial>S)\"", "lemma measure_map_pmf_conv_distr:\n  \"measure_pmf (map_pmf f p) = distr (measure_pmf p) (count_space UNIV) f\"", "lemma pred_rel_pmf:\n  \"\\<lbrakk> pred_pmf P p; rel_pmf R p q \\<rbrakk> \\<Longrightarrow> pred_pmf (Imagep R P) q\"", "lemma pmf_rel_mono': \"\\<lbrakk> rel_pmf P x y; P \\<le> Q \\<rbrakk> \\<Longrightarrow> rel_pmf Q x y\"", "lemma rel_pmf_eqI [simp]: \"rel_pmf (=) x x\"", "lemma rel_pmf_bind_reflI:\n  \"(\\<And>x. x \\<in> set_pmf p \\<Longrightarrow> rel_pmf R (f x) (g x))\n  \\<Longrightarrow> rel_pmf R (bind_pmf p f) (bind_pmf p g)\"", "lemma pmf_pred_mono_strong:\n  \"\\<lbrakk> pred_pmf P p; \\<And>a. \\<lbrakk> a \\<in> set_pmf p; P a \\<rbrakk> \\<Longrightarrow> P' a \\<rbrakk> \\<Longrightarrow> pred_pmf P' p\"", "lemma rel_pmf_restrict_relpI [intro?]:\n  \"\\<lbrakk> rel_pmf R x y; pred_pmf P x; pred_pmf Q y \\<rbrakk> \\<Longrightarrow> rel_pmf (R \\<upharpoonleft> P \\<otimes> Q) x y\"", "lemma rel_pmf_restrict_relpE [elim?]:\n  assumes \"rel_pmf (R \\<upharpoonleft> P \\<otimes> Q) x y\"\n  obtains \"rel_pmf R x y\" \"pred_pmf P x\" \"pred_pmf Q y\"", "lemma rel_pmf_restrict_relp_iff:\n  \"rel_pmf (R \\<upharpoonleft> P \\<otimes> Q) x y \\<longleftrightarrow> rel_pmf R x y \\<and> pred_pmf P x \\<and> pred_pmf Q y\"", "lemma rel_pmf_OO_trans [trans]:\n  \"\\<lbrakk> rel_pmf R p q; rel_pmf S q r \\<rbrakk> \\<Longrightarrow> rel_pmf (R OO S) p r\"", "lemma pmf_pred_map [simp]: \"pred_pmf P (map_pmf f p) = pred_pmf (P \\<circ> f) p\"", "lemma pred_pmf_bind [simp]: \"pred_pmf P (bind_pmf p f) = pred_pmf (pred_pmf P \\<circ> f) p\"", "lemma pred_pmf_return [simp]: \"pred_pmf P (return_pmf x) = P x\"", "lemma pred_pmf_of_set [simp]: \"\\<lbrakk> finite A; A \\<noteq> {} \\<rbrakk> \\<Longrightarrow> pred_pmf P (pmf_of_set A) = Ball A P\"", "lemma pred_pmf_of_multiset [simp]: \"M \\<noteq> {#} \\<Longrightarrow> pred_pmf P (pmf_of_multiset M) = Ball (set_mset M) P\"", "lemma pred_pmf_cond [simp]:\n  \"set_pmf p \\<inter> A \\<noteq> {} \\<Longrightarrow> pred_pmf P (cond_pmf p A) = pred_pmf (\\<lambda>x. x \\<in> A \\<longrightarrow> P x) p\"", "lemma pred_pmf_pair [simp]:\n  \"pred_pmf P (pair_pmf p q) = pred_pmf (\\<lambda>x. pred_pmf (P \\<circ> Pair x) q) p\"", "lemma pred_pmf_join [simp]: \"pred_pmf P (join_pmf p) = pred_pmf (pred_pmf P) p\"", "lemma pred_pmf_bernoulli [simp]: \"\\<lbrakk> 0 < p; p < 1 \\<rbrakk> \\<Longrightarrow> pred_pmf P (bernoulli_pmf p) = All P\"", "lemma pred_pmf_geometric [simp]: \"\\<lbrakk> 0 < p; p < 1 \\<rbrakk> \\<Longrightarrow> pred_pmf P (geometric_pmf p) = All P\"", "lemma pred_pmf_poisson [simp]: \"0 < rate \\<Longrightarrow> pred_pmf P (poisson_pmf rate) = All P\"", "lemma pmf_rel_map_restrict_relp: \n  shows pmf_rel_map_restrict_relp1: \"rel_pmf (R \\<upharpoonleft> P \\<otimes> Q) (map_pmf f p) = rel_pmf (R \\<circ> f \\<upharpoonleft> P \\<circ> f \\<otimes> Q) p\"\n  and pmf_rel_map_restrict_relp2: \"rel_pmf (R \\<upharpoonleft> P \\<otimes> Q) p (map_pmf g q) = rel_pmf ((\\<lambda>x. R x \\<circ> g) \\<upharpoonleft> P \\<otimes> Q \\<circ> g) p q\"", "lemma pred_pmf_conj [simp]: \"pred_pmf (\\<lambda>x. P x \\<and> Q x) = (\\<lambda>x. pred_pmf P x \\<and> pred_pmf Q x)\"", "lemma pred_pmf_top [simp]:\n  \"pred_pmf (\\<lambda>_. True) = (\\<lambda>_. True)\"", "lemma rel_pmf_of_setI:\n  assumes A: \"A \\<noteq> {}\" \"finite A\"\n  and B: \"B \\<noteq> {}\" \"finite B\"\n  and card: \"\\<And>X. X \\<subseteq> A \\<Longrightarrow> card B * card X \\<le> card A * card {y\\<in>B. \\<exists>x\\<in>X. R x y}\"\n  shows \"rel_pmf R (pmf_of_set A) (pmf_of_set B)\"", "lemmas set_rel_witness_pmf = set_rel_witness_pmf'[of _ \"(x, y)\" for x y, simplified]", "lemmas map1_rel_witness_pmf = map1_rel_witness_pmf'[of _ \"(x, y)\" for x y, simplified]", "lemmas map2_rel_witness_pmf = map2_rel_witness_pmf'[of _ \"(x, y)\" for x y, simplified]", "lemmas rel_witness_pmf = set_rel_witness_pmf map1_rel_witness_pmf map2_rel_witness_pmf", "lemma rel_witness_pmf1:\n  assumes \"rel_pmf A p q\" \n  shows \"rel_pmf (\\<lambda>a (a', b). a = a' \\<and> A a' b) p (rel_witness_pmf A (p, q))\"", "lemma rel_witness_pmf2:\n  assumes \"rel_pmf A p q\" \n  shows \"rel_pmf (\\<lambda>(a, b') b. b = b' \\<and> A a b') (rel_witness_pmf A (p, q)) q\"", "lemma cond_pmf_of_set:\n  assumes fin: \"finite A\" and nonempty: \"A \\<inter> B \\<noteq> {}\"\n  shows \"cond_pmf (pmf_of_set A) B = pmf_of_set (A \\<inter> B)\" (is \"?lhs = ?rhs\")", "lemma pair_pmf_of_set:\n  assumes A: \"finite A\" \"A \\<noteq> {}\"\n    and B: \"finite B\" \"B \\<noteq> {}\"\n  shows \"pair_pmf (pmf_of_set A) (pmf_of_set B) = pmf_of_set (A \\<times> B)\"", "lemma emeasure_cond_pmf:\n  fixes p A\n  defines \"q \\<equiv> cond_pmf p A\"\n  assumes \"set_pmf p \\<inter> A \\<noteq> {}\"\n  shows \"emeasure (measure_pmf q) B = emeasure (measure_pmf p) (A \\<inter> B) / emeasure (measure_pmf p) A\"", "lemma measure_cond_pmf:\n  \"measure (measure_pmf (cond_pmf p A)) B = measure (measure_pmf p) (A \\<inter> B) / measure (measure_pmf p) A\"\n  if \"set_pmf p \\<inter> A \\<noteq> {}\"", "lemma emeasure_measure_pmf_zero_iff: \"emeasure (measure_pmf p) s = 0 \\<longleftrightarrow> set_pmf p \\<inter> s = {}\" (is \"?lhs = ?rhs\")", "lemma ord_spmf_return_spmf1: \"ord_spmf R (return_spmf x) p \\<longleftrightarrow> lossless_spmf p \\<and> (\\<forall>y\\<in>set_spmf p. R x y)\"", "lemma ord_spmf_conv:\n  \"ord_spmf R = rel_spmf R OO ord_spmf (=)\"", "lemma ord_spmf_expand:\n  \"NO_MATCH (=) R \\<Longrightarrow> ord_spmf R = rel_spmf R OO ord_spmf (=)\"", "lemma ord_spmf_eqD_measure: \"ord_spmf (=) p q \\<Longrightarrow> measure (measure_spmf p) A \\<le> measure (measure_spmf q) A\"", "lemma ord_spmf_measureD:\n  assumes \"ord_spmf R p q\"\n  shows \"measure (measure_spmf p) A \\<le> measure (measure_spmf q) {y. \\<exists>x\\<in>A. R x y}\"\n    (is \"?lhs \\<le> ?rhs\")", "lemma ord_spmf_bind_pmfI1:\n  \"(\\<And>x. x \\<in> set_pmf p \\<Longrightarrow> ord_spmf R (f x) q) \\<Longrightarrow> ord_spmf R (bind_pmf p f) q\"", "lemma ord_spmf_bind_spmfI1:\n  \"(\\<And>x. x \\<in> set_spmf p \\<Longrightarrow> ord_spmf R (f x) q) \\<Longrightarrow> ord_spmf R (bind_spmf p f) q\"", "lemma spmf_of_set_empty: \"spmf_of_set {} = return_pmf None\"", "lemma rel_spmf_of_setI:\n  assumes card: \"\\<And>X. X \\<subseteq> A \\<Longrightarrow> card B * card X \\<le> card A * card {y\\<in>B. \\<exists>x\\<in>X. R x y}\"\n  and eq: \"(finite A \\<and> A \\<noteq> {}) \\<longleftrightarrow> (finite B \\<and> B \\<noteq> {})\"\n  shows \"rel_spmf R (spmf_of_set A) (spmf_of_set B)\"", "lemmas map_bind_spmf = map_spmf_bind_spmf", "lemma nn_integral_measure_spmf_conv_measure_pmf:\n  assumes [measurable]: \"f \\<in> borel_measurable (count_space UNIV)\"\n  shows \"nn_integral (measure_spmf p) f = nn_integral (restrict_space (measure_pmf p) (range Some)) (f \\<circ> the)\"", "lemma nn_integral_spmf_neq_infinity: \"(\\<integral>\\<^sup>+ x. spmf p x \\<partial>count_space UNIV) \\<noteq> \\<infinity>\"", "lemma return_pmf_bind_option:\n  \"return_pmf (Option.bind x f) = bind_spmf (return_pmf x) (return_pmf \\<circ> f)\"", "lemma rel_spmf_pos_distr: \"rel_spmf A OO rel_spmf B \\<le> rel_spmf (A OO B)\"", "lemma rel_spmf_OO_trans [trans]:\n  \"\\<lbrakk> rel_spmf R p q; rel_spmf S q r \\<rbrakk> \\<Longrightarrow> rel_spmf (R OO S) p r\"", "lemma map_spmf_eq_map_spmf_iff: \"map_spmf f p = map_spmf g q \\<longleftrightarrow> rel_spmf (\\<lambda>x y. f x = g y) p q\"", "lemma map_spmf_eq_map_spmfI: \"rel_spmf (\\<lambda>x y. f x = g y) p q \\<Longrightarrow> map_spmf f p = map_spmf g q\"", "lemma spmf_rel_mono_strong:\n  \"\\<lbrakk>rel_spmf A f g; \\<And>x y. \\<lbrakk> x \\<in> set_spmf f; y \\<in> set_spmf g; A x y \\<rbrakk> \\<Longrightarrow> B x y \\<rbrakk> \\<Longrightarrow> rel_spmf B f g\"", "lemma set_spmf_eq_empty: \"set_spmf p = {} \\<longleftrightarrow> p = return_pmf None\"", "lemma measure_pair_spmf_times:\n  \"measure (measure_spmf (pair_spmf p q)) (A \\<times> B) = measure (measure_spmf p) A * measure (measure_spmf q) B\"", "lemma lossless_spmfD_set_spmf_nonempty: \"lossless_spmf p \\<Longrightarrow> set_spmf p \\<noteq> {}\"", "lemma set_spmf_return_pmf: \"set_spmf (return_pmf x) = set_option x\"", "lemma bind_spmf_pmf_assoc: \"bind_spmf (bind_pmf p f) g = bind_pmf p (\\<lambda>x. bind_spmf (f x) g)\"", "lemma bind_spmf_of_set:  \"\\<lbrakk> finite A; A \\<noteq> {} \\<rbrakk> \\<Longrightarrow> bind_spmf (spmf_of_set A) f = bind_pmf (pmf_of_set A) f\"", "lemma bind_spmf_map_pmf:\n  \"bind_spmf (map_pmf f p) g = bind_pmf p (\\<lambda>x. bind_spmf (return_pmf (f x)) g)\"", "lemma rel_spmf_eqI [simp]: \"rel_spmf (=) x x\"", "lemma set_spmf_map_pmf: \"set_spmf (map_pmf f p) = (\\<Union>x\\<in>set_pmf p. set_option (f x))\"", "lemma ord_spmf_return_spmf [simp]: \"ord_spmf (=) (return_spmf x) p \\<longleftrightarrow> p = return_spmf x\"", "lemma bind_spmf_pmf_commute:\n  \"bind_spmf p (\\<lambda>x. bind_pmf q (f x)) = bind_pmf q (\\<lambda>y. bind_spmf p (\\<lambda>x. f x y))\"", "lemma return_pmf_map_option_conv_bind:\n  \"return_pmf (map_option f x) = bind_spmf (return_pmf x) (return_spmf \\<circ> f)\"", "lemma lossless_return_pmf_iff [simp]: \"lossless_spmf (return_pmf x) \\<longleftrightarrow> x \\<noteq> None\"", "lemma lossless_map_pmf: \"lossless_spmf (map_pmf f p) \\<longleftrightarrow> (\\<forall>x \\<in> set_pmf p. f x \\<noteq> None)\"", "lemma bind_pmf_spmf_assoc:\n  \"g None = return_pmf None\n  \\<Longrightarrow> bind_pmf (bind_spmf p f) g = bind_spmf p (\\<lambda>x. bind_pmf (f x) g)\"", "lemma pred_spmf_def: \"pred_spmf P p \\<longleftrightarrow> (\\<forall>x\\<in>set_spmf p. P x)\"", "lemma spmf_pred_mono_strong:\n  \"\\<lbrakk> pred_spmf P p; \\<And>a. \\<lbrakk> a \\<in> set_spmf p; P a \\<rbrakk> \\<Longrightarrow> P' a \\<rbrakk> \\<Longrightarrow> pred_spmf P' p\"", "lemma spmf_Domainp_rel: \"Domainp (rel_spmf R) = pred_spmf (Domainp R)\"", "lemma rel_spmf_restrict_relpI [intro?]:\n  \"\\<lbrakk> rel_spmf R p q; pred_spmf P p; pred_spmf Q q \\<rbrakk> \\<Longrightarrow> rel_spmf (R \\<upharpoonleft> P \\<otimes> Q) p q\"", "lemma rel_spmf_restrict_relpE [elim?]:\n  assumes \"rel_spmf (R \\<upharpoonleft> P \\<otimes> Q) x y\"\n  obtains \"rel_spmf R x y\" \"pred_spmf P x\" \"pred_spmf Q y\"", "lemma rel_spmf_restrict_relp_iff:\n  \"rel_spmf (R \\<upharpoonleft> P \\<otimes> Q) x y \\<longleftrightarrow> rel_spmf R x y \\<and> pred_spmf P x \\<and> pred_spmf Q y\"", "lemma spmf_pred_map: \"pred_spmf P (map_spmf f p) = pred_spmf (P \\<circ> f) p\"", "lemma pred_spmf_bind [simp]: \"pred_spmf P (bind_spmf p f) = pred_spmf (pred_spmf P \\<circ> f) p\"", "lemma pred_spmf_return: \"pred_spmf P (return_spmf x) = P x\"", "lemma pred_spmf_return_pmf_None: \"pred_spmf P (return_pmf None)\"", "lemma pred_spmf_spmf_of_pmf [simp]: \"pred_spmf P (spmf_of_pmf p) = pred_pmf P p\"", "lemma pred_spmf_of_set [simp]: \"pred_spmf P (spmf_of_set A) = (finite A \\<longrightarrow> Ball A P)\"", "lemma pred_spmf_assert_spmf [simp]: \"pred_spmf P (assert_spmf b) = (b \\<longrightarrow> P ())\"", "lemma pred_spmf_pair [simp]:\n  \"pred_spmf P (pair_spmf p q) = pred_spmf (\\<lambda>x. pred_spmf (P \\<circ> Pair x) q) p\"", "lemma set_spmf_try [simp]:\n  \"set_spmf (try_spmf p q) = set_spmf p \\<union> (if lossless_spmf p then {} else set_spmf q)\"", "lemma try_spmf_bind_out1:\n  \"(\\<And>x. lossless_spmf (f x)) \\<Longrightarrow> bind_spmf (TRY p ELSE q) f = TRY (bind_spmf p f) ELSE (bind_spmf q f)\"", "lemma pred_spmf_try [simp]:\n  \"pred_spmf P (try_spmf p q) = (pred_spmf P p \\<and> (\\<not> lossless_spmf p \\<longrightarrow> pred_spmf P q))\"", "lemma pred_spmf_cond [simp]:\n  \"pred_spmf P (cond_spmf p A) = pred_spmf (\\<lambda>x. x \\<in> A \\<longrightarrow> P x) p\"", "lemma spmf_rel_map_restrict_relp: \n  shows spmf_rel_map_restrict_relp1: \"rel_spmf (R \\<upharpoonleft> P \\<otimes> Q) (map_spmf f p) = rel_spmf (R \\<circ> f \\<upharpoonleft> P \\<circ> f \\<otimes> Q) p\"\n  and spmf_rel_map_restrict_relp2: \"rel_spmf (R \\<upharpoonleft> P \\<otimes> Q) p (map_spmf g q) = rel_spmf ((\\<lambda>x. R x \\<circ> g) \\<upharpoonleft> P \\<otimes> Q \\<circ> g) p q\"", "lemma pred_spmf_conj: \"pred_spmf (\\<lambda>x. P x \\<and> Q x) = (\\<lambda>x. pred_spmf P x \\<and> pred_spmf Q x)\"", "lemma spmf_of_pmf_parametric [transfer_rule]: \n  includes lifting_syntax shows\n  \"(rel_pmf A ===> rel_spmf A) spmf_of_pmf spmf_of_pmf\"", "lemma mono2mono_return_pmf[THEN spmf.mono2mono, simp, cont_intro]: (* Move to SPMF *)\n  shows monotone_return_pmf: \"monotone option_ord (ord_spmf (=)) return_pmf\"", "lemma mcont2mcont_return_pmf[THEN spmf.mcont2mcont, simp, cont_intro]:  (* Move to SPMF *)\n  shows mcont_return_pmf: \"mcont (flat_lub None) option_ord lub_spmf (ord_spmf (=)) return_pmf\"", "lemma pred_spmf_top: (* Move up *)\n  \"pred_spmf (\\<lambda>_. True) = (\\<lambda>_. True)\"", "lemma rel_spmf_restrict_relpI' [intro?]:\n  \"\\<lbrakk> rel_spmf (\\<lambda>x y. P x \\<longrightarrow> Q y \\<longrightarrow> R x y) p q; pred_spmf P p; pred_spmf Q q \\<rbrakk> \\<Longrightarrow> rel_spmf (R \\<upharpoonleft> P \\<otimes> Q) p q\"", "lemma set_spmf_map_pmf_MATCH [simp]:\n  assumes \"NO_MATCH (map_option g) f\"\n  shows \"set_spmf (map_pmf f p) = (\\<Union>x\\<in>set_pmf p. set_option (f x))\"", "lemma rel_spmf_bindI':\n  \"\\<lbrakk> rel_spmf A p q; \\<And>x y. \\<lbrakk> A x y; x \\<in> set_spmf p; y \\<in> set_spmf q \\<rbrakk> \\<Longrightarrow> rel_spmf B (f x) (g y) \\<rbrakk>\n  \\<Longrightarrow> rel_spmf B (p \\<bind> f) (q \\<bind> g)\"", "lemma assumes \"rel_spmf A p q\"\n  shows rel_witness_spmf1: \"rel_spmf (\\<lambda>a (a', b). a = a' \\<and> A a' b) p (rel_witness_spmf A (p, q))\"\n    and rel_witness_spmf2: \"rel_spmf (\\<lambda>(a, b') b. b = b' \\<and> A a b') (rel_witness_spmf A (p, q)) q\"", "lemma weight_assert_spmf [simp]: \"weight_spmf (assert_spmf b) = indicator {True} b\"", "lemma enforce_spmf_parametric [transfer_rule]: includes lifting_syntax shows\n  \"((A ===> (=)) ===> rel_spmf A ===> rel_spmf A) enforce_spmf enforce_spmf\"", "lemma enforce_return_spmf [simp]:\n  \"enforce_spmf P (return_spmf x) = (if P x then return_spmf x else return_pmf None)\"", "lemma enforce_return_pmf_None [simp]:\n  \"enforce_spmf P (return_pmf None) = return_pmf None\"", "lemma enforce_map_spmf:\n  \"enforce_spmf P (map_spmf f p) = map_spmf f (enforce_spmf (P \\<circ> f) p)\"", "lemma enforce_bind_spmf [simp]:\n  \"enforce_spmf P (bind_spmf p f) = bind_spmf p (enforce_spmf P \\<circ> f)\"", "lemma set_enforce_spmf [simp]: \"set_spmf (enforce_spmf P p) = {a \\<in> set_spmf p. P a}\"", "lemma enforce_spmf_alt_def:\n  \"enforce_spmf P p = bind_spmf p (\\<lambda>a. bind_spmf (assert_spmf (P a)) (\\<lambda>_ :: unit. return_spmf a))\"", "lemma bind_enforce_spmf [simp]:\n  \"bind_spmf (enforce_spmf P p) f = bind_spmf p (\\<lambda>x. if P x then f x else return_pmf None)\"", "lemma weight_enforce_spmf:\n  \"weight_spmf (enforce_spmf P p) = weight_spmf p - measure (measure_spmf p) {x. \\<not> P x}\" (is \"?lhs = ?rhs\")", "lemma lossless_enforce_spmf [simp]:\n  \"lossless_spmf (enforce_spmf P p) \\<longleftrightarrow> lossless_spmf p \\<and> set_spmf p \\<subseteq> {x. P x}\"", "lemma enforce_spmf_top [simp]: \"enforce_spmf \\<top> = id\"", "lemma enforce_spmf_K_True [simp]: \"enforce_spmf (\\<lambda>_. True) p = p\"", "lemma enforce_spmf_bot [simp]: \"enforce_spmf \\<bottom> = (\\<lambda>_. return_pmf None)\"", "lemma enforce_spmf_K_False [simp]: \"enforce_spmf (\\<lambda>_. False) p = return_pmf None\"", "lemma enforce_pred_id_spmf: \"enforce_spmf P p = p\" if \"pred_spmf P p\"", "lemma map_the_spmf_of_pmf [simp]: \"map_pmf the (spmf_of_pmf p) = p\"", "lemma bind_bind_conv_pair_spmf:\n  \"bind_spmf p (\\<lambda>x. bind_spmf q (f x)) = bind_spmf (pair_spmf p q) (\\<lambda>(x, y). f x y)\"", "lemma cond_spmf_spmf_of_set:\n  \"cond_spmf (spmf_of_set A) B = spmf_of_set (A \\<inter> B)\" if \"finite A\"", "lemma pair_spmf_of_set:\n  \"pair_spmf (spmf_of_set A) (spmf_of_set B) = spmf_of_set (A \\<times> B)\"", "lemma emeasure_cond_spmf:\n  \"emeasure (measure_spmf (cond_spmf p A)) B = emeasure (measure_spmf p) (A \\<inter> B) / emeasure (measure_spmf p) A\"", "lemma measure_cond_spmf:\n  \"measure (measure_spmf (cond_spmf p A)) B = measure (measure_spmf p) (A \\<inter> B) / measure (measure_spmf p) A\"", "lemma lossless_cond_spmf [simp]: \"lossless_spmf (cond_spmf p A) \\<longleftrightarrow> set_spmf p \\<inter> A \\<noteq> {}\"", "lemma measure_spmf_eq_density: \"measure_spmf p = density (count_space UNIV) (spmf p)\"", "lemma integral_measure_spmf:\n  fixes f :: \"'a \\<Rightarrow> 'b::{banach, second_countable_topology}\"\n  assumes A: \"finite A\"\n  shows \"(\\<And>a. a \\<in> set_spmf M \\<Longrightarrow> f a \\<noteq> 0 \\<Longrightarrow> a \\<in> A) \\<Longrightarrow> (LINT x|measure_spmf M. f x) = (\\<Sum>a\\<in>A. spmf M a *\\<^sub>R f a)\"", "lemma image_set_spmf_eq:\n  \"f ` set_spmf p = g ` set_spmf q\" if \"ASSUMPTION (map_spmf f p = map_spmf g q)\"", "lemma map_spmf_const: \"map_spmf (\\<lambda>_. x) p = scale_spmf (weight_spmf p) (return_spmf x)\"", "lemma cond_return_pmf [simp]: \"cond_pmf (return_pmf x) A = return_pmf x\" if \"x \\<in> A\"", "lemma cond_return_spmf [simp]: \"cond_spmf (return_spmf x) A = (if x \\<in> A then return_spmf x else return_pmf None)\"", "lemma measure_range_Some_eq_weight:\n  \"measure (measure_pmf p) (range Some) = weight_spmf p\"", "lemma restrict_spmf_eq_return_pmf_None [simp]:\n  \"restrict_spmf p A = return_pmf None \\<longleftrightarrow> set_spmf p \\<inter> A = {}\"", "lemma mk_lossless_idem [simp]: \"mk_lossless (mk_lossless p) = mk_lossless p\"", "lemma mk_lossless_return [simp]: \"mk_lossless (return_pmf x) = return_pmf x\"", "lemma mk_lossless_map [simp]: \"mk_lossless (map_spmf f p) = map_spmf f (mk_lossless p)\"", "lemma spmf_mk_lossless [simp]: \"spmf (mk_lossless p) x = spmf p x / weight_spmf p\"", "lemma set_spmf_mk_lossless [simp]: \"set_spmf (mk_lossless p) = set_spmf p\"", "lemma mk_lossless_lossless [simp]: \"lossless_spmf p \\<Longrightarrow> mk_lossless p = p\"", "lemma mk_lossless_eq_return_pmf_None [simp]: \"mk_lossless p = return_pmf None \\<longleftrightarrow> p = return_pmf None\"", "lemma return_pmf_None_eq_mk_lossless [simp]: \"return_pmf None = mk_lossless p \\<longleftrightarrow> p = return_pmf None\"", "lemma mk_lossless_spmf_of_set [simp]: \"mk_lossless (spmf_of_set A) = spmf_of_set A\"", "lemma weight_mk_lossless: \"weight_spmf (mk_lossless p) = (if p = return_pmf None then 0 else 1)\"", "lemma mk_lossless_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_spmf A ===> rel_spmf A) mk_lossless mk_lossless\"", "lemma rel_spmf_mk_losslessI:\n  \"rel_spmf A p q \\<Longrightarrow> rel_spmf A (mk_lossless p) (mk_lossless q)\"", "lemma rel_spmf_restrict_spmfI:\n  \"rel_spmf (\\<lambda>x y. (x \\<in> A \\<and> y \\<in> B \\<and> R x y) \\<or> x \\<notin> A \\<and> y \\<notin> B) p q\n   \\<Longrightarrow> rel_spmf R (restrict_spmf p A) (restrict_spmf q B)\"", "lemma cond_spmf_alt: \"cond_spmf p A = mk_lossless (restrict_spmf p A)\"", "lemma cond_spmf_bind:\n  \"cond_spmf (bind_spmf p f) A = mk_lossless (p \\<bind> (\\<lambda>x. f x \\<upharpoonleft> A))\"", "lemma cond_spmf_UNIV [simp]: \"cond_spmf p UNIV = mk_lossless p\"", "lemma cond_pmf_singleton:\n  \"cond_pmf p A = return_pmf x\" if \"set_pmf p \\<inter> A = {x}\"", "lemma cond_spmf_fst_return_spmf [simp]:\n  \"cond_spmf_fst (return_spmf (x, y)) x = return_spmf y\"", "lemma cond_spmf_fst_map_Pair [simp]: \"cond_spmf_fst (map_spmf (Pair x) p) x = mk_lossless p\"", "lemma cond_spmf_fst_map_Pair' [simp]: \"cond_spmf_fst (map_spmf (\\<lambda>y. (x, f y)) p) x = map_spmf f (mk_lossless p)\"", "lemma cond_spmf_fst_eq_return_None [simp]: \"cond_spmf_fst p x = return_pmf None \\<longleftrightarrow> x \\<notin> fst ` set_spmf p\"", "lemma cond_spmf_fst_map_Pair1:\n  \"cond_spmf_fst (map_spmf (\\<lambda>x. (f x, g x)) p) (f x) = return_spmf (g (inv_into (set_spmf p) f (f x)))\"\n  if \"x \\<in> set_spmf p\" \"inj_on f (set_spmf p)\"", "lemma lossless_cond_spmf_fst [simp]: \"lossless_spmf (cond_spmf_fst p x) \\<longleftrightarrow> x \\<in> fst ` set_spmf p\"", "lemma cond_spmf_fst_inverse:\n  \"bind_spmf (map_spmf fst p) (\\<lambda>x. map_spmf (Pair x) (cond_spmf_fst p x)) = p\"\n  (is \"?lhs = ?rhs\")", "lemma bind_option_spmf_monad [simp]: \"monad.bind_option (return_pmf None) x = bind_spmf (return_pmf x)\"", "lemma the_pmf_return [simp]: \"the_pmf (return_pmf x) = x\"", "lemma type_definition_option_spmf: \"type_definition return_pmf the_pmf {x. \\<exists>y :: 'a option. x = return_pmf y}\"", "lemmas Quotient_spmf_option = Quotient_option\n  and cr_spmf_option_def = cr_option_def\n  and pcr_spmf_option_bi_unique = option.bi_unique\n  and Domainp_pcr_spmf_option = option.domain\n  and Domainp_pcr_spmf_option_eq = option.domain_eq\n  and Domainp_pcr_spmf_option_par = option.domain_par\n  and Domainp_pcr_spmf_option_left_total = option.domain_par_left_total\n  and pcr_spmf_option_left_unique = option.left_unique\n  and pcr_spmf_option_cr_eq = option.pcr_cr_eq\n  and pcr_spmf_option_return_pmf_transfer = option.rep_transfer\n  and pcr_spmf_option_right_total = option.right_total\n  and pcr_spmf_option_right_unique = option.right_unique\n  and pcr_spmf_option_def = pcr_option_def", "lemma return_option_spmf_transfer [transfer_parametric return_spmf_parametric, transfer_rule]:\n  \"((=) ===> cr_spmf_option) return_spmf Some\"", "lemma map_option_spmf_transfer [transfer_parametric map_spmf_parametric, transfer_rule]:\n  \"(((=) ===> (=)) ===> cr_spmf_option ===> cr_spmf_option) map_spmf map_option\"", "lemma fail_option_spmf_transfer [transfer_parametric return_spmf_None_parametric, transfer_rule]:\n  \"cr_spmf_option (return_pmf None) None\"", "lemma bind_option_spmf_transfer [transfer_parametric bind_spmf_parametric, transfer_rule]:\n  \"(cr_spmf_option ===> ((=) ===> cr_spmf_option) ===> cr_spmf_option) bind_spmf Option.bind\"", "lemma set_option_spmf_transfer [transfer_parametric set_spmf_parametric, transfer_rule]:\n  \"(cr_spmf_option ===> rel_set (=)) set_spmf set_option\"", "lemma rel_option_spmf_transfer [transfer_parametric rel_spmf_parametric, transfer_rule]:\n  \"(((=) ===> (=) ===> (=)) ===> cr_spmf_option ===> cr_spmf_option ===> (=)) rel_spmf rel_option\"", "lemma return_option_le_spmf_transfer [transfer_rule]:\n  \"((=) ===> cr_option_le_spmf) (\\<lambda>x. x) return_pmf\"", "lemma map_option_le_spmf_transfer [transfer_rule]:\n  \"(((=) ===> (=)) ===> cr_option_le_spmf ===> cr_option_le_spmf) map_option map_spmf\"", "lemma bind_option_le_spmf_transfer [transfer_rule]:\n  \"(cr_option_le_spmf ===> ((=) ===> cr_option_le_spmf) ===> cr_option_le_spmf) Option.bind bind_spmf\"", "lemma if_distrib_bind_spmf1 [if_distribs]:\n  \"bind_spmf (if b then x else y) f = (if b then bind_spmf x f else bind_spmf y f)\"", "lemma if_distrib_bind_spmf2 [if_distribs]:\n  \"bind_spmf x (\\<lambda>y. if b then f y else g y) = (if b then bind_spmf x f else bind_spmf x g)\"", "lemma rel_spmf_if_distrib [if_distribs]:\n  \"rel_spmf R (if b then x else y) (if b then x' else y') \\<longleftrightarrow>\n  (b \\<longrightarrow> rel_spmf R x x') \\<and> (\\<not> b \\<longrightarrow> rel_spmf R y y')\"", "lemma if_distrib_map_spmf [if_distribs]:\n  \"map_spmf f (if b then p else q) = (if b then map_spmf f p else map_spmf f q)\"", "lemma if_distrib_restrict_spmf1 [if_distribs]:\n  \"restrict_spmf (if b then p else q) A = (if b then restrict_spmf p A else restrict_spmf q A)\""], "translations": [["", "lemma asm_rl_conv: \"(PROP P \\<Longrightarrow> PROP P) \\<equiv> Trueprop True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (PROP P \\<Longrightarrow> PROP P) \\<equiv> True", "by(rule equal_intr_rule) iprover+"], ["", "named_theorems if_distribs \"Distributivity theorems for If\""], ["", "lemma if_mono_cong: \"\\<lbrakk>b \\<Longrightarrow> x \\<le> x'; \\<not> b \\<Longrightarrow> y \\<le> y' \\<rbrakk> \\<Longrightarrow> If b x y \\<le> If b x' y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<Longrightarrow> x \\<le> x';\n     \\<not> b \\<Longrightarrow> y \\<le> y'\\<rbrakk>\n    \\<Longrightarrow> (if b then x else y) \\<le> (if b then x' else y')", "by simp"], ["", "lemma if_cong_then: \"\\<lbrakk> b = b'; b' \\<Longrightarrow> t = t'; e = e' \\<rbrakk> \\<Longrightarrow> If b t e = If b' t' e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b = b'; b' \\<Longrightarrow> t = t'; e = e'\\<rbrakk>\n    \\<Longrightarrow> (if b then t else e) = (if b' then t' else e')", "by simp"], ["", "lemma if_False_eq: \"\\<lbrakk> b \\<Longrightarrow> False; e = e' \\<rbrakk> \\<Longrightarrow> If b t e = e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<Longrightarrow> False; e = e'\\<rbrakk>\n    \\<Longrightarrow> (if b then t else e) = e'", "by auto"], ["", "lemma imp_OO_imp [simp]: \"(\\<longrightarrow>) OO (\\<longrightarrow>) = (\\<longrightarrow>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<longrightarrow>) OO (\\<longrightarrow>) = (\\<longrightarrow>)", "by auto"], ["", "lemma inj_on_fun_updD: \"\\<lbrakk> inj_on (f(x := y)) A; x \\<notin> A \\<rbrakk> \\<Longrightarrow> inj_on f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on (f(x := y)) A; x \\<notin> A\\<rbrakk>\n    \\<Longrightarrow> inj_on f A", "by(auto simp add: inj_on_def split: if_split_asm)"], ["", "lemma disjoint_notin1: \"\\<lbrakk> A \\<inter> B = {}; x \\<in> B \\<rbrakk> \\<Longrightarrow> x \\<notin> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<inter> B = {}; x \\<in> B\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> A", "by auto"], ["", "lemma Least_le_Least:\n  fixes x :: \"'a :: wellorder\"\n  assumes \"Q x\"\n  and Q: \"\\<And>x. Q x \\<Longrightarrow> \\<exists>y\\<le>x. P y\"\n  shows \"Least P \\<le> Least Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Least P \\<le> Least Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Least P \\<le> Least Q", "obtain f :: \"'a \\<Rightarrow> 'a\" where \"\\<forall>a. \\<not> Q a \\<or> f a \\<le> a \\<and> P (f a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<forall>a.\n           \\<not> Q a \\<or> f a \\<le> a \\<and> P (f a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Q"], ["proof (prove)\nusing this:\n  Q ?x \\<Longrightarrow> \\<exists>y\\<le>?x. P y\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<forall>a.\n           \\<not> Q a \\<or> f a \\<le> a \\<and> P (f a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  \\<forall>a. \\<not> Q a \\<or> f a \\<le> a \\<and> P (f a)\n\ngoal (1 subgoal):\n 1. Least P \\<le> Least Q", "moreover"], ["proof (state)\nthis:\n  \\<forall>a. \\<not> Q a \\<or> f a \\<le> a \\<and> P (f a)\n\ngoal (1 subgoal):\n 1. Least P \\<le> Least Q", "have \"Q (Least Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (Least Q)", "using \\<open>Q x\\<close>"], ["proof (prove)\nusing this:\n  Q x\n\ngoal (1 subgoal):\n 1. Q (Least Q)", "by(rule LeastI)"], ["proof (state)\nthis:\n  Q (Least Q)\n\ngoal (1 subgoal):\n 1. Least P \\<le> Least Q", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>a. \\<not> Q a \\<or> f a \\<le> a \\<and> P (f a)\n  Q (Least Q)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>a. \\<not> Q a \\<or> f a \\<le> a \\<and> P (f a)\n  Q (Least Q)\n\ngoal (1 subgoal):\n 1. Least P \\<le> Least Q", "by (metis (full_types) le_cases le_less less_le_trans not_less_Least)"], ["proof (state)\nthis:\n  Least P \\<le> Least Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_empty_image [simp]: \"Set.is_empty (f ` A) = Set.is_empty A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.is_empty (f ` A) = Set.is_empty A", "by(auto simp add: Set.is_empty_def)"], ["", "subsection \\<open>Relations\\<close>"], ["", "inductive Imagep :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> 'b \\<Rightarrow> bool\"\n  for R P\nwhere ImagepI: \"\\<lbrakk> P x; R x y \\<rbrakk> \\<Longrightarrow> Imagep R P y\""], ["", "lemma r_r_into_tranclp: \"\\<lbrakk> r x y; r y z \\<rbrakk> \\<Longrightarrow> r^++ x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r x y; r y z\\<rbrakk> \\<Longrightarrow> r\\<^sup>+\\<^sup>+ x z", "by(rule tranclp.trancl_into_trancl)(rule tranclp.r_into_trancl)"], ["", "lemma transp_tranclp_id:\n  assumes \"transp R\"\n  shows \"tranclp R = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R\\<^sup>+\\<^sup>+ = R", "proof(intro ext iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa. R\\<^sup>+\\<^sup>+ x xa \\<Longrightarrow> R x xa\n 2. \\<And>x xa. R x xa \\<Longrightarrow> R\\<^sup>+\\<^sup>+ x xa", "fix x y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa. R\\<^sup>+\\<^sup>+ x xa \\<Longrightarrow> R x xa\n 2. \\<And>x xa. R x xa \\<Longrightarrow> R\\<^sup>+\\<^sup>+ x xa", "assume \"R^++ x y\""], ["proof (state)\nthis:\n  R\\<^sup>+\\<^sup>+ x y\n\ngoal (2 subgoals):\n 1. \\<And>x xa. R\\<^sup>+\\<^sup>+ x xa \\<Longrightarrow> R x xa\n 2. \\<And>x xa. R x xa \\<Longrightarrow> R\\<^sup>+\\<^sup>+ x xa", "thus \"R x y\""], ["proof (prove)\nusing this:\n  R\\<^sup>+\\<^sup>+ x y\n\ngoal (1 subgoal):\n 1. R x y", "by induction(blast dest: transpD[OF assms])+"], ["proof (state)\nthis:\n  R x y\n\ngoal (1 subgoal):\n 1. \\<And>x xa. R x xa \\<Longrightarrow> R\\<^sup>+\\<^sup>+ x xa", "qed simp"], ["", "lemma transp_inv_image: \"transp r \\<Longrightarrow> transp (\\<lambda>x y. r (f x) (f y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transp r \\<Longrightarrow> transp (\\<lambda>x y. r (f x) (f y))", "using trans_inv_image[where r=\"{(x, y). r x y}\" and f = f]"], ["proof (prove)\nusing this:\n  trans {(x, y). r x y} \\<Longrightarrow>\n  trans (inv_image {(x, y). r x y} f)\n\ngoal (1 subgoal):\n 1. transp r \\<Longrightarrow> transp (\\<lambda>x y. r (f x) (f y))", "by(simp add: transp_trans inv_image_def)"], ["", "lemma Domainp_conversep: \"Domainp R\\<inverse>\\<inverse> = Rangep R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp R\\<inverse>\\<inverse> = Rangep R", "by(auto)"], ["", "lemma bi_unique_rel_set_bij_betw:\n  assumes unique: \"bi_unique R\"\n  and rel: \"rel_set R A B\"\n  shows \"\\<exists>f. bij_betw f A B \\<and> (\\<forall>x\\<in>A. R x (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f A B \\<and> (\\<forall>x\\<in>A. R x (f x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f A B \\<and> (\\<forall>x\\<in>A. R x (f x))", "from assms"], ["proof (chain)\npicking this:\n  bi_unique R\n  rel_set R A B", "obtain f where f: \"\\<And>x. x \\<in> A \\<Longrightarrow> R x (f x)\" and B: \"\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<in> B\""], ["proof (prove)\nusing this:\n  bi_unique R\n  rel_set R A B\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> R x (f x);\n         \\<And>x. x \\<in> A \\<Longrightarrow> f x \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(atomize_elim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bi_unique R; rel_set R A B\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f.\n                         (\\<forall>x.\n                             x \\<in> A \\<longrightarrow> R x (f x)) \\<and>\n                         (\\<forall>x.\n                             x \\<in> A \\<longrightarrow> f x \\<in> B)", "apply(fold all_conj_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bi_unique R; rel_set R A B\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f.\n                         \\<forall>x.\n                            (x \\<in> A \\<longrightarrow> R x (f x)) \\<and>\n                            (x \\<in> A \\<longrightarrow> f x \\<in> B)", "apply(subst choice_iff[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bi_unique R; rel_set R A B\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         \\<exists>y.\n                            (x \\<in> A \\<longrightarrow> R x y) \\<and>\n                            (x \\<in> A \\<longrightarrow> y \\<in> B)", "apply(auto dest: rel_setD1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?x \\<in> A \\<Longrightarrow> R ?x (f ?x)\n  ?x \\<in> A \\<Longrightarrow> f ?x \\<in> B\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f A B \\<and> (\\<forall>x\\<in>A. R x (f x))", "have \"inj_on f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f A", "by(rule inj_onI)(auto dest!: f dest: bi_uniqueDl[OF unique])"], ["proof (state)\nthis:\n  inj_on f A\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f A B \\<and> (\\<forall>x\\<in>A. R x (f x))", "moreover"], ["proof (state)\nthis:\n  inj_on f A\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f A B \\<and> (\\<forall>x\\<in>A. R x (f x))", "have \"f ` A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` A = B", "using rel"], ["proof (prove)\nusing this:\n  rel_set R A B\n\ngoal (1 subgoal):\n 1. f ` A = B", "by(auto 4 3 intro: B dest: rel_setD2 f bi_uniqueDr[OF unique])"], ["proof (state)\nthis:\n  f ` A = B\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f A B \\<and> (\\<forall>x\\<in>A. R x (f x))", "ultimately"], ["proof (chain)\npicking this:\n  inj_on f A\n  f ` A = B", "have \"bij_betw f A B\""], ["proof (prove)\nusing this:\n  inj_on f A\n  f ` A = B\n\ngoal (1 subgoal):\n 1. bij_betw f A B", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  inj_on f A\n  f ` A = B\n\ngoal (1 subgoal):\n 1. inj_on f A \\<and> f ` A = B", ".."], ["proof (state)\nthis:\n  bij_betw f A B\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f A B \\<and> (\\<forall>x\\<in>A. R x (f x))", "thus ?thesis"], ["proof (prove)\nusing this:\n  bij_betw f A B\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f A B \\<and> (\\<forall>x\\<in>A. R x (f x))", "using f"], ["proof (prove)\nusing this:\n  bij_betw f A B\n  ?x \\<in> A \\<Longrightarrow> R ?x (f ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f A B \\<and> (\\<forall>x\\<in>A. R x (f x))", "by blast"], ["proof (state)\nthis:\n  \\<exists>f. bij_betw f A B \\<and> (\\<forall>x\\<in>A. R x (f x))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition restrict_relp :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> ('b \\<Rightarrow> bool) \\<Rightarrow> 'a \\<Rightarrow> 'b \\<Rightarrow> bool\"\n  (\"_ \\<upharpoonleft> (_ \\<otimes> _)\" [53, 54, 54] 53)\nwhere \"restrict_relp R P Q = (\\<lambda>x y. R x y \\<and> P x \\<and> Q y)\""], ["", "lemma restrict_relp_apply [simp]: \"(R \\<upharpoonleft> P \\<otimes> Q) x y \\<longleftrightarrow> R x y \\<and> P x \\<and> Q y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (R \\<upharpoonleft> P \\<otimes> Q) x y = (R x y \\<and> P x \\<and> Q y)", "by(simp add: restrict_relp_def)"], ["", "lemma restrict_relpI [intro?]: \"\\<lbrakk> R x y; P x; Q y \\<rbrakk> \\<Longrightarrow> (R \\<upharpoonleft> P \\<otimes> Q) x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R x y; P x; Q y\\<rbrakk>\n    \\<Longrightarrow> (R \\<upharpoonleft> P \\<otimes> Q) x y", "by(simp add: restrict_relp_def)"], ["", "lemma restrict_relpE [elim?, cases pred]:\n  assumes \"(R \\<upharpoonleft> P \\<otimes> Q) x y\"\n  obtains (restrict_relp) \"R x y\" \"P x\" \"Q y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>R x y; P x; Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  (R \\<upharpoonleft> P \\<otimes> Q) x y\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>R x y; P x; Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(simp add: restrict_relp_def)"], ["", "lemma conversep_restrict_relp [simp]: \"(R \\<upharpoonleft> P \\<otimes> Q)\\<inverse>\\<inverse> = R\\<inverse>\\<inverse> \\<upharpoonleft> Q \\<otimes> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (R \\<upharpoonleft> P \\<otimes> Q)\\<inverse>\\<inverse> =\n    R\\<inverse>\\<inverse> \\<upharpoonleft> Q \\<otimes> P", "by(auto simp add: fun_eq_iff)"], ["", "lemma restrict_relp_restrict_relp [simp]: \"R \\<upharpoonleft> P \\<otimes> Q \\<upharpoonleft> P' \\<otimes> Q' = R \\<upharpoonleft> inf P P' \\<otimes> inf Q Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<upharpoonleft> P \\<otimes> Q \\<upharpoonleft> P' \\<otimes> Q' =\n    R \\<upharpoonleft> P \\<sqinter> P' \\<otimes> Q \\<sqinter> Q'", "by(auto simp add: fun_eq_iff)"], ["", "lemma restrict_relp_cong:\n  \"\\<lbrakk> P = P'; Q = Q'; \\<And>x y. \\<lbrakk> P x; Q y \\<rbrakk> \\<Longrightarrow> R x y = R' x y \\<rbrakk> \\<Longrightarrow> R \\<upharpoonleft> P \\<otimes> Q = R' \\<upharpoonleft> P' \\<otimes> Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P = P'; Q = Q';\n     \\<And>x y.\n        \\<lbrakk>P x; Q y\\<rbrakk> \\<Longrightarrow> R x y = R' x y\\<rbrakk>\n    \\<Longrightarrow> R \\<upharpoonleft> P \\<otimes> Q =\n                      R' \\<upharpoonleft> P' \\<otimes> Q'", "by(auto simp add: fun_eq_iff)"], ["", "lemma restrict_relp_cong_simp:\n  \"\\<lbrakk> P = P'; Q = Q'; \\<And>x y. P x =simp=> Q y =simp=> R x y = R' x y \\<rbrakk> \\<Longrightarrow> R \\<upharpoonleft> P \\<otimes> Q = R' \\<upharpoonleft> P' \\<otimes> Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P = P'; Q = Q';\n     \\<And>x y. P x =simp=> Q y =simp=> R x y = R' x y\\<rbrakk>\n    \\<Longrightarrow> R \\<upharpoonleft> P \\<otimes> Q =\n                      R' \\<upharpoonleft> P' \\<otimes> Q'", "by(rule restrict_relp_cong; simp add: simp_implies_def)"], ["", "lemma restrict_relp_parametric [transfer_rule]:\n  includes lifting_syntax shows\n  \"((A ===> B ===> (=)) ===> (A ===> (=)) ===> (B ===> (=)) ===> A ===> B ===> (=)) restrict_relp restrict_relp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> B ===> (=)) ===>\n     (A ===> (=)) ===> (B ===> (=)) ===> A ===> B ===> (=))\n     restrict_relp restrict_relp", "unfolding restrict_relp_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> B ===> (=)) ===>\n     (A ===> (=)) ===> (B ===> (=)) ===> A ===> B ===> (=))\n     (\\<lambda>R P Q x y. R x y \\<and> P x \\<and> Q y)\n     (\\<lambda>R P Q x y. R x y \\<and> P x \\<and> Q y)", "by transfer_prover"], ["", "lemma restrict_relp_mono: \"\\<lbrakk> R \\<le> R'; P \\<le> P'; Q \\<le> Q' \\<rbrakk> \\<Longrightarrow> R \\<upharpoonleft> P \\<otimes> Q \\<le> R' \\<upharpoonleft> P' \\<otimes> Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R \\<le> R'; P \\<le> P'; Q \\<le> Q'\\<rbrakk>\n    \\<Longrightarrow> R \\<upharpoonleft> P \\<otimes> Q\n                      \\<le> R' \\<upharpoonleft> P' \\<otimes> Q'", "by(simp add: le_fun_def)"], ["", "lemma restrict_relp_mono': \n  \"\\<lbrakk> (R \\<upharpoonleft> P \\<otimes> Q) x y; \\<lbrakk> R x y; P x; Q y \\<rbrakk> \\<Longrightarrow> R' x y &&& P' x &&& Q' y \\<rbrakk>\n  \\<Longrightarrow> (R' \\<upharpoonleft> P' \\<otimes> Q') x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(R \\<upharpoonleft> P \\<otimes> Q) x y;\n     \\<lbrakk>R x y; P x; Q y\\<rbrakk>\n     \\<Longrightarrow> R' x y &&& P' x &&& Q' y\\<rbrakk>\n    \\<Longrightarrow> (R' \\<upharpoonleft> P' \\<otimes> Q') x y", "by(auto dest: conjunctionD1 conjunctionD2)"], ["", "lemma restrict_relp_DomainpD: \"Domainp (R \\<upharpoonleft> P \\<otimes> Q) x \\<Longrightarrow> Domainp R x \\<and> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp (R \\<upharpoonleft> P \\<otimes> Q) x \\<Longrightarrow>\n    Domainp R x \\<and> P x", "by(auto simp add: Domainp.simps)"], ["", "lemma restrict_relp_True: \"R \\<upharpoonleft> (\\<lambda>_. True) \\<otimes> (\\<lambda>_. True) = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<upharpoonleft> (\\<lambda>_. True) \\<otimes> (\\<lambda>_. True) = R", "by(simp add: fun_eq_iff)"], ["", "lemma restrict_relp_False1: \"R \\<upharpoonleft> (\\<lambda>_. False) \\<otimes> Q = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<upharpoonleft> (\\<lambda>_. False) \\<otimes> Q = \\<bottom>", "by(simp add: fun_eq_iff)"], ["", "lemma restrict_relp_False2: \"R \\<upharpoonleft> P \\<otimes> (\\<lambda>_. False) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<upharpoonleft> P \\<otimes> (\\<lambda>_. False) = \\<bottom>", "by(simp add: fun_eq_iff)"], ["", "definition rel_prod2 :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> 'a \\<Rightarrow> ('c \\<times> 'b) \\<Rightarrow> bool\"\nwhere \"rel_prod2 R a = (\\<lambda>(c, b). R a b)\""], ["", "lemma rel_prod2_simps [simp]: \"rel_prod2 R a (c, b) \\<longleftrightarrow> R a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod2 R a (c, b) = R a b", "by(simp add: rel_prod2_def)"], ["", "lemma restrict_rel_prod:\n  \"rel_prod (R \\<upharpoonleft> I1 \\<otimes> I2) (S \\<upharpoonleft> I1' \\<otimes> I2') = rel_prod R S \\<upharpoonleft> pred_prod I1 I1' \\<otimes> pred_prod I2 I2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod (R \\<upharpoonleft> I1 \\<otimes> I2)\n     (S \\<upharpoonleft> I1' \\<otimes> I2') =\n    rel_prod R\n     S \\<upharpoonleft> pred_prod I1 I1' \\<otimes> pred_prod I2 I2'", "by(auto simp add: fun_eq_iff)"], ["", "lemma restrict_rel_prod1:\n  \"rel_prod (R \\<upharpoonleft> I1 \\<otimes> I2) S = rel_prod R S \\<upharpoonleft> pred_prod I1 (\\<lambda>_. True) \\<otimes> pred_prod I2 (\\<lambda>_. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod (R \\<upharpoonleft> I1 \\<otimes> I2) S =\n    rel_prod R\n     S \\<upharpoonleft> pred_prod I1\n                         (\\<lambda>_.\n                             True) \\<otimes> pred_prod I2 (\\<lambda>_. True)", "by(simp add: restrict_rel_prod[symmetric] restrict_relp_True)"], ["", "lemma restrict_rel_prod2:\n  \"rel_prod R (S \\<upharpoonleft> I1 \\<otimes> I2) = rel_prod R S \\<upharpoonleft> pred_prod (\\<lambda>_. True) I1 \\<otimes> pred_prod (\\<lambda>_. True) I2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod R (S \\<upharpoonleft> I1 \\<otimes> I2) =\n    rel_prod R\n     S \\<upharpoonleft> pred_prod (\\<lambda>_. True)\n                         I1 \\<otimes> pred_prod (\\<lambda>_. True) I2", "by(simp add: restrict_rel_prod[symmetric] restrict_relp_True)"], ["", "consts relcompp_witness :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('b \\<Rightarrow> 'c \\<Rightarrow> bool) \\<Rightarrow> 'a \\<times> 'c \\<Rightarrow> 'b\""], ["", "specification (relcompp_witness)\n  relcompp_witness1: \"(A OO B) (fst xy) (snd xy) \\<Longrightarrow> A (fst xy) (relcompp_witness A B xy)\"\n  relcompp_witness2: \"(A OO B) (fst xy) (snd xy) \\<Longrightarrow> B (relcompp_witness A B xy) (snd xy)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>relcompp_witness.\n       (\\<forall>A B xy.\n           (A OO B) (fst xy) (snd xy) \\<longrightarrow>\n           A (fst xy) (relcompp_witness A B xy)) \\<and>\n       (\\<forall>A B xy.\n           (A OO B) (fst xy) (snd xy) \\<longrightarrow>\n           B (relcompp_witness A B xy) (snd xy))", "apply(fold all_conj_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>relcompp_witness.\n       \\<forall>x xa xb.\n          ((x OO xa) (fst xb) (snd xb) \\<longrightarrow>\n           x (fst xb) (relcompp_witness x xa xb)) \\<and>\n          ((x OO xa) (fst xb) (snd xb) \\<longrightarrow>\n           xa (relcompp_witness x xa xb) (snd xb))", "apply(rule choice allI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<exists>y.\n          ((x OO xa) (fst xb) (snd xb) \\<longrightarrow>\n           x (fst xb) y) \\<and>\n          ((x OO xa) (fst xb) (snd xb) \\<longrightarrow> xa y (snd xb))", "by(auto intro: choice allI)"], ["", "lemmas relcompp_witness[of _ _ \"(x, y)\" for x y, simplified] = relcompp_witness1 relcompp_witness2"], ["", "hide_fact (open) relcompp_witness1 relcompp_witness2"], ["", "lemma relcompp_witness_eq [simp]: \"relcompp_witness (=) (=) (x, x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. relcompp_witness (=) (=) (x, x) = x", "using relcompp_witness(1)[of \"(=)\" \"(=)\" x x]"], ["proof (prove)\nusing this:\n  ((=) OO (=)) x x \\<Longrightarrow> x = relcompp_witness (=) (=) (x, x)\n\ngoal (1 subgoal):\n 1. relcompp_witness (=) (=) (x, x) = x", "by(simp add: eq_OO)"], ["", "subsection \\<open>Pairs\\<close>"], ["", "lemma split_apfst [simp]: \"case_prod h (apfst f xy) = case_prod (h \\<circ> f) xy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case apfst f xy of (x, xa) \\<Rightarrow> h x xa) =\n    (case xy of (x, xa) \\<Rightarrow> (h \\<circ> f) x xa)", "by(cases xy) simp"], ["", "definition corec_prod :: \"('s \\<Rightarrow> 'a) \\<Rightarrow> ('s \\<Rightarrow> 'b) \\<Rightarrow> 's \\<Rightarrow> 'a \\<times> 'b\"\nwhere \"corec_prod f g = (\\<lambda>s. (f s, g s))\""], ["", "lemma corec_prod_apply: \"corec_prod f g s = (f s, g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. corec_prod f g s = (f s, g s)", "by(simp add: corec_prod_def)"], ["", "lemma corec_prod_sel [simp]:\n  shows fst_corec_prod: \"fst (corec_prod f g s) = f s\"\n  and snd_corec_prod: \"snd (corec_prod f g s) = g s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (corec_prod f g s) = f s &&& snd (corec_prod f g s) = g s", "by(simp_all add: corec_prod_apply)"], ["", "lemma apfst_corec_prod [simp]: \"apfst h (corec_prod f g s) = corec_prod (h \\<circ> f) g s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apfst h (corec_prod f g s) = corec_prod (h \\<circ> f) g s", "by(simp add: corec_prod_apply)"], ["", "lemma apsnd_corec_prod [simp]: \"apsnd h (corec_prod f g s) = corec_prod f (h \\<circ> g) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apsnd h (corec_prod f g s) = corec_prod f (h \\<circ> g) s", "by(simp add: corec_prod_apply)"], ["", "lemma map_corec_prod [simp]: \"map_prod f g (corec_prod h k s) = corec_prod (f \\<circ> h) (g \\<circ> k) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_prod f g (corec_prod h k s) =\n    corec_prod (f \\<circ> h) (g \\<circ> k) s", "by(simp add: corec_prod_apply)"], ["", "lemma split_corec_prod [simp]: \"case_prod h (corec_prod f g s) = h (f s) (g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case corec_prod f g s of (x, xa) \\<Rightarrow> h x xa) = h (f s) (g s)", "by(simp add: corec_prod_apply)"], ["", "lemma Pair_fst_Unity: \"(fst x, ()) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst x, ()) = x", "by(cases x) simp"], ["", "definition rprodl :: \"('a \\<times> 'b) \\<times> 'c \\<Rightarrow> 'a \\<times> ('b \\<times> 'c)\" where \"rprodl = (\\<lambda>((a, b), c). (a, (b, c)))\""], ["", "lemma rprodl_simps [simp]: \"rprodl ((a, b), c) = (a, (b, c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rprodl ((a, b), c) = (a, b, c)", "by(simp add: rprodl_def)"], ["", "lemma rprodl_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_prod (rel_prod A B) C ===> rel_prod A (rel_prod B C)) rprodl rprodl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_prod (rel_prod A B) C ===> rel_prod A (rel_prod B C)) rprodl rprodl", "unfolding rprodl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_prod (rel_prod A B) C ===> rel_prod A (rel_prod B C))\n     (\\<lambda>((a, b), c). (a, b, c)) (\\<lambda>((a, b), c). (a, b, c))", "by transfer_prover"], ["", "definition lprodr :: \"'a \\<times> ('b \\<times> 'c) \\<Rightarrow> ('a \\<times> 'b) \\<times> 'c\" where \"lprodr = (\\<lambda>(a, b, c). ((a, b), c))\""], ["", "lemma lprodr_simps [simp]: \"lprodr (a, b, c) = ((a, b), c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprodr (a, b, c) = ((a, b), c)", "by(simp add: lprodr_def)"], ["", "lemma lprodr_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_prod A (rel_prod B C) ===> rel_prod (rel_prod A B) C) lprodr lprodr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_prod A (rel_prod B C) ===> rel_prod (rel_prod A B) C) lprodr lprodr", "unfolding lprodr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_prod A (rel_prod B C) ===> rel_prod (rel_prod A B) C)\n     (\\<lambda>(a, b, y). ((a, b), y)) (\\<lambda>(a, b, y). ((a, b), y))", "by transfer_prover"], ["", "lemma lprodr_inverse [simp]: \"rprodl (lprodr x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rprodl (lprodr x) = x", "by(cases x) auto"], ["", "lemma rprodl_inverse [simp]: \"lprodr (rprodl x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprodr (rprodl x) = x", "by(cases x) auto"], ["", "lemma pred_prod_mono' [mono]:\n  \"pred_prod A B xy \\<longrightarrow> pred_prod A' B' xy\"\n  if \"\\<And>x. A x \\<longrightarrow> A' x\" \"\\<And>y. B y \\<longrightarrow> B' y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_prod A B xy \\<longrightarrow> pred_prod A' B' xy", "using that"], ["proof (prove)\nusing this:\n  A ?x \\<longrightarrow> A' ?x\n  B ?y \\<longrightarrow> B' ?y\n\ngoal (1 subgoal):\n 1. pred_prod A B xy \\<longrightarrow> pred_prod A' B' xy", "by(cases xy) auto"], ["", "fun rel_witness_prod :: \"('a \\<times> 'b) \\<times> ('c \\<times> 'd) \\<Rightarrow> (('a \\<times> 'c) \\<times> ('b \\<times> 'd))\" where\n  \"rel_witness_prod ((a, b), (c, d)) = ((a, c), (b, d))\""], ["", "subsection \\<open>Sums\\<close>"], ["", "lemma islE:\n  assumes \"isl x\"\n  obtains l where \"x = Inl l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l. x = Inl l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  isl x\n\ngoal (1 subgoal):\n 1. (\\<And>l. x = Inl l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by(cases x) auto"], ["", "lemma Inl_in_Plus [simp]: \"Inl x \\<in> A <+> B \\<longleftrightarrow> x \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Inl x \\<in> A <+> B) = (x \\<in> A)", "by auto"], ["", "lemma Inr_in_Plus [simp]: \"Inr x \\<in> A <+> B \\<longleftrightarrow> x \\<in> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Inr x \\<in> A <+> B) = (x \\<in> B)", "by auto"], ["", "lemma Inl_eq_map_sum_iff: \"Inl x = map_sum f g y \\<longleftrightarrow> (\\<exists>z. y = Inl z \\<and> x = f z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Inl x = map_sum f g y) = (\\<exists>z. y = Inl z \\<and> x = f z)", "by(cases y) auto"], ["", "lemma Inr_eq_map_sum_iff: \"Inr x = map_sum f g y \\<longleftrightarrow> (\\<exists>z. y = Inr z \\<and> x = g z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Inr x = map_sum f g y) = (\\<exists>z. y = Inr z \\<and> x = g z)", "by(cases y) auto"], ["", "lemma inj_on_map_sum [simp]:\n  \"\\<lbrakk> inj_on f A; inj_on g B \\<rbrakk> \\<Longrightarrow> inj_on (map_sum f g) (A <+> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f A; inj_on g B\\<rbrakk>\n    \\<Longrightarrow> inj_on (map_sum f g) (A <+> B)", "proof(rule inj_onI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>inj_on f A; inj_on g B; x \\<in> A <+> B; y \\<in> A <+> B;\n        map_sum f g x = map_sum f g y\\<rbrakk>\n       \\<Longrightarrow> x = y", "case (1 x y)"], ["proof (state)\nthis:\n  inj_on f A\n  inj_on g B\n  x \\<in> A <+> B\n  y \\<in> A <+> B\n  map_sum f g x = map_sum f g y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>inj_on f A; inj_on g B; x \\<in> A <+> B; y \\<in> A <+> B;\n        map_sum f g x = map_sum f g y\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  inj_on f A\n  inj_on g B\n  x \\<in> A <+> B\n  y \\<in> A <+> B\n  map_sum f g x = map_sum f g y", "show ?case"], ["proof (prove)\nusing this:\n  inj_on f A\n  inj_on g B\n  x \\<in> A <+> B\n  y \\<in> A <+> B\n  map_sum f g x = map_sum f g y\n\ngoal (1 subgoal):\n 1. x = y", "by(cases x; cases y; auto simp add: inj_on_def)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inv_into_map_sum:\n  \"inv_into (A <+> B) (map_sum f g) x = map_sum (inv_into A f) (inv_into B g) x\"\n  if \"x \\<in> f ` A <+> g ` B\" \"inj_on f A\" \"inj_on g B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_into (A <+> B) (map_sum f g) x =\n    map_sum (inv_into A f) (inv_into B g) x", "using that"], ["proof (prove)\nusing this:\n  x \\<in> f ` A <+> g ` B\n  inj_on f A\n  inj_on g B\n\ngoal (1 subgoal):\n 1. inv_into (A <+> B) (map_sum f g) x =\n    map_sum (inv_into A f) (inv_into B g) x", "by(cases rule: PlusE[consumes 1])(auto simp add: inv_into_f_eq f_inv_into_f)"], ["", "fun rsuml :: \"('a + 'b) + 'c \\<Rightarrow> 'a + ('b + 'c)\" where\n  \"rsuml (Inl (Inl a)) = Inl a\"\n| \"rsuml (Inl (Inr b)) = Inr (Inl b)\"\n| \"rsuml (Inr c) = Inr (Inr c)\""], ["", "fun lsumr :: \"'a + ('b + 'c) \\<Rightarrow> ('a + 'b) + 'c\" where\n  \"lsumr (Inl a) = Inl (Inl a)\"\n| \"lsumr (Inr (Inl b)) = Inl (Inr b)\"\n| \"lsumr (Inr (Inr c)) = Inr c\""], ["", "lemma rsuml_lsumr [simp]: \"rsuml (lsumr x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rsuml (lsumr x) = x", "by(cases x rule: lsumr.cases) simp_all"], ["", "lemma lsumr_rsuml [simp]: \"lsumr (rsuml x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsumr (rsuml x) = x", "by(cases x rule: rsuml.cases) simp_all"], ["", "subsection \\<open>Option\\<close>"], ["", "declare is_none_bind [simp]"], ["", "lemma case_option_collapse: \"case_option x (\\<lambda>_. x) y = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case y of None \\<Rightarrow> x | _ \\<Rightarrow> x) = x", "by(simp split: option.split)"], ["", "lemma indicator_single_Some: \"indicator {Some x} (Some y) = indicator {x} y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indicator {Some x} (Some y) = indicator {x} y", "by(simp split: split_indicator)"], ["", "subsubsection \\<open>Predicator and relator\\<close>"], ["", "lemma option_pred_mono_strong:\n  \"\\<lbrakk> pred_option P x; \\<And>a. \\<lbrakk> a \\<in> set_option x; P a \\<rbrakk> \\<Longrightarrow> P' a \\<rbrakk> \\<Longrightarrow> pred_option P' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pred_option P x;\n     \\<And>a.\n        \\<lbrakk>a \\<in> set_option x; P a\\<rbrakk>\n        \\<Longrightarrow> P' a\\<rbrakk>\n    \\<Longrightarrow> pred_option P' x", "by(fact option.pred_mono_strong)"], ["", "lemma option_pred_map [simp]: \"pred_option P (map_option f x) = pred_option (P \\<circ> f) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_option P (map_option f x) = pred_option (P \\<circ> f) x", "by(fact option.pred_map)"], ["", "lemma option_pred_o_map [simp]: \"pred_option P \\<circ> map_option f = pred_option (P \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_option P \\<circ> map_option f = pred_option (P \\<circ> f)", "by(simp add: fun_eq_iff)"], ["", "lemma option_pred_bind [simp]: \"pred_option P (Option.bind x f) = pred_option (pred_option P \\<circ> f) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_option P (x \\<bind> f) = pred_option (pred_option P \\<circ> f) x", "by(simp add: pred_option_def)"], ["", "lemma pred_option_conj [simp]:\n  \"pred_option (\\<lambda>x. P x \\<and> Q x) = (\\<lambda>x. pred_option P x \\<and> pred_option Q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_option (\\<lambda>x. P x \\<and> Q x) =\n    (\\<lambda>x. pred_option P x \\<and> pred_option Q x)", "by(auto simp add: pred_option_def)"], ["", "lemma pred_option_top [simp]:\n  \"pred_option (\\<lambda>_. True) = (\\<lambda>_. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_option (\\<lambda>_. True) = (\\<lambda>_. True)", "by(fact option.pred_True)"], ["", "lemma rel_option_restrict_relpI [intro?]:\n  \"\\<lbrakk> rel_option R x y; pred_option P x; pred_option Q y \\<rbrakk> \\<Longrightarrow> rel_option (R \\<upharpoonleft> P \\<otimes> Q) x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel_option R x y; pred_option P x; pred_option Q y\\<rbrakk>\n    \\<Longrightarrow> rel_option (R \\<upharpoonleft> P \\<otimes> Q) x y", "by(erule option.rel_mono_strong) simp"], ["", "lemma rel_option_restrict_relpE [elim?]:\n  assumes \"rel_option (R \\<upharpoonleft> P \\<otimes> Q) x y\"\n  obtains \"rel_option R x y\" \"pred_option P x\" \"pred_option Q y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>rel_option R x y; pred_option P x; pred_option Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lbrakk>rel_option R x y; pred_option P x; pred_option Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    rel_option R x y\n 2. (\\<lbrakk>rel_option R x y; pred_option P x; pred_option Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pred_option P x\n 3. (\\<lbrakk>rel_option R x y; pred_option P x; pred_option Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pred_option Q y", "show \"rel_option R x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option R x y", "using assms"], ["proof (prove)\nusing this:\n  rel_option (R \\<upharpoonleft> P \\<otimes> Q) x y\n\ngoal (1 subgoal):\n 1. rel_option R x y", "by(auto elim!: option.rel_mono_strong)"], ["proof (state)\nthis:\n  rel_option R x y\n\ngoal (2 subgoals):\n 1. (\\<lbrakk>rel_option R x y; pred_option P x; pred_option Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pred_option P x\n 2. (\\<lbrakk>rel_option R x y; pred_option P x; pred_option Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pred_option Q y", "have \"pred_option (Domainp (R \\<upharpoonleft> P \\<otimes> Q)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_option (Domainp (R \\<upharpoonleft> P \\<otimes> Q)) x", "using assms"], ["proof (prove)\nusing this:\n  rel_option (R \\<upharpoonleft> P \\<otimes> Q) x y\n\ngoal (1 subgoal):\n 1. pred_option (Domainp (R \\<upharpoonleft> P \\<otimes> Q)) x", "by(fold option.Domainp_rel) blast"], ["proof (state)\nthis:\n  pred_option (Domainp (R \\<upharpoonleft> P \\<otimes> Q)) x\n\ngoal (2 subgoals):\n 1. (\\<lbrakk>rel_option R x y; pred_option P x; pred_option Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pred_option P x\n 2. (\\<lbrakk>rel_option R x y; pred_option P x; pred_option Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pred_option Q y", "then"], ["proof (chain)\npicking this:\n  pred_option (Domainp (R \\<upharpoonleft> P \\<otimes> Q)) x", "show \"pred_option P x\""], ["proof (prove)\nusing this:\n  pred_option (Domainp (R \\<upharpoonleft> P \\<otimes> Q)) x\n\ngoal (1 subgoal):\n 1. pred_option P x", "by(rule option_pred_mono_strong)(blast dest!: restrict_relp_DomainpD)"], ["proof (state)\nthis:\n  pred_option P x\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>rel_option R x y; pred_option P x; pred_option Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pred_option Q y", "have \"pred_option (Domainp (R \\<upharpoonleft> P \\<otimes> Q)\\<inverse>\\<inverse>) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_option\n     (Domainp (R \\<upharpoonleft> P \\<otimes> Q)\\<inverse>\\<inverse>) y", "using assms"], ["proof (prove)\nusing this:\n  rel_option (R \\<upharpoonleft> P \\<otimes> Q) x y\n\ngoal (1 subgoal):\n 1. pred_option\n     (Domainp (R \\<upharpoonleft> P \\<otimes> Q)\\<inverse>\\<inverse>) y", "by(fold option.Domainp_rel)(auto simp only: option.rel_conversep Domainp_conversep)"], ["proof (state)\nthis:\n  pred_option\n   (Domainp (R \\<upharpoonleft> P \\<otimes> Q)\\<inverse>\\<inverse>) y\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>rel_option R x y; pred_option P x; pred_option Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pred_option Q y", "then"], ["proof (chain)\npicking this:\n  pred_option\n   (Domainp (R \\<upharpoonleft> P \\<otimes> Q)\\<inverse>\\<inverse>) y", "show \"pred_option Q y\""], ["proof (prove)\nusing this:\n  pred_option\n   (Domainp (R \\<upharpoonleft> P \\<otimes> Q)\\<inverse>\\<inverse>) y\n\ngoal (1 subgoal):\n 1. pred_option Q y", "by(rule option_pred_mono_strong)(auto dest!: restrict_relp_DomainpD)"], ["proof (state)\nthis:\n  pred_option Q y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_option_restrict_relp_iff:\n  \"rel_option (R \\<upharpoonleft> P \\<otimes> Q) x y \\<longleftrightarrow> rel_option R x y \\<and> pred_option P x \\<and> pred_option Q y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (R \\<upharpoonleft> P \\<otimes> Q) x y =\n    (rel_option R x y \\<and> pred_option P x \\<and> pred_option Q y)", "by(blast intro: rel_option_restrict_relpI elim: rel_option_restrict_relpE)"], ["", "lemma option_rel_map_restrict_relp:\n  shows option_rel_map_restrict_relp1:\n  \"rel_option (R \\<upharpoonleft> P \\<otimes> Q) (map_option f x) = rel_option (R \\<circ> f \\<upharpoonleft> P \\<circ> f \\<otimes> Q) x\"\n  and option_rel_map_restrict_relp2:\n  \"rel_option (R \\<upharpoonleft> P \\<otimes> Q) x (map_option g y) = rel_option ((\\<lambda>x. R x \\<circ> g) \\<upharpoonleft> P \\<otimes> Q \\<circ> g) x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (R \\<upharpoonleft> P \\<otimes> Q) (map_option f x) =\n    rel_option (R \\<circ> f \\<upharpoonleft> P \\<circ> f \\<otimes> Q) x &&&\n    rel_option (R \\<upharpoonleft> P \\<otimes> Q) x (map_option g y) =\n    rel_option\n     ((\\<lambda>x. R x \\<circ> g) \\<upharpoonleft> P \\<otimes> Q \\<circ> g)\n     x y", "by(simp_all add: option.rel_map restrict_relp_def fun_eq_iff)"], ["", "fun rel_witness_option :: \"'a option \\<times> 'b option \\<Rightarrow> ('a \\<times> 'b) option\" where\n  \"rel_witness_option (Some x, Some y) = Some (x, y)\"\n| \"rel_witness_option (None, None) = None\"\n| \"rel_witness_option _ = None\" \\<comment> \\<open>Just to make the definition complete\\<close>"], ["", "lemma rel_witness_option:\n  shows set_rel_witness_option: \"\\<lbrakk> rel_option A x y; (a, b) \\<in> set_option (rel_witness_option (x, y)) \\<rbrakk> \\<Longrightarrow> A a b\"\n    and map1_rel_witness_option: \"rel_option A x y \\<Longrightarrow> map_option fst (rel_witness_option (x, y)) = x\"\n    and map2_rel_witness_option: \"rel_option A x y \\<Longrightarrow> map_option snd (rel_witness_option (x, y)) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>rel_option A x y;\n      (a, b) \\<in> set_option (rel_witness_option (x, y))\\<rbrakk>\n     \\<Longrightarrow> A a b) &&&\n    (rel_option A x y \\<Longrightarrow>\n     map_option fst (rel_witness_option (x, y)) = x) &&&\n    (rel_option A x y \\<Longrightarrow>\n     map_option snd (rel_witness_option (x, y)) = y)", "by(cases \"(x, y)\" rule: rel_witness_option.cases; simp; fail)+"], ["", "lemma rel_witness_option1:\n  assumes \"rel_option A x y\"\n  shows \"rel_option (\\<lambda>a (a', b). a = a' \\<and> A a' b) x (rel_witness_option (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>a (a', b). a = a' \\<and> A a' b) x\n     (rel_witness_option (x, y))", "using map1_rel_witness_option[OF assms, symmetric]"], ["proof (prove)\nusing this:\n  x = map_option fst (rel_witness_option (x, y))\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>a (a', b). a = a' \\<and> A a' b) x\n     (rel_witness_option (x, y))", "unfolding option.rel_eq[symmetric] option.rel_map"], ["proof (prove)\nusing this:\n  rel_option (\\<lambda>x y. x = fst y) x (rel_witness_option (x, y))\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>a (a', b). a = a' \\<and> A a' b) x\n     (rel_witness_option (x, y))", "by(rule option.rel_mono_strong)(auto intro: set_rel_witness_option[OF assms])"], ["", "lemma rel_witness_option2:\n  assumes \"rel_option A x y\"\n  shows \"rel_option (\\<lambda>(a, b') b. b = b' \\<and> A a b') (rel_witness_option (x, y)) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>(a, b') b. b = b' \\<and> A a b')\n     (rel_witness_option (x, y)) y", "using map2_rel_witness_option[OF assms]"], ["proof (prove)\nusing this:\n  map_option snd (rel_witness_option (x, y)) = y\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>(a, b') b. b = b' \\<and> A a b')\n     (rel_witness_option (x, y)) y", "unfolding option.rel_eq[symmetric] option.rel_map"], ["proof (prove)\nusing this:\n  rel_option (\\<lambda>x. (=) (snd x)) (rel_witness_option (x, y)) y\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>(a, b') b. b = b' \\<and> A a b')\n     (rel_witness_option (x, y)) y", "by(rule option.rel_mono_strong)(auto intro: set_rel_witness_option[OF assms])"], ["", "subsubsection \\<open>Orders on option\\<close>"], ["", "abbreviation le_option :: \"'a option \\<Rightarrow> 'a option \\<Rightarrow> bool\"\nwhere \"le_option \\<equiv> ord_option (=)\""], ["", "lemma le_option_bind_mono:\n  \"\\<lbrakk> le_option x y; \\<And>a. a \\<in> set_option x \\<Longrightarrow> le_option (f a) (g a) \\<rbrakk>\n  \\<Longrightarrow> le_option (Option.bind x f) (Option.bind y g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>le_option x y;\n     \\<And>a.\n        a \\<in> set_option x \\<Longrightarrow>\n        le_option (f a) (g a)\\<rbrakk>\n    \\<Longrightarrow> le_option (x \\<bind> f) (y \\<bind> g)", "by(cases x) simp_all"], ["", "lemma le_option_refl [simp]: \"le_option x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_option x x", "by(cases x) simp_all"], ["", "lemma le_option_conv_option_ord: \"le_option = option_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_option = option_ord", "by(auto simp add: fun_eq_iff flat_ord_def elim: ord_option.cases)"], ["", "definition pcr_Some :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> 'a \\<Rightarrow> 'b option \\<Rightarrow> bool\"\nwhere \"pcr_Some R x y \\<longleftrightarrow> (\\<exists>z. y = Some z \\<and> R x z)\""], ["", "lemma pcr_Some_simps [simp]: \"pcr_Some R x (Some y) \\<longleftrightarrow> R x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pcr_Some R x (Some y) = R x y", "by(simp add: pcr_Some_def)"], ["", "lemma pcr_SomeE [cases pred]:\n  assumes \"pcr_Some R x y\"\n  obtains (pcr_Some) z where \"y = Some z\" \"R x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>y = Some z; R x z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  pcr_Some R x y\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>y = Some z; R x z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: pcr_Some_def)"], ["", "subsubsection \\<open>Filter for option\\<close>"], ["", "fun filter_option :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a option \\<Rightarrow> 'a option\"\nwhere\n  \"filter_option P None = None\"\n| \"filter_option P (Some x) = (if P x then Some x else None)\""], ["", "lemma set_filter_option [simp]: \"set_option (filter_option P x) = {y \\<in> set_option x. P y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_option (filter_option P x) = {y \\<in> set_option x. P y}", "by(cases x) auto"], ["", "lemma filter_map_option: \"filter_option P (map_option f x) = map_option f (filter_option (P \\<circ> f) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_option P (map_option f x) =\n    map_option f (filter_option (P \\<circ> f) x)", "by(cases x) simp_all"], ["", "lemma is_none_filter_option [simp]: \"Option.is_none (filter_option P x) \\<longleftrightarrow> Option.is_none x \\<or> \\<not> P (the x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Option.is_none (filter_option P x) =\n    (Option.is_none x \\<or> \\<not> P (the x))", "by(cases x) simp_all"], ["", "lemma filter_option_eq_Some_iff [simp]: \"filter_option P x = Some y \\<longleftrightarrow> x = Some y \\<and> P y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (filter_option P x = Some y) = (x = Some y \\<and> P y)", "by(cases x) auto"], ["", "lemma Some_eq_filter_option_iff [simp]: \"Some y = filter_option P x \\<longleftrightarrow> x = Some y \\<and> P y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Some y = filter_option P x) = (x = Some y \\<and> P y)", "by(cases x) auto"], ["", "lemma filter_conv_bind_option: \"filter_option P x = Option.bind x (\\<lambda>y. if P y then Some y else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_option P x = x \\<bind> (\\<lambda>y. if P y then Some y else None)", "by(cases x) simp_all"], ["", "subsubsection \\<open>Assert for option\\<close>"], ["", "primrec assert_option :: \"bool \\<Rightarrow> unit option\" where\n  \"assert_option True = Some ()\"\n| \"assert_option False = None\""], ["", "lemma set_assert_option_conv: \"set_option (assert_option b) = (if b then {()} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_option (assert_option b) = (if b then {()} else {})", "by(simp)"], ["", "lemma in_set_assert_option [simp]: \"x \\<in> set_option (assert_option b) \\<longleftrightarrow> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set_option (assert_option b)) = b", "by(cases b) simp_all"], ["", "subsubsection \\<open>Join on options\\<close>"], ["", "definition join_option :: \"'a option option \\<Rightarrow> 'a option\"\nwhere \"join_option x = (case x of Some y \\<Rightarrow> y | None \\<Rightarrow> None)\""], ["", "simps_of_case join_simps [simp, code]: join_option_def"], ["", "lemma set_join_option [simp]: \"set_option (join_option x) = \\<Union>(set_option ` set_option x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_option (join_option x) = \\<Union> (set_option ` set_option x)", "by(cases x)(simp_all)"], ["", "lemma in_set_join_option: \"x \\<in> set_option (join_option (Some (Some x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set_option (join_option (Some (Some x)))", "by simp"], ["", "lemma map_join_option: \"map_option f (join_option x) = join_option (map_option (map_option f) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option f (join_option x) = join_option (map_option (map_option f) x)", "by(cases x) simp_all"], ["", "lemma bind_conv_join_option: \"Option.bind x f = join_option (map_option f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<bind> f = join_option (map_option f x)", "by(cases x) simp_all"], ["", "lemma join_conv_bind_option: \"join_option x = Option.bind x id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. join_option x = x \\<bind> id", "by(cases x) simp_all"], ["", "lemma join_option_parametric [transfer_rule]:\n  includes lifting_syntax shows\n  \"(rel_option (rel_option R) ===> rel_option R) join_option join_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_option (rel_option R) ===> rel_option R) join_option join_option", "unfolding join_conv_bind_option[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_option (rel_option R) ===> rel_option R) (\\<lambda>x. x \\<bind> id)\n     (\\<lambda>x. x \\<bind> id)", "by transfer_prover"], ["", "lemma join_option_eq_Some [simp]: \"join_option x = Some y \\<longleftrightarrow> x = Some (Some y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (join_option x = Some y) = (x = Some (Some y))", "by(cases x) simp_all"], ["", "lemma Some_eq_join_option [simp]: \"Some y = join_option x \\<longleftrightarrow> x = Some (Some y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Some y = join_option x) = (x = Some (Some y))", "by(cases x) auto"], ["", "lemma join_option_eq_None: \"join_option x = None \\<longleftrightarrow> x = None \\<or> x = Some None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (join_option x = None) = (x = None \\<or> x = Some None)", "by(cases x) simp_all"], ["", "lemma None_eq_join_option: \"None = join_option x \\<longleftrightarrow> x = None \\<or> x = Some None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (None = join_option x) = (x = None \\<or> x = Some None)", "by(cases x) auto"], ["", "subsubsection \\<open>Zip on options\\<close>"], ["", "function zip_option :: \"'a option \\<Rightarrow> 'b option \\<Rightarrow> ('a \\<times> 'b) option\"\nwhere\n  \"zip_option (Some x) (Some y) = Some (x, y)\"\n| \"zip_option _ None = None\"\n| \"zip_option None _ = None\""], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>xa y. x = (Some xa, Some y) \\<Longrightarrow> P;\n        \\<And>uu_. x = (uu_, None) \\<Longrightarrow> P;\n        \\<And>uv_. x = (None, uv_) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>x y xa ya.\n       (Some x, Some y) = (Some xa, Some ya) \\<Longrightarrow>\n       Some (x, y) = Some (xa, ya)\n 3. \\<And>x y uu_.\n       (Some x, Some y) = (uu_, None) \\<Longrightarrow> Some (x, y) = None\n 4. \\<And>x y uv_.\n       (Some x, Some y) = (None, uv_) \\<Longrightarrow> Some (x, y) = None\n 5. \\<And>uu_ uua_. (uu_, None) = (uua_, None) \\<Longrightarrow> None = None\n 6. \\<And>uu_ uv_. (uu_, None) = (None, uv_) \\<Longrightarrow> None = None\n 7. \\<And>uv_ uva_. (None, uv_) = (None, uva_) \\<Longrightarrow> None = None", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All zip_option_dom", "by lexicographic_order"], ["", "lemma zip_option_eq_Some_iff [iff]:\n  \"zip_option x y = Some (a, b) \\<longleftrightarrow> x = Some a \\<and> y = Some b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (zip_option x y = Some (a, b)) = (x = Some a \\<and> y = Some b)", "by(cases \"(x, y)\" rule: zip_option.cases) simp_all"], ["", "lemma set_zip_option [simp]:\n  \"set_option (zip_option x y) = set_option x \\<times> set_option y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_option (zip_option x y) = set_option x \\<times> set_option y", "by auto"], ["", "lemma zip_map_option1: \"zip_option (map_option f x) y = map_option (apfst f) (zip_option x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zip_option (map_option f x) y = map_option (apfst f) (zip_option x y)", "by(cases \"(x, y)\" rule: zip_option.cases) simp_all"], ["", "lemma zip_map_option2: \"zip_option x (map_option g y) = map_option (apsnd g) (zip_option x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zip_option x (map_option g y) = map_option (apsnd g) (zip_option x y)", "by(cases \"(x, y)\" rule: zip_option.cases) simp_all"], ["", "lemma map_zip_option:\n  \"map_option (map_prod f g) (zip_option x y) = zip_option (map_option f x) (map_option g y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option (map_prod f g) (zip_option x y) =\n    zip_option (map_option f x) (map_option g y)", "by(simp add: zip_map_option1 zip_map_option2 option.map_comp apfst_def apsnd_def o_def prod.map_comp)"], ["", "lemma zip_conv_bind_option:\n  \"zip_option x y = Option.bind x (\\<lambda>x. Option.bind y (\\<lambda>y. Some (x, y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zip_option x y =\n    x \\<bind> (\\<lambda>x. y \\<bind> (\\<lambda>y. Some (x, y)))", "by(cases \"(x, y)\" rule: zip_option.cases) simp_all"], ["", "lemma zip_option_parametric [transfer_rule]:\n  includes lifting_syntax shows\n  \"(rel_option R ===> rel_option Q ===> rel_option (rel_prod R Q)) zip_option zip_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_option R ===> rel_option Q ===> rel_option (rel_prod R Q))\n     zip_option zip_option", "unfolding zip_conv_bind_option[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_option R ===> rel_option Q ===> rel_option (rel_prod R Q))\n     (\\<lambda>x y.\n         x \\<bind> (\\<lambda>x. y \\<bind> (\\<lambda>y. Some (x, y))))\n     (\\<lambda>x y.\n         x \\<bind> (\\<lambda>x. y \\<bind> (\\<lambda>y. Some (x, y))))", "by transfer_prover"], ["", "lemma rel_option_eqI [simp]: \"rel_option (=) x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (=) x x", "by(simp add: option.rel_eq)"], ["", "subsubsection \\<open>Binary supremum on @{typ \"'a option\"}\\<close>"], ["", "primrec sup_option :: \"'a option \\<Rightarrow> 'a option \\<Rightarrow> 'a option\"\nwhere\n  \"sup_option x None = x\"\n| \"sup_option x (Some y) = (Some y)\""], ["", "lemma sup_option_idem [simp]: \"sup_option x x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_option x x = x", "by(cases x) simp_all"], ["", "lemma sup_option_assoc: \"sup_option (sup_option x y) z = sup_option x (sup_option y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_option (sup_option x y) z = sup_option x (sup_option y z)", "by(cases z) simp_all"], ["", "lemma sup_option_left_idem: \"sup_option x (sup_option x y) = sup_option x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_option x (sup_option x y) = sup_option x y", "by(rewrite sup_option_assoc[symmetric])(simp)"], ["", "lemmas sup_option_ai = sup_option_assoc sup_option_left_idem"], ["", "lemma sup_option_None [simp]: \"sup_option None y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_option None y = y", "by(cases y) simp_all"], ["", "subsubsection \\<open>Restriction on @{typ \"'a option\"}\\<close>"], ["", "primrec (transfer) enforce_option :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a option \\<Rightarrow> 'a option\" where\n  \"enforce_option P (Some x) = (if P x then Some x else None)\"\n| \"enforce_option P None = None\""], ["", "lemma set_enforce_option [simp]: \"set_option (enforce_option P x) = {a \\<in> set_option x. P a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_option (enforce_option P x) = {a \\<in> set_option x. P a}", "by(cases x) auto"], ["", "lemma enforce_map_option: \"enforce_option P (map_option f x) = map_option f (enforce_option (P \\<circ> f) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enforce_option P (map_option f x) =\n    map_option f (enforce_option (P \\<circ> f) x)", "by(cases x) auto"], ["", "lemma enforce_bind_option [simp]:\n  \"enforce_option P (Option.bind x f) = Option.bind x (enforce_option P \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enforce_option P (x \\<bind> f) = x \\<bind> enforce_option P \\<circ> f", "by(cases x) auto"], ["", "lemma enforce_option_alt_def:\n  \"enforce_option P x = Option.bind x (\\<lambda>a. Option.bind (assert_option (P a)) (\\<lambda>_ :: unit. Some a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enforce_option P x =\n    x \\<bind> (\\<lambda>a. assert_option (P a) \\<bind> (\\<lambda>_. Some a))", "by(cases x) simp_all"], ["", "lemma enforce_option_eq_None_iff [simp]:\n  \"enforce_option P x = None \\<longleftrightarrow> (\\<forall>a. x = Some a \\<longrightarrow> \\<not> P a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (enforce_option P x = None) =\n    (\\<forall>a. x = Some a \\<longrightarrow> \\<not> P a)", "by(cases x) auto"], ["", "lemma enforce_option_eq_Some_iff [simp]:\n  \"enforce_option P x = Some y \\<longleftrightarrow> x = Some y \\<and> P y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (enforce_option P x = Some y) = (x = Some y \\<and> P y)", "by(cases x) auto"], ["", "lemma Some_eq_enforce_option_iff [simp]:\n  \"Some y = enforce_option P x \\<longleftrightarrow> x = Some y \\<and> P y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Some y = enforce_option P x) = (x = Some y \\<and> P y)", "by(cases x) auto"], ["", "lemma enforce_option_top [simp]: \"enforce_option \\<top> = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enforce_option \\<top> = id", "by(rule ext; rename_tac x; case_tac x; simp)"], ["", "lemma enforce_option_K_True [simp]: \"enforce_option (\\<lambda>_. True) x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enforce_option (\\<lambda>_. True) x = x", "by(cases x) simp_all"], ["", "lemma enforce_option_bot [simp]: \"enforce_option \\<bottom> = (\\<lambda>_. None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enforce_option \\<bottom> = Map.empty", "by(simp add: fun_eq_iff)"], ["", "lemma enforce_option_K_False [simp]: \"enforce_option (\\<lambda>_. False) x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enforce_option (\\<lambda>_. False) x = None", "by simp"], ["", "lemma enforce_pred_id_option: \"pred_option P x \\<Longrightarrow> enforce_option P x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_option P x \\<Longrightarrow> enforce_option P x = x", "by(cases x) auto"], ["", "subsubsection \\<open>Maps\\<close>"], ["", "lemma map_add_apply: \"(m1 ++ m2) x = sup_option (m1 x) (m2 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m1 ++ m2) x = sup_option (m1 x) (m2 x)", "by(simp add: map_add_def split: option.split)"], ["", "lemma map_le_map_upd2: \"\\<lbrakk> f \\<subseteq>\\<^sub>m g; \\<And>y'. f x = Some y' \\<Longrightarrow> y' = y \\<rbrakk> \\<Longrightarrow> f \\<subseteq>\\<^sub>m g(x \\<mapsto> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<subseteq>\\<^sub>m g;\n     \\<And>y'. f x = Some y' \\<Longrightarrow> y' = y\\<rbrakk>\n    \\<Longrightarrow> f \\<subseteq>\\<^sub>m g(x \\<mapsto> y)", "by(cases \"x \\<in> dom f\")(auto simp add: map_le_def Ball_def)"], ["", "lemma eq_None_iff_not_dom: \"f x = None \\<longleftrightarrow> x \\<notin> dom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f x = None) = (x \\<notin> dom f)", "by auto"], ["", "lemma card_ran_le_dom: \"finite (dom m) \\<Longrightarrow> card (ran m) \\<le> card (dom m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom m) \\<Longrightarrow> card (ran m) \\<le> card (dom m)", "by(simp add: ran_alt_def card_image_le)"], ["", "lemma dom_subset_ran_iff:\n  assumes \"finite (ran m)\"\n  shows \"dom m \\<subseteq> ran m \\<longleftrightarrow> dom m = ran m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dom m \\<subseteq> ran m) = (dom m = ran m)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. dom m \\<subseteq> ran m \\<Longrightarrow> dom m = ran m\n 2. dom m = ran m \\<Longrightarrow> dom m \\<subseteq> ran m", "assume le: \"dom m \\<subseteq> ran m\""], ["proof (state)\nthis:\n  dom m \\<subseteq> ran m\n\ngoal (2 subgoals):\n 1. dom m \\<subseteq> ran m \\<Longrightarrow> dom m = ran m\n 2. dom m = ran m \\<Longrightarrow> dom m \\<subseteq> ran m", "then"], ["proof (chain)\npicking this:\n  dom m \\<subseteq> ran m", "have \"card (dom m) \\<le> card (ran m)\""], ["proof (prove)\nusing this:\n  dom m \\<subseteq> ran m\n\ngoal (1 subgoal):\n 1. card (dom m) \\<le> card (ran m)", "by(simp add: card_mono assms)"], ["proof (state)\nthis:\n  card (dom m) \\<le> card (ran m)\n\ngoal (2 subgoals):\n 1. dom m \\<subseteq> ran m \\<Longrightarrow> dom m = ran m\n 2. dom m = ran m \\<Longrightarrow> dom m \\<subseteq> ran m", "moreover"], ["proof (state)\nthis:\n  card (dom m) \\<le> card (ran m)\n\ngoal (2 subgoals):\n 1. dom m \\<subseteq> ran m \\<Longrightarrow> dom m = ran m\n 2. dom m = ran m \\<Longrightarrow> dom m \\<subseteq> ran m", "have \"card (ran m) \\<le> card (dom m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (ran m) \\<le> card (dom m)", "by(simp add: finite_subset[OF le assms] card_ran_le_dom)"], ["proof (state)\nthis:\n  card (ran m) \\<le> card (dom m)\n\ngoal (2 subgoals):\n 1. dom m \\<subseteq> ran m \\<Longrightarrow> dom m = ran m\n 2. dom m = ran m \\<Longrightarrow> dom m \\<subseteq> ran m", "ultimately"], ["proof (chain)\npicking this:\n  card (dom m) \\<le> card (ran m)\n  card (ran m) \\<le> card (dom m)", "show \"dom m = ran m\""], ["proof (prove)\nusing this:\n  card (dom m) \\<le> card (ran m)\n  card (ran m) \\<le> card (dom m)\n\ngoal (1 subgoal):\n 1. dom m = ran m", "using card_subset_eq[OF assms le]"], ["proof (prove)\nusing this:\n  card (dom m) \\<le> card (ran m)\n  card (ran m) \\<le> card (dom m)\n  card (dom m) = card (ran m) \\<Longrightarrow> dom m = ran m\n\ngoal (1 subgoal):\n 1. dom m = ran m", "by simp"], ["proof (state)\nthis:\n  dom m = ran m\n\ngoal (1 subgoal):\n 1. dom m = ran m \\<Longrightarrow> dom m \\<subseteq> ran m", "qed simp"], ["", "text \\<open>\n  We need a polymorphic constant for the empty map such that \\<open>transfer_prover\\<close>\n  can use a custom transfer rule for @{const Map.empty}\n\\<close>"], ["", "definition Map_empty where [simp]: \"Map_empty \\<equiv> Map.empty\""], ["", "lemma map_le_Some1D: \"\\<lbrakk> m \\<subseteq>\\<^sub>m m'; m x = Some y \\<rbrakk> \\<Longrightarrow> m' x = Some y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<subseteq>\\<^sub>m m'; m x = Some y\\<rbrakk>\n    \\<Longrightarrow> m' x = Some y", "by(auto simp add: map_le_def Ball_def)"], ["", "lemma map_le_fun_upd2: \"\\<lbrakk> f \\<subseteq>\\<^sub>m g; x \\<notin> dom f \\<rbrakk> \\<Longrightarrow> f \\<subseteq>\\<^sub>m g(x := y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<subseteq>\\<^sub>m g; x \\<notin> dom f\\<rbrakk>\n    \\<Longrightarrow> f \\<subseteq>\\<^sub>m g(x := y)", "by(auto simp add: map_le_def)"], ["", "lemma map_eqI: \"\\<forall>x\\<in>dom m \\<union> dom m'. m x = m' x \\<Longrightarrow> m = m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>dom m \\<union> dom m'. m x = m' x \\<Longrightarrow>\n    m = m'", "by(auto simp add: fun_eq_iff domIff intro: option.expand)"], ["", "subsection \\<open>Countable\\<close>"], ["", "lemma countable_lfp:\n  assumes step: \"\\<And>Y. countable Y \\<Longrightarrow> countable (F Y)\"\n  and cont: \"Order_Continuity.sup_continuous F\"\n  shows \"countable (lfp F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (lfp F)", "by(subst sup_continuous_lfp[OF cont])(simp add: countable_funpow[OF step])"], ["", "lemma countable_lfp_apply:\n  assumes step: \"\\<And>Y x. (\\<And>x. countable (Y x)) \\<Longrightarrow> countable (F Y x)\"\n  and cont: \"Order_Continuity.sup_continuous F\"\n  shows \"countable (lfp F x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (lfp F x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. countable (lfp F x)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. countable (lfp F x)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. countable (lfp F x)", "have \"\\<And>x. countable ((F ^^ n) bot x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. countable ((F ^^ n) \\<bottom> x)", "by(induct n)(auto intro: step)"], ["proof (state)\nthis:\n  countable ((F ^^ n) \\<bottom> ?x)\n\ngoal (1 subgoal):\n 1. countable (lfp F x)", "}"], ["proof (state)\nthis:\n  countable ((F ^^ ?n3) \\<bottom> ?x)\n\ngoal (1 subgoal):\n 1. countable (lfp F x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  countable ((F ^^ ?n3) \\<bottom> ?x)\n\ngoal (1 subgoal):\n 1. countable (lfp F x)", "using cont"], ["proof (prove)\nusing this:\n  countable ((F ^^ ?n3) \\<bottom> ?x)\n  sup_continuous F\n\ngoal (1 subgoal):\n 1. countable (lfp F x)", "by(simp add: sup_continuous_lfp)"], ["proof (state)\nthis:\n  countable (lfp F x)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Extended naturals \\<close>"], ["", "lemma idiff_enat_eq_enat_iff: \"x - enat n = enat m \\<longleftrightarrow> (\\<exists>k. x = enat k \\<and> k - n = m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x - enat n = enat m) = (\\<exists>k. x = enat k \\<and> k - n = m)", "by (cases x) simp_all"], ["", "lemma eSuc_SUP: \"A \\<noteq> {} \\<Longrightarrow> eSuc (\\<Squnion> (f ` A)) = (\\<Squnion>x\\<in>A. eSuc (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    eSuc (\\<Squnion> (f ` A)) = (\\<Squnion>x\\<in>A. eSuc (f x))", "by (subst eSuc_Sup) (simp_all add: image_comp)"], ["", "lemma ereal_of_enat_1: \"ereal_of_enat 1 = ereal 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal_of_enat 1 = ereal 1", "by (simp add: one_enat_def)"], ["", "lemma ennreal_real_conv_ennreal_of_enat: \"ennreal (real n) = ennreal_of_enat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (real n) = ennreal_of_enat (enat n)", "by (simp add: ennreal_of_nat_eq_real_of_nat)"], ["", "lemma enat_add_sub_same2: \"b \\<noteq> \\<infinity> \\<Longrightarrow> a + b - b = (a :: enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<noteq> \\<infinity> \\<Longrightarrow> a + b - b = a", "by (cases a; cases b) simp_all"], ["", "lemma enat_sub_add: \"y \\<le> x \\<Longrightarrow> x - y + z = x + z - (y :: enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> x \\<Longrightarrow> x - y + z = x + z - y", "by (cases x; cases y; cases z) simp_all"], ["", "lemma SUP_enat_eq_0_iff [simp]: \"\\<Squnion> (f ` A) = (0 :: enat) \\<longleftrightarrow> (\\<forall>x\\<in>A. f x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> (f ` A) = 0) = (\\<forall>x\\<in>A. f x = 0)", "by (simp add: bot_enat_def [symmetric])"], ["", "lemma SUP_enat_add_left:\n  assumes \"I \\<noteq> {}\"\n  shows \"(SUP i\\<in>I. f i + c :: enat) = (SUP i\\<in>I. f i) + c\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>i\\<in>I. f i + c) = \\<Squnion> (f ` I) + c", "proof(cases \"c\", rule antisym)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>nat.\n       c = enat nat \\<Longrightarrow>\n       (\\<Squnion>i\\<in>I. f i + c) \\<le> \\<Squnion> (f ` I) + c\n 2. \\<And>nat.\n       c = enat nat \\<Longrightarrow>\n       \\<Squnion> (f ` I) + c \\<le> (\\<Squnion>i\\<in>I. f i + c)\n 3. c = \\<infinity> \\<Longrightarrow>\n    (\\<Squnion>i\\<in>I. f i + c) = \\<Squnion> (f ` I) + c", "case (enat n)"], ["proof (state)\nthis:\n  c = enat n\n\ngoal (3 subgoals):\n 1. \\<And>nat.\n       c = enat nat \\<Longrightarrow>\n       (\\<Squnion>i\\<in>I. f i + c) \\<le> \\<Squnion> (f ` I) + c\n 2. \\<And>nat.\n       c = enat nat \\<Longrightarrow>\n       \\<Squnion> (f ` I) + c \\<le> (\\<Squnion>i\\<in>I. f i + c)\n 3. c = \\<infinity> \\<Longrightarrow>\n    (\\<Squnion>i\\<in>I. f i + c) = \\<Squnion> (f ` I) + c", "show \"?lhs \\<le> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>i\\<in>I. f i + c) \\<le> \\<Squnion> (f ` I) + c", "by(auto 4 3 intro: SUP_upper intro: SUP_least)"], ["proof (state)\nthis:\n  (\\<Squnion>i\\<in>I. f i + c) \\<le> \\<Squnion> (f ` I) + c\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       c = enat nat \\<Longrightarrow>\n       \\<Squnion> (f ` I) + c \\<le> (\\<Squnion>i\\<in>I. f i + c)\n 2. c = \\<infinity> \\<Longrightarrow>\n    (\\<Squnion>i\\<in>I. f i + c) = \\<Squnion> (f ` I) + c", "have \"(SUP i\\<in>I. f i) \\<le> ?lhs - c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (f ` I) \\<le> (\\<Squnion>i\\<in>I. f i + c) - c", "using enat"], ["proof (prove)\nusing this:\n  c = enat n\n\ngoal (1 subgoal):\n 1. \\<Squnion> (f ` I) \\<le> (\\<Squnion>i\\<in>I. f i + c) - c", "by(auto simp add: enat_add_sub_same2 intro!: SUP_least order_trans[OF _ SUP_upper[THEN enat_minus_mono1]])"], ["proof (state)\nthis:\n  \\<Squnion> (f ` I) \\<le> (\\<Squnion>i\\<in>I. f i + c) - c\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       c = enat nat \\<Longrightarrow>\n       \\<Squnion> (f ` I) + c \\<le> (\\<Squnion>i\\<in>I. f i + c)\n 2. c = \\<infinity> \\<Longrightarrow>\n    (\\<Squnion>i\\<in>I. f i + c) = \\<Squnion> (f ` I) + c", "note add_right_mono[OF this, of c]"], ["proof (state)\nthis:\n  \\<Squnion> (f ` I) + c \\<le> (\\<Squnion>i\\<in>I. f i + c) - c + c\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       c = enat nat \\<Longrightarrow>\n       \\<Squnion> (f ` I) + c \\<le> (\\<Squnion>i\\<in>I. f i + c)\n 2. c = \\<infinity> \\<Longrightarrow>\n    (\\<Squnion>i\\<in>I. f i + c) = \\<Squnion> (f ` I) + c", "also"], ["proof (state)\nthis:\n  \\<Squnion> (f ` I) + c \\<le> (\\<Squnion>i\\<in>I. f i + c) - c + c\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       c = enat nat \\<Longrightarrow>\n       \\<Squnion> (f ` I) + c \\<le> (\\<Squnion>i\\<in>I. f i + c)\n 2. c = \\<infinity> \\<Longrightarrow>\n    (\\<Squnion>i\\<in>I. f i + c) = \\<Squnion> (f ` I) + c", "have \"\\<dots> + c \\<le> ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>i\\<in>I. f i + c) - c + c \\<le> (\\<Squnion>i\\<in>I. f i + c)", "using assms"], ["proof (prove)\nusing this:\n  I \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<Squnion>i\\<in>I. f i + c) - c + c \\<le> (\\<Squnion>i\\<in>I. f i + c)", "by(subst enat_sub_add)(auto intro: SUP_upper2 simp add: enat_add_sub_same2 enat)"], ["proof (state)\nthis:\n  (\\<Squnion>i\\<in>I. f i + c) - c + c \\<le> (\\<Squnion>i\\<in>I. f i + c)\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       c = enat nat \\<Longrightarrow>\n       \\<Squnion> (f ` I) + c \\<le> (\\<Squnion>i\\<in>I. f i + c)\n 2. c = \\<infinity> \\<Longrightarrow>\n    (\\<Squnion>i\\<in>I. f i + c) = \\<Squnion> (f ` I) + c", "finally"], ["proof (chain)\npicking this:\n  \\<Squnion> (f ` I) + c \\<le> (\\<Squnion>i\\<in>I. f i + c)", "show \"?rhs \\<le> ?lhs\""], ["proof (prove)\nusing this:\n  \\<Squnion> (f ` I) + c \\<le> (\\<Squnion>i\\<in>I. f i + c)\n\ngoal (1 subgoal):\n 1. \\<Squnion> (f ` I) + c \\<le> (\\<Squnion>i\\<in>I. f i + c)", "."], ["proof (state)\nthis:\n  \\<Squnion> (f ` I) + c \\<le> (\\<Squnion>i\\<in>I. f i + c)\n\ngoal (1 subgoal):\n 1. c = \\<infinity> \\<Longrightarrow>\n    (\\<Squnion>i\\<in>I. f i + c) = \\<Squnion> (f ` I) + c", "qed(simp add: assms SUP_constant)"], ["", "lemma SUP_enat_add_right:\n  assumes \"I \\<noteq> {}\"\n  shows \"(SUP i\\<in>I. c + f i :: enat) = c + (SUP i\\<in>I. f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>i\\<in>I. c + f i) = c + \\<Squnion> (f ` I)", "using SUP_enat_add_left[OF assms, of f c]"], ["proof (prove)\nusing this:\n  (\\<Squnion>i\\<in>I. f i + c) = \\<Squnion> (f ` I) + c\n\ngoal (1 subgoal):\n 1. (\\<Squnion>i\\<in>I. c + f i) = c + \\<Squnion> (f ` I)", "by(simp add: add.commute)"], ["", "lemma iadd_SUP_le_iff: \"n + (SUP x\\<in>A. f x :: enat) \\<le> y \\<longleftrightarrow> (if A = {} then n \\<le> y else \\<forall>x\\<in>A. n + f x \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n + \\<Squnion> (f ` A) \\<le> y) =\n    (if A = {} then n \\<le> y else \\<forall>x\\<in>A. n + f x \\<le> y)", "by(simp add: bot_enat_def SUP_enat_add_right[symmetric] SUP_le_iff)"], ["", "lemma SUP_iadd_le_iff: \"(SUP x\\<in>A. f x :: enat) + n \\<le> y \\<longleftrightarrow> (if A = {} then n \\<le> y else \\<forall>x\\<in>A. f x + n \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> (f ` A) + n \\<le> y) =\n    (if A = {} then n \\<le> y else \\<forall>x\\<in>A. f x + n \\<le> y)", "using iadd_SUP_le_iff[of n f A y]"], ["proof (prove)\nusing this:\n  (n + \\<Squnion> (f ` A) \\<le> y) =\n  (if A = {} then n \\<le> y else \\<forall>x\\<in>A. n + f x \\<le> y)\n\ngoal (1 subgoal):\n 1. (\\<Squnion> (f ` A) + n \\<le> y) =\n    (if A = {} then n \\<le> y else \\<forall>x\\<in>A. f x + n \\<le> y)", "by(simp add: add.commute)"], ["", "subsection \\<open>Extended non-negative reals\\<close>"], ["", "lemma (in finite_measure) nn_integral_indicator_neq_infty: \n  \"f -` A \\<in> sets M \\<Longrightarrow> (\\<integral>\\<^sup>+ x. indicator A (f x) \\<partial>M) \\<noteq> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f -` A \\<in> sets M \\<Longrightarrow>\n    \\<integral>\\<^sup>+ x. indicator A (f x) \\<partial>M \\<noteq>\n    \\<infinity>", "unfolding ennreal_indicator[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. f -` A \\<in> sets M \\<Longrightarrow>\n    \\<integral>\\<^sup>+ x. ennreal (indicat_real A (f x))\n                       \\<partial>M \\<noteq>\n    \\<infinity>", "apply(rule integrableD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. f -` A \\<in> sets M \\<Longrightarrow>\n    integrable M (\\<lambda>x. indicat_real A (f x))", "apply(rule integrable_const_bound[where B=1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. f -` A \\<in> sets M \\<Longrightarrow>\n    AE x in M. norm (indicat_real A (f x)) \\<le> 1\n 2. f -` A \\<in> sets M \\<Longrightarrow>\n    (\\<lambda>x. indicat_real A (f x)) \\<in> borel_measurable M", "apply(simp_all add: indicator_vimage[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in finite_measure) nn_integral_indicator_neq_top: \n  \"f -` A \\<in> sets M \\<Longrightarrow> (\\<integral>\\<^sup>+ x. indicator A (f x) \\<partial>M) \\<noteq> \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f -` A \\<in> sets M \\<Longrightarrow>\n    \\<integral>\\<^sup>+ x. indicator A (f x) \\<partial>M \\<noteq> \\<top>", "by(drule nn_integral_indicator_neq_infty) simp"], ["", "lemma nn_integral_indicator_map:\n  assumes [measurable]: \"f \\<in> measurable M N\" \"{x\\<in>space N. P x} \\<in> sets N\"\n  shows \"(\\<integral>\\<^sup>+x. indicator {x\\<in>space N. P x} (f x) \\<partial>M) = emeasure M {x\\<in>space M. P (f x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. indicator {x \\<in> space N. P x} (f x)\n                       \\<partial>M =\n    emeasure M {x \\<in> space M. P (f x)}", "using assms(1)[THEN measurable_space]"], ["proof (prove)\nusing this:\n  ?x \\<in> space M \\<Longrightarrow> f ?x \\<in> space N\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. indicator {x \\<in> space N. P x} (f x)\n                       \\<partial>M =\n    emeasure M {x \\<in> space M. P (f x)}", "by (subst nn_integral_indicator[symmetric])\n     (auto intro!: nn_integral_cong split: split_indicator simp del: nn_integral_indicator)"], ["", "subsection \\<open>BNF material\\<close>"], ["", "lemma transp_rel_fun: \"\\<lbrakk> is_equality Q; transp R \\<rbrakk> \\<Longrightarrow> transp (rel_fun Q R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_equality Q; transp R\\<rbrakk>\n    \\<Longrightarrow> transp (rel_fun Q R)", "by(rule transpI)(auto dest: transpD rel_funD simp add: is_equality_def)"], ["", "lemma rel_fun_inf: \"inf (rel_fun Q R) (rel_fun Q R') = rel_fun Q (inf R R')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun Q R \\<sqinter> rel_fun Q R' = rel_fun Q (R \\<sqinter> R')", "by(rule antisym)(auto elim: rel_fun_mono dest: rel_funD)"], ["", "lemma reflp_fun1: includes lifting_syntax shows \"\\<lbrakk> is_equality A; reflp B \\<rbrakk> \\<Longrightarrow> reflp (A ===> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_equality A; reflp B\\<rbrakk>\n    \\<Longrightarrow> reflp (A ===> B)", "by(simp add: reflp_def rel_fun_def is_equality_def)"], ["", "lemma type_copy_id': \"type_definition (\\<lambda>x. x) (\\<lambda>x. x) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition (\\<lambda>x. x) (\\<lambda>x. x) UNIV", "by unfold_locales simp_all"], ["", "lemma type_copy_id: \"type_definition id id UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition id id UNIV", "by(simp add: id_def type_copy_id')"], ["", "lemma GrpE [cases pred]:\n  assumes \"BNF_Def.Grp A f x y\"\n  obtains (Grp) \"y = f x\" \"x \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>y = f x; x \\<in> A\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  BNF_Def.Grp A f x y\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>y = f x; x \\<in> A\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(simp add: Grp_def)"], ["", "lemma rel_fun_Grp_copy_Abs:\n  includes lifting_syntax\n  assumes \"type_definition Rep Abs A\"\n  shows \"rel_fun (BNF_Def.Grp A Abs) (BNF_Def.Grp B g) = BNF_Def.Grp {f. f ` A \\<subseteq> B} (Rep ---> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BNF_Def.Grp A Abs ===> BNF_Def.Grp B g =\n    BNF_Def.Grp {f. f ` A \\<subseteq> B} (Rep ---> g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. BNF_Def.Grp A Abs ===> BNF_Def.Grp B g =\n    BNF_Def.Grp {f. f ` A \\<subseteq> B} (Rep ---> g)", "interpret type_definition Rep Abs A"], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition Rep Abs A", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. BNF_Def.Grp A Abs ===> BNF_Def.Grp B g =\n    BNF_Def.Grp {f. f ` A \\<subseteq> B} (Rep ---> g)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. BNF_Def.Grp A Abs ===> BNF_Def.Grp B g =\n    BNF_Def.Grp {f. f ` A \\<subseteq> B} (Rep ---> g)", "by(auto simp add: rel_fun_def Grp_def fun_eq_iff Abs_inverse Rep_inverse intro!: Rep)"], ["proof (state)\nthis:\n  BNF_Def.Grp A Abs ===> BNF_Def.Grp B g =\n  BNF_Def.Grp {f. f ` A \\<subseteq> B} (Rep ---> g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_set_Grp:\n  \"rel_set (BNF_Def.Grp A f) = BNF_Def.Grp {B. B \\<subseteq> A} (image f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_set (BNF_Def.Grp A f) = BNF_Def.Grp {B. B \\<subseteq> A} ((`) f)", "by(auto simp add: rel_set_def BNF_Def.Grp_def fun_eq_iff)"], ["", "lemma rel_set_comp_Grp:\n  \"rel_set R = (BNF_Def.Grp {x. x \\<subseteq> {(x, y). R x y}} ((`) fst))\\<inverse>\\<inverse> OO BNF_Def.Grp {x. x \\<subseteq> {(x, y). R x y}} ((`) snd)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_set R =\n    (BNF_Def.Grp {x. x \\<subseteq> {(x, y). R x y}}\n      ((`) fst))\\<inverse>\\<inverse> OO\n    BNF_Def.Grp {x. x \\<subseteq> {(x, y). R x y}} ((`) snd)", "apply(auto 4 4 del: ext intro!: ext simp add: BNF_Def.Grp_def intro!: rel_setI intro: rev_bexI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       rel_set R x xa \\<Longrightarrow>\n       ((\\<lambda>a b.\n            b = fst ` a \\<and>\n            a \\<subseteq> {(x, y). R x y})\\<inverse>\\<inverse> OO\n        (\\<lambda>a b. b = snd ` a \\<and> a \\<subseteq> {(x, y). R x y}))\n        x xa", "apply(simp add: relcompp_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       rel_set R x xa \\<Longrightarrow>\n       \\<exists>b.\n          x = fst ` b \\<and>\n          b \\<subseteq> {(x, y). R x y} \\<and>\n          xa = snd ` b \\<and> b \\<subseteq> {(x, y). R x y}", "subgoal for A B"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_set R A B \\<Longrightarrow>\n    \\<exists>b.\n       A = fst ` b \\<and>\n       b \\<subseteq> {(x, y). R x y} \\<and>\n       B = snd ` b \\<and> b \\<subseteq> {(x, y). R x y}", "apply(rule exI[where x=\"A \\<times> B \\<inter> {(x, y). R x y}\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_set R A B \\<Longrightarrow>\n    A = fst ` (A \\<times> B \\<inter> {(b, y). R b y}) \\<and>\n    A \\<times> B \\<inter> {(b, y). R b y} \\<subseteq> {(x, y). R x y} \\<and>\n    B = snd ` (A \\<times> B \\<inter> {(b, y). R b y}) \\<and>\n    A \\<times> B \\<inter> {(b, y). R b y} \\<subseteq> {(x, y). R x y}", "apply(auto 4 3 dest: rel_setD1 rel_setD2 intro: rev_image_eqI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Domainp_Grp: \"Domainp (BNF_Def.Grp A f) = (\\<lambda>x. x \\<in> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp (BNF_Def.Grp A f) = (\\<lambda>x. x \\<in> A)", "by(auto simp add: fun_eq_iff Grp_def)"], ["", "lemma pred_prod_conj [simp]:\n  shows pred_prod_conj1: \"\\<And>P Q R. pred_prod (\\<lambda>x. P x \\<and> Q x) R = (\\<lambda>x. pred_prod P R x \\<and> pred_prod Q R x)\"\n  and pred_prod_conj2: \"\\<And>P Q R. pred_prod P (\\<lambda>x. Q x \\<and> R x) = (\\<lambda>x. pred_prod P Q x \\<and> pred_prod P R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P Q R.\n        pred_prod (\\<lambda>x. P x \\<and> Q x) R =\n        (\\<lambda>x. pred_prod P R x \\<and> pred_prod Q R x)) &&&\n    (\\<And>P Q R.\n        pred_prod P (\\<lambda>x. Q x \\<and> R x) =\n        (\\<lambda>x. pred_prod P Q x \\<and> pred_prod P R x))", "by(auto simp add: pred_prod.simps)"], ["", "lemma pred_sum_conj [simp]:\n  shows pred_sum_conj1: \"\\<And>P Q R. pred_sum (\\<lambda>x. P x \\<and> Q x) R = (\\<lambda>x. pred_sum P R x \\<and> pred_sum Q R x)\"\n  and pred_sum_conj2: \"\\<And>P Q R. pred_sum P (\\<lambda>x. Q x \\<and> R x) = (\\<lambda>x. pred_sum P Q x \\<and> pred_sum P R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P Q R.\n        pred_sum (\\<lambda>x. P x \\<and> Q x) R =\n        (\\<lambda>x. pred_sum P R x \\<and> pred_sum Q R x)) &&&\n    (\\<And>P Q R.\n        pred_sum P (\\<lambda>x. Q x \\<and> R x) =\n        (\\<lambda>x. pred_sum P Q x \\<and> pred_sum P R x))", "by(auto simp add: pred_sum.simps fun_eq_iff)"], ["", "lemma pred_list_conj [simp]: \"list_all (\\<lambda>x. P x \\<and> Q x) = (\\<lambda>x. list_all P x \\<and> list_all Q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. P x \\<and> Q x) =\n    (\\<lambda>x. list_all P x \\<and> list_all Q x)", "by(auto simp add: list_all_def)"], ["", "lemma pred_prod_top [simp]:\n  \"pred_prod (\\<lambda>_. True) (\\<lambda>_. True) = (\\<lambda>_. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_prod (\\<lambda>_. True) (\\<lambda>_. True) = (\\<lambda>_. True)", "by(simp add: pred_prod.simps fun_eq_iff)"], ["", "lemma rel_fun_conversep: includes lifting_syntax shows\n  \"(A^--1 ===> B^--1) = (A ===> B)^--1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A\\<inverse>\\<inverse> ===> B\\<inverse>\\<inverse> =\n    (A ===> B)\\<inverse>\\<inverse>", "by(auto simp add: rel_fun_def fun_eq_iff)"], ["", "lemma left_unique_Grp [iff]:\n  \"left_unique (BNF_Def.Grp A f) \\<longleftrightarrow> inj_on f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_unique (BNF_Def.Grp A f) = inj_on f A", "unfolding Grp_def left_unique_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y z.\n        z = f x \\<and> x \\<in> A \\<longrightarrow>\n        z = f y \\<and> y \\<in> A \\<longrightarrow> x = y) =\n    inj_on f A", "by(auto simp add: inj_on_def)"], ["", "lemma right_unique_Grp [simp, intro!]: \"right_unique (BNF_Def.Grp A f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_unique (BNF_Def.Grp A f)", "by(simp add: Grp_def right_unique_def)"], ["", "lemma bi_unique_Grp [iff]:\n  \"bi_unique (BNF_Def.Grp A f) \\<longleftrightarrow> inj_on f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique (BNF_Def.Grp A f) = inj_on f A", "by(simp add: bi_unique_alt_def)"], ["", "lemma left_total_Grp [iff]:\n  \"left_total (BNF_Def.Grp A f) \\<longleftrightarrow> A = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_total (BNF_Def.Grp A f) = (A = UNIV)", "by(auto simp add: left_total_def Grp_def)"], ["", "lemma right_total_Grp [iff]:\n  \"right_total (BNF_Def.Grp A f) \\<longleftrightarrow> f ` A = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_total (BNF_Def.Grp A f) = (f ` A = UNIV)", "by(auto simp add: right_total_def BNF_Def.Grp_def image_def)"], ["", "lemma bi_total_Grp [iff]:\n  \"bi_total (BNF_Def.Grp A f) \\<longleftrightarrow> A = UNIV \\<and> surj f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_total (BNF_Def.Grp A f) = (A = UNIV \\<and> surj f)", "by(auto simp add: bi_total_alt_def)"], ["", "lemma left_unique_vimage2p [simp]:\n  \"\\<lbrakk> left_unique P; inj f \\<rbrakk> \\<Longrightarrow> left_unique (BNF_Def.vimage2p f g P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>left_unique P; inj f\\<rbrakk>\n    \\<Longrightarrow> left_unique (BNF_Def.vimage2p f g P)", "unfolding vimage2p_Grp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>left_unique P; inj f\\<rbrakk>\n    \\<Longrightarrow> left_unique\n                       (BNF_Def.Grp UNIV f OO\n                        P OO (BNF_Def.Grp UNIV g)\\<inverse>\\<inverse>)", "by(intro left_unique_OO) simp_all"], ["", "lemma right_unique_vimage2p [simp]:\n  \"\\<lbrakk> right_unique P; inj g \\<rbrakk> \\<Longrightarrow> right_unique (BNF_Def.vimage2p f g P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>right_unique P; inj g\\<rbrakk>\n    \\<Longrightarrow> right_unique (BNF_Def.vimage2p f g P)", "unfolding vimage2p_Grp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>right_unique P; inj g\\<rbrakk>\n    \\<Longrightarrow> right_unique\n                       (BNF_Def.Grp UNIV f OO\n                        P OO (BNF_Def.Grp UNIV g)\\<inverse>\\<inverse>)", "by(intro right_unique_OO) simp_all"], ["", "lemma bi_unique_vimage2p [simp]:\n  \"\\<lbrakk> bi_unique P; inj f; inj g \\<rbrakk> \\<Longrightarrow> bi_unique (BNF_Def.vimage2p f g P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bi_unique P; inj f; inj g\\<rbrakk>\n    \\<Longrightarrow> bi_unique (BNF_Def.vimage2p f g P)", "unfolding bi_unique_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>left_unique P \\<and> right_unique P; inj f; inj g\\<rbrakk>\n    \\<Longrightarrow> left_unique (BNF_Def.vimage2p f g P) \\<and>\n                      right_unique (BNF_Def.vimage2p f g P)", "by simp"], ["", "lemma left_total_vimage2p [simp]:\n  \"\\<lbrakk> left_total P; surj g \\<rbrakk> \\<Longrightarrow> left_total (BNF_Def.vimage2p f g P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>left_total P; surj g\\<rbrakk>\n    \\<Longrightarrow> left_total (BNF_Def.vimage2p f g P)", "unfolding vimage2p_Grp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>left_total P; surj g\\<rbrakk>\n    \\<Longrightarrow> left_total\n                       (BNF_Def.Grp UNIV f OO\n                        P OO (BNF_Def.Grp UNIV g)\\<inverse>\\<inverse>)", "by(intro left_total_OO) simp_all"], ["", "lemma right_total_vimage2p [simp]:\n  \"\\<lbrakk> right_total P; surj f \\<rbrakk> \\<Longrightarrow> right_total (BNF_Def.vimage2p f g P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>right_total P; surj f\\<rbrakk>\n    \\<Longrightarrow> right_total (BNF_Def.vimage2p f g P)", "unfolding vimage2p_Grp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>right_total P; surj f\\<rbrakk>\n    \\<Longrightarrow> right_total\n                       (BNF_Def.Grp UNIV f OO\n                        P OO (BNF_Def.Grp UNIV g)\\<inverse>\\<inverse>)", "by(intro right_total_OO) simp_all"], ["", "lemma bi_total_vimage2p [simp]:\n  \"\\<lbrakk> bi_total P; surj f; surj g \\<rbrakk> \\<Longrightarrow> bi_total (BNF_Def.vimage2p f g P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bi_total P; surj f; surj g\\<rbrakk>\n    \\<Longrightarrow> bi_total (BNF_Def.vimage2p f g P)", "unfolding bi_total_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>left_total P \\<and> right_total P; surj f; surj g\\<rbrakk>\n    \\<Longrightarrow> left_total (BNF_Def.vimage2p f g P) \\<and>\n                      right_total (BNF_Def.vimage2p f g P)", "by simp"], ["", "lemma vimage2p_eq [simp]:\n  \"inj f \\<Longrightarrow> BNF_Def.vimage2p f f (=) = (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj f \\<Longrightarrow> BNF_Def.vimage2p f f (=) = (=)", "by(auto simp add: vimage2p_def fun_eq_iff inj_on_def)"], ["", "lemma vimage2p_conversep: \"BNF_Def.vimage2p f g R^--1 = (BNF_Def.vimage2p g f R)^--1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BNF_Def.vimage2p f g R\\<inverse>\\<inverse> =\n    (BNF_Def.vimage2p g f R)\\<inverse>\\<inverse>", "by(simp add: vimage2p_def fun_eq_iff)"], ["", "lemma rel_fun_refl: \"\\<lbrakk> A \\<le> (=); (=) \\<le> B \\<rbrakk> \\<Longrightarrow> (=) \\<le> rel_fun A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<le> (=); (=) \\<le> B\\<rbrakk>\n    \\<Longrightarrow> (=) \\<le> rel_fun A B", "by(subst fun.rel_eq[symmetric])(rule fun_mono)"], ["", "lemma rel_fun_mono_strong:\n  \"\\<lbrakk> rel_fun A B f g; A' \\<le> A; \\<And>x y. \\<lbrakk> x \\<in> f ` {x. Domainp A' x}; y \\<in> g ` {x. Rangep A' x}; B x y \\<rbrakk> \\<Longrightarrow> B' x y \\<rbrakk> \\<Longrightarrow> rel_fun A' B' f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel_fun A B f g; A' \\<le> A;\n     \\<And>x y.\n        \\<lbrakk>x \\<in> f ` {x. Domainp A' x};\n         y \\<in> g ` {x. Rangep A' x}; B x y\\<rbrakk>\n        \\<Longrightarrow> B' x y\\<rbrakk>\n    \\<Longrightarrow> rel_fun A' B' f g", "by(auto simp add: rel_fun_def) fastforce"], ["", "lemma rel_fun_refl_strong: \n  assumes \"A \\<le> (=)\" \"\\<And>x. x \\<in> f ` {x. Domainp A x} \\<Longrightarrow> B x x\"\n  shows \"rel_fun A B f f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun A B f f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_fun A B f f", "have \"rel_fun (=) (=) f f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (=) (=) f f", "by(simp add: rel_fun_eq)"], ["proof (state)\nthis:\n  rel_fun (=) (=) f f\n\ngoal (1 subgoal):\n 1. rel_fun A B f f", "then"], ["proof (chain)\npicking this:\n  rel_fun (=) (=) f f", "show ?thesis"], ["proof (prove)\nusing this:\n  rel_fun (=) (=) f f\n\ngoal (1 subgoal):\n 1. rel_fun A B f f", "using assms(1)"], ["proof (prove)\nusing this:\n  rel_fun (=) (=) f f\n  A \\<le> (=)\n\ngoal (1 subgoal):\n 1. rel_fun A B f f", "by(rule rel_fun_mono_strong) (auto intro: assms(2))"], ["proof (state)\nthis:\n  rel_fun A B f f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Grp_iff: \"BNF_Def.Grp B g x y \\<longleftrightarrow> y = g x \\<and> x \\<in> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BNF_Def.Grp B g x y = (y = g x \\<and> x \\<in> B)", "by(simp add: Grp_def)"], ["", "lemma Rangep_Grp: \"Rangep (BNF_Def.Grp A f) = (\\<lambda>x. x \\<in> f ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rangep (BNF_Def.Grp A f) = (\\<lambda>x. x \\<in> f ` A)", "by(auto simp add: fun_eq_iff Grp_iff)"], ["", "lemma rel_fun_Grp:\n  \"rel_fun (BNF_Def.Grp UNIV h)\\<inverse>\\<inverse> (BNF_Def.Grp A g) = BNF_Def.Grp {f. f ` range h \\<subseteq> A} (map_fun h g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (BNF_Def.Grp UNIV h)\\<inverse>\\<inverse> (BNF_Def.Grp A g) =\n    BNF_Def.Grp {f. f ` range h \\<subseteq> A} (map_fun h g)", "by(auto simp add: rel_fun_def fun_eq_iff Grp_iff)"], ["", "subsection \\<open>Transfer and lifting material\\<close>"], ["", "context includes lifting_syntax begin"], ["", "lemma monotone_parametric [transfer_rule]:\n  assumes [transfer_rule]: \"bi_total A\"\n  shows \"((A ===> A ===> (=)) ===> (B ===> B ===> (=)) ===> (A ===> B) ===> (=)) monotone monotone\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> (=)) ===> (B ===> B ===> (=)) ===> (A ===> B) ===> (=))\n     monotone monotone", "unfolding monotone_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> (=)) ===> (B ===> B ===> (=)) ===> (A ===> B) ===> (=))\n     (\\<lambda>orda ordb f.\n         \\<forall>x y. orda x y \\<longrightarrow> ordb (f x) (f y))\n     (\\<lambda>orda ordb f.\n         \\<forall>x y. orda x y \\<longrightarrow> ordb (f x) (f y))", "by transfer_prover"], ["", "lemma fun_ord_parametric [transfer_rule]:\n  assumes [transfer_rule]: \"bi_total C\"\n  shows \"((A ===> B ===> (=)) ===> (C ===> A) ===> (C ===> B) ===> (=)) fun_ord fun_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> B ===> (=)) ===> (C ===> A) ===> (C ===> B) ===> (=)) fun_ord\n     fun_ord", "unfolding fun_ord_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> B ===> (=)) ===> (C ===> A) ===> (C ===> B) ===> (=))\n     (\\<lambda>ord f g. \\<forall>x. ord (f x) (g x))\n     (\\<lambda>ord f g. \\<forall>x. ord (f x) (g x))", "by transfer_prover"], ["", "lemma Plus_parametric [transfer_rule]:\n  \"(rel_set A ===> rel_set B ===> rel_set (rel_sum A B)) (<+>) (<+>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> rel_set B ===> rel_set (rel_sum A B)) (<+>) (<+>)", "unfolding Plus_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> rel_set B ===> rel_set (rel_sum A B))\n     (\\<lambda>A B. Inl ` A \\<union> Inr ` B)\n     (\\<lambda>A B. Inl ` A \\<union> Inr ` B)", "by transfer_prover"], ["", "lemma pred_fun_parametric [transfer_rule]:\n  assumes [transfer_rule]: \"bi_total A\"\n  shows \"((A ===> (=)) ===> (B ===> (=)) ===> (A ===> B) ===> (=)) pred_fun pred_fun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> (=)) ===> (B ===> (=)) ===> (A ===> B) ===> (=)) pred_fun\n     pred_fun", "unfolding pred_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> (=)) ===> (B ===> (=)) ===> (A ===> B) ===> (=))\n     (\\<lambda>A B f. \\<forall>x. A x \\<longrightarrow> B (f x))\n     (\\<lambda>A B f. \\<forall>x. A x \\<longrightarrow> B (f x))", "by(transfer_prover)"], ["", "lemma rel_fun_eq_OO: \"((=) ===> A) OO ((=) ===> B) = ((=) ===> A OO B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> A) OO ((=) ===> B) = (=) ===> A OO B", "by(clarsimp simp add: rel_fun_def fun_eq_iff relcompp.simps) metis"], ["", "end"], ["", "lemma Quotient_set_rel_eq:\n  includes lifting_syntax\n  assumes \"Quotient R Abs Rep T\"\n  shows \"(rel_set T ===> rel_set T ===> (=)) (rel_set R) (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set T ===> rel_set T ===> (=)) (rel_set R) (=)", "proof(rule rel_funI iffI)+"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set T x y; rel_set T xa ya; rel_set R x xa\\<rbrakk>\n       \\<Longrightarrow> y = ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>rel_set T x y; rel_set T xa ya; y = ya\\<rbrakk>\n       \\<Longrightarrow> rel_set R x xa", "fix A B C D"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set T x y; rel_set T xa ya; rel_set R x xa\\<rbrakk>\n       \\<Longrightarrow> y = ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>rel_set T x y; rel_set T xa ya; y = ya\\<rbrakk>\n       \\<Longrightarrow> rel_set R x xa", "assume AB: \"rel_set T A B\" and CD: \"rel_set T C D\""], ["proof (state)\nthis:\n  rel_set T A B\n  rel_set T C D\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set T x y; rel_set T xa ya; rel_set R x xa\\<rbrakk>\n       \\<Longrightarrow> y = ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>rel_set T x y; rel_set T xa ya; y = ya\\<rbrakk>\n       \\<Longrightarrow> rel_set R x xa", "have *: \"\\<And>x y. R x y = (T x (Abs x) \\<and> T y (Abs y) \\<and> Abs x = Abs y)\"\n    \"\\<And>a b. T a b \\<Longrightarrow> Abs a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        R x y = (T x (Abs x) \\<and> T y (Abs y) \\<and> Abs x = Abs y)) &&&\n    (\\<And>a b. T a b \\<Longrightarrow> Abs a = b)", "using assms"], ["proof (prove)\nusing this:\n  Quotient R Abs Rep T\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        R x y = (T x (Abs x) \\<and> T y (Abs y) \\<and> Abs x = Abs y)) &&&\n    (\\<And>a b. T a b \\<Longrightarrow> Abs a = b)", "unfolding Quotient_alt_def"], ["proof (prove)\nusing this:\n  (\\<forall>a b. T a b \\<longrightarrow> Abs a = b) \\<and>\n  (\\<forall>b. T (Rep b) b) \\<and>\n  (\\<forall>x y.\n      R x y = (T x (Abs x) \\<and> T y (Abs y) \\<and> Abs x = Abs y))\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        R x y = (T x (Abs x) \\<and> T y (Abs y) \\<and> Abs x = Abs y)) &&&\n    (\\<And>a b. T a b \\<Longrightarrow> Abs a = b)", "by simp_all"], ["proof (state)\nthis:\n  R ?x ?y = (T ?x (Abs ?x) \\<and> T ?y (Abs ?y) \\<and> Abs ?x = Abs ?y)\n  T ?a ?b \\<Longrightarrow> Abs ?a = ?b\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set T x y; rel_set T xa ya; rel_set R x xa\\<rbrakk>\n       \\<Longrightarrow> y = ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>rel_set T x y; rel_set T xa ya; y = ya\\<rbrakk>\n       \\<Longrightarrow> rel_set R x xa", "{"], ["proof (state)\nthis:\n  R ?x ?y = (T ?x (Abs ?x) \\<and> T ?y (Abs ?y) \\<and> Abs ?x = Abs ?y)\n  T ?a ?b \\<Longrightarrow> Abs ?a = ?b\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set T x y; rel_set T xa ya; rel_set R x xa\\<rbrakk>\n       \\<Longrightarrow> y = ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>rel_set T x y; rel_set T xa ya; y = ya\\<rbrakk>\n       \\<Longrightarrow> rel_set R x xa", "assume [simp]: \"B = D\""], ["proof (state)\nthis:\n  B = D\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set T x y; rel_set T xa ya; rel_set R x xa\\<rbrakk>\n       \\<Longrightarrow> y = ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>rel_set T x y; rel_set T xa ya; y = ya\\<rbrakk>\n       \\<Longrightarrow> rel_set R x xa", "thus \"rel_set R A C\""], ["proof (prove)\nusing this:\n  B = D\n\ngoal (1 subgoal):\n 1. rel_set R A C", "by(auto 4 4 intro!: rel_setI dest: rel_setD1[OF AB, simplified] rel_setD2[OF AB, simplified] rel_setD2[OF CD] rel_setD1[OF CD] simp add: * elim!: rev_bexI)"], ["proof (state)\nthis:\n  rel_set R A C\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set T x y; rel_set T xa ya; rel_set R x xa\\<rbrakk>\n       \\<Longrightarrow> y = ya", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set T x y; rel_set T xa ya; rel_set R x xa\\<rbrakk>\n       \\<Longrightarrow> y = ya", "assume AC: \"rel_set R A C\""], ["proof (state)\nthis:\n  rel_set R A C\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set T x y; rel_set T xa ya; rel_set R x xa\\<rbrakk>\n       \\<Longrightarrow> y = ya", "show \"B = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = D", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> B \\<Longrightarrow> x \\<in> D\n 2. \\<And>x. x \\<in> D \\<Longrightarrow> x \\<in> B", "apply(drule rel_setD2[OF AB], erule bexE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; T xa x\\<rbrakk> \\<Longrightarrow> x \\<in> D\n 2. \\<And>x. x \\<in> D \\<Longrightarrow> x \\<in> B", "apply(drule rel_setD1[OF AC], erule bexE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa y.\n       \\<lbrakk>T xa x; y \\<in> C; R xa y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> D\n 2. \\<And>x. x \\<in> D \\<Longrightarrow> x \\<in> B", "apply(drule rel_setD1[OF CD], erule bexE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa y ya.\n       \\<lbrakk>T xa x; R xa y; ya \\<in> D; T y ya\\<rbrakk>\n       \\<Longrightarrow> x \\<in> D\n 2. \\<And>x. x \\<in> D \\<Longrightarrow> x \\<in> B", "apply(simp add: *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> D \\<Longrightarrow> x \\<in> B", "apply(drule rel_setD2[OF CD], erule bexE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> C; T xa x\\<rbrakk> \\<Longrightarrow> x \\<in> B", "apply(drule rel_setD2[OF AC], erule bexE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>T xa x; xb \\<in> A; R xb xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> B", "apply(drule rel_setD1[OF AB], erule bexE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb y.\n       \\<lbrakk>T xa x; R xb xa; y \\<in> B; T xb y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> B", "apply(simp add: *)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  B = D\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  rel_set R A C \\<Longrightarrow> B = D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Domainp_eq: \"Domainp (=) = (\\<lambda>_. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp (=) = (\\<lambda>_. True)", "by(simp add: Domainp.simps fun_eq_iff)"], ["", "lemma rel_fun_eq_onpI: \"eq_onp (pred_fun P Q) f g \\<Longrightarrow> rel_fun (eq_onp P) (eq_onp Q) f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_onp (pred_fun P Q) f g \\<Longrightarrow>\n    rel_fun (eq_onp P) (eq_onp Q) f g", "by(auto simp add: eq_onp_def rel_fun_def)"], ["", "lemma bi_unique_eq_onp: \"bi_unique (eq_onp P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique (eq_onp P)", "by(simp add: bi_unique_def eq_onp_def)"], ["", "lemma rel_fun_eq_conversep: includes lifting_syntax shows \"(A\\<inverse>\\<inverse> ===> (=)) = (A ===> (=))\\<inverse>\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A\\<inverse>\\<inverse> ===> (=) = (A ===> (=))\\<inverse>\\<inverse>", "by(auto simp add: fun_eq_iff rel_fun_def)"], ["", "lemma rel_fun_comp:\n  \"\\<And>f g h. rel_fun A B (f \\<circ> g) h = rel_fun A (\\<lambda>x. B (f x)) g h\"\n  \"\\<And>f g h. rel_fun A B f (g \\<circ> h) = rel_fun A (\\<lambda>x y. B x (g y)) f h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f g h.\n        rel_fun A B (f \\<circ> g) h =\n        rel_fun A (\\<lambda>x. B (f x)) g h) &&&\n    (\\<And>f g h.\n        rel_fun A B f (g \\<circ> h) =\n        rel_fun A (\\<lambda>x y. B x (g y)) f h)", "by(auto simp add: rel_fun_def)"], ["", "lemma rel_fun_map_fun1: \"rel_fun (BNF_Def.Grp UNIV h)\\<inverse>\\<inverse> A f g \\<Longrightarrow> rel_fun (=) A (map_fun h id f) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (BNF_Def.Grp UNIV h)\\<inverse>\\<inverse> A f g \\<Longrightarrow>\n    rel_fun (=) A (map_fun h id f) g", "by(auto simp add: rel_fun_def Grp_def)"], ["", "lemma map_fun2_id: \"map_fun f g x = g \\<circ> map_fun f id x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_fun f g x = g \\<circ> map_fun f id x", "by(simp add: map_fun_def o_assoc)"], ["", "lemma map_fun_id2_in: \"map_fun g h f = map_fun g id (h \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_fun g h f = map_fun g id (h \\<circ> f)", "by(simp add: map_fun_def)"], ["", "lemma Domainp_rel_fun_le: \"Domainp (rel_fun A B) \\<le> pred_fun (Domainp A) (Domainp B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp (rel_fun A B) \\<le> pred_fun (Domainp A) (Domainp B)", "by(auto dest: rel_funD)"], ["", "definition rel_witness_fun :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('b \\<Rightarrow> 'c \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<times> ('c \\<Rightarrow> 'e) \\<Rightarrow> ('b \\<Rightarrow> 'd \\<times> 'e)\" where\n  \"rel_witness_fun A A' = (\\<lambda>(f, g) b. (f (THE a. A a b), g (THE c. A' b c)))\""], ["", "lemma\n  assumes fg: \"rel_fun (A OO A') B f g\"\n    and A: \"left_unique A\" \"right_total A\"\n    and A': \"right_unique A'\" \"left_total A'\"\n  shows rel_witness_fun1: \"rel_fun A (\\<lambda>x (x', y). x = x' \\<and> B x' y) f (rel_witness_fun A A' (f, g))\"\n    and rel_witness_fun2: \"rel_fun A' (\\<lambda>(x, y') y. y = y' \\<and> B x y') (rel_witness_fun A A' (f, g)) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun A (\\<lambda>x (x', y). x = x' \\<and> B x' y) f\n     (rel_witness_fun A A' (f, g)) &&&\n    rel_fun A' (\\<lambda>(x, y') y. y = y' \\<and> B x y')\n     (rel_witness_fun A A' (f, g)) g", "proof (goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. rel_fun A (\\<lambda>x (x', y). x = x' \\<and> B x' y) f\n     (rel_witness_fun A A' (f, g))\n 2. rel_fun A' (\\<lambda>(x, y') y. y = y' \\<and> B x y')\n     (rel_witness_fun A A' (f, g)) g", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. rel_fun A (\\<lambda>x (x', y). x = x' \\<and> B x' y) f\n     (rel_witness_fun A A' (f, g))\n 2. rel_fun A' (\\<lambda>(x, y') y. y = y' \\<and> B x y')\n     (rel_witness_fun A A' (f, g)) g", "have \"A x y \\<Longrightarrow> f x = f (THE a. A a y) \\<and> B (f (THE a. A a y)) (g (The (A' y)))\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. A x y \\<Longrightarrow>\n    f x = f (THE a. A a y) \\<and> B (f (THE a. A a y)) (g (The (A' y)))", "by(rule left_totalE[OF A'(2)]; erule meta_allE[of _ y]; erule exE; frule (1) fg[THEN rel_funD, OF relcomppI])\n      (auto intro!: arg_cong[where f=f] arg_cong[where f=g] rel_funI the_equality the_equality[symmetric] dest: left_uniqueD[OF A(1)] right_uniqueD[OF A'(1)] elim!: arg_cong2[where f=B, THEN iffD2, rotated -1])"], ["proof (state)\nthis:\n  A ?x ?y \\<Longrightarrow>\n  f ?x = f (THE a. A a ?y) \\<and> B (f (THE a. A a ?y)) (g (The (A' ?y)))\n\ngoal (2 subgoals):\n 1. rel_fun A (\\<lambda>x (x', y). x = x' \\<and> B x' y) f\n     (rel_witness_fun A A' (f, g))\n 2. rel_fun A' (\\<lambda>(x, y') y. y = y' \\<and> B x y')\n     (rel_witness_fun A A' (f, g)) g", "with 1"], ["proof (chain)\npicking this:\n  A ?x ?y \\<Longrightarrow>\n  f ?x = f (THE a. A a ?y) \\<and> B (f (THE a. A a ?y)) (g (The (A' ?y)))", "show ?case"], ["proof (prove)\nusing this:\n  A ?x ?y \\<Longrightarrow>\n  f ?x = f (THE a. A a ?y) \\<and> B (f (THE a. A a ?y)) (g (The (A' ?y)))\n\ngoal (1 subgoal):\n 1. rel_fun A (\\<lambda>x (x', y). x = x' \\<and> B x' y) f\n     (rel_witness_fun A A' (f, g))", "by(clarsimp simp add: rel_fun_def rel_witness_fun_def)"], ["proof (state)\nthis:\n  rel_fun A (\\<lambda>x (x', y). x = x' \\<and> B x' y) f\n   (rel_witness_fun A A' (f, g))\n\ngoal (1 subgoal):\n 1. rel_fun A' (\\<lambda>(x, y') y. y = y' \\<and> B x y')\n     (rel_witness_fun A A' (f, g)) g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_fun A' (\\<lambda>(x, y') y. y = y' \\<and> B x y')\n     (rel_witness_fun A A' (f, g)) g", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. rel_fun A' (\\<lambda>(x, y') y. y = y' \\<and> B x y')\n     (rel_witness_fun A A' (f, g)) g", "have \"A' x y \\<Longrightarrow> g y = g (The (A' x)) \\<and> B (f (THE a. A a x)) (g (The (A' x)))\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. A' x y \\<Longrightarrow>\n    g y = g (The (A' x)) \\<and> B (f (THE a. A a x)) (g (The (A' x)))", "by(rule right_totalE[OF A(2), of x]; frule (1) fg[THEN rel_funD, OF relcomppI])\n      (auto intro!: arg_cong[where f=f] arg_cong[where f=g] rel_funI the_equality the_equality[symmetric] dest: left_uniqueD[OF A(1)] right_uniqueD[OF A'(1)] elim!: arg_cong2[where f=B, THEN iffD2, rotated -1])"], ["proof (state)\nthis:\n  A' ?x ?y \\<Longrightarrow>\n  g ?y = g (The (A' ?x)) \\<and> B (f (THE a. A a ?x)) (g (The (A' ?x)))\n\ngoal (1 subgoal):\n 1. rel_fun A' (\\<lambda>(x, y') y. y = y' \\<and> B x y')\n     (rel_witness_fun A A' (f, g)) g", "with 2"], ["proof (chain)\npicking this:\n  A' ?x ?y \\<Longrightarrow>\n  g ?y = g (The (A' ?x)) \\<and> B (f (THE a. A a ?x)) (g (The (A' ?x)))", "show ?case"], ["proof (prove)\nusing this:\n  A' ?x ?y \\<Longrightarrow>\n  g ?y = g (The (A' ?x)) \\<and> B (f (THE a. A a ?x)) (g (The (A' ?x)))\n\ngoal (1 subgoal):\n 1. rel_fun A' (\\<lambda>(x, y') y. y = y' \\<and> B x y')\n     (rel_witness_fun A A' (f, g)) g", "by(clarsimp simp add: rel_fun_def rel_witness_fun_def)"], ["proof (state)\nthis:\n  rel_fun A' (\\<lambda>(x, y') y. y = y' \\<and> B x y')\n   (rel_witness_fun A A' (f, g)) g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_witness_fun_eq [simp]: \"rel_witness_fun (=) (=) (f, g) = (\\<lambda>x. (f x, g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_witness_fun (=) (=) (f, g) = (\\<lambda>x. (f x, g x))", "by(simp add: rel_witness_fun_def)"], ["", "subsection \\<open>Arithmetic\\<close>"], ["", "lemma abs_diff_triangle_ineq2: \"\\<bar>a - b :: _ :: ordered_ab_group_add_abs\\<bar> \\<le> \\<bar>a - c\\<bar> + \\<bar>c - b\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>a - b\\<bar> \\<le> \\<bar>a - c\\<bar> + \\<bar>c - b\\<bar>", "by(rule order_trans[OF _ abs_diff_triangle_ineq]) simp"], ["", "lemma (in ordered_ab_semigroup_add) add_left_mono_trans:\n  \"\\<lbrakk> x \\<le> a + b; b \\<le> c \\<rbrakk> \\<Longrightarrow> x \\<le> a + c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> a + b; b \\<le> c\\<rbrakk>\n    \\<Longrightarrow> x \\<le> a + c", "by(erule order_trans)(rule add_left_mono)"], ["", "lemma of_nat_le_one_cancel_iff [simp]:\n  fixes n :: nat shows \"real n \\<le> 1 \\<longleftrightarrow> n \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (real n \\<le> 1) = (n \\<le> 1)", "by linarith"], ["", "lemma (in linordered_semidom) mult_right_le: \"c \\<le> 1 \\<Longrightarrow> 0 \\<le> a \\<Longrightarrow> c * a \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<le> (1::'a); (0::'a) \\<le> a\\<rbrakk>\n    \\<Longrightarrow> c * a \\<le> a", "by(subst mult.commute)(rule mult_left_le)"], ["", "subsection \\<open>Chain-complete partial orders and \\<open>partial_function\\<close>\\<close>"], ["", "lemma fun_ordD: \"fun_ord ord f g \\<Longrightarrow> ord (f x) (g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_ord ord f g \\<Longrightarrow> ord (f x) (g x)", "by(simp add: fun_ord_def)"], ["", "lemma parallel_fixp_induct_strong:\n  assumes ccpo1: \"class.ccpo luba orda (mk_less orda)\"\n  and ccpo2: \"class.ccpo lubb ordb (mk_less ordb)\"\n  and adm: \"ccpo.admissible (prod_lub luba lubb) (rel_prod orda ordb) (\\<lambda>x. P (fst x) (snd x))\"\n  and f: \"monotone orda orda f\"\n  and g: \"monotone ordb ordb g\"\n  and bot: \"P (luba {}) (lubb {})\"\n  and step: \"\\<And>x y. \\<lbrakk> orda x (ccpo.fixp luba orda f); ordb y (ccpo.fixp lubb ordb g); P x y \\<rbrakk> \\<Longrightarrow> P (f x) (g y)\"\n  shows \"P (ccpo.fixp luba orda f) (ccpo.fixp lubb ordb g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (ccpo.fixp luba orda f) (ccpo.fixp lubb ordb g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P (ccpo.fixp luba orda f) (ccpo.fixp lubb ordb g)", "let ?P=\"\\<lambda>x y. orda x (ccpo.fixp luba orda f) \\<and> ordb y (ccpo.fixp lubb ordb g) \\<and> P x y\""], ["proof (state)\ngoal (1 subgoal):\n 1. P (ccpo.fixp luba orda f) (ccpo.fixp lubb ordb g)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (ccpo.fixp luba orda f) (ccpo.fixp lubb ordb g)", "using ccpo1 ccpo2 _ f g"], ["proof (prove)\nusing this:\n  class.ccpo luba orda (mk_less orda)\n  class.ccpo lubb ordb (mk_less ordb)\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  monotone orda orda f\n  monotone ordb ordb g\n\ngoal (1 subgoal):\n 1. P (ccpo.fixp luba orda f) (ccpo.fixp lubb ordb g)", "proof(rule parallel_fixp_induct[where P=\"?P\", THEN conjunct2, THEN conjunct2])"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub luba lubb) (rel_prod orda ordb)\n     (\\<lambda>x.\n         orda (fst x) (ccpo.fixp luba orda f) \\<and>\n         ordb (snd x) (ccpo.fixp lubb ordb g) \\<and> P (fst x) (snd x))\n 2. orda (luba {}) (ccpo.fixp luba orda f) \\<and>\n    ordb (lubb {}) (ccpo.fixp lubb ordb g) \\<and> P (luba {}) (lubb {})\n 3. \\<And>x y.\n       orda x (ccpo.fixp luba orda f) \\<and>\n       ordb y (ccpo.fixp lubb ordb g) \\<and> P x y \\<Longrightarrow>\n       orda (f x) (ccpo.fixp luba orda f) \\<and>\n       ordb (g y) (ccpo.fixp lubb ordb g) \\<and> P (f x) (g y)", "note [cont_intro] = \n      admissible_leI[OF ccpo1] ccpo.mcont_const[OF ccpo1]\n      admissible_leI[OF ccpo2] ccpo.mcont_const[OF ccpo2]"], ["proof (state)\nthis:\n  \\<lbrakk>mcont ?luba ?orda luba orda ?f;\n   mcont ?luba ?orda luba orda ?g\\<rbrakk>\n  \\<Longrightarrow> ccpo.admissible ?luba ?orda\n                     (\\<lambda>x. orda (?f x) (?g x))\n  mcont ?luba ?orda luba orda (\\<lambda>x. ?c)\n  \\<lbrakk>mcont ?luba ?orda lubb ordb ?f;\n   mcont ?luba ?orda lubb ordb ?g\\<rbrakk>\n  \\<Longrightarrow> ccpo.admissible ?luba ?orda\n                     (\\<lambda>x. ordb (?f x) (?g x))\n  mcont ?luba ?orda lubb ordb (\\<lambda>x. ?c)\n\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub luba lubb) (rel_prod orda ordb)\n     (\\<lambda>x.\n         orda (fst x) (ccpo.fixp luba orda f) \\<and>\n         ordb (snd x) (ccpo.fixp lubb ordb g) \\<and> P (fst x) (snd x))\n 2. orda (luba {}) (ccpo.fixp luba orda f) \\<and>\n    ordb (lubb {}) (ccpo.fixp lubb ordb g) \\<and> P (luba {}) (lubb {})\n 3. \\<And>x y.\n       orda x (ccpo.fixp luba orda f) \\<and>\n       ordb y (ccpo.fixp lubb ordb g) \\<and> P x y \\<Longrightarrow>\n       orda (f x) (ccpo.fixp luba orda f) \\<and>\n       ordb (g y) (ccpo.fixp lubb ordb g) \\<and> P (f x) (g y)", "show \"ccpo.admissible (prod_lub luba lubb) (rel_prod orda ordb) (\\<lambda>xy. ?P (fst xy) (snd xy))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible (prod_lub luba lubb) (rel_prod orda ordb)\n     (\\<lambda>xy.\n         orda (fst xy) (ccpo.fixp luba orda f) \\<and>\n         ordb (snd xy) (ccpo.fixp lubb ordb g) \\<and> P (fst xy) (snd xy))", "using adm"], ["proof (prove)\nusing this:\n  ccpo.admissible (prod_lub luba lubb) (rel_prod orda ordb)\n   (\\<lambda>x. P (fst x) (snd x))\n\ngoal (1 subgoal):\n 1. ccpo.admissible (prod_lub luba lubb) (rel_prod orda ordb)\n     (\\<lambda>xy.\n         orda (fst xy) (ccpo.fixp luba orda f) \\<and>\n         ordb (snd xy) (ccpo.fixp lubb ordb g) \\<and> P (fst xy) (snd xy))", "by simp"], ["proof (state)\nthis:\n  ccpo.admissible (prod_lub luba lubb) (rel_prod orda ordb)\n   (\\<lambda>xy.\n       orda (fst xy) (ccpo.fixp luba orda f) \\<and>\n       ordb (snd xy) (ccpo.fixp lubb ordb g) \\<and> P (fst xy) (snd xy))\n\ngoal (2 subgoals):\n 1. orda (luba {}) (ccpo.fixp luba orda f) \\<and>\n    ordb (lubb {}) (ccpo.fixp lubb ordb g) \\<and> P (luba {}) (lubb {})\n 2. \\<And>x y.\n       orda x (ccpo.fixp luba orda f) \\<and>\n       ordb y (ccpo.fixp lubb ordb g) \\<and> P x y \\<Longrightarrow>\n       orda (f x) (ccpo.fixp luba orda f) \\<and>\n       ordb (g y) (ccpo.fixp lubb ordb g) \\<and> P (f x) (g y)", "show \"?P (luba {}) (lubb {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orda (luba {}) (ccpo.fixp luba orda f) \\<and>\n    ordb (lubb {}) (ccpo.fixp lubb ordb g) \\<and> P (luba {}) (lubb {})", "using bot"], ["proof (prove)\nusing this:\n  P (luba {}) (lubb {})\n\ngoal (1 subgoal):\n 1. orda (luba {}) (ccpo.fixp luba orda f) \\<and>\n    ordb (lubb {}) (ccpo.fixp lubb ordb g) \\<and> P (luba {}) (lubb {})", "by(auto intro: ccpo.ccpo_Sup_least ccpo1 ccpo2 chain_empty)"], ["proof (state)\nthis:\n  orda (luba {}) (ccpo.fixp luba orda f) \\<and>\n  ordb (lubb {}) (ccpo.fixp lubb ordb g) \\<and> P (luba {}) (lubb {})\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       orda x (ccpo.fixp luba orda f) \\<and>\n       ordb y (ccpo.fixp lubb ordb g) \\<and> P x y \\<Longrightarrow>\n       orda (f x) (ccpo.fixp luba orda f) \\<and>\n       ordb (g y) (ccpo.fixp lubb ordb g) \\<and> P (f x) (g y)", "show \"?P (f x) (g y)\" if \"?P x y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. orda (f x) (ccpo.fixp luba orda f) \\<and>\n    ordb (g y) (ccpo.fixp lubb ordb g) \\<and> P (f x) (g y)", "using that"], ["proof (prove)\nusing this:\n  orda x (ccpo.fixp luba orda f) \\<and>\n  ordb y (ccpo.fixp lubb ordb g) \\<and> P x y\n\ngoal (1 subgoal):\n 1. orda (f x) (ccpo.fixp luba orda f) \\<and>\n    ordb (g y) (ccpo.fixp lubb ordb g) \\<and> P (f x) (g y)", "apply(subst ccpo.fixp_unfold[OF ccpo1 f])"], ["proof (prove)\ngoal (1 subgoal):\n 1. orda x (ccpo.fixp luba orda f) \\<and>\n    ordb y (ccpo.fixp lubb ordb g) \\<and> P x y \\<Longrightarrow>\n    orda (f x) (f (ccpo.fixp luba orda f)) \\<and>\n    ordb (g y) (ccpo.fixp lubb ordb g) \\<and> P (f x) (g y)", "apply(subst ccpo.fixp_unfold[OF ccpo2 g])"], ["proof (prove)\ngoal (1 subgoal):\n 1. orda x (ccpo.fixp luba orda f) \\<and>\n    ordb y (ccpo.fixp lubb ordb g) \\<and> P x y \\<Longrightarrow>\n    orda (f x) (f (ccpo.fixp luba orda f)) \\<and>\n    ordb (g y) (g (ccpo.fixp lubb ordb g)) \\<and> P (f x) (g y)", "apply(auto intro: step monotoneD[OF f] monotoneD[OF g])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  orda ?x (ccpo.fixp luba orda f) \\<and>\n  ordb ?y (ccpo.fixp lubb ordb g) \\<and> P ?x ?y \\<Longrightarrow>\n  orda (f ?x) (ccpo.fixp luba orda f) \\<and>\n  ordb (g ?y) (ccpo.fixp lubb ordb g) \\<and> P (f ?x) (g ?y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (ccpo.fixp luba orda f) (ccpo.fixp lubb ordb g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma parallel_fixp_induct_strong_uc:\n  assumes a: \"partial_function_definitions orda luba\"\n  and b: \"partial_function_definitions ordb lubb\"\n  and F: \"\\<And>x. monotone (fun_ord orda) orda (\\<lambda>f. U1 (F (C1 f)) x)\"\n  and G: \"\\<And>y. monotone (fun_ord ordb) ordb (\\<lambda>g. U2 (G (C2 g)) y)\"\n  and eq1: \"f \\<equiv> C1 (ccpo.fixp (fun_lub luba) (fun_ord orda) (\\<lambda>f. U1 (F (C1 f))))\"\n  and eq2: \"g \\<equiv> C2 (ccpo.fixp (fun_lub lubb) (fun_ord ordb) (\\<lambda>g. U2 (G (C2 g))))\"\n  and inverse: \"\\<And>f. U1 (C1 f) = f\"\n  and inverse2: \"\\<And>g. U2 (C2 g) = g\"\n  and adm: \"ccpo.admissible (prod_lub (fun_lub luba) (fun_lub lubb)) (rel_prod (fun_ord orda) (fun_ord ordb)) (\\<lambda>x. P (fst x) (snd x))\"\n  and bot: \"P (\\<lambda>_. luba {}) (\\<lambda>_. lubb {})\"\n  and step: \"\\<And>f' g'. \\<lbrakk> \\<And>x. orda (U1 f' x) (U1 f x); \\<And>y. ordb (U2 g' y) (U2 g y); P (U1 f') (U2 g') \\<rbrakk> \\<Longrightarrow> P (U1 (F f')) (U2 (G g'))\"\n  shows \"P (U1 f) (U2 g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (U1 f) (U2 g)", "apply(unfold eq1 eq2 inverse inverse2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (ccpo.fixp (fun_lub luba) (fun_ord orda) (\\<lambda>f. U1 (F (C1 f))))\n     (ccpo.fixp (fun_lub lubb) (fun_ord ordb) (\\<lambda>g. U2 (G (C2 g))))", "apply(rule parallel_fixp_induct_strong[OF partial_function_definitions.ccpo[OF a] partial_function_definitions.ccpo[OF b] adm])"], ["proof (prove)\ngoal (4 subgoals):\n 1. monotone (fun_ord orda) (fun_ord orda) (\\<lambda>f. U1 (F (C1 f)))\n 2. monotone (fun_ord ordb) (fun_ord ordb) (\\<lambda>g. U2 (G (C2 g)))\n 3. P (fun_lub luba {}) (fun_lub lubb {})\n 4. \\<And>x y.\n       \\<lbrakk>fun_ord orda x\n                 (ccpo.fixp (fun_lub luba) (fun_ord orda)\n                   (\\<lambda>f. U1 (F (C1 f))));\n        fun_ord ordb y\n         (ccpo.fixp (fun_lub lubb) (fun_ord ordb)\n           (\\<lambda>g. U2 (G (C2 g))));\n        P x y\\<rbrakk>\n       \\<Longrightarrow> P (U1 (F (C1 x))) (U2 (G (C2 y)))", "using F"], ["proof (prove)\nusing this:\n  monotone (fun_ord orda) orda (\\<lambda>f. U1 (F (C1 f)) ?x)\n\ngoal (4 subgoals):\n 1. monotone (fun_ord orda) (fun_ord orda) (\\<lambda>f. U1 (F (C1 f)))\n 2. monotone (fun_ord ordb) (fun_ord ordb) (\\<lambda>g. U2 (G (C2 g)))\n 3. P (fun_lub luba {}) (fun_lub lubb {})\n 4. \\<And>x y.\n       \\<lbrakk>fun_ord orda x\n                 (ccpo.fixp (fun_lub luba) (fun_ord orda)\n                   (\\<lambda>f. U1 (F (C1 f))));\n        fun_ord ordb y\n         (ccpo.fixp (fun_lub lubb) (fun_ord ordb)\n           (\\<lambda>g. U2 (G (C2 g))));\n        P x y\\<rbrakk>\n       \\<Longrightarrow> P (U1 (F (C1 x))) (U2 (G (C2 y)))", "apply(simp add: monotone_def fun_ord_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. monotone (fun_ord ordb) (fun_ord ordb) (\\<lambda>g. U2 (G (C2 g)))\n 2. P (fun_lub luba {}) (fun_lub lubb {})\n 3. \\<And>x y.\n       \\<lbrakk>fun_ord orda x\n                 (ccpo.fixp (fun_lub luba) (fun_ord orda)\n                   (\\<lambda>f. U1 (F (C1 f))));\n        fun_ord ordb y\n         (ccpo.fixp (fun_lub lubb) (fun_ord ordb)\n           (\\<lambda>g. U2 (G (C2 g))));\n        P x y\\<rbrakk>\n       \\<Longrightarrow> P (U1 (F (C1 x))) (U2 (G (C2 y)))", "using G"], ["proof (prove)\nusing this:\n  monotone (fun_ord ordb) ordb (\\<lambda>g. U2 (G (C2 g)) ?y)\n\ngoal (3 subgoals):\n 1. monotone (fun_ord ordb) (fun_ord ordb) (\\<lambda>g. U2 (G (C2 g)))\n 2. P (fun_lub luba {}) (fun_lub lubb {})\n 3. \\<And>x y.\n       \\<lbrakk>fun_ord orda x\n                 (ccpo.fixp (fun_lub luba) (fun_ord orda)\n                   (\\<lambda>f. U1 (F (C1 f))));\n        fun_ord ordb y\n         (ccpo.fixp (fun_lub lubb) (fun_ord ordb)\n           (\\<lambda>g. U2 (G (C2 g))));\n        P x y\\<rbrakk>\n       \\<Longrightarrow> P (U1 (F (C1 x))) (U2 (G (C2 y)))", "apply(simp add: monotone_def fun_ord_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. P (fun_lub luba {}) (fun_lub lubb {})\n 2. \\<And>x y.\n       \\<lbrakk>fun_ord orda x\n                 (ccpo.fixp (fun_lub luba) (fun_ord orda)\n                   (\\<lambda>f. U1 (F (C1 f))));\n        fun_ord ordb y\n         (ccpo.fixp (fun_lub lubb) (fun_ord ordb)\n           (\\<lambda>g. U2 (G (C2 g))));\n        P x y\\<rbrakk>\n       \\<Longrightarrow> P (U1 (F (C1 x))) (U2 (G (C2 y)))", "apply(simp add: fun_lub_def bot)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>fun_ord orda x\n                 (ccpo.fixp (fun_lub luba) (fun_ord orda)\n                   (\\<lambda>f. U1 (F (C1 f))));\n        fun_ord ordb y\n         (ccpo.fixp (fun_lub lubb) (fun_ord ordb)\n           (\\<lambda>g. U2 (G (C2 g))));\n        P x y\\<rbrakk>\n       \\<Longrightarrow> P (U1 (F (C1 x))) (U2 (G (C2 y)))", "apply(rule step; simp add: inverse inverse2 eq1 eq2 fun_ordD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas parallel_fixp_induct_strong_1_1 = parallel_fixp_induct_strong_uc[\n  of _ _ _ _ \"\\<lambda>x. x\" _ \"\\<lambda>x. x\" \"\\<lambda>x. x\" _ \"\\<lambda>x. x\",\n  OF _ _ _ _ _ _ refl refl]"], ["", "lemmas parallel_fixp_induct_strong_2_2 = parallel_fixp_induct_strong_uc[\n  of _ _ _ _ \"case_prod\" _ \"curry\" \"case_prod\" _ \"curry\",\n  where P=\"\\<lambda>f g. P (curry f) (curry g)\",\n  unfolded case_prod_curry curry_case_prod curry_K,\n  OF _ _ _ _ _ _ refl refl,\n  split_format (complete), unfolded prod.case]\n  for P"], ["", "lemma fixp_induct_option': \\<comment> \\<open>Stronger induction rule\\<close>\n  fixes F :: \"'c \\<Rightarrow> 'c\" and\n    U :: \"'c \\<Rightarrow> 'b \\<Rightarrow> 'a option\" and\n    C :: \"('b \\<Rightarrow> 'a option) \\<Rightarrow> 'c\" and\n    P :: \"'b \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  assumes mono: \"\\<And>x. mono_option (\\<lambda>f. U (F (C f)) x)\"\n  assumes eq: \"f \\<equiv> C (ccpo.fixp (fun_lub (flat_lub None)) (fun_ord option_ord) (\\<lambda>f. U (F (C f))))\"\n  assumes inverse2: \"\\<And>f. U (C f) = f\"\n  assumes step: \"\\<And>g x y. \\<lbrakk> \\<And>x y. U g x = Some y \\<Longrightarrow> P x y; U (F g) x = Some y; \\<And>x. option_ord (U g x) (U f x) \\<rbrakk> \\<Longrightarrow> P x y\"\n  assumes defined: \"U f x = Some y\"\n  shows \"P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x y", "using step defined option.fixp_strong_induct_uc[of U F C, OF mono eq inverse2 option_admissible, of P]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y. U ?g x = Some y \\<Longrightarrow> P x y;\n   U (F ?g) ?x = Some ?y; \\<And>x. option_ord (U ?g x) (U f x)\\<rbrakk>\n  \\<Longrightarrow> P ?x ?y\n  U f x = Some y\n  \\<lbrakk>\\<forall>x y. None = Some y \\<longrightarrow> P x y;\n   \\<And>f'.\n      \\<lbrakk>\\<forall>x y. U f' x = Some y \\<longrightarrow> P x y;\n       option.le_fun (U f') (U f)\\<rbrakk>\n      \\<Longrightarrow> \\<forall>x y.\n                           U (F f') x = Some y \\<longrightarrow>\n                           P x y\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x y. U f x = Some y \\<longrightarrow> P x y\n\ngoal (1 subgoal):\n 1. P x y", "unfolding fun_lub_def flat_lub_def fun_ord_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y. U ?g x = Some y \\<Longrightarrow> P x y;\n   U (F ?g) ?x = Some ?y; \\<And>x. option_ord (U ?g x) (U f x)\\<rbrakk>\n  \\<Longrightarrow> P ?x ?y\n  U f x = Some y\n  \\<lbrakk>\\<forall>x y. None = Some y \\<longrightarrow> P x y;\n   \\<And>f'.\n      \\<lbrakk>\\<forall>x y. U f' x = Some y \\<longrightarrow> P x y;\n       \\<forall>x. option_ord (U f' x) (U f x)\\<rbrakk>\n      \\<Longrightarrow> \\<forall>x y.\n                           U (F f') x = Some y \\<longrightarrow>\n                           P x y\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x y. U f x = Some y \\<longrightarrow> P x y\n\ngoal (1 subgoal):\n 1. P x y", "by(simp (no_asm_use)) blast"], ["", "declaration \\<open>Partial_Function.init \"option'\" @{term option.fixp_fun}\n  @{term option.mono_body} @{thm option.fixp_rule_uc} @{thm option.fixp_induct_uc}\n  (SOME @{thm fixp_induct_option'})\\<close>"], ["", "lemma bot_fun_least [simp]: \"(\\<lambda>_. bot :: 'a :: order_bot) \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_. \\<bottom>) \\<le> x", "by(fold bot_fun_def) simp"], ["", "lemma fun_ord_conv_rel_fun: \"fun_ord = rel_fun (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_ord = rel_fun (=)", "by(simp add: fun_ord_def fun_eq_iff rel_fun_def)"], ["", "inductive finite_chains :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> bool\"\n  for ord\nwhere finite_chainsI: \"(\\<And>Y. Complete_Partial_Order.chain ord Y \\<Longrightarrow> finite Y) \\<Longrightarrow> finite_chains ord\""], ["", "lemma finite_chainsD: \"\\<lbrakk> finite_chains ord; Complete_Partial_Order.chain ord Y \\<rbrakk> \\<Longrightarrow> finite Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite_chains ord; Complete_Partial_Order.chain ord Y\\<rbrakk>\n    \\<Longrightarrow> finite Y", "by(rule finite_chains.cases)"], ["", "lemma finite_chains_flat_ord [simp, intro!]: \"finite_chains (flat_ord x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_chains (flat_ord x)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       Complete_Partial_Order.chain (flat_ord x) Y \\<Longrightarrow>\n       finite Y", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       Complete_Partial_Order.chain (flat_ord x) Y \\<Longrightarrow>\n       finite Y", "assume chain: \"Complete_Partial_Order.chain (flat_ord x) Y\""], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (flat_ord x) Y\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       Complete_Partial_Order.chain (flat_ord x) Y \\<Longrightarrow>\n       finite Y", "show \"finite Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite Y", "proof(cases \"\\<exists>y \\<in> Y. y \\<noteq> x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>y\\<in>Y. y \\<noteq> x \\<Longrightarrow> finite Y\n 2. \\<not> (\\<exists>y\\<in>Y. y \\<noteq> x) \\<Longrightarrow> finite Y", "case True"], ["proof (state)\nthis:\n  \\<exists>y\\<in>Y. y \\<noteq> x\n\ngoal (2 subgoals):\n 1. \\<exists>y\\<in>Y. y \\<noteq> x \\<Longrightarrow> finite Y\n 2. \\<not> (\\<exists>y\\<in>Y. y \\<noteq> x) \\<Longrightarrow> finite Y", "then"], ["proof (chain)\npicking this:\n  \\<exists>y\\<in>Y. y \\<noteq> x", "obtain y where y: \"y \\<in> Y\" and yx: \"y \\<noteq> x\""], ["proof (prove)\nusing this:\n  \\<exists>y\\<in>Y. y \\<noteq> x\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> Y; y \\<noteq> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<in> Y\n  y \\<noteq> x\n\ngoal (2 subgoals):\n 1. \\<exists>y\\<in>Y. y \\<noteq> x \\<Longrightarrow> finite Y\n 2. \\<not> (\\<exists>y\\<in>Y. y \\<noteq> x) \\<Longrightarrow> finite Y", "hence \"Y \\<subseteq> {x, y}\""], ["proof (prove)\nusing this:\n  y \\<in> Y\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. Y \\<subseteq> {x, y}", "by(auto dest: chainD[OF chain] simp add: flat_ord_def)"], ["proof (state)\nthis:\n  Y \\<subseteq> {x, y}\n\ngoal (2 subgoals):\n 1. \\<exists>y\\<in>Y. y \\<noteq> x \\<Longrightarrow> finite Y\n 2. \\<not> (\\<exists>y\\<in>Y. y \\<noteq> x) \\<Longrightarrow> finite Y", "thus ?thesis"], ["proof (prove)\nusing this:\n  Y \\<subseteq> {x, y}\n\ngoal (1 subgoal):\n 1. finite Y", "by(rule finite_subset) simp"], ["proof (state)\nthis:\n  finite Y\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>Y. y \\<noteq> x) \\<Longrightarrow> finite Y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>Y. y \\<noteq> x) \\<Longrightarrow> finite Y", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>y\\<in>Y. y \\<noteq> x)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>Y. y \\<noteq> x) \\<Longrightarrow> finite Y", "hence \"Y \\<subseteq> {x}\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>y\\<in>Y. y \\<noteq> x)\n\ngoal (1 subgoal):\n 1. Y \\<subseteq> {x}", "by auto"], ["proof (state)\nthis:\n  Y \\<subseteq> {x}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>Y. y \\<noteq> x) \\<Longrightarrow> finite Y", "thus ?thesis"], ["proof (prove)\nusing this:\n  Y \\<subseteq> {x}\n\ngoal (1 subgoal):\n 1. finite Y", "by(rule finite_subset) simp"], ["proof (state)\nthis:\n  finite Y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite Y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mcont_finite_chains:\n  assumes finite: \"finite_chains ord\"\n  and mono: \"monotone ord ord' f\"\n  and ccpo: \"class.ccpo lub ord (mk_less ord)\"\n  and ccpo': \"class.ccpo lub' ord' (mk_less ord')\"\n  shows \"mcont lub ord lub' ord' f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lub ord lub' ord' f", "proof(intro mcontI contI)"], ["proof (state)\ngoal (2 subgoals):\n 1. monotone ord ord' f\n 2. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain ord Y; Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> f (lub Y) = lub' (f ` Y)", "fix Y"], ["proof (state)\ngoal (2 subgoals):\n 1. monotone ord ord' f\n 2. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain ord Y; Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> f (lub Y) = lub' (f ` Y)", "assume chain: \"Complete_Partial_Order.chain ord Y\" and Y: \"Y \\<noteq> {}\""], ["proof (state)\nthis:\n  Complete_Partial_Order.chain ord Y\n  Y \\<noteq> {}\n\ngoal (2 subgoals):\n 1. monotone ord ord' f\n 2. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain ord Y; Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> f (lub Y) = lub' (f ` Y)", "from finite chain"], ["proof (chain)\npicking this:\n  finite_chains ord\n  Complete_Partial_Order.chain ord Y", "have fin: \"finite Y\""], ["proof (prove)\nusing this:\n  finite_chains ord\n  Complete_Partial_Order.chain ord Y\n\ngoal (1 subgoal):\n 1. finite Y", "by(rule finite_chainsD)"], ["proof (state)\nthis:\n  finite Y\n\ngoal (2 subgoals):\n 1. monotone ord ord' f\n 2. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain ord Y; Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> f (lub Y) = lub' (f ` Y)", "from ccpo chain fin Y"], ["proof (chain)\npicking this:\n  class.ccpo lub ord (mk_less ord)\n  Complete_Partial_Order.chain ord Y\n  finite Y\n  Y \\<noteq> {}", "have lub: \"lub Y \\<in> Y\""], ["proof (prove)\nusing this:\n  class.ccpo lub ord (mk_less ord)\n  Complete_Partial_Order.chain ord Y\n  finite Y\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. lub Y \\<in> Y", "by(rule ccpo.in_chain_finite)"], ["proof (state)\nthis:\n  lub Y \\<in> Y\n\ngoal (2 subgoals):\n 1. monotone ord ord' f\n 2. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain ord Y; Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> f (lub Y) = lub' (f ` Y)", "interpret ccpo': ccpo lub' ord' \"mk_less ord'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ccpo lub' ord' (mk_less ord')", "by(rule ccpo')"], ["proof (state)\ngoal (2 subgoals):\n 1. monotone ord ord' f\n 2. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain ord Y; Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> f (lub Y) = lub' (f ` Y)", "have chain': \"Complete_Partial_Order.chain ord' (f ` Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain ord' (f ` Y)", "using chain"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain ord Y\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain ord' (f ` Y)", "by(rule chain_imageI)(rule monotoneD[OF mono])"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain ord' (f ` Y)\n\ngoal (2 subgoals):\n 1. monotone ord ord' f\n 2. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain ord Y; Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> f (lub Y) = lub' (f ` Y)", "have \"ord' (f (lub Y)) (lub' (f ` Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord' (f (lub Y)) (lub' (f ` Y))", "using chain'"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain ord' (f ` Y)\n\ngoal (1 subgoal):\n 1. ord' (f (lub Y)) (lub' (f ` Y))", "by(rule ccpo'.ccpo_Sup_upper)(simp add: lub)"], ["proof (state)\nthis:\n  ord' (f (lub Y)) (lub' (f ` Y))\n\ngoal (2 subgoals):\n 1. monotone ord ord' f\n 2. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain ord Y; Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> f (lub Y) = lub' (f ` Y)", "moreover"], ["proof (state)\nthis:\n  ord' (f (lub Y)) (lub' (f ` Y))\n\ngoal (2 subgoals):\n 1. monotone ord ord' f\n 2. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain ord Y; Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> f (lub Y) = lub' (f ` Y)", "have \"ord' (lub' (f ` Y)) (f (lub Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord' (lub' (f ` Y)) (f (lub Y))", "using chain'"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain ord' (f ` Y)\n\ngoal (1 subgoal):\n 1. ord' (lub' (f ` Y)) (f (lub Y))", "by(rule ccpo'.ccpo_Sup_least)(blast intro: monotoneD[OF mono] ccpo.ccpo_Sup_upper[OF ccpo chain])"], ["proof (state)\nthis:\n  ord' (lub' (f ` Y)) (f (lub Y))\n\ngoal (2 subgoals):\n 1. monotone ord ord' f\n 2. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain ord Y; Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> f (lub Y) = lub' (f ` Y)", "ultimately"], ["proof (chain)\npicking this:\n  ord' (f (lub Y)) (lub' (f ` Y))\n  ord' (lub' (f ` Y)) (f (lub Y))", "show \"f (lub Y) = lub' (f ` Y)\""], ["proof (prove)\nusing this:\n  ord' (f (lub Y)) (lub' (f ` Y))\n  ord' (lub' (f ` Y)) (f (lub Y))\n\ngoal (1 subgoal):\n 1. f (lub Y) = lub' (f ` Y)", "by(rule ccpo'.antisym)"], ["proof (state)\nthis:\n  f (lub Y) = lub' (f ` Y)\n\ngoal (1 subgoal):\n 1. monotone ord ord' f", "qed(fact mono)"], ["", "lemma rel_fun_curry: includes lifting_syntax shows\n  \"(A ===> B ===> C) f g \\<longleftrightarrow> (rel_prod A B ===> C) (case_prod f) (case_prod g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> B ===> C) f g =\n    (rel_prod A B ===> C) (\\<lambda>(x, y). f x y) (\\<lambda>(x, y). g x y)", "by(auto simp add: rel_fun_def)"], ["", "lemma (in ccpo) Sup_image_mono:\n  assumes ccpo: \"class.ccpo luba orda lessa\"\n  and mono: \"monotone orda (\\<le>) f\"\n  and chain: \"Complete_Partial_Order.chain orda A\"\n  and \"A \\<noteq> {}\"\n  shows \"Sup (f ` A) \\<le> (f (luba A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (f ` A) \\<le> f (luba A)", "proof(rule ccpo_Sup_least)"], ["proof (state)\ngoal (2 subgoals):\n 1. Complete_Partial_Order.chain (\\<le>) (f ` A)\n 2. \\<And>x. x \\<in> f ` A \\<Longrightarrow> x \\<le> f (luba A)", "from chain"], ["proof (chain)\npicking this:\n  Complete_Partial_Order.chain orda A", "show \"Complete_Partial_Order.chain (\\<le>) (f ` A)\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain orda A\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<le>) (f ` A)", "by(rule chain_imageI)(rule monotoneD[OF mono])"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<le>) (f ` A)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> f ` A \\<Longrightarrow> x \\<le> f (luba A)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> f ` A \\<Longrightarrow> x \\<le> f (luba A)", "assume \"x \\<in> f ` A\""], ["proof (state)\nthis:\n  x \\<in> f ` A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> f ` A \\<Longrightarrow> x \\<le> f (luba A)", "then"], ["proof (chain)\npicking this:\n  x \\<in> f ` A", "obtain y where \"x = f y\" \"y \\<in> A\""], ["proof (prove)\nusing this:\n  x \\<in> f ` A\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>x = f y; y \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = f y\n  y \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> f ` A \\<Longrightarrow> x \\<le> f (luba A)", "from \\<open>y \\<in> A\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> A", "have \"orda y (luba A)\""], ["proof (prove)\nusing this:\n  y \\<in> A\n\ngoal (1 subgoal):\n 1. orda y (luba A)", "by(rule ccpo.ccpo_Sup_upper[OF ccpo chain])"], ["proof (state)\nthis:\n  orda y (luba A)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> f ` A \\<Longrightarrow> x \\<le> f (luba A)", "hence \"f y \\<le> f (luba A)\""], ["proof (prove)\nusing this:\n  orda y (luba A)\n\ngoal (1 subgoal):\n 1. f y \\<le> f (luba A)", "by(rule monotoneD[OF mono])"], ["proof (state)\nthis:\n  f y \\<le> f (luba A)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> f ` A \\<Longrightarrow> x \\<le> f (luba A)", "thus \"x \\<le> f (luba A)\""], ["proof (prove)\nusing this:\n  f y \\<le> f (luba A)\n\ngoal (1 subgoal):\n 1. x \\<le> f (luba A)", "using \\<open>x = f y\\<close>"], ["proof (prove)\nusing this:\n  f y \\<le> f (luba A)\n  x = f y\n\ngoal (1 subgoal):\n 1. x \\<le> f (luba A)", "by simp"], ["proof (state)\nthis:\n  x \\<le> f (luba A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in ccpo) admissible_le_mono:\n  assumes \"monotone (\\<le>) (\\<le>) f\"\n  shows \"ccpo.admissible Sup (\\<le>) (\\<lambda>x. x \\<le> f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible Sup (\\<le>) (\\<lambda>x. x \\<le> f x)", "proof(rule ccpo.admissibleI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) A; A \\<noteq> {};\n        \\<forall>x\\<in>A. x \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> A \\<le> f (\\<Squnion> A)", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) A; A \\<noteq> {};\n        \\<forall>x\\<in>A. x \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> A \\<le> f (\\<Squnion> A)", "assume chain: \"Complete_Partial_Order.chain (\\<le>) Y\"\n    and Y: \"Y \\<noteq> {}\"\n    and le [rule_format]: \"\\<forall>x\\<in>Y. x \\<le> f x\""], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<le>) Y\n  Y \\<noteq> {}\n  ?x \\<in> Y \\<Longrightarrow> ?x \\<le> f ?x\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) A; A \\<noteq> {};\n        \\<forall>x\\<in>A. x \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> A \\<le> f (\\<Squnion> A)", "have \"\\<Squnion>Y \\<le> \\<Squnion>(f ` Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> Y \\<le> \\<Squnion> (f ` Y)", "using chain"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<le>) Y\n\ngoal (1 subgoal):\n 1. \\<Squnion> Y \\<le> \\<Squnion> (f ` Y)", "by(rule ccpo_Sup_least)(rule order_trans[OF le]; blast intro!: ccpo_Sup_upper chain_imageI[OF chain] intro: monotoneD[OF assms])"], ["proof (state)\nthis:\n  \\<Squnion> Y \\<le> \\<Squnion> (f ` Y)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) A; A \\<noteq> {};\n        \\<forall>x\\<in>A. x \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> A \\<le> f (\\<Squnion> A)", "also"], ["proof (state)\nthis:\n  \\<Squnion> Y \\<le> \\<Squnion> (f ` Y)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) A; A \\<noteq> {};\n        \\<forall>x\\<in>A. x \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> A \\<le> f (\\<Squnion> A)", "have \"\\<dots> \\<le> f (\\<Squnion>Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (f ` Y) \\<le> f (\\<Squnion> Y)", "by(rule Sup_image_mono[OF _ assms chain Y, where lessa=\"(<)\"]) unfold_locales"], ["proof (state)\nthis:\n  \\<Squnion> (f ` Y) \\<le> f (\\<Squnion> Y)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) A; A \\<noteq> {};\n        \\<forall>x\\<in>A. x \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> A \\<le> f (\\<Squnion> A)", "finally"], ["proof (chain)\npicking this:\n  \\<Squnion> Y \\<le> f (\\<Squnion> Y)", "show \"\\<Squnion>Y \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  \\<Squnion> Y \\<le> f (\\<Squnion> Y)\n\ngoal (1 subgoal):\n 1. \\<Squnion> Y \\<le> f (\\<Squnion> Y)", "."], ["proof (state)\nthis:\n  \\<Squnion> Y \\<le> f (\\<Squnion> Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in ccpo) fixp_induct_strong2:\n  assumes adm: \"ccpo.admissible Sup (\\<le>) P\"\n  and mono: \"monotone (\\<le>) (\\<le>) f\"\n  and bot: \"P (\\<Squnion>{})\"\n  and step: \"\\<And>x. \\<lbrakk> x \\<le> ccpo_class.fixp f; x \\<le> f x; P x \\<rbrakk> \\<Longrightarrow> P (f x)\"\n  shows \"P (ccpo_class.fixp f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (ccpo_class.fixp f)", "proof(rule fixp_strong_induct[where P=\"\\<lambda>x. x \\<le> f x \\<and> P x\", THEN conjunct2])"], ["proof (state)\ngoal (4 subgoals):\n 1. ccpo.admissible Sup (\\<le>) (\\<lambda>x. x \\<le> f x \\<and> P x)\n 2. monotone (\\<le>) (\\<le>) f\n 3. \\<Squnion> {} \\<le> f (\\<Squnion> {}) \\<and> P (\\<Squnion> {})\n 4. \\<And>x.\n       \\<lbrakk>x \\<le> ccpo_class.fixp f; x \\<le> f x \\<and> P x\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> f (f x) \\<and> P (f x)", "show \"ccpo.admissible Sup (\\<le>) (\\<lambda>x. x \\<le> f x \\<and> P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible Sup (\\<le>) (\\<lambda>x. x \\<le> f x \\<and> P x)", "using admissible_le_mono adm"], ["proof (prove)\nusing this:\n  monotone (\\<le>) (\\<le>) ?f \\<Longrightarrow>\n  ccpo.admissible Sup (\\<le>) (\\<lambda>x. x \\<le> ?f x)\n  ccpo.admissible Sup (\\<le>) P\n\ngoal (1 subgoal):\n 1. ccpo.admissible Sup (\\<le>) (\\<lambda>x. x \\<le> f x \\<and> P x)", "by(rule admissible_conj)(rule mono)"], ["proof (state)\nthis:\n  ccpo.admissible Sup (\\<le>) (\\<lambda>x. x \\<le> f x \\<and> P x)\n\ngoal (3 subgoals):\n 1. monotone (\\<le>) (\\<le>) f\n 2. \\<Squnion> {} \\<le> f (\\<Squnion> {}) \\<and> P (\\<Squnion> {})\n 3. \\<And>x.\n       \\<lbrakk>x \\<le> ccpo_class.fixp f; x \\<le> f x \\<and> P x\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> f (f x) \\<and> P (f x)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. monotone (\\<le>) (\\<le>) f\n 2. \\<Squnion> {} \\<le> f (\\<Squnion> {}) \\<and> P (\\<Squnion> {})\n 3. \\<And>x.\n       \\<lbrakk>x \\<le> ccpo_class.fixp f; x \\<le> f x \\<and> P x\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> f (f x) \\<and> P (f x)", "show \"\\<Squnion>{} \\<le> f (\\<Squnion>{}) \\<and> P (\\<Squnion>{})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> {} \\<le> f (\\<Squnion> {}) \\<and> P (\\<Squnion> {})", "by(auto simp add: bot chain_empty intro: ccpo_Sup_least)"], ["proof (state)\nthis:\n  \\<Squnion> {} \\<le> f (\\<Squnion> {}) \\<and> P (\\<Squnion> {})\n\ngoal (2 subgoals):\n 1. monotone (\\<le>) (\\<le>) f\n 2. \\<And>x.\n       \\<lbrakk>x \\<le> ccpo_class.fixp f; x \\<le> f x \\<and> P x\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> f (f x) \\<and> P (f x)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. monotone (\\<le>) (\\<le>) f\n 2. \\<And>x.\n       \\<lbrakk>x \\<le> ccpo_class.fixp f; x \\<le> f x \\<and> P x\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> f (f x) \\<and> P (f x)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. monotone (\\<le>) (\\<le>) f\n 2. \\<And>x.\n       \\<lbrakk>x \\<le> ccpo_class.fixp f; x \\<le> f x \\<and> P x\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> f (f x) \\<and> P (f x)", "assume \"x \\<le> ccpo_class.fixp f\" \"x \\<le> f x \\<and> P x\""], ["proof (state)\nthis:\n  x \\<le> ccpo_class.fixp f\n  x \\<le> f x \\<and> P x\n\ngoal (2 subgoals):\n 1. monotone (\\<le>) (\\<le>) f\n 2. \\<And>x.\n       \\<lbrakk>x \\<le> ccpo_class.fixp f; x \\<le> f x \\<and> P x\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> f (f x) \\<and> P (f x)", "thus \"f x \\<le> f (f x) \\<and> P (f x)\""], ["proof (prove)\nusing this:\n  x \\<le> ccpo_class.fixp f\n  x \\<le> f x \\<and> P x\n\ngoal (1 subgoal):\n 1. f x \\<le> f (f x) \\<and> P (f x)", "by(auto dest: monotoneD[OF mono] intro: step)"], ["proof (state)\nthis:\n  f x \\<le> f (f x) \\<and> P (f x)\n\ngoal (1 subgoal):\n 1. monotone (\\<le>) (\\<le>) f", "qed(rule mono)"], ["", "context partial_function_definitions begin"], ["", "lemma fixp_induct_strong2_uc:\n  fixes F :: \"'c \\<Rightarrow> 'c\"\n    and U :: \"'c \\<Rightarrow> 'b \\<Rightarrow> 'a\"\n    and C :: \"('b \\<Rightarrow> 'a) \\<Rightarrow> 'c\"\n    and P :: \"('b \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n  assumes mono: \"\\<And>x. mono_body (\\<lambda>f. U (F (C f)) x)\"\n    and eq: \"f \\<equiv> C (fixp_fun (\\<lambda>f. U (F (C f))))\"\n    and inverse: \"\\<And>f. U (C f) = f\"\n    and adm: \"ccpo.admissible lub_fun le_fun P\"\n    and bot: \"P (\\<lambda>_. lub {})\"\n    and step: \"\\<And>f'. \\<lbrakk> le_fun (U f') (U f); le_fun (U f') (U (F f')); P (U f') \\<rbrakk> \\<Longrightarrow> P (U (F f'))\"\n  shows \"P (U f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (U f)", "unfolding eq inverse"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (fixp_fun (\\<lambda>f. U (F (C f))))", "apply (rule ccpo.fixp_induct_strong2[OF ccpo adm])"], ["proof (prove)\ngoal (3 subgoals):\n 1. monotone le_fun le_fun (\\<lambda>f. U (F (C f)))\n 2. P (lub_fun {})\n 3. \\<And>x.\n       \\<lbrakk>le_fun x (fixp_fun (\\<lambda>f. U (F (C f))));\n        le_fun x (U (F (C x))); P x\\<rbrakk>\n       \\<Longrightarrow> P (U (F (C x)))", "apply (insert mono, auto simp: monotone_def fun_ord_def bot fun_lub_def)[2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>le_fun x (fixp_fun (\\<lambda>f. U (F (C f))));\n        le_fun x (U (F (C x))); P x\\<rbrakk>\n       \\<Longrightarrow> P (U (F (C x)))", "apply (rule_tac f'5=\"C x\" in step)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>le_fun x (fixp_fun (\\<lambda>f. U (F (C f))));\n        le_fun x (U (F (C x))); P x\\<rbrakk>\n       \\<Longrightarrow> le_fun (U (C x)) (U f)\n 2. \\<And>x.\n       \\<lbrakk>le_fun x (fixp_fun (\\<lambda>f. U (F (C f))));\n        le_fun x (U (F (C x))); P x\\<rbrakk>\n       \\<Longrightarrow> le_fun (U (C x)) (U (F (C x)))\n 3. \\<And>x.\n       \\<lbrakk>le_fun x (fixp_fun (\\<lambda>f. U (F (C f))));\n        le_fun x (U (F (C x))); P x\\<rbrakk>\n       \\<Longrightarrow> P (U (C x))", "apply (simp_all add: inverse eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemmas parallel_fixp_induct_2_4 = parallel_fixp_induct_uc[\n  of _ _ _ _ \"case_prod\" _ \"curry\" \"\\<lambda>f. case_prod (case_prod (case_prod f))\" _ \"\\<lambda>f. curry (curry (curry f))\",\n  where P=\"\\<lambda>f g. P (curry f) (curry (curry (curry g)))\",\n  unfolded case_prod_curry curry_case_prod curry_K,\n  OF _ _ _ _ _ _ refl refl]\n  for P"], ["", "lemma (in ccpo) fixp_greatest:\n  assumes f: \"monotone (\\<le>) (\\<le>) f\"\n    and ge: \"\\<And>y. f y \\<le> y \\<Longrightarrow> x \\<le> y\"\n  shows \"x \\<le> ccpo.fixp Sup (\\<le>) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> ccpo_class.fixp f", "by(rule ge)(simp add: fixp_unfold[OF f, symmetric])"], ["", "lemma fixp_rolling:\n  assumes \"class.ccpo lub1 leq1 (mk_less leq1)\"\n    and \"class.ccpo lub2 leq2 (mk_less leq2)\"\n    and f: \"monotone leq1 leq2 f\"\n    and g: \"monotone leq2 leq1 g\"\n  shows \"ccpo.fixp lub1 leq1 (\\<lambda>x. g (f x)) = g (ccpo.fixp lub2 leq2 (\\<lambda>x. f (g x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.fixp lub1 leq1 (\\<lambda>x. g (f x)) =\n    g (ccpo.fixp lub2 leq2 (\\<lambda>x. f (g x)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ccpo.fixp lub1 leq1 (\\<lambda>x. g (f x)) =\n    g (ccpo.fixp lub2 leq2 (\\<lambda>x. f (g x)))", "interpret c1: ccpo lub1 leq1 \"mk_less leq1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ccpo lub1 leq1 (mk_less leq1)", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. c1.fixp (\\<lambda>x. g (f x)) =\n    g (ccpo.fixp lub2 leq2 (\\<lambda>x. f (g x)))", "interpret c2: ccpo lub2 leq2 \"mk_less leq2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ccpo lub2 leq2 (mk_less leq2)", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. c1.fixp (\\<lambda>x. g (f x)) = g (c2.fixp (\\<lambda>x. f (g x)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. c1.fixp (\\<lambda>x. g (f x)) = g (c2.fixp (\\<lambda>x. f (g x)))", "proof(rule c1.antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. leq1 (c1.fixp (\\<lambda>x. g (f x))) (g (c2.fixp (\\<lambda>x. f (g x))))\n 2. leq1 (g (c2.fixp (\\<lambda>x. f (g x)))) (c1.fixp (\\<lambda>x. g (f x)))", "have fg: \"monotone leq2 leq2 (\\<lambda>x. f (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone leq2 leq2 (\\<lambda>x. f (g x))", "using f g"], ["proof (prove)\nusing this:\n  monotone leq1 leq2 f\n  monotone leq2 leq1 g\n\ngoal (1 subgoal):\n 1. monotone leq2 leq2 (\\<lambda>x. f (g x))", "by(rule monotone2monotone) simp_all"], ["proof (state)\nthis:\n  monotone leq2 leq2 (\\<lambda>x. f (g x))\n\ngoal (2 subgoals):\n 1. leq1 (c1.fixp (\\<lambda>x. g (f x))) (g (c2.fixp (\\<lambda>x. f (g x))))\n 2. leq1 (g (c2.fixp (\\<lambda>x. f (g x)))) (c1.fixp (\\<lambda>x. g (f x)))", "have gf: \"monotone leq1 leq1 (\\<lambda>x. g (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone leq1 leq1 (\\<lambda>x. g (f x))", "using g f"], ["proof (prove)\nusing this:\n  monotone leq2 leq1 g\n  monotone leq1 leq2 f\n\ngoal (1 subgoal):\n 1. monotone leq1 leq1 (\\<lambda>x. g (f x))", "by(rule monotone2monotone) simp_all"], ["proof (state)\nthis:\n  monotone leq1 leq1 (\\<lambda>x. g (f x))\n\ngoal (2 subgoals):\n 1. leq1 (c1.fixp (\\<lambda>x. g (f x))) (g (c2.fixp (\\<lambda>x. f (g x))))\n 2. leq1 (g (c2.fixp (\\<lambda>x. f (g x)))) (c1.fixp (\\<lambda>x. g (f x)))", "show \"leq1 (c1.fixp (\\<lambda>x. g (f x))) (g (c2.fixp (\\<lambda>x. f (g x))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. leq1 (c1.fixp (\\<lambda>x. g (f x))) (g (c2.fixp (\\<lambda>x. f (g x))))", "using gf"], ["proof (prove)\nusing this:\n  monotone leq1 leq1 (\\<lambda>x. g (f x))\n\ngoal (1 subgoal):\n 1. leq1 (c1.fixp (\\<lambda>x. g (f x))) (g (c2.fixp (\\<lambda>x. f (g x))))", "by(rule c1.fixp_lowerbound)(subst (2) c2.fixp_unfold[OF fg], simp)"], ["proof (state)\nthis:\n  leq1 (c1.fixp (\\<lambda>x. g (f x))) (g (c2.fixp (\\<lambda>x. f (g x))))\n\ngoal (1 subgoal):\n 1. leq1 (g (c2.fixp (\\<lambda>x. f (g x)))) (c1.fixp (\\<lambda>x. g (f x)))", "show \"leq1 (g (c2.fixp (\\<lambda>x. f (g x)))) (c1.fixp (\\<lambda>x. g (f x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. leq1 (g (c2.fixp (\\<lambda>x. f (g x)))) (c1.fixp (\\<lambda>x. g (f x)))", "using gf"], ["proof (prove)\nusing this:\n  monotone leq1 leq1 (\\<lambda>x. g (f x))\n\ngoal (1 subgoal):\n 1. leq1 (g (c2.fixp (\\<lambda>x. f (g x)))) (c1.fixp (\\<lambda>x. g (f x)))", "proof(rule c1.fixp_greatest)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       leq1 (g (f y)) y \\<Longrightarrow>\n       leq1 (g (c2.fixp (\\<lambda>x. f (g x)))) y", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       leq1 (g (f y)) y \\<Longrightarrow>\n       leq1 (g (c2.fixp (\\<lambda>x. f (g x)))) y", "assume u: \"leq1 (g (f u)) u\""], ["proof (state)\nthis:\n  leq1 (g (f u)) u\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       leq1 (g (f y)) y \\<Longrightarrow>\n       leq1 (g (c2.fixp (\\<lambda>x. f (g x)))) y", "have \"leq1 (g (c2.fixp (\\<lambda>x. f (g x)))) (g (f u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. leq1 (g (c2.fixp (\\<lambda>x. f (g x)))) (g (f u))", "by(intro monotoneD[OF g] c2.fixp_lowerbound[OF fg] monotoneD[OF f u])"], ["proof (state)\nthis:\n  leq1 (g (c2.fixp (\\<lambda>x. f (g x)))) (g (f u))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       leq1 (g (f y)) y \\<Longrightarrow>\n       leq1 (g (c2.fixp (\\<lambda>x. f (g x)))) y", "then"], ["proof (chain)\npicking this:\n  leq1 (g (c2.fixp (\\<lambda>x. f (g x)))) (g (f u))", "show \"leq1 (g (c2.fixp (\\<lambda>x. f (g x)))) u\""], ["proof (prove)\nusing this:\n  leq1 (g (c2.fixp (\\<lambda>x. f (g x)))) (g (f u))\n\ngoal (1 subgoal):\n 1. leq1 (g (c2.fixp (\\<lambda>x. f (g x)))) u", "using u"], ["proof (prove)\nusing this:\n  leq1 (g (c2.fixp (\\<lambda>x. f (g x)))) (g (f u))\n  leq1 (g (f u)) u\n\ngoal (1 subgoal):\n 1. leq1 (g (c2.fixp (\\<lambda>x. f (g x)))) u", "by(rule c1.order_trans)"], ["proof (state)\nthis:\n  leq1 (g (c2.fixp (\\<lambda>x. f (g x)))) u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  leq1 (g (c2.fixp (\\<lambda>x. f (g x)))) (c1.fixp (\\<lambda>x. g (f x)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c1.fixp (\\<lambda>x. g (f x)) = g (c2.fixp (\\<lambda>x. f (g x)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fixp_lfp_parametric_eq:\n  includes lifting_syntax\n  assumes f: \"\\<And>x. lfp.mono_body (\\<lambda>f. F f x)\"\n  and g: \"\\<And>x. lfp.mono_body (\\<lambda>f. G f x)\"\n  and param: \"((A ===> (=)) ===> A ===> (=)) F G\"\n  shows \"(A ===> (=)) (lfp.fixp_fun F) (lfp.fixp_fun G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (=)) (lfp.fixp_fun F) (lfp.fixp_fun G)", "using f g"], ["proof (prove)\nusing this:\n  lfp.mono_body (\\<lambda>f. F f ?x)\n  lfp.mono_body (\\<lambda>f. G f ?x)\n\ngoal (1 subgoal):\n 1. (A ===> (=)) (lfp.fixp_fun F) (lfp.fixp_fun G)", "proof(rule parallel_fixp_induct_1_1[OF complete_lattice_partial_function_definitions complete_lattice_partial_function_definitions _ _ reflexive reflexive, where P=\"(A ===> (=))\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x. (A ===> (=)) (fst x) (snd x))\n 2. (A ===> (=)) (\\<lambda>_. \\<Squnion> {}) (\\<lambda>_. \\<Squnion> {})\n 3. \\<And>f g. (A ===> (=)) f g \\<Longrightarrow> (A ===> (=)) (F f) (G g)", "show \"ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun) (rel_prod lfp.le_fun lfp.le_fun) (\\<lambda>x. (A ===> (=)) (fst x) (snd x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x. (A ===> (=)) (fst x) (snd x))", "unfolding rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa y. A xa y \\<longrightarrow> fst x xa = snd x y)", "by simp"], ["proof (state)\nthis:\n  ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n   (rel_prod lfp.le_fun lfp.le_fun)\n   (\\<lambda>x. (A ===> (=)) (fst x) (snd x))\n\ngoal (2 subgoals):\n 1. (A ===> (=)) (\\<lambda>_. \\<Squnion> {}) (\\<lambda>_. \\<Squnion> {})\n 2. \\<And>f g. (A ===> (=)) f g \\<Longrightarrow> (A ===> (=)) (F f) (G g)", "show \"(A ===> (=)) (\\<lambda>_. \\<Squnion>{}) (\\<lambda>_. \\<Squnion>{})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (=)) (\\<lambda>_. \\<Squnion> {}) (\\<lambda>_. \\<Squnion> {})", "by auto"], ["proof (state)\nthis:\n  (A ===> (=)) (\\<lambda>_. \\<Squnion> {}) (\\<lambda>_. \\<Squnion> {})\n\ngoal (1 subgoal):\n 1. \\<And>f g. (A ===> (=)) f g \\<Longrightarrow> (A ===> (=)) (F f) (G g)", "show \"(A ===> (=)) (F f) (G g)\" if \"(A ===> (=)) f g\" for f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (=)) (F f) (G g)", "using that"], ["proof (prove)\nusing this:\n  (A ===> (=)) f g\n\ngoal (1 subgoal):\n 1. (A ===> (=)) (F f) (G g)", "by(rule rel_funD[OF param])"], ["proof (state)\nthis:\n  (A ===> (=)) ?f2 ?g2 \\<Longrightarrow> (A ===> (=)) (F ?f2) (G ?g2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mono2mono_map_option[THEN option.mono2mono, simp, cont_intro]:\n  shows monotone_map_option: \"monotone option_ord option_ord (map_option f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone option_ord option_ord (map_option f)", "by(rule monotoneI)(auto simp add: flat_ord_def)"], ["", "lemma mcont2mcont_map_option[THEN option.mcont2mcont, simp, cont_intro]:\n  shows mcont_map_option: \"mcont (flat_lub None) option_ord (flat_lub None) option_ord (map_option f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont (flat_lub None) option_ord (flat_lub None) option_ord\n     (map_option f)", "by(rule mcont_finite_chains[OF _ _ flat_interpretation[THEN ccpo] flat_interpretation[THEN ccpo]]) simp_all"], ["", "lemma mono2mono_set_option [THEN lfp.mono2mono]:\n  shows monotone_set_option: \"monotone option_ord (\\<subseteq>) set_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone option_ord (\\<subseteq>) set_option", "by(auto intro!: monotoneI simp add: option_ord_Some1_iff)"], ["", "lemma mcont2mcont_set_option [THEN lfp.mcont2mcont, cont_intro, simp]:\n  shows mcont_set_option: \"mcont (flat_lub None) option_ord Union (\\<subseteq>) set_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont (flat_lub None) option_ord \\<Union> (\\<subseteq>) set_option", "by(rule mcont_finite_chains)(simp_all add: monotone_set_option ccpo option.partial_function_definitions_axioms)"], ["", "lemma eadd_gfp_partial_function_mono [partial_function_mono]:\n  \"\\<lbrakk> monotone (fun_ord (\\<ge>)) (\\<ge>) f; monotone (fun_ord (\\<ge>)) (\\<ge>) g \\<rbrakk>\n  \\<Longrightarrow> monotone (fun_ord (\\<ge>)) (\\<ge>) (\\<lambda>x. f x + g x :: enat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>monotone (fun_ord (\\<lambda>x y. y \\<le> x))\n              (\\<lambda>x y. y \\<le> x) f;\n     monotone (fun_ord (\\<lambda>x y. y \\<le> x)) (\\<lambda>x y. y \\<le> x)\n      g\\<rbrakk>\n    \\<Longrightarrow> monotone (fun_ord (\\<lambda>x y. y \\<le> x))\n                       (\\<lambda>x y. y \\<le> x) (\\<lambda>x. f x + g x)", "by(rule mono2mono_gfp_eadd)"], ["", "lemma map_option_mono [partial_function_mono]:\n  \"mono_option B \\<Longrightarrow> mono_option (\\<lambda>f. map_option g (B f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone option.le_fun option_ord B \\<Longrightarrow>\n    monotone option.le_fun option_ord (\\<lambda>f. map_option g (B f))", "unfolding map_conv_bind_option"], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone option.le_fun option_ord B \\<Longrightarrow>\n    monotone option.le_fun option_ord\n     (\\<lambda>f. B f \\<bind> Some \\<circ> g)", "by(rule bind_mono) simp_all"], ["", "subsection \\<open>Folding over finite sets\\<close>"], ["", "lemma (in comp_fun_commute) fold_invariant_remove [consumes 1, case_names start step]:\n  assumes fin: \"finite A\"\n  and start: \"I A s\"\n  and step: \"\\<And>x s A'. \\<lbrakk> x \\<in> A'; I A' s; A' \\<subseteq> A \\<rbrakk> \\<Longrightarrow> I (A' - {x}) (f x s)\"\n  shows \"I {} (Finite_Set.fold f s A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I {} (Finite_Set.fold f s A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. I {} (Finite_Set.fold f s A)", "define A' where \"A' == A\""], ["proof (state)\nthis:\n  A' \\<equiv> A\n\ngoal (1 subgoal):\n 1. I {} (Finite_Set.fold f s A)", "with fin start"], ["proof (chain)\npicking this:\n  finite A\n  I A s\n  A' \\<equiv> A", "have \"finite A'\" \"A' \\<subseteq> A\" \"I A' s\""], ["proof (prove)\nusing this:\n  finite A\n  I A s\n  A' \\<equiv> A\n\ngoal (1 subgoal):\n 1. finite A' &&& A' \\<subseteq> A &&& I A' s", "by simp_all"], ["proof (state)\nthis:\n  finite A'\n  A' \\<subseteq> A\n  I A' s\n\ngoal (1 subgoal):\n 1. I {} (Finite_Set.fold f s A)", "thus \"I {} (Finite_Set.fold f s A')\""], ["proof (prove)\nusing this:\n  finite A'\n  A' \\<subseteq> A\n  I A' s\n\ngoal (1 subgoal):\n 1. I {} (Finite_Set.fold f s A')", "proof(induction arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>{} \\<subseteq> A; I {} s\\<rbrakk>\n       \\<Longrightarrow> I {} (Finite_Set.fold f s {})\n 2. \\<And>x F s.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s.\n           \\<lbrakk>F \\<subseteq> A; I F s\\<rbrakk>\n           \\<Longrightarrow> I {} (Finite_Set.fold f s F);\n        insert x F \\<subseteq> A; I (insert x F) s\\<rbrakk>\n       \\<Longrightarrow> I {} (Finite_Set.fold f s (insert x F))", "case empty"], ["proof (state)\nthis:\n  {} \\<subseteq> A\n  I {} s\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>{} \\<subseteq> A; I {} s\\<rbrakk>\n       \\<Longrightarrow> I {} (Finite_Set.fold f s {})\n 2. \\<And>x F s.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s.\n           \\<lbrakk>F \\<subseteq> A; I F s\\<rbrakk>\n           \\<Longrightarrow> I {} (Finite_Set.fold f s F);\n        insert x F \\<subseteq> A; I (insert x F) s\\<rbrakk>\n       \\<Longrightarrow> I {} (Finite_Set.fold f s (insert x F))", "thus ?case"], ["proof (prove)\nusing this:\n  {} \\<subseteq> A\n  I {} s\n\ngoal (1 subgoal):\n 1. I {} (Finite_Set.fold f s {})", "by simp"], ["proof (state)\nthis:\n  I {} (Finite_Set.fold f s {})\n\ngoal (1 subgoal):\n 1. \\<And>x F s.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s.\n           \\<lbrakk>F \\<subseteq> A; I F s\\<rbrakk>\n           \\<Longrightarrow> I {} (Finite_Set.fold f s F);\n        insert x F \\<subseteq> A; I (insert x F) s\\<rbrakk>\n       \\<Longrightarrow> I {} (Finite_Set.fold f s (insert x F))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F s.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s.\n           \\<lbrakk>F \\<subseteq> A; I F s\\<rbrakk>\n           \\<Longrightarrow> I {} (Finite_Set.fold f s F);\n        insert x F \\<subseteq> A; I (insert x F) s\\<rbrakk>\n       \\<Longrightarrow> I {} (Finite_Set.fold f s (insert x F))", "case (insert x A')"], ["proof (state)\nthis:\n  finite A'\n  x \\<notin> A'\n  \\<lbrakk>A' \\<subseteq> A; I A' ?s\\<rbrakk>\n  \\<Longrightarrow> I {} (Finite_Set.fold f ?s A')\n  insert x A' \\<subseteq> A\n  I (insert x A') s\n\ngoal (1 subgoal):\n 1. \\<And>x F s.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s.\n           \\<lbrakk>F \\<subseteq> A; I F s\\<rbrakk>\n           \\<Longrightarrow> I {} (Finite_Set.fold f s F);\n        insert x F \\<subseteq> A; I (insert x F) s\\<rbrakk>\n       \\<Longrightarrow> I {} (Finite_Set.fold f s (insert x F))", "let ?A' = \"insert x A'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F s.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s.\n           \\<lbrakk>F \\<subseteq> A; I F s\\<rbrakk>\n           \\<Longrightarrow> I {} (Finite_Set.fold f s F);\n        insert x F \\<subseteq> A; I (insert x F) s\\<rbrakk>\n       \\<Longrightarrow> I {} (Finite_Set.fold f s (insert x F))", "have \"x \\<in> ?A'\" \"I ?A' s\" \"?A' \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> insert x A' &&& I (insert x A') s &&& insert x A' \\<subseteq> A", "using insert"], ["proof (prove)\nusing this:\n  finite A'\n  x \\<notin> A'\n  \\<lbrakk>A' \\<subseteq> A; I A' ?s\\<rbrakk>\n  \\<Longrightarrow> I {} (Finite_Set.fold f ?s A')\n  insert x A' \\<subseteq> A\n  I (insert x A') s\n\ngoal (1 subgoal):\n 1. x \\<in> insert x A' &&& I (insert x A') s &&& insert x A' \\<subseteq> A", "by auto"], ["proof (state)\nthis:\n  x \\<in> insert x A'\n  I (insert x A') s\n  insert x A' \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>x F s.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s.\n           \\<lbrakk>F \\<subseteq> A; I F s\\<rbrakk>\n           \\<Longrightarrow> I {} (Finite_Set.fold f s F);\n        insert x F \\<subseteq> A; I (insert x F) s\\<rbrakk>\n       \\<Longrightarrow> I {} (Finite_Set.fold f s (insert x F))", "hence \"I (?A' - {x}) (f x s)\""], ["proof (prove)\nusing this:\n  x \\<in> insert x A'\n  I (insert x A') s\n  insert x A' \\<subseteq> A\n\ngoal (1 subgoal):\n 1. I (insert x A' - {x}) (f x s)", "by(rule step)"], ["proof (state)\nthis:\n  I (insert x A' - {x}) (f x s)\n\ngoal (1 subgoal):\n 1. \\<And>x F s.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s.\n           \\<lbrakk>F \\<subseteq> A; I F s\\<rbrakk>\n           \\<Longrightarrow> I {} (Finite_Set.fold f s F);\n        insert x F \\<subseteq> A; I (insert x F) s\\<rbrakk>\n       \\<Longrightarrow> I {} (Finite_Set.fold f s (insert x F))", "with insert"], ["proof (chain)\npicking this:\n  finite A'\n  x \\<notin> A'\n  \\<lbrakk>A' \\<subseteq> A; I A' ?s\\<rbrakk>\n  \\<Longrightarrow> I {} (Finite_Set.fold f ?s A')\n  insert x A' \\<subseteq> A\n  I (insert x A') s\n  I (insert x A' - {x}) (f x s)", "have \"A' \\<subseteq> A\" \"I A' (f x s)\""], ["proof (prove)\nusing this:\n  finite A'\n  x \\<notin> A'\n  \\<lbrakk>A' \\<subseteq> A; I A' ?s\\<rbrakk>\n  \\<Longrightarrow> I {} (Finite_Set.fold f ?s A')\n  insert x A' \\<subseteq> A\n  I (insert x A') s\n  I (insert x A' - {x}) (f x s)\n\ngoal (1 subgoal):\n 1. A' \\<subseteq> A &&& I A' (f x s)", "by auto"], ["proof (state)\nthis:\n  A' \\<subseteq> A\n  I A' (f x s)\n\ngoal (1 subgoal):\n 1. \\<And>x F s.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s.\n           \\<lbrakk>F \\<subseteq> A; I F s\\<rbrakk>\n           \\<Longrightarrow> I {} (Finite_Set.fold f s F);\n        insert x F \\<subseteq> A; I (insert x F) s\\<rbrakk>\n       \\<Longrightarrow> I {} (Finite_Set.fold f s (insert x F))", "hence \"I {} (Finite_Set.fold f (f x s) A')\""], ["proof (prove)\nusing this:\n  A' \\<subseteq> A\n  I A' (f x s)\n\ngoal (1 subgoal):\n 1. I {} (Finite_Set.fold f (f x s) A')", "by(rule insert.IH)"], ["proof (state)\nthis:\n  I {} (Finite_Set.fold f (f x s) A')\n\ngoal (1 subgoal):\n 1. \\<And>x F s.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s.\n           \\<lbrakk>F \\<subseteq> A; I F s\\<rbrakk>\n           \\<Longrightarrow> I {} (Finite_Set.fold f s F);\n        insert x F \\<subseteq> A; I (insert x F) s\\<rbrakk>\n       \\<Longrightarrow> I {} (Finite_Set.fold f s (insert x F))", "thus ?case"], ["proof (prove)\nusing this:\n  I {} (Finite_Set.fold f (f x s) A')\n\ngoal (1 subgoal):\n 1. I {} (Finite_Set.fold f s (insert x A'))", "using insert"], ["proof (prove)\nusing this:\n  I {} (Finite_Set.fold f (f x s) A')\n  finite A'\n  x \\<notin> A'\n  \\<lbrakk>A' \\<subseteq> A; I A' ?s\\<rbrakk>\n  \\<Longrightarrow> I {} (Finite_Set.fold f ?s A')\n  insert x A' \\<subseteq> A\n  I (insert x A') s\n\ngoal (1 subgoal):\n 1. I {} (Finite_Set.fold f s (insert x A'))", "by(simp add: fold_insert2 del: fold_insert)"], ["proof (state)\nthis:\n  I {} (Finite_Set.fold f s (insert x A'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  I {} (Finite_Set.fold f s A')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in comp_fun_commute) fold_invariant_insert [consumes 1, case_names start step]:\n  assumes fin: \"finite A\"\n  and start: \"I {} s\"\n  and step: \"\\<And>x s A'. \\<lbrakk> I A' s; x \\<notin> A'; x \\<in> A; A' \\<subseteq> A \\<rbrakk> \\<Longrightarrow> I (insert x A') (f x s)\"\n  shows \"I A (Finite_Set.fold f s A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I A (Finite_Set.fold f s A)", "using fin start"], ["proof (prove)\nusing this:\n  finite A\n  I {} s\n\ngoal (1 subgoal):\n 1. I A (Finite_Set.fold f s A)", "proof(rule fold_invariant_remove[where I=\"\\<lambda>A'. I (A - A')\" and A=A and s=s, simplified])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x s A'.\n       \\<lbrakk>x \\<in> A'; I (A - A') s; A' \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> I (A - (A' - {x})) (f x s)", "fix x s A'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x s A'.\n       \\<lbrakk>x \\<in> A'; I (A - A') s; A' \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> I (A - (A' - {x})) (f x s)", "assume *: \"x \\<in> A'\" \"I (A - A') s\" \"A' \\<subseteq> A\""], ["proof (state)\nthis:\n  x \\<in> A'\n  I (A - A') s\n  A' \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>x s A'.\n       \\<lbrakk>x \\<in> A'; I (A - A') s; A' \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> I (A - (A' - {x})) (f x s)", "hence \"x \\<notin> A - A'\" \"x \\<in> A\" \"A - A' \\<subseteq> A\""], ["proof (prove)\nusing this:\n  x \\<in> A'\n  I (A - A') s\n  A' \\<subseteq> A\n\ngoal (1 subgoal):\n 1. x \\<notin> A - A' &&& x \\<in> A &&& A - A' \\<subseteq> A", "by auto"], ["proof (state)\nthis:\n  x \\<notin> A - A'\n  x \\<in> A\n  A - A' \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>x s A'.\n       \\<lbrakk>x \\<in> A'; I (A - A') s; A' \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> I (A - (A' - {x})) (f x s)", "with \\<open>I (A - A') s\\<close>"], ["proof (chain)\npicking this:\n  I (A - A') s\n  x \\<notin> A - A'\n  x \\<in> A\n  A - A' \\<subseteq> A", "have \"I (insert x (A - A')) (f x s)\""], ["proof (prove)\nusing this:\n  I (A - A') s\n  x \\<notin> A - A'\n  x \\<in> A\n  A - A' \\<subseteq> A\n\ngoal (1 subgoal):\n 1. I (insert x (A - A')) (f x s)", "by(rule step)"], ["proof (state)\nthis:\n  I (insert x (A - A')) (f x s)\n\ngoal (1 subgoal):\n 1. \\<And>x s A'.\n       \\<lbrakk>x \\<in> A'; I (A - A') s; A' \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> I (A - (A' - {x})) (f x s)", "also"], ["proof (state)\nthis:\n  I (insert x (A - A')) (f x s)\n\ngoal (1 subgoal):\n 1. \\<And>x s A'.\n       \\<lbrakk>x \\<in> A'; I (A - A') s; A' \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> I (A - (A' - {x})) (f x s)", "have \"insert x (A - A') = A - (A' - {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert x (A - A') = A - (A' - {x})", "using *"], ["proof (prove)\nusing this:\n  x \\<in> A'\n  I (A - A') s\n  A' \\<subseteq> A\n\ngoal (1 subgoal):\n 1. insert x (A - A') = A - (A' - {x})", "by auto"], ["proof (state)\nthis:\n  insert x (A - A') = A - (A' - {x})\n\ngoal (1 subgoal):\n 1. \\<And>x s A'.\n       \\<lbrakk>x \\<in> A'; I (A - A') s; A' \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> I (A - (A' - {x})) (f x s)", "finally"], ["proof (chain)\npicking this:\n  I (A - (A' - {x})) (f x s)", "show \"I \\<dots> (f x s)\""], ["proof (prove)\nusing this:\n  I (A - (A' - {x})) (f x s)\n\ngoal (1 subgoal):\n 1. I (A - (A' - {x})) (f x s)", "."], ["proof (state)\nthis:\n  I (A - (A' - {x})) (f x s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in comp_fun_idem) fold_set_union:\n  assumes \"finite A\" \"finite B\"\n  shows \"Finite_Set.fold f z (A \\<union> B) = Finite_Set.fold f (Finite_Set.fold f z A) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold f z (A \\<union> B) =\n    Finite_Set.fold f (Finite_Set.fold f z A) B", "using assms(2,1)"], ["proof (prove)\nusing this:\n  finite B\n  finite A\n\ngoal (1 subgoal):\n 1. Finite_Set.fold f z (A \\<union> B) =\n    Finite_Set.fold f (Finite_Set.fold f z A) B", "by induction simp_all"], ["", "subsection \\<open>Parametrisation of transfer rules\\<close>"], ["", "attribute_setup transfer_parametric = \\<open> \n  Attrib.thm >> (fn parametricity =>\n    Thm.rule_attribute [] (fn context => fn transfer_rule =>\n      let\n        val ctxt = Context.proof_of context;\n        val thm' = Lifting_Term.parametrize_transfer_rule ctxt transfer_rule\n      in Lifting_Def.generate_parametric_transfer_rule ctxt thm' parametricity\n      end\n      handle Lifting_Term.MERGE_TRANSFER_REL msg => error (Pretty.string_of msg)\n      ))\n\\<close> \"combine transfer rule with parametricity theorem\""], ["", "subsection \\<open>Lists\\<close>"], ["", "lemma nth_eq_tlI: \"xs ! n = z \\<Longrightarrow> (x # xs) ! Suc n = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ! n = z \\<Longrightarrow> (x # xs) ! Suc n = z", "by simp"], ["", "lemma list_all2_append':\n  \"length us = length vs \\<Longrightarrow> list_all2 P (xs @ us) (ys @ vs) \\<longleftrightarrow> list_all2 P xs ys \\<and> list_all2 P us vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length us = length vs \\<Longrightarrow>\n    list_all2 P (xs @ us) (ys @ vs) =\n    (list_all2 P xs ys \\<and> list_all2 P us vs)", "by(auto simp add: list_all2_append1 list_all2_append2 dest: list_all2_lengthD)"], ["", "definition disjointp :: \"('a \\<Rightarrow> bool) list \\<Rightarrow> bool\"\nwhere \"disjointp xs = disjoint_family_on (\\<lambda>n. {x. (xs ! n) x}) {0..<length xs}\""], ["", "lemma disjointpD:\n  \"\\<lbrakk> disjointp xs; (xs ! n) x; (xs ! m) x; n < length xs; m < length xs \\<rbrakk> \\<Longrightarrow> n = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>disjointp xs; (xs ! n) x; (xs ! m) x; n < length xs;\n     m < length xs\\<rbrakk>\n    \\<Longrightarrow> n = m", "by(auto 4 3 simp add: disjointp_def disjoint_family_on_def)"], ["", "lemma disjointpD':\n  \"\\<lbrakk> disjointp xs; P x; Q x; xs ! n = P; xs ! m = Q; n < length xs; m < length xs \\<rbrakk> \\<Longrightarrow> n = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>disjointp xs; P x; Q x; xs ! n = P; xs ! m = Q; n < length xs;\n     m < length xs\\<rbrakk>\n    \\<Longrightarrow> n = m", "by(auto 4 3 simp add: disjointp_def disjoint_family_on_def)"], ["", "lemma wf_strict_prefix: \"wfP strict_prefix\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP strict_prefix", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wfP strict_prefix", "from wf"], ["proof (chain)\npicking this:\n  wf {(x, y). x < y}", "have \"wf (inv_image {(x, y). x < y} length)\""], ["proof (prove)\nusing this:\n  wf {(x, y). x < y}\n\ngoal (1 subgoal):\n 1. wf (inv_image {(x, y). x < y} length)", "by(rule wf_inv_image)"], ["proof (state)\nthis:\n  wf (inv_image {(x, y). x < y} length)\n\ngoal (1 subgoal):\n 1. wfP strict_prefix", "moreover"], ["proof (state)\nthis:\n  wf (inv_image {(x, y). x < y} length)\n\ngoal (1 subgoal):\n 1. wfP strict_prefix", "have \"{(x, y). strict_prefix x y} \\<subseteq> inv_image {(x, y). x < y} length\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). strict_prefix x y} \\<subseteq> inv_image {(x, y). x < y} length", "by(auto intro: prefix_length_less)"], ["proof (state)\nthis:\n  {(x, y). strict_prefix x y} \\<subseteq> inv_image {(x, y). x < y} length\n\ngoal (1 subgoal):\n 1. wfP strict_prefix", "ultimately"], ["proof (chain)\npicking this:\n  wf (inv_image {(x, y). x < y} length)\n  {(x, y). strict_prefix x y} \\<subseteq> inv_image {(x, y). x < y} length", "show ?thesis"], ["proof (prove)\nusing this:\n  wf (inv_image {(x, y). x < y} length)\n  {(x, y). strict_prefix x y} \\<subseteq> inv_image {(x, y). x < y} length\n\ngoal (1 subgoal):\n 1. wfP strict_prefix", "unfolding wfP_def"], ["proof (prove)\nusing this:\n  wf (inv_image {(x, y). x < y} length)\n  {(x, y). strict_prefix x y} \\<subseteq> inv_image {(x, y). x < y} length\n\ngoal (1 subgoal):\n 1. wf {(x, y). strict_prefix x y}", "by(rule wf_subset)"], ["proof (state)\nthis:\n  wfP strict_prefix\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strict_prefix_setD:\n  \"strict_prefix xs ys \\<Longrightarrow> set xs \\<subseteq> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_prefix xs ys \\<Longrightarrow> set xs \\<subseteq> set ys", "by(auto simp add: strict_prefix_def prefix_def)"], ["", "subsubsection \\<open>List of a given length\\<close>"], ["", "inductive_set nlists :: \"'a set \\<Rightarrow> nat \\<Rightarrow> 'a list set\" for A n\nwhere nlists: \"\\<lbrakk> set xs \\<subseteq> A; length xs = n \\<rbrakk> \\<Longrightarrow> xs \\<in> nlists A n\""], ["", "hide_fact (open) nlists"], ["", "lemma nlists_alt_def: \"nlists A n = {xs. set xs \\<subseteq> A \\<and> length xs = n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nlists A n = {xs. set xs \\<subseteq> A \\<and> length xs = n}", "by(auto simp add: nlists.simps)"], ["", "lemma nlists_empty: \"nlists {} n = (if n = 0 then {[]} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nlists {} n = (if n = 0 then {[]} else {})", "by(auto simp add: nlists_alt_def)"], ["", "lemma nlists_empty_gt0 [simp]: \"n > 0 \\<Longrightarrow> nlists {} n = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> nlists {} n = {}", "by(simp add: nlists_empty)"], ["", "lemma nlists_0 [simp]: \"nlists A 0 = {[]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nlists A 0 = {[]}", "by(auto simp add: nlists_alt_def)"], ["", "lemma Cons_in_nlists_Suc [simp]: \"x # xs \\<in> nlists A (Suc n) \\<longleftrightarrow> x \\<in> A \\<and> xs \\<in> nlists A n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x # xs \\<in> nlists A (Suc n)) = (x \\<in> A \\<and> xs \\<in> nlists A n)", "by(simp add: nlists_alt_def)"], ["", "lemma Nil_in_nlists [simp]: \"[] \\<in> nlists A n \\<longleftrightarrow> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([] \\<in> nlists A n) = (n = 0)", "by(auto simp add: nlists_alt_def)"], ["", "lemma Cons_in_nlists_iff: \"x # xs \\<in> nlists A n \\<longleftrightarrow> (\\<exists>n'. n = Suc n' \\<and> x \\<in> A \\<and> xs \\<in> nlists A n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x # xs \\<in> nlists A n) =\n    (\\<exists>n'. n = Suc n' \\<and> x \\<in> A \\<and> xs \\<in> nlists A n')", "by(cases n) simp_all"], ["", "lemma in_nlists_Suc_iff: \"xs \\<in> nlists A (Suc n) \\<longleftrightarrow> (\\<exists>x xs'. xs = x # xs' \\<and> x \\<in> A \\<and> xs' \\<in> nlists A n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<in> nlists A (Suc n)) =\n    (\\<exists>x xs'.\n        xs = x # xs' \\<and> x \\<in> A \\<and> xs' \\<in> nlists A n)", "by(cases xs) simp_all"], ["", "lemma nlists_Suc: \"nlists A (Suc n) = (\\<Union>x\\<in>A. (#) x ` nlists A n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nlists A (Suc n) = (\\<Union>x\\<in>A. (#) x ` nlists A n)", "by(auto 4 3 simp add: in_nlists_Suc_iff intro: rev_image_eqI)"], ["", "lemma replicate_in_nlists [simp, intro]: \"x \\<in> A \\<Longrightarrow> replicate n x \\<in> nlists A n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow> replicate n x \\<in> nlists A n", "by(simp add: nlists_alt_def set_replicate_conv_if)"], ["", "lemma nlists_eq_empty_iff [simp]: \"nlists A n = {} \\<longleftrightarrow> n > 0 \\<and> A = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nlists A n = {}) = (0 < n \\<and> A = {})", "using replicate_in_nlists"], ["proof (prove)\nusing this:\n  ?x \\<in> ?A \\<Longrightarrow> replicate ?n ?x \\<in> nlists ?A ?n\n\ngoal (1 subgoal):\n 1. (nlists A n = {}) = (0 < n \\<and> A = {})", "by(cases n)(auto)"], ["", "lemma finite_nlists [simp]: \"finite A \\<Longrightarrow> finite (nlists A n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> finite (nlists A n)", "by(induction n)(simp_all add: nlists_Suc)"], ["", "lemma finite_nlistsD: \n  assumes \"finite (nlists A n)\"\n  shows \"finite A \\<or> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<or> n = 0", "proof(rule disjCI)"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> finite A", "assume \"n \\<noteq> 0\""], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> finite A", "then"], ["proof (chain)\npicking this:\n  n \\<noteq> 0", "obtain n' where n: \"n = Suc n'\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>n'. n = Suc n' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by(cases n)auto"], ["proof (state)\nthis:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> finite A", "then"], ["proof (chain)\npicking this:\n  n = Suc n'", "have \"A = hd ` nlists A n\""], ["proof (prove)\nusing this:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. A = hd ` nlists A n", "by(auto 4 4 simp add: nlists_Suc intro: rev_image_eqI rev_bexI)"], ["proof (state)\nthis:\n  A = hd ` nlists A n\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> finite A", "also"], ["proof (state)\nthis:\n  A = hd ` nlists A n\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> finite A", "have \"finite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (hd ` nlists A n)", "using assms"], ["proof (prove)\nusing this:\n  finite (nlists A n)\n\ngoal (1 subgoal):\n 1. finite (hd ` nlists A n)", ".."], ["proof (state)\nthis:\n  finite (hd ` nlists A n)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> finite A", "finally"], ["proof (chain)\npicking this:\n  finite A", "show \"finite A\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. finite A", "."], ["proof (state)\nthis:\n  finite A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_nlists_iff: \"finite (nlists A n) \\<longleftrightarrow> finite A \\<or> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nlists A n) = (finite A \\<or> n = 0)", "by(auto dest: finite_nlistsD)"], ["", "lemma card_nlists: \"card (nlists A n) = card A ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (nlists A n) = card A ^ n", "proof(induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. card (nlists A 0) = card A ^ 0\n 2. \\<And>n.\n       card (nlists A n) = card A ^ n \\<Longrightarrow>\n       card (nlists A (Suc n)) = card A ^ Suc n", "case (Suc n)"], ["proof (state)\nthis:\n  card (nlists A n) = card A ^ n\n\ngoal (2 subgoals):\n 1. card (nlists A 0) = card A ^ 0\n 2. \\<And>n.\n       card (nlists A n) = card A ^ n \\<Longrightarrow>\n       card (nlists A (Suc n)) = card A ^ Suc n", "have \"card (\\<Union>x\\<in>A. (#) x ` nlists A n) = card A * card (nlists A n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (\\<Union>x\\<in>A. (#) x ` nlists A n) = card A * card (nlists A n)", "proof(cases \"finite A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow>\n    card (\\<Union>x\\<in>A. (#) x ` nlists A n) = card A * card (nlists A n)\n 2. infinite A \\<Longrightarrow>\n    card (\\<Union>x\\<in>A. (#) x ` nlists A n) = card A * card (nlists A n)", "case True"], ["proof (state)\nthis:\n  finite A\n\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow>\n    card (\\<Union>x\\<in>A. (#) x ` nlists A n) = card A * card (nlists A n)\n 2. infinite A \\<Longrightarrow>\n    card (\\<Union>x\\<in>A. (#) x ` nlists A n) = card A * card (nlists A n)", "then"], ["proof (chain)\npicking this:\n  finite A", "show ?thesis"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. card (\\<Union>x\\<in>A. (#) x ` nlists A n) = card A * card (nlists A n)", "by(subst card_UN_disjoint)(auto simp add: card_image inj_on_def)"], ["proof (state)\nthis:\n  card (\\<Union>x\\<in>A. (#) x ` nlists A n) = card A * card (nlists A n)\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow>\n    card (\\<Union>x\\<in>A. (#) x ` nlists A n) = card A * card (nlists A n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow>\n    card (\\<Union>x\\<in>A. (#) x ` nlists A n) = card A * card (nlists A n)", "case False"], ["proof (state)\nthis:\n  infinite A\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow>\n    card (\\<Union>x\\<in>A. (#) x ` nlists A n) = card A * card (nlists A n)", "hence \"\\<not> finite (\\<Union>x\\<in>A. (#) x ` nlists A n)\""], ["proof (prove)\nusing this:\n  infinite A\n\ngoal (1 subgoal):\n 1. infinite (\\<Union>x\\<in>A. (#) x ` nlists A n)", "unfolding nlists_Suc[symmetric]"], ["proof (prove)\nusing this:\n  infinite A\n\ngoal (1 subgoal):\n 1. infinite (nlists A (Suc n))", "by(auto dest: finite_nlistsD)"], ["proof (state)\nthis:\n  infinite (\\<Union>x\\<in>A. (#) x ` nlists A n)\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow>\n    card (\\<Union>x\\<in>A. (#) x ` nlists A n) = card A * card (nlists A n)", "then"], ["proof (chain)\npicking this:\n  infinite (\\<Union>x\\<in>A. (#) x ` nlists A n)", "show ?thesis"], ["proof (prove)\nusing this:\n  infinite (\\<Union>x\\<in>A. (#) x ` nlists A n)\n\ngoal (1 subgoal):\n 1. card (\\<Union>x\\<in>A. (#) x ` nlists A n) = card A * card (nlists A n)", "using False"], ["proof (prove)\nusing this:\n  infinite (\\<Union>x\\<in>A. (#) x ` nlists A n)\n  infinite A\n\ngoal (1 subgoal):\n 1. card (\\<Union>x\\<in>A. (#) x ` nlists A n) = card A * card (nlists A n)", "by simp"], ["proof (state)\nthis:\n  card (\\<Union>x\\<in>A. (#) x ` nlists A n) = card A * card (nlists A n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (\\<Union>x\\<in>A. (#) x ` nlists A n) = card A * card (nlists A n)\n\ngoal (2 subgoals):\n 1. card (nlists A 0) = card A ^ 0\n 2. \\<And>n.\n       card (nlists A n) = card A ^ n \\<Longrightarrow>\n       card (nlists A (Suc n)) = card A ^ Suc n", "then"], ["proof (chain)\npicking this:\n  card (\\<Union>x\\<in>A. (#) x ` nlists A n) = card A * card (nlists A n)", "show ?case"], ["proof (prove)\nusing this:\n  card (\\<Union>x\\<in>A. (#) x ` nlists A n) = card A * card (nlists A n)\n\ngoal (1 subgoal):\n 1. card (nlists A (Suc n)) = card A ^ Suc n", "using Suc.IH"], ["proof (prove)\nusing this:\n  card (\\<Union>x\\<in>A. (#) x ` nlists A n) = card A * card (nlists A n)\n  card (nlists A n) = card A ^ n\n\ngoal (1 subgoal):\n 1. card (nlists A (Suc n)) = card A ^ Suc n", "by(simp add: nlists_Suc)"], ["proof (state)\nthis:\n  card (nlists A (Suc n)) = card A ^ Suc n\n\ngoal (1 subgoal):\n 1. card (nlists A 0) = card A ^ 0", "qed simp"], ["", "lemma in_nlists_UNIV: \"xs \\<in> nlists UNIV n \\<longleftrightarrow> length xs = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<in> nlists UNIV n) = (length xs = n)", "by(simp add: nlists_alt_def)"], ["", "subsubsection \\<open> The type of lists of a given length \\<close>"], ["", "typedef (overloaded) ('a, 'b :: len0) nlist = \"nlists (UNIV :: 'a set) (LENGTH('b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> nlists UNIV LENGTH('b)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> nlists UNIV LENGTH('b)", "show \"replicate LENGTH('b) undefined \\<in> ?nlist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate LENGTH('b) undefined \\<in> nlists UNIV LENGTH('b)", "by simp"], ["proof (state)\nthis:\n  replicate LENGTH('b) undefined \\<in> nlists UNIV LENGTH('b)\n\ngoal:\nNo subgoals!", "qed"], ["", "setup_lifting type_definition_nlist"], ["", "subsection \\<open>Streams and infinite lists\\<close>"], ["", "primrec sprefix :: \"'a list \\<Rightarrow> 'a stream \\<Rightarrow> bool\" where\n  sprefix_Nil: \"sprefix [] ys = True\"\n| sprefix_Cons: \"sprefix (x # xs) ys \\<longleftrightarrow> x = shd ys \\<and> sprefix xs (stl ys)\""], ["", "lemma sprefix_append: \"sprefix (xs @ ys) zs \\<longleftrightarrow> sprefix xs zs \\<and> sprefix ys (sdrop (length xs) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sprefix (xs @ ys) zs =\n    (sprefix xs zs \\<and> sprefix ys (sdrop (length xs) zs))", "by(induct xs arbitrary: zs) simp_all"], ["", "lemma sprefix_stake_same [simp]: \"sprefix (stake n xs) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sprefix (stake n xs) xs", "by(induct n arbitrary: xs) simp_all"], ["", "lemma sprefix_same_imp_eq:\n  assumes \"sprefix xs ys\" \"sprefix xs' ys\"\n  and \"length xs = length xs'\"\n  shows \"xs = xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = xs'", "using assms(3,1,2)"], ["proof (prove)\nusing this:\n  length xs = length xs'\n  sprefix xs ys\n  sprefix xs' ys\n\ngoal (1 subgoal):\n 1. xs = xs'", "by(induct arbitrary: ys rule: list_induct2) auto"], ["", "lemma sprefix_shift_same [simp]:\n  \"sprefix xs (xs @- ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sprefix xs (xs @- ys)", "by(induct xs) simp_all"], ["", "lemma sprefix_shift [simp]:\n  \"length xs \\<le> length ys \\<Longrightarrow> sprefix xs (ys @- zs) \\<longleftrightarrow> prefix xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<le> length ys \\<Longrightarrow>\n    sprefix xs (ys @- zs) = prefix xs ys", "by(induct xs arbitrary: ys)(simp, case_tac ys, auto)"], ["", "lemma prefixeq_stake2 [simp]: \"prefix xs (stake n ys) \\<longleftrightarrow> length xs \\<le> n \\<and> sprefix xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix xs (stake n ys) = (length xs \\<le> n \\<and> sprefix xs ys)", "proof(induct xs arbitrary: n ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n ys.\n       prefix [] (stake n ys) = (length [] \\<le> n \\<and> sprefix [] ys)\n 2. \\<And>a xs n ys.\n       (\\<And>n ys.\n           prefix xs (stake n ys) =\n           (length xs \\<le> n \\<and> sprefix xs ys)) \\<Longrightarrow>\n       prefix (a # xs) (stake n ys) =\n       (length (a # xs) \\<le> n \\<and> sprefix (a # xs) ys)", "case (Cons x xs)"], ["proof (state)\nthis:\n  prefix xs (stake ?n ?ys) = (length xs \\<le> ?n \\<and> sprefix xs ?ys)\n\ngoal (2 subgoals):\n 1. \\<And>n ys.\n       prefix [] (stake n ys) = (length [] \\<le> n \\<and> sprefix [] ys)\n 2. \\<And>a xs n ys.\n       (\\<And>n ys.\n           prefix xs (stake n ys) =\n           (length xs \\<le> n \\<and> sprefix xs ys)) \\<Longrightarrow>\n       prefix (a # xs) (stake n ys) =\n       (length (a # xs) \\<le> n \\<and> sprefix (a # xs) ys)", "thus ?case"], ["proof (prove)\nusing this:\n  prefix xs (stake ?n ?ys) = (length xs \\<le> ?n \\<and> sprefix xs ?ys)\n\ngoal (1 subgoal):\n 1. prefix (x # xs) (stake n ys) =\n    (length (x # xs) \\<le> n \\<and> sprefix (x # xs) ys)", "by(cases ys n rule: stream.exhaust[case_product nat.exhaust]) auto"], ["proof (state)\nthis:\n  prefix (x # xs) (stake n ys) =\n  (length (x # xs) \\<le> n \\<and> sprefix (x # xs) ys)\n\ngoal (1 subgoal):\n 1. \\<And>n ys.\n       prefix [] (stake n ys) = (length [] \\<le> n \\<and> sprefix [] ys)", "qed simp"], ["", "lemma tlength_eq_infinity_iff: \"tlength xs = \\<infinity> \\<longleftrightarrow> \\<not> tfinite xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tlength xs = \\<infinity>) = (\\<not> tfinite xs)", "including tllist.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. (tlength xs = \\<infinity>) = (\\<not> tfinite xs)", "by transfer(simp add: llength_eq_infty_conv_lfinite)"], ["", "subsection \\<open>Monomorphic monads\\<close>"], ["", "context includes lifting_syntax begin"], ["", "local_setup \\<open>Local_Theory.map_background_naming (Name_Space.mandatory_path \"monad\")\\<close>"], ["", "definition bind_option :: \"'m fail \\<Rightarrow> 'a option \\<Rightarrow> ('a \\<Rightarrow> 'm) \\<Rightarrow> 'm\"\nwhere \"bind_option fail x f = (case x of None \\<Rightarrow> fail | Some x' \\<Rightarrow> f x')\" for fail"], ["", "simps_of_case bind_option_simps [simp]: bind_option_def"], ["", "lemma bind_option_parametric [transfer_rule]:\n  \"(M ===> rel_option B ===> (B ===> M) ===> M) bind_option bind_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M ===> rel_option B ===> (B ===> M) ===> M) local.bind_option\n     local.bind_option", "unfolding bind_option_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (M ===> rel_option B ===> (B ===> M) ===> M)\n     (\\<lambda>fail x f.\n         case x of None \\<Rightarrow> fail | Some x \\<Rightarrow> f x)\n     (\\<lambda>fail x f.\n         case x of None \\<Rightarrow> fail | Some x \\<Rightarrow> f x)", "by transfer_prover"], ["", "lemma bind_option_K:\n  \"\\<And>monad. (x = None \\<Longrightarrow> m = fail) \\<Longrightarrow> bind_option fail x (\\<lambda>_. m) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>monad.\n       (x = None \\<Longrightarrow> m = fail) \\<Longrightarrow>\n       local.bind_option fail x (\\<lambda>_. m) = m", "by(cases x) simp_all"], ["", "end"], ["", "lemma bind_option_option [simp]: \"monad.bind_option None = Option.bind\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad.bind_option None = (\\<bind>)", "by(simp add: monad.bind_option_def fun_eq_iff split: option.split)"], ["", "context monad_fail_hom begin"], ["", "lemma hom_bind_option: \"h (monad.bind_option fail1 x f) = monad.bind_option fail2 x (h \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h (monad.bind_option fail1 x f) =\n    monad.bind_option fail2 x (h \\<circ> f)", "by(cases x)(simp_all)"], ["", "end"], ["", "lemma bind_option_set [simp]: \"monad.bind_option fail_set = (\\<lambda>x f. \\<Union> (f ` set_option x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad.bind_option {} = (\\<lambda>x f. \\<Union> (f ` set_option x))", "by(simp add: monad.bind_option_def fun_eq_iff split: option.split)"], ["", "lemma run_bind_option_stateT [simp]:\n  \"\\<And>more. run_state (monad.bind_option (fail_state fail) x f) s = \n  monad.bind_option fail x (\\<lambda>y. run_state (f y) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>more.\n       run_state (monad.bind_option (fail_state fail) x f) s =\n       monad.bind_option fail x (\\<lambda>y. run_state (f y) s)", "by(cases x) simp_all"], ["", "lemma run_bind_option_envT [simp]:\n  \"\\<And>more. run_env (monad.bind_option (fail_env fail) x f) s = \n  monad.bind_option fail x (\\<lambda>y. run_env (f y) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>more.\n       run_env (monad.bind_option (fail_env fail) x f) s =\n       monad.bind_option fail x (\\<lambda>y. run_env (f y) s)", "by(cases x) simp_all"], ["", "subsection \\<open>Measures\\<close>"], ["", "declare sets_restrict_space_count_space [measurable_cong]"], ["", "lemma (in sigma_algebra) sets_Collect_countable_Ex1:\n  \"(\\<And>i :: 'i :: countable. {x \\<in> \\<Omega>. P i x} \\<in> M) \\<Longrightarrow> {x \\<in> \\<Omega>. \\<exists>!i. P i x} \\<in> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. {x \\<in> \\<Omega>. P i x} \\<in> M) \\<Longrightarrow>\n    {x \\<in> \\<Omega>. \\<exists>!i. P i x} \\<in> M", "using sets_Collect_countable_Ex1'[of \"UNIV :: 'i set\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>i.\n              i \\<in> UNIV \\<Longrightarrow>\n              {x \\<in> \\<Omega>. ?P i x} \\<in> M;\n   countable UNIV\\<rbrakk>\n  \\<Longrightarrow> {x \\<in> \\<Omega>.\n                     \\<exists>!i. i \\<in> UNIV \\<and> ?P i x}\n                    \\<in> M\n\ngoal (1 subgoal):\n 1. (\\<And>i. {x \\<in> \\<Omega>. P i x} \\<in> M) \\<Longrightarrow>\n    {x \\<in> \\<Omega>. \\<exists>!i. P i x} \\<in> M", "by simp"], ["", "lemma pred_countable_Ex1 [measurable]:\n  \"(\\<And>i :: _ :: countable. Measurable.pred M (\\<lambda>x. P i x))\n  \\<Longrightarrow> Measurable.pred M (\\<lambda>x. \\<exists>!i. P i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. Measurable.pred M (P i)) \\<Longrightarrow>\n    Measurable.pred M (\\<lambda>x. \\<exists>!i. P i x)", "unfolding pred_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. {x \\<in> space M. P i x} \\<in> sets M) \\<Longrightarrow>\n    {x \\<in> space M. \\<exists>!i. P i x} \\<in> sets M", "by(rule sets.sets_Collect_countable_Ex1)"], ["", "lemma measurable_snd_count_space [measurable]: \n  \"A \\<subseteq> B \\<Longrightarrow> snd \\<in> measurable (M1 \\<Otimes>\\<^sub>M count_space A) (count_space B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow>\n    snd\n    \\<in> M1 \\<Otimes>\\<^sub>M count_space A \\<rightarrow>\\<^sub>M\n          count_space B", "by(auto simp add: measurable_def space_pair_measure snd_vimage_eq_Times Times_Int_Times)"], ["", "lemma integrable_scale_measure [simp]:\n  \"\\<lbrakk> integrable M f; r < \\<top> \\<rbrakk> \\<Longrightarrow> integrable (scale_measure r M) f\" \n  for f :: \"'a \\<Rightarrow> 'b::{banach, second_countable_topology}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>integrable M f; r < \\<top>\\<rbrakk>\n    \\<Longrightarrow> integrable (scale_measure r M) f", "by(auto simp add: integrable_iff_bounded nn_integral_scale_measure ennreal_mult_less_top)"], ["", "lemma integral_scale_measure:\n  assumes \"integrable M f\" \"r < \\<top>\"\n  shows \"integral\\<^sup>L (scale_measure r M) f = enn2real r * integral\\<^sup>L M f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>L (scale_measure r M) f =\n    enn2real r * integral\\<^sup>L M f", "using assms"], ["proof (prove)\nusing this:\n  integrable M f\n  r < \\<top>\n\ngoal (1 subgoal):\n 1. integral\\<^sup>L (scale_measure r M) f =\n    enn2real r * integral\\<^sup>L M f", "apply(subst (1 2) real_lebesgue_integral_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>integrable M f; r < \\<top>\\<rbrakk>\n    \\<Longrightarrow> integrable M f\n 2. \\<lbrakk>integrable M f; r < \\<top>\\<rbrakk>\n    \\<Longrightarrow> integrable (scale_measure r M) f\n 3. \\<lbrakk>integrable M f; r < \\<top>\\<rbrakk>\n    \\<Longrightarrow> enn2real\n                       (\\<integral>\\<^sup>+ x. ennreal (f x)\n     \\<partial>scale_measure r M) -\n                      enn2real\n                       (\\<integral>\\<^sup>+ x. ennreal (- f x)\n     \\<partial>scale_measure r M) =\n                      enn2real r *\n                      (enn2real\n                        (\\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>M) -\n                       enn2real\n                        (\\<integral>\\<^sup>+ x. ennreal (- f x)\n      \\<partial>M))", "apply(simp_all add: nn_integral_scale_measure ennreal_enn2real_if)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>integrable M f; r < \\<top>\\<rbrakk>\n    \\<Longrightarrow> enn2real\n                       (r *\n                        \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>M) -\n                      enn2real\n                       (r *\n                        \\<integral>\\<^sup>+ x. ennreal (- f x)\n     \\<partial>M) =\n                      enn2real r *\n                      (enn2real\n                        (\\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>M) -\n                       enn2real\n                        (\\<integral>\\<^sup>+ x. ennreal (- f x)\n      \\<partial>M))", "by(auto simp add: ennreal_mult_less_top ennreal_less_top_iff ennreal_mult_eq_top_iff enn2real_mult right_diff_distrib elim!: integrableE)"], ["", "subsection \\<open>Sequence space\\<close>"], ["", "lemma (in sequence_space) nn_integral_split:\n  assumes f[measurable]: \"f \\<in> borel_measurable S\"\n  shows \"(\\<integral>\\<^sup>+\\<omega>. f \\<omega> \\<partial>S) = (\\<integral>\\<^sup>+\\<omega>. (\\<integral>\\<^sup>+\\<omega>'. f (comb_seq i \\<omega> \\<omega>') \\<partial>S) \\<partial>S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (Pi\\<^sub>M UNIV (\\<lambda>i. M)) f =\n    \\<integral>\\<^sup>+ \\<omega>.\n                         \\<integral>\\<^sup>+ \\<omega>'.\n        f (comb_seq i \\<omega> \\<omega>')\n      \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M)\n                       \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M)", "by (subst PiM_comb_seq[symmetric, where i=i])\n   (simp add: nn_integral_distr P.nn_integral_fst[symmetric])"], ["", "lemma (in sequence_space) prob_Collect_split:\n  assumes f[measurable]: \"{x\\<in>space S. P x} \\<in> sets S\"\n  shows \"\\<P>(x in S. P x) = (\\<integral>\\<^sup>+x. \\<P>(x' in S. P (comb_seq i x x')) \\<partial>S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (P.prob {x \\<in> space (Pi\\<^sub>M UNIV (\\<lambda>i. M)). P x}) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (P.prob\n                              {x' \\<in> space\n   (Pi\\<^sub>M UNIV (\\<lambda>i. M)).\n                               P (comb_seq i x x')})\n                       \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ennreal\n     (P.prob {x \\<in> space (Pi\\<^sub>M UNIV (\\<lambda>i. M)). P x}) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (P.prob\n                              {x' \\<in> space\n   (Pi\\<^sub>M UNIV (\\<lambda>i. M)).\n                               P (comb_seq i x x')})\n                       \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M)", "have \"\\<P>(x in S. P x) = (\\<integral>\\<^sup>+x. (\\<integral>\\<^sup>+x'. indicator {x\\<in>space S. P x} (comb_seq i x x') \\<partial>S) \\<partial>S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (P.prob {x \\<in> space (Pi\\<^sub>M UNIV (\\<lambda>i. M)). P x}) =\n    \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ x'.\n          indicator {x \\<in> space (Pi\\<^sub>M UNIV (\\<lambda>i. M)). P x}\n           (comb_seq i x x')\n        \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M)\n                       \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M)", "using nn_integral_split[of \"indicator {x\\<in>space S. P x}\"]"], ["proof (prove)\nusing this:\n  P.random_variable borel\n   (indicator\n     {x \\<in> space (Pi\\<^sub>M UNIV (\\<lambda>i. M)).\n      P x}) \\<Longrightarrow>\n  integral\\<^sup>N (Pi\\<^sub>M UNIV (\\<lambda>i. M))\n   (indicator {x \\<in> space (Pi\\<^sub>M UNIV (\\<lambda>i. M)). P x}) =\n  \\<integral>\\<^sup>+ \\<omega>.\n                       \\<integral>\\<^sup>+ \\<omega>'.\n      indicator {x \\<in> space (Pi\\<^sub>M UNIV (\\<lambda>i. M)). P x}\n       (comb_seq ?i \\<omega> \\<omega>')\n    \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M)\n                     \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M)\n\ngoal (1 subgoal):\n 1. ennreal\n     (P.prob {x \\<in> space (Pi\\<^sub>M UNIV (\\<lambda>i. M)). P x}) =\n    \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ x'.\n          indicator {x \\<in> space (Pi\\<^sub>M UNIV (\\<lambda>i. M)). P x}\n           (comb_seq i x x')\n        \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M)\n                       \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M)", "by (auto simp: emeasure_eq_measure)"], ["proof (state)\nthis:\n  ennreal (P.prob {x \\<in> space (Pi\\<^sub>M UNIV (\\<lambda>i. M)). P x}) =\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ x'.\n        indicator {x \\<in> space (Pi\\<^sub>M UNIV (\\<lambda>i. M)). P x}\n         (comb_seq i x x')\n      \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M)\n                     \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M)\n\ngoal (1 subgoal):\n 1. ennreal\n     (P.prob {x \\<in> space (Pi\\<^sub>M UNIV (\\<lambda>i. M)). P x}) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (P.prob\n                              {x' \\<in> space\n   (Pi\\<^sub>M UNIV (\\<lambda>i. M)).\n                               P (comb_seq i x x')})\n                       \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M)", "also"], ["proof (state)\nthis:\n  ennreal (P.prob {x \\<in> space (Pi\\<^sub>M UNIV (\\<lambda>i. M)). P x}) =\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ x'.\n        indicator {x \\<in> space (Pi\\<^sub>M UNIV (\\<lambda>i. M)). P x}\n         (comb_seq i x x')\n      \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M)\n                     \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M)\n\ngoal (1 subgoal):\n 1. ennreal\n     (P.prob {x \\<in> space (Pi\\<^sub>M UNIV (\\<lambda>i. M)). P x}) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (P.prob\n                              {x' \\<in> space\n   (Pi\\<^sub>M UNIV (\\<lambda>i. M)).\n                               P (comb_seq i x x')})\n                       \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M)", "have \"\\<dots> = (\\<integral>\\<^sup>+x. \\<P>(x' in S. P (comb_seq i x x')) \\<partial>S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ x'.\n          indicator {x \\<in> space (Pi\\<^sub>M UNIV (\\<lambda>i. M)). P x}\n           (comb_seq i x x')\n        \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M)\n                       \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (P.prob\n                              {x' \\<in> space\n   (Pi\\<^sub>M UNIV (\\<lambda>i. M)).\n                               P (comb_seq i x x')})\n                       \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M)", "by (intro nn_integral_cong) (auto simp: emeasure_eq_measure nn_integral_indicator_map)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ x'.\n        indicator {x \\<in> space (Pi\\<^sub>M UNIV (\\<lambda>i. M)). P x}\n         (comb_seq i x x')\n      \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M)\n                     \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M) =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (P.prob\n                            {x' \\<in> space\n (Pi\\<^sub>M UNIV (\\<lambda>i. M)).\n                             P (comb_seq i x x')})\n                     \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M)\n\ngoal (1 subgoal):\n 1. ennreal\n     (P.prob {x \\<in> space (Pi\\<^sub>M UNIV (\\<lambda>i. M)). P x}) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (P.prob\n                              {x' \\<in> space\n   (Pi\\<^sub>M UNIV (\\<lambda>i. M)).\n                               P (comb_seq i x x')})\n                       \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M)", "finally"], ["proof (chain)\npicking this:\n  ennreal (P.prob {x \\<in> space (Pi\\<^sub>M UNIV (\\<lambda>i. M)). P x}) =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (P.prob\n                            {x' \\<in> space\n (Pi\\<^sub>M UNIV (\\<lambda>i. M)).\n                             P (comb_seq i x x')})\n                     \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M)", "show ?thesis"], ["proof (prove)\nusing this:\n  ennreal (P.prob {x \\<in> space (Pi\\<^sub>M UNIV (\\<lambda>i. M)). P x}) =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (P.prob\n                            {x' \\<in> space\n (Pi\\<^sub>M UNIV (\\<lambda>i. M)).\n                             P (comb_seq i x x')})\n                     \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M)\n\ngoal (1 subgoal):\n 1. ennreal\n     (P.prob {x \\<in> space (Pi\\<^sub>M UNIV (\\<lambda>i. M)). P x}) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (P.prob\n                              {x' \\<in> space\n   (Pi\\<^sub>M UNIV (\\<lambda>i. M)).\n                               P (comb_seq i x x')})\n                       \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M)", "."], ["proof (state)\nthis:\n  ennreal (P.prob {x \\<in> space (Pi\\<^sub>M UNIV (\\<lambda>i. M)). P x}) =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (P.prob\n                            {x' \\<in> space\n (Pi\\<^sub>M UNIV (\\<lambda>i. M)).\n                             P (comb_seq i x x')})\n                     \\<partial>Pi\\<^sub>M UNIV (\\<lambda>i. M)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Probability mass functions\\<close>"], ["", "lemma measure_map_pmf_conv_distr:\n  \"measure_pmf (map_pmf f p) = distr (measure_pmf p) (count_space UNIV) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf (map_pmf f p) = distr (measure_pmf p) (count_space UNIV) f", "by(fact map_pmf_rep_eq)"], ["", "abbreviation coin_pmf :: \"bool pmf\" where \"coin_pmf \\<equiv> pmf_of_set UNIV\""], ["", "text \\<open>The rule @{thm [source] rel_pmf_bindI} is not complete as a program logic.\\<close>"], ["", "notepad begin"], ["proof (state)", "define x where \"x = pmf_of_set {True, False}\""], ["proof (state)\nthis:\n  x = pmf_of_set {True, False}", "define y where \"y = pmf_of_set {True, False}\""], ["proof (state)\nthis:\n  y = pmf_of_set {True, False}", "define f where \"f x = pmf_of_set {True, False}\" for x :: bool"], ["proof (state)\nthis:\n  f ?x = pmf_of_set {True, False}", "define g :: \"bool \\<Rightarrow> bool pmf\" where \"g = return_pmf\""], ["proof (state)\nthis:\n  g = return_pmf", "define P :: \"bool \\<Rightarrow> bool \\<Rightarrow> bool\" where \"P = (=)\""], ["proof (state)\nthis:\n  P = (=)", "have \"rel_pmf P (bind_pmf x f) (bind_pmf y g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_pmf P (x \\<bind> f) (y \\<bind> g)", "by(simp add: P_def f_def[abs_def] g_def y_def bind_return_pmf' pmf.rel_eq)"], ["proof (state)\nthis:\n  rel_pmf P (x \\<bind> f) (y \\<bind> g)", "have \"\\<not> R x y\" if \"\\<And>x y. R x y \\<Longrightarrow> rel_pmf P (f x) (g y)\" for R x y\n    \\<comment> \\<open>Only the empty relation satisfies @{thm [source] rel_pmf_bindI}'s second premise.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> R x y", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. R x y \\<Longrightarrow> False", "assume \"R x y\""], ["proof (state)\nthis:\n  R x y\n\ngoal (1 subgoal):\n 1. R x y \\<Longrightarrow> False", "hence \"rel_pmf P (f x) (g y)\""], ["proof (prove)\nusing this:\n  R x y\n\ngoal (1 subgoal):\n 1. rel_pmf P (f x) (g y)", "by(rule that)"], ["proof (state)\nthis:\n  rel_pmf P (f x) (g y)\n\ngoal (1 subgoal):\n 1. R x y \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  rel_pmf P (f x) (g y)\n\ngoal (1 subgoal):\n 1. False", "by(auto simp add: P_def f_def g_def rel_pmf_return_pmf2)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<And>x y.\n      ?R x y \\<Longrightarrow> rel_pmf P (f x) (g y)) \\<Longrightarrow>\n  \\<not> ?R ?x ?y", "define R where \"R x y = False\" for x y :: bool"], ["proof (state)\nthis:\n  R ?x ?y = False", "have \"\\<not> rel_pmf R x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> rel_pmf R x y", "by(simp add: R_def[abs_def])"], ["proof (state)\nthis:\n  \\<not> rel_pmf R x y", "end"], ["", "lemma pred_rel_pmf:\n  \"\\<lbrakk> pred_pmf P p; rel_pmf R p q \\<rbrakk> \\<Longrightarrow> pred_pmf (Imagep R P) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pred_pmf P p; rel_pmf R p q\\<rbrakk>\n    \\<Longrightarrow> pred_pmf (Imagep R P) q", "unfolding pred_pmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ball (set_pmf p) P; rel_pmf R p q\\<rbrakk>\n    \\<Longrightarrow> Ball (set_pmf q) (Imagep R P)", "apply(rule ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Ball (set_pmf p) P; rel_pmf R p q;\n        x \\<in> set_pmf q\\<rbrakk>\n       \\<Longrightarrow> Imagep R P x", "apply(unfold rel_pmf.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Ball (set_pmf p) P;\n        \\<exists>pq.\n           (\\<forall>x xa.\n               (x, xa) \\<in> set_pmf pq \\<longrightarrow> R x xa) \\<and>\n           map_pmf fst pq = p \\<and> map_pmf snd pq = q;\n        x \\<in> set_pmf q\\<rbrakk>\n       \\<Longrightarrow> Imagep R P x", "apply(erule exE conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x pq.\n       \\<lbrakk>Ball (set_pmf p) P; x \\<in> set_pmf q;\n        \\<forall>x xa. (x, xa) \\<in> set_pmf pq \\<longrightarrow> R x xa;\n        map_pmf fst pq = p; map_pmf snd pq = q\\<rbrakk>\n       \\<Longrightarrow> Imagep R P x", "apply hypsubst"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x pq.\n       \\<lbrakk>Ball (set_pmf (map_pmf fst pq)) P;\n        x \\<in> set_pmf (map_pmf snd pq);\n        \\<forall>x xa. (x, xa) \\<in> set_pmf pq \\<longrightarrow> R x xa;\n        p = map_pmf fst pq; q = map_pmf snd pq\\<rbrakk>\n       \\<Longrightarrow> Imagep R P x", "apply(unfold pmf.set_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x pq.\n       \\<lbrakk>Ball (fst ` set_pmf pq) P; x \\<in> snd ` set_pmf pq;\n        \\<forall>x xa. (x, xa) \\<in> set_pmf pq \\<longrightarrow> R x xa;\n        p = map_pmf fst pq; q = map_pmf snd pq\\<rbrakk>\n       \\<Longrightarrow> Imagep R P x", "apply(erule imageE, hypsubst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x pq xa.\n       \\<lbrakk>Ball (fst ` set_pmf pq) P;\n        \\<forall>x xa. (x, xa) \\<in> set_pmf pq \\<longrightarrow> R x xa;\n        p = map_pmf fst pq; q = map_pmf snd pq; xa \\<in> set_pmf pq\\<rbrakk>\n       \\<Longrightarrow> Imagep R P (snd xa)", "apply(drule bspec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x pq xa.\n       \\<lbrakk>\\<forall>x xa.\n                   (x, xa) \\<in> set_pmf pq \\<longrightarrow> R x xa;\n        p = map_pmf fst pq; q = map_pmf snd pq; xa \\<in> set_pmf pq\\<rbrakk>\n       \\<Longrightarrow> ?x17 x pq xa \\<in> fst ` set_pmf pq\n 2. \\<And>x pq xa.\n       \\<lbrakk>\\<forall>x xa.\n                   (x, xa) \\<in> set_pmf pq \\<longrightarrow> R x xa;\n        p = map_pmf fst pq; q = map_pmf snd pq; xa \\<in> set_pmf pq;\n        P (?x17 x pq xa)\\<rbrakk>\n       \\<Longrightarrow> Imagep R P (snd xa)", "apply(erule rev_image_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x pq xa.\n       \\<lbrakk>\\<forall>x xa.\n                   (x, xa) \\<in> set_pmf pq \\<longrightarrow> R x xa;\n        p = map_pmf fst pq; q = map_pmf snd pq\\<rbrakk>\n       \\<Longrightarrow> ?x17 x pq xa = fst xa\n 2. \\<And>x pq xa.\n       \\<lbrakk>\\<forall>x xa.\n                   (x, xa) \\<in> set_pmf pq \\<longrightarrow> R x xa;\n        p = map_pmf fst pq; q = map_pmf snd pq; xa \\<in> set_pmf pq;\n        P (?x17 x pq xa)\\<rbrakk>\n       \\<Longrightarrow> Imagep R P (snd xa)", "apply(rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x pq xa.\n       \\<lbrakk>\\<forall>x xa.\n                   (x, xa) \\<in> set_pmf pq \\<longrightarrow> R x xa;\n        p = map_pmf fst pq; q = map_pmf snd pq; xa \\<in> set_pmf pq;\n        P (fst xa)\\<rbrakk>\n       \\<Longrightarrow> Imagep R P (snd xa)", "apply(erule Imagep.intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x pq xa.\n       \\<lbrakk>\\<forall>x xa.\n                   (x, xa) \\<in> set_pmf pq \\<longrightarrow> R x xa;\n        p = map_pmf fst pq; q = map_pmf snd pq; xa \\<in> set_pmf pq\\<rbrakk>\n       \\<Longrightarrow> R (fst xa) (snd xa)", "apply(erule allE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x pq xa.\n       \\<lbrakk>p = map_pmf fst pq; q = map_pmf snd pq; xa \\<in> set_pmf pq;\n        (?x25 x pq xa, ?x27 x pq xa) \\<in> set_pmf pq \\<longrightarrow>\n        R (?x25 x pq xa) (?x27 x pq xa)\\<rbrakk>\n       \\<Longrightarrow> R (fst xa) (snd xa)", "apply(erule mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x pq xa.\n       \\<lbrakk>p = map_pmf fst pq; q = map_pmf snd pq;\n        xa \\<in> set_pmf pq\\<rbrakk>\n       \\<Longrightarrow> (fst xa, snd xa) \\<in> set_pmf pq", "apply(unfold prod.collapse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x pq xa.\n       \\<lbrakk>p = map_pmf fst pq; q = map_pmf snd pq;\n        xa \\<in> set_pmf pq\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> set_pmf pq", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pmf_rel_mono': \"\\<lbrakk> rel_pmf P x y; P \\<le> Q \\<rbrakk> \\<Longrightarrow> rel_pmf Q x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel_pmf P x y; P \\<le> Q\\<rbrakk>\n    \\<Longrightarrow> rel_pmf Q x y", "by(drule pmf.rel_mono) (auto)"], ["", "lemma rel_pmf_eqI [simp]: \"rel_pmf (=) x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_pmf (=) x x", "by(simp add: pmf.rel_eq)"], ["", "lemma rel_pmf_bind_reflI:\n  \"(\\<And>x. x \\<in> set_pmf p \\<Longrightarrow> rel_pmf R (f x) (g x))\n  \\<Longrightarrow> rel_pmf R (bind_pmf p f) (bind_pmf p g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set_pmf p \\<Longrightarrow>\n        rel_pmf R (f x) (g x)) \\<Longrightarrow>\n    rel_pmf R (p \\<bind> f) (p \\<bind> g)", "by(rule rel_pmf_bindI[where R=\"\\<lambda>x y. x = y \\<and> x \\<in> set_pmf p\"])(auto intro: rel_pmf_reflI)"], ["", "lemma pmf_pred_mono_strong:\n  \"\\<lbrakk> pred_pmf P p; \\<And>a. \\<lbrakk> a \\<in> set_pmf p; P a \\<rbrakk> \\<Longrightarrow> P' a \\<rbrakk> \\<Longrightarrow> pred_pmf P' p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pred_pmf P p;\n     \\<And>a.\n        \\<lbrakk>a \\<in> set_pmf p; P a\\<rbrakk>\n        \\<Longrightarrow> P' a\\<rbrakk>\n    \\<Longrightarrow> pred_pmf P' p", "by(simp add: pred_pmf_def)"], ["", "lemma rel_pmf_restrict_relpI [intro?]:\n  \"\\<lbrakk> rel_pmf R x y; pred_pmf P x; pred_pmf Q y \\<rbrakk> \\<Longrightarrow> rel_pmf (R \\<upharpoonleft> P \\<otimes> Q) x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel_pmf R x y; pred_pmf P x; pred_pmf Q y\\<rbrakk>\n    \\<Longrightarrow> rel_pmf (R \\<upharpoonleft> P \\<otimes> Q) x y", "by(erule pmf.rel_mono_strong)(simp add: pred_pmf_def)"], ["", "lemma rel_pmf_restrict_relpE [elim?]:\n  assumes \"rel_pmf (R \\<upharpoonleft> P \\<otimes> Q) x y\"\n  obtains \"rel_pmf R x y\" \"pred_pmf P x\" \"pred_pmf Q y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>rel_pmf R x y; pred_pmf P x; pred_pmf Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lbrakk>rel_pmf R x y; pred_pmf P x; pred_pmf Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    rel_pmf R x y\n 2. (\\<lbrakk>rel_pmf R x y; pred_pmf P x; pred_pmf Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pred_pmf P x\n 3. (\\<lbrakk>rel_pmf R x y; pred_pmf P x; pred_pmf Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pred_pmf Q y", "show \"rel_pmf R x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_pmf R x y", "using assms"], ["proof (prove)\nusing this:\n  rel_pmf (R \\<upharpoonleft> P \\<otimes> Q) x y\n\ngoal (1 subgoal):\n 1. rel_pmf R x y", "by(auto elim!: pmf.rel_mono_strong)"], ["proof (state)\nthis:\n  rel_pmf R x y\n\ngoal (2 subgoals):\n 1. (\\<lbrakk>rel_pmf R x y; pred_pmf P x; pred_pmf Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pred_pmf P x\n 2. (\\<lbrakk>rel_pmf R x y; pred_pmf P x; pred_pmf Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pred_pmf Q y", "have \"pred_pmf (Domainp (R \\<upharpoonleft> P \\<otimes> Q)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_pmf (Domainp (R \\<upharpoonleft> P \\<otimes> Q)) x", "using assms"], ["proof (prove)\nusing this:\n  rel_pmf (R \\<upharpoonleft> P \\<otimes> Q) x y\n\ngoal (1 subgoal):\n 1. pred_pmf (Domainp (R \\<upharpoonleft> P \\<otimes> Q)) x", "by(fold pmf.Domainp_rel) blast"], ["proof (state)\nthis:\n  pred_pmf (Domainp (R \\<upharpoonleft> P \\<otimes> Q)) x\n\ngoal (2 subgoals):\n 1. (\\<lbrakk>rel_pmf R x y; pred_pmf P x; pred_pmf Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pred_pmf P x\n 2. (\\<lbrakk>rel_pmf R x y; pred_pmf P x; pred_pmf Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pred_pmf Q y", "then"], ["proof (chain)\npicking this:\n  pred_pmf (Domainp (R \\<upharpoonleft> P \\<otimes> Q)) x", "show \"pred_pmf P x\""], ["proof (prove)\nusing this:\n  pred_pmf (Domainp (R \\<upharpoonleft> P \\<otimes> Q)) x\n\ngoal (1 subgoal):\n 1. pred_pmf P x", "by(rule pmf_pred_mono_strong)(blast dest!: restrict_relp_DomainpD)"], ["proof (state)\nthis:\n  pred_pmf P x\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>rel_pmf R x y; pred_pmf P x; pred_pmf Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pred_pmf Q y", "have \"pred_pmf (Domainp (R \\<upharpoonleft> P \\<otimes> Q)\\<inverse>\\<inverse>) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_pmf\n     (Domainp (R \\<upharpoonleft> P \\<otimes> Q)\\<inverse>\\<inverse>) y", "using assms"], ["proof (prove)\nusing this:\n  rel_pmf (R \\<upharpoonleft> P \\<otimes> Q) x y\n\ngoal (1 subgoal):\n 1. pred_pmf\n     (Domainp (R \\<upharpoonleft> P \\<otimes> Q)\\<inverse>\\<inverse>) y", "by(fold pmf.Domainp_rel)(auto simp only: pmf.rel_conversep Domainp_conversep)"], ["proof (state)\nthis:\n  pred_pmf (Domainp (R \\<upharpoonleft> P \\<otimes> Q)\\<inverse>\\<inverse>)\n   y\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>rel_pmf R x y; pred_pmf P x; pred_pmf Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pred_pmf Q y", "then"], ["proof (chain)\npicking this:\n  pred_pmf (Domainp (R \\<upharpoonleft> P \\<otimes> Q)\\<inverse>\\<inverse>)\n   y", "show \"pred_pmf Q y\""], ["proof (prove)\nusing this:\n  pred_pmf (Domainp (R \\<upharpoonleft> P \\<otimes> Q)\\<inverse>\\<inverse>)\n   y\n\ngoal (1 subgoal):\n 1. pred_pmf Q y", "by(rule pmf_pred_mono_strong)(auto dest!: restrict_relp_DomainpD)"], ["proof (state)\nthis:\n  pred_pmf Q y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_pmf_restrict_relp_iff:\n  \"rel_pmf (R \\<upharpoonleft> P \\<otimes> Q) x y \\<longleftrightarrow> rel_pmf R x y \\<and> pred_pmf P x \\<and> pred_pmf Q y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_pmf (R \\<upharpoonleft> P \\<otimes> Q) x y =\n    (rel_pmf R x y \\<and> pred_pmf P x \\<and> pred_pmf Q y)", "by(blast intro: rel_pmf_restrict_relpI elim: rel_pmf_restrict_relpE)"], ["", "lemma rel_pmf_OO_trans [trans]:\n  \"\\<lbrakk> rel_pmf R p q; rel_pmf S q r \\<rbrakk> \\<Longrightarrow> rel_pmf (R OO S) p r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel_pmf R p q; rel_pmf S q r\\<rbrakk>\n    \\<Longrightarrow> rel_pmf (R OO S) p r", "unfolding pmf.rel_compp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel_pmf R p q; rel_pmf S q r\\<rbrakk>\n    \\<Longrightarrow> (rel_pmf R OO rel_pmf S) p r", "by blast"], ["", "lemma pmf_pred_map [simp]: \"pred_pmf P (map_pmf f p) = pred_pmf (P \\<circ> f) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_pmf P (map_pmf f p) = pred_pmf (P \\<circ> f) p", "by(simp add: pred_pmf_def)"], ["", "lemma pred_pmf_bind [simp]: \"pred_pmf P (bind_pmf p f) = pred_pmf (pred_pmf P \\<circ> f) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_pmf P (p \\<bind> f) = pred_pmf (pred_pmf P \\<circ> f) p", "by(simp add: pred_pmf_def)"], ["", "lemma pred_pmf_return [simp]: \"pred_pmf P (return_pmf x) = P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_pmf P (return_pmf x) = P x", "by(simp add: pred_pmf_def)"], ["", "lemma pred_pmf_of_set [simp]: \"\\<lbrakk> finite A; A \\<noteq> {} \\<rbrakk> \\<Longrightarrow> pred_pmf P (pmf_of_set A) = Ball A P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> pred_pmf P (pmf_of_set A) = Ball A P", "by(simp add: pred_pmf_def)"], ["", "lemma pred_pmf_of_multiset [simp]: \"M \\<noteq> {#} \\<Longrightarrow> pred_pmf P (pmf_of_multiset M) = Ball (set_mset M) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<noteq> {#} \\<Longrightarrow>\n    pred_pmf P (pmf_of_multiset M) = Multiset.Ball M P", "by(simp add: pred_pmf_def)"], ["", "lemma pred_pmf_cond [simp]:\n  \"set_pmf p \\<inter> A \\<noteq> {} \\<Longrightarrow> pred_pmf P (cond_pmf p A) = pred_pmf (\\<lambda>x. x \\<in> A \\<longrightarrow> P x) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_pmf p \\<inter> A \\<noteq> {} \\<Longrightarrow>\n    pred_pmf P (cond_pmf p A) =\n    pred_pmf (\\<lambda>x. x \\<in> A \\<longrightarrow> P x) p", "by(auto simp add: pred_pmf_def)"], ["", "lemma pred_pmf_pair [simp]:\n  \"pred_pmf P (pair_pmf p q) = pred_pmf (\\<lambda>x. pred_pmf (P \\<circ> Pair x) q) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_pmf P (pair_pmf p q) =\n    pred_pmf (\\<lambda>x. pred_pmf (P \\<circ> Pair x) q) p", "by(simp add: pred_pmf_def)"], ["", "lemma pred_pmf_join [simp]: \"pred_pmf P (join_pmf p) = pred_pmf (pred_pmf P) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_pmf P (join_pmf p) = pred_pmf (pred_pmf P) p", "by(simp add: pred_pmf_def)"], ["", "lemma pred_pmf_bernoulli [simp]: \"\\<lbrakk> 0 < p; p < 1 \\<rbrakk> \\<Longrightarrow> pred_pmf P (bernoulli_pmf p) = All P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> pred_pmf P (bernoulli_pmf p) = All P", "by(simp add: pred_pmf_def)"], ["", "lemma pred_pmf_geometric [simp]: \"\\<lbrakk> 0 < p; p < 1 \\<rbrakk> \\<Longrightarrow> pred_pmf P (geometric_pmf p) = All P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < p; p < 1\\<rbrakk>\n    \\<Longrightarrow> pred_pmf P (geometric_pmf p) = All P", "by(simp add: pred_pmf_def set_pmf_geometric)"], ["", "lemma pred_pmf_poisson [simp]: \"0 < rate \\<Longrightarrow> pred_pmf P (poisson_pmf rate) = All P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < rate \\<Longrightarrow> pred_pmf P (poisson_pmf rate) = All P", "by(simp add: pred_pmf_def)"], ["", "lemma pmf_rel_map_restrict_relp: \n  shows pmf_rel_map_restrict_relp1: \"rel_pmf (R \\<upharpoonleft> P \\<otimes> Q) (map_pmf f p) = rel_pmf (R \\<circ> f \\<upharpoonleft> P \\<circ> f \\<otimes> Q) p\"\n  and pmf_rel_map_restrict_relp2: \"rel_pmf (R \\<upharpoonleft> P \\<otimes> Q) p (map_pmf g q) = rel_pmf ((\\<lambda>x. R x \\<circ> g) \\<upharpoonleft> P \\<otimes> Q \\<circ> g) p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_pmf (R \\<upharpoonleft> P \\<otimes> Q) (map_pmf f p) =\n    rel_pmf (R \\<circ> f \\<upharpoonleft> P \\<circ> f \\<otimes> Q) p &&&\n    rel_pmf (R \\<upharpoonleft> P \\<otimes> Q) p (map_pmf g q) =\n    rel_pmf\n     ((\\<lambda>x. R x \\<circ> g) \\<upharpoonleft> P \\<otimes> Q \\<circ> g)\n     p q", "by(simp_all add: pmf.rel_map restrict_relp_def fun_eq_iff)"], ["", "lemma pred_pmf_conj [simp]: \"pred_pmf (\\<lambda>x. P x \\<and> Q x) = (\\<lambda>x. pred_pmf P x \\<and> pred_pmf Q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_pmf (\\<lambda>x. P x \\<and> Q x) =\n    (\\<lambda>x. pred_pmf P x \\<and> pred_pmf Q x)", "by(auto simp add: pred_pmf_def)"], ["", "lemma pred_pmf_top [simp]:\n  \"pred_pmf (\\<lambda>_. True) = (\\<lambda>_. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_pmf (\\<lambda>_. True) = (\\<lambda>_. True)", "by(simp add: pred_pmf_def)"], ["", "lemma rel_pmf_of_setI:\n  assumes A: \"A \\<noteq> {}\" \"finite A\"\n  and B: \"B \\<noteq> {}\" \"finite B\"\n  and card: \"\\<And>X. X \\<subseteq> A \\<Longrightarrow> card B * card X \\<le> card A * card {y\\<in>B. \\<exists>x\\<in>X. R x y}\"\n  shows \"rel_pmf R (pmf_of_set A) (pmf_of_set B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_pmf R (pmf_of_set A) (pmf_of_set B)", "apply(rule rel_pmf_measureI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa.\n       measure_pmf.prob (pmf_of_set A) Aa\n       \\<le> measure_pmf.prob (pmf_of_set B) {y. \\<exists>x\\<in>Aa. R x y}", "using assms"], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n  finite A\n  B \\<noteq> {}\n  finite B\n  ?X \\<subseteq> A \\<Longrightarrow>\n  card B * card ?X \\<le> card A * card {y \\<in> B. \\<exists>x\\<in>?X. R x y}\n\ngoal (1 subgoal):\n 1. \\<And>Aa.\n       measure_pmf.prob (pmf_of_set A) Aa\n       \\<le> measure_pmf.prob (pmf_of_set B) {y. \\<exists>x\\<in>Aa. R x y}", "apply(clarsimp simp add: measure_pmf_of_set card_gt_0_iff field_simps of_nat_mult[symmetric] simp del: of_nat_mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa.\n       \\<lbrakk>A \\<noteq> {}; finite A; B \\<noteq> {}; finite B;\n        \\<And>X.\n           X \\<subseteq> A \\<Longrightarrow>\n           card X * card B\n           \\<le> card A * card {y \\<in> B. \\<exists>x\\<in>X. R x y}\\<rbrakk>\n       \\<Longrightarrow> card B * card (A \\<inter> Aa)\n                         \\<le> card A *\n                               card\n                                (B \\<inter> {y. \\<exists>x\\<in>Aa. R x y})", "apply(subst mult.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa.\n       \\<lbrakk>A \\<noteq> {}; finite A; B \\<noteq> {}; finite B;\n        \\<And>X.\n           X \\<subseteq> A \\<Longrightarrow>\n           card X * card B\n           \\<le> card A * card {y \\<in> B. \\<exists>x\\<in>X. R x y}\\<rbrakk>\n       \\<Longrightarrow> card (A \\<inter> Aa) * card B\n                         \\<le> card A *\n                               card\n                                (B \\<inter> {y. \\<exists>x\\<in>Aa. R x y})", "apply(erule meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa.\n       \\<lbrakk>A \\<noteq> {}; finite A; B \\<noteq> {}; finite B;\n        ?X9 Aa \\<subseteq> A \\<Longrightarrow>\n        card (?X9 Aa) * card B\n        \\<le> card A *\n              card {y \\<in> B. \\<exists>x\\<in>?X9 Aa. R x y}\\<rbrakk>\n       \\<Longrightarrow> card (A \\<inter> Aa) * card B\n                         \\<le> card A *\n                               card\n                                (B \\<inter> {y. \\<exists>x\\<in>Aa. R x y})", "apply(erule meta_impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Aa.\n       \\<lbrakk>A \\<noteq> {}; finite A; B \\<noteq> {}; finite B\\<rbrakk>\n       \\<Longrightarrow> ?X9 Aa \\<subseteq> A\n 2. \\<And>Aa.\n       \\<lbrakk>A \\<noteq> {}; finite A; B \\<noteq> {}; finite B;\n        card (?X9 Aa) * card B\n        \\<le> card A *\n              card {y \\<in> B. \\<exists>x\\<in>?X9 Aa. R x y}\\<rbrakk>\n       \\<Longrightarrow> card (A \\<inter> Aa) * card B\n                         \\<le> card A *\n                               card\n                                (B \\<inter> {y. \\<exists>x\\<in>Aa. R x y})", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Aa.\n       \\<lbrakk>A \\<noteq> {}; finite A; B \\<noteq> {}; finite B;\n        card (?X9 Aa) * card B\n        \\<le> card A *\n              card {y \\<in> B. \\<exists>x\\<in>?X9 Aa. R x y}\\<rbrakk>\n       \\<Longrightarrow> card (A \\<inter> Aa) * card B\n                         \\<le> card A *\n                               card\n                                (B \\<inter> {y. \\<exists>x\\<in>Aa. R x y})\n 2. \\<And>Aa.\n       \\<lbrakk>A \\<noteq> {}; finite A; B \\<noteq> {}; finite B\\<rbrakk>\n       \\<Longrightarrow> ?X9 Aa \\<subseteq> A", "apply(erule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Aa.\n       \\<lbrakk>A \\<noteq> {}; finite A; B \\<noteq> {}; finite B\\<rbrakk>\n       \\<Longrightarrow> card A *\n                         card\n                          {y \\<in> B. \\<exists>x\\<in>A \\<inter> Aa. R x y}\n                         \\<le> card A *\n                               card\n                                (B \\<inter> {y. \\<exists>x\\<in>Aa. R x y})\n 2. \\<And>Aa.\n       \\<lbrakk>A \\<noteq> {}; finite A; B \\<noteq> {}; finite B\\<rbrakk>\n       \\<Longrightarrow> A \\<inter> Aa \\<subseteq> A", "apply(auto simp add: card_gt_0_iff intro: card_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "consts rel_witness_pmf :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> 'a pmf \\<times> 'b pmf \\<Rightarrow> ('a \\<times> 'b) pmf\""], ["", "specification (rel_witness_pmf)\n  set_rel_witness_pmf': \"rel_pmf A (fst xy) (snd xy) \\<Longrightarrow> set_pmf (rel_witness_pmf A xy) \\<subseteq> {(a, b). A a b}\"\n  map1_rel_witness_pmf': \"rel_pmf A (fst xy) (snd xy) \\<Longrightarrow> map_pmf fst (rel_witness_pmf A xy) = fst xy\"\n  map2_rel_witness_pmf': \"rel_pmf A (fst xy) (snd xy) \\<Longrightarrow> map_pmf snd (rel_witness_pmf A xy) = snd xy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rel_witness_pmf.\n       (\\<forall>A xy.\n           rel_pmf A (fst xy) (snd xy) \\<longrightarrow>\n           set_pmf (rel_witness_pmf A xy)\n           \\<subseteq> {(x, y). A x y}) \\<and>\n       (\\<forall>A xy.\n           rel_pmf A (fst xy) (snd xy) \\<longrightarrow>\n           map_pmf fst (rel_witness_pmf A xy) = fst xy) \\<and>\n       (\\<forall>A xy.\n           rel_pmf A (fst xy) (snd xy) \\<longrightarrow>\n           map_pmf snd (rel_witness_pmf A xy) = snd xy)", "apply(fold all_conj_distrib imp_conjR)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rel_witness_pmf.\n       \\<forall>x xa.\n          (rel_pmf x (fst xa) (snd xa) \\<longrightarrow>\n           set_pmf (rel_witness_pmf x xa)\n           \\<subseteq> {(xa, y). x xa y}) \\<and>\n          (rel_pmf x (fst xa) (snd xa) \\<longrightarrow>\n           map_pmf fst (rel_witness_pmf x xa) = fst xa) \\<and>\n          (rel_pmf x (fst xa) (snd xa) \\<longrightarrow>\n           map_pmf snd (rel_witness_pmf x xa) = snd xa)", "apply(rule choice allI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<exists>y.\n          (rel_pmf x (fst xa) (snd xa) \\<longrightarrow>\n           set_pmf y\n           \\<subseteq> {a. case a of (a, b) \\<Rightarrow> x a b}) \\<and>\n          (rel_pmf x (fst xa) (snd xa) \\<longrightarrow>\n           map_pmf fst y = fst xa) \\<and>\n          (rel_pmf x (fst xa) (snd xa) \\<longrightarrow>\n           map_pmf snd y = snd xa)", "apply(unfold pmf.in_rel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<exists>y.\n          ((\\<exists>z.\n               z \\<in> {xa. set_pmf xa \\<subseteq> {(xa, y). x xa y}} \\<and>\n               map_pmf fst z = fst xa \\<and>\n               map_pmf snd z = snd xa) \\<longrightarrow>\n           set_pmf y\n           \\<subseteq> {a. case a of (a, b) \\<Rightarrow> x a b}) \\<and>\n          ((\\<exists>z.\n               z \\<in> {xa. set_pmf xa \\<subseteq> {(xa, y). x xa y}} \\<and>\n               map_pmf fst z = fst xa \\<and>\n               map_pmf snd z = snd xa) \\<longrightarrow>\n           map_pmf fst y = fst xa) \\<and>\n          ((\\<exists>z.\n               z \\<in> {xa. set_pmf xa \\<subseteq> {(xa, y). x xa y}} \\<and>\n               map_pmf fst z = fst xa \\<and>\n               map_pmf snd z = snd xa) \\<longrightarrow>\n           map_pmf snd y = snd xa)", "by blast"], ["", "lemmas set_rel_witness_pmf = set_rel_witness_pmf'[of _ \"(x, y)\" for x y, simplified]"], ["", "lemmas map1_rel_witness_pmf = map1_rel_witness_pmf'[of _ \"(x, y)\" for x y, simplified]"], ["", "lemmas map2_rel_witness_pmf = map2_rel_witness_pmf'[of _ \"(x, y)\" for x y, simplified]"], ["", "lemmas rel_witness_pmf = set_rel_witness_pmf map1_rel_witness_pmf map2_rel_witness_pmf"], ["", "lemma rel_witness_pmf1:\n  assumes \"rel_pmf A p q\" \n  shows \"rel_pmf (\\<lambda>a (a', b). a = a' \\<and> A a' b) p (rel_witness_pmf A (p, q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_pmf (\\<lambda>a (a', b). a = a' \\<and> A a' b) p\n     (rel_witness_pmf A (p, q))", "using map1_rel_witness_pmf[OF assms, symmetric]"], ["proof (prove)\nusing this:\n  p = map_pmf fst (rel_witness_pmf A (p, q))\n\ngoal (1 subgoal):\n 1. rel_pmf (\\<lambda>a (a', b). a = a' \\<and> A a' b) p\n     (rel_witness_pmf A (p, q))", "unfolding pmf.rel_eq[symmetric] pmf.rel_map"], ["proof (prove)\nusing this:\n  rel_pmf (\\<lambda>x y. x = fst y) p (rel_witness_pmf A (p, q))\n\ngoal (1 subgoal):\n 1. rel_pmf (\\<lambda>a (a', b). a = a' \\<and> A a' b) p\n     (rel_witness_pmf A (p, q))", "by(rule pmf.rel_mono_strong)(auto dest: set_rel_witness_pmf[OF assms, THEN subsetD])"], ["", "lemma rel_witness_pmf2:\n  assumes \"rel_pmf A p q\" \n  shows \"rel_pmf (\\<lambda>(a, b') b. b = b' \\<and> A a b') (rel_witness_pmf A (p, q)) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_pmf (\\<lambda>(a, b') b. b = b' \\<and> A a b')\n     (rel_witness_pmf A (p, q)) q", "using map2_rel_witness_pmf[OF assms]"], ["proof (prove)\nusing this:\n  map_pmf snd (rel_witness_pmf A (p, q)) = q\n\ngoal (1 subgoal):\n 1. rel_pmf (\\<lambda>(a, b') b. b = b' \\<and> A a b')\n     (rel_witness_pmf A (p, q)) q", "unfolding pmf.rel_eq[symmetric] pmf.rel_map"], ["proof (prove)\nusing this:\n  rel_pmf (\\<lambda>x. (=) (snd x)) (rel_witness_pmf A (p, q)) q\n\ngoal (1 subgoal):\n 1. rel_pmf (\\<lambda>(a, b') b. b = b' \\<and> A a b')\n     (rel_witness_pmf A (p, q)) q", "by(rule pmf.rel_mono_strong)(auto dest: set_rel_witness_pmf[OF assms, THEN subsetD])"], ["", "lemma cond_pmf_of_set:\n  assumes fin: \"finite A\" and nonempty: \"A \\<inter> B \\<noteq> {}\"\n  shows \"cond_pmf (pmf_of_set A) B = pmf_of_set (A \\<inter> B)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_pmf (pmf_of_set A) B = pmf_of_set (A \\<inter> B)", "proof(rule pmf_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (cond_pmf (pmf_of_set A) B) i = pmf (pmf_of_set (A \\<inter> B)) i", "from nonempty"], ["proof (chain)\npicking this:\n  A \\<inter> B \\<noteq> {}", "have A: \"A \\<noteq> {}\""], ["proof (prove)\nusing this:\n  A \\<inter> B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. A \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (cond_pmf (pmf_of_set A) B) i = pmf (pmf_of_set (A \\<inter> B)) i", "show \"pmf ?lhs x = pmf ?rhs x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (cond_pmf (pmf_of_set A) B) x = pmf (pmf_of_set (A \\<inter> B)) x", "by(subst pmf_cond; clarsimp simp add: fin A nonempty measure_pmf_of_set split: split_indicator)"], ["proof (state)\nthis:\n  pmf (cond_pmf (pmf_of_set A) B) ?x = pmf (pmf_of_set (A \\<inter> B)) ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pair_pmf_of_set:\n  assumes A: \"finite A\" \"A \\<noteq> {}\"\n    and B: \"finite B\" \"B \\<noteq> {}\"\n  shows \"pair_pmf (pmf_of_set A) (pmf_of_set B) = pmf_of_set (A \\<times> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_pmf (pmf_of_set A) (pmf_of_set B) = pmf_of_set (A \\<times> B)", "by(rule pmf_eqI)(clarsimp simp add: pmf_pair assms split: split_indicator)"], ["", "lemma emeasure_cond_pmf:\n  fixes p A\n  defines \"q \\<equiv> cond_pmf p A\"\n  assumes \"set_pmf p \\<inter> A \\<noteq> {}\"\n  shows \"emeasure (measure_pmf q) B = emeasure (measure_pmf p) (A \\<inter> B) / emeasure (measure_pmf p) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf q) B =\n    emeasure (measure_pmf p) (A \\<inter> B) / emeasure (measure_pmf p) A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf q) B =\n    emeasure (measure_pmf p) (A \\<inter> B) / emeasure (measure_pmf p) A", "note [transfer_rule] = cond_pmf.transfer[OF assms(2), folded q_def]"], ["proof (state)\nthis:\n  pmf_as_measure.cr_pmf (uniform_measure (measure_pmf p) A) q\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf q) B =\n    emeasure (measure_pmf p) (A \\<inter> B) / emeasure (measure_pmf p) A", "interpret pmf_as_measure"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf q) B =\n    emeasure (measure_pmf p) (A \\<inter> B) / emeasure (measure_pmf p) A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf q) B =\n    emeasure (measure_pmf p) (A \\<inter> B) / emeasure (measure_pmf p) A", "by transfer simp"], ["proof (state)\nthis:\n  emeasure (measure_pmf q) B =\n  emeasure (measure_pmf p) (A \\<inter> B) / emeasure (measure_pmf p) A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma measure_cond_pmf:\n  \"measure (measure_pmf (cond_pmf p A)) B = measure (measure_pmf p) (A \\<inter> B) / measure (measure_pmf p) A\"\n  if \"set_pmf p \\<inter> A \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob (cond_pmf p A) B =\n    measure_pmf.prob p (A \\<inter> B) / measure_pmf.prob p A", "using emeasure_cond_pmf[OF that, of B] that"], ["proof (prove)\nusing this:\n  emeasure (measure_pmf (cond_pmf p A)) B =\n  emeasure (measure_pmf p) (A \\<inter> B) / emeasure (measure_pmf p) A\n  set_pmf p \\<inter> A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. measure_pmf.prob (cond_pmf p A) B =\n    measure_pmf.prob p (A \\<inter> B) / measure_pmf.prob p A", "by(auto simp add: measure_pmf.emeasure_eq_measure measure_pmf_posI divide_ennreal)"], ["", "lemma emeasure_measure_pmf_zero_iff: \"emeasure (measure_pmf p) s = 0 \\<longleftrightarrow> set_pmf p \\<inter> s = {}\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (emeasure (measure_pmf p) s = 0) = (set_pmf p \\<inter> s = {})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (emeasure (measure_pmf p) s = 0) = (set_pmf p \\<inter> s = {})", "have \"?lhs \\<longleftrightarrow> (AE x in measure_pmf p. x \\<notin> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (emeasure (measure_pmf p) s = 0) = (AE x in measure_pmf p. x \\<notin> s)", "by(subst AE_iff_measurable)(auto)"], ["proof (state)\nthis:\n  (emeasure (measure_pmf p) s = 0) = (AE x in measure_pmf p. x \\<notin> s)\n\ngoal (1 subgoal):\n 1. (emeasure (measure_pmf p) s = 0) = (set_pmf p \\<inter> s = {})", "also"], ["proof (state)\nthis:\n  (emeasure (measure_pmf p) s = 0) = (AE x in measure_pmf p. x \\<notin> s)\n\ngoal (1 subgoal):\n 1. (emeasure (measure_pmf p) s = 0) = (set_pmf p \\<inter> s = {})", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (AE x in measure_pmf p. x \\<notin> s) = (set_pmf p \\<inter> s = {})", "by(auto simp add: AE_measure_pmf_iff)"], ["proof (state)\nthis:\n  (AE x in measure_pmf p. x \\<notin> s) = (set_pmf p \\<inter> s = {})\n\ngoal (1 subgoal):\n 1. (emeasure (measure_pmf p) s = 0) = (set_pmf p \\<inter> s = {})", "finally"], ["proof (chain)\npicking this:\n  (emeasure (measure_pmf p) s = 0) = (set_pmf p \\<inter> s = {})", "show ?thesis"], ["proof (prove)\nusing this:\n  (emeasure (measure_pmf p) s = 0) = (set_pmf p \\<inter> s = {})\n\ngoal (1 subgoal):\n 1. (emeasure (measure_pmf p) s = 0) = (set_pmf p \\<inter> s = {})", "."], ["proof (state)\nthis:\n  (emeasure (measure_pmf p) s = 0) = (set_pmf p \\<inter> s = {})\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Subprobability mass functions\\<close>"], ["", "lemma ord_spmf_return_spmf1: \"ord_spmf R (return_spmf x) p \\<longleftrightarrow> lossless_spmf p \\<and> (\\<forall>y\\<in>set_spmf p. R x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf R (return_spmf x) p =\n    (lossless_spmf p \\<and> (\\<forall>y\\<in>set_spmf p. R x y))", "by(auto simp add: rel_pmf_return_pmf1 ord_option.simps in_set_spmf lossless_iff_set_pmf_None Ball_def) (metis option.exhaust)"], ["", "lemma ord_spmf_conv:\n  \"ord_spmf R = rel_spmf R OO ord_spmf (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf R = rel_spmf R OO ord_spmf (=)", "apply(subst pmf.rel_compp[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf R = rel_pmf (rel_option R OO le_option)", "apply(rule arg_cong[where f=\"rel_pmf\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_option R = rel_option R OO le_option", "apply(rule ext)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa. ord_option R x xa = (rel_option R OO le_option) x xa", "apply(auto elim!: ord_option.cases option.rel_cases intro: option.rel_intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ord_spmf_expand:\n  \"NO_MATCH (=) R \\<Longrightarrow> ord_spmf R = rel_spmf R OO ord_spmf (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NO_MATCH (=) R \\<Longrightarrow> ord_spmf R = rel_spmf R OO ord_spmf (=)", "by(rule ord_spmf_conv)"], ["", "lemma ord_spmf_eqD_measure: \"ord_spmf (=) p q \\<Longrightarrow> measure (measure_spmf p) A \\<le> measure (measure_spmf q) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=) p q \\<Longrightarrow>\n    Sigma_Algebra.measure (measure_spmf p) A\n    \\<le> Sigma_Algebra.measure (measure_spmf q) A", "by(drule ord_spmf_eqD_measure_spmf)(simp add: le_measure measure_spmf.emeasure_eq_measure)"], ["", "lemma ord_spmf_measureD:\n  assumes \"ord_spmf R p q\"\n  shows \"measure (measure_spmf p) A \\<le> measure (measure_spmf q) {y. \\<exists>x\\<in>A. R x y}\"\n    (is \"?lhs \\<le> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf p) A\n    \\<le> Sigma_Algebra.measure (measure_spmf q)\n           {y. \\<exists>x\\<in>A. R x y}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf p) A\n    \\<le> Sigma_Algebra.measure (measure_spmf q)\n           {y. \\<exists>x\\<in>A. R x y}", "from assms"], ["proof (chain)\npicking this:\n  ord_spmf R p q", "obtain p' where *: \"rel_spmf R p p'\" and **: \"ord_spmf (=) p' q\""], ["proof (prove)\nusing this:\n  ord_spmf R p q\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>rel_spmf R p p'; ord_spmf (=) p' q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: ord_spmf_expand)"], ["proof (state)\nthis:\n  rel_spmf R p p'\n  ord_spmf (=) p' q\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf p) A\n    \\<le> Sigma_Algebra.measure (measure_spmf q)\n           {y. \\<exists>x\\<in>A. R x y}", "have \"?lhs \\<le> measure (measure_spmf p') {y. \\<exists>x\\<in>A. R x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf p) A\n    \\<le> Sigma_Algebra.measure (measure_spmf p')\n           {y. \\<exists>x\\<in>A. R x y}", "using *"], ["proof (prove)\nusing this:\n  rel_spmf R p p'\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf p) A\n    \\<le> Sigma_Algebra.measure (measure_spmf p')\n           {y. \\<exists>x\\<in>A. R x y}", "by(rule rel_spmf_measureD)"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf p) A\n  \\<le> Sigma_Algebra.measure (measure_spmf p') {y. \\<exists>x\\<in>A. R x y}\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf p) A\n    \\<le> Sigma_Algebra.measure (measure_spmf q)\n           {y. \\<exists>x\\<in>A. R x y}", "also"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf p) A\n  \\<le> Sigma_Algebra.measure (measure_spmf p') {y. \\<exists>x\\<in>A. R x y}\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf p) A\n    \\<le> Sigma_Algebra.measure (measure_spmf q)\n           {y. \\<exists>x\\<in>A. R x y}", "have \"\\<dots> \\<le> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf p') {y. \\<exists>x\\<in>A. R x y}\n    \\<le> Sigma_Algebra.measure (measure_spmf q)\n           {y. \\<exists>x\\<in>A. R x y}", "using **"], ["proof (prove)\nusing this:\n  ord_spmf (=) p' q\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf p') {y. \\<exists>x\\<in>A. R x y}\n    \\<le> Sigma_Algebra.measure (measure_spmf q)\n           {y. \\<exists>x\\<in>A. R x y}", "by(rule ord_spmf_eqD_measure)"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf p') {y. \\<exists>x\\<in>A. R x y}\n  \\<le> Sigma_Algebra.measure (measure_spmf q) {y. \\<exists>x\\<in>A. R x y}\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf p) A\n    \\<le> Sigma_Algebra.measure (measure_spmf q)\n           {y. \\<exists>x\\<in>A. R x y}", "finally"], ["proof (chain)\npicking this:\n  Sigma_Algebra.measure (measure_spmf p) A\n  \\<le> Sigma_Algebra.measure (measure_spmf q) {y. \\<exists>x\\<in>A. R x y}", "show ?thesis"], ["proof (prove)\nusing this:\n  Sigma_Algebra.measure (measure_spmf p) A\n  \\<le> Sigma_Algebra.measure (measure_spmf q) {y. \\<exists>x\\<in>A. R x y}\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf p) A\n    \\<le> Sigma_Algebra.measure (measure_spmf q)\n           {y. \\<exists>x\\<in>A. R x y}", "."], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf p) A\n  \\<le> Sigma_Algebra.measure (measure_spmf q) {y. \\<exists>x\\<in>A. R x y}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ord_spmf_bind_pmfI1:\n  \"(\\<And>x. x \\<in> set_pmf p \\<Longrightarrow> ord_spmf R (f x) q) \\<Longrightarrow> ord_spmf R (bind_pmf p f) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set_pmf p \\<Longrightarrow>\n        ord_spmf R (f x) q) \\<Longrightarrow>\n    ord_spmf R (p \\<bind> f) q", "apply(rewrite at \"ord_spmf _ _ \\<hole>\" bind_return_pmf[symmetric, where f=\"\\<lambda>_ :: unit. q\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set_pmf p \\<Longrightarrow>\n        ord_spmf R (f x) q) \\<Longrightarrow>\n    ord_spmf R (p \\<bind> f) (return_pmf ?x8 \\<bind> (\\<lambda>_. q))", "apply(rule rel_pmf_bindI[where R=\"\\<lambda>x y. x \\<in> set_pmf p\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> set_pmf p \\<Longrightarrow>\n        ord_spmf R (f x) q) \\<Longrightarrow>\n    rel_pmf (\\<lambda>x y. x \\<in> set_pmf p) p (return_pmf ?x8)\n 2. \\<And>x y.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set_pmf p \\<Longrightarrow> ord_spmf R (f x) q;\n        x \\<in> set_pmf p\\<rbrakk>\n       \\<Longrightarrow> ord_spmf R (f x) q", "apply(simp_all add: rel_pmf_return_pmf2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ord_spmf_bind_spmfI1:\n  \"(\\<And>x. x \\<in> set_spmf p \\<Longrightarrow> ord_spmf R (f x) q) \\<Longrightarrow> ord_spmf R (bind_spmf p f) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set_spmf p \\<Longrightarrow>\n        ord_spmf R (f x) q) \\<Longrightarrow>\n    ord_spmf R (p \\<bind> f) q", "unfolding bind_spmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set_spmf p \\<Longrightarrow>\n        ord_spmf R (f x) q) \\<Longrightarrow>\n    ord_spmf R (p \\<bind> case_option (return_pmf None) f) q", "by(rule ord_spmf_bind_pmfI1)(auto split: option.split simp add: in_set_spmf)"], ["", "lemma spmf_of_set_empty: \"spmf_of_set {} = return_pmf None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf_of_set {} = return_pmf None", "by(simp add: spmf_of_set_def)"], ["", "lemma rel_spmf_of_setI:\n  assumes card: \"\\<And>X. X \\<subseteq> A \\<Longrightarrow> card B * card X \\<le> card A * card {y\\<in>B. \\<exists>x\\<in>X. R x y}\"\n  and eq: \"(finite A \\<and> A \\<noteq> {}) \\<longleftrightarrow> (finite B \\<and> B \\<noteq> {})\"\n  shows \"rel_spmf R (spmf_of_set A) (spmf_of_set B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf R (spmf_of_set A) (spmf_of_set B)", "using eq"], ["proof (prove)\nusing this:\n  finite' A = finite' B\n\ngoal (1 subgoal):\n 1. rel_spmf R (spmf_of_set A) (spmf_of_set B)", "by(clarsimp simp add: spmf_of_set_def card rel_pmf_of_setI simp del: spmf_of_pmf_pmf_of_set cong: conj_cong)"], ["", "lemmas map_bind_spmf = map_spmf_bind_spmf"], ["", "lemma nn_integral_measure_spmf_conv_measure_pmf:\n  assumes [measurable]: \"f \\<in> borel_measurable (count_space UNIV)\"\n  shows \"nn_integral (measure_spmf p) f = nn_integral (restrict_space (measure_pmf p) (range Some)) (f \\<circ> the)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (measure_spmf p) f =\n    integral\\<^sup>N (restrict_space (measure_pmf p) (range Some))\n     (f \\<circ> the)", "by(simp add: measure_spmf_def nn_integral_distr o_def)"], ["", "lemma nn_integral_spmf_neq_infinity: \"(\\<integral>\\<^sup>+ x. spmf p x \\<partial>count_space UNIV) \\<noteq> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (spmf p x)) \\<noteq> \\<infinity>", "using nn_integral_measure_spmf[where f=\"\\<lambda>_. 1\", of p, symmetric]"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ x. ennreal (spmf p x) * 1) =\n  \\<integral>\\<^sup>+ x. 1 \\<partial>measure_spmf p\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (spmf p x)) \\<noteq> \\<infinity>", "by simp"], ["", "lemma return_pmf_bind_option:\n  \"return_pmf (Option.bind x f) = bind_spmf (return_pmf x) (return_pmf \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return_pmf (x \\<bind> f) = return_pmf x \\<bind> return_pmf \\<circ> f", "by(cases x) simp_all"], ["", "lemma rel_spmf_pos_distr: \"rel_spmf A OO rel_spmf B \\<le> rel_spmf (A OO B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf A OO rel_spmf B \\<le> rel_spmf (A OO B)", "unfolding option.rel_compp pmf.rel_compp"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf A OO rel_spmf B \\<le> rel_spmf A OO rel_spmf B", ".."], ["", "lemma rel_spmf_OO_trans [trans]:\n  \"\\<lbrakk> rel_spmf R p q; rel_spmf S q r \\<rbrakk> \\<Longrightarrow> rel_spmf (R OO S) p r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel_spmf R p q; rel_spmf S q r\\<rbrakk>\n    \\<Longrightarrow> rel_spmf (R OO S) p r", "by(rule rel_spmf_pos_distr[THEN predicate2D]) auto"], ["", "lemma map_spmf_eq_map_spmf_iff: \"map_spmf f p = map_spmf g q \\<longleftrightarrow> rel_spmf (\\<lambda>x y. f x = g y) p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_spmf f p = map_spmf g q) = rel_spmf (\\<lambda>x y. f x = g y) p q", "by(simp add: spmf_rel_eq[symmetric] spmf_rel_map)"], ["", "lemma map_spmf_eq_map_spmfI: \"rel_spmf (\\<lambda>x y. f x = g y) p q \\<Longrightarrow> map_spmf f p = map_spmf g q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (\\<lambda>x y. f x = g y) p q \\<Longrightarrow>\n    map_spmf f p = map_spmf g q", "by(simp add: map_spmf_eq_map_spmf_iff)"], ["", "lemma spmf_rel_mono_strong:\n  \"\\<lbrakk>rel_spmf A f g; \\<And>x y. \\<lbrakk> x \\<in> set_spmf f; y \\<in> set_spmf g; A x y \\<rbrakk> \\<Longrightarrow> B x y \\<rbrakk> \\<Longrightarrow> rel_spmf B f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel_spmf A f g;\n     \\<And>x y.\n        \\<lbrakk>x \\<in> set_spmf f; y \\<in> set_spmf g; A x y\\<rbrakk>\n        \\<Longrightarrow> B x y\\<rbrakk>\n    \\<Longrightarrow> rel_spmf B f g", "apply(erule pmf.rel_mono_strong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z yb.\n       \\<lbrakk>\\<And>x y.\n                   \\<lbrakk>x \\<in> set_spmf f; y \\<in> set_spmf g;\n                    A x y\\<rbrakk>\n                   \\<Longrightarrow> B x y;\n        z \\<in> set_pmf f; yb \\<in> set_pmf g; rel_option A z yb\\<rbrakk>\n       \\<Longrightarrow> rel_option B z yb", "apply(erule option.rel_mono_strong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z yb za yba.\n       \\<lbrakk>\\<And>x y.\n                   \\<lbrakk>x \\<in> set_spmf f; y \\<in> set_spmf g;\n                    A x y\\<rbrakk>\n                   \\<Longrightarrow> B x y;\n        z \\<in> set_pmf f; yb \\<in> set_pmf g; za \\<in> set_option z;\n        yba \\<in> set_option yb; A za yba\\<rbrakk>\n       \\<Longrightarrow> B za yba", "by(clarsimp simp add: in_set_spmf)"], ["", "lemma set_spmf_eq_empty: \"set_spmf p = {} \\<longleftrightarrow> p = return_pmf None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set_spmf p = {}) = (p = return_pmf None)", "by auto (metis restrict_spmf_empty restrict_spmf_trivial)"], ["", "lemma measure_pair_spmf_times:\n  \"measure (measure_spmf (pair_spmf p q)) (A \\<times> B) = measure (measure_spmf p) A * measure (measure_spmf q) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (pair_spmf p q)) (A \\<times> B) =\n    Sigma_Algebra.measure (measure_spmf p) A *\n    Sigma_Algebra.measure (measure_spmf q) B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (pair_spmf p q)) (A \\<times> B) =\n    Sigma_Algebra.measure (measure_spmf p) A *\n    Sigma_Algebra.measure (measure_spmf q) B", "have \"emeasure (measure_spmf (pair_spmf p q)) (A \\<times> B) = (\\<integral>\\<^sup>+ x. ennreal (spmf (pair_spmf p q) x) * indicator (A \\<times> B) x \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_spmf (pair_spmf p q)) (A \\<times> B) =\n    \\<integral>\\<^sup>+x\\<in>A \\<times> B. ennreal (spmf (pair_spmf p q) x)\n    \\<partial>count_space UNIV", "by(simp add: nn_integral_spmf[symmetric] nn_integral_count_space_indicator)"], ["proof (state)\nthis:\n  emeasure (measure_spmf (pair_spmf p q)) (A \\<times> B) =\n  \\<integral>\\<^sup>+x\\<in>A \\<times> B. ennreal (spmf (pair_spmf p q) x)\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (pair_spmf p q)) (A \\<times> B) =\n    Sigma_Algebra.measure (measure_spmf p) A *\n    Sigma_Algebra.measure (measure_spmf q) B", "also"], ["proof (state)\nthis:\n  emeasure (measure_spmf (pair_spmf p q)) (A \\<times> B) =\n  \\<integral>\\<^sup>+x\\<in>A \\<times> B. ennreal (spmf (pair_spmf p q) x)\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (pair_spmf p q)) (A \\<times> B) =\n    Sigma_Algebra.measure (measure_spmf p) A *\n    Sigma_Algebra.measure (measure_spmf q) B", "have \"\\<dots> = (\\<integral>\\<^sup>+ x. (\\<integral>\\<^sup>+ y. (ennreal (spmf p x) * indicator A x) * (ennreal (spmf q y) * indicator B y) \\<partial>count_space UNIV) \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>A \\<times> B. ennreal (spmf (pair_spmf p q) x)\n    \\<partial>count_space UNIV =\n    (\\<Sum>\\<^sup>+ x.\n       \\<Sum>\\<^sup>+ y.\n         ennreal (spmf p x) * indicator A x *\n         (ennreal (spmf q y) * indicator B y))", "by(subst nn_integral_fst_count_space[symmetric])(auto intro!: nn_integral_cong split: split_indicator simp add: ennreal_mult)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>A \\<times> B. ennreal (spmf (pair_spmf p q) x)\n  \\<partial>count_space UNIV =\n  (\\<Sum>\\<^sup>+ x.\n     \\<Sum>\\<^sup>+ y.\n       ennreal (spmf p x) * indicator A x *\n       (ennreal (spmf q y) * indicator B y))\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (pair_spmf p q)) (A \\<times> B) =\n    Sigma_Algebra.measure (measure_spmf p) A *\n    Sigma_Algebra.measure (measure_spmf q) B", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>A \\<times> B. ennreal (spmf (pair_spmf p q) x)\n  \\<partial>count_space UNIV =\n  (\\<Sum>\\<^sup>+ x.\n     \\<Sum>\\<^sup>+ y.\n       ennreal (spmf p x) * indicator A x *\n       (ennreal (spmf q y) * indicator B y))\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (pair_spmf p q)) (A \\<times> B) =\n    Sigma_Algebra.measure (measure_spmf p) A *\n    Sigma_Algebra.measure (measure_spmf q) B", "have \"\\<dots> = (\\<integral>\\<^sup>+ x. ennreal (spmf p x) * indicator A x * emeasure (measure_spmf q) B \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       \\<Sum>\\<^sup>+ y.\n         ennreal (spmf p x) * indicator A x *\n         (ennreal (spmf q y) * indicator B y)) =\n    (\\<Sum>\\<^sup>+ x.\n       ennreal (spmf p x) * indicator A x * emeasure (measure_spmf q) B)", "by(simp add: nn_integral_cmult nn_integral_spmf[symmetric] nn_integral_count_space_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     \\<Sum>\\<^sup>+ y.\n       ennreal (spmf p x) * indicator A x *\n       (ennreal (spmf q y) * indicator B y)) =\n  (\\<Sum>\\<^sup>+ x.\n     ennreal (spmf p x) * indicator A x * emeasure (measure_spmf q) B)\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (pair_spmf p q)) (A \\<times> B) =\n    Sigma_Algebra.measure (measure_spmf p) A *\n    Sigma_Algebra.measure (measure_spmf q) B", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     \\<Sum>\\<^sup>+ y.\n       ennreal (spmf p x) * indicator A x *\n       (ennreal (spmf q y) * indicator B y)) =\n  (\\<Sum>\\<^sup>+ x.\n     ennreal (spmf p x) * indicator A x * emeasure (measure_spmf q) B)\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (pair_spmf p q)) (A \\<times> B) =\n    Sigma_Algebra.measure (measure_spmf p) A *\n    Sigma_Algebra.measure (measure_spmf q) B", "have \"\\<dots> = emeasure (measure_spmf p) A * emeasure (measure_spmf q) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal (spmf p x) * indicator A x * emeasure (measure_spmf q) B) =\n    emeasure (measure_spmf p) A * emeasure (measure_spmf q) B", "by(simp add: nn_integral_multc)(simp add: nn_integral_spmf[symmetric] nn_integral_count_space_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     ennreal (spmf p x) * indicator A x * emeasure (measure_spmf q) B) =\n  emeasure (measure_spmf p) A * emeasure (measure_spmf q) B\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (pair_spmf p q)) (A \\<times> B) =\n    Sigma_Algebra.measure (measure_spmf p) A *\n    Sigma_Algebra.measure (measure_spmf q) B", "finally"], ["proof (chain)\npicking this:\n  emeasure (measure_spmf (pair_spmf p q)) (A \\<times> B) =\n  emeasure (measure_spmf p) A * emeasure (measure_spmf q) B", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure (measure_spmf (pair_spmf p q)) (A \\<times> B) =\n  emeasure (measure_spmf p) A * emeasure (measure_spmf q) B\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (pair_spmf p q)) (A \\<times> B) =\n    Sigma_Algebra.measure (measure_spmf p) A *\n    Sigma_Algebra.measure (measure_spmf q) B", "by(simp add: measure_spmf.emeasure_eq_measure ennreal_mult[symmetric])"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf (pair_spmf p q)) (A \\<times> B) =\n  Sigma_Algebra.measure (measure_spmf p) A *\n  Sigma_Algebra.measure (measure_spmf q) B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lossless_spmfD_set_spmf_nonempty: \"lossless_spmf p \\<Longrightarrow> set_spmf p \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf p \\<Longrightarrow> set_spmf p \\<noteq> {}", "using set_pmf_not_empty[of p]"], ["proof (prove)\nusing this:\n  set_pmf p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. lossless_spmf p \\<Longrightarrow> set_spmf p \\<noteq> {}", "by(auto simp add: set_spmf_def bind_UNION lossless_iff_set_pmf_None)"], ["", "lemma set_spmf_return_pmf: \"set_spmf (return_pmf x) = set_option x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_spmf (return_pmf x) = set_option x", "by(cases x) simp_all"], ["", "lemma bind_spmf_pmf_assoc: \"bind_spmf (bind_pmf p f) g = bind_pmf p (\\<lambda>x. bind_spmf (f x) g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bind> f \\<bind> g = p \\<bind> (\\<lambda>x. f x \\<bind> g)", "by(simp add: bind_spmf_def bind_assoc_pmf)"], ["", "lemma bind_spmf_of_set:  \"\\<lbrakk> finite A; A \\<noteq> {} \\<rbrakk> \\<Longrightarrow> bind_spmf (spmf_of_set A) f = bind_pmf (pmf_of_set A) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> spmf_of_set A \\<bind> f = pmf_of_set A \\<bind> f", "by(simp add: spmf_of_set_def del: spmf_of_pmf_pmf_of_set)"], ["", "lemma bind_spmf_map_pmf:\n  \"bind_spmf (map_pmf f p) g = bind_pmf p (\\<lambda>x. bind_spmf (return_pmf (f x)) g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf f p \\<bind> g =\n    p \\<bind> (\\<lambda>x. return_pmf (f x) \\<bind> g)", "by(simp add: map_pmf_def bind_spmf_def bind_assoc_pmf)"], ["", "lemma rel_spmf_eqI [simp]: \"rel_spmf (=) x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (=) x x", "by(simp add: option.rel_eq)"], ["", "lemma set_spmf_map_pmf: \"set_spmf (map_pmf f p) = (\\<Union>x\\<in>set_pmf p. set_option (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_spmf (map_pmf f p) = (\\<Union>x\\<in>set_pmf p. set_option (f x))", "(* Move up *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_spmf (map_pmf f p) = (\\<Union>x\\<in>set_pmf p. set_option (f x))", "by(simp add: set_spmf_def bind_UNION)"], ["", "lemma ord_spmf_return_spmf [simp]: \"ord_spmf (=) (return_spmf x) p \\<longleftrightarrow> p = return_spmf x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=) (return_spmf x) p = (p = return_spmf x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ord_spmf (=) (return_spmf x) p = (p = return_spmf x)", "have \"p = return_spmf x \\<Longrightarrow> ord_spmf (=) (return_spmf x) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = return_spmf x \\<Longrightarrow> ord_spmf (=) (return_spmf x) p", "by simp"], ["proof (state)\nthis:\n  p = return_spmf x \\<Longrightarrow> ord_spmf (=) (return_spmf x) p\n\ngoal (1 subgoal):\n 1. ord_spmf (=) (return_spmf x) p = (p = return_spmf x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = return_spmf x \\<Longrightarrow> ord_spmf (=) (return_spmf x) p\n\ngoal (1 subgoal):\n 1. ord_spmf (=) (return_spmf x) p = (p = return_spmf x)", "by (metis (no_types) ord_option_eq_simps(2) rel_pmf_return_pmf1 rel_pmf_return_pmf2 spmf.leq_antisym)"], ["proof (state)\nthis:\n  ord_spmf (=) (return_spmf x) p = (p = return_spmf x)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare\n  set_bind_spmf [simp]\n  set_spmf_return_pmf [simp]"], ["", "lemma bind_spmf_pmf_commute:\n  \"bind_spmf p (\\<lambda>x. bind_pmf q (f x)) = bind_pmf q (\\<lambda>y. bind_spmf p (\\<lambda>x. f x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bind> (\\<lambda>x. q \\<bind> f x) =\n    q \\<bind> (\\<lambda>y. p \\<bind> (\\<lambda>x. f x y))", "unfolding bind_spmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bind> case_option (return_pmf None) (\\<lambda>x. q \\<bind> f x) =\n    q \\<bind>\n    (\\<lambda>y.\n        p \\<bind> case_option (return_pmf None) (\\<lambda>x. f x y))", "by(subst bind_commute_pmf)(auto intro: bind_pmf_cong[OF refl] split: option.split)"], ["", "lemma return_pmf_map_option_conv_bind:\n  \"return_pmf (map_option f x) = bind_spmf (return_pmf x) (return_spmf \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return_pmf (map_option f x) = return_pmf x \\<bind> return_spmf \\<circ> f", "by(cases x) simp_all"], ["", "lemma lossless_return_pmf_iff [simp]: \"lossless_spmf (return_pmf x) \\<longleftrightarrow> x \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (return_pmf x) = (x \\<noteq> None)", "by(cases x) simp_all"], ["", "lemma lossless_map_pmf: \"lossless_spmf (map_pmf f p) \\<longleftrightarrow> (\\<forall>x \\<in> set_pmf p. f x \\<noteq> None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (map_pmf f p) =\n    (\\<forall>x\\<in>set_pmf p. f x \\<noteq> None)", "using image_iff"], ["proof (prove)\nusing this:\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)\n\ngoal (1 subgoal):\n 1. lossless_spmf (map_pmf f p) =\n    (\\<forall>x\\<in>set_pmf p. f x \\<noteq> None)", "by(fastforce simp add: lossless_iff_set_pmf_None)"], ["", "lemma bind_pmf_spmf_assoc:\n  \"g None = return_pmf None\n  \\<Longrightarrow> bind_pmf (bind_spmf p f) g = bind_spmf p (\\<lambda>x. bind_pmf (f x) g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g None = return_pmf None \\<Longrightarrow>\n    p \\<bind> f \\<bind> g = p \\<bind> (\\<lambda>x. f x \\<bind> g)", "by(auto simp add: bind_spmf_def bind_assoc_pmf bind_return_pmf fun_eq_iff intro!: arg_cong2[where f=bind_pmf] split: option.split)"], ["", "abbreviation pred_spmf :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a spmf \\<Rightarrow> bool\"\nwhere \"pred_spmf P \\<equiv> pred_pmf (pred_option P)\""], ["", "lemma pred_spmf_def: \"pred_spmf P p \\<longleftrightarrow> (\\<forall>x\\<in>set_spmf p. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_spmf P p = (\\<forall>x\\<in>set_spmf p. P x)", "by(auto simp add: pred_pmf_def pred_option_def set_spmf_def)"], ["", "lemma spmf_pred_mono_strong:\n  \"\\<lbrakk> pred_spmf P p; \\<And>a. \\<lbrakk> a \\<in> set_spmf p; P a \\<rbrakk> \\<Longrightarrow> P' a \\<rbrakk> \\<Longrightarrow> pred_spmf P' p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pred_spmf P p;\n     \\<And>a.\n        \\<lbrakk>a \\<in> set_spmf p; P a\\<rbrakk>\n        \\<Longrightarrow> P' a\\<rbrakk>\n    \\<Longrightarrow> pred_spmf P' p", "by(simp add: pred_spmf_def)"], ["", "lemma spmf_Domainp_rel: \"Domainp (rel_spmf R) = pred_spmf (Domainp R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp (rel_spmf R) = pred_spmf (Domainp R)", "by(simp add: pmf.Domainp_rel option.Domainp_rel)"], ["", "lemma rel_spmf_restrict_relpI [intro?]:\n  \"\\<lbrakk> rel_spmf R p q; pred_spmf P p; pred_spmf Q q \\<rbrakk> \\<Longrightarrow> rel_spmf (R \\<upharpoonleft> P \\<otimes> Q) p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel_spmf R p q; pred_spmf P p; pred_spmf Q q\\<rbrakk>\n    \\<Longrightarrow> rel_spmf (R \\<upharpoonleft> P \\<otimes> Q) p q", "by(erule spmf_rel_mono_strong)(simp add: pred_spmf_def)"], ["", "lemma rel_spmf_restrict_relpE [elim?]:\n  assumes \"rel_spmf (R \\<upharpoonleft> P \\<otimes> Q) x y\"\n  obtains \"rel_spmf R x y\" \"pred_spmf P x\" \"pred_spmf Q y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>rel_spmf R x y; pred_spmf P x; pred_spmf Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lbrakk>rel_spmf R x y; pred_spmf P x; pred_spmf Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    rel_spmf R x y\n 2. (\\<lbrakk>rel_spmf R x y; pred_spmf P x; pred_spmf Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pred_spmf P x\n 3. (\\<lbrakk>rel_spmf R x y; pred_spmf P x; pred_spmf Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pred_spmf Q y", "show \"rel_spmf R x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf R x y", "using assms"], ["proof (prove)\nusing this:\n  rel_spmf (R \\<upharpoonleft> P \\<otimes> Q) x y\n\ngoal (1 subgoal):\n 1. rel_spmf R x y", "by(auto elim!: spmf_rel_mono_strong)"], ["proof (state)\nthis:\n  rel_spmf R x y\n\ngoal (2 subgoals):\n 1. (\\<lbrakk>rel_spmf R x y; pred_spmf P x; pred_spmf Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pred_spmf P x\n 2. (\\<lbrakk>rel_spmf R x y; pred_spmf P x; pred_spmf Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pred_spmf Q y", "have \"pred_spmf (Domainp (R \\<upharpoonleft> P \\<otimes> Q)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_spmf (Domainp (R \\<upharpoonleft> P \\<otimes> Q)) x", "using assms"], ["proof (prove)\nusing this:\n  rel_spmf (R \\<upharpoonleft> P \\<otimes> Q) x y\n\ngoal (1 subgoal):\n 1. pred_spmf (Domainp (R \\<upharpoonleft> P \\<otimes> Q)) x", "by(fold spmf_Domainp_rel) blast"], ["proof (state)\nthis:\n  pred_spmf (Domainp (R \\<upharpoonleft> P \\<otimes> Q)) x\n\ngoal (2 subgoals):\n 1. (\\<lbrakk>rel_spmf R x y; pred_spmf P x; pred_spmf Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pred_spmf P x\n 2. (\\<lbrakk>rel_spmf R x y; pred_spmf P x; pred_spmf Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pred_spmf Q y", "then"], ["proof (chain)\npicking this:\n  pred_spmf (Domainp (R \\<upharpoonleft> P \\<otimes> Q)) x", "show \"pred_spmf P x\""], ["proof (prove)\nusing this:\n  pred_spmf (Domainp (R \\<upharpoonleft> P \\<otimes> Q)) x\n\ngoal (1 subgoal):\n 1. pred_spmf P x", "by(rule spmf_pred_mono_strong)(blast dest!: restrict_relp_DomainpD)"], ["proof (state)\nthis:\n  pred_spmf P x\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>rel_spmf R x y; pred_spmf P x; pred_spmf Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pred_spmf Q y", "have \"pred_spmf (Domainp (R \\<upharpoonleft> P \\<otimes> Q)\\<inverse>\\<inverse>) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_spmf\n     (Domainp (R \\<upharpoonleft> P \\<otimes> Q)\\<inverse>\\<inverse>) y", "using assms"], ["proof (prove)\nusing this:\n  rel_spmf (R \\<upharpoonleft> P \\<otimes> Q) x y\n\ngoal (1 subgoal):\n 1. pred_spmf\n     (Domainp (R \\<upharpoonleft> P \\<otimes> Q)\\<inverse>\\<inverse>) y", "by(fold spmf_Domainp_rel)(auto simp only: spmf_rel_conversep Domainp_conversep)"], ["proof (state)\nthis:\n  pred_spmf (Domainp (R \\<upharpoonleft> P \\<otimes> Q)\\<inverse>\\<inverse>)\n   y\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>rel_spmf R x y; pred_spmf P x; pred_spmf Q y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pred_spmf Q y", "then"], ["proof (chain)\npicking this:\n  pred_spmf (Domainp (R \\<upharpoonleft> P \\<otimes> Q)\\<inverse>\\<inverse>)\n   y", "show \"pred_spmf Q y\""], ["proof (prove)\nusing this:\n  pred_spmf (Domainp (R \\<upharpoonleft> P \\<otimes> Q)\\<inverse>\\<inverse>)\n   y\n\ngoal (1 subgoal):\n 1. pred_spmf Q y", "by(rule spmf_pred_mono_strong)(auto dest!: restrict_relp_DomainpD)"], ["proof (state)\nthis:\n  pred_spmf Q y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_spmf_restrict_relp_iff:\n  \"rel_spmf (R \\<upharpoonleft> P \\<otimes> Q) x y \\<longleftrightarrow> rel_spmf R x y \\<and> pred_spmf P x \\<and> pred_spmf Q y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (R \\<upharpoonleft> P \\<otimes> Q) x y =\n    (rel_spmf R x y \\<and> pred_spmf P x \\<and> pred_spmf Q y)", "by(blast intro: rel_spmf_restrict_relpI elim: rel_spmf_restrict_relpE)"], ["", "lemma spmf_pred_map: \"pred_spmf P (map_spmf f p) = pred_spmf (P \\<circ> f) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_spmf P (map_spmf f p) = pred_spmf (P \\<circ> f) p", "by(simp)"], ["", "lemma pred_spmf_bind [simp]: \"pred_spmf P (bind_spmf p f) = pred_spmf (pred_spmf P \\<circ> f) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_spmf P (p \\<bind> f) = pred_spmf (pred_spmf P \\<circ> f) p", "by(simp add: pred_spmf_def bind_UNION)"], ["", "lemma pred_spmf_return: \"pred_spmf P (return_spmf x) = P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_spmf P (return_spmf x) = P x", "by simp"], ["", "lemma pred_spmf_return_pmf_None: \"pred_spmf P (return_pmf None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_spmf P (return_pmf None)", "by simp"], ["", "lemma pred_spmf_spmf_of_pmf [simp]: \"pred_spmf P (spmf_of_pmf p) = pred_pmf P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_spmf P (spmf_of_pmf p) = pred_pmf P p", "unfolding pred_spmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set_spmf (spmf_of_pmf p)) P = pred_pmf P p", "by(simp add: pred_pmf_def)"], ["", "lemma pred_spmf_of_set [simp]: \"pred_spmf P (spmf_of_set A) = (finite A \\<longrightarrow> Ball A P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_spmf P (spmf_of_set A) = (finite A \\<longrightarrow> Ball A P)", "by(auto simp add: pred_spmf_def set_spmf_of_set)"], ["", "lemma pred_spmf_assert_spmf [simp]: \"pred_spmf P (assert_spmf b) = (b \\<longrightarrow> P ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_spmf P (assert_spmf b) = (b \\<longrightarrow> P ())", "by(cases b) simp_all"], ["", "lemma pred_spmf_pair [simp]:\n  \"pred_spmf P (pair_spmf p q) = pred_spmf (\\<lambda>x. pred_spmf (P \\<circ> Pair x) q) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_spmf P (pair_spmf p q) =\n    pred_spmf (\\<lambda>x. pred_spmf (P \\<circ> Pair x) q) p", "by(simp add: pred_spmf_def)"], ["", "lemma set_spmf_try [simp]:\n  \"set_spmf (try_spmf p q) = set_spmf p \\<union> (if lossless_spmf p then {} else set_spmf q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_spmf (TRY p ELSE q) =\n    set_spmf p \\<union> (if lossless_spmf p then {} else set_spmf q)", "by(auto simp add: try_spmf_def set_spmf_bind_pmf in_set_spmf lossless_iff_set_pmf_None split: option.splits)(metis option.collapse)"], ["", "lemma try_spmf_bind_out1:\n  \"(\\<And>x. lossless_spmf (f x)) \\<Longrightarrow> bind_spmf (TRY p ELSE q) f = TRY (bind_spmf p f) ELSE (bind_spmf q f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. lossless_spmf (f x)) \\<Longrightarrow>\n    TRY p ELSE q \\<bind> f = TRY p \\<bind> f ELSE (q \\<bind> f)", "apply(clarsimp simp add: bind_spmf_def try_spmf_def bind_assoc_pmf bind_return_pmf intro!: bind_pmf_cong[OF refl] split: option.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>x. lossless_spmf (f x);\n        Some x2 \\<in> set_pmf p\\<rbrakk>\n       \\<Longrightarrow> f x2 =\n                         f x2 \\<bind>\n                         case_option\n                          (q \\<bind> case_option (return_pmf None) f)\n                          return_spmf", "apply(rewrite in \"\\<hole> = _\" bind_return_pmf'[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>x. lossless_spmf (f x);\n        Some x2 \\<in> set_pmf p\\<rbrakk>\n       \\<Longrightarrow> f x2 \\<bind> return_pmf =\n                         f x2 \\<bind>\n                         case_option\n                          (q \\<bind> case_option (return_pmf None) f)\n                          return_spmf", "apply(rule bind_pmf_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 x.\n       \\<lbrakk>\\<And>x. lossless_spmf (f x); Some x2 \\<in> set_pmf p;\n        x \\<in> set_pmf (f x2)\\<rbrakk>\n       \\<Longrightarrow> return_pmf x =\n                         (case x of\n                          None \\<Rightarrow>\n                            q \\<bind> case_option (return_pmf None) f\n                          | Some y \\<Rightarrow> return_spmf y)", "apply(clarsimp split: option.split simp add: lossless_iff_set_pmf_None)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pred_spmf_try [simp]:\n  \"pred_spmf P (try_spmf p q) = (pred_spmf P p \\<and> (\\<not> lossless_spmf p \\<longrightarrow> pred_spmf P q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_spmf P (TRY p ELSE q) =\n    (pred_spmf P p \\<and>\n     (\\<not> lossless_spmf p \\<longrightarrow> pred_spmf P q))", "by(auto simp add: pred_spmf_def)"], ["", "lemma pred_spmf_cond [simp]:\n  \"pred_spmf P (cond_spmf p A) = pred_spmf (\\<lambda>x. x \\<in> A \\<longrightarrow> P x) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_spmf P (cond_spmf p A) =\n    pred_spmf (\\<lambda>x. x \\<in> A \\<longrightarrow> P x) p", "by(auto simp add: pred_spmf_def)"], ["", "lemma spmf_rel_map_restrict_relp: \n  shows spmf_rel_map_restrict_relp1: \"rel_spmf (R \\<upharpoonleft> P \\<otimes> Q) (map_spmf f p) = rel_spmf (R \\<circ> f \\<upharpoonleft> P \\<circ> f \\<otimes> Q) p\"\n  and spmf_rel_map_restrict_relp2: \"rel_spmf (R \\<upharpoonleft> P \\<otimes> Q) p (map_spmf g q) = rel_spmf ((\\<lambda>x. R x \\<circ> g) \\<upharpoonleft> P \\<otimes> Q \\<circ> g) p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (R \\<upharpoonleft> P \\<otimes> Q) (map_spmf f p) =\n    rel_spmf (R \\<circ> f \\<upharpoonleft> P \\<circ> f \\<otimes> Q) p &&&\n    rel_spmf (R \\<upharpoonleft> P \\<otimes> Q) p (map_spmf g q) =\n    rel_spmf\n     ((\\<lambda>x. R x \\<circ> g) \\<upharpoonleft> P \\<otimes> Q \\<circ> g)\n     p q", "by(simp_all add: spmf_rel_map restrict_relp_def)"], ["", "lemma pred_spmf_conj: \"pred_spmf (\\<lambda>x. P x \\<and> Q x) = (\\<lambda>x. pred_spmf P x \\<and> pred_spmf Q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_spmf (\\<lambda>x. P x \\<and> Q x) =\n    (\\<lambda>x. pred_spmf P x \\<and> pred_spmf Q x)", "by simp"], ["", "lemma spmf_of_pmf_parametric [transfer_rule]: \n  includes lifting_syntax shows\n  \"(rel_pmf A ===> rel_spmf A) spmf_of_pmf spmf_of_pmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_pmf A ===> rel_spmf A) spmf_of_pmf spmf_of_pmf", "unfolding spmf_of_pmf_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_pmf A ===> rel_spmf A) (map_pmf Some) (map_pmf Some)", "by transfer_prover"], ["", "lemma mono2mono_return_pmf[THEN spmf.mono2mono, simp, cont_intro]: (* Move to SPMF *)\n  shows monotone_return_pmf: \"monotone option_ord (ord_spmf (=)) return_pmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone option_ord (ord_spmf (=)) return_pmf", "by(rule monotoneI)(auto simp add: flat_ord_def)"], ["", "lemma mcont2mcont_return_pmf[THEN spmf.mcont2mcont, simp, cont_intro]:  (* Move to SPMF *)\n  shows mcont_return_pmf: \"mcont (flat_lub None) option_ord lub_spmf (ord_spmf (=)) return_pmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont (flat_lub None) option_ord lub_spmf (ord_spmf (=)) return_pmf", "by(rule mcont_finite_chains[OF _ _ flat_interpretation[THEN ccpo] ccpo_spmf]) simp_all"], ["", "lemma pred_spmf_top: (* Move up *)\n  \"pred_spmf (\\<lambda>_. True) = (\\<lambda>_. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_spmf (\\<lambda>_. True) = (\\<lambda>_. True)", "by(simp)"], ["", "lemma rel_spmf_restrict_relpI' [intro?]:\n  \"\\<lbrakk> rel_spmf (\\<lambda>x y. P x \\<longrightarrow> Q y \\<longrightarrow> R x y) p q; pred_spmf P p; pred_spmf Q q \\<rbrakk> \\<Longrightarrow> rel_spmf (R \\<upharpoonleft> P \\<otimes> Q) p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel_spmf\n              (\\<lambda>x y.\n                  P x \\<longrightarrow> Q y \\<longrightarrow> R x y)\n              p q;\n     pred_spmf P p; pred_spmf Q q\\<rbrakk>\n    \\<Longrightarrow> rel_spmf (R \\<upharpoonleft> P \\<otimes> Q) p q", "by(erule spmf_rel_mono_strong)(simp add: pred_spmf_def)"], ["", "lemma set_spmf_map_pmf_MATCH [simp]:\n  assumes \"NO_MATCH (map_option g) f\"\n  shows \"set_spmf (map_pmf f p) = (\\<Union>x\\<in>set_pmf p. set_option (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_spmf (map_pmf f p) = (\\<Union>x\\<in>set_pmf p. set_option (f x))", "by(rule set_spmf_map_pmf)"], ["", "lemma rel_spmf_bindI':\n  \"\\<lbrakk> rel_spmf A p q; \\<And>x y. \\<lbrakk> A x y; x \\<in> set_spmf p; y \\<in> set_spmf q \\<rbrakk> \\<Longrightarrow> rel_spmf B (f x) (g y) \\<rbrakk>\n  \\<Longrightarrow> rel_spmf B (p \\<bind> f) (q \\<bind> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel_spmf A p q;\n     \\<And>x y.\n        \\<lbrakk>A x y; x \\<in> set_spmf p; y \\<in> set_spmf q\\<rbrakk>\n        \\<Longrightarrow> rel_spmf B (f x) (g y)\\<rbrakk>\n    \\<Longrightarrow> rel_spmf B (p \\<bind> f) (q \\<bind> g)", "apply(rule rel_spmf_bindI[where R=\"\\<lambda>x y. A x y \\<and> x \\<in> set_spmf p \\<and> y \\<in> set_spmf q\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rel_spmf A p q;\n     \\<And>x y.\n        \\<lbrakk>A x y; x \\<in> set_spmf p; y \\<in> set_spmf q\\<rbrakk>\n        \\<Longrightarrow> rel_spmf B (f x) (g y)\\<rbrakk>\n    \\<Longrightarrow> rel_spmf\n                       (\\<lambda>x y.\n                           A x y \\<and>\n                           x \\<in> set_spmf p \\<and> y \\<in> set_spmf q)\n                       p q\n 2. \\<And>x y.\n       \\<lbrakk>rel_spmf A p q;\n        \\<And>x y.\n           \\<lbrakk>A x y; x \\<in> set_spmf p; y \\<in> set_spmf q\\<rbrakk>\n           \\<Longrightarrow> rel_spmf B (f x) (g y);\n        A x y \\<and> x \\<in> set_spmf p \\<and> y \\<in> set_spmf q\\<rbrakk>\n       \\<Longrightarrow> rel_spmf B (f x) (g y)", "apply(erule spmf_rel_mono_strong; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>rel_spmf A p q;\n        \\<And>x y.\n           \\<lbrakk>A x y; x \\<in> set_spmf p; y \\<in> set_spmf q\\<rbrakk>\n           \\<Longrightarrow> rel_spmf B (f x) (g y);\n        A x y \\<and> x \\<in> set_spmf p \\<and> y \\<in> set_spmf q\\<rbrakk>\n       \\<Longrightarrow> rel_spmf B (f x) (g y)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition rel_witness_spmf :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> 'a spmf \\<times> 'b spmf \\<Rightarrow> ('a \\<times> 'b) spmf\" where\n  \"rel_witness_spmf A = map_pmf rel_witness_option \\<circ> rel_witness_pmf (rel_option A)\""], ["", "lemma assumes \"rel_spmf A p q\"\n  shows rel_witness_spmf1: \"rel_spmf (\\<lambda>a (a', b). a = a' \\<and> A a' b) p (rel_witness_spmf A (p, q))\"\n    and rel_witness_spmf2: \"rel_spmf (\\<lambda>(a, b') b. b = b' \\<and> A a b') (rel_witness_spmf A (p, q)) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (\\<lambda>a (a', b). a = a' \\<and> A a' b) p\n     (rel_witness_spmf A (p, q)) &&&\n    rel_spmf (\\<lambda>(a, b') b. b = b' \\<and> A a b')\n     (rel_witness_spmf A (p, q)) q", "by(auto simp add: pmf.rel_map rel_witness_spmf_def intro: pmf.rel_mono_strong[OF rel_witness_pmf1[OF assms]] rel_witness_option1 pmf.rel_mono_strong[OF rel_witness_pmf2[OF assms]] rel_witness_option2)"], ["", "lemma weight_assert_spmf [simp]: \"weight_spmf (assert_spmf b) = indicator {True} b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight_spmf (assert_spmf b) = indicat_real {True} b", "by(simp split: split_indicator)"], ["", "definition enforce_spmf :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a spmf \\<Rightarrow> 'a spmf\" where\n  \"enforce_spmf P = map_pmf (enforce_option P)\""], ["", "lemma enforce_spmf_parametric [transfer_rule]: includes lifting_syntax shows\n  \"((A ===> (=)) ===> rel_spmf A ===> rel_spmf A) enforce_spmf enforce_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> (=)) ===> rel_spmf A ===> rel_spmf A) enforce_spmf enforce_spmf", "unfolding enforce_spmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> (=)) ===> rel_spmf A ===> rel_spmf A)\n     (\\<lambda>P. map_pmf (enforce_option P))\n     (\\<lambda>P. map_pmf (enforce_option P))", "by transfer_prover"], ["", "lemma enforce_return_spmf [simp]:\n  \"enforce_spmf P (return_spmf x) = (if P x then return_spmf x else return_pmf None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enforce_spmf P (return_spmf x) =\n    (if P x then return_spmf x else return_pmf None)", "by(simp add: enforce_spmf_def)"], ["", "lemma enforce_return_pmf_None [simp]:\n  \"enforce_spmf P (return_pmf None) = return_pmf None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enforce_spmf P (return_pmf None) = return_pmf None", "by(simp add: enforce_spmf_def)"], ["", "lemma enforce_map_spmf:\n  \"enforce_spmf P (map_spmf f p) = map_spmf f (enforce_spmf (P \\<circ> f) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enforce_spmf P (map_spmf f p) =\n    map_spmf f (enforce_spmf (P \\<circ> f) p)", "by(simp add: enforce_spmf_def pmf.map_comp o_def enforce_map_option)"], ["", "lemma enforce_bind_spmf [simp]:\n  \"enforce_spmf P (bind_spmf p f) = bind_spmf p (enforce_spmf P \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enforce_spmf P (p \\<bind> f) = p \\<bind> enforce_spmf P \\<circ> f", "by(auto simp add: enforce_spmf_def bind_spmf_def map_bind_pmf intro!: bind_pmf_cong split: option.split)"], ["", "lemma set_enforce_spmf [simp]: \"set_spmf (enforce_spmf P p) = {a \\<in> set_spmf p. P a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_spmf (enforce_spmf P p) = {a \\<in> set_spmf p. P a}", "by(auto simp add: enforce_spmf_def in_set_spmf)"], ["", "lemma enforce_spmf_alt_def:\n  \"enforce_spmf P p = bind_spmf p (\\<lambda>a. bind_spmf (assert_spmf (P a)) (\\<lambda>_ :: unit. return_spmf a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enforce_spmf P p =\n    p \\<bind>\n    (\\<lambda>a. assert_spmf (P a) \\<bind> (\\<lambda>_. return_spmf a))", "by(auto simp add: enforce_spmf_def assert_spmf_def map_pmf_def bind_spmf_def bind_return_pmf intro!: bind_pmf_cong split: option.split)"], ["", "lemma bind_enforce_spmf [simp]:\n  \"bind_spmf (enforce_spmf P p) f = bind_spmf p (\\<lambda>x. if P x then f x else return_pmf None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enforce_spmf P p \\<bind> f =\n    p \\<bind> (\\<lambda>x. if P x then f x else return_pmf None)", "by(auto simp add: enforce_spmf_alt_def assert_spmf_def intro!: bind_spmf_cong)"], ["", "lemma weight_enforce_spmf:\n  \"weight_spmf (enforce_spmf P p) = weight_spmf p - measure (measure_spmf p) {x. \\<not> P x}\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. weight_spmf (enforce_spmf P p) =\n    weight_spmf p - Sigma_Algebra.measure (measure_spmf p) {x. \\<not> P x}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. weight_spmf (enforce_spmf P p) =\n    weight_spmf p - Sigma_Algebra.measure (measure_spmf p) {x. \\<not> P x}", "have \"?lhs = LINT x|measure_spmf p. indicator {x. P x} x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight_spmf (enforce_spmf P p) =\n    integral\\<^sup>L (measure_spmf p) (indicat_real {x. P x})", "by(auto simp add: enforce_spmf_alt_def weight_bind_spmf o_def simp del: Bochner_Integration.integral_indicator intro!: Bochner_Integration.integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  weight_spmf (enforce_spmf P p) =\n  integral\\<^sup>L (measure_spmf p) (indicat_real {x. P x})\n\ngoal (1 subgoal):\n 1. weight_spmf (enforce_spmf P p) =\n    weight_spmf p - Sigma_Algebra.measure (measure_spmf p) {x. \\<not> P x}", "also"], ["proof (state)\nthis:\n  weight_spmf (enforce_spmf P p) =\n  integral\\<^sup>L (measure_spmf p) (indicat_real {x. P x})\n\ngoal (1 subgoal):\n 1. weight_spmf (enforce_spmf P p) =\n    weight_spmf p - Sigma_Algebra.measure (measure_spmf p) {x. \\<not> P x}", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>L (measure_spmf p) (indicat_real {x. P x}) =\n    weight_spmf p - Sigma_Algebra.measure (measure_spmf p) {x. \\<not> P x}", "by(subst measure_spmf.finite_measure_Diff[symmetric])(auto simp add: space_measure_spmf intro!: arg_cong2[where f=measure])"], ["proof (state)\nthis:\n  integral\\<^sup>L (measure_spmf p) (indicat_real {x. P x}) =\n  weight_spmf p - Sigma_Algebra.measure (measure_spmf p) {x. \\<not> P x}\n\ngoal (1 subgoal):\n 1. weight_spmf (enforce_spmf P p) =\n    weight_spmf p - Sigma_Algebra.measure (measure_spmf p) {x. \\<not> P x}", "finally"], ["proof (chain)\npicking this:\n  weight_spmf (enforce_spmf P p) =\n  weight_spmf p - Sigma_Algebra.measure (measure_spmf p) {x. \\<not> P x}", "show ?thesis"], ["proof (prove)\nusing this:\n  weight_spmf (enforce_spmf P p) =\n  weight_spmf p - Sigma_Algebra.measure (measure_spmf p) {x. \\<not> P x}\n\ngoal (1 subgoal):\n 1. weight_spmf (enforce_spmf P p) =\n    weight_spmf p - Sigma_Algebra.measure (measure_spmf p) {x. \\<not> P x}", "."], ["proof (state)\nthis:\n  weight_spmf (enforce_spmf P p) =\n  weight_spmf p - Sigma_Algebra.measure (measure_spmf p) {x. \\<not> P x}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lossless_enforce_spmf [simp]:\n  \"lossless_spmf (enforce_spmf P p) \\<longleftrightarrow> lossless_spmf p \\<and> set_spmf p \\<subseteq> {x. P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (enforce_spmf P p) =\n    (lossless_spmf p \\<and> set_spmf p \\<subseteq> {x. P x})", "by(auto simp add: enforce_spmf_alt_def)"], ["", "lemma enforce_spmf_top [simp]: \"enforce_spmf \\<top> = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enforce_spmf \\<top> = id", "by(simp add: enforce_spmf_def)"], ["", "lemma enforce_spmf_K_True [simp]: \"enforce_spmf (\\<lambda>_. True) p = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enforce_spmf (\\<lambda>_. True) p = p", "using enforce_spmf_top[THEN fun_cong, of p]"], ["proof (prove)\nusing this:\n  enforce_spmf \\<top> p = id p\n\ngoal (1 subgoal):\n 1. enforce_spmf (\\<lambda>_. True) p = p", "by(simp add: top_fun_def)"], ["", "lemma enforce_spmf_bot [simp]: \"enforce_spmf \\<bottom> = (\\<lambda>_. return_pmf None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enforce_spmf \\<bottom> = (\\<lambda>_. return_pmf None)", "by(simp add: enforce_spmf_def fun_eq_iff)"], ["", "lemma enforce_spmf_K_False [simp]: \"enforce_spmf (\\<lambda>_. False) p = return_pmf None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enforce_spmf (\\<lambda>_. False) p = return_pmf None", "using enforce_spmf_bot[THEN fun_cong, of p]"], ["proof (prove)\nusing this:\n  enforce_spmf \\<bottom> p = return_pmf None\n\ngoal (1 subgoal):\n 1. enforce_spmf (\\<lambda>_. False) p = return_pmf None", "by(simp add: bot_fun_def)"], ["", "lemma enforce_pred_id_spmf: \"enforce_spmf P p = p\" if \"pred_spmf P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enforce_spmf P p = p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. enforce_spmf P p = p", "have \"enforce_spmf P p = map_pmf id p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enforce_spmf P p = map_pmf id p", "using that"], ["proof (prove)\nusing this:\n  pred_spmf P p\n\ngoal (1 subgoal):\n 1. enforce_spmf P p = map_pmf id p", "by(auto simp add: enforce_spmf_def enforce_pred_id_option simp del: map_pmf_id intro!: pmf.map_cong_pred[OF refl] elim!: pmf_pred_mono_strong)"], ["proof (state)\nthis:\n  enforce_spmf P p = map_pmf id p\n\ngoal (1 subgoal):\n 1. enforce_spmf P p = p", "then"], ["proof (chain)\npicking this:\n  enforce_spmf P p = map_pmf id p", "show ?thesis"], ["proof (prove)\nusing this:\n  enforce_spmf P p = map_pmf id p\n\ngoal (1 subgoal):\n 1. enforce_spmf P p = p", "by simp"], ["proof (state)\nthis:\n  enforce_spmf P p = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_the_spmf_of_pmf [simp]: \"map_pmf the (spmf_of_pmf p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf the (spmf_of_pmf p) = p", "by(simp add: spmf_of_pmf_def pmf.map_comp o_def)"], ["", "lemma bind_bind_conv_pair_spmf:\n  \"bind_spmf p (\\<lambda>x. bind_spmf q (f x)) = bind_spmf (pair_spmf p q) (\\<lambda>(x, y). f x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bind> (\\<lambda>x. q \\<bind> f x) =\n    pair_spmf p q \\<bind> (\\<lambda>(x, y). f x y)", "by(simp add: pair_spmf_alt_def)"], ["", "lemma cond_spmf_spmf_of_set:\n  \"cond_spmf (spmf_of_set A) B = spmf_of_set (A \\<inter> B)\" if \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf (spmf_of_set A) B = spmf_of_set (A \\<inter> B)", "by(rule spmf_eqI)(auto simp add: spmf_of_set measure_spmf_of_set that split: split_indicator)"], ["", "lemma pair_spmf_of_set:\n  \"pair_spmf (spmf_of_set A) (spmf_of_set B) = spmf_of_set (A \\<times> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_spmf (spmf_of_set A) (spmf_of_set B) = spmf_of_set (A \\<times> B)", "by(rule spmf_eqI)(clarsimp simp add: spmf_of_set card_cartesian_product split: split_indicator)"], ["", "lemma emeasure_cond_spmf:\n  \"emeasure (measure_spmf (cond_spmf p A)) B = emeasure (measure_spmf p) (A \\<inter> B) / emeasure (measure_spmf p) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_spmf (cond_spmf p A)) B =\n    emeasure (measure_spmf p) (A \\<inter> B) / emeasure (measure_spmf p) A", "apply(clarsimp simp add: cond_spmf_def emeasure_measure_spmf_conv_measure_pmf emeasure_measure_pmf_zero_iff set_pmf_Int_Some split!: if_split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set_spmf p \\<inter> A = {} \\<Longrightarrow>\n    set_spmf p \\<inter> (A \\<inter> B) = {}\n 2. \\<And>x.\n       \\<lbrakk>emeasure (measure_pmf (cond_pmf p (Some ` A)))\n                 (Some ` B) \\<noteq>\n                emeasure (measure_pmf p) (Some ` (A \\<inter> B)) /\n                emeasure (measure_pmf p) (Some ` A);\n        x \\<in> set_spmf p; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>emeasure (measure_pmf (cond_pmf p (Some ` A)))\n                 (Some ` B) \\<noteq>\n                emeasure (measure_pmf p) (Some ` (A \\<inter> B)) /\n                emeasure (measure_pmf p) (Some ` A);\n        x \\<in> set_spmf p; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "apply(subst (asm) emeasure_cond_pmf)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set_spmf p; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> set_pmf p \\<inter> Some ` A \\<noteq> {}\n 2. \\<And>x.\n       \\<lbrakk>emeasure (measure_pmf p) (Some ` A \\<inter> Some ` B) /\n                emeasure (measure_pmf p) (Some ` A) \\<noteq>\n                emeasure (measure_pmf p) (Some ` (A \\<inter> B)) /\n                emeasure (measure_pmf p) (Some ` A);\n        x \\<in> set_spmf p; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "by(auto simp add: set_pmf_Int_Some image_Int)"], ["", "lemma measure_cond_spmf:\n  \"measure (measure_spmf (cond_spmf p A)) B = measure (measure_spmf p) (A \\<inter> B) / measure (measure_spmf p) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (cond_spmf p A)) B =\n    Sigma_Algebra.measure (measure_spmf p) (A \\<inter> B) /\n    Sigma_Algebra.measure (measure_spmf p) A", "apply(clarsimp simp add: cond_spmf_def measure_measure_spmf_conv_measure_pmf measure_pmf_zero_iff set_pmf_Int_Some split!: if_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>measure_pmf.prob (cond_pmf p (Some ` A)) (Some ` B) \\<noteq>\n                measure_pmf.prob p (Some ` (A \\<inter> B)) /\n                measure_pmf.prob p (Some ` A);\n        x \\<in> set_spmf p; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "apply(subst (asm) measure_cond_pmf)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set_spmf p; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> set_pmf p \\<inter> Some ` A \\<noteq> {}\n 2. \\<And>x.\n       \\<lbrakk>measure_pmf.prob p (Some ` A \\<inter> Some ` B) /\n                measure_pmf.prob p (Some ` A) \\<noteq>\n                measure_pmf.prob p (Some ` (A \\<inter> B)) /\n                measure_pmf.prob p (Some ` A);\n        x \\<in> set_spmf p; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "by(auto simp add: image_Int set_pmf_Int_Some)"], ["", "lemma lossless_cond_spmf [simp]: \"lossless_spmf (cond_spmf p A) \\<longleftrightarrow> set_spmf p \\<inter> A \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (cond_spmf p A) = (set_spmf p \\<inter> A \\<noteq> {})", "by(clarsimp simp add: cond_spmf_def lossless_iff_set_pmf_None set_pmf_Int_Some)"], ["", "lemma measure_spmf_eq_density: \"measure_spmf p = density (count_space UNIV) (spmf p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_spmf p =\n    density (count_space UNIV) (\\<lambda>x. ennreal (spmf p x))", "by(rule measure_eqI)(simp_all add: emeasure_density nn_integral_spmf[symmetric] nn_integral_count_space_indicator)"], ["", "lemma integral_measure_spmf:\n  fixes f :: \"'a \\<Rightarrow> 'b::{banach, second_countable_topology}\"\n  assumes A: \"finite A\"\n  shows \"(\\<And>a. a \\<in> set_spmf M \\<Longrightarrow> f a \\<noteq> 0 \\<Longrightarrow> a \\<in> A) \\<Longrightarrow> (LINT x|measure_spmf M. f x) = (\\<Sum>a\\<in>A. spmf M a *\\<^sub>R f a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set_spmf M; f a \\<noteq> (0::'b)\\<rbrakk>\n        \\<Longrightarrow> a \\<in> A) \\<Longrightarrow>\n    integral\\<^sup>L (measure_spmf M) f =\n    (\\<Sum>a\\<in>A. spmf M a *\\<^sub>R f a)", "unfolding measure_spmf_eq_density"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set_spmf M; f a \\<noteq> (0::'b)\\<rbrakk>\n        \\<Longrightarrow> a \\<in> A) \\<Longrightarrow>\n    integral\\<^sup>L\n     (density (count_space UNIV) (\\<lambda>x. ennreal (spmf M x))) f =\n    (\\<Sum>a\\<in>A. spmf M a *\\<^sub>R f a)", "apply (simp add: integral_density)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set_spmf M; f a \\<noteq> (0::'b)\\<rbrakk>\n        \\<Longrightarrow> a \\<in> A) \\<Longrightarrow>\n    LINT x|count_space UNIV. spmf M x *\\<^sub>R f x =\n    (\\<Sum>a\\<in>A. spmf M a *\\<^sub>R f a)", "apply (subst lebesgue_integral_count_space_finite_support)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set_spmf M; f a \\<noteq> (0::'b)\\<rbrakk>\n        \\<Longrightarrow> a \\<in> A) \\<Longrightarrow>\n    finite {a \\<in> UNIV. spmf M a *\\<^sub>R f a \\<noteq> (0::'b)}\n 2. (\\<And>a.\n        \\<lbrakk>a \\<in> set_spmf M; f a \\<noteq> (0::'b)\\<rbrakk>\n        \\<Longrightarrow> a \\<in> A) \\<Longrightarrow>\n    (\\<Sum>a | a \\<in> UNIV \\<and> spmf M a *\\<^sub>R f a \\<noteq> (0::'b).\n       spmf M a *\\<^sub>R f a) =\n    (\\<Sum>a\\<in>A. spmf M a *\\<^sub>R f a)", "by (auto intro!: finite_subset[OF _ \\<open>finite A\\<close>] sum.mono_neutral_left simp: spmf_eq_0_set_spmf)"], ["", "lemma image_set_spmf_eq:\n  \"f ` set_spmf p = g ` set_spmf q\" if \"ASSUMPTION (map_spmf f p = map_spmf g q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` set_spmf p = g ` set_spmf q", "using that[unfolded ASSUMPTION_def, THEN arg_cong[where f=set_spmf]]"], ["proof (prove)\nusing this:\n  set_spmf (map_spmf f p) = set_spmf (map_spmf g q)\n\ngoal (1 subgoal):\n 1. f ` set_spmf p = g ` set_spmf q", "by simp"], ["", "lemma map_spmf_const: \"map_spmf (\\<lambda>_. x) p = scale_spmf (weight_spmf p) (return_spmf x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>_. x) p = scale_spmf (weight_spmf p) (return_spmf x)", "by(simp add: map_spmf_conv_bind_spmf bind_spmf_const)"], ["", "lemma cond_return_pmf [simp]: \"cond_pmf (return_pmf x) A = return_pmf x\" if \"x \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_pmf (return_pmf x) A = return_pmf x", "using that"], ["proof (prove)\nusing this:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. cond_pmf (return_pmf x) A = return_pmf x", "by(intro pmf_eqI)(auto simp add: pmf_cond split: split_indicator)"], ["", "lemma cond_return_spmf [simp]: \"cond_spmf (return_spmf x) A = (if x \\<in> A then return_spmf x else return_pmf None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf (return_spmf x) A =\n    (if x \\<in> A then return_spmf x else return_pmf None)", "by(simp add: cond_spmf_def)"], ["", "lemma measure_range_Some_eq_weight:\n  \"measure (measure_pmf p) (range Some) = weight_spmf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob p (range Some) = weight_spmf p", "by (simp add: measure_measure_spmf_conv_measure_pmf space_measure_spmf)"], ["", "lemma restrict_spmf_eq_return_pmf_None [simp]:\n  \"restrict_spmf p A = return_pmf None \\<longleftrightarrow> set_spmf p \\<inter> A = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<upharpoonleft> A = return_pmf None) = (set_spmf p \\<inter> A = {})", "by(auto 4 3 simp add: restrict_spmf_def map_pmf_eq_return_pmf_iff bind_UNION in_set_spmf bind_eq_None_conv option.the_def dest: bspec split: if_split_asm option.split_asm)"], ["", "definition mk_lossless :: \"'a spmf \\<Rightarrow> 'a spmf\" where\n  \"mk_lossless p = scale_spmf (inverse (weight_spmf p)) p\""], ["", "lemma mk_lossless_idem [simp]: \"mk_lossless (mk_lossless p) = mk_lossless p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_lossless (mk_lossless p) = mk_lossless p", "by(simp add: mk_lossless_def weight_scale_spmf min_def max_def inverse_eq_divide)"], ["", "lemma mk_lossless_return [simp]: \"mk_lossless (return_pmf x) = return_pmf x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_lossless (return_pmf x) = return_pmf x", "by(cases x)(simp_all add: mk_lossless_def)"], ["", "lemma mk_lossless_map [simp]: \"mk_lossless (map_spmf f p) = map_spmf f (mk_lossless p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_lossless (map_spmf f p) = map_spmf f (mk_lossless p)", "by(simp add: mk_lossless_def map_scale_spmf)"], ["", "lemma spmf_mk_lossless [simp]: \"spmf (mk_lossless p) x = spmf p x / weight_spmf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (mk_lossless p) x = spmf p x / weight_spmf p", "by(simp add: mk_lossless_def spmf_scale_spmf inverse_eq_divide max_def)"], ["", "lemma set_spmf_mk_lossless [simp]: \"set_spmf (mk_lossless p) = set_spmf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_spmf (mk_lossless p) = set_spmf p", "by(simp add: mk_lossless_def set_scale_spmf measure_spmf_zero_iff zero_less_measure_iff)"], ["", "lemma mk_lossless_lossless [simp]: \"lossless_spmf p \\<Longrightarrow> mk_lossless p = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf p \\<Longrightarrow> mk_lossless p = p", "by(simp add: mk_lossless_def lossless_weight_spmfD)"], ["", "lemma mk_lossless_eq_return_pmf_None [simp]: \"mk_lossless p = return_pmf None \\<longleftrightarrow> p = return_pmf None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk_lossless p = return_pmf None) = (p = return_pmf None)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (mk_lossless p = return_pmf None) = (p = return_pmf None)", "have aux: \"weight_spmf p = 0 \\<Longrightarrow> spmf p i = 0\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. weight_spmf p = 0 \\<Longrightarrow> spmf p i = 0", "by(rule antisym, rule order_trans[OF spmf_le_weight]) (auto intro!: order_trans[OF spmf_le_weight])"], ["proof (state)\nthis:\n  weight_spmf p = 0 \\<Longrightarrow> spmf p ?i = 0\n\ngoal (1 subgoal):\n 1. (mk_lossless p = return_pmf None) = (p = return_pmf None)", "have[simp]: \" spmf (scale_spmf (inverse (weight_spmf p)) p) = spmf (return_pmf None) \\<Longrightarrow> spmf p i = 0\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (scale_spmf (inverse (weight_spmf p)) p) =\n    spmf (return_pmf None) \\<Longrightarrow>\n    spmf p i = 0", "by(drule fun_cong[where x=i]) (auto simp add: aux spmf_scale_spmf max_def)"], ["proof (state)\nthis:\n  spmf (scale_spmf (inverse (weight_spmf p)) p) =\n  spmf (return_pmf None) \\<Longrightarrow>\n  spmf p ?i = 0\n\ngoal (1 subgoal):\n 1. (mk_lossless p = return_pmf None) = (p = return_pmf None)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk_lossless p = return_pmf None) = (p = return_pmf None)", "by(auto simp add: mk_lossless_def intro: spmf_eqI)"], ["proof (state)\nthis:\n  (mk_lossless p = return_pmf None) = (p = return_pmf None)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma return_pmf_None_eq_mk_lossless [simp]: \"return_pmf None = mk_lossless p \\<longleftrightarrow> p = return_pmf None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return_pmf None = mk_lossless p) = (p = return_pmf None)", "by(metis mk_lossless_eq_return_pmf_None)"], ["", "lemma mk_lossless_spmf_of_set [simp]: \"mk_lossless (spmf_of_set A) = spmf_of_set A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_lossless (spmf_of_set A) = spmf_of_set A", "by(simp add: spmf_of_set_def del: spmf_of_pmf_pmf_of_set)"], ["", "lemma weight_mk_lossless: \"weight_spmf (mk_lossless p) = (if p = return_pmf None then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight_spmf (mk_lossless p) = (if p = return_pmf None then 0 else 1)", "by(simp add: mk_lossless_def weight_scale_spmf min_def max_def inverse_eq_divide weight_spmf_eq_0)"], ["", "lemma mk_lossless_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_spmf A ===> rel_spmf A) mk_lossless mk_lossless\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_spmf A ===> rel_spmf A) mk_lossless mk_lossless", "by(simp add: mk_lossless_def rel_fun_def rel_spmf_weightD rel_spmf_scaleI)"], ["", "lemma rel_spmf_mk_losslessI:\n  \"rel_spmf A p q \\<Longrightarrow> rel_spmf A (mk_lossless p) (mk_lossless q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf A p q \\<Longrightarrow>\n    rel_spmf A (mk_lossless p) (mk_lossless q)", "by(rule mk_lossless_parametric[THEN rel_funD])"], ["", "lemma rel_spmf_restrict_spmfI:\n  \"rel_spmf (\\<lambda>x y. (x \\<in> A \\<and> y \\<in> B \\<and> R x y) \\<or> x \\<notin> A \\<and> y \\<notin> B) p q\n   \\<Longrightarrow> rel_spmf R (restrict_spmf p A) (restrict_spmf q B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>x y.\n         x \\<in> A \\<and> y \\<in> B \\<and> R x y \\<or>\n         x \\<notin> A \\<and> y \\<notin> B)\n     p q \\<Longrightarrow>\n    rel_spmf R (p \\<upharpoonleft> A) (q \\<upharpoonleft> B)", "by(auto simp add: restrict_spmf_def pmf.rel_map elim!: option.rel_cases pmf.rel_mono_strong)"], ["", "lemma cond_spmf_alt: \"cond_spmf p A = mk_lossless (restrict_spmf p A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf p A = mk_lossless (p \\<upharpoonleft> A)", "proof(cases \"set_spmf p \\<inter> A = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. set_spmf p \\<inter> A = {} \\<Longrightarrow>\n    cond_spmf p A = mk_lossless (p \\<upharpoonleft> A)\n 2. set_spmf p \\<inter> A \\<noteq> {} \\<Longrightarrow>\n    cond_spmf p A = mk_lossless (p \\<upharpoonleft> A)", "case True"], ["proof (state)\nthis:\n  set_spmf p \\<inter> A = {}\n\ngoal (2 subgoals):\n 1. set_spmf p \\<inter> A = {} \\<Longrightarrow>\n    cond_spmf p A = mk_lossless (p \\<upharpoonleft> A)\n 2. set_spmf p \\<inter> A \\<noteq> {} \\<Longrightarrow>\n    cond_spmf p A = mk_lossless (p \\<upharpoonleft> A)", "then"], ["proof (chain)\npicking this:\n  set_spmf p \\<inter> A = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  set_spmf p \\<inter> A = {}\n\ngoal (1 subgoal):\n 1. cond_spmf p A = mk_lossless (p \\<upharpoonleft> A)", "by(simp add: cond_spmf_def measure_spmf_zero_iff)"], ["proof (state)\nthis:\n  cond_spmf p A = mk_lossless (p \\<upharpoonleft> A)\n\ngoal (1 subgoal):\n 1. set_spmf p \\<inter> A \\<noteq> {} \\<Longrightarrow>\n    cond_spmf p A = mk_lossless (p \\<upharpoonleft> A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. set_spmf p \\<inter> A \\<noteq> {} \\<Longrightarrow>\n    cond_spmf p A = mk_lossless (p \\<upharpoonleft> A)", "case False"], ["proof (state)\nthis:\n  set_spmf p \\<inter> A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. set_spmf p \\<inter> A \\<noteq> {} \\<Longrightarrow>\n    cond_spmf p A = mk_lossless (p \\<upharpoonleft> A)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf p A = mk_lossless (p \\<upharpoonleft> A)", "by(rule spmf_eqI)(simp add: False cond_spmf_def pmf_cond set_pmf_Int_Some image_iff measure_measure_spmf_conv_measure_pmf[symmetric] spmf_scale_spmf max_def inverse_eq_divide)"], ["proof (state)\nthis:\n  cond_spmf p A = mk_lossless (p \\<upharpoonleft> A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cond_spmf_bind:\n  \"cond_spmf (bind_spmf p f) A = mk_lossless (p \\<bind> (\\<lambda>x. f x \\<upharpoonleft> A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf (p \\<bind> f) A =\n    mk_lossless (p \\<bind> (\\<lambda>x. f x \\<upharpoonleft> A))", "by(simp add: cond_spmf_alt restrict_bind_spmf scale_bind_spmf)"], ["", "lemma cond_spmf_UNIV [simp]: \"cond_spmf p UNIV = mk_lossless p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf p UNIV = mk_lossless p", "by(clarsimp simp add: cond_spmf_alt)"], ["", "lemma cond_pmf_singleton:\n  \"cond_pmf p A = return_pmf x\" if \"set_pmf p \\<inter> A = {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_pmf p A = return_pmf x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cond_pmf p A = return_pmf x", "have[simp]: \"set_pmf p \\<inter> A = {x} \\<Longrightarrow> x \\<in> A \\<Longrightarrow> measure_pmf.prob p A = pmf p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set_pmf p \\<inter> A = {x}; x \\<in> A\\<rbrakk>\n    \\<Longrightarrow> measure_pmf.prob p A = pmf p x", "by(auto simp add: measure_pmf_single[symmetric] AE_measure_pmf_iff intro!: measure_pmf.finite_measure_eq_AE)"], ["proof (state)\nthis:\n  \\<lbrakk>set_pmf p \\<inter> A = {x}; x \\<in> A\\<rbrakk>\n  \\<Longrightarrow> measure_pmf.prob p A = pmf p x\n\ngoal (1 subgoal):\n 1. cond_pmf p A = return_pmf x", "have \"pmf (cond_pmf p A) i = pmf (return_pmf x) i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (cond_pmf p A) i = pmf (return_pmf x) i", "using that"], ["proof (prove)\nusing this:\n  set_pmf p \\<inter> A = {x}\n\ngoal (1 subgoal):\n 1. pmf (cond_pmf p A) i = pmf (return_pmf x) i", "by(auto simp add: pmf_cond measure_pmf_zero_iff pmf_eq_0_set_pmf split: split_indicator)"], ["proof (state)\nthis:\n  pmf (cond_pmf p A) ?i = pmf (return_pmf x) ?i\n\ngoal (1 subgoal):\n 1. cond_pmf p A = return_pmf x", "then"], ["proof (chain)\npicking this:\n  pmf (cond_pmf p A) ?i = pmf (return_pmf x) ?i", "show ?thesis"], ["proof (prove)\nusing this:\n  pmf (cond_pmf p A) ?i = pmf (return_pmf x) ?i\n\ngoal (1 subgoal):\n 1. cond_pmf p A = return_pmf x", "by(rule pmf_eqI)"], ["proof (state)\nthis:\n  cond_pmf p A = return_pmf x\n\ngoal:\nNo subgoals!", "qed"], ["", "definition cond_spmf_fst :: \"('a \\<times> 'b) spmf \\<Rightarrow> 'a \\<Rightarrow> 'b spmf\" where\n  \"cond_spmf_fst p a = map_spmf snd (cond_spmf p ({a} \\<times> UNIV))\""], ["", "lemma cond_spmf_fst_return_spmf [simp]:\n  \"cond_spmf_fst (return_spmf (x, y)) x = return_spmf y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf_fst (return_spmf (x, y)) x = return_spmf y", "by(simp add: cond_spmf_fst_def)"], ["", "lemma cond_spmf_fst_map_Pair [simp]: \"cond_spmf_fst (map_spmf (Pair x) p) x = mk_lossless p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf_fst (map_spmf (Pair x) p) x = mk_lossless p", "by(clarsimp simp add: cond_spmf_fst_def spmf.map_comp o_def)"], ["", "lemma cond_spmf_fst_map_Pair' [simp]: \"cond_spmf_fst (map_spmf (\\<lambda>y. (x, f y)) p) x = map_spmf f (mk_lossless p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf_fst (map_spmf (\\<lambda>y. (x, f y)) p) x =\n    map_spmf f (mk_lossless p)", "by(subst spmf.map_comp[where f=\"Pair x\", symmetric, unfolded o_def]) simp"], ["", "lemma cond_spmf_fst_eq_return_None [simp]: \"cond_spmf_fst p x = return_pmf None \\<longleftrightarrow> x \\<notin> fst ` set_spmf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cond_spmf_fst p x = return_pmf None) = (x \\<notin> fst ` set_spmf p)", "by(auto 4 4 simp add: cond_spmf_fst_def map_pmf_eq_return_pmf_iff in_set_spmf[symmetric] dest: bspec[where x=\"Some _\"] intro: ccontr rev_image_eqI)"], ["", "lemma cond_spmf_fst_map_Pair1:\n  \"cond_spmf_fst (map_spmf (\\<lambda>x. (f x, g x)) p) (f x) = return_spmf (g (inv_into (set_spmf p) f (f x)))\"\n  if \"x \\<in> set_spmf p\" \"inj_on f (set_spmf p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf_fst (map_spmf (\\<lambda>x. (f x, g x)) p) (f x) =\n    return_spmf (g (inv_into (set_spmf p) f (f x)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cond_spmf_fst (map_spmf (\\<lambda>x. (f x, g x)) p) (f x) =\n    return_spmf (g (inv_into (set_spmf p) f (f x)))", "let ?foo=\"\\<lambda>y. map_option (\\<lambda>x. (f x, g x)) -` Some ` ({f y} \\<times> UNIV)\""], ["proof (state)\ngoal (1 subgoal):\n 1. cond_spmf_fst (map_spmf (\\<lambda>x. (f x, g x)) p) (f x) =\n    return_spmf (g (inv_into (set_spmf p) f (f x)))", "have[simp]: \"y \\<in> set_spmf p \\<Longrightarrow> f x = f y \\<Longrightarrow> set_pmf p \\<inter> (?foo y) \\<noteq> {}\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> set_spmf p; f x = f y\\<rbrakk>\n    \\<Longrightarrow> set_pmf p \\<inter>\n                      map_option (\\<lambda>x. (f x, g x)) -`\n                      Some ` ({f y} \\<times> UNIV) \\<noteq>\n                      {}", "by(auto simp add: vimage_def image_def in_set_spmf)"], ["proof (state)\nthis:\n  \\<lbrakk>?y \\<in> set_spmf p; f x = f ?y\\<rbrakk>\n  \\<Longrightarrow> set_pmf p \\<inter>\n                    map_option (\\<lambda>x. (f x, g x)) -`\n                    Some ` ({f ?y} \\<times> UNIV) \\<noteq>\n                    {}\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (map_spmf (\\<lambda>x. (f x, g x)) p) (f x) =\n    return_spmf (g (inv_into (set_spmf p) f (f x)))", "have[simp]: \"y \\<in> set_spmf p \\<Longrightarrow> f x = f y \\<Longrightarrow>  map_spmf snd (map_spmf (\\<lambda>x. (f x, g x)) (cond_pmf p (?foo y))) = return_spmf (g x)\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> set_spmf p; f x = f y\\<rbrakk>\n    \\<Longrightarrow> map_spmf snd\n                       (map_spmf (\\<lambda>x. (f x, g x))\n                         (cond_pmf p\n                           (map_option (\\<lambda>x. (f x, g x)) -`\n                            Some ` ({f y} \\<times> UNIV)))) =\n                      return_spmf (g x)", "using that"], ["proof (prove)\nusing this:\n  x \\<in> set_spmf p\n  inj_on f (set_spmf p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> set_spmf p; f x = f y\\<rbrakk>\n    \\<Longrightarrow> map_spmf snd\n                       (map_spmf (\\<lambda>x. (f x, g x))\n                         (cond_pmf p\n                           (map_option (\\<lambda>x. (f x, g x)) -`\n                            Some ` ({f y} \\<times> UNIV)))) =\n                      return_spmf (g x)", "by(subst cond_pmf_singleton[where x=\"Some x\"]) (auto simp add: in_set_spmf elim: inj_onD)"], ["proof (state)\nthis:\n  \\<lbrakk>?y \\<in> set_spmf p; f x = f ?y\\<rbrakk>\n  \\<Longrightarrow> map_spmf snd\n                     (map_spmf (\\<lambda>x. (f x, g x))\n                       (cond_pmf p\n                         (map_option (\\<lambda>x. (f x, g x)) -`\n                          Some ` ({f ?y} \\<times> UNIV)))) =\n                    return_spmf (g x)\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (map_spmf (\\<lambda>x. (f x, g x)) p) (f x) =\n    return_spmf (g (inv_into (set_spmf p) f (f x)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf_fst (map_spmf (\\<lambda>x. (f x, g x)) p) (f x) =\n    return_spmf (g (inv_into (set_spmf p) f (f x)))", "using that"], ["proof (prove)\nusing this:\n  x \\<in> set_spmf p\n  inj_on f (set_spmf p)\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (map_spmf (\\<lambda>x. (f x, g x)) p) (f x) =\n    return_spmf (g (inv_into (set_spmf p) f (f x)))", "by(auto simp add: cond_spmf_fst_def cond_spmf_def)\n      (erule notE, subst cond_map_pmf, simp_all)"], ["proof (state)\nthis:\n  cond_spmf_fst (map_spmf (\\<lambda>x. (f x, g x)) p) (f x) =\n  return_spmf (g (inv_into (set_spmf p) f (f x)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lossless_cond_spmf_fst [simp]: \"lossless_spmf (cond_spmf_fst p x) \\<longleftrightarrow> x \\<in> fst ` set_spmf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (cond_spmf_fst p x) = (x \\<in> fst ` set_spmf p)", "by(auto simp add: cond_spmf_fst_def intro: rev_image_eqI)"], ["", "lemma cond_spmf_fst_inverse:\n  \"bind_spmf (map_spmf fst p) (\\<lambda>x. map_spmf (Pair x) (cond_spmf_fst p x)) = p\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf fst p \\<bind>\n    (\\<lambda>x. map_spmf (Pair x) (cond_spmf_fst p x)) =\n    p", "proof(rule spmf_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       spmf\n        (map_spmf fst p \\<bind>\n         (\\<lambda>x. map_spmf (Pair x) (cond_spmf_fst p x)))\n        i =\n       spmf p i", "fix i :: \"'a \\<times> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       spmf\n        (map_spmf fst p \\<bind>\n         (\\<lambda>x. map_spmf (Pair x) (cond_spmf_fst p x)))\n        i =\n       spmf p i", "have *: \"({x} \\<times> UNIV \\<inter> (Pair x \\<circ> snd) -` {i}) = (if x = fst i then {i} else {})\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x} \\<times> UNIV \\<inter> (Pair x \\<circ> snd) -` {i} =\n    (if x = fst i then {i} else {})", "by(cases i)auto"], ["proof (state)\nthis:\n  {?x} \\<times> UNIV \\<inter> (Pair ?x \\<circ> snd) -` {i} =\n  (if ?x = fst i then {i} else {})\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       spmf\n        (map_spmf fst p \\<bind>\n         (\\<lambda>x. map_spmf (Pair x) (cond_spmf_fst p x)))\n        i =\n       spmf p i", "have \"spmf ?lhs i = LINT x|measure_spmf (map_spmf fst p). spmf (map_spmf (Pair x \\<circ> snd) (cond_spmf p ({x} \\<times> UNIV))) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf fst p \\<bind>\n      (\\<lambda>x. map_spmf (Pair x) (cond_spmf_fst p x)))\n     i =\n    LINT x|measure_spmf (map_spmf fst p).\n       spmf\n        (map_spmf (Pair x \\<circ> snd) (cond_spmf p ({x} \\<times> UNIV))) i", "by(auto simp add: spmf_bind spmf.map_comp[symmetric] cond_spmf_fst_def intro!: integral_cong_AE)"], ["proof (state)\nthis:\n  spmf\n   (map_spmf fst p \\<bind>\n    (\\<lambda>x. map_spmf (Pair x) (cond_spmf_fst p x)))\n   i =\n  LINT x|measure_spmf (map_spmf fst p).\n     spmf (map_spmf (Pair x \\<circ> snd) (cond_spmf p ({x} \\<times> UNIV)))\n      i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       spmf\n        (map_spmf fst p \\<bind>\n         (\\<lambda>x. map_spmf (Pair x) (cond_spmf_fst p x)))\n        i =\n       spmf p i", "also"], ["proof (state)\nthis:\n  spmf\n   (map_spmf fst p \\<bind>\n    (\\<lambda>x. map_spmf (Pair x) (cond_spmf_fst p x)))\n   i =\n  LINT x|measure_spmf (map_spmf fst p).\n     spmf (map_spmf (Pair x \\<circ> snd) (cond_spmf p ({x} \\<times> UNIV)))\n      i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       spmf\n        (map_spmf fst p \\<bind>\n         (\\<lambda>x. map_spmf (Pair x) (cond_spmf_fst p x)))\n        i =\n       spmf p i", "have \"\\<dots> = LINT x|measure_spmf (map_spmf fst p). measure (measure_spmf (cond_spmf p ({x} \\<times> UNIV))) ((Pair x \\<circ> snd) -` {i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT x|measure_spmf (map_spmf fst p).\n       spmf\n        (map_spmf (Pair x \\<circ> snd) (cond_spmf p ({x} \\<times> UNIV)))\n        i =\n    LINT x|measure_spmf (map_spmf fst p).\n       Sigma_Algebra.measure\n        (measure_spmf (cond_spmf p ({x} \\<times> UNIV)))\n        ((Pair x \\<circ> snd) -` {i})", "by(rule integral_cong_AE)(auto simp add: spmf_map)"], ["proof (state)\nthis:\n  LINT x|measure_spmf (map_spmf fst p).\n     spmf (map_spmf (Pair x \\<circ> snd) (cond_spmf p ({x} \\<times> UNIV)))\n      i =\n  LINT x|measure_spmf (map_spmf fst p).\n     Sigma_Algebra.measure (measure_spmf (cond_spmf p ({x} \\<times> UNIV)))\n      ((Pair x \\<circ> snd) -` {i})\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       spmf\n        (map_spmf fst p \\<bind>\n         (\\<lambda>x. map_spmf (Pair x) (cond_spmf_fst p x)))\n        i =\n       spmf p i", "also"], ["proof (state)\nthis:\n  LINT x|measure_spmf (map_spmf fst p).\n     spmf (map_spmf (Pair x \\<circ> snd) (cond_spmf p ({x} \\<times> UNIV)))\n      i =\n  LINT x|measure_spmf (map_spmf fst p).\n     Sigma_Algebra.measure (measure_spmf (cond_spmf p ({x} \\<times> UNIV)))\n      ((Pair x \\<circ> snd) -` {i})\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       spmf\n        (map_spmf fst p \\<bind>\n         (\\<lambda>x. map_spmf (Pair x) (cond_spmf_fst p x)))\n        i =\n       spmf p i", "have \"\\<dots> = LINT x|measure_spmf (map_spmf fst p). measure (measure_spmf p) ({x} \\<times> UNIV \\<inter> (Pair x \\<circ> snd) -` {i}) /\n       measure (measure_spmf p) ({x} \\<times> UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT x|measure_spmf (map_spmf fst p).\n       Sigma_Algebra.measure\n        (measure_spmf (cond_spmf p ({x} \\<times> UNIV)))\n        ((Pair x \\<circ> snd) -` {i}) =\n    LINT x|measure_spmf (map_spmf fst p).\n       Sigma_Algebra.measure (measure_spmf p)\n        ({x} \\<times> UNIV \\<inter> (Pair x \\<circ> snd) -` {i}) /\n       Sigma_Algebra.measure (measure_spmf p) ({x} \\<times> UNIV)", "by(rule integral_cong_AE; clarsimp simp add: measure_cond_spmf)"], ["proof (state)\nthis:\n  LINT x|measure_spmf (map_spmf fst p).\n     Sigma_Algebra.measure (measure_spmf (cond_spmf p ({x} \\<times> UNIV)))\n      ((Pair x \\<circ> snd) -` {i}) =\n  LINT x|measure_spmf (map_spmf fst p).\n     Sigma_Algebra.measure (measure_spmf p)\n      ({x} \\<times> UNIV \\<inter> (Pair x \\<circ> snd) -` {i}) /\n     Sigma_Algebra.measure (measure_spmf p) ({x} \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       spmf\n        (map_spmf fst p \\<bind>\n         (\\<lambda>x. map_spmf (Pair x) (cond_spmf_fst p x)))\n        i =\n       spmf p i", "also"], ["proof (state)\nthis:\n  LINT x|measure_spmf (map_spmf fst p).\n     Sigma_Algebra.measure (measure_spmf (cond_spmf p ({x} \\<times> UNIV)))\n      ((Pair x \\<circ> snd) -` {i}) =\n  LINT x|measure_spmf (map_spmf fst p).\n     Sigma_Algebra.measure (measure_spmf p)\n      ({x} \\<times> UNIV \\<inter> (Pair x \\<circ> snd) -` {i}) /\n     Sigma_Algebra.measure (measure_spmf p) ({x} \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       spmf\n        (map_spmf fst p \\<bind>\n         (\\<lambda>x. map_spmf (Pair x) (cond_spmf_fst p x)))\n        i =\n       spmf p i", "have \"\\<dots> = spmf (map_spmf fst p) (fst i) * spmf p i / measure (measure_spmf p) ({fst i} \\<times> UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT x|measure_spmf (map_spmf fst p).\n       Sigma_Algebra.measure (measure_spmf p)\n        ({x} \\<times> UNIV \\<inter> (Pair x \\<circ> snd) -` {i}) /\n       Sigma_Algebra.measure (measure_spmf p) ({x} \\<times> UNIV) =\n    spmf (map_spmf fst p) (fst i) * spmf p i /\n    Sigma_Algebra.measure (measure_spmf p) ({fst i} \\<times> UNIV)", "by(simp add: * if_distrib[where f=\"measure (measure_spmf _)\"] cong: if_cong)\n      (subst integral_measure_spmf[where A=\"{fst i}\"]; auto split: if_split_asm simp add: spmf_conv_measure_spmf)"], ["proof (state)\nthis:\n  LINT x|measure_spmf (map_spmf fst p).\n     Sigma_Algebra.measure (measure_spmf p)\n      ({x} \\<times> UNIV \\<inter> (Pair x \\<circ> snd) -` {i}) /\n     Sigma_Algebra.measure (measure_spmf p) ({x} \\<times> UNIV) =\n  spmf (map_spmf fst p) (fst i) * spmf p i /\n  Sigma_Algebra.measure (measure_spmf p) ({fst i} \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       spmf\n        (map_spmf fst p \\<bind>\n         (\\<lambda>x. map_spmf (Pair x) (cond_spmf_fst p x)))\n        i =\n       spmf p i", "also"], ["proof (state)\nthis:\n  LINT x|measure_spmf (map_spmf fst p).\n     Sigma_Algebra.measure (measure_spmf p)\n      ({x} \\<times> UNIV \\<inter> (Pair x \\<circ> snd) -` {i}) /\n     Sigma_Algebra.measure (measure_spmf p) ({x} \\<times> UNIV) =\n  spmf (map_spmf fst p) (fst i) * spmf p i /\n  Sigma_Algebra.measure (measure_spmf p) ({fst i} \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       spmf\n        (map_spmf fst p \\<bind>\n         (\\<lambda>x. map_spmf (Pair x) (cond_spmf_fst p x)))\n        i =\n       spmf p i", "have \"\\<dots> = spmf p i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (map_spmf fst p) (fst i) * spmf p i /\n    Sigma_Algebra.measure (measure_spmf p) ({fst i} \\<times> UNIV) =\n    spmf p i", "by(clarsimp simp add: spmf_map vimage_fst)(metis (no_types, lifting) Int_insert_left_if1 in_set_spmf_iff_spmf insertI1 insert_UNIV insert_absorb insert_not_empty measure_spmf_zero_iff mem_Sigma_iff prod.collapse)"], ["proof (state)\nthis:\n  spmf (map_spmf fst p) (fst i) * spmf p i /\n  Sigma_Algebra.measure (measure_spmf p) ({fst i} \\<times> UNIV) =\n  spmf p i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       spmf\n        (map_spmf fst p \\<bind>\n         (\\<lambda>x. map_spmf (Pair x) (cond_spmf_fst p x)))\n        i =\n       spmf p i", "finally"], ["proof (chain)\npicking this:\n  spmf\n   (map_spmf fst p \\<bind>\n    (\\<lambda>x. map_spmf (Pair x) (cond_spmf_fst p x)))\n   i =\n  spmf p i", "show \"spmf ?lhs i = spmf ?rhs i\""], ["proof (prove)\nusing this:\n  spmf\n   (map_spmf fst p \\<bind>\n    (\\<lambda>x. map_spmf (Pair x) (cond_spmf_fst p x)))\n   i =\n  spmf p i\n\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf fst p \\<bind>\n      (\\<lambda>x. map_spmf (Pair x) (cond_spmf_fst p x)))\n     i =\n    spmf p i", "."], ["proof (state)\nthis:\n  spmf\n   (map_spmf fst p \\<bind>\n    (\\<lambda>x. map_spmf (Pair x) (cond_spmf_fst p x)))\n   i =\n  spmf p i\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Embedding of @{typ \"'a option\"} into @{typ \"'a spmf\"}\\<close>"], ["", "text \\<open>This theoretically follows from the embedding between @{typ \"_ id\"} into @{typ \"_ prob\"} and the isomorphism\n  between @{typ \"(_, _ prob) optionT\"} and @{typ \"_ spmf\"}, but we would only get the monomorphic\n  version via this connection. So we do it directly.\n\\<close>"], ["", "lemma bind_option_spmf_monad [simp]: \"monad.bind_option (return_pmf None) x = bind_spmf (return_pmf x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad.bind_option (return_pmf None) x = (\\<bind>) (return_pmf x)", "by(cases x)(simp_all add: fun_eq_iff)"], ["", "locale option_to_spmf begin"], ["", "text \\<open>\n  We have to get the embedding into the lifting package such that we can use the parametrisation of transfer rules.\n\\<close>"], ["", "definition the_pmf :: \"'a pmf \\<Rightarrow> 'a\" where \"the_pmf p = (THE x. p = return_pmf x)\""], ["", "lemma the_pmf_return [simp]: \"the_pmf (return_pmf x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_pmf (return_pmf x) = x", "by(simp add: the_pmf_def)"], ["", "lemma type_definition_option_spmf: \"type_definition return_pmf the_pmf {x. \\<exists>y :: 'a option. x = return_pmf y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition return_pmf the_pmf {x. \\<exists>y. x = return_pmf y}", "by unfold_locales(auto)"], ["", "context begin"], ["", "private"], ["", "setup_lifting type_definition_option_spmf"], ["", "abbreviation cr_spmf_option where \"cr_spmf_option \\<equiv> cr_option\""], ["", "abbreviation pcr_spmf_option where \"pcr_spmf_option \\<equiv> pcr_option\""], ["", "lemmas Quotient_spmf_option = Quotient_option\n  and cr_spmf_option_def = cr_option_def\n  and pcr_spmf_option_bi_unique = option.bi_unique\n  and Domainp_pcr_spmf_option = option.domain\n  and Domainp_pcr_spmf_option_eq = option.domain_eq\n  and Domainp_pcr_spmf_option_par = option.domain_par\n  and Domainp_pcr_spmf_option_left_total = option.domain_par_left_total\n  and pcr_spmf_option_left_unique = option.left_unique\n  and pcr_spmf_option_cr_eq = option.pcr_cr_eq\n  and pcr_spmf_option_return_pmf_transfer = option.rep_transfer\n  and pcr_spmf_option_right_total = option.right_total\n  and pcr_spmf_option_right_unique = option.right_unique\n  and pcr_spmf_option_def = pcr_option_def"], ["", "bundle spmf_option_lifting = [[Lifting.lifting_restore_internal \"Misc_CryptHOL.option.lifting\"]]"], ["", "end"], ["", "context includes lifting_syntax begin"], ["", "lemma return_option_spmf_transfer [transfer_parametric return_spmf_parametric, transfer_rule]:\n  \"((=) ===> cr_spmf_option) return_spmf Some\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> ??.Misc_CryptHOL.option_to_spmf.cr_option) return_spmf Some", "by(rule rel_funI)(simp add: cr_spmf_option_def)"], ["", "lemma map_option_spmf_transfer [transfer_parametric map_spmf_parametric, transfer_rule]:\n  \"(((=) ===> (=)) ===> cr_spmf_option ===> cr_spmf_option) map_spmf map_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((=) ===> (=)) ===>\n     ??.Misc_CryptHOL.option_to_spmf.cr_option ===>\n     ??.Misc_CryptHOL.option_to_spmf.cr_option)\n     map_spmf map_option", "unfolding rel_fun_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===>\n     ??.Misc_CryptHOL.option_to_spmf.cr_option ===>\n     ??.Misc_CryptHOL.option_to_spmf.cr_option)\n     map_spmf map_option", "by(auto simp add: rel_fun_def cr_spmf_option_def)"], ["", "lemma fail_option_spmf_transfer [transfer_parametric return_spmf_None_parametric, transfer_rule]:\n  \"cr_spmf_option (return_pmf None) None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ??.Misc_CryptHOL.option_to_spmf.cr_option (return_pmf None) None", "by(simp add: cr_spmf_option_def)"], ["", "lemma bind_option_spmf_transfer [transfer_parametric bind_spmf_parametric, transfer_rule]:\n  \"(cr_spmf_option ===> ((=) ===> cr_spmf_option) ===> cr_spmf_option) bind_spmf Option.bind\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (??.Misc_CryptHOL.option_to_spmf.cr_option ===>\n     ((=) ===> ??.Misc_CryptHOL.option_to_spmf.cr_option) ===>\n     ??.Misc_CryptHOL.option_to_spmf.cr_option)\n     (\\<bind>) (\\<bind>)", "apply(clarsimp simp add: rel_fun_def cr_spmf_option_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x ya.\n       \\<forall>xa. x xa = return_pmf (ya xa) \\<Longrightarrow>\n       return_pmf y \\<bind> x = return_pmf (y \\<bind> ya)", "subgoal for x f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. f x = return_pmf (g x) \\<Longrightarrow>\n    return_pmf x \\<bind> f = return_pmf (x \\<bind> g)", "by(cases x; simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_option_spmf_transfer [transfer_parametric set_spmf_parametric, transfer_rule]:\n  \"(cr_spmf_option ===> rel_set (=)) set_spmf set_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (??.Misc_CryptHOL.option_to_spmf.cr_option ===> rel_set (=)) set_spmf\n     set_option", "by(clarsimp simp add: rel_fun_def cr_spmf_option_def rel_set_eq)"], ["", "lemma rel_option_spmf_transfer [transfer_parametric rel_spmf_parametric, transfer_rule]:\n  \"(((=) ===> (=) ===> (=)) ===> cr_spmf_option ===> cr_spmf_option ===> (=)) rel_spmf rel_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((=) ===> (=) ===> (=)) ===>\n     ??.Misc_CryptHOL.option_to_spmf.cr_option ===>\n     ??.Misc_CryptHOL.option_to_spmf.cr_option ===> (=))\n     rel_spmf rel_option", "unfolding rel_fun_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===>\n     ??.Misc_CryptHOL.option_to_spmf.cr_option ===>\n     ??.Misc_CryptHOL.option_to_spmf.cr_option ===> (=))\n     rel_spmf rel_option", "by(simp add: rel_fun_def cr_spmf_option_def)"], ["", "end"], ["", "end"], ["", "locale option_le_spmf begin"], ["", "text \\<open>\n  Embedding where only successful computations in the option monad are related to Dirac spmf.\n\\<close>"], ["", "definition cr_option_le_spmf :: \"'a option \\<Rightarrow> 'a spmf \\<Rightarrow> bool\"\nwhere \"cr_option_le_spmf x p \\<longleftrightarrow> ord_spmf (=) (return_pmf x) p\""], ["", "context includes lifting_syntax begin"], ["", "lemma return_option_le_spmf_transfer [transfer_rule]:\n  \"((=) ===> cr_option_le_spmf) (\\<lambda>x. x) return_pmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> cr_option_le_spmf) (\\<lambda>x. x) return_pmf", "by(rule rel_funI)(simp add: cr_option_le_spmf_def ord_option_reflI)"], ["", "lemma map_option_le_spmf_transfer [transfer_rule]:\n  \"(((=) ===> (=)) ===> cr_option_le_spmf ===> cr_option_le_spmf) map_option map_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((=) ===> (=)) ===> cr_option_le_spmf ===> cr_option_le_spmf)\n     map_option map_spmf", "unfolding rel_fun_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> cr_option_le_spmf ===> cr_option_le_spmf) map_option map_spmf", "apply(clarsimp simp add: rel_fun_def cr_option_le_spmf_def rel_pmf_return_pmf1 ord_option_map1 ord_option_map2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa y xb.\n       \\<lbrakk>\\<forall>x\\<in>set_pmf y. le_option xa x;\n        xb \\<in> set_pmf y\\<rbrakk>\n       \\<Longrightarrow> ord_option (\\<lambda>xa y. x xa = x y) xa xb", "subgoal for f x p y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>xa\\<in>set_pmf p. le_option x xa;\n     y \\<in> set_pmf p\\<rbrakk>\n    \\<Longrightarrow> ord_option (\\<lambda>x y. f x = f y) x y", "by(cases x; simp add: ord_option_reflI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bind_option_le_spmf_transfer [transfer_rule]:\n  \"(cr_option_le_spmf ===> ((=) ===> cr_option_le_spmf) ===> cr_option_le_spmf) Option.bind bind_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_option_le_spmf ===>\n     ((=) ===> cr_option_le_spmf) ===> cr_option_le_spmf)\n     (\\<bind>) (\\<bind>)", "apply(clarsimp simp add: rel_fun_def cr_option_le_spmf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>ord_spmf (=) (return_pmf x) y;\n        \\<forall>x. ord_spmf (=) (return_pmf (xa x)) (ya x)\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=) (return_pmf (x \\<bind> xa))\n                          (y \\<bind> ya)", "subgoal for x p f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ord_spmf (=) (return_pmf x) p;\n     \\<forall>x. ord_spmf (=) (return_pmf (f x)) (g x)\\<rbrakk>\n    \\<Longrightarrow> ord_spmf (=) (return_pmf (x \\<bind> f)) (p \\<bind> g)", "by(cases x; auto 4 3 simp add: rel_pmf_return_pmf1 set_pmf_bind_spmf)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"], ["", "interpretation rel_spmf_characterisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf_characterisation TYPE('a) TYPE('b)", "by unfold_locales(rule rel_pmf_measureI)"], ["", "lemma if_distrib_bind_spmf1 [if_distribs]:\n  \"bind_spmf (if b then x else y) f = (if b then bind_spmf x f else bind_spmf y f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if b then x else y) \\<bind> f =\n    (if b then x \\<bind> f else y \\<bind> f)", "by simp"], ["", "lemma if_distrib_bind_spmf2 [if_distribs]:\n  \"bind_spmf x (\\<lambda>y. if b then f y else g y) = (if b then bind_spmf x f else bind_spmf x g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<bind> (\\<lambda>y. if b then f y else g y) =\n    (if b then x \\<bind> f else x \\<bind> g)", "by simp"], ["", "lemma rel_spmf_if_distrib [if_distribs]:\n  \"rel_spmf R (if b then x else y) (if b then x' else y') \\<longleftrightarrow>\n  (b \\<longrightarrow> rel_spmf R x x') \\<and> (\\<not> b \\<longrightarrow> rel_spmf R y y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf R (if b then x else y) (if b then x' else y') =\n    ((b \\<longrightarrow> rel_spmf R x x') \\<and>\n     (\\<not> b \\<longrightarrow> rel_spmf R y y'))", "by(simp)"], ["", "lemma if_distrib_map_spmf [if_distribs]:\n  \"map_spmf f (if b then p else q) = (if b then map_spmf f p else map_spmf f q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf f (if b then p else q) =\n    (if b then map_spmf f p else map_spmf f q)", "by simp"], ["", "lemma if_distrib_restrict_spmf1 [if_distribs]:\n  \"restrict_spmf (if b then p else q) A = (if b then restrict_spmf p A else restrict_spmf q A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if b then p else q) \\<upharpoonleft> A =\n    (if b then p \\<upharpoonleft> A else q \\<upharpoonleft> A)", "by simp"], ["", "end"]]}