{"file_name": "/home/qj213/afp-2021-10-22/thys/CryptHOL/Partial_Function_Set.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CryptHOL", "problem_names": ["lemma (in complete_lattice) lattice_partial_function_definition:\n  \"partial_function_definitions (\\<le>) Sup\"", "lemma fun_lub_Sup: \"fun_lub Sup = (Sup :: _ \\<Rightarrow> _ :: complete_lattice)\"", "lemma set_admissible: \"set.admissible (\\<lambda>f :: 'a \\<Rightarrow> 'b set. \\<forall>x y. y \\<in> f x \\<longrightarrow> P x y)\"", "lemma fixp_induct_set_scott:\n  fixes F :: \"'c \\<Rightarrow> 'c\"\n  and U :: \"'c \\<Rightarrow> 'b \\<Rightarrow> 'a set\"\n  and C :: \"('b \\<Rightarrow> 'a set) \\<Rightarrow> 'c\"\n  and P :: \"'b \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  and x and y\n  assumes mono: \"\\<And>x. mono_set (\\<lambda>f. U (F (C f)) x)\"\n  and eq: \"f \\<equiv> C (ccpo.fixp (fun_lub Sup) (fun_ord (\\<le>)) (\\<lambda>f. U (F (C f))))\"\n  and inverse2: \"\\<And>f. U (C f) = f\"\n  and step: \"\\<And>f x y. \\<lbrakk> \\<And>x y. y \\<in> U f x \\<Longrightarrow> P x y; y \\<in> U (F f) x \\<rbrakk> \\<Longrightarrow> P x y\"\n  and enforce_variable_ordering: \"x = x\"\n  and elem: \"y \\<in> U f x\"\n  shows \"P x y\"", "lemma fixp_Sup_le:\n  defines \"le \\<equiv> ((\\<le>) :: _ :: complete_lattice \\<Rightarrow> _)\"\n  shows \"ccpo.fixp Sup le = ccpo_class.fixp\"", "lemma fun_ord_le: \"fun_ord (\\<le>) = (\\<le>)\"", "lemma monotone_le_le: \"monotone (\\<le>) (\\<le>) = mono\"", "lemma fixp_induct_set:\n  fixes F :: \"'c \\<Rightarrow> 'c\"\n  and U :: \"'c \\<Rightarrow> 'b \\<Rightarrow> 'a set\"\n  and C :: \"('b \\<Rightarrow> 'a set) \\<Rightarrow> 'c\"\n  and P :: \"'b \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  and x and y\n  assumes mono: \"\\<And>x. mono_set (\\<lambda>f. U (F (C f)) x)\"\n  and eq: \"f \\<equiv> C (ccpo.fixp (fun_lub Sup) (fun_ord (\\<le>)) (\\<lambda>f. U (F (C f))))\"\n  and inverse2: \"\\<And>f. U (C f) = f\"\n\n  and step: \"\\<And>f' x y. \\<lbrakk> \\<And>x. U f' x = U f' x; y \\<in> U (F (C (inf (U f) (\\<lambda>x. {y. P x y})))) x \\<rbrakk> \\<Longrightarrow> P x y\"\n    \\<comment> \\<open>partial\\_function requires a quantifier over f', so let's have a fake one\\<close>\n  and elem: \"y \\<in> U f x\"\n  shows \"P x y\"", "lemma [partial_function_mono]:\n  shows insert_mono: \"mono_set A \\<Longrightarrow> mono_set (\\<lambda>f. insert x (A f))\"\n  and UNION_mono: \"\\<lbrakk>mono_set B; \\<And>y. mono_set (\\<lambda>f. C y f)\\<rbrakk> \\<Longrightarrow> mono_set (\\<lambda>f. \\<Union>y\\<in>B f. C y f)\"\n  and set_bind_mono: \"\\<lbrakk>mono_set B; \\<And>y. mono_set (\\<lambda>f. C y f)\\<rbrakk> \\<Longrightarrow> mono_set (\\<lambda>f. Set.bind (B f) (\\<lambda>y. C y f))\"\n  and Un_mono: \"\\<lbrakk> mono_set A; mono_set B \\<rbrakk> \\<Longrightarrow> mono_set (\\<lambda>f. A f \\<union> B f)\"\n  and Int_mono: \"\\<lbrakk> mono_set A; mono_set B \\<rbrakk> \\<Longrightarrow> mono_set (\\<lambda>f. A f \\<inter> B f)\"\n  and Diff_mono1: \"mono_set A \\<Longrightarrow> mono_set (\\<lambda>f. A f - X)\"\n  and image_mono: \"mono_set A \\<Longrightarrow> mono_set (\\<lambda>f. g ` A f)\"\n  and vimage_mono: \"mono_set A \\<Longrightarrow> mono_set (\\<lambda>f. g -` A f)\"", "lemma fun_lub_Inf: \"fun_lub Inf = (Inf :: _ \\<Rightarrow> _ :: complete_lattice)\"", "lemma fun_ord_ge: \"fun_ord (\\<ge>) = (\\<ge>)\"", "lemma coset_admissible: \"coset.admissible (\\<lambda>f :: 'a \\<Rightarrow> 'b set. \\<forall>x y. P x y \\<longrightarrow> y \\<in> f x)\"", "lemma gfp_eq_fixp:\n  fixes f :: \"'a :: complete_lattice \\<Rightarrow> 'a\"\n  assumes f: \"monotone (\\<ge>) (\\<ge>) f\"\n  shows \"gfp f = ccpo.fixp Inf (\\<ge>) f\"", "lemma fixp_coinduct_set:\n  fixes F :: \"'c \\<Rightarrow> 'c\"\n  and U :: \"'c \\<Rightarrow> 'b \\<Rightarrow> 'a set\"\n  and C :: \"('b \\<Rightarrow> 'a set) \\<Rightarrow> 'c\"\n  and P :: \"'b \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  and x and y\n  assumes mono: \"\\<And>x. mono_coset (\\<lambda>f. U (F (C f)) x)\"\n  and eq: \"f \\<equiv> C (ccpo.fixp (fun_lub Inter) (fun_ord (\\<ge>)) (\\<lambda>f. U (F (C f))))\"\n  and inverse2: \"\\<And>f. U (C f) = f\"\n\n  and step: \"\\<And>f' x y. \\<lbrakk> \\<And>x. U f' x = U f' x; \\<not> P x y \\<rbrakk> \\<Longrightarrow> y \\<in> U (F (C (sup (\\<lambda>x. {y. \\<not> P x y}) (U f)))) x\"\n    \\<comment> \\<open>partial\\_function requires a quantifier over f', so let's have a fake one\\<close>\n  and elem: \"y \\<notin> U f x\"\n  shows \"P x y\"", "lemma [partial_function_mono]:\n  shows insert_mono': \"mono_set' A \\<Longrightarrow> mono_set' (\\<lambda>f. insert x (A f))\"\n  and UNION_mono': \"\\<lbrakk>mono_set' B; \\<And>y. mono_set' (\\<lambda>f. C y f)\\<rbrakk> \\<Longrightarrow> mono_set' (\\<lambda>f. \\<Union>y\\<in>B f. C y f)\"\n  and set_bind_mono': \"\\<lbrakk>mono_set' B; \\<And>y. mono_set' (\\<lambda>f. C y f)\\<rbrakk> \\<Longrightarrow> mono_set' (\\<lambda>f. Set.bind (B f) (\\<lambda>y. C y f))\"\n  and Un_mono': \"\\<lbrakk> mono_set' A; mono_set' B \\<rbrakk> \\<Longrightarrow> mono_set' (\\<lambda>f. A f \\<union> B f)\"\n  and Int_mono': \"\\<lbrakk> mono_set' A; mono_set' B \\<rbrakk> \\<Longrightarrow> mono_set' (\\<lambda>f. A f \\<inter> B f)\"", "lemma test2_coinduct:\n  assumes \"P x y\"\n  and *: \"\\<And>x y. P x y \\<Longrightarrow> y = x \\<or> (P (Suc x) y \\<or> y \\<in> test2 (Suc x))\"\n  shows \"y \\<in> test2 x\""], "translations": [["", "lemma (in complete_lattice) lattice_partial_function_definition:\n  \"partial_function_definitions (\\<le>) Sup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_function_definitions (\\<le>) Sup", "by(unfold_locales)(auto intro: Sup_upper Sup_least)"], ["", "interpretation set: partial_function_definitions \"(\\<subseteq>)\" Union"], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_function_definitions (\\<subseteq>) \\<Union>", "by(rule lattice_partial_function_definition)"], ["", "lemma fun_lub_Sup: \"fun_lub Sup = (Sup :: _ \\<Rightarrow> _ :: complete_lattice)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_lub Sup = Sup", "by(fastforce simp add: fun_lub_def fun_eq_iff Sup_fun_def intro: Sup_eqI SUP_upper SUP_least)"], ["", "lemma set_admissible: \"set.admissible (\\<lambda>f :: 'a \\<Rightarrow> 'b set. \\<forall>x y. y \\<in> f x \\<longrightarrow> P x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set.admissible\n     (\\<lambda>f. \\<forall>x y. y \\<in> f x \\<longrightarrow> P x y)", "by(rule ccpo.admissibleI)(auto simp add: fun_lub_Sup)"], ["", "abbreviation \"mono_set \\<equiv> monotone (fun_ord (\\<subseteq>)) (\\<subseteq>)\""], ["", "lemma fixp_induct_set_scott:\n  fixes F :: \"'c \\<Rightarrow> 'c\"\n  and U :: \"'c \\<Rightarrow> 'b \\<Rightarrow> 'a set\"\n  and C :: \"('b \\<Rightarrow> 'a set) \\<Rightarrow> 'c\"\n  and P :: \"'b \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  and x and y\n  assumes mono: \"\\<And>x. mono_set (\\<lambda>f. U (F (C f)) x)\"\n  and eq: \"f \\<equiv> C (ccpo.fixp (fun_lub Sup) (fun_ord (\\<le>)) (\\<lambda>f. U (F (C f))))\"\n  and inverse2: \"\\<And>f. U (C f) = f\"\n  and step: \"\\<And>f x y. \\<lbrakk> \\<And>x y. y \\<in> U f x \\<Longrightarrow> P x y; y \\<in> U (F f) x \\<rbrakk> \\<Longrightarrow> P x y\"\n  and enforce_variable_ordering: \"x = x\"\n  and elem: \"y \\<in> U f x\"\n  shows \"P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x y", "using step elem set.fixp_induct_uc[of U F C, OF mono eq inverse2 set_admissible, of P]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y. y \\<in> U ?f x \\<Longrightarrow> P x y;\n   ?y \\<in> U (F ?f) ?x\\<rbrakk>\n  \\<Longrightarrow> P ?x ?y\n  y \\<in> U f x\n  \\<lbrakk>\\<forall>x y. y \\<in> \\<Union> {} \\<longrightarrow> P x y;\n   \\<And>f.\n      \\<forall>x y. y \\<in> U f x \\<longrightarrow> P x y \\<Longrightarrow>\n      \\<forall>x y. y \\<in> U (F f) x \\<longrightarrow> P x y\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x y. y \\<in> U f x \\<longrightarrow> P x y\n\ngoal (1 subgoal):\n 1. P x y", "by blast"], ["", "lemma fixp_Sup_le:\n  defines \"le \\<equiv> ((\\<le>) :: _ :: complete_lattice \\<Rightarrow> _)\"\n  shows \"ccpo.fixp Sup le = ccpo_class.fixp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.fixp Sup le = ccpo_class.fixp", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ccpo.fixp Sup le = ccpo_class.fixp", "have \"class.ccpo Sup le (<)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ccpo Sup le (<)", "unfolding le_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ccpo Sup (\\<le>) (<)", "by unfold_locales"], ["proof (state)\nthis:\n  class.ccpo Sup le (<)\n\ngoal (1 subgoal):\n 1. ccpo.fixp Sup le = ccpo_class.fixp", "thus ?thesis"], ["proof (prove)\nusing this:\n  class.ccpo Sup le (<)\n\ngoal (1 subgoal):\n 1. ccpo.fixp Sup le = ccpo_class.fixp", "by(simp add: ccpo.fixp_def fixp_def ccpo.iterates_def iterates_def ccpo.iteratesp_def iteratesp_def fun_eq_iff le_def)"], ["proof (state)\nthis:\n  ccpo.fixp Sup le = ccpo_class.fixp\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fun_ord_le: \"fun_ord (\\<le>) = (\\<le>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_ord (\\<le>) = (\\<le>)", "by(auto simp add: fun_ord_def fun_eq_iff le_fun_def)"], ["", "lemma monotone_le_le: \"monotone (\\<le>) (\\<le>) = mono\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<le>) (\\<le>) = mono", "by(simp add: monotone_def[abs_def] mono_def[abs_def])"], ["", "lemma fixp_induct_set:\n  fixes F :: \"'c \\<Rightarrow> 'c\"\n  and U :: \"'c \\<Rightarrow> 'b \\<Rightarrow> 'a set\"\n  and C :: \"('b \\<Rightarrow> 'a set) \\<Rightarrow> 'c\"\n  and P :: \"'b \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  and x and y\n  assumes mono: \"\\<And>x. mono_set (\\<lambda>f. U (F (C f)) x)\"\n  and eq: \"f \\<equiv> C (ccpo.fixp (fun_lub Sup) (fun_ord (\\<le>)) (\\<lambda>f. U (F (C f))))\"\n  and inverse2: \"\\<And>f. U (C f) = f\"\n\n  and step: \"\\<And>f' x y. \\<lbrakk> \\<And>x. U f' x = U f' x; y \\<in> U (F (C (inf (U f) (\\<lambda>x. {y. P x y})))) x \\<rbrakk> \\<Longrightarrow> P x y\"\n    \\<comment> \\<open>partial\\_function requires a quantifier over f', so let's have a fake one\\<close>\n  and elem: \"y \\<in> U f x\"\n  shows \"P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P x y", "from mono"], ["proof (chain)\npicking this:\n  set.mono_body (\\<lambda>f. U (F (C f)) ?x)", "have mono': \"mono (\\<lambda>f. U (F (C f)))\""], ["proof (prove)\nusing this:\n  set.mono_body (\\<lambda>f. U (F (C f)) ?x)\n\ngoal (1 subgoal):\n 1. mono (\\<lambda>f. U (F (C f)))", "by(simp add: fun_ord_le monotone_le_le mono_def le_fun_def)"], ["proof (state)\nthis:\n  mono (\\<lambda>f. U (F (C f)))\n\ngoal (1 subgoal):\n 1. P x y", "hence eq': \"f \\<equiv> C (lfp (\\<lambda>f. U (F (C f))))\""], ["proof (prove)\nusing this:\n  mono (\\<lambda>f. U (F (C f)))\n\ngoal (1 subgoal):\n 1. f \\<equiv> C (lfp (\\<lambda>f. U (F (C f))))", "using eq"], ["proof (prove)\nusing this:\n  mono (\\<lambda>f. U (F (C f)))\n  f \\<equiv> C (set.fixp_fun (\\<lambda>f. U (F (C f))))\n\ngoal (1 subgoal):\n 1. f \\<equiv> C (lfp (\\<lambda>f. U (F (C f))))", "unfolding fun_ord_le fun_lub_Sup fixp_Sup_le"], ["proof (prove)\nusing this:\n  mono (\\<lambda>f. U (F (C f)))\n  f \\<equiv> C (ccpo_class.fixp (\\<lambda>f. U (F (C f))))\n\ngoal (1 subgoal):\n 1. f \\<equiv> C (lfp (\\<lambda>f. U (F (C f))))", "by(simp add: lfp_eq_fixp)"], ["proof (state)\nthis:\n  f \\<equiv> C (lfp (\\<lambda>f. U (F (C f))))\n\ngoal (1 subgoal):\n 1. P x y", "let ?f = \"C (lfp (\\<lambda>f. U (F (C f))))\""], ["proof (state)\ngoal (1 subgoal):\n 1. P x y", "have step': \"\\<And>x y. \\<lbrakk> y \\<in> U (F (C (inf (U ?f) (\\<lambda>x. {y. P x y})))) x \\<rbrakk> \\<Longrightarrow> P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       y \\<in> U (F (C (inf (U (C (lfp (\\<lambda>f. U (F (C f))))))\n                         (\\<lambda>x. {y. P x y}))))\n                x \\<Longrightarrow>\n       P x y", "unfolding eq'[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       y \\<in> U (F (C (inf (U f) (\\<lambda>x. {y. P x y}))))\n                x \\<Longrightarrow>\n       P x y", "by(rule step[OF refl])"], ["proof (state)\nthis:\n  ?y \\<in> U (F (C (inf (U (C (lfp (\\<lambda>f. U (F (C f))))))\n                     (\\<lambda>x. {y. P x y}))))\n            ?x \\<Longrightarrow>\n  P ?x ?y\n\ngoal (1 subgoal):\n 1. P x y", "let ?P = \"\\<lambda>x. {y. P x y}\""], ["proof (state)\ngoal (1 subgoal):\n 1. P x y", "from mono'"], ["proof (chain)\npicking this:\n  mono (\\<lambda>f. U (F (C f)))", "have \"lfp (\\<lambda>f. U (F (C f))) \\<le> ?P\""], ["proof (prove)\nusing this:\n  mono (\\<lambda>f. U (F (C f)))\n\ngoal (1 subgoal):\n 1. lfp (\\<lambda>f. U (F (C f))) \\<le> (\\<lambda>x. {y. P x y})", "by(rule lfp_induct)(auto intro!: le_funI step' simp add: inverse2)"], ["proof (state)\nthis:\n  lfp (\\<lambda>f. U (F (C f))) \\<le> (\\<lambda>x. {y. P x y})\n\ngoal (1 subgoal):\n 1. P x y", "with elem"], ["proof (chain)\npicking this:\n  y \\<in> U f x\n  lfp (\\<lambda>f. U (F (C f))) \\<le> (\\<lambda>x. {y. P x y})", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> U f x\n  lfp (\\<lambda>f. U (F (C f))) \\<le> (\\<lambda>x. {y. P x y})\n\ngoal (1 subgoal):\n 1. P x y", "by(subst (asm) eq')(auto simp add: inverse2 le_fun_def)"], ["proof (state)\nthis:\n  P x y\n\ngoal:\nNo subgoals!", "qed"], ["", "declaration \\<open>Partial_Function.init \"set\" @{term set.fixp_fun}\n  @{term set.mono_body} @{thm set.fixp_rule_uc} @{thm set.fixp_induct_uc}\n  (SOME @{thm fixp_induct_set})\\<close>"], ["", "lemma [partial_function_mono]:\n  shows insert_mono: \"mono_set A \\<Longrightarrow> mono_set (\\<lambda>f. insert x (A f))\"\n  and UNION_mono: \"\\<lbrakk>mono_set B; \\<And>y. mono_set (\\<lambda>f. C y f)\\<rbrakk> \\<Longrightarrow> mono_set (\\<lambda>f. \\<Union>y\\<in>B f. C y f)\"\n  and set_bind_mono: \"\\<lbrakk>mono_set B; \\<And>y. mono_set (\\<lambda>f. C y f)\\<rbrakk> \\<Longrightarrow> mono_set (\\<lambda>f. Set.bind (B f) (\\<lambda>y. C y f))\"\n  and Un_mono: \"\\<lbrakk> mono_set A; mono_set B \\<rbrakk> \\<Longrightarrow> mono_set (\\<lambda>f. A f \\<union> B f)\"\n  and Int_mono: \"\\<lbrakk> mono_set A; mono_set B \\<rbrakk> \\<Longrightarrow> mono_set (\\<lambda>f. A f \\<inter> B f)\"\n  and Diff_mono1: \"mono_set A \\<Longrightarrow> mono_set (\\<lambda>f. A f - X)\"\n  and image_mono: \"mono_set A \\<Longrightarrow> mono_set (\\<lambda>f. g ` A f)\"\n  and vimage_mono: \"mono_set A \\<Longrightarrow> mono_set (\\<lambda>f. g -` A f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((monotone set.le_fun (\\<subseteq>) A \\<Longrightarrow>\n       monotone set.le_fun (\\<subseteq>) (\\<lambda>f. insert x (A f))) &&&\n      (\\<lbrakk>monotone set.le_fun (\\<subseteq>) B;\n        \\<And>y. monotone set.le_fun (\\<subseteq>) (C y)\\<rbrakk>\n       \\<Longrightarrow> monotone set.le_fun (\\<subseteq>)\n                          (\\<lambda>f. \\<Union>y\\<in>B f. C y f))) &&&\n     (\\<lbrakk>monotone set.le_fun (\\<subseteq>) B;\n       \\<And>y. monotone set.le_fun (\\<subseteq>) (C y)\\<rbrakk>\n      \\<Longrightarrow> monotone set.le_fun (\\<subseteq>)\n                         (\\<lambda>f.\n                             Set.bind (B f) (\\<lambda>y. C y f))) &&&\n     (\\<lbrakk>monotone set.le_fun (\\<subseteq>) A;\n       monotone set.le_fun (\\<subseteq>) B\\<rbrakk>\n      \\<Longrightarrow> monotone set.le_fun (\\<subseteq>)\n                         (\\<lambda>f. A f \\<union> B f))) &&&\n    ((\\<lbrakk>monotone set.le_fun (\\<subseteq>) A;\n       monotone set.le_fun (\\<subseteq>) B\\<rbrakk>\n      \\<Longrightarrow> monotone set.le_fun (\\<subseteq>)\n                         (\\<lambda>f. A f \\<inter> B f)) &&&\n     (monotone set.le_fun (\\<subseteq>) A \\<Longrightarrow>\n      monotone set.le_fun (\\<subseteq>) (\\<lambda>f. A f - X))) &&&\n    (monotone set.le_fun (\\<subseteq>) A \\<Longrightarrow>\n     monotone set.le_fun (\\<subseteq>) (\\<lambda>f. g ` A f)) &&&\n    (monotone set.le_fun (\\<subseteq>) A \\<Longrightarrow>\n     monotone set.le_fun (\\<subseteq>) (\\<lambda>f. g -` A f))", "unfolding bind_UNION"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((monotone set.le_fun (\\<subseteq>) A \\<Longrightarrow>\n       monotone set.le_fun (\\<subseteq>) (\\<lambda>f. insert x (A f))) &&&\n      (\\<lbrakk>monotone set.le_fun (\\<subseteq>) B;\n        \\<And>y. monotone set.le_fun (\\<subseteq>) (C y)\\<rbrakk>\n       \\<Longrightarrow> monotone set.le_fun (\\<subseteq>)\n                          (\\<lambda>f. \\<Union>y\\<in>B f. C y f))) &&&\n     (\\<lbrakk>monotone set.le_fun (\\<subseteq>) B;\n       \\<And>y. monotone set.le_fun (\\<subseteq>) (C y)\\<rbrakk>\n      \\<Longrightarrow> monotone set.le_fun (\\<subseteq>)\n                         (\\<lambda>f. \\<Union>y\\<in>B f. C y f)) &&&\n     (\\<lbrakk>monotone set.le_fun (\\<subseteq>) A;\n       monotone set.le_fun (\\<subseteq>) B\\<rbrakk>\n      \\<Longrightarrow> monotone set.le_fun (\\<subseteq>)\n                         (\\<lambda>f. A f \\<union> B f))) &&&\n    ((\\<lbrakk>monotone set.le_fun (\\<subseteq>) A;\n       monotone set.le_fun (\\<subseteq>) B\\<rbrakk>\n      \\<Longrightarrow> monotone set.le_fun (\\<subseteq>)\n                         (\\<lambda>f. A f \\<inter> B f)) &&&\n     (monotone set.le_fun (\\<subseteq>) A \\<Longrightarrow>\n      monotone set.le_fun (\\<subseteq>) (\\<lambda>f. A f - X))) &&&\n    (monotone set.le_fun (\\<subseteq>) A \\<Longrightarrow>\n     monotone set.le_fun (\\<subseteq>) (\\<lambda>f. g ` A f)) &&&\n    (monotone set.le_fun (\\<subseteq>) A \\<Longrightarrow>\n     monotone set.le_fun (\\<subseteq>) (\\<lambda>f. g -` A f))", "by(fast intro!: monotoneI dest: monotoneD)+"], ["", "partial_function (set) test :: \"'a list \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> int set\"\nwhere\n  \"test xs i j = insert 4 (test [] 0 j \\<union> test [] 1 True \\<inter> test [] 2 False - {5} \\<union> uminus ` test [undefined] 0 True \\<union> uminus -` test [] 1 False)\""], ["", "interpretation coset: partial_function_definitions \"(\\<supseteq>)\" Inter"], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_function_definitions (\\<lambda>x y. y \\<subseteq> x) \\<Inter>", "by(rule complete_lattice.lattice_partial_function_definition[OF dual_complete_lattice])"], ["", "lemma fun_lub_Inf: \"fun_lub Inf = (Inf :: _ \\<Rightarrow> _ :: complete_lattice)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_lub Inf = Inf", "by(auto simp add: fun_lub_def fun_eq_iff Inf_fun_def intro: Inf_eqI INF_lower INF_greatest)"], ["", "lemma fun_ord_ge: \"fun_ord (\\<ge>) = (\\<ge>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_ord (\\<lambda>x y. y \\<le> x) = (\\<lambda>x y. y \\<le> x)", "by(auto simp add: fun_ord_def fun_eq_iff le_fun_def)"], ["", "lemma coset_admissible: \"coset.admissible (\\<lambda>f :: 'a \\<Rightarrow> 'b set. \\<forall>x y. P x y \\<longrightarrow> y \\<in> f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coset.admissible\n     (\\<lambda>f. \\<forall>x y. P x y \\<longrightarrow> y \\<in> f x)", "by(rule ccpo.admissibleI)(auto simp add: fun_lub_Inf)"], ["", "abbreviation \"mono_coset \\<equiv> monotone (fun_ord (\\<supseteq>)) (\\<supseteq>)\""], ["", "lemma gfp_eq_fixp:\n  fixes f :: \"'a :: complete_lattice \\<Rightarrow> 'a\"\n  assumes f: \"monotone (\\<ge>) (\\<ge>) f\"\n  shows \"gfp f = ccpo.fixp Inf (\\<ge>) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gfp f = ccpo.fixp Inf (\\<lambda>x y. y \\<le> x) f", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. gfp f \\<le> ccpo.fixp Inf (\\<lambda>x y. y \\<le> x) f\n 2. ccpo.fixp Inf (\\<lambda>x y. y \\<le> x) f \\<le> gfp f", "from f"], ["proof (chain)\npicking this:\n  monotone (\\<lambda>x y. y \\<le> x) (\\<lambda>x y. y \\<le> x) f", "have f': \"mono f\""], ["proof (prove)\nusing this:\n  monotone (\\<lambda>x y. y \\<le> x) (\\<lambda>x y. y \\<le> x) f\n\ngoal (1 subgoal):\n 1. mono f", "by(simp add: mono_def monotone_def)"], ["proof (state)\nthis:\n  mono f\n\ngoal (2 subgoals):\n 1. gfp f \\<le> ccpo.fixp Inf (\\<lambda>x y. y \\<le> x) f\n 2. ccpo.fixp Inf (\\<lambda>x y. y \\<le> x) f \\<le> gfp f", "interpret ccpo Inf \"(\\<ge>)\" \"mk_less (\\<ge>) :: 'a \\<Rightarrow> _\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ccpo Inf (\\<lambda>x y. y \\<le> x)\n     (mk_less (\\<lambda>x y. y \\<le> x))", "by(rule ccpo)(rule complete_lattice.lattice_partial_function_definition[OF dual_complete_lattice])"], ["proof (state)\ngoal (2 subgoals):\n 1. gfp f \\<le> fixp f\n 2. fixp f \\<le> gfp f", "show \"ccpo.fixp Inf (\\<ge>) f \\<le> gfp f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fixp f \\<le> gfp f", "by(rule gfp_upperbound)(subst fixp_unfold[OF f], rule order_refl)"], ["proof (state)\nthis:\n  fixp f \\<le> gfp f\n\ngoal (1 subgoal):\n 1. gfp f \\<le> fixp f", "show \"gfp f \\<le> ccpo.fixp Inf (\\<ge>) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gfp f \\<le> fixp f", "by(rule fixp_lowerbound[OF f])(subst gfp_unfold[OF f'], rule order_refl)"], ["proof (state)\nthis:\n  gfp f \\<le> fixp f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fixp_coinduct_set:\n  fixes F :: \"'c \\<Rightarrow> 'c\"\n  and U :: \"'c \\<Rightarrow> 'b \\<Rightarrow> 'a set\"\n  and C :: \"('b \\<Rightarrow> 'a set) \\<Rightarrow> 'c\"\n  and P :: \"'b \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  and x and y\n  assumes mono: \"\\<And>x. mono_coset (\\<lambda>f. U (F (C f)) x)\"\n  and eq: \"f \\<equiv> C (ccpo.fixp (fun_lub Inter) (fun_ord (\\<ge>)) (\\<lambda>f. U (F (C f))))\"\n  and inverse2: \"\\<And>f. U (C f) = f\"\n\n  and step: \"\\<And>f' x y. \\<lbrakk> \\<And>x. U f' x = U f' x; \\<not> P x y \\<rbrakk> \\<Longrightarrow> y \\<in> U (F (C (sup (\\<lambda>x. {y. \\<not> P x y}) (U f)))) x\"\n    \\<comment> \\<open>partial\\_function requires a quantifier over f', so let's have a fake one\\<close>\n  and elem: \"y \\<notin> U f x\"\n  shows \"P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x y", "using elem"], ["proof (prove)\nusing this:\n  y \\<notin> U f x\n\ngoal (1 subgoal):\n 1. P x y", "proof(rule contrapos_np)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> P x y \\<Longrightarrow> y \\<in> U f x", "have mono': \"monotone (\\<ge>) (\\<ge>) (\\<lambda>f. U (F (C f)))\"\n    and mono'': \"mono (\\<lambda>f. U (F (C f)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<lambda>x y. y \\<le> x) (\\<lambda>x y. y \\<le> x)\n     (\\<lambda>f. U (F (C f))) &&&\n    mono (\\<lambda>f. U (F (C f)))", "using mono"], ["proof (prove)\nusing this:\n  coset.mono_body (\\<lambda>f. U (F (C f)) ?x)\n\ngoal (1 subgoal):\n 1. monotone (\\<lambda>x y. y \\<le> x) (\\<lambda>x y. y \\<le> x)\n     (\\<lambda>f. U (F (C f))) &&&\n    mono (\\<lambda>f. U (F (C f)))", "by(simp_all add: monotone_def fun_ord_def le_fun_def mono_def)"], ["proof (state)\nthis:\n  monotone (\\<lambda>x y. y \\<le> x) (\\<lambda>x y. y \\<le> x)\n   (\\<lambda>f. U (F (C f)))\n  mono (\\<lambda>f. U (F (C f)))\n\ngoal (1 subgoal):\n 1. \\<not> P x y \\<Longrightarrow> y \\<in> U f x", "hence eq': \"U f = gfp (\\<lambda>f. U (F (C f)))\""], ["proof (prove)\nusing this:\n  monotone (\\<lambda>x y. y \\<le> x) (\\<lambda>x y. y \\<le> x)\n   (\\<lambda>f. U (F (C f)))\n  mono (\\<lambda>f. U (F (C f)))\n\ngoal (1 subgoal):\n 1. U f = gfp (\\<lambda>f. U (F (C f)))", "by(subst eq)(simp add: fun_lub_Inf fun_ord_ge gfp_eq_fixp inverse2)"], ["proof (state)\nthis:\n  U f = gfp (\\<lambda>f. U (F (C f)))\n\ngoal (1 subgoal):\n 1. \\<not> P x y \\<Longrightarrow> y \\<in> U f x", "let ?P = \"\\<lambda>x. {y. \\<not> P x y}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> P x y \\<Longrightarrow> y \\<in> U f x", "have \"?P \\<le> gfp (\\<lambda>f. U (F (C f)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. {y. \\<not> P x y}) \\<le> gfp (\\<lambda>f. U (F (C f)))", "using mono''"], ["proof (prove)\nusing this:\n  mono (\\<lambda>f. U (F (C f)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. {y. \\<not> P x y}) \\<le> gfp (\\<lambda>f. U (F (C f)))", "by(rule coinduct)(auto intro!:  le_funI dest: step[OF refl] simp add: eq')"], ["proof (state)\nthis:\n  (\\<lambda>x. {y. \\<not> P x y}) \\<le> gfp (\\<lambda>f. U (F (C f)))\n\ngoal (1 subgoal):\n 1. \\<not> P x y \\<Longrightarrow> y \\<in> U f x", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>x. {y. \\<not> P x y}) \\<le> gfp (\\<lambda>f. U (F (C f)))\n\ngoal (1 subgoal):\n 1. \\<not> P x y \\<Longrightarrow> y \\<in> U f x", "assume \"\\<not> P x y\""], ["proof (state)\nthis:\n  \\<not> P x y\n\ngoal (1 subgoal):\n 1. \\<not> P x y \\<Longrightarrow> y \\<in> U f x", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>x. {y. \\<not> P x y}) \\<le> gfp (\\<lambda>f. U (F (C f)))\n  \\<not> P x y", "show \"y \\<in> U f x\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. {y. \\<not> P x y}) \\<le> gfp (\\<lambda>f. U (F (C f)))\n  \\<not> P x y\n\ngoal (1 subgoal):\n 1. y \\<in> U f x", "by(auto simp add: le_fun_def eq')"], ["proof (state)\nthis:\n  y \\<in> U f x\n\ngoal:\nNo subgoals!", "qed"], ["", "declaration \\<open>Partial_Function.init \"coset\" @{term coset.fixp_fun}\n  @{term coset.mono_body} @{thm coset.fixp_rule_uc} @{thm coset.fixp_induct_uc}\n  (SOME @{thm fixp_coinduct_set})\\<close>"], ["", "abbreviation \"mono_set' \\<equiv> monotone (fun_ord (\\<supseteq>)) (\\<supseteq>)\""], ["", "lemma [partial_function_mono]:\n  shows insert_mono': \"mono_set' A \\<Longrightarrow> mono_set' (\\<lambda>f. insert x (A f))\"\n  and UNION_mono': \"\\<lbrakk>mono_set' B; \\<And>y. mono_set' (\\<lambda>f. C y f)\\<rbrakk> \\<Longrightarrow> mono_set' (\\<lambda>f. \\<Union>y\\<in>B f. C y f)\"\n  and set_bind_mono': \"\\<lbrakk>mono_set' B; \\<And>y. mono_set' (\\<lambda>f. C y f)\\<rbrakk> \\<Longrightarrow> mono_set' (\\<lambda>f. Set.bind (B f) (\\<lambda>y. C y f))\"\n  and Un_mono': \"\\<lbrakk> mono_set' A; mono_set' B \\<rbrakk> \\<Longrightarrow> mono_set' (\\<lambda>f. A f \\<union> B f)\"\n  and Int_mono': \"\\<lbrakk> mono_set' A; mono_set' B \\<rbrakk> \\<Longrightarrow> mono_set' (\\<lambda>f. A f \\<inter> B f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x)\n       A \\<Longrightarrow>\n      monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x)\n       (\\<lambda>f. insert x (A f))) &&&\n     (\\<lbrakk>monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x) B;\n       \\<And>y.\n          monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x)\n           (C y)\\<rbrakk>\n      \\<Longrightarrow> monotone coset.le_fun\n                         (\\<lambda>x y. y \\<subseteq> x)\n                         (\\<lambda>f. \\<Union>y\\<in>B f. C y f))) &&&\n    (\\<lbrakk>monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x) B;\n      \\<And>y.\n         monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x)\n          (C y)\\<rbrakk>\n     \\<Longrightarrow> monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x)\n                        (\\<lambda>f.\n                            Set.bind (B f) (\\<lambda>y. C y f))) &&&\n    (\\<lbrakk>monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x) A;\n      monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x) B\\<rbrakk>\n     \\<Longrightarrow> monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x)\n                        (\\<lambda>f. A f \\<union> B f)) &&&\n    (\\<lbrakk>monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x) A;\n      monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x) B\\<rbrakk>\n     \\<Longrightarrow> monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x)\n                        (\\<lambda>f. A f \\<inter> B f))", "unfolding bind_UNION"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x)\n       A \\<Longrightarrow>\n      monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x)\n       (\\<lambda>f. insert x (A f))) &&&\n     (\\<lbrakk>monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x) B;\n       \\<And>y.\n          monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x)\n           (C y)\\<rbrakk>\n      \\<Longrightarrow> monotone coset.le_fun\n                         (\\<lambda>x y. y \\<subseteq> x)\n                         (\\<lambda>f. \\<Union>y\\<in>B f. C y f))) &&&\n    (\\<lbrakk>monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x) B;\n      \\<And>y.\n         monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x)\n          (C y)\\<rbrakk>\n     \\<Longrightarrow> monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x)\n                        (\\<lambda>f. \\<Union>y\\<in>B f. C y f)) &&&\n    (\\<lbrakk>monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x) A;\n      monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x) B\\<rbrakk>\n     \\<Longrightarrow> monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x)\n                        (\\<lambda>f. A f \\<union> B f)) &&&\n    (\\<lbrakk>monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x) A;\n      monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x) B\\<rbrakk>\n     \\<Longrightarrow> monotone coset.le_fun (\\<lambda>x y. y \\<subseteq> x)\n                        (\\<lambda>f. A f \\<inter> B f))", "by(fast intro!: monotoneI dest: monotoneD)+"], ["", "context begin"], ["", "private"], ["", "partial_function (coset) test2 :: \"nat \\<Rightarrow> nat set\"\nwhere \"test2 x = insert x (test2 (Suc x))\""], ["", "private"], ["", "lemma test2_coinduct:\n  assumes \"P x y\"\n  and *: \"\\<And>x y. P x y \\<Longrightarrow> y = x \\<or> (P (Suc x) y \\<or> y \\<in> test2 (Suc x))\"\n  shows \"y \\<in> test2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> test2 x", "using \\<open>P x y\\<close>"], ["proof (prove)\nusing this:\n  P x y\n\ngoal (1 subgoal):\n 1. y \\<in> test2 x", "apply(rule contrapos_pp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<notin> test2 x \\<Longrightarrow> \\<not> P x y", "apply(erule test2.raw_induct[rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>test2a x xa.\n       \\<lbrakk>\\<And>x. test2a x = test2a x; \\<not> \\<not> P x xa\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> insert x\n                                   (sup (\\<lambda>x.\n      {y. \\<not> \\<not> P x y})\n                                     test2 (Suc x))", "apply(simp add: *)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}