{"file_name": "/home/qj213/afp-2021-10-22/thys/Paraconsistency/Paraconsistency.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Paraconsistency", "problem_names": ["lemma eval_equality_simplify: \"eval i (Eql p q) = Det (eval i p = eval i q)\"", "theorem eval_equality:\n  \"eval i (Eql' p q) =\n    (\n      if eval i p = eval i q then Det True else\n      if eval i p = Det True then eval i q else\n      if eval i q = Det True then eval i p else\n      if eval i p = Det False then eval i (Neg' q) else\n      if eval i q = Det False then eval i (Neg' p) else\n      Det False\n    )\"", "theorem eval_negation:\n  \"eval i (Neg' p) =\n    (\n      if eval i p = Det False then Det True else\n      if eval i p = Det True then Det False else\n      eval i p\n    )\"", "lemma double_negation: \"eval i p = eval i (Neg' (Neg' p))\"", "theorem conjunction: \"valid (Con' p q) \\<longleftrightarrow> valid p \\<and> valid q\"", "theorem universal_domain: \"domain {n. True} = {x. True}\"", "theorem valid_valid_in: assumes \"valid p\" shows \"valid_in U p\"", "theorem transfer: assumes \"\\<not> valid_in U p\" shows \"\\<not> valid p\"", "theorem conjunction_in: \"valid_in U (Con' p q) \\<longleftrightarrow> valid_in U p \\<and> valid_in U q\"", "lemma explosion_counterexample: \"\\<not> valid_in {1} (Explosion (Pro ''p'') (Pro ''q''))\"", "theorem explosion_not_valid: \"\\<not> valid (Explosion (Pro ''p'') (Pro ''q''))\"", "lemma contraposition_counterexample: \"\\<not> valid_in {1, 2} (Contraposition (Pro ''p'') (Pro ''q''))\"", "theorem contraposition_not_valid: \"\\<not> valid (Contraposition (Pro ''p'') (Pro ''q''))\"", "lemma ranges: assumes \"range i \\<subseteq> domain U\" shows \"eval i p \\<in> domain U\"", "lemma relevant_props: assumes \"\\<forall>s \\<in> props p. i1 s = i2 s\" shows \"eval i1 p = eval i2 p\"", "lemma change_tv_injection: assumes \"inj f\" shows \"inj (change_tv f)\"", "lemma eval_change: assumes \"inj f\" shows \"eval (change_int f i) p = change_tv f (eval i p)\"", "theorem valid_in_valid: assumes \"card U \\<ge> card (props p)\" and \"valid_in U p\" shows \"valid p\"", "theorem reduce: \"valid p \\<longleftrightarrow> valid_in {1..card (props p)} p\"", "theorem entailment_not_chain:\n  \"\\<not> valid (Eql (Entail [Pro ''p'', Pro ''q''] (Pro ''r''))\n      (Box ((Imp' (Pro ''p'') (Imp' (Pro ''q'') (Pro ''r''))))))\"", "theorem classical_logic_is_not_usable: \"valid_boole (Entail [B0, B1] p)\""], "translations": [["", "lemma eval_equality_simplify: \"eval i (Eql p q) = Det (eval i p = eval i q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval i (Eql p q) = Det (eval i p = eval i q)", "by simp"], ["", "theorem eval_equality:\n  \"eval i (Eql' p q) =\n    (\n      if eval i p = eval i q then Det True else\n      if eval i p = Det True then eval i q else\n      if eval i q = Det True then eval i p else\n      if eval i p = Det False then eval i (Neg' q) else\n      if eval i q = Det False then eval i (Neg' p) else\n      Det False\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval i (Eql' p q) =\n    (if eval i p = eval i q then Det True\n     else if eval i p = Det True then eval i q\n          else if eval i q = Det True then eval i p\n               else if eval i p = Det False then eval i (Neg' q)\n                    else if eval i q = Det False then eval i (Neg' p)\n                         else Det False)", "by (cases \"eval i p\"; cases \"eval i q\") simp_all"], ["", "theorem eval_negation:\n  \"eval i (Neg' p) =\n    (\n      if eval i p = Det False then Det True else\n      if eval i p = Det True then Det False else\n      eval i p\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval i (Neg' p) =\n    (if eval i p = Det False then Det True\n     else if eval i p = Det True then Det False else eval i p)", "by (cases \"eval i p\") simp_all"], ["", "corollary \"eval i (Cla p) = eval i (Box (Dis' p (Neg' p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval i (Cla p) = eval i (Dis p (Neg' p))", "using eval_negation"], ["proof (prove)\nusing this:\n  eval ?i (Neg' ?p) =\n  (if eval ?i ?p = Det False then Det True\n   else if eval ?i ?p = Det True then Det False else eval ?i ?p)\n\ngoal (1 subgoal):\n 1. eval i (Cla p) = eval i (Dis p (Neg' p))", "by simp"], ["", "lemma double_negation: \"eval i p = eval i (Neg' (Neg' p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval i p = eval i (Neg' (Neg' p))", "using eval_negation"], ["proof (prove)\nusing this:\n  eval ?i (Neg' ?p) =\n  (if eval ?i ?p = Det False then Det True\n   else if eval ?i ?p = Det True then Det False else eval ?i ?p)\n\ngoal (1 subgoal):\n 1. eval i p = eval i (Neg' (Neg' p))", "by simp"], ["", "subsection \\<open>Validity and Consistency\\<close>"], ["", "text\n\\<open>\nValidity gives the set of theorems and the logic has at least a theorem and a non-theorem.\n\\<close>"], ["", "definition valid :: \"fm \\<Rightarrow> bool\"\nwhere\n  \"valid p \\<equiv> \\<forall>i. eval i p = Det True\""], ["", "proposition \"valid Truth\" and \"\\<not> valid Falsity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid Truth &&& \\<not> valid Falsity", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. eval i Truth = Det True &&&\n    \\<not> (\\<forall>i. eval i Falsity = Det True)", "by simp_all"], ["", "section \\<open>Truth Tables\\<close>"], ["", "subsection \\<open>String Functions\\<close>"], ["", "text\n\\<open>\nThe following functions support arbitrary unary and binary truth tables.\n\\<close>"], ["", "definition tv_pair_row :: \"tv list \\<Rightarrow> tv \\<Rightarrow> (tv * tv) list\"\nwhere\n  \"tv_pair_row tvs tv \\<equiv> map (\\<lambda>x. (tv, x)) tvs\""], ["", "definition tv_pair_table :: \"tv list \\<Rightarrow> (tv * tv) list list\"\nwhere\n  \"tv_pair_table tvs \\<equiv> map (tv_pair_row tvs) tvs\""], ["", "definition map_row :: \"(tv \\<Rightarrow> tv \\<Rightarrow> tv) \\<Rightarrow> (tv * tv) list \\<Rightarrow> tv list\"\nwhere\n  \"map_row f tvtvs \\<equiv> map (\\<lambda>(x, y). f x y) tvtvs\""], ["", "definition map_table :: \"(tv \\<Rightarrow> tv \\<Rightarrow> tv) \\<Rightarrow> (tv * tv) list list \\<Rightarrow> tv list list\"\nwhere\n  \"map_table f tvtvss \\<equiv> map (map_row f) tvtvss\""], ["", "definition unary_truth_table :: \"fm \\<Rightarrow> tv list \\<Rightarrow> tv list\"\nwhere\n  \"unary_truth_table p tvs \\<equiv>\n      map (\\<lambda>x. eval ((\\<lambda>s. undefined)(''p'' := x)) p) tvs\""], ["", "definition binary_truth_table :: \"fm \\<Rightarrow> tv list \\<Rightarrow> tv list list\"\nwhere\n  \"binary_truth_table p tvs \\<equiv>\n      map_table (\\<lambda>x y. eval ((\\<lambda>s. undefined)(''p'' := x, ''q'' := y)) p) (tv_pair_table tvs)\""], ["", "definition digit_of_nat :: \"nat \\<Rightarrow> char\"\nwhere\n  \"digit_of_nat n \\<equiv>\n   (if n = 1 then (CHR ''1'') else if n = 2 then (CHR ''2'') else if n = 3 then (CHR ''3'') else\n    if n = 4 then (CHR ''4'') else if n = 5 then (CHR ''5'') else if n = 6 then (CHR ''6'') else\n    if n = 7 then (CHR ''7'') else if n = 8 then (CHR ''8'') else if n = 9 then (CHR ''9'') else\n      (CHR ''0''))\""], ["", "fun string_of_nat :: \"nat \\<Rightarrow> string\"\nwhere\n  \"string_of_nat n =\n      (if n < 10 then [digit_of_nat n] else string_of_nat (n div 10) @ [digit_of_nat (n mod 10)])\""], ["", "fun string_tv :: \"tv \\<Rightarrow> string\"\nwhere\n  \"string_tv (Det True) = ''*''\" |\n  \"string_tv (Det False) = ''o''\" |\n  \"string_tv (Indet n) = string_of_nat n\""], ["", "definition appends :: \"string list \\<Rightarrow> string\"\nwhere\n  \"appends strs \\<equiv> foldr append strs []\""], ["", "definition appends_nl :: \"string list \\<Rightarrow> string\"\nwhere\n  \"appends_nl strs \\<equiv> ''\\<newline>  '' @ foldr (\\<lambda>s s'. s @ ''\\<newline>  '' @ s') (butlast strs) (last strs) @ ''\\<newline>''\""], ["", "definition string_table :: \"tv list list \\<Rightarrow> string list list\"\nwhere\n  \"string_table tvss \\<equiv> map (map string_tv) tvss\""], ["", "definition string_table_string :: \"string list list \\<Rightarrow> string\"\nwhere\n  \"string_table_string strss \\<equiv> appends_nl (map appends strss)\""], ["", "definition unary :: \"fm \\<Rightarrow> tv list \\<Rightarrow> string\"\nwhere\n  \"unary p tvs \\<equiv> appends_nl (map string_tv (unary_truth_table p tvs))\""], ["", "definition binary :: \"fm \\<Rightarrow> tv list \\<Rightarrow> string\"\nwhere\n  \"binary p tvs \\<equiv> string_table_string (string_table (binary_truth_table p tvs))\""], ["", "subsection \\<open>Main Truth Tables\\<close>"], ["", "text\n\\<open>\nThe omitted Cla (for Classic) is discussed later; Nab (for Nabla) is simply the negation of it.\n\\<close>"], ["", "proposition (* Box Truth Table *)\n  \"unary (Box (Pro ''p'')) [Det True, Det False, Indet 1] = ''\n  *\n  o\n  o\n''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unary (Box (Pro ''p'')) [Det True, Det False, Indet 1] =\n    ''\\<newline>  *\\<newline>  o\\<newline>  o\\<newline>''", "by code_simp"], ["", "proposition (* Con' Truth Table *)\n  \"binary (Con' (Pro ''p'') (Pro ''q'')) [Det True, Det False, Indet 1, Indet 2] = ''\n  *o12\n  oooo\n  1o1o\n  2oo2\n''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binary (Con' (Pro ''p'') (Pro ''q''))\n     [Det True, Det False, Indet 1, Indet 2] =\n    ''\\<newline>  *o12\\<newline>  oooo\\<newline>  1o1o\\<newline>  2oo2\\<newline>''", "by code_simp"], ["", "proposition (* Dis' Truth Table *)\n  \"binary (Dis' (Pro ''p'') (Pro ''q'')) [Det True, Det False, Indet 1, Indet 2] = ''\n  ****\n  *o12\n  *11*\n  *2*2\n''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binary (Dis' (Pro ''p'') (Pro ''q''))\n     [Det True, Det False, Indet 1, Indet 2] =\n    ''\\<newline>  ****\\<newline>  *o12\\<newline>  *11*\\<newline>  *2*2\\<newline>''", "by code_simp"], ["", "proposition (* Neg' Truth Table *)\n  \"unary (Neg' (Pro ''p'')) [Det True, Det False, Indet 1] = ''\n  o\n  *\n  1\n''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unary (Neg' (Pro ''p'')) [Det True, Det False, Indet 1] =\n    ''\\<newline>  o\\<newline>  *\\<newline>  1\\<newline>''", "by code_simp"], ["", "proposition (* Eql' Truth Table *)\n  \"binary (Eql' (Pro ''p'') (Pro ''q'')) [Det True, Det False, Indet 1, Indet 2] = ''\n  *o12\n  o*12\n  11*o\n  22o*\n''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binary (Eql' (Pro ''p'') (Pro ''q''))\n     [Det True, Det False, Indet 1, Indet 2] =\n    ''\\<newline>  *o12\\<newline>  o*12\\<newline>  11*o\\<newline>  22o*\\<newline>''", "by code_simp"], ["", "proposition (* Imp' Truth Table *)\n  \"binary (Imp' (Pro ''p'') (Pro ''q'')) [Det True, Det False, Indet 1, Indet 2] = ''\n  *o12\n  ****\n  *1*1\n  *22*\n''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binary (Imp' (Pro ''p'') (Pro ''q''))\n     [Det True, Det False, Indet 1, Indet 2] =\n    ''\\<newline>  *o12\\<newline>  ****\\<newline>  *1*1\\<newline>  *22*\\<newline>''", "by code_simp"], ["", "proposition (* Neg Truth Table *)\n  \"unary (Neg (Pro ''p'')) [Det True, Det False, Indet 1] = ''\n  o\n  *\n  o\n''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unary (Neg (Pro ''p'')) [Det True, Det False, Indet 1] =\n    ''\\<newline>  o\\<newline>  *\\<newline>  o\\<newline>''", "by code_simp"], ["", "proposition (* Eql Truth Table *)\n  \"binary (Eql (Pro ''p'') (Pro ''q'')) [Det True, Det False, Indet 1, Indet 2] = ''\n  *ooo\n  o*oo\n  oo*o\n  ooo*\n''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binary (Eql (Pro ''p'') (Pro ''q''))\n     [Det True, Det False, Indet 1, Indet 2] =\n    ''\\<newline>  *ooo\\<newline>  o*oo\\<newline>  oo*o\\<newline>  ooo*\\<newline>''", "by code_simp"], ["", "proposition (* Imp Truth Table *)\n  \"binary (Imp (Pro ''p'') (Pro ''q'')) [Det True, Det False, Indet 1, Indet 2] = ''\n  *ooo\n  ****\n  *o*o\n  *oo*\n''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binary (Imp (Pro ''p'') (Pro ''q''))\n     [Det True, Det False, Indet 1, Indet 2] =\n    ''\\<newline>  *ooo\\<newline>  ****\\<newline>  *o*o\\<newline>  *oo*\\<newline>''", "by code_simp"], ["", "proposition (* Nab Truth Table *)\n  \"unary (Nab (Pro ''p'')) [Det True, Det False, Indet 1] = ''\n  o\n  o\n  *\n''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unary (Nab (Pro ''p'')) [Det True, Det False, Indet 1] =\n    ''\\<newline>  o\\<newline>  o\\<newline>  *\\<newline>''", "by code_simp"], ["", "proposition (* Con Truth Table *)\n  \"binary (Con (Pro ''p'') (Pro ''q'')) [Det True, Det False, Indet 1, Indet 2] = ''\n  *ooo\n  oooo\n  oooo\n  oooo\n''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binary (Con (Pro ''p'') (Pro ''q''))\n     [Det True, Det False, Indet 1, Indet 2] =\n    ''\\<newline>  *ooo\\<newline>  oooo\\<newline>  oooo\\<newline>  oooo\\<newline>''", "by code_simp"], ["", "proposition (* Dis Truth Table *)\n  \"binary (Dis (Pro ''p'') (Pro ''q'')) [Det True, Det False, Indet 1, Indet 2] = ''\n  ****\n  *ooo\n  *oo*\n  *o*o\n''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binary (Dis (Pro ''p'') (Pro ''q''))\n     [Det True, Det False, Indet 1, Indet 2] =\n    ''\\<newline>  ****\\<newline>  *ooo\\<newline>  *oo*\\<newline>  *o*o\\<newline>''", "by code_simp"], ["", "section \\<open>Basic Theorems\\<close>"], ["", "subsection \\<open>Selected Theorems and Non-Theorems\\<close>"], ["", "text\n\\<open>\nMany of the following theorems and non-theorems use assumptions and meta-variables.\n\\<close>"], ["", "proposition \"valid (Cla (Box p))\" and \"\\<not> valid (Nab (Box p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Cla (Box p)) &&& \\<not> valid (Nab (Box p))", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. eval i (Cla (Box p)) = Det True &&&\n    \\<not> (\\<forall>i. eval i (Nab (Box p)) = Det True)", "by simp_all"], ["", "proposition \"valid (Cla (Cla p))\" and \"\\<not> valid (Nab (Nab p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Cla (Cla p)) &&& \\<not> valid (Nab (Nab p))", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. eval i (Cla (Cla p)) = Det True &&&\n    \\<not> (\\<forall>i. eval i (Nab (Nab p)) = Det True)", "by simp_all"], ["", "proposition \"valid (Cla (Nab p))\" and \"\\<not> valid (Nab (Cla p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Cla (Nab p)) &&& \\<not> valid (Nab (Cla p))", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. eval i (Cla (Nab p)) = Det True &&&\n    \\<not> (\\<forall>i. eval i (Nab (Cla p)) = Det True)", "by simp_all"], ["", "proposition \"valid (Box p) \\<longleftrightarrow> valid (Box (Box p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Box p) = valid (Box (Box p))", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i. eval i (Box p) = Det True) =\n    (\\<forall>i. eval i (Box (Box p)) = Det True)", "by simp"], ["", "proposition \"valid (Neg p) \\<longleftrightarrow> valid (Neg' p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Neg p) = valid (Neg' p)", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i. eval i (Neg p) = Det True) =\n    (\\<forall>i. eval i (Neg' p) = Det True)", "by simp"], ["", "proposition \"valid (Con p q) \\<longleftrightarrow> valid (Con' p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Con p q) = valid (Con' p q)", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i. eval i (Con p q) = Det True) =\n    (\\<forall>i. eval i (Con' p q) = Det True)", "by simp"], ["", "proposition \"valid (Dis p q) \\<longleftrightarrow> valid (Dis' p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Dis p q) = valid (Dis' p q)", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i. eval i (Dis p q) = Det True) =\n    (\\<forall>i. eval i (Dis' p q) = Det True)", "by simp"], ["", "proposition \"valid (Eql p q) \\<longleftrightarrow> valid (Eql' p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Eql p q) = valid (Eql' p q)", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i. eval i (Eql p q) = Det True) =\n    (\\<forall>i. eval i (Eql' p q) = Det True)", "using eval.simps tv.inject eval_equality eval_negation"], ["proof (prove)\nusing this:\n  eval ?i (Pro ?s) = ?i ?s\n  eval ?i Truth = Det True\n  eval ?i (Neg' ?p) =\n  (case eval ?i ?p of Det True \\<Rightarrow> Det False\n   | Det False \\<Rightarrow> Det True | Indet x \\<Rightarrow> Indet x)\n  eval ?i (Con' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then eval ?i ?p\n   else if eval ?i ?p = Det True then eval ?i ?q\n        else if eval ?i ?q = Det True then eval ?i ?p else Det False)\n  eval ?i (Eql ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True else Det False)\n  eval ?i (Eql' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True\n   else case (eval ?i ?p, eval ?i ?q) of\n        (Det True, xa) \\<Rightarrow> eval ?i ?q\n        | (Det False, Det True) \\<Rightarrow> eval ?i ?p\n        | (Det False, Det False) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Det False, Indet nat) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Det True) \\<Rightarrow> eval ?i ?p\n        | (Indet nat, Det False) \\<Rightarrow>\n            case eval ?i ?p of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Indet nata) \\<Rightarrow> Det False)\n  (Det ?x1.0 = Det ?y1.0) = (?x1.0 = ?y1.0)\n  (Indet ?x2.0 = Indet ?y2.0) = (?x2.0 = ?y2.0)\n  eval ?i (Eql' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True\n   else if eval ?i ?p = Det True then eval ?i ?q\n        else if eval ?i ?q = Det True then eval ?i ?p\n             else if eval ?i ?p = Det False then eval ?i (Neg' ?q)\n                  else if eval ?i ?q = Det False then eval ?i (Neg' ?p)\n                       else Det False)\n  eval ?i (Neg' ?p) =\n  (if eval ?i ?p = Det False then Det True\n   else if eval ?i ?p = Det True then Det False else eval ?i ?p)\n\ngoal (1 subgoal):\n 1. (\\<forall>i. eval i (Eql p q) = Det True) =\n    (\\<forall>i. eval i (Eql' p q) = Det True)", "by (metis (full_types))"], ["", "proposition \"valid (Imp p q) \\<longleftrightarrow> valid (Imp' p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Imp p q) = valid (Imp' p q)", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i. eval i (Imp p q) = Det True) =\n    (\\<forall>i. eval i (Imp' p q) = Det True)", "using eval.simps tv.inject eval_equality eval_negation"], ["proof (prove)\nusing this:\n  eval ?i (Pro ?s) = ?i ?s\n  eval ?i Truth = Det True\n  eval ?i (Neg' ?p) =\n  (case eval ?i ?p of Det True \\<Rightarrow> Det False\n   | Det False \\<Rightarrow> Det True | Indet x \\<Rightarrow> Indet x)\n  eval ?i (Con' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then eval ?i ?p\n   else if eval ?i ?p = Det True then eval ?i ?q\n        else if eval ?i ?q = Det True then eval ?i ?p else Det False)\n  eval ?i (Eql ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True else Det False)\n  eval ?i (Eql' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True\n   else case (eval ?i ?p, eval ?i ?q) of\n        (Det True, xa) \\<Rightarrow> eval ?i ?q\n        | (Det False, Det True) \\<Rightarrow> eval ?i ?p\n        | (Det False, Det False) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Det False, Indet nat) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Det True) \\<Rightarrow> eval ?i ?p\n        | (Indet nat, Det False) \\<Rightarrow>\n            case eval ?i ?p of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Indet nata) \\<Rightarrow> Det False)\n  (Det ?x1.0 = Det ?y1.0) = (?x1.0 = ?y1.0)\n  (Indet ?x2.0 = Indet ?y2.0) = (?x2.0 = ?y2.0)\n  eval ?i (Eql' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True\n   else if eval ?i ?p = Det True then eval ?i ?q\n        else if eval ?i ?q = Det True then eval ?i ?p\n             else if eval ?i ?p = Det False then eval ?i (Neg' ?q)\n                  else if eval ?i ?q = Det False then eval ?i (Neg' ?p)\n                       else Det False)\n  eval ?i (Neg' ?p) =\n  (if eval ?i ?p = Det False then Det True\n   else if eval ?i ?p = Det True then Det False else eval ?i ?p)\n\ngoal (1 subgoal):\n 1. (\\<forall>i. eval i (Imp p q) = Det True) =\n    (\\<forall>i. eval i (Imp' p q) = Det True)", "by (metis (full_types))"], ["", "proposition \"\\<not> valid (Pro ''p'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valid (Pro ''p'')", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. eval i (Pro ''p'') = Det True)", "by auto"], ["", "proposition \"\\<not> valid (Neg' (Pro ''p''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valid (Neg' (Pro ''p''))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> valid (Neg' (Pro ''p''))", "have \"eval (\\<lambda>s. Det True) (Neg' (Pro ''p'')) = Det False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (\\<lambda>s. Det True) (Neg' (Pro ''p'')) = Det False", "by simp"], ["proof (state)\nthis:\n  eval (\\<lambda>s. Det True) (Neg' (Pro ''p'')) = Det False\n\ngoal (1 subgoal):\n 1. \\<not> valid (Neg' (Pro ''p''))", "then"], ["proof (chain)\npicking this:\n  eval (\\<lambda>s. Det True) (Neg' (Pro ''p'')) = Det False", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (\\<lambda>s. Det True) (Neg' (Pro ''p'')) = Det False\n\ngoal (1 subgoal):\n 1. \\<not> valid (Neg' (Pro ''p''))", "unfolding valid_def"], ["proof (prove)\nusing this:\n  eval (\\<lambda>s. Det True) (Neg' (Pro ''p'')) = Det False\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. eval i (Neg' (Pro ''p'')) = Det True)", "using tv.inject"], ["proof (prove)\nusing this:\n  eval (\\<lambda>s. Det True) (Neg' (Pro ''p'')) = Det False\n  (Det ?x1.0 = Det ?y1.0) = (?x1.0 = ?y1.0)\n  (Indet ?x2.0 = Indet ?y2.0) = (?x2.0 = ?y2.0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. eval i (Neg' (Pro ''p'')) = Det True)", "by metis"], ["proof (state)\nthis:\n  \\<not> valid (Neg' (Pro ''p''))\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition assumes \"valid p\" shows \"\\<not> valid (Neg' p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valid (Neg' p)", "using assms"], ["proof (prove)\nusing this:\n  valid p\n\ngoal (1 subgoal):\n 1. \\<not> valid (Neg' p)", "unfolding valid_def"], ["proof (prove)\nusing this:\n  \\<forall>i. eval i p = Det True\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. eval i (Neg' p) = Det True)", "by simp"], ["", "proposition assumes \"valid (Neg' p)\" shows \"\\<not> valid p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valid p", "using assms"], ["proof (prove)\nusing this:\n  valid (Neg' p)\n\ngoal (1 subgoal):\n 1. \\<not> valid p", "unfolding valid_def"], ["proof (prove)\nusing this:\n  \\<forall>i. eval i (Neg' p) = Det True\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. eval i p = Det True)", "by force"], ["", "proposition \"valid (Neg' (Neg' p)) \\<longleftrightarrow> valid p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Neg' (Neg' p)) = valid p", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i. eval i (Neg' (Neg' p)) = Det True) =\n    (\\<forall>i. eval i p = Det True)", "using double_negation"], ["proof (prove)\nusing this:\n  eval ?i ?p = eval ?i (Neg' (Neg' ?p))\n\ngoal (1 subgoal):\n 1. (\\<forall>i. eval i (Neg' (Neg' p)) = Det True) =\n    (\\<forall>i. eval i p = Det True)", "by simp"], ["", "theorem conjunction: \"valid (Con' p q) \\<longleftrightarrow> valid p \\<and> valid q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Con' p q) = (valid p \\<and> valid q)", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i. eval i (Con' p q) = Det True) =\n    ((\\<forall>i. eval i p = Det True) \\<and>\n     (\\<forall>i. eval i q = Det True))", "by auto"], ["", "corollary assumes \"valid (Con' p q)\" shows \"valid p\" and \"valid q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid p &&& valid q", "using assms conjunction"], ["proof (prove)\nusing this:\n  valid (Con' p q)\n  valid (Con' ?p ?q) = (valid ?p \\<and> valid ?q)\n\ngoal (1 subgoal):\n 1. valid p &&& valid q", "by simp_all"], ["", "proposition assumes \"valid p\" and \"valid (Imp p q)\" shows \"valid q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid q", "using assms eval.simps tv.inject"], ["proof (prove)\nusing this:\n  valid p\n  valid (Imp p q)\n  eval ?i (Pro ?s) = ?i ?s\n  eval ?i Truth = Det True\n  eval ?i (Neg' ?p) =\n  (case eval ?i ?p of Det True \\<Rightarrow> Det False\n   | Det False \\<Rightarrow> Det True | Indet x \\<Rightarrow> Indet x)\n  eval ?i (Con' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then eval ?i ?p\n   else if eval ?i ?p = Det True then eval ?i ?q\n        else if eval ?i ?q = Det True then eval ?i ?p else Det False)\n  eval ?i (Eql ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True else Det False)\n  eval ?i (Eql' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True\n   else case (eval ?i ?p, eval ?i ?q) of\n        (Det True, xa) \\<Rightarrow> eval ?i ?q\n        | (Det False, Det True) \\<Rightarrow> eval ?i ?p\n        | (Det False, Det False) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Det False, Indet nat) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Det True) \\<Rightarrow> eval ?i ?p\n        | (Indet nat, Det False) \\<Rightarrow>\n            case eval ?i ?p of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Indet nata) \\<Rightarrow> Det False)\n  (Det ?x1.0 = Det ?y1.0) = (?x1.0 = ?y1.0)\n  (Indet ?x2.0 = Indet ?y2.0) = (?x2.0 = ?y2.0)\n\ngoal (1 subgoal):\n 1. valid q", "unfolding valid_def"], ["proof (prove)\nusing this:\n  \\<forall>i. eval i p = Det True\n  \\<forall>i. eval i (Imp p q) = Det True\n  eval ?i (Pro ?s) = ?i ?s\n  eval ?i Truth = Det True\n  eval ?i (Neg' ?p) =\n  (case eval ?i ?p of Det True \\<Rightarrow> Det False\n   | Det False \\<Rightarrow> Det True | Indet x \\<Rightarrow> Indet x)\n  eval ?i (Con' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then eval ?i ?p\n   else if eval ?i ?p = Det True then eval ?i ?q\n        else if eval ?i ?q = Det True then eval ?i ?p else Det False)\n  eval ?i (Eql ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True else Det False)\n  eval ?i (Eql' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True\n   else case (eval ?i ?p, eval ?i ?q) of\n        (Det True, xa) \\<Rightarrow> eval ?i ?q\n        | (Det False, Det True) \\<Rightarrow> eval ?i ?p\n        | (Det False, Det False) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Det False, Indet nat) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Det True) \\<Rightarrow> eval ?i ?p\n        | (Indet nat, Det False) \\<Rightarrow>\n            case eval ?i ?p of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Indet nata) \\<Rightarrow> Det False)\n  (Det ?x1.0 = Det ?y1.0) = (?x1.0 = ?y1.0)\n  (Indet ?x2.0 = Indet ?y2.0) = (?x2.0 = ?y2.0)\n\ngoal (1 subgoal):\n 1. \\<forall>i. eval i q = Det True", "by (metis (full_types))"], ["", "proposition assumes \"valid p\" and \"valid (Imp' p q)\" shows \"valid q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid q", "using assms eval.simps tv.inject eval_equality"], ["proof (prove)\nusing this:\n  valid p\n  valid (Imp' p q)\n  eval ?i (Pro ?s) = ?i ?s\n  eval ?i Truth = Det True\n  eval ?i (Neg' ?p) =\n  (case eval ?i ?p of Det True \\<Rightarrow> Det False\n   | Det False \\<Rightarrow> Det True | Indet x \\<Rightarrow> Indet x)\n  eval ?i (Con' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then eval ?i ?p\n   else if eval ?i ?p = Det True then eval ?i ?q\n        else if eval ?i ?q = Det True then eval ?i ?p else Det False)\n  eval ?i (Eql ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True else Det False)\n  eval ?i (Eql' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True\n   else case (eval ?i ?p, eval ?i ?q) of\n        (Det True, xa) \\<Rightarrow> eval ?i ?q\n        | (Det False, Det True) \\<Rightarrow> eval ?i ?p\n        | (Det False, Det False) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Det False, Indet nat) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Det True) \\<Rightarrow> eval ?i ?p\n        | (Indet nat, Det False) \\<Rightarrow>\n            case eval ?i ?p of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Indet nata) \\<Rightarrow> Det False)\n  (Det ?x1.0 = Det ?y1.0) = (?x1.0 = ?y1.0)\n  (Indet ?x2.0 = Indet ?y2.0) = (?x2.0 = ?y2.0)\n  eval ?i (Eql' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True\n   else if eval ?i ?p = Det True then eval ?i ?q\n        else if eval ?i ?q = Det True then eval ?i ?p\n             else if eval ?i ?p = Det False then eval ?i (Neg' ?q)\n                  else if eval ?i ?q = Det False then eval ?i (Neg' ?p)\n                       else Det False)\n\ngoal (1 subgoal):\n 1. valid q", "unfolding valid_def"], ["proof (prove)\nusing this:\n  \\<forall>i. eval i p = Det True\n  \\<forall>i. eval i (Imp' p q) = Det True\n  eval ?i (Pro ?s) = ?i ?s\n  eval ?i Truth = Det True\n  eval ?i (Neg' ?p) =\n  (case eval ?i ?p of Det True \\<Rightarrow> Det False\n   | Det False \\<Rightarrow> Det True | Indet x \\<Rightarrow> Indet x)\n  eval ?i (Con' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then eval ?i ?p\n   else if eval ?i ?p = Det True then eval ?i ?q\n        else if eval ?i ?q = Det True then eval ?i ?p else Det False)\n  eval ?i (Eql ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True else Det False)\n  eval ?i (Eql' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True\n   else case (eval ?i ?p, eval ?i ?q) of\n        (Det True, xa) \\<Rightarrow> eval ?i ?q\n        | (Det False, Det True) \\<Rightarrow> eval ?i ?p\n        | (Det False, Det False) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Det False, Indet nat) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Det True) \\<Rightarrow> eval ?i ?p\n        | (Indet nat, Det False) \\<Rightarrow>\n            case eval ?i ?p of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Indet nata) \\<Rightarrow> Det False)\n  (Det ?x1.0 = Det ?y1.0) = (?x1.0 = ?y1.0)\n  (Indet ?x2.0 = Indet ?y2.0) = (?x2.0 = ?y2.0)\n  eval ?i (Eql' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True\n   else if eval ?i ?p = Det True then eval ?i ?q\n        else if eval ?i ?q = Det True then eval ?i ?p\n             else if eval ?i ?p = Det False then eval ?i (Neg' ?q)\n                  else if eval ?i ?q = Det False then eval ?i (Neg' ?p)\n                       else Det False)\n\ngoal (1 subgoal):\n 1. \\<forall>i. eval i q = Det True", "by (metis (full_types))"], ["", "subsection \\<open>Key Equalities\\<close>"], ["", "text\n\\<open>\nThe key equalities are part of the motivation for the semantic clauses.\n\\<close>"], ["", "proposition \"valid (Eql p (Neg' (Neg' p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Eql p (Neg' (Neg' p)))", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. eval i (Eql p (Neg' (Neg' p))) = Det True", "using double_negation"], ["proof (prove)\nusing this:\n  eval ?i ?p = eval ?i (Neg' (Neg' ?p))\n\ngoal (1 subgoal):\n 1. \\<forall>i. eval i (Eql p (Neg' (Neg' p))) = Det True", "by simp"], ["", "proposition \"valid (Eql Truth (Neg' Falsity))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Eql Truth (Neg' Falsity))", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. eval i (Eql Truth (Neg' Falsity)) = Det True", "by simp"], ["", "proposition \"valid (Eql Falsity (Neg' Truth))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Eql Falsity Falsity)", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. eval i (Eql Falsity Falsity) = Det True", "by simp"], ["", "proposition \"valid (Eql p (Con' p p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Imp p p)", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. eval i (Imp p p) = Det True", "by simp"], ["", "proposition \"valid (Eql p (Con' Truth p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Eql p (Con' Truth p))", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. eval i (Eql p (Con' Truth p)) = Det True", "by simp"], ["", "proposition \"valid (Eql p (Con' p Truth))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Imp p Truth)", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. eval i (Imp p Truth) = Det True", "by simp"], ["", "proposition \"valid (Eql Truth (Eql' p p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Eql Truth (Eql' p p))", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. eval i (Eql Truth (Eql' p p)) = Det True", "by simp"], ["", "proposition \"valid (Eql p (Eql' Truth p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Eql p (Eql' Truth p))", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. eval i (Eql p (Eql' Truth p)) = Det True", "by simp"], ["", "proposition \"valid (Eql p (Eql' p Truth))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Eql p (Eql' p Truth))", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. eval i (Eql p (Eql' p Truth)) = Det True", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. eval i (Eql p (Eql' p Truth)) = Det True", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. eval i (Eql p (Eql' p Truth)) = Det True", "show \"eval i (Eql p (Eql' p Truth)) = Det True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval i (Eql p (Eql' p Truth)) = Det True", "by (cases \"eval i p\") simp_all"], ["proof (state)\nthis:\n  eval i (Eql p (Eql' p Truth)) = Det True\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition \"valid (Eql (Neg' p) (Eql' Falsity p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Eql (Neg' p) (Eql' Falsity p))", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. eval i (Eql (Neg' p) (Eql' Falsity p)) = Det True", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. eval i (Eql (Neg' p) (Eql' Falsity p)) = Det True", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. eval i (Eql (Neg' p) (Eql' Falsity p)) = Det True", "show \"eval i (Eql (Neg' p) (Eql' (Neg' Truth) p)) = Det True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval i (Eql (Neg' p) (Eql' Falsity p)) = Det True", "by (cases \"eval i p\") simp_all"], ["proof (state)\nthis:\n  eval i (Eql (Neg' p) (Eql' Falsity p)) = Det True\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition \"valid (Eql (Neg' p) (Eql' p Falsity))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (Eql (Neg' p) (Eql' p Falsity))", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. eval i (Eql (Neg' p) (Eql' p Falsity)) = Det True", "using eval.simps eval_equality eval_negation"], ["proof (prove)\nusing this:\n  eval ?i (Pro ?s) = ?i ?s\n  eval ?i Truth = Det True\n  eval ?i (Neg' ?p) =\n  (case eval ?i ?p of Det True \\<Rightarrow> Det False\n   | Det False \\<Rightarrow> Det True | Indet x \\<Rightarrow> Indet x)\n  eval ?i (Con' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then eval ?i ?p\n   else if eval ?i ?p = Det True then eval ?i ?q\n        else if eval ?i ?q = Det True then eval ?i ?p else Det False)\n  eval ?i (Eql ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True else Det False)\n  eval ?i (Eql' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True\n   else case (eval ?i ?p, eval ?i ?q) of\n        (Det True, xa) \\<Rightarrow> eval ?i ?q\n        | (Det False, Det True) \\<Rightarrow> eval ?i ?p\n        | (Det False, Det False) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Det False, Indet nat) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Det True) \\<Rightarrow> eval ?i ?p\n        | (Indet nat, Det False) \\<Rightarrow>\n            case eval ?i ?p of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Indet nata) \\<Rightarrow> Det False)\n  eval ?i (Eql' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True\n   else if eval ?i ?p = Det True then eval ?i ?q\n        else if eval ?i ?q = Det True then eval ?i ?p\n             else if eval ?i ?p = Det False then eval ?i (Neg' ?q)\n                  else if eval ?i ?q = Det False then eval ?i (Neg' ?p)\n                       else Det False)\n  eval ?i (Neg' ?p) =\n  (if eval ?i ?p = Det False then Det True\n   else if eval ?i ?p = Det True then Det False else eval ?i ?p)\n\ngoal (1 subgoal):\n 1. \\<forall>i. eval i (Eql (Neg' p) (Eql' p Falsity)) = Det True", "by metis"], ["", "section \\<open>Further Non-Theorems\\<close>"], ["", "subsection \\<open>Smaller Domains and Paraconsistency\\<close>"], ["", "text\n\\<open>\nValidity is relativized to a set of indeterminate truth values (called a domain).\n\\<close>"], ["", "definition domain :: \"nat set \\<Rightarrow> tv set\"\nwhere\n  \"domain U \\<equiv> {Det True, Det False} \\<union> Indet ` U\""], ["", "theorem universal_domain: \"domain {n. True} = {x. True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domain {n. True} = {x. True}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. domain {n. True} = {x. True}", "have \"\\<forall>x. x = Det True \\<or> x = Det False \\<or> x \\<in> range Indet\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. x = Det True \\<or> x = Det False \\<or> x \\<in> range Indet", "using range_eqI tv.exhaust tv.inject"], ["proof (prove)\nusing this:\n  ?b = ?f ?x \\<Longrightarrow> ?b \\<in> range ?f\n  \\<lbrakk>\\<And>x1. ?y = Det x1 \\<Longrightarrow> ?P;\n   \\<And>x2. ?y = Indet x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  (Det ?x1.0 = Det ?y1.0) = (?x1.0 = ?y1.0)\n  (Indet ?x2.0 = Indet ?y2.0) = (?x2.0 = ?y2.0)\n\ngoal (1 subgoal):\n 1. \\<forall>x. x = Det True \\<or> x = Det False \\<or> x \\<in> range Indet", "by metis"], ["proof (state)\nthis:\n  \\<forall>x. x = Det True \\<or> x = Det False \\<or> x \\<in> range Indet\n\ngoal (1 subgoal):\n 1. domain {n. True} = {x. True}", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. x = Det True \\<or> x = Det False \\<or> x \\<in> range Indet", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x. x = Det True \\<or> x = Det False \\<or> x \\<in> range Indet\n\ngoal (1 subgoal):\n 1. domain {n. True} = {x. True}", "unfolding domain_def"], ["proof (prove)\nusing this:\n  \\<forall>x. x = Det True \\<or> x = Det False \\<or> x \\<in> range Indet\n\ngoal (1 subgoal):\n 1. {Det True, Det False} \\<union> Indet ` {n. True} = {x. True}", "by blast"], ["proof (state)\nthis:\n  domain {n. True} = {x. True}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition valid_in :: \"nat set \\<Rightarrow> fm \\<Rightarrow> bool\"\nwhere\n  \"valid_in U p \\<equiv> \\<forall>i. range i \\<subseteq> domain U \\<longrightarrow> eval i p = Det True\""], ["", "abbreviation valid_boole :: \"fm \\<Rightarrow> bool\" where \"valid_boole p \\<equiv> valid_in {} p\""], ["", "proposition \"valid p \\<longleftrightarrow> valid_in {n. True} p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid p = valid_in {n. True} p", "unfolding valid_def valid_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i. eval i p = Det True) =\n    (\\<forall>i.\n        range i \\<subseteq> domain {n. True} \\<longrightarrow>\n        eval i p = Det True)", "using universal_domain"], ["proof (prove)\nusing this:\n  domain {n. True} = {x. True}\n\ngoal (1 subgoal):\n 1. (\\<forall>i. eval i p = Det True) =\n    (\\<forall>i.\n        range i \\<subseteq> domain {n. True} \\<longrightarrow>\n        eval i p = Det True)", "by simp"], ["", "theorem valid_valid_in: assumes \"valid p\" shows \"valid_in U p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_in U p", "using assms"], ["proof (prove)\nusing this:\n  valid p\n\ngoal (1 subgoal):\n 1. valid_in U p", "unfolding valid_in_def valid_def"], ["proof (prove)\nusing this:\n  \\<forall>i. eval i p = Det True\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       range i \\<subseteq> domain U \\<longrightarrow> eval i p = Det True", "by simp"], ["", "theorem transfer: assumes \"\\<not> valid_in U p\" shows \"\\<not> valid p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valid p", "using assms valid_valid_in"], ["proof (prove)\nusing this:\n  \\<not> valid_in U p\n  valid ?p \\<Longrightarrow> valid_in ?U ?p\n\ngoal (1 subgoal):\n 1. \\<not> valid p", "by blast"], ["", "proposition \"valid_in U (Neg' (Neg' p)) \\<longleftrightarrow> valid_in U p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_in U (Neg' (Neg' p)) = valid_in U p", "unfolding valid_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i.\n        range i \\<subseteq> domain U \\<longrightarrow>\n        eval i (Neg' (Neg' p)) = Det True) =\n    (\\<forall>i.\n        range i \\<subseteq> domain U \\<longrightarrow> eval i p = Det True)", "using double_negation"], ["proof (prove)\nusing this:\n  eval ?i ?p = eval ?i (Neg' (Neg' ?p))\n\ngoal (1 subgoal):\n 1. (\\<forall>i.\n        range i \\<subseteq> domain U \\<longrightarrow>\n        eval i (Neg' (Neg' p)) = Det True) =\n    (\\<forall>i.\n        range i \\<subseteq> domain U \\<longrightarrow> eval i p = Det True)", "by simp"], ["", "theorem conjunction_in: \"valid_in U (Con' p q) \\<longleftrightarrow> valid_in U p \\<and> valid_in U q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_in U (Con' p q) = (valid_in U p \\<and> valid_in U q)", "unfolding valid_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i.\n        range i \\<subseteq> domain U \\<longrightarrow>\n        eval i (Con' p q) = Det True) =\n    ((\\<forall>i.\n         range i \\<subseteq> domain U \\<longrightarrow>\n         eval i p = Det True) \\<and>\n     (\\<forall>i.\n         range i \\<subseteq> domain U \\<longrightarrow>\n         eval i q = Det True))", "by auto"], ["", "corollary assumes \"valid_in U (Con' p q)\" shows \"valid_in U p\" and \"valid_in U q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_in U p &&& valid_in U q", "using assms conjunction_in"], ["proof (prove)\nusing this:\n  valid_in U (Con' p q)\n  valid_in ?U (Con' ?p ?q) = (valid_in ?U ?p \\<and> valid_in ?U ?q)\n\ngoal (1 subgoal):\n 1. valid_in U p &&& valid_in U q", "by simp_all"], ["", "proposition assumes \"valid_in U p\" and \"valid_in U (Imp p q)\" shows \"valid_in U q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_in U q", "using assms eval.simps tv.inject"], ["proof (prove)\nusing this:\n  valid_in U p\n  valid_in U (Imp p q)\n  eval ?i (Pro ?s) = ?i ?s\n  eval ?i Truth = Det True\n  eval ?i (Neg' ?p) =\n  (case eval ?i ?p of Det True \\<Rightarrow> Det False\n   | Det False \\<Rightarrow> Det True | Indet x \\<Rightarrow> Indet x)\n  eval ?i (Con' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then eval ?i ?p\n   else if eval ?i ?p = Det True then eval ?i ?q\n        else if eval ?i ?q = Det True then eval ?i ?p else Det False)\n  eval ?i (Eql ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True else Det False)\n  eval ?i (Eql' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True\n   else case (eval ?i ?p, eval ?i ?q) of\n        (Det True, xa) \\<Rightarrow> eval ?i ?q\n        | (Det False, Det True) \\<Rightarrow> eval ?i ?p\n        | (Det False, Det False) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Det False, Indet nat) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Det True) \\<Rightarrow> eval ?i ?p\n        | (Indet nat, Det False) \\<Rightarrow>\n            case eval ?i ?p of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Indet nata) \\<Rightarrow> Det False)\n  (Det ?x1.0 = Det ?y1.0) = (?x1.0 = ?y1.0)\n  (Indet ?x2.0 = Indet ?y2.0) = (?x2.0 = ?y2.0)\n\ngoal (1 subgoal):\n 1. valid_in U q", "unfolding valid_in_def"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     range i \\<subseteq> domain U \\<longrightarrow> eval i p = Det True\n  \\<forall>i.\n     range i \\<subseteq> domain U \\<longrightarrow>\n     eval i (Imp p q) = Det True\n  eval ?i (Pro ?s) = ?i ?s\n  eval ?i Truth = Det True\n  eval ?i (Neg' ?p) =\n  (case eval ?i ?p of Det True \\<Rightarrow> Det False\n   | Det False \\<Rightarrow> Det True | Indet x \\<Rightarrow> Indet x)\n  eval ?i (Con' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then eval ?i ?p\n   else if eval ?i ?p = Det True then eval ?i ?q\n        else if eval ?i ?q = Det True then eval ?i ?p else Det False)\n  eval ?i (Eql ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True else Det False)\n  eval ?i (Eql' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True\n   else case (eval ?i ?p, eval ?i ?q) of\n        (Det True, xa) \\<Rightarrow> eval ?i ?q\n        | (Det False, Det True) \\<Rightarrow> eval ?i ?p\n        | (Det False, Det False) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Det False, Indet nat) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Det True) \\<Rightarrow> eval ?i ?p\n        | (Indet nat, Det False) \\<Rightarrow>\n            case eval ?i ?p of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Indet nata) \\<Rightarrow> Det False)\n  (Det ?x1.0 = Det ?y1.0) = (?x1.0 = ?y1.0)\n  (Indet ?x2.0 = Indet ?y2.0) = (?x2.0 = ?y2.0)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       range i \\<subseteq> domain U \\<longrightarrow> eval i q = Det True", "by (metis (full_types))"], ["", "proposition assumes \"valid_in U p\" and \"valid_in U (Imp' p q)\" shows \"valid_in U q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_in U q", "using assms eval.simps tv.inject eval_equality"], ["proof (prove)\nusing this:\n  valid_in U p\n  valid_in U (Imp' p q)\n  eval ?i (Pro ?s) = ?i ?s\n  eval ?i Truth = Det True\n  eval ?i (Neg' ?p) =\n  (case eval ?i ?p of Det True \\<Rightarrow> Det False\n   | Det False \\<Rightarrow> Det True | Indet x \\<Rightarrow> Indet x)\n  eval ?i (Con' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then eval ?i ?p\n   else if eval ?i ?p = Det True then eval ?i ?q\n        else if eval ?i ?q = Det True then eval ?i ?p else Det False)\n  eval ?i (Eql ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True else Det False)\n  eval ?i (Eql' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True\n   else case (eval ?i ?p, eval ?i ?q) of\n        (Det True, xa) \\<Rightarrow> eval ?i ?q\n        | (Det False, Det True) \\<Rightarrow> eval ?i ?p\n        | (Det False, Det False) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Det False, Indet nat) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Det True) \\<Rightarrow> eval ?i ?p\n        | (Indet nat, Det False) \\<Rightarrow>\n            case eval ?i ?p of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Indet nata) \\<Rightarrow> Det False)\n  (Det ?x1.0 = Det ?y1.0) = (?x1.0 = ?y1.0)\n  (Indet ?x2.0 = Indet ?y2.0) = (?x2.0 = ?y2.0)\n  eval ?i (Eql' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True\n   else if eval ?i ?p = Det True then eval ?i ?q\n        else if eval ?i ?q = Det True then eval ?i ?p\n             else if eval ?i ?p = Det False then eval ?i (Neg' ?q)\n                  else if eval ?i ?q = Det False then eval ?i (Neg' ?p)\n                       else Det False)\n\ngoal (1 subgoal):\n 1. valid_in U q", "unfolding valid_in_def"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     range i \\<subseteq> domain U \\<longrightarrow> eval i p = Det True\n  \\<forall>i.\n     range i \\<subseteq> domain U \\<longrightarrow>\n     eval i (Imp' p q) = Det True\n  eval ?i (Pro ?s) = ?i ?s\n  eval ?i Truth = Det True\n  eval ?i (Neg' ?p) =\n  (case eval ?i ?p of Det True \\<Rightarrow> Det False\n   | Det False \\<Rightarrow> Det True | Indet x \\<Rightarrow> Indet x)\n  eval ?i (Con' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then eval ?i ?p\n   else if eval ?i ?p = Det True then eval ?i ?q\n        else if eval ?i ?q = Det True then eval ?i ?p else Det False)\n  eval ?i (Eql ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True else Det False)\n  eval ?i (Eql' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True\n   else case (eval ?i ?p, eval ?i ?q) of\n        (Det True, xa) \\<Rightarrow> eval ?i ?q\n        | (Det False, Det True) \\<Rightarrow> eval ?i ?p\n        | (Det False, Det False) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Det False, Indet nat) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Det True) \\<Rightarrow> eval ?i ?p\n        | (Indet nat, Det False) \\<Rightarrow>\n            case eval ?i ?p of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Indet nata) \\<Rightarrow> Det False)\n  (Det ?x1.0 = Det ?y1.0) = (?x1.0 = ?y1.0)\n  (Indet ?x2.0 = Indet ?y2.0) = (?x2.0 = ?y2.0)\n  eval ?i (Eql' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True\n   else if eval ?i ?p = Det True then eval ?i ?q\n        else if eval ?i ?q = Det True then eval ?i ?p\n             else if eval ?i ?p = Det False then eval ?i (Neg' ?q)\n                  else if eval ?i ?q = Det False then eval ?i (Neg' ?p)\n                       else Det False)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       range i \\<subseteq> domain U \\<longrightarrow> eval i q = Det True", "by (metis (full_types))"], ["", "abbreviation (input) Explosion :: \"fm \\<Rightarrow> fm \\<Rightarrow> fm\"\nwhere\n  \"Explosion p q \\<equiv> Imp' (Con' p (Neg' p)) q\""], ["", "proposition \"valid_boole (Explosion (Pro ''p'') (Pro ''q''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_boole (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))", "unfolding valid_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       range i \\<subseteq> domain {} \\<longrightarrow>\n       eval i (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q'')) =\n       Det True", "proof (rule; rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q'')) =\n       Det True", "fix i :: \"id \\<Rightarrow> tv\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q'')) =\n       Det True", "assume \"range i \\<subseteq> domain {}\""], ["proof (state)\nthis:\n  range i \\<subseteq> domain {}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q'')) =\n       Det True", "then"], ["proof (chain)\npicking this:\n  range i \\<subseteq> domain {}", "have\n      \"i ''p'' \\<in> {Det True, Det False}\"\n      \"i ''q'' \\<in> {Det True, Det False}\""], ["proof (prove)\nusing this:\n  range i \\<subseteq> domain {}\n\ngoal (1 subgoal):\n 1. i ''p'' \\<in> {Det True, Det False} &&&\n    i ''q'' \\<in> {Det True, Det False}", "unfolding domain_def"], ["proof (prove)\nusing this:\n  range i \\<subseteq> {Det True, Det False} \\<union> Indet ` {}\n\ngoal (1 subgoal):\n 1. i ''p'' \\<in> {Det True, Det False} &&&\n    i ''q'' \\<in> {Det True, Det False}", "by auto"], ["proof (state)\nthis:\n  i ''p'' \\<in> {Det True, Det False}\n  i ''q'' \\<in> {Det True, Det False}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q'')) =\n       Det True", "then"], ["proof (chain)\npicking this:\n  i ''p'' \\<in> {Det True, Det False}\n  i ''q'' \\<in> {Det True, Det False}", "show \"eval i (Explosion (Pro ''p'') (Pro ''q'')) = Det True\""], ["proof (prove)\nusing this:\n  i ''p'' \\<in> {Det True, Det False}\n  i ''q'' \\<in> {Det True, Det False}\n\ngoal (1 subgoal):\n 1. eval i (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q'')) =\n    Det True", "by (cases \"i ''p''\"; cases \"i ''q''\") simp_all"], ["proof (state)\nthis:\n  eval i (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q'')) = Det True\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma explosion_counterexample: \"\\<not> valid_in {1} (Explosion (Pro ''p'') (Pro ''q''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valid_in {1}\n            (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> valid_in {1}\n            (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))", "let ?i = \"(\\<lambda>s. Indet 1)(''q'' := Det False)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> valid_in {1}\n            (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))", "have \"range ?i \\<subseteq> domain {1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range ((\\<lambda>s. Indet 1)(''q'' := Det False)) \\<subseteq> domain {1}", "unfolding domain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. range ((\\<lambda>s. Indet 1)(''q'' := Det False))\n    \\<subseteq> {Det True, Det False} \\<union> Indet ` {1}", "by (simp add: image_subset_iff)"], ["proof (state)\nthis:\n  range ((\\<lambda>s. Indet 1)(''q'' := Det False)) \\<subseteq> domain {1}\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1}\n            (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))", "moreover"], ["proof (state)\nthis:\n  range ((\\<lambda>s. Indet 1)(''q'' := Det False)) \\<subseteq> domain {1}\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1}\n            (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))", "have \"eval ?i (Explosion (Pro ''p'') (Pro ''q'')) = Indet 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval ((\\<lambda>s. Indet 1)(''q'' := Det False))\n     (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q'')) =\n    Indet 1", "by simp"], ["proof (state)\nthis:\n  eval ((\\<lambda>s. Indet 1)(''q'' := Det False))\n   (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q'')) =\n  Indet 1\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1}\n            (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))", "moreover"], ["proof (state)\nthis:\n  eval ((\\<lambda>s. Indet 1)(''q'' := Det False))\n   (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q'')) =\n  Indet 1\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1}\n            (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))", "have \"Indet 1 \\<noteq> Det True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Indet 1 \\<noteq> Det True", "by simp"], ["proof (state)\nthis:\n  Indet 1 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1}\n            (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))", "ultimately"], ["proof (chain)\npicking this:\n  range ((\\<lambda>s. Indet 1)(''q'' := Det False)) \\<subseteq> domain {1}\n  eval ((\\<lambda>s. Indet 1)(''q'' := Det False))\n   (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q'')) =\n  Indet 1\n  Indet 1 \\<noteq> Det True", "show ?thesis"], ["proof (prove)\nusing this:\n  range ((\\<lambda>s. Indet 1)(''q'' := Det False)) \\<subseteq> domain {1}\n  eval ((\\<lambda>s. Indet 1)(''q'' := Det False))\n   (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q'')) =\n  Indet 1\n  Indet 1 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1}\n            (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))", "unfolding valid_in_def"], ["proof (prove)\nusing this:\n  range ((\\<lambda>s. Indet 1)(''q'' := Det False)) \\<subseteq> domain {1}\n  eval ((\\<lambda>s. Indet 1)(''q'' := Det False))\n   (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q'')) =\n  Indet 1\n  Indet 1 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i.\n               range i \\<subseteq> domain {1} \\<longrightarrow>\n               eval i\n                (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q'')) =\n               Det True)", "by metis"], ["proof (state)\nthis:\n  \\<not> valid_in {1}\n          (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem explosion_not_valid: \"\\<not> valid (Explosion (Pro ''p'') (Pro ''q''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valid (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))", "using explosion_counterexample transfer"], ["proof (prove)\nusing this:\n  \\<not> valid_in {1}\n          (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))\n  \\<not> valid_in ?U ?p \\<Longrightarrow> \\<not> valid ?p\n\ngoal (1 subgoal):\n 1. \\<not> valid (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))", "by simp"], ["", "proposition \"\\<not> valid (Imp (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valid (Imp (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))", "using explosion_counterexample transfer eval.simps tv.simps"], ["proof (prove)\nusing this:\n  \\<not> valid_in {1}\n          (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))\n  \\<not> valid_in ?U ?p \\<Longrightarrow> \\<not> valid ?p\n  eval ?i (Pro ?s) = ?i ?s\n  eval ?i Truth = Det True\n  eval ?i (Neg' ?p) =\n  (case eval ?i ?p of Det True \\<Rightarrow> Det False\n   | Det False \\<Rightarrow> Det True | Indet x \\<Rightarrow> Indet x)\n  eval ?i (Con' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then eval ?i ?p\n   else if eval ?i ?p = Det True then eval ?i ?q\n        else if eval ?i ?q = Det True then eval ?i ?p else Det False)\n  eval ?i (Eql ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True else Det False)\n  eval ?i (Eql' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True\n   else case (eval ?i ?p, eval ?i ?q) of\n        (Det True, xa) \\<Rightarrow> eval ?i ?q\n        | (Det False, Det True) \\<Rightarrow> eval ?i ?p\n        | (Det False, Det False) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Det False, Indet nat) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Det True) \\<Rightarrow> eval ?i ?p\n        | (Indet nat, Det False) \\<Rightarrow>\n            case eval ?i ?p of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Indet nata) \\<Rightarrow> Det False)\n  (Det ?x1.0 = Det ?y1.0) = (?x1.0 = ?y1.0)\n  (Indet ?x2.0 = Indet ?y2.0) = (?x2.0 = ?y2.0)\n  Det ?x1.0 \\<noteq> Indet ?x2.0\n  Indet ?x2.0 \\<noteq> Det ?x1.0\n  (case Det ?x1.0 of Det x \\<Rightarrow> ?f1.0 x\n   | Indet x \\<Rightarrow> ?f2.0 x) =\n  ?f1.0 ?x1.0\n  (case Indet ?x2.0 of Det x \\<Rightarrow> ?f1.0 x\n   | Indet x \\<Rightarrow> ?f2.0 x) =\n  ?f2.0 ?x2.0\n  rec_tv ?f1.0 ?f2.0 (Det ?x1.0) = ?f1.0 ?x1.0\n  rec_tv ?f1.0 ?f2.0 (Indet ?x2.0) = ?f2.0 ?x2.0\n\ngoal (1 subgoal):\n 1. \\<not> valid (Imp (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))", "unfolding valid_in_def\n  \\<comment> \\<open>by smt OK\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i.\n             range i \\<subseteq> domain {1} \\<longrightarrow>\n             eval i\n              (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q'')) =\n             Det True)\n  \\<not> (\\<forall>i.\n             range i \\<subseteq> domain ?U \\<longrightarrow>\n             eval i ?p = Det True) \\<Longrightarrow>\n  \\<not> valid ?p\n  eval ?i (Pro ?s) = ?i ?s\n  eval ?i Truth = Det True\n  eval ?i (Neg' ?p) =\n  (case eval ?i ?p of Det True \\<Rightarrow> Det False\n   | Det False \\<Rightarrow> Det True | Indet x \\<Rightarrow> Indet x)\n  eval ?i (Con' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then eval ?i ?p\n   else if eval ?i ?p = Det True then eval ?i ?q\n        else if eval ?i ?q = Det True then eval ?i ?p else Det False)\n  eval ?i (Eql ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True else Det False)\n  eval ?i (Eql' ?p ?q) =\n  (if eval ?i ?p = eval ?i ?q then Det True\n   else case (eval ?i ?p, eval ?i ?q) of\n        (Det True, xa) \\<Rightarrow> eval ?i ?q\n        | (Det False, Det True) \\<Rightarrow> eval ?i ?p\n        | (Det False, Det False) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Det False, Indet nat) \\<Rightarrow>\n            case eval ?i ?q of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Det True) \\<Rightarrow> eval ?i ?p\n        | (Indet nat, Det False) \\<Rightarrow>\n            case eval ?i ?p of Det True \\<Rightarrow> Det False\n            | Det False \\<Rightarrow> Det True\n            | Indet x \\<Rightarrow> Indet x\n        | (Indet nat, Indet nata) \\<Rightarrow> Det False)\n  (Det ?x1.0 = Det ?y1.0) = (?x1.0 = ?y1.0)\n  (Indet ?x2.0 = Indet ?y2.0) = (?x2.0 = ?y2.0)\n  Det ?x1.0 \\<noteq> Indet ?x2.0\n  Indet ?x2.0 \\<noteq> Det ?x1.0\n  (case Det ?x1.0 of Det x \\<Rightarrow> ?f1.0 x\n   | Indet x \\<Rightarrow> ?f2.0 x) =\n  ?f1.0 ?x1.0\n  (case Indet ?x2.0 of Det x \\<Rightarrow> ?f1.0 x\n   | Indet x \\<Rightarrow> ?f2.0 x) =\n  ?f2.0 ?x2.0\n  rec_tv ?f1.0 ?f2.0 (Det ?x1.0) = ?f1.0 ?x1.0\n  rec_tv ?f1.0 ?f2.0 (Indet ?x2.0) = ?f2.0 ?x2.0\n\ngoal (1 subgoal):\n 1. \\<not> valid (Imp (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (\\<forall>i.\n                        range i \\<subseteq> domain {1} \\<longrightarrow>\n                        eval i\n                         (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p'')))\n                           (Pro ''q'')) =\n                        Det True);\n     \\<And>U p.\n        \\<not> (\\<forall>i.\n                   range i \\<subseteq> domain U \\<longrightarrow>\n                   eval i p = Det True) \\<Longrightarrow>\n        \\<not> valid p;\n     \\<And>i s. eval i (Pro s) = i s; \\<And>i. eval i Truth = Det True;\n     \\<And>i p.\n        eval i (Neg' p) =\n        (case eval i p of Det True \\<Rightarrow> Det False\n         | Det False \\<Rightarrow> Det True\n         | Indet x \\<Rightarrow> Indet x);\n     \\<And>i p q.\n        eval i (Con' p q) =\n        (if eval i p = eval i q then eval i p\n         else if eval i p = Det True then eval i q\n              else if eval i q = Det True then eval i p else Det False);\n     \\<And>i p q.\n        eval i (Eql p q) =\n        (if eval i p = eval i q then Det True else Det False);\n     \\<And>i p q.\n        eval i (Eql' p q) =\n        (if eval i p = eval i q then Det True\n         else case (eval i p, eval i q) of\n              (Det True, xa) \\<Rightarrow> eval i q\n              | (Det False, Det True) \\<Rightarrow> eval i p\n              | (Det False, Det False) \\<Rightarrow>\n                  case eval i q of Det True \\<Rightarrow> Det False\n                  | Det False \\<Rightarrow> Det True\n                  | Indet x \\<Rightarrow> Indet x\n              | (Det False, Indet nat) \\<Rightarrow>\n                  case eval i q of Det True \\<Rightarrow> Det False\n                  | Det False \\<Rightarrow> Det True\n                  | Indet x \\<Rightarrow> Indet x\n              | (Indet nat, Det True) \\<Rightarrow> eval i p\n              | (Indet nat, Det False) \\<Rightarrow>\n                  case eval i p of Det True \\<Rightarrow> Det False\n                  | Det False \\<Rightarrow> Det True\n                  | Indet x \\<Rightarrow> Indet x\n              | (Indet nat, Indet nata) \\<Rightarrow> Det False);\n     \\<And>x1 y1. (Det x1 = Det y1) = (x1 = y1);\n     \\<And>x2 y2. (Indet x2 = Indet y2) = (x2 = y2);\n     \\<And>x1 x2. Det x1 \\<noteq> Indet x2;\n     \\<And>x2 x1. Indet x2 \\<noteq> Det x1;\n     \\<And>f1 f2 x1.\n        (case Det x1 of Det x \\<Rightarrow> f1 x\n         | Indet x \\<Rightarrow> f2 x) =\n        f1 x1;\n     \\<And>f1 f2 x2.\n        (case Indet x2 of Det x \\<Rightarrow> f1 x\n         | Indet x \\<Rightarrow> f2 x) =\n        f2 x2;\n     \\<And>f1 f2 x1. rec_tv f1 f2 (Det x1) = f1 x1;\n     \\<And>f1 f2 x2. rec_tv f1 f2 (Indet x2) = f2 x2\\<rbrakk>\n    \\<Longrightarrow> \\<not> valid\n                              (Imp (Con' (Pro ''p'') (Neg' (Pro ''p'')))\n                                (Pro ''q''))", "assume *: \"\\<not> (\\<forall>i. range i \\<subseteq> domain U \\<longrightarrow> eval i p = Det True) \\<Longrightarrow> \\<not> valid p\" for U p"], ["proof (state)\nthis:\n  \\<not> (\\<forall>i.\n             range i \\<subseteq> domain ?U \\<longrightarrow>\n             eval i ?p = Det True) \\<Longrightarrow>\n  \\<not> valid ?p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (\\<forall>i.\n                        range i \\<subseteq> domain {1} \\<longrightarrow>\n                        eval i\n                         (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p'')))\n                           (Pro ''q'')) =\n                        Det True);\n     \\<And>U p.\n        \\<not> (\\<forall>i.\n                   range i \\<subseteq> domain U \\<longrightarrow>\n                   eval i p = Det True) \\<Longrightarrow>\n        \\<not> valid p;\n     \\<And>i s. eval i (Pro s) = i s; \\<And>i. eval i Truth = Det True;\n     \\<And>i p.\n        eval i (Neg' p) =\n        (case eval i p of Det True \\<Rightarrow> Det False\n         | Det False \\<Rightarrow> Det True\n         | Indet x \\<Rightarrow> Indet x);\n     \\<And>i p q.\n        eval i (Con' p q) =\n        (if eval i p = eval i q then eval i p\n         else if eval i p = Det True then eval i q\n              else if eval i q = Det True then eval i p else Det False);\n     \\<And>i p q.\n        eval i (Eql p q) =\n        (if eval i p = eval i q then Det True else Det False);\n     \\<And>i p q.\n        eval i (Eql' p q) =\n        (if eval i p = eval i q then Det True\n         else case (eval i p, eval i q) of\n              (Det True, xa) \\<Rightarrow> eval i q\n              | (Det False, Det True) \\<Rightarrow> eval i p\n              | (Det False, Det False) \\<Rightarrow>\n                  case eval i q of Det True \\<Rightarrow> Det False\n                  | Det False \\<Rightarrow> Det True\n                  | Indet x \\<Rightarrow> Indet x\n              | (Det False, Indet nat) \\<Rightarrow>\n                  case eval i q of Det True \\<Rightarrow> Det False\n                  | Det False \\<Rightarrow> Det True\n                  | Indet x \\<Rightarrow> Indet x\n              | (Indet nat, Det True) \\<Rightarrow> eval i p\n              | (Indet nat, Det False) \\<Rightarrow>\n                  case eval i p of Det True \\<Rightarrow> Det False\n                  | Det False \\<Rightarrow> Det True\n                  | Indet x \\<Rightarrow> Indet x\n              | (Indet nat, Indet nata) \\<Rightarrow> Det False);\n     \\<And>x1 y1. (Det x1 = Det y1) = (x1 = y1);\n     \\<And>x2 y2. (Indet x2 = Indet y2) = (x2 = y2);\n     \\<And>x1 x2. Det x1 \\<noteq> Indet x2;\n     \\<And>x2 x1. Indet x2 \\<noteq> Det x1;\n     \\<And>f1 f2 x1.\n        (case Det x1 of Det x \\<Rightarrow> f1 x\n         | Indet x \\<Rightarrow> f2 x) =\n        f1 x1;\n     \\<And>f1 f2 x2.\n        (case Indet x2 of Det x \\<Rightarrow> f1 x\n         | Indet x \\<Rightarrow> f2 x) =\n        f2 x2;\n     \\<And>f1 f2 x1. rec_tv f1 f2 (Det x1) = f1 x1;\n     \\<And>f1 f2 x2. rec_tv f1 f2 (Indet x2) = f2 x2\\<rbrakk>\n    \\<Longrightarrow> \\<not> valid\n                              (Imp (Con' (Pro ''p'') (Neg' (Pro ''p'')))\n                                (Pro ''q''))", "assume \"\\<not> (\\<forall>i. range i \\<subseteq> domain {1} \\<longrightarrow>\n      eval i (Explosion (Pro ''p'') (Pro ''q'')) = Det True)\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>i.\n             range i \\<subseteq> domain {1} \\<longrightarrow>\n             eval i\n              (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q'')) =\n             Det True)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (\\<forall>i.\n                        range i \\<subseteq> domain {1} \\<longrightarrow>\n                        eval i\n                         (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p'')))\n                           (Pro ''q'')) =\n                        Det True);\n     \\<And>U p.\n        \\<not> (\\<forall>i.\n                   range i \\<subseteq> domain U \\<longrightarrow>\n                   eval i p = Det True) \\<Longrightarrow>\n        \\<not> valid p;\n     \\<And>i s. eval i (Pro s) = i s; \\<And>i. eval i Truth = Det True;\n     \\<And>i p.\n        eval i (Neg' p) =\n        (case eval i p of Det True \\<Rightarrow> Det False\n         | Det False \\<Rightarrow> Det True\n         | Indet x \\<Rightarrow> Indet x);\n     \\<And>i p q.\n        eval i (Con' p q) =\n        (if eval i p = eval i q then eval i p\n         else if eval i p = Det True then eval i q\n              else if eval i q = Det True then eval i p else Det False);\n     \\<And>i p q.\n        eval i (Eql p q) =\n        (if eval i p = eval i q then Det True else Det False);\n     \\<And>i p q.\n        eval i (Eql' p q) =\n        (if eval i p = eval i q then Det True\n         else case (eval i p, eval i q) of\n              (Det True, xa) \\<Rightarrow> eval i q\n              | (Det False, Det True) \\<Rightarrow> eval i p\n              | (Det False, Det False) \\<Rightarrow>\n                  case eval i q of Det True \\<Rightarrow> Det False\n                  | Det False \\<Rightarrow> Det True\n                  | Indet x \\<Rightarrow> Indet x\n              | (Det False, Indet nat) \\<Rightarrow>\n                  case eval i q of Det True \\<Rightarrow> Det False\n                  | Det False \\<Rightarrow> Det True\n                  | Indet x \\<Rightarrow> Indet x\n              | (Indet nat, Det True) \\<Rightarrow> eval i p\n              | (Indet nat, Det False) \\<Rightarrow>\n                  case eval i p of Det True \\<Rightarrow> Det False\n                  | Det False \\<Rightarrow> Det True\n                  | Indet x \\<Rightarrow> Indet x\n              | (Indet nat, Indet nata) \\<Rightarrow> Det False);\n     \\<And>x1 y1. (Det x1 = Det y1) = (x1 = y1);\n     \\<And>x2 y2. (Indet x2 = Indet y2) = (x2 = y2);\n     \\<And>x1 x2. Det x1 \\<noteq> Indet x2;\n     \\<And>x2 x1. Indet x2 \\<noteq> Det x1;\n     \\<And>f1 f2 x1.\n        (case Det x1 of Det x \\<Rightarrow> f1 x\n         | Indet x \\<Rightarrow> f2 x) =\n        f1 x1;\n     \\<And>f1 f2 x2.\n        (case Indet x2 of Det x \\<Rightarrow> f1 x\n         | Indet x \\<Rightarrow> f2 x) =\n        f2 x2;\n     \\<And>f1 f2 x1. rec_tv f1 f2 (Det x1) = f1 x1;\n     \\<And>f1 f2 x2. rec_tv f1 f2 (Indet x2) = f2 x2\\<rbrakk>\n    \\<Longrightarrow> \\<not> valid\n                              (Imp (Con' (Pro ''p'') (Neg' (Pro ''p'')))\n                                (Pro ''q''))", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>i.\n             range i \\<subseteq> domain {1} \\<longrightarrow>\n             eval i\n              (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q'')) =\n             Det True)", "obtain i where\n    **: \"range i \\<subseteq> domain {1} \\<and>\n        eval i (Explosion (Pro ''p'') (Pro ''q'')) \\<noteq> Det True\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i.\n             range i \\<subseteq> domain {1} \\<longrightarrow>\n             eval i\n              (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q'')) =\n             Det True)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        range i \\<subseteq> domain {1} \\<and>\n        eval i\n         (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q'')) \\<noteq>\n        Det True \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  range i \\<subseteq> domain {1} \\<and>\n  eval i (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q'')) \\<noteq>\n  Det True\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (\\<forall>i.\n                        range i \\<subseteq> domain {1} \\<longrightarrow>\n                        eval i\n                         (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p'')))\n                           (Pro ''q'')) =\n                        Det True);\n     \\<And>U p.\n        \\<not> (\\<forall>i.\n                   range i \\<subseteq> domain U \\<longrightarrow>\n                   eval i p = Det True) \\<Longrightarrow>\n        \\<not> valid p;\n     \\<And>i s. eval i (Pro s) = i s; \\<And>i. eval i Truth = Det True;\n     \\<And>i p.\n        eval i (Neg' p) =\n        (case eval i p of Det True \\<Rightarrow> Det False\n         | Det False \\<Rightarrow> Det True\n         | Indet x \\<Rightarrow> Indet x);\n     \\<And>i p q.\n        eval i (Con' p q) =\n        (if eval i p = eval i q then eval i p\n         else if eval i p = Det True then eval i q\n              else if eval i q = Det True then eval i p else Det False);\n     \\<And>i p q.\n        eval i (Eql p q) =\n        (if eval i p = eval i q then Det True else Det False);\n     \\<And>i p q.\n        eval i (Eql' p q) =\n        (if eval i p = eval i q then Det True\n         else case (eval i p, eval i q) of\n              (Det True, xa) \\<Rightarrow> eval i q\n              | (Det False, Det True) \\<Rightarrow> eval i p\n              | (Det False, Det False) \\<Rightarrow>\n                  case eval i q of Det True \\<Rightarrow> Det False\n                  | Det False \\<Rightarrow> Det True\n                  | Indet x \\<Rightarrow> Indet x\n              | (Det False, Indet nat) \\<Rightarrow>\n                  case eval i q of Det True \\<Rightarrow> Det False\n                  | Det False \\<Rightarrow> Det True\n                  | Indet x \\<Rightarrow> Indet x\n              | (Indet nat, Det True) \\<Rightarrow> eval i p\n              | (Indet nat, Det False) \\<Rightarrow>\n                  case eval i p of Det True \\<Rightarrow> Det False\n                  | Det False \\<Rightarrow> Det True\n                  | Indet x \\<Rightarrow> Indet x\n              | (Indet nat, Indet nata) \\<Rightarrow> Det False);\n     \\<And>x1 y1. (Det x1 = Det y1) = (x1 = y1);\n     \\<And>x2 y2. (Indet x2 = Indet y2) = (x2 = y2);\n     \\<And>x1 x2. Det x1 \\<noteq> Indet x2;\n     \\<And>x2 x1. Indet x2 \\<noteq> Det x1;\n     \\<And>f1 f2 x1.\n        (case Det x1 of Det x \\<Rightarrow> f1 x\n         | Indet x \\<Rightarrow> f2 x) =\n        f1 x1;\n     \\<And>f1 f2 x2.\n        (case Indet x2 of Det x \\<Rightarrow> f1 x\n         | Indet x \\<Rightarrow> f2 x) =\n        f2 x2;\n     \\<And>f1 f2 x1. rec_tv f1 f2 (Det x1) = f1 x1;\n     \\<And>f1 f2 x2. rec_tv f1 f2 (Indet x2) = f2 x2\\<rbrakk>\n    \\<Longrightarrow> \\<not> valid\n                              (Imp (Con' (Pro ''p'') (Neg' (Pro ''p'')))\n                                (Pro ''q''))", "then"], ["proof (chain)\npicking this:\n  range i \\<subseteq> domain {1} \\<and>\n  eval i (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q'')) \\<noteq>\n  Det True", "have \"eval i (Con' (Pro ''p'') (Neg' (Pro ''p''))) \\<noteq>\n      eval i (Con' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))\""], ["proof (prove)\nusing this:\n  range i \\<subseteq> domain {1} \\<and>\n  eval i (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q'')) \\<noteq>\n  Det True\n\ngoal (1 subgoal):\n 1. eval i (Con' (Pro ''p'') (Neg' (Pro ''p''))) \\<noteq>\n    eval i (Con' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))", "by force"], ["proof (state)\nthis:\n  eval i (Con' (Pro ''p'') (Neg' (Pro ''p''))) \\<noteq>\n  eval i (Con' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (\\<forall>i.\n                        range i \\<subseteq> domain {1} \\<longrightarrow>\n                        eval i\n                         (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p'')))\n                           (Pro ''q'')) =\n                        Det True);\n     \\<And>U p.\n        \\<not> (\\<forall>i.\n                   range i \\<subseteq> domain U \\<longrightarrow>\n                   eval i p = Det True) \\<Longrightarrow>\n        \\<not> valid p;\n     \\<And>i s. eval i (Pro s) = i s; \\<And>i. eval i Truth = Det True;\n     \\<And>i p.\n        eval i (Neg' p) =\n        (case eval i p of Det True \\<Rightarrow> Det False\n         | Det False \\<Rightarrow> Det True\n         | Indet x \\<Rightarrow> Indet x);\n     \\<And>i p q.\n        eval i (Con' p q) =\n        (if eval i p = eval i q then eval i p\n         else if eval i p = Det True then eval i q\n              else if eval i q = Det True then eval i p else Det False);\n     \\<And>i p q.\n        eval i (Eql p q) =\n        (if eval i p = eval i q then Det True else Det False);\n     \\<And>i p q.\n        eval i (Eql' p q) =\n        (if eval i p = eval i q then Det True\n         else case (eval i p, eval i q) of\n              (Det True, xa) \\<Rightarrow> eval i q\n              | (Det False, Det True) \\<Rightarrow> eval i p\n              | (Det False, Det False) \\<Rightarrow>\n                  case eval i q of Det True \\<Rightarrow> Det False\n                  | Det False \\<Rightarrow> Det True\n                  | Indet x \\<Rightarrow> Indet x\n              | (Det False, Indet nat) \\<Rightarrow>\n                  case eval i q of Det True \\<Rightarrow> Det False\n                  | Det False \\<Rightarrow> Det True\n                  | Indet x \\<Rightarrow> Indet x\n              | (Indet nat, Det True) \\<Rightarrow> eval i p\n              | (Indet nat, Det False) \\<Rightarrow>\n                  case eval i p of Det True \\<Rightarrow> Det False\n                  | Det False \\<Rightarrow> Det True\n                  | Indet x \\<Rightarrow> Indet x\n              | (Indet nat, Indet nata) \\<Rightarrow> Det False);\n     \\<And>x1 y1. (Det x1 = Det y1) = (x1 = y1);\n     \\<And>x2 y2. (Indet x2 = Indet y2) = (x2 = y2);\n     \\<And>x1 x2. Det x1 \\<noteq> Indet x2;\n     \\<And>x2 x1. Indet x2 \\<noteq> Det x1;\n     \\<And>f1 f2 x1.\n        (case Det x1 of Det x \\<Rightarrow> f1 x\n         | Indet x \\<Rightarrow> f2 x) =\n        f1 x1;\n     \\<And>f1 f2 x2.\n        (case Indet x2 of Det x \\<Rightarrow> f1 x\n         | Indet x \\<Rightarrow> f2 x) =\n        f2 x2;\n     \\<And>f1 f2 x1. rec_tv f1 f2 (Det x1) = f1 x1;\n     \\<And>f1 f2 x2. rec_tv f1 f2 (Indet x2) = f2 x2\\<rbrakk>\n    \\<Longrightarrow> \\<not> valid\n                              (Imp (Con' (Pro ''p'') (Neg' (Pro ''p'')))\n                                (Pro ''q''))", "then"], ["proof (chain)\npicking this:\n  eval i (Con' (Pro ''p'') (Neg' (Pro ''p''))) \\<noteq>\n  eval i (Con' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))", "show ?thesis"], ["proof (prove)\nusing this:\n  eval i (Con' (Pro ''p'') (Neg' (Pro ''p''))) \\<noteq>\n  eval i (Con' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))\n\ngoal (1 subgoal):\n 1. \\<not> valid (Imp (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))", "using * **"], ["proof (prove)\nusing this:\n  eval i (Con' (Pro ''p'') (Neg' (Pro ''p''))) \\<noteq>\n  eval i (Con' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))\n  \\<not> (\\<forall>i.\n             range i \\<subseteq> domain ?U \\<longrightarrow>\n             eval i ?p = Det True) \\<Longrightarrow>\n  \\<not> valid ?p\n  range i \\<subseteq> domain {1} \\<and>\n  eval i (Imp' (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q'')) \\<noteq>\n  Det True\n\ngoal (1 subgoal):\n 1. \\<not> valid (Imp (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))", "by force"], ["proof (state)\nthis:\n  \\<not> valid (Imp (Con' (Pro ''p'') (Neg' (Pro ''p''))) (Pro ''q''))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Example: Contraposition\\<close>"], ["", "text\n\\<open>\nContraposition is not valid.\n\\<close>"], ["", "abbreviation (input) Contraposition :: \"fm \\<Rightarrow> fm \\<Rightarrow> fm\"\nwhere\n  \"Contraposition p q \\<equiv> Eql' (Imp' p q) (Imp' (Neg' q) (Neg' p))\""], ["", "proposition \"valid_boole (Contraposition (Pro ''p'') (Pro ''q''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_boole\n     (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n       (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p''))))", "unfolding valid_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       range i \\<subseteq> domain {} \\<longrightarrow>\n       eval i\n        (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n          (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p'')))) =\n       Det True", "proof (rule; rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i\n        (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n          (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p'')))) =\n       Det True", "fix i :: \"id \\<Rightarrow> tv\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i\n        (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n          (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p'')))) =\n       Det True", "assume \"range i \\<subseteq> domain {}\""], ["proof (state)\nthis:\n  range i \\<subseteq> domain {}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i\n        (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n          (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p'')))) =\n       Det True", "then"], ["proof (chain)\npicking this:\n  range i \\<subseteq> domain {}", "have\n      \"i ''p'' \\<in> {Det True, Det False}\"\n      \"i ''q'' \\<in> {Det True, Det False}\""], ["proof (prove)\nusing this:\n  range i \\<subseteq> domain {}\n\ngoal (1 subgoal):\n 1. i ''p'' \\<in> {Det True, Det False} &&&\n    i ''q'' \\<in> {Det True, Det False}", "unfolding domain_def"], ["proof (prove)\nusing this:\n  range i \\<subseteq> {Det True, Det False} \\<union> Indet ` {}\n\ngoal (1 subgoal):\n 1. i ''p'' \\<in> {Det True, Det False} &&&\n    i ''q'' \\<in> {Det True, Det False}", "by auto"], ["proof (state)\nthis:\n  i ''p'' \\<in> {Det True, Det False}\n  i ''q'' \\<in> {Det True, Det False}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i\n        (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n          (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p'')))) =\n       Det True", "then"], ["proof (chain)\npicking this:\n  i ''p'' \\<in> {Det True, Det False}\n  i ''q'' \\<in> {Det True, Det False}", "show \"eval i (Contraposition (Pro ''p'') (Pro ''q'')) = Det True\""], ["proof (prove)\nusing this:\n  i ''p'' \\<in> {Det True, Det False}\n  i ''q'' \\<in> {Det True, Det False}\n\ngoal (1 subgoal):\n 1. eval i\n     (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n       (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p'')))) =\n    Det True", "by (cases \"i ''p''\"; cases \"i ''q''\") simp_all"], ["proof (state)\nthis:\n  eval i\n   (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n     (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p'')))) =\n  Det True\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition \"valid_in {1} (Contraposition (Pro ''p'') (Pro ''q''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_in {1}\n     (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n       (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p''))))", "unfolding valid_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       range i \\<subseteq> domain {1} \\<longrightarrow>\n       eval i\n        (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n          (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p'')))) =\n       Det True", "proof (rule; rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1} \\<Longrightarrow>\n       eval i\n        (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n          (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p'')))) =\n       Det True", "fix i :: \"id \\<Rightarrow> tv\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1} \\<Longrightarrow>\n       eval i\n        (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n          (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p'')))) =\n       Det True", "assume \"range i \\<subseteq> domain {1}\""], ["proof (state)\nthis:\n  range i \\<subseteq> domain {1}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1} \\<Longrightarrow>\n       eval i\n        (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n          (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p'')))) =\n       Det True", "then"], ["proof (chain)\npicking this:\n  range i \\<subseteq> domain {1}", "have\n      \"i ''p'' \\<in> {Det True, Det False, Indet 1}\"\n      \"i ''q'' \\<in> {Det True, Det False, Indet 1}\""], ["proof (prove)\nusing this:\n  range i \\<subseteq> domain {1}\n\ngoal (1 subgoal):\n 1. i ''p'' \\<in> {Det True, Det False, Indet 1} &&&\n    i ''q'' \\<in> {Det True, Det False, Indet 1}", "unfolding domain_def"], ["proof (prove)\nusing this:\n  range i \\<subseteq> {Det True, Det False} \\<union> Indet ` {1}\n\ngoal (1 subgoal):\n 1. i ''p'' \\<in> {Det True, Det False, Indet 1} &&&\n    i ''q'' \\<in> {Det True, Det False, Indet 1}", "by auto"], ["proof (state)\nthis:\n  i ''p'' \\<in> {Det True, Det False, Indet 1}\n  i ''q'' \\<in> {Det True, Det False, Indet 1}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1} \\<Longrightarrow>\n       eval i\n        (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n          (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p'')))) =\n       Det True", "then"], ["proof (chain)\npicking this:\n  i ''p'' \\<in> {Det True, Det False, Indet 1}\n  i ''q'' \\<in> {Det True, Det False, Indet 1}", "show \"eval i (Contraposition (Pro ''p'') (Pro ''q'')) = Det True\""], ["proof (prove)\nusing this:\n  i ''p'' \\<in> {Det True, Det False, Indet 1}\n  i ''q'' \\<in> {Det True, Det False, Indet 1}\n\ngoal (1 subgoal):\n 1. eval i\n     (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n       (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p'')))) =\n    Det True", "by (cases \"i ''p''\"; cases \"i ''q''\") simp_all"], ["proof (state)\nthis:\n  eval i\n   (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n     (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p'')))) =\n  Det True\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma contraposition_counterexample: \"\\<not> valid_in {1, 2} (Contraposition (Pro ''p'') (Pro ''q''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2}\n            (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n              (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p''))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2}\n            (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n              (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p''))))", "let ?i = \"(\\<lambda>s. Indet 1)(''q'' := Indet 2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2}\n            (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n              (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p''))))", "have \"range ?i \\<subseteq> domain {1, 2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range ((\\<lambda>s. Indet 1)(''q'' := Indet 2))\n    \\<subseteq> domain {1, 2}", "unfolding domain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. range ((\\<lambda>s. Indet 1)(''q'' := Indet 2))\n    \\<subseteq> {Det True, Det False} \\<union> Indet ` {1, 2}", "by (simp add: image_subset_iff)"], ["proof (state)\nthis:\n  range ((\\<lambda>s. Indet 1)(''q'' := Indet 2)) \\<subseteq> domain {1, 2}\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2}\n            (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n              (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p''))))", "moreover"], ["proof (state)\nthis:\n  range ((\\<lambda>s. Indet 1)(''q'' := Indet 2)) \\<subseteq> domain {1, 2}\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2}\n            (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n              (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p''))))", "have \"eval ?i (Contraposition (Pro ''p'') (Pro ''q'')) = Det False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval ((\\<lambda>s. Indet 1)(''q'' := Indet 2))\n     (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n       (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p'')))) =\n    Det False", "by simp"], ["proof (state)\nthis:\n  eval ((\\<lambda>s. Indet 1)(''q'' := Indet 2))\n   (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n     (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p'')))) =\n  Det False\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2}\n            (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n              (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p''))))", "moreover"], ["proof (state)\nthis:\n  eval ((\\<lambda>s. Indet 1)(''q'' := Indet 2))\n   (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n     (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p'')))) =\n  Det False\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2}\n            (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n              (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p''))))", "have \"Det False \\<noteq> Det True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Det False \\<noteq> Det True", "by simp"], ["proof (state)\nthis:\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2}\n            (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n              (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p''))))", "ultimately"], ["proof (chain)\npicking this:\n  range ((\\<lambda>s. Indet 1)(''q'' := Indet 2)) \\<subseteq> domain {1, 2}\n  eval ((\\<lambda>s. Indet 1)(''q'' := Indet 2))\n   (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n     (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p'')))) =\n  Det False\n  Det False \\<noteq> Det True", "show ?thesis"], ["proof (prove)\nusing this:\n  range ((\\<lambda>s. Indet 1)(''q'' := Indet 2)) \\<subseteq> domain {1, 2}\n  eval ((\\<lambda>s. Indet 1)(''q'' := Indet 2))\n   (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n     (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p'')))) =\n  Det False\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2}\n            (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n              (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p''))))", "unfolding valid_in_def"], ["proof (prove)\nusing this:\n  range ((\\<lambda>s. Indet 1)(''q'' := Indet 2)) \\<subseteq> domain {1, 2}\n  eval ((\\<lambda>s. Indet 1)(''q'' := Indet 2))\n   (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n     (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p'')))) =\n  Det False\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i.\n               range i \\<subseteq> domain {1, 2} \\<longrightarrow>\n               eval i\n                (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n                  (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p'')))) =\n               Det True)", "by metis"], ["proof (state)\nthis:\n  \\<not> valid_in {1, 2}\n          (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n            (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p''))))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem contraposition_not_valid: \"\\<not> valid (Contraposition (Pro ''p'') (Pro ''q''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n              (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p''))))", "using contraposition_counterexample transfer"], ["proof (prove)\nusing this:\n  \\<not> valid_in {1, 2}\n          (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n            (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p''))))\n  \\<not> valid_in ?U ?p \\<Longrightarrow> \\<not> valid ?p\n\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Eql' (Imp' (Pro ''p'') (Pro ''q''))\n              (Imp' (Neg' (Pro ''q'')) (Neg' (Pro ''p''))))", "by simp"], ["", "subsection \\<open>More Than Four Truth Values Needed\\<close>"], ["", "text\n\\<open>\nCla3 is valid for two indeterminate truth values but not for three indeterminate truth values.\n\\<close>"], ["", "lemma ranges: assumes \"range i \\<subseteq> domain U\" shows \"eval i p \\<in> domain U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval i p \\<in> domain U", "using assms"], ["proof (prove)\nusing this:\n  range i \\<subseteq> domain U\n\ngoal (1 subgoal):\n 1. eval i p \\<in> domain U", "unfolding domain_def"], ["proof (prove)\nusing this:\n  range i \\<subseteq> {Det True, Det False} \\<union> Indet ` U\n\ngoal (1 subgoal):\n 1. eval i p \\<in> {Det True, Det False} \\<union> Indet ` U", "by (induct p) auto"], ["", "proposition (* Cla Truth Table *)\n  \"unary (Cla (Pro ''p'')) [Det True, Det False, Indet 1] = ''\n  *\n  *\n  o\n''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unary (Cla (Pro ''p'')) [Det True, Det False, Indet 1] =\n    ''\\<newline>  *\\<newline>  *\\<newline>  o\\<newline>''", "by code_simp"], ["", "proposition \"valid_boole (Cla p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_boole (Cla p)", "unfolding valid_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       range i \\<subseteq> domain {} \\<longrightarrow>\n       eval i (Cla p) = Det True", "proof (rule; rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i (Cla p) = Det True", "fix i :: \"id \\<Rightarrow> tv\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i (Cla p) = Det True", "assume \"range i \\<subseteq> domain {}\""], ["proof (state)\nthis:\n  range i \\<subseteq> domain {}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i (Cla p) = Det True", "then"], ["proof (chain)\npicking this:\n  range i \\<subseteq> domain {}", "have\n      \"eval i p \\<in> {Det True, Det False}\""], ["proof (prove)\nusing this:\n  range i \\<subseteq> domain {}\n\ngoal (1 subgoal):\n 1. eval i p \\<in> {Det True, Det False}", "using ranges[of i \"{}\"]"], ["proof (prove)\nusing this:\n  range i \\<subseteq> domain {}\n  range i \\<subseteq> domain {} \\<Longrightarrow> eval i ?p \\<in> domain {}\n\ngoal (1 subgoal):\n 1. eval i p \\<in> {Det True, Det False}", "unfolding domain_def"], ["proof (prove)\nusing this:\n  range i \\<subseteq> {Det True, Det False} \\<union> Indet ` {}\n  range i\n  \\<subseteq> {Det True, Det False} \\<union> Indet ` {} \\<Longrightarrow>\n  eval i ?p \\<in> {Det True, Det False} \\<union> Indet ` {}\n\ngoal (1 subgoal):\n 1. eval i p \\<in> {Det True, Det False}", "by auto"], ["proof (state)\nthis:\n  eval i p \\<in> {Det True, Det False}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i (Cla p) = Det True", "then"], ["proof (chain)\npicking this:\n  eval i p \\<in> {Det True, Det False}", "show \"eval i (Cla p) = Det True\""], ["proof (prove)\nusing this:\n  eval i p \\<in> {Det True, Det False}\n\ngoal (1 subgoal):\n 1. eval i (Cla p) = Det True", "by (cases \"eval i p\") simp_all"], ["proof (state)\nthis:\n  eval i (Cla p) = Det True\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition \"\\<not> valid_in {1} (Cla (Pro ''p''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valid_in {1} (Cla (Pro ''p''))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> valid_in {1} (Cla (Pro ''p''))", "let ?i = \"\\<lambda>s. Indet 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> valid_in {1} (Cla (Pro ''p''))", "have \"range ?i \\<subseteq> domain {1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (\\<lambda>s. Indet 1) \\<subseteq> domain {1}", "unfolding domain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. range (\\<lambda>s. Indet 1)\n    \\<subseteq> {Det True, Det False} \\<union> Indet ` {1}", "by (simp add: image_subset_iff)"], ["proof (state)\nthis:\n  range (\\<lambda>s. Indet 1) \\<subseteq> domain {1}\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1} (Cla (Pro ''p''))", "moreover"], ["proof (state)\nthis:\n  range (\\<lambda>s. Indet 1) \\<subseteq> domain {1}\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1} (Cla (Pro ''p''))", "have \"eval ?i (Cla (Pro ''p'')) = Det False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (\\<lambda>s. Indet 1) (Cla (Pro ''p'')) = Det False", "by simp"], ["proof (state)\nthis:\n  eval (\\<lambda>s. Indet 1) (Cla (Pro ''p'')) = Det False\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1} (Cla (Pro ''p''))", "moreover"], ["proof (state)\nthis:\n  eval (\\<lambda>s. Indet 1) (Cla (Pro ''p'')) = Det False\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1} (Cla (Pro ''p''))", "have \"Det False \\<noteq> Det True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Det False \\<noteq> Det True", "by simp"], ["proof (state)\nthis:\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1} (Cla (Pro ''p''))", "ultimately"], ["proof (chain)\npicking this:\n  range (\\<lambda>s. Indet 1) \\<subseteq> domain {1}\n  eval (\\<lambda>s. Indet 1) (Cla (Pro ''p'')) = Det False\n  Det False \\<noteq> Det True", "show ?thesis"], ["proof (prove)\nusing this:\n  range (\\<lambda>s. Indet 1) \\<subseteq> domain {1}\n  eval (\\<lambda>s. Indet 1) (Cla (Pro ''p'')) = Det False\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1} (Cla (Pro ''p''))", "unfolding valid_in_def"], ["proof (prove)\nusing this:\n  range (\\<lambda>s. Indet 1) \\<subseteq> domain {1}\n  eval (\\<lambda>s. Indet 1) (Cla (Pro ''p'')) = Det False\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i.\n               range i \\<subseteq> domain {1} \\<longrightarrow>\n               eval i (Cla (Pro ''p'')) = Det True)", "by metis"], ["proof (state)\nthis:\n  \\<not> valid_in {1} (Cla (Pro ''p''))\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation (input) Cla2 :: \"fm \\<Rightarrow> fm \\<Rightarrow> fm\"\nwhere\n  \"Cla2 p q \\<equiv> Dis (Dis (Cla p) (Cla q)) (Eql p q)\""], ["", "proposition (* Cla2 Truth Table *)\n  \"binary (Cla2 (Pro ''p'') (Pro ''q'')) [Det True, Det False, Indet 1, Indet 2] = ''\n  ****\n  ****\n  ***o\n  **o*\n''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binary\n     (Dis (Dis (Cla (Pro ''p'')) (Cla (Pro ''q'')))\n       (Eql (Pro ''p'') (Pro ''q'')))\n     [Det True, Det False, Indet 1, Indet 2] =\n    ''\\<newline>  ****\\<newline>  ****\\<newline>  ***o\\<newline>  **o*\\<newline>''", "by code_simp"], ["", "proposition \"valid_boole (Cla2 p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_boole (Dis (Dis (Cla p) (Cla q)) (Eql p q))", "unfolding valid_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       range i \\<subseteq> domain {} \\<longrightarrow>\n       eval i (Dis (Dis (Cla p) (Cla q)) (Eql p q)) = Det True", "proof (rule; rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i (Dis (Dis (Cla p) (Cla q)) (Eql p q)) = Det True", "fix i :: \"id \\<Rightarrow> tv\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i (Dis (Dis (Cla p) (Cla q)) (Eql p q)) = Det True", "assume range: \"range i \\<subseteq> domain {}\""], ["proof (state)\nthis:\n  range i \\<subseteq> domain {}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i (Dis (Dis (Cla p) (Cla q)) (Eql p q)) = Det True", "then"], ["proof (chain)\npicking this:\n  range i \\<subseteq> domain {}", "have\n      \"eval i p \\<in> {Det True, Det False}\"\n      \"eval i q \\<in> {Det True, Det False}\""], ["proof (prove)\nusing this:\n  range i \\<subseteq> domain {}\n\ngoal (1 subgoal):\n 1. eval i p \\<in> {Det True, Det False} &&&\n    eval i q \\<in> {Det True, Det False}", "using ranges[of i \"{}\"]"], ["proof (prove)\nusing this:\n  range i \\<subseteq> domain {}\n  range i \\<subseteq> domain {} \\<Longrightarrow> eval i ?p \\<in> domain {}\n\ngoal (1 subgoal):\n 1. eval i p \\<in> {Det True, Det False} &&&\n    eval i q \\<in> {Det True, Det False}", "unfolding domain_def"], ["proof (prove)\nusing this:\n  range i \\<subseteq> {Det True, Det False} \\<union> Indet ` {}\n  range i\n  \\<subseteq> {Det True, Det False} \\<union> Indet ` {} \\<Longrightarrow>\n  eval i ?p \\<in> {Det True, Det False} \\<union> Indet ` {}\n\ngoal (1 subgoal):\n 1. eval i p \\<in> {Det True, Det False} &&&\n    eval i q \\<in> {Det True, Det False}", "by auto"], ["proof (state)\nthis:\n  eval i p \\<in> {Det True, Det False}\n  eval i q \\<in> {Det True, Det False}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i (Dis (Dis (Cla p) (Cla q)) (Eql p q)) = Det True", "then"], ["proof (chain)\npicking this:\n  eval i p \\<in> {Det True, Det False}\n  eval i q \\<in> {Det True, Det False}", "show \"eval i (Cla2 p q) = Det True\""], ["proof (prove)\nusing this:\n  eval i p \\<in> {Det True, Det False}\n  eval i q \\<in> {Det True, Det False}\n\ngoal (1 subgoal):\n 1. eval i (Dis (Dis (Cla p) (Cla q)) (Eql p q)) = Det True", "by (cases \"eval i p\"; cases \"eval i q\") simp_all"], ["proof (state)\nthis:\n  eval i (Dis (Dis (Cla p) (Cla q)) (Eql p q)) = Det True\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition \"valid_in {1} (Cla2 p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_in {1} (Dis (Dis (Cla p) (Cla q)) (Eql p q))", "unfolding valid_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       range i \\<subseteq> domain {1} \\<longrightarrow>\n       eval i (Dis (Dis (Cla p) (Cla q)) (Eql p q)) = Det True", "proof (rule; rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1} \\<Longrightarrow>\n       eval i (Dis (Dis (Cla p) (Cla q)) (Eql p q)) = Det True", "fix i :: \"id \\<Rightarrow> tv\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1} \\<Longrightarrow>\n       eval i (Dis (Dis (Cla p) (Cla q)) (Eql p q)) = Det True", "assume range: \"range i \\<subseteq> domain {1}\""], ["proof (state)\nthis:\n  range i \\<subseteq> domain {1}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1} \\<Longrightarrow>\n       eval i (Dis (Dis (Cla p) (Cla q)) (Eql p q)) = Det True", "then"], ["proof (chain)\npicking this:\n  range i \\<subseteq> domain {1}", "have\n      \"eval i p \\<in> {Det True, Det False, Indet 1}\"\n      \"eval i q \\<in> {Det True, Det False, Indet 1}\""], ["proof (prove)\nusing this:\n  range i \\<subseteq> domain {1}\n\ngoal (1 subgoal):\n 1. eval i p \\<in> {Det True, Det False, Indet 1} &&&\n    eval i q \\<in> {Det True, Det False, Indet 1}", "using ranges[of i \"{1}\"]"], ["proof (prove)\nusing this:\n  range i \\<subseteq> domain {1}\n  range i \\<subseteq> domain {1} \\<Longrightarrow>\n  eval i ?p \\<in> domain {1}\n\ngoal (1 subgoal):\n 1. eval i p \\<in> {Det True, Det False, Indet 1} &&&\n    eval i q \\<in> {Det True, Det False, Indet 1}", "unfolding domain_def"], ["proof (prove)\nusing this:\n  range i \\<subseteq> {Det True, Det False} \\<union> Indet ` {1}\n  range i\n  \\<subseteq> {Det True, Det False} \\<union> Indet ` {1} \\<Longrightarrow>\n  eval i ?p \\<in> {Det True, Det False} \\<union> Indet ` {1}\n\ngoal (1 subgoal):\n 1. eval i p \\<in> {Det True, Det False, Indet 1} &&&\n    eval i q \\<in> {Det True, Det False, Indet 1}", "by auto"], ["proof (state)\nthis:\n  eval i p \\<in> {Det True, Det False, Indet 1}\n  eval i q \\<in> {Det True, Det False, Indet 1}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1} \\<Longrightarrow>\n       eval i (Dis (Dis (Cla p) (Cla q)) (Eql p q)) = Det True", "then"], ["proof (chain)\npicking this:\n  eval i p \\<in> {Det True, Det False, Indet 1}\n  eval i q \\<in> {Det True, Det False, Indet 1}", "show \"eval i (Cla2 p q) = Det True\""], ["proof (prove)\nusing this:\n  eval i p \\<in> {Det True, Det False, Indet 1}\n  eval i q \\<in> {Det True, Det False, Indet 1}\n\ngoal (1 subgoal):\n 1. eval i (Dis (Dis (Cla p) (Cla q)) (Eql p q)) = Det True", "by (cases \"eval i p\"; cases \"eval i q\") simp_all"], ["proof (state)\nthis:\n  eval i (Dis (Dis (Cla p) (Cla q)) (Eql p q)) = Det True\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition \"\\<not> valid_in {1, 2} (Cla2 (Pro ''p'') (Pro ''q''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2}\n            (Dis (Dis (Cla (Pro ''p'')) (Cla (Pro ''q'')))\n              (Eql (Pro ''p'') (Pro ''q'')))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2}\n            (Dis (Dis (Cla (Pro ''p'')) (Cla (Pro ''q'')))\n              (Eql (Pro ''p'') (Pro ''q'')))", "let ?i = \"(\\<lambda>s. Indet 1)(''q'' := Indet 2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2}\n            (Dis (Dis (Cla (Pro ''p'')) (Cla (Pro ''q'')))\n              (Eql (Pro ''p'') (Pro ''q'')))", "have \"range ?i \\<subseteq> domain {1, 2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range ((\\<lambda>s. Indet 1)(''q'' := Indet 2))\n    \\<subseteq> domain {1, 2}", "unfolding domain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. range ((\\<lambda>s. Indet 1)(''q'' := Indet 2))\n    \\<subseteq> {Det True, Det False} \\<union> Indet ` {1, 2}", "by (simp add: image_subset_iff)"], ["proof (state)\nthis:\n  range ((\\<lambda>s. Indet 1)(''q'' := Indet 2)) \\<subseteq> domain {1, 2}\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2}\n            (Dis (Dis (Cla (Pro ''p'')) (Cla (Pro ''q'')))\n              (Eql (Pro ''p'') (Pro ''q'')))", "moreover"], ["proof (state)\nthis:\n  range ((\\<lambda>s. Indet 1)(''q'' := Indet 2)) \\<subseteq> domain {1, 2}\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2}\n            (Dis (Dis (Cla (Pro ''p'')) (Cla (Pro ''q'')))\n              (Eql (Pro ''p'') (Pro ''q'')))", "have \"eval ?i (Cla2 (Pro ''p'') (Pro ''q'')) = Det False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval ((\\<lambda>s. Indet 1)(''q'' := Indet 2))\n     (Dis (Dis (Cla (Pro ''p'')) (Cla (Pro ''q'')))\n       (Eql (Pro ''p'') (Pro ''q''))) =\n    Det False", "by simp"], ["proof (state)\nthis:\n  eval ((\\<lambda>s. Indet 1)(''q'' := Indet 2))\n   (Dis (Dis (Cla (Pro ''p'')) (Cla (Pro ''q'')))\n     (Eql (Pro ''p'') (Pro ''q''))) =\n  Det False\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2}\n            (Dis (Dis (Cla (Pro ''p'')) (Cla (Pro ''q'')))\n              (Eql (Pro ''p'') (Pro ''q'')))", "moreover"], ["proof (state)\nthis:\n  eval ((\\<lambda>s. Indet 1)(''q'' := Indet 2))\n   (Dis (Dis (Cla (Pro ''p'')) (Cla (Pro ''q'')))\n     (Eql (Pro ''p'') (Pro ''q''))) =\n  Det False\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2}\n            (Dis (Dis (Cla (Pro ''p'')) (Cla (Pro ''q'')))\n              (Eql (Pro ''p'') (Pro ''q'')))", "have \"Det False \\<noteq> Det True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Det False \\<noteq> Det True", "by simp"], ["proof (state)\nthis:\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2}\n            (Dis (Dis (Cla (Pro ''p'')) (Cla (Pro ''q'')))\n              (Eql (Pro ''p'') (Pro ''q'')))", "ultimately"], ["proof (chain)\npicking this:\n  range ((\\<lambda>s. Indet 1)(''q'' := Indet 2)) \\<subseteq> domain {1, 2}\n  eval ((\\<lambda>s. Indet 1)(''q'' := Indet 2))\n   (Dis (Dis (Cla (Pro ''p'')) (Cla (Pro ''q'')))\n     (Eql (Pro ''p'') (Pro ''q''))) =\n  Det False\n  Det False \\<noteq> Det True", "show ?thesis"], ["proof (prove)\nusing this:\n  range ((\\<lambda>s. Indet 1)(''q'' := Indet 2)) \\<subseteq> domain {1, 2}\n  eval ((\\<lambda>s. Indet 1)(''q'' := Indet 2))\n   (Dis (Dis (Cla (Pro ''p'')) (Cla (Pro ''q'')))\n     (Eql (Pro ''p'') (Pro ''q''))) =\n  Det False\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2}\n            (Dis (Dis (Cla (Pro ''p'')) (Cla (Pro ''q'')))\n              (Eql (Pro ''p'') (Pro ''q'')))", "unfolding valid_in_def"], ["proof (prove)\nusing this:\n  range ((\\<lambda>s. Indet 1)(''q'' := Indet 2)) \\<subseteq> domain {1, 2}\n  eval ((\\<lambda>s. Indet 1)(''q'' := Indet 2))\n   (Dis (Dis (Cla (Pro ''p'')) (Cla (Pro ''q'')))\n     (Eql (Pro ''p'') (Pro ''q''))) =\n  Det False\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i.\n               range i \\<subseteq> domain {1, 2} \\<longrightarrow>\n               eval i\n                (Dis (Dis (Cla (Pro ''p'')) (Cla (Pro ''q'')))\n                  (Eql (Pro ''p'') (Pro ''q''))) =\n               Det True)", "by metis"], ["proof (state)\nthis:\n  \\<not> valid_in {1, 2}\n          (Dis (Dis (Cla (Pro ''p'')) (Cla (Pro ''q'')))\n            (Eql (Pro ''p'') (Pro ''q'')))\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation (input) Cla3 :: \"fm \\<Rightarrow> fm \\<Rightarrow> fm \\<Rightarrow> fm\"\nwhere\n  \"Cla3 p q r \\<equiv> Dis (Dis (Cla p) (Dis (Cla q) (Cla r))) (Dis (Eql p q) (Dis (Eql p r) (Eql q r)))\""], ["", "proposition \"valid_boole (Cla3 p q r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_boole\n     (Dis (Dis (Cla p) (Dis (Cla q) (Cla r)))\n       (Dis (Eql p q) (Dis (Eql p r) (Eql q r))))", "unfolding valid_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       range i \\<subseteq> domain {} \\<longrightarrow>\n       eval i\n        (Dis (Dis (Cla p) (Dis (Cla q) (Cla r)))\n          (Dis (Eql p q) (Dis (Eql p r) (Eql q r)))) =\n       Det True", "proof (rule; rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i\n        (Dis (Dis (Cla p) (Dis (Cla q) (Cla r)))\n          (Dis (Eql p q) (Dis (Eql p r) (Eql q r)))) =\n       Det True", "fix i :: \"id \\<Rightarrow> tv\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i\n        (Dis (Dis (Cla p) (Dis (Cla q) (Cla r)))\n          (Dis (Eql p q) (Dis (Eql p r) (Eql q r)))) =\n       Det True", "assume \"range i \\<subseteq> domain {}\""], ["proof (state)\nthis:\n  range i \\<subseteq> domain {}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i\n        (Dis (Dis (Cla p) (Dis (Cla q) (Cla r)))\n          (Dis (Eql p q) (Dis (Eql p r) (Eql q r)))) =\n       Det True", "then"], ["proof (chain)\npicking this:\n  range i \\<subseteq> domain {}", "have\n      \"eval i p \\<in> {Det True, Det False}\"\n      \"eval i q \\<in> {Det True, Det False}\"\n      \"eval i r \\<in> {Det True, Det False}\""], ["proof (prove)\nusing this:\n  range i \\<subseteq> domain {}\n\ngoal (1 subgoal):\n 1. eval i p \\<in> {Det True, Det False} &&&\n    eval i q \\<in> {Det True, Det False} &&&\n    eval i r \\<in> {Det True, Det False}", "using ranges[of i \"{}\"]"], ["proof (prove)\nusing this:\n  range i \\<subseteq> domain {}\n  range i \\<subseteq> domain {} \\<Longrightarrow> eval i ?p \\<in> domain {}\n\ngoal (1 subgoal):\n 1. eval i p \\<in> {Det True, Det False} &&&\n    eval i q \\<in> {Det True, Det False} &&&\n    eval i r \\<in> {Det True, Det False}", "unfolding domain_def"], ["proof (prove)\nusing this:\n  range i \\<subseteq> {Det True, Det False} \\<union> Indet ` {}\n  range i\n  \\<subseteq> {Det True, Det False} \\<union> Indet ` {} \\<Longrightarrow>\n  eval i ?p \\<in> {Det True, Det False} \\<union> Indet ` {}\n\ngoal (1 subgoal):\n 1. eval i p \\<in> {Det True, Det False} &&&\n    eval i q \\<in> {Det True, Det False} &&&\n    eval i r \\<in> {Det True, Det False}", "by auto"], ["proof (state)\nthis:\n  eval i p \\<in> {Det True, Det False}\n  eval i q \\<in> {Det True, Det False}\n  eval i r \\<in> {Det True, Det False}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i\n        (Dis (Dis (Cla p) (Dis (Cla q) (Cla r)))\n          (Dis (Eql p q) (Dis (Eql p r) (Eql q r)))) =\n       Det True", "then"], ["proof (chain)\npicking this:\n  eval i p \\<in> {Det True, Det False}\n  eval i q \\<in> {Det True, Det False}\n  eval i r \\<in> {Det True, Det False}", "show \"eval i (Cla3 p q r) = Det True\""], ["proof (prove)\nusing this:\n  eval i p \\<in> {Det True, Det False}\n  eval i q \\<in> {Det True, Det False}\n  eval i r \\<in> {Det True, Det False}\n\ngoal (1 subgoal):\n 1. eval i\n     (Dis (Dis (Cla p) (Dis (Cla q) (Cla r)))\n       (Dis (Eql p q) (Dis (Eql p r) (Eql q r)))) =\n    Det True", "by (cases \"eval i p\"; cases \"eval i q\"; cases \"eval i r\") simp_all"], ["proof (state)\nthis:\n  eval i\n   (Dis (Dis (Cla p) (Dis (Cla q) (Cla r)))\n     (Dis (Eql p q) (Dis (Eql p r) (Eql q r)))) =\n  Det True\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition \"valid_in {1} (Cla3 p q r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_in {1}\n     (Dis (Dis (Cla p) (Dis (Cla q) (Cla r)))\n       (Dis (Eql p q) (Dis (Eql p r) (Eql q r))))", "unfolding valid_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       range i \\<subseteq> domain {1} \\<longrightarrow>\n       eval i\n        (Dis (Dis (Cla p) (Dis (Cla q) (Cla r)))\n          (Dis (Eql p q) (Dis (Eql p r) (Eql q r)))) =\n       Det True", "proof (rule; rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1} \\<Longrightarrow>\n       eval i\n        (Dis (Dis (Cla p) (Dis (Cla q) (Cla r)))\n          (Dis (Eql p q) (Dis (Eql p r) (Eql q r)))) =\n       Det True", "fix i :: \"id \\<Rightarrow> tv\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1} \\<Longrightarrow>\n       eval i\n        (Dis (Dis (Cla p) (Dis (Cla q) (Cla r)))\n          (Dis (Eql p q) (Dis (Eql p r) (Eql q r)))) =\n       Det True", "assume \"range i \\<subseteq> domain {1}\""], ["proof (state)\nthis:\n  range i \\<subseteq> domain {1}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1} \\<Longrightarrow>\n       eval i\n        (Dis (Dis (Cla p) (Dis (Cla q) (Cla r)))\n          (Dis (Eql p q) (Dis (Eql p r) (Eql q r)))) =\n       Det True", "then"], ["proof (chain)\npicking this:\n  range i \\<subseteq> domain {1}", "have\n      \"eval i p \\<in> {Det True, Det False, Indet 1}\"\n      \"eval i q \\<in> {Det True, Det False, Indet 1}\"\n      \"eval i r \\<in> {Det True, Det False, Indet 1}\""], ["proof (prove)\nusing this:\n  range i \\<subseteq> domain {1}\n\ngoal (1 subgoal):\n 1. eval i p \\<in> {Det True, Det False, Indet 1} &&&\n    eval i q \\<in> {Det True, Det False, Indet 1} &&&\n    eval i r \\<in> {Det True, Det False, Indet 1}", "using ranges[of i \"{1}\"]"], ["proof (prove)\nusing this:\n  range i \\<subseteq> domain {1}\n  range i \\<subseteq> domain {1} \\<Longrightarrow>\n  eval i ?p \\<in> domain {1}\n\ngoal (1 subgoal):\n 1. eval i p \\<in> {Det True, Det False, Indet 1} &&&\n    eval i q \\<in> {Det True, Det False, Indet 1} &&&\n    eval i r \\<in> {Det True, Det False, Indet 1}", "unfolding domain_def"], ["proof (prove)\nusing this:\n  range i \\<subseteq> {Det True, Det False} \\<union> Indet ` {1}\n  range i\n  \\<subseteq> {Det True, Det False} \\<union> Indet ` {1} \\<Longrightarrow>\n  eval i ?p \\<in> {Det True, Det False} \\<union> Indet ` {1}\n\ngoal (1 subgoal):\n 1. eval i p \\<in> {Det True, Det False, Indet 1} &&&\n    eval i q \\<in> {Det True, Det False, Indet 1} &&&\n    eval i r \\<in> {Det True, Det False, Indet 1}", "by auto"], ["proof (state)\nthis:\n  eval i p \\<in> {Det True, Det False, Indet 1}\n  eval i q \\<in> {Det True, Det False, Indet 1}\n  eval i r \\<in> {Det True, Det False, Indet 1}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1} \\<Longrightarrow>\n       eval i\n        (Dis (Dis (Cla p) (Dis (Cla q) (Cla r)))\n          (Dis (Eql p q) (Dis (Eql p r) (Eql q r)))) =\n       Det True", "then"], ["proof (chain)\npicking this:\n  eval i p \\<in> {Det True, Det False, Indet 1}\n  eval i q \\<in> {Det True, Det False, Indet 1}\n  eval i r \\<in> {Det True, Det False, Indet 1}", "show \"eval i (Cla3 p q r) = Det True\""], ["proof (prove)\nusing this:\n  eval i p \\<in> {Det True, Det False, Indet 1}\n  eval i q \\<in> {Det True, Det False, Indet 1}\n  eval i r \\<in> {Det True, Det False, Indet 1}\n\ngoal (1 subgoal):\n 1. eval i\n     (Dis (Dis (Cla p) (Dis (Cla q) (Cla r)))\n       (Dis (Eql p q) (Dis (Eql p r) (Eql q r)))) =\n    Det True", "by (cases \"eval i p\"; cases \"eval i q\"; cases \"eval i r\") simp_all"], ["proof (state)\nthis:\n  eval i\n   (Dis (Dis (Cla p) (Dis (Cla q) (Cla r)))\n     (Dis (Eql p q) (Dis (Eql p r) (Eql q r)))) =\n  Det True\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition \"valid_in {1, 2} (Cla3 p q r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_in {1, 2}\n     (Dis (Dis (Cla p) (Dis (Cla q) (Cla r)))\n       (Dis (Eql p q) (Dis (Eql p r) (Eql q r))))", "unfolding valid_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       range i \\<subseteq> domain {1, 2} \\<longrightarrow>\n       eval i\n        (Dis (Dis (Cla p) (Dis (Cla q) (Cla r)))\n          (Dis (Eql p q) (Dis (Eql p r) (Eql q r)))) =\n       Det True", "proof (rule; rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1, 2} \\<Longrightarrow>\n       eval i\n        (Dis (Dis (Cla p) (Dis (Cla q) (Cla r)))\n          (Dis (Eql p q) (Dis (Eql p r) (Eql q r)))) =\n       Det True", "fix i :: \"id \\<Rightarrow> tv\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1, 2} \\<Longrightarrow>\n       eval i\n        (Dis (Dis (Cla p) (Dis (Cla q) (Cla r)))\n          (Dis (Eql p q) (Dis (Eql p r) (Eql q r)))) =\n       Det True", "assume \"range i \\<subseteq> domain {1, 2}\""], ["proof (state)\nthis:\n  range i \\<subseteq> domain {1, 2}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1, 2} \\<Longrightarrow>\n       eval i\n        (Dis (Dis (Cla p) (Dis (Cla q) (Cla r)))\n          (Dis (Eql p q) (Dis (Eql p r) (Eql q r)))) =\n       Det True", "then"], ["proof (chain)\npicking this:\n  range i \\<subseteq> domain {1, 2}", "have\n      \"eval i p \\<in> {Det True, Det False, Indet 1, Indet 2}\"\n      \"eval i q \\<in> {Det True, Det False, Indet 1, Indet 2}\"\n      \"eval i r \\<in> {Det True, Det False, Indet 1, Indet 2}\""], ["proof (prove)\nusing this:\n  range i \\<subseteq> domain {1, 2}\n\ngoal (1 subgoal):\n 1. eval i p \\<in> {Det True, Det False, Indet 1, Indet 2} &&&\n    eval i q \\<in> {Det True, Det False, Indet 1, Indet 2} &&&\n    eval i r \\<in> {Det True, Det False, Indet 1, Indet 2}", "using ranges[of i \"{1, 2}\"]"], ["proof (prove)\nusing this:\n  range i \\<subseteq> domain {1, 2}\n  range i \\<subseteq> domain {1, 2} \\<Longrightarrow>\n  eval i ?p \\<in> domain {1, 2}\n\ngoal (1 subgoal):\n 1. eval i p \\<in> {Det True, Det False, Indet 1, Indet 2} &&&\n    eval i q \\<in> {Det True, Det False, Indet 1, Indet 2} &&&\n    eval i r \\<in> {Det True, Det False, Indet 1, Indet 2}", "unfolding domain_def"], ["proof (prove)\nusing this:\n  range i \\<subseteq> {Det True, Det False} \\<union> Indet ` {1, 2}\n  range i\n  \\<subseteq> {Det True, Det False} \\<union>\n              Indet ` {1, 2} \\<Longrightarrow>\n  eval i ?p \\<in> {Det True, Det False} \\<union> Indet ` {1, 2}\n\ngoal (1 subgoal):\n 1. eval i p \\<in> {Det True, Det False, Indet 1, Indet 2} &&&\n    eval i q \\<in> {Det True, Det False, Indet 1, Indet 2} &&&\n    eval i r \\<in> {Det True, Det False, Indet 1, Indet 2}", "by auto"], ["proof (state)\nthis:\n  eval i p \\<in> {Det True, Det False, Indet 1, Indet 2}\n  eval i q \\<in> {Det True, Det False, Indet 1, Indet 2}\n  eval i r \\<in> {Det True, Det False, Indet 1, Indet 2}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1, 2} \\<Longrightarrow>\n       eval i\n        (Dis (Dis (Cla p) (Dis (Cla q) (Cla r)))\n          (Dis (Eql p q) (Dis (Eql p r) (Eql q r)))) =\n       Det True", "then"], ["proof (chain)\npicking this:\n  eval i p \\<in> {Det True, Det False, Indet 1, Indet 2}\n  eval i q \\<in> {Det True, Det False, Indet 1, Indet 2}\n  eval i r \\<in> {Det True, Det False, Indet 1, Indet 2}", "show \"eval i (Cla3 p q r) = Det True\""], ["proof (prove)\nusing this:\n  eval i p \\<in> {Det True, Det False, Indet 1, Indet 2}\n  eval i q \\<in> {Det True, Det False, Indet 1, Indet 2}\n  eval i r \\<in> {Det True, Det False, Indet 1, Indet 2}\n\ngoal (1 subgoal):\n 1. eval i\n     (Dis (Dis (Cla p) (Dis (Cla q) (Cla r)))\n       (Dis (Eql p q) (Dis (Eql p r) (Eql q r)))) =\n    Det True", "by (cases \"eval i p\"; cases \"eval i q\"; cases \"eval i r\") auto"], ["proof (state)\nthis:\n  eval i\n   (Dis (Dis (Cla p) (Dis (Cla q) (Cla r)))\n     (Dis (Eql p q) (Dis (Eql p r) (Eql q r)))) =\n  Det True\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition \"\\<not> valid_in {1, 2, 3} (Cla3 (Pro ''p'') (Pro ''q'') (Pro ''r''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2, 3}\n            (Dis (Dis (Cla (Pro ''p''))\n                   (Dis (Cla (Pro ''q'')) (Cla (Pro ''r''))))\n              (Dis (Eql (Pro ''p'') (Pro ''q''))\n                (Dis (Eql (Pro ''p'') (Pro ''r''))\n                  (Eql (Pro ''q'') (Pro ''r'')))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2, 3}\n            (Dis (Dis (Cla (Pro ''p''))\n                   (Dis (Cla (Pro ''q'')) (Cla (Pro ''r''))))\n              (Dis (Eql (Pro ''p'') (Pro ''q''))\n                (Dis (Eql (Pro ''p'') (Pro ''r''))\n                  (Eql (Pro ''q'') (Pro ''r'')))))", "let ?i = \"(\\<lambda>s. Indet 1)(''q'' := Indet 2, ''r'' := Indet 3)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2, 3}\n            (Dis (Dis (Cla (Pro ''p''))\n                   (Dis (Cla (Pro ''q'')) (Cla (Pro ''r''))))\n              (Dis (Eql (Pro ''p'') (Pro ''q''))\n                (Dis (Eql (Pro ''p'') (Pro ''r''))\n                  (Eql (Pro ''q'') (Pro ''r'')))))", "have \"range ?i \\<subseteq> domain {1, 2, 3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range ((\\<lambda>s. Indet 1)(''q'' := Indet 2, ''r'' := Indet 3))\n    \\<subseteq> domain {1, 2, 3}", "unfolding domain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. range ((\\<lambda>s. Indet 1)(''q'' := Indet 2, ''r'' := Indet 3))\n    \\<subseteq> {Det True, Det False} \\<union> Indet ` {1, 2, 3}", "by (simp add: image_subset_iff)"], ["proof (state)\nthis:\n  range ((\\<lambda>s. Indet 1)(''q'' := Indet 2, ''r'' := Indet 3))\n  \\<subseteq> domain {1, 2, 3}\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2, 3}\n            (Dis (Dis (Cla (Pro ''p''))\n                   (Dis (Cla (Pro ''q'')) (Cla (Pro ''r''))))\n              (Dis (Eql (Pro ''p'') (Pro ''q''))\n                (Dis (Eql (Pro ''p'') (Pro ''r''))\n                  (Eql (Pro ''q'') (Pro ''r'')))))", "moreover"], ["proof (state)\nthis:\n  range ((\\<lambda>s. Indet 1)(''q'' := Indet 2, ''r'' := Indet 3))\n  \\<subseteq> domain {1, 2, 3}\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2, 3}\n            (Dis (Dis (Cla (Pro ''p''))\n                   (Dis (Cla (Pro ''q'')) (Cla (Pro ''r''))))\n              (Dis (Eql (Pro ''p'') (Pro ''q''))\n                (Dis (Eql (Pro ''p'') (Pro ''r''))\n                  (Eql (Pro ''q'') (Pro ''r'')))))", "have \"eval ?i (Cla3 (Pro ''p'') (Pro ''q'') (Pro ''r'')) = Det False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval ((\\<lambda>s. Indet 1)(''q'' := Indet 2, ''r'' := Indet 3))\n     (Dis (Dis (Cla (Pro ''p'')) (Dis (Cla (Pro ''q'')) (Cla (Pro ''r''))))\n       (Dis (Eql (Pro ''p'') (Pro ''q''))\n         (Dis (Eql (Pro ''p'') (Pro ''r''))\n           (Eql (Pro ''q'') (Pro ''r''))))) =\n    Det False", "by simp"], ["proof (state)\nthis:\n  eval ((\\<lambda>s. Indet 1)(''q'' := Indet 2, ''r'' := Indet 3))\n   (Dis (Dis (Cla (Pro ''p'')) (Dis (Cla (Pro ''q'')) (Cla (Pro ''r''))))\n     (Dis (Eql (Pro ''p'') (Pro ''q''))\n       (Dis (Eql (Pro ''p'') (Pro ''r'')) (Eql (Pro ''q'') (Pro ''r''))))) =\n  Det False\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2, 3}\n            (Dis (Dis (Cla (Pro ''p''))\n                   (Dis (Cla (Pro ''q'')) (Cla (Pro ''r''))))\n              (Dis (Eql (Pro ''p'') (Pro ''q''))\n                (Dis (Eql (Pro ''p'') (Pro ''r''))\n                  (Eql (Pro ''q'') (Pro ''r'')))))", "moreover"], ["proof (state)\nthis:\n  eval ((\\<lambda>s. Indet 1)(''q'' := Indet 2, ''r'' := Indet 3))\n   (Dis (Dis (Cla (Pro ''p'')) (Dis (Cla (Pro ''q'')) (Cla (Pro ''r''))))\n     (Dis (Eql (Pro ''p'') (Pro ''q''))\n       (Dis (Eql (Pro ''p'') (Pro ''r'')) (Eql (Pro ''q'') (Pro ''r''))))) =\n  Det False\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2, 3}\n            (Dis (Dis (Cla (Pro ''p''))\n                   (Dis (Cla (Pro ''q'')) (Cla (Pro ''r''))))\n              (Dis (Eql (Pro ''p'') (Pro ''q''))\n                (Dis (Eql (Pro ''p'') (Pro ''r''))\n                  (Eql (Pro ''q'') (Pro ''r'')))))", "have \"Det False \\<noteq> Det True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Det False \\<noteq> Det True", "by simp"], ["proof (state)\nthis:\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2, 3}\n            (Dis (Dis (Cla (Pro ''p''))\n                   (Dis (Cla (Pro ''q'')) (Cla (Pro ''r''))))\n              (Dis (Eql (Pro ''p'') (Pro ''q''))\n                (Dis (Eql (Pro ''p'') (Pro ''r''))\n                  (Eql (Pro ''q'') (Pro ''r'')))))", "ultimately"], ["proof (chain)\npicking this:\n  range ((\\<lambda>s. Indet 1)(''q'' := Indet 2, ''r'' := Indet 3))\n  \\<subseteq> domain {1, 2, 3}\n  eval ((\\<lambda>s. Indet 1)(''q'' := Indet 2, ''r'' := Indet 3))\n   (Dis (Dis (Cla (Pro ''p'')) (Dis (Cla (Pro ''q'')) (Cla (Pro ''r''))))\n     (Dis (Eql (Pro ''p'') (Pro ''q''))\n       (Dis (Eql (Pro ''p'') (Pro ''r'')) (Eql (Pro ''q'') (Pro ''r''))))) =\n  Det False\n  Det False \\<noteq> Det True", "show ?thesis"], ["proof (prove)\nusing this:\n  range ((\\<lambda>s. Indet 1)(''q'' := Indet 2, ''r'' := Indet 3))\n  \\<subseteq> domain {1, 2, 3}\n  eval ((\\<lambda>s. Indet 1)(''q'' := Indet 2, ''r'' := Indet 3))\n   (Dis (Dis (Cla (Pro ''p'')) (Dis (Cla (Pro ''q'')) (Cla (Pro ''r''))))\n     (Dis (Eql (Pro ''p'') (Pro ''q''))\n       (Dis (Eql (Pro ''p'') (Pro ''r'')) (Eql (Pro ''q'') (Pro ''r''))))) =\n  Det False\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> valid_in {1, 2, 3}\n            (Dis (Dis (Cla (Pro ''p''))\n                   (Dis (Cla (Pro ''q'')) (Cla (Pro ''r''))))\n              (Dis (Eql (Pro ''p'') (Pro ''q''))\n                (Dis (Eql (Pro ''p'') (Pro ''r''))\n                  (Eql (Pro ''q'') (Pro ''r'')))))", "unfolding valid_in_def"], ["proof (prove)\nusing this:\n  range ((\\<lambda>s. Indet 1)(''q'' := Indet 2, ''r'' := Indet 3))\n  \\<subseteq> domain {1, 2, 3}\n  eval ((\\<lambda>s. Indet 1)(''q'' := Indet 2, ''r'' := Indet 3))\n   (Dis (Dis (Cla (Pro ''p'')) (Dis (Cla (Pro ''q'')) (Cla (Pro ''r''))))\n     (Dis (Eql (Pro ''p'') (Pro ''q''))\n       (Dis (Eql (Pro ''p'') (Pro ''r'')) (Eql (Pro ''q'') (Pro ''r''))))) =\n  Det False\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i.\n               range i \\<subseteq> domain {1, 2, 3} \\<longrightarrow>\n               eval i\n                (Dis (Dis (Cla (Pro ''p''))\n                       (Dis (Cla (Pro ''q'')) (Cla (Pro ''r''))))\n                  (Dis (Eql (Pro ''p'') (Pro ''q''))\n                    (Dis (Eql (Pro ''p'') (Pro ''r''))\n                      (Eql (Pro ''q'') (Pro ''r''))))) =\n               Det True)", "by metis"], ["proof (state)\nthis:\n  \\<not> valid_in {1, 2, 3}\n          (Dis (Dis (Cla (Pro ''p''))\n                 (Dis (Cla (Pro ''q'')) (Cla (Pro ''r''))))\n            (Dis (Eql (Pro ''p'') (Pro ''q''))\n              (Dis (Eql (Pro ''p'') (Pro ''r''))\n                (Eql (Pro ''q'') (Pro ''r'')))))\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Further Meta-Theorems\\<close>"], ["", "subsection \\<open>Fundamental Definitions and Lemmas\\<close>"], ["", "text\n\\<open>\nThe function props collects the set of propositional symbols occurring in a formula.\n\\<close>"], ["", "fun props :: \"fm \\<Rightarrow> id set\"\nwhere\n  \"props Truth = {}\" |\n  \"props (Pro s) = {s}\" |\n  \"props (Neg' p) = props p\" |\n  \"props (Con' p q) = props p \\<union> props q\" |\n  \"props (Eql p q) = props p \\<union> props q\" |\n  \"props (Eql' p q) = props p \\<union> props q\""], ["", "lemma relevant_props: assumes \"\\<forall>s \\<in> props p. i1 s = i2 s\" shows \"eval i1 p = eval i2 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval i1 p = eval i2 p", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>props p. i1 s = i2 s\n\ngoal (1 subgoal):\n 1. eval i1 p = eval i2 p", "by (induct p) (simp_all, metis)"], ["", "fun change_tv :: \"(nat \\<Rightarrow> nat) \\<Rightarrow> tv \\<Rightarrow> tv\"\nwhere\n  \"change_tv f (Det b) = Det b\" |\n  \"change_tv f (Indet n) = Indet (f n)\""], ["", "lemma change_tv_injection: assumes \"inj f\" shows \"inj (change_tv f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (change_tv f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inj (change_tv f)", "have \"change_tv f tv1 = change_tv f tv2 \\<Longrightarrow> tv1 = tv2\" for tv1 tv2"], ["proof (prove)\ngoal (1 subgoal):\n 1. change_tv f tv1 = change_tv f tv2 \\<Longrightarrow> tv1 = tv2", "using assms"], ["proof (prove)\nusing this:\n  inj f\n\ngoal (1 subgoal):\n 1. change_tv f tv1 = change_tv f tv2 \\<Longrightarrow> tv1 = tv2", "by (cases tv1; cases tv2) (simp_all add: inj_eq)"], ["proof (state)\nthis:\n  change_tv f ?tv1.0 = change_tv f ?tv2.0 \\<Longrightarrow> ?tv1.0 = ?tv2.0\n\ngoal (1 subgoal):\n 1. inj (change_tv f)", "then"], ["proof (chain)\npicking this:\n  change_tv f ?tv1.0 = change_tv f ?tv2.0 \\<Longrightarrow> ?tv1.0 = ?tv2.0", "show ?thesis"], ["proof (prove)\nusing this:\n  change_tv f ?tv1.0 = change_tv f ?tv2.0 \\<Longrightarrow> ?tv1.0 = ?tv2.0\n\ngoal (1 subgoal):\n 1. inj (change_tv f)", "by (simp add: injI)"], ["proof (state)\nthis:\n  inj (change_tv f)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  change_int :: \"(nat \\<Rightarrow> nat) \\<Rightarrow> (id \\<Rightarrow> tv) \\<Rightarrow> (id \\<Rightarrow> tv)\"\nwhere\n  \"change_int f i \\<equiv> \\<lambda>s. change_tv f (i s)\""], ["", "lemma eval_change: assumes \"inj f\" shows \"eval (change_int f i) p = change_tv f (eval i p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (change_int f i) p = change_tv f (eval i p)", "proof (induct p)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)\n 3. \\<And>p.\n       eval (change_int f i) p = change_tv f (eval i p) \\<Longrightarrow>\n       eval (change_int f i) (Neg' p) = change_tv f (eval i (Neg' p))\n 4. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Con' p1 p2) =\n                         change_tv f (eval i (Con' p1 p2))\n 5. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql p1 p2) =\n                         change_tv f (eval i (Eql p1 p2))\n 6. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql' p1 p2) =\n                         change_tv f (eval i (Eql' p1 p2))", "fix p"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)\n 3. \\<And>p.\n       eval (change_int f i) p = change_tv f (eval i p) \\<Longrightarrow>\n       eval (change_int f i) (Neg' p) = change_tv f (eval i (Neg' p))\n 4. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Con' p1 p2) =\n                         change_tv f (eval i (Con' p1 p2))\n 5. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql p1 p2) =\n                         change_tv f (eval i (Eql p1 p2))\n 6. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql' p1 p2) =\n                         change_tv f (eval i (Eql' p1 p2))", "assume \"eval (change_int f i) p = change_tv f (eval i p)\""], ["proof (state)\nthis:\n  eval (change_int f i) p = change_tv f (eval i p)\n\ngoal (6 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)\n 3. \\<And>p.\n       eval (change_int f i) p = change_tv f (eval i p) \\<Longrightarrow>\n       eval (change_int f i) (Neg' p) = change_tv f (eval i (Neg' p))\n 4. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Con' p1 p2) =\n                         change_tv f (eval i (Con' p1 p2))\n 5. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql p1 p2) =\n                         change_tv f (eval i (Eql p1 p2))\n 6. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql' p1 p2) =\n                         change_tv f (eval i (Eql' p1 p2))", "then"], ["proof (chain)\npicking this:\n  eval (change_int f i) p = change_tv f (eval i p)", "have \"eval_neg (eval (change_int f i) p) = eval_neg (change_tv f (eval i p))\""], ["proof (prove)\nusing this:\n  eval (change_int f i) p = change_tv f (eval i p)\n\ngoal (1 subgoal):\n 1. (case eval (change_int f i) p of Det True \\<Rightarrow> Det False\n     | Det False \\<Rightarrow> Det True | Indet n \\<Rightarrow> Indet n) =\n    (case change_tv f (eval i p) of Det True \\<Rightarrow> Det False\n     | Det False \\<Rightarrow> Det True | Indet n \\<Rightarrow> Indet n)", "by simp"], ["proof (state)\nthis:\n  (case eval (change_int f i) p of Det True \\<Rightarrow> Det False\n   | Det False \\<Rightarrow> Det True | Indet n \\<Rightarrow> Indet n) =\n  (case change_tv f (eval i p) of Det True \\<Rightarrow> Det False\n   | Det False \\<Rightarrow> Det True | Indet n \\<Rightarrow> Indet n)\n\ngoal (6 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)\n 3. \\<And>p.\n       eval (change_int f i) p = change_tv f (eval i p) \\<Longrightarrow>\n       eval (change_int f i) (Neg' p) = change_tv f (eval i (Neg' p))\n 4. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Con' p1 p2) =\n                         change_tv f (eval i (Con' p1 p2))\n 5. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql p1 p2) =\n                         change_tv f (eval i (Eql p1 p2))\n 6. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql' p1 p2) =\n                         change_tv f (eval i (Eql' p1 p2))", "then"], ["proof (chain)\npicking this:\n  (case eval (change_int f i) p of Det True \\<Rightarrow> Det False\n   | Det False \\<Rightarrow> Det True | Indet n \\<Rightarrow> Indet n) =\n  (case change_tv f (eval i p) of Det True \\<Rightarrow> Det False\n   | Det False \\<Rightarrow> Det True | Indet n \\<Rightarrow> Indet n)", "have \"eval_neg (eval (change_int f i) p) = change_tv f (eval_neg (eval i p))\""], ["proof (prove)\nusing this:\n  (case eval (change_int f i) p of Det True \\<Rightarrow> Det False\n   | Det False \\<Rightarrow> Det True | Indet n \\<Rightarrow> Indet n) =\n  (case change_tv f (eval i p) of Det True \\<Rightarrow> Det False\n   | Det False \\<Rightarrow> Det True | Indet n \\<Rightarrow> Indet n)\n\ngoal (1 subgoal):\n 1. (case eval (change_int f i) p of Det True \\<Rightarrow> Det False\n     | Det False \\<Rightarrow> Det True | Indet n \\<Rightarrow> Indet n) =\n    change_tv f\n     (case eval i p of Det True \\<Rightarrow> Det False\n      | Det False \\<Rightarrow> Det True | Indet n \\<Rightarrow> Indet n)", "by (cases \"eval i p\") (simp_all add: case_bool_if)"], ["proof (state)\nthis:\n  (case eval (change_int f i) p of Det True \\<Rightarrow> Det False\n   | Det False \\<Rightarrow> Det True | Indet n \\<Rightarrow> Indet n) =\n  change_tv f\n   (case eval i p of Det True \\<Rightarrow> Det False\n    | Det False \\<Rightarrow> Det True | Indet n \\<Rightarrow> Indet n)\n\ngoal (6 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)\n 3. \\<And>p.\n       eval (change_int f i) p = change_tv f (eval i p) \\<Longrightarrow>\n       eval (change_int f i) (Neg' p) = change_tv f (eval i (Neg' p))\n 4. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Con' p1 p2) =\n                         change_tv f (eval i (Con' p1 p2))\n 5. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql p1 p2) =\n                         change_tv f (eval i (Eql p1 p2))\n 6. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql' p1 p2) =\n                         change_tv f (eval i (Eql' p1 p2))", "then"], ["proof (chain)\npicking this:\n  (case eval (change_int f i) p of Det True \\<Rightarrow> Det False\n   | Det False \\<Rightarrow> Det True | Indet n \\<Rightarrow> Indet n) =\n  change_tv f\n   (case eval i p of Det True \\<Rightarrow> Det False\n    | Det False \\<Rightarrow> Det True | Indet n \\<Rightarrow> Indet n)", "show \"eval (change_int f i) (Neg' p) = change_tv f (eval i (Neg' p))\""], ["proof (prove)\nusing this:\n  (case eval (change_int f i) p of Det True \\<Rightarrow> Det False\n   | Det False \\<Rightarrow> Det True | Indet n \\<Rightarrow> Indet n) =\n  change_tv f\n   (case eval i p of Det True \\<Rightarrow> Det False\n    | Det False \\<Rightarrow> Det True | Indet n \\<Rightarrow> Indet n)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Neg' p) = change_tv f (eval i (Neg' p))", "by simp"], ["proof (state)\nthis:\n  eval (change_int f i) (Neg' p) = change_tv f (eval i (Neg' p))\n\ngoal (5 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)\n 3. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Con' p1 p2) =\n                         change_tv f (eval i (Con' p1 p2))\n 4. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql p1 p2) =\n                         change_tv f (eval i (Eql p1 p2))\n 5. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql' p1 p2) =\n                         change_tv f (eval i (Eql' p1 p2))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)\n 3. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Con' p1 p2) =\n                         change_tv f (eval i (Con' p1 p2))\n 4. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql p1 p2) =\n                         change_tv f (eval i (Eql p1 p2))\n 5. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql' p1 p2) =\n                         change_tv f (eval i (Eql' p1 p2))", "fix p1 p2"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)\n 3. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Con' p1 p2) =\n                         change_tv f (eval i (Con' p1 p2))\n 4. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql p1 p2) =\n                         change_tv f (eval i (Eql p1 p2))\n 5. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql' p1 p2) =\n                         change_tv f (eval i (Eql' p1 p2))", "assume ih1: \"eval (change_int f i) p1 = change_tv f (eval i p1)\""], ["proof (state)\nthis:\n  eval (change_int f i) p1 = change_tv f (eval i p1)\n\ngoal (5 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)\n 3. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Con' p1 p2) =\n                         change_tv f (eval i (Con' p1 p2))\n 4. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql p1 p2) =\n                         change_tv f (eval i (Eql p1 p2))\n 5. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql' p1 p2) =\n                         change_tv f (eval i (Eql' p1 p2))", "assume ih2: \"eval (change_int f i) p2 = change_tv f (eval i p2)\""], ["proof (state)\nthis:\n  eval (change_int f i) p2 = change_tv f (eval i p2)\n\ngoal (5 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)\n 3. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Con' p1 p2) =\n                         change_tv f (eval i (Con' p1 p2))\n 4. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql p1 p2) =\n                         change_tv f (eval i (Eql p1 p2))\n 5. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql' p1 p2) =\n                         change_tv f (eval i (Eql' p1 p2))", "show \"eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "proof (cases \"eval i p1 = eval i p2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. eval i p1 = eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\n 2. eval i p1 \\<noteq> eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "assume a: \"eval i p1 = eval i p2\""], ["proof (state)\nthis:\n  eval i p1 = eval i p2\n\ngoal (2 subgoals):\n 1. eval i p1 = eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\n 2. eval i p1 \\<noteq> eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "then"], ["proof (chain)\npicking this:\n  eval i p1 = eval i p2", "have yes: \"eval i (Con' p1 p2) = eval i p1\""], ["proof (prove)\nusing this:\n  eval i p1 = eval i p2\n\ngoal (1 subgoal):\n 1. eval i (Con' p1 p2) = eval i p1", "by auto"], ["proof (state)\nthis:\n  eval i (Con' p1 p2) = eval i p1\n\ngoal (2 subgoals):\n 1. eval i p1 = eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\n 2. eval i p1 \\<noteq> eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "from a"], ["proof (chain)\npicking this:\n  eval i p1 = eval i p2", "have \"change_tv f (eval i p1) = change_tv f (eval i p2)\""], ["proof (prove)\nusing this:\n  eval i p1 = eval i p2\n\ngoal (1 subgoal):\n 1. change_tv f (eval i p1) = change_tv f (eval i p2)", "by auto"], ["proof (state)\nthis:\n  change_tv f (eval i p1) = change_tv f (eval i p2)\n\ngoal (2 subgoals):\n 1. eval i p1 = eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\n 2. eval i p1 \\<noteq> eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "then"], ["proof (chain)\npicking this:\n  change_tv f (eval i p1) = change_tv f (eval i p2)", "have \"eval (change_int f i) p1 = eval (change_int f i) p2\""], ["proof (prove)\nusing this:\n  change_tv f (eval i p1) = change_tv f (eval i p2)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 = eval (change_int f i) p2", "using ih1 ih2"], ["proof (prove)\nusing this:\n  change_tv f (eval i p1) = change_tv f (eval i p2)\n  eval (change_int f i) p1 = change_tv f (eval i p1)\n  eval (change_int f i) p2 = change_tv f (eval i p2)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 = eval (change_int f i) p2", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) p1 = eval (change_int f i) p2\n\ngoal (2 subgoals):\n 1. eval i p1 = eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\n 2. eval i p1 \\<noteq> eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "then"], ["proof (chain)\npicking this:\n  eval (change_int f i) p1 = eval (change_int f i) p2", "have \"eval (change_int f i) (Con' p1 p2) = eval (change_int f i) p1\""], ["proof (prove)\nusing this:\n  eval (change_int f i) p1 = eval (change_int f i) p2\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Con' p1 p2) = eval (change_int f i) p1", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) (Con' p1 p2) = eval (change_int f i) p1\n\ngoal (2 subgoals):\n 1. eval i p1 = eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\n 2. eval i p1 \\<noteq> eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "then"], ["proof (chain)\npicking this:\n  eval (change_int f i) (Con' p1 p2) = eval (change_int f i) p1", "show \"eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\""], ["proof (prove)\nusing this:\n  eval (change_int f i) (Con' p1 p2) = eval (change_int f i) p1\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "using yes ih1"], ["proof (prove)\nusing this:\n  eval (change_int f i) (Con' p1 p2) = eval (change_int f i) p1\n  eval i (Con' p1 p2) = eval i p1\n  eval (change_int f i) p1 = change_tv f (eval i p1)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\n\ngoal (1 subgoal):\n 1. eval i p1 \\<noteq> eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. eval i p1 \\<noteq> eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "assume a': \"eval i p1 \\<noteq> eval i p2\""], ["proof (state)\nthis:\n  eval i p1 \\<noteq> eval i p2\n\ngoal (1 subgoal):\n 1. eval i p1 \\<noteq> eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "from a'"], ["proof (chain)\npicking this:\n  eval i p1 \\<noteq> eval i p2", "have b': \"eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\""], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> eval i p2\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2", "using assms ih1 ih2 change_tv_injection the_inv_f_f"], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> eval i p2\n  inj f\n  eval (change_int f i) p1 = change_tv f (eval i p1)\n  eval (change_int f i) p2 = change_tv f (eval i p2)\n  inj ?f \\<Longrightarrow> inj (change_tv ?f)\n  inj ?f \\<Longrightarrow> the_inv ?f (?f ?x) = ?x\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2", "by metis"], ["proof (state)\nthis:\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n\ngoal (1 subgoal):\n 1. eval i p1 \\<noteq> eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "show \"eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "proof (cases \"eval i p1 = Det True\")"], ["proof (state)\ngoal (2 subgoals):\n 1. eval i p1 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\n 2. eval i p1 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "assume a: \"eval i p1 = Det True\""], ["proof (state)\nthis:\n  eval i p1 = Det True\n\ngoal (2 subgoals):\n 1. eval i p1 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\n 2. eval i p1 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "from a a'"], ["proof (chain)\npicking this:\n  eval i p1 = Det True\n  eval i p1 \\<noteq> eval i p2", "have \"eval i (Con' p1 p2) = eval i p2\""], ["proof (prove)\nusing this:\n  eval i p1 = Det True\n  eval i p1 \\<noteq> eval i p2\n\ngoal (1 subgoal):\n 1. eval i (Con' p1 p2) = eval i p2", "by auto"], ["proof (state)\nthis:\n  eval i (Con' p1 p2) = eval i p2\n\ngoal (2 subgoals):\n 1. eval i p1 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\n 2. eval i p1 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "then"], ["proof (chain)\npicking this:\n  eval i (Con' p1 p2) = eval i p2", "have c: \"change_tv f (eval i (Con' p1 p2)) = change_tv f (eval i p2)\""], ["proof (prove)\nusing this:\n  eval i (Con' p1 p2) = eval i p2\n\ngoal (1 subgoal):\n 1. change_tv f (eval i (Con' p1 p2)) = change_tv f (eval i p2)", "by auto"], ["proof (state)\nthis:\n  change_tv f (eval i (Con' p1 p2)) = change_tv f (eval i p2)\n\ngoal (2 subgoals):\n 1. eval i p1 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\n 2. eval i p1 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "from a"], ["proof (chain)\npicking this:\n  eval i p1 = Det True", "have b: \"eval (change_int f i) p1 = Det True\""], ["proof (prove)\nusing this:\n  eval i p1 = Det True\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 = Det True", "using ih1"], ["proof (prove)\nusing this:\n  eval i p1 = Det True\n  eval (change_int f i) p1 = change_tv f (eval i p1)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 = Det True", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) p1 = Det True\n\ngoal (2 subgoals):\n 1. eval i p1 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\n 2. eval i p1 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "from b b'"], ["proof (chain)\npicking this:\n  eval (change_int f i) p1 = Det True\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2", "have \"eval (change_int f i) (Con' p1 p2) = eval (change_int f i) p2\""], ["proof (prove)\nusing this:\n  eval (change_int f i) p1 = Det True\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Con' p1 p2) = eval (change_int f i) p2", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) (Con' p1 p2) = eval (change_int f i) p2\n\ngoal (2 subgoals):\n 1. eval i p1 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\n 2. eval i p1 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "then"], ["proof (chain)\npicking this:\n  eval (change_int f i) (Con' p1 p2) = eval (change_int f i) p2", "show \"eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\""], ["proof (prove)\nusing this:\n  eval (change_int f i) (Con' p1 p2) = eval (change_int f i) p2\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "using c ih2"], ["proof (prove)\nusing this:\n  eval (change_int f i) (Con' p1 p2) = eval (change_int f i) p2\n  change_tv f (eval i (Con' p1 p2)) = change_tv f (eval i p2)\n  eval (change_int f i) p2 = change_tv f (eval i p2)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\n\ngoal (1 subgoal):\n 1. eval i p1 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. eval i p1 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "assume a'': \"eval i p1 \\<noteq> Det True\""], ["proof (state)\nthis:\n  eval i p1 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval i p1 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "from a''"], ["proof (chain)\npicking this:\n  eval i p1 \\<noteq> Det True", "have b'': \"eval (change_int f i) p1 \\<noteq> Det True\""], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 \\<noteq> Det True", "using assms ih1 ih2 change_tv_injection the_inv_f_f change_tv.simps"], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> Det True\n  inj f\n  eval (change_int f i) p1 = change_tv f (eval i p1)\n  eval (change_int f i) p2 = change_tv f (eval i p2)\n  inj ?f \\<Longrightarrow> inj (change_tv ?f)\n  inj ?f \\<Longrightarrow> the_inv ?f (?f ?x) = ?x\n  change_tv ?f (Det ?b) = Det ?b\n  change_tv ?f (Indet ?n) = Indet (?f ?n)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 \\<noteq> Det True", "by metis"], ["proof (state)\nthis:\n  eval (change_int f i) p1 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval i p1 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "show \"eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "proof (cases \"eval i p2 = Det True\")"], ["proof (state)\ngoal (2 subgoals):\n 1. eval i p2 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\n 2. eval i p2 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "assume a: \"eval i p2 = Det True\""], ["proof (state)\nthis:\n  eval i p2 = Det True\n\ngoal (2 subgoals):\n 1. eval i p2 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\n 2. eval i p2 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "from a a' a''"], ["proof (chain)\npicking this:\n  eval i p2 = Det True\n  eval i p1 \\<noteq> eval i p2\n  eval i p1 \\<noteq> Det True", "have \"eval i (Con' p1 p2) = eval i p1\""], ["proof (prove)\nusing this:\n  eval i p2 = Det True\n  eval i p1 \\<noteq> eval i p2\n  eval i p1 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval i (Con' p1 p2) = eval i p1", "by auto"], ["proof (state)\nthis:\n  eval i (Con' p1 p2) = eval i p1\n\ngoal (2 subgoals):\n 1. eval i p2 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\n 2. eval i p2 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "then"], ["proof (chain)\npicking this:\n  eval i (Con' p1 p2) = eval i p1", "have c: \"change_tv f (eval i (Con' p1 p2)) = change_tv f (eval i p1)\""], ["proof (prove)\nusing this:\n  eval i (Con' p1 p2) = eval i p1\n\ngoal (1 subgoal):\n 1. change_tv f (eval i (Con' p1 p2)) = change_tv f (eval i p1)", "by auto"], ["proof (state)\nthis:\n  change_tv f (eval i (Con' p1 p2)) = change_tv f (eval i p1)\n\ngoal (2 subgoals):\n 1. eval i p2 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\n 2. eval i p2 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "from a"], ["proof (chain)\npicking this:\n  eval i p2 = Det True", "have b: \"eval (change_int f i) p2 = Det True\""], ["proof (prove)\nusing this:\n  eval i p2 = Det True\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p2 = Det True", "using ih2"], ["proof (prove)\nusing this:\n  eval i p2 = Det True\n  eval (change_int f i) p2 = change_tv f (eval i p2)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p2 = Det True", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) p2 = Det True\n\ngoal (2 subgoals):\n 1. eval i p2 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\n 2. eval i p2 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "from b b' b''"], ["proof (chain)\npicking this:\n  eval (change_int f i) p2 = Det True\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n  eval (change_int f i) p1 \\<noteq> Det True", "have \"eval (change_int f i) (Con' p1 p2) = eval (change_int f i) p1\""], ["proof (prove)\nusing this:\n  eval (change_int f i) p2 = Det True\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n  eval (change_int f i) p1 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Con' p1 p2) = eval (change_int f i) p1", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) (Con' p1 p2) = eval (change_int f i) p1\n\ngoal (2 subgoals):\n 1. eval i p2 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\n 2. eval i p2 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "then"], ["proof (chain)\npicking this:\n  eval (change_int f i) (Con' p1 p2) = eval (change_int f i) p1", "show \"eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\""], ["proof (prove)\nusing this:\n  eval (change_int f i) (Con' p1 p2) = eval (change_int f i) p1\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "using c ih1"], ["proof (prove)\nusing this:\n  eval (change_int f i) (Con' p1 p2) = eval (change_int f i) p1\n  change_tv f (eval i (Con' p1 p2)) = change_tv f (eval i p1)\n  eval (change_int f i) p1 = change_tv f (eval i p1)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\n\ngoal (1 subgoal):\n 1. eval i p2 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. eval i p2 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "assume a''': \"eval i p2 \\<noteq> Det True\""], ["proof (state)\nthis:\n  eval i p2 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval i p2 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "from a' a'' a'''"], ["proof (chain)\npicking this:\n  eval i p1 \\<noteq> eval i p2\n  eval i p1 \\<noteq> Det True\n  eval i p2 \\<noteq> Det True", "have \"eval i (Con' p1 p2) = Det False\""], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> eval i p2\n  eval i p1 \\<noteq> Det True\n  eval i p2 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval i (Con' p1 p2) = Det False", "by auto"], ["proof (state)\nthis:\n  eval i (Con' p1 p2) = Det False\n\ngoal (1 subgoal):\n 1. eval i p2 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "then"], ["proof (chain)\npicking this:\n  eval i (Con' p1 p2) = Det False", "have c: \"change_tv f (eval i (Con' p1 p2)) = Det False\""], ["proof (prove)\nusing this:\n  eval i (Con' p1 p2) = Det False\n\ngoal (1 subgoal):\n 1. change_tv f (eval i (Con' p1 p2)) = Det False", "by auto"], ["proof (state)\nthis:\n  change_tv f (eval i (Con' p1 p2)) = Det False\n\ngoal (1 subgoal):\n 1. eval i p2 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "from a'''"], ["proof (chain)\npicking this:\n  eval i p2 \\<noteq> Det True", "have b''': \"eval (change_int f i) p2 \\<noteq> Det True\""], ["proof (prove)\nusing this:\n  eval i p2 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p2 \\<noteq> Det True", "using assms ih1 ih2 change_tv_injection the_inv_f_f change_tv.simps"], ["proof (prove)\nusing this:\n  eval i p2 \\<noteq> Det True\n  inj f\n  eval (change_int f i) p1 = change_tv f (eval i p1)\n  eval (change_int f i) p2 = change_tv f (eval i p2)\n  inj ?f \\<Longrightarrow> inj (change_tv ?f)\n  inj ?f \\<Longrightarrow> the_inv ?f (?f ?x) = ?x\n  change_tv ?f (Det ?b) = Det ?b\n  change_tv ?f (Indet ?n) = Indet (?f ?n)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p2 \\<noteq> Det True", "by metis"], ["proof (state)\nthis:\n  eval (change_int f i) p2 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval i p2 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "from b' b'' b'''"], ["proof (chain)\npicking this:\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n  eval (change_int f i) p1 \\<noteq> Det True\n  eval (change_int f i) p2 \\<noteq> Det True", "have \"eval (change_int f i) (Con' p1 p2) = Det False\""], ["proof (prove)\nusing this:\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n  eval (change_int f i) p1 \\<noteq> Det True\n  eval (change_int f i) p2 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Con' p1 p2) = Det False", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) (Con' p1 p2) = Det False\n\ngoal (1 subgoal):\n 1. eval i p2 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "then"], ["proof (chain)\npicking this:\n  eval (change_int f i) (Con' p1 p2) = Det False", "show \"eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\""], ["proof (prove)\nusing this:\n  eval (change_int f i) (Con' p1 p2) = Det False\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "using c"], ["proof (prove)\nusing this:\n  eval (change_int f i) (Con' p1 p2) = Det False\n  change_tv f (eval i (Con' p1 p2)) = Det False\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (change_int f i) (Con' p1 p2) = change_tv f (eval i (Con' p1 p2))\n\ngoal (4 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)\n 3. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql p1 p2) =\n                         change_tv f (eval i (Eql p1 p2))\n 4. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql' p1 p2) =\n                         change_tv f (eval i (Eql' p1 p2))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)\n 3. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql p1 p2) =\n                         change_tv f (eval i (Eql p1 p2))\n 4. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql' p1 p2) =\n                         change_tv f (eval i (Eql' p1 p2))", "fix p1 p2"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)\n 3. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql p1 p2) =\n                         change_tv f (eval i (Eql p1 p2))\n 4. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql' p1 p2) =\n                         change_tv f (eval i (Eql' p1 p2))", "assume ih1: \"eval (change_int f i) p1 = change_tv f (eval i p1)\""], ["proof (state)\nthis:\n  eval (change_int f i) p1 = change_tv f (eval i p1)\n\ngoal (4 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)\n 3. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql p1 p2) =\n                         change_tv f (eval i (Eql p1 p2))\n 4. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql' p1 p2) =\n                         change_tv f (eval i (Eql' p1 p2))", "assume ih2: \"eval (change_int f i) p2 = change_tv f (eval i p2)\""], ["proof (state)\nthis:\n  eval (change_int f i) p2 = change_tv f (eval i p2)\n\ngoal (4 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)\n 3. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql p1 p2) =\n                         change_tv f (eval i (Eql p1 p2))\n 4. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql' p1 p2) =\n                         change_tv f (eval i (Eql' p1 p2))", "have \"Det (eval (change_int f i) p1 = eval (change_int f i) p2) =\n      Det (change_tv f (eval i p1) = change_tv f (eval i p2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Det (eval (change_int f i) p1 = eval (change_int f i) p2) =\n    Det (change_tv f (eval i p1) = change_tv f (eval i p2))", "using ih1 ih2"], ["proof (prove)\nusing this:\n  eval (change_int f i) p1 = change_tv f (eval i p1)\n  eval (change_int f i) p2 = change_tv f (eval i p2)\n\ngoal (1 subgoal):\n 1. Det (eval (change_int f i) p1 = eval (change_int f i) p2) =\n    Det (change_tv f (eval i p1) = change_tv f (eval i p2))", "by simp"], ["proof (state)\nthis:\n  Det (eval (change_int f i) p1 = eval (change_int f i) p2) =\n  Det (change_tv f (eval i p1) = change_tv f (eval i p2))\n\ngoal (4 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)\n 3. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql p1 p2) =\n                         change_tv f (eval i (Eql p1 p2))\n 4. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql' p1 p2) =\n                         change_tv f (eval i (Eql' p1 p2))", "also"], ["proof (state)\nthis:\n  Det (eval (change_int f i) p1 = eval (change_int f i) p2) =\n  Det (change_tv f (eval i p1) = change_tv f (eval i p2))\n\ngoal (4 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)\n 3. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql p1 p2) =\n                         change_tv f (eval i (Eql p1 p2))\n 4. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql' p1 p2) =\n                         change_tv f (eval i (Eql' p1 p2))", "have \"... = Det ((eval i p1) = (eval i p2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Det (change_tv f (eval i p1) = change_tv f (eval i p2)) =\n    Det (eval i p1 = eval i p2)", "using assms change_tv_injection"], ["proof (prove)\nusing this:\n  inj f\n  inj ?f \\<Longrightarrow> inj (change_tv ?f)\n\ngoal (1 subgoal):\n 1. Det (change_tv f (eval i p1) = change_tv f (eval i p2)) =\n    Det (eval i p1 = eval i p2)", "by (simp add: inj_eq)"], ["proof (state)\nthis:\n  Det (change_tv f (eval i p1) = change_tv f (eval i p2)) =\n  Det (eval i p1 = eval i p2)\n\ngoal (4 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)\n 3. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql p1 p2) =\n                         change_tv f (eval i (Eql p1 p2))\n 4. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql' p1 p2) =\n                         change_tv f (eval i (Eql' p1 p2))", "also"], ["proof (state)\nthis:\n  Det (change_tv f (eval i p1) = change_tv f (eval i p2)) =\n  Det (eval i p1 = eval i p2)\n\ngoal (4 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)\n 3. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql p1 p2) =\n                         change_tv f (eval i (Eql p1 p2))\n 4. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql' p1 p2) =\n                         change_tv f (eval i (Eql' p1 p2))", "have \"... = change_tv f (Det (eval i p1 = eval i p2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Det (eval i p1 = eval i p2) = change_tv f (Det (eval i p1 = eval i p2))", "by simp"], ["proof (state)\nthis:\n  Det (eval i p1 = eval i p2) = change_tv f (Det (eval i p1 = eval i p2))\n\ngoal (4 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)\n 3. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql p1 p2) =\n                         change_tv f (eval i (Eql p1 p2))\n 4. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql' p1 p2) =\n                         change_tv f (eval i (Eql' p1 p2))", "finally"], ["proof (chain)\npicking this:\n  Det (eval (change_int f i) p1 = eval (change_int f i) p2) =\n  change_tv f (Det (eval i p1 = eval i p2))", "show \"eval (change_int f i) (Eql p1 p2) = change_tv f (eval i (Eql p1 p2))\""], ["proof (prove)\nusing this:\n  Det (eval (change_int f i) p1 = eval (change_int f i) p2) =\n  change_tv f (Det (eval i p1 = eval i p2))\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql p1 p2) = change_tv f (eval i (Eql p1 p2))", "by simp"], ["proof (state)\nthis:\n  eval (change_int f i) (Eql p1 p2) = change_tv f (eval i (Eql p1 p2))\n\ngoal (3 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)\n 3. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql' p1 p2) =\n                         change_tv f (eval i (Eql' p1 p2))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)\n 3. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql' p1 p2) =\n                         change_tv f (eval i (Eql' p1 p2))", "fix p1 p2"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)\n 3. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql' p1 p2) =\n                         change_tv f (eval i (Eql' p1 p2))", "assume ih1: \"eval (change_int f i) p1 = change_tv f (eval i p1)\""], ["proof (state)\nthis:\n  eval (change_int f i) p1 = change_tv f (eval i p1)\n\ngoal (3 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)\n 3. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql' p1 p2) =\n                         change_tv f (eval i (Eql' p1 p2))", "assume ih2: \"eval (change_int f i) p2 = change_tv f (eval i p2)\""], ["proof (state)\nthis:\n  eval (change_int f i) p2 = change_tv f (eval i p2)\n\ngoal (3 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)\n 3. \\<And>p1 p2.\n       \\<lbrakk>eval (change_int f i) p1 = change_tv f (eval i p1);\n        eval (change_int f i) p2 = change_tv f (eval i p2)\\<rbrakk>\n       \\<Longrightarrow> eval (change_int f i) (Eql' p1 p2) =\n                         change_tv f (eval i (Eql' p1 p2))", "show \"eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "proof (cases \"eval i p1 = eval i p2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. eval i p1 = eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p1 \\<noteq> eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "assume a: \"eval i p1 = eval i p2\""], ["proof (state)\nthis:\n  eval i p1 = eval i p2\n\ngoal (2 subgoals):\n 1. eval i p1 = eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p1 \\<noteq> eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "then"], ["proof (chain)\npicking this:\n  eval i p1 = eval i p2", "have yes: \"eval i (Eql' p1 p2) = Det True\""], ["proof (prove)\nusing this:\n  eval i p1 = eval i p2\n\ngoal (1 subgoal):\n 1. eval i (Eql' p1 p2) = Det True", "by auto"], ["proof (state)\nthis:\n  eval i (Eql' p1 p2) = Det True\n\ngoal (2 subgoals):\n 1. eval i p1 = eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p1 \\<noteq> eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from a"], ["proof (chain)\npicking this:\n  eval i p1 = eval i p2", "have \"change_tv f (eval i p1) = change_tv f (eval i p2)\""], ["proof (prove)\nusing this:\n  eval i p1 = eval i p2\n\ngoal (1 subgoal):\n 1. change_tv f (eval i p1) = change_tv f (eval i p2)", "by auto"], ["proof (state)\nthis:\n  change_tv f (eval i p1) = change_tv f (eval i p2)\n\ngoal (2 subgoals):\n 1. eval i p1 = eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p1 \\<noteq> eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "then"], ["proof (chain)\npicking this:\n  change_tv f (eval i p1) = change_tv f (eval i p2)", "have \"eval (change_int f i) p1 = eval (change_int f i) p2\""], ["proof (prove)\nusing this:\n  change_tv f (eval i p1) = change_tv f (eval i p2)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 = eval (change_int f i) p2", "using ih1 ih2"], ["proof (prove)\nusing this:\n  change_tv f (eval i p1) = change_tv f (eval i p2)\n  eval (change_int f i) p1 = change_tv f (eval i p1)\n  eval (change_int f i) p2 = change_tv f (eval i p2)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 = eval (change_int f i) p2", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) p1 = eval (change_int f i) p2\n\ngoal (2 subgoals):\n 1. eval i p1 = eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p1 \\<noteq> eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "then"], ["proof (chain)\npicking this:\n  eval (change_int f i) p1 = eval (change_int f i) p2", "have \"eval (change_int f i) (Eql' p1 p2) = Det True\""], ["proof (prove)\nusing this:\n  eval (change_int f i) p1 = eval (change_int f i) p2\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = Det True", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) (Eql' p1 p2) = Det True\n\ngoal (2 subgoals):\n 1. eval i p1 = eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p1 \\<noteq> eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "then"], ["proof (chain)\npicking this:\n  eval (change_int f i) (Eql' p1 p2) = Det True", "show \"eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\""], ["proof (prove)\nusing this:\n  eval (change_int f i) (Eql' p1 p2) = Det True\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "using yes ih1"], ["proof (prove)\nusing this:\n  eval (change_int f i) (Eql' p1 p2) = Det True\n  eval i (Eql' p1 p2) = Det True\n  eval (change_int f i) p1 = change_tv f (eval i p1)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n\ngoal (1 subgoal):\n 1. eval i p1 \\<noteq> eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. eval i p1 \\<noteq> eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "assume a': \"eval i p1 \\<noteq> eval i p2\""], ["proof (state)\nthis:\n  eval i p1 \\<noteq> eval i p2\n\ngoal (1 subgoal):\n 1. eval i p1 \\<noteq> eval i p2 \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "show \"eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "proof (cases \"eval i p1 = Det True\")"], ["proof (state)\ngoal (2 subgoals):\n 1. eval i p1 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p1 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "assume a: \"eval i p1 = Det True\""], ["proof (state)\nthis:\n  eval i p1 = Det True\n\ngoal (2 subgoals):\n 1. eval i p1 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p1 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from a a'"], ["proof (chain)\npicking this:\n  eval i p1 = Det True\n  eval i p1 \\<noteq> eval i p2", "have yes: \"eval i (Eql' p1 p2) = eval i p2\""], ["proof (prove)\nusing this:\n  eval i p1 = Det True\n  eval i p1 \\<noteq> eval i p2\n\ngoal (1 subgoal):\n 1. eval i (Eql' p1 p2) = eval i p2", "by auto"], ["proof (state)\nthis:\n  eval i (Eql' p1 p2) = eval i p2\n\ngoal (2 subgoals):\n 1. eval i p1 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p1 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from a"], ["proof (chain)\npicking this:\n  eval i p1 = Det True", "have \"change_tv f (eval i p1) = Det True\""], ["proof (prove)\nusing this:\n  eval i p1 = Det True\n\ngoal (1 subgoal):\n 1. change_tv f (eval i p1) = Det True", "by auto"], ["proof (state)\nthis:\n  change_tv f (eval i p1) = Det True\n\ngoal (2 subgoals):\n 1. eval i p1 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p1 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "then"], ["proof (chain)\npicking this:\n  change_tv f (eval i p1) = Det True", "have b: \"eval (change_int f i) p1 = Det True\""], ["proof (prove)\nusing this:\n  change_tv f (eval i p1) = Det True\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 = Det True", "using ih1"], ["proof (prove)\nusing this:\n  change_tv f (eval i p1) = Det True\n  eval (change_int f i) p1 = change_tv f (eval i p1)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 = Det True", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) p1 = Det True\n\ngoal (2 subgoals):\n 1. eval i p1 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p1 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from a'"], ["proof (chain)\npicking this:\n  eval i p1 \\<noteq> eval i p2", "have b': \"eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\""], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> eval i p2\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2", "using assms ih1 ih2 change_tv_injection the_inv_f_f change_tv.simps"], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> eval i p2\n  inj f\n  eval (change_int f i) p1 = change_tv f (eval i p1)\n  eval (change_int f i) p2 = change_tv f (eval i p2)\n  inj ?f \\<Longrightarrow> inj (change_tv ?f)\n  inj ?f \\<Longrightarrow> the_inv ?f (?f ?x) = ?x\n  change_tv ?f (Det ?b) = Det ?b\n  change_tv ?f (Indet ?n) = Indet (?f ?n)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2", "by metis"], ["proof (state)\nthis:\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n\ngoal (2 subgoals):\n 1. eval i p1 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p1 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from b b'"], ["proof (chain)\npicking this:\n  eval (change_int f i) p1 = Det True\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2", "have \"eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) p2\""], ["proof (prove)\nusing this:\n  eval (change_int f i) p1 = Det True\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) p2", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) p2\n\ngoal (2 subgoals):\n 1. eval i p1 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p1 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "then"], ["proof (chain)\npicking this:\n  eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) p2", "show \"eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\""], ["proof (prove)\nusing this:\n  eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) p2\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "using ih2 yes"], ["proof (prove)\nusing this:\n  eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) p2\n  eval (change_int f i) p2 = change_tv f (eval i p2)\n  eval i (Eql' p1 p2) = eval i p2\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n\ngoal (1 subgoal):\n 1. eval i p1 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. eval i p1 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "assume a'': \"eval i p1 \\<noteq> Det True\""], ["proof (state)\nthis:\n  eval i p1 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval i p1 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "show \"eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "proof (cases \"eval i p2 = Det True\")"], ["proof (state)\ngoal (2 subgoals):\n 1. eval i p2 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p2 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "assume a: \"eval i p2 = Det True\""], ["proof (state)\nthis:\n  eval i p2 = Det True\n\ngoal (2 subgoals):\n 1. eval i p2 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p2 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from a a' a''"], ["proof (chain)\npicking this:\n  eval i p2 = Det True\n  eval i p1 \\<noteq> eval i p2\n  eval i p1 \\<noteq> Det True", "have yes: \"eval i (Eql' p1 p2) = eval i p1\""], ["proof (prove)\nusing this:\n  eval i p2 = Det True\n  eval i p1 \\<noteq> eval i p2\n  eval i p1 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval i (Eql' p1 p2) = eval i p1", "using eval_equality[of i p1 p2]"], ["proof (prove)\nusing this:\n  eval i p2 = Det True\n  eval i p1 \\<noteq> eval i p2\n  eval i p1 \\<noteq> Det True\n  eval i (Eql' p1 p2) =\n  (if eval i p1 = eval i p2 then Det True\n   else if eval i p1 = Det True then eval i p2\n        else if eval i p2 = Det True then eval i p1\n             else if eval i p1 = Det False then eval i (Neg' p2)\n                  else if eval i p2 = Det False then eval i (Neg' p1)\n                       else Det False)\n\ngoal (1 subgoal):\n 1. eval i (Eql' p1 p2) = eval i p1", "by auto"], ["proof (state)\nthis:\n  eval i (Eql' p1 p2) = eval i p1\n\ngoal (2 subgoals):\n 1. eval i p2 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p2 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from a"], ["proof (chain)\npicking this:\n  eval i p2 = Det True", "have \"change_tv f (eval i p2) = Det True\""], ["proof (prove)\nusing this:\n  eval i p2 = Det True\n\ngoal (1 subgoal):\n 1. change_tv f (eval i p2) = Det True", "by auto"], ["proof (state)\nthis:\n  change_tv f (eval i p2) = Det True\n\ngoal (2 subgoals):\n 1. eval i p2 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p2 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "then"], ["proof (chain)\npicking this:\n  change_tv f (eval i p2) = Det True", "have b: \"eval (change_int f i) p2 = Det True\""], ["proof (prove)\nusing this:\n  change_tv f (eval i p2) = Det True\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p2 = Det True", "using ih2"], ["proof (prove)\nusing this:\n  change_tv f (eval i p2) = Det True\n  eval (change_int f i) p2 = change_tv f (eval i p2)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p2 = Det True", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) p2 = Det True\n\ngoal (2 subgoals):\n 1. eval i p2 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p2 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from a'"], ["proof (chain)\npicking this:\n  eval i p1 \\<noteq> eval i p2", "have b': \"eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\""], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> eval i p2\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2", "using assms ih1 ih2 change_tv_injection the_inv_f_f change_tv.simps"], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> eval i p2\n  inj f\n  eval (change_int f i) p1 = change_tv f (eval i p1)\n  eval (change_int f i) p2 = change_tv f (eval i p2)\n  inj ?f \\<Longrightarrow> inj (change_tv ?f)\n  inj ?f \\<Longrightarrow> the_inv ?f (?f ?x) = ?x\n  change_tv ?f (Det ?b) = Det ?b\n  change_tv ?f (Indet ?n) = Indet (?f ?n)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2", "by metis"], ["proof (state)\nthis:\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n\ngoal (2 subgoals):\n 1. eval i p2 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p2 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from a''"], ["proof (chain)\npicking this:\n  eval i p1 \\<noteq> Det True", "have b'': \"eval (change_int f i) p1 \\<noteq> Det True\""], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 \\<noteq> Det True", "using b b'"], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> Det True\n  eval (change_int f i) p2 = Det True\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 \\<noteq> Det True", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) p1 \\<noteq> Det True\n\ngoal (2 subgoals):\n 1. eval i p2 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p2 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from b b' b''"], ["proof (chain)\npicking this:\n  eval (change_int f i) p2 = Det True\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n  eval (change_int f i) p1 \\<noteq> Det True", "have \"eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) p1\""], ["proof (prove)\nusing this:\n  eval (change_int f i) p2 = Det True\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n  eval (change_int f i) p1 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) p1", "using eval_equality[of \"change_int f i\" p1 p2]"], ["proof (prove)\nusing this:\n  eval (change_int f i) p2 = Det True\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n  eval (change_int f i) p1 \\<noteq> Det True\n  eval (change_int f i) (Eql' p1 p2) =\n  (if eval (change_int f i) p1 = eval (change_int f i) p2 then Det True\n   else if eval (change_int f i) p1 = Det True then eval (change_int f i) p2\n        else if eval (change_int f i) p2 = Det True\n             then eval (change_int f i) p1\n             else if eval (change_int f i) p1 = Det False\n                  then eval (change_int f i) (Neg' p2)\n                  else if eval (change_int f i) p2 = Det False\n                       then eval (change_int f i) (Neg' p1) else Det False)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) p1", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) p1\n\ngoal (2 subgoals):\n 1. eval i p2 = Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p2 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "then"], ["proof (chain)\npicking this:\n  eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) p1", "show \"eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\""], ["proof (prove)\nusing this:\n  eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) p1\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "using ih1 yes"], ["proof (prove)\nusing this:\n  eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) p1\n  eval (change_int f i) p1 = change_tv f (eval i p1)\n  eval i (Eql' p1 p2) = eval i p1\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n\ngoal (1 subgoal):\n 1. eval i p2 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. eval i p2 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "assume a''': \"eval i p2 \\<noteq> Det True\""], ["proof (state)\nthis:\n  eval i p2 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval i p2 \\<noteq> Det True \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "show \"eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "proof (cases \"eval i p1 = Det False\")"], ["proof (state)\ngoal (2 subgoals):\n 1. eval i p1 = Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p1 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "assume a: \"eval i p1 = Det False\""], ["proof (state)\nthis:\n  eval i p1 = Det False\n\ngoal (2 subgoals):\n 1. eval i p1 = Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p1 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from a a' a'' a'''"], ["proof (chain)\npicking this:\n  eval i p1 = Det False\n  eval i p1 \\<noteq> eval i p2\n  eval i p1 \\<noteq> Det True\n  eval i p2 \\<noteq> Det True", "have yes: \"eval i (Eql' p1 p2) = eval i (Neg' p2)\""], ["proof (prove)\nusing this:\n  eval i p1 = Det False\n  eval i p1 \\<noteq> eval i p2\n  eval i p1 \\<noteq> Det True\n  eval i p2 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval i (Eql' p1 p2) = eval i (Neg' p2)", "using eval_equality[of i p1 p2]"], ["proof (prove)\nusing this:\n  eval i p1 = Det False\n  eval i p1 \\<noteq> eval i p2\n  eval i p1 \\<noteq> Det True\n  eval i p2 \\<noteq> Det True\n  eval i (Eql' p1 p2) =\n  (if eval i p1 = eval i p2 then Det True\n   else if eval i p1 = Det True then eval i p2\n        else if eval i p2 = Det True then eval i p1\n             else if eval i p1 = Det False then eval i (Neg' p2)\n                  else if eval i p2 = Det False then eval i (Neg' p1)\n                       else Det False)\n\ngoal (1 subgoal):\n 1. eval i (Eql' p1 p2) = eval i (Neg' p2)", "by auto"], ["proof (state)\nthis:\n  eval i (Eql' p1 p2) = eval i (Neg' p2)\n\ngoal (2 subgoals):\n 1. eval i p1 = Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p1 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from a"], ["proof (chain)\npicking this:\n  eval i p1 = Det False", "have \"change_tv f (eval i p1) = Det False\""], ["proof (prove)\nusing this:\n  eval i p1 = Det False\n\ngoal (1 subgoal):\n 1. change_tv f (eval i p1) = Det False", "by auto"], ["proof (state)\nthis:\n  change_tv f (eval i p1) = Det False\n\ngoal (2 subgoals):\n 1. eval i p1 = Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p1 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "then"], ["proof (chain)\npicking this:\n  change_tv f (eval i p1) = Det False", "have b: \"eval (change_int f i) p1 = Det False\""], ["proof (prove)\nusing this:\n  change_tv f (eval i p1) = Det False\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 = Det False", "using ih1"], ["proof (prove)\nusing this:\n  change_tv f (eval i p1) = Det False\n  eval (change_int f i) p1 = change_tv f (eval i p1)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 = Det False", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) p1 = Det False\n\ngoal (2 subgoals):\n 1. eval i p1 = Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p1 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from a'"], ["proof (chain)\npicking this:\n  eval i p1 \\<noteq> eval i p2", "have b': \"eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\""], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> eval i p2\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2", "using assms ih1 ih2 change_tv_injection the_inv_f_f change_tv.simps"], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> eval i p2\n  inj f\n  eval (change_int f i) p1 = change_tv f (eval i p1)\n  eval (change_int f i) p2 = change_tv f (eval i p2)\n  inj ?f \\<Longrightarrow> inj (change_tv ?f)\n  inj ?f \\<Longrightarrow> the_inv ?f (?f ?x) = ?x\n  change_tv ?f (Det ?b) = Det ?b\n  change_tv ?f (Indet ?n) = Indet (?f ?n)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2", "by metis"], ["proof (state)\nthis:\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n\ngoal (2 subgoals):\n 1. eval i p1 = Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p1 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from a''"], ["proof (chain)\npicking this:\n  eval i p1 \\<noteq> Det True", "have b'': \"eval (change_int f i) p1 \\<noteq> Det True\""], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 \\<noteq> Det True", "using b b'"], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> Det True\n  eval (change_int f i) p1 = Det False\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 \\<noteq> Det True", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) p1 \\<noteq> Det True\n\ngoal (2 subgoals):\n 1. eval i p1 = Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p1 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from a'''"], ["proof (chain)\npicking this:\n  eval i p2 \\<noteq> Det True", "have b''': \"eval (change_int f i) p2 \\<noteq> Det True\""], ["proof (prove)\nusing this:\n  eval i p2 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p2 \\<noteq> Det True", "using b b' b''"], ["proof (prove)\nusing this:\n  eval i p2 \\<noteq> Det True\n  eval (change_int f i) p1 = Det False\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n  eval (change_int f i) p1 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p2 \\<noteq> Det True", "by (metis assms change_tv.simps(1) change_tv_injection inj_eq ih2)"], ["proof (state)\nthis:\n  eval (change_int f i) p2 \\<noteq> Det True\n\ngoal (2 subgoals):\n 1. eval i p1 = Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p1 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from b b' b'' b'''"], ["proof (chain)\npicking this:\n  eval (change_int f i) p1 = Det False\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n  eval (change_int f i) p1 \\<noteq> Det True\n  eval (change_int f i) p2 \\<noteq> Det True", "have \"eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) (Neg' p2)\""], ["proof (prove)\nusing this:\n  eval (change_int f i) p1 = Det False\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n  eval (change_int f i) p1 \\<noteq> Det True\n  eval (change_int f i) p2 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) (Neg' p2)", "using eval_equality[of \"change_int f i\" p1 p2]"], ["proof (prove)\nusing this:\n  eval (change_int f i) p1 = Det False\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n  eval (change_int f i) p1 \\<noteq> Det True\n  eval (change_int f i) p2 \\<noteq> Det True\n  eval (change_int f i) (Eql' p1 p2) =\n  (if eval (change_int f i) p1 = eval (change_int f i) p2 then Det True\n   else if eval (change_int f i) p1 = Det True then eval (change_int f i) p2\n        else if eval (change_int f i) p2 = Det True\n             then eval (change_int f i) p1\n             else if eval (change_int f i) p1 = Det False\n                  then eval (change_int f i) (Neg' p2)\n                  else if eval (change_int f i) p2 = Det False\n                       then eval (change_int f i) (Neg' p1) else Det False)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) (Neg' p2)", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) (Neg' p2)\n\ngoal (2 subgoals):\n 1. eval i p1 = Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p1 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "then"], ["proof (chain)\npicking this:\n  eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) (Neg' p2)", "show \"eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\""], ["proof (prove)\nusing this:\n  eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) (Neg' p2)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "using ih2 yes a a' a''' b b' b''' eval_negation"], ["proof (prove)\nusing this:\n  eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) (Neg' p2)\n  eval (change_int f i) p2 = change_tv f (eval i p2)\n  eval i (Eql' p1 p2) = eval i (Neg' p2)\n  eval i p1 = Det False\n  eval i p1 \\<noteq> eval i p2\n  eval i p2 \\<noteq> Det True\n  eval (change_int f i) p1 = Det False\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n  eval (change_int f i) p2 \\<noteq> Det True\n  eval ?i (Neg' ?p) =\n  (if eval ?i ?p = Det False then Det True\n   else if eval ?i ?p = Det True then Det False else eval ?i ?p)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "by metis"], ["proof (state)\nthis:\n  eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n\ngoal (1 subgoal):\n 1. eval i p1 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. eval i p1 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "assume a'''': \"eval i p1 \\<noteq> Det False\""], ["proof (state)\nthis:\n  eval i p1 \\<noteq> Det False\n\ngoal (1 subgoal):\n 1. eval i p1 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "show \"eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "proof (cases \"eval i p2 = Det False\")"], ["proof (state)\ngoal (2 subgoals):\n 1. eval i p2 = Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p2 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "assume a: \"eval i p2 = Det False\""], ["proof (state)\nthis:\n  eval i p2 = Det False\n\ngoal (2 subgoals):\n 1. eval i p2 = Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p2 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from a a' a'' a''' a''''"], ["proof (chain)\npicking this:\n  eval i p2 = Det False\n  eval i p1 \\<noteq> eval i p2\n  eval i p1 \\<noteq> Det True\n  eval i p2 \\<noteq> Det True\n  eval i p1 \\<noteq> Det False", "have yes: \"eval i (Eql' p1 p2) = eval i (Neg' p1)\""], ["proof (prove)\nusing this:\n  eval i p2 = Det False\n  eval i p1 \\<noteq> eval i p2\n  eval i p1 \\<noteq> Det True\n  eval i p2 \\<noteq> Det True\n  eval i p1 \\<noteq> Det False\n\ngoal (1 subgoal):\n 1. eval i (Eql' p1 p2) = eval i (Neg' p1)", "using eval_equality[of i p1 p2]"], ["proof (prove)\nusing this:\n  eval i p2 = Det False\n  eval i p1 \\<noteq> eval i p2\n  eval i p1 \\<noteq> Det True\n  eval i p2 \\<noteq> Det True\n  eval i p1 \\<noteq> Det False\n  eval i (Eql' p1 p2) =\n  (if eval i p1 = eval i p2 then Det True\n   else if eval i p1 = Det True then eval i p2\n        else if eval i p2 = Det True then eval i p1\n             else if eval i p1 = Det False then eval i (Neg' p2)\n                  else if eval i p2 = Det False then eval i (Neg' p1)\n                       else Det False)\n\ngoal (1 subgoal):\n 1. eval i (Eql' p1 p2) = eval i (Neg' p1)", "by auto"], ["proof (state)\nthis:\n  eval i (Eql' p1 p2) = eval i (Neg' p1)\n\ngoal (2 subgoals):\n 1. eval i p2 = Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p2 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from a"], ["proof (chain)\npicking this:\n  eval i p2 = Det False", "have \"change_tv f (eval i p2) = Det False\""], ["proof (prove)\nusing this:\n  eval i p2 = Det False\n\ngoal (1 subgoal):\n 1. change_tv f (eval i p2) = Det False", "by auto"], ["proof (state)\nthis:\n  change_tv f (eval i p2) = Det False\n\ngoal (2 subgoals):\n 1. eval i p2 = Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p2 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "then"], ["proof (chain)\npicking this:\n  change_tv f (eval i p2) = Det False", "have b: \"eval (change_int f i) p2 = Det False\""], ["proof (prove)\nusing this:\n  change_tv f (eval i p2) = Det False\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p2 = Det False", "using ih2"], ["proof (prove)\nusing this:\n  change_tv f (eval i p2) = Det False\n  eval (change_int f i) p2 = change_tv f (eval i p2)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p2 = Det False", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) p2 = Det False\n\ngoal (2 subgoals):\n 1. eval i p2 = Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p2 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from a'"], ["proof (chain)\npicking this:\n  eval i p1 \\<noteq> eval i p2", "have b': \"eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\""], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> eval i p2\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2", "using assms ih1 ih2 change_tv_injection the_inv_f_f change_tv.simps"], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> eval i p2\n  inj f\n  eval (change_int f i) p1 = change_tv f (eval i p1)\n  eval (change_int f i) p2 = change_tv f (eval i p2)\n  inj ?f \\<Longrightarrow> inj (change_tv ?f)\n  inj ?f \\<Longrightarrow> the_inv ?f (?f ?x) = ?x\n  change_tv ?f (Det ?b) = Det ?b\n  change_tv ?f (Indet ?n) = Indet (?f ?n)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2", "by metis"], ["proof (state)\nthis:\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n\ngoal (2 subgoals):\n 1. eval i p2 = Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p2 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from a''"], ["proof (chain)\npicking this:\n  eval i p1 \\<noteq> Det True", "have b'': \"eval (change_int f i) p1 \\<noteq> Det True\""], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 \\<noteq> Det True", "using change_tv.elims ih1 tv.simps(4)"], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> Det True\n  \\<lbrakk>change_tv ?x ?xa = ?y;\n   \\<And>f b.\n      \\<lbrakk>?x = f; ?xa = Det b; ?y = Det b\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>f n.\n      \\<lbrakk>?x = f; ?xa = Indet n; ?y = Indet (f n)\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  eval (change_int f i) p1 = change_tv f (eval i p1)\n  Indet ?x2.0 \\<noteq> Det ?x1.0\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 \\<noteq> Det True", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) p1 \\<noteq> Det True\n\ngoal (2 subgoals):\n 1. eval i p2 = Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p2 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from a'''"], ["proof (chain)\npicking this:\n  eval i p2 \\<noteq> Det True", "have b''': \"eval (change_int f i) p2 \\<noteq> Det True\""], ["proof (prove)\nusing this:\n  eval i p2 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p2 \\<noteq> Det True", "using b b' b''"], ["proof (prove)\nusing this:\n  eval i p2 \\<noteq> Det True\n  eval (change_int f i) p2 = Det False\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n  eval (change_int f i) p1 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p2 \\<noteq> Det True", "by (metis assms change_tv.simps(1) change_tv_injection inj_eq ih2)"], ["proof (state)\nthis:\n  eval (change_int f i) p2 \\<noteq> Det True\n\ngoal (2 subgoals):\n 1. eval i p2 = Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p2 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from a''''"], ["proof (chain)\npicking this:\n  eval i p1 \\<noteq> Det False", "have b'''': \"eval (change_int f i) p1 \\<noteq> Det False\""], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> Det False\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 \\<noteq> Det False", "using b b'"], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> Det False\n  eval (change_int f i) p2 = Det False\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 \\<noteq> Det False", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) p1 \\<noteq> Det False\n\ngoal (2 subgoals):\n 1. eval i p2 = Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p2 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from b b' b'' b''' b''''"], ["proof (chain)\npicking this:\n  eval (change_int f i) p2 = Det False\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n  eval (change_int f i) p1 \\<noteq> Det True\n  eval (change_int f i) p2 \\<noteq> Det True\n  eval (change_int f i) p1 \\<noteq> Det False", "have \"eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) (Neg' p1)\""], ["proof (prove)\nusing this:\n  eval (change_int f i) p2 = Det False\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n  eval (change_int f i) p1 \\<noteq> Det True\n  eval (change_int f i) p2 \\<noteq> Det True\n  eval (change_int f i) p1 \\<noteq> Det False\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) (Neg' p1)", "using eval_equality[of \"change_int f i\" p1 p2]"], ["proof (prove)\nusing this:\n  eval (change_int f i) p2 = Det False\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n  eval (change_int f i) p1 \\<noteq> Det True\n  eval (change_int f i) p2 \\<noteq> Det True\n  eval (change_int f i) p1 \\<noteq> Det False\n  eval (change_int f i) (Eql' p1 p2) =\n  (if eval (change_int f i) p1 = eval (change_int f i) p2 then Det True\n   else if eval (change_int f i) p1 = Det True then eval (change_int f i) p2\n        else if eval (change_int f i) p2 = Det True\n             then eval (change_int f i) p1\n             else if eval (change_int f i) p1 = Det False\n                  then eval (change_int f i) (Neg' p2)\n                  else if eval (change_int f i) p2 = Det False\n                       then eval (change_int f i) (Neg' p1) else Det False)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) (Neg' p1)", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) (Neg' p1)\n\ngoal (2 subgoals):\n 1. eval i p2 = Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n 2. eval i p2 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "then"], ["proof (chain)\npicking this:\n  eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) (Neg' p1)", "show \"eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\""], ["proof (prove)\nusing this:\n  eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) (Neg' p1)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "using ih1 yes a a' a''' a'''' b b' b''' b'''' eval_negation a'' b''"], ["proof (prove)\nusing this:\n  eval (change_int f i) (Eql' p1 p2) = eval (change_int f i) (Neg' p1)\n  eval (change_int f i) p1 = change_tv f (eval i p1)\n  eval i (Eql' p1 p2) = eval i (Neg' p1)\n  eval i p2 = Det False\n  eval i p1 \\<noteq> eval i p2\n  eval i p2 \\<noteq> Det True\n  eval i p1 \\<noteq> Det False\n  eval (change_int f i) p2 = Det False\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n  eval (change_int f i) p2 \\<noteq> Det True\n  eval (change_int f i) p1 \\<noteq> Det False\n  eval ?i (Neg' ?p) =\n  (if eval ?i ?p = Det False then Det True\n   else if eval ?i ?p = Det True then Det False else eval ?i ?p)\n  eval i p1 \\<noteq> Det True\n  eval (change_int f i) p1 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "by metis"], ["proof (state)\nthis:\n  eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n\ngoal (1 subgoal):\n 1. eval i p2 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. eval i p2 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "assume a''''': \"eval i p2 \\<noteq> Det False\""], ["proof (state)\nthis:\n  eval i p2 \\<noteq> Det False\n\ngoal (1 subgoal):\n 1. eval i p2 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from a' a'' a''' a'''' a'''''"], ["proof (chain)\npicking this:\n  eval i p1 \\<noteq> eval i p2\n  eval i p1 \\<noteq> Det True\n  eval i p2 \\<noteq> Det True\n  eval i p1 \\<noteq> Det False\n  eval i p2 \\<noteq> Det False", "have yes: \"eval i (Eql' p1 p2) = Det False\""], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> eval i p2\n  eval i p1 \\<noteq> Det True\n  eval i p2 \\<noteq> Det True\n  eval i p1 \\<noteq> Det False\n  eval i p2 \\<noteq> Det False\n\ngoal (1 subgoal):\n 1. eval i (Eql' p1 p2) = Det False", "using eval_equality[of i p1 p2]"], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> eval i p2\n  eval i p1 \\<noteq> Det True\n  eval i p2 \\<noteq> Det True\n  eval i p1 \\<noteq> Det False\n  eval i p2 \\<noteq> Det False\n  eval i (Eql' p1 p2) =\n  (if eval i p1 = eval i p2 then Det True\n   else if eval i p1 = Det True then eval i p2\n        else if eval i p2 = Det True then eval i p1\n             else if eval i p1 = Det False then eval i (Neg' p2)\n                  else if eval i p2 = Det False then eval i (Neg' p1)\n                       else Det False)\n\ngoal (1 subgoal):\n 1. eval i (Eql' p1 p2) = Det False", "by auto"], ["proof (state)\nthis:\n  eval i (Eql' p1 p2) = Det False\n\ngoal (1 subgoal):\n 1. eval i p2 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from a'''''"], ["proof (chain)\npicking this:\n  eval i p2 \\<noteq> Det False", "have \"change_tv f (eval i p2) \\<noteq> Det False\""], ["proof (prove)\nusing this:\n  eval i p2 \\<noteq> Det False\n\ngoal (1 subgoal):\n 1. change_tv f (eval i p2) \\<noteq> Det False", "using change_tv_injection inj_eq assms change_tv.simps"], ["proof (prove)\nusing this:\n  eval i p2 \\<noteq> Det False\n  inj ?f \\<Longrightarrow> inj (change_tv ?f)\n  inj ?f \\<Longrightarrow> (?f ?x = ?f ?y) = (?x = ?y)\n  inj f\n  change_tv ?f (Det ?b) = Det ?b\n  change_tv ?f (Indet ?n) = Indet (?f ?n)\n\ngoal (1 subgoal):\n 1. change_tv f (eval i p2) \\<noteq> Det False", "by metis"], ["proof (state)\nthis:\n  change_tv f (eval i p2) \\<noteq> Det False\n\ngoal (1 subgoal):\n 1. eval i p2 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "then"], ["proof (chain)\npicking this:\n  change_tv f (eval i p2) \\<noteq> Det False", "have b: \"eval (change_int f i) p2 \\<noteq> Det False\""], ["proof (prove)\nusing this:\n  change_tv f (eval i p2) \\<noteq> Det False\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p2 \\<noteq> Det False", "using ih2"], ["proof (prove)\nusing this:\n  change_tv f (eval i p2) \\<noteq> Det False\n  eval (change_int f i) p2 = change_tv f (eval i p2)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p2 \\<noteq> Det False", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) p2 \\<noteq> Det False\n\ngoal (1 subgoal):\n 1. eval i p2 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from a'"], ["proof (chain)\npicking this:\n  eval i p1 \\<noteq> eval i p2", "have b': \"eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\""], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> eval i p2\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2", "using assms ih1 ih2 change_tv_injection the_inv_f_f change_tv.simps"], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> eval i p2\n  inj f\n  eval (change_int f i) p1 = change_tv f (eval i p1)\n  eval (change_int f i) p2 = change_tv f (eval i p2)\n  inj ?f \\<Longrightarrow> inj (change_tv ?f)\n  inj ?f \\<Longrightarrow> the_inv ?f (?f ?x) = ?x\n  change_tv ?f (Det ?b) = Det ?b\n  change_tv ?f (Indet ?n) = Indet (?f ?n)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2", "by metis"], ["proof (state)\nthis:\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n\ngoal (1 subgoal):\n 1. eval i p2 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from a''"], ["proof (chain)\npicking this:\n  eval i p1 \\<noteq> Det True", "have b'': \"eval (change_int f i) p1 \\<noteq> Det True\""], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 \\<noteq> Det True", "using change_tv.elims ih1 tv.simps(4)"], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> Det True\n  \\<lbrakk>change_tv ?x ?xa = ?y;\n   \\<And>f b.\n      \\<lbrakk>?x = f; ?xa = Det b; ?y = Det b\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>f n.\n      \\<lbrakk>?x = f; ?xa = Indet n; ?y = Indet (f n)\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  eval (change_int f i) p1 = change_tv f (eval i p1)\n  Indet ?x2.0 \\<noteq> Det ?x1.0\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 \\<noteq> Det True", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) p1 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval i p2 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from a'''"], ["proof (chain)\npicking this:\n  eval i p2 \\<noteq> Det True", "have b''': \"eval (change_int f i) p2 \\<noteq> Det True\""], ["proof (prove)\nusing this:\n  eval i p2 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p2 \\<noteq> Det True", "using b b' b''"], ["proof (prove)\nusing this:\n  eval i p2 \\<noteq> Det True\n  eval (change_int f i) p2 \\<noteq> Det False\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n  eval (change_int f i) p1 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p2 \\<noteq> Det True", "by (metis assms change_tv.simps(1) change_tv_injection the_inv_f_f ih2)"], ["proof (state)\nthis:\n  eval (change_int f i) p2 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval i p2 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from a''''"], ["proof (chain)\npicking this:\n  eval i p1 \\<noteq> Det False", "have b'''': \"eval (change_int f i) p1 \\<noteq> Det False\""], ["proof (prove)\nusing this:\n  eval i p1 \\<noteq> Det False\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p1 \\<noteq> Det False", "by (metis a'' change_tv.simps(2) ih1 string_tv.cases tv.distinct(1))"], ["proof (state)\nthis:\n  eval (change_int f i) p1 \\<noteq> Det False\n\ngoal (1 subgoal):\n 1. eval i p2 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "from b b' b'' b''' b''''"], ["proof (chain)\npicking this:\n  eval (change_int f i) p2 \\<noteq> Det False\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n  eval (change_int f i) p1 \\<noteq> Det True\n  eval (change_int f i) p2 \\<noteq> Det True\n  eval (change_int f i) p1 \\<noteq> Det False", "have \"eval (change_int f i) (Eql' p1 p2) = Det False\""], ["proof (prove)\nusing this:\n  eval (change_int f i) p2 \\<noteq> Det False\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n  eval (change_int f i) p1 \\<noteq> Det True\n  eval (change_int f i) p2 \\<noteq> Det True\n  eval (change_int f i) p1 \\<noteq> Det False\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = Det False", "using eval_equality[of \"change_int f i\" p1 p2]"], ["proof (prove)\nusing this:\n  eval (change_int f i) p2 \\<noteq> Det False\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n  eval (change_int f i) p1 \\<noteq> Det True\n  eval (change_int f i) p2 \\<noteq> Det True\n  eval (change_int f i) p1 \\<noteq> Det False\n  eval (change_int f i) (Eql' p1 p2) =\n  (if eval (change_int f i) p1 = eval (change_int f i) p2 then Det True\n   else if eval (change_int f i) p1 = Det True then eval (change_int f i) p2\n        else if eval (change_int f i) p2 = Det True\n             then eval (change_int f i) p1\n             else if eval (change_int f i) p1 = Det False\n                  then eval (change_int f i) (Neg' p2)\n                  else if eval (change_int f i) p2 = Det False\n                       then eval (change_int f i) (Neg' p1) else Det False)\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = Det False", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) (Eql' p1 p2) = Det False\n\ngoal (1 subgoal):\n 1. eval i p2 \\<noteq> Det False \\<Longrightarrow>\n    eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "then"], ["proof (chain)\npicking this:\n  eval (change_int f i) (Eql' p1 p2) = Det False", "show \"eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\""], ["proof (prove)\nusing this:\n  eval (change_int f i) (Eql' p1 p2) = Det False\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "using ih1 yes a' a''' a'''' b b' b''' b'''' a'' b''"], ["proof (prove)\nusing this:\n  eval (change_int f i) (Eql' p1 p2) = Det False\n  eval (change_int f i) p1 = change_tv f (eval i p1)\n  eval i (Eql' p1 p2) = Det False\n  eval i p1 \\<noteq> eval i p2\n  eval i p2 \\<noteq> Det True\n  eval i p1 \\<noteq> Det False\n  eval (change_int f i) p2 \\<noteq> Det False\n  eval (change_int f i) p1 \\<noteq> eval (change_int f i) p2\n  eval (change_int f i) p2 \\<noteq> Det True\n  eval (change_int f i) p1 \\<noteq> Det False\n  eval i p1 \\<noteq> Det True\n  eval (change_int f i) p1 \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (change_int f i) (Eql' p1 p2) = change_tv f (eval i (Eql' p1 p2))\n\ngoal (2 subgoals):\n 1. \\<And>x. eval (change_int f i) (Pro x) = change_tv f (eval i (Pro x))\n 2. eval (change_int f i) Truth = change_tv f (eval i Truth)", "qed (simp_all add: change_int_def)"], ["", "subsection \\<open>Only a Finite Number of Truth Values Needed\\<close>"], ["", "text\n\\<open>\nTheorem valid_in_valid is a kind of the reverse of valid_valid_in (or its transfer variant).\n\\<close>"], ["", "abbreviation is_indet :: \"tv \\<Rightarrow> bool\"\nwhere\n  \"is_indet tv \\<equiv> (case tv of Det _ \\<Rightarrow> False | Indet _ \\<Rightarrow> True)\""], ["", "abbreviation get_indet :: \"tv \\<Rightarrow> nat\"\nwhere\n  \"get_indet tv \\<equiv> (case tv of Det _ \\<Rightarrow> undefined | Indet n \\<Rightarrow> n)\""], ["", "theorem valid_in_valid: assumes \"card U \\<ge> card (props p)\" and \"valid_in U p\" shows \"valid p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid p", "have \"finite U \\<Longrightarrow> card (props p) \\<le> card U \\<Longrightarrow> valid_in U p \\<Longrightarrow> valid p\" for U p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite U; card (props p) \\<le> card U; valid_in U p\\<rbrakk>\n    \\<Longrightarrow> valid p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite U; card (props p) \\<le> card U; valid_in U p\\<rbrakk>\n    \\<Longrightarrow> valid p", "assume assms: \"finite U\" \"card (props p) \\<le> card U\" \"valid_in U p\""], ["proof (state)\nthis:\n  finite U\n  card (props p) \\<le> card U\n  valid_in U p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite U; card (props p) \\<le> card U; valid_in U p\\<rbrakk>\n    \\<Longrightarrow> valid p", "show \"valid p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid p", "unfolding valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. eval i p = Det True", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. eval i p = Det True", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. eval i p = Det True", "obtain f where f_p: \"(change_int f i) ` (props p) \\<subseteq> (domain U) \\<and> inj f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        change_int f i ` props p \\<subseteq> domain U \\<and>\n        inj f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        change_int f i ` props p \\<subseteq> domain U \\<and>\n        inj f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"finite U \\<Longrightarrow> card (props p) \\<le> card U \\<Longrightarrow>\n            \\<exists>f. change_int f i ` props p \\<subseteq> domain U \\<and> inj f\" for U p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite U; card (props p) \\<le> card U\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f.\n                         change_int f i ` props p\n                         \\<subseteq> domain U \\<and>\n                         inj f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite U; card (props p) \\<le> card U\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f.\n                         change_int f i ` props p\n                         \\<subseteq> domain U \\<and>\n                         inj f", "assume assms: \"finite U\" \"card (props p) \\<le> card U\""], ["proof (state)\nthis:\n  finite U\n  card (props p) \\<le> card U\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite U; card (props p) \\<le> card U\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f.\n                         change_int f i ` props p\n                         \\<subseteq> domain U \\<and>\n                         inj f", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. change_int f i ` props p \\<subseteq> domain U \\<and> inj f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f. change_int f i ` props p \\<subseteq> domain U \\<and> inj f", "let ?X = \"(get_indet ` ((i ` props p) \\<inter> {tv. is_indet tv}))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f. change_int f i ` props p \\<subseteq> domain U \\<and> inj f", "have d: \"finite (props p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (props p)", "by (induct p) auto"], ["proof (state)\nthis:\n  finite (props p)\n\ngoal (1 subgoal):\n 1. \\<exists>f. change_int f i ` props p \\<subseteq> domain U \\<and> inj f", "then"], ["proof (chain)\npicking this:\n  finite (props p)", "have cx: \"card ?X \\<le> card U\""], ["proof (prove)\nusing this:\n  finite (props p)\n\ngoal (1 subgoal):\n 1. card (get_indet ` (i ` props p \\<inter> Collect is_indet)) \\<le> card U", "using assms surj_card_le Int_lower1 card_image_le finite_Int finite_imageI le_trans"], ["proof (prove)\nusing this:\n  finite (props p)\n  finite U\n  card (props p) \\<le> card U\n  \\<lbrakk>finite ?A; ?B \\<subseteq> ?f ` ?A\\<rbrakk>\n  \\<Longrightarrow> card ?B \\<le> card ?A\n  ?A \\<inter> ?B \\<subseteq> ?A\n  finite ?A \\<Longrightarrow> card (?f ` ?A) \\<le> card ?A\n  finite ?F \\<or> finite ?G \\<Longrightarrow> finite (?F \\<inter> ?G)\n  finite ?F \\<Longrightarrow> finite (?h ` ?F)\n  \\<lbrakk>?i \\<le> ?j; ?j \\<le> ?k\\<rbrakk> \\<Longrightarrow> ?i \\<le> ?k\n\ngoal (1 subgoal):\n 1. card (get_indet ` (i ` props p \\<inter> Collect is_indet)) \\<le> card U", "by metis"], ["proof (state)\nthis:\n  card (get_indet ` (i ` props p \\<inter> Collect is_indet)) \\<le> card U\n\ngoal (1 subgoal):\n 1. \\<exists>f. change_int f i ` props p \\<subseteq> domain U \\<and> inj f", "have f: \"finite ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (get_indet ` (i ` props p \\<inter> Collect is_indet))", "using d"], ["proof (prove)\nusing this:\n  finite (props p)\n\ngoal (1 subgoal):\n 1. finite (get_indet ` (i ` props p \\<inter> Collect is_indet))", "by simp"], ["proof (state)\nthis:\n  finite (get_indet ` (i ` props p \\<inter> Collect is_indet))\n\ngoal (1 subgoal):\n 1. \\<exists>f. change_int f i ` props p \\<subseteq> domain U \\<and> inj f", "obtain f where f_p: \"(\\<forall>n \\<in> ?X. f n \\<in> U) \\<and> (inj f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        (\\<forall>n\\<in>get_indet ` (i ` props p \\<inter> Collect is_indet).\n            f n \\<in> U) \\<and>\n        inj f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        (\\<forall>n\\<in>get_indet ` (i ` props p \\<inter> Collect is_indet).\n            f n \\<in> U) \\<and>\n        inj f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"finite X \\<Longrightarrow> finite Y \\<Longrightarrow> card X \\<le> card Y \\<Longrightarrow> \\<exists>f. (\\<forall>n \\<in> X. f n \\<in> Y) \\<and> inj f\"\n                  for X Y :: \"nat set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite X; finite Y; card X \\<le> card Y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f.\n                         (\\<forall>n\\<in>X. f n \\<in> Y) \\<and> inj f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite X; finite Y; card X \\<le> card Y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f.\n                         (\\<forall>n\\<in>X. f n \\<in> Y) \\<and> inj f", "assume assms: \"finite X\" \"finite Y\" \"card X \\<le> card Y\""], ["proof (state)\nthis:\n  finite X\n  finite Y\n  card X \\<le> card Y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite X; finite Y; card X \\<le> card Y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f.\n                         (\\<forall>n\\<in>X. f n \\<in> Y) \\<and> inj f", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. (\\<forall>n\\<in>X. f n \\<in> Y) \\<and> inj f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f. (\\<forall>n\\<in>X. f n \\<in> Y) \\<and> inj f", "from assms"], ["proof (chain)\npicking this:\n  finite X\n  finite Y\n  card X \\<le> card Y", "obtain Z where xyz: \"Z \\<subseteq> Y \\<and> card Z = card X\""], ["proof (prove)\nusing this:\n  finite X\n  finite Y\n  card X \\<le> card Y\n\ngoal (1 subgoal):\n 1. (\\<And>Z.\n        Z \\<subseteq> Y \\<and> card Z = card X \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis card_image card_le_inj)"], ["proof (state)\nthis:\n  Z \\<subseteq> Y \\<and> card Z = card X\n\ngoal (1 subgoal):\n 1. \\<exists>f. (\\<forall>n\\<in>X. f n \\<in> Y) \\<and> inj f", "then"], ["proof (chain)\npicking this:\n  Z \\<subseteq> Y \\<and> card Z = card X", "obtain f where \"bij_betw f X Z\""], ["proof (prove)\nusing this:\n  Z \\<subseteq> Y \\<and> card Z = card X\n\ngoal (1 subgoal):\n 1. (\\<And>f. bij_betw f X Z \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis assms(1) assms(2) finite_same_card_bij infinite_super)"], ["proof (state)\nthis:\n  bij_betw f X Z\n\ngoal (1 subgoal):\n 1. \\<exists>f. (\\<forall>n\\<in>X. f n \\<in> Y) \\<and> inj f", "then"], ["proof (chain)\npicking this:\n  bij_betw f X Z", "have f_p: \"(\\<forall>n \\<in> X. f n \\<in> Y) \\<and> inj_on f X\""], ["proof (prove)\nusing this:\n  bij_betw f X Z\n\ngoal (1 subgoal):\n 1. (\\<forall>n\\<in>X. f n \\<in> Y) \\<and> inj_on f X", "using bij_betwE bij_betw_imp_inj_on xyz"], ["proof (prove)\nusing this:\n  bij_betw f X Z\n  bij_betw ?f ?A ?B \\<Longrightarrow> \\<forall>a\\<in>?A. ?f a \\<in> ?B\n  bij_betw ?f ?A ?B \\<Longrightarrow> inj_on ?f ?A\n  Z \\<subseteq> Y \\<and> card Z = card X\n\ngoal (1 subgoal):\n 1. (\\<forall>n\\<in>X. f n \\<in> Y) \\<and> inj_on f X", "by blast"], ["proof (state)\nthis:\n  (\\<forall>n\\<in>X. f n \\<in> Y) \\<and> inj_on f X\n\ngoal (1 subgoal):\n 1. \\<exists>f. (\\<forall>n\\<in>X. f n \\<in> Y) \\<and> inj f", "obtain f' where f': \"f' = (\\<lambda>n. if n \\<in> X then f n else n + Suc (Max Y + n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        f' =\n        (\\<lambda>n.\n            if n \\<in> X then f n\n            else n + Suc (Max Y + n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  f' = (\\<lambda>n. if n \\<in> X then f n else n + Suc (Max Y + n))\n\ngoal (1 subgoal):\n 1. \\<exists>f. (\\<forall>n\\<in>X. f n \\<in> Y) \\<and> inj f", "have \"inj f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj f'", "unfolding f' inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          (if x \\<in> X then f x else x + Suc (Max Y + x)) =\n          (if y \\<in> X then f y else y + Suc (Max Y + y)) \\<longrightarrow>\n          x = y", "using assms(2) f_p le_add2 trans_le_add2 not_less_eq_eq"], ["proof (prove)\nusing this:\n  finite Y\n  (\\<forall>n\\<in>X. f n \\<in> Y) \\<and> inj_on f X\n  ?n \\<le> ?m + ?n\n  ?i \\<le> ?j \\<Longrightarrow> ?i \\<le> ?m + ?j\n  (\\<not> ?m \\<le> ?n) = (Suc ?n \\<le> ?m)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          (if x \\<in> X then f x else x + Suc (Max Y + x)) =\n          (if y \\<in> X then f y else y + Suc (Max Y + y)) \\<longrightarrow>\n          x = y", "by (simp, metis Max_ge add.commute inj_on_eq_iff)"], ["proof (state)\nthis:\n  inj f'\n\ngoal (1 subgoal):\n 1. \\<exists>f. (\\<forall>n\\<in>X. f n \\<in> Y) \\<and> inj f", "moreover"], ["proof (state)\nthis:\n  inj f'\n\ngoal (1 subgoal):\n 1. \\<exists>f. (\\<forall>n\\<in>X. f n \\<in> Y) \\<and> inj f", "have \"(\\<forall>n \\<in> X. f' n \\<in> Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>X. f' n \\<in> Y", "unfolding f'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>X.\n       (if n \\<in> X then f n else n + Suc (Max Y + n)) \\<in> Y", "using f_p"], ["proof (prove)\nusing this:\n  (\\<forall>n\\<in>X. f n \\<in> Y) \\<and> inj_on f X\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>X.\n       (if n \\<in> X then f n else n + Suc (Max Y + n)) \\<in> Y", "by auto"], ["proof (state)\nthis:\n  \\<forall>n\\<in>X. f' n \\<in> Y\n\ngoal (1 subgoal):\n 1. \\<exists>f. (\\<forall>n\\<in>X. f n \\<in> Y) \\<and> inj f", "ultimately"], ["proof (chain)\npicking this:\n  inj f'\n  \\<forall>n\\<in>X. f' n \\<in> Y", "show ?thesis"], ["proof (prove)\nusing this:\n  inj f'\n  \\<forall>n\\<in>X. f' n \\<in> Y\n\ngoal (1 subgoal):\n 1. \\<exists>f. (\\<forall>n\\<in>X. f n \\<in> Y) \\<and> inj f", "by metis"], ["proof (state)\nthis:\n  \\<exists>f. (\\<forall>n\\<in>X. f n \\<in> Y) \\<and> inj f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f. (\\<forall>n\\<in>X. f n \\<in> Y) \\<and> inj f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?X; finite ?Y; card ?X \\<le> card ?Y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f.\n                       (\\<forall>n\\<in>?X. f n \\<in> ?Y) \\<and> inj f\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        (\\<forall>n\\<in>get_indet ` (i ` props p \\<inter> Collect is_indet).\n            f n \\<in> U) \\<and>\n        inj f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite ?X; finite ?Y; card ?X \\<le> card ?Y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f.\n                       (\\<forall>n\\<in>?X. f n \\<in> ?Y) \\<and> inj f", "show \"(\\<And>f. (\\<forall>n \\<in> get_indet ` (i ` props p \\<inter> {tv. is_indet tv}). f n \\<in> U)\n                  \\<and> inj f \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\""], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?X; finite ?Y; card ?X \\<le> card ?Y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f.\n                       (\\<forall>n\\<in>?X. f n \\<in> ?Y) \\<and> inj f\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        (\\<forall>n\\<in>get_indet ` (i ` props p \\<inter> Collect is_indet).\n            f n \\<in> U) \\<and>\n        inj f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms cx f"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?X; finite ?Y; card ?X \\<le> card ?Y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f.\n                       (\\<forall>n\\<in>?X. f n \\<in> ?Y) \\<and> inj f\n  finite U\n  card (props p) \\<le> card U\n  card (get_indet ` (i ` props p \\<inter> Collect is_indet)) \\<le> card U\n  finite (get_indet ` (i ` props p \\<inter> Collect is_indet))\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        (\\<forall>n\\<in>get_indet ` (i ` props p \\<inter> Collect is_indet).\n            f n \\<in> U) \\<and>\n        inj f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?X; finite ?Y; card ?X \\<le> card ?Y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f.\n                       (\\<forall>n\\<in>?X. f n \\<in> ?Y) \\<and>\n                       (\\<forall>x\\<in>UNIV.\n                           \\<forall>y\\<in>UNIV.\n                              f x = f y \\<longrightarrow> x = y)\n  finite U\n  card (props p) \\<le> card U\n  card (get_indet ` (i ` props p \\<inter> Collect is_indet)) \\<le> card U\n  finite (get_indet ` (i ` props p \\<inter> Collect is_indet))\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        (\\<forall>n\\<in>get_indet ` (i ` props p \\<inter> Collect is_indet).\n            f n \\<in> U) \\<and>\n        (\\<forall>x\\<in>UNIV.\n            \\<forall>y\\<in>UNIV.\n               f x = f y \\<longrightarrow> x = y) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  (\\<And>f.\n      (\\<forall>n\\<in>get_indet ` (i ` props p \\<inter> Collect is_indet).\n          f n \\<in> U) \\<and>\n      inj f \\<Longrightarrow>\n      thesis) \\<Longrightarrow>\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>n\\<in>get_indet ` (i ` props p \\<inter> Collect is_indet).\n      f n \\<in> U) \\<and>\n  inj f\n\ngoal (1 subgoal):\n 1. \\<exists>f. change_int f i ` props p \\<subseteq> domain U \\<and> inj f", "have \"(change_int f i) ` (props p) \\<subseteq> (domain U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. change_int f i ` props p \\<subseteq> domain U", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> change_int f i ` props p \\<Longrightarrow> x \\<in> domain U", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> change_int f i ` props p \\<Longrightarrow> x \\<in> domain U", "assume \"x \\<in> change_int f i ` props p\""], ["proof (state)\nthis:\n  x \\<in> change_int f i ` props p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> change_int f i ` props p \\<Longrightarrow> x \\<in> domain U", "then"], ["proof (chain)\npicking this:\n  x \\<in> change_int f i ` props p", "obtain s where s_p: \"s \\<in> props p \\<and> change_int f i s = x\""], ["proof (prove)\nusing this:\n  x \\<in> change_int f i ` props p\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        s \\<in> props p \\<and> change_int f i s = x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s \\<in> props p \\<and> change_int f i s = x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> change_int f i ` props p \\<Longrightarrow> x \\<in> domain U", "then"], ["proof (chain)\npicking this:\n  s \\<in> props p \\<and> change_int f i s = x", "have \"change_int f i s \\<in> {Det True, Det False} \\<union> Indet ` U\""], ["proof (prove)\nusing this:\n  s \\<in> props p \\<and> change_int f i s = x\n\ngoal (1 subgoal):\n 1. change_int f i s \\<in> {Det True, Det False} \\<union> Indet ` U", "proof (cases \"change_int f i s \\<in> {Det True, Det False}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<in> props p \\<and> change_int f i s = x;\n     change_int f i s \\<in> {Det True, Det False}\\<rbrakk>\n    \\<Longrightarrow> change_int f i s\n                      \\<in> {Det True, Det False} \\<union> Indet ` U\n 2. \\<lbrakk>s \\<in> props p \\<and> change_int f i s = x;\n     change_int f i s \\<notin> {Det True, Det False}\\<rbrakk>\n    \\<Longrightarrow> change_int f i s\n                      \\<in> {Det True, Det False} \\<union> Indet ` U", "case True"], ["proof (state)\nthis:\n  change_int f i s \\<in> {Det True, Det False}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<in> props p \\<and> change_int f i s = x;\n     change_int f i s \\<in> {Det True, Det False}\\<rbrakk>\n    \\<Longrightarrow> change_int f i s\n                      \\<in> {Det True, Det False} \\<union> Indet ` U\n 2. \\<lbrakk>s \\<in> props p \\<and> change_int f i s = x;\n     change_int f i s \\<notin> {Det True, Det False}\\<rbrakk>\n    \\<Longrightarrow> change_int f i s\n                      \\<in> {Det True, Det False} \\<union> Indet ` U", "then"], ["proof (chain)\npicking this:\n  change_int f i s \\<in> {Det True, Det False}", "show ?thesis"], ["proof (prove)\nusing this:\n  change_int f i s \\<in> {Det True, Det False}\n\ngoal (1 subgoal):\n 1. change_int f i s \\<in> {Det True, Det False} \\<union> Indet ` U", "by auto"], ["proof (state)\nthis:\n  change_int f i s \\<in> {Det True, Det False} \\<union> Indet ` U\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> props p \\<and> change_int f i s = x;\n     change_int f i s \\<notin> {Det True, Det False}\\<rbrakk>\n    \\<Longrightarrow> change_int f i s\n                      \\<in> {Det True, Det False} \\<union> Indet ` U", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> props p \\<and> change_int f i s = x;\n     change_int f i s \\<notin> {Det True, Det False}\\<rbrakk>\n    \\<Longrightarrow> change_int f i s\n                      \\<in> {Det True, Det False} \\<union> Indet ` U", "case False"], ["proof (state)\nthis:\n  change_int f i s \\<notin> {Det True, Det False}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> props p \\<and> change_int f i s = x;\n     change_int f i s \\<notin> {Det True, Det False}\\<rbrakk>\n    \\<Longrightarrow> change_int f i s\n                      \\<in> {Det True, Det False} \\<union> Indet ` U", "then"], ["proof (chain)\npicking this:\n  change_int f i s \\<notin> {Det True, Det False}", "obtain n' where \"change_int f i s = Indet n'\""], ["proof (prove)\nusing this:\n  change_int f i s \\<notin> {Det True, Det False}\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        change_int f i s = Indet n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"change_int f i s\") simp_all"], ["proof (state)\nthis:\n  change_int f i s = Indet n'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> props p \\<and> change_int f i s = x;\n     change_int f i s \\<notin> {Det True, Det False}\\<rbrakk>\n    \\<Longrightarrow> change_int f i s\n                      \\<in> {Det True, Det False} \\<union> Indet ` U", "then"], ["proof (chain)\npicking this:\n  change_int f i s = Indet n'", "have p: \"change_tv f (i s) = Indet n'\""], ["proof (prove)\nusing this:\n  change_int f i s = Indet n'\n\ngoal (1 subgoal):\n 1. change_tv f (i s) = Indet n'", "by (simp add: change_int_def)"], ["proof (state)\nthis:\n  change_tv f (i s) = Indet n'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> props p \\<and> change_int f i s = x;\n     change_int f i s \\<notin> {Det True, Det False}\\<rbrakk>\n    \\<Longrightarrow> change_int f i s\n                      \\<in> {Det True, Det False} \\<union> Indet ` U", "moreover"], ["proof (state)\nthis:\n  change_tv f (i s) = Indet n'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> props p \\<and> change_int f i s = x;\n     change_int f i s \\<notin> {Det True, Det False}\\<rbrakk>\n    \\<Longrightarrow> change_int f i s\n                      \\<in> {Det True, Det False} \\<union> Indet ` U", "have \"n' \\<in> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n' \\<in> U", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n' \\<in> U", "obtain n'' where \"f n'' = n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n''. f n'' = n' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation change_tv.elims"], ["proof (prove)\nusing this:\n  change_tv f (i s) = Indet n'\n  \\<lbrakk>change_tv ?x ?xa = ?y;\n   \\<And>f b.\n      \\<lbrakk>?x = f; ?xa = Det b; ?y = Det b\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>f n.\n      \\<lbrakk>?x = f; ?xa = Indet n; ?y = Indet (f n)\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>n''. f n'' = n' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  f n'' = n'\n\ngoal (1 subgoal):\n 1. n' \\<in> U", "moreover"], ["proof (state)\nthis:\n  f n'' = n'\n\ngoal (1 subgoal):\n 1. n' \\<in> U", "have \"s \\<in> props p \\<and> i s = (Indet n'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> props p \\<and> i s = Indet n''", "using p calculation change_tv.simps change_tv_injection the_inv_f_f f_p s_p"], ["proof (prove)\nusing this:\n  change_tv f (i s) = Indet n'\n  f n'' = n'\n  change_tv ?f (Det ?b) = Det ?b\n  change_tv ?f (Indet ?n) = Indet (?f ?n)\n  inj ?f \\<Longrightarrow> inj (change_tv ?f)\n  inj ?f \\<Longrightarrow> the_inv ?f (?f ?x) = ?x\n  (\\<forall>n\\<in>get_indet ` (i ` props p \\<inter> Collect is_indet).\n      f n \\<in> U) \\<and>\n  inj f\n  s \\<in> props p \\<and> change_int f i s = x\n\ngoal (1 subgoal):\n 1. s \\<in> props p \\<and> i s = Indet n''", "by metis"], ["proof (state)\nthis:\n  s \\<in> props p \\<and> i s = Indet n''\n\ngoal (1 subgoal):\n 1. n' \\<in> U", "then"], ["proof (chain)\npicking this:\n  s \\<in> props p \\<and> i s = Indet n''", "have \"(Indet n'') \\<in> i ` props p\""], ["proof (prove)\nusing this:\n  s \\<in> props p \\<and> i s = Indet n''\n\ngoal (1 subgoal):\n 1. Indet n'' \\<in> i ` props p", "using image_iff"], ["proof (prove)\nusing this:\n  s \\<in> props p \\<and> i s = Indet n''\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)\n\ngoal (1 subgoal):\n 1. Indet n'' \\<in> i ` props p", "by metis"], ["proof (state)\nthis:\n  Indet n'' \\<in> i ` props p\n\ngoal (1 subgoal):\n 1. n' \\<in> U", "then"], ["proof (chain)\npicking this:\n  Indet n'' \\<in> i ` props p", "have \"(Indet n'') \\<in> i ` props p \\<and> is_indet (Indet n'') \\<and>\n                      get_indet (Indet n'') = n''\""], ["proof (prove)\nusing this:\n  Indet n'' \\<in> i ` props p\n\ngoal (1 subgoal):\n 1. Indet n'' \\<in> i ` props p \\<and>\n    is_indet (Indet n'') \\<and> get_indet (Indet n'') = n''", "by auto"], ["proof (state)\nthis:\n  Indet n'' \\<in> i ` props p \\<and>\n  is_indet (Indet n'') \\<and> get_indet (Indet n'') = n''\n\ngoal (1 subgoal):\n 1. n' \\<in> U", "then"], ["proof (chain)\npicking this:\n  Indet n'' \\<in> i ` props p \\<and>\n  is_indet (Indet n'') \\<and> get_indet (Indet n'') = n''", "have \"n'' \\<in> ?X\""], ["proof (prove)\nusing this:\n  Indet n'' \\<in> i ` props p \\<and>\n  is_indet (Indet n'') \\<and> get_indet (Indet n'') = n''\n\ngoal (1 subgoal):\n 1. n'' \\<in> get_indet ` (i ` props p \\<inter> Collect is_indet)", "using Int_Collect image_iff"], ["proof (prove)\nusing this:\n  Indet n'' \\<in> i ` props p \\<and>\n  is_indet (Indet n'') \\<and> get_indet (Indet n'') = n''\n  (?x \\<in> ?A \\<inter> {x. ?P x}) = (?x \\<in> ?A \\<and> ?P ?x)\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)\n\ngoal (1 subgoal):\n 1. n'' \\<in> get_indet ` (i ` props p \\<inter> Collect is_indet)", "by metis"], ["proof (state)\nthis:\n  n'' \\<in> get_indet ` (i ` props p \\<inter> Collect is_indet)\n\ngoal (1 subgoal):\n 1. n' \\<in> U", "ultimately"], ["proof (chain)\npicking this:\n  f n'' = n'\n  n'' \\<in> get_indet ` (i ` props p \\<inter> Collect is_indet)", "show ?thesis"], ["proof (prove)\nusing this:\n  f n'' = n'\n  n'' \\<in> get_indet ` (i ` props p \\<inter> Collect is_indet)\n\ngoal (1 subgoal):\n 1. n' \\<in> U", "using f_p"], ["proof (prove)\nusing this:\n  f n'' = n'\n  n'' \\<in> get_indet ` (i ` props p \\<inter> Collect is_indet)\n  (\\<forall>n\\<in>get_indet ` (i ` props p \\<inter> Collect is_indet).\n      f n \\<in> U) \\<and>\n  inj f\n\ngoal (1 subgoal):\n 1. n' \\<in> U", "by auto"], ["proof (state)\nthis:\n  n' \\<in> U\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n' \\<in> U\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> props p \\<and> change_int f i s = x;\n     change_int f i s \\<notin> {Det True, Det False}\\<rbrakk>\n    \\<Longrightarrow> change_int f i s\n                      \\<in> {Det True, Det False} \\<union> Indet ` U", "ultimately"], ["proof (chain)\npicking this:\n  change_tv f (i s) = Indet n'\n  n' \\<in> U", "have \"change_tv f (i s) \\<in> Indet ` U\""], ["proof (prove)\nusing this:\n  change_tv f (i s) = Indet n'\n  n' \\<in> U\n\ngoal (1 subgoal):\n 1. change_tv f (i s) \\<in> Indet ` U", "by auto"], ["proof (state)\nthis:\n  change_tv f (i s) \\<in> Indet ` U\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> props p \\<and> change_int f i s = x;\n     change_int f i s \\<notin> {Det True, Det False}\\<rbrakk>\n    \\<Longrightarrow> change_int f i s\n                      \\<in> {Det True, Det False} \\<union> Indet ` U", "then"], ["proof (chain)\npicking this:\n  change_tv f (i s) \\<in> Indet ` U", "have \"change_int f i s \\<in> Indet ` U\""], ["proof (prove)\nusing this:\n  change_tv f (i s) \\<in> Indet ` U\n\ngoal (1 subgoal):\n 1. change_int f i s \\<in> Indet ` U", "unfolding change_int_def"], ["proof (prove)\nusing this:\n  change_tv f (i s) \\<in> Indet ` U\n\ngoal (1 subgoal):\n 1. change_tv f (i s) \\<in> Indet ` U", "by auto"], ["proof (state)\nthis:\n  change_int f i s \\<in> Indet ` U\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> props p \\<and> change_int f i s = x;\n     change_int f i s \\<notin> {Det True, Det False}\\<rbrakk>\n    \\<Longrightarrow> change_int f i s\n                      \\<in> {Det True, Det False} \\<union> Indet ` U", "then"], ["proof (chain)\npicking this:\n  change_int f i s \\<in> Indet ` U", "show ?thesis"], ["proof (prove)\nusing this:\n  change_int f i s \\<in> Indet ` U\n\ngoal (1 subgoal):\n 1. change_int f i s \\<in> {Det True, Det False} \\<union> Indet ` U", "by auto"], ["proof (state)\nthis:\n  change_int f i s \\<in> {Det True, Det False} \\<union> Indet ` U\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  change_int f i s \\<in> {Det True, Det False} \\<union> Indet ` U\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> change_int f i ` props p \\<Longrightarrow> x \\<in> domain U", "then"], ["proof (chain)\npicking this:\n  change_int f i s \\<in> {Det True, Det False} \\<union> Indet ` U", "show \"x \\<in> domain U\""], ["proof (prove)\nusing this:\n  change_int f i s \\<in> {Det True, Det False} \\<union> Indet ` U\n\ngoal (1 subgoal):\n 1. x \\<in> domain U", "unfolding domain_def"], ["proof (prove)\nusing this:\n  change_int f i s \\<in> {Det True, Det False} \\<union> Indet ` U\n\ngoal (1 subgoal):\n 1. x \\<in> {Det True, Det False} \\<union> Indet ` U", "using s_p"], ["proof (prove)\nusing this:\n  change_int f i s \\<in> {Det True, Det False} \\<union> Indet ` U\n  s \\<in> props p \\<and> change_int f i s = x\n\ngoal (1 subgoal):\n 1. x \\<in> {Det True, Det False} \\<union> Indet ` U", "by simp"], ["proof (state)\nthis:\n  x \\<in> domain U\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  change_int f i ` props p \\<subseteq> domain U\n\ngoal (1 subgoal):\n 1. \\<exists>f. change_int f i ` props p \\<subseteq> domain U \\<and> inj f", "then"], ["proof (chain)\npicking this:\n  change_int f i ` props p \\<subseteq> domain U", "have \"(change_int f i) ` (props p) \\<subseteq> (domain U) \\<and> (inj f)\""], ["proof (prove)\nusing this:\n  change_int f i ` props p \\<subseteq> domain U\n\ngoal (1 subgoal):\n 1. change_int f i ` props p \\<subseteq> domain U \\<and> inj f", "unfolding domain_def"], ["proof (prove)\nusing this:\n  change_int f i ` props p\n  \\<subseteq> {Det True, Det False} \\<union> Indet ` U\n\ngoal (1 subgoal):\n 1. change_int f i ` props p\n    \\<subseteq> {Det True, Det False} \\<union> Indet ` U \\<and>\n    inj f", "using f_p"], ["proof (prove)\nusing this:\n  change_int f i ` props p\n  \\<subseteq> {Det True, Det False} \\<union> Indet ` U\n  (\\<forall>n\\<in>get_indet ` (i ` props p \\<inter> Collect is_indet).\n      f n \\<in> U) \\<and>\n  inj f\n\ngoal (1 subgoal):\n 1. change_int f i ` props p\n    \\<subseteq> {Det True, Det False} \\<union> Indet ` U \\<and>\n    inj f", "by simp"], ["proof (state)\nthis:\n  change_int f i ` props p \\<subseteq> domain U \\<and> inj f\n\ngoal (1 subgoal):\n 1. \\<exists>f. change_int f i ` props p \\<subseteq> domain U \\<and> inj f", "then"], ["proof (chain)\npicking this:\n  change_int f i ` props p \\<subseteq> domain U \\<and> inj f", "show ?thesis"], ["proof (prove)\nusing this:\n  change_int f i ` props p \\<subseteq> domain U \\<and> inj f\n\ngoal (1 subgoal):\n 1. \\<exists>f. change_int f i ` props p \\<subseteq> domain U \\<and> inj f", "using f_p"], ["proof (prove)\nusing this:\n  change_int f i ` props p \\<subseteq> domain U \\<and> inj f\n  (\\<forall>n\\<in>get_indet ` (i ` props p \\<inter> Collect is_indet).\n      f n \\<in> U) \\<and>\n  inj f\n\ngoal (1 subgoal):\n 1. \\<exists>f. change_int f i ` props p \\<subseteq> domain U \\<and> inj f", "by metis"], ["proof (state)\nthis:\n  \\<exists>f. change_int f i ` props p \\<subseteq> domain U \\<and> inj f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f. change_int f i ` props p \\<subseteq> domain U \\<and> inj f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?U; card (props ?p) \\<le> card ?U\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f.\n                       change_int f i ` props ?p\n                       \\<subseteq> domain ?U \\<and>\n                       inj f\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        change_int f i ` props p \\<subseteq> domain U \\<and>\n        inj f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite ?U; card (props ?p) \\<le> card ?U\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f.\n                       change_int f i ` props ?p\n                       \\<subseteq> domain ?U \\<and>\n                       inj f", "show \"(\\<And>f. change_int f i ` props p \\<subseteq> domain U \\<and> inj f \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\""], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?U; card (props ?p) \\<le> card ?U\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f.\n                       change_int f i ` props ?p\n                       \\<subseteq> domain ?U \\<and>\n                       inj f\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        change_int f i ` props p \\<subseteq> domain U \\<and>\n        inj f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?U; card (props ?p) \\<le> card ?U\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f.\n                       change_int f i ` props ?p\n                       \\<subseteq> domain ?U \\<and>\n                       inj f\n  finite U\n  card (props p) \\<le> card U\n  valid_in U p\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        change_int f i ` props p \\<subseteq> domain U \\<and>\n        inj f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  (\\<And>f.\n      change_int f i ` props p \\<subseteq> domain U \\<and>\n      inj f \\<Longrightarrow>\n      thesis) \\<Longrightarrow>\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  change_int f i ` props p \\<subseteq> domain U \\<and> inj f\n\ngoal (1 subgoal):\n 1. \\<And>i. eval i p = Det True", "obtain i2 where i2: \"i2 = (\\<lambda>s. if s \\<in> props p then (change_int f i) s else Det True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i2.\n        i2 =\n        (\\<lambda>s.\n            if s \\<in> props p then change_int f i s\n            else Det True) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  i2 = (\\<lambda>s. if s \\<in> props p then change_int f i s else Det True)\n\ngoal (1 subgoal):\n 1. \\<And>i. eval i p = Det True", "then"], ["proof (chain)\npicking this:\n  i2 = (\\<lambda>s. if s \\<in> props p then change_int f i s else Det True)", "have i2_p: \"\\<forall>s \\<in> props p. i2 s = (change_int f i) s\"\n            \"\\<forall>s \\<in> - props p. i2 s = Det True\""], ["proof (prove)\nusing this:\n  i2 = (\\<lambda>s. if s \\<in> props p then change_int f i s else Det True)\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>props p. i2 s = change_int f i s &&&\n    \\<forall>s\\<in>- props p. i2 s = Det True", "by auto"], ["proof (state)\nthis:\n  \\<forall>s\\<in>props p. i2 s = change_int f i s\n  \\<forall>s\\<in>- props p. i2 s = Det True\n\ngoal (1 subgoal):\n 1. \\<And>i. eval i p = Det True", "then"], ["proof (chain)\npicking this:\n  \\<forall>s\\<in>props p. i2 s = change_int f i s\n  \\<forall>s\\<in>- props p. i2 s = Det True", "have \"range i2 \\<subseteq> (domain U)\""], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>props p. i2 s = change_int f i s\n  \\<forall>s\\<in>- props p. i2 s = Det True\n\ngoal (1 subgoal):\n 1. range i2 \\<subseteq> domain U", "using i2 f_p"], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>props p. i2 s = change_int f i s\n  \\<forall>s\\<in>- props p. i2 s = Det True\n  i2 = (\\<lambda>s. if s \\<in> props p then change_int f i s else Det True)\n  change_int f i ` props p \\<subseteq> domain U \\<and> inj f\n\ngoal (1 subgoal):\n 1. range i2 \\<subseteq> domain U", "unfolding domain_def"], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>props p. i2 s = change_int f i s\n  \\<forall>s\\<in>- props p. i2 s = Det True\n  i2 = (\\<lambda>s. if s \\<in> props p then change_int f i s else Det True)\n  change_int f i ` props p\n  \\<subseteq> {Det True, Det False} \\<union> Indet ` U \\<and>\n  inj f\n\ngoal (1 subgoal):\n 1. range i2 \\<subseteq> {Det True, Det False} \\<union> Indet ` U", "by auto"], ["proof (state)\nthis:\n  range i2 \\<subseteq> domain U\n\ngoal (1 subgoal):\n 1. \\<And>i. eval i p = Det True", "then"], ["proof (chain)\npicking this:\n  range i2 \\<subseteq> domain U", "have \"eval i2 p = Det True\""], ["proof (prove)\nusing this:\n  range i2 \\<subseteq> domain U\n\ngoal (1 subgoal):\n 1. eval i2 p = Det True", "using assms"], ["proof (prove)\nusing this:\n  range i2 \\<subseteq> domain U\n  finite U\n  card (props p) \\<le> card U\n  valid_in U p\n\ngoal (1 subgoal):\n 1. eval i2 p = Det True", "unfolding valid_in_def"], ["proof (prove)\nusing this:\n  range i2 \\<subseteq> domain U\n  finite U\n  card (props p) \\<le> card U\n  \\<forall>i.\n     range i \\<subseteq> domain U \\<longrightarrow> eval i p = Det True\n\ngoal (1 subgoal):\n 1. eval i2 p = Det True", "by auto"], ["proof (state)\nthis:\n  eval i2 p = Det True\n\ngoal (1 subgoal):\n 1. \\<And>i. eval i p = Det True", "then"], ["proof (chain)\npicking this:\n  eval i2 p = Det True", "have \"eval (change_int f i) p = Det True\""], ["proof (prove)\nusing this:\n  eval i2 p = Det True\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p = Det True", "using relevant_props[of p i2 \"change_int f i\"] i2_p"], ["proof (prove)\nusing this:\n  eval i2 p = Det True\n  \\<forall>s\\<in>props p. i2 s = change_int f i s \\<Longrightarrow>\n  eval i2 p = eval (change_int f i) p\n  \\<forall>s\\<in>props p. i2 s = change_int f i s\n  \\<forall>s\\<in>- props p. i2 s = Det True\n\ngoal (1 subgoal):\n 1. eval (change_int f i) p = Det True", "by auto"], ["proof (state)\nthis:\n  eval (change_int f i) p = Det True\n\ngoal (1 subgoal):\n 1. \\<And>i. eval i p = Det True", "then"], ["proof (chain)\npicking this:\n  eval (change_int f i) p = Det True", "have \"change_tv f (eval i p) = Det True\""], ["proof (prove)\nusing this:\n  eval (change_int f i) p = Det True\n\ngoal (1 subgoal):\n 1. change_tv f (eval i p) = Det True", "using eval_change f_p"], ["proof (prove)\nusing this:\n  eval (change_int f i) p = Det True\n  inj ?f \\<Longrightarrow>\n  eval (change_int ?f ?i) ?p = change_tv ?f (eval ?i ?p)\n  change_int f i ` props p \\<subseteq> domain U \\<and> inj f\n\ngoal (1 subgoal):\n 1. change_tv f (eval i p) = Det True", "by auto"], ["proof (state)\nthis:\n  change_tv f (eval i p) = Det True\n\ngoal (1 subgoal):\n 1. \\<And>i. eval i p = Det True", "then"], ["proof (chain)\npicking this:\n  change_tv f (eval i p) = Det True", "show \"eval i p = Det True\""], ["proof (prove)\nusing this:\n  change_tv f (eval i p) = Det True\n\ngoal (1 subgoal):\n 1. eval i p = Det True", "by (cases \"eval i p\") simp_all"], ["proof (state)\nthis:\n  eval i p = Det True\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?U; card (props ?p) \\<le> card ?U; valid_in ?U ?p\\<rbrakk>\n  \\<Longrightarrow> valid ?p\n\ngoal (1 subgoal):\n 1. valid p", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite ?U; card (props ?p) \\<le> card ?U; valid_in ?U ?p\\<rbrakk>\n  \\<Longrightarrow> valid ?p", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?U; card (props ?p) \\<le> card ?U; valid_in ?U ?p\\<rbrakk>\n  \\<Longrightarrow> valid ?p\n\ngoal (1 subgoal):\n 1. valid p", "using assms subsetI sup_bot.comm_neutral image_is_empty subsetCE UnCI valid_in_def\n        Un_insert_left card.empty card.infinite finite.intros(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?U; card (props ?p) \\<le> card ?U; valid_in ?U ?p\\<rbrakk>\n  \\<Longrightarrow> valid ?p\n  card (props p) \\<le> card U\n  valid_in U p\n  (\\<And>x. x \\<in> ?A \\<Longrightarrow> x \\<in> ?B) \\<Longrightarrow>\n  ?A \\<subseteq> ?B\n  sup ?a bot = ?a\n  (?f ` ?A = {}) = (?A = {})\n  \\<lbrakk>?A \\<subseteq> ?B; ?c \\<notin> ?A \\<Longrightarrow> ?P;\n   ?c \\<in> ?B \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  (?c \\<notin> ?B \\<Longrightarrow> ?c \\<in> ?A) \\<Longrightarrow>\n  ?c \\<in> ?A \\<union> ?B\n  valid_in ?U ?p \\<equiv>\n  \\<forall>i.\n     range i \\<subseteq> domain ?U \\<longrightarrow> eval i ?p = Det True\n  insert ?a ?B \\<union> ?C = insert ?a (?B \\<union> ?C)\n  card {} = 0\n  infinite ?A \\<Longrightarrow> card ?A = 0\n  finite {}\n\ngoal (1 subgoal):\n 1. valid p", "unfolding domain_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?U; card (props ?p) \\<le> card ?U; valid_in ?U ?p\\<rbrakk>\n  \\<Longrightarrow> valid ?p\n  card (props p) \\<le> card U\n  valid_in U p\n  (\\<And>x. x \\<in> ?A \\<Longrightarrow> x \\<in> ?B) \\<Longrightarrow>\n  ?A \\<subseteq> ?B\n  sup ?a bot = ?a\n  (?f ` ?A = {}) = (?A = {})\n  \\<lbrakk>?A \\<subseteq> ?B; ?c \\<notin> ?A \\<Longrightarrow> ?P;\n   ?c \\<in> ?B \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  (?c \\<notin> ?B \\<Longrightarrow> ?c \\<in> ?A) \\<Longrightarrow>\n  ?c \\<in> ?A \\<union> ?B\n  valid_in ?U ?p \\<equiv>\n  \\<forall>i.\n     range i\n     \\<subseteq> {Det True, Det False} \\<union> Indet ` ?U \\<longrightarrow>\n     eval i ?p = Det True\n  insert ?a ?B \\<union> ?C = insert ?a (?B \\<union> ?C)\n  card {} = 0\n  infinite ?A \\<Longrightarrow> card ?A = 0\n  finite {}\n\ngoal (1 subgoal):\n 1. valid p", "by metis"], ["proof (state)\nthis:\n  valid p\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem reduce: \"valid p \\<longleftrightarrow> valid_in {1..card (props p)} p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid p = valid_in {1..card (props p)} p", "using valid_in_valid transfer"], ["proof (prove)\nusing this:\n  \\<lbrakk>card (props ?p) \\<le> card ?U; valid_in ?U ?p\\<rbrakk>\n  \\<Longrightarrow> valid ?p\n  \\<not> valid_in ?U ?p \\<Longrightarrow> \\<not> valid ?p\n\ngoal (1 subgoal):\n 1. valid p = valid_in {1..card (props p)} p", "by force"], ["", "section \\<open>Case Study\\<close>"], ["", "subsection \\<open>Abbreviations\\<close>"], ["", "text\n\\<open>\nEntailment takes a list of assumptions.\n\\<close>"], ["", "abbreviation (input) Entail :: \"fm list \\<Rightarrow> fm \\<Rightarrow> fm\"\nwhere\n  \"Entail l p \\<equiv> Imp (if l = [] then Truth else fold Con' (butlast l) (last l)) p\""], ["", "theorem entailment_not_chain:\n  \"\\<not> valid (Eql (Entail [Pro ''p'', Pro ''q''] (Pro ''r''))\n      (Box ((Imp' (Pro ''p'') (Imp' (Pro ''q'') (Pro ''r''))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Eql (Imp (if [Pro ''p'', Pro ''q''] = [] then Truth\n                       else fold Con' (butlast [Pro ''p'', Pro ''q''])\n                             (last [Pro ''p'', Pro ''q'']))\n                   (Pro ''r''))\n              (Box (Imp' (Pro ''p'') (Imp' (Pro ''q'') (Pro ''r'')))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Eql (Imp (if [Pro ''p'', Pro ''q''] = [] then Truth\n                       else fold Con' (butlast [Pro ''p'', Pro ''q''])\n                             (last [Pro ''p'', Pro ''q'']))\n                   (Pro ''r''))\n              (Box (Imp' (Pro ''p'') (Imp' (Pro ''q'') (Pro ''r'')))))", "let ?i = \"(\\<lambda>s. Indet 1)(''r'' := Det False)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Eql (Imp (if [Pro ''p'', Pro ''q''] = [] then Truth\n                       else fold Con' (butlast [Pro ''p'', Pro ''q''])\n                             (last [Pro ''p'', Pro ''q'']))\n                   (Pro ''r''))\n              (Box (Imp' (Pro ''p'') (Imp' (Pro ''q'') (Pro ''r'')))))", "have \"eval ?i (Eql (Entail [Pro ''p'', Pro ''q''] (Pro ''r''))\n      (Box ((Imp' (Pro ''p'') (Imp' (Pro ''q'') (Pro ''r'')))))) = Det False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval ((\\<lambda>s. Indet 1)(''r'' := Det False))\n     (Eql (Imp (if [Pro ''p'', Pro ''q''] = [] then Truth\n                else fold Con' (butlast [Pro ''p'', Pro ''q''])\n                      (last [Pro ''p'', Pro ''q'']))\n            (Pro ''r''))\n       (Box (Imp' (Pro ''p'') (Imp' (Pro ''q'') (Pro ''r''))))) =\n    Det False", "by simp"], ["proof (state)\nthis:\n  eval ((\\<lambda>s. Indet 1)(''r'' := Det False))\n   (Eql (Imp (if [Pro ''p'', Pro ''q''] = [] then Truth\n              else fold Con' (butlast [Pro ''p'', Pro ''q''])\n                    (last [Pro ''p'', Pro ''q'']))\n          (Pro ''r''))\n     (Box (Imp' (Pro ''p'') (Imp' (Pro ''q'') (Pro ''r''))))) =\n  Det False\n\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Eql (Imp (if [Pro ''p'', Pro ''q''] = [] then Truth\n                       else fold Con' (butlast [Pro ''p'', Pro ''q''])\n                             (last [Pro ''p'', Pro ''q'']))\n                   (Pro ''r''))\n              (Box (Imp' (Pro ''p'') (Imp' (Pro ''q'') (Pro ''r'')))))", "moreover"], ["proof (state)\nthis:\n  eval ((\\<lambda>s. Indet 1)(''r'' := Det False))\n   (Eql (Imp (if [Pro ''p'', Pro ''q''] = [] then Truth\n              else fold Con' (butlast [Pro ''p'', Pro ''q''])\n                    (last [Pro ''p'', Pro ''q'']))\n          (Pro ''r''))\n     (Box (Imp' (Pro ''p'') (Imp' (Pro ''q'') (Pro ''r''))))) =\n  Det False\n\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Eql (Imp (if [Pro ''p'', Pro ''q''] = [] then Truth\n                       else fold Con' (butlast [Pro ''p'', Pro ''q''])\n                             (last [Pro ''p'', Pro ''q'']))\n                   (Pro ''r''))\n              (Box (Imp' (Pro ''p'') (Imp' (Pro ''q'') (Pro ''r'')))))", "have \"Det False \\<noteq> Det True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Det False \\<noteq> Det True", "by simp"], ["proof (state)\nthis:\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Eql (Imp (if [Pro ''p'', Pro ''q''] = [] then Truth\n                       else fold Con' (butlast [Pro ''p'', Pro ''q''])\n                             (last [Pro ''p'', Pro ''q'']))\n                   (Pro ''r''))\n              (Box (Imp' (Pro ''p'') (Imp' (Pro ''q'') (Pro ''r'')))))", "ultimately"], ["proof (chain)\npicking this:\n  eval ((\\<lambda>s. Indet 1)(''r'' := Det False))\n   (Eql (Imp (if [Pro ''p'', Pro ''q''] = [] then Truth\n              else fold Con' (butlast [Pro ''p'', Pro ''q''])\n                    (last [Pro ''p'', Pro ''q'']))\n          (Pro ''r''))\n     (Box (Imp' (Pro ''p'') (Imp' (Pro ''q'') (Pro ''r''))))) =\n  Det False\n  Det False \\<noteq> Det True", "show ?thesis"], ["proof (prove)\nusing this:\n  eval ((\\<lambda>s. Indet 1)(''r'' := Det False))\n   (Eql (Imp (if [Pro ''p'', Pro ''q''] = [] then Truth\n              else fold Con' (butlast [Pro ''p'', Pro ''q''])\n                    (last [Pro ''p'', Pro ''q'']))\n          (Pro ''r''))\n     (Box (Imp' (Pro ''p'') (Imp' (Pro ''q'') (Pro ''r''))))) =\n  Det False\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Eql (Imp (if [Pro ''p'', Pro ''q''] = [] then Truth\n                       else fold Con' (butlast [Pro ''p'', Pro ''q''])\n                             (last [Pro ''p'', Pro ''q'']))\n                   (Pro ''r''))\n              (Box (Imp' (Pro ''p'') (Imp' (Pro ''q'') (Pro ''r'')))))", "unfolding valid_def"], ["proof (prove)\nusing this:\n  eval ((\\<lambda>s. Indet 1)(''r'' := Det False))\n   (Eql (Imp (if [Pro ''p'', Pro ''q''] = [] then Truth\n              else fold Con' (butlast [Pro ''p'', Pro ''q''])\n                    (last [Pro ''p'', Pro ''q'']))\n          (Pro ''r''))\n     (Box (Imp' (Pro ''p'') (Imp' (Pro ''q'') (Pro ''r''))))) =\n  Det False\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i.\n               eval i\n                (Eql (Imp (if [Pro ''p'', Pro ''q''] = [] then Truth\n                           else fold Con' (butlast [Pro ''p'', Pro ''q''])\n                                 (last [Pro ''p'', Pro ''q'']))\n                       (Pro ''r''))\n                  (Box (Imp' (Pro ''p'') (Imp' (Pro ''q'') (Pro ''r''))))) =\n               Det True)", "by metis"], ["proof (state)\nthis:\n  \\<not> valid\n          (Eql (Imp (if [Pro ''p'', Pro ''q''] = [] then Truth\n                     else fold Con' (butlast [Pro ''p'', Pro ''q''])\n                           (last [Pro ''p'', Pro ''q'']))\n                 (Pro ''r''))\n            (Box (Imp' (Pro ''p'') (Imp' (Pro ''q'') (Pro ''r'')))))\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation (input) B0 :: fm where \"B0 \\<equiv> Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r''))\""], ["", "abbreviation (input) B1 :: fm where \"B1 \\<equiv> Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')\""], ["", "abbreviation (input) B2 :: fm where \"B2 \\<equiv> Imp' (Pro ''r'') (Pro ''s'')\""], ["", "abbreviation (input) B3 :: fm where \"B3 \\<equiv> Imp' (Neg' (Pro ''s'')) (Neg' (Pro ''r''))\""], ["", "subsection \\<open>Results\\<close>"], ["", "text\n\\<open>\nThe paraconsistent logic is usable in contrast to classical logic.\n\\<close>"], ["", "theorem classical_logic_is_not_usable: \"valid_boole (Entail [B0, B1] p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_boole\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')]))\n       p)", "unfolding valid_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       range i \\<subseteq> domain {} \\<longrightarrow>\n       eval i\n        (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')] =\n                 []\n              then Truth\n              else fold Con'\n                    (butlast\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')])\n                    (last\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')]))\n          p) =\n       Det True", "proof (rule; rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i\n        (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')] =\n                 []\n              then Truth\n              else fold Con'\n                    (butlast\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')])\n                    (last\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')]))\n          p) =\n       Det True", "fix i :: \"id \\<Rightarrow> tv\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i\n        (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')] =\n                 []\n              then Truth\n              else fold Con'\n                    (butlast\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')])\n                    (last\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')]))\n          p) =\n       Det True", "assume \"range i \\<subseteq> domain {}\""], ["proof (state)\nthis:\n  range i \\<subseteq> domain {}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i\n        (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')] =\n                 []\n              then Truth\n              else fold Con'\n                    (butlast\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')])\n                    (last\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')]))\n          p) =\n       Det True", "then"], ["proof (chain)\npicking this:\n  range i \\<subseteq> domain {}", "have\n      \"i ''p'' \\<in> {Det True, Det False}\"\n      \"i ''q'' \\<in> {Det True, Det False}\"\n      \"i ''r'' \\<in> {Det True, Det False}\""], ["proof (prove)\nusing this:\n  range i \\<subseteq> domain {}\n\ngoal (1 subgoal):\n 1. i ''p'' \\<in> {Det True, Det False} &&&\n    i ''q'' \\<in> {Det True, Det False} &&&\n    i ''r'' \\<in> {Det True, Det False}", "unfolding domain_def"], ["proof (prove)\nusing this:\n  range i \\<subseteq> {Det True, Det False} \\<union> Indet ` {}\n\ngoal (1 subgoal):\n 1. i ''p'' \\<in> {Det True, Det False} &&&\n    i ''q'' \\<in> {Det True, Det False} &&&\n    i ''r'' \\<in> {Det True, Det False}", "by auto"], ["proof (state)\nthis:\n  i ''p'' \\<in> {Det True, Det False}\n  i ''q'' \\<in> {Det True, Det False}\n  i ''r'' \\<in> {Det True, Det False}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i\n        (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')] =\n                 []\n              then Truth\n              else fold Con'\n                    (butlast\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')])\n                    (last\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')]))\n          p) =\n       Det True", "then"], ["proof (chain)\npicking this:\n  i ''p'' \\<in> {Det True, Det False}\n  i ''q'' \\<in> {Det True, Det False}\n  i ''r'' \\<in> {Det True, Det False}", "show \"eval i (Entail [B0, B1] p) = Det True\""], ["proof (prove)\nusing this:\n  i ''p'' \\<in> {Det True, Det False}\n  i ''q'' \\<in> {Det True, Det False}\n  i ''r'' \\<in> {Det True, Det False}\n\ngoal (1 subgoal):\n 1. eval i\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')]))\n       p) =\n    Det True", "by (cases \"i ''p''\"; cases \"i ''q''\"; cases \"i ''r''\") simp_all"], ["proof (state)\nthis:\n  eval i\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')]))\n     p) =\n  Det True\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary \"valid_boole (Entail [B0, B1] (Pro ''r''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_boole\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')]))\n       (Pro ''r''))", "by (rule classical_logic_is_not_usable)"], ["", "corollary \"valid_boole (Entail [B0, B1] (Neg' (Pro ''r'')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_boole\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')]))\n       (Neg' (Pro ''r'')))", "by (rule classical_logic_is_not_usable)"], ["", "proposition \"\\<not> valid (Entail [B0, B1] (Pro ''r''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Imp' (Con' (Pro ''p'') (Pro ''q''))\n                            (Pro ''r'')]))\n              (Pro ''r''))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Imp' (Con' (Pro ''p'') (Pro ''q''))\n                            (Pro ''r'')]))\n              (Pro ''r''))", "let ?i = \"(\\<lambda>s. Indet 1)(''r'' := Det False)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Imp' (Con' (Pro ''p'') (Pro ''q''))\n                            (Pro ''r'')]))\n              (Pro ''r''))", "have \"eval ?i (Entail [B0, B1] (Pro ''r'')) = Det False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval ((\\<lambda>s. Indet 1)(''r'' := Det False))\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')]))\n       (Pro ''r'')) =\n    Det False", "by simp"], ["proof (state)\nthis:\n  eval ((\\<lambda>s. Indet 1)(''r'' := Det False))\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')]))\n     (Pro ''r'')) =\n  Det False\n\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Imp' (Con' (Pro ''p'') (Pro ''q''))\n                            (Pro ''r'')]))\n              (Pro ''r''))", "moreover"], ["proof (state)\nthis:\n  eval ((\\<lambda>s. Indet 1)(''r'' := Det False))\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')]))\n     (Pro ''r'')) =\n  Det False\n\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Imp' (Con' (Pro ''p'') (Pro ''q''))\n                            (Pro ''r'')]))\n              (Pro ''r''))", "have \"Det False \\<noteq> Det True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Det False \\<noteq> Det True", "by simp"], ["proof (state)\nthis:\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Imp' (Con' (Pro ''p'') (Pro ''q''))\n                            (Pro ''r'')]))\n              (Pro ''r''))", "ultimately"], ["proof (chain)\npicking this:\n  eval ((\\<lambda>s. Indet 1)(''r'' := Det False))\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')]))\n     (Pro ''r'')) =\n  Det False\n  Det False \\<noteq> Det True", "show ?thesis"], ["proof (prove)\nusing this:\n  eval ((\\<lambda>s. Indet 1)(''r'' := Det False))\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')]))\n     (Pro ''r'')) =\n  Det False\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Imp' (Con' (Pro ''p'') (Pro ''q''))\n                            (Pro ''r'')]))\n              (Pro ''r''))", "unfolding valid_def"], ["proof (prove)\nusing this:\n  eval ((\\<lambda>s. Indet 1)(''r'' := Det False))\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')]))\n     (Pro ''r'')) =\n  Det False\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i.\n               eval i\n                (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                           (Neg' (Pro ''r'')),\n                          Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')] =\n                         []\n                      then Truth\n                      else fold Con'\n                            (butlast\n                              [Con' (Con' (Pro ''p'') (Pro ''q''))\n                                (Neg' (Pro ''r'')),\n                               Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                (Pro ''r'')])\n                            (last\n                              [Con' (Con' (Pro ''p'') (Pro ''q''))\n                                (Neg' (Pro ''r'')),\n                               Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                (Pro ''r'')]))\n                  (Pro ''r'')) =\n               Det True)", "by metis"], ["proof (state)\nthis:\n  \\<not> valid\n          (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')] =\n                   []\n                then Truth\n                else fold Con'\n                      (butlast\n                        [Con' (Con' (Pro ''p'') (Pro ''q''))\n                          (Neg' (Pro ''r'')),\n                         Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')])\n                      (last\n                        [Con' (Con' (Pro ''p'') (Pro ''q''))\n                          (Neg' (Pro ''r'')),\n                         Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')]))\n            (Pro ''r''))\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition \"valid_boole (Entail [B0, Box B1] p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_boole\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r''))]))\n       p)", "unfolding valid_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       range i \\<subseteq> domain {} \\<longrightarrow>\n       eval i\n        (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r''))] =\n                 []\n              then Truth\n              else fold Con'\n                    (butlast\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r''))])\n                    (last\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r''))]))\n          p) =\n       Det True", "proof (rule; rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i\n        (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r''))] =\n                 []\n              then Truth\n              else fold Con'\n                    (butlast\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r''))])\n                    (last\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r''))]))\n          p) =\n       Det True", "fix i :: \"id \\<Rightarrow> tv\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i\n        (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r''))] =\n                 []\n              then Truth\n              else fold Con'\n                    (butlast\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r''))])\n                    (last\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r''))]))\n          p) =\n       Det True", "assume \"range i \\<subseteq> domain {}\""], ["proof (state)\nthis:\n  range i \\<subseteq> domain {}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i\n        (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r''))] =\n                 []\n              then Truth\n              else fold Con'\n                    (butlast\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r''))])\n                    (last\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r''))]))\n          p) =\n       Det True", "then"], ["proof (chain)\npicking this:\n  range i \\<subseteq> domain {}", "have\n      \"i ''p'' \\<in> {Det True, Det False}\"\n      \"i ''q'' \\<in> {Det True, Det False}\"\n      \"i ''r'' \\<in> {Det True, Det False}\""], ["proof (prove)\nusing this:\n  range i \\<subseteq> domain {}\n\ngoal (1 subgoal):\n 1. i ''p'' \\<in> {Det True, Det False} &&&\n    i ''q'' \\<in> {Det True, Det False} &&&\n    i ''r'' \\<in> {Det True, Det False}", "unfolding domain_def"], ["proof (prove)\nusing this:\n  range i \\<subseteq> {Det True, Det False} \\<union> Indet ` {}\n\ngoal (1 subgoal):\n 1. i ''p'' \\<in> {Det True, Det False} &&&\n    i ''q'' \\<in> {Det True, Det False} &&&\n    i ''r'' \\<in> {Det True, Det False}", "by auto"], ["proof (state)\nthis:\n  i ''p'' \\<in> {Det True, Det False}\n  i ''q'' \\<in> {Det True, Det False}\n  i ''r'' \\<in> {Det True, Det False}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {} \\<Longrightarrow>\n       eval i\n        (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r''))] =\n                 []\n              then Truth\n              else fold Con'\n                    (butlast\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r''))])\n                    (last\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r''))]))\n          p) =\n       Det True", "then"], ["proof (chain)\npicking this:\n  i ''p'' \\<in> {Det True, Det False}\n  i ''q'' \\<in> {Det True, Det False}\n  i ''r'' \\<in> {Det True, Det False}", "show \"eval i (Entail [B0, Box B1] p) = Det True\""], ["proof (prove)\nusing this:\n  i ''p'' \\<in> {Det True, Det False}\n  i ''q'' \\<in> {Det True, Det False}\n  i ''r'' \\<in> {Det True, Det False}\n\ngoal (1 subgoal):\n 1. eval i\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r''))]))\n       p) =\n    Det True", "by (cases \"i ''p''\"; cases \"i ''q''\"; cases \"i ''r''\") simp_all"], ["proof (state)\nthis:\n  eval i\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r''))]))\n     p) =\n  Det True\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition \"\\<not> valid (Entail [B0, Box B1, Box B2] (Neg' (Pro ''p'')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                      Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))]))\n              (Neg' (Pro ''p'')))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                      Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))]))\n              (Neg' (Pro ''p'')))", "let ?i = \"(\\<lambda>s. Indet 1)(''p'' := Det True)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                      Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))]))\n              (Neg' (Pro ''p'')))", "have \"eval ?i (Entail [B0, Box B1, Box B2] (Neg' (Pro ''p''))) = Det False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval ((\\<lambda>s. Indet 1)(''p'' := Det True))\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Neg' (Pro ''p''))) =\n    Det False", "by simp"], ["proof (state)\nthis:\n  eval ((\\<lambda>s. Indet 1)(''p'' := Det True))\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Neg' (Pro ''p''))) =\n  Det False\n\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                      Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))]))\n              (Neg' (Pro ''p'')))", "moreover"], ["proof (state)\nthis:\n  eval ((\\<lambda>s. Indet 1)(''p'' := Det True))\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Neg' (Pro ''p''))) =\n  Det False\n\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                      Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))]))\n              (Neg' (Pro ''p'')))", "have \"Det False \\<noteq> Det True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Det False \\<noteq> Det True", "by simp"], ["proof (state)\nthis:\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                      Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))]))\n              (Neg' (Pro ''p'')))", "ultimately"], ["proof (chain)\npicking this:\n  eval ((\\<lambda>s. Indet 1)(''p'' := Det True))\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Neg' (Pro ''p''))) =\n  Det False\n  Det False \\<noteq> Det True", "show ?thesis"], ["proof (prove)\nusing this:\n  eval ((\\<lambda>s. Indet 1)(''p'' := Det True))\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Neg' (Pro ''p''))) =\n  Det False\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                      Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))]))\n              (Neg' (Pro ''p'')))", "unfolding valid_def"], ["proof (prove)\nusing this:\n  eval ((\\<lambda>s. Indet 1)(''p'' := Det True))\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Neg' (Pro ''p''))) =\n  Det False\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i.\n               eval i\n                (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                           (Neg' (Pro ''r'')),\n                          Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                (Pro ''r'')),\n                          Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                         []\n                      then Truth\n                      else fold Con'\n                            (butlast\n                              [Con' (Con' (Pro ''p'') (Pro ''q''))\n                                (Neg' (Pro ''r'')),\n                               Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                     (Pro ''r'')),\n                               Box (Imp' (Pro ''r'') (Pro ''s''))])\n                            (last\n                              [Con' (Con' (Pro ''p'') (Pro ''q''))\n                                (Neg' (Pro ''r'')),\n                               Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                     (Pro ''r'')),\n                               Box (Imp' (Pro ''r'') (Pro ''s''))]))\n                  (Neg' (Pro ''p''))) =\n               Det True)", "by metis"], ["proof (state)\nthis:\n  \\<not> valid\n          (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                   []\n                then Truth\n                else fold Con'\n                      (butlast\n                        [Con' (Con' (Pro ''p'') (Pro ''q''))\n                          (Neg' (Pro ''r'')),\n                         Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                               (Pro ''r'')),\n                         Box (Imp' (Pro ''r'') (Pro ''s''))])\n                      (last\n                        [Con' (Con' (Pro ''p'') (Pro ''q''))\n                          (Neg' (Pro ''r'')),\n                         Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                               (Pro ''r'')),\n                         Box (Imp' (Pro ''r'') (Pro ''s''))]))\n            (Neg' (Pro ''p'')))\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition \"\\<not> valid (Entail [B0, Box B1, Box B2] (Neg' (Pro ''q'')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                      Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))]))\n              (Neg' (Pro ''q'')))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                      Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))]))\n              (Neg' (Pro ''q'')))", "let ?i = \"(\\<lambda>s. Indet 1)(''q'' := Det True)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                      Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))]))\n              (Neg' (Pro ''q'')))", "have \"eval ?i (Entail [B0, Box B1, Box B2] (Neg' (Pro ''q''))) = Det False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval ((\\<lambda>s. Indet 1)(''q'' := Det True))\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Neg' (Pro ''q''))) =\n    Det False", "by simp"], ["proof (state)\nthis:\n  eval ((\\<lambda>s. Indet 1)(''q'' := Det True))\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Neg' (Pro ''q''))) =\n  Det False\n\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                      Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))]))\n              (Neg' (Pro ''q'')))", "moreover"], ["proof (state)\nthis:\n  eval ((\\<lambda>s. Indet 1)(''q'' := Det True))\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Neg' (Pro ''q''))) =\n  Det False\n\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                      Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))]))\n              (Neg' (Pro ''q'')))", "have \"Det False \\<noteq> Det True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Det False \\<noteq> Det True", "by simp"], ["proof (state)\nthis:\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                      Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))]))\n              (Neg' (Pro ''q'')))", "ultimately"], ["proof (chain)\npicking this:\n  eval ((\\<lambda>s. Indet 1)(''q'' := Det True))\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Neg' (Pro ''q''))) =\n  Det False\n  Det False \\<noteq> Det True", "show ?thesis"], ["proof (prove)\nusing this:\n  eval ((\\<lambda>s. Indet 1)(''q'' := Det True))\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Neg' (Pro ''q''))) =\n  Det False\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                      Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))]))\n              (Neg' (Pro ''q'')))", "unfolding valid_def"], ["proof (prove)\nusing this:\n  eval ((\\<lambda>s. Indet 1)(''q'' := Det True))\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Neg' (Pro ''q''))) =\n  Det False\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i.\n               eval i\n                (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                           (Neg' (Pro ''r'')),\n                          Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                (Pro ''r'')),\n                          Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                         []\n                      then Truth\n                      else fold Con'\n                            (butlast\n                              [Con' (Con' (Pro ''p'') (Pro ''q''))\n                                (Neg' (Pro ''r'')),\n                               Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                     (Pro ''r'')),\n                               Box (Imp' (Pro ''r'') (Pro ''s''))])\n                            (last\n                              [Con' (Con' (Pro ''p'') (Pro ''q''))\n                                (Neg' (Pro ''r'')),\n                               Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                     (Pro ''r'')),\n                               Box (Imp' (Pro ''r'') (Pro ''s''))]))\n                  (Neg' (Pro ''q''))) =\n               Det True)", "by metis"], ["proof (state)\nthis:\n  \\<not> valid\n          (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                   []\n                then Truth\n                else fold Con'\n                      (butlast\n                        [Con' (Con' (Pro ''p'') (Pro ''q''))\n                          (Neg' (Pro ''r'')),\n                         Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                               (Pro ''r'')),\n                         Box (Imp' (Pro ''r'') (Pro ''s''))])\n                      (last\n                        [Con' (Con' (Pro ''p'') (Pro ''q''))\n                          (Neg' (Pro ''r'')),\n                         Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                               (Pro ''r'')),\n                         Box (Imp' (Pro ''r'') (Pro ''s''))]))\n            (Neg' (Pro ''q'')))\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition \"\\<not> valid (Entail [B0, Box B1, Box B2] (Neg' (Pro ''s'')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                      Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))]))\n              (Neg' (Pro ''s'')))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                      Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))]))\n              (Neg' (Pro ''s'')))", "let ?i = \"(\\<lambda>s. Indet 1)(''s'' := Det True)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                      Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))]))\n              (Neg' (Pro ''s'')))", "have \"eval ?i (Entail [B0, Box B1, Box B2] (Neg' (Pro ''s''))) = Det False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval ((\\<lambda>s. Indet 1)(''s'' := Det True))\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Neg' (Pro ''s''))) =\n    Det False", "by simp"], ["proof (state)\nthis:\n  eval ((\\<lambda>s. Indet 1)(''s'' := Det True))\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Neg' (Pro ''s''))) =\n  Det False\n\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                      Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))]))\n              (Neg' (Pro ''s'')))", "moreover"], ["proof (state)\nthis:\n  eval ((\\<lambda>s. Indet 1)(''s'' := Det True))\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Neg' (Pro ''s''))) =\n  Det False\n\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                      Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))]))\n              (Neg' (Pro ''s'')))", "have \"Det False \\<noteq> Det True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Det False \\<noteq> Det True", "by simp"], ["proof (state)\nthis:\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                      Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))]))\n              (Neg' (Pro ''s'')))", "ultimately"], ["proof (chain)\npicking this:\n  eval ((\\<lambda>s. Indet 1)(''s'' := Det True))\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Neg' (Pro ''s''))) =\n  Det False\n  Det False \\<noteq> Det True", "show ?thesis"], ["proof (prove)\nusing this:\n  eval ((\\<lambda>s. Indet 1)(''s'' := Det True))\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Neg' (Pro ''s''))) =\n  Det False\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> valid\n            (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                       (Neg' (Pro ''r'')),\n                      Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                      Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                     []\n                  then Truth\n                  else fold Con'\n                        (butlast\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))])\n                        (last\n                          [Con' (Con' (Pro ''p'') (Pro ''q''))\n                            (Neg' (Pro ''r'')),\n                           Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                 (Pro ''r'')),\n                           Box (Imp' (Pro ''r'') (Pro ''s''))]))\n              (Neg' (Pro ''s'')))", "unfolding valid_def"], ["proof (prove)\nusing this:\n  eval ((\\<lambda>s. Indet 1)(''s'' := Det True))\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Neg' (Pro ''s''))) =\n  Det False\n  Det False \\<noteq> Det True\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i.\n               eval i\n                (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q''))\n                           (Neg' (Pro ''r'')),\n                          Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                (Pro ''r'')),\n                          Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                         []\n                      then Truth\n                      else fold Con'\n                            (butlast\n                              [Con' (Con' (Pro ''p'') (Pro ''q''))\n                                (Neg' (Pro ''r'')),\n                               Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                     (Pro ''r'')),\n                               Box (Imp' (Pro ''r'') (Pro ''s''))])\n                            (last\n                              [Con' (Con' (Pro ''p'') (Pro ''q''))\n                                (Neg' (Pro ''r'')),\n                               Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                     (Pro ''r'')),\n                               Box (Imp' (Pro ''r'') (Pro ''s''))]))\n                  (Neg' (Pro ''s''))) =\n               Det True)", "by metis"], ["proof (state)\nthis:\n  \\<not> valid\n          (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                   []\n                then Truth\n                else fold Con'\n                      (butlast\n                        [Con' (Con' (Pro ''p'') (Pro ''q''))\n                          (Neg' (Pro ''r'')),\n                         Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                               (Pro ''r'')),\n                         Box (Imp' (Pro ''r'') (Pro ''s''))])\n                      (last\n                        [Con' (Con' (Pro ''p'') (Pro ''q''))\n                          (Neg' (Pro ''r'')),\n                         Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                               (Pro ''r'')),\n                         Box (Imp' (Pro ''r'') (Pro ''s''))]))\n            (Neg' (Pro ''s'')))\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition \"valid (Entail [B0, Box B1, Box B2] (Pro ''r''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Pro ''r''))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Pro ''r''))", "have \"{1..card (props (Entail [B0, Box B1, Box B2] (Pro ''r'')))} = {1, 2, 3, 4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {1..card\n         (props\n           (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                     Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                     Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                    []\n                 then Truth\n                 else fold Con'\n                       (butlast\n                         [Con' (Con' (Pro ''p'') (Pro ''q''))\n                           (Neg' (Pro ''r'')),\n                          Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                (Pro ''r'')),\n                          Box (Imp' (Pro ''r'') (Pro ''s''))])\n                       (last\n                         [Con' (Con' (Pro ''p'') (Pro ''q''))\n                           (Neg' (Pro ''r'')),\n                          Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                (Pro ''r'')),\n                          Box (Imp' (Pro ''r'') (Pro ''s''))]))\n             (Pro ''r'')))} =\n    {1, 2, 3, 4}", "by code_simp"], ["proof (state)\nthis:\n  {1..card\n       (props\n         (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                   Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                   Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                  []\n               then Truth\n               else fold Con'\n                     (butlast\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))])\n                     (last\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))]))\n           (Pro ''r'')))} =\n  {1, 2, 3, 4}\n\ngoal (1 subgoal):\n 1. valid\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Pro ''r''))", "moreover"], ["proof (state)\nthis:\n  {1..card\n       (props\n         (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                   Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                   Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                  []\n               then Truth\n               else fold Con'\n                     (butlast\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))])\n                     (last\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))]))\n           (Pro ''r'')))} =\n  {1, 2, 3, 4}\n\ngoal (1 subgoal):\n 1. valid\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Pro ''r''))", "have \"valid_in {1, 2, 3, 4} (Entail [B0, Box B1, Box B2] (Pro ''r''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_in {1, 2, 3, 4}\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Pro ''r''))", "unfolding valid_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       range i \\<subseteq> domain {1, 2, 3, 4} \\<longrightarrow>\n       eval i\n        (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                 []\n              then Truth\n              else fold Con'\n                    (butlast\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))])\n                    (last\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))]))\n          (Pro ''r'')) =\n       Det True", "proof (rule; rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1, 2, 3, 4} \\<Longrightarrow>\n       eval i\n        (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                 []\n              then Truth\n              else fold Con'\n                    (butlast\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))])\n                    (last\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))]))\n          (Pro ''r'')) =\n       Det True", "fix i :: \"id \\<Rightarrow> tv\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1, 2, 3, 4} \\<Longrightarrow>\n       eval i\n        (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                 []\n              then Truth\n              else fold Con'\n                    (butlast\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))])\n                    (last\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))]))\n          (Pro ''r'')) =\n       Det True", "assume \"range i \\<subseteq> domain {1, 2, 3, 4}\""], ["proof (state)\nthis:\n  range i \\<subseteq> domain {1, 2, 3, 4}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1, 2, 3, 4} \\<Longrightarrow>\n       eval i\n        (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                 []\n              then Truth\n              else fold Con'\n                    (butlast\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))])\n                    (last\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))]))\n          (Pro ''r'')) =\n       Det True", "then"], ["proof (chain)\npicking this:\n  range i \\<subseteq> domain {1, 2, 3, 4}", "have icase:\n      \"i ''p'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\"\n      \"i ''q'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\"\n      \"i ''r'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\"\n      \"i ''s'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\""], ["proof (prove)\nusing this:\n  range i \\<subseteq> domain {1, 2, 3, 4}\n\ngoal (1 subgoal):\n 1. (i ''p''\n     \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4} &&&\n     i ''q''\n     \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}) &&&\n    i ''r''\n    \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4} &&&\n    i ''s'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}", "unfolding domain_def"], ["proof (prove)\nusing this:\n  range i \\<subseteq> {Det True, Det False} \\<union> Indet ` {1, 2, 3, 4}\n\ngoal (1 subgoal):\n 1. (i ''p''\n     \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4} &&&\n     i ''q''\n     \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}) &&&\n    i ''r''\n    \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4} &&&\n    i ''s'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}", "by auto"], ["proof (state)\nthis:\n  i ''p'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\n  i ''q'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\n  i ''r'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\n  i ''s'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1, 2, 3, 4} \\<Longrightarrow>\n       eval i\n        (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                 []\n              then Truth\n              else fold Con'\n                    (butlast\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))])\n                    (last\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))]))\n          (Pro ''r'')) =\n       Det True", "show \"eval i (Entail [B0, Box B1, Box B2] (Pro ''r'')) = Det True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval i\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Pro ''r'')) =\n    Det True", "using icase"], ["proof (prove)\nusing this:\n  i ''p'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\n  i ''q'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\n  i ''r'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\n  i ''s'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\n\ngoal (1 subgoal):\n 1. eval i\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Pro ''r'')) =\n    Det True", "by (cases \"i ''p''\"; cases \"i ''q''\"; cases \"i ''r''\"; cases \"i ''s''\") simp_all"], ["proof (state)\nthis:\n  eval i\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Pro ''r'')) =\n  Det True\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_in {1, 2, 3, 4}\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Pro ''r''))\n\ngoal (1 subgoal):\n 1. valid\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Pro ''r''))", "ultimately"], ["proof (chain)\npicking this:\n  {1..card\n       (props\n         (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                   Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                   Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                  []\n               then Truth\n               else fold Con'\n                     (butlast\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))])\n                     (last\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))]))\n           (Pro ''r'')))} =\n  {1, 2, 3, 4}\n  valid_in {1, 2, 3, 4}\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Pro ''r''))", "show ?thesis"], ["proof (prove)\nusing this:\n  {1..card\n       (props\n         (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                   Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                   Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                  []\n               then Truth\n               else fold Con'\n                     (butlast\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))])\n                     (last\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))]))\n           (Pro ''r'')))} =\n  {1, 2, 3, 4}\n  valid_in {1, 2, 3, 4}\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Pro ''r''))\n\ngoal (1 subgoal):\n 1. valid\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Pro ''r''))", "using reduce"], ["proof (prove)\nusing this:\n  {1..card\n       (props\n         (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                   Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                   Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                  []\n               then Truth\n               else fold Con'\n                     (butlast\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))])\n                     (last\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))]))\n           (Pro ''r'')))} =\n  {1, 2, 3, 4}\n  valid_in {1, 2, 3, 4}\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Pro ''r''))\n  valid ?p = valid_in {1..card (props ?p)} ?p\n\ngoal (1 subgoal):\n 1. valid\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Pro ''r''))", "by simp"], ["proof (state)\nthis:\n  valid\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Pro ''r''))\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition \"valid (Entail [B0, Box B1, Box B2] (Neg' (Pro ''r'')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Neg' (Pro ''r'')))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Neg' (Pro ''r'')))", "have \"{1..card (props (Entail [B0, Box B1, Box B2] (Neg' (Pro ''r''))))} = {1, 2, 3, 4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {1..card\n         (props\n           (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                     Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                     Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                    []\n                 then Truth\n                 else fold Con'\n                       (butlast\n                         [Con' (Con' (Pro ''p'') (Pro ''q''))\n                           (Neg' (Pro ''r'')),\n                          Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                (Pro ''r'')),\n                          Box (Imp' (Pro ''r'') (Pro ''s''))])\n                       (last\n                         [Con' (Con' (Pro ''p'') (Pro ''q''))\n                           (Neg' (Pro ''r'')),\n                          Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                (Pro ''r'')),\n                          Box (Imp' (Pro ''r'') (Pro ''s''))]))\n             (Neg' (Pro ''r''))))} =\n    {1, 2, 3, 4}", "by code_simp"], ["proof (state)\nthis:\n  {1..card\n       (props\n         (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                   Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                   Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                  []\n               then Truth\n               else fold Con'\n                     (butlast\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))])\n                     (last\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))]))\n           (Neg' (Pro ''r''))))} =\n  {1, 2, 3, 4}\n\ngoal (1 subgoal):\n 1. valid\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Neg' (Pro ''r'')))", "moreover"], ["proof (state)\nthis:\n  {1..card\n       (props\n         (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                   Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                   Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                  []\n               then Truth\n               else fold Con'\n                     (butlast\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))])\n                     (last\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))]))\n           (Neg' (Pro ''r''))))} =\n  {1, 2, 3, 4}\n\ngoal (1 subgoal):\n 1. valid\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Neg' (Pro ''r'')))", "have \"valid_in {1, 2, 3, 4} (Entail [B0, Box B1, Box B2] (Neg' (Pro ''r'')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_in {1, 2, 3, 4}\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Neg' (Pro ''r'')))", "unfolding valid_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       range i \\<subseteq> domain {1, 2, 3, 4} \\<longrightarrow>\n       eval i\n        (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                 []\n              then Truth\n              else fold Con'\n                    (butlast\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))])\n                    (last\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))]))\n          (Neg' (Pro ''r''))) =\n       Det True", "proof (rule; rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1, 2, 3, 4} \\<Longrightarrow>\n       eval i\n        (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                 []\n              then Truth\n              else fold Con'\n                    (butlast\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))])\n                    (last\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))]))\n          (Neg' (Pro ''r''))) =\n       Det True", "fix i :: \"id \\<Rightarrow> tv\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1, 2, 3, 4} \\<Longrightarrow>\n       eval i\n        (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                 []\n              then Truth\n              else fold Con'\n                    (butlast\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))])\n                    (last\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))]))\n          (Neg' (Pro ''r''))) =\n       Det True", "assume \"range i \\<subseteq> domain {1, 2, 3, 4}\""], ["proof (state)\nthis:\n  range i \\<subseteq> domain {1, 2, 3, 4}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1, 2, 3, 4} \\<Longrightarrow>\n       eval i\n        (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                 []\n              then Truth\n              else fold Con'\n                    (butlast\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))])\n                    (last\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))]))\n          (Neg' (Pro ''r''))) =\n       Det True", "then"], ["proof (chain)\npicking this:\n  range i \\<subseteq> domain {1, 2, 3, 4}", "have icase:\n      \"i ''p'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\"\n      \"i ''q'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\"\n      \"i ''r'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\"\n      \"i ''s'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\""], ["proof (prove)\nusing this:\n  range i \\<subseteq> domain {1, 2, 3, 4}\n\ngoal (1 subgoal):\n 1. (i ''p''\n     \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4} &&&\n     i ''q''\n     \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}) &&&\n    i ''r''\n    \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4} &&&\n    i ''s'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}", "unfolding domain_def"], ["proof (prove)\nusing this:\n  range i \\<subseteq> {Det True, Det False} \\<union> Indet ` {1, 2, 3, 4}\n\ngoal (1 subgoal):\n 1. (i ''p''\n     \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4} &&&\n     i ''q''\n     \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}) &&&\n    i ''r''\n    \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4} &&&\n    i ''s'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}", "by auto"], ["proof (state)\nthis:\n  i ''p'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\n  i ''q'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\n  i ''r'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\n  i ''s'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1, 2, 3, 4} \\<Longrightarrow>\n       eval i\n        (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                 []\n              then Truth\n              else fold Con'\n                    (butlast\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))])\n                    (last\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))]))\n          (Neg' (Pro ''r''))) =\n       Det True", "show \"eval i (Entail [B0, Box B1, Box B2] (Neg' (Pro ''r''))) = Det True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval i\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Neg' (Pro ''r''))) =\n    Det True", "using icase"], ["proof (prove)\nusing this:\n  i ''p'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\n  i ''q'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\n  i ''r'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\n  i ''s'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\n\ngoal (1 subgoal):\n 1. eval i\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Neg' (Pro ''r''))) =\n    Det True", "by (cases \"i ''p''\"; cases \"i ''q''\"; cases \"i ''r''\"; cases \"i ''s''\") simp_all"], ["proof (state)\nthis:\n  eval i\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Neg' (Pro ''r''))) =\n  Det True\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_in {1, 2, 3, 4}\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Neg' (Pro ''r'')))\n\ngoal (1 subgoal):\n 1. valid\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Neg' (Pro ''r'')))", "ultimately"], ["proof (chain)\npicking this:\n  {1..card\n       (props\n         (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                   Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                   Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                  []\n               then Truth\n               else fold Con'\n                     (butlast\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))])\n                     (last\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))]))\n           (Neg' (Pro ''r''))))} =\n  {1, 2, 3, 4}\n  valid_in {1, 2, 3, 4}\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Neg' (Pro ''r'')))", "show ?thesis"], ["proof (prove)\nusing this:\n  {1..card\n       (props\n         (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                   Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                   Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                  []\n               then Truth\n               else fold Con'\n                     (butlast\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))])\n                     (last\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))]))\n           (Neg' (Pro ''r''))))} =\n  {1, 2, 3, 4}\n  valid_in {1, 2, 3, 4}\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Neg' (Pro ''r'')))\n\ngoal (1 subgoal):\n 1. valid\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Neg' (Pro ''r'')))", "using reduce"], ["proof (prove)\nusing this:\n  {1..card\n       (props\n         (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                   Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                   Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                  []\n               then Truth\n               else fold Con'\n                     (butlast\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))])\n                     (last\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))]))\n           (Neg' (Pro ''r''))))} =\n  {1, 2, 3, 4}\n  valid_in {1, 2, 3, 4}\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Neg' (Pro ''r'')))\n  valid ?p = valid_in {1..card (props ?p)} ?p\n\ngoal (1 subgoal):\n 1. valid\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Neg' (Pro ''r'')))", "by simp"], ["proof (state)\nthis:\n  valid\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Neg' (Pro ''r'')))\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition \"valid (Entail [B0, Box B1, Box B2] (Pro ''s''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Pro ''s''))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Pro ''s''))", "have \"{1..card (props (Entail [B0, Box B1, Box B2] (Pro ''s'')))} = {1, 2, 3, 4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {1..card\n         (props\n           (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                     Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                     Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                    []\n                 then Truth\n                 else fold Con'\n                       (butlast\n                         [Con' (Con' (Pro ''p'') (Pro ''q''))\n                           (Neg' (Pro ''r'')),\n                          Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                (Pro ''r'')),\n                          Box (Imp' (Pro ''r'') (Pro ''s''))])\n                       (last\n                         [Con' (Con' (Pro ''p'') (Pro ''q''))\n                           (Neg' (Pro ''r'')),\n                          Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                                (Pro ''r'')),\n                          Box (Imp' (Pro ''r'') (Pro ''s''))]))\n             (Pro ''s'')))} =\n    {1, 2, 3, 4}", "by code_simp"], ["proof (state)\nthis:\n  {1..card\n       (props\n         (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                   Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                   Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                  []\n               then Truth\n               else fold Con'\n                     (butlast\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))])\n                     (last\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))]))\n           (Pro ''s'')))} =\n  {1, 2, 3, 4}\n\ngoal (1 subgoal):\n 1. valid\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Pro ''s''))", "moreover"], ["proof (state)\nthis:\n  {1..card\n       (props\n         (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                   Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                   Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                  []\n               then Truth\n               else fold Con'\n                     (butlast\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))])\n                     (last\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))]))\n           (Pro ''s'')))} =\n  {1, 2, 3, 4}\n\ngoal (1 subgoal):\n 1. valid\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Pro ''s''))", "have \"valid_in {1, 2, 3, 4} (Entail [B0, Box B1, Box B2] (Pro ''s''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_in {1, 2, 3, 4}\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Pro ''s''))", "unfolding valid_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       range i \\<subseteq> domain {1, 2, 3, 4} \\<longrightarrow>\n       eval i\n        (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                 []\n              then Truth\n              else fold Con'\n                    (butlast\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))])\n                    (last\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))]))\n          (Pro ''s'')) =\n       Det True", "proof (rule; rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1, 2, 3, 4} \\<Longrightarrow>\n       eval i\n        (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                 []\n              then Truth\n              else fold Con'\n                    (butlast\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))])\n                    (last\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))]))\n          (Pro ''s'')) =\n       Det True", "fix i :: \"id \\<Rightarrow> tv\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1, 2, 3, 4} \\<Longrightarrow>\n       eval i\n        (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                 []\n              then Truth\n              else fold Con'\n                    (butlast\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))])\n                    (last\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))]))\n          (Pro ''s'')) =\n       Det True", "assume \"range i \\<subseteq> domain {1, 2, 3, 4}\""], ["proof (state)\nthis:\n  range i \\<subseteq> domain {1, 2, 3, 4}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1, 2, 3, 4} \\<Longrightarrow>\n       eval i\n        (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                 []\n              then Truth\n              else fold Con'\n                    (butlast\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))])\n                    (last\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))]))\n          (Pro ''s'')) =\n       Det True", "then"], ["proof (chain)\npicking this:\n  range i \\<subseteq> domain {1, 2, 3, 4}", "have icase:\n      \"i ''p'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\"\n      \"i ''q'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\"\n      \"i ''r'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\"\n      \"i ''s'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\""], ["proof (prove)\nusing this:\n  range i \\<subseteq> domain {1, 2, 3, 4}\n\ngoal (1 subgoal):\n 1. (i ''p''\n     \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4} &&&\n     i ''q''\n     \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}) &&&\n    i ''r''\n    \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4} &&&\n    i ''s'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}", "unfolding domain_def"], ["proof (prove)\nusing this:\n  range i \\<subseteq> {Det True, Det False} \\<union> Indet ` {1, 2, 3, 4}\n\ngoal (1 subgoal):\n 1. (i ''p''\n     \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4} &&&\n     i ''q''\n     \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}) &&&\n    i ''r''\n    \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4} &&&\n    i ''s'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}", "by auto"], ["proof (state)\nthis:\n  i ''p'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\n  i ''q'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\n  i ''r'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\n  i ''s'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       range i \\<subseteq> domain {1, 2, 3, 4} \\<Longrightarrow>\n       eval i\n        (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                 []\n              then Truth\n              else fold Con'\n                    (butlast\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))])\n                    (last\n                      [Con' (Con' (Pro ''p'') (Pro ''q''))\n                        (Neg' (Pro ''r'')),\n                       Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                             (Pro ''r'')),\n                       Box (Imp' (Pro ''r'') (Pro ''s''))]))\n          (Pro ''s'')) =\n       Det True", "show \"eval i (Entail [B0, Box B1, Box B2] (Pro ''s'')) = Det True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval i\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Pro ''s'')) =\n    Det True", "using icase"], ["proof (prove)\nusing this:\n  i ''p'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\n  i ''q'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\n  i ''r'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\n  i ''s'' \\<in> {Det True, Det False, Indet 1, Indet 2, Indet 3, Indet 4}\n\ngoal (1 subgoal):\n 1. eval i\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Pro ''s'')) =\n    Det True", "by (cases \"i ''p''\"; cases \"i ''q''\"; cases \"i ''r''\"; cases \"i ''s''\") simp_all"], ["proof (state)\nthis:\n  eval i\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Pro ''s'')) =\n  Det True\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_in {1, 2, 3, 4}\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Pro ''s''))\n\ngoal (1 subgoal):\n 1. valid\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Pro ''s''))", "ultimately"], ["proof (chain)\npicking this:\n  {1..card\n       (props\n         (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                   Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                   Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                  []\n               then Truth\n               else fold Con'\n                     (butlast\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))])\n                     (last\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))]))\n           (Pro ''s'')))} =\n  {1, 2, 3, 4}\n  valid_in {1, 2, 3, 4}\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Pro ''s''))", "show ?thesis"], ["proof (prove)\nusing this:\n  {1..card\n       (props\n         (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                   Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                   Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                  []\n               then Truth\n               else fold Con'\n                     (butlast\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))])\n                     (last\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))]))\n           (Pro ''s'')))} =\n  {1, 2, 3, 4}\n  valid_in {1, 2, 3, 4}\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Pro ''s''))\n\ngoal (1 subgoal):\n 1. valid\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Pro ''s''))", "using reduce"], ["proof (prove)\nusing this:\n  {1..card\n       (props\n         (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                   Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                   Box (Imp' (Pro ''r'') (Pro ''s''))] =\n                  []\n               then Truth\n               else fold Con'\n                     (butlast\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))])\n                     (last\n                       [Con' (Con' (Pro ''p'') (Pro ''q''))\n                         (Neg' (Pro ''r'')),\n                        Box (Imp' (Con' (Pro ''p'') (Pro ''q''))\n                              (Pro ''r'')),\n                        Box (Imp' (Pro ''r'') (Pro ''s''))]))\n           (Pro ''s'')))} =\n  {1, 2, 3, 4}\n  valid_in {1, 2, 3, 4}\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Pro ''s''))\n  valid ?p = valid_in {1..card (props ?p)} ?p\n\ngoal (1 subgoal):\n 1. valid\n     (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n               Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n               Box (Imp' (Pro ''r'') (Pro ''s''))] =\n              []\n           then Truth\n           else fold Con'\n                 (butlast\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))])\n                 (last\n                   [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                    Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                    Box (Imp' (Pro ''r'') (Pro ''s''))]))\n       (Pro ''s''))", "by simp"], ["proof (state)\nthis:\n  valid\n   (Imp (if [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n             Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n             Box (Imp' (Pro ''r'') (Pro ''s''))] =\n            []\n         then Truth\n         else fold Con'\n               (butlast\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))])\n               (last\n                 [Con' (Con' (Pro ''p'') (Pro ''q'')) (Neg' (Pro ''r'')),\n                  Box (Imp' (Con' (Pro ''p'') (Pro ''q'')) (Pro ''r'')),\n                  Box (Imp' (Pro ''r'') (Pro ''s''))]))\n     (Pro ''s''))\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Acknowledgements\\<close>"], ["", "text\n\\<open>\nThanks to the Isabelle developers for making a superb system and for always being willing to help.\n\\<close>"], ["", "end \\<comment> \\<open>Paraconsistency file\\<close>"]]}