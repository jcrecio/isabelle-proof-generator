{"file_name": "/home/qj213/afp-2021-10-22/thys/Random_BSTs/Random_BSTs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Random_BSTs", "problem_names": ["lemma linorder_on_linorder_class [intro]:\n  \"linorder_on UNIV {(x, y). x \\<le> (y :: 'a :: linorder)}\"", "lemma Nil_in_permutations_of_set_iff [simp]: \"[] \\<in> permutations_of_set A \\<longleftrightarrow> A = {}\"", "lemma max_power_distrib_right:\n  fixes a :: \"'a :: linordered_semidom\"\n  shows \"a > 1 \\<Longrightarrow> max (a ^ b) (a ^ c) = a ^ max b c\"", "lemma set_tree_empty_iff [simp]: \"set_tree t = {} \\<longleftrightarrow> t = Leaf\"", "lemma card_set_tree_bst: \"bst t \\<Longrightarrow> card (set_tree t) = size t\"", "lemma pair_pmf_cong:\n  \"p = p' \\<Longrightarrow> q = q' \\<Longrightarrow> pair_pmf p q = pair_pmf p' q'\"", "lemma expectation_add_pair_pmf:\n  fixes f :: \"'a \\<Rightarrow> 'c::{banach, second_countable_topology}\"\n  assumes \"finite (set_pmf p)\" and \"finite (set_pmf q)\"\n  shows \"measure_pmf.expectation (pair_pmf p q) (\\<lambda>(x,y). f x + g y) =\n           measure_pmf.expectation p f + measure_pmf.expectation q g\"", "lemma bst_of_list_eq_Leaf_iff [simp]: \"bst_of_list xs = Leaf \\<longleftrightarrow> xs = []\"", "lemma bst_of_list_snoc [simp]:\n  \"bst_of_list (xs @ [y]) = Tree_Set.insert y (bst_of_list xs)\"", "lemma bst_of_list_append:\n  \"bst_of_list (xs @ ys) = fold Tree_Set.insert ys (bst_of_list xs)\"", "lemma bst_of_list_altdef: \"bst_of_list xs = fold Tree_Set.insert xs Leaf\"", "lemma size_bst_insert: \"x \\<notin> set_tree t \\<Longrightarrow> size (Tree_Set.insert x t) = Suc (size t)\"", "lemma set_bst_insert [simp]: \"set_tree (Tree_Set.insert x t) = insert x (set_tree t)\"", "lemma set_bst_of_list [simp]: \"set_tree (bst_of_list xs) = set xs\"", "lemma size_bst_of_list_distinct [simp]:\n  assumes \"distinct xs\"\n  shows   \"size (bst_of_list xs) = length xs\"", "lemma strict_mono_on_imp_less_iff:\n  assumes \"strict_mono_on f A\" \"x \\<in> A\" \"y \\<in> A\"\n  shows   \"f x < (f y :: 'b :: linorder) \\<longleftrightarrow> x < (y :: 'a :: linorder)\"", "lemma bst_of_list_map: \n  fixes f :: \"'a :: linorder \\<Rightarrow> 'b :: linorder\"\n  assumes \"strict_mono_on f A\" \"set xs \\<subseteq> A\"\n  shows   \"bst_of_list (map f xs) = map_tree f (bst_of_list xs)\"", "lemma random_bst_empty [simp]: \"random_bst {} = return_pmf Leaf\"", "lemma set_pmf_random_permutation [simp]:\n  \"finite A \\<Longrightarrow> set_pmf (pmf_of_set (permutations_of_set A)) = {xs. distinct xs \\<and> set xs = A}\"", "lemma random_bst_altdef:\n  assumes \"finite A\"\n  shows   \"random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\"", "lemma finite_set_random_bst [simp, intro]:\n  \"finite A \\<Longrightarrow> finite (set_pmf (random_bst A))\"", "lemma random_bst_code [code]:\n  \"random_bst (set xs) = map_pmf bst_of_list (pmf_of_set (permutations_of_set (set xs)))\"", "lemma random_bst_singleton [simp]: \"random_bst {x} = return_pmf (Node Leaf x Leaf)\"", "lemma size_random_bst:\n  assumes \"t \\<in> set_pmf (random_bst A)\" \"finite A\"\n  shows   \"size t = card A\"", "lemma random_bst_image:\n  assumes \"finite A\" \"strict_mono_on f A\"\n  shows   \"random_bst (f ` A) = map_pmf (map_tree f) (random_bst A)\"", "lemma random_bst_altdef':\n  assumes \"finite A\"\n  shows   \"random_bst A = fold_random_permutation Tree_Set.insert Leaf A\"", "lemma eheight_Leaf [simp]: \"eheight Leaf = 0\"", "lemma eheight_Node_singleton [simp]: \"eheight (Node Leaf x Leaf) = 1\"", "lemma eheight_Node:\n  \"l \\<noteq> Leaf \\<or> r \\<noteq> Leaf \\<Longrightarrow> eheight (Node l x r) = 2 * max (eheight l) (eheight r)\"", "lemma eheight_rbst_reduce:\n  assumes \"n > 1\"\n  shows   \"eheight_rbst n =\n             do {k \\<leftarrow> pmf_of_set {..<n}; h1 \\<leftarrow> eheight_rbst k; h2 \\<leftarrow> eheight_rbst (n - k - 1);\n                 return_pmf (2 * max h1 h2)}\"", "lemma Leaf_in_set_random_bst_iff:\n  assumes \"finite A\"\n  shows   \"Leaf \\<in> set_pmf (random_bst A) \\<longleftrightarrow> A = {}\"", "lemma eheight_rbst:\n  assumes \"finite A\"\n  shows   \"eheight_rbst (card A) = map_pmf eheight (random_bst A)\"", "lemma finite_pmf_set_eheight_rbst [simp, intro]: \"finite (set_pmf (eheight_rbst n))\"", "lemma eheight_exp_0 [simp]: \"eheight_exp 0 = 0\"", "lemma eheight_exp_1 [simp]: \"eheight_exp (Suc 0) = 1\"", "lemma eheight_exp_reduce_bound:\n  assumes \"n > 1\"\n  shows   \"eheight_exp n \\<le> 4 / n * (\\<Sum>k<n. eheight_exp k)\"", "lemma eheight_exp_bound: \"eheight_exp n \\<le> real ((n + 3) choose 3) / 4\"", "theorem height_expectation_bound:\n  assumes \"finite A\" \"A \\<noteq> {}\"\n  shows   \"measure_pmf.expectation (random_bst A) height\n             \\<le> height_exp_approx (card A)\"", "lemma ln_sum_bigo_ln: \"(\\<lambda>x::real. ln (x + c)) \\<in> O(ln)\"", "theorem sum_lookup_costs:\n  fixes t :: \"'a :: linorder tree\"\n  assumes \"bst t\"\n  shows   \"(\\<Sum>x\\<in>set_tree t. lookup_cost x t) = ipl t\"", "theorem expected_lookup_cost:\n  assumes \"bst t\" \"t \\<noteq> Leaf\"\n  shows   \"measure_pmf.expectation (pmf_of_set (set_tree t)) (\\<lambda>x. lookup_cost x t) =\n             ipl t / size t\"", "theorem map_pmf_random_bst_eq_rqs_cost:\n  assumes \"finite A\"\n  shows   \"map_pmf ipl (random_bst A) = rqs_cost (card A)\""], "translations": [["", "lemma linorder_on_linorder_class [intro]:\n  \"linorder_on UNIV {(x, y). x \\<le> (y :: 'a :: linorder)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_on UNIV {(x, y). x \\<le> y}", "by (auto simp: linorder_on_def refl_on_def antisym_def trans_def total_on_def)"], ["", "lemma Nil_in_permutations_of_set_iff [simp]: \"[] \\<in> permutations_of_set A \\<longleftrightarrow> A = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([] \\<in> permutations_of_set A) = (A = {})", "by (auto simp: permutations_of_set_def)"], ["", "lemma max_power_distrib_right:\n  fixes a :: \"'a :: linordered_semidom\"\n  shows \"a > 1 \\<Longrightarrow> max (a ^ b) (a ^ c) = a ^ max b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) < a \\<Longrightarrow> max (a ^ b) (a ^ c) = a ^ max b c", "by (auto simp: max_def)"], ["", "lemma set_tree_empty_iff [simp]: \"set_tree t = {} \\<longleftrightarrow> t = Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set_tree t = {}) = (t = \\<langle>\\<rangle>)", "by (cases t) auto"], ["", "lemma card_set_tree_bst: \"bst t \\<Longrightarrow> card (set_tree t) = size t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bst t \\<Longrightarrow> card (set_tree t) = size t", "proof (induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. bst \\<langle>\\<rangle> \\<Longrightarrow>\n    card (set_tree \\<langle>\\<rangle>) = size \\<langle>\\<rangle>\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>bst t1 \\<Longrightarrow> card (set_tree t1) = size t1;\n        bst t2 \\<Longrightarrow> card (set_tree t2) = size t2;\n        bst \\<langle>t1, x2, t2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> card (set_tree \\<langle>t1, x2, t2\\<rangle>) =\n                         size \\<langle>t1, x2, t2\\<rangle>", "case (Node l x r)"], ["proof (state)\nthis:\n  bst l \\<Longrightarrow> card (set_tree l) = size l\n  bst r \\<Longrightarrow> card (set_tree r) = size r\n  bst \\<langle>l, x, r\\<rangle>\n\ngoal (2 subgoals):\n 1. bst \\<langle>\\<rangle> \\<Longrightarrow>\n    card (set_tree \\<langle>\\<rangle>) = size \\<langle>\\<rangle>\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>bst t1 \\<Longrightarrow> card (set_tree t1) = size t1;\n        bst t2 \\<Longrightarrow> card (set_tree t2) = size t2;\n        bst \\<langle>t1, x2, t2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> card (set_tree \\<langle>t1, x2, t2\\<rangle>) =\n                         size \\<langle>t1, x2, t2\\<rangle>", "have \"set_tree \\<langle>l, x, r\\<rangle> = insert x (set_tree l \\<union> set_tree r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_tree \\<langle>l, x, r\\<rangle> =\n    insert x (set_tree l \\<union> set_tree r)", "by simp"], ["proof (state)\nthis:\n  set_tree \\<langle>l, x, r\\<rangle> =\n  insert x (set_tree l \\<union> set_tree r)\n\ngoal (2 subgoals):\n 1. bst \\<langle>\\<rangle> \\<Longrightarrow>\n    card (set_tree \\<langle>\\<rangle>) = size \\<langle>\\<rangle>\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>bst t1 \\<Longrightarrow> card (set_tree t1) = size t1;\n        bst t2 \\<Longrightarrow> card (set_tree t2) = size t2;\n        bst \\<langle>t1, x2, t2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> card (set_tree \\<langle>t1, x2, t2\\<rangle>) =\n                         size \\<langle>t1, x2, t2\\<rangle>", "also"], ["proof (state)\nthis:\n  set_tree \\<langle>l, x, r\\<rangle> =\n  insert x (set_tree l \\<union> set_tree r)\n\ngoal (2 subgoals):\n 1. bst \\<langle>\\<rangle> \\<Longrightarrow>\n    card (set_tree \\<langle>\\<rangle>) = size \\<langle>\\<rangle>\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>bst t1 \\<Longrightarrow> card (set_tree t1) = size t1;\n        bst t2 \\<Longrightarrow> card (set_tree t2) = size t2;\n        bst \\<langle>t1, x2, t2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> card (set_tree \\<langle>t1, x2, t2\\<rangle>) =\n                         size \\<langle>t1, x2, t2\\<rangle>", "from Node.prems"], ["proof (chain)\npicking this:\n  bst \\<langle>l, x, r\\<rangle>", "have \"card \\<dots> = Suc (card (set_tree l \\<union> set_tree r))\""], ["proof (prove)\nusing this:\n  bst \\<langle>l, x, r\\<rangle>\n\ngoal (1 subgoal):\n 1. card (insert x (set_tree l \\<union> set_tree r)) =\n    Suc (card (set_tree l \\<union> set_tree r))", "by (intro card_insert_disjoint) auto"], ["proof (state)\nthis:\n  card (insert x (set_tree l \\<union> set_tree r)) =\n  Suc (card (set_tree l \\<union> set_tree r))\n\ngoal (2 subgoals):\n 1. bst \\<langle>\\<rangle> \\<Longrightarrow>\n    card (set_tree \\<langle>\\<rangle>) = size \\<langle>\\<rangle>\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>bst t1 \\<Longrightarrow> card (set_tree t1) = size t1;\n        bst t2 \\<Longrightarrow> card (set_tree t2) = size t2;\n        bst \\<langle>t1, x2, t2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> card (set_tree \\<langle>t1, x2, t2\\<rangle>) =\n                         size \\<langle>t1, x2, t2\\<rangle>", "also"], ["proof (state)\nthis:\n  card (insert x (set_tree l \\<union> set_tree r)) =\n  Suc (card (set_tree l \\<union> set_tree r))\n\ngoal (2 subgoals):\n 1. bst \\<langle>\\<rangle> \\<Longrightarrow>\n    card (set_tree \\<langle>\\<rangle>) = size \\<langle>\\<rangle>\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>bst t1 \\<Longrightarrow> card (set_tree t1) = size t1;\n        bst t2 \\<Longrightarrow> card (set_tree t2) = size t2;\n        bst \\<langle>t1, x2, t2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> card (set_tree \\<langle>t1, x2, t2\\<rangle>) =\n                         size \\<langle>t1, x2, t2\\<rangle>", "from Node"], ["proof (chain)\npicking this:\n  bst l \\<Longrightarrow> card (set_tree l) = size l\n  bst r \\<Longrightarrow> card (set_tree r) = size r\n  bst \\<langle>l, x, r\\<rangle>", "have \"card (set_tree l \\<union> set_tree r) = size l + size r\""], ["proof (prove)\nusing this:\n  bst l \\<Longrightarrow> card (set_tree l) = size l\n  bst r \\<Longrightarrow> card (set_tree r) = size r\n  bst \\<langle>l, x, r\\<rangle>\n\ngoal (1 subgoal):\n 1. card (set_tree l \\<union> set_tree r) = size l + size r", "by (subst card_Un_disjoint) force+"], ["proof (state)\nthis:\n  card (set_tree l \\<union> set_tree r) = size l + size r\n\ngoal (2 subgoals):\n 1. bst \\<langle>\\<rangle> \\<Longrightarrow>\n    card (set_tree \\<langle>\\<rangle>) = size \\<langle>\\<rangle>\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>bst t1 \\<Longrightarrow> card (set_tree t1) = size t1;\n        bst t2 \\<Longrightarrow> card (set_tree t2) = size t2;\n        bst \\<langle>t1, x2, t2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> card (set_tree \\<langle>t1, x2, t2\\<rangle>) =\n                         size \\<langle>t1, x2, t2\\<rangle>", "finally"], ["proof (chain)\npicking this:\n  card (set_tree \\<langle>l, x, r\\<rangle>) = Suc (size l + size r)", "show ?case"], ["proof (prove)\nusing this:\n  card (set_tree \\<langle>l, x, r\\<rangle>) = Suc (size l + size r)\n\ngoal (1 subgoal):\n 1. card (set_tree \\<langle>l, x, r\\<rangle>) =\n    size \\<langle>l, x, r\\<rangle>", "by simp"], ["proof (state)\nthis:\n  card (set_tree \\<langle>l, x, r\\<rangle>) = size \\<langle>l, x, r\\<rangle>\n\ngoal (1 subgoal):\n 1. bst \\<langle>\\<rangle> \\<Longrightarrow>\n    card (set_tree \\<langle>\\<rangle>) = size \\<langle>\\<rangle>", "qed simp_all"], ["", "lemma pair_pmf_cong:\n  \"p = p' \\<Longrightarrow> q = q' \\<Longrightarrow> pair_pmf p q = pair_pmf p' q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = p'; q = q'\\<rbrakk>\n    \\<Longrightarrow> pair_pmf p q = pair_pmf p' q'", "by simp"], ["", "lemma expectation_add_pair_pmf:\n  fixes f :: \"'a \\<Rightarrow> 'c::{banach, second_countable_topology}\"\n  assumes \"finite (set_pmf p)\" and \"finite (set_pmf q)\"\n  shows \"measure_pmf.expectation (pair_pmf p q) (\\<lambda>(x,y). f x + g y) =\n           measure_pmf.expectation p f + measure_pmf.expectation q g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>(x, y). f x + g y) =\n    measure_pmf.expectation p f + measure_pmf.expectation q g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>(x, y). f x + g y) =\n    measure_pmf.expectation p f + measure_pmf.expectation q g", "have \"measure_pmf.expectation (pair_pmf p q) (\\<lambda>(x,y). f x + g y) =\n          measure_pmf.expectation (pair_pmf p q) (\\<lambda>z. f (fst z) + g (snd z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>(x, y). f x + g y) =\n    measure_pmf.expectation (pair_pmf p q)\n     (\\<lambda>z. f (fst z) + g (snd z))", "by (simp add: case_prod_unfold)"], ["proof (state)\nthis:\n  measure_pmf.expectation (pair_pmf p q) (\\<lambda>(x, y). f x + g y) =\n  measure_pmf.expectation (pair_pmf p q) (\\<lambda>z. f (fst z) + g (snd z))\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>(x, y). f x + g y) =\n    measure_pmf.expectation p f + measure_pmf.expectation q g", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation (pair_pmf p q) (\\<lambda>(x, y). f x + g y) =\n  measure_pmf.expectation (pair_pmf p q) (\\<lambda>z. f (fst z) + g (snd z))\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>(x, y). f x + g y) =\n    measure_pmf.expectation p f + measure_pmf.expectation q g", "have \"\\<dots> = measure_pmf.expectation (pair_pmf p q) (\\<lambda>z. f (fst z)) +\n                  measure_pmf.expectation (pair_pmf p q) (\\<lambda>z. g (snd z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q)\n     (\\<lambda>z. f (fst z) + g (snd z)) =\n    measure_pmf.expectation (pair_pmf p q) (\\<lambda>z. f (fst z)) +\n    measure_pmf.expectation (pair_pmf p q) (\\<lambda>z. g (snd z))", "by (intro Bochner_Integration.integral_add integrable_measure_pmf_finite) (auto intro: assms)"], ["proof (state)\nthis:\n  measure_pmf.expectation (pair_pmf p q)\n   (\\<lambda>z. f (fst z) + g (snd z)) =\n  measure_pmf.expectation (pair_pmf p q) (\\<lambda>z. f (fst z)) +\n  measure_pmf.expectation (pair_pmf p q) (\\<lambda>z. g (snd z))\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>(x, y). f x + g y) =\n    measure_pmf.expectation p f + measure_pmf.expectation q g", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation (pair_pmf p q)\n   (\\<lambda>z. f (fst z) + g (snd z)) =\n  measure_pmf.expectation (pair_pmf p q) (\\<lambda>z. f (fst z)) +\n  measure_pmf.expectation (pair_pmf p q) (\\<lambda>z. g (snd z))\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>(x, y). f x + g y) =\n    measure_pmf.expectation p f + measure_pmf.expectation q g", "have \"measure_pmf.expectation (pair_pmf p q) (\\<lambda>z. f (fst z)) =\n               measure_pmf.expectation (map_pmf fst (pair_pmf p q)) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>z. f (fst z)) =\n    measure_pmf.expectation (map_pmf fst (pair_pmf p q)) f", "by simp"], ["proof (state)\nthis:\n  measure_pmf.expectation (pair_pmf p q) (\\<lambda>z. f (fst z)) =\n  measure_pmf.expectation (map_pmf fst (pair_pmf p q)) f\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>(x, y). f x + g y) =\n    measure_pmf.expectation p f + measure_pmf.expectation q g", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation (pair_pmf p q) (\\<lambda>z. f (fst z)) =\n  measure_pmf.expectation (map_pmf fst (pair_pmf p q)) f\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>(x, y). f x + g y) =\n    measure_pmf.expectation p f + measure_pmf.expectation q g", "have \"map_pmf fst (pair_pmf p q) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf fst (pair_pmf p q) = p", "by (rule map_fst_pair_pmf)"], ["proof (state)\nthis:\n  map_pmf fst (pair_pmf p q) = p\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>(x, y). f x + g y) =\n    measure_pmf.expectation p f + measure_pmf.expectation q g", "also"], ["proof (state)\nthis:\n  map_pmf fst (pair_pmf p q) = p\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>(x, y). f x + g y) =\n    measure_pmf.expectation p f + measure_pmf.expectation q g", "have \"measure_pmf.expectation (pair_pmf p q) (\\<lambda>z. g (snd z)) =\n               measure_pmf.expectation (map_pmf snd (pair_pmf p q)) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>z. g (snd z)) =\n    measure_pmf.expectation (map_pmf snd (pair_pmf p q)) g", "by simp"], ["proof (state)\nthis:\n  measure_pmf.expectation (pair_pmf p q) (\\<lambda>z. g (snd z)) =\n  measure_pmf.expectation (map_pmf snd (pair_pmf p q)) g\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>(x, y). f x + g y) =\n    measure_pmf.expectation p f + measure_pmf.expectation q g", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation (pair_pmf p q) (\\<lambda>z. g (snd z)) =\n  measure_pmf.expectation (map_pmf snd (pair_pmf p q)) g\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>(x, y). f x + g y) =\n    measure_pmf.expectation p f + measure_pmf.expectation q g", "have \"map_pmf snd (pair_pmf p q) = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf snd (pair_pmf p q) = q", "by (rule map_snd_pair_pmf)"], ["proof (state)\nthis:\n  map_pmf snd (pair_pmf p q) = q\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>(x, y). f x + g y) =\n    measure_pmf.expectation p f + measure_pmf.expectation q g", "finally"], ["proof (chain)\npicking this:\n  measure_pmf.expectation (pair_pmf p q)\n   (\\<lambda>a. case a of (x, y) \\<Rightarrow> f x + g y) =\n  measure_pmf.expectation p f + measure_pmf.expectation q g", "show ?thesis"], ["proof (prove)\nusing this:\n  measure_pmf.expectation (pair_pmf p q)\n   (\\<lambda>a. case a of (x, y) \\<Rightarrow> f x + g y) =\n  measure_pmf.expectation p f + measure_pmf.expectation q g\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>(x, y). f x + g y) =\n    measure_pmf.expectation p f + measure_pmf.expectation q g", "."], ["proof (state)\nthis:\n  measure_pmf.expectation (pair_pmf p q) (\\<lambda>(x, y). f x + g y) =\n  measure_pmf.expectation p f + measure_pmf.expectation q g\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Creating a BST from a list\\<close>"], ["", "text \\<open>\n  The following recursive function creates a binary search tree from a given list of\n  elements by inserting them into an initially empty BST from left to right. We will prove\n  that this is the case later, but the recursive definition has the advantage of giving us\n  a useful induction rule, so we chose that definition and prove the alternative definitions later.\n\n  This recursion, which already almost looks like QuickSort, will be key in analysing the\n  shape distributions of random BSTs.\n\\<close>"], ["", "fun bst_of_list :: \"'a :: linorder list \\<Rightarrow> 'a tree\" where\n  \"bst_of_list [] = Leaf\"\n| \"bst_of_list (x # xs) =\n     Node (bst_of_list [y \\<leftarrow> xs. y < x]) x (bst_of_list [y \\<leftarrow> xs. y > x])\""], ["", "lemma bst_of_list_eq_Leaf_iff [simp]: \"bst_of_list xs = Leaf \\<longleftrightarrow> xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bst_of_list xs = \\<langle>\\<rangle>) = (xs = [])", "by (induction xs) auto"], ["", "lemma bst_of_list_snoc [simp]:\n  \"bst_of_list (xs @ [y]) = Tree_Set.insert y (bst_of_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bst_of_list (xs @ [y]) = Tree_Set.insert y (bst_of_list xs)", "by (induction xs rule: bst_of_list.induct) auto"], ["", "lemma bst_of_list_append:\n  \"bst_of_list (xs @ ys) = fold Tree_Set.insert ys (bst_of_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bst_of_list (xs @ ys) = fold Tree_Set.insert ys (bst_of_list xs)", "proof (induction ys arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       bst_of_list (xs @ []) = fold Tree_Set.insert [] (bst_of_list xs)\n 2. \\<And>a ys xs.\n       (\\<And>xs.\n           bst_of_list (xs @ ys) =\n           fold Tree_Set.insert ys (bst_of_list xs)) \\<Longrightarrow>\n       bst_of_list (xs @ a # ys) =\n       fold Tree_Set.insert (a # ys) (bst_of_list xs)", "case (Cons y ys)"], ["proof (state)\nthis:\n  bst_of_list (?xs @ ys) = fold Tree_Set.insert ys (bst_of_list ?xs)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       bst_of_list (xs @ []) = fold Tree_Set.insert [] (bst_of_list xs)\n 2. \\<And>a ys xs.\n       (\\<And>xs.\n           bst_of_list (xs @ ys) =\n           fold Tree_Set.insert ys (bst_of_list xs)) \\<Longrightarrow>\n       bst_of_list (xs @ a # ys) =\n       fold Tree_Set.insert (a # ys) (bst_of_list xs)", "have \"bst_of_list (xs @ (y # ys)) = bst_of_list ((xs @ [y]) @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bst_of_list (xs @ y # ys) = bst_of_list ((xs @ [y]) @ ys)", "by simp"], ["proof (state)\nthis:\n  bst_of_list (xs @ y # ys) = bst_of_list ((xs @ [y]) @ ys)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       bst_of_list (xs @ []) = fold Tree_Set.insert [] (bst_of_list xs)\n 2. \\<And>a ys xs.\n       (\\<And>xs.\n           bst_of_list (xs @ ys) =\n           fold Tree_Set.insert ys (bst_of_list xs)) \\<Longrightarrow>\n       bst_of_list (xs @ a # ys) =\n       fold Tree_Set.insert (a # ys) (bst_of_list xs)", "also"], ["proof (state)\nthis:\n  bst_of_list (xs @ y # ys) = bst_of_list ((xs @ [y]) @ ys)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       bst_of_list (xs @ []) = fold Tree_Set.insert [] (bst_of_list xs)\n 2. \\<And>a ys xs.\n       (\\<And>xs.\n           bst_of_list (xs @ ys) =\n           fold Tree_Set.insert ys (bst_of_list xs)) \\<Longrightarrow>\n       bst_of_list (xs @ a # ys) =\n       fold Tree_Set.insert (a # ys) (bst_of_list xs)", "have \"\\<dots> = fold Tree_Set.insert ys (bst_of_list (xs @ [y]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bst_of_list ((xs @ [y]) @ ys) =\n    fold Tree_Set.insert ys (bst_of_list (xs @ [y]))", "by (rule Cons.IH)"], ["proof (state)\nthis:\n  bst_of_list ((xs @ [y]) @ ys) =\n  fold Tree_Set.insert ys (bst_of_list (xs @ [y]))\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       bst_of_list (xs @ []) = fold Tree_Set.insert [] (bst_of_list xs)\n 2. \\<And>a ys xs.\n       (\\<And>xs.\n           bst_of_list (xs @ ys) =\n           fold Tree_Set.insert ys (bst_of_list xs)) \\<Longrightarrow>\n       bst_of_list (xs @ a # ys) =\n       fold Tree_Set.insert (a # ys) (bst_of_list xs)", "finally"], ["proof (chain)\npicking this:\n  bst_of_list (xs @ y # ys) =\n  fold Tree_Set.insert ys (bst_of_list (xs @ [y]))", "show ?case"], ["proof (prove)\nusing this:\n  bst_of_list (xs @ y # ys) =\n  fold Tree_Set.insert ys (bst_of_list (xs @ [y]))\n\ngoal (1 subgoal):\n 1. bst_of_list (xs @ y # ys) =\n    fold Tree_Set.insert (y # ys) (bst_of_list xs)", "by simp"], ["proof (state)\nthis:\n  bst_of_list (xs @ y # ys) = fold Tree_Set.insert (y # ys) (bst_of_list xs)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       bst_of_list (xs @ []) = fold Tree_Set.insert [] (bst_of_list xs)", "qed simp_all"], ["", "text \\<open>\n  The following now shows that the recursive function indeed corresponds to the\n  notion of inserting the elements from the list from left to right.\n\\<close>"], ["", "lemma bst_of_list_altdef: \"bst_of_list xs = fold Tree_Set.insert xs Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bst_of_list xs = fold Tree_Set.insert xs \\<langle>\\<rangle>", "using bst_of_list_append[of \"[]\" xs]"], ["proof (prove)\nusing this:\n  bst_of_list ([] @ xs) = fold Tree_Set.insert xs (bst_of_list [])\n\ngoal (1 subgoal):\n 1. bst_of_list xs = fold Tree_Set.insert xs \\<langle>\\<rangle>", "by simp"], ["", "lemma size_bst_insert: \"x \\<notin> set_tree t \\<Longrightarrow> size (Tree_Set.insert x t) = Suc (size t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set_tree t \\<Longrightarrow>\n    size (Tree_Set.insert x t) = Suc (size t)", "by (induction t) auto"], ["", "lemma set_bst_insert [simp]: \"set_tree (Tree_Set.insert x t) = insert x (set_tree t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_tree (Tree_Set.insert x t) = insert x (set_tree t)", "by (induction t) auto"], ["", "lemma set_bst_of_list [simp]: \"set_tree (bst_of_list xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_tree (bst_of_list xs) = set xs", "by (induction xs rule: rev_induct) simp_all"], ["", "lemma size_bst_of_list_distinct [simp]:\n  assumes \"distinct xs\"\n  shows   \"size (bst_of_list xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (bst_of_list xs) = length xs", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. size (bst_of_list xs) = length xs", "by (induction xs rule: rev_induct) (auto simp: size_bst_insert)"], ["", "lemma strict_mono_on_imp_less_iff:\n  assumes \"strict_mono_on f A\" \"x \\<in> A\" \"y \\<in> A\"\n  shows   \"f x < (f y :: 'b :: linorder) \\<longleftrightarrow> x < (y :: 'a :: linorder)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f x < f y) = (x < y)", "using assms"], ["proof (prove)\nusing this:\n  strict_mono_on f A\n  x \\<in> A\n  y \\<in> A\n\ngoal (1 subgoal):\n 1. (f x < f y) = (x < y)", "by (cases x y rule: linorder_cases; force simp: strict_mono_on_def)+"], ["", "lemma bst_of_list_map: \n  fixes f :: \"'a :: linorder \\<Rightarrow> 'b :: linorder\"\n  assumes \"strict_mono_on f A\" \"set xs \\<subseteq> A\"\n  shows   \"bst_of_list (map f xs) = map_tree f (bst_of_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bst_of_list (map f xs) = map_tree f (bst_of_list xs)", "using assms"], ["proof (prove)\nusing this:\n  strict_mono_on f A\n  set xs \\<subseteq> A\n\ngoal (1 subgoal):\n 1. bst_of_list (map f xs) = map_tree f (bst_of_list xs)", "proof (induction xs rule: bst_of_list.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>strict_mono_on f A; set [] \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> bst_of_list (map f []) = map_tree f (bst_of_list [])\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>strict_mono_on f A;\n                 set (filter (\\<lambda>y. y < x) xs) \\<subseteq> A\\<rbrakk>\n                \\<Longrightarrow> bst_of_list\n                                   (map f (filter (\\<lambda>y. y < x) xs)) =\n                                  map_tree f\n                                   (bst_of_list\n                                     (filter (\\<lambda>y. y < x) xs));\n        \\<lbrakk>strict_mono_on f A;\n         set (filter ((<) x) xs) \\<subseteq> A\\<rbrakk>\n        \\<Longrightarrow> bst_of_list (map f (filter ((<) x) xs)) =\n                          map_tree f (bst_of_list (filter ((<) x) xs));\n        strict_mono_on f A; set (x # xs) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> bst_of_list (map f (x # xs)) =\n                         map_tree f (bst_of_list (x # xs))", "case (2 x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>strict_mono_on f A;\n   set (filter (\\<lambda>y. y < x) xs) \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> bst_of_list (map f (filter (\\<lambda>y. y < x) xs)) =\n                    map_tree f (bst_of_list (filter (\\<lambda>y. y < x) xs))\n  \\<lbrakk>strict_mono_on f A;\n   set (filter ((<) x) xs) \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> bst_of_list (map f (filter ((<) x) xs)) =\n                    map_tree f (bst_of_list (filter ((<) x) xs))\n  strict_mono_on f A\n  set (x # xs) \\<subseteq> A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>strict_mono_on f A; set [] \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> bst_of_list (map f []) = map_tree f (bst_of_list [])\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>strict_mono_on f A;\n                 set (filter (\\<lambda>y. y < x) xs) \\<subseteq> A\\<rbrakk>\n                \\<Longrightarrow> bst_of_list\n                                   (map f (filter (\\<lambda>y. y < x) xs)) =\n                                  map_tree f\n                                   (bst_of_list\n                                     (filter (\\<lambda>y. y < x) xs));\n        \\<lbrakk>strict_mono_on f A;\n         set (filter ((<) x) xs) \\<subseteq> A\\<rbrakk>\n        \\<Longrightarrow> bst_of_list (map f (filter ((<) x) xs)) =\n                          map_tree f (bst_of_list (filter ((<) x) xs));\n        strict_mono_on f A; set (x # xs) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> bst_of_list (map f (x # xs)) =\n                         map_tree f (bst_of_list (x # xs))", "have \"[xa\\<leftarrow>xs . f xa < f x] = [xa\\<leftarrow>xs . xa < x]\" and \"[xa\\<leftarrow>xs . f xa > f x] = [xa\\<leftarrow>xs . xa > x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>xa. f xa < f x) xs =\n    filter (\\<lambda>xa. xa < x) xs &&&\n    filter (\\<lambda>xa. f x < f xa) xs = filter ((<) x) xs", "using \"2.prems\""], ["proof (prove)\nusing this:\n  strict_mono_on f A\n  set (x # xs) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>xa. f xa < f x) xs =\n    filter (\\<lambda>xa. xa < x) xs &&&\n    filter (\\<lambda>xa. f x < f xa) xs = filter ((<) x) xs", "by (auto simp: strict_mono_on_imp_less_iff intro!: filter_cong)"], ["proof (state)\nthis:\n  filter (\\<lambda>xa. f xa < f x) xs = filter (\\<lambda>xa. xa < x) xs\n  filter (\\<lambda>xa. f x < f xa) xs = filter ((<) x) xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>strict_mono_on f A; set [] \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> bst_of_list (map f []) = map_tree f (bst_of_list [])\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>strict_mono_on f A;\n                 set (filter (\\<lambda>y. y < x) xs) \\<subseteq> A\\<rbrakk>\n                \\<Longrightarrow> bst_of_list\n                                   (map f (filter (\\<lambda>y. y < x) xs)) =\n                                  map_tree f\n                                   (bst_of_list\n                                     (filter (\\<lambda>y. y < x) xs));\n        \\<lbrakk>strict_mono_on f A;\n         set (filter ((<) x) xs) \\<subseteq> A\\<rbrakk>\n        \\<Longrightarrow> bst_of_list (map f (filter ((<) x) xs)) =\n                          map_tree f (bst_of_list (filter ((<) x) xs));\n        strict_mono_on f A; set (x # xs) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> bst_of_list (map f (x # xs)) =\n                         map_tree f (bst_of_list (x # xs))", "with 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>strict_mono_on f A;\n   set (filter (\\<lambda>y. y < x) xs) \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> bst_of_list (map f (filter (\\<lambda>y. y < x) xs)) =\n                    map_tree f (bst_of_list (filter (\\<lambda>y. y < x) xs))\n  \\<lbrakk>strict_mono_on f A;\n   set (filter ((<) x) xs) \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> bst_of_list (map f (filter ((<) x) xs)) =\n                    map_tree f (bst_of_list (filter ((<) x) xs))\n  strict_mono_on f A\n  set (x # xs) \\<subseteq> A\n  filter (\\<lambda>xa. f xa < f x) xs = filter (\\<lambda>xa. xa < x) xs\n  filter (\\<lambda>xa. f x < f xa) xs = filter ((<) x) xs", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>strict_mono_on f A;\n   set (filter (\\<lambda>y. y < x) xs) \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> bst_of_list (map f (filter (\\<lambda>y. y < x) xs)) =\n                    map_tree f (bst_of_list (filter (\\<lambda>y. y < x) xs))\n  \\<lbrakk>strict_mono_on f A;\n   set (filter ((<) x) xs) \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> bst_of_list (map f (filter ((<) x) xs)) =\n                    map_tree f (bst_of_list (filter ((<) x) xs))\n  strict_mono_on f A\n  set (x # xs) \\<subseteq> A\n  filter (\\<lambda>xa. f xa < f x) xs = filter (\\<lambda>xa. xa < x) xs\n  filter (\\<lambda>xa. f x < f xa) xs = filter ((<) x) xs\n\ngoal (1 subgoal):\n 1. bst_of_list (map f (x # xs)) = map_tree f (bst_of_list (x # xs))", "by (auto simp: filter_map o_def)"], ["proof (state)\nthis:\n  bst_of_list (map f (x # xs)) = map_tree f (bst_of_list (x # xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>strict_mono_on f A; set [] \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> bst_of_list (map f []) = map_tree f (bst_of_list [])", "qed auto"], ["", "subsection \\<open>Random BSTs\\<close>"], ["", "text \\<open>\n  Analogously to the previous section, we can now view the concept of a random BST\n  (i.\\,e.\\ a BST obtained by inserting a given set of elements in random order) in two\n  different ways.\n\n  We again start with the recursive variant:\n\\<close>"], ["", "function random_bst :: \"'a :: linorder set \\<Rightarrow> 'a tree pmf\" where\n  \"random_bst A =\n     (if \\<not>finite A \\<or> A = {} then\n        return_pmf Leaf\n      else do {\n        x \\<leftarrow> pmf_of_set A;\n        l \\<leftarrow> random_bst {y \\<in> A. y < x};\n        r \\<leftarrow> random_bst {y \\<in> A. y > x};\n        return_pmf (Node l x r)\n     })\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>A. x = A \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>A Aa.\n       A = Aa \\<Longrightarrow>\n       (if infinite A \\<or> A = {} then return_pmf \\<langle>\\<rangle>\n        else pmf_of_set A \\<bind>\n             (\\<lambda>x.\n                 random_bst_sumC {y \\<in> A. y < x} \\<bind>\n                 (\\<lambda>l.\n                     random_bst_sumC {y \\<in> A. x < y} \\<bind>\n                     (\\<lambda>r. return_pmf \\<langle>l, x, r\\<rangle>)))) =\n       (if infinite Aa \\<or> Aa = {} then return_pmf \\<langle>\\<rangle>\n        else pmf_of_set Aa \\<bind>\n             (\\<lambda>x.\n                 random_bst_sumC {y \\<in> Aa. y < x} \\<bind>\n                 (\\<lambda>l.\n                     random_bst_sumC {y \\<in> Aa. x < y} \\<bind>\n                     (\\<lambda>r. return_pmf \\<langle>l, x, r\\<rangle>))))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All random_bst_dom", "by (relation finite_psubset) auto"], ["", "declare random_bst.simps [simp del]"], ["", "lemma random_bst_empty [simp]: \"random_bst {} = return_pmf Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. random_bst {} = return_pmf \\<langle>\\<rangle>", "by (simp add: random_bst.simps)"], ["", "lemma set_pmf_random_permutation [simp]:\n  \"finite A \\<Longrightarrow> set_pmf (pmf_of_set (permutations_of_set A)) = {xs. distinct xs \\<and> set xs = A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    set_pmf (pmf_of_set (permutations_of_set A)) =\n    {xs. distinct xs \\<and> set xs = A}", "by (subst set_pmf_of_set) (auto dest: permutations_of_setD)"], ["", "text \\<open>\n  The alternative characterisation is the more intuitive one where we simply pick a\n  random permutation of the set elements uniformly at random and insert them into an empty\n  tree from left to right:\n\\<close>"], ["", "lemma random_bst_altdef:\n  assumes \"finite A\"\n  shows   \"random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "using assms"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "proof (induction A rule: finite_psubset_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>finite A;\n        \\<And>B.\n           B \\<subset> A \\<Longrightarrow>\n           random_bst B =\n           map_pmf bst_of_list (pmf_of_set (permutations_of_set B))\\<rbrakk>\n       \\<Longrightarrow> random_bst A =\n                         map_pmf bst_of_list\n                          (pmf_of_set (permutations_of_set A))", "case (psubset A)"], ["proof (state)\nthis:\n  finite A\n  ?B \\<subset> A \\<Longrightarrow>\n  random_bst ?B = map_pmf bst_of_list (pmf_of_set (permutations_of_set ?B))\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>finite A;\n        \\<And>B.\n           B \\<subset> A \\<Longrightarrow>\n           random_bst B =\n           map_pmf bst_of_list (pmf_of_set (permutations_of_set B))\\<rbrakk>\n       \\<Longrightarrow> random_bst A =\n                         map_pmf bst_of_list\n                          (pmf_of_set (permutations_of_set A))", "define L R where \"L = (\\<lambda>x. {y\\<in>A. y < x})\" and \"R = (\\<lambda>x. {y\\<in>A. y > x})\""], ["proof (state)\nthis:\n  L = (\\<lambda>x. {y \\<in> A. y < x})\n  R = (\\<lambda>x. {y \\<in> A. x < y})\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>finite A;\n        \\<And>B.\n           B \\<subset> A \\<Longrightarrow>\n           random_bst B =\n           map_pmf bst_of_list (pmf_of_set (permutations_of_set B))\\<rbrakk>\n       \\<Longrightarrow> random_bst A =\n                         map_pmf bst_of_list\n                          (pmf_of_set (permutations_of_set A))", "{"], ["proof (state)\nthis:\n  L = (\\<lambda>x. {y \\<in> A. y < x})\n  R = (\\<lambda>x. {y \\<in> A. x < y})\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>finite A;\n        \\<And>B.\n           B \\<subset> A \\<Longrightarrow>\n           random_bst B =\n           map_pmf bst_of_list (pmf_of_set (permutations_of_set B))\\<rbrakk>\n       \\<Longrightarrow> random_bst A =\n                         map_pmf bst_of_list\n                          (pmf_of_set (permutations_of_set A))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>finite A;\n        \\<And>B.\n           B \\<subset> A \\<Longrightarrow>\n           random_bst B =\n           map_pmf bst_of_list (pmf_of_set (permutations_of_set B))\\<rbrakk>\n       \\<Longrightarrow> random_bst A =\n                         map_pmf bst_of_list\n                          (pmf_of_set (permutations_of_set A))", "assume x: \"x \\<in> A\""], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>finite A;\n        \\<And>B.\n           B \\<subset> A \\<Longrightarrow>\n           random_bst B =\n           map_pmf bst_of_list (pmf_of_set (permutations_of_set B))\\<rbrakk>\n       \\<Longrightarrow> random_bst A =\n                         map_pmf bst_of_list\n                          (pmf_of_set (permutations_of_set A))", "hence *: \"L x \\<subset> A\" \"R x \\<subset> A\""], ["proof (prove)\nusing this:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. L x \\<subset> A &&& R x \\<subset> A", "by (auto simp: L_def R_def)"], ["proof (state)\nthis:\n  L x \\<subset> A\n  R x \\<subset> A\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>finite A;\n        \\<And>B.\n           B \\<subset> A \\<Longrightarrow>\n           random_bst B =\n           map_pmf bst_of_list (pmf_of_set (permutations_of_set B))\\<rbrakk>\n       \\<Longrightarrow> random_bst A =\n                         map_pmf bst_of_list\n                          (pmf_of_set (permutations_of_set A))", "note this [THEN psubset.IH]"], ["proof (state)\nthis:\n  random_bst (L x) =\n  map_pmf bst_of_list (pmf_of_set (permutations_of_set (L x)))\n  random_bst (R x) =\n  map_pmf bst_of_list (pmf_of_set (permutations_of_set (R x)))\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>finite A;\n        \\<And>B.\n           B \\<subset> A \\<Longrightarrow>\n           random_bst B =\n           map_pmf bst_of_list (pmf_of_set (permutations_of_set B))\\<rbrakk>\n       \\<Longrightarrow> random_bst A =\n                         map_pmf bst_of_list\n                          (pmf_of_set (permutations_of_set A))", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> A \\<Longrightarrow>\n  random_bst (L ?x2) =\n  map_pmf bst_of_list (pmf_of_set (permutations_of_set (L ?x2)))\n  ?x2 \\<in> A \\<Longrightarrow>\n  random_bst (R ?x2) =\n  map_pmf bst_of_list (pmf_of_set (permutations_of_set (R ?x2)))\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>finite A;\n        \\<And>B.\n           B \\<subset> A \\<Longrightarrow>\n           random_bst B =\n           map_pmf bst_of_list (pmf_of_set (permutations_of_set B))\\<rbrakk>\n       \\<Longrightarrow> random_bst A =\n                         map_pmf bst_of_list\n                          (pmf_of_set (permutations_of_set A))", "note IH = this"], ["proof (state)\nthis:\n  ?x2 \\<in> A \\<Longrightarrow>\n  random_bst (L ?x2) =\n  map_pmf bst_of_list (pmf_of_set (permutations_of_set (L ?x2)))\n  ?x2 \\<in> A \\<Longrightarrow>\n  random_bst (R ?x2) =\n  map_pmf bst_of_list (pmf_of_set (permutations_of_set (R ?x2)))\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>finite A;\n        \\<And>B.\n           B \\<subset> A \\<Longrightarrow>\n           random_bst B =\n           map_pmf bst_of_list (pmf_of_set (permutations_of_set B))\\<rbrakk>\n       \\<Longrightarrow> random_bst A =\n                         map_pmf bst_of_list\n                          (pmf_of_set (permutations_of_set A))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "proof (cases \"A = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\n 2. A \\<noteq> {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "case False"], ["proof (state)\nthis:\n  A \\<noteq> {}\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\n 2. A \\<noteq> {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "note A = \\<open>finite A\\<close> \\<open>A \\<noteq> {}\\<close>"], ["proof (state)\nthis:\n  finite A\n  A \\<noteq> {}\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\n 2. A \\<noteq> {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "have \"random_bst A =\n            do {\n              x \\<leftarrow> pmf_of_set A;\n              (l, r) \\<leftarrow> pair_pmf (random_bst (L x)) (random_bst (R x));\n              return_pmf (Node l x r)\n            }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. random_bst A =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pair_pmf (random_bst (L x)) (random_bst (R x)) \\<bind>\n        (\\<lambda>(l, r). return_pmf \\<langle>l, x, r\\<rangle>))", "using A"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. random_bst A =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pair_pmf (random_bst (L x)) (random_bst (R x)) \\<bind>\n        (\\<lambda>(l, r). return_pmf \\<langle>l, x, r\\<rangle>))", "unfolding pair_pmf_def L_def R_def"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. random_bst A =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        random_bst {y \\<in> A. y < x} \\<bind>\n        (\\<lambda>xa.\n            random_bst {y \\<in> A. x < y} \\<bind>\n            (\\<lambda>y. return_pmf (xa, y))) \\<bind>\n        (\\<lambda>(l, r). return_pmf \\<langle>l, x, r\\<rangle>))", "by (subst random_bst.simps) (simp add: bind_return_pmf bind_assoc_pmf)"], ["proof (state)\nthis:\n  random_bst A =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf (random_bst (L x)) (random_bst (R x)) \\<bind>\n      (\\<lambda>(l, r). return_pmf \\<langle>l, x, r\\<rangle>))\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\n 2. A \\<noteq> {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "also"], ["proof (state)\nthis:\n  random_bst A =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf (random_bst (L x)) (random_bst (R x)) \\<bind>\n      (\\<lambda>(l, r). return_pmf \\<langle>l, x, r\\<rangle>))\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\n 2. A \\<noteq> {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "have \"\\<dots> = do {\n                      x \\<leftarrow> pmf_of_set A;\n                      (l, r) \\<leftarrow> pair_pmf\n                        (map_pmf bst_of_list (pmf_of_set (permutations_of_set (L x))))\n                        (map_pmf bst_of_list (pmf_of_set (permutations_of_set (R x))));\n                      return_pmf (Node l x r)\n                    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pair_pmf (random_bst (L x)) (random_bst (R x)) \\<bind>\n        (\\<lambda>(l, r). return_pmf \\<langle>l, x, r\\<rangle>)) =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pair_pmf\n         (map_pmf bst_of_list (pmf_of_set (permutations_of_set (L x))))\n         (map_pmf bst_of_list\n           (pmf_of_set (permutations_of_set (R x)))) \\<bind>\n        (\\<lambda>(l, r). return_pmf \\<langle>l, x, r\\<rangle>))", "using A"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pair_pmf (random_bst (L x)) (random_bst (R x)) \\<bind>\n        (\\<lambda>(l, r). return_pmf \\<langle>l, x, r\\<rangle>)) =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pair_pmf\n         (map_pmf bst_of_list (pmf_of_set (permutations_of_set (L x))))\n         (map_pmf bst_of_list\n           (pmf_of_set (permutations_of_set (R x)))) \\<bind>\n        (\\<lambda>(l, r). return_pmf \\<langle>l, x, r\\<rangle>))", "by (intro bind_pmf_cong refl) (simp_all add: IH)"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf (random_bst (L x)) (random_bst (R x)) \\<bind>\n      (\\<lambda>(l, r). return_pmf \\<langle>l, x, r\\<rangle>)) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf\n       (map_pmf bst_of_list (pmf_of_set (permutations_of_set (L x))))\n       (map_pmf bst_of_list\n         (pmf_of_set (permutations_of_set (R x)))) \\<bind>\n      (\\<lambda>(l, r). return_pmf \\<langle>l, x, r\\<rangle>))\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\n 2. A \\<noteq> {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "also"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf (random_bst (L x)) (random_bst (R x)) \\<bind>\n      (\\<lambda>(l, r). return_pmf \\<langle>l, x, r\\<rangle>)) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf\n       (map_pmf bst_of_list (pmf_of_set (permutations_of_set (L x))))\n       (map_pmf bst_of_list\n         (pmf_of_set (permutations_of_set (R x)))) \\<bind>\n      (\\<lambda>(l, r). return_pmf \\<langle>l, x, r\\<rangle>))\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\n 2. A \\<noteq> {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "have \"\\<dots> = do {\n                     x \\<leftarrow> pmf_of_set A;\n                     (ls, rs) \\<leftarrow> pair_pmf (pmf_of_set (permutations_of_set (L x)))\n                                          (pmf_of_set (permutations_of_set (R x)));\n                     return_pmf (Node (bst_of_list ls) x (bst_of_list rs))\n                   }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pair_pmf\n         (map_pmf bst_of_list (pmf_of_set (permutations_of_set (L x))))\n         (map_pmf bst_of_list\n           (pmf_of_set (permutations_of_set (R x)))) \\<bind>\n        (\\<lambda>(l, r). return_pmf \\<langle>l, x, r\\<rangle>)) =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pair_pmf (pmf_of_set (permutations_of_set (L x)))\n         (pmf_of_set (permutations_of_set (R x))) \\<bind>\n        (\\<lambda>(ls, rs).\n            return_pmf \\<langle>bst_of_list ls, x, bst_of_list rs\\<rangle>))", "unfolding map_pair [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        map_pmf (\\<lambda>(a, b). (bst_of_list a, bst_of_list b))\n         (pair_pmf (pmf_of_set (permutations_of_set (L x)))\n           (pmf_of_set (permutations_of_set (R x)))) \\<bind>\n        (\\<lambda>(l, r). return_pmf \\<langle>l, x, r\\<rangle>)) =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pair_pmf (pmf_of_set (permutations_of_set (L x)))\n         (pmf_of_set (permutations_of_set (R x))) \\<bind>\n        (\\<lambda>(ls, rs).\n            return_pmf \\<langle>bst_of_list ls, x, bst_of_list rs\\<rangle>))", "by (simp add: map_pmf_def case_prod_unfold bind_return_pmf bind_assoc_pmf)"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf\n       (map_pmf bst_of_list (pmf_of_set (permutations_of_set (L x))))\n       (map_pmf bst_of_list\n         (pmf_of_set (permutations_of_set (R x)))) \\<bind>\n      (\\<lambda>(l, r). return_pmf \\<langle>l, x, r\\<rangle>)) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf (pmf_of_set (permutations_of_set (L x)))\n       (pmf_of_set (permutations_of_set (R x))) \\<bind>\n      (\\<lambda>(ls, rs).\n          return_pmf \\<langle>bst_of_list ls, x, bst_of_list rs\\<rangle>))\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\n 2. A \\<noteq> {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "also"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf\n       (map_pmf bst_of_list (pmf_of_set (permutations_of_set (L x))))\n       (map_pmf bst_of_list\n         (pmf_of_set (permutations_of_set (R x)))) \\<bind>\n      (\\<lambda>(l, r). return_pmf \\<langle>l, x, r\\<rangle>)) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf (pmf_of_set (permutations_of_set (L x)))\n       (pmf_of_set (permutations_of_set (R x))) \\<bind>\n      (\\<lambda>(ls, rs).\n          return_pmf \\<langle>bst_of_list ls, x, bst_of_list rs\\<rangle>))\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\n 2. A \\<noteq> {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "have \"L = (\\<lambda>x. {y \\<in> A - {x}. y \\<le> x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L = (\\<lambda>x. {y \\<in> A - {x}. y \\<le> x})", "by (auto simp: L_def)"], ["proof (state)\nthis:\n  L = (\\<lambda>x. {y \\<in> A - {x}. y \\<le> x})\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\n 2. A \\<noteq> {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "also"], ["proof (state)\nthis:\n  L = (\\<lambda>x. {y \\<in> A - {x}. y \\<le> x})\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\n 2. A \\<noteq> {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "have \"R = (\\<lambda>x. {y \\<in> A - {x}. \\<not>y \\<le> x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R = (\\<lambda>x. {y \\<in> A - {x}. \\<not> y \\<le> x})", "by (auto simp: R_def)"], ["proof (state)\nthis:\n  R = (\\<lambda>x. {y \\<in> A - {x}. \\<not> y \\<le> x})\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\n 2. A \\<noteq> {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "also"], ["proof (state)\nthis:\n  R = (\\<lambda>x. {y \\<in> A - {x}. \\<not> y \\<le> x})\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\n 2. A \\<noteq> {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "have \"do {\n                 x \\<leftarrow> pmf_of_set A;\n                 (ls, rs) \\<leftarrow> pair_pmf (pmf_of_set (permutations_of_set {y \\<in> A - {x}. y \\<le> x}))\n                                      (pmf_of_set (permutations_of_set {y \\<in> A - {x}. \\<not>y \\<le> x}));\n                 return_pmf (Node (bst_of_list ls) x (bst_of_list rs))\n               } =\n               do {\n                 x \\<leftarrow> pmf_of_set A;\n                 (ls, rs) \\<leftarrow> map_pmf (partition (\\<lambda>y. y \\<le> x))\n                               (pmf_of_set (permutations_of_set (A - {x})));\n                 return_pmf (Node (bst_of_list ls) x (bst_of_list rs))\n               }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pair_pmf\n         (pmf_of_set (permutations_of_set {y \\<in> A - {x}. y \\<le> x}))\n         (pmf_of_set\n           (permutations_of_set\n             {y \\<in> A - {x}. \\<not> y \\<le> x})) \\<bind>\n        (\\<lambda>(ls, rs).\n            return_pmf\n             \\<langle>bst_of_list ls, x, bst_of_list rs\\<rangle>)) =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        map_pmf (partition (\\<lambda>y. y \\<le> x))\n         (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n        (\\<lambda>(ls, rs).\n            return_pmf \\<langle>bst_of_list ls, x, bst_of_list rs\\<rangle>))", "using \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pair_pmf\n         (pmf_of_set (permutations_of_set {y \\<in> A - {x}. y \\<le> x}))\n         (pmf_of_set\n           (permutations_of_set\n             {y \\<in> A - {x}. \\<not> y \\<le> x})) \\<bind>\n        (\\<lambda>(ls, rs).\n            return_pmf\n             \\<langle>bst_of_list ls, x, bst_of_list rs\\<rangle>)) =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        map_pmf (partition (\\<lambda>y. y \\<le> x))\n         (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n        (\\<lambda>(ls, rs).\n            return_pmf \\<langle>bst_of_list ls, x, bst_of_list rs\\<rangle>))", "by (intro bind_pmf_cong refl partition_random_permutations [symmetric]) auto"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf\n       (pmf_of_set (permutations_of_set {y \\<in> A - {x}. y \\<le> x}))\n       (pmf_of_set\n         (permutations_of_set {y \\<in> A - {x}. \\<not> y \\<le> x})) \\<bind>\n      (\\<lambda>(ls, rs).\n          return_pmf \\<langle>bst_of_list ls, x, bst_of_list rs\\<rangle>)) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      map_pmf (partition (\\<lambda>y. y \\<le> x))\n       (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n      (\\<lambda>(ls, rs).\n          return_pmf \\<langle>bst_of_list ls, x, bst_of_list rs\\<rangle>))\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\n 2. A \\<noteq> {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "also"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf\n       (pmf_of_set (permutations_of_set {y \\<in> A - {x}. y \\<le> x}))\n       (pmf_of_set\n         (permutations_of_set {y \\<in> A - {x}. \\<not> y \\<le> x})) \\<bind>\n      (\\<lambda>(ls, rs).\n          return_pmf \\<langle>bst_of_list ls, x, bst_of_list rs\\<rangle>)) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      map_pmf (partition (\\<lambda>y. y \\<le> x))\n       (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n      (\\<lambda>(ls, rs).\n          return_pmf \\<langle>bst_of_list ls, x, bst_of_list rs\\<rangle>))\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\n 2. A \\<noteq> {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "have \"\\<dots> = do {\n                      x \\<leftarrow> pmf_of_set A;\n                      (ls, rs) \\<leftarrow> map_pmf (\\<lambda>xs. ([y\\<leftarrow>xs. y < x], [y\\<leftarrow>xs. y > x]))\n                                    (pmf_of_set (permutations_of_set (A - {x})));\n                      return_pmf (Node (bst_of_list ls) x (bst_of_list rs))\n                    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        map_pmf (partition (\\<lambda>y. y \\<le> x))\n         (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n        (\\<lambda>(ls, rs).\n            return_pmf\n             \\<langle>bst_of_list ls, x, bst_of_list rs\\<rangle>)) =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        map_pmf\n         (\\<lambda>xs. (filter (\\<lambda>y. y < x) xs, filter ((<) x) xs))\n         (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n        (\\<lambda>(ls, rs).\n            return_pmf \\<langle>bst_of_list ls, x, bst_of_list rs\\<rangle>))", "using A"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        map_pmf (partition (\\<lambda>y. y \\<le> x))\n         (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n        (\\<lambda>(ls, rs).\n            return_pmf\n             \\<langle>bst_of_list ls, x, bst_of_list rs\\<rangle>)) =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        map_pmf\n         (\\<lambda>xs. (filter (\\<lambda>y. y < x) xs, filter ((<) x) xs))\n         (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n        (\\<lambda>(ls, rs).\n            return_pmf \\<langle>bst_of_list ls, x, bst_of_list rs\\<rangle>))", "by (intro bind_pmf_cong refl map_pmf_cong)\n         (auto intro!: filter_cong dest: permutations_of_setD simp: order.strict_iff_order)"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      map_pmf (partition (\\<lambda>y. y \\<le> x))\n       (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n      (\\<lambda>(ls, rs).\n          return_pmf \\<langle>bst_of_list ls, x, bst_of_list rs\\<rangle>)) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      map_pmf\n       (\\<lambda>xs. (filter (\\<lambda>y. y < x) xs, filter ((<) x) xs))\n       (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n      (\\<lambda>(ls, rs).\n          return_pmf \\<langle>bst_of_list ls, x, bst_of_list rs\\<rangle>))\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\n 2. A \\<noteq> {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "also"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      map_pmf (partition (\\<lambda>y. y \\<le> x))\n       (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n      (\\<lambda>(ls, rs).\n          return_pmf \\<langle>bst_of_list ls, x, bst_of_list rs\\<rangle>)) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      map_pmf\n       (\\<lambda>xs. (filter (\\<lambda>y. y < x) xs, filter ((<) x) xs))\n       (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n      (\\<lambda>(ls, rs).\n          return_pmf \\<langle>bst_of_list ls, x, bst_of_list rs\\<rangle>))\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\n 2. A \\<noteq> {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "have \"\\<dots> = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        map_pmf\n         (\\<lambda>xs. (filter (\\<lambda>y. y < x) xs, filter ((<) x) xs))\n         (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n        (\\<lambda>(ls, rs).\n            return_pmf\n             \\<langle>bst_of_list ls, x, bst_of_list rs\\<rangle>)) =\n    map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "using A"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        map_pmf\n         (\\<lambda>xs. (filter (\\<lambda>y. y < x) xs, filter ((<) x) xs))\n         (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n        (\\<lambda>(ls, rs).\n            return_pmf\n             \\<langle>bst_of_list ls, x, bst_of_list rs\\<rangle>)) =\n    map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "by (subst random_permutation_of_set[of A])\n                 (auto simp: map_pmf_def bind_return_pmf o_def bind_assoc_pmf not_le)"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      map_pmf\n       (\\<lambda>xs. (filter (\\<lambda>y. y < x) xs, filter ((<) x) xs))\n       (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n      (\\<lambda>(ls, rs).\n          return_pmf \\<langle>bst_of_list ls, x, bst_of_list rs\\<rangle>)) =\n  map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\n 2. A \\<noteq> {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "finally"], ["proof (chain)\npicking this:\n  random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "show ?thesis"], ["proof (prove)\nusing this:\n  random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\n\ngoal (1 subgoal):\n 1. random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "."], ["proof (state)\nthis:\n  random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\n\ngoal (1 subgoal):\n 1. A = {} \\<Longrightarrow>\n    random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "qed (simp_all add: pmf_of_set_singleton)"], ["proof (state)\nthis:\n  random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_set_random_bst [simp, intro]:\n  \"finite A \\<Longrightarrow> finite (set_pmf (random_bst A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> finite (set_pmf (random_bst A))", "by (simp add: random_bst_altdef)"], ["", "lemma random_bst_code [code]:\n  \"random_bst (set xs) = map_pmf bst_of_list (pmf_of_set (permutations_of_set (set xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. random_bst (set xs) =\n    map_pmf bst_of_list (pmf_of_set (permutations_of_set (set xs)))", "by (rule random_bst_altdef) simp_all"], ["", "lemma random_bst_singleton [simp]: \"random_bst {x} = return_pmf (Node Leaf x Leaf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. random_bst {x} =\n    return_pmf \\<langle>\\<langle>\\<rangle>, x, \\<langle>\\<rangle>\\<rangle>", "by (simp add: random_bst_altdef pmf_of_set_singleton)"], ["", "lemma size_random_bst:\n  assumes \"t \\<in> set_pmf (random_bst A)\" \"finite A\"\n  shows   \"size t = card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size t = card A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. size t = card A", "from assms"], ["proof (chain)\npicking this:\n  t \\<in> set_pmf (random_bst A)\n  finite A", "obtain xs where \"distinct xs\" \"A = set xs\" \"t = bst_of_list xs\""], ["proof (prove)\nusing this:\n  t \\<in> set_pmf (random_bst A)\n  finite A\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>distinct xs; A = set xs; t = bst_of_list xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: random_bst_altdef dest: permutations_of_setD)"], ["proof (state)\nthis:\n  distinct xs\n  A = set xs\n  t = bst_of_list xs\n\ngoal (1 subgoal):\n 1. size t = card A", "thus ?thesis"], ["proof (prove)\nusing this:\n  distinct xs\n  A = set xs\n  t = bst_of_list xs\n\ngoal (1 subgoal):\n 1. size t = card A", "using \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  distinct xs\n  A = set xs\n  t = bst_of_list xs\n  finite A\n\ngoal (1 subgoal):\n 1. size t = card A", "by (simp add: distinct_card)"], ["proof (state)\nthis:\n  size t = card A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma random_bst_image:\n  assumes \"finite A\" \"strict_mono_on f A\"\n  shows   \"random_bst (f ` A) = map_pmf (map_tree f) (random_bst A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. random_bst (f ` A) = map_pmf (map_tree f) (random_bst A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. random_bst (f ` A) = map_pmf (map_tree f) (random_bst A)", "from assms(2)"], ["proof (chain)\npicking this:\n  strict_mono_on f A", "have inj: \"inj_on f A\""], ["proof (prove)\nusing this:\n  strict_mono_on f A\n\ngoal (1 subgoal):\n 1. inj_on f A", "by (rule strict_mono_on_imp_inj_on)"], ["proof (state)\nthis:\n  inj_on f A\n\ngoal (1 subgoal):\n 1. random_bst (f ` A) = map_pmf (map_tree f) (random_bst A)", "with assms"], ["proof (chain)\npicking this:\n  finite A\n  strict_mono_on f A\n  inj_on f A", "have \"inj_on (map f) (permutations_of_set A)\""], ["proof (prove)\nusing this:\n  finite A\n  strict_mono_on f A\n  inj_on f A\n\ngoal (1 subgoal):\n 1. inj_on (map f) (permutations_of_set A)", "by (intro inj_on_mapI) auto"], ["proof (state)\nthis:\n  inj_on (map f) (permutations_of_set A)\n\ngoal (1 subgoal):\n 1. random_bst (f ` A) = map_pmf (map_tree f) (random_bst A)", "with assms inj"], ["proof (chain)\npicking this:\n  finite A\n  strict_mono_on f A\n  inj_on f A\n  inj_on (map f) (permutations_of_set A)", "have \"random_bst (f ` A) = \n                         map_pmf (\\<lambda>x. bst_of_list (map f x)) (pmf_of_set (permutations_of_set A))\""], ["proof (prove)\nusing this:\n  finite A\n  strict_mono_on f A\n  inj_on f A\n  inj_on (map f) (permutations_of_set A)\n\ngoal (1 subgoal):\n 1. random_bst (f ` A) =\n    map_pmf (\\<lambda>x. bst_of_list (map f x))\n     (pmf_of_set (permutations_of_set A))", "by (simp add: random_bst_altdef permutations_of_set_image_inj map_pmf_of_set_inj [symmetric]\n                  pmf.map_comp o_def)"], ["proof (state)\nthis:\n  random_bst (f ` A) =\n  map_pmf (\\<lambda>x. bst_of_list (map f x))\n   (pmf_of_set (permutations_of_set A))\n\ngoal (1 subgoal):\n 1. random_bst (f ` A) = map_pmf (map_tree f) (random_bst A)", "also"], ["proof (state)\nthis:\n  random_bst (f ` A) =\n  map_pmf (\\<lambda>x. bst_of_list (map f x))\n   (pmf_of_set (permutations_of_set A))\n\ngoal (1 subgoal):\n 1. random_bst (f ` A) = map_pmf (map_tree f) (random_bst A)", "have \"\\<dots> = map_pmf (map_tree f) (random_bst A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>x. bst_of_list (map f x))\n     (pmf_of_set (permutations_of_set A)) =\n    map_pmf (map_tree f) (random_bst A)", "unfolding random_bst_altdef[OF \\<open>finite A\\<close>] pmf.map_comp o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>x. bst_of_list (map f x))\n     (pmf_of_set (permutations_of_set A)) =\n    map_pmf (\\<lambda>x. map_tree f (bst_of_list x))\n     (pmf_of_set (permutations_of_set A))", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  strict_mono_on f A\n\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>x. bst_of_list (map f x))\n     (pmf_of_set (permutations_of_set A)) =\n    map_pmf (\\<lambda>x. map_tree f (bst_of_list x))\n     (pmf_of_set (permutations_of_set A))", "by (intro map_pmf_cong refl bst_of_list_map[of f A]) (auto dest: permutations_of_setD)"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>x. bst_of_list (map f x))\n   (pmf_of_set (permutations_of_set A)) =\n  map_pmf (map_tree f) (random_bst A)\n\ngoal (1 subgoal):\n 1. random_bst (f ` A) = map_pmf (map_tree f) (random_bst A)", "finally"], ["proof (chain)\npicking this:\n  random_bst (f ` A) = map_pmf (map_tree f) (random_bst A)", "show ?thesis"], ["proof (prove)\nusing this:\n  random_bst (f ` A) = map_pmf (map_tree f) (random_bst A)\n\ngoal (1 subgoal):\n 1. random_bst (f ` A) = map_pmf (map_tree f) (random_bst A)", "."], ["proof (state)\nthis:\n  random_bst (f ` A) = map_pmf (map_tree f) (random_bst A)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We can also re-phrase the non-recursive definition using the @{const fold_random_permutation}\n  combinator from the HOL-Probability library, which folds over a given set in random order.\n\\<close>"], ["", "lemma random_bst_altdef':\n  assumes \"finite A\"\n  shows   \"random_bst A = fold_random_permutation Tree_Set.insert Leaf A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. random_bst A =\n    fold_random_permutation Tree_Set.insert \\<langle>\\<rangle> A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. random_bst A =\n    fold_random_permutation Tree_Set.insert \\<langle>\\<rangle> A", "have \"random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "using assms"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))", "by (simp add: random_bst_altdef)"], ["proof (state)\nthis:\n  random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\n\ngoal (1 subgoal):\n 1. random_bst A =\n    fold_random_permutation Tree_Set.insert \\<langle>\\<rangle> A", "also"], ["proof (state)\nthis:\n  random_bst A = map_pmf bst_of_list (pmf_of_set (permutations_of_set A))\n\ngoal (1 subgoal):\n 1. random_bst A =\n    fold_random_permutation Tree_Set.insert \\<langle>\\<rangle> A", "have \"\\<dots> = map_pmf (\\<lambda>xs. fold Tree_Set.insert xs Leaf) (pmf_of_set (permutations_of_set A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf bst_of_list (pmf_of_set (permutations_of_set A)) =\n    map_pmf (\\<lambda>xs. fold Tree_Set.insert xs \\<langle>\\<rangle>)\n     (pmf_of_set (permutations_of_set A))", "using assms"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. map_pmf bst_of_list (pmf_of_set (permutations_of_set A)) =\n    map_pmf (\\<lambda>xs. fold Tree_Set.insert xs \\<langle>\\<rangle>)\n     (pmf_of_set (permutations_of_set A))", "by (intro map_pmf_cong refl) (auto simp: bst_of_list_altdef)"], ["proof (state)\nthis:\n  map_pmf bst_of_list (pmf_of_set (permutations_of_set A)) =\n  map_pmf (\\<lambda>xs. fold Tree_Set.insert xs \\<langle>\\<rangle>)\n   (pmf_of_set (permutations_of_set A))\n\ngoal (1 subgoal):\n 1. random_bst A =\n    fold_random_permutation Tree_Set.insert \\<langle>\\<rangle> A", "also"], ["proof (state)\nthis:\n  map_pmf bst_of_list (pmf_of_set (permutations_of_set A)) =\n  map_pmf (\\<lambda>xs. fold Tree_Set.insert xs \\<langle>\\<rangle>)\n   (pmf_of_set (permutations_of_set A))\n\ngoal (1 subgoal):\n 1. random_bst A =\n    fold_random_permutation Tree_Set.insert \\<langle>\\<rangle> A", "from assms"], ["proof (chain)\npicking this:\n  finite A", "have \"\\<dots> = fold_random_permutation Tree_Set.insert Leaf A\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>xs. fold Tree_Set.insert xs \\<langle>\\<rangle>)\n     (pmf_of_set (permutations_of_set A)) =\n    fold_random_permutation Tree_Set.insert \\<langle>\\<rangle> A", "by (simp add: fold_random_permutation_fold)"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>xs. fold Tree_Set.insert xs \\<langle>\\<rangle>)\n   (pmf_of_set (permutations_of_set A)) =\n  fold_random_permutation Tree_Set.insert \\<langle>\\<rangle> A\n\ngoal (1 subgoal):\n 1. random_bst A =\n    fold_random_permutation Tree_Set.insert \\<langle>\\<rangle> A", "finally"], ["proof (chain)\npicking this:\n  random_bst A =\n  fold_random_permutation Tree_Set.insert \\<langle>\\<rangle> A", "show ?thesis"], ["proof (prove)\nusing this:\n  random_bst A =\n  fold_random_permutation Tree_Set.insert \\<langle>\\<rangle> A\n\ngoal (1 subgoal):\n 1. random_bst A =\n    fold_random_permutation Tree_Set.insert \\<langle>\\<rangle> A", "."], ["proof (state)\nthis:\n  random_bst A =\n  fold_random_permutation Tree_Set.insert \\<langle>\\<rangle> A\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Expected height\\<close>"], ["", "text \\<open>\n  For the purposes of the analysis of the expected height, we define the following notion\n  of `expected height', which is essentially two to the power of the height (as defined\n  by Cormen \\textit{et al.}) with a special treatment for the empty tree, which has exponential\n  height 0.\n\n  Note that the height defined by Cormen \\textit{et al.}\\ differs from the @{const height}\n  function here in Isabelle in that for them, the height of the empty tree is undefined and\n  the height of a singleton tree is 0 etc., whereas in Isabelle, the height of the empty tree is\n  0 and the height of a singleton tree is 1.\n\\<close>"], ["", "definition eheight :: \"'a tree \\<Rightarrow> nat\" where\n  \"eheight t = (if t = Leaf then 0 else 2 ^ (height t - 1))\""], ["", "lemma eheight_Leaf [simp]: \"eheight Leaf = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eheight \\<langle>\\<rangle> = 0", "by (simp add: eheight_def)"], ["", "lemma eheight_Node_singleton [simp]: \"eheight (Node Leaf x Leaf) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eheight \\<langle>\\<langle>\\<rangle>, x, \\<langle>\\<rangle>\\<rangle> = 1", "by (simp add: eheight_def)"], ["", "lemma eheight_Node:\n  \"l \\<noteq> Leaf \\<or> r \\<noteq> Leaf \\<Longrightarrow> eheight (Node l x r) = 2 * max (eheight l) (eheight r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> \\<langle>\\<rangle> \\<or>\n    r \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    eheight \\<langle>l, x, r\\<rangle> = 2 * max (eheight l) (eheight r)", "by (cases l; cases r) (simp_all add: eheight_def max_power_distrib_right)"], ["", "fun eheight_rbst :: \"nat \\<Rightarrow> nat pmf\" where\n  \"eheight_rbst 0 = return_pmf 0\"\n| \"eheight_rbst (Suc 0) = return_pmf 1\"\n| \"eheight_rbst (Suc n) =\n     do {\n       k \\<leftarrow> pmf_of_set {..n};\n       h1 \\<leftarrow> eheight_rbst k;\n       h2 \\<leftarrow> eheight_rbst (n - k);\n       return_pmf (2 * max h1 h2)}\""], ["", "definition eheight_exp :: \"nat \\<Rightarrow> real\" where\n  \"eheight_exp n = measure_pmf.expectation (eheight_rbst n) real\""], ["", "lemma eheight_rbst_reduce:\n  assumes \"n > 1\"\n  shows   \"eheight_rbst n =\n             do {k \\<leftarrow> pmf_of_set {..<n}; h1 \\<leftarrow> eheight_rbst k; h2 \\<leftarrow> eheight_rbst (n - k - 1);\n                 return_pmf (2 * max h1 h2)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eheight_rbst n =\n    pmf_of_set {..<n} \\<bind>\n    (\\<lambda>k.\n        eheight_rbst k \\<bind>\n        (\\<lambda>h1.\n            eheight_rbst (n - k - 1) \\<bind>\n            (\\<lambda>h2. return_pmf (2 * max h1 h2))))", "using assms"], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. eheight_rbst n =\n    pmf_of_set {..<n} \\<bind>\n    (\\<lambda>k.\n        eheight_rbst k \\<bind>\n        (\\<lambda>h1.\n            eheight_rbst (n - k - 1) \\<bind>\n            (\\<lambda>h2. return_pmf (2 * max h1 h2))))", "by (cases n rule: eheight_rbst.cases) (simp_all add: lessThan_Suc_atMost)"], ["", "lemma Leaf_in_set_random_bst_iff:\n  assumes \"finite A\"\n  shows   \"Leaf \\<in> set_pmf (random_bst A) \\<longleftrightarrow> A = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>\\<rangle> \\<in> set_pmf (random_bst A)) = (A = {})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<langle>\\<rangle> \\<in> set_pmf (random_bst A) \\<Longrightarrow> A = {}\n 2. A = {} \\<Longrightarrow> \\<langle>\\<rangle> \\<in> set_pmf (random_bst A)", "assume \"Leaf \\<in> set_pmf (random_bst A)\""], ["proof (state)\nthis:\n  \\<langle>\\<rangle> \\<in> set_pmf (random_bst A)\n\ngoal (2 subgoals):\n 1. \\<langle>\\<rangle> \\<in> set_pmf (random_bst A) \\<Longrightarrow> A = {}\n 2. A = {} \\<Longrightarrow> \\<langle>\\<rangle> \\<in> set_pmf (random_bst A)", "from size_random_bst[OF this] and assms"], ["proof (chain)\npicking this:\n  finite A \\<Longrightarrow> size \\<langle>\\<rangle> = card A\n  finite A", "show \"A = {}\""], ["proof (prove)\nusing this:\n  finite A \\<Longrightarrow> size \\<langle>\\<rangle> = card A\n  finite A\n\ngoal (1 subgoal):\n 1. A = {}", "by auto"], ["proof (state)\nthis:\n  A = {}\n\ngoal (1 subgoal):\n 1. A = {} \\<Longrightarrow> \\<langle>\\<rangle> \\<in> set_pmf (random_bst A)", "qed auto"], ["", "lemma eheight_rbst:\n  assumes \"finite A\"\n  shows   \"eheight_rbst (card A) = map_pmf eheight (random_bst A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eheight_rbst (card A) = map_pmf eheight (random_bst A)", "using assms"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. eheight_rbst (card A) = map_pmf eheight (random_bst A)", "proof (induction A rule: finite_psubset_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>finite A;\n        \\<And>B.\n           B \\<subset> A \\<Longrightarrow>\n           eheight_rbst (card B) = map_pmf eheight (random_bst B)\\<rbrakk>\n       \\<Longrightarrow> eheight_rbst (card A) =\n                         map_pmf eheight (random_bst A)", "case (psubset A)"], ["proof (state)\nthis:\n  finite A\n  ?B \\<subset> A \\<Longrightarrow>\n  eheight_rbst (card ?B) = map_pmf eheight (random_bst ?B)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>finite A;\n        \\<And>B.\n           B \\<subset> A \\<Longrightarrow>\n           eheight_rbst (card B) = map_pmf eheight (random_bst B)\\<rbrakk>\n       \\<Longrightarrow> eheight_rbst (card A) =\n                         map_pmf eheight (random_bst A)", "define rank where \"rank = linorder_rank {(x,y). x \\<le> y} A\""], ["proof (state)\nthis:\n  rank = linorder_rank {(x, y). x \\<le> y} A\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>finite A;\n        \\<And>B.\n           B \\<subset> A \\<Longrightarrow>\n           eheight_rbst (card B) = map_pmf eheight (random_bst B)\\<rbrakk>\n       \\<Longrightarrow> eheight_rbst (card A) =\n                         map_pmf eheight (random_bst A)", "from \\<open>finite A\\<close>"], ["proof (chain)\npicking this:\n  finite A", "have \"A = {} \\<or> is_singleton A \\<or> card A > 1\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. A = {} \\<or> is_singleton A \\<or> 1 < card A", "by (auto simp: not_less le_Suc_eq is_singleton_altdef)"], ["proof (state)\nthis:\n  A = {} \\<or> is_singleton A \\<or> 1 < card A\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>finite A;\n        \\<And>B.\n           B \\<subset> A \\<Longrightarrow>\n           eheight_rbst (card B) = map_pmf eheight (random_bst B)\\<rbrakk>\n       \\<Longrightarrow> eheight_rbst (card A) =\n                         map_pmf eheight (random_bst A)", "then"], ["proof (chain)\npicking this:\n  A = {} \\<or> is_singleton A \\<or> 1 < card A", "consider \"A = {}\" | \"is_singleton A\" | \"card A > 1\""], ["proof (prove)\nusing this:\n  A = {} \\<or> is_singleton A \\<or> 1 < card A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A = {} \\<Longrightarrow> thesis;\n     is_singleton A \\<Longrightarrow> thesis;\n     1 < card A \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>A = {} \\<Longrightarrow> ?thesis;\n   is_singleton A \\<Longrightarrow> ?thesis;\n   1 < card A \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>finite A;\n        \\<And>B.\n           B \\<subset> A \\<Longrightarrow>\n           eheight_rbst (card B) = map_pmf eheight (random_bst B)\\<rbrakk>\n       \\<Longrightarrow> eheight_rbst (card A) =\n                         map_pmf eheight (random_bst A)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>A = {} \\<Longrightarrow> ?thesis;\n   is_singleton A \\<Longrightarrow> ?thesis;\n   1 < card A \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. eheight_rbst (card A) = map_pmf eheight (random_bst A)", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. A = {} \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 2. is_singleton A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 3. 1 < card A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)", "case 3"], ["proof (state)\nthis:\n  1 < card A\n\ngoal (3 subgoals):\n 1. A = {} \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 2. is_singleton A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 3. 1 < card A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)", "hence nonempty: \"A \\<noteq> {}\""], ["proof (prove)\nusing this:\n  1 < card A\n\ngoal (1 subgoal):\n 1. A \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  A \\<noteq> {}\n\ngoal (3 subgoals):\n 1. A = {} \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 2. is_singleton A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 3. 1 < card A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)", "from 3"], ["proof (chain)\npicking this:\n  1 < card A", "have \"\\<not>is_singleton A\""], ["proof (prove)\nusing this:\n  1 < card A\n\ngoal (1 subgoal):\n 1. \\<not> is_singleton A", "by (auto simp: is_singleton_def)"], ["proof (state)\nthis:\n  \\<not> is_singleton A\n\ngoal (3 subgoals):\n 1. A = {} \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 2. is_singleton A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 3. 1 < card A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)", "hence exists_other: \"\\<exists>y\\<in>A. y \\<noteq> x\" for x"], ["proof (prove)\nusing this:\n  \\<not> is_singleton A\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>A. y \\<noteq> x", "using \\<open>A \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  \\<not> is_singleton A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>A. y \\<noteq> x", "by (force simp: is_singleton_def)"], ["proof (state)\nthis:\n  \\<exists>y\\<in>A. y \\<noteq> ?x\n\ngoal (3 subgoals):\n 1. A = {} \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 2. is_singleton A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 3. 1 < card A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)", "hence \"map_pmf eheight (random_bst A) = \n             do {\n               x \\<leftarrow> pmf_of_set A;\n               l \\<leftarrow> random_bst {y \\<in> A. y < x};\n               r \\<leftarrow> random_bst {y \\<in> A. y > x};\n               return_pmf (eheight (Node l x r))\n             }\""], ["proof (prove)\nusing this:\n  \\<exists>y\\<in>A. y \\<noteq> ?x\n\ngoal (1 subgoal):\n 1. map_pmf eheight (random_bst A) =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        random_bst {y \\<in> A. y < x} \\<bind>\n        (\\<lambda>l.\n            random_bst {y \\<in> A. x < y} \\<bind>\n            (\\<lambda>r. return_pmf (eheight \\<langle>l, x, r\\<rangle>))))", "using \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>y\\<in>A. y \\<noteq> ?x\n  finite A\n\ngoal (1 subgoal):\n 1. map_pmf eheight (random_bst A) =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        random_bst {y \\<in> A. y < x} \\<bind>\n        (\\<lambda>l.\n            random_bst {y \\<in> A. x < y} \\<bind>\n            (\\<lambda>r. return_pmf (eheight \\<langle>l, x, r\\<rangle>))))", "by (subst random_bst.simps) (auto simp: map_bind_pmf)"], ["proof (state)\nthis:\n  map_pmf eheight (random_bst A) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      random_bst {y \\<in> A. y < x} \\<bind>\n      (\\<lambda>l.\n          random_bst {y \\<in> A. x < y} \\<bind>\n          (\\<lambda>r. return_pmf (eheight \\<langle>l, x, r\\<rangle>))))\n\ngoal (3 subgoals):\n 1. A = {} \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 2. is_singleton A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 3. 1 < card A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)", "also"], ["proof (state)\nthis:\n  map_pmf eheight (random_bst A) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      random_bst {y \\<in> A. y < x} \\<bind>\n      (\\<lambda>l.\n          random_bst {y \\<in> A. x < y} \\<bind>\n          (\\<lambda>r. return_pmf (eheight \\<langle>l, x, r\\<rangle>))))\n\ngoal (3 subgoals):\n 1. A = {} \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 2. is_singleton A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 3. 1 < card A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)", "have \"\\<dots> = do {\n                      x \\<leftarrow> pmf_of_set A;\n                      l \\<leftarrow> random_bst {y \\<in> A. y < x};\n                      r \\<leftarrow> random_bst {y \\<in> A. y > x};\n                      return_pmf (2 * max (eheight l) (eheight r))\n                    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        random_bst {y \\<in> A. y < x} \\<bind>\n        (\\<lambda>l.\n            random_bst {y \\<in> A. x < y} \\<bind>\n            (\\<lambda>r. return_pmf (eheight \\<langle>l, x, r\\<rangle>)))) =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        random_bst {y \\<in> A. y < x} \\<bind>\n        (\\<lambda>l.\n            random_bst {y \\<in> A. x < y} \\<bind>\n            (\\<lambda>r. return_pmf (2 * max (eheight l) (eheight r)))))", "using 3 \\<open>finite A\\<close> exists_other"], ["proof (prove)\nusing this:\n  1 < card A\n  finite A\n  \\<exists>y\\<in>A. y \\<noteq> ?x\n\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        random_bst {y \\<in> A. y < x} \\<bind>\n        (\\<lambda>l.\n            random_bst {y \\<in> A. x < y} \\<bind>\n            (\\<lambda>r. return_pmf (eheight \\<langle>l, x, r\\<rangle>)))) =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        random_bst {y \\<in> A. y < x} \\<bind>\n        (\\<lambda>l.\n            random_bst {y \\<in> A. x < y} \\<bind>\n            (\\<lambda>r. return_pmf (2 * max (eheight l) (eheight r)))))", "by (intro bind_pmf_cong refl, subst eheight_Node)\n         (force simp: Leaf_in_set_random_bst_iff not_less nonempty eheight_Node)+"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      random_bst {y \\<in> A. y < x} \\<bind>\n      (\\<lambda>l.\n          random_bst {y \\<in> A. x < y} \\<bind>\n          (\\<lambda>r. return_pmf (eheight \\<langle>l, x, r\\<rangle>)))) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      random_bst {y \\<in> A. y < x} \\<bind>\n      (\\<lambda>l.\n          random_bst {y \\<in> A. x < y} \\<bind>\n          (\\<lambda>r. return_pmf (2 * max (eheight l) (eheight r)))))\n\ngoal (3 subgoals):\n 1. A = {} \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 2. is_singleton A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 3. 1 < card A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)", "also"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      random_bst {y \\<in> A. y < x} \\<bind>\n      (\\<lambda>l.\n          random_bst {y \\<in> A. x < y} \\<bind>\n          (\\<lambda>r. return_pmf (eheight \\<langle>l, x, r\\<rangle>)))) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      random_bst {y \\<in> A. y < x} \\<bind>\n      (\\<lambda>l.\n          random_bst {y \\<in> A. x < y} \\<bind>\n          (\\<lambda>r. return_pmf (2 * max (eheight l) (eheight r)))))\n\ngoal (3 subgoals):\n 1. A = {} \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 2. is_singleton A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 3. 1 < card A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)", "have \"\\<dots> = do {\n                      x \\<leftarrow> pmf_of_set A;\n                      h1 \\<leftarrow> map_pmf eheight (random_bst {y \\<in> A. y < x});\n                      h2 \\<leftarrow> map_pmf eheight (random_bst {y \\<in> A. y > x});\n                      return_pmf (2 * max h1 h2)\n                    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        random_bst {y \\<in> A. y < x} \\<bind>\n        (\\<lambda>l.\n            random_bst {y \\<in> A. x < y} \\<bind>\n            (\\<lambda>r. return_pmf (2 * max (eheight l) (eheight r))))) =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        map_pmf eheight (random_bst {y \\<in> A. y < x}) \\<bind>\n        (\\<lambda>h1.\n            map_pmf eheight (random_bst {y \\<in> A. x < y}) \\<bind>\n            (\\<lambda>h2. return_pmf (2 * max h1 h2))))", "by (simp add: bind_map_pmf)"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      random_bst {y \\<in> A. y < x} \\<bind>\n      (\\<lambda>l.\n          random_bst {y \\<in> A. x < y} \\<bind>\n          (\\<lambda>r. return_pmf (2 * max (eheight l) (eheight r))))) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      map_pmf eheight (random_bst {y \\<in> A. y < x}) \\<bind>\n      (\\<lambda>h1.\n          map_pmf eheight (random_bst {y \\<in> A. x < y}) \\<bind>\n          (\\<lambda>h2. return_pmf (2 * max h1 h2))))\n\ngoal (3 subgoals):\n 1. A = {} \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 2. is_singleton A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 3. 1 < card A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)", "also"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      random_bst {y \\<in> A. y < x} \\<bind>\n      (\\<lambda>l.\n          random_bst {y \\<in> A. x < y} \\<bind>\n          (\\<lambda>r. return_pmf (2 * max (eheight l) (eheight r))))) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      map_pmf eheight (random_bst {y \\<in> A. y < x}) \\<bind>\n      (\\<lambda>h1.\n          map_pmf eheight (random_bst {y \\<in> A. x < y}) \\<bind>\n          (\\<lambda>h2. return_pmf (2 * max h1 h2))))\n\ngoal (3 subgoals):\n 1. A = {} \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 2. is_singleton A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 3. 1 < card A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)", "have \"\\<dots> = do {\n                      x \\<leftarrow> pmf_of_set A;\n                      h1 \\<leftarrow> eheight_rbst (card {y \\<in> A. y < x});\n                      h2 \\<leftarrow> eheight_rbst (card {y \\<in> A. y > x});\n                      return_pmf (2 * max h1 h2)\n                    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        map_pmf eheight (random_bst {y \\<in> A. y < x}) \\<bind>\n        (\\<lambda>h1.\n            map_pmf eheight (random_bst {y \\<in> A. x < y}) \\<bind>\n            (\\<lambda>h2. return_pmf (2 * max h1 h2)))) =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        eheight_rbst (card {y \\<in> A. y < x}) \\<bind>\n        (\\<lambda>h1.\n            eheight_rbst (card {y \\<in> A. x < y}) \\<bind>\n            (\\<lambda>h2. return_pmf (2 * max h1 h2))))", "using \\<open>A \\<noteq> {}\\<close> \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n  finite A\n\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        map_pmf eheight (random_bst {y \\<in> A. y < x}) \\<bind>\n        (\\<lambda>h1.\n            map_pmf eheight (random_bst {y \\<in> A. x < y}) \\<bind>\n            (\\<lambda>h2. return_pmf (2 * max h1 h2)))) =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        eheight_rbst (card {y \\<in> A. y < x}) \\<bind>\n        (\\<lambda>h1.\n            eheight_rbst (card {y \\<in> A. x < y}) \\<bind>\n            (\\<lambda>h2. return_pmf (2 * max h1 h2))))", "by (intro bind_pmf_cong psubset.IH [symmetric] refl) auto"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      map_pmf eheight (random_bst {y \\<in> A. y < x}) \\<bind>\n      (\\<lambda>h1.\n          map_pmf eheight (random_bst {y \\<in> A. x < y}) \\<bind>\n          (\\<lambda>h2. return_pmf (2 * max h1 h2)))) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      eheight_rbst (card {y \\<in> A. y < x}) \\<bind>\n      (\\<lambda>h1.\n          eheight_rbst (card {y \\<in> A. x < y}) \\<bind>\n          (\\<lambda>h2. return_pmf (2 * max h1 h2))))\n\ngoal (3 subgoals):\n 1. A = {} \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 2. is_singleton A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 3. 1 < card A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)", "also"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      map_pmf eheight (random_bst {y \\<in> A. y < x}) \\<bind>\n      (\\<lambda>h1.\n          map_pmf eheight (random_bst {y \\<in> A. x < y}) \\<bind>\n          (\\<lambda>h2. return_pmf (2 * max h1 h2)))) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      eheight_rbst (card {y \\<in> A. y < x}) \\<bind>\n      (\\<lambda>h1.\n          eheight_rbst (card {y \\<in> A. x < y}) \\<bind>\n          (\\<lambda>h2. return_pmf (2 * max h1 h2))))\n\ngoal (3 subgoals):\n 1. A = {} \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 2. is_singleton A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 3. 1 < card A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)", "have \"\\<dots> = do {\n                      k \\<leftarrow> map_pmf rank (pmf_of_set A);\n                      h1 \\<leftarrow> eheight_rbst k;\n                      h2 \\<leftarrow> eheight_rbst (card A - k - 1);\n                      return_pmf (2 * max h1 h2)\n                    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        eheight_rbst (card {y \\<in> A. y < x}) \\<bind>\n        (\\<lambda>h1.\n            eheight_rbst (card {y \\<in> A. x < y}) \\<bind>\n            (\\<lambda>h2. return_pmf (2 * max h1 h2)))) =\n    map_pmf rank (pmf_of_set A) \\<bind>\n    (\\<lambda>k.\n        eheight_rbst k \\<bind>\n        (\\<lambda>h1.\n            eheight_rbst (card A - k - 1) \\<bind>\n            (\\<lambda>h2. return_pmf (2 * max h1 h2))))", "unfolding bind_map_pmf"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        eheight_rbst (card {y \\<in> A. y < x}) \\<bind>\n        (\\<lambda>h1.\n            eheight_rbst (card {y \\<in> A. x < y}) \\<bind>\n            (\\<lambda>h2. return_pmf (2 * max h1 h2)))) =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        eheight_rbst (rank x) \\<bind>\n        (\\<lambda>h1.\n            eheight_rbst (card A - rank x - 1) \\<bind>\n            (\\<lambda>h2. return_pmf (2 * max h1 h2))))", "proof (intro bind_pmf_cong refl, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       eheight_rbst (card {y \\<in> A. y < x}) = eheight_rbst (rank x)\n 2. \\<And>x xa.\n       \\<lbrakk>x \\<in> set_pmf (pmf_of_set A);\n        xa \\<in> set_pmf (eheight_rbst (rank x))\\<rbrakk>\n       \\<Longrightarrow> eheight_rbst (card {y \\<in> A. x < y}) =\n                         eheight_rbst (card A - rank x - 1)", "case (1 x)"], ["proof (state)\nthis:\n  x \\<in> set_pmf (pmf_of_set A)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       eheight_rbst (card {y \\<in> A. y < x}) = eheight_rbst (rank x)\n 2. \\<And>x xa.\n       \\<lbrakk>x \\<in> set_pmf (pmf_of_set A);\n        xa \\<in> set_pmf (eheight_rbst (rank x))\\<rbrakk>\n       \\<Longrightarrow> eheight_rbst (card {y \\<in> A. x < y}) =\n                         eheight_rbst (card A - rank x - 1)", "have \"rank x = card {y\\<in>A-{x}. y \\<le> x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank x = card {y \\<in> A - {x}. y \\<le> x}", "by (simp add: rank_def linorder_rank_def)"], ["proof (state)\nthis:\n  rank x = card {y \\<in> A - {x}. y \\<le> x}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       eheight_rbst (card {y \\<in> A. y < x}) = eheight_rbst (rank x)\n 2. \\<And>x xa.\n       \\<lbrakk>x \\<in> set_pmf (pmf_of_set A);\n        xa \\<in> set_pmf (eheight_rbst (rank x))\\<rbrakk>\n       \\<Longrightarrow> eheight_rbst (card {y \\<in> A. x < y}) =\n                         eheight_rbst (card A - rank x - 1)", "also"], ["proof (state)\nthis:\n  rank x = card {y \\<in> A - {x}. y \\<le> x}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       eheight_rbst (card {y \\<in> A. y < x}) = eheight_rbst (rank x)\n 2. \\<And>x xa.\n       \\<lbrakk>x \\<in> set_pmf (pmf_of_set A);\n        xa \\<in> set_pmf (eheight_rbst (rank x))\\<rbrakk>\n       \\<Longrightarrow> eheight_rbst (card {y \\<in> A. x < y}) =\n                         eheight_rbst (card A - rank x - 1)", "have \"{y\\<in>A-{x}. y \\<le> x} = {y\\<in>A. y < x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y \\<in> A - {x}. y \\<le> x} = {y \\<in> A. y < x}", "by auto"], ["proof (state)\nthis:\n  {y \\<in> A - {x}. y \\<le> x} = {y \\<in> A. y < x}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       eheight_rbst (card {y \\<in> A. y < x}) = eheight_rbst (rank x)\n 2. \\<And>x xa.\n       \\<lbrakk>x \\<in> set_pmf (pmf_of_set A);\n        xa \\<in> set_pmf (eheight_rbst (rank x))\\<rbrakk>\n       \\<Longrightarrow> eheight_rbst (card {y \\<in> A. x < y}) =\n                         eheight_rbst (card A - rank x - 1)", "finally"], ["proof (chain)\npicking this:\n  rank x = card {y \\<in> A. y < x}", "show ?case"], ["proof (prove)\nusing this:\n  rank x = card {y \\<in> A. y < x}\n\ngoal (1 subgoal):\n 1. eheight_rbst (card {y \\<in> A. y < x}) = eheight_rbst (rank x)", "by simp"], ["proof (state)\nthis:\n  eheight_rbst (card {y \\<in> A. y < x}) = eheight_rbst (rank x)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> set_pmf (pmf_of_set A);\n        xa \\<in> set_pmf (eheight_rbst (rank x))\\<rbrakk>\n       \\<Longrightarrow> eheight_rbst (card {y \\<in> A. x < y}) =\n                         eheight_rbst (card A - rank x - 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> set_pmf (pmf_of_set A);\n        xa \\<in> set_pmf (eheight_rbst (rank x))\\<rbrakk>\n       \\<Longrightarrow> eheight_rbst (card {y \\<in> A. x < y}) =\n                         eheight_rbst (card A - rank x - 1)", "case (2 x)"], ["proof (state)\nthis:\n  x \\<in> set_pmf (pmf_of_set A)\n  xa_ \\<in> set_pmf (eheight_rbst (rank x))\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> set_pmf (pmf_of_set A);\n        xa \\<in> set_pmf (eheight_rbst (rank x))\\<rbrakk>\n       \\<Longrightarrow> eheight_rbst (card {y \\<in> A. x < y}) =\n                         eheight_rbst (card A - rank x - 1)", "have \"A - {x} = {y\\<in>A-{x}. y \\<le> x} \\<union> {y\\<in>A. y > x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - {x} = {y \\<in> A - {x}. y \\<le> x} \\<union> {y \\<in> A. x < y}", "by auto"], ["proof (state)\nthis:\n  A - {x} = {y \\<in> A - {x}. y \\<le> x} \\<union> {y \\<in> A. x < y}\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> set_pmf (pmf_of_set A);\n        xa \\<in> set_pmf (eheight_rbst (rank x))\\<rbrakk>\n       \\<Longrightarrow> eheight_rbst (card {y \\<in> A. x < y}) =\n                         eheight_rbst (card A - rank x - 1)", "also"], ["proof (state)\nthis:\n  A - {x} = {y \\<in> A - {x}. y \\<le> x} \\<union> {y \\<in> A. x < y}\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> set_pmf (pmf_of_set A);\n        xa \\<in> set_pmf (eheight_rbst (rank x))\\<rbrakk>\n       \\<Longrightarrow> eheight_rbst (card {y \\<in> A. x < y}) =\n                         eheight_rbst (card A - rank x - 1)", "have \"card \\<dots> = rank x + card {y\\<in>A. y > x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ({y \\<in> A - {x}. y \\<le> x} \\<union> {y \\<in> A. x < y}) =\n    rank x + card {y \\<in> A. x < y}", "using \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. card ({y \\<in> A - {x}. y \\<le> x} \\<union> {y \\<in> A. x < y}) =\n    rank x + card {y \\<in> A. x < y}", "by (subst card_Un_disjoint) (auto simp: rank_def linorder_rank_def)"], ["proof (state)\nthis:\n  card ({y \\<in> A - {x}. y \\<le> x} \\<union> {y \\<in> A. x < y}) =\n  rank x + card {y \\<in> A. x < y}\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> set_pmf (pmf_of_set A);\n        xa \\<in> set_pmf (eheight_rbst (rank x))\\<rbrakk>\n       \\<Longrightarrow> eheight_rbst (card {y \\<in> A. x < y}) =\n                         eheight_rbst (card A - rank x - 1)", "finally"], ["proof (chain)\npicking this:\n  card (A - {x}) = rank x + card {y \\<in> A. x < y}", "have \"card {y\\<in>A. y > x} = card A - rank x - 1\""], ["proof (prove)\nusing this:\n  card (A - {x}) = rank x + card {y \\<in> A. x < y}\n\ngoal (1 subgoal):\n 1. card {y \\<in> A. x < y} = card A - rank x - 1", "using 2 \\<open>finite A\\<close> \\<open>A \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  card (A - {x}) = rank x + card {y \\<in> A. x < y}\n  x \\<in> set_pmf (pmf_of_set A)\n  xa_ \\<in> set_pmf (eheight_rbst (rank x))\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card {y \\<in> A. x < y} = card A - rank x - 1", "by simp"], ["proof (state)\nthis:\n  card {y \\<in> A. x < y} = card A - rank x - 1\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> set_pmf (pmf_of_set A);\n        xa \\<in> set_pmf (eheight_rbst (rank x))\\<rbrakk>\n       \\<Longrightarrow> eheight_rbst (card {y \\<in> A. x < y}) =\n                         eheight_rbst (card A - rank x - 1)", "thus ?case"], ["proof (prove)\nusing this:\n  card {y \\<in> A. x < y} = card A - rank x - 1\n\ngoal (1 subgoal):\n 1. eheight_rbst (card {y \\<in> A. x < y}) =\n    eheight_rbst (card A - rank x - 1)", "by simp"], ["proof (state)\nthis:\n  eheight_rbst (card {y \\<in> A. x < y}) =\n  eheight_rbst (card A - rank x - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      eheight_rbst (card {y \\<in> A. y < x}) \\<bind>\n      (\\<lambda>h1.\n          eheight_rbst (card {y \\<in> A. x < y}) \\<bind>\n          (\\<lambda>h2. return_pmf (2 * max h1 h2)))) =\n  map_pmf rank (pmf_of_set A) \\<bind>\n  (\\<lambda>k.\n      eheight_rbst k \\<bind>\n      (\\<lambda>h1.\n          eheight_rbst (card A - k - 1) \\<bind>\n          (\\<lambda>h2. return_pmf (2 * max h1 h2))))\n\ngoal (3 subgoals):\n 1. A = {} \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 2. is_singleton A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 3. 1 < card A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)", "also"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      eheight_rbst (card {y \\<in> A. y < x}) \\<bind>\n      (\\<lambda>h1.\n          eheight_rbst (card {y \\<in> A. x < y}) \\<bind>\n          (\\<lambda>h2. return_pmf (2 * max h1 h2)))) =\n  map_pmf rank (pmf_of_set A) \\<bind>\n  (\\<lambda>k.\n      eheight_rbst k \\<bind>\n      (\\<lambda>h1.\n          eheight_rbst (card A - k - 1) \\<bind>\n          (\\<lambda>h2. return_pmf (2 * max h1 h2))))\n\ngoal (3 subgoals):\n 1. A = {} \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 2. is_singleton A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 3. 1 < card A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)", "have \"map_pmf rank (pmf_of_set A) = pmf_of_set {..<card A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf rank (pmf_of_set A) = pmf_of_set {..<card A}", "using \\<open>A \\<noteq> {}\\<close> \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n  finite A\n\ngoal (1 subgoal):\n 1. map_pmf rank (pmf_of_set A) = pmf_of_set {..<card A}", "unfolding rank_def"], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n  finite A\n\ngoal (1 subgoal):\n 1. map_pmf (linorder_rank {(x, y). x \\<le> y} A) (pmf_of_set A) =\n    pmf_of_set {..<card A}", "by (intro map_pmf_of_set_bij_betw bij_betw_linorder_rank[of UNIV]) auto"], ["proof (state)\nthis:\n  map_pmf rank (pmf_of_set A) = pmf_of_set {..<card A}\n\ngoal (3 subgoals):\n 1. A = {} \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 2. is_singleton A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 3. 1 < card A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)", "also"], ["proof (state)\nthis:\n  map_pmf rank (pmf_of_set A) = pmf_of_set {..<card A}\n\ngoal (3 subgoals):\n 1. A = {} \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 2. is_singleton A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 3. 1 < card A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)", "have \"do {\n                 k \\<leftarrow> pmf_of_set {..<card A};\n                 h1 \\<leftarrow> eheight_rbst k;\n                 h2 \\<leftarrow> eheight_rbst (card A - k - 1);\n                 return_pmf (2 * max h1 h2)\n               } = eheight_rbst (card A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set {..<card A} \\<bind>\n    (\\<lambda>k.\n        eheight_rbst k \\<bind>\n        (\\<lambda>h1.\n            eheight_rbst (card A - k - 1) \\<bind>\n            (\\<lambda>h2. return_pmf (2 * max h1 h2)))) =\n    eheight_rbst (card A)", "by (rule eheight_rbst_reduce [symmetric]) fact+"], ["proof (state)\nthis:\n  pmf_of_set {..<card A} \\<bind>\n  (\\<lambda>k.\n      eheight_rbst k \\<bind>\n      (\\<lambda>h1.\n          eheight_rbst (card A - k - 1) \\<bind>\n          (\\<lambda>h2. return_pmf (2 * max h1 h2)))) =\n  eheight_rbst (card A)\n\ngoal (3 subgoals):\n 1. A = {} \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 2. is_singleton A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 3. 1 < card A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)", "finally"], ["proof (chain)\npicking this:\n  map_pmf eheight (random_bst A) = eheight_rbst (card A)", "show ?thesis"], ["proof (prove)\nusing this:\n  map_pmf eheight (random_bst A) = eheight_rbst (card A)\n\ngoal (1 subgoal):\n 1. eheight_rbst (card A) = map_pmf eheight (random_bst A)", ".."], ["proof (state)\nthis:\n  eheight_rbst (card A) = map_pmf eheight (random_bst A)\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)\n 2. is_singleton A \\<Longrightarrow>\n    eheight_rbst (card A) = map_pmf eheight (random_bst A)", "qed (auto simp: is_singleton_def)"], ["proof (state)\nthis:\n  eheight_rbst (card A) = map_pmf eheight (random_bst A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_pmf_set_eheight_rbst [simp, intro]: \"finite (set_pmf (eheight_rbst n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_pmf (eheight_rbst n))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (set_pmf (eheight_rbst n))", "have \"eheight_rbst n = map_pmf eheight (random_bst {..<n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eheight_rbst n = map_pmf eheight (random_bst {..<n})", "by (subst eheight_rbst [symmetric]) auto"], ["proof (state)\nthis:\n  eheight_rbst n = map_pmf eheight (random_bst {..<n})\n\ngoal (1 subgoal):\n 1. finite (set_pmf (eheight_rbst n))", "also"], ["proof (state)\nthis:\n  eheight_rbst n = map_pmf eheight (random_bst {..<n})\n\ngoal (1 subgoal):\n 1. finite (set_pmf (eheight_rbst n))", "have \"finite (set_pmf \\<dots>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_pmf (map_pmf eheight (random_bst {..<n})))", "by simp"], ["proof (state)\nthis:\n  finite (set_pmf (map_pmf eheight (random_bst {..<n})))\n\ngoal (1 subgoal):\n 1. finite (set_pmf (eheight_rbst n))", "finally"], ["proof (chain)\npicking this:\n  finite (set_pmf (eheight_rbst n))", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (set_pmf (eheight_rbst n))\n\ngoal (1 subgoal):\n 1. finite (set_pmf (eheight_rbst n))", "."], ["proof (state)\nthis:\n  finite (set_pmf (eheight_rbst n))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eheight_exp_0 [simp]: \"eheight_exp 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eheight_exp 0 = 0", "by (simp add: eheight_exp_def)"], ["", "lemma eheight_exp_1 [simp]: \"eheight_exp (Suc 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eheight_exp (Suc 0) = 1", "by (simp add: eheight_exp_def lessThan_Suc)"], ["", "lemma eheight_exp_reduce_bound:\n  assumes \"n > 1\"\n  shows   \"eheight_exp n \\<le> 4 / n * (\\<Sum>k<n. eheight_exp k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "have [simp]: \"real (max a b) = max (real a) (real b)\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (max a b) = max (real a) (real b)", "by (simp add: max_def)"], ["proof (state)\nthis:\n  real (max ?a ?b) = max (real ?a) (real ?b)\n\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "let ?f = \"\\<lambda>(h1,h2). max h1 h2\""], ["proof (state)\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "let ?p = \"\\<lambda>k. pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k))\""], ["proof (state)\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "have \"eheight_exp n = measure_pmf.expectation (eheight_rbst n) real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eheight_exp n = measure_pmf.expectation (eheight_rbst n) real", "by (simp add: eheight_exp_def)"], ["proof (state)\nthis:\n  eheight_exp n = measure_pmf.expectation (eheight_rbst n) real\n\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "also"], ["proof (state)\nthis:\n  eheight_exp n = measure_pmf.expectation (eheight_rbst n) real\n\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "have \"\\<dots> = 1 / real n * (\\<Sum>k<n. measure_pmf.expectation\n                                         (map_pmf (\\<lambda>(h1,h2). 2 * max h1 h2) (?p k)) real)\"\n    (is \"_ = _ * ?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (eheight_rbst n) real =\n    1 / real n *\n    (\\<Sum>k<n.\n        measure_pmf.expectation\n         (map_pmf (\\<lambda>(h1, h2). 2 * max h1 h2)\n           (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k))))\n         real)", "unfolding pair_pmf_def map_bind_pmf"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (eheight_rbst n) real =\n    1 / real n *\n    (\\<Sum>k<n.\n        measure_pmf.expectation\n         (eheight_rbst k \\<bind>\n          (\\<lambda>x.\n              eheight_rbst (n - Suc k) \\<bind>\n              (\\<lambda>xa.\n                  map_pmf (\\<lambda>(h1, h2). 2 * max h1 h2)\n                   (return_pmf (x, xa)))))\n         real)", "by (subst eheight_rbst_reduce [OF assms], subst pmf_expectation_bind_pmf_of_set)\n       (insert assms, auto simp: sum_divide_distrib divide_simps)"], ["proof (state)\nthis:\n  measure_pmf.expectation (eheight_rbst n) real =\n  1 / real n *\n  (\\<Sum>k<n.\n      measure_pmf.expectation\n       (map_pmf (\\<lambda>(h1, h2). 2 * max h1 h2)\n         (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k))))\n       real)\n\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation (eheight_rbst n) real =\n  1 / real n *\n  (\\<Sum>k<n.\n      measure_pmf.expectation\n       (map_pmf (\\<lambda>(h1, h2). 2 * max h1 h2)\n         (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k))))\n       real)\n\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "have \"?S = (\\<Sum>k<n. measure_pmf.expectation (map_pmf (\\<lambda>x. 2 * x) (map_pmf ?f (?p k))) real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n.\n        measure_pmf.expectation\n         (map_pmf (\\<lambda>(h1, h2). 2 * max h1 h2)\n           (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k))))\n         real) =\n    (\\<Sum>k<n.\n        measure_pmf.expectation\n         (map_pmf ((*) 2)\n           (map_pmf (\\<lambda>(h1, h2). max h1 h2)\n             (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k)))))\n         real)", "by (simp only: pmf.map_comp o_def case_prod_unfold)"], ["proof (state)\nthis:\n  (\\<Sum>k<n.\n      measure_pmf.expectation\n       (map_pmf (\\<lambda>(h1, h2). 2 * max h1 h2)\n         (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k))))\n       real) =\n  (\\<Sum>k<n.\n      measure_pmf.expectation\n       (map_pmf ((*) 2)\n         (map_pmf (\\<lambda>(h1, h2). max h1 h2)\n           (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k)))))\n       real)\n\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<n.\n      measure_pmf.expectation\n       (map_pmf (\\<lambda>(h1, h2). 2 * max h1 h2)\n         (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k))))\n       real) =\n  (\\<Sum>k<n.\n      measure_pmf.expectation\n       (map_pmf ((*) 2)\n         (map_pmf (\\<lambda>(h1, h2). max h1 h2)\n           (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k)))))\n       real)\n\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "have \"\\<dots> = 2 * (\\<Sum>k<n. measure_pmf.expectation (map_pmf ?f (?p k)) real)\" (is \"_ = _ * ?S'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n.\n        measure_pmf.expectation\n         (map_pmf ((*) 2)\n           (map_pmf (\\<lambda>(h1, h2). max h1 h2)\n             (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k)))))\n         real) =\n    2 *\n    (\\<Sum>k<n.\n        measure_pmf.expectation\n         (map_pmf (\\<lambda>(h1, h2). max h1 h2)\n           (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k))))\n         real)", "by (subst integral_map_pmf) (simp add: sum_distrib_left)"], ["proof (state)\nthis:\n  (\\<Sum>k<n.\n      measure_pmf.expectation\n       (map_pmf ((*) 2)\n         (map_pmf (\\<lambda>(h1, h2). max h1 h2)\n           (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k)))))\n       real) =\n  2 *\n  (\\<Sum>k<n.\n      measure_pmf.expectation\n       (map_pmf (\\<lambda>(h1, h2). max h1 h2)\n         (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k))))\n       real)\n\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<n.\n      measure_pmf.expectation\n       (map_pmf ((*) 2)\n         (map_pmf (\\<lambda>(h1, h2). max h1 h2)\n           (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k)))))\n       real) =\n  2 *\n  (\\<Sum>k<n.\n      measure_pmf.expectation\n       (map_pmf (\\<lambda>(h1, h2). max h1 h2)\n         (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k))))\n       real)\n\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "have \"?S' = (\\<Sum>k<n. measure_pmf.expectation (?p k) (\\<lambda>(h1,h2). max (real h1) (real h2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n.\n        measure_pmf.expectation\n         (map_pmf (\\<lambda>(h1, h2). max h1 h2)\n           (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k))))\n         real) =\n    (\\<Sum>k<n.\n        measure_pmf.expectation\n         (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k)))\n         (\\<lambda>(h1, h2). max (real h1) (real h2)))", "by (simp add: case_prod_unfold)"], ["proof (state)\nthis:\n  (\\<Sum>k<n.\n      measure_pmf.expectation\n       (map_pmf (\\<lambda>(h1, h2). max h1 h2)\n         (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k))))\n       real) =\n  (\\<Sum>k<n.\n      measure_pmf.expectation\n       (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k)))\n       (\\<lambda>(h1, h2). max (real h1) (real h2)))\n\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<n.\n      measure_pmf.expectation\n       (map_pmf (\\<lambda>(h1, h2). max h1 h2)\n         (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k))))\n       real) =\n  (\\<Sum>k<n.\n      measure_pmf.expectation\n       (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k)))\n       (\\<lambda>(h1, h2). max (real h1) (real h2)))\n\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "have \"\\<dots> \\<le> (\\<Sum>k<n. measure_pmf.expectation (?p k) (\\<lambda>(h1,h2). real h1 + real h2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n.\n        measure_pmf.expectation\n         (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k)))\n         (\\<lambda>(h1, h2). max (real h1) (real h2)))\n    \\<le> (\\<Sum>k<n.\n              measure_pmf.expectation\n               (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k)))\n               (\\<lambda>(h1, h2). real h1 + real h2))", "unfolding integral_map_pmf case_prod_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n.\n        measure_pmf.expectation\n         (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k)))\n         (\\<lambda>p. max (real (fst p)) (real (snd p))))\n    \\<le> (\\<Sum>k<n.\n              measure_pmf.expectation\n               (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k)))\n               (\\<lambda>p. real (fst p) + real (snd p)))", "by (intro sum_mono Bochner_Integration.integral_mono integrable_measure_pmf_finite) auto"], ["proof (state)\nthis:\n  (\\<Sum>k<n.\n      measure_pmf.expectation\n       (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k)))\n       (\\<lambda>(h1, h2). max (real h1) (real h2)))\n  \\<le> (\\<Sum>k<n.\n            measure_pmf.expectation\n             (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k)))\n             (\\<lambda>(h1, h2). real h1 + real h2))\n\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<n.\n      measure_pmf.expectation\n       (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k)))\n       (\\<lambda>(h1, h2). max (real h1) (real h2)))\n  \\<le> (\\<Sum>k<n.\n            measure_pmf.expectation\n             (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k)))\n             (\\<lambda>(h1, h2). real h1 + real h2))\n\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "have \"\\<dots> = (\\<Sum>k<n. eheight_exp k) + (\\<Sum>k<n. eheight_exp (n - Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n.\n        measure_pmf.expectation\n         (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k)))\n         (\\<lambda>(h1, h2). real h1 + real h2)) =\n    sum eheight_exp {..<n} + (\\<Sum>k<n. eheight_exp (n - Suc k))", "by (subst expectation_add_pair_pmf) (auto simp: sum.distrib eheight_exp_def)"], ["proof (state)\nthis:\n  (\\<Sum>k<n.\n      measure_pmf.expectation\n       (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k)))\n       (\\<lambda>(h1, h2). real h1 + real h2)) =\n  sum eheight_exp {..<n} + (\\<Sum>k<n. eheight_exp (n - Suc k))\n\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<n.\n      measure_pmf.expectation\n       (pair_pmf (eheight_rbst k) (eheight_rbst (n - Suc k)))\n       (\\<lambda>(h1, h2). real h1 + real h2)) =\n  sum eheight_exp {..<n} + (\\<Sum>k<n. eheight_exp (n - Suc k))\n\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "have \"(\\<Sum>k<n. eheight_exp (n - Suc k)) = (\\<Sum>k<n. eheight_exp k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n. eheight_exp (n - Suc k)) = sum eheight_exp {..<n}", "by (intro sum.reindex_bij_witness[of _ \"\\<lambda>k. n - Suc k\" \"\\<lambda>k. n - Suc k\"]) auto"], ["proof (state)\nthis:\n  (\\<Sum>k<n. eheight_exp (n - Suc k)) = sum eheight_exp {..<n}\n\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<n. eheight_exp (n - Suc k)) = sum eheight_exp {..<n}\n\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "have \"1 / real n * (2 * (\\<dots> + \\<dots>)) = 4 / real n * \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / real n * (2 * (sum eheight_exp {..<n} + sum eheight_exp {..<n})) =\n    4 / real n * sum eheight_exp {..<n}", "by simp"], ["proof (state)\nthis:\n  1 / real n * (2 * (sum eheight_exp {..<n} + sum eheight_exp {..<n})) =\n  4 / real n * sum eheight_exp {..<n}\n\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      1 / real n * (2 * x) \\<le> 1 / real n * (2 * y)) \\<Longrightarrow>\n  eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      1 / real n * (2 * x) \\<le> 1 / real n * (2 * y)) \\<Longrightarrow>\n  eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}\n\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "using assms"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      1 / real n * (2 * x) \\<le> 1 / real n * (2 * y)) \\<Longrightarrow>\n  eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}\n  1 < n\n\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "by (simp_all add: mult_left_mono divide_right_mono)"], ["proof (state)\nthis:\n  eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We now define the following upper bound on the expected exponential height due to\n  Cormen\\ \\textit{et\\ al.}~\\cite{cormen}:\n\\<close>"], ["", "lemma eheight_exp_bound: \"eheight_exp n \\<le> real ((n + 3) choose 3) / 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> real (n + 3 choose 3) / 4", "proof (induction n rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y < x \\<Longrightarrow>\n           eheight_exp y \\<le> real (y + 3 choose 3) / 4) \\<Longrightarrow>\n       eheight_exp x \\<le> real (x + 3 choose 3) / 4", "case (less n)"], ["proof (state)\nthis:\n  ?y < n \\<Longrightarrow> eheight_exp ?y \\<le> real (?y + 3 choose 3) / 4\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y < x \\<Longrightarrow>\n           eheight_exp y \\<le> real (y + 3 choose 3) / 4) \\<Longrightarrow>\n       eheight_exp x \\<le> real (x + 3 choose 3) / 4", "consider \"n = 0\" | \"n = 1\" | \"n > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = 0 \\<Longrightarrow> thesis; n = 1 \\<Longrightarrow> thesis;\n     1 < n \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>n = 0 \\<Longrightarrow> ?thesis; n = 1 \\<Longrightarrow> ?thesis;\n   1 < n \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y < x \\<Longrightarrow>\n           eheight_exp y \\<le> real (y + 3 choose 3) / 4) \\<Longrightarrow>\n       eheight_exp x \\<le> real (x + 3 choose 3) / 4", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>n = 0 \\<Longrightarrow> ?thesis; n = 1 \\<Longrightarrow> ?thesis;\n   1 < n \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> real (n + 3 choose 3) / 4", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. n = 0 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 2. n = 1 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 3. 1 < n \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4", "case 3"], ["proof (state)\nthis:\n  1 < n\n\ngoal (3 subgoals):\n 1. n = 0 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 2. n = 1 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 3. 1 < n \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4", "hence \"eheight_exp n \\<le> 4 / n * (\\<Sum>k<n. eheight_exp k)\""], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}", "by (rule eheight_exp_reduce_bound)"], ["proof (state)\nthis:\n  eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}\n\ngoal (3 subgoals):\n 1. n = 0 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 2. n = 1 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 3. 1 < n \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4", "also"], ["proof (state)\nthis:\n  eheight_exp n \\<le> 4 / real n * sum eheight_exp {..<n}\n\ngoal (3 subgoals):\n 1. n = 0 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 2. n = 1 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 3. 1 < n \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4", "have \"(\\<Sum>k<n. eheight_exp k) \\<le> (\\<Sum>k<n. real ((k + 3) choose 3) / 4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum eheight_exp {..<n} \\<le> (\\<Sum>k<n. real (k + 3 choose 3) / 4)", "by (intro sum_mono less.IH) auto"], ["proof (state)\nthis:\n  sum eheight_exp {..<n} \\<le> (\\<Sum>k<n. real (k + 3 choose 3) / 4)\n\ngoal (3 subgoals):\n 1. n = 0 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 2. n = 1 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 3. 1 < n \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4", "also"], ["proof (state)\nthis:\n  sum eheight_exp {..<n} \\<le> (\\<Sum>k<n. real (k + 3 choose 3) / 4)\n\ngoal (3 subgoals):\n 1. n = 0 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 2. n = 1 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 3. 1 < n \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4", "have \"\\<dots> = real (\\<Sum>k<n. ((k + 3) choose 3)) / 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n. real (k + 3 choose 3) / 4) =\n    real (\\<Sum>k<n. k + 3 choose 3) / 4", "by (simp add: sum_divide_distrib)"], ["proof (state)\nthis:\n  (\\<Sum>k<n. real (k + 3 choose 3) / 4) =\n  real (\\<Sum>k<n. k + 3 choose 3) / 4\n\ngoal (3 subgoals):\n 1. n = 0 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 2. n = 1 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 3. 1 < n \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<n. real (k + 3 choose 3) / 4) =\n  real (\\<Sum>k<n. k + 3 choose 3) / 4\n\ngoal (3 subgoals):\n 1. n = 0 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 2. n = 1 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 3. 1 < n \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4", "have \"(\\<Sum>k<n. ((k + 3) choose 3)) = (\\<Sum>k\\<le>n - 1. ((k + 3) choose 3))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n. k + 3 choose 3) = (\\<Sum>k\\<le>n - 1. k + 3 choose 3)", "using \\<open>n > 1\\<close>"], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>k<n. k + 3 choose 3) = (\\<Sum>k\\<le>n - 1. k + 3 choose 3)", "by (intro sum.cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>k<n. k + 3 choose 3) = (\\<Sum>k\\<le>n - 1. k + 3 choose 3)\n\ngoal (3 subgoals):\n 1. n = 0 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 2. n = 1 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 3. 1 < n \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<n. k + 3 choose 3) = (\\<Sum>k\\<le>n - 1. k + 3 choose 3)\n\ngoal (3 subgoals):\n 1. n = 0 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 2. n = 1 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 3. 1 < n \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4", "have \"\\<dots> = ((n + 3) choose 4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>n - 1. k + 3 choose 3) = n + 3 choose 4", "using choose_rising_sum(1)[of 3 \"n - 1\"] and \\<open>n > 1\\<close>"], ["proof (prove)\nusing this:\n  (\\<Sum>j\\<le>n - 1. 3 + j choose 3) = 3 + (n - 1) + 1 choose (3 + 1)\n  1 < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>n - 1. k + 3 choose 3) = n + 3 choose 4", "by (simp add: add_ac Suc3_eq_add_3)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>n - 1. k + 3 choose 3) = n + 3 choose 4\n\ngoal (3 subgoals):\n 1. n = 0 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 2. n = 1 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 3. 1 < n \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>n - 1. k + 3 choose 3) = n + 3 choose 4\n\ngoal (3 subgoals):\n 1. n = 0 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 2. n = 1 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 3. 1 < n \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4", "have \"4 / real n * (\\<dots> / 4) = real ((n + 3) choose 3) / 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 / real n * (real (n + 3 choose 4) / 4) = real (n + 3 choose 3) / 4", "using \\<open>n > 1\\<close>"], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. 4 / real n * (real (n + 3 choose 4) / 4) = real (n + 3 choose 3) / 4", "by (cases n) (simp_all add: binomial_fact fact_numeral divide_simps)"], ["proof (state)\nthis:\n  4 / real n * (real (n + 3 choose 4) / 4) = real (n + 3 choose 3) / 4\n\ngoal (3 subgoals):\n 1. n = 0 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 2. n = 1 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 3. 1 < n \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      4 / real n * x \\<le> 4 / real n * y) \\<Longrightarrow>\n  eheight_exp n \\<le> real (n + 3 choose 3) / 4", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      4 / real n * x \\<le> 4 / real n * y) \\<Longrightarrow>\n  eheight_exp n \\<le> real (n + 3 choose 3) / 4\n\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> real (n + 3 choose 3) / 4", "using \\<open>n > 1\\<close>"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      4 / real n * x \\<le> 4 / real n * y) \\<Longrightarrow>\n  eheight_exp n \\<le> real (n + 3 choose 3) / 4\n  1 < n\n\ngoal (1 subgoal):\n 1. eheight_exp n \\<le> real (n + 3 choose 3) / 4", "by (simp add: mult_left_mono divide_right_mono)"], ["proof (state)\nthis:\n  eheight_exp n \\<le> real (n + 3 choose 3) / 4\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4\n 2. n = 1 \\<Longrightarrow> eheight_exp n \\<le> real (n + 3 choose 3) / 4", "qed (auto simp: eval_nat_numeral)"], ["proof (state)\nthis:\n  eheight_exp n \\<le> real (n + 3 choose 3) / 4\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We then show that this is indeed an upper bound on the expected exponential height by induction\n  over the set of elements. This proof mostly follows that by Cormen\\ \\textit{et al.}~\\cite{cormen},\n  and partially an answer on the Computer Science Stack Exchange~\\cite{sofl}.\n\\<close>"], ["", "text \\<open>\n  Since the function $\\uplambda x.\\ 2 ^ x$ is convex, we can then easily derive a bound on the\n  actual height using Jensen's inequality:\n\\<close>"], ["", "definition height_exp_approx :: \"nat \\<Rightarrow> real\" where\n  \"height_exp_approx n = log 2 (real ((n + 3) choose 3) / 4) + 1\""], ["", "theorem height_expectation_bound:\n  assumes \"finite A\" \"A \\<noteq> {}\"\n  shows   \"measure_pmf.expectation (random_bst A) height\n             \\<le> height_exp_approx (card A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n    \\<le> height_exp_approx (card A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n    \\<le> height_exp_approx (card A)", "have \"convex_on UNIV ((powr) 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex_on UNIV ((powr) 2)", "by (intro convex_on_realI[where f' = \"\\<lambda>x. ln 2 * 2 powr x\"])\n       (auto intro!: derivative_eq_intros DERIV_powr simp: powr_def [abs_def])"], ["proof (state)\nthis:\n  convex_on UNIV ((powr) 2)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n    \\<le> height_exp_approx (card A)", "hence \"2 powr measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t - 1)) \\<le>\n          measure_pmf.expectation (random_bst A) (\\<lambda>t. 2 powr real (height t - 1))\""], ["proof (prove)\nusing this:\n  convex_on UNIV ((powr) 2)\n\ngoal (1 subgoal):\n 1. 2 powr\n    measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t - 1))\n    \\<le> measure_pmf.expectation (random_bst A)\n           (\\<lambda>t. 2 powr real (height t - 1))", "using assms"], ["proof (prove)\nusing this:\n  convex_on UNIV ((powr) 2)\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. 2 powr\n    measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t - 1))\n    \\<le> measure_pmf.expectation (random_bst A)\n           (\\<lambda>t. 2 powr real (height t - 1))", "by (intro measure_pmf.jensens_inequality[where I = UNIV])\n       (auto intro!: integrable_measure_pmf_finite)"], ["proof (state)\nthis:\n  2 powr\n  measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t - 1))\n  \\<le> measure_pmf.expectation (random_bst A)\n         (\\<lambda>t. 2 powr real (height t - 1))\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n    \\<le> height_exp_approx (card A)", "also"], ["proof (state)\nthis:\n  2 powr\n  measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t - 1))\n  \\<le> measure_pmf.expectation (random_bst A)\n         (\\<lambda>t. 2 powr real (height t - 1))\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n    \\<le> height_exp_approx (card A)", "have \"(\\<lambda>t. 2 powr real (height t - 1)) = (\\<lambda>t. 2 ^ (height t - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t. 2 powr real (height t - 1)) =\n    (\\<lambda>t. 2 ^ (height t - 1))", "by (simp add: powr_realpow)"], ["proof (state)\nthis:\n  (\\<lambda>t. 2 powr real (height t - 1)) =\n  (\\<lambda>t. 2 ^ (height t - 1))\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n    \\<le> height_exp_approx (card A)", "also"], ["proof (state)\nthis:\n  (\\<lambda>t. 2 powr real (height t - 1)) =\n  (\\<lambda>t. 2 ^ (height t - 1))\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n    \\<le> height_exp_approx (card A)", "have \"measure_pmf.expectation (random_bst A) (\\<lambda>t. 2 ^ (height t - 1)) =\n               measure_pmf.expectation (random_bst A) (\\<lambda>t. real (eheight t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A)\n     (\\<lambda>t. 2 ^ (height t - 1)) =\n    measure_pmf.expectation (random_bst A) (\\<lambda>t. real (eheight t))", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A)\n     (\\<lambda>t. 2 ^ (height t - 1)) =\n    measure_pmf.expectation (random_bst A) (\\<lambda>t. real (eheight t))", "by (intro integral_cong_AE)\n       (auto simp: AE_measure_pmf_iff random_bst_altdef eheight_def)"], ["proof (state)\nthis:\n  measure_pmf.expectation (random_bst A) (\\<lambda>t. 2 ^ (height t - 1)) =\n  measure_pmf.expectation (random_bst A) (\\<lambda>t. real (eheight t))\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n    \\<le> height_exp_approx (card A)", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation (random_bst A) (\\<lambda>t. 2 ^ (height t - 1)) =\n  measure_pmf.expectation (random_bst A) (\\<lambda>t. real (eheight t))\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n    \\<le> height_exp_approx (card A)", "have \"\\<dots> = measure_pmf.expectation (map_pmf eheight (random_bst A)) real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>t. real (eheight t)) =\n    measure_pmf.expectation (map_pmf eheight (random_bst A)) real", "by simp"], ["proof (state)\nthis:\n  measure_pmf.expectation (random_bst A) (\\<lambda>t. real (eheight t)) =\n  measure_pmf.expectation (map_pmf eheight (random_bst A)) real\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n    \\<le> height_exp_approx (card A)", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation (random_bst A) (\\<lambda>t. real (eheight t)) =\n  measure_pmf.expectation (map_pmf eheight (random_bst A)) real\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n    \\<le> height_exp_approx (card A)", "have \"map_pmf eheight (random_bst A) = eheight_rbst (card A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf eheight (random_bst A) = eheight_rbst (card A)", "by (rule eheight_rbst [symmetric]) fact+"], ["proof (state)\nthis:\n  map_pmf eheight (random_bst A) = eheight_rbst (card A)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n    \\<le> height_exp_approx (card A)", "also"], ["proof (state)\nthis:\n  map_pmf eheight (random_bst A) = eheight_rbst (card A)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n    \\<le> height_exp_approx (card A)", "have \"measure_pmf.expectation \\<dots> real = eheight_exp (card A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (eheight_rbst (card A)) real =\n    eheight_exp (card A)", "by (simp add: eheight_exp_def)"], ["proof (state)\nthis:\n  measure_pmf.expectation (eheight_rbst (card A)) real =\n  eheight_exp (card A)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n    \\<le> height_exp_approx (card A)", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation (eheight_rbst (card A)) real =\n  eheight_exp (card A)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n    \\<le> height_exp_approx (card A)", "have \"\\<dots> \\<le> real ((card A + 3) choose 3) / 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eheight_exp (card A) \\<le> real (card A + 3 choose 3) / 4", "by (rule eheight_exp_bound)"], ["proof (state)\nthis:\n  eheight_exp (card A) \\<le> real (card A + 3 choose 3) / 4\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n    \\<le> height_exp_approx (card A)", "also"], ["proof (state)\nthis:\n  eheight_exp (card A) \\<le> real (card A + 3 choose 3) / 4\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n    \\<le> height_exp_approx (card A)", "have \"measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t - 1)) =\n               measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A)\n     (\\<lambda>t. real (height t - 1)) =\n    measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t) - 1)", "proof (intro integral_cong_AE AE_pmfI, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. measure_pmf.random_variable (random_bst A) borel\n     (\\<lambda>t. real (height t - 1))\n 2. measure_pmf.random_variable (random_bst A) borel\n     (\\<lambda>t. real (height t) - 1)\n 3. \\<And>y.\n       y \\<in> set_pmf (random_bst A) \\<Longrightarrow>\n       real (height y - 1) = real (height y) - 1", "case (3 t)"], ["proof (state)\nthis:\n  t \\<in> set_pmf (random_bst A)\n\ngoal (3 subgoals):\n 1. measure_pmf.random_variable (random_bst A) borel\n     (\\<lambda>t. real (height t - 1))\n 2. measure_pmf.random_variable (random_bst A) borel\n     (\\<lambda>t. real (height t) - 1)\n 3. \\<And>y.\n       y \\<in> set_pmf (random_bst A) \\<Longrightarrow>\n       real (height y - 1) = real (height y) - 1", "with \\<open>A \\<noteq> {}\\<close> and assms"], ["proof (chain)\npicking this:\n  A \\<noteq> {}\n  finite A\n  A \\<noteq> {}\n  t \\<in> set_pmf (random_bst A)", "show ?case"], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n  finite A\n  A \\<noteq> {}\n  t \\<in> set_pmf (random_bst A)\n\ngoal (1 subgoal):\n 1. real (height t - 1) = real (height t) - 1", "by (subst of_nat_diff) (auto simp: Suc_le_eq random_bst_altdef)"], ["proof (state)\nthis:\n  real (height t - 1) = real (height t) - 1\n\ngoal (2 subgoals):\n 1. measure_pmf.random_variable (random_bst A) borel\n     (\\<lambda>t. real (height t - 1))\n 2. measure_pmf.random_variable (random_bst A) borel\n     (\\<lambda>t. real (height t) - 1)", "qed auto"], ["proof (state)\nthis:\n  measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t - 1)) =\n  measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t) - 1)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n    \\<le> height_exp_approx (card A)", "finally"], ["proof (chain)\npicking this:\n  2 powr\n  measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t) - 1)\n  \\<le> real (card A + 3 choose 3) / 4", "have \"2 powr measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t) - 1)\n                  \\<le> real ((card A + 3) choose 3) / 4\""], ["proof (prove)\nusing this:\n  2 powr\n  measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t) - 1)\n  \\<le> real (card A + 3 choose 3) / 4\n\ngoal (1 subgoal):\n 1. 2 powr\n    measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t) - 1)\n    \\<le> real (card A + 3 choose 3) / 4", "."], ["proof (state)\nthis:\n  2 powr\n  measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t) - 1)\n  \\<le> real (card A + 3 choose 3) / 4\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n    \\<le> height_exp_approx (card A)", "hence \"log 2 (2 powr measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t) - 1)) \\<le>\n           log 2 (real ((card A + 3) choose 3) / 4)\" (is \"?lhs \\<le> ?rhs\")"], ["proof (prove)\nusing this:\n  2 powr\n  measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t) - 1)\n  \\<le> real (card A + 3 choose 3) / 4\n\ngoal (1 subgoal):\n 1. log 2\n     (2 powr\n      measure_pmf.expectation (random_bst A)\n       (\\<lambda>t. real (height t) - 1))\n    \\<le> log 2 (real (card A + 3 choose 3) / 4)", "by (subst log_le_cancel_iff) (auto simp: )"], ["proof (state)\nthis:\n  log 2\n   (2 powr\n    measure_pmf.expectation (random_bst A)\n     (\\<lambda>t. real (height t) - 1))\n  \\<le> log 2 (real (card A + 3 choose 3) / 4)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n    \\<le> height_exp_approx (card A)", "also"], ["proof (state)\nthis:\n  log 2\n   (2 powr\n    measure_pmf.expectation (random_bst A)\n     (\\<lambda>t. real (height t) - 1))\n  \\<le> log 2 (real (card A + 3 choose 3) / 4)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n    \\<le> height_exp_approx (card A)", "have \"?lhs = measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2\n     (2 powr\n      measure_pmf.expectation (random_bst A)\n       (\\<lambda>t. real (height t) - 1)) =\n    measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t) - 1)", "by simp"], ["proof (state)\nthis:\n  log 2\n   (2 powr\n    measure_pmf.expectation (random_bst A)\n     (\\<lambda>t. real (height t) - 1)) =\n  measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t) - 1)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n    \\<le> height_exp_approx (card A)", "also"], ["proof (state)\nthis:\n  log 2\n   (2 powr\n    measure_pmf.expectation (random_bst A)\n     (\\<lambda>t. real (height t) - 1)) =\n  measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t) - 1)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n    \\<le> height_exp_approx (card A)", "have \"\\<dots> = measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t)) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A)\n     (\\<lambda>t. real (height t) - 1) =\n    measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t)) - 1", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A)\n     (\\<lambda>t. real (height t) - 1) =\n    measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t)) - 1", "by (subst Bochner_Integration.integral_diff) (auto intro!: integrable_measure_pmf_finite)"], ["proof (state)\nthis:\n  measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t) - 1) =\n  measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t)) - 1\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n    \\<le> height_exp_approx (card A)", "finally"], ["proof (chain)\npicking this:\n  measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t)) - 1\n  \\<le> log 2 (real (card A + 3 choose 3) / 4)", "show ?thesis"], ["proof (prove)\nusing this:\n  measure_pmf.expectation (random_bst A) (\\<lambda>t. real (height t)) - 1\n  \\<le> log 2 (real (card A + 3 choose 3) / 4)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n    \\<le> height_exp_approx (card A)", "by (simp add: height_exp_approx_def)"], ["proof (state)\nthis:\n  measure_pmf.expectation (random_bst A) (\\<lambda>x. real (height x))\n  \\<le> height_exp_approx (card A)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  This upper bound is asymptotically equivalent to $c \\ln n$ with\n  $c = \\frac{3}{\\ln 2} \\approx 4.328$. This is actually a relatively tight upper bound, since\n  the exact asymptotics of the expected height of a random BST is $c \\ln n$ with\n  $c \\approx 4.311$.~\\cite{reed} However, the proof of these precise asymptotics is very intricate\n  and we will therefore be content with the upper bound.\n\n  In particular, we can now show that the expected height is $O(\\log n)$.\n\\<close>"], ["", "lemma ln_sum_bigo_ln: \"(\\<lambda>x::real. ln (x + c)) \\<in> O(ln)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. ln (x + c)) \\<in> O(ln)", "proof (rule bigoI_tendsto)"], ["proof (state)\ngoal (2 subgoals):\n 1. ((\\<lambda>x. ln (x + c) / ln x) \\<longlongrightarrow> ?c) at_top\n 2. \\<forall>\\<^sub>F x in at_top. ln x \\<noteq> 0", "from eventually_gt_at_top[of \"1::real\"]"], ["proof (chain)\npicking this:\n  eventually ((<) 1) at_top", "show \"eventually (\\<lambda>x::real. ln x \\<noteq> 0) at_top\""], ["proof (prove)\nusing this:\n  eventually ((<) 1) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. ln x \\<noteq> 0", "by eventually_elim simp_all"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. ln x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. ln (x + c) / ln x) \\<longlongrightarrow> ?c) at_top", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. ln (x + c) / ln x) \\<longlongrightarrow> ?c) at_top", "show \"((\\<lambda>x. ln (x + c) / ln x) \\<longlongrightarrow> 1) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. ln (x + c) / ln x) \\<longlongrightarrow> 1) at_top", "proof (rule lhospital_at_top_at_top)"], ["proof (state)\ngoal (5 subgoals):\n 1. filterlim ln at_top at_top\n 2. \\<forall>\\<^sub>F x in at_top. ?g' x \\<noteq> 0\n 3. \\<forall>\\<^sub>F x in at_top.\n       ((\\<lambda>x. ln (x + c)) has_real_derivative ?f' x) (at x)\n 4. \\<forall>\\<^sub>F x in at_top. (ln has_real_derivative ?g' x) (at x)\n 5. ((\\<lambda>x. ?f' x / ?g' x) \\<longlongrightarrow> 1) at_top", "show \"eventually (\\<lambda>x. ((\\<lambda>x. ln (x + c)) has_real_derivative inverse (x + c)) (at x)) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       ((\\<lambda>x. ln (x + c)) has_real_derivative inverse (x + c)) (at x)", "using eventually_gt_at_top[of \"-c\"]"], ["proof (prove)\nusing this:\n  eventually ((<) (- c)) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       ((\\<lambda>x. ln (x + c)) has_real_derivative inverse (x + c)) (at x)", "by eventually_elim (auto intro!: derivative_eq_intros simp: field_simps)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top.\n     ((\\<lambda>x. ln (x + c)) has_real_derivative inverse (x + c)) (at x)\n\ngoal (4 subgoals):\n 1. filterlim ln at_top at_top\n 2. \\<forall>\\<^sub>F x in at_top. ?g' x \\<noteq> 0\n 3. \\<forall>\\<^sub>F x in at_top. (ln has_real_derivative ?g' x) (at x)\n 4. ((\\<lambda>x. inverse (x + c) / ?g' x) \\<longlongrightarrow> 1) at_top", "show \"eventually (\\<lambda>x. ((\\<lambda>x. ln x) has_real_derivative inverse x) (at x)) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. (ln has_real_derivative inverse x) (at x)", "using eventually_gt_at_top[of 0]"], ["proof (prove)\nusing this:\n  eventually ((<) (0::?'a1)) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. (ln has_real_derivative inverse x) (at x)", "by eventually_elim (auto intro!: derivative_eq_intros simp: field_simps)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. (ln has_real_derivative inverse x) (at x)\n\ngoal (3 subgoals):\n 1. filterlim ln at_top at_top\n 2. \\<forall>\\<^sub>F x in at_top. inverse x \\<noteq> 0\n 3. ((\\<lambda>x. inverse (x + c) / inverse x) \\<longlongrightarrow> 1)\n     at_top", "show \"((\\<lambda>x. inverse (x + c) / inverse x) \\<longlongrightarrow> 1) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. inverse (x + c) / inverse x) \\<longlongrightarrow> 1)\n     at_top", "proof (rule Lim_transform_eventually)"], ["proof (state)\ngoal (2 subgoals):\n 1. (?f \\<longlongrightarrow> 1) at_top\n 2. \\<forall>\\<^sub>F x in at_top. ?f x = inverse (x + c) / inverse x", "show \"eventually (\\<lambda>x. inverse (1 + c / x) = inverse (x + c) / inverse x) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       inverse (1 + c / x) = inverse (x + c) / inverse x", "using eventually_gt_at_top[of \"0::real\"] eventually_gt_at_top[of \"-c\"]"], ["proof (prove)\nusing this:\n  eventually ((<) 0) at_top\n  eventually ((<) (- c)) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       inverse (1 + c / x) = inverse (x + c) / inverse x", "by eventually_elim (simp add: field_simps)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top.\n     inverse (1 + c / x) = inverse (x + c) / inverse x\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. inverse (1 + c / x)) \\<longlongrightarrow> 1) at_top", "have \"((\\<lambda>x. inverse (1 + c / x)) \\<longlongrightarrow> inverse (1 + 0)) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. inverse (1 + c / x)) \\<longlongrightarrow>\n     inverse (1 + 0))\n     at_top", "by (intro tendsto_inverse tendsto_add tendsto_const\n              real_tendsto_divide_at_top[OF tendsto_const] filterlim_ident) simp_all"], ["proof (state)\nthis:\n  ((\\<lambda>x. inverse (1 + c / x)) \\<longlongrightarrow> inverse (1 + 0))\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. inverse (1 + c / x)) \\<longlongrightarrow> 1) at_top", "thus \"((\\<lambda>x. inverse (1 + c / x)) \\<longlongrightarrow> 1) at_top\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x. inverse (1 + c / x)) \\<longlongrightarrow> inverse (1 + 0))\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. inverse (1 + c / x)) \\<longlongrightarrow> 1) at_top", "by simp"], ["proof (state)\nthis:\n  ((\\<lambda>x. inverse (1 + c / x)) \\<longlongrightarrow> 1) at_top\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>x. inverse (x + c) / inverse x) \\<longlongrightarrow> 1) at_top\n\ngoal (2 subgoals):\n 1. filterlim ln at_top at_top\n 2. \\<forall>\\<^sub>F x in at_top. inverse x \\<noteq> 0", "qed (auto simp: ln_at_top eventually_at_top_not_equal)"], ["proof (state)\nthis:\n  ((\\<lambda>x. ln (x + c) / ln x) \\<longlongrightarrow> 1) at_top\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary height_expectation_bigo: \"height_exp_approx \\<in> O(ln)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height_exp_approx \\<in> O(\\<lambda>x. ln (real x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. height_exp_approx \\<in> O(\\<lambda>x. ln (real x))", "let ?T = \"\\<lambda>x::real. log 2 (x + 1) + log 2 (x + 2) + log 2 (x + 3) + (1 - log 2 24)\""], ["proof (state)\ngoal (1 subgoal):\n 1. height_exp_approx \\<in> O(\\<lambda>x. ln (real x))", "have \"eventually (\\<lambda>n. height_exp_approx n =\n          log 2 (real n + 1) + log 2 (real n + 2) + log 2 (real n + 3) + (1 - log 2 24)) at_top\"\n    (is \"eventually (\\<lambda>n. _ = ?T n) at_top\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       height_exp_approx n =\n       log 2 (real n + 1) + log 2 (real n + 2) + log 2 (real n + 3) +\n       (1 - log 2 24)", "using eventually_gt_at_top[of \"0::nat\"]"], ["proof (prove)\nusing this:\n  eventually ((<) 0) sequentially\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       height_exp_approx n =\n       log 2 (real n + 1) + log 2 (real n + 2) + log 2 (real n + 3) +\n       (1 - log 2 24)", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       0 < n \\<Longrightarrow>\n       height_exp_approx n =\n       log 2 (real n + 1) + log 2 (real n + 2) + log 2 (real n + 3) +\n       (1 - log 2 24)", "case (elim n)"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       0 < n \\<Longrightarrow>\n       height_exp_approx n =\n       log 2 (real n + 1) + log 2 (real n + 2) + log 2 (real n + 3) +\n       (1 - log 2 24)", "have \"height_exp_approx n = log 2 (real (n + 3 choose 3) / 4) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height_exp_approx n = log 2 (real (n + 3 choose 3) / 4) + 1", "by (simp add: height_exp_approx_def log_divide)"], ["proof (state)\nthis:\n  height_exp_approx n = log 2 (real (n + 3 choose 3) / 4) + 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       0 < n \\<Longrightarrow>\n       height_exp_approx n =\n       log 2 (real n + 1) + log 2 (real n + 2) + log 2 (real n + 3) +\n       (1 - log 2 24)", "also"], ["proof (state)\nthis:\n  height_exp_approx n = log 2 (real (n + 3 choose 3) / 4) + 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       0 < n \\<Longrightarrow>\n       height_exp_approx n =\n       log 2 (real n + 1) + log 2 (real n + 2) + log 2 (real n + 3) +\n       (1 - log 2 24)", "have \"real ((n + 3) choose 3) = real (n + 3) gchoose 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (n + 3 choose 3) = real (n + 3) gchoose 3", "by (simp add: binomial_gbinomial)"], ["proof (state)\nthis:\n  real (n + 3 choose 3) = real (n + 3) gchoose 3\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       0 < n \\<Longrightarrow>\n       height_exp_approx n =\n       log 2 (real n + 1) + log 2 (real n + 2) + log 2 (real n + 3) +\n       (1 - log 2 24)", "also"], ["proof (state)\nthis:\n  real (n + 3 choose 3) = real (n + 3) gchoose 3\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       0 < n \\<Longrightarrow>\n       height_exp_approx n =\n       log 2 (real n + 1) + log 2 (real n + 2) + log 2 (real n + 3) +\n       (1 - log 2 24)", "have \"\\<dots> / 4 = (real n + 1) * (real n + 2) * (real n + 3) / 24\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (real (n + 3) gchoose 3) / 4 =\n    (real n + 1) * (real n + 2) * (real n + 3) / 24", "by (simp add: gbinomial_pochhammer' numeral_3_eq_3 pochhammer_Suc add_ac)"], ["proof (state)\nthis:\n  (real (n + 3) gchoose 3) / 4 =\n  (real n + 1) * (real n + 2) * (real n + 3) / 24\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       0 < n \\<Longrightarrow>\n       height_exp_approx n =\n       log 2 (real n + 1) + log 2 (real n + 2) + log 2 (real n + 3) +\n       (1 - log 2 24)", "also"], ["proof (state)\nthis:\n  (real (n + 3) gchoose 3) / 4 =\n  (real n + 1) * (real n + 2) * (real n + 3) / 24\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       0 < n \\<Longrightarrow>\n       height_exp_approx n =\n       log 2 (real n + 1) + log 2 (real n + 2) + log 2 (real n + 3) +\n       (1 - log 2 24)", "have \"log 2 \\<dots> = log 2 (real n + 1) + log 2 (real n + 2) + log 2 (real n + 3) - log 2 24\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 ((real n + 1) * (real n + 2) * (real n + 3) / 24) =\n    log 2 (real n + 1) + log 2 (real n + 2) + log 2 (real n + 3) - log 2 24", "by (simp add: log_divide log_mult)"], ["proof (state)\nthis:\n  log 2 ((real n + 1) * (real n + 2) * (real n + 3) / 24) =\n  log 2 (real n + 1) + log 2 (real n + 2) + log 2 (real n + 3) - log 2 24\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       0 < n \\<Longrightarrow>\n       height_exp_approx n =\n       log 2 (real n + 1) + log 2 (real n + 2) + log 2 (real n + 3) +\n       (1 - log 2 24)", "finally"], ["proof (chain)\npicking this:\n  height_exp_approx n =\n  log 2 (real n + 1) + log 2 (real n + 2) + log 2 (real n + 3) - log 2 24 +\n  1", "show ?case"], ["proof (prove)\nusing this:\n  height_exp_approx n =\n  log 2 (real n + 1) + log 2 (real n + 2) + log 2 (real n + 3) - log 2 24 +\n  1\n\ngoal (1 subgoal):\n 1. height_exp_approx n =\n    log 2 (real n + 1) + log 2 (real n + 2) + log 2 (real n + 3) +\n    (1 - log 2 24)", "by simp"], ["proof (state)\nthis:\n  height_exp_approx n =\n  log 2 (real n + 1) + log 2 (real n + 2) + log 2 (real n + 3) +\n  (1 - log 2 24)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     height_exp_approx n =\n     log 2 (real n + 1) + log 2 (real n + 2) + log 2 (real n + 3) +\n     (1 - log 2 24)\n\ngoal (1 subgoal):\n 1. height_exp_approx \\<in> O(\\<lambda>x. ln (real x))", "hence \"height_exp_approx \\<in> \\<Theta>(?T)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially.\n     height_exp_approx n =\n     log 2 (real n + 1) + log 2 (real n + 2) + log 2 (real n + 3) +\n     (1 - log 2 24)\n\ngoal (1 subgoal):\n 1. height_exp_approx\n    \\<in> \\<Theta>(\\<lambda>n.\n                      log 2 (real n + 1) + log 2 (real n + 2) +\n                      log 2 (real n + 3) +\n                      (1 - log 2 24))", "by (rule bigthetaI_cong)"], ["proof (state)\nthis:\n  height_exp_approx\n  \\<in> \\<Theta>(\\<lambda>n.\n                    log 2 (real n + 1) + log 2 (real n + 2) +\n                    log 2 (real n + 3) +\n                    (1 - log 2 24))\n\ngoal (1 subgoal):\n 1. height_exp_approx \\<in> O(\\<lambda>x. ln (real x))", "also"], ["proof (state)\nthis:\n  height_exp_approx\n  \\<in> \\<Theta>(\\<lambda>n.\n                    log 2 (real n + 1) + log 2 (real n + 2) +\n                    log 2 (real n + 3) +\n                    (1 - log 2 24))\n\ngoal (1 subgoal):\n 1. height_exp_approx \\<in> O(\\<lambda>x. ln (real x))", "have *: \"(\\<lambda>x. ln (x + c) / ln 2) \\<in> O(ln)\" for c :: real"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. ln (x + c) / ln 2) \\<in> O(ln)", "by (subst landau_o.big.cdiv_in_iff') (auto intro!: ln_sum_bigo_ln)"], ["proof (state)\nthis:\n  (\\<lambda>x. ln (x + ?c) / ln 2) \\<in> O(ln)\n\ngoal (1 subgoal):\n 1. height_exp_approx \\<in> O(\\<lambda>x. ln (real x))", "have \"?T \\<in> O(\\<lambda>n. ln (real n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        log 2 (real n + 1) + log 2 (real n + 2) + log 2 (real n + 3) +\n        (1 - log 2 24))\n    \\<in> O(\\<lambda>n. ln (real n))", "unfolding log_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        ln (real n + 1) / ln 2 + ln (real n + 2) / ln 2 +\n        ln (real n + 3) / ln 2 +\n        (1 - ln 24 / ln 2))\n    \\<in> O(\\<lambda>n. ln (real n))", "by (intro bigo_real_nat_transfer sum_in_bigo ln_sum_bigo_ln *) simp_all"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      log 2 (real n + 1) + log 2 (real n + 2) + log 2 (real n + 3) +\n      (1 - log 2 24))\n  \\<in> O(\\<lambda>n. ln (real n))\n\ngoal (1 subgoal):\n 1. height_exp_approx \\<in> O(\\<lambda>x. ln (real x))", "finally"], ["proof (chain)\npicking this:\n  height_exp_approx \\<in> O(\\<lambda>n. ln (real n))", "show ?thesis"], ["proof (prove)\nusing this:\n  height_exp_approx \\<in> O(\\<lambda>n. ln (real n))\n\ngoal (1 subgoal):\n 1. height_exp_approx \\<in> O(\\<lambda>x. ln (real x))", "."], ["proof (state)\nthis:\n  height_exp_approx \\<in> O(\\<lambda>x. ln (real x))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Lookup costs\\<close>"], ["", "text \\<open>\n  The following function describes the cost incurred when looking up a specific element\n  in a specific BST. The cost corresponds to the number of edges traversed in the lookup.\n\\<close>"], ["", "primrec lookup_cost :: \"'a :: linorder \\<Rightarrow> 'a tree \\<Rightarrow> nat\" where\n  \"lookup_cost x Leaf = 0\"\n| \"lookup_cost x (Node l y r) =\n     (if x = y then 0\n      else if x < y then Suc (lookup_cost x l)\n      else Suc (lookup_cost x r))\""], ["", "text \\<open>\n  Some of the literature defines these costs as 1 in the case that the current node is\n  the correct one, i.\\,e.\\ their costs are our costs plus 1. These alternative costs are\n  exactly the number of comparisons performed in the lookup. Our cost function has the\n  advantage of precisely summing up to the internal path length and therefore gives us\n  slightly nicer results, and since the difference is only a ${}+1$ in the end, this\n  variant seemed more reasonable.\n\\<close>"], ["", "text \\<open>\n  It can be shown with a simple induction that The sum of all lookup costs in a tree is the\n  internal path length of the tree.\n\\<close>"], ["", "theorem sum_lookup_costs:\n  fixes t :: \"'a :: linorder tree\"\n  assumes \"bst t\"\n  shows   \"(\\<Sum>x\\<in>set_tree t. lookup_cost x t) = ipl t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set_tree t. lookup_cost x t) = ipl t", "using assms"], ["proof (prove)\nusing this:\n  bst t\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set_tree t. lookup_cost x t) = ipl t", "proof (induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. bst \\<langle>\\<rangle> \\<Longrightarrow>\n    (\\<Sum>x\\<in>set_tree \\<langle>\\<rangle>.\n       lookup_cost x \\<langle>\\<rangle>) =\n    ipl \\<langle>\\<rangle>\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>bst t1 \\<Longrightarrow>\n                (\\<Sum>x\\<in>set_tree t1. lookup_cost x t1) = ipl t1;\n        bst t2 \\<Longrightarrow>\n        (\\<Sum>x\\<in>set_tree t2. lookup_cost x t2) = ipl t2;\n        bst \\<langle>t1, x2, t2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set_tree \\<langle>t1, x2, t2\\<rangle>.\n                            lookup_cost x \\<langle>t1, x2, t2\\<rangle>) =\n                         ipl \\<langle>t1, x2, t2\\<rangle>", "case (Node l x r)"], ["proof (state)\nthis:\n  bst l \\<Longrightarrow> (\\<Sum>x\\<in>set_tree l. lookup_cost x l) = ipl l\n  bst r \\<Longrightarrow> (\\<Sum>x\\<in>set_tree r. lookup_cost x r) = ipl r\n  bst \\<langle>l, x, r\\<rangle>\n\ngoal (2 subgoals):\n 1. bst \\<langle>\\<rangle> \\<Longrightarrow>\n    (\\<Sum>x\\<in>set_tree \\<langle>\\<rangle>.\n       lookup_cost x \\<langle>\\<rangle>) =\n    ipl \\<langle>\\<rangle>\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>bst t1 \\<Longrightarrow>\n                (\\<Sum>x\\<in>set_tree t1. lookup_cost x t1) = ipl t1;\n        bst t2 \\<Longrightarrow>\n        (\\<Sum>x\\<in>set_tree t2. lookup_cost x t2) = ipl t2;\n        bst \\<langle>t1, x2, t2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set_tree \\<langle>t1, x2, t2\\<rangle>.\n                            lookup_cost x \\<langle>t1, x2, t2\\<rangle>) =\n                         ipl \\<langle>t1, x2, t2\\<rangle>", "from Node.prems"], ["proof (chain)\npicking this:\n  bst \\<langle>l, x, r\\<rangle>", "have disj: \"x \\<notin> set_tree l\" \"x \\<notin> set_tree r\" \"set_tree l \\<inter> set_tree r = {}\""], ["proof (prove)\nusing this:\n  bst \\<langle>l, x, r\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<notin> set_tree l &&&\n    x \\<notin> set_tree r &&& set_tree l \\<inter> set_tree r = {}", "by force+"], ["proof (state)\nthis:\n  x \\<notin> set_tree l\n  x \\<notin> set_tree r\n  set_tree l \\<inter> set_tree r = {}\n\ngoal (2 subgoals):\n 1. bst \\<langle>\\<rangle> \\<Longrightarrow>\n    (\\<Sum>x\\<in>set_tree \\<langle>\\<rangle>.\n       lookup_cost x \\<langle>\\<rangle>) =\n    ipl \\<langle>\\<rangle>\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>bst t1 \\<Longrightarrow>\n                (\\<Sum>x\\<in>set_tree t1. lookup_cost x t1) = ipl t1;\n        bst t2 \\<Longrightarrow>\n        (\\<Sum>x\\<in>set_tree t2. lookup_cost x t2) = ipl t2;\n        bst \\<langle>t1, x2, t2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set_tree \\<langle>t1, x2, t2\\<rangle>.\n                            lookup_cost x \\<langle>t1, x2, t2\\<rangle>) =\n                         ipl \\<langle>t1, x2, t2\\<rangle>", "have \"set_tree (Node l x r) = insert x (set_tree l \\<union> set_tree r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_tree \\<langle>l, x, r\\<rangle> =\n    insert x (set_tree l \\<union> set_tree r)", "by simp"], ["proof (state)\nthis:\n  set_tree \\<langle>l, x, r\\<rangle> =\n  insert x (set_tree l \\<union> set_tree r)\n\ngoal (2 subgoals):\n 1. bst \\<langle>\\<rangle> \\<Longrightarrow>\n    (\\<Sum>x\\<in>set_tree \\<langle>\\<rangle>.\n       lookup_cost x \\<langle>\\<rangle>) =\n    ipl \\<langle>\\<rangle>\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>bst t1 \\<Longrightarrow>\n                (\\<Sum>x\\<in>set_tree t1. lookup_cost x t1) = ipl t1;\n        bst t2 \\<Longrightarrow>\n        (\\<Sum>x\\<in>set_tree t2. lookup_cost x t2) = ipl t2;\n        bst \\<langle>t1, x2, t2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set_tree \\<langle>t1, x2, t2\\<rangle>.\n                            lookup_cost x \\<langle>t1, x2, t2\\<rangle>) =\n                         ipl \\<langle>t1, x2, t2\\<rangle>", "also"], ["proof (state)\nthis:\n  set_tree \\<langle>l, x, r\\<rangle> =\n  insert x (set_tree l \\<union> set_tree r)\n\ngoal (2 subgoals):\n 1. bst \\<langle>\\<rangle> \\<Longrightarrow>\n    (\\<Sum>x\\<in>set_tree \\<langle>\\<rangle>.\n       lookup_cost x \\<langle>\\<rangle>) =\n    ipl \\<langle>\\<rangle>\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>bst t1 \\<Longrightarrow>\n                (\\<Sum>x\\<in>set_tree t1. lookup_cost x t1) = ipl t1;\n        bst t2 \\<Longrightarrow>\n        (\\<Sum>x\\<in>set_tree t2. lookup_cost x t2) = ipl t2;\n        bst \\<langle>t1, x2, t2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set_tree \\<langle>t1, x2, t2\\<rangle>.\n                            lookup_cost x \\<langle>t1, x2, t2\\<rangle>) =\n                         ipl \\<langle>t1, x2, t2\\<rangle>", "have \"(\\<Sum>y\\<in>\\<dots>. lookup_cost y (Node l x r)) = lookup_cost x \\<langle>l, x, r\\<rangle> +\n               (\\<Sum>y\\<in>set_tree l. lookup_cost y \\<langle>l, x, r\\<rangle>) + (\\<Sum>y\\<in>set_tree r. lookup_cost y \\<langle>l, x, r\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>insert x (set_tree l \\<union> set_tree r).\n       lookup_cost y \\<langle>l, x, r\\<rangle>) =\n    lookup_cost x \\<langle>l, x, r\\<rangle> +\n    (\\<Sum>y\\<in>set_tree l. lookup_cost y \\<langle>l, x, r\\<rangle>) +\n    (\\<Sum>y\\<in>set_tree r. lookup_cost y \\<langle>l, x, r\\<rangle>)", "using disj"], ["proof (prove)\nusing this:\n  x \\<notin> set_tree l\n  x \\<notin> set_tree r\n  set_tree l \\<inter> set_tree r = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>insert x (set_tree l \\<union> set_tree r).\n       lookup_cost y \\<langle>l, x, r\\<rangle>) =\n    lookup_cost x \\<langle>l, x, r\\<rangle> +\n    (\\<Sum>y\\<in>set_tree l. lookup_cost y \\<langle>l, x, r\\<rangle>) +\n    (\\<Sum>y\\<in>set_tree r. lookup_cost y \\<langle>l, x, r\\<rangle>)", "by (simp add: sum.union_disjoint)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>insert x (set_tree l \\<union> set_tree r).\n     lookup_cost y \\<langle>l, x, r\\<rangle>) =\n  lookup_cost x \\<langle>l, x, r\\<rangle> +\n  (\\<Sum>y\\<in>set_tree l. lookup_cost y \\<langle>l, x, r\\<rangle>) +\n  (\\<Sum>y\\<in>set_tree r. lookup_cost y \\<langle>l, x, r\\<rangle>)\n\ngoal (2 subgoals):\n 1. bst \\<langle>\\<rangle> \\<Longrightarrow>\n    (\\<Sum>x\\<in>set_tree \\<langle>\\<rangle>.\n       lookup_cost x \\<langle>\\<rangle>) =\n    ipl \\<langle>\\<rangle>\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>bst t1 \\<Longrightarrow>\n                (\\<Sum>x\\<in>set_tree t1. lookup_cost x t1) = ipl t1;\n        bst t2 \\<Longrightarrow>\n        (\\<Sum>x\\<in>set_tree t2. lookup_cost x t2) = ipl t2;\n        bst \\<langle>t1, x2, t2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set_tree \\<langle>t1, x2, t2\\<rangle>.\n                            lookup_cost x \\<langle>t1, x2, t2\\<rangle>) =\n                         ipl \\<langle>t1, x2, t2\\<rangle>", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>insert x (set_tree l \\<union> set_tree r).\n     lookup_cost y \\<langle>l, x, r\\<rangle>) =\n  lookup_cost x \\<langle>l, x, r\\<rangle> +\n  (\\<Sum>y\\<in>set_tree l. lookup_cost y \\<langle>l, x, r\\<rangle>) +\n  (\\<Sum>y\\<in>set_tree r. lookup_cost y \\<langle>l, x, r\\<rangle>)\n\ngoal (2 subgoals):\n 1. bst \\<langle>\\<rangle> \\<Longrightarrow>\n    (\\<Sum>x\\<in>set_tree \\<langle>\\<rangle>.\n       lookup_cost x \\<langle>\\<rangle>) =\n    ipl \\<langle>\\<rangle>\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>bst t1 \\<Longrightarrow>\n                (\\<Sum>x\\<in>set_tree t1. lookup_cost x t1) = ipl t1;\n        bst t2 \\<Longrightarrow>\n        (\\<Sum>x\\<in>set_tree t2. lookup_cost x t2) = ipl t2;\n        bst \\<langle>t1, x2, t2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set_tree \\<langle>t1, x2, t2\\<rangle>.\n                            lookup_cost x \\<langle>t1, x2, t2\\<rangle>) =\n                         ipl \\<langle>t1, x2, t2\\<rangle>", "have \"(\\<Sum>y\\<in>set_tree l. lookup_cost y \\<langle>l, x, r\\<rangle>) = (\\<Sum>y\\<in>set_tree l. 1 + lookup_cost y l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>set_tree l. lookup_cost y \\<langle>l, x, r\\<rangle>) =\n    (\\<Sum>y\\<in>set_tree l. 1 + lookup_cost y l)", "using disj and Node"], ["proof (prove)\nusing this:\n  x \\<notin> set_tree l\n  x \\<notin> set_tree r\n  set_tree l \\<inter> set_tree r = {}\n  bst l \\<Longrightarrow> (\\<Sum>x\\<in>set_tree l. lookup_cost x l) = ipl l\n  bst r \\<Longrightarrow> (\\<Sum>x\\<in>set_tree r. lookup_cost x r) = ipl r\n  bst \\<langle>l, x, r\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>set_tree l. lookup_cost y \\<langle>l, x, r\\<rangle>) =\n    (\\<Sum>y\\<in>set_tree l. 1 + lookup_cost y l)", "by (intro sum.cong refl) auto"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>set_tree l. lookup_cost y \\<langle>l, x, r\\<rangle>) =\n  (\\<Sum>y\\<in>set_tree l. 1 + lookup_cost y l)\n\ngoal (2 subgoals):\n 1. bst \\<langle>\\<rangle> \\<Longrightarrow>\n    (\\<Sum>x\\<in>set_tree \\<langle>\\<rangle>.\n       lookup_cost x \\<langle>\\<rangle>) =\n    ipl \\<langle>\\<rangle>\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>bst t1 \\<Longrightarrow>\n                (\\<Sum>x\\<in>set_tree t1. lookup_cost x t1) = ipl t1;\n        bst t2 \\<Longrightarrow>\n        (\\<Sum>x\\<in>set_tree t2. lookup_cost x t2) = ipl t2;\n        bst \\<langle>t1, x2, t2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set_tree \\<langle>t1, x2, t2\\<rangle>.\n                            lookup_cost x \\<langle>t1, x2, t2\\<rangle>) =\n                         ipl \\<langle>t1, x2, t2\\<rangle>", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>set_tree l. lookup_cost y \\<langle>l, x, r\\<rangle>) =\n  (\\<Sum>y\\<in>set_tree l. 1 + lookup_cost y l)\n\ngoal (2 subgoals):\n 1. bst \\<langle>\\<rangle> \\<Longrightarrow>\n    (\\<Sum>x\\<in>set_tree \\<langle>\\<rangle>.\n       lookup_cost x \\<langle>\\<rangle>) =\n    ipl \\<langle>\\<rangle>\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>bst t1 \\<Longrightarrow>\n                (\\<Sum>x\\<in>set_tree t1. lookup_cost x t1) = ipl t1;\n        bst t2 \\<Longrightarrow>\n        (\\<Sum>x\\<in>set_tree t2. lookup_cost x t2) = ipl t2;\n        bst \\<langle>t1, x2, t2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set_tree \\<langle>t1, x2, t2\\<rangle>.\n                            lookup_cost x \\<langle>t1, x2, t2\\<rangle>) =\n                         ipl \\<langle>t1, x2, t2\\<rangle>", "have \"\\<dots> = size l + ipl l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>set_tree l. 1 + lookup_cost y l) = size l + ipl l", "using Node"], ["proof (prove)\nusing this:\n  bst l \\<Longrightarrow> (\\<Sum>x\\<in>set_tree l. lookup_cost x l) = ipl l\n  bst r \\<Longrightarrow> (\\<Sum>x\\<in>set_tree r. lookup_cost x r) = ipl r\n  bst \\<langle>l, x, r\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>set_tree l. 1 + lookup_cost y l) = size l + ipl l", "by (subst sum.distrib) (simp_all add: card_set_tree_bst)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>set_tree l. 1 + lookup_cost y l) = size l + ipl l\n\ngoal (2 subgoals):\n 1. bst \\<langle>\\<rangle> \\<Longrightarrow>\n    (\\<Sum>x\\<in>set_tree \\<langle>\\<rangle>.\n       lookup_cost x \\<langle>\\<rangle>) =\n    ipl \\<langle>\\<rangle>\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>bst t1 \\<Longrightarrow>\n                (\\<Sum>x\\<in>set_tree t1. lookup_cost x t1) = ipl t1;\n        bst t2 \\<Longrightarrow>\n        (\\<Sum>x\\<in>set_tree t2. lookup_cost x t2) = ipl t2;\n        bst \\<langle>t1, x2, t2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set_tree \\<langle>t1, x2, t2\\<rangle>.\n                            lookup_cost x \\<langle>t1, x2, t2\\<rangle>) =\n                         ipl \\<langle>t1, x2, t2\\<rangle>", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>set_tree l. 1 + lookup_cost y l) = size l + ipl l\n\ngoal (2 subgoals):\n 1. bst \\<langle>\\<rangle> \\<Longrightarrow>\n    (\\<Sum>x\\<in>set_tree \\<langle>\\<rangle>.\n       lookup_cost x \\<langle>\\<rangle>) =\n    ipl \\<langle>\\<rangle>\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>bst t1 \\<Longrightarrow>\n                (\\<Sum>x\\<in>set_tree t1. lookup_cost x t1) = ipl t1;\n        bst t2 \\<Longrightarrow>\n        (\\<Sum>x\\<in>set_tree t2. lookup_cost x t2) = ipl t2;\n        bst \\<langle>t1, x2, t2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set_tree \\<langle>t1, x2, t2\\<rangle>.\n                            lookup_cost x \\<langle>t1, x2, t2\\<rangle>) =\n                         ipl \\<langle>t1, x2, t2\\<rangle>", "have \"(\\<Sum>y\\<in>set_tree r. lookup_cost y \\<langle>l, x, r\\<rangle>) = (\\<Sum>y\\<in>set_tree r. 1 + lookup_cost y r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>set_tree r. lookup_cost y \\<langle>l, x, r\\<rangle>) =\n    (\\<Sum>y\\<in>set_tree r. 1 + lookup_cost y r)", "using disj and Node"], ["proof (prove)\nusing this:\n  x \\<notin> set_tree l\n  x \\<notin> set_tree r\n  set_tree l \\<inter> set_tree r = {}\n  bst l \\<Longrightarrow> (\\<Sum>x\\<in>set_tree l. lookup_cost x l) = ipl l\n  bst r \\<Longrightarrow> (\\<Sum>x\\<in>set_tree r. lookup_cost x r) = ipl r\n  bst \\<langle>l, x, r\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>set_tree r. lookup_cost y \\<langle>l, x, r\\<rangle>) =\n    (\\<Sum>y\\<in>set_tree r. 1 + lookup_cost y r)", "by (intro sum.cong refl) auto"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>set_tree r. lookup_cost y \\<langle>l, x, r\\<rangle>) =\n  (\\<Sum>y\\<in>set_tree r. 1 + lookup_cost y r)\n\ngoal (2 subgoals):\n 1. bst \\<langle>\\<rangle> \\<Longrightarrow>\n    (\\<Sum>x\\<in>set_tree \\<langle>\\<rangle>.\n       lookup_cost x \\<langle>\\<rangle>) =\n    ipl \\<langle>\\<rangle>\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>bst t1 \\<Longrightarrow>\n                (\\<Sum>x\\<in>set_tree t1. lookup_cost x t1) = ipl t1;\n        bst t2 \\<Longrightarrow>\n        (\\<Sum>x\\<in>set_tree t2. lookup_cost x t2) = ipl t2;\n        bst \\<langle>t1, x2, t2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set_tree \\<langle>t1, x2, t2\\<rangle>.\n                            lookup_cost x \\<langle>t1, x2, t2\\<rangle>) =\n                         ipl \\<langle>t1, x2, t2\\<rangle>", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>set_tree r. lookup_cost y \\<langle>l, x, r\\<rangle>) =\n  (\\<Sum>y\\<in>set_tree r. 1 + lookup_cost y r)\n\ngoal (2 subgoals):\n 1. bst \\<langle>\\<rangle> \\<Longrightarrow>\n    (\\<Sum>x\\<in>set_tree \\<langle>\\<rangle>.\n       lookup_cost x \\<langle>\\<rangle>) =\n    ipl \\<langle>\\<rangle>\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>bst t1 \\<Longrightarrow>\n                (\\<Sum>x\\<in>set_tree t1. lookup_cost x t1) = ipl t1;\n        bst t2 \\<Longrightarrow>\n        (\\<Sum>x\\<in>set_tree t2. lookup_cost x t2) = ipl t2;\n        bst \\<langle>t1, x2, t2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set_tree \\<langle>t1, x2, t2\\<rangle>.\n                            lookup_cost x \\<langle>t1, x2, t2\\<rangle>) =\n                         ipl \\<langle>t1, x2, t2\\<rangle>", "have \"\\<dots> = size r + ipl r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>set_tree r. 1 + lookup_cost y r) = size r + ipl r", "using Node"], ["proof (prove)\nusing this:\n  bst l \\<Longrightarrow> (\\<Sum>x\\<in>set_tree l. lookup_cost x l) = ipl l\n  bst r \\<Longrightarrow> (\\<Sum>x\\<in>set_tree r. lookup_cost x r) = ipl r\n  bst \\<langle>l, x, r\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>set_tree r. 1 + lookup_cost y r) = size r + ipl r", "by (subst sum.distrib) (simp_all add: card_set_tree_bst)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>set_tree r. 1 + lookup_cost y r) = size r + ipl r\n\ngoal (2 subgoals):\n 1. bst \\<langle>\\<rangle> \\<Longrightarrow>\n    (\\<Sum>x\\<in>set_tree \\<langle>\\<rangle>.\n       lookup_cost x \\<langle>\\<rangle>) =\n    ipl \\<langle>\\<rangle>\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>bst t1 \\<Longrightarrow>\n                (\\<Sum>x\\<in>set_tree t1. lookup_cost x t1) = ipl t1;\n        bst t2 \\<Longrightarrow>\n        (\\<Sum>x\\<in>set_tree t2. lookup_cost x t2) = ipl t2;\n        bst \\<langle>t1, x2, t2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>set_tree \\<langle>t1, x2, t2\\<rangle>.\n                            lookup_cost x \\<langle>t1, x2, t2\\<rangle>) =\n                         ipl \\<langle>t1, x2, t2\\<rangle>", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>y\\<in>set_tree \\<langle>l, x, r\\<rangle>.\n     lookup_cost y \\<langle>l, x, r\\<rangle>) =\n  lookup_cost x \\<langle>l, x, r\\<rangle> + (size l + ipl l) +\n  (size r + ipl r)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Sum>y\\<in>set_tree \\<langle>l, x, r\\<rangle>.\n     lookup_cost y \\<langle>l, x, r\\<rangle>) =\n  lookup_cost x \\<langle>l, x, r\\<rangle> + (size l + ipl l) +\n  (size r + ipl r)\n\ngoal (1 subgoal):\n 1. (\\<Sum>xa\\<in>set_tree \\<langle>l, x, r\\<rangle>.\n       lookup_cost xa \\<langle>l, x, r\\<rangle>) =\n    ipl \\<langle>l, x, r\\<rangle>", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>xa\\<in>set_tree \\<langle>l, x, r\\<rangle>.\n     lookup_cost xa \\<langle>l, x, r\\<rangle>) =\n  ipl \\<langle>l, x, r\\<rangle>\n\ngoal (1 subgoal):\n 1. bst \\<langle>\\<rangle> \\<Longrightarrow>\n    (\\<Sum>x\\<in>set_tree \\<langle>\\<rangle>.\n       lookup_cost x \\<langle>\\<rangle>) =\n    ipl \\<langle>\\<rangle>", "qed simp_all"], ["", "text \\<open>\n  This allows us to easily show that the expected cost of looking up a random element in a\n  fixed tree is the internal path length divided by the number of elements.\n\\<close>"], ["", "theorem expected_lookup_cost:\n  assumes \"bst t\" \"t \\<noteq> Leaf\"\n  shows   \"measure_pmf.expectation (pmf_of_set (set_tree t)) (\\<lambda>x. lookup_cost x t) =\n             ipl t / size t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pmf_of_set (set_tree t))\n     (\\<lambda>x. real (lookup_cost x t)) =\n    real (ipl t) / real (size t)", "using assms"], ["proof (prove)\nusing this:\n  bst t\n  t \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pmf_of_set (set_tree t))\n     (\\<lambda>x. real (lookup_cost x t)) =\n    real (ipl t) / real (size t)", "by (subst integral_pmf_of_set)\n                 (simp_all add: sum_lookup_costs of_nat_sum [symmetric] card_set_tree_bst)"], ["", "text \\<open>\n  Therefore, we will now turn to analysing the internal path length of a random BST. This\n  then clearly related to the expected lookup costs of a random element in a random BST by\n  the above result.\n\\<close>"], ["", "subsection \\<open>Average Path Length\\<close>"], ["", "text \\<open>\n  The internal path length satisfies the recursive equation @{thm ipl.simps(2)[of l x r]}.\n  This is quite similar to the number of comparisons performed by QuickSort, and indeed, we can\n  reduce the internal path length of a random BST to the number of comparisons performed by\n  QuickSort on a randomly-ordered list relatively easily:\n\\<close>"], ["", "theorem map_pmf_random_bst_eq_rqs_cost:\n  assumes \"finite A\"\n  shows   \"map_pmf ipl (random_bst A) = rqs_cost (card A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf ipl (random_bst A) = rqs_cost (card A)", "using assms"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. map_pmf ipl (random_bst A) = rqs_cost (card A)", "proof (induction A rule: finite_psubset_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>finite A;\n        \\<And>B.\n           B \\<subset> A \\<Longrightarrow>\n           map_pmf ipl (random_bst B) = rqs_cost (card B)\\<rbrakk>\n       \\<Longrightarrow> map_pmf ipl (random_bst A) = rqs_cost (card A)", "case (psubset A)"], ["proof (state)\nthis:\n  finite A\n  ?B \\<subset> A \\<Longrightarrow>\n  map_pmf ipl (random_bst ?B) = rqs_cost (card ?B)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>finite A;\n        \\<And>B.\n           B \\<subset> A \\<Longrightarrow>\n           map_pmf ipl (random_bst B) = rqs_cost (card B)\\<rbrakk>\n       \\<Longrightarrow> map_pmf ipl (random_bst A) = rqs_cost (card A)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf ipl (random_bst A) = rqs_cost (card A)", "proof (cases \"A = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> map_pmf ipl (random_bst A) = rqs_cost (card A)\n 2. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf ipl (random_bst A) = rqs_cost (card A)", "case False"], ["proof (state)\nthis:\n  A \\<noteq> {}\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> map_pmf ipl (random_bst A) = rqs_cost (card A)\n 2. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf ipl (random_bst A) = rqs_cost (card A)", "note A = \\<open>finite A\\<close> \\<open>A \\<noteq> {}\\<close>"], ["proof (state)\nthis:\n  finite A\n  A \\<noteq> {}\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> map_pmf ipl (random_bst A) = rqs_cost (card A)\n 2. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf ipl (random_bst A) = rqs_cost (card A)", "define n where \"n = card A - 1\""], ["proof (state)\nthis:\n  n = card A - 1\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> map_pmf ipl (random_bst A) = rqs_cost (card A)\n 2. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf ipl (random_bst A) = rqs_cost (card A)", "define rank :: \"'a \\<Rightarrow> nat\" where \"rank = linorder_rank {(x,y). x \\<le> y} A\""], ["proof (state)\nthis:\n  rank = linorder_rank {(x, y). x \\<le> y} A\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> map_pmf ipl (random_bst A) = rqs_cost (card A)\n 2. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf ipl (random_bst A) = rqs_cost (card A)", "from A"], ["proof (chain)\npicking this:\n  finite A\n  A \\<noteq> {}", "have card: \"card A = Suc n\""], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card A = Suc n", "by (cases \"card A\") (auto simp: n_def)"], ["proof (state)\nthis:\n  card A = Suc n\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> map_pmf ipl (random_bst A) = rqs_cost (card A)\n 2. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf ipl (random_bst A) = rqs_cost (card A)", "from A"], ["proof (chain)\npicking this:\n  finite A\n  A \\<noteq> {}", "have \"map_pmf ipl (random_bst A) =\n                   do {\n                     x \\<leftarrow> pmf_of_set A;\n                     (l,r) \\<leftarrow> pair_pmf (random_bst {y \\<in> A. y < x}) (random_bst {y \\<in> A. y > x});\n                     return_pmf (ipl (Node l x r))\n                   }\""], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. map_pmf ipl (random_bst A) =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pair_pmf (random_bst {y \\<in> A. y < x})\n         (random_bst {y \\<in> A. x < y}) \\<bind>\n        (\\<lambda>(l, r). return_pmf (ipl \\<langle>l, x, r\\<rangle>)))", "by (subst random_bst.simps)\n         (simp_all add: pair_pmf_def card map_pmf_def bind_assoc_pmf bind_return_pmf)"], ["proof (state)\nthis:\n  map_pmf ipl (random_bst A) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf (random_bst {y \\<in> A. y < x})\n       (random_bst {y \\<in> A. x < y}) \\<bind>\n      (\\<lambda>(l, r). return_pmf (ipl \\<langle>l, x, r\\<rangle>)))\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> map_pmf ipl (random_bst A) = rqs_cost (card A)\n 2. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf ipl (random_bst A) = rqs_cost (card A)", "also"], ["proof (state)\nthis:\n  map_pmf ipl (random_bst A) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf (random_bst {y \\<in> A. y < x})\n       (random_bst {y \\<in> A. x < y}) \\<bind>\n      (\\<lambda>(l, r). return_pmf (ipl \\<langle>l, x, r\\<rangle>)))\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> map_pmf ipl (random_bst A) = rqs_cost (card A)\n 2. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf ipl (random_bst A) = rqs_cost (card A)", "have \"\\<dots> = do {\n                      x \\<leftarrow> pmf_of_set A;\n                      (l,r) \\<leftarrow> pair_pmf (random_bst {y \\<in> A. y < x}) (random_bst {y \\<in> A. y > x});\n                      return_pmf (n + ipl l + ipl r)\n                    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pair_pmf (random_bst {y \\<in> A. y < x})\n         (random_bst {y \\<in> A. x < y}) \\<bind>\n        (\\<lambda>(l, r). return_pmf (ipl \\<langle>l, x, r\\<rangle>))) =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pair_pmf (random_bst {y \\<in> A. y < x})\n         (random_bst {y \\<in> A. x < y}) \\<bind>\n        (\\<lambda>(l, r). return_pmf (n + ipl l + ipl r)))", "proof (intro bind_pmf_cong refl, clarify, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>x \\<in> set_pmf (pmf_of_set A);\n        (a, b)\n        \\<in> set_pmf\n               (pair_pmf (random_bst {y \\<in> A. y < x})\n                 (random_bst {y \\<in> A. x < y}))\\<rbrakk>\n       \\<Longrightarrow> return_pmf (ipl \\<langle>a, x, b\\<rangle>) =\n                         return_pmf (n + ipl a + ipl b)", "case (1 x l r)"], ["proof (state)\nthis:\n  x \\<in> set_pmf (pmf_of_set A)\n  (l, r)\n  \\<in> set_pmf\n         (pair_pmf (random_bst {y \\<in> A. y < x})\n           (random_bst {y \\<in> A. x < y}))\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>x \\<in> set_pmf (pmf_of_set A);\n        (a, b)\n        \\<in> set_pmf\n               (pair_pmf (random_bst {y \\<in> A. y < x})\n                 (random_bst {y \\<in> A. x < y}))\\<rbrakk>\n       \\<Longrightarrow> return_pmf (ipl \\<langle>a, x, b\\<rangle>) =\n                         return_pmf (n + ipl a + ipl b)", "from 1 and A"], ["proof (chain)\npicking this:\n  x \\<in> set_pmf (pmf_of_set A)\n  (l, r)\n  \\<in> set_pmf\n         (pair_pmf (random_bst {y \\<in> A. y < x})\n           (random_bst {y \\<in> A. x < y}))\n  finite A\n  A \\<noteq> {}", "have \"n = card (A - {x})\""], ["proof (prove)\nusing this:\n  x \\<in> set_pmf (pmf_of_set A)\n  (l, r)\n  \\<in> set_pmf\n         (pair_pmf (random_bst {y \\<in> A. y < x})\n           (random_bst {y \\<in> A. x < y}))\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. n = card (A - {x})", "by (simp add: n_def)"], ["proof (state)\nthis:\n  n = card (A - {x})\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>x \\<in> set_pmf (pmf_of_set A);\n        (a, b)\n        \\<in> set_pmf\n               (pair_pmf (random_bst {y \\<in> A. y < x})\n                 (random_bst {y \\<in> A. x < y}))\\<rbrakk>\n       \\<Longrightarrow> return_pmf (ipl \\<langle>a, x, b\\<rangle>) =\n                         return_pmf (n + ipl a + ipl b)", "also"], ["proof (state)\nthis:\n  n = card (A - {x})\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>x \\<in> set_pmf (pmf_of_set A);\n        (a, b)\n        \\<in> set_pmf\n               (pair_pmf (random_bst {y \\<in> A. y < x})\n                 (random_bst {y \\<in> A. x < y}))\\<rbrakk>\n       \\<Longrightarrow> return_pmf (ipl \\<langle>a, x, b\\<rangle>) =\n                         return_pmf (n + ipl a + ipl b)", "have \"A - {x} = {y\\<in>A. y < x} \\<union> {y\\<in>A. y > x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - {x} = {y \\<in> A. y < x} \\<union> {y \\<in> A. x < y}", "by auto"], ["proof (state)\nthis:\n  A - {x} = {y \\<in> A. y < x} \\<union> {y \\<in> A. x < y}\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>x \\<in> set_pmf (pmf_of_set A);\n        (a, b)\n        \\<in> set_pmf\n               (pair_pmf (random_bst {y \\<in> A. y < x})\n                 (random_bst {y \\<in> A. x < y}))\\<rbrakk>\n       \\<Longrightarrow> return_pmf (ipl \\<langle>a, x, b\\<rangle>) =\n                         return_pmf (n + ipl a + ipl b)", "also"], ["proof (state)\nthis:\n  A - {x} = {y \\<in> A. y < x} \\<union> {y \\<in> A. x < y}\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>x \\<in> set_pmf (pmf_of_set A);\n        (a, b)\n        \\<in> set_pmf\n               (pair_pmf (random_bst {y \\<in> A. y < x})\n                 (random_bst {y \\<in> A. x < y}))\\<rbrakk>\n       \\<Longrightarrow> return_pmf (ipl \\<langle>a, x, b\\<rangle>) =\n                         return_pmf (n + ipl a + ipl b)", "have \"card \\<dots> = card {y\\<in>A. y < x} + card {y\\<in>A. y > x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ({y \\<in> A. y < x} \\<union> {y \\<in> A. x < y}) =\n    card {y \\<in> A. y < x} + card {y \\<in> A. x < y}", "using \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. card ({y \\<in> A. y < x} \\<union> {y \\<in> A. x < y}) =\n    card {y \\<in> A. y < x} + card {y \\<in> A. x < y}", "by (intro card_Un_disjoint) auto"], ["proof (state)\nthis:\n  card ({y \\<in> A. y < x} \\<union> {y \\<in> A. x < y}) =\n  card {y \\<in> A. y < x} + card {y \\<in> A. x < y}\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>x \\<in> set_pmf (pmf_of_set A);\n        (a, b)\n        \\<in> set_pmf\n               (pair_pmf (random_bst {y \\<in> A. y < x})\n                 (random_bst {y \\<in> A. x < y}))\\<rbrakk>\n       \\<Longrightarrow> return_pmf (ipl \\<langle>a, x, b\\<rangle>) =\n                         return_pmf (n + ipl a + ipl b)", "also"], ["proof (state)\nthis:\n  card ({y \\<in> A. y < x} \\<union> {y \\<in> A. x < y}) =\n  card {y \\<in> A. y < x} + card {y \\<in> A. x < y}\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>x \\<in> set_pmf (pmf_of_set A);\n        (a, b)\n        \\<in> set_pmf\n               (pair_pmf (random_bst {y \\<in> A. y < x})\n                 (random_bst {y \\<in> A. x < y}))\\<rbrakk>\n       \\<Longrightarrow> return_pmf (ipl \\<langle>a, x, b\\<rangle>) =\n                         return_pmf (n + ipl a + ipl b)", "from 1 and A"], ["proof (chain)\npicking this:\n  x \\<in> set_pmf (pmf_of_set A)\n  (l, r)\n  \\<in> set_pmf\n         (pair_pmf (random_bst {y \\<in> A. y < x})\n           (random_bst {y \\<in> A. x < y}))\n  finite A\n  A \\<noteq> {}", "have \"card {y\\<in>A. y < x} = size l\""], ["proof (prove)\nusing this:\n  x \\<in> set_pmf (pmf_of_set A)\n  (l, r)\n  \\<in> set_pmf\n         (pair_pmf (random_bst {y \\<in> A. y < x})\n           (random_bst {y \\<in> A. x < y}))\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card {y \\<in> A. y < x} = size l", "by (auto dest: size_random_bst)"], ["proof (state)\nthis:\n  card {y \\<in> A. y < x} = size l\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>x \\<in> set_pmf (pmf_of_set A);\n        (a, b)\n        \\<in> set_pmf\n               (pair_pmf (random_bst {y \\<in> A. y < x})\n                 (random_bst {y \\<in> A. x < y}))\\<rbrakk>\n       \\<Longrightarrow> return_pmf (ipl \\<langle>a, x, b\\<rangle>) =\n                         return_pmf (n + ipl a + ipl b)", "also"], ["proof (state)\nthis:\n  card {y \\<in> A. y < x} = size l\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>x \\<in> set_pmf (pmf_of_set A);\n        (a, b)\n        \\<in> set_pmf\n               (pair_pmf (random_bst {y \\<in> A. y < x})\n                 (random_bst {y \\<in> A. x < y}))\\<rbrakk>\n       \\<Longrightarrow> return_pmf (ipl \\<langle>a, x, b\\<rangle>) =\n                         return_pmf (n + ipl a + ipl b)", "from 1 and A"], ["proof (chain)\npicking this:\n  x \\<in> set_pmf (pmf_of_set A)\n  (l, r)\n  \\<in> set_pmf\n         (pair_pmf (random_bst {y \\<in> A. y < x})\n           (random_bst {y \\<in> A. x < y}))\n  finite A\n  A \\<noteq> {}", "have \"card {y\\<in>A. y > x} = size r\""], ["proof (prove)\nusing this:\n  x \\<in> set_pmf (pmf_of_set A)\n  (l, r)\n  \\<in> set_pmf\n         (pair_pmf (random_bst {y \\<in> A. y < x})\n           (random_bst {y \\<in> A. x < y}))\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card {y \\<in> A. x < y} = size r", "by (auto dest: size_random_bst)"], ["proof (state)\nthis:\n  card {y \\<in> A. x < y} = size r\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>x \\<in> set_pmf (pmf_of_set A);\n        (a, b)\n        \\<in> set_pmf\n               (pair_pmf (random_bst {y \\<in> A. y < x})\n                 (random_bst {y \\<in> A. x < y}))\\<rbrakk>\n       \\<Longrightarrow> return_pmf (ipl \\<langle>a, x, b\\<rangle>) =\n                         return_pmf (n + ipl a + ipl b)", "finally"], ["proof (chain)\npicking this:\n  n = size l + size r", "show ?case"], ["proof (prove)\nusing this:\n  n = size l + size r\n\ngoal (1 subgoal):\n 1. return_pmf (ipl \\<langle>l, x, r\\<rangle>) =\n    return_pmf (n + ipl l + ipl r)", "by simp"], ["proof (state)\nthis:\n  return_pmf (ipl \\<langle>l, x, r\\<rangle>) =\n  return_pmf (n + ipl l + ipl r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf (random_bst {y \\<in> A. y < x})\n       (random_bst {y \\<in> A. x < y}) \\<bind>\n      (\\<lambda>(l, r). return_pmf (ipl \\<langle>l, x, r\\<rangle>))) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf (random_bst {y \\<in> A. y < x})\n       (random_bst {y \\<in> A. x < y}) \\<bind>\n      (\\<lambda>(l, r). return_pmf (n + ipl l + ipl r)))\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> map_pmf ipl (random_bst A) = rqs_cost (card A)\n 2. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf ipl (random_bst A) = rqs_cost (card A)", "also"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf (random_bst {y \\<in> A. y < x})\n       (random_bst {y \\<in> A. x < y}) \\<bind>\n      (\\<lambda>(l, r). return_pmf (ipl \\<langle>l, x, r\\<rangle>))) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf (random_bst {y \\<in> A. y < x})\n       (random_bst {y \\<in> A. x < y}) \\<bind>\n      (\\<lambda>(l, r). return_pmf (n + ipl l + ipl r)))\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> map_pmf ipl (random_bst A) = rqs_cost (card A)\n 2. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf ipl (random_bst A) = rqs_cost (card A)", "have \"\\<dots> = do {\n                      x \\<leftarrow> pmf_of_set A;\n                      (l,r) \\<leftarrow> pair_pmf (map_pmf ipl (random_bst {y \\<in> A. y < x}))\n                                        (map_pmf ipl (random_bst {y \\<in> A. y > x}));\n                      return_pmf (n + l + r)\n                    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pair_pmf (random_bst {y \\<in> A. y < x})\n         (random_bst {y \\<in> A. x < y}) \\<bind>\n        (\\<lambda>(l, r). return_pmf (n + ipl l + ipl r))) =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pair_pmf (map_pmf ipl (random_bst {y \\<in> A. y < x}))\n         (map_pmf ipl (random_bst {y \\<in> A. x < y})) \\<bind>\n        (\\<lambda>(l, r). return_pmf (n + l + r)))", "by (simp add: map_pair [symmetric] case_prod_unfold bind_map_pmf)"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf (random_bst {y \\<in> A. y < x})\n       (random_bst {y \\<in> A. x < y}) \\<bind>\n      (\\<lambda>(l, r). return_pmf (n + ipl l + ipl r))) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf (map_pmf ipl (random_bst {y \\<in> A. y < x}))\n       (map_pmf ipl (random_bst {y \\<in> A. x < y})) \\<bind>\n      (\\<lambda>(l, r). return_pmf (n + l + r)))\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> map_pmf ipl (random_bst A) = rqs_cost (card A)\n 2. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf ipl (random_bst A) = rqs_cost (card A)", "also"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf (random_bst {y \\<in> A. y < x})\n       (random_bst {y \\<in> A. x < y}) \\<bind>\n      (\\<lambda>(l, r). return_pmf (n + ipl l + ipl r))) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf (map_pmf ipl (random_bst {y \\<in> A. y < x}))\n       (map_pmf ipl (random_bst {y \\<in> A. x < y})) \\<bind>\n      (\\<lambda>(l, r). return_pmf (n + l + r)))\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> map_pmf ipl (random_bst A) = rqs_cost (card A)\n 2. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf ipl (random_bst A) = rqs_cost (card A)", "have \"\\<dots> = do {\n                      i \\<leftarrow> map_pmf rank (pmf_of_set A);\n                      (l,r) \\<leftarrow> pair_pmf (rqs_cost i) (rqs_cost (n - i));\n                      return_pmf (n + l + r)\n                    }\" (is \"_ = bind_pmf _ ?f\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pair_pmf (map_pmf ipl (random_bst {y \\<in> A. y < x}))\n         (map_pmf ipl (random_bst {y \\<in> A. x < y})) \\<bind>\n        (\\<lambda>(l, r). return_pmf (n + l + r))) =\n    map_pmf rank (pmf_of_set A) \\<bind>\n    (\\<lambda>i.\n        pair_pmf (rqs_cost i) (rqs_cost (n - i)) \\<bind>\n        (\\<lambda>(l, r). return_pmf (n + l + r)))", "unfolding bind_map_pmf"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pair_pmf (map_pmf ipl (random_bst {y \\<in> A. y < x}))\n         (map_pmf ipl (random_bst {y \\<in> A. x < y})) \\<bind>\n        (\\<lambda>(l, r). return_pmf (n + l + r))) =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pair_pmf (rqs_cost (rank x)) (rqs_cost (n - rank x)) \\<bind>\n        (\\<lambda>(l, r). return_pmf (n + l + r)))", "proof (intro bind_pmf_cong refl pair_pmf_cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf ipl (random_bst {y \\<in> A. y < x}) = rqs_cost (rank x)\n 2. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf ipl (random_bst {y \\<in> A. x < y}) = rqs_cost (n - rank x)", "case (1 x)"], ["proof (state)\nthis:\n  x \\<in> set_pmf (pmf_of_set A)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf ipl (random_bst {y \\<in> A. y < x}) = rqs_cost (rank x)\n 2. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf ipl (random_bst {y \\<in> A. x < y}) = rqs_cost (n - rank x)", "have \"map_pmf ipl (random_bst {y \\<in> A. y < x}) = rqs_cost (card {y \\<in> A. y < x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf ipl (random_bst {y \\<in> A. y < x}) =\n    rqs_cost (card {y \\<in> A. y < x})", "using 1 and A"], ["proof (prove)\nusing this:\n  x \\<in> set_pmf (pmf_of_set A)\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. map_pmf ipl (random_bst {y \\<in> A. y < x}) =\n    rqs_cost (card {y \\<in> A. y < x})", "by (intro psubset.IH) auto"], ["proof (state)\nthis:\n  map_pmf ipl (random_bst {y \\<in> A. y < x}) =\n  rqs_cost (card {y \\<in> A. y < x})\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf ipl (random_bst {y \\<in> A. y < x}) = rqs_cost (rank x)\n 2. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf ipl (random_bst {y \\<in> A. x < y}) = rqs_cost (n - rank x)", "also"], ["proof (state)\nthis:\n  map_pmf ipl (random_bst {y \\<in> A. y < x}) =\n  rqs_cost (card {y \\<in> A. y < x})\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf ipl (random_bst {y \\<in> A. y < x}) = rqs_cost (rank x)\n 2. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf ipl (random_bst {y \\<in> A. x < y}) = rqs_cost (n - rank x)", "have \"{y \\<in> A. y < x} = {y \\<in> A - {x}. y \\<le> x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y \\<in> A. y < x} = {y \\<in> A - {x}. y \\<le> x}", "by auto"], ["proof (state)\nthis:\n  {y \\<in> A. y < x} = {y \\<in> A - {x}. y \\<le> x}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf ipl (random_bst {y \\<in> A. y < x}) = rqs_cost (rank x)\n 2. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf ipl (random_bst {y \\<in> A. x < y}) = rqs_cost (n - rank x)", "hence \"card {y \\<in> A. y < x} = rank x\""], ["proof (prove)\nusing this:\n  {y \\<in> A. y < x} = {y \\<in> A - {x}. y \\<le> x}\n\ngoal (1 subgoal):\n 1. card {y \\<in> A. y < x} = rank x", "by (simp add: rank_def linorder_rank_def)"], ["proof (state)\nthis:\n  card {y \\<in> A. y < x} = rank x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf ipl (random_bst {y \\<in> A. y < x}) = rqs_cost (rank x)\n 2. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf ipl (random_bst {y \\<in> A. x < y}) = rqs_cost (n - rank x)", "finally"], ["proof (chain)\npicking this:\n  map_pmf ipl (random_bst {y \\<in> A. y < x}) = rqs_cost (rank x)", "show ?case"], ["proof (prove)\nusing this:\n  map_pmf ipl (random_bst {y \\<in> A. y < x}) = rqs_cost (rank x)\n\ngoal (1 subgoal):\n 1. map_pmf ipl (random_bst {y \\<in> A. y < x}) = rqs_cost (rank x)", "."], ["proof (state)\nthis:\n  map_pmf ipl (random_bst {y \\<in> A. y < x}) = rqs_cost (rank x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf ipl (random_bst {y \\<in> A. x < y}) = rqs_cost (n - rank x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf ipl (random_bst {y \\<in> A. x < y}) = rqs_cost (n - rank x)", "case (2 x)"], ["proof (state)\nthis:\n  x \\<in> set_pmf (pmf_of_set A)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf ipl (random_bst {y \\<in> A. x < y}) = rqs_cost (n - rank x)", "have \"map_pmf ipl (random_bst {y \\<in> A. y > x}) = rqs_cost (card {y \\<in> A. y > x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf ipl (random_bst {y \\<in> A. x < y}) =\n    rqs_cost (card {y \\<in> A. x < y})", "using 2 and A"], ["proof (prove)\nusing this:\n  x \\<in> set_pmf (pmf_of_set A)\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. map_pmf ipl (random_bst {y \\<in> A. x < y}) =\n    rqs_cost (card {y \\<in> A. x < y})", "by (intro psubset.IH) auto"], ["proof (state)\nthis:\n  map_pmf ipl (random_bst {y \\<in> A. x < y}) =\n  rqs_cost (card {y \\<in> A. x < y})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf ipl (random_bst {y \\<in> A. x < y}) = rqs_cost (n - rank x)", "also"], ["proof (state)\nthis:\n  map_pmf ipl (random_bst {y \\<in> A. x < y}) =\n  rqs_cost (card {y \\<in> A. x < y})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf ipl (random_bst {y \\<in> A. x < y}) = rqs_cost (n - rank x)", "have \"{y \\<in> A. y > x} = A - {x} - {y \\<in> A - {x}. y \\<le> x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y \\<in> A. x < y} = A - {x} - {y \\<in> A - {x}. y \\<le> x}", "by auto"], ["proof (state)\nthis:\n  {y \\<in> A. x < y} = A - {x} - {y \\<in> A - {x}. y \\<le> x}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf ipl (random_bst {y \\<in> A. x < y}) = rqs_cost (n - rank x)", "hence \"card {y \\<in> A. y > x} = card \\<dots>\""], ["proof (prove)\nusing this:\n  {y \\<in> A. x < y} = A - {x} - {y \\<in> A - {x}. y \\<le> x}\n\ngoal (1 subgoal):\n 1. card {y \\<in> A. x < y} = card (A - {x} - {y \\<in> A - {x}. y \\<le> x})", "by (simp only:)"], ["proof (state)\nthis:\n  card {y \\<in> A. x < y} = card (A - {x} - {y \\<in> A - {x}. y \\<le> x})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf ipl (random_bst {y \\<in> A. x < y}) = rqs_cost (n - rank x)", "also"], ["proof (state)\nthis:\n  card {y \\<in> A. x < y} = card (A - {x} - {y \\<in> A - {x}. y \\<le> x})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf ipl (random_bst {y \\<in> A. x < y}) = rqs_cost (n - rank x)", "from 2 and A"], ["proof (chain)\npicking this:\n  x \\<in> set_pmf (pmf_of_set A)\n  finite A\n  A \\<noteq> {}", "have \"\\<dots> = n - rank x\""], ["proof (prove)\nusing this:\n  x \\<in> set_pmf (pmf_of_set A)\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card (A - {x} - {y \\<in> A - {x}. y \\<le> x}) = n - rank x", "by (subst card_Diff_subset) (auto simp: rank_def linorder_rank_def n_def)"], ["proof (state)\nthis:\n  card (A - {x} - {y \\<in> A - {x}. y \\<le> x}) = n - rank x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf ipl (random_bst {y \\<in> A. x < y}) = rqs_cost (n - rank x)", "finally"], ["proof (chain)\npicking this:\n  map_pmf ipl (random_bst {y \\<in> A. x < y}) = rqs_cost (n - rank x)", "show ?case"], ["proof (prove)\nusing this:\n  map_pmf ipl (random_bst {y \\<in> A. x < y}) = rqs_cost (n - rank x)\n\ngoal (1 subgoal):\n 1. map_pmf ipl (random_bst {y \\<in> A. x < y}) = rqs_cost (n - rank x)", "."], ["proof (state)\nthis:\n  map_pmf ipl (random_bst {y \\<in> A. x < y}) = rqs_cost (n - rank x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf (map_pmf ipl (random_bst {y \\<in> A. y < x}))\n       (map_pmf ipl (random_bst {y \\<in> A. x < y})) \\<bind>\n      (\\<lambda>(l, r). return_pmf (n + l + r))) =\n  map_pmf rank (pmf_of_set A) \\<bind>\n  (\\<lambda>i.\n      pair_pmf (rqs_cost i) (rqs_cost (n - i)) \\<bind>\n      (\\<lambda>(l, r). return_pmf (n + l + r)))\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> map_pmf ipl (random_bst A) = rqs_cost (card A)\n 2. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf ipl (random_bst A) = rqs_cost (card A)", "also"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf (map_pmf ipl (random_bst {y \\<in> A. y < x}))\n       (map_pmf ipl (random_bst {y \\<in> A. x < y})) \\<bind>\n      (\\<lambda>(l, r). return_pmf (n + l + r))) =\n  map_pmf rank (pmf_of_set A) \\<bind>\n  (\\<lambda>i.\n      pair_pmf (rqs_cost i) (rqs_cost (n - i)) \\<bind>\n      (\\<lambda>(l, r). return_pmf (n + l + r)))\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> map_pmf ipl (random_bst A) = rqs_cost (card A)\n 2. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf ipl (random_bst A) = rqs_cost (card A)", "from A"], ["proof (chain)\npicking this:\n  finite A\n  A \\<noteq> {}", "have \"map_pmf rank (pmf_of_set A) = pmf_of_set {..<card A}\""], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. map_pmf rank (pmf_of_set A) = pmf_of_set {..<card A}", "unfolding rank_def"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. map_pmf (linorder_rank {(x, y). x \\<le> y} A) (pmf_of_set A) =\n    pmf_of_set {..<card A}", "by (intro map_pmf_of_set_bij_betw bij_betw_linorder_rank[of UNIV]) auto"], ["proof (state)\nthis:\n  map_pmf rank (pmf_of_set A) = pmf_of_set {..<card A}\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> map_pmf ipl (random_bst A) = rqs_cost (card A)\n 2. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf ipl (random_bst A) = rqs_cost (card A)", "also"], ["proof (state)\nthis:\n  map_pmf rank (pmf_of_set A) = pmf_of_set {..<card A}\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> map_pmf ipl (random_bst A) = rqs_cost (card A)\n 2. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf ipl (random_bst A) = rqs_cost (card A)", "have \"{..<card A} = {..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..<card A} = {..n}", "by (auto simp: card)"], ["proof (state)\nthis:\n  {..<card A} = {..n}\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> map_pmf ipl (random_bst A) = rqs_cost (card A)\n 2. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf ipl (random_bst A) = rqs_cost (card A)", "also"], ["proof (state)\nthis:\n  {..<card A} = {..n}\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> map_pmf ipl (random_bst A) = rqs_cost (card A)\n 2. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf ipl (random_bst A) = rqs_cost (card A)", "have \"pmf_of_set \\<dots> \\<bind> ?f = rqs_cost (card A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set {..n} \\<bind>\n    (\\<lambda>i.\n        pair_pmf (rqs_cost i) (rqs_cost (n - i)) \\<bind>\n        (\\<lambda>(l, r). return_pmf (n + l + r))) =\n    rqs_cost (card A)", "by (simp add: pair_pmf_def bind_assoc_pmf bind_return_pmf card)"], ["proof (state)\nthis:\n  pmf_of_set {..n} \\<bind>\n  (\\<lambda>i.\n      pair_pmf (rqs_cost i) (rqs_cost (n - i)) \\<bind>\n      (\\<lambda>(l, r). return_pmf (n + l + r))) =\n  rqs_cost (card A)\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> map_pmf ipl (random_bst A) = rqs_cost (card A)\n 2. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf ipl (random_bst A) = rqs_cost (card A)", "finally"], ["proof (chain)\npicking this:\n  map_pmf ipl (random_bst A) = rqs_cost (card A)", "show ?thesis"], ["proof (prove)\nusing this:\n  map_pmf ipl (random_bst A) = rqs_cost (card A)\n\ngoal (1 subgoal):\n 1. map_pmf ipl (random_bst A) = rqs_cost (card A)", "."], ["proof (state)\nthis:\n  map_pmf ipl (random_bst A) = rqs_cost (card A)\n\ngoal (1 subgoal):\n 1. A = {} \\<Longrightarrow> map_pmf ipl (random_bst A) = rqs_cost (card A)", "qed simp_all"], ["proof (state)\nthis:\n  map_pmf ipl (random_bst A) = rqs_cost (card A)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  In particular, this means that the expected values are the same:\n\\<close>"], ["", "corollary expected_ipl_random_bst_eq:\n  assumes \"finite A\"\n  shows   \"measure_pmf.expectation (random_bst A) ipl = rqs_cost_exp (card A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (ipl x)) =\n    rqs_cost_exp (card A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (ipl x)) =\n    rqs_cost_exp (card A)", "have \"measure_pmf.expectation (random_bst A) ipl =\n          measure_pmf.expectation (map_pmf ipl (random_bst A)) real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (ipl x)) =\n    measure_pmf.expectation (map_pmf ipl (random_bst A)) real", "by simp"], ["proof (state)\nthis:\n  measure_pmf.expectation (random_bst A) (\\<lambda>x. real (ipl x)) =\n  measure_pmf.expectation (map_pmf ipl (random_bst A)) real\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (ipl x)) =\n    rqs_cost_exp (card A)", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation (random_bst A) (\\<lambda>x. real (ipl x)) =\n  measure_pmf.expectation (map_pmf ipl (random_bst A)) real\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (ipl x)) =\n    rqs_cost_exp (card A)", "from assms"], ["proof (chain)\npicking this:\n  finite A", "have \"map_pmf ipl (random_bst A) = rqs_cost (card A)\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. map_pmf ipl (random_bst A) = rqs_cost (card A)", "by (rule map_pmf_random_bst_eq_rqs_cost)"], ["proof (state)\nthis:\n  map_pmf ipl (random_bst A) = rqs_cost (card A)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (ipl x)) =\n    rqs_cost_exp (card A)", "also"], ["proof (state)\nthis:\n  map_pmf ipl (random_bst A) = rqs_cost (card A)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (ipl x)) =\n    rqs_cost_exp (card A)", "have \"measure_pmf.expectation \\<dots> real = rqs_cost_exp (card A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (rqs_cost (card A)) real = rqs_cost_exp (card A)", "by (rule expectation_rqs_cost)"], ["proof (state)\nthis:\n  measure_pmf.expectation (rqs_cost (card A)) real = rqs_cost_exp (card A)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (ipl x)) =\n    rqs_cost_exp (card A)", "finally"], ["proof (chain)\npicking this:\n  measure_pmf.expectation (random_bst A) (\\<lambda>x. real (ipl x)) =\n  rqs_cost_exp (card A)", "show ?thesis"], ["proof (prove)\nusing this:\n  measure_pmf.expectation (random_bst A) (\\<lambda>x. real (ipl x)) =\n  rqs_cost_exp (card A)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (ipl x)) =\n    rqs_cost_exp (card A)", "."], ["proof (state)\nthis:\n  measure_pmf.expectation (random_bst A) (\\<lambda>x. real (ipl x)) =\n  rqs_cost_exp (card A)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Therefore, the results about the expected number of comparisons of QuickSort carry over\n  to the expected internal path length:\n\\<close>"], ["", "corollary expected_ipl_random_bst_eq':\n  assumes \"finite A\"\n  shows   \"measure_pmf.expectation (random_bst A) ipl =\n             2 * real (card A + 1) * harm (card A) - 4 * real (card A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (random_bst A) (\\<lambda>x. real (ipl x)) =\n    2 * real (card A + 1) * harm (card A) - 4 * real (card A)", "by (simp add: expected_ipl_random_bst_eq rqs_cost_exp_eq assms)"], ["", "end"]]}