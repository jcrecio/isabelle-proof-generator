{"file_name": "/home/qj213/afp-2021-10-22/thys/LatticeProperties/Modular_Distrib_Lattice.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LatticeProperties", "problem_names": ["lemma d_b_c_a: \"d_aux b c a = d_aux a b c\"", "lemma d_c_a_b: \"d_aux c a b = d_aux a b c\"", "lemma e_b_c_a: \"e_aux b c a = e_aux a b c\"", "lemma e_c_a_b: \"e_aux c a b = e_aux a b c\"", "lemma b_a: \"b_aux a b c = a_aux b c a\"", "lemma c_a: \"c_aux a b c = a_aux c a b\"", "lemma [simp]: \"a_aux a b c \\<le> e_aux a b c\"", "lemma [simp]: \"b_aux a b c \\<le> e_aux a b c\"", "lemma [simp]: \"c_aux a b c \\<le> e_aux a b c\"", "lemma [simp]: \"d_aux a b c \\<le> a_aux a b c\"", "lemma [simp]: \"d_aux a b c \\<le> b_aux a b c\"", "lemma [simp]: \"d_aux a b c \\<le> c_aux a b c\"", "lemma a_meet_e: \"a \\<sqinter> (e_aux a b c) = a \\<sqinter> (b \\<squnion> c)\"", "lemma b_meet_e: \"b \\<sqinter> (e_aux a b c) = b \\<sqinter> (c \\<squnion> a)\"", "lemma c_meet_e: \"c \\<sqinter> (e_aux a b c) = c \\<sqinter> (a \\<squnion> b)\"", "lemma a_join_d: \"a \\<squnion> d_aux a b c = a \\<squnion> (b \\<sqinter> c)\"", "lemma b_join_d: \"b \\<squnion> d_aux a b c = b \\<squnion> (c \\<sqinter> a)\"", "lemma M5_lattice_incomp: \"M5_lattice a b c \\<Longrightarrow> incomp a b\"", "lemma a_meet_d: \"a \\<sqinter> (d_aux a b c) = (a \\<sqinter> b) \\<squnion> (c \\<sqinter> a)\"", "lemma b_meet_d: \"b \\<sqinter> (d_aux a b c) = (b \\<sqinter> c) \\<squnion> (a \\<sqinter> b)\"", "lemma c_meet_d: \"c \\<sqinter> (d_aux a b c) = (c \\<sqinter> a) \\<squnion> (b \\<sqinter> c)\"", "lemma d_less_e: \"no_distrib a b c \\<Longrightarrow> d_aux a b c < e_aux a b c\"", "lemma a_meet_b_eq_d: \" d_aux a b c \\<le> e_aux a b c \\<Longrightarrow> a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c\"", "lemma b_meet_c_eq_d: \" d_aux a b c \\<le> e_aux a b c \\<Longrightarrow> b_aux a b c \\<sqinter> c_aux a b c = d_aux a b c\"", "lemma c_meet_a_eq_d: \"d_aux a b c \\<le> e_aux a b c \\<Longrightarrow> c_aux a b c \\<sqinter> a_aux a b c = d_aux a b c\"", "lemma a_def_equiv: \"d_aux a b c \\<le> e_aux a b c \\<Longrightarrow> a_aux a b c = (a \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c\"", "lemma b_def_equiv: \"d_aux a b c \\<le> e_aux a b c \\<Longrightarrow> b_aux a b c = (b \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c\"", "lemma c_def_equiv: \"d_aux a b c \\<le> e_aux a b c \\<Longrightarrow> c_aux a b c = (c \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c\"", "lemma a_join_b_eq_e: \"d_aux a b c \\<le> e_aux a b c \\<Longrightarrow> a_aux a b c \\<squnion> b_aux a b c = e_aux a b c\"", "lemma b_join_c_eq_e: \" d_aux a b c <= e_aux a b c \\<Longrightarrow> b_aux a b c \\<squnion> c_aux a b c = e_aux a b c\"", "lemma c_join_a_eq_e: \"d_aux a b c <= e_aux a b c \\<Longrightarrow> c_aux a b c \\<squnion> a_aux a b c = e_aux a b c\"", "lemma \"no_distrib a b c \\<Longrightarrow> incomp a b\"", "lemma M5_modular: \"no_distrib a b c \\<Longrightarrow> M5_lattice (a_aux a b c) (b_aux a b c) (c_aux a b c)\"", "lemma M5_modular_def: \"M5_lattice a b c = (a \\<sqinter> b = b \\<sqinter> c \\<and> c \\<sqinter> a = b \\<sqinter> c \\<and> a \\<squnion> b = b \\<squnion> c \\<and> c \\<squnion> a = b \\<squnion> c \\<and> a \\<sqinter> b < a \\<squnion> b)\"", "lemma not_modular_N5: \"(\\<not> class.modular_lattice inf ((\\<le>)::'a \\<Rightarrow> 'a \\<Rightarrow> bool) (<) sup) =\n   (\\<exists> a b c::'a . N5_lattice a b c)\"", "lemma not_distrib_N5_M5: \"(\\<not> class.distrib_lattice (\\<sqinter>) ((\\<le>)::'a \\<Rightarrow> 'a \\<Rightarrow> bool) (<) (\\<squnion>)) =\n   ((\\<exists> a b c::'a . N5_lattice a b c) \\<or> (\\<exists> a b c::'a . M5_lattice a b c))\"", "lemma distrib_not_N5_M5: \"(class.distrib_lattice (\\<sqinter>) ((\\<le>)::'a \\<Rightarrow> 'a \\<Rightarrow> bool) (<) (\\<squnion>)) =\n   ((\\<forall> a b c::'a . \\<not> N5_lattice a b c) \\<and> (\\<forall> a b c::'a . \\<not> M5_lattice a b c))\"", "lemma distrib_inf_sup_eq:\n  \"(class.distrib_lattice (\\<sqinter>) ((\\<le>)::'a \\<Rightarrow> 'a \\<Rightarrow> bool) (<) (\\<squnion>)) = \n    (\\<forall> x y z::'a . x \\<sqinter> z = y \\<sqinter> z \\<and> x \\<squnion> z = y \\<squnion> z \\<longrightarrow> x = y)\""], "translations": [["", "lemma d_b_c_a: \"d_aux b c a = d_aux a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux b c a = d_aux a b c", "by (metis d_aux_def sup.assoc sup_commute)"], ["", "lemma d_c_a_b: \"d_aux c a b = d_aux a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux c a b = d_aux a b c", "by (metis d_aux_def sup.assoc sup_commute)"], ["", "definition\n  \"e_aux a b c = (a \\<squnion> b) \\<sqinter> (b \\<squnion> c) \\<sqinter> (c \\<squnion> a)\""], ["", "lemma e_b_c_a: \"e_aux b c a = e_aux a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_aux b c a = e_aux a b c", "apply (simp add: e_aux_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (b \\<squnion> c) \\<sqinter> (c \\<squnion> a) \\<sqinter>\n    (a \\<squnion> b) =\n    (a \\<squnion> b) \\<sqinter> (b \\<squnion> c) \\<sqinter> (c \\<squnion> a)", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (b \\<squnion> c) \\<sqinter> (c \\<squnion> a) \\<sqinter> (a \\<squnion> b)\n    \\<le> (a \\<squnion> b) \\<sqinter> (b \\<squnion> c) \\<sqinter>\n          (c \\<squnion> a)\n 2. (a \\<squnion> b) \\<sqinter> (b \\<squnion> c) \\<sqinter> (c \\<squnion> a)\n    \\<le> (b \\<squnion> c) \\<sqinter> (c \\<squnion> a) \\<sqinter>\n          (a \\<squnion> b)", "by (simp_all add: sup_commute)"], ["", "lemma e_c_a_b: \"e_aux c a b = e_aux a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_aux c a b = e_aux a b c", "apply (simp add: e_aux_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (c \\<squnion> a) \\<sqinter> (a \\<squnion> b) \\<sqinter>\n    (b \\<squnion> c) =\n    (a \\<squnion> b) \\<sqinter> (b \\<squnion> c) \\<sqinter> (c \\<squnion> a)", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (c \\<squnion> a) \\<sqinter> (a \\<squnion> b) \\<sqinter> (b \\<squnion> c)\n    \\<le> (a \\<squnion> b) \\<sqinter> (b \\<squnion> c) \\<sqinter>\n          (c \\<squnion> a)\n 2. (a \\<squnion> b) \\<sqinter> (b \\<squnion> c) \\<sqinter> (c \\<squnion> a)\n    \\<le> (c \\<squnion> a) \\<sqinter> (a \\<squnion> b) \\<sqinter>\n          (b \\<squnion> c)", "by (simp_all add: sup_commute)"], ["", "definition\n  \"a_aux a b c = (a \\<sqinter> (e_aux a b c)) \\<squnion> (d_aux a b c)\""], ["", "definition\n  \"b_aux a b c = (b \\<sqinter> (e_aux a b c)) \\<squnion> (d_aux a b c)\""], ["", "definition\n  \"c_aux a b c = (c \\<sqinter> (e_aux a b c)) \\<squnion> (d_aux a b c)\""], ["", "lemma b_a: \"b_aux a b c = a_aux b c a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b_aux a b c = a_aux b c a", "by (simp add: a_aux_def b_aux_def e_b_c_a d_b_c_a)"], ["", "lemma c_a: \"c_aux a b c = a_aux c a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_aux a b c = a_aux c a b", "by (simp add: a_aux_def c_aux_def e_c_a_b d_c_a_b)"], ["", "lemma [simp]: \"a_aux a b c \\<le> e_aux a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a_aux a b c \\<le> e_aux a b c", "apply (simp add: a_aux_def e_aux_def d_aux_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sqinter>\n    ((a \\<squnion> b) \\<sqinter> (b \\<squnion> c) \\<sqinter>\n     (c \\<squnion> a))\n    \\<le> b \\<squnion> c", "apply (rule_tac y = \"(a \\<squnion> b) \\<sqinter> (b \\<squnion> c) \\<sqinter> (c \\<squnion> a)\" in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<sqinter>\n    ((a \\<squnion> b) \\<sqinter> (b \\<squnion> c) \\<sqinter>\n     (c \\<squnion> a))\n    \\<le> (a \\<squnion> b) \\<sqinter> (b \\<squnion> c) \\<sqinter>\n          (c \\<squnion> a)\n 2. (a \\<squnion> b) \\<sqinter> (b \\<squnion> c) \\<sqinter> (c \\<squnion> a)\n    \\<le> b \\<squnion> c", "apply (rule inf_le2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<squnion> b) \\<sqinter> (b \\<squnion> c) \\<sqinter> (c \\<squnion> a)\n    \\<le> b \\<squnion> c", "by simp"], ["", "lemma [simp]: \"b_aux a b c \\<le> e_aux a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b_aux a b c \\<le> e_aux a b c", "apply (unfold b_a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a_aux b c a \\<le> e_aux a b c", "apply (subst e_b_c_a [THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. a_aux b c a \\<le> e_aux b c a", "by simp"], ["", "lemma [simp]: \"c_aux a b c \\<le> e_aux a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_aux a b c \\<le> e_aux a b c", "apply (unfold c_a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a_aux c a b \\<le> e_aux a b c", "apply (subst e_c_a_b [THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. a_aux c a b \\<le> e_aux c a b", "by simp"], ["", "lemma [simp]: \"d_aux a b c \\<le> a_aux a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> a_aux a b c", "by (simp add: a_aux_def e_aux_def d_aux_def)"], ["", "lemma [simp]: \"d_aux a b c \\<le> b_aux a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> b_aux a b c", "apply (unfold b_a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> a_aux b c a", "apply (subst d_b_c_a [THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux b c a \\<le> a_aux b c a", "by simp"], ["", "lemma [simp]: \"d_aux a b c \\<le> c_aux a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> c_aux a b c", "apply (unfold c_a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> a_aux c a b", "apply (subst d_c_a_b [THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux c a b \\<le> a_aux c a b", "by simp"], ["", "lemma a_meet_e: \"a \\<sqinter> (e_aux a b c) = a \\<sqinter> (b \\<squnion> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sqinter> e_aux a b c = a \\<sqinter> (b \\<squnion> c)", "apply (simp add: e_aux_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sqinter>\n    ((a \\<squnion> b) \\<sqinter> (b \\<squnion> c) \\<sqinter>\n     (c \\<squnion> a)) =\n    a \\<sqinter> (b \\<squnion> c)", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<sqinter>\n    ((a \\<squnion> b) \\<sqinter> (b \\<squnion> c) \\<sqinter>\n     (c \\<squnion> a))\n    \\<le> a \\<sqinter> (b \\<squnion> c)\n 2. a \\<sqinter> (b \\<squnion> c)\n    \\<le> a \\<sqinter>\n          ((a \\<squnion> b) \\<sqinter> (b \\<squnion> c) \\<sqinter>\n           (c \\<squnion> a))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sqinter>\n    ((a \\<squnion> b) \\<sqinter> (b \\<squnion> c) \\<sqinter>\n     (c \\<squnion> a))\n    \\<le> b \\<squnion> c", "apply (rule_tac y = \"(a \\<squnion> b) \\<sqinter> (b \\<squnion> c) \\<sqinter> (c \\<squnion> a)\" in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<sqinter>\n    ((a \\<squnion> b) \\<sqinter> (b \\<squnion> c) \\<sqinter>\n     (c \\<squnion> a))\n    \\<le> (a \\<squnion> b) \\<sqinter> (b \\<squnion> c) \\<sqinter>\n          (c \\<squnion> a)\n 2. (a \\<squnion> b) \\<sqinter> (b \\<squnion> c) \\<sqinter> (c \\<squnion> a)\n    \\<le> b \\<squnion> c", "apply (rule inf_le2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<squnion> b) \\<sqinter> (b \\<squnion> c) \\<sqinter> (c \\<squnion> a)\n    \\<le> b \\<squnion> c", "by simp"], ["", "lemma b_meet_e: \"b \\<sqinter> (e_aux a b c) = b \\<sqinter> (c \\<squnion> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<sqinter> e_aux a b c = b \\<sqinter> (c \\<squnion> a)", "by (simp add: a_meet_e [THEN sym] e_b_c_a)"], ["", "lemma c_meet_e: \"c \\<sqinter> (e_aux a b c) = c \\<sqinter> (a \\<squnion> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<sqinter> e_aux a b c = c \\<sqinter> (a \\<squnion> b)", "by (simp add: a_meet_e [THEN sym] e_c_a_b)"], ["", "lemma a_join_d: \"a \\<squnion> d_aux a b c = a \\<squnion> (b \\<sqinter> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<squnion> d_aux a b c = a \\<squnion> b \\<sqinter> c", "apply (simp add: d_aux_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<squnion>\n    (a \\<sqinter> b \\<squnion> b \\<sqinter> c \\<squnion> c \\<sqinter> a) =\n    a \\<squnion> b \\<sqinter> c", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<squnion>\n    (a \\<sqinter> b \\<squnion> b \\<sqinter> c \\<squnion> c \\<sqinter> a)\n    \\<le> a \\<squnion> b \\<sqinter> c\n 2. a \\<squnion> b \\<sqinter> c\n    \\<le> a \\<squnion>\n          (a \\<sqinter> b \\<squnion> b \\<sqinter> c \\<squnion>\n           c \\<sqinter> a)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<sqinter> c\n    \\<le> a \\<squnion>\n          (a \\<sqinter> b \\<squnion> b \\<sqinter> c \\<squnion>\n           c \\<sqinter> a)", "apply (rule_tac y = \"a \\<sqinter> b \\<squnion> b \\<sqinter> c \\<squnion> c \\<sqinter> a\" in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. b \\<sqinter> c\n    \\<le> a \\<sqinter> b \\<squnion> b \\<sqinter> c \\<squnion> c \\<sqinter> a\n 2. a \\<sqinter> b \\<squnion> b \\<sqinter> c \\<squnion> c \\<sqinter> a\n    \\<le> a \\<squnion>\n          (a \\<sqinter> b \\<squnion> b \\<sqinter> c \\<squnion>\n           c \\<sqinter> a)", "by simp_all"], ["", "lemma b_join_d: \"b \\<squnion> d_aux a b c = b \\<squnion> (c \\<sqinter> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<squnion> d_aux a b c = b \\<squnion> c \\<sqinter> a", "by (simp add: a_join_d [THEN sym] d_b_c_a)"], ["", "end"], ["", "context lattice begin"], ["", "definition\n  \"no_distrib a b c = (a \\<sqinter> b \\<squnion> c \\<sqinter> a < a \\<sqinter> (b \\<squnion> c))\""], ["", "definition\n  \"incomp x y = (\\<not> x \\<le> y \\<and> \\<not> y \\<le> x)\""], ["", "definition \n  \"N5_lattice a b c = (a \\<sqinter> c = b \\<sqinter> c \\<and> a < b \\<and> a \\<squnion> c = b \\<squnion> c)\""], ["", "definition \n  \"M5_lattice a b c = (a \\<sqinter> b = b \\<sqinter> c \\<and> c \\<sqinter> a = b \\<sqinter> c \\<and> a \\<squnion> b = b \\<squnion> c \\<and> c \\<squnion> a = b \\<squnion> c \\<and> a \\<sqinter> b < a \\<squnion> b)\""], ["", "lemma M5_lattice_incomp: \"M5_lattice a b c \\<Longrightarrow> incomp a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M5_lattice a b c \\<Longrightarrow> incomp a b", "apply (simp add: M5_lattice_def incomp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sqinter> b = b \\<sqinter> c \\<and>\n    c \\<sqinter> a = b \\<sqinter> c \\<and>\n    a \\<squnion> b = b \\<squnion> c \\<and>\n    c \\<squnion> a = b \\<squnion> c \\<and>\n    a \\<sqinter> b < a \\<squnion> b \\<Longrightarrow>\n    \\<not> a \\<le> b \\<and> \\<not> b \\<le> a", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<sqinter> b = b \\<sqinter> c;\n     c \\<sqinter> a = b \\<sqinter> c; a \\<squnion> b = b \\<squnion> c;\n     c \\<squnion> a = b \\<squnion> c; a \\<sqinter> b < a \\<squnion> b;\n     a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>a \\<sqinter> b = b \\<sqinter> c;\n     c \\<sqinter> a = b \\<sqinter> c; a \\<squnion> b = b \\<squnion> c;\n     c \\<squnion> a = b \\<squnion> c; a \\<sqinter> b < a \\<squnion> b;\n     b \\<le> a\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp_all add: inf_absorb1 inf_absorb2 )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = b \\<sqinter> c;\n     b \\<sqinter> c \\<squnion> b = b \\<squnion> c;\n     c \\<squnion> b \\<sqinter> c = b \\<squnion> c;\n     b \\<sqinter> c < b \\<squnion> c\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>b = b \\<sqinter> c; c \\<sqinter> a = b;\n     a \\<squnion> b = b \\<squnion> c; c \\<squnion> a = b \\<squnion> c;\n     b < b \\<squnion> c; b \\<le> a\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp_all add: sup_absorb1 sup_absorb2 )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b = b \\<sqinter> c; c \\<sqinter> (b \\<squnion> c) = b;\n     a = b \\<squnion> c; b < b \\<squnion> c\\<rbrakk>\n    \\<Longrightarrow> False", "apply (subgoal_tac \"c \\<sqinter> (b \\<squnion> c) = c\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>b = b \\<sqinter> c; c \\<sqinter> (b \\<squnion> c) = b;\n     a = b \\<squnion> c; b < b \\<squnion> c;\n     c \\<sqinter> (b \\<squnion> c) = c\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>b = b \\<sqinter> c; c \\<sqinter> (b \\<squnion> c) = b;\n     a = b \\<squnion> c; b < b \\<squnion> c\\<rbrakk>\n    \\<Longrightarrow> c \\<sqinter> (b \\<squnion> c) = c", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b = b \\<sqinter> c; c \\<sqinter> (b \\<squnion> c) = b;\n     a = b \\<squnion> c; b < b \\<squnion> c\\<rbrakk>\n    \\<Longrightarrow> c \\<sqinter> (b \\<squnion> c) = c", "apply (subst sup_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b = b \\<sqinter> c; c \\<sqinter> (b \\<squnion> c) = b;\n     a = b \\<squnion> c; b < b \\<squnion> c\\<rbrakk>\n    \\<Longrightarrow> c \\<sqinter> (c \\<squnion> b) = c", "by simp"], ["", "end"], ["", "context modular_lattice begin"], ["", "lemma a_meet_d: \"a \\<sqinter> (d_aux a b c) = (a \\<sqinter> b) \\<squnion> (c \\<sqinter> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sqinter> d_aux a b c = a \\<sqinter> b \\<squnion> c \\<sqinter> a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<sqinter> d_aux a b c = a \\<sqinter> b \\<squnion> c \\<sqinter> a", "have \"a \\<sqinter> (d_aux a b c) = a \\<sqinter> ((a \\<sqinter> b) \\<squnion> (b \\<sqinter> c) \\<squnion> (c \\<sqinter> a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sqinter> d_aux a b c =\n    a \\<sqinter>\n    (a \\<sqinter> b \\<squnion> b \\<sqinter> c \\<squnion> c \\<sqinter> a)", "by (simp add: d_aux_def)"], ["proof (state)\nthis:\n  a \\<sqinter> d_aux a b c =\n  a \\<sqinter>\n  (a \\<sqinter> b \\<squnion> b \\<sqinter> c \\<squnion> c \\<sqinter> a)\n\ngoal (1 subgoal):\n 1. a \\<sqinter> d_aux a b c = a \\<sqinter> b \\<squnion> c \\<sqinter> a", "also"], ["proof (state)\nthis:\n  a \\<sqinter> d_aux a b c =\n  a \\<sqinter>\n  (a \\<sqinter> b \\<squnion> b \\<sqinter> c \\<squnion> c \\<sqinter> a)\n\ngoal (1 subgoal):\n 1. a \\<sqinter> d_aux a b c = a \\<sqinter> b \\<squnion> c \\<sqinter> a", "have \"... = a \\<sqinter> (a \\<sqinter> b \\<squnion> c \\<sqinter> a \\<squnion> b \\<sqinter> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sqinter>\n    (a \\<sqinter> b \\<squnion> b \\<sqinter> c \\<squnion> c \\<sqinter> a) =\n    a \\<sqinter>\n    (a \\<sqinter> b \\<squnion> c \\<sqinter> a \\<squnion> b \\<sqinter> c)", "by (simp add: sup_assoc, simp add: sup_commute)"], ["proof (state)\nthis:\n  a \\<sqinter>\n  (a \\<sqinter> b \\<squnion> b \\<sqinter> c \\<squnion> c \\<sqinter> a) =\n  a \\<sqinter>\n  (a \\<sqinter> b \\<squnion> c \\<sqinter> a \\<squnion> b \\<sqinter> c)\n\ngoal (1 subgoal):\n 1. a \\<sqinter> d_aux a b c = a \\<sqinter> b \\<squnion> c \\<sqinter> a", "also"], ["proof (state)\nthis:\n  a \\<sqinter>\n  (a \\<sqinter> b \\<squnion> b \\<sqinter> c \\<squnion> c \\<sqinter> a) =\n  a \\<sqinter>\n  (a \\<sqinter> b \\<squnion> c \\<sqinter> a \\<squnion> b \\<sqinter> c)\n\ngoal (1 subgoal):\n 1. a \\<sqinter> d_aux a b c = a \\<sqinter> b \\<squnion> c \\<sqinter> a", "have \"... = (a \\<sqinter> b \\<squnion> c \\<sqinter> a) \\<squnion> (a \\<sqinter> (b \\<sqinter> c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sqinter>\n    (a \\<sqinter> b \\<squnion> c \\<sqinter> a \\<squnion> b \\<sqinter> c) =\n    a \\<sqinter> b \\<squnion> c \\<sqinter> a \\<squnion>\n    a \\<sqinter> (b \\<sqinter> c)", "by (simp add: modular)"], ["proof (state)\nthis:\n  a \\<sqinter>\n  (a \\<sqinter> b \\<squnion> c \\<sqinter> a \\<squnion> b \\<sqinter> c) =\n  a \\<sqinter> b \\<squnion> c \\<sqinter> a \\<squnion>\n  a \\<sqinter> (b \\<sqinter> c)\n\ngoal (1 subgoal):\n 1. a \\<sqinter> d_aux a b c = a \\<sqinter> b \\<squnion> c \\<sqinter> a", "also"], ["proof (state)\nthis:\n  a \\<sqinter>\n  (a \\<sqinter> b \\<squnion> c \\<sqinter> a \\<squnion> b \\<sqinter> c) =\n  a \\<sqinter> b \\<squnion> c \\<sqinter> a \\<squnion>\n  a \\<sqinter> (b \\<sqinter> c)\n\ngoal (1 subgoal):\n 1. a \\<sqinter> d_aux a b c = a \\<sqinter> b \\<squnion> c \\<sqinter> a", "have \"... = (a \\<sqinter> b) \\<squnion> (c \\<sqinter> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sqinter> b \\<squnion> c \\<sqinter> a \\<squnion>\n    a \\<sqinter> (b \\<sqinter> c) =\n    a \\<sqinter> b \\<squnion> c \\<sqinter> a", "by (rule antisym, simp_all, rule_tac y = \"a \\<sqinter> b\" in order_trans, simp_all)"], ["proof (state)\nthis:\n  a \\<sqinter> b \\<squnion> c \\<sqinter> a \\<squnion>\n  a \\<sqinter> (b \\<sqinter> c) =\n  a \\<sqinter> b \\<squnion> c \\<sqinter> a\n\ngoal (1 subgoal):\n 1. a \\<sqinter> d_aux a b c = a \\<sqinter> b \\<squnion> c \\<sqinter> a", "finally"], ["proof (chain)\npicking this:\n  a \\<sqinter> d_aux a b c = a \\<sqinter> b \\<squnion> c \\<sqinter> a", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<sqinter> d_aux a b c = a \\<sqinter> b \\<squnion> c \\<sqinter> a\n\ngoal (1 subgoal):\n 1. a \\<sqinter> d_aux a b c = a \\<sqinter> b \\<squnion> c \\<sqinter> a", "by simp"], ["proof (state)\nthis:\n  a \\<sqinter> d_aux a b c = a \\<sqinter> b \\<squnion> c \\<sqinter> a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma b_meet_d: \"b \\<sqinter> (d_aux a b c) = (b \\<sqinter> c) \\<squnion> (a \\<sqinter> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<sqinter> d_aux a b c = b \\<sqinter> c \\<squnion> a \\<sqinter> b", "by (simp add: a_meet_d [THEN sym] d_b_c_a)"], ["", "lemma c_meet_d: \"c \\<sqinter> (d_aux a b c) = (c \\<sqinter> a) \\<squnion> (b \\<sqinter> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<sqinter> d_aux a b c = c \\<sqinter> a \\<squnion> b \\<sqinter> c", "by (simp add: a_meet_d [THEN sym] d_c_a_b)"], ["", "lemma d_less_e: \"no_distrib a b c \\<Longrightarrow> d_aux a b c < e_aux a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_distrib a b c \\<Longrightarrow> d_aux a b c < e_aux a b c", "apply (subst less_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_distrib a b c \\<Longrightarrow>\n    d_aux a b c \\<le> e_aux a b c \\<and> d_aux a b c \\<noteq> e_aux a b c", "apply(case_tac \"d_aux a b c = e_aux a b c\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>no_distrib a b c; d_aux a b c = e_aux a b c\\<rbrakk>\n    \\<Longrightarrow> d_aux a b c \\<le> e_aux a b c \\<and>\n                      d_aux a b c \\<noteq> e_aux a b c\n 2. \\<lbrakk>no_distrib a b c; d_aux a b c \\<noteq> e_aux a b c\\<rbrakk>\n    \\<Longrightarrow> d_aux a b c \\<le> e_aux a b c \\<and>\n                      d_aux a b c \\<noteq> e_aux a b c", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>no_distrib a b c; d_aux a b c = e_aux a b c\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>no_distrib a b c; d_aux a b c \\<noteq> e_aux a b c\\<rbrakk>\n    \\<Longrightarrow> d_aux a b c \\<le> e_aux a b c", "apply (simp add: no_distrib_def a_meet_e [THEN sym] a_meet_d [THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>no_distrib a b c; d_aux a b c \\<noteq> e_aux a b c\\<rbrakk>\n    \\<Longrightarrow> d_aux a b c \\<le> e_aux a b c", "apply (rule_tac y = \"a_aux a b c\" in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>no_distrib a b c; d_aux a b c \\<noteq> e_aux a b c\\<rbrakk>\n    \\<Longrightarrow> d_aux a b c \\<le> a_aux a b c\n 2. \\<lbrakk>no_distrib a b c; d_aux a b c \\<noteq> e_aux a b c\\<rbrakk>\n    \\<Longrightarrow> a_aux a b c \\<le> e_aux a b c", "by simp_all"], ["", "lemma a_meet_b_eq_d: \" d_aux a b c \\<le> e_aux a b c \\<Longrightarrow> a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "assume d_less_e: \" d_aux a b c \\<le> e_aux a b c\""], ["proof (state)\nthis:\n  d_aux a b c \\<le> e_aux a b c\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "have \"(a \\<sqinter> e_aux a b c \\<squnion> d_aux a b c) \\<sqinter> (b \\<sqinter> e_aux a b c \\<squnion> d_aux a b c) = (b \\<sqinter> e_aux a b c \\<squnion>  d_aux a b c) \\<sqinter> (d_aux a b c \\<squnion> a \\<sqinter> e_aux a b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<sqinter> e_aux a b c \\<squnion> d_aux a b c) \\<sqinter>\n    (b \\<sqinter> e_aux a b c \\<squnion> d_aux a b c) =\n    (b \\<sqinter> e_aux a b c \\<squnion> d_aux a b c) \\<sqinter>\n    (d_aux a b c \\<squnion> a \\<sqinter> e_aux a b c)", "by (simp add: inf_commute sup_commute)"], ["proof (state)\nthis:\n  (a \\<sqinter> e_aux a b c \\<squnion> d_aux a b c) \\<sqinter>\n  (b \\<sqinter> e_aux a b c \\<squnion> d_aux a b c) =\n  (b \\<sqinter> e_aux a b c \\<squnion> d_aux a b c) \\<sqinter>\n  (d_aux a b c \\<squnion> a \\<sqinter> e_aux a b c)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "also"], ["proof (state)\nthis:\n  (a \\<sqinter> e_aux a b c \\<squnion> d_aux a b c) \\<sqinter>\n  (b \\<sqinter> e_aux a b c \\<squnion> d_aux a b c) =\n  (b \\<sqinter> e_aux a b c \\<squnion> d_aux a b c) \\<sqinter>\n  (d_aux a b c \\<squnion> a \\<sqinter> e_aux a b c)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "have \"\\<dots> = d_aux a b c \\<squnion> ((b \\<sqinter> e_aux a b c \\<squnion> d_aux a b c) \\<sqinter> (a \\<sqinter> e_aux a b c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b \\<sqinter> e_aux a b c \\<squnion> d_aux a b c) \\<sqinter>\n    (d_aux a b c \\<squnion> a \\<sqinter> e_aux a b c) =\n    d_aux a b c \\<squnion>\n    (b \\<sqinter> e_aux a b c \\<squnion> d_aux a b c) \\<sqinter>\n    (a \\<sqinter> e_aux a b c)", "by (simp add: modular)"], ["proof (state)\nthis:\n  (b \\<sqinter> e_aux a b c \\<squnion> d_aux a b c) \\<sqinter>\n  (d_aux a b c \\<squnion> a \\<sqinter> e_aux a b c) =\n  d_aux a b c \\<squnion>\n  (b \\<sqinter> e_aux a b c \\<squnion> d_aux a b c) \\<sqinter>\n  (a \\<sqinter> e_aux a b c)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "also"], ["proof (state)\nthis:\n  (b \\<sqinter> e_aux a b c \\<squnion> d_aux a b c) \\<sqinter>\n  (d_aux a b c \\<squnion> a \\<sqinter> e_aux a b c) =\n  d_aux a b c \\<squnion>\n  (b \\<sqinter> e_aux a b c \\<squnion> d_aux a b c) \\<sqinter>\n  (a \\<sqinter> e_aux a b c)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "have \"\\<dots> = d_aux a b c \\<squnion> (d_aux a b c \\<squnion> e_aux a b c \\<sqinter> b) \\<sqinter> (a \\<sqinter> e_aux a b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<squnion>\n    (b \\<sqinter> e_aux a b c \\<squnion> d_aux a b c) \\<sqinter>\n    (a \\<sqinter> e_aux a b c) =\n    d_aux a b c \\<squnion>\n    (d_aux a b c \\<squnion> e_aux a b c \\<sqinter> b) \\<sqinter>\n    (a \\<sqinter> e_aux a b c)", "by (simp add: inf_commute sup_commute)"], ["proof (state)\nthis:\n  d_aux a b c \\<squnion>\n  (b \\<sqinter> e_aux a b c \\<squnion> d_aux a b c) \\<sqinter>\n  (a \\<sqinter> e_aux a b c) =\n  d_aux a b c \\<squnion>\n  (d_aux a b c \\<squnion> e_aux a b c \\<sqinter> b) \\<sqinter>\n  (a \\<sqinter> e_aux a b c)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "also"], ["proof (state)\nthis:\n  d_aux a b c \\<squnion>\n  (b \\<sqinter> e_aux a b c \\<squnion> d_aux a b c) \\<sqinter>\n  (a \\<sqinter> e_aux a b c) =\n  d_aux a b c \\<squnion>\n  (d_aux a b c \\<squnion> e_aux a b c \\<sqinter> b) \\<sqinter>\n  (a \\<sqinter> e_aux a b c)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "have \"\\<dots> = d_aux a b c \\<squnion> (e_aux a b c \\<sqinter> (d_aux a b c \\<squnion> b)) \\<sqinter> (a \\<sqinter> e_aux a b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<squnion>\n    (d_aux a b c \\<squnion> e_aux a b c \\<sqinter> b) \\<sqinter>\n    (a \\<sqinter> e_aux a b c) =\n    d_aux a b c \\<squnion>\n    e_aux a b c \\<sqinter> (d_aux a b c \\<squnion> b) \\<sqinter>\n    (a \\<sqinter> e_aux a b c)", "by (cut_tac d_less_e, simp add: modular [THEN sym] less_le)"], ["proof (state)\nthis:\n  d_aux a b c \\<squnion>\n  (d_aux a b c \\<squnion> e_aux a b c \\<sqinter> b) \\<sqinter>\n  (a \\<sqinter> e_aux a b c) =\n  d_aux a b c \\<squnion>\n  e_aux a b c \\<sqinter> (d_aux a b c \\<squnion> b) \\<sqinter>\n  (a \\<sqinter> e_aux a b c)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "also"], ["proof (state)\nthis:\n  d_aux a b c \\<squnion>\n  (d_aux a b c \\<squnion> e_aux a b c \\<sqinter> b) \\<sqinter>\n  (a \\<sqinter> e_aux a b c) =\n  d_aux a b c \\<squnion>\n  e_aux a b c \\<sqinter> (d_aux a b c \\<squnion> b) \\<sqinter>\n  (a \\<sqinter> e_aux a b c)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "have \"\\<dots> =  d_aux a b c \\<squnion> ((a \\<sqinter> e_aux a b c) \\<sqinter> (e_aux a b c \\<sqinter> (b \\<squnion> d_aux a b c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<squnion>\n    e_aux a b c \\<sqinter> (d_aux a b c \\<squnion> b) \\<sqinter>\n    (a \\<sqinter> e_aux a b c) =\n    d_aux a b c \\<squnion>\n    a \\<sqinter> e_aux a b c \\<sqinter>\n    (e_aux a b c \\<sqinter> (b \\<squnion> d_aux a b c))", "by (simp add: inf_commute sup_commute)"], ["proof (state)\nthis:\n  d_aux a b c \\<squnion>\n  e_aux a b c \\<sqinter> (d_aux a b c \\<squnion> b) \\<sqinter>\n  (a \\<sqinter> e_aux a b c) =\n  d_aux a b c \\<squnion>\n  a \\<sqinter> e_aux a b c \\<sqinter>\n  (e_aux a b c \\<sqinter> (b \\<squnion> d_aux a b c))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "also"], ["proof (state)\nthis:\n  d_aux a b c \\<squnion>\n  e_aux a b c \\<sqinter> (d_aux a b c \\<squnion> b) \\<sqinter>\n  (a \\<sqinter> e_aux a b c) =\n  d_aux a b c \\<squnion>\n  a \\<sqinter> e_aux a b c \\<sqinter>\n  (e_aux a b c \\<sqinter> (b \\<squnion> d_aux a b c))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "have \"\\<dots> = d_aux a b c \\<squnion> (a \\<sqinter> e_aux a b c \\<sqinter> (b \\<squnion> d_aux a b c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<squnion>\n    a \\<sqinter> e_aux a b c \\<sqinter>\n    (e_aux a b c \\<sqinter> (b \\<squnion> d_aux a b c)) =\n    d_aux a b c \\<squnion>\n    a \\<sqinter> e_aux a b c \\<sqinter> (b \\<squnion> d_aux a b c)", "by (simp add: inf_assoc)"], ["proof (state)\nthis:\n  d_aux a b c \\<squnion>\n  a \\<sqinter> e_aux a b c \\<sqinter>\n  (e_aux a b c \\<sqinter> (b \\<squnion> d_aux a b c)) =\n  d_aux a b c \\<squnion>\n  a \\<sqinter> e_aux a b c \\<sqinter> (b \\<squnion> d_aux a b c)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "also"], ["proof (state)\nthis:\n  d_aux a b c \\<squnion>\n  a \\<sqinter> e_aux a b c \\<sqinter>\n  (e_aux a b c \\<sqinter> (b \\<squnion> d_aux a b c)) =\n  d_aux a b c \\<squnion>\n  a \\<sqinter> e_aux a b c \\<sqinter> (b \\<squnion> d_aux a b c)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "have \"\\<dots> = d_aux a b c \\<squnion> (a \\<sqinter> e_aux a b c \\<sqinter> (b \\<squnion> (c \\<sqinter> a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<squnion>\n    a \\<sqinter> e_aux a b c \\<sqinter> (b \\<squnion> d_aux a b c) =\n    d_aux a b c \\<squnion>\n    a \\<sqinter> e_aux a b c \\<sqinter> (b \\<squnion> c \\<sqinter> a)", "by (simp add: b_join_d)"], ["proof (state)\nthis:\n  d_aux a b c \\<squnion>\n  a \\<sqinter> e_aux a b c \\<sqinter> (b \\<squnion> d_aux a b c) =\n  d_aux a b c \\<squnion>\n  a \\<sqinter> e_aux a b c \\<sqinter> (b \\<squnion> c \\<sqinter> a)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "also"], ["proof (state)\nthis:\n  d_aux a b c \\<squnion>\n  a \\<sqinter> e_aux a b c \\<sqinter> (b \\<squnion> d_aux a b c) =\n  d_aux a b c \\<squnion>\n  a \\<sqinter> e_aux a b c \\<sqinter> (b \\<squnion> c \\<sqinter> a)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "have \"\\<dots> = d_aux a b c \\<squnion> (a \\<sqinter> (b \\<squnion> c) \\<sqinter> (b \\<squnion> (c \\<sqinter> a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<squnion>\n    a \\<sqinter> e_aux a b c \\<sqinter> (b \\<squnion> c \\<sqinter> a) =\n    d_aux a b c \\<squnion>\n    a \\<sqinter> (b \\<squnion> c) \\<sqinter> (b \\<squnion> c \\<sqinter> a)", "by (simp add: a_meet_e)"], ["proof (state)\nthis:\n  d_aux a b c \\<squnion>\n  a \\<sqinter> e_aux a b c \\<sqinter> (b \\<squnion> c \\<sqinter> a) =\n  d_aux a b c \\<squnion>\n  a \\<sqinter> (b \\<squnion> c) \\<sqinter> (b \\<squnion> c \\<sqinter> a)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "also"], ["proof (state)\nthis:\n  d_aux a b c \\<squnion>\n  a \\<sqinter> e_aux a b c \\<sqinter> (b \\<squnion> c \\<sqinter> a) =\n  d_aux a b c \\<squnion>\n  a \\<sqinter> (b \\<squnion> c) \\<sqinter> (b \\<squnion> c \\<sqinter> a)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "have \"\\<dots> = d_aux a b c \\<squnion> (a \\<sqinter> ((b \\<squnion> c) \\<sqinter> (b \\<squnion> (c \\<sqinter> a))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<squnion>\n    a \\<sqinter> (b \\<squnion> c) \\<sqinter> (b \\<squnion> c \\<sqinter> a) =\n    d_aux a b c \\<squnion>\n    a \\<sqinter> ((b \\<squnion> c) \\<sqinter> (b \\<squnion> c \\<sqinter> a))", "by (simp add: inf_assoc)"], ["proof (state)\nthis:\n  d_aux a b c \\<squnion>\n  a \\<sqinter> (b \\<squnion> c) \\<sqinter> (b \\<squnion> c \\<sqinter> a) =\n  d_aux a b c \\<squnion>\n  a \\<sqinter> ((b \\<squnion> c) \\<sqinter> (b \\<squnion> c \\<sqinter> a))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "also"], ["proof (state)\nthis:\n  d_aux a b c \\<squnion>\n  a \\<sqinter> (b \\<squnion> c) \\<sqinter> (b \\<squnion> c \\<sqinter> a) =\n  d_aux a b c \\<squnion>\n  a \\<sqinter> ((b \\<squnion> c) \\<sqinter> (b \\<squnion> c \\<sqinter> a))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "have \"\\<dots> = d_aux a b c \\<squnion> (a \\<sqinter> (b \\<squnion> ((b \\<squnion> c) \\<sqinter> (c \\<sqinter> a))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<squnion>\n    a \\<sqinter>\n    ((b \\<squnion> c) \\<sqinter> (b \\<squnion> c \\<sqinter> a)) =\n    d_aux a b c \\<squnion>\n    a \\<sqinter> (b \\<squnion> (b \\<squnion> c) \\<sqinter> (c \\<sqinter> a))", "by (simp add: modular)"], ["proof (state)\nthis:\n  d_aux a b c \\<squnion>\n  a \\<sqinter> ((b \\<squnion> c) \\<sqinter> (b \\<squnion> c \\<sqinter> a)) =\n  d_aux a b c \\<squnion>\n  a \\<sqinter> (b \\<squnion> (b \\<squnion> c) \\<sqinter> (c \\<sqinter> a))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "also"], ["proof (state)\nthis:\n  d_aux a b c \\<squnion>\n  a \\<sqinter> ((b \\<squnion> c) \\<sqinter> (b \\<squnion> c \\<sqinter> a)) =\n  d_aux a b c \\<squnion>\n  a \\<sqinter> (b \\<squnion> (b \\<squnion> c) \\<sqinter> (c \\<sqinter> a))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "have \"\\<dots> = d_aux a b c \\<squnion> (a \\<sqinter> (b \\<squnion> (c \\<sqinter> a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<squnion>\n    a \\<sqinter>\n    (b \\<squnion> (b \\<squnion> c) \\<sqinter> (c \\<sqinter> a)) =\n    d_aux a b c \\<squnion> a \\<sqinter> (b \\<squnion> c \\<sqinter> a)", "by (simp add: inf_absorb2)"], ["proof (state)\nthis:\n  d_aux a b c \\<squnion>\n  a \\<sqinter> (b \\<squnion> (b \\<squnion> c) \\<sqinter> (c \\<sqinter> a)) =\n  d_aux a b c \\<squnion> a \\<sqinter> (b \\<squnion> c \\<sqinter> a)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "also"], ["proof (state)\nthis:\n  d_aux a b c \\<squnion>\n  a \\<sqinter> (b \\<squnion> (b \\<squnion> c) \\<sqinter> (c \\<sqinter> a)) =\n  d_aux a b c \\<squnion> a \\<sqinter> (b \\<squnion> c \\<sqinter> a)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "have \"\\<dots> = d_aux a b c \\<squnion> (a \\<sqinter> ((c \\<sqinter> a) \\<squnion> b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<squnion> a \\<sqinter> (b \\<squnion> c \\<sqinter> a) =\n    d_aux a b c \\<squnion> a \\<sqinter> (c \\<sqinter> a \\<squnion> b)", "by (simp add: sup_commute inf_commute)"], ["proof (state)\nthis:\n  d_aux a b c \\<squnion> a \\<sqinter> (b \\<squnion> c \\<sqinter> a) =\n  d_aux a b c \\<squnion> a \\<sqinter> (c \\<sqinter> a \\<squnion> b)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "also"], ["proof (state)\nthis:\n  d_aux a b c \\<squnion> a \\<sqinter> (b \\<squnion> c \\<sqinter> a) =\n  d_aux a b c \\<squnion> a \\<sqinter> (c \\<sqinter> a \\<squnion> b)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "have \"\\<dots> = d_aux a b c \\<squnion> ((c \\<sqinter> a) \\<squnion> (a \\<sqinter> b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<squnion> a \\<sqinter> (c \\<sqinter> a \\<squnion> b) =\n    d_aux a b c \\<squnion> (c \\<sqinter> a \\<squnion> a \\<sqinter> b)", "by (simp add: modular)"], ["proof (state)\nthis:\n  d_aux a b c \\<squnion> a \\<sqinter> (c \\<sqinter> a \\<squnion> b) =\n  d_aux a b c \\<squnion> (c \\<sqinter> a \\<squnion> a \\<sqinter> b)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "also"], ["proof (state)\nthis:\n  d_aux a b c \\<squnion> a \\<sqinter> (c \\<sqinter> a \\<squnion> b) =\n  d_aux a b c \\<squnion> (c \\<sqinter> a \\<squnion> a \\<sqinter> b)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "have \"\\<dots> = d_aux a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<squnion> (c \\<sqinter> a \\<squnion> a \\<sqinter> b) =\n    d_aux a b c", "by (rule antisym, simp_all add: d_aux_def)"], ["proof (state)\nthis:\n  d_aux a b c \\<squnion> (c \\<sqinter> a \\<squnion> a \\<sqinter> b) =\n  d_aux a b c\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "finally"], ["proof (chain)\npicking this:\n  (a \\<sqinter> e_aux a b c \\<squnion> d_aux a b c) \\<sqinter>\n  (b \\<sqinter> e_aux a b c \\<squnion> d_aux a b c) =\n  d_aux a b c", "show ?thesis"], ["proof (prove)\nusing this:\n  (a \\<sqinter> e_aux a b c \\<squnion> d_aux a b c) \\<sqinter>\n  (b \\<sqinter> e_aux a b c \\<squnion> d_aux a b c) =\n  d_aux a b c\n\ngoal (1 subgoal):\n 1. a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c", "by (simp add: a_aux_def b_aux_def)"], ["proof (state)\nthis:\n  a_aux a b c \\<sqinter> b_aux a b c = d_aux a b c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma b_meet_c_eq_d: \" d_aux a b c \\<le> e_aux a b c \\<Longrightarrow> b_aux a b c \\<sqinter> c_aux a b c = d_aux a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    b_aux a b c \\<sqinter> c_aux a b c = d_aux a b c", "apply (subst b_a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux b c a \\<sqinter> c_aux a b c = d_aux a b c", "apply (subgoal_tac \"c_aux a b c = b_aux b c a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>d_aux a b c \\<le> e_aux a b c;\n     c_aux a b c = b_aux b c a\\<rbrakk>\n    \\<Longrightarrow> a_aux b c a \\<sqinter> c_aux a b c = d_aux a b c\n 2. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    c_aux a b c = b_aux b c a", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>d_aux a b c \\<le> e_aux a b c;\n     c_aux a b c = b_aux b c a\\<rbrakk>\n    \\<Longrightarrow> a_aux b c a \\<sqinter> b_aux b c a = d_aux a b c\n 2. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    c_aux a b c = b_aux b c a", "apply (subst a_meet_b_eq_d)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>d_aux a b c \\<le> e_aux a b c;\n     c_aux a b c = b_aux b c a\\<rbrakk>\n    \\<Longrightarrow> d_aux b c a \\<le> e_aux b c a\n 2. \\<lbrakk>d_aux a b c \\<le> e_aux a b c;\n     c_aux a b c = b_aux b c a\\<rbrakk>\n    \\<Longrightarrow> d_aux b c a = d_aux a b c\n 3. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    c_aux a b c = b_aux b c a", "by (simp_all add: c_aux_def b_aux_def d_b_c_a e_b_c_a)"], ["", "lemma c_meet_a_eq_d: \"d_aux a b c \\<le> e_aux a b c \\<Longrightarrow> c_aux a b c \\<sqinter> a_aux a b c = d_aux a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    c_aux a b c \\<sqinter> a_aux a b c = d_aux a b c", "apply (subst c_a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux c a b \\<sqinter> a_aux a b c = d_aux a b c", "apply (subgoal_tac \"a_aux a b c = b_aux c a b\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>d_aux a b c \\<le> e_aux a b c;\n     a_aux a b c = b_aux c a b\\<rbrakk>\n    \\<Longrightarrow> a_aux c a b \\<sqinter> a_aux a b c = d_aux a b c\n 2. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c = b_aux c a b", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>d_aux a b c \\<le> e_aux a b c;\n     a_aux a b c = b_aux c a b\\<rbrakk>\n    \\<Longrightarrow> a_aux c a b \\<sqinter> b_aux c a b = d_aux a b c\n 2. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c = b_aux c a b", "apply (subst a_meet_b_eq_d)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>d_aux a b c \\<le> e_aux a b c;\n     a_aux a b c = b_aux c a b\\<rbrakk>\n    \\<Longrightarrow> d_aux c a b \\<le> e_aux c a b\n 2. \\<lbrakk>d_aux a b c \\<le> e_aux a b c;\n     a_aux a b c = b_aux c a b\\<rbrakk>\n    \\<Longrightarrow> d_aux c a b = d_aux a b c\n 3. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c = b_aux c a b", "by (simp_all add: a_aux_def b_aux_def d_b_c_a e_b_c_a)"], ["", "lemma a_def_equiv: \"d_aux a b c \\<le> e_aux a b c \\<Longrightarrow> a_aux a b c = (a \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c = (a \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c", "apply (simp add: a_aux_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a \\<sqinter> e_aux a b c \\<squnion> d_aux a b c =\n    (a \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c", "apply (subst inf_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    e_aux a b c \\<sqinter> a \\<squnion> d_aux a b c =\n    (a \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c", "apply (subst sup_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    d_aux a b c \\<squnion> e_aux a b c \\<sqinter> a =\n    (a \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c", "apply (simp add: modular)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    e_aux a b c \\<sqinter> (d_aux a b c \\<squnion> a) =\n    (a \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c", "by (simp add: inf_commute sup_commute)"], ["", "lemma b_def_equiv: \"d_aux a b c \\<le> e_aux a b c \\<Longrightarrow> b_aux a b c = (b \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    b_aux a b c = (b \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c", "apply (cut_tac a = b and b = c and c = a in a_def_equiv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    d_aux b c a \\<le> e_aux b c a\n 2. \\<lbrakk>d_aux a b c \\<le> e_aux a b c;\n     a_aux b c a =\n     (b \\<squnion> d_aux b c a) \\<sqinter> e_aux b c a\\<rbrakk>\n    \\<Longrightarrow> b_aux a b c =\n                      (b \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c", "by (simp_all add: d_b_c_a e_b_c_a b_a)"], ["", "lemma c_def_equiv: \"d_aux a b c \\<le> e_aux a b c \\<Longrightarrow> c_aux a b c = (c \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    c_aux a b c = (c \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c", "apply (cut_tac a = c and b = a and c = b in a_def_equiv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    d_aux c a b \\<le> e_aux c a b\n 2. \\<lbrakk>d_aux a b c \\<le> e_aux a b c;\n     a_aux c a b =\n     (c \\<squnion> d_aux c a b) \\<sqinter> e_aux c a b\\<rbrakk>\n    \\<Longrightarrow> c_aux a b c =\n                      (c \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c", "by (simp_all add: d_c_a_b e_c_a_b c_a)"], ["", "lemma a_join_b_eq_e: \"d_aux a b c \\<le> e_aux a b c \\<Longrightarrow> a_aux a b c \\<squnion> b_aux a b c = e_aux a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "assume d_less_e: \" d_aux a b c \\<le> e_aux a b c\""], ["proof (state)\nthis:\n  d_aux a b c \\<le> e_aux a b c\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "have \"((a \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c) \\<squnion> ((b \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c) = ((b \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c) \\<squnion> (e_aux a b c \\<sqinter> (a \\<squnion> d_aux a b c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c \\<squnion>\n    (b \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c =\n    (b \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c \\<squnion>\n    e_aux a b c \\<sqinter> (a \\<squnion> d_aux a b c)", "by (simp add: inf_commute sup_commute)"], ["proof (state)\nthis:\n  (a \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c \\<squnion>\n  (b \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c =\n  (b \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c \\<squnion>\n  e_aux a b c \\<sqinter> (a \\<squnion> d_aux a b c)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "also"], ["proof (state)\nthis:\n  (a \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c \\<squnion>\n  (b \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c =\n  (b \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c \\<squnion>\n  e_aux a b c \\<sqinter> (a \\<squnion> d_aux a b c)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "have \"\\<dots> = e_aux a b c \\<sqinter> (((b \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c) \\<squnion> (a \\<squnion> d_aux a b c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c \\<squnion>\n    e_aux a b c \\<sqinter> (a \\<squnion> d_aux a b c) =\n    e_aux a b c \\<sqinter>\n    ((b \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c \\<squnion>\n     (a \\<squnion> d_aux a b c))", "by (simp add: modular)"], ["proof (state)\nthis:\n  (b \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c \\<squnion>\n  e_aux a b c \\<sqinter> (a \\<squnion> d_aux a b c) =\n  e_aux a b c \\<sqinter>\n  ((b \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c \\<squnion>\n   (a \\<squnion> d_aux a b c))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "also"], ["proof (state)\nthis:\n  (b \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c \\<squnion>\n  e_aux a b c \\<sqinter> (a \\<squnion> d_aux a b c) =\n  e_aux a b c \\<sqinter>\n  ((b \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c \\<squnion>\n   (a \\<squnion> d_aux a b c))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "have \"\\<dots> = e_aux a b c \\<sqinter> ((e_aux a b c \\<sqinter> (d_aux a b c \\<squnion> b)) \\<squnion> (a \\<squnion> d_aux a b c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_aux a b c \\<sqinter>\n    ((b \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c \\<squnion>\n     (a \\<squnion> d_aux a b c)) =\n    e_aux a b c \\<sqinter>\n    (e_aux a b c \\<sqinter> (d_aux a b c \\<squnion> b) \\<squnion>\n     (a \\<squnion> d_aux a b c))", "by (simp add: inf_commute sup_commute)"], ["proof (state)\nthis:\n  e_aux a b c \\<sqinter>\n  ((b \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c \\<squnion>\n   (a \\<squnion> d_aux a b c)) =\n  e_aux a b c \\<sqinter>\n  (e_aux a b c \\<sqinter> (d_aux a b c \\<squnion> b) \\<squnion>\n   (a \\<squnion> d_aux a b c))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "also"], ["proof (state)\nthis:\n  e_aux a b c \\<sqinter>\n  ((b \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c \\<squnion>\n   (a \\<squnion> d_aux a b c)) =\n  e_aux a b c \\<sqinter>\n  (e_aux a b c \\<sqinter> (d_aux a b c \\<squnion> b) \\<squnion>\n   (a \\<squnion> d_aux a b c))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "have \"\\<dots> = e_aux a b c \\<sqinter> ((d_aux a b c \\<squnion> (e_aux a b c \\<sqinter> b)) \\<squnion> (a \\<squnion> d_aux a b c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_aux a b c \\<sqinter>\n    (e_aux a b c \\<sqinter> (d_aux a b c \\<squnion> b) \\<squnion>\n     (a \\<squnion> d_aux a b c)) =\n    e_aux a b c \\<sqinter>\n    (d_aux a b c \\<squnion> e_aux a b c \\<sqinter> b \\<squnion>\n     (a \\<squnion> d_aux a b c))", "by (cut_tac d_less_e, simp add: modular)"], ["proof (state)\nthis:\n  e_aux a b c \\<sqinter>\n  (e_aux a b c \\<sqinter> (d_aux a b c \\<squnion> b) \\<squnion>\n   (a \\<squnion> d_aux a b c)) =\n  e_aux a b c \\<sqinter>\n  (d_aux a b c \\<squnion> e_aux a b c \\<sqinter> b \\<squnion>\n   (a \\<squnion> d_aux a b c))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "also"], ["proof (state)\nthis:\n  e_aux a b c \\<sqinter>\n  (e_aux a b c \\<sqinter> (d_aux a b c \\<squnion> b) \\<squnion>\n   (a \\<squnion> d_aux a b c)) =\n  e_aux a b c \\<sqinter>\n  (d_aux a b c \\<squnion> e_aux a b c \\<sqinter> b \\<squnion>\n   (a \\<squnion> d_aux a b c))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "have \"\\<dots> = e_aux a b c \\<sqinter> ((a \\<squnion> d_aux a b c) \\<squnion> (d_aux a b c \\<squnion> (b \\<sqinter> e_aux a b c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_aux a b c \\<sqinter>\n    (d_aux a b c \\<squnion> e_aux a b c \\<sqinter> b \\<squnion>\n     (a \\<squnion> d_aux a b c)) =\n    e_aux a b c \\<sqinter>\n    (a \\<squnion> d_aux a b c \\<squnion>\n     (d_aux a b c \\<squnion> b \\<sqinter> e_aux a b c))", "by (simp add: inf_commute sup_commute)"], ["proof (state)\nthis:\n  e_aux a b c \\<sqinter>\n  (d_aux a b c \\<squnion> e_aux a b c \\<sqinter> b \\<squnion>\n   (a \\<squnion> d_aux a b c)) =\n  e_aux a b c \\<sqinter>\n  (a \\<squnion> d_aux a b c \\<squnion>\n   (d_aux a b c \\<squnion> b \\<sqinter> e_aux a b c))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "also"], ["proof (state)\nthis:\n  e_aux a b c \\<sqinter>\n  (d_aux a b c \\<squnion> e_aux a b c \\<sqinter> b \\<squnion>\n   (a \\<squnion> d_aux a b c)) =\n  e_aux a b c \\<sqinter>\n  (a \\<squnion> d_aux a b c \\<squnion>\n   (d_aux a b c \\<squnion> b \\<sqinter> e_aux a b c))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "have \"\\<dots> = e_aux a b c \\<sqinter> (a \\<squnion> d_aux a b c \\<squnion> (b \\<sqinter> e_aux a b c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_aux a b c \\<sqinter>\n    (a \\<squnion> d_aux a b c \\<squnion>\n     (d_aux a b c \\<squnion> b \\<sqinter> e_aux a b c)) =\n    e_aux a b c \\<sqinter>\n    (a \\<squnion> d_aux a b c \\<squnion> b \\<sqinter> e_aux a b c)", "by (simp add: sup_assoc)"], ["proof (state)\nthis:\n  e_aux a b c \\<sqinter>\n  (a \\<squnion> d_aux a b c \\<squnion>\n   (d_aux a b c \\<squnion> b \\<sqinter> e_aux a b c)) =\n  e_aux a b c \\<sqinter>\n  (a \\<squnion> d_aux a b c \\<squnion> b \\<sqinter> e_aux a b c)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "also"], ["proof (state)\nthis:\n  e_aux a b c \\<sqinter>\n  (a \\<squnion> d_aux a b c \\<squnion>\n   (d_aux a b c \\<squnion> b \\<sqinter> e_aux a b c)) =\n  e_aux a b c \\<sqinter>\n  (a \\<squnion> d_aux a b c \\<squnion> b \\<sqinter> e_aux a b c)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "have \"\\<dots> = e_aux a b c \\<sqinter> (a \\<squnion> d_aux a b c \\<squnion> (b \\<sqinter> (c \\<squnion> a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_aux a b c \\<sqinter>\n    (a \\<squnion> d_aux a b c \\<squnion> b \\<sqinter> e_aux a b c) =\n    e_aux a b c \\<sqinter>\n    (a \\<squnion> d_aux a b c \\<squnion> b \\<sqinter> (c \\<squnion> a))", "by (simp add: b_meet_e)"], ["proof (state)\nthis:\n  e_aux a b c \\<sqinter>\n  (a \\<squnion> d_aux a b c \\<squnion> b \\<sqinter> e_aux a b c) =\n  e_aux a b c \\<sqinter>\n  (a \\<squnion> d_aux a b c \\<squnion> b \\<sqinter> (c \\<squnion> a))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "also"], ["proof (state)\nthis:\n  e_aux a b c \\<sqinter>\n  (a \\<squnion> d_aux a b c \\<squnion> b \\<sqinter> e_aux a b c) =\n  e_aux a b c \\<sqinter>\n  (a \\<squnion> d_aux a b c \\<squnion> b \\<sqinter> (c \\<squnion> a))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "have \"\\<dots> = e_aux a b c \\<sqinter> (a \\<squnion> (b \\<sqinter> c) \\<squnion> (b \\<sqinter> (c \\<squnion> a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_aux a b c \\<sqinter>\n    (a \\<squnion> d_aux a b c \\<squnion> b \\<sqinter> (c \\<squnion> a)) =\n    e_aux a b c \\<sqinter>\n    (a \\<squnion> b \\<sqinter> c \\<squnion> b \\<sqinter> (c \\<squnion> a))", "by (simp add: a_join_d)"], ["proof (state)\nthis:\n  e_aux a b c \\<sqinter>\n  (a \\<squnion> d_aux a b c \\<squnion> b \\<sqinter> (c \\<squnion> a)) =\n  e_aux a b c \\<sqinter>\n  (a \\<squnion> b \\<sqinter> c \\<squnion> b \\<sqinter> (c \\<squnion> a))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "also"], ["proof (state)\nthis:\n  e_aux a b c \\<sqinter>\n  (a \\<squnion> d_aux a b c \\<squnion> b \\<sqinter> (c \\<squnion> a)) =\n  e_aux a b c \\<sqinter>\n  (a \\<squnion> b \\<sqinter> c \\<squnion> b \\<sqinter> (c \\<squnion> a))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "have \"\\<dots> = e_aux a b c \\<sqinter> (a \\<squnion> ((b \\<sqinter> c) \\<squnion> (b \\<sqinter> (c \\<squnion> a))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_aux a b c \\<sqinter>\n    (a \\<squnion> b \\<sqinter> c \\<squnion> b \\<sqinter> (c \\<squnion> a)) =\n    e_aux a b c \\<sqinter>\n    (a \\<squnion> (b \\<sqinter> c \\<squnion> b \\<sqinter> (c \\<squnion> a)))", "by (simp add: sup_assoc)"], ["proof (state)\nthis:\n  e_aux a b c \\<sqinter>\n  (a \\<squnion> b \\<sqinter> c \\<squnion> b \\<sqinter> (c \\<squnion> a)) =\n  e_aux a b c \\<sqinter>\n  (a \\<squnion> (b \\<sqinter> c \\<squnion> b \\<sqinter> (c \\<squnion> a)))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "also"], ["proof (state)\nthis:\n  e_aux a b c \\<sqinter>\n  (a \\<squnion> b \\<sqinter> c \\<squnion> b \\<sqinter> (c \\<squnion> a)) =\n  e_aux a b c \\<sqinter>\n  (a \\<squnion> (b \\<sqinter> c \\<squnion> b \\<sqinter> (c \\<squnion> a)))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "have \"\\<dots> = e_aux a b c \\<sqinter> (a \\<squnion> (b \\<sqinter> ((b \\<sqinter> c) \\<squnion> (c \\<squnion> a))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_aux a b c \\<sqinter>\n    (a \\<squnion>\n     (b \\<sqinter> c \\<squnion> b \\<sqinter> (c \\<squnion> a))) =\n    e_aux a b c \\<sqinter>\n    (a \\<squnion> b \\<sqinter> (b \\<sqinter> c \\<squnion> (c \\<squnion> a)))", "by (simp add: modular)"], ["proof (state)\nthis:\n  e_aux a b c \\<sqinter>\n  (a \\<squnion> (b \\<sqinter> c \\<squnion> b \\<sqinter> (c \\<squnion> a))) =\n  e_aux a b c \\<sqinter>\n  (a \\<squnion> b \\<sqinter> (b \\<sqinter> c \\<squnion> (c \\<squnion> a)))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "also"], ["proof (state)\nthis:\n  e_aux a b c \\<sqinter>\n  (a \\<squnion> (b \\<sqinter> c \\<squnion> b \\<sqinter> (c \\<squnion> a))) =\n  e_aux a b c \\<sqinter>\n  (a \\<squnion> b \\<sqinter> (b \\<sqinter> c \\<squnion> (c \\<squnion> a)))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "have \"\\<dots> = e_aux a b c \\<sqinter> (a \\<squnion> (b \\<sqinter> (c \\<squnion> a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_aux a b c \\<sqinter>\n    (a \\<squnion>\n     b \\<sqinter> (b \\<sqinter> c \\<squnion> (c \\<squnion> a))) =\n    e_aux a b c \\<sqinter> (a \\<squnion> b \\<sqinter> (c \\<squnion> a))", "by (simp add: sup_absorb2)"], ["proof (state)\nthis:\n  e_aux a b c \\<sqinter>\n  (a \\<squnion> b \\<sqinter> (b \\<sqinter> c \\<squnion> (c \\<squnion> a))) =\n  e_aux a b c \\<sqinter> (a \\<squnion> b \\<sqinter> (c \\<squnion> a))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "also"], ["proof (state)\nthis:\n  e_aux a b c \\<sqinter>\n  (a \\<squnion> b \\<sqinter> (b \\<sqinter> c \\<squnion> (c \\<squnion> a))) =\n  e_aux a b c \\<sqinter> (a \\<squnion> b \\<sqinter> (c \\<squnion> a))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "have \"\\<dots> = e_aux a b c \\<sqinter> (a \\<squnion> ((c \\<squnion> a) \\<sqinter> b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_aux a b c \\<sqinter> (a \\<squnion> b \\<sqinter> (c \\<squnion> a)) =\n    e_aux a b c \\<sqinter> (a \\<squnion> (c \\<squnion> a) \\<sqinter> b)", "by (simp add: sup_commute inf_commute)"], ["proof (state)\nthis:\n  e_aux a b c \\<sqinter> (a \\<squnion> b \\<sqinter> (c \\<squnion> a)) =\n  e_aux a b c \\<sqinter> (a \\<squnion> (c \\<squnion> a) \\<sqinter> b)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "also"], ["proof (state)\nthis:\n  e_aux a b c \\<sqinter> (a \\<squnion> b \\<sqinter> (c \\<squnion> a)) =\n  e_aux a b c \\<sqinter> (a \\<squnion> (c \\<squnion> a) \\<sqinter> b)\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "have \"\\<dots> = e_aux a b c \\<sqinter> ((c \\<squnion> a) \\<sqinter> (a \\<squnion> b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_aux a b c \\<sqinter> (a \\<squnion> (c \\<squnion> a) \\<sqinter> b) =\n    e_aux a b c \\<sqinter> ((c \\<squnion> a) \\<sqinter> (a \\<squnion> b))", "by (simp add: modular)"], ["proof (state)\nthis:\n  e_aux a b c \\<sqinter> (a \\<squnion> (c \\<squnion> a) \\<sqinter> b) =\n  e_aux a b c \\<sqinter> ((c \\<squnion> a) \\<sqinter> (a \\<squnion> b))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "also"], ["proof (state)\nthis:\n  e_aux a b c \\<sqinter> (a \\<squnion> (c \\<squnion> a) \\<sqinter> b) =\n  e_aux a b c \\<sqinter> ((c \\<squnion> a) \\<sqinter> (a \\<squnion> b))\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "have \"\\<dots> = e_aux a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_aux a b c \\<sqinter> ((c \\<squnion> a) \\<sqinter> (a \\<squnion> b)) =\n    e_aux a b c", "by (rule antisym, simp_all, simp_all add: e_aux_def)"], ["proof (state)\nthis:\n  e_aux a b c \\<sqinter> ((c \\<squnion> a) \\<sqinter> (a \\<squnion> b)) =\n  e_aux a b c\n\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "finally"], ["proof (chain)\npicking this:\n  (a \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c \\<squnion>\n  (b \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c =\n  e_aux a b c", "show ?thesis"], ["proof (prove)\nusing this:\n  (a \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c \\<squnion>\n  (b \\<squnion> d_aux a b c) \\<sqinter> e_aux a b c =\n  e_aux a b c\n\ngoal (1 subgoal):\n 1. a_aux a b c \\<squnion> b_aux a b c = e_aux a b c", "by (cut_tac d_less_e, simp add: a_def_equiv b_def_equiv)"], ["proof (state)\nthis:\n  a_aux a b c \\<squnion> b_aux a b c = e_aux a b c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma b_join_c_eq_e: \" d_aux a b c <= e_aux a b c \\<Longrightarrow> b_aux a b c \\<squnion> c_aux a b c = e_aux a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    b_aux a b c \\<squnion> c_aux a b c = e_aux a b c", "apply (subst b_a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux b c a \\<squnion> c_aux a b c = e_aux a b c", "apply (subgoal_tac \"c_aux a b c = b_aux b c a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>d_aux a b c \\<le> e_aux a b c;\n     c_aux a b c = b_aux b c a\\<rbrakk>\n    \\<Longrightarrow> a_aux b c a \\<squnion> c_aux a b c = e_aux a b c\n 2. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    c_aux a b c = b_aux b c a", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>d_aux a b c \\<le> e_aux a b c;\n     c_aux a b c = b_aux b c a\\<rbrakk>\n    \\<Longrightarrow> a_aux b c a \\<squnion> b_aux b c a = e_aux a b c\n 2. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    c_aux a b c = b_aux b c a", "apply (subst a_join_b_eq_e)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>d_aux a b c \\<le> e_aux a b c;\n     c_aux a b c = b_aux b c a\\<rbrakk>\n    \\<Longrightarrow> d_aux b c a \\<le> e_aux b c a\n 2. \\<lbrakk>d_aux a b c \\<le> e_aux a b c;\n     c_aux a b c = b_aux b c a\\<rbrakk>\n    \\<Longrightarrow> e_aux b c a = e_aux a b c\n 3. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    c_aux a b c = b_aux b c a", "by (simp_all add: c_aux_def b_aux_def d_b_c_a e_b_c_a)"], ["", "lemma c_join_a_eq_e: \"d_aux a b c <= e_aux a b c \\<Longrightarrow> c_aux a b c \\<squnion> a_aux a b c = e_aux a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    c_aux a b c \\<squnion> a_aux a b c = e_aux a b c", "apply (subst c_a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux c a b \\<squnion> a_aux a b c = e_aux a b c", "apply (subgoal_tac \"a_aux a b c = b_aux c a b\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>d_aux a b c \\<le> e_aux a b c;\n     a_aux a b c = b_aux c a b\\<rbrakk>\n    \\<Longrightarrow> a_aux c a b \\<squnion> a_aux a b c = e_aux a b c\n 2. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c = b_aux c a b", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>d_aux a b c \\<le> e_aux a b c;\n     a_aux a b c = b_aux c a b\\<rbrakk>\n    \\<Longrightarrow> a_aux c a b \\<squnion> b_aux c a b = e_aux a b c\n 2. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c = b_aux c a b", "apply (subst a_join_b_eq_e)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>d_aux a b c \\<le> e_aux a b c;\n     a_aux a b c = b_aux c a b\\<rbrakk>\n    \\<Longrightarrow> d_aux c a b \\<le> e_aux c a b\n 2. \\<lbrakk>d_aux a b c \\<le> e_aux a b c;\n     a_aux a b c = b_aux c a b\\<rbrakk>\n    \\<Longrightarrow> e_aux c a b = e_aux a b c\n 3. d_aux a b c \\<le> e_aux a b c \\<Longrightarrow>\n    a_aux a b c = b_aux c a b", "by (simp_all add: a_aux_def b_aux_def d_b_c_a e_b_c_a)"], ["", "lemma \"no_distrib a b c \\<Longrightarrow> incomp a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_distrib a b c \\<Longrightarrow> incomp a b", "apply (simp add: no_distrib_def incomp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sqinter> b \\<squnion> c \\<sqinter> a\n    < a \\<sqinter> (b \\<squnion> c) \\<Longrightarrow>\n    \\<not> a \\<le> b \\<and> \\<not> b \\<le> a", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<sqinter> b \\<squnion> c \\<sqinter> a\n             < a \\<sqinter> (b \\<squnion> c);\n     a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>a \\<sqinter> b \\<squnion> c \\<sqinter> a\n             < a \\<sqinter> (b \\<squnion> c);\n     b \\<le> a\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp add: inf_absorb1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<squnion> c \\<sqinter> a < a \\<sqinter> (b \\<squnion> c);\n     a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>a \\<sqinter> b \\<squnion> c \\<sqinter> a\n             < a \\<sqinter> (b \\<squnion> c);\n     b \\<le> a\\<rbrakk>\n    \\<Longrightarrow> False", "apply (subgoal_tac \"a \\<squnion> c \\<sqinter> a = a \\<and> a \\<sqinter> (b \\<squnion> c) = a\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>a \\<squnion> c \\<sqinter> a < a \\<sqinter> (b \\<squnion> c);\n     a \\<le> b;\n     a \\<squnion> c \\<sqinter> a = a \\<and>\n     a \\<sqinter> (b \\<squnion> c) = a\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>a \\<squnion> c \\<sqinter> a < a \\<sqinter> (b \\<squnion> c);\n     a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> a \\<squnion> c \\<sqinter> a = a \\<and>\n                      a \\<sqinter> (b \\<squnion> c) = a\n 3. \\<lbrakk>a \\<sqinter> b \\<squnion> c \\<sqinter> a\n             < a \\<sqinter> (b \\<squnion> c);\n     b \\<le> a\\<rbrakk>\n    \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<squnion> c \\<sqinter> a < a \\<sqinter> (b \\<squnion> c);\n     a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> a \\<squnion> c \\<sqinter> a = a \\<and>\n                      a \\<sqinter> (b \\<squnion> c) = a\n 2. \\<lbrakk>a \\<sqinter> b \\<squnion> c \\<sqinter> a\n             < a \\<sqinter> (b \\<squnion> c);\n     b \\<le> a\\<rbrakk>\n    \\<Longrightarrow> False", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>a \\<squnion> c \\<sqinter> a < a \\<sqinter> (b \\<squnion> c);\n     a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> a \\<squnion> c \\<sqinter> a = a\n 2. \\<lbrakk>a \\<squnion> c \\<sqinter> a < a \\<sqinter> (b \\<squnion> c);\n     a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> a \\<sqinter> (b \\<squnion> c) = a\n 3. \\<lbrakk>a \\<sqinter> b \\<squnion> c \\<sqinter> a\n             < a \\<sqinter> (b \\<squnion> c);\n     b \\<le> a\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule antisym)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>a \\<squnion> c \\<sqinter> a < a \\<sqinter> (b \\<squnion> c);\n     a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> a \\<squnion> c \\<sqinter> a \\<le> a\n 2. \\<lbrakk>a \\<squnion> c \\<sqinter> a < a \\<sqinter> (b \\<squnion> c);\n     a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> a \\<le> a \\<squnion> c \\<sqinter> a\n 3. \\<lbrakk>a \\<squnion> c \\<sqinter> a < a \\<sqinter> (b \\<squnion> c);\n     a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> a \\<sqinter> (b \\<squnion> c) = a\n 4. \\<lbrakk>a \\<sqinter> b \\<squnion> c \\<sqinter> a\n             < a \\<sqinter> (b \\<squnion> c);\n     b \\<le> a\\<rbrakk>\n    \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>a \\<squnion> c \\<sqinter> a < a \\<sqinter> (b \\<squnion> c);\n     a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> a \\<le> a \\<squnion> c \\<sqinter> a\n 2. \\<lbrakk>a \\<squnion> c \\<sqinter> a < a \\<sqinter> (b \\<squnion> c);\n     a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> a \\<sqinter> (b \\<squnion> c) = a\n 3. \\<lbrakk>a \\<sqinter> b \\<squnion> c \\<sqinter> a\n             < a \\<sqinter> (b \\<squnion> c);\n     b \\<le> a\\<rbrakk>\n    \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<squnion> c \\<sqinter> a < a \\<sqinter> (b \\<squnion> c);\n     a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> a \\<sqinter> (b \\<squnion> c) = a\n 2. \\<lbrakk>a \\<sqinter> b \\<squnion> c \\<sqinter> a\n             < a \\<sqinter> (b \\<squnion> c);\n     b \\<le> a\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule antisym)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>a \\<squnion> c \\<sqinter> a < a \\<sqinter> (b \\<squnion> c);\n     a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> a \\<sqinter> (b \\<squnion> c) \\<le> a\n 2. \\<lbrakk>a \\<squnion> c \\<sqinter> a < a \\<sqinter> (b \\<squnion> c);\n     a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> a \\<le> a \\<sqinter> (b \\<squnion> c)\n 3. \\<lbrakk>a \\<sqinter> b \\<squnion> c \\<sqinter> a\n             < a \\<sqinter> (b \\<squnion> c);\n     b \\<le> a\\<rbrakk>\n    \\<Longrightarrow> False", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<squnion> c \\<sqinter> a < a \\<sqinter> (b \\<squnion> c);\n     a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> a \\<le> b \\<squnion> c\n 2. \\<lbrakk>a \\<sqinter> b \\<squnion> c \\<sqinter> a\n             < a \\<sqinter> (b \\<squnion> c);\n     b \\<le> a\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule_tac y = b in order_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>a \\<squnion> c \\<sqinter> a < a \\<sqinter> (b \\<squnion> c);\n     a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> a \\<le> b\n 2. \\<lbrakk>a \\<squnion> c \\<sqinter> a < a \\<sqinter> (b \\<squnion> c);\n     a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> b \\<le> b \\<squnion> c\n 3. \\<lbrakk>a \\<sqinter> b \\<squnion> c \\<sqinter> a\n             < a \\<sqinter> (b \\<squnion> c);\n     b \\<le> a\\<rbrakk>\n    \\<Longrightarrow> False", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<sqinter> b \\<squnion> c \\<sqinter> a\n             < a \\<sqinter> (b \\<squnion> c);\n     b \\<le> a\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp add: inf_absorb2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<squnion> c \\<sqinter> a < a \\<sqinter> (b \\<squnion> c);\n     b \\<le> a\\<rbrakk>\n    \\<Longrightarrow> False", "apply (unfold modular [THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<squnion> c \\<sqinter> a < b \\<squnion> a \\<sqinter> c;\n     b \\<le> a\\<rbrakk>\n    \\<Longrightarrow> False", "by (simp add: inf_commute)"], ["", "lemma M5_modular: \"no_distrib a b c \\<Longrightarrow> M5_lattice (a_aux a b c) (b_aux a b c) (c_aux a b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_distrib a b c \\<Longrightarrow>\n    M5_lattice (a_aux a b c) (b_aux a b c) (c_aux a b c)", "apply (frule d_less_e)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>no_distrib a b c; d_aux a b c < e_aux a b c\\<rbrakk>\n    \\<Longrightarrow> M5_lattice (a_aux a b c) (b_aux a b c) (c_aux a b c)", "by (simp add: M5_lattice_def a_meet_b_eq_d b_meet_c_eq_d c_meet_a_eq_d a_join_b_eq_e b_join_c_eq_e c_join_a_eq_e)"], ["", "lemma M5_modular_def: \"M5_lattice a b c = (a \\<sqinter> b = b \\<sqinter> c \\<and> c \\<sqinter> a = b \\<sqinter> c \\<and> a \\<squnion> b = b \\<squnion> c \\<and> c \\<squnion> a = b \\<squnion> c \\<and> a \\<sqinter> b < a \\<squnion> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M5_lattice a b c =\n    (a \\<sqinter> b = b \\<sqinter> c \\<and>\n     c \\<sqinter> a = b \\<sqinter> c \\<and>\n     a \\<squnion> b = b \\<squnion> c \\<and>\n     c \\<squnion> a = b \\<squnion> c \\<and> a \\<sqinter> b < a \\<squnion> b)", "by (simp add: M5_lattice_def)"], ["", "end"], ["", "context lattice begin"], ["", "lemma not_modular_N5: \"(\\<not> class.modular_lattice inf ((\\<le>)::'a \\<Rightarrow> 'a \\<Rightarrow> bool) (<) sup) =\n   (\\<exists> a b c::'a . N5_lattice a b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> class.modular_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)) =\n    (\\<exists>a b c. N5_lattice a b c)", "apply (subgoal_tac \"class.lattice (\\<sqinter>) ((\\<le>)::'a \\<Rightarrow> 'a \\<Rightarrow> bool) (<) sup\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) \\<Longrightarrow>\n    (\\<not> class.modular_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)) =\n    (\\<exists>a b c. N5_lattice a b c)\n 2. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply (unfold N5_lattice_def class.modular_lattice_def class.modular_lattice_axioms_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) \\<Longrightarrow>\n    (\\<not> (class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) \\<and>\n             (\\<forall>x y z.\n                 x \\<le> y \\<longrightarrow>\n                 x \\<squnion> y \\<sqinter> z =\n                 y \\<sqinter> (x \\<squnion> z)))) =\n    (\\<exists>a b c.\n        a \\<sqinter> c = b \\<sqinter> c \\<and>\n        a < b \\<and> a \\<squnion> c = b \\<squnion> c)\n 2. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) \\<Longrightarrow>\n    (\\<exists>x y.\n        x \\<le> y \\<and>\n        (\\<exists>z.\n            x \\<squnion> y \\<sqinter> z \\<noteq>\n            y \\<sqinter> (x \\<squnion> z))) =\n    (\\<exists>a b c.\n        a \\<sqinter> c = b \\<sqinter> c \\<and>\n        a < b \\<and> a \\<squnion> c = b \\<squnion> c)\n 2. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq>\n        y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b c.\n                            a \\<sqinter> c = b \\<sqinter> c \\<and>\n                            a < b \\<and> a \\<squnion> c = b \\<squnion> c\n 2. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            x \\<le> y \\<and>\n                            (\\<exists>z.\n                                x \\<squnion> y \\<sqinter> z \\<noteq>\n                                y \\<sqinter> (x \\<squnion> z))\n 3. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply (subgoal_tac \"x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b c.\n                            a \\<sqinter> c = b \\<sqinter> c \\<and>\n                            a < b \\<and> a \\<squnion> c = b \\<squnion> c\n 2. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq>\n        y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z\n                         < y \\<sqinter> (x \\<squnion> z)\n 3. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            x \\<le> y \\<and>\n                            (\\<exists>z.\n                                x \\<squnion> y \\<sqinter> z \\<noteq>\n                                y \\<sqinter> (x \\<squnion> z))\n 4. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply (rule_tac x = \"x \\<squnion> y \\<sqinter> z\" in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b c.\n                            (x \\<squnion> y \\<sqinter> z) \\<sqinter> c =\n                            b \\<sqinter> c \\<and>\n                            x \\<squnion> y \\<sqinter> z < b \\<and>\n                            x \\<squnion> y \\<sqinter> z \\<squnion> c =\n                            b \\<squnion> c\n 2. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq>\n        y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z\n                         < y \\<sqinter> (x \\<squnion> z)\n 3. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            x \\<le> y \\<and>\n                            (\\<exists>z.\n                                x \\<squnion> y \\<sqinter> z \\<noteq>\n                                y \\<sqinter> (x \\<squnion> z))\n 4. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply (rule_tac x = \"y \\<sqinter> (x \\<squnion> z)\" in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (x \\<squnion> y \\<sqinter> z) \\<sqinter> c =\n                            y \\<sqinter> (x \\<squnion> z) \\<sqinter>\n                            c \\<and>\n                            x \\<squnion> y \\<sqinter> z\n                            < y \\<sqinter> (x \\<squnion> z) \\<and>\n                            x \\<squnion> y \\<sqinter> z \\<squnion> c =\n                            y \\<sqinter> (x \\<squnion> z) \\<squnion> c\n 2. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq>\n        y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z\n                         < y \\<sqinter> (x \\<squnion> z)\n 3. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            x \\<le> y \\<and>\n                            (\\<exists>z.\n                                x \\<squnion> y \\<sqinter> z \\<noteq>\n                                y \\<sqinter> (x \\<squnion> z))\n 4. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply (rule_tac x = z in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> (x \\<squnion> y \\<sqinter> z) \\<sqinter> z =\n                         y \\<sqinter> (x \\<squnion> z) \\<sqinter> z \\<and>\n                         x \\<squnion> y \\<sqinter> z\n                         < y \\<sqinter> (x \\<squnion> z) \\<and>\n                         x \\<squnion> y \\<sqinter> z \\<squnion> z =\n                         y \\<sqinter> (x \\<squnion> z) \\<squnion> z\n 2. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq>\n        y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z\n                         < y \\<sqinter> (x \\<squnion> z)\n 3. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            x \\<le> y \\<and>\n                            (\\<exists>z.\n                                x \\<squnion> y \\<sqinter> z \\<noteq>\n                                y \\<sqinter> (x \\<squnion> z))\n 4. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply safe"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> (x \\<squnion> y \\<sqinter> z) \\<sqinter> z =\n                         y \\<sqinter> (x \\<squnion> z) \\<sqinter> z\n 2. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z \\<squnion> z =\n                         y \\<sqinter> (x \\<squnion> z) \\<squnion> z\n 3. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq>\n        y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z\n                         < y \\<sqinter> (x \\<squnion> z)\n 4. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            x \\<le> y \\<and>\n                            (\\<exists>z.\n                                x \\<squnion> y \\<sqinter> z \\<noteq>\n                                y \\<sqinter> (x \\<squnion> z))\n 5. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply (rule antisym)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> (x \\<squnion> y \\<sqinter> z) \\<sqinter> z\n                         \\<le> y \\<sqinter> (x \\<squnion> z) \\<sqinter> z\n 2. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> y \\<sqinter> (x \\<squnion> z) \\<sqinter> z\n                         \\<le> (x \\<squnion> y \\<sqinter> z) \\<sqinter> z\n 3. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z \\<squnion> z =\n                         y \\<sqinter> (x \\<squnion> z) \\<squnion> z\n 4. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq>\n        y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z\n                         < y \\<sqinter> (x \\<squnion> z)\n 5. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            x \\<le> y \\<and>\n                            (\\<exists>z.\n                                x \\<squnion> y \\<sqinter> z \\<noteq>\n                                y \\<sqinter> (x \\<squnion> z))\n 6. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> (x \\<squnion> y \\<sqinter> z) \\<sqinter> z \\<le> y\n 2. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> y \\<sqinter> (x \\<squnion> z) \\<sqinter> z\n                         \\<le> (x \\<squnion> y \\<sqinter> z) \\<sqinter> z\n 3. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z \\<squnion> z =\n                         y \\<sqinter> (x \\<squnion> z) \\<squnion> z\n 4. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq>\n        y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z\n                         < y \\<sqinter> (x \\<squnion> z)\n 5. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            x \\<le> y \\<and>\n                            (\\<exists>z.\n                                x \\<squnion> y \\<sqinter> z \\<noteq>\n                                y \\<sqinter> (x \\<squnion> z))\n 6. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply (rule_tac y = \"x \\<squnion> y \\<sqinter> z\" in order_trans)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> (x \\<squnion> y \\<sqinter> z) \\<sqinter> z\n                         \\<le> x \\<squnion> y \\<sqinter> z\n 2. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> y \\<sqinter> (x \\<squnion> z) \\<sqinter> z\n                         \\<le> (x \\<squnion> y \\<sqinter> z) \\<sqinter> z\n 4. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z \\<squnion> z =\n                         y \\<sqinter> (x \\<squnion> z) \\<squnion> z\n 5. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq>\n        y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z\n                         < y \\<sqinter> (x \\<squnion> z)\n 6. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            x \\<le> y \\<and>\n                            (\\<exists>z.\n                                x \\<squnion> y \\<sqinter> z \\<noteq>\n                                y \\<sqinter> (x \\<squnion> z))\n 7. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply simp_all"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> y \\<sqinter> (x \\<squnion> z) \\<sqinter> z\n                         \\<le> x \\<squnion> y \\<sqinter> z\n 2. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z \\<squnion> z =\n                         y \\<sqinter> (x \\<squnion> z) \\<squnion> z\n 3. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq>\n        y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z\n                         < y \\<sqinter> (x \\<squnion> z)\n 4. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            x \\<le> y \\<and>\n                            (\\<exists>z.\n                                x \\<squnion> y \\<sqinter> z \\<noteq>\n                                y \\<sqinter> (x \\<squnion> z))\n 5. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply (rule_tac y = \"y \\<sqinter> z\" in order_trans)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> y \\<sqinter> (x \\<squnion> z) \\<sqinter> z\n                         \\<le> y \\<sqinter> z\n 2. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> y \\<sqinter> z \\<le> x \\<squnion> y \\<sqinter> z\n 3. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z \\<squnion> z =\n                         y \\<sqinter> (x \\<squnion> z) \\<squnion> z\n 4. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq>\n        y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z\n                         < y \\<sqinter> (x \\<squnion> z)\n 5. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            x \\<le> y \\<and>\n                            (\\<exists>z.\n                                x \\<squnion> y \\<sqinter> z \\<noteq>\n                                y \\<sqinter> (x \\<squnion> z))\n 6. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply simp_all"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z \\<squnion> z =\n                         y \\<sqinter> (x \\<squnion> z) \\<squnion> z\n 2. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq>\n        y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z\n                         < y \\<sqinter> (x \\<squnion> z)\n 3. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            x \\<le> y \\<and>\n                            (\\<exists>z.\n                                x \\<squnion> y \\<sqinter> z \\<noteq>\n                                y \\<sqinter> (x \\<squnion> z))\n 4. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply (rule antisym)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z \\<squnion> z\n                         \\<le> y \\<sqinter> (x \\<squnion> z) \\<squnion> z\n 2. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> y \\<sqinter> (x \\<squnion> z) \\<squnion> z\n                         \\<le> x \\<squnion> y \\<sqinter> z \\<squnion> z\n 3. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq>\n        y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z\n                         < y \\<sqinter> (x \\<squnion> z)\n 4. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            x \\<le> y \\<and>\n                            (\\<exists>z.\n                                x \\<squnion> y \\<sqinter> z \\<noteq>\n                                y \\<sqinter> (x \\<squnion> z))\n 5. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply simp_all"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> (x \\<squnion> z) \\<squnion> z\n 2. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> y \\<sqinter> (x \\<squnion> z)\n                         \\<le> x \\<squnion> y \\<sqinter> z \\<squnion> z\n 3. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq>\n        y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z\n                         < y \\<sqinter> (x \\<squnion> z)\n 4. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            x \\<le> y \\<and>\n                            (\\<exists>z.\n                                x \\<squnion> y \\<sqinter> z \\<noteq>\n                                y \\<sqinter> (x \\<squnion> z))\n 5. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply (rule_tac y = \"y \\<sqinter> (x \\<squnion> z)\" in order_trans)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> (x \\<squnion> z)\n 2. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> y \\<sqinter> (x \\<squnion> z)\n                         \\<le> y \\<sqinter> (x \\<squnion> z) \\<squnion> z\n 3. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> y \\<sqinter> (x \\<squnion> z)\n                         \\<le> x \\<squnion> y \\<sqinter> z \\<squnion> z\n 4. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq>\n        y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z\n                         < y \\<sqinter> (x \\<squnion> z)\n 5. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            x \\<le> y \\<and>\n                            (\\<exists>z.\n                                x \\<squnion> y \\<sqinter> z \\<noteq>\n                                y \\<sqinter> (x \\<squnion> z))\n 6. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply simp_all"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> y \\<sqinter> (x \\<squnion> z)\n                         \\<le> x \\<squnion> y \\<sqinter> z \\<squnion> z\n 2. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq>\n        y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z\n                         < y \\<sqinter> (x \\<squnion> z)\n 3. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            x \\<le> y \\<and>\n                            (\\<exists>z.\n                                x \\<squnion> y \\<sqinter> z \\<noteq>\n                                y \\<sqinter> (x \\<squnion> z))\n 4. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply (rule_tac y = \"x \\<squnion> z\" in order_trans)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> y \\<sqinter> (x \\<squnion> z) \\<le> x \\<squnion> z\n 2. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq> y \\<sqinter> (x \\<squnion> z);\n        x \\<squnion> y \\<sqinter> z < y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> z\n                         \\<le> x \\<squnion> y \\<sqinter> z \\<squnion> z\n 3. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq>\n        y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z\n                         < y \\<sqinter> (x \\<squnion> z)\n 4. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            x \\<le> y \\<and>\n                            (\\<exists>z.\n                                x \\<squnion> y \\<sqinter> z \\<noteq>\n                                y \\<sqinter> (x \\<squnion> z))\n 5. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq>\n        y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z\n                         < y \\<sqinter> (x \\<squnion> z)\n 2. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            x \\<le> y \\<and>\n                            (\\<exists>z.\n                                x \\<squnion> y \\<sqinter> z \\<noteq>\n                                y \\<sqinter> (x \\<squnion> z))\n 3. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply (rule neq_le_trans)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq>\n        y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z \\<noteq>\n                         y \\<sqinter> (x \\<squnion> z)\n 2. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq>\n        y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z\n                         \\<le> y \\<sqinter> (x \\<squnion> z)\n 3. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            x \\<le> y \\<and>\n                            (\\<exists>z.\n                                x \\<squnion> y \\<sqinter> z \\<noteq>\n                                y \\<sqinter> (x \\<squnion> z))\n 4. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y;\n        x \\<squnion> y \\<sqinter> z \\<noteq>\n        y \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z\n                         \\<le> y \\<sqinter> (x \\<squnion> z)\n 2. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            x \\<le> y \\<and>\n                            (\\<exists>z.\n                                x \\<squnion> y \\<sqinter> z \\<noteq>\n                                y \\<sqinter> (x \\<squnion> z))\n 3. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            x \\<le> y \\<and>\n                            (\\<exists>z.\n                                x \\<squnion> y \\<sqinter> z \\<noteq>\n                                y \\<sqinter> (x \\<squnion> z))\n 2. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply (rule_tac x = a in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<ge>a.\n                            \\<exists>z.\n                               a \\<squnion> y \\<sqinter> z \\<noteq>\n                               y \\<sqinter> (a \\<squnion> z)\n 2. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply (rule_tac x = b in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<and>\n                         (\\<exists>z.\n                             a \\<squnion> b \\<sqinter> z \\<noteq>\n                             b \\<sqinter> (a \\<squnion> z))\n 2. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b\n 2. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z.\n                            a \\<squnion> b \\<sqinter> z \\<noteq>\n                            b \\<sqinter> (a \\<squnion> z)\n 3. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply (simp add: less_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z.\n                            a \\<squnion> b \\<sqinter> z \\<noteq>\n                            b \\<sqinter> (a \\<squnion> z)\n 2. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply (rule_tac x = c in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> a \\<squnion> b \\<sqinter> c \\<noteq>\n                         b \\<sqinter> (a \\<squnion> c)\n 2. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a < b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> a \\<squnion> b \\<sqinter> c \\<noteq> b\n 2. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply (simp add: less_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a \\<le> b \\<and> a \\<noteq> b;\n        a \\<squnion> c = b \\<squnion> c\\<rbrakk>\n       \\<Longrightarrow> a \\<squnion> b \\<sqinter> c \\<noteq> b\n 2. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a \\<squnion> c = b \\<squnion> c;\n        a \\<le> b; a \\<noteq> b; a \\<squnion> b \\<sqinter> c = b\\<rbrakk>\n       \\<Longrightarrow> False\n 2. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply (subgoal_tac \"a \\<squnion> a \\<sqinter> c = b\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a \\<squnion> c = b \\<squnion> c;\n        a \\<le> b; a \\<noteq> b; a \\<squnion> b \\<sqinter> c = b;\n        a \\<squnion> a \\<sqinter> c = b\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a \\<squnion> c = b \\<squnion> c;\n        a \\<le> b; a \\<noteq> b; a \\<squnion> b \\<sqinter> c = b\\<rbrakk>\n       \\<Longrightarrow> a \\<squnion> a \\<sqinter> c = b\n 3. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply (unfold sup_inf_absorb) [1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a \\<squnion> c = b \\<squnion> c;\n        a \\<le> b; a \\<noteq> b; a \\<squnion> b \\<sqinter> c = b;\n        a = b\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a \\<squnion> c = b \\<squnion> c;\n        a \\<le> b; a \\<noteq> b; a \\<squnion> b \\<sqinter> c = b\\<rbrakk>\n       \\<Longrightarrow> a \\<squnion> a \\<sqinter> c = b\n 3. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        a \\<sqinter> c = b \\<sqinter> c; a \\<squnion> c = b \\<squnion> c;\n        a \\<le> b; a \\<noteq> b; a \\<squnion> b \\<sqinter> c = b\\<rbrakk>\n       \\<Longrightarrow> a \\<squnion> a \\<sqinter> c = b\n 2. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "proof"], ["proof (state)\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_distrib_N5_M5: \"(\\<not> class.distrib_lattice (\\<sqinter>) ((\\<le>)::'a \\<Rightarrow> 'a \\<Rightarrow> bool) (<) (\\<squnion>)) =\n   ((\\<exists> a b c::'a . N5_lattice a b c) \\<or> (\\<exists> a b c::'a . M5_lattice a b c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)) =\n    ((\\<exists>a b c. N5_lattice a b c) \\<or>\n     (\\<exists>a b c. M5_lattice a b c))", "apply (unfold not_modular_N5 [THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)) =\n    (\\<not> class.modular_lattice (\\<sqinter>) (\\<le>) (<)\n             (\\<squnion>) \\<or>\n     (\\<exists>a b c. M5_lattice a b c))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> class.distrib_lattice (\\<sqinter>) (\\<le>) (<)\n            (\\<squnion>) \\<Longrightarrow>\n    \\<not> class.modular_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) \\<or>\n    (\\<exists>a b c. M5_lattice a b c)\n 2. \\<not> class.modular_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) \\<or>\n    (\\<exists>a b c. M5_lattice a b c) \\<Longrightarrow>\n    \\<not> class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "assume A: \"\\<not> class.distrib_lattice (\\<sqinter>) ((\\<le>)::'a \\<Rightarrow> 'a \\<Rightarrow> bool) (<) (\\<squnion>)\""], ["proof (state)\nthis:\n  \\<not> class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)\n\ngoal (2 subgoals):\n 1. \\<not> class.distrib_lattice (\\<sqinter>) (\\<le>) (<)\n            (\\<squnion>) \\<Longrightarrow>\n    \\<not> class.modular_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) \\<or>\n    (\\<exists>a b c. M5_lattice a b c)\n 2. \\<not> class.modular_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) \\<or>\n    (\\<exists>a b c. M5_lattice a b c) \\<Longrightarrow>\n    \\<not> class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "have B: \"\\<exists> a b c:: 'a . (a \\<sqinter> b) \\<squnion> (a \\<sqinter> c) < a \\<sqinter> (b \\<squnion> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a b c.\n       a \\<sqinter> b \\<squnion> a \\<sqinter> c\n       < a \\<sqinter> (b \\<squnion> c)", "apply (cut_tac A)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> class.distrib_lattice (\\<sqinter>) (\\<le>) (<)\n            (\\<squnion>) \\<Longrightarrow>\n    \\<exists>a b c.\n       a \\<sqinter> b \\<squnion> a \\<sqinter> c\n       < a \\<sqinter> (b \\<squnion> c)", "apply (unfold  class.distrib_lattice_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) \\<and>\n            class.distrib_lattice_axioms (\\<sqinter>)\n             (\\<squnion>)) \\<Longrightarrow>\n    \\<exists>a b c.\n       a \\<sqinter> b \\<squnion> a \\<sqinter> c\n       < a \\<sqinter> (b \\<squnion> c)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<nexists>a b c.\n       a \\<sqinter> b \\<squnion> a \\<sqinter> c\n       < a \\<sqinter> (b \\<squnion> c) \\<Longrightarrow>\n    class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)\n 2. \\<nexists>a b c.\n       a \\<sqinter> b \\<squnion> a \\<sqinter> c\n       < a \\<sqinter> (b \\<squnion> c) \\<Longrightarrow>\n    class.distrib_lattice_axioms (\\<sqinter>) (\\<squnion>)", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>a b c.\n       \\<not> a \\<sqinter> b \\<squnion> a \\<sqinter> c\n              < a \\<sqinter> (b \\<squnion> c) \\<Longrightarrow>\n    class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)\n 2. \\<forall>a b c.\n       \\<not> a \\<sqinter> b \\<squnion> a \\<sqinter> c\n              < a \\<sqinter> (b \\<squnion> c) \\<Longrightarrow>\n    class.distrib_lattice_axioms (\\<sqinter>) (\\<squnion>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<forall>a b c.\n          \\<not> a \\<sqinter> b \\<squnion> a \\<sqinter> c\n                 < a \\<sqinter> (b \\<squnion> c) \\<Longrightarrow>\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "fix x y z::'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<forall>a b c.\n          \\<not> a \\<sqinter> b \\<squnion> a \\<sqinter> c\n                 < a \\<sqinter> (b \\<squnion> c) \\<Longrightarrow>\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "assume A: \"\\<forall>(a::'a) (b::'a) c::'a. \\<not> a \\<sqinter> b \\<squnion> a \\<sqinter> c < a \\<sqinter> (b \\<squnion> c)\""], ["proof (state)\nthis:\n  \\<forall>a b c.\n     \\<not> a \\<sqinter> b \\<squnion> a \\<sqinter> c\n            < a \\<sqinter> (b \\<squnion> c)\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<forall>a b c.\n          \\<not> a \\<sqinter> b \\<squnion> a \\<sqinter> c\n                 < a \\<sqinter> (b \\<squnion> c) \\<Longrightarrow>\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "show \"x \\<squnion> y \\<sqinter> z = (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<sqinter> z =\n    (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "apply (cut_tac A)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b c.\n       \\<not> a \\<sqinter> b \\<squnion> a \\<sqinter> c\n              < a \\<sqinter> (b \\<squnion> c) \\<Longrightarrow>\n    x \\<squnion> y \\<sqinter> z =\n    (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "apply (rule distrib_imp1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<forall>a b c.\n          \\<not> a \\<sqinter> b \\<squnion> a \\<sqinter> c\n                 < a \\<sqinter> (b \\<squnion> c) \\<Longrightarrow>\n       x \\<sqinter> (y \\<squnion> z) =\n       x \\<sqinter> y \\<squnion> x \\<sqinter> z", "by (simp add: less_le)"], ["proof (state)\nthis:\n  x \\<squnion> y \\<sqinter> z = (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a b c.\n     a \\<sqinter> b \\<squnion> a \\<sqinter> c\n     < a \\<sqinter> (b \\<squnion> c)\n\ngoal (2 subgoals):\n 1. \\<not> class.distrib_lattice (\\<sqinter>) (\\<le>) (<)\n            (\\<squnion>) \\<Longrightarrow>\n    \\<not> class.modular_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) \\<or>\n    (\\<exists>a b c. M5_lattice a b c)\n 2. \\<not> class.modular_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) \\<or>\n    (\\<exists>a b c. M5_lattice a b c) \\<Longrightarrow>\n    \\<not> class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "from B"], ["proof (chain)\npicking this:\n  \\<exists>a b c.\n     a \\<sqinter> b \\<squnion> a \\<sqinter> c\n     < a \\<sqinter> (b \\<squnion> c)", "show \"\\<not> class.modular_lattice (\\<sqinter>) ((\\<le>)::'a \\<Rightarrow> 'a \\<Rightarrow> bool) (<) (\\<squnion>) \\<or> (\\<exists>a b c::'a. M5_lattice a b c)\""], ["proof (prove)\nusing this:\n  \\<exists>a b c.\n     a \\<sqinter> b \\<squnion> a \\<sqinter> c\n     < a \\<sqinter> (b \\<squnion> c)\n\ngoal (1 subgoal):\n 1. \\<not> class.modular_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) \\<or>\n    (\\<exists>a b c. M5_lattice a b c)", "proof (unfold disj_not1, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b ba c ca.\n       \\<lbrakk>a \\<sqinter> b \\<squnion> a \\<sqinter> c\n                < a \\<sqinter> (b \\<squnion> c);\n        aa \\<sqinter> ba \\<squnion> aa \\<sqinter> ca\n        < aa \\<sqinter> (ba \\<squnion> ca);\n        class.modular_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b. Ex (M5_lattice a b)", "fix a b c::'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b ba c ca.\n       \\<lbrakk>a \\<sqinter> b \\<squnion> a \\<sqinter> c\n                < a \\<sqinter> (b \\<squnion> c);\n        aa \\<sqinter> ba \\<squnion> aa \\<sqinter> ca\n        < aa \\<sqinter> (ba \\<squnion> ca);\n        class.modular_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b. Ex (M5_lattice a b)", "assume A: \"a \\<sqinter> b \\<squnion> a \\<sqinter> c < a \\<sqinter> (b \\<squnion> c)\""], ["proof (state)\nthis:\n  a \\<sqinter> b \\<squnion> a \\<sqinter> c < a \\<sqinter> (b \\<squnion> c)\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ba c ca.\n       \\<lbrakk>a \\<sqinter> b \\<squnion> a \\<sqinter> c\n                < a \\<sqinter> (b \\<squnion> c);\n        aa \\<sqinter> ba \\<squnion> aa \\<sqinter> ca\n        < aa \\<sqinter> (ba \\<squnion> ca);\n        class.modular_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b. Ex (M5_lattice a b)", "assume B: \"class.modular_lattice (\\<sqinter>) ((\\<le>)::'a \\<Rightarrow> 'a \\<Rightarrow> bool) (<) (\\<squnion>)\""], ["proof (state)\nthis:\n  class.modular_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ba c ca.\n       \\<lbrakk>a \\<sqinter> b \\<squnion> a \\<sqinter> c\n                < a \\<sqinter> (b \\<squnion> c);\n        aa \\<sqinter> ba \\<squnion> aa \\<sqinter> ca\n        < aa \\<sqinter> (ba \\<squnion> ca);\n        class.modular_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b. Ex (M5_lattice a b)", "interpret modular: modular_lattice \"(\\<sqinter>)\" \"((\\<le>)::'a \\<Rightarrow> 'a \\<Rightarrow> bool)\" \"(<)\" \"(\\<squnion>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.modular_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "by (fact B)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b ba c ca.\n       \\<lbrakk>a \\<sqinter> b \\<squnion> a \\<sqinter> c\n                < a \\<sqinter> (b \\<squnion> c);\n        aa \\<sqinter> ba \\<squnion> aa \\<sqinter> ca\n        < aa \\<sqinter> (ba \\<squnion> ca);\n        class.modular_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b. Ex (M5_lattice a b)", "have H: \"M5_lattice (a_aux a b c) (b_aux a b c) (c_aux a b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M5_lattice (a_aux a b c) (b_aux a b c) (c_aux a b c)", "apply (cut_tac a = a and b = b and c = c in  modular.M5_modular)"], ["proof (prove)\ngoal (2 subgoals):\n 1. no_distrib a b c\n 2. M5_lattice (a_aux a b c) (b_aux a b c) (c_aux a b c) \\<Longrightarrow>\n    M5_lattice (a_aux a b c) (b_aux a b c) (c_aux a b c)", "apply (unfold no_distrib_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<sqinter> b \\<squnion> c \\<sqinter> a < a \\<sqinter> (b \\<squnion> c)\n 2. M5_lattice (a_aux a b c) (b_aux a b c) (c_aux a b c) \\<Longrightarrow>\n    M5_lattice (a_aux a b c) (b_aux a b c) (c_aux a b c)", "by (simp_all add: A inf_commute)"], ["proof (state)\nthis:\n  M5_lattice (a_aux a b c) (b_aux a b c) (c_aux a b c)\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ba c ca.\n       \\<lbrakk>a \\<sqinter> b \\<squnion> a \\<sqinter> c\n                < a \\<sqinter> (b \\<squnion> c);\n        aa \\<sqinter> ba \\<squnion> aa \\<sqinter> ca\n        < aa \\<sqinter> (ba \\<squnion> ca);\n        class.modular_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b. Ex (M5_lattice a b)", "from H"], ["proof (chain)\npicking this:\n  M5_lattice (a_aux a b c) (b_aux a b c) (c_aux a b c)", "show \"\\<exists>a b c::'a. M5_lattice a b c\""], ["proof (prove)\nusing this:\n  M5_lattice (a_aux a b c) (b_aux a b c) (c_aux a b c)\n\ngoal (1 subgoal):\n 1. \\<exists>a b c. M5_lattice a b c", "by blast"], ["proof (state)\nthis:\n  \\<exists>a b c. M5_lattice a b c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> class.modular_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) \\<or>\n  (\\<exists>a b c. M5_lattice a b c)\n\ngoal (1 subgoal):\n 1. \\<not> class.modular_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) \\<or>\n    (\\<exists>a b c. M5_lattice a b c) \\<Longrightarrow>\n    \\<not> class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> class.modular_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) \\<or>\n    (\\<exists>a b c. M5_lattice a b c) \\<Longrightarrow>\n    \\<not> class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "assume A: \"\\<not> class.modular_lattice (\\<sqinter>) ((\\<le>)::'a \\<Rightarrow> 'a \\<Rightarrow> bool) (<) (\\<squnion>) \\<or> (\\<exists>(a::'a) (b::'a) c::'a. M5_lattice a b c)\""], ["proof (state)\nthis:\n  \\<not> class.modular_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) \\<or>\n  (\\<exists>a b c. M5_lattice a b c)\n\ngoal (1 subgoal):\n 1. \\<not> class.modular_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) \\<or>\n    (\\<exists>a b c. M5_lattice a b c) \\<Longrightarrow>\n    \\<not> class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "show \"\\<not> class.distrib_lattice (\\<sqinter>) ((\\<le>)::'a \\<Rightarrow> 'a \\<Rightarrow> bool) (<) (\\<squnion>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply (cut_tac A)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> class.modular_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) \\<or>\n    (\\<exists>a b c. M5_lattice a b c) \\<Longrightarrow>\n    \\<not> class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n     \\<not> class.modular_lattice (\\<sqinter>) (\\<le>) (<)\n             (\\<squnion>)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>a b c.\n       \\<lbrakk>class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        M5_lattice a b c\\<rbrakk>\n       \\<Longrightarrow> False", "apply (erule notE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. class.distrib_lattice (\\<sqinter>) (\\<le>) (<)\n     (\\<squnion>) \\<Longrightarrow>\n    class.modular_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)\n 2. \\<And>a b c.\n       \\<lbrakk>class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        M5_lattice a b c\\<rbrakk>\n       \\<Longrightarrow> False", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z =\n                         y \\<sqinter> (x \\<squnion> z)\n 2. \\<And>a b c.\n       \\<lbrakk>class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        M5_lattice a b c\\<rbrakk>\n       \\<Longrightarrow> False", "apply (unfold class.distrib_lattice_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) \\<and>\n                class.distrib_lattice_axioms (\\<sqinter>) (\\<squnion>);\n        x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z =\n                         y \\<sqinter> (x \\<squnion> z)\n 2. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) \\<and>\n                class.distrib_lattice_axioms (\\<sqinter>) (\\<squnion>);\n        M5_lattice a b c\\<rbrakk>\n       \\<Longrightarrow> False", "apply (unfold class.distrib_lattice_axioms_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) \\<and>\n                (\\<forall>x y z.\n                    x \\<squnion> y \\<sqinter> z =\n                    (x \\<squnion> y) \\<sqinter> (x \\<squnion> z));\n        x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z =\n                         y \\<sqinter> (x \\<squnion> z)\n 2. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) \\<and>\n                (\\<forall>x y z.\n                    x \\<squnion> y \\<sqinter> z =\n                    (x \\<squnion> y) \\<sqinter> (x \\<squnion> z));\n        M5_lattice a b c\\<rbrakk>\n       \\<Longrightarrow> False", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y;\n        class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        \\<forall>x y z.\n           x \\<squnion> y \\<sqinter> z =\n           (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z =\n                         y \\<sqinter> (x \\<squnion> z)\n 2. \\<And>a b c.\n       \\<lbrakk>M5_lattice a b c;\n        class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        \\<forall>x y z.\n           x \\<squnion> y \\<sqinter> z =\n           (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp add: sup_absorb2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>M5_lattice a b c;\n        class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        \\<forall>x y z.\n           x \\<squnion> y \\<sqinter> z =\n           (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (frule M5_lattice_incomp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>M5_lattice a b c;\n        class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        \\<forall>x y z.\n           x \\<squnion> y \\<sqinter> z =\n           (x \\<squnion> y) \\<sqinter> (x \\<squnion> z);\n        incomp a b\\<rbrakk>\n       \\<Longrightarrow> False", "apply (unfold M5_lattice_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<sqinter> b = b \\<sqinter> c \\<and>\n                c \\<sqinter> a = b \\<sqinter> c \\<and>\n                a \\<squnion> b = b \\<squnion> c \\<and>\n                c \\<squnion> a = b \\<squnion> c \\<and>\n                a \\<sqinter> b < a \\<squnion> b;\n        class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        \\<forall>x y z.\n           x \\<squnion> y \\<sqinter> z =\n           (x \\<squnion> y) \\<sqinter> (x \\<squnion> z);\n        incomp a b\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule_tac x = a in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<sqinter> b = b \\<sqinter> c \\<and>\n                c \\<sqinter> a = b \\<sqinter> c \\<and>\n                a \\<squnion> b = b \\<squnion> c \\<and>\n                c \\<squnion> a = b \\<squnion> c \\<and>\n                a \\<sqinter> b < a \\<squnion> b;\n        class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>); incomp a b;\n        \\<forall>y z.\n           a \\<squnion> y \\<sqinter> z =\n           (a \\<squnion> y) \\<sqinter> (a \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule_tac x = b in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<sqinter> b = b \\<sqinter> c \\<and>\n                c \\<sqinter> a = b \\<sqinter> c \\<and>\n                a \\<squnion> b = b \\<squnion> c \\<and>\n                c \\<squnion> a = b \\<squnion> c \\<and>\n                a \\<sqinter> b < a \\<squnion> b;\n        class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>); incomp a b;\n        \\<forall>z.\n           a \\<squnion> b \\<sqinter> z =\n           (a \\<squnion> b) \\<sqinter> (a \\<squnion> z)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule_tac x = c in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<sqinter> b = b \\<sqinter> c \\<and>\n                c \\<sqinter> a = b \\<sqinter> c \\<and>\n                a \\<squnion> b = b \\<squnion> c \\<and>\n                c \\<squnion> a = b \\<squnion> c \\<and>\n                a \\<sqinter> b < a \\<squnion> b;\n        class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>); incomp a b;\n        a \\<squnion> b \\<sqinter> c =\n        (a \\<squnion> b) \\<sqinter> (a \\<squnion> c)\\<rbrakk>\n       \\<Longrightarrow> False", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        incomp a b;\n        a \\<squnion> b \\<sqinter> c =\n        (a \\<squnion> b) \\<sqinter> (a \\<squnion> c);\n        a \\<sqinter> b = b \\<sqinter> c; c \\<sqinter> a = b \\<sqinter> c;\n        a \\<squnion> b = b \\<squnion> c; c \\<squnion> a = b \\<squnion> c;\n        a \\<sqinter> b < a \\<squnion> b\\<rbrakk>\n       \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        incomp a b;\n        a \\<squnion> b \\<sqinter> c =\n        (a \\<squnion> b) \\<sqinter> (a \\<squnion> c);\n        a \\<sqinter> b = b \\<sqinter> c; c \\<sqinter> a = b \\<sqinter> c;\n        a \\<squnion> b = b \\<squnion> c; c \\<squnion> a = b \\<squnion> c;\n        a \\<sqinter> b < a \\<squnion> b\\<rbrakk>\n       \\<Longrightarrow> False", "fix a b c:: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        incomp a b;\n        a \\<squnion> b \\<sqinter> c =\n        (a \\<squnion> b) \\<sqinter> (a \\<squnion> c);\n        a \\<sqinter> b = b \\<sqinter> c; c \\<sqinter> a = b \\<sqinter> c;\n        a \\<squnion> b = b \\<squnion> c; c \\<squnion> a = b \\<squnion> c;\n        a \\<sqinter> b < a \\<squnion> b\\<rbrakk>\n       \\<Longrightarrow> False", "assume A:\"a \\<squnion> b \\<sqinter> c = (a \\<squnion> b) \\<sqinter> (a \\<squnion> c)\""], ["proof (state)\nthis:\n  a \\<squnion> b \\<sqinter> c = (a \\<squnion> b) \\<sqinter> (a \\<squnion> c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        incomp a b;\n        a \\<squnion> b \\<sqinter> c =\n        (a \\<squnion> b) \\<sqinter> (a \\<squnion> c);\n        a \\<sqinter> b = b \\<sqinter> c; c \\<sqinter> a = b \\<sqinter> c;\n        a \\<squnion> b = b \\<squnion> c; c \\<squnion> a = b \\<squnion> c;\n        a \\<sqinter> b < a \\<squnion> b\\<rbrakk>\n       \\<Longrightarrow> False", "assume B: \"a \\<sqinter> b = b \\<sqinter> c\""], ["proof (state)\nthis:\n  a \\<sqinter> b = b \\<sqinter> c\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        incomp a b;\n        a \\<squnion> b \\<sqinter> c =\n        (a \\<squnion> b) \\<sqinter> (a \\<squnion> c);\n        a \\<sqinter> b = b \\<sqinter> c; c \\<sqinter> a = b \\<sqinter> c;\n        a \\<squnion> b = b \\<squnion> c; c \\<squnion> a = b \\<squnion> c;\n        a \\<sqinter> b < a \\<squnion> b\\<rbrakk>\n       \\<Longrightarrow> False", "assume D: \"a \\<squnion> b = b \\<squnion> c\""], ["proof (state)\nthis:\n  a \\<squnion> b = b \\<squnion> c\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        incomp a b;\n        a \\<squnion> b \\<sqinter> c =\n        (a \\<squnion> b) \\<sqinter> (a \\<squnion> c);\n        a \\<sqinter> b = b \\<sqinter> c; c \\<sqinter> a = b \\<sqinter> c;\n        a \\<squnion> b = b \\<squnion> c; c \\<squnion> a = b \\<squnion> c;\n        a \\<sqinter> b < a \\<squnion> b\\<rbrakk>\n       \\<Longrightarrow> False", "assume E: \"c \\<squnion> a = b \\<squnion> c\""], ["proof (state)\nthis:\n  c \\<squnion> a = b \\<squnion> c\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        incomp a b;\n        a \\<squnion> b \\<sqinter> c =\n        (a \\<squnion> b) \\<sqinter> (a \\<squnion> c);\n        a \\<sqinter> b = b \\<sqinter> c; c \\<sqinter> a = b \\<sqinter> c;\n        a \\<squnion> b = b \\<squnion> c; c \\<squnion> a = b \\<squnion> c;\n        a \\<sqinter> b < a \\<squnion> b\\<rbrakk>\n       \\<Longrightarrow> False", "assume G: \"incomp a b\""], ["proof (state)\nthis:\n  incomp a b\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        incomp a b;\n        a \\<squnion> b \\<sqinter> c =\n        (a \\<squnion> b) \\<sqinter> (a \\<squnion> c);\n        a \\<sqinter> b = b \\<sqinter> c; c \\<sqinter> a = b \\<sqinter> c;\n        a \\<squnion> b = b \\<squnion> c; c \\<squnion> a = b \\<squnion> c;\n        a \\<sqinter> b < a \\<squnion> b\\<rbrakk>\n       \\<Longrightarrow> False", "have H: \"a \\<squnion> b \\<sqinter> c = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<squnion> b \\<sqinter> c = a", "by (simp add: B [THEN sym] sup_absorb1)"], ["proof (state)\nthis:\n  a \\<squnion> b \\<sqinter> c = a\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        incomp a b;\n        a \\<squnion> b \\<sqinter> c =\n        (a \\<squnion> b) \\<sqinter> (a \\<squnion> c);\n        a \\<sqinter> b = b \\<sqinter> c; c \\<sqinter> a = b \\<sqinter> c;\n        a \\<squnion> b = b \\<squnion> c; c \\<squnion> a = b \\<squnion> c;\n        a \\<sqinter> b < a \\<squnion> b\\<rbrakk>\n       \\<Longrightarrow> False", "have I: \"(a \\<squnion> b) \\<sqinter> (a \\<squnion> c) = a \\<squnion> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<squnion> b) \\<sqinter> (a \\<squnion> c) = a \\<squnion> b", "by (cut_tac E, simp add: sup_commute D)"], ["proof (state)\nthis:\n  (a \\<squnion> b) \\<sqinter> (a \\<squnion> c) = a \\<squnion> b\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        incomp a b;\n        a \\<squnion> b \\<sqinter> c =\n        (a \\<squnion> b) \\<sqinter> (a \\<squnion> c);\n        a \\<sqinter> b = b \\<sqinter> c; c \\<sqinter> a = b \\<sqinter> c;\n        a \\<squnion> b = b \\<squnion> c; c \\<squnion> a = b \\<squnion> c;\n        a \\<sqinter> b < a \\<squnion> b\\<rbrakk>\n       \\<Longrightarrow> False", "have J: \"a = a \\<squnion> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = a \\<squnion> b", "by (cut_tac A, simp add: H I)"], ["proof (state)\nthis:\n  a = a \\<squnion> b\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>class.lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        incomp a b;\n        a \\<squnion> b \\<sqinter> c =\n        (a \\<squnion> b) \\<sqinter> (a \\<squnion> c);\n        a \\<sqinter> b = b \\<sqinter> c; c \\<sqinter> a = b \\<sqinter> c;\n        a \\<squnion> b = b \\<squnion> c; c \\<squnion> a = b \\<squnion> c;\n        a \\<sqinter> b < a \\<squnion> b\\<rbrakk>\n       \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "apply (cut_tac G J)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>incomp a b; a = a \\<squnion> b\\<rbrakk> \\<Longrightarrow> False", "apply (subgoal_tac \"b \\<le> a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>incomp a b; a = a \\<squnion> b; b \\<le> a\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>incomp a b; a = a \\<squnion> b\\<rbrakk>\n    \\<Longrightarrow> b \\<le> a", "apply (simp add: incomp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>incomp a b; a = a \\<squnion> b\\<rbrakk>\n    \\<Longrightarrow> b \\<le> a", "apply (rule_tac y = \"a \\<squnion> b\" in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>incomp a b; a = a \\<squnion> b\\<rbrakk>\n    \\<Longrightarrow> b \\<le> a \\<squnion> b\n 2. \\<lbrakk>incomp a b; a = a \\<squnion> b\\<rbrakk>\n    \\<Longrightarrow> a \\<squnion> b \\<le> a", "apply (rule sup_ge2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>incomp a b; a = a \\<squnion> b\\<rbrakk>\n    \\<Longrightarrow> a \\<squnion> b \\<le> a", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distrib_not_N5_M5: \"(class.distrib_lattice (\\<sqinter>) ((\\<le>)::'a \\<Rightarrow> 'a \\<Rightarrow> bool) (<) (\\<squnion>)) =\n   ((\\<forall> a b c::'a . \\<not> N5_lattice a b c) \\<and> (\\<forall> a b c::'a . \\<not> M5_lattice a b c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) =\n    ((\\<forall>a b c. \\<not> N5_lattice a b c) \\<and>\n     (\\<forall>a b c. \\<not> M5_lattice a b c))", "apply (cut_tac not_distrib_N5_M5)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)) =\n    ((\\<exists>a b c. N5_lattice a b c) \\<or>\n     (\\<exists>a b c. M5_lattice a b c)) \\<Longrightarrow>\n    class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) =\n    ((\\<forall>a b c. \\<not> N5_lattice a b c) \\<and>\n     (\\<forall>a b c. \\<not> M5_lattice a b c))", "by auto"], ["", "lemma distrib_inf_sup_eq:\n  \"(class.distrib_lattice (\\<sqinter>) ((\\<le>)::'a \\<Rightarrow> 'a \\<Rightarrow> bool) (<) (\\<squnion>)) = \n    (\\<forall> x y z::'a . x \\<sqinter> z = y \\<sqinter> z \\<and> x \\<squnion> z = y \\<squnion> z \\<longrightarrow> x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) =\n    (\\<forall>x y z.\n        x \\<sqinter> z = y \\<sqinter> z \\<and>\n        x \\<squnion> z = y \\<squnion> z \\<longrightarrow>\n        x = y)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<sqinter> z = y \\<sqinter> z;\n        x \\<squnion> z = y \\<squnion> z\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<forall>x y z.\n       x \\<sqinter> z = y \\<sqinter> z \\<and>\n       x \\<squnion> z = y \\<squnion> z \\<longrightarrow>\n       x = y \\<Longrightarrow>\n    class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<sqinter> z = y \\<sqinter> z;\n        x \\<squnion> z = y \\<squnion> z\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<forall>x y z.\n       x \\<sqinter> z = y \\<sqinter> z \\<and>\n       x \\<squnion> z = y \\<squnion> z \\<longrightarrow>\n       x = y \\<Longrightarrow>\n    class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "fix x y z:: 'a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<sqinter> z = y \\<sqinter> z;\n        x \\<squnion> z = y \\<squnion> z\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<forall>x y z.\n       x \\<sqinter> z = y \\<sqinter> z \\<and>\n       x \\<squnion> z = y \\<squnion> z \\<longrightarrow>\n       x = y \\<Longrightarrow>\n    class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "assume A: \"class.distrib_lattice (\\<sqinter>) ((\\<le>) ::'a \\<Rightarrow> 'a \\<Rightarrow> bool) (<) (\\<squnion>)\""], ["proof (state)\nthis:\n  class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<sqinter> z = y \\<sqinter> z;\n        x \\<squnion> z = y \\<squnion> z\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<forall>x y z.\n       x \\<sqinter> z = y \\<sqinter> z \\<and>\n       x \\<squnion> z = y \\<squnion> z \\<longrightarrow>\n       x = y \\<Longrightarrow>\n    class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "interpret distrib: distrib_lattice \"(\\<sqinter>)\" \"(\\<le>) :: 'a \\<Rightarrow> 'a \\<Rightarrow> bool\" \"(<)\" \"(\\<squnion>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "by (fact A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<sqinter> z = y \\<sqinter> z;\n        x \\<squnion> z = y \\<squnion> z\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<forall>x y z.\n       x \\<sqinter> z = y \\<sqinter> z \\<and>\n       x \\<squnion> z = y \\<squnion> z \\<longrightarrow>\n       x = y \\<Longrightarrow>\n    class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "assume B: \"x \\<sqinter> z = y \\<sqinter> z\""], ["proof (state)\nthis:\n  x \\<sqinter> z = y \\<sqinter> z\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<sqinter> z = y \\<sqinter> z;\n        x \\<squnion> z = y \\<squnion> z\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<forall>x y z.\n       x \\<sqinter> z = y \\<sqinter> z \\<and>\n       x \\<squnion> z = y \\<squnion> z \\<longrightarrow>\n       x = y \\<Longrightarrow>\n    class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "assume C: \"x \\<squnion> z = y \\<squnion> z\""], ["proof (state)\nthis:\n  x \\<squnion> z = y \\<squnion> z\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<sqinter> z = y \\<sqinter> z;\n        x \\<squnion> z = y \\<squnion> z\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<forall>x y z.\n       x \\<sqinter> z = y \\<sqinter> z \\<and>\n       x \\<squnion> z = y \\<squnion> z \\<longrightarrow>\n       x = y \\<Longrightarrow>\n    class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "have \"x = x \\<sqinter> (x \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x \\<sqinter> (x \\<squnion> z)", "by simp"], ["proof (state)\nthis:\n  x = x \\<sqinter> (x \\<squnion> z)\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<sqinter> z = y \\<sqinter> z;\n        x \\<squnion> z = y \\<squnion> z\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<forall>x y z.\n       x \\<sqinter> z = y \\<sqinter> z \\<and>\n       x \\<squnion> z = y \\<squnion> z \\<longrightarrow>\n       x = y \\<Longrightarrow>\n    class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "also"], ["proof (state)\nthis:\n  x = x \\<sqinter> (x \\<squnion> z)\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<sqinter> z = y \\<sqinter> z;\n        x \\<squnion> z = y \\<squnion> z\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<forall>x y z.\n       x \\<sqinter> z = y \\<sqinter> z \\<and>\n       x \\<squnion> z = y \\<squnion> z \\<longrightarrow>\n       x = y \\<Longrightarrow>\n    class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "have \"\\<dots> = x \\<sqinter> (y \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> (x \\<squnion> z) = x \\<sqinter> (y \\<squnion> z)", "by (simp add: C)"], ["proof (state)\nthis:\n  x \\<sqinter> (x \\<squnion> z) = x \\<sqinter> (y \\<squnion> z)\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<sqinter> z = y \\<sqinter> z;\n        x \\<squnion> z = y \\<squnion> z\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<forall>x y z.\n       x \\<sqinter> z = y \\<sqinter> z \\<and>\n       x \\<squnion> z = y \\<squnion> z \\<longrightarrow>\n       x = y \\<Longrightarrow>\n    class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "also"], ["proof (state)\nthis:\n  x \\<sqinter> (x \\<squnion> z) = x \\<sqinter> (y \\<squnion> z)\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<sqinter> z = y \\<sqinter> z;\n        x \\<squnion> z = y \\<squnion> z\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<forall>x y z.\n       x \\<sqinter> z = y \\<sqinter> z \\<and>\n       x \\<squnion> z = y \\<squnion> z \\<longrightarrow>\n       x = y \\<Longrightarrow>\n    class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "have \"\\<dots> = (x \\<sqinter> y) \\<squnion> (x \\<sqinter> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> (y \\<squnion> z) = x \\<sqinter> y \\<squnion> x \\<sqinter> z", "by (simp add: distrib.inf_sup_distrib)"], ["proof (state)\nthis:\n  x \\<sqinter> (y \\<squnion> z) = x \\<sqinter> y \\<squnion> x \\<sqinter> z\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<sqinter> z = y \\<sqinter> z;\n        x \\<squnion> z = y \\<squnion> z\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<forall>x y z.\n       x \\<sqinter> z = y \\<sqinter> z \\<and>\n       x \\<squnion> z = y \\<squnion> z \\<longrightarrow>\n       x = y \\<Longrightarrow>\n    class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "also"], ["proof (state)\nthis:\n  x \\<sqinter> (y \\<squnion> z) = x \\<sqinter> y \\<squnion> x \\<sqinter> z\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<sqinter> z = y \\<sqinter> z;\n        x \\<squnion> z = y \\<squnion> z\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<forall>x y z.\n       x \\<sqinter> z = y \\<sqinter> z \\<and>\n       x \\<squnion> z = y \\<squnion> z \\<longrightarrow>\n       x = y \\<Longrightarrow>\n    class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "have \"\\<dots> = (y \\<sqinter> x) \\<squnion> (y \\<sqinter> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<squnion> x \\<sqinter> z =\n    y \\<sqinter> x \\<squnion> y \\<sqinter> z", "by (simp add: B inf_commute)"], ["proof (state)\nthis:\n  x \\<sqinter> y \\<squnion> x \\<sqinter> z =\n  y \\<sqinter> x \\<squnion> y \\<sqinter> z\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<sqinter> z = y \\<sqinter> z;\n        x \\<squnion> z = y \\<squnion> z\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<forall>x y z.\n       x \\<sqinter> z = y \\<sqinter> z \\<and>\n       x \\<squnion> z = y \\<squnion> z \\<longrightarrow>\n       x = y \\<Longrightarrow>\n    class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "also"], ["proof (state)\nthis:\n  x \\<sqinter> y \\<squnion> x \\<sqinter> z =\n  y \\<sqinter> x \\<squnion> y \\<sqinter> z\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<sqinter> z = y \\<sqinter> z;\n        x \\<squnion> z = y \\<squnion> z\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<forall>x y z.\n       x \\<sqinter> z = y \\<sqinter> z \\<and>\n       x \\<squnion> z = y \\<squnion> z \\<longrightarrow>\n       x = y \\<Longrightarrow>\n    class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "have \"\\<dots> = y \\<sqinter> (x \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sqinter> x \\<squnion> y \\<sqinter> z = y \\<sqinter> (x \\<squnion> z)", "by (simp add: distrib.inf_sup_distrib)"], ["proof (state)\nthis:\n  y \\<sqinter> x \\<squnion> y \\<sqinter> z = y \\<sqinter> (x \\<squnion> z)\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<sqinter> z = y \\<sqinter> z;\n        x \\<squnion> z = y \\<squnion> z\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<forall>x y z.\n       x \\<sqinter> z = y \\<sqinter> z \\<and>\n       x \\<squnion> z = y \\<squnion> z \\<longrightarrow>\n       x = y \\<Longrightarrow>\n    class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "also"], ["proof (state)\nthis:\n  y \\<sqinter> x \\<squnion> y \\<sqinter> z = y \\<sqinter> (x \\<squnion> z)\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<sqinter> z = y \\<sqinter> z;\n        x \\<squnion> z = y \\<squnion> z\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<forall>x y z.\n       x \\<sqinter> z = y \\<sqinter> z \\<and>\n       x \\<squnion> z = y \\<squnion> z \\<longrightarrow>\n       x = y \\<Longrightarrow>\n    class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "have \"\\<dots> = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sqinter> (x \\<squnion> z) = y", "by (simp add: C)"], ["proof (state)\nthis:\n  y \\<sqinter> (x \\<squnion> z) = y\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>);\n        x \\<sqinter> z = y \\<sqinter> z;\n        x \\<squnion> z = y \\<squnion> z\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<forall>x y z.\n       x \\<sqinter> z = y \\<sqinter> z \\<and>\n       x \\<squnion> z = y \\<squnion> z \\<longrightarrow>\n       x = y \\<Longrightarrow>\n    class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "finally"], ["proof (chain)\npicking this:\n  x = y", "show \"x = y\""], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. x = y", "."], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       x \\<sqinter> z = y \\<sqinter> z \\<and>\n       x \\<squnion> z = y \\<squnion> z \\<longrightarrow>\n       x = y \\<Longrightarrow>\n    class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       x \\<sqinter> z = y \\<sqinter> z \\<and>\n       x \\<squnion> z = y \\<squnion> z \\<longrightarrow>\n       x = y \\<Longrightarrow>\n    class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "assume A: \"(\\<forall>x y z:: 'a. x \\<sqinter> z = y \\<sqinter> z \\<and> x \\<squnion> z = y \\<squnion> z \\<longrightarrow> x = y)\""], ["proof (state)\nthis:\n  \\<forall>x y z.\n     x \\<sqinter> z = y \\<sqinter> z \\<and>\n     x \\<squnion> z = y \\<squnion> z \\<longrightarrow>\n     x = y\n\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       x \\<sqinter> z = y \\<sqinter> z \\<and>\n       x \\<squnion> z = y \\<squnion> z \\<longrightarrow>\n       x = y \\<Longrightarrow>\n    class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "have B: \"!! x y z :: 'a. x \\<sqinter> z = y \\<sqinter> z \\<and> x \\<squnion> z = y \\<squnion> z \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       x \\<sqinter> z = y \\<sqinter> z \\<and>\n       x \\<squnion> z = y \\<squnion> z \\<Longrightarrow>\n       x = y", "by (cut_tac A, blast)"], ["proof (state)\nthis:\n  ?x \\<sqinter> ?z = ?y \\<sqinter> ?z \\<and>\n  ?x \\<squnion> ?z = ?y \\<squnion> ?z \\<Longrightarrow>\n  ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       x \\<sqinter> z = y \\<sqinter> z \\<and>\n       x \\<squnion> z = y \\<squnion> z \\<longrightarrow>\n       x = y \\<Longrightarrow>\n    class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "show \"class.distrib_lattice (\\<sqinter>) ((\\<le>)::'a \\<Rightarrow> 'a \\<Rightarrow> bool) (<) (\\<squnion>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply (unfold distrib_not_N5_M5)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a b c. \\<not> N5_lattice a b c) \\<and>\n    (\\<forall>a b c. \\<not> M5_lattice a b c)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c. N5_lattice a b c \\<Longrightarrow> False\n 2. \\<And>a b c. M5_lattice a b c \\<Longrightarrow> False", "apply (unfold N5_lattice_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       a \\<sqinter> c = b \\<sqinter> c \\<and>\n       a < b \\<and> a \\<squnion> c = b \\<squnion> c \\<Longrightarrow>\n       False\n 2. \\<And>a b c. M5_lattice a b c \\<Longrightarrow> False", "apply (cut_tac x = a and y = b and z = c in B)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b c.\n       a \\<sqinter> c = b \\<sqinter> c \\<and>\n       a < b \\<and> a \\<squnion> c = b \\<squnion> c \\<Longrightarrow>\n       a \\<sqinter> c = b \\<sqinter> c \\<and>\n       a \\<squnion> c = b \\<squnion> c\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<sqinter> c = b \\<sqinter> c \\<and>\n                a < b \\<and> a \\<squnion> c = b \\<squnion> c;\n        a = b\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a b c. M5_lattice a b c \\<Longrightarrow> False", "apply (simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c. M5_lattice a b c \\<Longrightarrow> False", "apply (unfold M5_lattice_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       a \\<sqinter> b = b \\<sqinter> c \\<and>\n       c \\<sqinter> a = b \\<sqinter> c \\<and>\n       a \\<squnion> b = b \\<squnion> c \\<and>\n       c \\<squnion> a = b \\<squnion> c \\<and>\n       a \\<sqinter> b < a \\<squnion> b \\<Longrightarrow>\n       False", "apply (cut_tac x = a and y = b and z = c in B)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       a \\<sqinter> b = b \\<sqinter> c \\<and>\n       c \\<sqinter> a = b \\<sqinter> c \\<and>\n       a \\<squnion> b = b \\<squnion> c \\<and>\n       c \\<squnion> a = b \\<squnion> c \\<and>\n       a \\<sqinter> b < a \\<squnion> b \\<Longrightarrow>\n       a \\<sqinter> c = b \\<sqinter> c \\<and>\n       a \\<squnion> c = b \\<squnion> c\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<sqinter> b = b \\<sqinter> c \\<and>\n                c \\<sqinter> a = b \\<sqinter> c \\<and>\n                a \\<squnion> b = b \\<squnion> c \\<and>\n                c \\<squnion> a = b \\<squnion> c \\<and>\n                a \\<sqinter> b < a \\<squnion> b;\n        a = b\\<rbrakk>\n       \\<Longrightarrow> False", "by (simp_all add: inf_commute sup_commute)"], ["proof (state)\nthis:\n  class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "class inf_sup_eq_lattice = lattice +\n  assumes inf_sup_eq: \"x \\<sqinter> z = y \\<sqinter> z \\<Longrightarrow> x \\<squnion> z = y \\<squnion> z \\<Longrightarrow> x = y\"\nbegin"], ["", "subclass distrib_lattice"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "by (metis distrib_inf_sup_eq inf_sup_eq)"], ["", "end"], ["", "end"]]}