{"file_name": "/home/qj213/afp-2021-10-22/thys/Incompleteness/Coding_Predicates.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Incompleteness", "problem_names": ["lemma VarP_eqvt [eqvt]: \"(p \\<bullet> VarP x) = VarP (p \\<bullet> x)\"", "lemma VarP_fresh_iff [simp]: \"a \\<sharp> VarP x \\<longleftrightarrow> a \\<sharp> x\"", "lemma eval_fm_VarP [simp]:  \"eval_fm e (VarP x) \\<longleftrightarrow> is_Var \\<lbrakk>x\\<rbrakk>e\"", "lemma VarP_sf [iff]: \"Sigma_fm (VarP x)\"", "lemma VarP_subst [simp]: \"(VarP x)(i::=t) = VarP (subst i t x) \"", "lemma VarP_cong: \"H \\<turnstile> x EQ x' \\<Longrightarrow> H \\<turnstile> VarP x IFF VarP x'\"", "lemma VarP_HPairE [intro!]: \"insert (VarP (HPair x y)) H \\<turnstile> A\"", "lemma is_Var_succ_iff [simp]: \"is_Var (succ x) = Ord x\"", "lemma is_Var_q_Var [iff]: \"is_Var (q_Var i)\"", "lemma decode_Var_q_Var [simp]: \"decode_Var (q_Var i) = i\"", "lemma is_Var_imp_decode_Var: \"is_Var x \\<Longrightarrow> x = \\<lbrakk>\\<guillemotleft>Var (decode_Var x)\\<guillemotright>\\<rbrakk> e\"", "lemma is_Var_iff: \"is_Var v \\<longleftrightarrow> v = succ (ord_of (nat_of_name (decode_Var v)))\"", "lemma decode_Var_inject [simp]: \"is_Var v \\<Longrightarrow> is_Var v' \\<Longrightarrow> decode_Var v = decode_Var v' \\<longleftrightarrow> v=v'\"", "lemma\n  shows IndP_fresh_iff [simp]: \"a \\<sharp> IndP x \\<longleftrightarrow> a \\<sharp> x\"                (is ?thesis1)\n    and eval_fm_IndP [simp]:   \"eval_fm e (IndP x) \\<longleftrightarrow> is_Ind \\<lbrakk>x\\<rbrakk>e\"  (is ?thesis2)\n    and IndP_sf [iff]:         \"Sigma_fm (IndP x)\"                   (is ?thsf)\n    and OrdP_IndP_Q_Ind:       \"{OrdP x} \\<turnstile> IndP (Q_Ind x)\"           (is ?thqind)", "lemma IndP_Q_Ind: \"H \\<turnstile> OrdP x \\<Longrightarrow> H \\<turnstile> IndP (Q_Ind x)\"", "lemma subst_fm_IndP [simp]: \"(IndP t)(i::=x) = IndP (subst i x t)\"", "lemma IndP_cong: \"H \\<turnstile> x EQ x' \\<Longrightarrow> H \\<turnstile> IndP x IFF IndP x'\"", "lemma is_Ind_pair_iff [simp]: \"is_Ind \\<langle>x, y\\<rangle> \\<longleftrightarrow> x = htuple 6 \\<and> Ord y\"", "lemma eval_Var_q: \"\\<lbrakk>\\<guillemotleft>Var i\\<guillemotright>\\<rbrakk> e = q_Var i\"", "lemma is_Var_eval_Var [simp]: \"is_Var \\<lbrakk>\\<guillemotleft>Var i\\<guillemotright>\\<rbrakk>e\"", "lemma\n  shows SeqCTermP_fresh_iff [simp]:\n       \"a \\<sharp> SeqCTermP vf s k t \\<longleftrightarrow> a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> t\"  (is ?thesis1)\n    and eval_fm_SeqCTermP [simp]:\n       \"eval_fm e (SeqCTermP vf s k t) \\<longleftrightarrow> SeqCTerm vf \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\"    (is ?thesis2)\n    and SeqCTermP_sf [iff]:\n       \"Sigma_fm (SeqCTermP vf s k t)\"   (is ?thsf)\n    and SeqCTermP_imp_LstSeqP:\n      \"{ SeqCTermP vf s k t } \\<turnstile> LstSeqP s k t\"  (is ?thlstseq)\n    and SeqCTermP_imp_OrdP [simp]:\n      \"{ SeqCTermP vf s k t } \\<turnstile> OrdP k\"  (is ?thord)", "lemma SeqCTermP_subst [simp]:\n      \"(SeqCTermP vf s k t)(j::=w) = SeqCTermP vf (subst j w s) (subst j w k) (subst j w t)\"", "lemma SeqConst_imp_SeqTerm: \"SeqConst s k x \\<Longrightarrow> SeqTerm s k x\"", "lemma SeqConstP_imp_SeqTermP: \"{SeqConstP s k t} \\<turnstile> SeqTermP s k t\"", "lemma\n  shows CTermP_fresh_iff [simp]: \"a \\<sharp> CTermP vf t \\<longleftrightarrow> a \\<sharp> t\"            (is ?thesis1)\n    and eval_fm_CTermP [simp] :\"eval_fm e (CTermP vf t) \\<longleftrightarrow> CTerm vf \\<lbrakk>t\\<rbrakk>e\"  (is ?thesis2)\n    and CTermP_sf [iff]: \"Sigma_fm (CTermP vf t)\"                      (is ?thsf)", "lemma CTermP_subst [simp]: \"(CTermP vf i)(j::=w) = CTermP vf (subst j w i)\"", "lemma wf_Term_quot_dbtm [simp]: \"wf_dbtm u \\<Longrightarrow> Term \\<lbrakk>quot_dbtm u\\<rbrakk>e\"", "lemma SeqCTerm_imp_wf_dbtm:\n  assumes \"SeqCTerm vf s k x\"\n  shows \"\\<exists>t::dbtm. wf_dbtm t \\<and> x = \\<lbrakk>quot_dbtm t\\<rbrakk>e\"", "lemma Term_Var: \"Term (q_Var i)\"", "lemma Term_Eats: assumes x: \"Term x\" and y: \"Term y\" shows \"Term (q_Eats x y)\"", "lemma Const_imp_Term: \"Const x \\<Longrightarrow> Term x\"", "lemma Const_0: \"Const 0\"", "lemma ConstP_imp_TermP: \"{ConstP t} \\<turnstile> TermP t\"", "lemma\n  shows SeqStTermP_fresh_iff [simp]:\n      \"a \\<sharp> SeqStTermP v i t u s k \\<longleftrightarrow> a \\<sharp> v \\<and> a \\<sharp> i \\<and> a \\<sharp> t \\<and> a \\<sharp> u \\<and> a \\<sharp> s \\<and> a \\<sharp> k\"  (is ?thesis1)\n    and eval_fm_SeqStTermP [simp]:\n      \"eval_fm e (SeqStTermP v i t u s k) \\<longleftrightarrow> SeqStTerm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e\"  (is ?thesis2)\n    and SeqStTermP_sf [iff]:\n      \"Sigma_fm (SeqStTermP v i t u s k)\"  (is ?thsf)\n    and SeqStTermP_imp_OrdP:\n      \"{ SeqStTermP v i t u s k } \\<turnstile> OrdP k\"  (is ?thord)\n    and SeqStTermP_imp_VarP:\n      \"{ SeqStTermP v i t u s k } \\<turnstile> VarP v\"  (is ?thvar)\n    and SeqStTermP_imp_LstSeqP:\n      \"{ SeqStTermP v i t u s k } \\<turnstile> LstSeqP s k (HPair t u)\"  (is ?thlstseq)", "lemma SeqStTermP_subst [simp]:\n      \"(SeqStTermP v i t u s k)(j::=w) =\n       SeqStTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u) (subst j w s) (subst j w k)\"", "lemma SeqStTermP_cong:\n  \"\\<lbrakk>H \\<turnstile> t EQ t'; H \\<turnstile> u EQ u'; H \\<turnstile> s EQ s'; H \\<turnstile> k EQ k'\\<rbrakk>\n   \\<Longrightarrow> H \\<turnstile> SeqStTermP v i t u s k IFF SeqStTermP v i t' u' s' k'\"", "lemma\n  shows AbstTermP_fresh_iff [simp]:\n      \"a \\<sharp> AbstTermP v i t u \\<longleftrightarrow> a \\<sharp> v \\<and> a \\<sharp> i \\<and> a \\<sharp> t \\<and> a \\<sharp> u\"  (is ?thesis1)\n    and eval_fm_AbstTermP [simp]:\n      \"eval_fm e (AbstTermP v i t u) \\<longleftrightarrow> AbstTerm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e \"  (is ?thesis2)\n    and AbstTermP_sf [iff]:\n      \"Sigma_fm (AbstTermP v i t u)\"  (is ?thsf)", "lemma AbstTermP_subst [simp]:\n      \"(AbstTermP v i t u)(j::=w) = AbstTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u)\"", "lemma not_is_Var_is_Ind: \"is_Var v \\<Longrightarrow> \\<not> is_Ind v\"", "lemma AbstTerm_imp_abst_dbtm:\n  assumes \"AbstTerm v i x x'\"\n  shows \"\\<exists>t. x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n             x' = \\<lbrakk>quot_dbtm (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e\"", "lemma AbstTerm_abst_dbtm:\n     \"AbstTerm (q_Var i) (ord_of n) \\<lbrakk>quot_dbtm t\\<rbrakk>e\n                                    \\<lbrakk>quot_dbtm (abst_dbtm i n t)\\<rbrakk>e\"", "lemma\n  shows SubstTermP_fresh_iff [simp]:\n       \"a \\<sharp> SubstTermP v i t u \\<longleftrightarrow> a \\<sharp> v \\<and> a \\<sharp> i \\<and> a \\<sharp> t \\<and> a \\<sharp> u\"  (is ?thesis1)\n    and eval_fm_SubstTermP [simp]:\n       \"eval_fm e (SubstTermP v i t u) \\<longleftrightarrow> SubstTerm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e\"  (is ?thesis2)\n    and SubstTermP_sf [iff]:\n       \"Sigma_fm (SubstTermP v i t u)\"     (is ?thsf)\n    and SubstTermP_imp_TermP:\n       \"{ SubstTermP v i t u } \\<turnstile> TermP i\"  (is ?thterm)\n    and SubstTermP_imp_VarP:\n       \"{ SubstTermP v i t u } \\<turnstile> VarP v\"   (is ?thvar)", "lemma SubstTermP_subst [simp]:\n      \"(SubstTermP v i t u)(j::=w) = SubstTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u)\"", "lemma SubstTermP_cong:\n  \"\\<lbrakk>H \\<turnstile> v EQ v'; H \\<turnstile> i EQ i'; H \\<turnstile> t EQ t'; H \\<turnstile> u EQ u'\\<rbrakk>\n   \\<Longrightarrow> H \\<turnstile> SubstTermP v i t u IFF SubstTermP v' i' t' u'\"", "lemma SubstTerm_imp_subst_dbtm:\n  assumes \"SubstTerm v \\<lbrakk>quot_dbtm u\\<rbrakk>e x x'\"\n  shows \"\\<exists>t. x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n             x' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e\"", "lemma SubstTerm_subst_dbtm:\n  assumes \"Term \\<lbrakk>quot_dbtm u\\<rbrakk>e\"\n    shows \"SubstTerm (q_Var v) \\<lbrakk>quot_dbtm u\\<rbrakk>e \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<lbrakk>quot_dbtm (subst_dbtm u v t)\\<rbrakk>e\"", "lemma\n  shows AbstAtomicP_fresh_iff [simp]:\n       \"a \\<sharp> AbstAtomicP v i y y' \\<longleftrightarrow> a \\<sharp> v \\<and> a \\<sharp> i \\<and> a \\<sharp> y \\<and> a \\<sharp> y'\"         (is ?thesis1)\n    and eval_fm_AbstAtomicP [simp]:\n       \"eval_fm e (AbstAtomicP v i y y') \\<longleftrightarrow> AbstAtomic \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>y\\<rbrakk>e \\<lbrakk>y'\\<rbrakk>e\"  (is ?thesis2)\n    and AbstAtomicP_sf [iff]: \"Sigma_fm (AbstAtomicP v i y y')\"              (is ?thsf)", "lemma AbstAtomicP_subst [simp]:\n      \"(AbstAtomicP v tm y y')(i::=w) = AbstAtomicP (subst i w v) (subst i w tm) (subst i w y) (subst i w y')\"", "lemma\n  shows SeqAbstFormP_fresh_iff [simp]:\n       \"a \\<sharp> SeqAbstFormP v i x x' s k \\<longleftrightarrow> a \\<sharp> v \\<and> a \\<sharp> i \\<and> a \\<sharp> x \\<and> a \\<sharp> x' \\<and> a \\<sharp> s \\<and> a \\<sharp> k\"  (is ?thesis1)\n    and eval_fm_SeqAbstFormP [simp]:\n       \"eval_fm e (SeqAbstFormP v i x x' s k) \\<longleftrightarrow> SeqAbstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>x\\<rbrakk>e \\<lbrakk>x'\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e\" (is ?thesis2)\n    and SeqAbstFormP_sf [iff]:\n       \"Sigma_fm (SeqAbstFormP v i x x' s k)\"  (is ?thsf)", "lemma SeqAbstFormP_subst [simp]:\n      \"(SeqAbstFormP v u x x' s k)(i::=t) =\n       SeqAbstFormP (subst i t v) (subst i t u) (subst i t x) (subst i t x') (subst i t s) (subst i t k)\"", "lemma\n  shows AbstFormP_fresh_iff [simp]:\n       \"a \\<sharp> AbstFormP v i x x' \\<longleftrightarrow> a \\<sharp> v \\<and> a \\<sharp> i \\<and> a \\<sharp> x \\<and> a \\<sharp> x'\" (is ?thesis1)\n    and eval_fm_AbstFormP [simp]:\n       \"eval_fm e (AbstFormP v i x x') \\<longleftrightarrow> AbstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>x\\<rbrakk>e \\<lbrakk>x'\\<rbrakk>e\" (is ?thesis2)\n    and AbstFormP_sf [iff]:\n       \"Sigma_fm (AbstFormP v i x x')\"    (is ?thsf)", "lemma AbstFormP_subst [simp]:\n     \"(AbstFormP v i x x')(j::=t) = AbstFormP (subst j t v) (subst j t i) (subst j t x) (subst j t x')\"", "lemma AbstForm_imp_Ord: \"AbstForm v u x x' \\<Longrightarrow> Ord v\"", "lemma AbstForm_imp_abst_dbfm:\n  assumes \"AbstForm v i x x'\"\n  shows \"\\<exists>A. x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n             x' = \\<lbrakk>quot_dbfm (abst_dbfm (decode_Var v) (nat_of_ord i) A)\\<rbrakk>e\"", "lemma AbstForm_abst_dbfm:\n  \"AbstForm (q_Var i) (ord_of n) \\<lbrakk>quot_dbfm fm\\<rbrakk>e \\<lbrakk>quot_dbfm (abst_dbfm i n fm)\\<rbrakk>e\"", "lemma\n  shows SubstAtomicP_fresh_iff [simp]:\n       \"a \\<sharp> SubstAtomicP v tm y y' \\<longleftrightarrow> a \\<sharp> v \\<and> a \\<sharp> tm \\<and> a \\<sharp> y \\<and> a \\<sharp> y'\"           (is ?thesis1)\n    and eval_fm_SubstAtomicP [simp]:\n       \"eval_fm e (SubstAtomicP v tm y y') \\<longleftrightarrow> SubstAtomic \\<lbrakk>v\\<rbrakk>e \\<lbrakk>tm\\<rbrakk>e \\<lbrakk>y\\<rbrakk>e \\<lbrakk>y'\\<rbrakk>e\"  (is ?thesis2)\n    and SubstAtomicP_sf [iff]: \"Sigma_fm (SubstAtomicP v tm y y')\"               (is ?thsf)", "lemma SubstAtomicP_subst [simp]:\n  \"(SubstAtomicP v tm y y')(i::=w) = SubstAtomicP (subst i w v) (subst i w tm) (subst i w y) (subst i w y')\"", "lemma SubstAtomicP_cong:\n  \"\\<lbrakk>H \\<turnstile> v EQ v'; H \\<turnstile> tm EQ tm'; H \\<turnstile> x EQ x'; H \\<turnstile> y EQ y'\\<rbrakk>\n   \\<Longrightarrow> H \\<turnstile> SubstAtomicP v tm x y IFF SubstAtomicP v' tm' x' y'\"", "lemma\n  shows SeqSubstFormP_fresh_iff [simp]:\n       \"a \\<sharp> SeqSubstFormP v u x x' s k \\<longleftrightarrow> a \\<sharp> v \\<and> a \\<sharp> u \\<and> a \\<sharp> x \\<and> a \\<sharp> x' \\<and> a \\<sharp> s \\<and> a \\<sharp> k\"  (is ?thesis1)\n    and eval_fm_SeqSubstFormP [simp]:\n       \"eval_fm e (SeqSubstFormP v u x x' s k) \\<longleftrightarrow> \n         SeqSubstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e \\<lbrakk>x\\<rbrakk>e \\<lbrakk>x'\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e\" (is ?thesis2)\n    and SeqSubstFormP_sf [iff]:\n       \"Sigma_fm (SeqSubstFormP v u x x' s k)\"  (is ?thsf)\n    and SeqSubstFormP_imp_OrdP:\n       \"{ SeqSubstFormP v u x x' s k } \\<turnstile> OrdP k\"  (is ?thOrd)\n    and SeqSubstFormP_imp_LstSeqP:\n       \"{ SeqSubstFormP v u x x' s k } \\<turnstile> LstSeqP s k (HPair x x')\"  (is ?thLstSeq)", "lemma SeqSubstFormP_subst [simp]:\n      \"(SeqSubstFormP v u x x' s k)(i::=t) =\n       SeqSubstFormP (subst i t v) (subst i t u) (subst i t x) (subst i t x') (subst i t s) (subst i t k)\"", "lemma SeqSubstFormP_cong:\n  \"\\<lbrakk>H \\<turnstile> t EQ t'; H \\<turnstile> u EQ u'; H \\<turnstile> s EQ s'; H \\<turnstile> k EQ k'\\<rbrakk>\n   \\<Longrightarrow> H \\<turnstile> SeqSubstFormP v i t u s k IFF SeqSubstFormP v i t' u' s' k'\"", "lemma\n  shows SubstFormP_fresh_iff [simp]:\n       \"a \\<sharp> SubstFormP v i x x' \\<longleftrightarrow> a \\<sharp> v \\<and> a \\<sharp> i \\<and> a \\<sharp> x \\<and> a \\<sharp> x'\"  (is ?thesis1)\n    and eval_fm_SubstFormP [simp]:\n       \"eval_fm e (SubstFormP v i x x') \\<longleftrightarrow> SubstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>x\\<rbrakk>e \\<lbrakk>x'\\<rbrakk>e\"  (is ?thesis2)\n    and SubstFormP_sf [iff]:\n       \"Sigma_fm (SubstFormP v i x x')\"  (is ?thsf)", "lemma SubstFormP_subst [simp]:\n     \"(SubstFormP v i x x')(j::=t) = SubstFormP (subst j t v) (subst j t i) (subst j t x) (subst j t x')\"", "lemma SubstFormP_cong:\n  \"\\<lbrakk>H \\<turnstile> v EQ v'; H \\<turnstile> i EQ i'; H \\<turnstile> t EQ t'; H \\<turnstile> u EQ u'\\<rbrakk>\n   \\<Longrightarrow> H \\<turnstile> SubstFormP v i t u IFF SubstFormP v' i' t' u'\"", "lemma ground_SubstFormP [simp]: \"ground_fm (SubstFormP v y x x') \\<longleftrightarrow> ground v \\<and> ground y \\<and> ground x \\<and> ground x'\"", "lemma SubstForm_imp_subst_dbfm_lemma:\n  assumes \"SubstForm v \\<lbrakk>quot_dbtm u\\<rbrakk>e x x'\"\n    shows \"\\<exists>A. x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n               x' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\"", "lemma SubstForm_imp_subst_dbfm:\n  assumes \"SubstForm v u x x'\"\n   obtains t A where \"u = \\<lbrakk>quot_dbtm t\\<rbrakk>e\"\n                     \"x = \\<lbrakk>quot_dbfm A\\<rbrakk>e\"\n                     \"x' = \\<lbrakk>quot_dbfm (subst_dbfm t (decode_Var v) A)\\<rbrakk>e\"", "lemma SubstForm_subst_dbfm:\n  assumes u: \"wf_dbtm u\"\n  shows \"SubstForm (q_Var i) \\<lbrakk>quot_dbtm u\\<rbrakk>e \\<lbrakk>quot_dbfm A\\<rbrakk>e\n                             \\<lbrakk>quot_dbfm (subst_dbfm u i A)\\<rbrakk>e\"", "lemma\n  shows AtomicP_fresh_iff [simp]: \"a \\<sharp> AtomicP y \\<longleftrightarrow> a \\<sharp> y\"    (is ?thesis1)\n    and eval_fm_AtomicP [simp]: \"eval_fm e (AtomicP y) \\<longleftrightarrow> Atomic\\<lbrakk>y\\<rbrakk>e\"    (is ?thesis2)\n    and AtomicP_sf [iff]: \"Sigma_fm (AtomicP y)\"  (is ?thsf)", "lemma\n  shows MakeFormP_fresh_iff [simp]:\n       \"a \\<sharp> MakeFormP y u w \\<longleftrightarrow> a \\<sharp> y \\<and> a \\<sharp> u \\<and> a \\<sharp> w\"  (is ?thesis1)\n    and eval_fm_MakeFormP [simp]:\n       \"eval_fm e (MakeFormP y u w) \\<longleftrightarrow> MakeForm \\<lbrakk>y\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e \\<lbrakk>w\\<rbrakk>e\"  (is ?thesis2)\n    and MakeFormP_sf [iff]:\n       \"Sigma_fm (MakeFormP y u w)\"  (is ?thsf)", "lemma\n  shows SeqFormP_fresh_iff [simp]:\n       \"a \\<sharp> SeqFormP s k t \\<longleftrightarrow> a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> t\" (is ?thesis1)\n    and eval_fm_SeqFormP [simp]:\n       \"eval_fm e (SeqFormP s k t) \\<longleftrightarrow> SeqForm \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\"   (is ?thesis2)\n    and SeqFormP_sf [iff]: \"Sigma_fm (SeqFormP s k t)\"          (is ?thsf)", "lemma SeqFormP_subst [simp]:\n      \"(SeqFormP s k t)(j::=w) = SeqFormP (subst j w s) (subst j w k) (subst j w t)\"", "lemma\n  shows FormP_fresh_iff [simp]: \"a \\<sharp> FormP y \\<longleftrightarrow> a \\<sharp> y\"              (is ?thesis1)\n    and eval_fm_FormP [simp]:   \"eval_fm e (FormP y) \\<longleftrightarrow> Form \\<lbrakk>y\\<rbrakk>e\"  (is ?thesis2)\n    and FormP_sf [iff]:         \"Sigma_fm (FormP y)\"                 (is ?thsf)", "lemma FormP_subst [simp]: \"(FormP y)(j::=w) = FormP (subst j w y)\"", "lemma AbstForm_trans_fm:\n  \"AbstForm (q_Var i) 0 \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e\"", "lemma wf_Form_quot_dbfm [simp]:\n  assumes \"wf_dbfm A\" shows \"Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\"", "lemma Form_quot_fm [iff]: fixes A :: fm  shows \"Form \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\"", "lemma Atomic_Form_is_wf_dbfm: \"Atomic x \\<Longrightarrow> \\<exists>A. wf_dbfm A \\<and> x = \\<lbrakk>quot_dbfm A\\<rbrakk>e\"", "lemma SeqForm_imp_wf_dbfm:\n  assumes \"SeqForm s k x\"\n  shows \"\\<exists>A. wf_dbfm A \\<and> x = \\<lbrakk>quot_dbfm A\\<rbrakk>e\"", "lemma Form_imp_wf_dbfm:\n  assumes \"Form x\" obtains A where \"wf_dbfm A\" \"x = \\<lbrakk>quot_dbfm A\\<rbrakk>e\"", "lemma Form_imp_is_fm: assumes \"Form x\" obtains A::fm where \"x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk> e\"", "lemma SubstForm_imp_subst_fm:\n  assumes \"SubstForm v \\<lbrakk>\\<guillemotleft>u\\<guillemotright>\\<rbrakk>e x x'\" \"Form x\"\n  obtains A::fm where \"x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk> e\" \"x' = \\<lbrakk>\\<guillemotleft>A(decode_Var v::=u)\\<guillemotright>\\<rbrakk> e\"", "lemma SubstForm_unique:\n  assumes \"is_Var v\" and \"Term y\" and \"Form x\"\n     shows \"SubstForm v y x x' \\<longleftrightarrow>\n            (\\<exists>t::tm. y = \\<lbrakk>\\<guillemotleft>t\\<guillemotright>\\<rbrakk>e \\<and> (\\<exists>A::fm. x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and> x' = \\<lbrakk>\\<guillemotleft>A(decode_Var v::=t)\\<guillemotright>\\<rbrakk>e))\"", "lemma SubstForm_quot_unique: \"SubstForm (q_Var i) \\<lbrakk>\\<guillemotleft>t\\<guillemotright>\\<rbrakk>e \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e x' \\<longleftrightarrow> x' = \\<lbrakk>\\<guillemotleft>A(i::=t)\\<guillemotright>\\<rbrakk> e\"", "lemma SubstForm_quot: \"SubstForm \\<lbrakk>\\<guillemotleft>Var i\\<guillemotright>\\<rbrakk>e \\<lbrakk>\\<guillemotleft>t\\<guillemotright>\\<rbrakk>e \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<lbrakk>\\<guillemotleft>A(i::=t)\\<guillemotright>\\<rbrakk>e\"", "lemma\n  shows VarNonOccFormP_fresh_iff [simp]: \"a \\<sharp> VarNonOccFormP v y \\<longleftrightarrow> a \\<sharp> v \\<and> a \\<sharp> y\" (is ?thesis1)\n    and eval_fm_VarNonOccFormP [simp]:\n       \"eval_fm e (VarNonOccFormP v y) \\<longleftrightarrow> VarNonOccForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>y\\<rbrakk>e\"    (is ?thesis2)\n    and VarNonOccFormP_sf [iff]: \"Sigma_fm (VarNonOccFormP v y)\" (is ?thsf)", "lemma VarNonOccForm_imp_dbfm_fresh:\n  assumes \"VarNonOccForm v x\" \n  shows \"\\<exists>A. wf_dbfm A \\<and> x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and> atom (decode_Var v) \\<sharp> A\"", "lemma VarNonOccForm_dbfm:\n  \"wf_dbfm A \\<Longrightarrow> atom i \\<sharp> A \\<Longrightarrow> VarNonOccForm (q_Var i) \\<lbrakk>quot_dbfm A\\<rbrakk>e\""], "translations": [["", "lemma VarP_eqvt [eqvt]: \"(p \\<bullet> VarP x) = VarP (p \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> VarP x = VarP (p \\<bullet> x)", "by (simp add: VarP_def)"], ["", "lemma VarP_fresh_iff [simp]: \"a \\<sharp> VarP x \\<longleftrightarrow> a \\<sharp> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> VarP x = a \\<sharp> x", "by (simp add: VarP_def)"], ["", "lemma eval_fm_VarP [simp]:  \"eval_fm e (VarP x) \\<longleftrightarrow> is_Var \\<lbrakk>x\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_fm e (VarP x) = is_Var \\<lbrakk>x\\<rbrakk>e", "by (simp add: VarP_def is_Var_def)"], ["", "lemma VarP_sf [iff]: \"Sigma_fm (VarP x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_fm (VarP x)", "by (auto simp: VarP_def)"], ["", "lemma VarP_subst [simp]: \"(VarP x)(i::=t) = VarP (subst i t x) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (VarP x)(i::=t) = VarP (subst i t x)", "by (simp add: VarP_def)"], ["", "lemma VarP_cong: \"H \\<turnstile> x EQ x' \\<Longrightarrow> H \\<turnstile> VarP x IFF VarP x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> x EQ x' \\<Longrightarrow>\n    H \\<turnstile> VarP x IFF VarP x'", "by (rule P1_cong) auto"], ["", "lemma VarP_HPairE [intro!]: \"insert (VarP (HPair x y)) H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (VarP (HPair x y)) H \\<turnstile> A", "by (auto simp: VarP_def)"], ["", "lemma is_Var_succ_iff [simp]: \"is_Var (succ x) = Ord x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Var (succ x) = Ord x", "by (metis Ord_succ_iff is_Var_def succ_iff zero_in_Ord)"], ["", "lemma is_Var_q_Var [iff]: \"is_Var (q_Var i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Var (q_Var i)", "by (simp add: q_Var_def)"], ["", "definition decode_Var :: \"hf \\<Rightarrow> name\"\n  where \"decode_Var x \\<equiv> name_of_nat (nat_of_ord (pred x))\""], ["", "lemma decode_Var_q_Var [simp]: \"decode_Var (q_Var i) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decode_Var (q_Var i) = i", "by (simp add: decode_Var_def q_Var_def)"], ["", "lemma is_Var_imp_decode_Var: \"is_Var x \\<Longrightarrow> x = \\<lbrakk>\\<guillemotleft>Var (decode_Var x)\\<guillemotright>\\<rbrakk> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Var x \\<Longrightarrow>\n    x =\n    \\<lbrakk>\\<guillemotleft>Var (decode_Var x)\\<guillemotright>\\<rbrakk>e", "by (simp add: is_Var_def quot_Var decode_Var_def) (metis hempty_iff succ_pred)"], ["", "lemma is_Var_iff: \"is_Var v \\<longleftrightarrow> v = succ (ord_of (nat_of_name (decode_Var v)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Var v = (v = succ (ord_of (nat_of_name (decode_Var v))))", "by (metis eval_tm_ORD_OF eval_tm_SUCC is_Var_imp_decode_Var quot_Var is_Var_succ_iff Ord_ord_of)"], ["", "lemma decode_Var_inject [simp]: \"is_Var v \\<Longrightarrow> is_Var v' \\<Longrightarrow> decode_Var v = decode_Var v' \\<longleftrightarrow> v=v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_Var v; is_Var v'\\<rbrakk>\n    \\<Longrightarrow> (decode_Var v = decode_Var v') = (v = v')", "by (metis is_Var_iff)"], ["", "subsection \\<open>De Bruijn Indexes\\<close>"], ["", "definition is_Ind :: \"hf \\<Rightarrow> bool\"\n  where \"is_Ind x \\<equiv> (\\<exists>m. Ord m \\<and> x = \\<langle>htuple 6, m\\<rangle>)\""], ["", "abbreviation Q_Ind :: \"tm \\<Rightarrow> tm\"\n  where \"Q_Ind k \\<equiv> HPair (HTuple 6) k\""], ["", "nominal_function IndP :: \"tm \\<Rightarrow> fm\"\n  where \"atom m \\<sharp> x \\<Longrightarrow>\n    IndP x = Ex m (OrdP (Var m) AND x EQ HPair (HTuple 6) (Var m))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt IndP_graph_aux\n 2. \\<And>x y. IndP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>m xa.\n           \\<lbrakk>atom m \\<sharp> xa; x = xa\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>m x ma xa.\n       \\<lbrakk>atom m \\<sharp> x; atom ma \\<sharp> xa; x = xa\\<rbrakk>\n       \\<Longrightarrow> SyntaxN.Ex m\n                          (OrdP (Var m) AND x EQ Q_Ind (Var m)) =\n                         SyntaxN.Ex ma\n                          (OrdP (Var ma) AND xa EQ Q_Ind (Var ma))", "by (auto simp: eqvt_def IndP_graph_aux_def flip_fresh_fresh) (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All IndP_dom", "by lexicographic_order"], ["", "lemma\n  shows IndP_fresh_iff [simp]: \"a \\<sharp> IndP x \\<longleftrightarrow> a \\<sharp> x\"                (is ?thesis1)\n    and eval_fm_IndP [simp]:   \"eval_fm e (IndP x) \\<longleftrightarrow> is_Ind \\<lbrakk>x\\<rbrakk>e\"  (is ?thesis2)\n    and IndP_sf [iff]:         \"Sigma_fm (IndP x)\"                   (is ?thsf)\n    and OrdP_IndP_Q_Ind:       \"{OrdP x} \\<turnstile> IndP (Q_Ind x)\"           (is ?thqind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<sharp> IndP x = a \\<sharp> x &&&\n     eval_fm e (IndP x) = is_Ind \\<lbrakk>x\\<rbrakk>e) &&&\n    Sigma_fm (IndP x) &&& {OrdP x} \\<turnstile> IndP (Q_Ind x)", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. a \\<sharp> IndP x = a \\<sharp> x\n 2. eval_fm e (IndP x) = is_Ind \\<lbrakk>x\\<rbrakk>e\n 3. Sigma_fm (IndP x)\n 4. {OrdP x} \\<turnstile> IndP (Q_Ind x)", "obtain m::name where \"atom m \\<sharp> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m. atom m \\<sharp> x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom m \\<sharp> x\n\ngoal (4 subgoals):\n 1. a \\<sharp> IndP x = a \\<sharp> x\n 2. eval_fm e (IndP x) = is_Ind \\<lbrakk>x\\<rbrakk>e\n 3. Sigma_fm (IndP x)\n 4. {OrdP x} \\<turnstile> IndP (Q_Ind x)", "thus ?thesis1 ?thesis2 ?thsf ?thqind"], ["proof (prove)\nusing this:\n  atom m \\<sharp> x\n\ngoal (1 subgoal):\n 1. (a \\<sharp> IndP x = a \\<sharp> x &&&\n     eval_fm e (IndP x) = is_Ind \\<lbrakk>x\\<rbrakk>e) &&&\n    Sigma_fm (IndP x) &&& {OrdP x} \\<turnstile> IndP (Q_Ind x)", "by (auto simp: is_Ind_def intro: Ex_I [where x=x])"], ["proof (state)\nthis:\n  a \\<sharp> IndP x = a \\<sharp> x\n  eval_fm e (IndP x) = is_Ind \\<lbrakk>x\\<rbrakk>e\n  Sigma_fm (IndP x)\n  {OrdP x} \\<turnstile> IndP (Q_Ind x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma IndP_Q_Ind: \"H \\<turnstile> OrdP x \\<Longrightarrow> H \\<turnstile> IndP (Q_Ind x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> OrdP x \\<Longrightarrow> H \\<turnstile> IndP (Q_Ind x)", "by (rule cut1 [OF OrdP_IndP_Q_Ind])"], ["", "lemma subst_fm_IndP [simp]: \"(IndP t)(i::=x) = IndP (subst i x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (IndP t)(i::=x) = IndP (subst i x t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (IndP t)(i::=x) = IndP (subst i x t)", "obtain m::name where \"atom m \\<sharp> (i,t,x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m.\n        atom m \\<sharp> (i, t, x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom m \\<sharp> (i, t, x)\n\ngoal (1 subgoal):\n 1. (IndP t)(i::=x) = IndP (subst i x t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom m \\<sharp> (i, t, x)\n\ngoal (1 subgoal):\n 1. (IndP t)(i::=x) = IndP (subst i x t)", "by (auto simp: IndP.simps [of m])"], ["proof (state)\nthis:\n  (IndP t)(i::=x) = IndP (subst i x t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma IndP_cong: \"H \\<turnstile> x EQ x' \\<Longrightarrow> H \\<turnstile> IndP x IFF IndP x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> x EQ x' \\<Longrightarrow>\n    H \\<turnstile> IndP x IFF IndP x'", "by (rule P1_cong) auto"], ["", "definition decode_Ind :: \"hf \\<Rightarrow> nat\"\n  where \"decode_Ind x \\<equiv> nat_of_ord (hsnd x)\""], ["", "lemma is_Ind_pair_iff [simp]: \"is_Ind \\<langle>x, y\\<rangle> \\<longleftrightarrow> x = htuple 6 \\<and> Ord y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Ind \\<langle>x, y\\<rangle> = (x = htuple 6 \\<and> Ord y)", "by (auto simp: is_Ind_def)"], ["", "subsection \\<open>Various syntactic lemmas\\<close>"], ["", "lemma eval_Var_q: \"\\<lbrakk>\\<guillemotleft>Var i\\<guillemotright>\\<rbrakk> e = q_Var i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<guillemotleft>Var i\\<guillemotright>\\<rbrakk>e = q_Var i", "by (simp add: quot_tm_def q_Var_def)"], ["", "lemma is_Var_eval_Var [simp]: \"is_Var \\<lbrakk>\\<guillemotleft>Var i\\<guillemotright>\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Var \\<lbrakk>\\<guillemotleft>Var i\\<guillemotright>\\<rbrakk>e", "by (metis decode_Var_q_Var is_Var_imp_decode_Var is_Var_q_Var)"], ["", "section \\<open>The predicate \\<open>SeqCTermP\\<close>, for Terms and Constants\\<close>"], ["", "(*SeqCTerm(s,k,t) \\<equiv> LstSeq(s,k,t) \\<and> (\\<forall>l\\<in>k)[s l=0 \\<or> Var(s l)\\<or>(\\<exists>m,n\\<in>l)[s l = \\<langle>Eats, s m, s n\\<rangle>]]*)"], ["", "definition SeqCTerm :: \"bool \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> bool\"\n  where \"SeqCTerm vf s k t \\<equiv> BuildSeq (\\<lambda>u. u=0 \\<or> vf \\<and> is_Var u) (\\<lambda>u v w. u = q_Eats v w) s k t\""], ["", "nominal_function SeqCTermP :: \"bool \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> fm\"\n  where \"\\<lbrakk>atom l \\<sharp> (s,k,sl,m,n,sm,sn);  atom sl \\<sharp> (s,m,n,sm,sn);\n          atom m \\<sharp> (s,n,sm,sn);  atom n \\<sharp> (s,sm,sn);\n          atom sm \\<sharp> (s,sn);  atom sn \\<sharp> (s)\\<rbrakk> \\<Longrightarrow>\n    SeqCTermP vf s k t =\n      LstSeqP s k t AND\n      All2 l (SUCC k) (Ex sl (HPair (Var l) (Var sl) IN s AND \n               (Var sl EQ Zero OR (if vf then VarP (Var sl) else Fls) OR\n                Ex m (Ex n (Ex sm (Ex sn (Var m IN Var l AND Var n IN Var l AND\n                       HPair (Var m) (Var sm) IN s AND HPair (Var n) (Var sn) IN s AND\n                       Var sl EQ Q_Eats (Var sm) (Var sn))))))))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt SeqCTermP_graph_aux\n 2. \\<And>x y. SeqCTermP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>l s k sl m n sm sn vf t.\n           \\<lbrakk>atom l \\<sharp> (s, k, sl, m, n, sm, sn);\n            atom sl \\<sharp> (s, m, n, sm, sn);\n            atom m \\<sharp> (s, n, sm, sn); atom n \\<sharp> (s, sm, sn);\n            atom sm \\<sharp> (s, sn); atom sn \\<sharp> s;\n            x = (vf, s, k, t)\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>l s k sl m n sm sn vf t la sa ka sla ma na sma sna vfa ta.\n       \\<lbrakk>atom l \\<sharp> (s, k, sl, m, n, sm, sn);\n        atom sl \\<sharp> (s, m, n, sm, sn); atom m \\<sharp> (s, n, sm, sn);\n        atom n \\<sharp> (s, sm, sn); atom sm \\<sharp> (s, sn);\n        atom sn \\<sharp> s;\n        atom la \\<sharp> (sa, ka, sla, ma, na, sma, sna);\n        atom sla \\<sharp> (sa, ma, na, sma, sna);\n        atom ma \\<sharp> (sa, na, sma, sna);\n        atom na \\<sharp> (sa, sma, sna); atom sma \\<sharp> (sa, sna);\n        atom sna \\<sharp> sa; (vf, s, k, t) = (vfa, sa, ka, ta)\\<rbrakk>\n       \\<Longrightarrow> LstSeqP s k t AND\n                         All2 l (SUCC k)\n                          (SyntaxN.Ex sl\n                            (HPair (Var l) (Var sl) IN s AND\n                             (Var sl EQ Zero OR\n                              (if vf then VarP (Var sl) else Fls) OR\n                              SyntaxN.Ex m\n                               (SyntaxN.Ex n\n                                 (SyntaxN.Ex sm\n                                   (SyntaxN.Ex sn\n                                     (Var m IN Var l AND\nVar n IN Var l AND\nHPair (Var m) (Var sm) IN s AND\nHPair (Var n) (Var sn) IN s AND Var sl EQ Q_Eats (Var sm) (Var sn)))))))) =\n                         LstSeqP sa ka ta AND\n                         All2 la (SUCC ka)\n                          (SyntaxN.Ex sla\n                            (HPair (Var la) (Var sla) IN sa AND\n                             (Var sla EQ Zero OR\n                              (if vfa then VarP (Var sla) else Fls) OR\n                              SyntaxN.Ex ma\n                               (SyntaxN.Ex na\n                                 (SyntaxN.Ex sma\n                                   (SyntaxN.Ex sna\n                                     (Var ma IN Var la AND\nVar na IN Var la AND\nHPair (Var ma) (Var sma) IN sa AND\nHPair (Var na) (Var sna) IN sa AND\nVar sla EQ Q_Eats (Var sma) (Var sna))))))))", "by (auto simp: eqvt_def SeqCTermP_graph_aux_def flip_fresh_fresh) (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All SeqCTermP_dom", "by lexicographic_order"], ["", "lemma\n  shows SeqCTermP_fresh_iff [simp]:\n       \"a \\<sharp> SeqCTermP vf s k t \\<longleftrightarrow> a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> t\"  (is ?thesis1)\n    and eval_fm_SeqCTermP [simp]:\n       \"eval_fm e (SeqCTermP vf s k t) \\<longleftrightarrow> SeqCTerm vf \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\"    (is ?thesis2)\n    and SeqCTermP_sf [iff]:\n       \"Sigma_fm (SeqCTermP vf s k t)\"   (is ?thsf)\n    and SeqCTermP_imp_LstSeqP:\n      \"{ SeqCTermP vf s k t } \\<turnstile> LstSeqP s k t\"  (is ?thlstseq)\n    and SeqCTermP_imp_OrdP [simp]:\n      \"{ SeqCTermP vf s k t } \\<turnstile> OrdP k\"  (is ?thord)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<sharp> SeqCTermP vf s k t =\n     (a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> t) &&&\n     eval_fm e (SeqCTermP vf s k t) =\n     SeqCTerm vf \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e\n      \\<lbrakk>t\\<rbrakk>e) &&&\n    Sigma_fm (SeqCTermP vf s k t) &&&\n    {SeqCTermP vf s k t} \\<turnstile> LstSeqP s k t &&&\n    {SeqCTermP vf s k t} \\<turnstile> OrdP k", "proof -"], ["proof (state)\ngoal (5 subgoals):\n 1. a \\<sharp> SeqCTermP vf s k t =\n    (a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> t)\n 2. eval_fm e (SeqCTermP vf s k t) =\n    SeqCTerm vf \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e\n     \\<lbrakk>t\\<rbrakk>e\n 3. Sigma_fm (SeqCTermP vf s k t)\n 4. {SeqCTermP vf s k t} \\<turnstile> LstSeqP s k t\n 5. {SeqCTermP vf s k t} \\<turnstile> OrdP k", "obtain l::name and sl::name and m::name and n::name and sm::name and sn::name\n    where atoms: \"atom l \\<sharp> (s,k,sl,m,n,sm,sn)\"   \"atom sl \\<sharp> (s,m,n,sm,sn)\"\n        \"atom m \\<sharp> (s,n,sm,sn)\"   \"atom n \\<sharp> (s,sm,sn)\"\n        \"atom sm \\<sharp> (s,sn)\"   \"atom sn \\<sharp> (s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l sl m n sm sn.\n        \\<lbrakk>atom l \\<sharp> (s, k, sl, m, n, sm, sn);\n         atom sl \\<sharp> (s, m, n, sm, sn); atom m \\<sharp> (s, n, sm, sn);\n         atom n \\<sharp> (s, sm, sn); atom sm \\<sharp> (s, sn);\n         atom sn \\<sharp> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom l \\<sharp> (s, k, sl, m, n, sm, sn)\n  atom sl \\<sharp> (s, m, n, sm, sn)\n  atom m \\<sharp> (s, n, sm, sn)\n  atom n \\<sharp> (s, sm, sn)\n  atom sm \\<sharp> (s, sn)\n  atom sn \\<sharp> s\n\ngoal (5 subgoals):\n 1. a \\<sharp> SeqCTermP vf s k t =\n    (a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> t)\n 2. eval_fm e (SeqCTermP vf s k t) =\n    SeqCTerm vf \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e\n     \\<lbrakk>t\\<rbrakk>e\n 3. Sigma_fm (SeqCTermP vf s k t)\n 4. {SeqCTermP vf s k t} \\<turnstile> LstSeqP s k t\n 5. {SeqCTermP vf s k t} \\<turnstile> OrdP k", "thus ?thesis1 ?thsf ?thlstseq ?thord"], ["proof (prove)\nusing this:\n  atom l \\<sharp> (s, k, sl, m, n, sm, sn)\n  atom sl \\<sharp> (s, m, n, sm, sn)\n  atom m \\<sharp> (s, n, sm, sn)\n  atom n \\<sharp> (s, sm, sn)\n  atom sm \\<sharp> (s, sn)\n  atom sn \\<sharp> s\n\ngoal (1 subgoal):\n 1. (a \\<sharp> SeqCTermP vf s k t =\n     (a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> t) &&&\n     Sigma_fm (SeqCTermP vf s k t)) &&&\n    {SeqCTermP vf s k t} \\<turnstile> LstSeqP s k t &&&\n    {SeqCTermP vf s k t} \\<turnstile> OrdP k", "by (auto simp: LstSeqP.simps)"], ["proof (state)\nthis:\n  a \\<sharp> SeqCTermP vf s k t =\n  (a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> t)\n  Sigma_fm (SeqCTermP vf s k t)\n  {SeqCTermP vf s k t} \\<turnstile> LstSeqP s k t\n  {SeqCTermP vf s k t} \\<turnstile> OrdP k\n\ngoal (1 subgoal):\n 1. eval_fm e (SeqCTermP vf s k t) =\n    SeqCTerm vf \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e\n     \\<lbrakk>t\\<rbrakk>e", "show ?thesis2"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_fm e (SeqCTermP vf s k t) =\n    SeqCTerm vf \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e\n     \\<lbrakk>t\\<rbrakk>e", "using atoms"], ["proof (prove)\nusing this:\n  atom l \\<sharp> (s, k, sl, m, n, sm, sn)\n  atom sl \\<sharp> (s, m, n, sm, sn)\n  atom m \\<sharp> (s, n, sm, sn)\n  atom n \\<sharp> (s, sm, sn)\n  atom sm \\<sharp> (s, sn)\n  atom sn \\<sharp> s\n\ngoal (1 subgoal):\n 1. eval_fm e (SeqCTermP vf s k t) =\n    SeqCTerm vf \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e\n     \\<lbrakk>t\\<rbrakk>e", "by (simp cong: conj_cong add: LstSeq_imp_Ord SeqCTerm_def BuildSeq_def Builds_def\n             HBall_def HBex_def q_Eats_def Fls_def\n             Seq_iff_app [of \"\\<lbrakk>s\\<rbrakk>e\", OF LstSeq_imp_Seq_succ]\n             Ord_trans [of _ _ \"succ \\<lbrakk>k\\<rbrakk>e\"])"], ["proof (state)\nthis:\n  eval_fm e (SeqCTermP vf s k t) =\n  SeqCTerm vf \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SeqCTermP_subst [simp]:\n      \"(SeqCTermP vf s k t)(j::=w) = SeqCTermP vf (subst j w s) (subst j w k) (subst j w t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SeqCTermP vf s k t)(j::=w) =\n    SeqCTermP vf (subst j w s) (subst j w k) (subst j w t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (SeqCTermP vf s k t)(j::=w) =\n    SeqCTermP vf (subst j w s) (subst j w k) (subst j w t)", "obtain l::name and sl::name and m::name and n::name and sm::name and sn::name\n    where \"atom l \\<sharp> (j,w,s,k,sl,m,n,sm,sn)\"   \"atom sl \\<sharp> (j,w,s,m,n,sm,sn)\"\n          \"atom m \\<sharp> (j,w,s,n,sm,sn)\"   \"atom n \\<sharp> (j,w,s,sm,sn)\"\n          \"atom sm \\<sharp> (j,w,s,sn)\"   \"atom sn \\<sharp> (j,w,s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l sl m n sm sn.\n        \\<lbrakk>atom l \\<sharp> (j, w, s, k, sl, m, n, sm, sn);\n         atom sl \\<sharp> (j, w, s, m, n, sm, sn);\n         atom m \\<sharp> (j, w, s, n, sm, sn);\n         atom n \\<sharp> (j, w, s, sm, sn); atom sm \\<sharp> (j, w, s, sn);\n         atom sn \\<sharp> (j, w, s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom l \\<sharp> (j, w, s, k, sl, m, n, sm, sn)\n  atom sl \\<sharp> (j, w, s, m, n, sm, sn)\n  atom m \\<sharp> (j, w, s, n, sm, sn)\n  atom n \\<sharp> (j, w, s, sm, sn)\n  atom sm \\<sharp> (j, w, s, sn)\n  atom sn \\<sharp> (j, w, s)\n\ngoal (1 subgoal):\n 1. (SeqCTermP vf s k t)(j::=w) =\n    SeqCTermP vf (subst j w s) (subst j w k) (subst j w t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom l \\<sharp> (j, w, s, k, sl, m, n, sm, sn)\n  atom sl \\<sharp> (j, w, s, m, n, sm, sn)\n  atom m \\<sharp> (j, w, s, n, sm, sn)\n  atom n \\<sharp> (j, w, s, sm, sn)\n  atom sm \\<sharp> (j, w, s, sn)\n  atom sn \\<sharp> (j, w, s)\n\ngoal (1 subgoal):\n 1. (SeqCTermP vf s k t)(j::=w) =\n    SeqCTermP vf (subst j w s) (subst j w k) (subst j w t)", "by (force simp add: SeqCTermP.simps [of l _ _ sl m n sm sn])"], ["proof (state)\nthis:\n  (SeqCTermP vf s k t)(j::=w) =\n  SeqCTermP vf (subst j w s) (subst j w k) (subst j w t)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare SeqCTermP.simps [simp del]"], ["", "abbreviation SeqTerm :: \"hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> bool\"\n  where \"SeqTerm \\<equiv> SeqCTerm True\""], ["", "abbreviation SeqTermP :: \"tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> fm\"\n  where \"SeqTermP \\<equiv> SeqCTermP True\""], ["", "abbreviation SeqConst :: \"hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> bool\"\n  where \"SeqConst \\<equiv> SeqCTerm False\""], ["", "abbreviation SeqConstP :: \"tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> fm\"\n  where \"SeqConstP \\<equiv> SeqCTermP False\""], ["", "lemma SeqConst_imp_SeqTerm: \"SeqConst s k x \\<Longrightarrow> SeqTerm s k x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SeqConst s k x \\<Longrightarrow> SeqTerm s k x", "by (auto simp: SeqCTerm_def intro: BuildSeq_mono)"], ["", "lemma SeqConstP_imp_SeqTermP: \"{SeqConstP s k t} \\<turnstile> SeqTermP s k t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {SeqConstP s k t} \\<turnstile> SeqTermP s k t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {SeqConstP s k t} \\<turnstile> SeqTermP s k t", "obtain l::name and sl::name and m::name and n::name and sm::name and sn::name\n    where \"atom l \\<sharp> (s,k,t,sl,m,n,sm,sn)\"   \"atom sl \\<sharp> (s,k,t,m,n,sm,sn)\"\n          \"atom m \\<sharp> (s,k,t,n,sm,sn)\"   \"atom n \\<sharp> (s,k,t,sm,sn)\"\n          \"atom sm \\<sharp> (s,k,t,sn)\"   \"atom sn \\<sharp> (s,k,t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l sl m n sm sn.\n        \\<lbrakk>atom l \\<sharp> (s, k, t, sl, m, n, sm, sn);\n         atom sl \\<sharp> (s, k, t, m, n, sm, sn);\n         atom m \\<sharp> (s, k, t, n, sm, sn);\n         atom n \\<sharp> (s, k, t, sm, sn); atom sm \\<sharp> (s, k, t, sn);\n         atom sn \\<sharp> (s, k, t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom l \\<sharp> (s, k, t, sl, m, n, sm, sn)\n  atom sl \\<sharp> (s, k, t, m, n, sm, sn)\n  atom m \\<sharp> (s, k, t, n, sm, sn)\n  atom n \\<sharp> (s, k, t, sm, sn)\n  atom sm \\<sharp> (s, k, t, sn)\n  atom sn \\<sharp> (s, k, t)\n\ngoal (1 subgoal):\n 1. {SeqConstP s k t} \\<turnstile> SeqTermP s k t", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom l \\<sharp> (s, k, t, sl, m, n, sm, sn)\n  atom sl \\<sharp> (s, k, t, m, n, sm, sn)\n  atom m \\<sharp> (s, k, t, n, sm, sn)\n  atom n \\<sharp> (s, k, t, sm, sn)\n  atom sm \\<sharp> (s, k, t, sn)\n  atom sn \\<sharp> (s, k, t)\n\ngoal (1 subgoal):\n 1. {SeqConstP s k t} \\<turnstile> SeqTermP s k t", "apply (auto simp: SeqCTermP.simps [of l s k sl m n sm sn])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom l \\<sharp> (s, k, t, sl, m, n, sm, sn);\n     atom sl \\<sharp> (s, k, t, m, n, sm, sn);\n     atom m \\<sharp> (s, k, t, n, sm, sn);\n     atom n \\<sharp> (s, k, t, sm, sn); atom sm \\<sharp> (s, k, t, sn);\n     atom sn \\<sharp> (s, k, t)\\<rbrakk>\n    \\<Longrightarrow> {Neg (SyntaxN.Ex sl\n                             (HPair (Var l) (Var sl) IN s AND\n                              (Var sl EQ Zero OR\n                               VarP (Var sl) OR\n                               SyntaxN.Ex m\n                                (SyntaxN.Ex n\n                                  (SyntaxN.Ex sm\n                                    (SyntaxN.Ex sn\n(Var m IN Var l AND\n Var n IN Var l AND\n HPair (Var m) (Var sm) IN s AND\n HPair (Var n) (Var sn) IN s AND Var sl EQ Q_Eats (Var sm) (Var sn)))))))),\n                       Var l IN SUCC k, LstSeqP s k t} \\<turnstile>\n                      SyntaxN.Ex l\n                       (Neg (Var l IN SUCC k IMP\n                             SyntaxN.Ex sl\n                              (HPair (Var l) (Var sl) IN s AND\n                               (Var sl EQ Zero OR\n                                Fls OR\n                                SyntaxN.Ex m\n                                 (SyntaxN.Ex n\n                                   (SyntaxN.Ex sm\n                                     (SyntaxN.Ex sn\n (Var m IN Var l AND\n  Var n IN Var l AND\n  HPair (Var m) (Var sm) IN s AND\n  HPair (Var n) (Var sn) IN s AND Var sl EQ Q_Eats (Var sm) (Var sn)))))))))", "apply (rule Ex_I [where x=\"Var l\"], auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom l \\<sharp> (s, k, t, sl, m, n, sm, sn);\n     atom sl \\<sharp> (s, k, t, m, n, sm, sn);\n     atom m \\<sharp> (s, k, t, n, sm, sn);\n     atom n \\<sharp> (s, k, t, sm, sn); atom sm \\<sharp> (s, k, t, sn);\n     atom sn \\<sharp> (s, k, t)\\<rbrakk>\n    \\<Longrightarrow> {Var sl EQ Zero, HPair (Var l) (Var sl) IN s,\n                       Var l IN SUCC k, LstSeqP s k t} \\<turnstile>\n                      SyntaxN.Ex sl\n                       (HPair (Var l) (Var sl) IN s AND\n                        (Var sl EQ Zero OR\n                         VarP (Var sl) OR\n                         SyntaxN.Ex m\n                          (SyntaxN.Ex n\n                            (SyntaxN.Ex sm\n                              (SyntaxN.Ex sn\n                                (Var m IN Var l AND\n                                 Var n IN Var l AND\n                                 HPair (Var m) (Var sm) IN s AND\n                                 HPair (Var n) (Var sn) IN s AND\n                                 Var sl EQ Q_Eats (Var sm) (Var sn)))))))\n 2. \\<lbrakk>atom l \\<sharp> (s, k, t, sl, m, n, sm, sn);\n     atom sl \\<sharp> (s, k, t, m, n, sm, sn);\n     atom m \\<sharp> (s, k, t, n, sm, sn);\n     atom n \\<sharp> (s, k, t, sm, sn); atom sm \\<sharp> (s, k, t, sn);\n     atom sn \\<sharp> (s, k, t)\\<rbrakk>\n    \\<Longrightarrow> {HPair (Var n) (Var sn) IN s,\n                       Var sl EQ Q_Eats (Var sm) (Var sn),\n                       HPair (Var m) (Var sm) IN s, Var n IN Var l,\n                       Var m IN Var l, HPair (Var l) (Var sl) IN s,\n                       Var l IN SUCC k, LstSeqP s k t} \\<turnstile>\n                      SyntaxN.Ex sl\n                       (HPair (Var l) (Var sl) IN s AND\n                        (Var sl EQ Zero OR\n                         VarP (Var sl) OR\n                         SyntaxN.Ex m\n                          (SyntaxN.Ex n\n                            (SyntaxN.Ex sm\n                              (SyntaxN.Ex sn\n                                (Var m IN Var l AND\n                                 Var n IN Var l AND\n                                 HPair (Var m) (Var sm) IN s AND\n                                 HPair (Var n) (Var sn) IN s AND\n                                 Var sl EQ Q_Eats (Var sm) (Var sn)))))))", "apply (rule Ex_I [where x = \"Var sl\"], force intro: Disj_I1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom l \\<sharp> (s, k, t, sl, m, n, sm, sn);\n     atom sl \\<sharp> (s, k, t, m, n, sm, sn);\n     atom m \\<sharp> (s, k, t, n, sm, sn);\n     atom n \\<sharp> (s, k, t, sm, sn); atom sm \\<sharp> (s, k, t, sn);\n     atom sn \\<sharp> (s, k, t)\\<rbrakk>\n    \\<Longrightarrow> {HPair (Var n) (Var sn) IN s,\n                       Var sl EQ Q_Eats (Var sm) (Var sn),\n                       HPair (Var m) (Var sm) IN s, Var n IN Var l,\n                       Var m IN Var l, HPair (Var l) (Var sl) IN s,\n                       Var l IN SUCC k, LstSeqP s k t} \\<turnstile>\n                      SyntaxN.Ex sl\n                       (HPair (Var l) (Var sl) IN s AND\n                        (Var sl EQ Zero OR\n                         VarP (Var sl) OR\n                         SyntaxN.Ex m\n                          (SyntaxN.Ex n\n                            (SyntaxN.Ex sm\n                              (SyntaxN.Ex sn\n                                (Var m IN Var l AND\n                                 Var n IN Var l AND\n                                 HPair (Var m) (Var sm) IN s AND\n                                 HPair (Var n) (Var sn) IN s AND\n                                 Var sl EQ Q_Eats (Var sm) (Var sn)))))))", "apply (rule Ex_I [where x = \"Var sl\"], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom l \\<sharp> (s, k, t, sl, m, n, sm, sn);\n     atom sl \\<sharp> (s, k, t, m, n, sm, sn);\n     atom m \\<sharp> (s, k, t, n, sm, sn);\n     atom n \\<sharp> (s, k, t, sm, sn); atom sm \\<sharp> (s, k, t, sn);\n     atom sn \\<sharp> (s, k, t)\\<rbrakk>\n    \\<Longrightarrow> {HPair (Var n) (Var sn) IN s,\n                       Var sl EQ Q_Eats (Var sm) (Var sn),\n                       HPair (Var m) (Var sm) IN s, Var n IN Var l,\n                       Var m IN Var l, HPair (Var l) (Var sl) IN s,\n                       Var l IN SUCC k, LstSeqP s k t} \\<turnstile>\n                      HPair (Var l) (Var sl) IN s AND\n                      (Var sl EQ Zero OR\n                       VarP (Var sl) OR\n                       SyntaxN.Ex m\n                        (SyntaxN.Ex n\n                          (SyntaxN.Ex sm\n                            (SyntaxN.Ex sn\n                              (Var m IN Var l AND\n                               Var n IN Var l AND\n                               HPair (Var m) (Var sm) IN s AND\n                               HPair (Var n) (Var sn) IN s AND\n                               Var sl EQ Q_Eats (Var sm) (Var sn))))))", "apply (rule Conj_I, blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom l \\<sharp> (s, k, t, sl, m, n, sm, sn);\n     atom sl \\<sharp> (s, k, t, m, n, sm, sn);\n     atom m \\<sharp> (s, k, t, n, sm, sn);\n     atom n \\<sharp> (s, k, t, sm, sn); atom sm \\<sharp> (s, k, t, sn);\n     atom sn \\<sharp> (s, k, t)\\<rbrakk>\n    \\<Longrightarrow> {HPair (Var n) (Var sn) IN s,\n                       Var sl EQ Q_Eats (Var sm) (Var sn),\n                       HPair (Var m) (Var sm) IN s, Var n IN Var l,\n                       Var m IN Var l, HPair (Var l) (Var sl) IN s,\n                       Var l IN SUCC k, LstSeqP s k t} \\<turnstile>\n                      Var sl EQ Zero OR\n                      VarP (Var sl) OR\n                      SyntaxN.Ex m\n                       (SyntaxN.Ex n\n                         (SyntaxN.Ex sm\n                           (SyntaxN.Ex sn\n                             (Var m IN Var l AND\n                              Var n IN Var l AND\n                              HPair (Var m) (Var sm) IN s AND\n                              HPair (Var n) (Var sn) IN s AND\n                              Var sl EQ Q_Eats (Var sm) (Var sn)))))", "apply (rule Disj_I2)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom l \\<sharp> (s, k, t, sl, m, n, sm, sn);\n     atom sl \\<sharp> (s, k, t, m, n, sm, sn);\n     atom m \\<sharp> (s, k, t, n, sm, sn);\n     atom n \\<sharp> (s, k, t, sm, sn); atom sm \\<sharp> (s, k, t, sn);\n     atom sn \\<sharp> (s, k, t)\\<rbrakk>\n    \\<Longrightarrow> {HPair (Var n) (Var sn) IN s,\n                       Var sl EQ Q_Eats (Var sm) (Var sn),\n                       HPair (Var m) (Var sm) IN s, Var n IN Var l,\n                       Var m IN Var l, HPair (Var l) (Var sl) IN s,\n                       Var l IN SUCC k, LstSeqP s k t} \\<turnstile>\n                      SyntaxN.Ex m\n                       (SyntaxN.Ex n\n                         (SyntaxN.Ex sm\n                           (SyntaxN.Ex sn\n                             (Var m IN Var l AND\n                              Var n IN Var l AND\n                              HPair (Var m) (Var sm) IN s AND\n                              HPair (Var n) (Var sn) IN s AND\n                              Var sl EQ Q_Eats (Var sm) (Var sn)))))", "apply (rule Ex_I [where x = \"Var m\"], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom l \\<sharp> (s, k, t, sl, m, n, sm, sn);\n     atom sl \\<sharp> (s, k, t, m, n, sm, sn);\n     atom m \\<sharp> (s, k, t, n, sm, sn);\n     atom n \\<sharp> (s, k, t, sm, sn); atom sm \\<sharp> (s, k, t, sn);\n     atom sn \\<sharp> (s, k, t)\\<rbrakk>\n    \\<Longrightarrow> {HPair (Var n) (Var sn) IN s,\n                       Var sl EQ Q_Eats (Var sm) (Var sn),\n                       HPair (Var m) (Var sm) IN s, Var n IN Var l,\n                       Var m IN Var l, HPair (Var l) (Var sl) IN s,\n                       Var l IN SUCC k, LstSeqP s k t} \\<turnstile>\n                      SyntaxN.Ex n\n                       (SyntaxN.Ex sm\n                         (SyntaxN.Ex sn\n                           (Var m IN Var l AND\n                            Var n IN Var l AND\n                            HPair (Var m) (Var sm) IN s AND\n                            HPair (Var n) (Var sn) IN s AND\n                            Var sl EQ Q_Eats (Var sm) (Var sn))))", "apply (rule Ex_I [where x = \"Var n\"], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom l \\<sharp> (s, k, t, sl, m, n, sm, sn);\n     atom sl \\<sharp> (s, k, t, m, n, sm, sn);\n     atom m \\<sharp> (s, k, t, n, sm, sn);\n     atom n \\<sharp> (s, k, t, sm, sn); atom sm \\<sharp> (s, k, t, sn);\n     atom sn \\<sharp> (s, k, t)\\<rbrakk>\n    \\<Longrightarrow> {HPair (Var n) (Var sn) IN s,\n                       Var sl EQ Q_Eats (Var sm) (Var sn),\n                       HPair (Var m) (Var sm) IN s, Var n IN Var l,\n                       Var m IN Var l, HPair (Var l) (Var sl) IN s,\n                       Var l IN SUCC k, LstSeqP s k t} \\<turnstile>\n                      SyntaxN.Ex sm\n                       (SyntaxN.Ex sn\n                         (Var m IN Var l AND\n                          Var n IN Var l AND\n                          HPair (Var m) (Var sm) IN s AND\n                          HPair (Var n) (Var sn) IN s AND\n                          Var sl EQ Q_Eats (Var sm) (Var sn)))", "apply (rule Ex_I [where x = \"Var sm\"], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom l \\<sharp> (s, k, t, sl, m, n, sm, sn);\n     atom sl \\<sharp> (s, k, t, m, n, sm, sn);\n     atom m \\<sharp> (s, k, t, n, sm, sn);\n     atom n \\<sharp> (s, k, t, sm, sn); atom sm \\<sharp> (s, k, t, sn);\n     atom sn \\<sharp> (s, k, t)\\<rbrakk>\n    \\<Longrightarrow> {HPair (Var n) (Var sn) IN s,\n                       Var sl EQ Q_Eats (Var sm) (Var sn),\n                       HPair (Var m) (Var sm) IN s, Var n IN Var l,\n                       Var m IN Var l, HPair (Var l) (Var sl) IN s,\n                       Var l IN SUCC k, LstSeqP s k t} \\<turnstile>\n                      SyntaxN.Ex sn\n                       (Var m IN Var l AND\n                        Var n IN Var l AND\n                        HPair (Var m) (Var sm) IN s AND\n                        HPair (Var n) (Var sn) IN s AND\n                        Var sl EQ Q_Eats (Var sm) (Var sn))", "apply (rule Ex_I [where x = \"Var sn\"], auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {SeqConstP s k t} \\<turnstile> SeqTermP s k t\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>The predicates \\<open>TermP\\<close> and \\<open>ConstP\\<close>\\<close>"], ["", "subsection \\<open>Definition\\<close>"], ["", "definition CTerm :: \"bool \\<Rightarrow> hf \\<Rightarrow> bool\"\n  where \"CTerm vf t \\<equiv> (\\<exists>s k. SeqCTerm vf s k t)\""], ["", "nominal_function CTermP :: \"bool \\<Rightarrow> tm \\<Rightarrow> fm\"\n  where \"\\<lbrakk>atom k \\<sharp> (s,t); atom s \\<sharp> t\\<rbrakk> \\<Longrightarrow>\n    CTermP vf t = Ex s (Ex k (SeqCTermP vf (Var s) (Var k) t))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt CTermP_graph_aux\n 2. \\<And>x y. CTermP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>k s t vf.\n           \\<lbrakk>atom k \\<sharp> (s, t); atom s \\<sharp> t;\n            x = (vf, t)\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>k s t vf ka sa ta vfa.\n       \\<lbrakk>atom k \\<sharp> (s, t); atom s \\<sharp> t;\n        atom ka \\<sharp> (sa, ta); atom sa \\<sharp> ta;\n        (vf, t) = (vfa, ta)\\<rbrakk>\n       \\<Longrightarrow> SyntaxN.Ex s\n                          (SyntaxN.Ex k (SeqCTermP vf (Var s) (Var k) t)) =\n                         SyntaxN.Ex sa\n                          (SyntaxN.Ex ka\n                            (SeqCTermP vfa (Var sa) (Var ka) ta))", "by (auto simp: eqvt_def CTermP_graph_aux_def flip_fresh_fresh) (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All CTermP_dom", "by lexicographic_order"], ["", "lemma\n  shows CTermP_fresh_iff [simp]: \"a \\<sharp> CTermP vf t \\<longleftrightarrow> a \\<sharp> t\"            (is ?thesis1)\n    and eval_fm_CTermP [simp] :\"eval_fm e (CTermP vf t) \\<longleftrightarrow> CTerm vf \\<lbrakk>t\\<rbrakk>e\"  (is ?thesis2)\n    and CTermP_sf [iff]: \"Sigma_fm (CTermP vf t)\"                      (is ?thsf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> CTermP vf t = a \\<sharp> t &&&\n    eval_fm e (CTermP vf t) = CTerm vf \\<lbrakk>t\\<rbrakk>e &&&\n    Sigma_fm (CTermP vf t)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. a \\<sharp> CTermP vf t = a \\<sharp> t\n 2. eval_fm e (CTermP vf t) = CTerm vf \\<lbrakk>t\\<rbrakk>e\n 3. Sigma_fm (CTermP vf t)", "obtain k::name and s::name  where \"atom k \\<sharp> (s,t)\" \"atom s \\<sharp> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k s.\n        \\<lbrakk>atom k \\<sharp> (s, t); atom s \\<sharp> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom k \\<sharp> (s, t)\n  atom s \\<sharp> t\n\ngoal (3 subgoals):\n 1. a \\<sharp> CTermP vf t = a \\<sharp> t\n 2. eval_fm e (CTermP vf t) = CTerm vf \\<lbrakk>t\\<rbrakk>e\n 3. Sigma_fm (CTermP vf t)", "thus ?thesis1 ?thesis2 ?thsf"], ["proof (prove)\nusing this:\n  atom k \\<sharp> (s, t)\n  atom s \\<sharp> t\n\ngoal (1 subgoal):\n 1. a \\<sharp> CTermP vf t = a \\<sharp> t &&&\n    eval_fm e (CTermP vf t) = CTerm vf \\<lbrakk>t\\<rbrakk>e &&&\n    Sigma_fm (CTermP vf t)", "by (auto simp: CTerm_def)"], ["proof (state)\nthis:\n  a \\<sharp> CTermP vf t = a \\<sharp> t\n  eval_fm e (CTermP vf t) = CTerm vf \\<lbrakk>t\\<rbrakk>e\n  Sigma_fm (CTermP vf t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma CTermP_subst [simp]: \"(CTermP vf i)(j::=w) = CTermP vf (subst j w i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (CTermP vf i)(j::=w) = CTermP vf (subst j w i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (CTermP vf i)(j::=w) = CTermP vf (subst j w i)", "obtain k::name and s::name  where \"atom k \\<sharp> (s,i,j,w)\" \"atom s \\<sharp> (i,j,w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k s.\n        \\<lbrakk>atom k \\<sharp> (s, i, j, w);\n         atom s \\<sharp> (i, j, w)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom k \\<sharp> (s, i, j, w)\n  atom s \\<sharp> (i, j, w)\n\ngoal (1 subgoal):\n 1. (CTermP vf i)(j::=w) = CTermP vf (subst j w i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom k \\<sharp> (s, i, j, w)\n  atom s \\<sharp> (i, j, w)\n\ngoal (1 subgoal):\n 1. (CTermP vf i)(j::=w) = CTermP vf (subst j w i)", "by (simp add: CTermP.simps [of k s])"], ["proof (state)\nthis:\n  (CTermP vf i)(j::=w) = CTermP vf (subst j w i)\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation Term :: \"hf \\<Rightarrow> bool\"\n  where \"Term \\<equiv> CTerm True\""], ["", "abbreviation TermP :: \"tm \\<Rightarrow> fm\"\n  where \"TermP \\<equiv> CTermP True\""], ["", "abbreviation Const :: \"hf \\<Rightarrow> bool\"\n  where \"Const \\<equiv> CTerm False\""], ["", "abbreviation ConstP :: \"tm \\<Rightarrow> fm\"\n  where \"ConstP \\<equiv> CTermP False\""], ["", "subsection \\<open>Correctness: It Corresponds to Quotations of Real Terms\\<close>"], ["", "lemma wf_Term_quot_dbtm [simp]: \"wf_dbtm u \\<Longrightarrow> Term \\<lbrakk>quot_dbtm u\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dbtm u \\<Longrightarrow> Term \\<lbrakk>quot_dbtm u\\<rbrakk>e", "by (induct rule: wf_dbtm.induct)\n   (auto simp: CTerm_def SeqCTerm_def q_Eats_def intro: BuildSeq_combine BuildSeq_exI)"], ["", "corollary Term_quot_tm [iff]: fixes t :: tm  shows \"Term \\<lbrakk>\\<guillemotleft>t\\<guillemotright>\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Term \\<lbrakk>\\<guillemotleft>t\\<guillemotright>\\<rbrakk>e", "by (metis quot_tm_def wf_Term_quot_dbtm wf_dbtm_trans_tm)"], ["", "lemma SeqCTerm_imp_wf_dbtm:\n  assumes \"SeqCTerm vf s k x\"\n  shows \"\\<exists>t::dbtm. wf_dbtm t \\<and> x = \\<lbrakk>quot_dbtm t\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t. wf_dbtm t \\<and> x = \\<lbrakk>quot_dbtm t\\<rbrakk>e", "using assms [unfolded SeqCTerm_def]"], ["proof (prove)\nusing this:\n  BuildSeq (\\<lambda>u. u = 0 \\<or> vf \\<and> is_Var u)\n   (\\<lambda>u v w. u = q_Eats v w) s k x\n\ngoal (1 subgoal):\n 1. \\<exists>t. wf_dbtm t \\<and> x = \\<lbrakk>quot_dbtm t\\<rbrakk>e", "proof (induct x rule: BuildSeq_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x = 0 \\<or> vf \\<and> is_Var x \\<Longrightarrow>\n       \\<exists>t. wf_dbtm t \\<and> x = \\<lbrakk>quot_dbtm t\\<rbrakk>e\n 2. \\<And>x y z.\n       \\<lbrakk>x = q_Eats y z;\n        \\<exists>t. wf_dbtm t \\<and> y = \\<lbrakk>quot_dbtm t\\<rbrakk>e;\n        \\<exists>t.\n           wf_dbtm t \\<and> z = \\<lbrakk>quot_dbtm t\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            wf_dbtm t \\<and>\n                            x = \\<lbrakk>quot_dbtm t\\<rbrakk>e", "case (B x)"], ["proof (state)\nthis:\n  x = 0 \\<or> vf \\<and> is_Var x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x = 0 \\<or> vf \\<and> is_Var x \\<Longrightarrow>\n       \\<exists>t. wf_dbtm t \\<and> x = \\<lbrakk>quot_dbtm t\\<rbrakk>e\n 2. \\<And>x y z.\n       \\<lbrakk>x = q_Eats y z;\n        \\<exists>t. wf_dbtm t \\<and> y = \\<lbrakk>quot_dbtm t\\<rbrakk>e;\n        \\<exists>t.\n           wf_dbtm t \\<and> z = \\<lbrakk>quot_dbtm t\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            wf_dbtm t \\<and>\n                            x = \\<lbrakk>quot_dbtm t\\<rbrakk>e", "thus ?case"], ["proof (prove)\nusing this:\n  x = 0 \\<or> vf \\<and> is_Var x\n\ngoal (1 subgoal):\n 1. \\<exists>t. wf_dbtm t \\<and> x = \\<lbrakk>quot_dbtm t\\<rbrakk>e", "by auto (metis ORD_OF.simps(2) Var quot_dbtm.simps(2) is_Var_imp_decode_Var quot_Var)"], ["proof (state)\nthis:\n  \\<exists>t. wf_dbtm t \\<and> x = \\<lbrakk>quot_dbtm t\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x = q_Eats y z;\n        \\<exists>t. wf_dbtm t \\<and> y = \\<lbrakk>quot_dbtm t\\<rbrakk>e;\n        \\<exists>t.\n           wf_dbtm t \\<and> z = \\<lbrakk>quot_dbtm t\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            wf_dbtm t \\<and>\n                            x = \\<lbrakk>quot_dbtm t\\<rbrakk>e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x = q_Eats y z;\n        \\<exists>t. wf_dbtm t \\<and> y = \\<lbrakk>quot_dbtm t\\<rbrakk>e;\n        \\<exists>t.\n           wf_dbtm t \\<and> z = \\<lbrakk>quot_dbtm t\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            wf_dbtm t \\<and>\n                            x = \\<lbrakk>quot_dbtm t\\<rbrakk>e", "case (C x y z)"], ["proof (state)\nthis:\n  x = q_Eats y z\n  \\<exists>t. wf_dbtm t \\<and> y = \\<lbrakk>quot_dbtm t\\<rbrakk>e\n  \\<exists>t. wf_dbtm t \\<and> z = \\<lbrakk>quot_dbtm t\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x = q_Eats y z;\n        \\<exists>t. wf_dbtm t \\<and> y = \\<lbrakk>quot_dbtm t\\<rbrakk>e;\n        \\<exists>t.\n           wf_dbtm t \\<and> z = \\<lbrakk>quot_dbtm t\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            wf_dbtm t \\<and>\n                            x = \\<lbrakk>quot_dbtm t\\<rbrakk>e", "then"], ["proof (chain)\npicking this:\n  x = q_Eats y z\n  \\<exists>t. wf_dbtm t \\<and> y = \\<lbrakk>quot_dbtm t\\<rbrakk>e\n  \\<exists>t. wf_dbtm t \\<and> z = \\<lbrakk>quot_dbtm t\\<rbrakk>e", "obtain tm1::dbtm and tm2::dbtm\n    where \"wf_dbtm tm1\" \"y = \\<lbrakk>quot_dbtm tm1\\<rbrakk>e\"\n          \"wf_dbtm tm2\" \"z = \\<lbrakk>quot_dbtm tm2\\<rbrakk>e\""], ["proof (prove)\nusing this:\n  x = q_Eats y z\n  \\<exists>t. wf_dbtm t \\<and> y = \\<lbrakk>quot_dbtm t\\<rbrakk>e\n  \\<exists>t. wf_dbtm t \\<and> z = \\<lbrakk>quot_dbtm t\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. (\\<And>tm1 tm2.\n        \\<lbrakk>wf_dbtm tm1; y = \\<lbrakk>quot_dbtm tm1\\<rbrakk>e;\n         wf_dbtm tm2; z = \\<lbrakk>quot_dbtm tm2\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  wf_dbtm tm1\n  y = \\<lbrakk>quot_dbtm tm1\\<rbrakk>e\n  wf_dbtm tm2\n  z = \\<lbrakk>quot_dbtm tm2\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x = q_Eats y z;\n        \\<exists>t. wf_dbtm t \\<and> y = \\<lbrakk>quot_dbtm t\\<rbrakk>e;\n        \\<exists>t.\n           wf_dbtm t \\<and> z = \\<lbrakk>quot_dbtm t\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            wf_dbtm t \\<and>\n                            x = \\<lbrakk>quot_dbtm t\\<rbrakk>e", "thus ?case"], ["proof (prove)\nusing this:\n  wf_dbtm tm1\n  y = \\<lbrakk>quot_dbtm tm1\\<rbrakk>e\n  wf_dbtm tm2\n  z = \\<lbrakk>quot_dbtm tm2\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<exists>t. wf_dbtm t \\<and> x = \\<lbrakk>quot_dbtm t\\<rbrakk>e", "by (auto simp: wf_dbtm.intros C q_Eats_def intro!: exI [of _ \"DBEats tm1 tm2\"])"], ["proof (state)\nthis:\n  \\<exists>t. wf_dbtm t \\<and> x = \\<lbrakk>quot_dbtm t\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary Term_imp_wf_dbtm:\n  assumes \"Term x\" obtains t where \"wf_dbtm t\" \"x = \\<lbrakk>quot_dbtm t\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>wf_dbtm t; x = \\<lbrakk>quot_dbtm t\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis assms SeqCTerm_imp_wf_dbtm CTerm_def)"], ["", "corollary Term_imp_is_tm: assumes \"Term x\" obtains t::tm where \"x = \\<lbrakk>\\<guillemotleft>t\\<guillemotright>\\<rbrakk> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        x =\n        \\<lbrakk>\\<guillemotleft>t\\<guillemotright>\\<rbrakk>e \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis assms Term_imp_wf_dbtm quot_tm_def wf_dbtm_imp_is_tm)"], ["", "lemma Term_Var: \"Term (q_Var i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Term (q_Var i)", "using wf_Term_quot_dbtm [of \"DBVar i\"]"], ["proof (prove)\nusing this:\n  wf_dbtm (DBVar i) \\<Longrightarrow>\n  Term \\<lbrakk>quot_dbtm (DBVar i)\\<rbrakk>?e\n\ngoal (1 subgoal):\n 1. Term (q_Var i)", "by (metis Term_quot_tm is_Var_imp_decode_Var is_Var_q_Var)"], ["", "lemma Term_Eats: assumes x: \"Term x\" and y: \"Term y\" shows \"Term (q_Eats x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Term (q_Eats x y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Term (q_Eats x y)", "obtain t u  where \"x = \\<lbrakk>quot_dbtm t\\<rbrakk>e\" \"y = \\<lbrakk>quot_dbtm u\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t u.\n        \\<lbrakk>x = \\<lbrakk>quot_dbtm t\\<rbrakk>e;\n         y = \\<lbrakk>quot_dbtm u\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Term_imp_wf_dbtm x y)"], ["proof (state)\nthis:\n  x = \\<lbrakk>quot_dbtm t\\<rbrakk>e\n  y = \\<lbrakk>quot_dbtm u\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. Term (q_Eats x y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = \\<lbrakk>quot_dbtm t\\<rbrakk>e\n  y = \\<lbrakk>quot_dbtm u\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. Term (q_Eats x y)", "using wf_Term_quot_dbtm [of \"DBEats t u\"] x y"], ["proof (prove)\nusing this:\n  x = \\<lbrakk>quot_dbtm t\\<rbrakk>e\n  y = \\<lbrakk>quot_dbtm u\\<rbrakk>e\n  wf_dbtm (DBEats t u) \\<Longrightarrow>\n  Term \\<lbrakk>quot_dbtm (DBEats t u)\\<rbrakk>?e\n  Term x\n  Term y\n\ngoal (1 subgoal):\n 1. Term (q_Eats x y)", "by (auto simp: q_defs) (metis Eats Term_imp_wf_dbtm quot_dbtm_inject_lemma)"], ["proof (state)\nthis:\n  Term (q_Eats x y)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Correctness properties for constants\\<close>"], ["", "lemma Const_imp_Term: \"Const x \\<Longrightarrow> Term x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Const x \\<Longrightarrow> Term x", "by (metis SeqConst_imp_SeqTerm CTerm_def)"], ["", "lemma Const_0: \"Const 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Const 0", "by (force simp add: CTerm_def SeqCTerm_def intro: BuildSeq_exI)"], ["", "lemma ConstP_imp_TermP: \"{ConstP t} \\<turnstile> TermP t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ConstP t} \\<turnstile> TermP t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {ConstP t} \\<turnstile> TermP t", "obtain k::name and s::name  where \"atom k \\<sharp> (s,t)\" \"atom s \\<sharp> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k s.\n        \\<lbrakk>atom k \\<sharp> (s, t); atom s \\<sharp> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom k \\<sharp> (s, t)\n  atom s \\<sharp> t\n\ngoal (1 subgoal):\n 1. {ConstP t} \\<turnstile> TermP t", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom k \\<sharp> (s, t)\n  atom s \\<sharp> t\n\ngoal (1 subgoal):\n 1. {ConstP t} \\<turnstile> TermP t", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom k \\<sharp> (s, t); atom s \\<sharp> t\\<rbrakk>\n    \\<Longrightarrow> {SeqConstP (Var s) (Var k) t} \\<turnstile>\n                      SyntaxN.Ex s\n                       (SyntaxN.Ex k (SeqTermP (Var s) (Var k) t))", "apply (rule Ex_I [where x = \"Var s\"], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom k \\<sharp> (s, t); atom s \\<sharp> t\\<rbrakk>\n    \\<Longrightarrow> {SeqConstP (Var s) (Var k) t} \\<turnstile>\n                      SyntaxN.Ex k (SeqTermP (Var s) (Var k) t)", "apply (rule Ex_I [where x = \"Var k\"], auto intro: SeqConstP_imp_SeqTermP [THEN cut1])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {ConstP t} \\<turnstile> TermP t\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Abstraction over terms\\<close>"], ["", "definition SeqStTerm :: \"hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> bool\"\nwhere \"SeqStTerm v u x x' s k \\<equiv>\n       is_Var v \\<and> BuildSeq2 (\\<lambda>y y'. (is_Ind y \\<or> Ord y) \\<and> y' = (if y=v then u else y))\n                (\\<lambda>u u' v v' w w'. u = q_Eats v w \\<and> u' = q_Eats v' w') s k x x'\""], ["", "definition AbstTerm :: \"hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> bool\"\nwhere \"AbstTerm v i x x' \\<equiv> Ord i \\<and> (\\<exists>s k. SeqStTerm v (q_Ind i) x x' s k)\""], ["", "subsection \\<open>Defining the syntax: quantified body\\<close>"], ["", "nominal_function SeqStTermP :: \"tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> fm\"\n  where \"\\<lbrakk>atom l \\<sharp> (s,k,v,i,sl,sl',m,n,sm,sm',sn,sn');\n          atom sl \\<sharp> (s,v,i,sl',m,n,sm,sm',sn,sn'); atom sl' \\<sharp> (s,v,i,m,n,sm,sm',sn,sn');\n          atom m \\<sharp> (s,n,sm,sm',sn,sn'); atom n \\<sharp> (s,sm,sm',sn,sn');\n          atom sm \\<sharp> (s,sm',sn,sn'); atom sm' \\<sharp> (s,sn,sn');\n          atom sn \\<sharp> (s,sn'); atom sn' \\<sharp> s\\<rbrakk> \\<Longrightarrow>\n    SeqStTermP v i t u s k =\n      VarP v AND LstSeqP s k (HPair t u) AND\n      All2 l (SUCC k) (Ex sl (Ex sl' (HPair (Var l) (HPair (Var sl) (Var sl')) IN s AND\n                (((Var sl EQ v AND Var sl' EQ i) OR\n                  ((IndP (Var sl) OR Var sl NEQ v) AND Var sl' EQ Var sl)) OR\n                Ex m (Ex n (Ex sm (Ex sm' (Ex sn (Ex sn' (Var m IN Var l AND Var n IN Var l AND\n                       HPair (Var m) (HPair (Var sm) (Var sm')) IN s AND\n                       HPair (Var n) (HPair (Var sn) (Var sn')) IN s AND\n                       Var sl EQ Q_Eats (Var sm) (Var sn) AND\n                       Var sl' EQ Q_Eats (Var sm') (Var sn')))))))))))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt SeqStTermP_graph_aux\n 2. \\<And>x y. SeqStTermP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>l s k v i sl sl' m n sm sm' sn sn' t u.\n           \\<lbrakk>atom\n                     l \\<sharp> (s, k, v, i, sl, sl', m, n, sm, sm', sn,\n                                 sn');\n            atom sl \\<sharp> (s, v, i, sl', m, n, sm, sm', sn, sn');\n            atom sl' \\<sharp> (s, v, i, m, n, sm, sm', sn, sn');\n            atom m \\<sharp> (s, n, sm, sm', sn, sn');\n            atom n \\<sharp> (s, sm, sm', sn, sn');\n            atom sm \\<sharp> (s, sm', sn, sn');\n            atom sm' \\<sharp> (s, sn, sn'); atom sn \\<sharp> (s, sn');\n            atom sn' \\<sharp> s; x = (v, i, t, u, s, k)\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>l s k v i sl sl' m n sm sm' sn sn' t u la sa ka va ia sla sl'a ma\n       na sma sm'a sna sn'a ta ua.\n       \\<lbrakk>atom\n                 l \\<sharp> (s, k, v, i, sl, sl', m, n, sm, sm', sn, sn');\n        atom sl \\<sharp> (s, v, i, sl', m, n, sm, sm', sn, sn');\n        atom sl' \\<sharp> (s, v, i, m, n, sm, sm', sn, sn');\n        atom m \\<sharp> (s, n, sm, sm', sn, sn');\n        atom n \\<sharp> (s, sm, sm', sn, sn');\n        atom sm \\<sharp> (s, sm', sn, sn'); atom sm' \\<sharp> (s, sn, sn');\n        atom sn \\<sharp> (s, sn'); atom sn' \\<sharp> s;\n        atom\n         la \\<sharp> (sa, ka, va, ia, sla, sl'a, ma, na, sma, sm'a, sna,\n                      sn'a);\n        atom sla \\<sharp> (sa, va, ia, sl'a, ma, na, sma, sm'a, sna, sn'a);\n        atom sl'a \\<sharp> (sa, va, ia, ma, na, sma, sm'a, sna, sn'a);\n        atom ma \\<sharp> (sa, na, sma, sm'a, sna, sn'a);\n        atom na \\<sharp> (sa, sma, sm'a, sna, sn'a);\n        atom sma \\<sharp> (sa, sm'a, sna, sn'a);\n        atom sm'a \\<sharp> (sa, sna, sn'a); atom sna \\<sharp> (sa, sn'a);\n        atom sn'a \\<sharp> sa;\n        (v, i, t, u, s, k) = (va, ia, ta, ua, sa, ka)\\<rbrakk>\n       \\<Longrightarrow> VarP v AND\n                         LstSeqP s k (HPair t u) AND\n                         All2 l (SUCC k)\n                          (SyntaxN.Ex sl\n                            (SyntaxN.Ex sl'\n                              (HPair (Var l) (HPair (Var sl) (Var sl')) IN\n                               s AND\n                               ((Var sl EQ v AND Var sl' EQ i OR\n                                 (IndP (Var sl) OR Var sl NEQ v) AND\n                                 Var sl' EQ Var sl) OR\n                                SyntaxN.Ex m\n                                 (SyntaxN.Ex n\n                                   (SyntaxN.Ex sm\n                                     (SyntaxN.Ex sm'\n (SyntaxN.Ex sn\n   (SyntaxN.Ex sn'\n     (Var m IN Var l AND\n      Var n IN Var l AND\n      HPair (Var m) (HPair (Var sm) (Var sm')) IN s AND\n      HPair (Var n) (HPair (Var sn) (Var sn')) IN s AND\n      Var sl EQ Q_Eats (Var sm) (Var sn) AND\n      Var sl' EQ Q_Eats (Var sm') (Var sn'))))))))))) =\n                         VarP va AND\n                         LstSeqP sa ka (HPair ta ua) AND\n                         All2 la (SUCC ka)\n                          (SyntaxN.Ex sla\n                            (SyntaxN.Ex sl'a\n                              (HPair (Var la)\n                                (HPair (Var sla) (Var sl'a)) IN\n                               sa AND\n                               ((Var sla EQ va AND Var sl'a EQ ia OR\n                                 (IndP (Var sla) OR Var sla NEQ va) AND\n                                 Var sl'a EQ Var sla) OR\n                                SyntaxN.Ex ma\n                                 (SyntaxN.Ex na\n                                   (SyntaxN.Ex sma\n                                     (SyntaxN.Ex sm'a\n (SyntaxN.Ex sna\n   (SyntaxN.Ex sn'a\n     (Var ma IN Var la AND\n      Var na IN Var la AND\n      HPair (Var ma) (HPair (Var sma) (Var sm'a)) IN sa AND\n      HPair (Var na) (HPair (Var sna) (Var sn'a)) IN sa AND\n      Var sla EQ Q_Eats (Var sma) (Var sna) AND\n      Var sl'a EQ Q_Eats (Var sm'a) (Var sn'a)))))))))))", "apply (simp_all add: eqvt_def SeqStTermP_graph_aux_def flip_fresh_fresh)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P x.\n       (\\<And>l s k v i sl sl' m n sm sm' sn sn' t u.\n           \\<lbrakk>atom\n                     l \\<sharp> (s, k, v, i, sl, sl', m, n, sm, sm', sn,\n                                 sn');\n            atom sl \\<sharp> (s, v, i, sl', m, n, sm, sm', sn, sn');\n            atom sl' \\<sharp> (s, v, i, m, n, sm, sm', sn, sn');\n            atom m \\<sharp> (s, n, sm, sm', sn, sn');\n            atom n \\<sharp> (s, sm, sm', sn, sn');\n            atom sm \\<sharp> (s, sm', sn, sn');\n            atom sm' \\<sharp> (s, sn, sn'); atom sn \\<sharp> (s, sn');\n            atom sn' \\<sharp> s; x = (v, i, t, u, s, k)\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P", "by auto (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All SeqStTermP_dom", "by lexicographic_order"], ["", "lemma\n  shows SeqStTermP_fresh_iff [simp]:\n      \"a \\<sharp> SeqStTermP v i t u s k \\<longleftrightarrow> a \\<sharp> v \\<and> a \\<sharp> i \\<and> a \\<sharp> t \\<and> a \\<sharp> u \\<and> a \\<sharp> s \\<and> a \\<sharp> k\"  (is ?thesis1)\n    and eval_fm_SeqStTermP [simp]:\n      \"eval_fm e (SeqStTermP v i t u s k) \\<longleftrightarrow> SeqStTerm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e\"  (is ?thesis2)\n    and SeqStTermP_sf [iff]:\n      \"Sigma_fm (SeqStTermP v i t u s k)\"  (is ?thsf)\n    and SeqStTermP_imp_OrdP:\n      \"{ SeqStTermP v i t u s k } \\<turnstile> OrdP k\"  (is ?thord)\n    and SeqStTermP_imp_VarP:\n      \"{ SeqStTermP v i t u s k } \\<turnstile> VarP v\"  (is ?thvar)\n    and SeqStTermP_imp_LstSeqP:\n      \"{ SeqStTermP v i t u s k } \\<turnstile> LstSeqP s k (HPair t u)\"  (is ?thlstseq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<sharp> SeqStTermP v i t u s k =\n     (a \\<sharp> v \\<and>\n      a \\<sharp> i \\<and>\n      a \\<sharp> t \\<and>\n      a \\<sharp> u \\<and> a \\<sharp> s \\<and> a \\<sharp> k) &&&\n     eval_fm e (SeqStTermP v i t u s k) =\n     SeqStTerm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e\n      \\<lbrakk>t\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e\n      \\<lbrakk>k\\<rbrakk>e &&&\n     Sigma_fm (SeqStTermP v i t u s k)) &&&\n    {SeqStTermP v i t u s k} \\<turnstile> OrdP k &&&\n    {SeqStTermP v i t u s k} \\<turnstile> VarP v &&&\n    {SeqStTermP v i t u s k} \\<turnstile> LstSeqP s k (HPair t u)", "proof -"], ["proof (state)\ngoal (6 subgoals):\n 1. a \\<sharp> SeqStTermP v i t u s k =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> i \\<and>\n     a \\<sharp> t \\<and>\n     a \\<sharp> u \\<and> a \\<sharp> s \\<and> a \\<sharp> k)\n 2. eval_fm e (SeqStTermP v i t u s k) =\n    SeqStTerm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\n     \\<lbrakk>u\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e\n 3. Sigma_fm (SeqStTermP v i t u s k)\n 4. {SeqStTermP v i t u s k} \\<turnstile> OrdP k\n 5. {SeqStTermP v i t u s k} \\<turnstile> VarP v\n 6. {SeqStTermP v i t u s k} \\<turnstile> LstSeqP s k (HPair t u)", "obtain l::name and sl::name and sl'::name and m::name and n::name and\n         sm::name and sm'::name and sn::name and sn'::name\n    where atoms:\n       \"atom l \\<sharp> (s,k,v,i,sl,sl',m,n,sm,sm',sn,sn')\"\n       \"atom sl \\<sharp> (s,v,i,sl',m,n,sm,sm',sn,sn')\" \"atom sl' \\<sharp> (s,v,i,m,n,sm,sm',sn,sn')\"\n       \"atom m \\<sharp> (s,n,sm,sm',sn,sn')\" \"atom n \\<sharp> (s,sm,sm',sn,sn')\"\n       \"atom sm \\<sharp> (s,sm',sn,sn')\" \"atom sm' \\<sharp> (s,sn,sn')\"\n       \"atom sn \\<sharp> (s,sn')\" \"atom sn' \\<sharp> (s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l sl sl' m n sm sm' sn sn'.\n        \\<lbrakk>atom\n                  l \\<sharp> (s, k, v, i, sl, sl', m, n, sm, sm', sn, sn');\n         atom sl \\<sharp> (s, v, i, sl', m, n, sm, sm', sn, sn');\n         atom sl' \\<sharp> (s, v, i, m, n, sm, sm', sn, sn');\n         atom m \\<sharp> (s, n, sm, sm', sn, sn');\n         atom n \\<sharp> (s, sm, sm', sn, sn');\n         atom sm \\<sharp> (s, sm', sn, sn'); atom sm' \\<sharp> (s, sn, sn');\n         atom sn \\<sharp> (s, sn'); atom sn' \\<sharp> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom l \\<sharp> (s, k, v, i, sl, sl', m, n, sm, sm', sn, sn')\n  atom sl \\<sharp> (s, v, i, sl', m, n, sm, sm', sn, sn')\n  atom sl' \\<sharp> (s, v, i, m, n, sm, sm', sn, sn')\n  atom m \\<sharp> (s, n, sm, sm', sn, sn')\n  atom n \\<sharp> (s, sm, sm', sn, sn')\n  atom sm \\<sharp> (s, sm', sn, sn')\n  atom sm' \\<sharp> (s, sn, sn')\n  atom sn \\<sharp> (s, sn')\n  atom sn' \\<sharp> s\n\ngoal (6 subgoals):\n 1. a \\<sharp> SeqStTermP v i t u s k =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> i \\<and>\n     a \\<sharp> t \\<and>\n     a \\<sharp> u \\<and> a \\<sharp> s \\<and> a \\<sharp> k)\n 2. eval_fm e (SeqStTermP v i t u s k) =\n    SeqStTerm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\n     \\<lbrakk>u\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e\n 3. Sigma_fm (SeqStTermP v i t u s k)\n 4. {SeqStTermP v i t u s k} \\<turnstile> OrdP k\n 5. {SeqStTermP v i t u s k} \\<turnstile> VarP v\n 6. {SeqStTermP v i t u s k} \\<turnstile> LstSeqP s k (HPair t u)", "thus ?thesis1 ?thsf ?thord ?thvar ?thlstseq"], ["proof (prove)\nusing this:\n  atom l \\<sharp> (s, k, v, i, sl, sl', m, n, sm, sm', sn, sn')\n  atom sl \\<sharp> (s, v, i, sl', m, n, sm, sm', sn, sn')\n  atom sl' \\<sharp> (s, v, i, m, n, sm, sm', sn, sn')\n  atom m \\<sharp> (s, n, sm, sm', sn, sn')\n  atom n \\<sharp> (s, sm, sm', sn, sn')\n  atom sm \\<sharp> (s, sm', sn, sn')\n  atom sm' \\<sharp> (s, sn, sn')\n  atom sn \\<sharp> (s, sn')\n  atom sn' \\<sharp> s\n\ngoal (1 subgoal):\n 1. (a \\<sharp> SeqStTermP v i t u s k =\n     (a \\<sharp> v \\<and>\n      a \\<sharp> i \\<and>\n      a \\<sharp> t \\<and>\n      a \\<sharp> u \\<and> a \\<sharp> s \\<and> a \\<sharp> k) &&&\n     Sigma_fm (SeqStTermP v i t u s k)) &&&\n    {SeqStTermP v i t u s k} \\<turnstile> OrdP k &&&\n    {SeqStTermP v i t u s k} \\<turnstile> VarP v &&&\n    {SeqStTermP v i t u s k} \\<turnstile> LstSeqP s k (HPair t u)", "by (auto intro: LstSeqP_OrdP)"], ["proof (state)\nthis:\n  a \\<sharp> SeqStTermP v i t u s k =\n  (a \\<sharp> v \\<and>\n   a \\<sharp> i \\<and>\n   a \\<sharp> t \\<and> a \\<sharp> u \\<and> a \\<sharp> s \\<and> a \\<sharp> k)\n  Sigma_fm (SeqStTermP v i t u s k)\n  {SeqStTermP v i t u s k} \\<turnstile> OrdP k\n  {SeqStTermP v i t u s k} \\<turnstile> VarP v\n  {SeqStTermP v i t u s k} \\<turnstile> LstSeqP s k (HPair t u)\n\ngoal (1 subgoal):\n 1. eval_fm e (SeqStTermP v i t u s k) =\n    SeqStTerm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\n     \\<lbrakk>u\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e", "show ?thesis2"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_fm e (SeqStTermP v i t u s k) =\n    SeqStTerm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\n     \\<lbrakk>u\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e", "using atoms"], ["proof (prove)\nusing this:\n  atom l \\<sharp> (s, k, v, i, sl, sl', m, n, sm, sm', sn, sn')\n  atom sl \\<sharp> (s, v, i, sl', m, n, sm, sm', sn, sn')\n  atom sl' \\<sharp> (s, v, i, m, n, sm, sm', sn, sn')\n  atom m \\<sharp> (s, n, sm, sm', sn, sn')\n  atom n \\<sharp> (s, sm, sm', sn, sn')\n  atom sm \\<sharp> (s, sm', sn, sn')\n  atom sm' \\<sharp> (s, sn, sn')\n  atom sn \\<sharp> (s, sn')\n  atom sn' \\<sharp> s\n\ngoal (1 subgoal):\n 1. eval_fm e (SeqStTermP v i t u s k) =\n    SeqStTerm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\n     \\<lbrakk>u\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e", "apply (simp add: LstSeq_imp_Ord SeqStTerm_def ex_disj_distrib\n             BuildSeq2_def BuildSeq_def Builds_def\n             HBall_def q_Eats_def q_Ind_def is_Var_def\n             Seq_iff_app [of \"\\<lbrakk>s\\<rbrakk>e\", OF LstSeq_imp_Seq_succ]\n             Ord_trans [of _ _ \"succ \\<lbrakk>k\\<rbrakk>e\"]\n             cong: conj_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom l \\<sharp> (s, k, v, i, sl, sl', m, n, sm, sm', sn, sn');\n     atom sl \\<sharp> (s, v, i, sl', m, n, sm, sm', sn, sn');\n     atom sl' \\<sharp> (s, v, i, m, n, sm, sm', sn, sn');\n     atom m \\<sharp> (s, n, sm, sm', sn, sn');\n     atom n \\<sharp> (s, sm, sm', sn, sn');\n     atom sm \\<sharp> (s, sm', sn, sn'); atom sm' \\<sharp> (s, sn, sn');\n     atom sn \\<sharp> (s, sn'); atom sn' \\<sharp> s\\<rbrakk>\n    \\<Longrightarrow> (Ord \\<lbrakk>v\\<rbrakk>e \\<and>\n                       0 \\<^bold>\\<in> \\<lbrakk>v\\<rbrakk>e \\<and>\n                       LstSeq \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e\n                        \\<langle>\\<lbrakk>t\\<rbrakk>e,\n                                 \\<lbrakk>u\\<rbrakk>e\\<rangle> \\<and>\n                       (\\<forall>x.\n                           x \\<^bold>\\<in>\n                           succ \\<lbrakk>k\\<rbrakk>e \\<longrightarrow>\n                           (\\<exists>xa xb.\n                               app \\<lbrakk>s\\<rbrakk>e x =\n                               \\<langle>xa, xb\\<rangle> \\<and>\n                               (xa = \\<lbrakk>v\\<rbrakk>e \\<and>\n                                xb = \\<lbrakk>i\\<rbrakk>e \\<or>\n                                (is_Ind xa \\<or>\n                                 Ord xa \\<and>\n                                 xa \\<noteq> \\<lbrakk>v\\<rbrakk>e) \\<and>\n                                xb = xa \\<or>\n                                (\\<exists>xc.\n                                    xc \\<^bold>\\<in> x \\<and>\n                                    (\\<exists>xd.\n  xd \\<^bold>\\<in> x \\<and>\n  (\\<exists>x xe.\n      app \\<lbrakk>s\\<rbrakk>e xc = \\<langle>x, xe\\<rangle> \\<and>\n      (\\<exists>xc.\n          xa = \\<langle>\\<langle>0, 0, 0\\<rangle>, x, xc\\<rangle> \\<and>\n          (\\<exists>x.\n              app \\<lbrakk>s\\<rbrakk>e xd = \\<langle>xc, x\\<rangle> \\<and>\n              xb =\n              \\<langle>\\<langle>0, 0, 0\\<rangle>, xe, x\\<rangle>))))))))) =\n                      (Ord \\<lbrakk>v\\<rbrakk>e \\<and>\n                       0 \\<^bold>\\<in> \\<lbrakk>v\\<rbrakk>e \\<and>\n                       LstSeq \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e\n                        \\<langle>\\<lbrakk>t\\<rbrakk>e,\n                                 \\<lbrakk>u\\<rbrakk>e\\<rangle> \\<and>\n                       (\\<forall>x.\n                           x \\<^bold>\\<in>\n                           succ \\<lbrakk>k\\<rbrakk>e \\<longrightarrow>\n                           (\\<exists>xa.\n                               (xa = \\<lbrakk>v\\<rbrakk>e \\<longrightarrow>\n                                app \\<lbrakk>s\\<rbrakk>e x =\n                                \\<langle>\\<lbrakk>v\\<rbrakk>e,\n   \\<lbrakk>i\\<rbrakk>e\\<rangle>) \\<and>\n                               (xa \\<noteq>\n                                \\<lbrakk>v\\<rbrakk>e \\<longrightarrow>\n                                app \\<lbrakk>s\\<rbrakk>e x =\n                                \\<langle>xa, xa\\<rangle> \\<and>\n                                (is_Ind xa \\<or> Ord xa))) \\<or>\n                           (\\<exists>m\\<^bold>\\<in>x.\n                               \\<exists>n\\<^bold>\\<in>x.\n                                  \\<exists>xa x'.\n                                     app \\<lbrakk>s\\<rbrakk>e x =\n                                     \\<langle>xa, x'\\<rangle> \\<and>\n                                     (\\<exists>y y'.\n   app \\<lbrakk>s\\<rbrakk>e m = \\<langle>y, y'\\<rangle> \\<and>\n   (\\<exists>z z'.\n       app \\<lbrakk>s\\<rbrakk>e n = \\<langle>z, z'\\<rangle> \\<and>\n       xa = \\<langle>\\<langle>0, 0, 0\\<rangle>, y, z\\<rangle> \\<and>\n       x' = \\<langle>\\<langle>0, 0, 0\\<rangle>, y', z'\\<rangle>)))))", "apply (rule conj_cong refl all_cong)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>atom\n                 l \\<sharp> (s, k, v, i, sl, sl', m, n, sm, sm', sn, sn');\n        atom sl \\<sharp> (s, v, i, sl', m, n, sm, sm', sn, sn');\n        atom sl' \\<sharp> (s, v, i, m, n, sm, sm', sn, sn');\n        atom m \\<sharp> (s, n, sm, sm', sn, sn');\n        atom n \\<sharp> (s, sm, sm', sn, sn');\n        atom sm \\<sharp> (s, sm', sn, sn'); atom sm' \\<sharp> (s, sn, sn');\n        atom sn \\<sharp> (s, sn'); atom sn' \\<sharp> s;\n        Ord \\<lbrakk>v\\<rbrakk>e; 0 \\<^bold>\\<in> \\<lbrakk>v\\<rbrakk>e;\n        LstSeq \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e\n         \\<langle>\\<lbrakk>t\\<rbrakk>e, \\<lbrakk>u\\<rbrakk>e\\<rangle>;\n        x \\<^bold>\\<in> succ \\<lbrakk>k\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa xb.\n                             app \\<lbrakk>s\\<rbrakk>e x =\n                             \\<langle>xa, xb\\<rangle> \\<and>\n                             (xa = \\<lbrakk>v\\<rbrakk>e \\<and>\n                              xb = \\<lbrakk>i\\<rbrakk>e \\<or>\n                              (is_Ind xa \\<or>\n                               Ord xa \\<and>\n                               xa \\<noteq> \\<lbrakk>v\\<rbrakk>e) \\<and>\n                              xb = xa \\<or>\n                              (\\<exists>xc.\n                                  xc \\<^bold>\\<in> x \\<and>\n                                  (\\<exists>xd.\nxd \\<^bold>\\<in> x \\<and>\n(\\<exists>x xe.\n    app \\<lbrakk>s\\<rbrakk>e xc = \\<langle>x, xe\\<rangle> \\<and>\n    (\\<exists>xc.\n        xa = \\<langle>\\<langle>0, 0, 0\\<rangle>, x, xc\\<rangle> \\<and>\n        (\\<exists>x.\n            app \\<lbrakk>s\\<rbrakk>e xd = \\<langle>xc, x\\<rangle> \\<and>\n            xb = \\<langle>\\<langle>0, 0, 0\\<rangle>, xe, x\\<rangle>))))))) =\n                         ((\\<exists>xa.\n                              (xa = \\<lbrakk>v\\<rbrakk>e \\<longrightarrow>\n                               app \\<lbrakk>s\\<rbrakk>e x =\n                               \\<langle>\\<lbrakk>v\\<rbrakk>e,\n  \\<lbrakk>i\\<rbrakk>e\\<rangle>) \\<and>\n                              (xa \\<noteq>\n                               \\<lbrakk>v\\<rbrakk>e \\<longrightarrow>\n                               app \\<lbrakk>s\\<rbrakk>e x =\n                               \\<langle>xa, xa\\<rangle> \\<and>\n                               (is_Ind xa \\<or> Ord xa))) \\<or>\n                          (\\<exists>m\\<^bold>\\<in>x.\n                              \\<exists>n\\<^bold>\\<in>x.\n                                 \\<exists>xa x'.\n                                    app \\<lbrakk>s\\<rbrakk>e x =\n                                    \\<langle>xa, x'\\<rangle> \\<and>\n                                    (\\<exists>y y'.\n  app \\<lbrakk>s\\<rbrakk>e m = \\<langle>y, y'\\<rangle> \\<and>\n  (\\<exists>z z'.\n      app \\<lbrakk>s\\<rbrakk>e n = \\<langle>z, z'\\<rangle> \\<and>\n      xa = \\<langle>\\<langle>0, 0, 0\\<rangle>, y, z\\<rangle> \\<and>\n      x' = \\<langle>\\<langle>0, 0, 0\\<rangle>, y', z'\\<rangle>))))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>atom\n                 l \\<sharp> (s, k, v, i, sl, sl', m, n, sm, sm', sn, sn');\n        atom sl \\<sharp> (s, v, i, sl', m, n, sm, sm', sn, sn');\n        atom sl' \\<sharp> (s, v, i, m, n, sm, sm', sn, sn');\n        atom m \\<sharp> (s, n, sm, sm', sn, sn');\n        atom n \\<sharp> (s, sm, sm', sn, sn');\n        atom sm \\<sharp> (s, sm', sn, sn'); atom sm' \\<sharp> (s, sn, sn');\n        atom sn \\<sharp> (s, sn'); atom sn' \\<sharp> s;\n        Ord \\<lbrakk>v\\<rbrakk>e; 0 \\<^bold>\\<in> \\<lbrakk>v\\<rbrakk>e;\n        LstSeq \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e\n         \\<langle>\\<lbrakk>t\\<rbrakk>e, \\<lbrakk>u\\<rbrakk>e\\<rangle>;\n        x \\<^bold>\\<in> succ \\<lbrakk>k\\<rbrakk>e;\n        app \\<lbrakk>s\\<rbrakk>e x = \\<langle>xa, xa\\<rangle>;\n        \\<forall>m\\<^bold>\\<in>x.\n           \\<forall>n\\<^bold>\\<in>x.\n              \\<forall>y y'.\n                 app \\<lbrakk>s\\<rbrakk>e m =\n                 \\<langle>y, y'\\<rangle> \\<longrightarrow>\n                 (\\<forall>z.\n                     xa =\n                     \\<langle>\\<langle>0, 0, 0\\<rangle>, y,\n                              z\\<rangle> \\<longrightarrow>\n                     y = y' \\<longrightarrow>\n                     (\\<forall>z'.\n                         app \\<lbrakk>s\\<rbrakk>e n =\n                         \\<langle>z, z'\\<rangle> \\<longrightarrow>\n                         z \\<noteq> z'));\n        is_Ind xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x = \\<lbrakk>v\\<rbrakk>e \\<longrightarrow>\n                             xa = \\<lbrakk>v\\<rbrakk>e \\<and>\n                             xa = \\<lbrakk>i\\<rbrakk>e) \\<and>\n                            (x \\<noteq>\n                             \\<lbrakk>v\\<rbrakk>e \\<longrightarrow>\n                             xa = x \\<and> (is_Ind x \\<or> Ord x))", "apply (metis Not_Ord_hpair is_Ind_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eval_fm e (SeqStTermP v i t u s k) =\n  SeqStTerm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\n   \\<lbrakk>u\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SeqStTermP_subst [simp]:\n      \"(SeqStTermP v i t u s k)(j::=w) =\n       SeqStTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u) (subst j w s) (subst j w k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SeqStTermP v i t u s k)(j::=w) =\n    SeqStTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u)\n     (subst j w s) (subst j w k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (SeqStTermP v i t u s k)(j::=w) =\n    SeqStTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u)\n     (subst j w s) (subst j w k)", "obtain l::name and sl::name and sl'::name and m::name and n::name and\n         sm::name and sm'::name and sn::name and sn'::name\n    where \"atom l \\<sharp> (s,k,v,i,w,j,sl,sl',m,n,sm,sm',sn,sn')\"\n         \"atom sl \\<sharp> (s,v,i,w,j,sl',m,n,sm,sm',sn,sn')\"\n         \"atom sl' \\<sharp> (s,v,i,w,j,m,n,sm,sm',sn,sn')\"\n         \"atom m \\<sharp> (s,w,j,n,sm,sm',sn,sn')\" \"atom n \\<sharp> (s,w,j,sm,sm',sn,sn')\"\n         \"atom sm \\<sharp> (s,w,j,sm',sn,sn')\" \"atom sm' \\<sharp> (s,w,j,sn,sn')\"\n         \"atom sn \\<sharp> (s,w,j,sn')\" \"atom sn' \\<sharp> (s,w,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l sl sl' m n sm sm' sn sn'.\n        \\<lbrakk>atom\n                  l \\<sharp> (s, k, v, i, w, j, sl, sl', m, n, sm, sm', sn,\n                              sn');\n         atom sl \\<sharp> (s, v, i, w, j, sl', m, n, sm, sm', sn, sn');\n         atom sl' \\<sharp> (s, v, i, w, j, m, n, sm, sm', sn, sn');\n         atom m \\<sharp> (s, w, j, n, sm, sm', sn, sn');\n         atom n \\<sharp> (s, w, j, sm, sm', sn, sn');\n         atom sm \\<sharp> (s, w, j, sm', sn, sn');\n         atom sm' \\<sharp> (s, w, j, sn, sn');\n         atom sn \\<sharp> (s, w, j, sn');\n         atom sn' \\<sharp> (s, w, j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom l \\<sharp> (s, k, v, i, w, j, sl, sl', m, n, sm, sm', sn, sn')\n  atom sl \\<sharp> (s, v, i, w, j, sl', m, n, sm, sm', sn, sn')\n  atom sl' \\<sharp> (s, v, i, w, j, m, n, sm, sm', sn, sn')\n  atom m \\<sharp> (s, w, j, n, sm, sm', sn, sn')\n  atom n \\<sharp> (s, w, j, sm, sm', sn, sn')\n  atom sm \\<sharp> (s, w, j, sm', sn, sn')\n  atom sm' \\<sharp> (s, w, j, sn, sn')\n  atom sn \\<sharp> (s, w, j, sn')\n  atom sn' \\<sharp> (s, w, j)\n\ngoal (1 subgoal):\n 1. (SeqStTermP v i t u s k)(j::=w) =\n    SeqStTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u)\n     (subst j w s) (subst j w k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom l \\<sharp> (s, k, v, i, w, j, sl, sl', m, n, sm, sm', sn, sn')\n  atom sl \\<sharp> (s, v, i, w, j, sl', m, n, sm, sm', sn, sn')\n  atom sl' \\<sharp> (s, v, i, w, j, m, n, sm, sm', sn, sn')\n  atom m \\<sharp> (s, w, j, n, sm, sm', sn, sn')\n  atom n \\<sharp> (s, w, j, sm, sm', sn, sn')\n  atom sm \\<sharp> (s, w, j, sm', sn, sn')\n  atom sm' \\<sharp> (s, w, j, sn, sn')\n  atom sn \\<sharp> (s, w, j, sn')\n  atom sn' \\<sharp> (s, w, j)\n\ngoal (1 subgoal):\n 1. (SeqStTermP v i t u s k)(j::=w) =\n    SeqStTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u)\n     (subst j w s) (subst j w k)", "by (force simp add: SeqStTermP.simps [of l _ _ _ _ sl sl' m n sm sm' sn sn'])"], ["proof (state)\nthis:\n  (SeqStTermP v i t u s k)(j::=w) =\n  SeqStTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u)\n   (subst j w s) (subst j w k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SeqStTermP_cong:\n  \"\\<lbrakk>H \\<turnstile> t EQ t'; H \\<turnstile> u EQ u'; H \\<turnstile> s EQ s'; H \\<turnstile> k EQ k'\\<rbrakk>\n   \\<Longrightarrow> H \\<turnstile> SeqStTermP v i t u s k IFF SeqStTermP v i t' u' s' k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> t EQ t'; H \\<turnstile> u EQ u';\n     H \\<turnstile> s EQ s'; H \\<turnstile> k EQ k'\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile>\n                      SeqStTermP v i t u s k IFF SeqStTermP v i t' u' s' k'", "by (rule P4_cong [where tms=\"[v,i]\"]) (auto simp: fresh_Cons)"], ["", "declare SeqStTermP.simps [simp del]"], ["", "subsection \\<open>Defining the syntax: main predicate\\<close>"], ["", "nominal_function AbstTermP :: \"tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> fm\"\n  where \"\\<lbrakk>atom s \\<sharp> (v,i,t,u,k); atom k \\<sharp> (v,i,t,u)\\<rbrakk> \\<Longrightarrow>\n    AbstTermP v i t u =\n     OrdP i AND Ex s (Ex k (SeqStTermP v (Q_Ind i) t u (Var s) (Var k)))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt AbstTermP_graph_aux\n 2. \\<And>x y. AbstTermP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>s v i t u k.\n           \\<lbrakk>atom s \\<sharp> (v, i, t, u, k);\n            atom k \\<sharp> (v, i, t, u); x = (v, i, t, u)\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>s v i t u k sa va ia ta ua ka.\n       \\<lbrakk>atom s \\<sharp> (v, i, t, u, k);\n        atom k \\<sharp> (v, i, t, u); atom sa \\<sharp> (va, ia, ta, ua, ka);\n        atom ka \\<sharp> (va, ia, ta, ua);\n        (v, i, t, u) = (va, ia, ta, ua)\\<rbrakk>\n       \\<Longrightarrow> OrdP i AND\n                         SyntaxN.Ex s\n                          (SyntaxN.Ex k\n                            (SeqStTermP v (Q_Ind i) t u (Var s) (Var k))) =\n                         OrdP ia AND\n                         SyntaxN.Ex sa\n                          (SyntaxN.Ex ka\n                            (SeqStTermP va (Q_Ind ia) ta ua (Var sa)\n                              (Var ka)))", "by (auto simp: eqvt_def AbstTermP_graph_aux_def flip_fresh_fresh) (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All AbstTermP_dom", "by lexicographic_order"], ["", "lemma\n  shows AbstTermP_fresh_iff [simp]:\n      \"a \\<sharp> AbstTermP v i t u \\<longleftrightarrow> a \\<sharp> v \\<and> a \\<sharp> i \\<and> a \\<sharp> t \\<and> a \\<sharp> u\"  (is ?thesis1)\n    and eval_fm_AbstTermP [simp]:\n      \"eval_fm e (AbstTermP v i t u) \\<longleftrightarrow> AbstTerm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e \"  (is ?thesis2)\n    and AbstTermP_sf [iff]:\n      \"Sigma_fm (AbstTermP v i t u)\"  (is ?thsf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> AbstTermP v i t u =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> i \\<and> a \\<sharp> t \\<and> a \\<sharp> u) &&&\n    eval_fm e (AbstTermP v i t u) =\n    AbstTerm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\n     \\<lbrakk>u\\<rbrakk>e &&&\n    Sigma_fm (AbstTermP v i t u)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. a \\<sharp> AbstTermP v i t u =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> i \\<and> a \\<sharp> t \\<and> a \\<sharp> u)\n 2. eval_fm e (AbstTermP v i t u) =\n    AbstTerm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\n     \\<lbrakk>u\\<rbrakk>e\n 3. Sigma_fm (AbstTermP v i t u)", "obtain s::name and k::name where \"atom s \\<sharp> (v,i,t,u,k)\"  \"atom k \\<sharp> (v,i,t,u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s k.\n        \\<lbrakk>atom s \\<sharp> (v, i, t, u, k);\n         atom k \\<sharp> (v, i, t, u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom s \\<sharp> (v, i, t, u, k)\n  atom k \\<sharp> (v, i, t, u)\n\ngoal (3 subgoals):\n 1. a \\<sharp> AbstTermP v i t u =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> i \\<and> a \\<sharp> t \\<and> a \\<sharp> u)\n 2. eval_fm e (AbstTermP v i t u) =\n    AbstTerm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\n     \\<lbrakk>u\\<rbrakk>e\n 3. Sigma_fm (AbstTermP v i t u)", "thus ?thesis1 ?thesis2 ?thsf"], ["proof (prove)\nusing this:\n  atom s \\<sharp> (v, i, t, u, k)\n  atom k \\<sharp> (v, i, t, u)\n\ngoal (1 subgoal):\n 1. a \\<sharp> AbstTermP v i t u =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> i \\<and> a \\<sharp> t \\<and> a \\<sharp> u) &&&\n    eval_fm e (AbstTermP v i t u) =\n    AbstTerm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\n     \\<lbrakk>u\\<rbrakk>e &&&\n    Sigma_fm (AbstTermP v i t u)", "by (auto simp: AbstTerm_def q_defs)"], ["proof (state)\nthis:\n  a \\<sharp> AbstTermP v i t u =\n  (a \\<sharp> v \\<and> a \\<sharp> i \\<and> a \\<sharp> t \\<and> a \\<sharp> u)\n  eval_fm e (AbstTermP v i t u) =\n  AbstTerm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\n   \\<lbrakk>u\\<rbrakk>e\n  Sigma_fm (AbstTermP v i t u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma AbstTermP_subst [simp]:\n      \"(AbstTermP v i t u)(j::=w) = AbstTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (AbstTermP v i t u)(j::=w) =\n    AbstTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (AbstTermP v i t u)(j::=w) =\n    AbstTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u)", "obtain s::name and k::name  where \"atom s \\<sharp> (v,i,t,u,w,j,k)\"  \"atom k \\<sharp> (v,i,t,u,w,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s k.\n        \\<lbrakk>atom s \\<sharp> (v, i, t, u, w, j, k);\n         atom k \\<sharp> (v, i, t, u, w, j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom s \\<sharp> (v, i, t, u, w, j, k)\n  atom k \\<sharp> (v, i, t, u, w, j)\n\ngoal (1 subgoal):\n 1. (AbstTermP v i t u)(j::=w) =\n    AbstTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u)", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom s \\<sharp> (v, i, t, u, w, j, k)\n  atom k \\<sharp> (v, i, t, u, w, j)\n\ngoal (1 subgoal):\n 1. (AbstTermP v i t u)(j::=w) =\n    AbstTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u)", "by (simp add: AbstTermP.simps [of s _ _ _ _ k])"], ["proof (state)\nthis:\n  (AbstTermP v i t u)(j::=w) =\n  AbstTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare AbstTermP.simps [simp del]"], ["", "subsection \\<open>Correctness: It Coincides with Abstraction over real terms\\<close>"], ["", "lemma not_is_Var_is_Ind: \"is_Var v \\<Longrightarrow> \\<not> is_Ind v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Var v \\<Longrightarrow> \\<not> is_Ind v", "by (auto simp: is_Var_def is_Ind_def)"], ["", "lemma AbstTerm_imp_abst_dbtm:\n  assumes \"AbstTerm v i x x'\"\n  shows \"\\<exists>t. x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n             x' = \\<lbrakk>quot_dbtm (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t.\n       x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n       x' =\n       \\<lbrakk>quot_dbtm\n                 (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t.\n       x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n       x' =\n       \\<lbrakk>quot_dbtm\n                 (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e", "obtain s k where v: \"is_Var v\" and i: \"Ord i\" and sk: \"SeqStTerm v (q_Ind i) x x' s k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s k.\n        \\<lbrakk>is_Var v; Ord i; SeqStTerm v (q_Ind i) x x' s k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  AbstTerm v i x x'\n\ngoal (1 subgoal):\n 1. (\\<And>s k.\n        \\<lbrakk>is_Var v; Ord i; SeqStTerm v (q_Ind i) x x' s k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: AbstTerm_def SeqStTerm_def)"], ["proof (state)\nthis:\n  is_Var v\n  Ord i\n  SeqStTerm v (q_Ind i) x x' s k\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n       x' =\n       \\<lbrakk>quot_dbtm\n                 (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e", "from sk [unfolded SeqStTerm_def, THEN conjunct2]"], ["proof (chain)\npicking this:\n  BuildSeq2\n   (\\<lambda>y y'.\n       (is_Ind y \\<or> Ord y) \\<and> y' = (if y = v then q_Ind i else y))\n   (\\<lambda>u u' v v' w w'. u = q_Eats v w \\<and> u' = q_Eats v' w') s k x\n   x'", "show ?thesis"], ["proof (prove)\nusing this:\n  BuildSeq2\n   (\\<lambda>y y'.\n       (is_Ind y \\<or> Ord y) \\<and> y' = (if y = v then q_Ind i else y))\n   (\\<lambda>u u' v v' w w'. u = q_Eats v w \\<and> u' = q_Eats v' w') s k x\n   x'\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n       x' =\n       \\<lbrakk>quot_dbtm\n                 (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e", "proof (induct x x' rule: BuildSeq2_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x x'.\n       (is_Ind x \\<or> Ord x) \\<and>\n       x' = (if x = v then q_Ind i else x) \\<Longrightarrow>\n       \\<exists>t.\n          x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n          x' =\n          \\<lbrakk>quot_dbtm\n                    (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e\n 2. \\<And>x x' y y' z z'.\n       \\<lbrakk>x = q_Eats y z \\<and> x' = q_Eats y' z';\n        \\<exists>t.\n           y = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n           y' =\n           \\<lbrakk>quot_dbtm\n                     (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e;\n        \\<exists>t.\n           z = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n           z' =\n           \\<lbrakk>quot_dbtm\n                     (abst_dbtm (decode_Var v) (nat_of_ord i)\n                       t)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                            x' =\n                            \\<lbrakk>quot_dbtm\n(abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e", "case (B x x')"], ["proof (state)\nthis:\n  (is_Ind x \\<or> Ord x) \\<and> x' = (if x = v then q_Ind i else x)\n\ngoal (2 subgoals):\n 1. \\<And>x x'.\n       (is_Ind x \\<or> Ord x) \\<and>\n       x' = (if x = v then q_Ind i else x) \\<Longrightarrow>\n       \\<exists>t.\n          x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n          x' =\n          \\<lbrakk>quot_dbtm\n                    (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e\n 2. \\<And>x x' y y' z z'.\n       \\<lbrakk>x = q_Eats y z \\<and> x' = q_Eats y' z';\n        \\<exists>t.\n           y = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n           y' =\n           \\<lbrakk>quot_dbtm\n                     (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e;\n        \\<exists>t.\n           z = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n           z' =\n           \\<lbrakk>quot_dbtm\n                     (abst_dbtm (decode_Var v) (nat_of_ord i)\n                       t)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                            x' =\n                            \\<lbrakk>quot_dbtm\n(abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e", "thus ?case"], ["proof (prove)\nusing this:\n  (is_Ind x \\<or> Ord x) \\<and> x' = (if x = v then q_Ind i else x)\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n       x' =\n       \\<lbrakk>quot_dbtm\n                 (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e", "using v i"], ["proof (prove)\nusing this:\n  (is_Ind x \\<or> Ord x) \\<and> x' = (if x = v then q_Ind i else x)\n  is_Var v\n  Ord i\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n       x' =\n       \\<lbrakk>quot_dbtm\n                 (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e", "apply (auto simp: not_is_Var_is_Ind)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_Var v; Ord i; x' = x; is_Ind x; x \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                         x =\n                         \\<lbrakk>quot_dbtm\n                                   (abst_dbtm (decode_Var v) (nat_of_ord i)\n                                     t)\\<rbrakk>e\n 2. \\<lbrakk>is_Var v; Ord i; x' = q_Ind i; Ord v; x = v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         v = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                         q_Ind i =\n                         \\<lbrakk>quot_dbtm\n                                   (abst_dbtm (decode_Var v) (nat_of_ord i)\n                                     t)\\<rbrakk>e\n 3. \\<lbrakk>is_Var v; Ord i; x' = x; Ord x; x \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                         x =\n                         \\<lbrakk>quot_dbtm\n                                   (abst_dbtm (decode_Var v) (nat_of_ord i)\n                                     t)\\<rbrakk>e", "apply (rule_tac [1] x=\"DBInd (nat_of_ord (hsnd x))\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_Var v; Ord i; x' = x; is_Ind x; x \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> x =\n                      \\<lbrakk>quot_dbtm\n                                (DBInd\n                                  (nat_of_ord (hsnd x)))\\<rbrakk>e \\<and>\n                      x =\n                      \\<lbrakk>quot_dbtm\n                                (abst_dbtm (decode_Var v) (nat_of_ord i)\n                                  (DBInd (nat_of_ord (hsnd x))))\\<rbrakk>e\n 2. \\<lbrakk>is_Var v; Ord i; x' = q_Ind i; Ord v; x = v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         v = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                         q_Ind i =\n                         \\<lbrakk>quot_dbtm\n                                   (abst_dbtm (decode_Var v) (nat_of_ord i)\n                                     t)\\<rbrakk>e\n 3. \\<lbrakk>is_Var v; Ord i; x' = x; Ord x; x \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                         x =\n                         \\<lbrakk>quot_dbtm\n                                   (abst_dbtm (decode_Var v) (nat_of_ord i)\n                                     t)\\<rbrakk>e", "apply (rule_tac [2] x=\"DBVar (decode_Var v)\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_Var v; Ord i; x' = x; is_Ind x; x \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> x =\n                      \\<lbrakk>quot_dbtm\n                                (DBInd\n                                  (nat_of_ord (hsnd x)))\\<rbrakk>e \\<and>\n                      x =\n                      \\<lbrakk>quot_dbtm\n                                (abst_dbtm (decode_Var v) (nat_of_ord i)\n                                  (DBInd (nat_of_ord (hsnd x))))\\<rbrakk>e\n 2. \\<lbrakk>is_Var v; Ord i; x' = q_Ind i; Ord v; x = v\\<rbrakk>\n    \\<Longrightarrow> v =\n                      \\<lbrakk>quot_dbtm\n                                (DBVar (decode_Var v))\\<rbrakk>e \\<and>\n                      q_Ind i =\n                      \\<lbrakk>quot_dbtm\n                                (abst_dbtm (decode_Var v) (nat_of_ord i)\n                                  (DBVar (decode_Var v)))\\<rbrakk>e\n 3. \\<lbrakk>is_Var v; Ord i; x' = x; Ord x; x \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                         x =\n                         \\<lbrakk>quot_dbtm\n                                   (abst_dbtm (decode_Var v) (nat_of_ord i)\n                                     t)\\<rbrakk>e", "apply (case_tac [3] \"is_Var x\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>is_Var v; Ord i; x' = x; is_Ind x; x \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> x =\n                      \\<lbrakk>quot_dbtm\n                                (DBInd\n                                  (nat_of_ord (hsnd x)))\\<rbrakk>e \\<and>\n                      x =\n                      \\<lbrakk>quot_dbtm\n                                (abst_dbtm (decode_Var v) (nat_of_ord i)\n                                  (DBInd (nat_of_ord (hsnd x))))\\<rbrakk>e\n 2. \\<lbrakk>is_Var v; Ord i; x' = q_Ind i; Ord v; x = v\\<rbrakk>\n    \\<Longrightarrow> v =\n                      \\<lbrakk>quot_dbtm\n                                (DBVar (decode_Var v))\\<rbrakk>e \\<and>\n                      q_Ind i =\n                      \\<lbrakk>quot_dbtm\n                                (abst_dbtm (decode_Var v) (nat_of_ord i)\n                                  (DBVar (decode_Var v)))\\<rbrakk>e\n 3. \\<lbrakk>is_Var v; Ord i; x' = x; Ord x; x \\<noteq> v; is_Var x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                         x =\n                         \\<lbrakk>quot_dbtm\n                                   (abst_dbtm (decode_Var v) (nat_of_ord i)\n                                     t)\\<rbrakk>e\n 4. \\<lbrakk>is_Var v; Ord i; x' = x; Ord x; x \\<noteq> v;\n     \\<not> is_Var x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                         x =\n                         \\<lbrakk>quot_dbtm\n                                   (abst_dbtm (decode_Var v) (nat_of_ord i)\n                                     t)\\<rbrakk>e", "apply (rule_tac [3] x=\"DBVar (decode_Var x)\" in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>is_Var v; Ord i; x' = x; is_Ind x; x \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> x =\n                      \\<lbrakk>quot_dbtm\n                                (DBInd\n                                  (nat_of_ord (hsnd x)))\\<rbrakk>e \\<and>\n                      x =\n                      \\<lbrakk>quot_dbtm\n                                (abst_dbtm (decode_Var v) (nat_of_ord i)\n                                  (DBInd (nat_of_ord (hsnd x))))\\<rbrakk>e\n 2. \\<lbrakk>is_Var v; Ord i; x' = q_Ind i; Ord v; x = v\\<rbrakk>\n    \\<Longrightarrow> v =\n                      \\<lbrakk>quot_dbtm\n                                (DBVar (decode_Var v))\\<rbrakk>e \\<and>\n                      q_Ind i =\n                      \\<lbrakk>quot_dbtm\n                                (abst_dbtm (decode_Var v) (nat_of_ord i)\n                                  (DBVar (decode_Var v)))\\<rbrakk>e\n 3. \\<lbrakk>is_Var v; Ord i; x' = x; Ord x; x \\<noteq> v; is_Var x\\<rbrakk>\n    \\<Longrightarrow> x =\n                      \\<lbrakk>quot_dbtm\n                                (DBVar (decode_Var x))\\<rbrakk>e \\<and>\n                      x =\n                      \\<lbrakk>quot_dbtm\n                                (abst_dbtm (decode_Var v) (nat_of_ord i)\n                                  (DBVar (decode_Var x)))\\<rbrakk>e\n 4. \\<lbrakk>is_Var v; Ord i; x' = x; Ord x; x \\<noteq> v;\n     \\<not> is_Var x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                         x =\n                         \\<lbrakk>quot_dbtm\n                                   (abst_dbtm (decode_Var v) (nat_of_ord i)\n                                     t)\\<rbrakk>e", "apply (rule_tac [4] x=DBZero in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>is_Var v; Ord i; x' = x; is_Ind x; x \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> x =\n                      \\<lbrakk>quot_dbtm\n                                (DBInd\n                                  (nat_of_ord (hsnd x)))\\<rbrakk>e \\<and>\n                      x =\n                      \\<lbrakk>quot_dbtm\n                                (abst_dbtm (decode_Var v) (nat_of_ord i)\n                                  (DBInd (nat_of_ord (hsnd x))))\\<rbrakk>e\n 2. \\<lbrakk>is_Var v; Ord i; x' = q_Ind i; Ord v; x = v\\<rbrakk>\n    \\<Longrightarrow> v =\n                      \\<lbrakk>quot_dbtm\n                                (DBVar (decode_Var v))\\<rbrakk>e \\<and>\n                      q_Ind i =\n                      \\<lbrakk>quot_dbtm\n                                (abst_dbtm (decode_Var v) (nat_of_ord i)\n                                  (DBVar (decode_Var v)))\\<rbrakk>e\n 3. \\<lbrakk>is_Var v; Ord i; x' = x; Ord x; x \\<noteq> v; is_Var x\\<rbrakk>\n    \\<Longrightarrow> x =\n                      \\<lbrakk>quot_dbtm\n                                (DBVar (decode_Var x))\\<rbrakk>e \\<and>\n                      x =\n                      \\<lbrakk>quot_dbtm\n                                (abst_dbtm (decode_Var v) (nat_of_ord i)\n                                  (DBVar (decode_Var x)))\\<rbrakk>e\n 4. \\<lbrakk>is_Var v; Ord i; x' = x; Ord x; x \\<noteq> v;\n     \\<not> is_Var x\\<rbrakk>\n    \\<Longrightarrow> x = \\<lbrakk>quot_dbtm DBZero\\<rbrakk>e \\<and>\n                      x =\n                      \\<lbrakk>quot_dbtm\n                                (abst_dbtm (decode_Var v) (nat_of_ord i)\n                                  DBZero)\\<rbrakk>e", "apply (auto simp: is_Ind_def q_Ind_def is_Var_iff [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_Var v; Ord i; x' = x; Ord x; x \\<noteq> v;\n     \\<not> is_Var x\\<rbrakk>\n    \\<Longrightarrow> x = 0", "apply (metis hmem_0_Ord is_Var_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>t.\n     x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n     x' =\n     \\<lbrakk>quot_dbtm\n               (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>x x' y y' z z'.\n       \\<lbrakk>x = q_Eats y z \\<and> x' = q_Eats y' z';\n        \\<exists>t.\n           y = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n           y' =\n           \\<lbrakk>quot_dbtm\n                     (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e;\n        \\<exists>t.\n           z = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n           z' =\n           \\<lbrakk>quot_dbtm\n                     (abst_dbtm (decode_Var v) (nat_of_ord i)\n                       t)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                            x' =\n                            \\<lbrakk>quot_dbtm\n(abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x' y y' z z'.\n       \\<lbrakk>x = q_Eats y z \\<and> x' = q_Eats y' z';\n        \\<exists>t.\n           y = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n           y' =\n           \\<lbrakk>quot_dbtm\n                     (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e;\n        \\<exists>t.\n           z = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n           z' =\n           \\<lbrakk>quot_dbtm\n                     (abst_dbtm (decode_Var v) (nat_of_ord i)\n                       t)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                            x' =\n                            \\<lbrakk>quot_dbtm\n(abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e", "case (C x x' y y' z z')"], ["proof (state)\nthis:\n  x = q_Eats y z \\<and> x' = q_Eats y' z'\n  \\<exists>t.\n     y = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n     y' =\n     \\<lbrakk>quot_dbtm\n               (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e\n  \\<exists>t.\n     z = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n     z' =\n     \\<lbrakk>quot_dbtm\n               (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>x x' y y' z z'.\n       \\<lbrakk>x = q_Eats y z \\<and> x' = q_Eats y' z';\n        \\<exists>t.\n           y = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n           y' =\n           \\<lbrakk>quot_dbtm\n                     (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e;\n        \\<exists>t.\n           z = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n           z' =\n           \\<lbrakk>quot_dbtm\n                     (abst_dbtm (decode_Var v) (nat_of_ord i)\n                       t)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                            x' =\n                            \\<lbrakk>quot_dbtm\n(abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e", "then"], ["proof (chain)\npicking this:\n  x = q_Eats y z \\<and> x' = q_Eats y' z'\n  \\<exists>t.\n     y = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n     y' =\n     \\<lbrakk>quot_dbtm\n               (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e\n  \\<exists>t.\n     z = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n     z' =\n     \\<lbrakk>quot_dbtm\n               (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e", "obtain tm1 and tm2\n      where \"y = \\<lbrakk>quot_dbtm tm1\\<rbrakk>e\"\n              \"y' = \\<lbrakk>quot_dbtm (abst_dbtm (decode_Var v) (nat_of_ord i) tm1)\\<rbrakk>e\"\n            \"z = \\<lbrakk>quot_dbtm tm2\\<rbrakk>e\"\n              \"z' = \\<lbrakk>quot_dbtm (abst_dbtm (decode_Var v) (nat_of_ord i) tm2)\\<rbrakk>e\""], ["proof (prove)\nusing this:\n  x = q_Eats y z \\<and> x' = q_Eats y' z'\n  \\<exists>t.\n     y = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n     y' =\n     \\<lbrakk>quot_dbtm\n               (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e\n  \\<exists>t.\n     z = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n     z' =\n     \\<lbrakk>quot_dbtm\n               (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. (\\<And>tm1 tm2.\n        \\<lbrakk>y = \\<lbrakk>quot_dbtm tm1\\<rbrakk>e;\n         y' =\n         \\<lbrakk>quot_dbtm\n                   (abst_dbtm (decode_Var v) (nat_of_ord i) tm1)\\<rbrakk>e;\n         z = \\<lbrakk>quot_dbtm tm2\\<rbrakk>e;\n         z' =\n         \\<lbrakk>quot_dbtm\n                   (abst_dbtm (decode_Var v) (nat_of_ord i)\n                     tm2)\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y = \\<lbrakk>quot_dbtm tm1\\<rbrakk>e\n  y' =\n  \\<lbrakk>quot_dbtm (abst_dbtm (decode_Var v) (nat_of_ord i) tm1)\\<rbrakk>e\n  z = \\<lbrakk>quot_dbtm tm2\\<rbrakk>e\n  z' =\n  \\<lbrakk>quot_dbtm (abst_dbtm (decode_Var v) (nat_of_ord i) tm2)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>x x' y y' z z'.\n       \\<lbrakk>x = q_Eats y z \\<and> x' = q_Eats y' z';\n        \\<exists>t.\n           y = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n           y' =\n           \\<lbrakk>quot_dbtm\n                     (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e;\n        \\<exists>t.\n           z = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n           z' =\n           \\<lbrakk>quot_dbtm\n                     (abst_dbtm (decode_Var v) (nat_of_ord i)\n                       t)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                            x' =\n                            \\<lbrakk>quot_dbtm\n(abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e", "thus ?case"], ["proof (prove)\nusing this:\n  y = \\<lbrakk>quot_dbtm tm1\\<rbrakk>e\n  y' =\n  \\<lbrakk>quot_dbtm (abst_dbtm (decode_Var v) (nat_of_ord i) tm1)\\<rbrakk>e\n  z = \\<lbrakk>quot_dbtm tm2\\<rbrakk>e\n  z' =\n  \\<lbrakk>quot_dbtm (abst_dbtm (decode_Var v) (nat_of_ord i) tm2)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n       x' =\n       \\<lbrakk>quot_dbtm\n                 (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e", "by (auto simp: wf_dbtm.intros C q_Eats_def intro!: exI [where x=\"DBEats tm1 tm2\"])"], ["proof (state)\nthis:\n  \\<exists>t.\n     x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n     x' =\n     \\<lbrakk>quot_dbtm\n               (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>t.\n     x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n     x' =\n     \\<lbrakk>quot_dbtm\n               (abst_dbtm (decode_Var v) (nat_of_ord i) t)\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma AbstTerm_abst_dbtm:\n     \"AbstTerm (q_Var i) (ord_of n) \\<lbrakk>quot_dbtm t\\<rbrakk>e\n                                    \\<lbrakk>quot_dbtm (abst_dbtm i n t)\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AbstTerm (q_Var i) (ord_of n) \\<lbrakk>quot_dbtm t\\<rbrakk>e\n     \\<lbrakk>quot_dbtm (abst_dbtm i n t)\\<rbrakk>e", "by (induct t rule: dbtm.induct)\n     (auto simp: AbstTerm_def SeqStTerm_def q_defs intro: BuildSeq2_exI BuildSeq2_combine)"], ["", "section \\<open>Substitution over terms\\<close>"], ["", "definition SubstTerm :: \"hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> bool\"\n  where \"SubstTerm v u x x' \\<equiv> Term u \\<and> (\\<exists>s k. SeqStTerm v u x x' s k)\""], ["", "subsection \\<open>Defining the syntax\\<close>"], ["", "nominal_function SubstTermP :: \"tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> fm\"\n  where \"\\<lbrakk>atom s \\<sharp> (v,i,t,u,k); atom k \\<sharp> (v,i,t,u)\\<rbrakk> \\<Longrightarrow>\n    SubstTermP v i t u = TermP i AND Ex s (Ex k (SeqStTermP v i t u (Var s) (Var k)))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt SubstTermP_graph_aux\n 2. \\<And>x y. SubstTermP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>s v i t u k.\n           \\<lbrakk>atom s \\<sharp> (v, i, t, u, k);\n            atom k \\<sharp> (v, i, t, u); x = (v, i, t, u)\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>s v i t u k sa va ia ta ua ka.\n       \\<lbrakk>atom s \\<sharp> (v, i, t, u, k);\n        atom k \\<sharp> (v, i, t, u); atom sa \\<sharp> (va, ia, ta, ua, ka);\n        atom ka \\<sharp> (va, ia, ta, ua);\n        (v, i, t, u) = (va, ia, ta, ua)\\<rbrakk>\n       \\<Longrightarrow> TermP i AND\n                         SyntaxN.Ex s\n                          (SyntaxN.Ex k\n                            (SeqStTermP v i t u (Var s) (Var k))) =\n                         TermP ia AND\n                         SyntaxN.Ex sa\n                          (SyntaxN.Ex ka\n                            (SeqStTermP va ia ta ua (Var sa) (Var ka)))", "by (auto simp: eqvt_def SubstTermP_graph_aux_def flip_fresh_fresh) (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All SubstTermP_dom", "by lexicographic_order"], ["", "lemma\n  shows SubstTermP_fresh_iff [simp]:\n       \"a \\<sharp> SubstTermP v i t u \\<longleftrightarrow> a \\<sharp> v \\<and> a \\<sharp> i \\<and> a \\<sharp> t \\<and> a \\<sharp> u\"  (is ?thesis1)\n    and eval_fm_SubstTermP [simp]:\n       \"eval_fm e (SubstTermP v i t u) \\<longleftrightarrow> SubstTerm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e\"  (is ?thesis2)\n    and SubstTermP_sf [iff]:\n       \"Sigma_fm (SubstTermP v i t u)\"     (is ?thsf)\n    and SubstTermP_imp_TermP:\n       \"{ SubstTermP v i t u } \\<turnstile> TermP i\"  (is ?thterm)\n    and SubstTermP_imp_VarP:\n       \"{ SubstTermP v i t u } \\<turnstile> VarP v\"   (is ?thvar)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<sharp> SubstTermP v i t u =\n     (a \\<sharp> v \\<and>\n      a \\<sharp> i \\<and> a \\<sharp> t \\<and> a \\<sharp> u) &&&\n     eval_fm e (SubstTermP v i t u) =\n     SubstTerm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e\n      \\<lbrakk>t\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e) &&&\n    Sigma_fm (SubstTermP v i t u) &&&\n    {SubstTermP v i t u} \\<turnstile> TermP i &&&\n    {SubstTermP v i t u} \\<turnstile> VarP v", "proof -"], ["proof (state)\ngoal (5 subgoals):\n 1. a \\<sharp> SubstTermP v i t u =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> i \\<and> a \\<sharp> t \\<and> a \\<sharp> u)\n 2. eval_fm e (SubstTermP v i t u) =\n    SubstTerm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\n     \\<lbrakk>u\\<rbrakk>e\n 3. Sigma_fm (SubstTermP v i t u)\n 4. {SubstTermP v i t u} \\<turnstile> TermP i\n 5. {SubstTermP v i t u} \\<turnstile> VarP v", "obtain s::name and k::name  where \"atom s \\<sharp> (v,i,t,u,k)\" \"atom k \\<sharp> (v,i,t,u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s k.\n        \\<lbrakk>atom s \\<sharp> (v, i, t, u, k);\n         atom k \\<sharp> (v, i, t, u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom s \\<sharp> (v, i, t, u, k)\n  atom k \\<sharp> (v, i, t, u)\n\ngoal (5 subgoals):\n 1. a \\<sharp> SubstTermP v i t u =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> i \\<and> a \\<sharp> t \\<and> a \\<sharp> u)\n 2. eval_fm e (SubstTermP v i t u) =\n    SubstTerm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\n     \\<lbrakk>u\\<rbrakk>e\n 3. Sigma_fm (SubstTermP v i t u)\n 4. {SubstTermP v i t u} \\<turnstile> TermP i\n 5. {SubstTermP v i t u} \\<turnstile> VarP v", "thus ?thesis1 ?thesis2 ?thsf ?thterm ?thvar"], ["proof (prove)\nusing this:\n  atom s \\<sharp> (v, i, t, u, k)\n  atom k \\<sharp> (v, i, t, u)\n\ngoal (1 subgoal):\n 1. (a \\<sharp> SubstTermP v i t u =\n     (a \\<sharp> v \\<and>\n      a \\<sharp> i \\<and> a \\<sharp> t \\<and> a \\<sharp> u) &&&\n     eval_fm e (SubstTermP v i t u) =\n     SubstTerm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e\n      \\<lbrakk>t\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e) &&&\n    Sigma_fm (SubstTermP v i t u) &&&\n    {SubstTermP v i t u} \\<turnstile> TermP i &&&\n    {SubstTermP v i t u} \\<turnstile> VarP v", "by (auto simp: SubstTerm_def intro: SeqStTermP_imp_VarP thin2)"], ["proof (state)\nthis:\n  a \\<sharp> SubstTermP v i t u =\n  (a \\<sharp> v \\<and> a \\<sharp> i \\<and> a \\<sharp> t \\<and> a \\<sharp> u)\n  eval_fm e (SubstTermP v i t u) =\n  SubstTerm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\n   \\<lbrakk>u\\<rbrakk>e\n  Sigma_fm (SubstTermP v i t u)\n  {SubstTermP v i t u} \\<turnstile> TermP i\n  {SubstTermP v i t u} \\<turnstile> VarP v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SubstTermP_subst [simp]:\n      \"(SubstTermP v i t u)(j::=w) = SubstTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SubstTermP v i t u)(j::=w) =\n    SubstTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (SubstTermP v i t u)(j::=w) =\n    SubstTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u)", "obtain s::name and k::name\n    where \"atom s \\<sharp> (v,i,t,u,w,j,k)\"  \"atom k \\<sharp> (v,i,t,u,w,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s k.\n        \\<lbrakk>atom s \\<sharp> (v, i, t, u, w, j, k);\n         atom k \\<sharp> (v, i, t, u, w, j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom s \\<sharp> (v, i, t, u, w, j, k)\n  atom k \\<sharp> (v, i, t, u, w, j)\n\ngoal (1 subgoal):\n 1. (SubstTermP v i t u)(j::=w) =\n    SubstTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u)", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom s \\<sharp> (v, i, t, u, w, j, k)\n  atom k \\<sharp> (v, i, t, u, w, j)\n\ngoal (1 subgoal):\n 1. (SubstTermP v i t u)(j::=w) =\n    SubstTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u)", "by (simp add: SubstTermP.simps [of s _ _ _ _ k])"], ["proof (state)\nthis:\n  (SubstTermP v i t u)(j::=w) =\n  SubstTermP (subst j w v) (subst j w i) (subst j w t) (subst j w u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SubstTermP_cong:\n  \"\\<lbrakk>H \\<turnstile> v EQ v'; H \\<turnstile> i EQ i'; H \\<turnstile> t EQ t'; H \\<turnstile> u EQ u'\\<rbrakk>\n   \\<Longrightarrow> H \\<turnstile> SubstTermP v i t u IFF SubstTermP v' i' t' u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> v EQ v'; H \\<turnstile> i EQ i';\n     H \\<turnstile> t EQ t'; H \\<turnstile> u EQ u'\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile>\n                      SubstTermP v i t u IFF SubstTermP v' i' t' u'", "by (rule P4_cong) auto"], ["", "declare SubstTermP.simps [simp del]"], ["", "lemma SubstTerm_imp_subst_dbtm:\n  assumes \"SubstTerm v \\<lbrakk>quot_dbtm u\\<rbrakk>e x x'\"\n  shows \"\\<exists>t. x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n             x' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t.\n       x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n       x' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t.\n       x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n       x' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e", "obtain s k where v: \"is_Var v\" and u: \"Term \\<lbrakk>quot_dbtm u\\<rbrakk>e\"\n               and sk: \"SeqStTerm v \\<lbrakk>quot_dbtm u\\<rbrakk>e x x' s k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s k.\n        \\<lbrakk>is_Var v; Term \\<lbrakk>quot_dbtm u\\<rbrakk>e;\n         SeqStTerm v \\<lbrakk>quot_dbtm u\\<rbrakk>e x x' s k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms [unfolded SubstTerm_def]"], ["proof (prove)\nusing this:\n  Term \\<lbrakk>quot_dbtm u\\<rbrakk>e \\<and>\n  (\\<exists>s k. SeqStTerm v \\<lbrakk>quot_dbtm u\\<rbrakk>e x x' s k)\n\ngoal (1 subgoal):\n 1. (\\<And>s k.\n        \\<lbrakk>is_Var v; Term \\<lbrakk>quot_dbtm u\\<rbrakk>e;\n         SeqStTerm v \\<lbrakk>quot_dbtm u\\<rbrakk>e x x' s k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: SeqStTerm_def)"], ["proof (state)\nthis:\n  is_Var v\n  Term \\<lbrakk>quot_dbtm u\\<rbrakk>e\n  SeqStTerm v \\<lbrakk>quot_dbtm u\\<rbrakk>e x x' s k\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n       x' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e", "from sk [unfolded SeqStTerm_def, THEN conjunct2]"], ["proof (chain)\npicking this:\n  BuildSeq2\n   (\\<lambda>y y'.\n       (is_Ind y \\<or> Ord y) \\<and>\n       y' = (if y = v then \\<lbrakk>quot_dbtm u\\<rbrakk>e else y))\n   (\\<lambda>u u' v v' w w'. u = q_Eats v w \\<and> u' = q_Eats v' w') s k x\n   x'", "show ?thesis"], ["proof (prove)\nusing this:\n  BuildSeq2\n   (\\<lambda>y y'.\n       (is_Ind y \\<or> Ord y) \\<and>\n       y' = (if y = v then \\<lbrakk>quot_dbtm u\\<rbrakk>e else y))\n   (\\<lambda>u u' v v' w w'. u = q_Eats v w \\<and> u' = q_Eats v' w') s k x\n   x'\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n       x' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e", "proof (induct x x' rule: BuildSeq2_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x x'.\n       (is_Ind x \\<or> Ord x) \\<and>\n       x' =\n       (if x = v then \\<lbrakk>quot_dbtm u\\<rbrakk>e\n        else x) \\<Longrightarrow>\n       \\<exists>t.\n          x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n          x' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e\n 2. \\<And>x x' y y' z z'.\n       \\<lbrakk>x = q_Eats y z \\<and> x' = q_Eats y' z';\n        \\<exists>t.\n           y = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n           y' =\n           \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e;\n        \\<exists>t.\n           z = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n           z' =\n           \\<lbrakk>quot_dbtm\n                     (subst_dbtm u (decode_Var v) t)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                            x' =\n                            \\<lbrakk>quot_dbtm\n(subst_dbtm u (decode_Var v) t)\\<rbrakk>e", "case (B x x')"], ["proof (state)\nthis:\n  (is_Ind x \\<or> Ord x) \\<and>\n  x' = (if x = v then \\<lbrakk>quot_dbtm u\\<rbrakk>e else x)\n\ngoal (2 subgoals):\n 1. \\<And>x x'.\n       (is_Ind x \\<or> Ord x) \\<and>\n       x' =\n       (if x = v then \\<lbrakk>quot_dbtm u\\<rbrakk>e\n        else x) \\<Longrightarrow>\n       \\<exists>t.\n          x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n          x' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e\n 2. \\<And>x x' y y' z z'.\n       \\<lbrakk>x = q_Eats y z \\<and> x' = q_Eats y' z';\n        \\<exists>t.\n           y = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n           y' =\n           \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e;\n        \\<exists>t.\n           z = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n           z' =\n           \\<lbrakk>quot_dbtm\n                     (subst_dbtm u (decode_Var v) t)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                            x' =\n                            \\<lbrakk>quot_dbtm\n(subst_dbtm u (decode_Var v) t)\\<rbrakk>e", "thus ?case"], ["proof (prove)\nusing this:\n  (is_Ind x \\<or> Ord x) \\<and>\n  x' = (if x = v then \\<lbrakk>quot_dbtm u\\<rbrakk>e else x)\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n       x' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e", "using v"], ["proof (prove)\nusing this:\n  (is_Ind x \\<or> Ord x) \\<and>\n  x' = (if x = v then \\<lbrakk>quot_dbtm u\\<rbrakk>e else x)\n  is_Var v\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n       x' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e", "apply (auto simp: not_is_Var_is_Ind)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_Var v; x' = x; is_Ind x; x \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                         x =\n                         \\<lbrakk>quot_dbtm\n                                   (subst_dbtm u (decode_Var v) t)\\<rbrakk>e\n 2. \\<lbrakk>is_Var v; x' = \\<lbrakk>quot_dbtm u\\<rbrakk>e; Ord v;\n     x = v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         v = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                         u = subst_dbtm u (decode_Var v) t\n 3. \\<lbrakk>is_Var v; x' = x; Ord x; x \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                         x =\n                         \\<lbrakk>quot_dbtm\n                                   (subst_dbtm u (decode_Var v) t)\\<rbrakk>e", "apply (rule_tac [1] x=\"DBInd (nat_of_ord (hsnd x))\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_Var v; x' = x; is_Ind x; x \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> x =\n                      \\<lbrakk>quot_dbtm\n                                (DBInd\n                                  (nat_of_ord (hsnd x)))\\<rbrakk>e \\<and>\n                      x =\n                      \\<lbrakk>quot_dbtm\n                                (subst_dbtm u (decode_Var v)\n                                  (DBInd (nat_of_ord (hsnd x))))\\<rbrakk>e\n 2. \\<lbrakk>is_Var v; x' = \\<lbrakk>quot_dbtm u\\<rbrakk>e; Ord v;\n     x = v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         v = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                         u = subst_dbtm u (decode_Var v) t\n 3. \\<lbrakk>is_Var v; x' = x; Ord x; x \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                         x =\n                         \\<lbrakk>quot_dbtm\n                                   (subst_dbtm u (decode_Var v) t)\\<rbrakk>e", "apply (rule_tac [2] x=\"DBVar (decode_Var v)\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_Var v; x' = x; is_Ind x; x \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> x =\n                      \\<lbrakk>quot_dbtm\n                                (DBInd\n                                  (nat_of_ord (hsnd x)))\\<rbrakk>e \\<and>\n                      x =\n                      \\<lbrakk>quot_dbtm\n                                (subst_dbtm u (decode_Var v)\n                                  (DBInd (nat_of_ord (hsnd x))))\\<rbrakk>e\n 2. \\<lbrakk>is_Var v; x' = \\<lbrakk>quot_dbtm u\\<rbrakk>e; Ord v;\n     x = v\\<rbrakk>\n    \\<Longrightarrow> v =\n                      \\<lbrakk>quot_dbtm\n                                (DBVar (decode_Var v))\\<rbrakk>e \\<and>\n                      u = subst_dbtm u (decode_Var v) (DBVar (decode_Var v))\n 3. \\<lbrakk>is_Var v; x' = x; Ord x; x \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                         x =\n                         \\<lbrakk>quot_dbtm\n                                   (subst_dbtm u (decode_Var v) t)\\<rbrakk>e", "apply (case_tac [3] \"is_Var x\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>is_Var v; x' = x; is_Ind x; x \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> x =\n                      \\<lbrakk>quot_dbtm\n                                (DBInd\n                                  (nat_of_ord (hsnd x)))\\<rbrakk>e \\<and>\n                      x =\n                      \\<lbrakk>quot_dbtm\n                                (subst_dbtm u (decode_Var v)\n                                  (DBInd (nat_of_ord (hsnd x))))\\<rbrakk>e\n 2. \\<lbrakk>is_Var v; x' = \\<lbrakk>quot_dbtm u\\<rbrakk>e; Ord v;\n     x = v\\<rbrakk>\n    \\<Longrightarrow> v =\n                      \\<lbrakk>quot_dbtm\n                                (DBVar (decode_Var v))\\<rbrakk>e \\<and>\n                      u = subst_dbtm u (decode_Var v) (DBVar (decode_Var v))\n 3. \\<lbrakk>is_Var v; x' = x; Ord x; x \\<noteq> v; is_Var x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                         x =\n                         \\<lbrakk>quot_dbtm\n                                   (subst_dbtm u (decode_Var v) t)\\<rbrakk>e\n 4. \\<lbrakk>is_Var v; x' = x; Ord x; x \\<noteq> v; \\<not> is_Var x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                         x =\n                         \\<lbrakk>quot_dbtm\n                                   (subst_dbtm u (decode_Var v) t)\\<rbrakk>e", "apply (rule_tac [3] x=\"DBVar (decode_Var x)\" in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>is_Var v; x' = x; is_Ind x; x \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> x =\n                      \\<lbrakk>quot_dbtm\n                                (DBInd\n                                  (nat_of_ord (hsnd x)))\\<rbrakk>e \\<and>\n                      x =\n                      \\<lbrakk>quot_dbtm\n                                (subst_dbtm u (decode_Var v)\n                                  (DBInd (nat_of_ord (hsnd x))))\\<rbrakk>e\n 2. \\<lbrakk>is_Var v; x' = \\<lbrakk>quot_dbtm u\\<rbrakk>e; Ord v;\n     x = v\\<rbrakk>\n    \\<Longrightarrow> v =\n                      \\<lbrakk>quot_dbtm\n                                (DBVar (decode_Var v))\\<rbrakk>e \\<and>\n                      u = subst_dbtm u (decode_Var v) (DBVar (decode_Var v))\n 3. \\<lbrakk>is_Var v; x' = x; Ord x; x \\<noteq> v; is_Var x\\<rbrakk>\n    \\<Longrightarrow> x =\n                      \\<lbrakk>quot_dbtm\n                                (DBVar (decode_Var x))\\<rbrakk>e \\<and>\n                      x =\n                      \\<lbrakk>quot_dbtm\n                                (subst_dbtm u (decode_Var v)\n                                  (DBVar (decode_Var x)))\\<rbrakk>e\n 4. \\<lbrakk>is_Var v; x' = x; Ord x; x \\<noteq> v; \\<not> is_Var x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                         x =\n                         \\<lbrakk>quot_dbtm\n                                   (subst_dbtm u (decode_Var v) t)\\<rbrakk>e", "apply (rule_tac [4] x=DBZero in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>is_Var v; x' = x; is_Ind x; x \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> x =\n                      \\<lbrakk>quot_dbtm\n                                (DBInd\n                                  (nat_of_ord (hsnd x)))\\<rbrakk>e \\<and>\n                      x =\n                      \\<lbrakk>quot_dbtm\n                                (subst_dbtm u (decode_Var v)\n                                  (DBInd (nat_of_ord (hsnd x))))\\<rbrakk>e\n 2. \\<lbrakk>is_Var v; x' = \\<lbrakk>quot_dbtm u\\<rbrakk>e; Ord v;\n     x = v\\<rbrakk>\n    \\<Longrightarrow> v =\n                      \\<lbrakk>quot_dbtm\n                                (DBVar (decode_Var v))\\<rbrakk>e \\<and>\n                      u = subst_dbtm u (decode_Var v) (DBVar (decode_Var v))\n 3. \\<lbrakk>is_Var v; x' = x; Ord x; x \\<noteq> v; is_Var x\\<rbrakk>\n    \\<Longrightarrow> x =\n                      \\<lbrakk>quot_dbtm\n                                (DBVar (decode_Var x))\\<rbrakk>e \\<and>\n                      x =\n                      \\<lbrakk>quot_dbtm\n                                (subst_dbtm u (decode_Var v)\n                                  (DBVar (decode_Var x)))\\<rbrakk>e\n 4. \\<lbrakk>is_Var v; x' = x; Ord x; x \\<noteq> v; \\<not> is_Var x\\<rbrakk>\n    \\<Longrightarrow> x = \\<lbrakk>quot_dbtm DBZero\\<rbrakk>e \\<and>\n                      x =\n                      \\<lbrakk>quot_dbtm\n                                (subst_dbtm u (decode_Var v)\n                                  DBZero)\\<rbrakk>e", "apply (auto simp: is_Ind_def q_Ind_def is_Var_iff [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_Var v; x' = x; Ord x; x \\<noteq> v; \\<not> is_Var x\\<rbrakk>\n    \\<Longrightarrow> x = 0", "apply (metis hmem_0_Ord is_Var_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>t.\n     x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n     x' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>x x' y y' z z'.\n       \\<lbrakk>x = q_Eats y z \\<and> x' = q_Eats y' z';\n        \\<exists>t.\n           y = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n           y' =\n           \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e;\n        \\<exists>t.\n           z = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n           z' =\n           \\<lbrakk>quot_dbtm\n                     (subst_dbtm u (decode_Var v) t)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                            x' =\n                            \\<lbrakk>quot_dbtm\n(subst_dbtm u (decode_Var v) t)\\<rbrakk>e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x' y y' z z'.\n       \\<lbrakk>x = q_Eats y z \\<and> x' = q_Eats y' z';\n        \\<exists>t.\n           y = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n           y' =\n           \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e;\n        \\<exists>t.\n           z = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n           z' =\n           \\<lbrakk>quot_dbtm\n                     (subst_dbtm u (decode_Var v) t)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                            x' =\n                            \\<lbrakk>quot_dbtm\n(subst_dbtm u (decode_Var v) t)\\<rbrakk>e", "case (C x x' y y' z z')"], ["proof (state)\nthis:\n  x = q_Eats y z \\<and> x' = q_Eats y' z'\n  \\<exists>t.\n     y = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n     y' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e\n  \\<exists>t.\n     z = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n     z' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>x x' y y' z z'.\n       \\<lbrakk>x = q_Eats y z \\<and> x' = q_Eats y' z';\n        \\<exists>t.\n           y = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n           y' =\n           \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e;\n        \\<exists>t.\n           z = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n           z' =\n           \\<lbrakk>quot_dbtm\n                     (subst_dbtm u (decode_Var v) t)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                            x' =\n                            \\<lbrakk>quot_dbtm\n(subst_dbtm u (decode_Var v) t)\\<rbrakk>e", "then"], ["proof (chain)\npicking this:\n  x = q_Eats y z \\<and> x' = q_Eats y' z'\n  \\<exists>t.\n     y = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n     y' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e\n  \\<exists>t.\n     z = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n     z' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e", "obtain tm1 and tm2\n      where \"y = \\<lbrakk>quot_dbtm tm1\\<rbrakk>e\"\n              \"y' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) tm1)\\<rbrakk>e\"\n            \"z = \\<lbrakk>quot_dbtm tm2\\<rbrakk>e\"\n              \"z' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) tm2)\\<rbrakk>e\""], ["proof (prove)\nusing this:\n  x = q_Eats y z \\<and> x' = q_Eats y' z'\n  \\<exists>t.\n     y = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n     y' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e\n  \\<exists>t.\n     z = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n     z' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. (\\<And>tm1 tm2.\n        \\<lbrakk>y = \\<lbrakk>quot_dbtm tm1\\<rbrakk>e;\n         y' =\n         \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) tm1)\\<rbrakk>e;\n         z = \\<lbrakk>quot_dbtm tm2\\<rbrakk>e;\n         z' =\n         \\<lbrakk>quot_dbtm\n                   (subst_dbtm u (decode_Var v) tm2)\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y = \\<lbrakk>quot_dbtm tm1\\<rbrakk>e\n  y' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) tm1)\\<rbrakk>e\n  z = \\<lbrakk>quot_dbtm tm2\\<rbrakk>e\n  z' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) tm2)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>x x' y y' z z'.\n       \\<lbrakk>x = q_Eats y z \\<and> x' = q_Eats y' z';\n        \\<exists>t.\n           y = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n           y' =\n           \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e;\n        \\<exists>t.\n           z = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n           z' =\n           \\<lbrakk>quot_dbtm\n                     (subst_dbtm u (decode_Var v) t)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n                            x' =\n                            \\<lbrakk>quot_dbtm\n(subst_dbtm u (decode_Var v) t)\\<rbrakk>e", "thus ?case"], ["proof (prove)\nusing this:\n  y = \\<lbrakk>quot_dbtm tm1\\<rbrakk>e\n  y' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) tm1)\\<rbrakk>e\n  z = \\<lbrakk>quot_dbtm tm2\\<rbrakk>e\n  z' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) tm2)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n       x' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e", "by (auto simp: wf_dbtm.intros C q_Eats_def intro!: exI [where x=\"DBEats tm1 tm2\"])"], ["proof (state)\nthis:\n  \\<exists>t.\n     x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n     x' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>t.\n     x = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<and>\n     x' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary SubstTerm_imp_subst_dbtm':\n  assumes \"SubstTerm v y x x'\"\n  obtains t::dbtm and u::dbtm\n  where \"y = \\<lbrakk>quot_dbtm u\\<rbrakk>e\"\n        \"x = \\<lbrakk>quot_dbtm t\\<rbrakk>e\"\n        \"x' = \\<lbrakk>quot_dbtm (subst_dbtm u (decode_Var v) t)\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u t.\n        \\<lbrakk>y = \\<lbrakk>quot_dbtm u\\<rbrakk>e;\n         x = \\<lbrakk>quot_dbtm t\\<rbrakk>e;\n         x' =\n         \\<lbrakk>quot_dbtm\n                   (subst_dbtm u (decode_Var v) t)\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis SubstTerm_def SubstTerm_imp_subst_dbtm Term_imp_is_tm assms quot_tm_def)"], ["", "lemma SubstTerm_subst_dbtm:\n  assumes \"Term \\<lbrakk>quot_dbtm u\\<rbrakk>e\"\n    shows \"SubstTerm (q_Var v) \\<lbrakk>quot_dbtm u\\<rbrakk>e \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<lbrakk>quot_dbtm (subst_dbtm u v t)\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SubstTerm (q_Var v) \\<lbrakk>quot_dbtm u\\<rbrakk>e\n     \\<lbrakk>quot_dbtm t\\<rbrakk>e\n     \\<lbrakk>quot_dbtm (subst_dbtm u v t)\\<rbrakk>e", "by (induct t rule: dbtm.induct) \n     (auto simp: assms SubstTerm_def SeqStTerm_def q_defs intro: BuildSeq2_exI BuildSeq2_combine)"], ["", "section \\<open>Abstraction over formulas\\<close>"], ["", "subsection \\<open>The predicate \\<open>AbstAtomicP\\<close>\\<close>"], ["", "definition AbstAtomic :: \"hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> bool\"\n  where \"AbstAtomic v i y y' \\<equiv> \n            (\\<exists>t u t' u'. AbstTerm v i t t' \\<and> AbstTerm v i u u' \\<and>\n             ((y = q_Eq t u \\<and> y' = q_Eq t' u') \\<or> (y = q_Mem t u \\<and> y' = q_Mem t' u')))\""], ["", "nominal_function AbstAtomicP :: \"tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> fm\"\n  where \"\\<lbrakk>atom t \\<sharp> (v,i,y,y',t',u,u'); atom t' \\<sharp> (v,i,y,y',u,u');\n          atom u \\<sharp> (v,i,y,y',u'); atom u' \\<sharp> (v,i,y,y')\\<rbrakk> \\<Longrightarrow>\n    AbstAtomicP v i y y' =\n         Ex t (Ex u (Ex t' (Ex u'\n           (AbstTermP v i (Var t) (Var t') AND AbstTermP v i (Var u) (Var u') AND\n                      ((y EQ Q_Eq (Var t) (Var u) AND y' EQ Q_Eq (Var t') (Var u')) OR\n                       (y EQ Q_Mem (Var t) (Var u) AND y' EQ Q_Mem (Var t') (Var u')))))))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt AbstAtomicP_graph_aux\n 2. \\<And>x y. AbstAtomicP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>t v i y y' t' u u'.\n           \\<lbrakk>atom t \\<sharp> (v, i, y, y', t', u, u');\n            atom t' \\<sharp> (v, i, y, y', u, u');\n            atom u \\<sharp> (v, i, y, y', u');\n            atom u' \\<sharp> (v, i, y, y'); x = (v, i, y, y')\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>t v i y y' t' u u' ta va ia ya y'a t'a ua u'a.\n       \\<lbrakk>atom t \\<sharp> (v, i, y, y', t', u, u');\n        atom t' \\<sharp> (v, i, y, y', u, u');\n        atom u \\<sharp> (v, i, y, y', u'); atom u' \\<sharp> (v, i, y, y');\n        atom ta \\<sharp> (va, ia, ya, y'a, t'a, ua, u'a);\n        atom t'a \\<sharp> (va, ia, ya, y'a, ua, u'a);\n        atom ua \\<sharp> (va, ia, ya, y'a, u'a);\n        atom u'a \\<sharp> (va, ia, ya, y'a);\n        (v, i, y, y') = (va, ia, ya, y'a)\\<rbrakk>\n       \\<Longrightarrow> SyntaxN.Ex t\n                          (SyntaxN.Ex u\n                            (SyntaxN.Ex t'\n                              (SyntaxN.Ex u'\n                                (AbstTermP v i (Var t) (Var t') AND\n                                 AbstTermP v i (Var u) (Var u') AND\n                                 (y EQ Q_Eq (Var t) (Var u) AND\n                                  y' EQ Q_Eq (Var t') (Var u') OR\n                                  y EQ Q_Mem (Var t) (Var u) AND\n                                  y' EQ Q_Mem (Var t') (Var u')))))) =\n                         SyntaxN.Ex ta\n                          (SyntaxN.Ex ua\n                            (SyntaxN.Ex t'a\n                              (SyntaxN.Ex u'a\n                                (AbstTermP va ia (Var ta) (Var t'a) AND\n                                 AbstTermP va ia (Var ua) (Var u'a) AND\n                                 (ya EQ Q_Eq (Var ta) (Var ua) AND\n                                  y'a EQ Q_Eq (Var t'a) (Var u'a) OR\n                                  ya EQ Q_Mem (Var ta) (Var ua) AND\n                                  y'a EQ Q_Mem (Var t'a) (Var u'a))))))", "by (auto simp: eqvt_def AbstAtomicP_graph_aux_def flip_fresh_fresh) (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All AbstAtomicP_dom", "by lexicographic_order"], ["", "lemma\n  shows AbstAtomicP_fresh_iff [simp]:\n       \"a \\<sharp> AbstAtomicP v i y y' \\<longleftrightarrow> a \\<sharp> v \\<and> a \\<sharp> i \\<and> a \\<sharp> y \\<and> a \\<sharp> y'\"         (is ?thesis1)\n    and eval_fm_AbstAtomicP [simp]:\n       \"eval_fm e (AbstAtomicP v i y y') \\<longleftrightarrow> AbstAtomic \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>y\\<rbrakk>e \\<lbrakk>y'\\<rbrakk>e\"  (is ?thesis2)\n    and AbstAtomicP_sf [iff]: \"Sigma_fm (AbstAtomicP v i y y')\"              (is ?thsf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> AbstAtomicP v i y y' =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> i \\<and> a \\<sharp> y \\<and> a \\<sharp> y') &&&\n    eval_fm e (AbstAtomicP v i y y') =\n    AbstAtomic \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e\n     \\<lbrakk>y\\<rbrakk>e \\<lbrakk>y'\\<rbrakk>e &&&\n    Sigma_fm (AbstAtomicP v i y y')", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. a \\<sharp> AbstAtomicP v i y y' =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> i \\<and> a \\<sharp> y \\<and> a \\<sharp> y')\n 2. eval_fm e (AbstAtomicP v i y y') =\n    AbstAtomic \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e\n     \\<lbrakk>y\\<rbrakk>e \\<lbrakk>y'\\<rbrakk>e\n 3. Sigma_fm (AbstAtomicP v i y y')", "obtain t::name and u::name and t'::name  and u'::name\n    where \"atom t \\<sharp> (v,i,y,y',t',u,u')\" \"atom t' \\<sharp> (v,i,y,y',u,u')\"\n          \"atom u \\<sharp> (v,i,y,y',u')\" \"atom u' \\<sharp> (v,i,y,y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t t' u u'.\n        \\<lbrakk>atom t \\<sharp> (v, i, y, y', t', u, u');\n         atom t' \\<sharp> (v, i, y, y', u, u');\n         atom u \\<sharp> (v, i, y, y', u');\n         atom u' \\<sharp> (v, i, y, y')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom t \\<sharp> (v, i, y, y', t', u, u')\n  atom t' \\<sharp> (v, i, y, y', u, u')\n  atom u \\<sharp> (v, i, y, y', u')\n  atom u' \\<sharp> (v, i, y, y')\n\ngoal (3 subgoals):\n 1. a \\<sharp> AbstAtomicP v i y y' =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> i \\<and> a \\<sharp> y \\<and> a \\<sharp> y')\n 2. eval_fm e (AbstAtomicP v i y y') =\n    AbstAtomic \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e\n     \\<lbrakk>y\\<rbrakk>e \\<lbrakk>y'\\<rbrakk>e\n 3. Sigma_fm (AbstAtomicP v i y y')", "thus ?thesis1 ?thesis2 ?thsf"], ["proof (prove)\nusing this:\n  atom t \\<sharp> (v, i, y, y', t', u, u')\n  atom t' \\<sharp> (v, i, y, y', u, u')\n  atom u \\<sharp> (v, i, y, y', u')\n  atom u' \\<sharp> (v, i, y, y')\n\ngoal (1 subgoal):\n 1. a \\<sharp> AbstAtomicP v i y y' =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> i \\<and> a \\<sharp> y \\<and> a \\<sharp> y') &&&\n    eval_fm e (AbstAtomicP v i y y') =\n    AbstAtomic \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e\n     \\<lbrakk>y\\<rbrakk>e \\<lbrakk>y'\\<rbrakk>e &&&\n    Sigma_fm (AbstAtomicP v i y y')", "by (auto simp: AbstAtomic_def q_defs)"], ["proof (state)\nthis:\n  a \\<sharp> AbstAtomicP v i y y' =\n  (a \\<sharp> v \\<and>\n   a \\<sharp> i \\<and> a \\<sharp> y \\<and> a \\<sharp> y')\n  eval_fm e (AbstAtomicP v i y y') =\n  AbstAtomic \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>y\\<rbrakk>e\n   \\<lbrakk>y'\\<rbrakk>e\n  Sigma_fm (AbstAtomicP v i y y')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma AbstAtomicP_subst [simp]:\n      \"(AbstAtomicP v tm y y')(i::=w) = AbstAtomicP (subst i w v) (subst i w tm) (subst i w y) (subst i w y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (AbstAtomicP v tm y y')(i::=w) =\n    AbstAtomicP (subst i w v) (subst i w tm) (subst i w y) (subst i w y')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (AbstAtomicP v tm y y')(i::=w) =\n    AbstAtomicP (subst i w v) (subst i w tm) (subst i w y) (subst i w y')", "obtain t::name and u::name and t'::name  and u'::name\n    where \"atom t \\<sharp> (v,tm,y,y',w,i,t',u,u')\"  \"atom t' \\<sharp> (v,tm,y,y',w,i,u,u')\"\n          \"atom u \\<sharp> (v,tm,y,y',w,i,u')\"       \"atom u' \\<sharp> (v,tm,y,y',w,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t t' u u'.\n        \\<lbrakk>atom t \\<sharp> (v, tm, y, y', w, i, t', u, u');\n         atom t' \\<sharp> (v, tm, y, y', w, i, u, u');\n         atom u \\<sharp> (v, tm, y, y', w, i, u');\n         atom u' \\<sharp> (v, tm, y, y', w, i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom t \\<sharp> (v, tm, y, y', w, i, t', u, u')\n  atom t' \\<sharp> (v, tm, y, y', w, i, u, u')\n  atom u \\<sharp> (v, tm, y, y', w, i, u')\n  atom u' \\<sharp> (v, tm, y, y', w, i)\n\ngoal (1 subgoal):\n 1. (AbstAtomicP v tm y y')(i::=w) =\n    AbstAtomicP (subst i w v) (subst i w tm) (subst i w y) (subst i w y')", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom t \\<sharp> (v, tm, y, y', w, i, t', u, u')\n  atom t' \\<sharp> (v, tm, y, y', w, i, u, u')\n  atom u \\<sharp> (v, tm, y, y', w, i, u')\n  atom u' \\<sharp> (v, tm, y, y', w, i)\n\ngoal (1 subgoal):\n 1. (AbstAtomicP v tm y y')(i::=w) =\n    AbstAtomicP (subst i w v) (subst i w tm) (subst i w y) (subst i w y')", "by (simp add: AbstAtomicP.simps [of t _ _ _ _ t' u u'])"], ["proof (state)\nthis:\n  (AbstAtomicP v tm y y')(i::=w) =\n  AbstAtomicP (subst i w v) (subst i w tm) (subst i w y) (subst i w y')\n\ngoal:\nNo subgoals!", "qed"], ["", "declare AbstAtomicP.simps [simp del]"], ["", "subsection \\<open>The predicate \\<open>AbsMakeForm\\<close>\\<close>"], ["", "definition AbstMakeForm :: \"hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> bool\"\nwhere \"AbstMakeForm k y y' i u u' j w w' \\<equiv>\n      Ord k \\<and>\n      ((k = i \\<and> k = j \\<and> y = q_Disj u w \\<and> y' = q_Disj u' w') \\<or>\n       (k = i \\<and> y = q_Neg u \\<and> y' = q_Neg u') \\<or>\n       (succ k = i \\<and> y = q_Ex u \\<and> y' = q_Ex u'))\""], ["", "definition SeqAbstForm :: \"hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> bool\"\nwhere \"SeqAbstForm v i x x' s k \\<equiv>\n       BuildSeq3 (AbstAtomic v) AbstMakeForm s k i x x'\""], ["", "nominal_function SeqAbstFormP :: \"tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> fm\"\n  where \"\\<lbrakk>atom l \\<sharp> (s,k,v,sli,sl,sl',m,n,smi,sm,sm',sni,sn,sn');\n          atom sli \\<sharp> (s,v,sl,sl',m,n,smi,sm,sm',sni,sn,sn');\n          atom sl \\<sharp> (s,v,sl',m,n,smi,sm,sm',sni,sn,sn');\n          atom sl' \\<sharp> (s,v,m,n,smi,sm,sm',sni,sn,sn');\n          atom m \\<sharp> (s,n,smi,sm,sm',sni,sn,sn');\n          atom n \\<sharp> (s,smi,sm,sm',sni,sn,sn'); atom smi \\<sharp> (s,sm,sm',sni,sn,sn');\n          atom sm \\<sharp> (s,sm',sni,sn,sn'); atom sm' \\<sharp> (s,sni,sn,sn');\n          atom sni \\<sharp> (s,sn,sn'); atom sn \\<sharp> (s,sn'); atom sn' \\<sharp> (s)\\<rbrakk> \\<Longrightarrow>\n    SeqAbstFormP v i x x' s k =\n      LstSeqP s k (HPair i (HPair x x')) AND\n      All2 l (SUCC k) (Ex sli (Ex sl (Ex sl' (HPair (Var l) (HPair (Var sli) (HPair (Var sl) (Var sl'))) IN s AND\n                (AbstAtomicP v (Var sli) (Var sl) (Var sl') OR\n                OrdP (Var sli) AND\n                Ex m (Ex n (Ex smi (Ex sm (Ex sm' (Ex sni (Ex sn (Ex sn'\n                      (Var m IN Var l AND Var n IN Var l AND\n                       HPair (Var m) (HPair (Var smi) (HPair (Var sm) (Var sm'))) IN s AND\n                       HPair (Var n) (HPair (Var sni) (HPair (Var sn) (Var sn'))) IN s AND\n                       ((Var sli EQ Var smi AND Var sli EQ Var sni AND\n                         Var sl EQ Q_Disj (Var sm) (Var sn) AND\n                         Var sl' EQ Q_Disj (Var sm') (Var sn')) OR\n                        (Var sli EQ Var smi AND\n                         Var sl EQ Q_Neg (Var sm) AND Var sl' EQ Q_Neg (Var sm')) OR\n                        (SUCC (Var sli) EQ Var smi AND\n                         Var sl EQ Q_Ex (Var sm) AND Var sl' EQ Q_Ex (Var sm'))))))))))))))))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt SeqAbstFormP_graph_aux\n 2. \\<And>x y. SeqAbstFormP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>l s k v sli sl sl' m n smi sm sm' sni sn sn' i xa x'.\n           \\<lbrakk>atom\n                     l \\<sharp> (s, k, v, sli, sl, sl', m, n, smi, sm, sm',\n                                 sni, sn, sn');\n            atom\n             sli \\<sharp> (s, v, sl, sl', m, n, smi, sm, sm', sni, sn, sn');\n            atom sl \\<sharp> (s, v, sl', m, n, smi, sm, sm', sni, sn, sn');\n            atom sl' \\<sharp> (s, v, m, n, smi, sm, sm', sni, sn, sn');\n            atom m \\<sharp> (s, n, smi, sm, sm', sni, sn, sn');\n            atom n \\<sharp> (s, smi, sm, sm', sni, sn, sn');\n            atom smi \\<sharp> (s, sm, sm', sni, sn, sn');\n            atom sm \\<sharp> (s, sm', sni, sn, sn');\n            atom sm' \\<sharp> (s, sni, sn, sn');\n            atom sni \\<sharp> (s, sn, sn'); atom sn \\<sharp> (s, sn');\n            atom sn' \\<sharp> s; x = (v, i, xa, x', s, k)\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>l s k v sli sl sl' m n smi sm sm' sni sn sn' i x x' la sa ka va\n       slia sla sl'a ma na smia sma sm'a snia sna sn'a ia xa x'a.\n       \\<lbrakk>atom\n                 l \\<sharp> (s, k, v, sli, sl, sl', m, n, smi, sm, sm', sni,\n                             sn, sn');\n        atom sli \\<sharp> (s, v, sl, sl', m, n, smi, sm, sm', sni, sn, sn');\n        atom sl \\<sharp> (s, v, sl', m, n, smi, sm, sm', sni, sn, sn');\n        atom sl' \\<sharp> (s, v, m, n, smi, sm, sm', sni, sn, sn');\n        atom m \\<sharp> (s, n, smi, sm, sm', sni, sn, sn');\n        atom n \\<sharp> (s, smi, sm, sm', sni, sn, sn');\n        atom smi \\<sharp> (s, sm, sm', sni, sn, sn');\n        atom sm \\<sharp> (s, sm', sni, sn, sn');\n        atom sm' \\<sharp> (s, sni, sn, sn'); atom sni \\<sharp> (s, sn, sn');\n        atom sn \\<sharp> (s, sn'); atom sn' \\<sharp> s;\n        atom\n         la \\<sharp> (sa, ka, va, slia, sla, sl'a, ma, na, smia, sma, sm'a,\n                      snia, sna, sn'a);\n        atom\n         slia \\<sharp> (sa, va, sla, sl'a, ma, na, smia, sma, sm'a, snia,\n                        sna, sn'a);\n        atom\n         sla \\<sharp> (sa, va, sl'a, ma, na, smia, sma, sm'a, snia, sna,\n                       sn'a);\n        atom\n         sl'a \\<sharp> (sa, va, ma, na, smia, sma, sm'a, snia, sna, sn'a);\n        atom ma \\<sharp> (sa, na, smia, sma, sm'a, snia, sna, sn'a);\n        atom na \\<sharp> (sa, smia, sma, sm'a, snia, sna, sn'a);\n        atom smia \\<sharp> (sa, sma, sm'a, snia, sna, sn'a);\n        atom sma \\<sharp> (sa, sm'a, snia, sna, sn'a);\n        atom sm'a \\<sharp> (sa, snia, sna, sn'a);\n        atom snia \\<sharp> (sa, sna, sn'a); atom sna \\<sharp> (sa, sn'a);\n        atom sn'a \\<sharp> sa;\n        (v, i, x, x', s, k) = (va, ia, xa, x'a, sa, ka)\\<rbrakk>\n       \\<Longrightarrow> LstSeqP s k (HPair i (HPair x x')) AND\n                         All2 l (SUCC k)\n                          (SyntaxN.Ex sli\n                            (SyntaxN.Ex sl\n                              (SyntaxN.Ex sl'\n                                (HPair (Var l)\n                                  (HPair (Var sli)\n                                    (HPair (Var sl) (Var sl'))) IN\n                                 s AND\n                                 (AbstAtomicP v (Var sli) (Var sl)\n                                   (Var sl') OR\n                                  OrdP (Var sli) AND\n                                  SyntaxN.Ex m\n                                   (SyntaxN.Ex n\n                                     (SyntaxN.Ex smi\n (SyntaxN.Ex sm\n   (SyntaxN.Ex sm'\n     (SyntaxN.Ex sni\n       (SyntaxN.Ex sn\n         (SyntaxN.Ex sn'\n           (Var m IN Var l AND\n            Var n IN Var l AND\n            HPair (Var m) (HPair (Var smi) (HPair (Var sm) (Var sm'))) IN\n            s AND\n            HPair (Var n) (HPair (Var sni) (HPair (Var sn) (Var sn'))) IN\n            s AND\n            (Var sli EQ Var smi AND\n             Var sli EQ Var sni AND\n             Var sl EQ Q_Disj (Var sm) (Var sn) AND\n             Var sl' EQ Q_Disj (Var sm') (Var sn') OR\n             Var sli EQ Var smi AND\n             Var sl EQ Q_Neg (Var sm) AND Var sl' EQ Q_Neg (Var sm') OR\n             SUCC (Var sli) EQ Var smi AND\n             Var sl EQ Q_Ex (Var sm) AND\n             Var sl' EQ Q_Ex (Var sm'))))))))))))))) =\n                         LstSeqP sa ka (HPair ia (HPair xa x'a)) AND\n                         All2 la (SUCC ka)\n                          (SyntaxN.Ex slia\n                            (SyntaxN.Ex sla\n                              (SyntaxN.Ex sl'a\n                                (HPair (Var la)\n                                  (HPair (Var slia)\n                                    (HPair (Var sla) (Var sl'a))) IN\n                                 sa AND\n                                 (AbstAtomicP va (Var slia) (Var sla)\n                                   (Var sl'a) OR\n                                  OrdP (Var slia) AND\n                                  SyntaxN.Ex ma\n                                   (SyntaxN.Ex na\n                                     (SyntaxN.Ex smia\n (SyntaxN.Ex sma\n   (SyntaxN.Ex sm'a\n     (SyntaxN.Ex snia\n       (SyntaxN.Ex sna\n         (SyntaxN.Ex sn'a\n           (Var ma IN Var la AND\n            Var na IN Var la AND\n            HPair (Var ma)\n             (HPair (Var smia) (HPair (Var sma) (Var sm'a))) IN\n            sa AND\n            HPair (Var na)\n             (HPair (Var snia) (HPair (Var sna) (Var sn'a))) IN\n            sa AND\n            (Var slia EQ Var smia AND\n             Var slia EQ Var snia AND\n             Var sla EQ Q_Disj (Var sma) (Var sna) AND\n             Var sl'a EQ Q_Disj (Var sm'a) (Var sn'a) OR\n             Var slia EQ Var smia AND\n             Var sla EQ Q_Neg (Var sma) AND Var sl'a EQ Q_Neg (Var sm'a) OR\n             SUCC (Var slia) EQ Var smia AND\n             Var sla EQ Q_Ex (Var sma) AND\n             Var sl'a EQ Q_Ex (Var sm'a)))))))))))))))", "by (auto simp: eqvt_def SeqAbstFormP_graph_aux_def flip_fresh_fresh) (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All SeqAbstFormP_dom", "by lexicographic_order"], ["", "lemma\n  shows SeqAbstFormP_fresh_iff [simp]:\n       \"a \\<sharp> SeqAbstFormP v i x x' s k \\<longleftrightarrow> a \\<sharp> v \\<and> a \\<sharp> i \\<and> a \\<sharp> x \\<and> a \\<sharp> x' \\<and> a \\<sharp> s \\<and> a \\<sharp> k\"  (is ?thesis1)\n    and eval_fm_SeqAbstFormP [simp]:\n       \"eval_fm e (SeqAbstFormP v i x x' s k) \\<longleftrightarrow> SeqAbstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>x\\<rbrakk>e \\<lbrakk>x'\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e\" (is ?thesis2)\n    and SeqAbstFormP_sf [iff]:\n       \"Sigma_fm (SeqAbstFormP v i x x' s k)\"  (is ?thsf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> SeqAbstFormP v i x x' s k =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> i \\<and>\n     a \\<sharp> x \\<and>\n     a \\<sharp> x' \\<and> a \\<sharp> s \\<and> a \\<sharp> k) &&&\n    eval_fm e (SeqAbstFormP v i x x' s k) =\n    SeqAbstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e\n     \\<lbrakk>x\\<rbrakk>e \\<lbrakk>x'\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e\n     \\<lbrakk>k\\<rbrakk>e &&&\n    Sigma_fm (SeqAbstFormP v i x x' s k)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. a \\<sharp> SeqAbstFormP v i x x' s k =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> i \\<and>\n     a \\<sharp> x \\<and>\n     a \\<sharp> x' \\<and> a \\<sharp> s \\<and> a \\<sharp> k)\n 2. eval_fm e (SeqAbstFormP v i x x' s k) =\n    SeqAbstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e\n     \\<lbrakk>x\\<rbrakk>e \\<lbrakk>x'\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e\n     \\<lbrakk>k\\<rbrakk>e\n 3. Sigma_fm (SeqAbstFormP v i x x' s k)", "obtain l::name and sli::name and sl::name and sl'::name and m::name and n::name and\n         smi::name and sm::name and sm'::name and sni::name and sn::name and sn'::name\n    where atoms:\n         \"atom l \\<sharp> (s,k,v,sli,sl,sl',m,n,smi,sm,sm',sni,sn,sn')\"\n         \"atom sli \\<sharp> (s,v,sl,sl',m,n,smi,sm,sm',sni,sn,sn')\"\n         \"atom sl \\<sharp> (s,v,sl',m,n,smi,sm,sm',sni,sn,sn')\"\n         \"atom sl' \\<sharp> (s,v,m,n,smi,sm,sm',sni,sn,sn')\"\n         \"atom m \\<sharp> (s,n,smi,sm,sm',sni,sn,sn')\" \"atom n \\<sharp> (s,smi,sm,sm',sni,sn,sn')\"\n         \"atom smi \\<sharp> (s,sm,sm',sni,sn,sn')\"\n         \"atom sm \\<sharp> (s,sm',sni,sn,sn')\"\n         \"atom sm' \\<sharp> (s,sni,sn,sn')\"\n         \"atom sni \\<sharp> (s,sn,sn')\" \"atom sn \\<sharp> (s,sn')\" \"atom sn' \\<sharp> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l sli sl sl' m n smi sm sm' sni sn sn'.\n        \\<lbrakk>atom\n                  l \\<sharp> (s, k, v, sli, sl, sl', m, n, smi, sm, sm',\n                              sni, sn, sn');\n         atom\n          sli \\<sharp> (s, v, sl, sl', m, n, smi, sm, sm', sni, sn, sn');\n         atom sl \\<sharp> (s, v, sl', m, n, smi, sm, sm', sni, sn, sn');\n         atom sl' \\<sharp> (s, v, m, n, smi, sm, sm', sni, sn, sn');\n         atom m \\<sharp> (s, n, smi, sm, sm', sni, sn, sn');\n         atom n \\<sharp> (s, smi, sm, sm', sni, sn, sn');\n         atom smi \\<sharp> (s, sm, sm', sni, sn, sn');\n         atom sm \\<sharp> (s, sm', sni, sn, sn');\n         atom sm' \\<sharp> (s, sni, sn, sn');\n         atom sni \\<sharp> (s, sn, sn'); atom sn \\<sharp> (s, sn');\n         atom sn' \\<sharp> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom l \\<sharp> (s, k, v, sli, sl, sl', m, n, smi, sm, sm', sni, sn, sn')\n  atom sli \\<sharp> (s, v, sl, sl', m, n, smi, sm, sm', sni, sn, sn')\n  atom sl \\<sharp> (s, v, sl', m, n, smi, sm, sm', sni, sn, sn')\n  atom sl' \\<sharp> (s, v, m, n, smi, sm, sm', sni, sn, sn')\n  atom m \\<sharp> (s, n, smi, sm, sm', sni, sn, sn')\n  atom n \\<sharp> (s, smi, sm, sm', sni, sn, sn')\n  atom smi \\<sharp> (s, sm, sm', sni, sn, sn')\n  atom sm \\<sharp> (s, sm', sni, sn, sn')\n  atom sm' \\<sharp> (s, sni, sn, sn')\n  atom sni \\<sharp> (s, sn, sn')\n  atom sn \\<sharp> (s, sn')\n  atom sn' \\<sharp> s\n\ngoal (3 subgoals):\n 1. a \\<sharp> SeqAbstFormP v i x x' s k =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> i \\<and>\n     a \\<sharp> x \\<and>\n     a \\<sharp> x' \\<and> a \\<sharp> s \\<and> a \\<sharp> k)\n 2. eval_fm e (SeqAbstFormP v i x x' s k) =\n    SeqAbstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e\n     \\<lbrakk>x\\<rbrakk>e \\<lbrakk>x'\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e\n     \\<lbrakk>k\\<rbrakk>e\n 3. Sigma_fm (SeqAbstFormP v i x x' s k)", "thus ?thesis1 ?thsf"], ["proof (prove)\nusing this:\n  atom l \\<sharp> (s, k, v, sli, sl, sl', m, n, smi, sm, sm', sni, sn, sn')\n  atom sli \\<sharp> (s, v, sl, sl', m, n, smi, sm, sm', sni, sn, sn')\n  atom sl \\<sharp> (s, v, sl', m, n, smi, sm, sm', sni, sn, sn')\n  atom sl' \\<sharp> (s, v, m, n, smi, sm, sm', sni, sn, sn')\n  atom m \\<sharp> (s, n, smi, sm, sm', sni, sn, sn')\n  atom n \\<sharp> (s, smi, sm, sm', sni, sn, sn')\n  atom smi \\<sharp> (s, sm, sm', sni, sn, sn')\n  atom sm \\<sharp> (s, sm', sni, sn, sn')\n  atom sm' \\<sharp> (s, sni, sn, sn')\n  atom sni \\<sharp> (s, sn, sn')\n  atom sn \\<sharp> (s, sn')\n  atom sn' \\<sharp> s\n\ngoal (1 subgoal):\n 1. a \\<sharp> SeqAbstFormP v i x x' s k =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> i \\<and>\n     a \\<sharp> x \\<and>\n     a \\<sharp> x' \\<and> a \\<sharp> s \\<and> a \\<sharp> k) &&&\n    Sigma_fm (SeqAbstFormP v i x x' s k)", "by (auto intro: LstSeqP_OrdP)"], ["proof (state)\nthis:\n  a \\<sharp> SeqAbstFormP v i x x' s k =\n  (a \\<sharp> v \\<and>\n   a \\<sharp> i \\<and>\n   a \\<sharp> x \\<and>\n   a \\<sharp> x' \\<and> a \\<sharp> s \\<and> a \\<sharp> k)\n  Sigma_fm (SeqAbstFormP v i x x' s k)\n\ngoal (1 subgoal):\n 1. eval_fm e (SeqAbstFormP v i x x' s k) =\n    SeqAbstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e\n     \\<lbrakk>x\\<rbrakk>e \\<lbrakk>x'\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e\n     \\<lbrakk>k\\<rbrakk>e", "show ?thesis2"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_fm e (SeqAbstFormP v i x x' s k) =\n    SeqAbstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e\n     \\<lbrakk>x\\<rbrakk>e \\<lbrakk>x'\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e\n     \\<lbrakk>k\\<rbrakk>e", "using atoms"], ["proof (prove)\nusing this:\n  atom l \\<sharp> (s, k, v, sli, sl, sl', m, n, smi, sm, sm', sni, sn, sn')\n  atom sli \\<sharp> (s, v, sl, sl', m, n, smi, sm, sm', sni, sn, sn')\n  atom sl \\<sharp> (s, v, sl', m, n, smi, sm, sm', sni, sn, sn')\n  atom sl' \\<sharp> (s, v, m, n, smi, sm, sm', sni, sn, sn')\n  atom m \\<sharp> (s, n, smi, sm, sm', sni, sn, sn')\n  atom n \\<sharp> (s, smi, sm, sm', sni, sn, sn')\n  atom smi \\<sharp> (s, sm, sm', sni, sn, sn')\n  atom sm \\<sharp> (s, sm', sni, sn, sn')\n  atom sm' \\<sharp> (s, sni, sn, sn')\n  atom sni \\<sharp> (s, sn, sn')\n  atom sn \\<sharp> (s, sn')\n  atom sn' \\<sharp> s\n\ngoal (1 subgoal):\n 1. eval_fm e (SeqAbstFormP v i x x' s k) =\n    SeqAbstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e\n     \\<lbrakk>x\\<rbrakk>e \\<lbrakk>x'\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e\n     \\<lbrakk>k\\<rbrakk>e", "unfolding SeqAbstForm_def BuildSeq3_def BuildSeq_def Builds_def\n              HBall_def HBex_def q_defs AbstMakeForm_def"], ["proof (prove)\nusing this:\n  atom l \\<sharp> (s, k, v, sli, sl, sl', m, n, smi, sm, sm', sni, sn, sn')\n  atom sli \\<sharp> (s, v, sl, sl', m, n, smi, sm, sm', sni, sn, sn')\n  atom sl \\<sharp> (s, v, sl', m, n, smi, sm, sm', sni, sn, sn')\n  atom sl' \\<sharp> (s, v, m, n, smi, sm, sm', sni, sn, sn')\n  atom m \\<sharp> (s, n, smi, sm, sm', sni, sn, sn')\n  atom n \\<sharp> (s, smi, sm, sm', sni, sn, sn')\n  atom smi \\<sharp> (s, sm, sm', sni, sn, sn')\n  atom sm \\<sharp> (s, sm', sni, sn, sn')\n  atom sm' \\<sharp> (s, sni, sn, sn')\n  atom sni \\<sharp> (s, sn, sn')\n  atom sn \\<sharp> (s, sn')\n  atom sn' \\<sharp> s\n\ngoal (1 subgoal):\n 1. eval_fm e (SeqAbstFormP v i x x' s k) =\n    (LstSeq \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e\n      \\<langle>\\<lbrakk>i\\<rbrakk>e, \\<lbrakk>x\\<rbrakk>e,\n               \\<lbrakk>x'\\<rbrakk>e\\<rangle> \\<and>\n     (\\<forall>x.\n         x \\<^bold>\\<in> succ \\<lbrakk>k\\<rbrakk>e \\<longrightarrow>\n         (\\<exists>xa x' x''.\n             app \\<lbrakk>s\\<rbrakk>e x =\n             \\<langle>xa, x', x''\\<rangle> \\<and>\n             AbstAtomic \\<lbrakk>v\\<rbrakk>e xa x' x'') \\<or>\n         (\\<exists>xa.\n             xa \\<^bold>\\<in> x \\<and>\n             (\\<exists>xb.\n                 xb \\<^bold>\\<in> x \\<and>\n                 (\\<exists>xc x' x'' y y' y'' z z' z''.\n                     app \\<lbrakk>s\\<rbrakk>e x =\n                     \\<langle>xc, x', x''\\<rangle> \\<and>\n                     app \\<lbrakk>s\\<rbrakk>e xa =\n                     \\<langle>y, y', y''\\<rangle> \\<and>\n                     app \\<lbrakk>s\\<rbrakk>e xb =\n                     \\<langle>z, z', z''\\<rangle> \\<and>\n                     Ord xc \\<and>\n                     (xc = y \\<and>\n                      xc = z \\<and>\n                      x' = \\<langle>htuple 3, y', z'\\<rangle> \\<and>\n                      x'' = \\<langle>htuple 3, y'', z''\\<rangle> \\<or>\n                      xc = y \\<and>\n                      x' = \\<langle>htuple 4, y'\\<rangle> \\<and>\n                      x'' = \\<langle>htuple 4, y''\\<rangle> \\<or>\n                      succ xc = y \\<and>\n                      x' = \\<langle>htuple 5, y'\\<rangle> \\<and>\n                      x'' = \\<langle>htuple 5, y''\\<rangle>))))))", "by (force simp add: LstSeq_imp_Ord   Ord_trans [of _ _ \"succ \\<lbrakk>k\\<rbrakk>e\"]\n                        Seq_iff_app [of \"\\<lbrakk>s\\<rbrakk>e\", OF LstSeq_imp_Seq_succ]\n              intro!: conj_cong [OF refl] all_cong)"], ["proof (state)\nthis:\n  eval_fm e (SeqAbstFormP v i x x' s k) =\n  SeqAbstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>x\\<rbrakk>e\n   \\<lbrakk>x'\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SeqAbstFormP_subst [simp]:\n      \"(SeqAbstFormP v u x x' s k)(i::=t) =\n       SeqAbstFormP (subst i t v) (subst i t u) (subst i t x) (subst i t x') (subst i t s) (subst i t k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SeqAbstFormP v u x x' s k)(i::=t) =\n    SeqAbstFormP (subst i t v) (subst i t u) (subst i t x) (subst i t x')\n     (subst i t s) (subst i t k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (SeqAbstFormP v u x x' s k)(i::=t) =\n    SeqAbstFormP (subst i t v) (subst i t u) (subst i t x) (subst i t x')\n     (subst i t s) (subst i t k)", "obtain l::name and sli::name and sl::name and sl'::name and m::name and n::name and\n         smi::name and sm::name and sm'::name and sni::name and sn::name and sn'::name\n   where \"atom l \\<sharp> (i,t,s,k,v,sli,sl,sl',m,n,smi,sm,sm',sni,sn,sn')\"\n         \"atom sli \\<sharp> (i,t,s,v,sl,sl',m,n,smi,sm,sm',sni,sn,sn')\"\n         \"atom sl \\<sharp> (i,t,s,v,sl',m,n,smi,sm,sm',sni,sn,sn')\"\n         \"atom sl' \\<sharp> (i,t,s,v,m,n,smi,sm,sm',sni,sn,sn')\"\n         \"atom m \\<sharp> (i,t,s,n,smi,sm,sm',sni,sn,sn')\"\n         \"atom n \\<sharp> (i,t,s,smi,sm,sm',sni,sn,sn')\"\n         \"atom smi \\<sharp> (i,t,s,sm,sm',sni,sn,sn')\"\n         \"atom sm \\<sharp> (i,t,s,sm',sni,sn,sn')\" \"atom sm' \\<sharp> (i,t,s,sni,sn,sn')\"\n         \"atom sni \\<sharp> (i,t,s,sn,sn')\" \"atom sn \\<sharp> (i,t,s,sn')\" \"atom sn' \\<sharp> (i,t,s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l sli sl sl' m n smi sm sm' sni sn sn'.\n        \\<lbrakk>atom\n                  l \\<sharp> (i, t, s, k, v, sli, sl, sl', m, n, smi, sm,\n                              sm', sni, sn, sn');\n         atom\n          sli \\<sharp> (i, t, s, v, sl, sl', m, n, smi, sm, sm', sni, sn,\n                        sn');\n         atom\n          sl \\<sharp> (i, t, s, v, sl', m, n, smi, sm, sm', sni, sn, sn');\n         atom sl' \\<sharp> (i, t, s, v, m, n, smi, sm, sm', sni, sn, sn');\n         atom m \\<sharp> (i, t, s, n, smi, sm, sm', sni, sn, sn');\n         atom n \\<sharp> (i, t, s, smi, sm, sm', sni, sn, sn');\n         atom smi \\<sharp> (i, t, s, sm, sm', sni, sn, sn');\n         atom sm \\<sharp> (i, t, s, sm', sni, sn, sn');\n         atom sm' \\<sharp> (i, t, s, sni, sn, sn');\n         atom sni \\<sharp> (i, t, s, sn, sn');\n         atom sn \\<sharp> (i, t, s, sn');\n         atom sn' \\<sharp> (i, t, s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom\n   l \\<sharp> (i, t, s, k, v, sli, sl, sl', m, n, smi, sm, sm', sni, sn,\n               sn')\n  atom sli \\<sharp> (i, t, s, v, sl, sl', m, n, smi, sm, sm', sni, sn, sn')\n  atom sl \\<sharp> (i, t, s, v, sl', m, n, smi, sm, sm', sni, sn, sn')\n  atom sl' \\<sharp> (i, t, s, v, m, n, smi, sm, sm', sni, sn, sn')\n  atom m \\<sharp> (i, t, s, n, smi, sm, sm', sni, sn, sn')\n  atom n \\<sharp> (i, t, s, smi, sm, sm', sni, sn, sn')\n  atom smi \\<sharp> (i, t, s, sm, sm', sni, sn, sn')\n  atom sm \\<sharp> (i, t, s, sm', sni, sn, sn')\n  atom sm' \\<sharp> (i, t, s, sni, sn, sn')\n  atom sni \\<sharp> (i, t, s, sn, sn')\n  atom sn \\<sharp> (i, t, s, sn')\n  atom sn' \\<sharp> (i, t, s)\n\ngoal (1 subgoal):\n 1. (SeqAbstFormP v u x x' s k)(i::=t) =\n    SeqAbstFormP (subst i t v) (subst i t u) (subst i t x) (subst i t x')\n     (subst i t s) (subst i t k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom\n   l \\<sharp> (i, t, s, k, v, sli, sl, sl', m, n, smi, sm, sm', sni, sn,\n               sn')\n  atom sli \\<sharp> (i, t, s, v, sl, sl', m, n, smi, sm, sm', sni, sn, sn')\n  atom sl \\<sharp> (i, t, s, v, sl', m, n, smi, sm, sm', sni, sn, sn')\n  atom sl' \\<sharp> (i, t, s, v, m, n, smi, sm, sm', sni, sn, sn')\n  atom m \\<sharp> (i, t, s, n, smi, sm, sm', sni, sn, sn')\n  atom n \\<sharp> (i, t, s, smi, sm, sm', sni, sn, sn')\n  atom smi \\<sharp> (i, t, s, sm, sm', sni, sn, sn')\n  atom sm \\<sharp> (i, t, s, sm', sni, sn, sn')\n  atom sm' \\<sharp> (i, t, s, sni, sn, sn')\n  atom sni \\<sharp> (i, t, s, sn, sn')\n  atom sn \\<sharp> (i, t, s, sn')\n  atom sn' \\<sharp> (i, t, s)\n\ngoal (1 subgoal):\n 1. (SeqAbstFormP v u x x' s k)(i::=t) =\n    SeqAbstFormP (subst i t v) (subst i t u) (subst i t x) (subst i t x')\n     (subst i t s) (subst i t k)", "by (force simp add: SeqAbstFormP.simps [of l _ _ _ sli sl sl' m n smi sm sm' sni sn sn'])"], ["proof (state)\nthis:\n  (SeqAbstFormP v u x x' s k)(i::=t) =\n  SeqAbstFormP (subst i t v) (subst i t u) (subst i t x) (subst i t x')\n   (subst i t s) (subst i t k)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare SeqAbstFormP.simps [simp del]"], ["", "subsection \\<open>Defining the syntax: the main AbstForm predicate\\<close>"], ["", "definition AbstForm :: \"hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> bool\"\n  where \"AbstForm v i x x' \\<equiv> is_Var v \\<and> Ord i \\<and> (\\<exists>s k. SeqAbstForm v i x x' s k)\""], ["", "nominal_function AbstFormP :: \"tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> fm\"\n  where \"\\<lbrakk>atom s \\<sharp> (v,i,x,x',k);\n          atom k \\<sharp> (v,i,x,x')\\<rbrakk> \\<Longrightarrow>\n    AbstFormP v i x x' = VarP v AND OrdP i AND Ex s (Ex k (SeqAbstFormP v i x x' (Var s) (Var k)))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt AbstFormP_graph_aux\n 2. \\<And>x y. AbstFormP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>s v i xa x' k.\n           \\<lbrakk>atom s \\<sharp> (v, i, xa, x', k);\n            atom k \\<sharp> (v, i, xa, x'); x = (v, i, xa, x')\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>s v i x x' k sa va ia xa x'a ka.\n       \\<lbrakk>atom s \\<sharp> (v, i, x, x', k);\n        atom k \\<sharp> (v, i, x, x');\n        atom sa \\<sharp> (va, ia, xa, x'a, ka);\n        atom ka \\<sharp> (va, ia, xa, x'a);\n        (v, i, x, x') = (va, ia, xa, x'a)\\<rbrakk>\n       \\<Longrightarrow> VarP v AND\n                         OrdP i AND\n                         SyntaxN.Ex s\n                          (SyntaxN.Ex k\n                            (SeqAbstFormP v i x x' (Var s) (Var k))) =\n                         VarP va AND\n                         OrdP ia AND\n                         SyntaxN.Ex sa\n                          (SyntaxN.Ex ka\n                            (SeqAbstFormP va ia xa x'a (Var sa) (Var ka)))", "by (auto simp: eqvt_def AbstFormP_graph_aux_def flip_fresh_fresh) (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All AbstFormP_dom", "by lexicographic_order"], ["", "lemma\n  shows AbstFormP_fresh_iff [simp]:\n       \"a \\<sharp> AbstFormP v i x x' \\<longleftrightarrow> a \\<sharp> v \\<and> a \\<sharp> i \\<and> a \\<sharp> x \\<and> a \\<sharp> x'\" (is ?thesis1)\n    and eval_fm_AbstFormP [simp]:\n       \"eval_fm e (AbstFormP v i x x') \\<longleftrightarrow> AbstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>x\\<rbrakk>e \\<lbrakk>x'\\<rbrakk>e\" (is ?thesis2)\n    and AbstFormP_sf [iff]:\n       \"Sigma_fm (AbstFormP v i x x')\"    (is ?thsf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> AbstFormP v i x x' =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> i \\<and> a \\<sharp> x \\<and> a \\<sharp> x') &&&\n    eval_fm e (AbstFormP v i x x') =\n    AbstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>x\\<rbrakk>e\n     \\<lbrakk>x'\\<rbrakk>e &&&\n    Sigma_fm (AbstFormP v i x x')", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. a \\<sharp> AbstFormP v i x x' =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> i \\<and> a \\<sharp> x \\<and> a \\<sharp> x')\n 2. eval_fm e (AbstFormP v i x x') =\n    AbstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>x\\<rbrakk>e\n     \\<lbrakk>x'\\<rbrakk>e\n 3. Sigma_fm (AbstFormP v i x x')", "obtain s::name and k::name  where \"atom s \\<sharp> (v,i,x,x',k)\" \"atom k \\<sharp> (v,i,x,x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s k.\n        \\<lbrakk>atom s \\<sharp> (v, i, x, x', k);\n         atom k \\<sharp> (v, i, x, x')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom s \\<sharp> (v, i, x, x', k)\n  atom k \\<sharp> (v, i, x, x')\n\ngoal (3 subgoals):\n 1. a \\<sharp> AbstFormP v i x x' =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> i \\<and> a \\<sharp> x \\<and> a \\<sharp> x')\n 2. eval_fm e (AbstFormP v i x x') =\n    AbstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>x\\<rbrakk>e\n     \\<lbrakk>x'\\<rbrakk>e\n 3. Sigma_fm (AbstFormP v i x x')", "thus ?thesis1 ?thesis2 ?thsf"], ["proof (prove)\nusing this:\n  atom s \\<sharp> (v, i, x, x', k)\n  atom k \\<sharp> (v, i, x, x')\n\ngoal (1 subgoal):\n 1. a \\<sharp> AbstFormP v i x x' =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> i \\<and> a \\<sharp> x \\<and> a \\<sharp> x') &&&\n    eval_fm e (AbstFormP v i x x') =\n    AbstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>x\\<rbrakk>e\n     \\<lbrakk>x'\\<rbrakk>e &&&\n    Sigma_fm (AbstFormP v i x x')", "by (auto simp: AbstForm_def)"], ["proof (state)\nthis:\n  a \\<sharp> AbstFormP v i x x' =\n  (a \\<sharp> v \\<and>\n   a \\<sharp> i \\<and> a \\<sharp> x \\<and> a \\<sharp> x')\n  eval_fm e (AbstFormP v i x x') =\n  AbstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>x\\<rbrakk>e\n   \\<lbrakk>x'\\<rbrakk>e\n  Sigma_fm (AbstFormP v i x x')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma AbstFormP_subst [simp]:\n     \"(AbstFormP v i x x')(j::=t) = AbstFormP (subst j t v) (subst j t i) (subst j t x) (subst j t x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (AbstFormP v i x x')(j::=t) =\n    AbstFormP (subst j t v) (subst j t i) (subst j t x) (subst j t x')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (AbstFormP v i x x')(j::=t) =\n    AbstFormP (subst j t v) (subst j t i) (subst j t x) (subst j t x')", "obtain s::name and k::name  where \"atom s \\<sharp> (v,i,x,x',t,j,k)\" \"atom k \\<sharp> (v,i,x,x',t,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s k.\n        \\<lbrakk>atom s \\<sharp> (v, i, x, x', t, j, k);\n         atom k \\<sharp> (v, i, x, x', t, j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom s \\<sharp> (v, i, x, x', t, j, k)\n  atom k \\<sharp> (v, i, x, x', t, j)\n\ngoal (1 subgoal):\n 1. (AbstFormP v i x x')(j::=t) =\n    AbstFormP (subst j t v) (subst j t i) (subst j t x) (subst j t x')", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom s \\<sharp> (v, i, x, x', t, j, k)\n  atom k \\<sharp> (v, i, x, x', t, j)\n\ngoal (1 subgoal):\n 1. (AbstFormP v i x x')(j::=t) =\n    AbstFormP (subst j t v) (subst j t i) (subst j t x) (subst j t x')", "by (auto simp: AbstFormP.simps [of s _ _ _ _ k])"], ["proof (state)\nthis:\n  (AbstFormP v i x x')(j::=t) =\n  AbstFormP (subst j t v) (subst j t i) (subst j t x) (subst j t x')\n\ngoal:\nNo subgoals!", "qed"], ["", "declare AbstFormP.simps [simp del]"], ["", "subsection \\<open>Correctness: It Coincides with Abstraction over real Formulas\\<close>"], ["", "lemma AbstForm_imp_Ord: \"AbstForm v u x x' \\<Longrightarrow> Ord v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AbstForm v u x x' \\<Longrightarrow> Ord v", "by (metis AbstForm_def is_Var_def)"], ["", "lemma AbstForm_imp_abst_dbfm:\n  assumes \"AbstForm v i x x'\"\n  shows \"\\<exists>A. x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n             x' = \\<lbrakk>quot_dbfm (abst_dbfm (decode_Var v) (nat_of_ord i) A)\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n       x' =\n       \\<lbrakk>quot_dbfm\n                 (abst_dbfm (decode_Var v) (nat_of_ord i) A)\\<rbrakk>e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n       x' =\n       \\<lbrakk>quot_dbfm\n                 (abst_dbfm (decode_Var v) (nat_of_ord i) A)\\<rbrakk>e", "obtain s k where v: \"is_Var v\" and i: \"Ord i\" and sk: \"SeqAbstForm v i x x' s k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s k.\n        \\<lbrakk>is_Var v; Ord i; SeqAbstForm v i x x' s k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms [unfolded AbstForm_def]"], ["proof (prove)\nusing this:\n  is_Var v \\<and> Ord i \\<and> (\\<exists>s k. SeqAbstForm v i x x' s k)\n\ngoal (1 subgoal):\n 1. (\\<And>s k.\n        \\<lbrakk>is_Var v; Ord i; SeqAbstForm v i x x' s k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_Var v\n  Ord i\n  SeqAbstForm v i x x' s k\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n       x' =\n       \\<lbrakk>quot_dbfm\n                 (abst_dbfm (decode_Var v) (nat_of_ord i) A)\\<rbrakk>e", "from sk [unfolded SeqAbstForm_def]"], ["proof (chain)\npicking this:\n  BuildSeq3 (AbstAtomic v) AbstMakeForm s k i x x'", "show ?thesis"], ["proof (prove)\nusing this:\n  BuildSeq3 (AbstAtomic v) AbstMakeForm s k i x x'\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n       x' =\n       \\<lbrakk>quot_dbfm\n                 (abst_dbfm (decode_Var v) (nat_of_ord i) A)\\<rbrakk>e", "proof (induction i x x' rule: BuildSeq3_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x x' x''.\n       AbstAtomic v x x' x'' \\<Longrightarrow>\n       \\<exists>A.\n          x' = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n          x'' =\n          \\<lbrakk>quot_dbfm\n                    (abst_dbfm (decode_Var v) (nat_of_ord x) A)\\<rbrakk>e\n 2. \\<And>x x' x'' y y' y'' z z' z''.\n       \\<lbrakk>AbstMakeForm x x' x'' y y' y'' z z' z'';\n        \\<exists>A.\n           y' = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n           y'' =\n           \\<lbrakk>quot_dbfm\n                     (abst_dbfm (decode_Var v) (nat_of_ord y) A)\\<rbrakk>e;\n        \\<exists>A.\n           z' = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n           z'' =\n           \\<lbrakk>quot_dbfm\n                     (abst_dbfm (decode_Var v) (nat_of_ord z)\n                       A)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            x' = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n                            x'' =\n                            \\<lbrakk>quot_dbfm\n(abst_dbfm (decode_Var v) (nat_of_ord x) A)\\<rbrakk>e", "case (B i x x')"], ["proof (state)\nthis:\n  AbstAtomic v i x x'\n\ngoal (2 subgoals):\n 1. \\<And>x x' x''.\n       AbstAtomic v x x' x'' \\<Longrightarrow>\n       \\<exists>A.\n          x' = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n          x'' =\n          \\<lbrakk>quot_dbfm\n                    (abst_dbfm (decode_Var v) (nat_of_ord x) A)\\<rbrakk>e\n 2. \\<And>x x' x'' y y' y'' z z' z''.\n       \\<lbrakk>AbstMakeForm x x' x'' y y' y'' z z' z'';\n        \\<exists>A.\n           y' = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n           y'' =\n           \\<lbrakk>quot_dbfm\n                     (abst_dbfm (decode_Var v) (nat_of_ord y) A)\\<rbrakk>e;\n        \\<exists>A.\n           z' = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n           z'' =\n           \\<lbrakk>quot_dbfm\n                     (abst_dbfm (decode_Var v) (nat_of_ord z)\n                       A)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            x' = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n                            x'' =\n                            \\<lbrakk>quot_dbfm\n(abst_dbfm (decode_Var v) (nat_of_ord x) A)\\<rbrakk>e", "thus ?case"], ["proof (prove)\nusing this:\n  AbstAtomic v i x x'\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n       x' =\n       \\<lbrakk>quot_dbfm\n                 (abst_dbfm (decode_Var v) (nat_of_ord i) A)\\<rbrakk>e", "apply (auto simp: AbstAtomic_def dest!: AbstTerm_imp_abst_dbtm [where e=e])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ta tb.\n       \\<lbrakk>x' =\n                q_Eq\n                 \\<lbrakk>quot_dbtm\n                           (abst_dbtm (decode_Var v) (nat_of_ord i)\n                             ta)\\<rbrakk>e\n                 \\<lbrakk>quot_dbtm\n                           (abst_dbtm (decode_Var v) (nat_of_ord i)\n                             tb)\\<rbrakk>e;\n        x =\n        q_Eq \\<lbrakk>quot_dbtm ta\\<rbrakk>e\n         \\<lbrakk>quot_dbtm tb\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Eq \\<lbrakk>quot_dbtm ta\\<rbrakk>e\n                             \\<lbrakk>quot_dbtm tb\\<rbrakk>e =\n                            \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n                            q_Eq\n                             \\<lbrakk>quot_dbtm\n (abst_dbtm (decode_Var v) (nat_of_ord i) ta)\\<rbrakk>e\n                             \\<lbrakk>quot_dbtm\n (abst_dbtm (decode_Var v) (nat_of_ord i) tb)\\<rbrakk>e =\n                            \\<lbrakk>quot_dbfm\n(abst_dbfm (decode_Var v) (nat_of_ord i) A)\\<rbrakk>e\n 2. \\<And>ta tb.\n       \\<lbrakk>x' =\n                q_Mem\n                 \\<lbrakk>quot_dbtm\n                           (abst_dbtm (decode_Var v) (nat_of_ord i)\n                             ta)\\<rbrakk>e\n                 \\<lbrakk>quot_dbtm\n                           (abst_dbtm (decode_Var v) (nat_of_ord i)\n                             tb)\\<rbrakk>e;\n        x =\n        q_Mem \\<lbrakk>quot_dbtm ta\\<rbrakk>e\n         \\<lbrakk>quot_dbtm tb\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Mem \\<lbrakk>quot_dbtm ta\\<rbrakk>e\n                             \\<lbrakk>quot_dbtm tb\\<rbrakk>e =\n                            \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n                            q_Mem\n                             \\<lbrakk>quot_dbtm\n (abst_dbtm (decode_Var v) (nat_of_ord i) ta)\\<rbrakk>e\n                             \\<lbrakk>quot_dbtm\n (abst_dbtm (decode_Var v) (nat_of_ord i) tb)\\<rbrakk>e =\n                            \\<lbrakk>quot_dbfm\n(abst_dbfm (decode_Var v) (nat_of_ord i) A)\\<rbrakk>e", "apply (rule_tac [1] x=\"DBEq ta tb\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ta tb.\n       \\<lbrakk>x' =\n                q_Eq\n                 \\<lbrakk>quot_dbtm\n                           (abst_dbtm (decode_Var v) (nat_of_ord i)\n                             ta)\\<rbrakk>e\n                 \\<lbrakk>quot_dbtm\n                           (abst_dbtm (decode_Var v) (nat_of_ord i)\n                             tb)\\<rbrakk>e;\n        x =\n        q_Eq \\<lbrakk>quot_dbtm ta\\<rbrakk>e\n         \\<lbrakk>quot_dbtm tb\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> q_Eq \\<lbrakk>quot_dbtm ta\\<rbrakk>e\n                          \\<lbrakk>quot_dbtm tb\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm (DBEq ta tb)\\<rbrakk>e \\<and>\n                         q_Eq\n                          \\<lbrakk>quot_dbtm\n                                    (abst_dbtm (decode_Var v) (nat_of_ord i)\nta)\\<rbrakk>e\n                          \\<lbrakk>quot_dbtm\n                                    (abst_dbtm (decode_Var v) (nat_of_ord i)\ntb)\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm\n                                   (abst_dbfm (decode_Var v) (nat_of_ord i)\n                                     (DBEq ta tb))\\<rbrakk>e\n 2. \\<And>ta tb.\n       \\<lbrakk>x' =\n                q_Mem\n                 \\<lbrakk>quot_dbtm\n                           (abst_dbtm (decode_Var v) (nat_of_ord i)\n                             ta)\\<rbrakk>e\n                 \\<lbrakk>quot_dbtm\n                           (abst_dbtm (decode_Var v) (nat_of_ord i)\n                             tb)\\<rbrakk>e;\n        x =\n        q_Mem \\<lbrakk>quot_dbtm ta\\<rbrakk>e\n         \\<lbrakk>quot_dbtm tb\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Mem \\<lbrakk>quot_dbtm ta\\<rbrakk>e\n                             \\<lbrakk>quot_dbtm tb\\<rbrakk>e =\n                            \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n                            q_Mem\n                             \\<lbrakk>quot_dbtm\n (abst_dbtm (decode_Var v) (nat_of_ord i) ta)\\<rbrakk>e\n                             \\<lbrakk>quot_dbtm\n (abst_dbtm (decode_Var v) (nat_of_ord i) tb)\\<rbrakk>e =\n                            \\<lbrakk>quot_dbfm\n(abst_dbfm (decode_Var v) (nat_of_ord i) A)\\<rbrakk>e", "apply (rule_tac [2] x=\"DBMem ta tb\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ta tb.\n       \\<lbrakk>x' =\n                q_Eq\n                 \\<lbrakk>quot_dbtm\n                           (abst_dbtm (decode_Var v) (nat_of_ord i)\n                             ta)\\<rbrakk>e\n                 \\<lbrakk>quot_dbtm\n                           (abst_dbtm (decode_Var v) (nat_of_ord i)\n                             tb)\\<rbrakk>e;\n        x =\n        q_Eq \\<lbrakk>quot_dbtm ta\\<rbrakk>e\n         \\<lbrakk>quot_dbtm tb\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> q_Eq \\<lbrakk>quot_dbtm ta\\<rbrakk>e\n                          \\<lbrakk>quot_dbtm tb\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm (DBEq ta tb)\\<rbrakk>e \\<and>\n                         q_Eq\n                          \\<lbrakk>quot_dbtm\n                                    (abst_dbtm (decode_Var v) (nat_of_ord i)\nta)\\<rbrakk>e\n                          \\<lbrakk>quot_dbtm\n                                    (abst_dbtm (decode_Var v) (nat_of_ord i)\ntb)\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm\n                                   (abst_dbfm (decode_Var v) (nat_of_ord i)\n                                     (DBEq ta tb))\\<rbrakk>e\n 2. \\<And>ta tb.\n       \\<lbrakk>x' =\n                q_Mem\n                 \\<lbrakk>quot_dbtm\n                           (abst_dbtm (decode_Var v) (nat_of_ord i)\n                             ta)\\<rbrakk>e\n                 \\<lbrakk>quot_dbtm\n                           (abst_dbtm (decode_Var v) (nat_of_ord i)\n                             tb)\\<rbrakk>e;\n        x =\n        q_Mem \\<lbrakk>quot_dbtm ta\\<rbrakk>e\n         \\<lbrakk>quot_dbtm tb\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> q_Mem \\<lbrakk>quot_dbtm ta\\<rbrakk>e\n                          \\<lbrakk>quot_dbtm tb\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm (DBMem ta tb)\\<rbrakk>e \\<and>\n                         q_Mem\n                          \\<lbrakk>quot_dbtm\n                                    (abst_dbtm (decode_Var v) (nat_of_ord i)\nta)\\<rbrakk>e\n                          \\<lbrakk>quot_dbtm\n                                    (abst_dbtm (decode_Var v) (nat_of_ord i)\ntb)\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm\n                                   (abst_dbfm (decode_Var v) (nat_of_ord i)\n                                     (DBMem ta tb))\\<rbrakk>e", "apply (auto simp: q_defs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>A.\n     x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     x' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord i) A)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>x x' x'' y y' y'' z z' z''.\n       \\<lbrakk>AbstMakeForm x x' x'' y y' y'' z z' z'';\n        \\<exists>A.\n           y' = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n           y'' =\n           \\<lbrakk>quot_dbfm\n                     (abst_dbfm (decode_Var v) (nat_of_ord y) A)\\<rbrakk>e;\n        \\<exists>A.\n           z' = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n           z'' =\n           \\<lbrakk>quot_dbfm\n                     (abst_dbfm (decode_Var v) (nat_of_ord z)\n                       A)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            x' = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n                            x'' =\n                            \\<lbrakk>quot_dbfm\n(abst_dbfm (decode_Var v) (nat_of_ord x) A)\\<rbrakk>e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x' x'' y y' y'' z z' z''.\n       \\<lbrakk>AbstMakeForm x x' x'' y y' y'' z z' z'';\n        \\<exists>A.\n           y' = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n           y'' =\n           \\<lbrakk>quot_dbfm\n                     (abst_dbfm (decode_Var v) (nat_of_ord y) A)\\<rbrakk>e;\n        \\<exists>A.\n           z' = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n           z'' =\n           \\<lbrakk>quot_dbfm\n                     (abst_dbfm (decode_Var v) (nat_of_ord z)\n                       A)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            x' = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n                            x'' =\n                            \\<lbrakk>quot_dbfm\n(abst_dbfm (decode_Var v) (nat_of_ord x) A)\\<rbrakk>e", "case (C i x x' j y y' k z z')"], ["proof (state)\nthis:\n  AbstMakeForm i x x' j y y' k z z'\n  \\<exists>A.\n     y = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     y' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord j) A)\\<rbrakk>e\n  \\<exists>A.\n     z = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     z' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord k) A)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>x x' x'' y y' y'' z z' z''.\n       \\<lbrakk>AbstMakeForm x x' x'' y y' y'' z z' z'';\n        \\<exists>A.\n           y' = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n           y'' =\n           \\<lbrakk>quot_dbfm\n                     (abst_dbfm (decode_Var v) (nat_of_ord y) A)\\<rbrakk>e;\n        \\<exists>A.\n           z' = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n           z'' =\n           \\<lbrakk>quot_dbfm\n                     (abst_dbfm (decode_Var v) (nat_of_ord z)\n                       A)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            x' = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n                            x'' =\n                            \\<lbrakk>quot_dbfm\n(abst_dbfm (decode_Var v) (nat_of_ord x) A)\\<rbrakk>e", "then"], ["proof (chain)\npicking this:\n  AbstMakeForm i x x' j y y' k z z'\n  \\<exists>A.\n     y = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     y' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord j) A)\\<rbrakk>e\n  \\<exists>A.\n     z = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     z' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord k) A)\\<rbrakk>e", "obtain A1 and A2\n      where \"y = \\<lbrakk>quot_dbfm A1\\<rbrakk>e\"\n            \"y' = \\<lbrakk>quot_dbfm (abst_dbfm (decode_Var v) (nat_of_ord j) A1)\\<rbrakk>e\"\n            \"z = \\<lbrakk>quot_dbfm A2\\<rbrakk>e\"\n            \"z' = \\<lbrakk>quot_dbfm (abst_dbfm (decode_Var v) (nat_of_ord k) A2)\\<rbrakk>e\""], ["proof (prove)\nusing this:\n  AbstMakeForm i x x' j y y' k z z'\n  \\<exists>A.\n     y = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     y' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord j) A)\\<rbrakk>e\n  \\<exists>A.\n     z = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     z' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord k) A)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. (\\<And>A1 A2.\n        \\<lbrakk>y = \\<lbrakk>quot_dbfm A1\\<rbrakk>e;\n         y' =\n         \\<lbrakk>quot_dbfm\n                   (abst_dbfm (decode_Var v) (nat_of_ord j) A1)\\<rbrakk>e;\n         z = \\<lbrakk>quot_dbfm A2\\<rbrakk>e;\n         z' =\n         \\<lbrakk>quot_dbfm\n                   (abst_dbfm (decode_Var v) (nat_of_ord k)\n                     A2)\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y = \\<lbrakk>quot_dbfm A1\\<rbrakk>e\n  y' =\n  \\<lbrakk>quot_dbfm (abst_dbfm (decode_Var v) (nat_of_ord j) A1)\\<rbrakk>e\n  z = \\<lbrakk>quot_dbfm A2\\<rbrakk>e\n  z' =\n  \\<lbrakk>quot_dbfm (abst_dbfm (decode_Var v) (nat_of_ord k) A2)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>x x' x'' y y' y'' z z' z''.\n       \\<lbrakk>AbstMakeForm x x' x'' y y' y'' z z' z'';\n        \\<exists>A.\n           y' = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n           y'' =\n           \\<lbrakk>quot_dbfm\n                     (abst_dbfm (decode_Var v) (nat_of_ord y) A)\\<rbrakk>e;\n        \\<exists>A.\n           z' = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n           z'' =\n           \\<lbrakk>quot_dbfm\n                     (abst_dbfm (decode_Var v) (nat_of_ord z)\n                       A)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            x' = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n                            x'' =\n                            \\<lbrakk>quot_dbfm\n(abst_dbfm (decode_Var v) (nat_of_ord x) A)\\<rbrakk>e", "with C.hyps"], ["proof (chain)\npicking this:\n  AbstMakeForm i x x' j y y' k z z'\n  y = \\<lbrakk>quot_dbfm A1\\<rbrakk>e\n  y' =\n  \\<lbrakk>quot_dbfm (abst_dbfm (decode_Var v) (nat_of_ord j) A1)\\<rbrakk>e\n  z = \\<lbrakk>quot_dbfm A2\\<rbrakk>e\n  z' =\n  \\<lbrakk>quot_dbfm (abst_dbfm (decode_Var v) (nat_of_ord k) A2)\\<rbrakk>e", "show ?case"], ["proof (prove)\nusing this:\n  AbstMakeForm i x x' j y y' k z z'\n  y = \\<lbrakk>quot_dbfm A1\\<rbrakk>e\n  y' =\n  \\<lbrakk>quot_dbfm (abst_dbfm (decode_Var v) (nat_of_ord j) A1)\\<rbrakk>e\n  z = \\<lbrakk>quot_dbfm A2\\<rbrakk>e\n  z' =\n  \\<lbrakk>quot_dbfm (abst_dbfm (decode_Var v) (nat_of_ord k) A2)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n       x' =\n       \\<lbrakk>quot_dbfm\n                 (abst_dbfm (decode_Var v) (nat_of_ord i) A)\\<rbrakk>e", "apply (auto simp: AbstMakeForm_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y = \\<lbrakk>quot_dbfm A1\\<rbrakk>e;\n     y' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord k) A1)\\<rbrakk>e;\n     z = \\<lbrakk>quot_dbfm A2\\<rbrakk>e;\n     z' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord k) A2)\\<rbrakk>e;\n     Ord k; i = k; j = k;\n     x' =\n     q_Disj\n      \\<lbrakk>quot_dbfm\n                (abst_dbfm (decode_Var v) (nat_of_ord k) A1)\\<rbrakk>e\n      \\<lbrakk>quot_dbfm\n                (abst_dbfm (decode_Var v) (nat_of_ord k) A2)\\<rbrakk>e;\n     x =\n     q_Disj \\<lbrakk>quot_dbfm A1\\<rbrakk>e\n      \\<lbrakk>quot_dbfm A2\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A.\n                         q_Disj \\<lbrakk>quot_dbfm A1\\<rbrakk>e\n                          \\<lbrakk>quot_dbfm A2\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n                         q_Disj\n                          \\<lbrakk>quot_dbfm\n                                    (abst_dbfm (decode_Var v) (nat_of_ord k)\nA1)\\<rbrakk>e\n                          \\<lbrakk>quot_dbfm\n                                    (abst_dbfm (decode_Var v) (nat_of_ord k)\nA2)\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm\n                                   (abst_dbfm (decode_Var v) (nat_of_ord k)\n                                     A)\\<rbrakk>e\n 2. \\<lbrakk>y = \\<lbrakk>quot_dbfm A1\\<rbrakk>e;\n     y' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord j) A1)\\<rbrakk>e;\n     z = \\<lbrakk>quot_dbfm A2\\<rbrakk>e;\n     z' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord k) A2)\\<rbrakk>e;\n     Ord j; i = j;\n     x' =\n     q_Neg\n      \\<lbrakk>quot_dbfm\n                (abst_dbfm (decode_Var v) (nat_of_ord j) A1)\\<rbrakk>e;\n     x = q_Neg \\<lbrakk>quot_dbfm A1\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A.\n                         q_Neg \\<lbrakk>quot_dbfm A1\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n                         q_Neg\n                          \\<lbrakk>quot_dbfm\n                                    (abst_dbfm (decode_Var v) (nat_of_ord j)\nA1)\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm\n                                   (abst_dbfm (decode_Var v) (nat_of_ord j)\n                                     A)\\<rbrakk>e\n 3. \\<lbrakk>y = \\<lbrakk>quot_dbfm A1\\<rbrakk>e;\n     y' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (Suc (nat_of_ord i)) A1)\\<rbrakk>e;\n     z = \\<lbrakk>quot_dbfm A2\\<rbrakk>e;\n     z' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord k) A2)\\<rbrakk>e;\n     Ord i; j = succ i;\n     x' =\n     q_Ex\n      \\<lbrakk>quot_dbfm\n                (abst_dbfm (decode_Var v) (Suc (nat_of_ord i))\n                  A1)\\<rbrakk>e;\n     x = q_Ex \\<lbrakk>quot_dbfm A1\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A.\n                         q_Ex \\<lbrakk>quot_dbfm A1\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n                         q_Ex\n                          \\<lbrakk>quot_dbfm\n                                    (abst_dbfm (decode_Var v)\n(Suc (nat_of_ord i)) A1)\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm\n                                   (abst_dbfm (decode_Var v) (nat_of_ord i)\n                                     A)\\<rbrakk>e", "apply (rule_tac [1] x=\"DBDisj A1 A2\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y = \\<lbrakk>quot_dbfm A1\\<rbrakk>e;\n     y' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord k) A1)\\<rbrakk>e;\n     z = \\<lbrakk>quot_dbfm A2\\<rbrakk>e;\n     z' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord k) A2)\\<rbrakk>e;\n     Ord k; i = k; j = k;\n     x' =\n     q_Disj\n      \\<lbrakk>quot_dbfm\n                (abst_dbfm (decode_Var v) (nat_of_ord k) A1)\\<rbrakk>e\n      \\<lbrakk>quot_dbfm\n                (abst_dbfm (decode_Var v) (nat_of_ord k) A2)\\<rbrakk>e;\n     x =\n     q_Disj \\<lbrakk>quot_dbfm A1\\<rbrakk>e\n      \\<lbrakk>quot_dbfm A2\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> q_Disj \\<lbrakk>quot_dbfm A1\\<rbrakk>e\n                       \\<lbrakk>quot_dbfm A2\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm (DBDisj A1 A2)\\<rbrakk>e \\<and>\n                      q_Disj\n                       \\<lbrakk>quot_dbfm\n                                 (abst_dbfm (decode_Var v) (nat_of_ord k)\n                                   A1)\\<rbrakk>e\n                       \\<lbrakk>quot_dbfm\n                                 (abst_dbfm (decode_Var v) (nat_of_ord k)\n                                   A2)\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm\n                                (abst_dbfm (decode_Var v) (nat_of_ord k)\n                                  (DBDisj A1 A2))\\<rbrakk>e\n 2. \\<lbrakk>y = \\<lbrakk>quot_dbfm A1\\<rbrakk>e;\n     y' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord j) A1)\\<rbrakk>e;\n     z = \\<lbrakk>quot_dbfm A2\\<rbrakk>e;\n     z' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord k) A2)\\<rbrakk>e;\n     Ord j; i = j;\n     x' =\n     q_Neg\n      \\<lbrakk>quot_dbfm\n                (abst_dbfm (decode_Var v) (nat_of_ord j) A1)\\<rbrakk>e;\n     x = q_Neg \\<lbrakk>quot_dbfm A1\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A.\n                         q_Neg \\<lbrakk>quot_dbfm A1\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n                         q_Neg\n                          \\<lbrakk>quot_dbfm\n                                    (abst_dbfm (decode_Var v) (nat_of_ord j)\nA1)\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm\n                                   (abst_dbfm (decode_Var v) (nat_of_ord j)\n                                     A)\\<rbrakk>e\n 3. \\<lbrakk>y = \\<lbrakk>quot_dbfm A1\\<rbrakk>e;\n     y' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (Suc (nat_of_ord i)) A1)\\<rbrakk>e;\n     z = \\<lbrakk>quot_dbfm A2\\<rbrakk>e;\n     z' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord k) A2)\\<rbrakk>e;\n     Ord i; j = succ i;\n     x' =\n     q_Ex\n      \\<lbrakk>quot_dbfm\n                (abst_dbfm (decode_Var v) (Suc (nat_of_ord i))\n                  A1)\\<rbrakk>e;\n     x = q_Ex \\<lbrakk>quot_dbfm A1\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A.\n                         q_Ex \\<lbrakk>quot_dbfm A1\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n                         q_Ex\n                          \\<lbrakk>quot_dbfm\n                                    (abst_dbfm (decode_Var v)\n(Suc (nat_of_ord i)) A1)\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm\n                                   (abst_dbfm (decode_Var v) (nat_of_ord i)\n                                     A)\\<rbrakk>e", "apply (rule_tac [2] x=\"DBNeg A1\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y = \\<lbrakk>quot_dbfm A1\\<rbrakk>e;\n     y' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord k) A1)\\<rbrakk>e;\n     z = \\<lbrakk>quot_dbfm A2\\<rbrakk>e;\n     z' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord k) A2)\\<rbrakk>e;\n     Ord k; i = k; j = k;\n     x' =\n     q_Disj\n      \\<lbrakk>quot_dbfm\n                (abst_dbfm (decode_Var v) (nat_of_ord k) A1)\\<rbrakk>e\n      \\<lbrakk>quot_dbfm\n                (abst_dbfm (decode_Var v) (nat_of_ord k) A2)\\<rbrakk>e;\n     x =\n     q_Disj \\<lbrakk>quot_dbfm A1\\<rbrakk>e\n      \\<lbrakk>quot_dbfm A2\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> q_Disj \\<lbrakk>quot_dbfm A1\\<rbrakk>e\n                       \\<lbrakk>quot_dbfm A2\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm (DBDisj A1 A2)\\<rbrakk>e \\<and>\n                      q_Disj\n                       \\<lbrakk>quot_dbfm\n                                 (abst_dbfm (decode_Var v) (nat_of_ord k)\n                                   A1)\\<rbrakk>e\n                       \\<lbrakk>quot_dbfm\n                                 (abst_dbfm (decode_Var v) (nat_of_ord k)\n                                   A2)\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm\n                                (abst_dbfm (decode_Var v) (nat_of_ord k)\n                                  (DBDisj A1 A2))\\<rbrakk>e\n 2. \\<lbrakk>y = \\<lbrakk>quot_dbfm A1\\<rbrakk>e;\n     y' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord j) A1)\\<rbrakk>e;\n     z = \\<lbrakk>quot_dbfm A2\\<rbrakk>e;\n     z' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord k) A2)\\<rbrakk>e;\n     Ord j; i = j;\n     x' =\n     q_Neg\n      \\<lbrakk>quot_dbfm\n                (abst_dbfm (decode_Var v) (nat_of_ord j) A1)\\<rbrakk>e;\n     x = q_Neg \\<lbrakk>quot_dbfm A1\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> q_Neg \\<lbrakk>quot_dbfm A1\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm (DBNeg A1)\\<rbrakk>e \\<and>\n                      q_Neg\n                       \\<lbrakk>quot_dbfm\n                                 (abst_dbfm (decode_Var v) (nat_of_ord j)\n                                   A1)\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm\n                                (abst_dbfm (decode_Var v) (nat_of_ord j)\n                                  (DBNeg A1))\\<rbrakk>e\n 3. \\<lbrakk>y = \\<lbrakk>quot_dbfm A1\\<rbrakk>e;\n     y' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (Suc (nat_of_ord i)) A1)\\<rbrakk>e;\n     z = \\<lbrakk>quot_dbfm A2\\<rbrakk>e;\n     z' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord k) A2)\\<rbrakk>e;\n     Ord i; j = succ i;\n     x' =\n     q_Ex\n      \\<lbrakk>quot_dbfm\n                (abst_dbfm (decode_Var v) (Suc (nat_of_ord i))\n                  A1)\\<rbrakk>e;\n     x = q_Ex \\<lbrakk>quot_dbfm A1\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A.\n                         q_Ex \\<lbrakk>quot_dbfm A1\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n                         q_Ex\n                          \\<lbrakk>quot_dbfm\n                                    (abst_dbfm (decode_Var v)\n(Suc (nat_of_ord i)) A1)\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm\n                                   (abst_dbfm (decode_Var v) (nat_of_ord i)\n                                     A)\\<rbrakk>e", "apply (rule_tac [3] x=\"DBEx A1\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y = \\<lbrakk>quot_dbfm A1\\<rbrakk>e;\n     y' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord k) A1)\\<rbrakk>e;\n     z = \\<lbrakk>quot_dbfm A2\\<rbrakk>e;\n     z' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord k) A2)\\<rbrakk>e;\n     Ord k; i = k; j = k;\n     x' =\n     q_Disj\n      \\<lbrakk>quot_dbfm\n                (abst_dbfm (decode_Var v) (nat_of_ord k) A1)\\<rbrakk>e\n      \\<lbrakk>quot_dbfm\n                (abst_dbfm (decode_Var v) (nat_of_ord k) A2)\\<rbrakk>e;\n     x =\n     q_Disj \\<lbrakk>quot_dbfm A1\\<rbrakk>e\n      \\<lbrakk>quot_dbfm A2\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> q_Disj \\<lbrakk>quot_dbfm A1\\<rbrakk>e\n                       \\<lbrakk>quot_dbfm A2\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm (DBDisj A1 A2)\\<rbrakk>e \\<and>\n                      q_Disj\n                       \\<lbrakk>quot_dbfm\n                                 (abst_dbfm (decode_Var v) (nat_of_ord k)\n                                   A1)\\<rbrakk>e\n                       \\<lbrakk>quot_dbfm\n                                 (abst_dbfm (decode_Var v) (nat_of_ord k)\n                                   A2)\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm\n                                (abst_dbfm (decode_Var v) (nat_of_ord k)\n                                  (DBDisj A1 A2))\\<rbrakk>e\n 2. \\<lbrakk>y = \\<lbrakk>quot_dbfm A1\\<rbrakk>e;\n     y' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord j) A1)\\<rbrakk>e;\n     z = \\<lbrakk>quot_dbfm A2\\<rbrakk>e;\n     z' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord k) A2)\\<rbrakk>e;\n     Ord j; i = j;\n     x' =\n     q_Neg\n      \\<lbrakk>quot_dbfm\n                (abst_dbfm (decode_Var v) (nat_of_ord j) A1)\\<rbrakk>e;\n     x = q_Neg \\<lbrakk>quot_dbfm A1\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> q_Neg \\<lbrakk>quot_dbfm A1\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm (DBNeg A1)\\<rbrakk>e \\<and>\n                      q_Neg\n                       \\<lbrakk>quot_dbfm\n                                 (abst_dbfm (decode_Var v) (nat_of_ord j)\n                                   A1)\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm\n                                (abst_dbfm (decode_Var v) (nat_of_ord j)\n                                  (DBNeg A1))\\<rbrakk>e\n 3. \\<lbrakk>y = \\<lbrakk>quot_dbfm A1\\<rbrakk>e;\n     y' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (Suc (nat_of_ord i)) A1)\\<rbrakk>e;\n     z = \\<lbrakk>quot_dbfm A2\\<rbrakk>e;\n     z' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord k) A2)\\<rbrakk>e;\n     Ord i; j = succ i;\n     x' =\n     q_Ex\n      \\<lbrakk>quot_dbfm\n                (abst_dbfm (decode_Var v) (Suc (nat_of_ord i))\n                  A1)\\<rbrakk>e;\n     x = q_Ex \\<lbrakk>quot_dbfm A1\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> q_Ex \\<lbrakk>quot_dbfm A1\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm (DBEx A1)\\<rbrakk>e \\<and>\n                      q_Ex\n                       \\<lbrakk>quot_dbfm\n                                 (abst_dbfm (decode_Var v)\n                                   (Suc (nat_of_ord i)) A1)\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm\n                                (abst_dbfm (decode_Var v) (nat_of_ord i)\n                                  (DBEx A1))\\<rbrakk>e", "apply (auto simp: C q_defs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>A.\n     x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     x' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord i) A)\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>A.\n     x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     x' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord i) A)\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma AbstForm_abst_dbfm:\n  \"AbstForm (q_Var i) (ord_of n) \\<lbrakk>quot_dbfm fm\\<rbrakk>e \\<lbrakk>quot_dbfm (abst_dbfm i n fm)\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AbstForm (q_Var i) (ord_of n) \\<lbrakk>quot_dbfm fm\\<rbrakk>e\n     \\<lbrakk>quot_dbfm (abst_dbfm i n fm)\\<rbrakk>e", "apply (induction fm arbitrary: n rule: dbfm.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 n.\n       AbstForm (q_Var i) (ord_of n)\n        \\<lbrakk>quot_dbfm (DBMem x1 x2)\\<rbrakk>e\n        \\<lbrakk>quot_dbfm (abst_dbfm i n (DBMem x1 x2))\\<rbrakk>e\n 2. \\<And>x1 x2 n.\n       AbstForm (q_Var i) (ord_of n)\n        \\<lbrakk>quot_dbfm (DBEq x1 x2)\\<rbrakk>e\n        \\<lbrakk>quot_dbfm (abst_dbfm i n (DBEq x1 x2))\\<rbrakk>e\n 3. \\<And>x1 x2 n.\n       \\<lbrakk>\\<And>n.\n                   AbstForm (q_Var i) (ord_of n)\n                    \\<lbrakk>quot_dbfm x1\\<rbrakk>e\n                    \\<lbrakk>quot_dbfm (abst_dbfm i n x1)\\<rbrakk>e;\n        \\<And>n.\n           AbstForm (q_Var i) (ord_of n) \\<lbrakk>quot_dbfm x2\\<rbrakk>e\n            \\<lbrakk>quot_dbfm (abst_dbfm i n x2)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> AbstForm (q_Var i) (ord_of n)\n                          \\<lbrakk>quot_dbfm (DBDisj x1 x2)\\<rbrakk>e\n                          \\<lbrakk>quot_dbfm\n                                    (abst_dbfm i n (DBDisj x1 x2))\\<rbrakk>e\n 4. \\<And>x n.\n       (\\<And>n.\n           AbstForm (q_Var i) (ord_of n) \\<lbrakk>quot_dbfm x\\<rbrakk>e\n            \\<lbrakk>quot_dbfm\n                      (abst_dbfm i n x)\\<rbrakk>e) \\<Longrightarrow>\n       AbstForm (q_Var i) (ord_of n) \\<lbrakk>quot_dbfm (DBNeg x)\\<rbrakk>e\n        \\<lbrakk>quot_dbfm (abst_dbfm i n (DBNeg x))\\<rbrakk>e\n 5. \\<And>x n.\n       (\\<And>n.\n           AbstForm (q_Var i) (ord_of n) \\<lbrakk>quot_dbfm x\\<rbrakk>e\n            \\<lbrakk>quot_dbfm\n                      (abst_dbfm i n x)\\<rbrakk>e) \\<Longrightarrow>\n       AbstForm (q_Var i) (ord_of n) \\<lbrakk>quot_dbfm (DBEx x)\\<rbrakk>e\n        \\<lbrakk>quot_dbfm (abst_dbfm i n (DBEx x))\\<rbrakk>e", "apply (force simp add: AbstForm_def SeqAbstForm_def AbstMakeForm_def AbstAtomic_def\n                       AbstTerm_abst_dbtm htuple_minus_1 q_defs simp del: q_Var_def\n             intro: BuildSeq3_exI BuildSeq3_combine)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "section \\<open>Substitution over formulas\\<close>"], ["", "subsection \\<open>The predicate \\<open>SubstAtomicP\\<close>\\<close>"], ["", "definition SubstAtomic :: \"hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> bool\"\n  where \"SubstAtomic v tm y y' \\<equiv> \n            (\\<exists>t u t' u'. SubstTerm v tm t t' \\<and> SubstTerm v tm u u' \\<and>\n             ((y = q_Eq t u \\<and> y' = q_Eq t' u') \\<or> (y = q_Mem t u \\<and> y' = q_Mem t' u')))\""], ["", "nominal_function SubstAtomicP :: \"tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> fm\"\n  where \"\\<lbrakk>atom t \\<sharp> (v,tm,y,y',t',u,u');\n          atom t' \\<sharp> (v,tm,y,y',u,u');\n          atom u \\<sharp> (v,tm,y,y',u');\n          atom u' \\<sharp> (v,tm,y,y')\\<rbrakk> \\<Longrightarrow>\n    SubstAtomicP v tm y y' =\n         Ex t (Ex u (Ex t' (Ex u'\n           (SubstTermP v tm (Var t) (Var t') AND SubstTermP v tm (Var u) (Var u') AND\n                      ((y EQ Q_Eq (Var t) (Var u) AND y' EQ Q_Eq (Var t') (Var u')) OR\n                       (y EQ Q_Mem (Var t) (Var u) AND y' EQ Q_Mem (Var t') (Var u')))))))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt SubstAtomicP_graph_aux\n 2. \\<And>x y. SubstAtomicP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>t v tm y y' t' u u'.\n           \\<lbrakk>atom t \\<sharp> (v, tm, y, y', t', u, u');\n            atom t' \\<sharp> (v, tm, y, y', u, u');\n            atom u \\<sharp> (v, tm, y, y', u');\n            atom u' \\<sharp> (v, tm, y, y'); x = (v, tm, y, y')\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>t v tm y y' t' u u' ta va tma ya y'a t'a ua u'a.\n       \\<lbrakk>atom t \\<sharp> (v, tm, y, y', t', u, u');\n        atom t' \\<sharp> (v, tm, y, y', u, u');\n        atom u \\<sharp> (v, tm, y, y', u'); atom u' \\<sharp> (v, tm, y, y');\n        atom ta \\<sharp> (va, tma, ya, y'a, t'a, ua, u'a);\n        atom t'a \\<sharp> (va, tma, ya, y'a, ua, u'a);\n        atom ua \\<sharp> (va, tma, ya, y'a, u'a);\n        atom u'a \\<sharp> (va, tma, ya, y'a);\n        (v, tm, y, y') = (va, tma, ya, y'a)\\<rbrakk>\n       \\<Longrightarrow> SyntaxN.Ex t\n                          (SyntaxN.Ex u\n                            (SyntaxN.Ex t'\n                              (SyntaxN.Ex u'\n                                (SubstTermP v tm (Var t) (Var t') AND\n                                 SubstTermP v tm (Var u) (Var u') AND\n                                 (y EQ Q_Eq (Var t) (Var u) AND\n                                  y' EQ Q_Eq (Var t') (Var u') OR\n                                  y EQ Q_Mem (Var t) (Var u) AND\n                                  y' EQ Q_Mem (Var t') (Var u')))))) =\n                         SyntaxN.Ex ta\n                          (SyntaxN.Ex ua\n                            (SyntaxN.Ex t'a\n                              (SyntaxN.Ex u'a\n                                (SubstTermP va tma (Var ta) (Var t'a) AND\n                                 SubstTermP va tma (Var ua) (Var u'a) AND\n                                 (ya EQ Q_Eq (Var ta) (Var ua) AND\n                                  y'a EQ Q_Eq (Var t'a) (Var u'a) OR\n                                  ya EQ Q_Mem (Var ta) (Var ua) AND\n                                  y'a EQ Q_Mem (Var t'a) (Var u'a))))))", "by (auto simp: eqvt_def SubstAtomicP_graph_aux_def flip_fresh_fresh) (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All SubstAtomicP_dom", "by lexicographic_order"], ["", "lemma\n  shows SubstAtomicP_fresh_iff [simp]:\n       \"a \\<sharp> SubstAtomicP v tm y y' \\<longleftrightarrow> a \\<sharp> v \\<and> a \\<sharp> tm \\<and> a \\<sharp> y \\<and> a \\<sharp> y'\"           (is ?thesis1)\n    and eval_fm_SubstAtomicP [simp]:\n       \"eval_fm e (SubstAtomicP v tm y y') \\<longleftrightarrow> SubstAtomic \\<lbrakk>v\\<rbrakk>e \\<lbrakk>tm\\<rbrakk>e \\<lbrakk>y\\<rbrakk>e \\<lbrakk>y'\\<rbrakk>e\"  (is ?thesis2)\n    and SubstAtomicP_sf [iff]: \"Sigma_fm (SubstAtomicP v tm y y')\"               (is ?thsf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> SubstAtomicP v tm y y' =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> tm \\<and> a \\<sharp> y \\<and> a \\<sharp> y') &&&\n    eval_fm e (SubstAtomicP v tm y y') =\n    SubstAtomic \\<lbrakk>v\\<rbrakk>e \\<lbrakk>tm\\<rbrakk>e\n     \\<lbrakk>y\\<rbrakk>e \\<lbrakk>y'\\<rbrakk>e &&&\n    Sigma_fm (SubstAtomicP v tm y y')", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. a \\<sharp> SubstAtomicP v tm y y' =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> tm \\<and> a \\<sharp> y \\<and> a \\<sharp> y')\n 2. eval_fm e (SubstAtomicP v tm y y') =\n    SubstAtomic \\<lbrakk>v\\<rbrakk>e \\<lbrakk>tm\\<rbrakk>e\n     \\<lbrakk>y\\<rbrakk>e \\<lbrakk>y'\\<rbrakk>e\n 3. Sigma_fm (SubstAtomicP v tm y y')", "obtain t::name and u::name and t'::name  and u'::name\n    where \"atom t \\<sharp> (v,tm,y,y',t',u,u')\" \"atom t' \\<sharp> (v,tm,y,y',u,u')\"\n          \"atom u \\<sharp> (v,tm,y,y',u')\" \"atom u' \\<sharp> (v,tm,y,y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t t' u u'.\n        \\<lbrakk>atom t \\<sharp> (v, tm, y, y', t', u, u');\n         atom t' \\<sharp> (v, tm, y, y', u, u');\n         atom u \\<sharp> (v, tm, y, y', u');\n         atom u' \\<sharp> (v, tm, y, y')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom t \\<sharp> (v, tm, y, y', t', u, u')\n  atom t' \\<sharp> (v, tm, y, y', u, u')\n  atom u \\<sharp> (v, tm, y, y', u')\n  atom u' \\<sharp> (v, tm, y, y')\n\ngoal (3 subgoals):\n 1. a \\<sharp> SubstAtomicP v tm y y' =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> tm \\<and> a \\<sharp> y \\<and> a \\<sharp> y')\n 2. eval_fm e (SubstAtomicP v tm y y') =\n    SubstAtomic \\<lbrakk>v\\<rbrakk>e \\<lbrakk>tm\\<rbrakk>e\n     \\<lbrakk>y\\<rbrakk>e \\<lbrakk>y'\\<rbrakk>e\n 3. Sigma_fm (SubstAtomicP v tm y y')", "thus ?thesis1 ?thesis2 ?thsf"], ["proof (prove)\nusing this:\n  atom t \\<sharp> (v, tm, y, y', t', u, u')\n  atom t' \\<sharp> (v, tm, y, y', u, u')\n  atom u \\<sharp> (v, tm, y, y', u')\n  atom u' \\<sharp> (v, tm, y, y')\n\ngoal (1 subgoal):\n 1. a \\<sharp> SubstAtomicP v tm y y' =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> tm \\<and> a \\<sharp> y \\<and> a \\<sharp> y') &&&\n    eval_fm e (SubstAtomicP v tm y y') =\n    SubstAtomic \\<lbrakk>v\\<rbrakk>e \\<lbrakk>tm\\<rbrakk>e\n     \\<lbrakk>y\\<rbrakk>e \\<lbrakk>y'\\<rbrakk>e &&&\n    Sigma_fm (SubstAtomicP v tm y y')", "by (auto simp: SubstAtomic_def q_defs)"], ["proof (state)\nthis:\n  a \\<sharp> SubstAtomicP v tm y y' =\n  (a \\<sharp> v \\<and>\n   a \\<sharp> tm \\<and> a \\<sharp> y \\<and> a \\<sharp> y')\n  eval_fm e (SubstAtomicP v tm y y') =\n  SubstAtomic \\<lbrakk>v\\<rbrakk>e \\<lbrakk>tm\\<rbrakk>e\n   \\<lbrakk>y\\<rbrakk>e \\<lbrakk>y'\\<rbrakk>e\n  Sigma_fm (SubstAtomicP v tm y y')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SubstAtomicP_subst [simp]:\n  \"(SubstAtomicP v tm y y')(i::=w) = SubstAtomicP (subst i w v) (subst i w tm) (subst i w y) (subst i w y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SubstAtomicP v tm y y')(i::=w) =\n    SubstAtomicP (subst i w v) (subst i w tm) (subst i w y) (subst i w y')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (SubstAtomicP v tm y y')(i::=w) =\n    SubstAtomicP (subst i w v) (subst i w tm) (subst i w y) (subst i w y')", "obtain t::name and u::name and t'::name  and u'::name\n    where \"atom t \\<sharp> (v,tm,y,y',w,i,t',u,u')\" \"atom t' \\<sharp> (v,tm,y,y',w,i,u,u')\"\n          \"atom u \\<sharp> (v,tm,y,y',w,i,u')\" \"atom u' \\<sharp> (v,tm,y,y',w,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t t' u u'.\n        \\<lbrakk>atom t \\<sharp> (v, tm, y, y', w, i, t', u, u');\n         atom t' \\<sharp> (v, tm, y, y', w, i, u, u');\n         atom u \\<sharp> (v, tm, y, y', w, i, u');\n         atom u' \\<sharp> (v, tm, y, y', w, i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom t \\<sharp> (v, tm, y, y', w, i, t', u, u')\n  atom t' \\<sharp> (v, tm, y, y', w, i, u, u')\n  atom u \\<sharp> (v, tm, y, y', w, i, u')\n  atom u' \\<sharp> (v, tm, y, y', w, i)\n\ngoal (1 subgoal):\n 1. (SubstAtomicP v tm y y')(i::=w) =\n    SubstAtomicP (subst i w v) (subst i w tm) (subst i w y) (subst i w y')", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom t \\<sharp> (v, tm, y, y', w, i, t', u, u')\n  atom t' \\<sharp> (v, tm, y, y', w, i, u, u')\n  atom u \\<sharp> (v, tm, y, y', w, i, u')\n  atom u' \\<sharp> (v, tm, y, y', w, i)\n\ngoal (1 subgoal):\n 1. (SubstAtomicP v tm y y')(i::=w) =\n    SubstAtomicP (subst i w v) (subst i w tm) (subst i w y) (subst i w y')", "by (simp add: SubstAtomicP.simps [of t _ _ _ _ t' u u'])"], ["proof (state)\nthis:\n  (SubstAtomicP v tm y y')(i::=w) =\n  SubstAtomicP (subst i w v) (subst i w tm) (subst i w y) (subst i w y')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SubstAtomicP_cong:\n  \"\\<lbrakk>H \\<turnstile> v EQ v'; H \\<turnstile> tm EQ tm'; H \\<turnstile> x EQ x'; H \\<turnstile> y EQ y'\\<rbrakk>\n   \\<Longrightarrow> H \\<turnstile> SubstAtomicP v tm x y IFF SubstAtomicP v' tm' x' y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> v EQ v'; H \\<turnstile> tm EQ tm';\n     H \\<turnstile> x EQ x'; H \\<turnstile> y EQ y'\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile>\n                      SubstAtomicP v tm x y IFF SubstAtomicP v' tm' x' y'", "by (rule P4_cong) auto"], ["", "subsection \\<open>The predicate \\<open>SubstMakeForm\\<close>\\<close>"], ["", "definition SubstMakeForm :: \"hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> bool\"\n  where \"SubstMakeForm y y' u u' w w' \\<equiv>\n          ((y = q_Disj u w \\<and> y' = q_Disj u' w') \\<or>\n           (y = q_Neg u \\<and> y' = q_Neg u') \\<or>\n           (y = q_Ex u \\<and> y' = q_Ex u'))\""], ["", "definition SeqSubstForm :: \"hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> bool\"\n  where \"SeqSubstForm v u x x' s k \\<equiv> BuildSeq2 (SubstAtomic v u) SubstMakeForm s k x x'\""], ["", "nominal_function SeqSubstFormP :: \"tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> fm\"\n  where \"\\<lbrakk>atom l \\<sharp> (s,k,v,u,sl,sl',m,n,sm,sm',sn,sn');\n          atom sl \\<sharp> (s,v,u,sl',m,n,sm,sm',sn,sn');\n          atom sl' \\<sharp> (s,v,u,m,n,sm,sm',sn,sn');\n          atom m \\<sharp> (s,n,sm,sm',sn,sn'); atom n \\<sharp> (s,sm,sm',sn,sn');\n          atom sm \\<sharp> (s,sm',sn,sn'); atom sm' \\<sharp> (s,sn,sn');\n          atom sn \\<sharp> (s,sn'); atom sn' \\<sharp> s\\<rbrakk> \\<Longrightarrow>\n    SeqSubstFormP v u x x' s k =\n      LstSeqP s k (HPair x x') AND\n      All2 l (SUCC k) (Ex sl (Ex sl' (HPair (Var l) (HPair (Var sl) (Var sl')) IN s AND\n                (SubstAtomicP v u (Var sl) (Var sl') OR\n                Ex m (Ex n (Ex sm (Ex sm' (Ex sn (Ex sn' (Var m IN Var l AND Var n IN Var l AND\n                       HPair (Var m) (HPair (Var sm) (Var sm')) IN s AND\n                       HPair (Var n) (HPair (Var sn) (Var sn')) IN s AND\n                       ((Var sl EQ Q_Disj (Var sm) (Var sn) AND\n                        Var sl' EQ Q_Disj (Var sm') (Var sn')) OR\n                        (Var sl EQ Q_Neg (Var sm) AND Var sl' EQ Q_Neg (Var sm')) OR\n                        (Var sl EQ Q_Ex (Var sm) AND Var sl' EQ Q_Ex (Var sm')))))))))))))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt SeqSubstFormP_graph_aux\n 2. \\<And>x y. SeqSubstFormP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>l s k v u sl sl' m n sm sm' sn sn' xa x'.\n           \\<lbrakk>atom\n                     l \\<sharp> (s, k, v, u, sl, sl', m, n, sm, sm', sn,\n                                 sn');\n            atom sl \\<sharp> (s, v, u, sl', m, n, sm, sm', sn, sn');\n            atom sl' \\<sharp> (s, v, u, m, n, sm, sm', sn, sn');\n            atom m \\<sharp> (s, n, sm, sm', sn, sn');\n            atom n \\<sharp> (s, sm, sm', sn, sn');\n            atom sm \\<sharp> (s, sm', sn, sn');\n            atom sm' \\<sharp> (s, sn, sn'); atom sn \\<sharp> (s, sn');\n            atom sn' \\<sharp> s; x = (v, u, xa, x', s, k)\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>l s k v u sl sl' m n sm sm' sn sn' x x' la sa ka va ua sla sl'a ma\n       na sma sm'a sna sn'a xa x'a.\n       \\<lbrakk>atom\n                 l \\<sharp> (s, k, v, u, sl, sl', m, n, sm, sm', sn, sn');\n        atom sl \\<sharp> (s, v, u, sl', m, n, sm, sm', sn, sn');\n        atom sl' \\<sharp> (s, v, u, m, n, sm, sm', sn, sn');\n        atom m \\<sharp> (s, n, sm, sm', sn, sn');\n        atom n \\<sharp> (s, sm, sm', sn, sn');\n        atom sm \\<sharp> (s, sm', sn, sn'); atom sm' \\<sharp> (s, sn, sn');\n        atom sn \\<sharp> (s, sn'); atom sn' \\<sharp> s;\n        atom\n         la \\<sharp> (sa, ka, va, ua, sla, sl'a, ma, na, sma, sm'a, sna,\n                      sn'a);\n        atom sla \\<sharp> (sa, va, ua, sl'a, ma, na, sma, sm'a, sna, sn'a);\n        atom sl'a \\<sharp> (sa, va, ua, ma, na, sma, sm'a, sna, sn'a);\n        atom ma \\<sharp> (sa, na, sma, sm'a, sna, sn'a);\n        atom na \\<sharp> (sa, sma, sm'a, sna, sn'a);\n        atom sma \\<sharp> (sa, sm'a, sna, sn'a);\n        atom sm'a \\<sharp> (sa, sna, sn'a); atom sna \\<sharp> (sa, sn'a);\n        atom sn'a \\<sharp> sa;\n        (v, u, x, x', s, k) = (va, ua, xa, x'a, sa, ka)\\<rbrakk>\n       \\<Longrightarrow> LstSeqP s k (HPair x x') AND\n                         All2 l (SUCC k)\n                          (SyntaxN.Ex sl\n                            (SyntaxN.Ex sl'\n                              (HPair (Var l) (HPair (Var sl) (Var sl')) IN\n                               s AND\n                               (SubstAtomicP v u (Var sl) (Var sl') OR\n                                SyntaxN.Ex m\n                                 (SyntaxN.Ex n\n                                   (SyntaxN.Ex sm\n                                     (SyntaxN.Ex sm'\n (SyntaxN.Ex sn\n   (SyntaxN.Ex sn'\n     (Var m IN Var l AND\n      Var n IN Var l AND\n      HPair (Var m) (HPair (Var sm) (Var sm')) IN s AND\n      HPair (Var n) (HPair (Var sn) (Var sn')) IN s AND\n      (Var sl EQ Q_Disj (Var sm) (Var sn) AND\n       Var sl' EQ Q_Disj (Var sm') (Var sn') OR\n       Var sl EQ Q_Neg (Var sm) AND Var sl' EQ Q_Neg (Var sm') OR\n       Var sl EQ Q_Ex (Var sm) AND Var sl' EQ Q_Ex (Var sm')))))))))))) =\n                         LstSeqP sa ka (HPair xa x'a) AND\n                         All2 la (SUCC ka)\n                          (SyntaxN.Ex sla\n                            (SyntaxN.Ex sl'a\n                              (HPair (Var la)\n                                (HPair (Var sla) (Var sl'a)) IN\n                               sa AND\n                               (SubstAtomicP va ua (Var sla) (Var sl'a) OR\n                                SyntaxN.Ex ma\n                                 (SyntaxN.Ex na\n                                   (SyntaxN.Ex sma\n                                     (SyntaxN.Ex sm'a\n (SyntaxN.Ex sna\n   (SyntaxN.Ex sn'a\n     (Var ma IN Var la AND\n      Var na IN Var la AND\n      HPair (Var ma) (HPair (Var sma) (Var sm'a)) IN sa AND\n      HPair (Var na) (HPair (Var sna) (Var sn'a)) IN sa AND\n      (Var sla EQ Q_Disj (Var sma) (Var sna) AND\n       Var sl'a EQ Q_Disj (Var sm'a) (Var sn'a) OR\n       Var sla EQ Q_Neg (Var sma) AND Var sl'a EQ Q_Neg (Var sm'a) OR\n       Var sla EQ Q_Ex (Var sma) AND Var sl'a EQ Q_Ex (Var sm'a))))))))))))", "apply (simp_all add: eqvt_def SeqSubstFormP_graph_aux_def flip_fresh_fresh)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P x.\n       (\\<And>l s k v u sl sl' m n sm sm' sn sn' xa x'.\n           \\<lbrakk>atom\n                     l \\<sharp> (s, k, v, u, sl, sl', m, n, sm, sm', sn,\n                                 sn');\n            atom sl \\<sharp> (s, v, u, sl', m, n, sm, sm', sn, sn');\n            atom sl' \\<sharp> (s, v, u, m, n, sm, sm', sn, sn');\n            atom m \\<sharp> (s, n, sm, sm', sn, sn');\n            atom n \\<sharp> (s, sm, sm', sn, sn');\n            atom sm \\<sharp> (s, sm', sn, sn');\n            atom sm' \\<sharp> (s, sn, sn'); atom sn \\<sharp> (s, sn');\n            atom sn' \\<sharp> s; x = (v, u, xa, x', s, k)\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P", "by auto (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All SeqSubstFormP_dom", "by lexicographic_order"], ["", "lemma\n  shows SeqSubstFormP_fresh_iff [simp]:\n       \"a \\<sharp> SeqSubstFormP v u x x' s k \\<longleftrightarrow> a \\<sharp> v \\<and> a \\<sharp> u \\<and> a \\<sharp> x \\<and> a \\<sharp> x' \\<and> a \\<sharp> s \\<and> a \\<sharp> k\"  (is ?thesis1)\n    and eval_fm_SeqSubstFormP [simp]:\n       \"eval_fm e (SeqSubstFormP v u x x' s k) \\<longleftrightarrow> \n         SeqSubstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e \\<lbrakk>x\\<rbrakk>e \\<lbrakk>x'\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e\" (is ?thesis2)\n    and SeqSubstFormP_sf [iff]:\n       \"Sigma_fm (SeqSubstFormP v u x x' s k)\"  (is ?thsf)\n    and SeqSubstFormP_imp_OrdP:\n       \"{ SeqSubstFormP v u x x' s k } \\<turnstile> OrdP k\"  (is ?thOrd)\n    and SeqSubstFormP_imp_LstSeqP:\n       \"{ SeqSubstFormP v u x x' s k } \\<turnstile> LstSeqP s k (HPair x x')\"  (is ?thLstSeq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<sharp> SeqSubstFormP v u x x' s k =\n     (a \\<sharp> v \\<and>\n      a \\<sharp> u \\<and>\n      a \\<sharp> x \\<and>\n      a \\<sharp> x' \\<and> a \\<sharp> s \\<and> a \\<sharp> k) &&&\n     eval_fm e (SeqSubstFormP v u x x' s k) =\n     SeqSubstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e\n      \\<lbrakk>x\\<rbrakk>e \\<lbrakk>x'\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e\n      \\<lbrakk>k\\<rbrakk>e) &&&\n    Sigma_fm (SeqSubstFormP v u x x' s k) &&&\n    {SeqSubstFormP v u x x' s k} \\<turnstile> OrdP k &&&\n    {SeqSubstFormP v u x x' s k} \\<turnstile> LstSeqP s k (HPair x x')", "proof -"], ["proof (state)\ngoal (5 subgoals):\n 1. a \\<sharp> SeqSubstFormP v u x x' s k =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> u \\<and>\n     a \\<sharp> x \\<and>\n     a \\<sharp> x' \\<and> a \\<sharp> s \\<and> a \\<sharp> k)\n 2. eval_fm e (SeqSubstFormP v u x x' s k) =\n    SeqSubstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e\n     \\<lbrakk>x\\<rbrakk>e \\<lbrakk>x'\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e\n     \\<lbrakk>k\\<rbrakk>e\n 3. Sigma_fm (SeqSubstFormP v u x x' s k)\n 4. {SeqSubstFormP v u x x' s k} \\<turnstile> OrdP k\n 5. {SeqSubstFormP v u x x' s k} \\<turnstile> LstSeqP s k (HPair x x')", "obtain l::name and sl::name and sl'::name and m::name and n::name and\n         sm::name and sm'::name and sn::name and sn'::name\n    where atoms:\n         \"atom l \\<sharp> (s,k,v,u,sl,sl',m,n,sm,sm',sn,sn')\"\n         \"atom sl \\<sharp> (s,v,u,sl',m,n,sm,sm',sn,sn')\"\n         \"atom sl' \\<sharp> (s,v,u,m,n,sm,sm',sn,sn')\"\n         \"atom m \\<sharp> (s,n,sm,sm',sn,sn')\" \"atom n \\<sharp> (s,sm,sm',sn,sn')\"\n         \"atom sm \\<sharp> (s,sm',sn,sn')\" \"atom sm' \\<sharp> (s,sn,sn')\"\n         \"atom sn \\<sharp> (s,sn')\" \"atom sn' \\<sharp> (s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l sl sl' m n sm sm' sn sn'.\n        \\<lbrakk>atom\n                  l \\<sharp> (s, k, v, u, sl, sl', m, n, sm, sm', sn, sn');\n         atom sl \\<sharp> (s, v, u, sl', m, n, sm, sm', sn, sn');\n         atom sl' \\<sharp> (s, v, u, m, n, sm, sm', sn, sn');\n         atom m \\<sharp> (s, n, sm, sm', sn, sn');\n         atom n \\<sharp> (s, sm, sm', sn, sn');\n         atom sm \\<sharp> (s, sm', sn, sn'); atom sm' \\<sharp> (s, sn, sn');\n         atom sn \\<sharp> (s, sn'); atom sn' \\<sharp> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom l \\<sharp> (s, k, v, u, sl, sl', m, n, sm, sm', sn, sn')\n  atom sl \\<sharp> (s, v, u, sl', m, n, sm, sm', sn, sn')\n  atom sl' \\<sharp> (s, v, u, m, n, sm, sm', sn, sn')\n  atom m \\<sharp> (s, n, sm, sm', sn, sn')\n  atom n \\<sharp> (s, sm, sm', sn, sn')\n  atom sm \\<sharp> (s, sm', sn, sn')\n  atom sm' \\<sharp> (s, sn, sn')\n  atom sn \\<sharp> (s, sn')\n  atom sn' \\<sharp> s\n\ngoal (5 subgoals):\n 1. a \\<sharp> SeqSubstFormP v u x x' s k =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> u \\<and>\n     a \\<sharp> x \\<and>\n     a \\<sharp> x' \\<and> a \\<sharp> s \\<and> a \\<sharp> k)\n 2. eval_fm e (SeqSubstFormP v u x x' s k) =\n    SeqSubstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e\n     \\<lbrakk>x\\<rbrakk>e \\<lbrakk>x'\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e\n     \\<lbrakk>k\\<rbrakk>e\n 3. Sigma_fm (SeqSubstFormP v u x x' s k)\n 4. {SeqSubstFormP v u x x' s k} \\<turnstile> OrdP k\n 5. {SeqSubstFormP v u x x' s k} \\<turnstile> LstSeqP s k (HPair x x')", "thus ?thesis1 ?thsf ?thOrd ?thLstSeq"], ["proof (prove)\nusing this:\n  atom l \\<sharp> (s, k, v, u, sl, sl', m, n, sm, sm', sn, sn')\n  atom sl \\<sharp> (s, v, u, sl', m, n, sm, sm', sn, sn')\n  atom sl' \\<sharp> (s, v, u, m, n, sm, sm', sn, sn')\n  atom m \\<sharp> (s, n, sm, sm', sn, sn')\n  atom n \\<sharp> (s, sm, sm', sn, sn')\n  atom sm \\<sharp> (s, sm', sn, sn')\n  atom sm' \\<sharp> (s, sn, sn')\n  atom sn \\<sharp> (s, sn')\n  atom sn' \\<sharp> s\n\ngoal (1 subgoal):\n 1. (a \\<sharp> SeqSubstFormP v u x x' s k =\n     (a \\<sharp> v \\<and>\n      a \\<sharp> u \\<and>\n      a \\<sharp> x \\<and>\n      a \\<sharp> x' \\<and> a \\<sharp> s \\<and> a \\<sharp> k) &&&\n     Sigma_fm (SeqSubstFormP v u x x' s k)) &&&\n    {SeqSubstFormP v u x x' s k} \\<turnstile> OrdP k &&&\n    {SeqSubstFormP v u x x' s k} \\<turnstile> LstSeqP s k (HPair x x')", "by (auto intro: LstSeqP_OrdP)"], ["proof (state)\nthis:\n  a \\<sharp> SeqSubstFormP v u x x' s k =\n  (a \\<sharp> v \\<and>\n   a \\<sharp> u \\<and>\n   a \\<sharp> x \\<and>\n   a \\<sharp> x' \\<and> a \\<sharp> s \\<and> a \\<sharp> k)\n  Sigma_fm (SeqSubstFormP v u x x' s k)\n  {SeqSubstFormP v u x x' s k} \\<turnstile> OrdP k\n  {SeqSubstFormP v u x x' s k} \\<turnstile> LstSeqP s k (HPair x x')\n\ngoal (1 subgoal):\n 1. eval_fm e (SeqSubstFormP v u x x' s k) =\n    SeqSubstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e\n     \\<lbrakk>x\\<rbrakk>e \\<lbrakk>x'\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e\n     \\<lbrakk>k\\<rbrakk>e", "show ?thesis2"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_fm e (SeqSubstFormP v u x x' s k) =\n    SeqSubstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e\n     \\<lbrakk>x\\<rbrakk>e \\<lbrakk>x'\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e\n     \\<lbrakk>k\\<rbrakk>e", "using atoms"], ["proof (prove)\nusing this:\n  atom l \\<sharp> (s, k, v, u, sl, sl', m, n, sm, sm', sn, sn')\n  atom sl \\<sharp> (s, v, u, sl', m, n, sm, sm', sn, sn')\n  atom sl' \\<sharp> (s, v, u, m, n, sm, sm', sn, sn')\n  atom m \\<sharp> (s, n, sm, sm', sn, sn')\n  atom n \\<sharp> (s, sm, sm', sn, sn')\n  atom sm \\<sharp> (s, sm', sn, sn')\n  atom sm' \\<sharp> (s, sn, sn')\n  atom sn \\<sharp> (s, sn')\n  atom sn' \\<sharp> s\n\ngoal (1 subgoal):\n 1. eval_fm e (SeqSubstFormP v u x x' s k) =\n    SeqSubstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e\n     \\<lbrakk>x\\<rbrakk>e \\<lbrakk>x'\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e\n     \\<lbrakk>k\\<rbrakk>e", "unfolding SeqSubstForm_def BuildSeq2_def BuildSeq_def Builds_def\n                 HBall_def HBex_def q_defs SubstMakeForm_def"], ["proof (prove)\nusing this:\n  atom l \\<sharp> (s, k, v, u, sl, sl', m, n, sm, sm', sn, sn')\n  atom sl \\<sharp> (s, v, u, sl', m, n, sm, sm', sn, sn')\n  atom sl' \\<sharp> (s, v, u, m, n, sm, sm', sn, sn')\n  atom m \\<sharp> (s, n, sm, sm', sn, sn')\n  atom n \\<sharp> (s, sm, sm', sn, sn')\n  atom sm \\<sharp> (s, sm', sn, sn')\n  atom sm' \\<sharp> (s, sn, sn')\n  atom sn \\<sharp> (s, sn')\n  atom sn' \\<sharp> s\n\ngoal (1 subgoal):\n 1. eval_fm e (SeqSubstFormP v u x x' s k) =\n    (LstSeq \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e\n      \\<langle>\\<lbrakk>x\\<rbrakk>e, \\<lbrakk>x'\\<rbrakk>e\\<rangle> \\<and>\n     (\\<forall>x.\n         x \\<^bold>\\<in> succ \\<lbrakk>k\\<rbrakk>e \\<longrightarrow>\n         (\\<exists>xa x'.\n             app \\<lbrakk>s\\<rbrakk>e x = \\<langle>xa, x'\\<rangle> \\<and>\n             SubstAtomic \\<lbrakk>v\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e xa\n              x') \\<or>\n         (\\<exists>xa.\n             xa \\<^bold>\\<in> x \\<and>\n             (\\<exists>xb.\n                 xb \\<^bold>\\<in> x \\<and>\n                 (\\<exists>xc x' y y' z z'.\n                     app \\<lbrakk>s\\<rbrakk>e x =\n                     \\<langle>xc, x'\\<rangle> \\<and>\n                     app \\<lbrakk>s\\<rbrakk>e xa =\n                     \\<langle>y, y'\\<rangle> \\<and>\n                     app \\<lbrakk>s\\<rbrakk>e xb =\n                     \\<langle>z, z'\\<rangle> \\<and>\n                     (xc = \\<langle>htuple 3, y, z\\<rangle> \\<and>\n                      x' = \\<langle>htuple 3, y', z'\\<rangle> \\<or>\n                      xc = \\<langle>htuple 4, y\\<rangle> \\<and>\n                      x' = \\<langle>htuple 4, y'\\<rangle> \\<or>\n                      xc = \\<langle>htuple 5, y\\<rangle> \\<and>\n                      x' = \\<langle>htuple 5, y'\\<rangle>))))))", "by (force simp add: LstSeq_imp_Ord   Ord_trans [of _ _ \"succ \\<lbrakk>k\\<rbrakk>e\"]\n                 Seq_iff_app [of \"\\<lbrakk>s\\<rbrakk>e\", OF LstSeq_imp_Seq_succ]\n              intro!: conj_cong [OF refl]  all_cong)"], ["proof (state)\nthis:\n  eval_fm e (SeqSubstFormP v u x x' s k) =\n  SeqSubstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e\n   \\<lbrakk>x\\<rbrakk>e \\<lbrakk>x'\\<rbrakk>e \\<lbrakk>s\\<rbrakk>e\n   \\<lbrakk>k\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SeqSubstFormP_subst [simp]:\n      \"(SeqSubstFormP v u x x' s k)(i::=t) =\n       SeqSubstFormP (subst i t v) (subst i t u) (subst i t x) (subst i t x') (subst i t s) (subst i t k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SeqSubstFormP v u x x' s k)(i::=t) =\n    SeqSubstFormP (subst i t v) (subst i t u) (subst i t x) (subst i t x')\n     (subst i t s) (subst i t k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (SeqSubstFormP v u x x' s k)(i::=t) =\n    SeqSubstFormP (subst i t v) (subst i t u) (subst i t x) (subst i t x')\n     (subst i t s) (subst i t k)", "obtain l::name and sl::name and sl'::name and m::name and n::name and\n         sm::name and sm'::name and sn::name and sn'::name\n   where \"atom l \\<sharp> (s,k,v,u,t,i,sl,sl',m,n,sm,sm',sn,sn')\"\n         \"atom sl \\<sharp> (s,v,u,t,i,sl',m,n,sm,sm',sn,sn')\"\n         \"atom sl' \\<sharp> (s,v,u,t,i,m,n,sm,sm',sn,sn')\"\n         \"atom m \\<sharp> (s,t,i,n,sm,sm',sn,sn')\" \"atom n \\<sharp> (s,t,i,sm,sm',sn,sn')\"\n         \"atom sm \\<sharp> (s,t,i,sm',sn,sn')\" \"atom sm' \\<sharp> (s,t,i,sn,sn')\"\n         \"atom sn \\<sharp> (s,t,i,sn')\" \"atom sn' \\<sharp> (s,t,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l sl sl' m n sm sm' sn sn'.\n        \\<lbrakk>atom\n                  l \\<sharp> (s, k, v, u, t, i, sl, sl', m, n, sm, sm', sn,\n                              sn');\n         atom sl \\<sharp> (s, v, u, t, i, sl', m, n, sm, sm', sn, sn');\n         atom sl' \\<sharp> (s, v, u, t, i, m, n, sm, sm', sn, sn');\n         atom m \\<sharp> (s, t, i, n, sm, sm', sn, sn');\n         atom n \\<sharp> (s, t, i, sm, sm', sn, sn');\n         atom sm \\<sharp> (s, t, i, sm', sn, sn');\n         atom sm' \\<sharp> (s, t, i, sn, sn');\n         atom sn \\<sharp> (s, t, i, sn');\n         atom sn' \\<sharp> (s, t, i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom l \\<sharp> (s, k, v, u, t, i, sl, sl', m, n, sm, sm', sn, sn')\n  atom sl \\<sharp> (s, v, u, t, i, sl', m, n, sm, sm', sn, sn')\n  atom sl' \\<sharp> (s, v, u, t, i, m, n, sm, sm', sn, sn')\n  atom m \\<sharp> (s, t, i, n, sm, sm', sn, sn')\n  atom n \\<sharp> (s, t, i, sm, sm', sn, sn')\n  atom sm \\<sharp> (s, t, i, sm', sn, sn')\n  atom sm' \\<sharp> (s, t, i, sn, sn')\n  atom sn \\<sharp> (s, t, i, sn')\n  atom sn' \\<sharp> (s, t, i)\n\ngoal (1 subgoal):\n 1. (SeqSubstFormP v u x x' s k)(i::=t) =\n    SeqSubstFormP (subst i t v) (subst i t u) (subst i t x) (subst i t x')\n     (subst i t s) (subst i t k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom l \\<sharp> (s, k, v, u, t, i, sl, sl', m, n, sm, sm', sn, sn')\n  atom sl \\<sharp> (s, v, u, t, i, sl', m, n, sm, sm', sn, sn')\n  atom sl' \\<sharp> (s, v, u, t, i, m, n, sm, sm', sn, sn')\n  atom m \\<sharp> (s, t, i, n, sm, sm', sn, sn')\n  atom n \\<sharp> (s, t, i, sm, sm', sn, sn')\n  atom sm \\<sharp> (s, t, i, sm', sn, sn')\n  atom sm' \\<sharp> (s, t, i, sn, sn')\n  atom sn \\<sharp> (s, t, i, sn')\n  atom sn' \\<sharp> (s, t, i)\n\ngoal (1 subgoal):\n 1. (SeqSubstFormP v u x x' s k)(i::=t) =\n    SeqSubstFormP (subst i t v) (subst i t u) (subst i t x) (subst i t x')\n     (subst i t s) (subst i t k)", "by (force simp add: SeqSubstFormP.simps [of l _ _ _ _ sl sl' m n sm sm' sn sn'])"], ["proof (state)\nthis:\n  (SeqSubstFormP v u x x' s k)(i::=t) =\n  SeqSubstFormP (subst i t v) (subst i t u) (subst i t x) (subst i t x')\n   (subst i t s) (subst i t k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SeqSubstFormP_cong:\n  \"\\<lbrakk>H \\<turnstile> t EQ t'; H \\<turnstile> u EQ u'; H \\<turnstile> s EQ s'; H \\<turnstile> k EQ k'\\<rbrakk>\n   \\<Longrightarrow> H \\<turnstile> SeqSubstFormP v i t u s k IFF SeqSubstFormP v i t' u' s' k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> t EQ t'; H \\<turnstile> u EQ u';\n     H \\<turnstile> s EQ s'; H \\<turnstile> k EQ k'\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile>\n                      SeqSubstFormP v i t u s k IFF\n                      SeqSubstFormP v i t' u' s' k'", "by (rule P4_cong [where tms=\"[v,i]\"]) (auto simp: fresh_Cons)"], ["", "declare SeqSubstFormP.simps [simp del]"], ["", "subsection \\<open>Defining the syntax: the main SubstForm predicate\\<close>"], ["", "definition SubstForm :: \"hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> bool\"\nwhere \"SubstForm v u x x' \\<equiv> is_Var v \\<and> Term u \\<and> (\\<exists>s k. SeqSubstForm v u x x' s k)\""], ["", "nominal_function SubstFormP :: \"tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> fm\"\n  where \"\\<lbrakk>atom s \\<sharp> (v,i,x,x',k); atom k \\<sharp> (v,i,x,x')\\<rbrakk> \\<Longrightarrow>\n    SubstFormP v i x x' =\n      VarP v AND TermP i AND Ex s (Ex k (SeqSubstFormP v i x x' (Var s) (Var k)))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt SubstFormP_graph_aux\n 2. \\<And>x y. SubstFormP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>s v i xa x' k.\n           \\<lbrakk>atom s \\<sharp> (v, i, xa, x', k);\n            atom k \\<sharp> (v, i, xa, x'); x = (v, i, xa, x')\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>s v i x x' k sa va ia xa x'a ka.\n       \\<lbrakk>atom s \\<sharp> (v, i, x, x', k);\n        atom k \\<sharp> (v, i, x, x');\n        atom sa \\<sharp> (va, ia, xa, x'a, ka);\n        atom ka \\<sharp> (va, ia, xa, x'a);\n        (v, i, x, x') = (va, ia, xa, x'a)\\<rbrakk>\n       \\<Longrightarrow> VarP v AND\n                         TermP i AND\n                         SyntaxN.Ex s\n                          (SyntaxN.Ex k\n                            (SeqSubstFormP v i x x' (Var s) (Var k))) =\n                         VarP va AND\n                         TermP ia AND\n                         SyntaxN.Ex sa\n                          (SyntaxN.Ex ka\n                            (SeqSubstFormP va ia xa x'a (Var sa) (Var ka)))", "by (auto simp: eqvt_def SubstFormP_graph_aux_def flip_fresh_fresh) (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All SubstFormP_dom", "by lexicographic_order"], ["", "lemma\n  shows SubstFormP_fresh_iff [simp]:\n       \"a \\<sharp> SubstFormP v i x x' \\<longleftrightarrow> a \\<sharp> v \\<and> a \\<sharp> i \\<and> a \\<sharp> x \\<and> a \\<sharp> x'\"  (is ?thesis1)\n    and eval_fm_SubstFormP [simp]:\n       \"eval_fm e (SubstFormP v i x x') \\<longleftrightarrow> SubstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>x\\<rbrakk>e \\<lbrakk>x'\\<rbrakk>e\"  (is ?thesis2)\n    and SubstFormP_sf [iff]:\n       \"Sigma_fm (SubstFormP v i x x')\"  (is ?thsf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> SubstFormP v i x x' =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> i \\<and> a \\<sharp> x \\<and> a \\<sharp> x') &&&\n    eval_fm e (SubstFormP v i x x') =\n    SubstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>x\\<rbrakk>e\n     \\<lbrakk>x'\\<rbrakk>e &&&\n    Sigma_fm (SubstFormP v i x x')", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. a \\<sharp> SubstFormP v i x x' =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> i \\<and> a \\<sharp> x \\<and> a \\<sharp> x')\n 2. eval_fm e (SubstFormP v i x x') =\n    SubstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>x\\<rbrakk>e\n     \\<lbrakk>x'\\<rbrakk>e\n 3. Sigma_fm (SubstFormP v i x x')", "obtain s::name and k::name\n    where \"atom s \\<sharp> (v,i,x,x',k)\"  \"atom k \\<sharp> (v,i,x,x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s k.\n        \\<lbrakk>atom s \\<sharp> (v, i, x, x', k);\n         atom k \\<sharp> (v, i, x, x')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom s \\<sharp> (v, i, x, x', k)\n  atom k \\<sharp> (v, i, x, x')\n\ngoal (3 subgoals):\n 1. a \\<sharp> SubstFormP v i x x' =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> i \\<and> a \\<sharp> x \\<and> a \\<sharp> x')\n 2. eval_fm e (SubstFormP v i x x') =\n    SubstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>x\\<rbrakk>e\n     \\<lbrakk>x'\\<rbrakk>e\n 3. Sigma_fm (SubstFormP v i x x')", "thus ?thesis1 ?thesis2 ?thsf"], ["proof (prove)\nusing this:\n  atom s \\<sharp> (v, i, x, x', k)\n  atom k \\<sharp> (v, i, x, x')\n\ngoal (1 subgoal):\n 1. a \\<sharp> SubstFormP v i x x' =\n    (a \\<sharp> v \\<and>\n     a \\<sharp> i \\<and> a \\<sharp> x \\<and> a \\<sharp> x') &&&\n    eval_fm e (SubstFormP v i x x') =\n    SubstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>x\\<rbrakk>e\n     \\<lbrakk>x'\\<rbrakk>e &&&\n    Sigma_fm (SubstFormP v i x x')", "by (auto simp: SubstForm_def)"], ["proof (state)\nthis:\n  a \\<sharp> SubstFormP v i x x' =\n  (a \\<sharp> v \\<and>\n   a \\<sharp> i \\<and> a \\<sharp> x \\<and> a \\<sharp> x')\n  eval_fm e (SubstFormP v i x x') =\n  SubstForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>i\\<rbrakk>e \\<lbrakk>x\\<rbrakk>e\n   \\<lbrakk>x'\\<rbrakk>e\n  Sigma_fm (SubstFormP v i x x')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SubstFormP_subst [simp]:\n     \"(SubstFormP v i x x')(j::=t) = SubstFormP (subst j t v) (subst j t i) (subst j t x) (subst j t x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SubstFormP v i x x')(j::=t) =\n    SubstFormP (subst j t v) (subst j t i) (subst j t x) (subst j t x')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (SubstFormP v i x x')(j::=t) =\n    SubstFormP (subst j t v) (subst j t i) (subst j t x) (subst j t x')", "obtain s::name and k::name  where \"atom s \\<sharp> (v,i,x,x',t,j,k)\" \"atom k \\<sharp> (v,i,x,x',t,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s k.\n        \\<lbrakk>atom s \\<sharp> (v, i, x, x', t, j, k);\n         atom k \\<sharp> (v, i, x, x', t, j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom s \\<sharp> (v, i, x, x', t, j, k)\n  atom k \\<sharp> (v, i, x, x', t, j)\n\ngoal (1 subgoal):\n 1. (SubstFormP v i x x')(j::=t) =\n    SubstFormP (subst j t v) (subst j t i) (subst j t x) (subst j t x')", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom s \\<sharp> (v, i, x, x', t, j, k)\n  atom k \\<sharp> (v, i, x, x', t, j)\n\ngoal (1 subgoal):\n 1. (SubstFormP v i x x')(j::=t) =\n    SubstFormP (subst j t v) (subst j t i) (subst j t x) (subst j t x')", "by (auto simp: SubstFormP.simps [of s _ _ _ _ k])"], ["proof (state)\nthis:\n  (SubstFormP v i x x')(j::=t) =\n  SubstFormP (subst j t v) (subst j t i) (subst j t x) (subst j t x')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SubstFormP_cong:\n  \"\\<lbrakk>H \\<turnstile> v EQ v'; H \\<turnstile> i EQ i'; H \\<turnstile> t EQ t'; H \\<turnstile> u EQ u'\\<rbrakk>\n   \\<Longrightarrow> H \\<turnstile> SubstFormP v i t u IFF SubstFormP v' i' t' u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> v EQ v'; H \\<turnstile> i EQ i';\n     H \\<turnstile> t EQ t'; H \\<turnstile> u EQ u'\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile>\n                      SubstFormP v i t u IFF SubstFormP v' i' t' u'", "by (rule P4_cong) auto"], ["", "lemma ground_SubstFormP [simp]: \"ground_fm (SubstFormP v y x x') \\<longleftrightarrow> ground v \\<and> ground y \\<and> ground x \\<and> ground x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ground_fm (SubstFormP v y x x') =\n    (ground v \\<and> ground y \\<and> ground x \\<and> ground x')", "by (auto simp: ground_aux_def ground_fm_aux_def supp_conv_fresh)"], ["", "declare SubstFormP.simps [simp del]"], ["", "subsection \\<open>Correctness of substitution over formulas\\<close>"], ["", "lemma SubstForm_imp_subst_dbfm_lemma:\n  assumes \"SubstForm v \\<lbrakk>quot_dbtm u\\<rbrakk>e x x'\"\n    shows \"\\<exists>A. x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n               x' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n       x' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n       x' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e", "obtain s k where v: \"is_Var v\" and u: \"Term \\<lbrakk>quot_dbtm u\\<rbrakk>e\"\n               and sk: \"SeqSubstForm v \\<lbrakk>quot_dbtm u\\<rbrakk>e x x' s k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s k.\n        \\<lbrakk>is_Var v; Term \\<lbrakk>quot_dbtm u\\<rbrakk>e;\n         SeqSubstForm v \\<lbrakk>quot_dbtm u\\<rbrakk>e x x' s k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms [unfolded SubstForm_def]"], ["proof (prove)\nusing this:\n  is_Var v \\<and>\n  Term \\<lbrakk>quot_dbtm u\\<rbrakk>e \\<and>\n  (\\<exists>s k. SeqSubstForm v \\<lbrakk>quot_dbtm u\\<rbrakk>e x x' s k)\n\ngoal (1 subgoal):\n 1. (\\<And>s k.\n        \\<lbrakk>is_Var v; Term \\<lbrakk>quot_dbtm u\\<rbrakk>e;\n         SeqSubstForm v \\<lbrakk>quot_dbtm u\\<rbrakk>e x x' s k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  is_Var v\n  Term \\<lbrakk>quot_dbtm u\\<rbrakk>e\n  SeqSubstForm v \\<lbrakk>quot_dbtm u\\<rbrakk>e x x' s k\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n       x' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e", "from sk [unfolded SeqSubstForm_def]"], ["proof (chain)\npicking this:\n  BuildSeq2 (SubstAtomic v \\<lbrakk>quot_dbtm u\\<rbrakk>e) SubstMakeForm s k\n   x x'", "show ?thesis"], ["proof (prove)\nusing this:\n  BuildSeq2 (SubstAtomic v \\<lbrakk>quot_dbtm u\\<rbrakk>e) SubstMakeForm s k\n   x x'\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n       x' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e", "proof (induct x x' rule: BuildSeq2_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x x'.\n       SubstAtomic v \\<lbrakk>quot_dbtm u\\<rbrakk>e x x' \\<Longrightarrow>\n       \\<exists>A.\n          x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n          x' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\n 2. \\<And>x x' y y' z z'.\n       \\<lbrakk>SubstMakeForm x x' y y' z z';\n        \\<exists>A.\n           y = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n           y' =\n           \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n        \\<exists>A.\n           z = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n           z' =\n           \\<lbrakk>quot_dbfm\n                     (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n                            x' =\n                            \\<lbrakk>quot_dbfm\n(subst_dbfm u (decode_Var v) A)\\<rbrakk>e", "case (B x x')"], ["proof (state)\nthis:\n  SubstAtomic v \\<lbrakk>quot_dbtm u\\<rbrakk>e x x'\n\ngoal (2 subgoals):\n 1. \\<And>x x'.\n       SubstAtomic v \\<lbrakk>quot_dbtm u\\<rbrakk>e x x' \\<Longrightarrow>\n       \\<exists>A.\n          x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n          x' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\n 2. \\<And>x x' y y' z z'.\n       \\<lbrakk>SubstMakeForm x x' y y' z z';\n        \\<exists>A.\n           y = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n           y' =\n           \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n        \\<exists>A.\n           z = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n           z' =\n           \\<lbrakk>quot_dbfm\n                     (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n                            x' =\n                            \\<lbrakk>quot_dbfm\n(subst_dbfm u (decode_Var v) A)\\<rbrakk>e", "thus ?case"], ["proof (prove)\nusing this:\n  SubstAtomic v \\<lbrakk>quot_dbtm u\\<rbrakk>e x x'\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n       x' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e", "apply (auto simp: SubstAtomic_def elim!: SubstTerm_imp_subst_dbtm' [where e=e])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ta tb.\n       \\<lbrakk>x' =\n                q_Eq\n                 \\<lbrakk>quot_dbtm\n                           (subst_dbtm u (decode_Var v) ta)\\<rbrakk>e\n                 \\<lbrakk>quot_dbtm\n                           (subst_dbtm u (decode_Var v) tb)\\<rbrakk>e;\n        x =\n        q_Eq \\<lbrakk>quot_dbtm ta\\<rbrakk>e\n         \\<lbrakk>quot_dbtm tb\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Eq \\<lbrakk>quot_dbtm ta\\<rbrakk>e\n                             \\<lbrakk>quot_dbtm tb\\<rbrakk>e =\n                            \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n                            q_Eq\n                             \\<lbrakk>quot_dbtm\n (subst_dbtm u (decode_Var v) ta)\\<rbrakk>e\n                             \\<lbrakk>quot_dbtm\n (subst_dbtm u (decode_Var v) tb)\\<rbrakk>e =\n                            \\<lbrakk>quot_dbfm\n(subst_dbfm u (decode_Var v) A)\\<rbrakk>e\n 2. \\<And>ta tb.\n       \\<lbrakk>x' =\n                q_Mem\n                 \\<lbrakk>quot_dbtm\n                           (subst_dbtm u (decode_Var v) ta)\\<rbrakk>e\n                 \\<lbrakk>quot_dbtm\n                           (subst_dbtm u (decode_Var v) tb)\\<rbrakk>e;\n        x =\n        q_Mem \\<lbrakk>quot_dbtm ta\\<rbrakk>e\n         \\<lbrakk>quot_dbtm tb\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Mem \\<lbrakk>quot_dbtm ta\\<rbrakk>e\n                             \\<lbrakk>quot_dbtm tb\\<rbrakk>e =\n                            \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n                            q_Mem\n                             \\<lbrakk>quot_dbtm\n (subst_dbtm u (decode_Var v) ta)\\<rbrakk>e\n                             \\<lbrakk>quot_dbtm\n (subst_dbtm u (decode_Var v) tb)\\<rbrakk>e =\n                            \\<lbrakk>quot_dbfm\n(subst_dbfm u (decode_Var v) A)\\<rbrakk>e", "apply (rule_tac [1] x=\"DBEq ta tb\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ta tb.\n       \\<lbrakk>x' =\n                q_Eq\n                 \\<lbrakk>quot_dbtm\n                           (subst_dbtm u (decode_Var v) ta)\\<rbrakk>e\n                 \\<lbrakk>quot_dbtm\n                           (subst_dbtm u (decode_Var v) tb)\\<rbrakk>e;\n        x =\n        q_Eq \\<lbrakk>quot_dbtm ta\\<rbrakk>e\n         \\<lbrakk>quot_dbtm tb\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> q_Eq \\<lbrakk>quot_dbtm ta\\<rbrakk>e\n                          \\<lbrakk>quot_dbtm tb\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm (DBEq ta tb)\\<rbrakk>e \\<and>\n                         q_Eq\n                          \\<lbrakk>quot_dbtm\n                                    (subst_dbtm u (decode_Var v)\nta)\\<rbrakk>e\n                          \\<lbrakk>quot_dbtm\n                                    (subst_dbtm u (decode_Var v)\ntb)\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm\n                                   (subst_dbfm u (decode_Var v)\n                                     (DBEq ta tb))\\<rbrakk>e\n 2. \\<And>ta tb.\n       \\<lbrakk>x' =\n                q_Mem\n                 \\<lbrakk>quot_dbtm\n                           (subst_dbtm u (decode_Var v) ta)\\<rbrakk>e\n                 \\<lbrakk>quot_dbtm\n                           (subst_dbtm u (decode_Var v) tb)\\<rbrakk>e;\n        x =\n        q_Mem \\<lbrakk>quot_dbtm ta\\<rbrakk>e\n         \\<lbrakk>quot_dbtm tb\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Mem \\<lbrakk>quot_dbtm ta\\<rbrakk>e\n                             \\<lbrakk>quot_dbtm tb\\<rbrakk>e =\n                            \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n                            q_Mem\n                             \\<lbrakk>quot_dbtm\n (subst_dbtm u (decode_Var v) ta)\\<rbrakk>e\n                             \\<lbrakk>quot_dbtm\n (subst_dbtm u (decode_Var v) tb)\\<rbrakk>e =\n                            \\<lbrakk>quot_dbfm\n(subst_dbfm u (decode_Var v) A)\\<rbrakk>e", "apply (rule_tac [2] x=\"DBMem ta tb\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ta tb.\n       \\<lbrakk>x' =\n                q_Eq\n                 \\<lbrakk>quot_dbtm\n                           (subst_dbtm u (decode_Var v) ta)\\<rbrakk>e\n                 \\<lbrakk>quot_dbtm\n                           (subst_dbtm u (decode_Var v) tb)\\<rbrakk>e;\n        x =\n        q_Eq \\<lbrakk>quot_dbtm ta\\<rbrakk>e\n         \\<lbrakk>quot_dbtm tb\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> q_Eq \\<lbrakk>quot_dbtm ta\\<rbrakk>e\n                          \\<lbrakk>quot_dbtm tb\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm (DBEq ta tb)\\<rbrakk>e \\<and>\n                         q_Eq\n                          \\<lbrakk>quot_dbtm\n                                    (subst_dbtm u (decode_Var v)\nta)\\<rbrakk>e\n                          \\<lbrakk>quot_dbtm\n                                    (subst_dbtm u (decode_Var v)\ntb)\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm\n                                   (subst_dbfm u (decode_Var v)\n                                     (DBEq ta tb))\\<rbrakk>e\n 2. \\<And>ta tb.\n       \\<lbrakk>x' =\n                q_Mem\n                 \\<lbrakk>quot_dbtm\n                           (subst_dbtm u (decode_Var v) ta)\\<rbrakk>e\n                 \\<lbrakk>quot_dbtm\n                           (subst_dbtm u (decode_Var v) tb)\\<rbrakk>e;\n        x =\n        q_Mem \\<lbrakk>quot_dbtm ta\\<rbrakk>e\n         \\<lbrakk>quot_dbtm tb\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> q_Mem \\<lbrakk>quot_dbtm ta\\<rbrakk>e\n                          \\<lbrakk>quot_dbtm tb\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm (DBMem ta tb)\\<rbrakk>e \\<and>\n                         q_Mem\n                          \\<lbrakk>quot_dbtm\n                                    (subst_dbtm u (decode_Var v)\nta)\\<rbrakk>e\n                          \\<lbrakk>quot_dbtm\n                                    (subst_dbtm u (decode_Var v)\ntb)\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm\n                                   (subst_dbfm u (decode_Var v)\n                                     (DBMem ta tb))\\<rbrakk>e", "apply (auto simp: q_defs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>A.\n     x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     x' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>x x' y y' z z'.\n       \\<lbrakk>SubstMakeForm x x' y y' z z';\n        \\<exists>A.\n           y = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n           y' =\n           \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n        \\<exists>A.\n           z = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n           z' =\n           \\<lbrakk>quot_dbfm\n                     (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n                            x' =\n                            \\<lbrakk>quot_dbfm\n(subst_dbfm u (decode_Var v) A)\\<rbrakk>e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x' y y' z z'.\n       \\<lbrakk>SubstMakeForm x x' y y' z z';\n        \\<exists>A.\n           y = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n           y' =\n           \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n        \\<exists>A.\n           z = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n           z' =\n           \\<lbrakk>quot_dbfm\n                     (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n                            x' =\n                            \\<lbrakk>quot_dbfm\n(subst_dbfm u (decode_Var v) A)\\<rbrakk>e", "case (C x x' y y' z z')"], ["proof (state)\nthis:\n  SubstMakeForm x x' y y' z z'\n  \\<exists>A.\n     y = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     y' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\n  \\<exists>A.\n     z = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     z' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>x x' y y' z z'.\n       \\<lbrakk>SubstMakeForm x x' y y' z z';\n        \\<exists>A.\n           y = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n           y' =\n           \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n        \\<exists>A.\n           z = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n           z' =\n           \\<lbrakk>quot_dbfm\n                     (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n                            x' =\n                            \\<lbrakk>quot_dbfm\n(subst_dbfm u (decode_Var v) A)\\<rbrakk>e", "then"], ["proof (chain)\npicking this:\n  SubstMakeForm x x' y y' z z'\n  \\<exists>A.\n     y = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     y' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\n  \\<exists>A.\n     z = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     z' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e", "obtain A and B\n      where \"y = \\<lbrakk>quot_dbfm A\\<rbrakk>e\" \"y' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\"\n            \"z = \\<lbrakk>quot_dbfm B\\<rbrakk>e\" \"z' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) B)\\<rbrakk>e\""], ["proof (prove)\nusing this:\n  SubstMakeForm x x' y y' z z'\n  \\<exists>A.\n     y = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     y' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\n  \\<exists>A.\n     z = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     z' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>y = \\<lbrakk>quot_dbfm A\\<rbrakk>e;\n         y' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n         z = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n         z' =\n         \\<lbrakk>quot_dbfm\n                   (subst_dbfm u (decode_Var v) B)\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n  y' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\n  z = \\<lbrakk>quot_dbfm B\\<rbrakk>e\n  z' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) B)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>x x' y y' z z'.\n       \\<lbrakk>SubstMakeForm x x' y y' z z';\n        \\<exists>A.\n           y = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n           y' =\n           \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n        \\<exists>A.\n           z = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n           z' =\n           \\<lbrakk>quot_dbfm\n                     (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n                            x' =\n                            \\<lbrakk>quot_dbfm\n(subst_dbfm u (decode_Var v) A)\\<rbrakk>e", "with C.hyps"], ["proof (chain)\npicking this:\n  SubstMakeForm x x' y y' z z'\n  \\<exists>A.\n     y = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     y' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\n  \\<exists>A.\n     z = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     z' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\n  y = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n  y' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\n  z = \\<lbrakk>quot_dbfm B\\<rbrakk>e\n  z' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) B)\\<rbrakk>e", "show ?case"], ["proof (prove)\nusing this:\n  SubstMakeForm x x' y y' z z'\n  \\<exists>A.\n     y = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     y' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\n  \\<exists>A.\n     z = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     z' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\n  y = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n  y' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\n  z = \\<lbrakk>quot_dbfm B\\<rbrakk>e\n  z' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) B)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n       x' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e", "apply (auto simp: SubstMakeForm_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y = \\<lbrakk>quot_dbfm A\\<rbrakk>e;\n     y' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n     z = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n     z' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) B)\\<rbrakk>e;\n     x' =\n     q_Disj \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\n      \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) B)\\<rbrakk>e;\n     x =\n     q_Disj \\<lbrakk>quot_dbfm A\\<rbrakk>e\n      \\<lbrakk>quot_dbfm B\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Aa.\n                         q_Disj \\<lbrakk>quot_dbfm A\\<rbrakk>e\n                          \\<lbrakk>quot_dbfm B\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm Aa\\<rbrakk>e \\<and>\n                         q_Disj\n                          \\<lbrakk>quot_dbfm\n                                    (subst_dbfm u (decode_Var v)\nA)\\<rbrakk>e\n                          \\<lbrakk>quot_dbfm\n                                    (subst_dbfm u (decode_Var v)\nB)\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm\n                                   (subst_dbfm u (decode_Var v)\n                                     Aa)\\<rbrakk>e\n 2. \\<lbrakk>y = \\<lbrakk>quot_dbfm A\\<rbrakk>e;\n     y' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n     z = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n     z' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) B)\\<rbrakk>e;\n     x' =\n     q_Neg \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n     x = q_Neg \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Aa.\n                         q_Neg \\<lbrakk>quot_dbfm A\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm Aa\\<rbrakk>e \\<and>\n                         q_Neg\n                          \\<lbrakk>quot_dbfm\n                                    (subst_dbfm u (decode_Var v)\nA)\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm\n                                   (subst_dbfm u (decode_Var v)\n                                     Aa)\\<rbrakk>e\n 3. \\<lbrakk>y = \\<lbrakk>quot_dbfm A\\<rbrakk>e;\n     y' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n     z = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n     z' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) B)\\<rbrakk>e;\n     x' = q_Ex \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n     x = q_Ex \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Aa.\n                         q_Ex \\<lbrakk>quot_dbfm A\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm Aa\\<rbrakk>e \\<and>\n                         q_Ex\n                          \\<lbrakk>quot_dbfm\n                                    (subst_dbfm u (decode_Var v)\nA)\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm\n                                   (subst_dbfm u (decode_Var v)\n                                     Aa)\\<rbrakk>e", "apply (rule_tac [1] x=\"DBDisj A B\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y = \\<lbrakk>quot_dbfm A\\<rbrakk>e;\n     y' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n     z = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n     z' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) B)\\<rbrakk>e;\n     x' =\n     q_Disj \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\n      \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) B)\\<rbrakk>e;\n     x =\n     q_Disj \\<lbrakk>quot_dbfm A\\<rbrakk>e\n      \\<lbrakk>quot_dbfm B\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> q_Disj \\<lbrakk>quot_dbfm A\\<rbrakk>e\n                       \\<lbrakk>quot_dbfm B\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm (DBDisj A B)\\<rbrakk>e \\<and>\n                      q_Disj\n                       \\<lbrakk>quot_dbfm\n                                 (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\n                       \\<lbrakk>quot_dbfm\n                                 (subst_dbfm u (decode_Var v) B)\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm\n                                (subst_dbfm u (decode_Var v)\n                                  (DBDisj A B))\\<rbrakk>e\n 2. \\<lbrakk>y = \\<lbrakk>quot_dbfm A\\<rbrakk>e;\n     y' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n     z = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n     z' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) B)\\<rbrakk>e;\n     x' =\n     q_Neg \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n     x = q_Neg \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Aa.\n                         q_Neg \\<lbrakk>quot_dbfm A\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm Aa\\<rbrakk>e \\<and>\n                         q_Neg\n                          \\<lbrakk>quot_dbfm\n                                    (subst_dbfm u (decode_Var v)\nA)\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm\n                                   (subst_dbfm u (decode_Var v)\n                                     Aa)\\<rbrakk>e\n 3. \\<lbrakk>y = \\<lbrakk>quot_dbfm A\\<rbrakk>e;\n     y' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n     z = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n     z' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) B)\\<rbrakk>e;\n     x' = q_Ex \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n     x = q_Ex \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Aa.\n                         q_Ex \\<lbrakk>quot_dbfm A\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm Aa\\<rbrakk>e \\<and>\n                         q_Ex\n                          \\<lbrakk>quot_dbfm\n                                    (subst_dbfm u (decode_Var v)\nA)\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm\n                                   (subst_dbfm u (decode_Var v)\n                                     Aa)\\<rbrakk>e", "apply (rule_tac [2] x=\"DBNeg A\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y = \\<lbrakk>quot_dbfm A\\<rbrakk>e;\n     y' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n     z = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n     z' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) B)\\<rbrakk>e;\n     x' =\n     q_Disj \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\n      \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) B)\\<rbrakk>e;\n     x =\n     q_Disj \\<lbrakk>quot_dbfm A\\<rbrakk>e\n      \\<lbrakk>quot_dbfm B\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> q_Disj \\<lbrakk>quot_dbfm A\\<rbrakk>e\n                       \\<lbrakk>quot_dbfm B\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm (DBDisj A B)\\<rbrakk>e \\<and>\n                      q_Disj\n                       \\<lbrakk>quot_dbfm\n                                 (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\n                       \\<lbrakk>quot_dbfm\n                                 (subst_dbfm u (decode_Var v) B)\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm\n                                (subst_dbfm u (decode_Var v)\n                                  (DBDisj A B))\\<rbrakk>e\n 2. \\<lbrakk>y = \\<lbrakk>quot_dbfm A\\<rbrakk>e;\n     y' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n     z = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n     z' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) B)\\<rbrakk>e;\n     x' =\n     q_Neg \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n     x = q_Neg \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> q_Neg \\<lbrakk>quot_dbfm A\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e \\<and>\n                      q_Neg\n                       \\<lbrakk>quot_dbfm\n                                 (subst_dbfm u (decode_Var v) A)\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm\n                                (subst_dbfm u (decode_Var v)\n                                  (DBNeg A))\\<rbrakk>e\n 3. \\<lbrakk>y = \\<lbrakk>quot_dbfm A\\<rbrakk>e;\n     y' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n     z = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n     z' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) B)\\<rbrakk>e;\n     x' = q_Ex \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n     x = q_Ex \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Aa.\n                         q_Ex \\<lbrakk>quot_dbfm A\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm Aa\\<rbrakk>e \\<and>\n                         q_Ex\n                          \\<lbrakk>quot_dbfm\n                                    (subst_dbfm u (decode_Var v)\nA)\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm\n                                   (subst_dbfm u (decode_Var v)\n                                     Aa)\\<rbrakk>e", "apply (rule_tac [3] x=\"DBEx A\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y = \\<lbrakk>quot_dbfm A\\<rbrakk>e;\n     y' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n     z = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n     z' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) B)\\<rbrakk>e;\n     x' =\n     q_Disj \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\n      \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) B)\\<rbrakk>e;\n     x =\n     q_Disj \\<lbrakk>quot_dbfm A\\<rbrakk>e\n      \\<lbrakk>quot_dbfm B\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> q_Disj \\<lbrakk>quot_dbfm A\\<rbrakk>e\n                       \\<lbrakk>quot_dbfm B\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm (DBDisj A B)\\<rbrakk>e \\<and>\n                      q_Disj\n                       \\<lbrakk>quot_dbfm\n                                 (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\n                       \\<lbrakk>quot_dbfm\n                                 (subst_dbfm u (decode_Var v) B)\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm\n                                (subst_dbfm u (decode_Var v)\n                                  (DBDisj A B))\\<rbrakk>e\n 2. \\<lbrakk>y = \\<lbrakk>quot_dbfm A\\<rbrakk>e;\n     y' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n     z = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n     z' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) B)\\<rbrakk>e;\n     x' =\n     q_Neg \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n     x = q_Neg \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> q_Neg \\<lbrakk>quot_dbfm A\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e \\<and>\n                      q_Neg\n                       \\<lbrakk>quot_dbfm\n                                 (subst_dbfm u (decode_Var v) A)\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm\n                                (subst_dbfm u (decode_Var v)\n                                  (DBNeg A))\\<rbrakk>e\n 3. \\<lbrakk>y = \\<lbrakk>quot_dbfm A\\<rbrakk>e;\n     y' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n     z = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n     z' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) B)\\<rbrakk>e;\n     x' = q_Ex \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e;\n     x = q_Ex \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> q_Ex \\<lbrakk>quot_dbfm A\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm (DBEx A)\\<rbrakk>e \\<and>\n                      q_Ex\n                       \\<lbrakk>quot_dbfm\n                                 (subst_dbfm u (decode_Var v) A)\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm\n                                (subst_dbfm u (decode_Var v)\n                                  (DBEx A))\\<rbrakk>e", "apply (auto simp: C q_defs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>A.\n     x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     x' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>A.\n     x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     x' = \\<lbrakk>quot_dbfm (subst_dbfm u (decode_Var v) A)\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SubstForm_imp_subst_dbfm:\n  assumes \"SubstForm v u x x'\"\n   obtains t A where \"u = \\<lbrakk>quot_dbtm t\\<rbrakk>e\"\n                     \"x = \\<lbrakk>quot_dbfm A\\<rbrakk>e\"\n                     \"x' = \\<lbrakk>quot_dbfm (subst_dbfm t (decode_Var v) A)\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t A.\n        \\<lbrakk>u = \\<lbrakk>quot_dbtm t\\<rbrakk>e;\n         x = \\<lbrakk>quot_dbfm A\\<rbrakk>e;\n         x' =\n         \\<lbrakk>quot_dbfm\n                   (subst_dbfm t (decode_Var v) A)\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>t A.\n        \\<lbrakk>u = \\<lbrakk>quot_dbtm t\\<rbrakk>e;\n         x = \\<lbrakk>quot_dbfm A\\<rbrakk>e;\n         x' =\n         \\<lbrakk>quot_dbfm\n                   (subst_dbfm t (decode_Var v) A)\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain t where \"u = \\<lbrakk>quot_dbtm t\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        u = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms [unfolded SubstForm_def]"], ["proof (prove)\nusing this:\n  is_Var v \\<and> Term u \\<and> (\\<exists>s k. SeqSubstForm v u x x' s k)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        u = \\<lbrakk>quot_dbtm t\\<rbrakk>e \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis Term_imp_wf_dbtm)"], ["proof (state)\nthis:\n  u = \\<lbrakk>quot_dbtm t\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. (\\<And>t A.\n        \\<lbrakk>u = \\<lbrakk>quot_dbtm t\\<rbrakk>e;\n         x = \\<lbrakk>quot_dbfm A\\<rbrakk>e;\n         x' =\n         \\<lbrakk>quot_dbfm\n                   (subst_dbfm t (decode_Var v) A)\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  u = \\<lbrakk>quot_dbtm t\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. thesis", "by (metis SubstForm_imp_subst_dbfm_lemma assms that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SubstForm_subst_dbfm:\n  assumes u: \"wf_dbtm u\"\n  shows \"SubstForm (q_Var i) \\<lbrakk>quot_dbtm u\\<rbrakk>e \\<lbrakk>quot_dbfm A\\<rbrakk>e\n                             \\<lbrakk>quot_dbfm (subst_dbfm u i A)\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SubstForm (q_Var i) \\<lbrakk>quot_dbtm u\\<rbrakk>e\n     \\<lbrakk>quot_dbfm A\\<rbrakk>e\n     \\<lbrakk>quot_dbfm (subst_dbfm u i A)\\<rbrakk>e", "apply (induction A rule: dbfm.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       SubstForm (q_Var i) \\<lbrakk>quot_dbtm u\\<rbrakk>e\n        \\<lbrakk>quot_dbfm (DBMem x1 x2)\\<rbrakk>e\n        \\<lbrakk>quot_dbfm (subst_dbfm u i (DBMem x1 x2))\\<rbrakk>e\n 2. \\<And>x1 x2.\n       SubstForm (q_Var i) \\<lbrakk>quot_dbtm u\\<rbrakk>e\n        \\<lbrakk>quot_dbfm (DBEq x1 x2)\\<rbrakk>e\n        \\<lbrakk>quot_dbfm (subst_dbfm u i (DBEq x1 x2))\\<rbrakk>e\n 3. \\<And>x1 x2.\n       \\<lbrakk>SubstForm (q_Var i) \\<lbrakk>quot_dbtm u\\<rbrakk>e\n                 \\<lbrakk>quot_dbfm x1\\<rbrakk>e\n                 \\<lbrakk>quot_dbfm (subst_dbfm u i x1)\\<rbrakk>e;\n        SubstForm (q_Var i) \\<lbrakk>quot_dbtm u\\<rbrakk>e\n         \\<lbrakk>quot_dbfm x2\\<rbrakk>e\n         \\<lbrakk>quot_dbfm (subst_dbfm u i x2)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> SubstForm (q_Var i) \\<lbrakk>quot_dbtm u\\<rbrakk>e\n                          \\<lbrakk>quot_dbfm (DBDisj x1 x2)\\<rbrakk>e\n                          \\<lbrakk>quot_dbfm\n                                    (subst_dbfm u i\n(DBDisj x1 x2))\\<rbrakk>e\n 4. \\<And>x.\n       SubstForm (q_Var i) \\<lbrakk>quot_dbtm u\\<rbrakk>e\n        \\<lbrakk>quot_dbfm x\\<rbrakk>e\n        \\<lbrakk>quot_dbfm (subst_dbfm u i x)\\<rbrakk>e \\<Longrightarrow>\n       SubstForm (q_Var i) \\<lbrakk>quot_dbtm u\\<rbrakk>e\n        \\<lbrakk>quot_dbfm (DBNeg x)\\<rbrakk>e\n        \\<lbrakk>quot_dbfm (subst_dbfm u i (DBNeg x))\\<rbrakk>e\n 5. \\<And>x.\n       SubstForm (q_Var i) \\<lbrakk>quot_dbtm u\\<rbrakk>e\n        \\<lbrakk>quot_dbfm x\\<rbrakk>e\n        \\<lbrakk>quot_dbfm (subst_dbfm u i x)\\<rbrakk>e \\<Longrightarrow>\n       SubstForm (q_Var i) \\<lbrakk>quot_dbtm u\\<rbrakk>e\n        \\<lbrakk>quot_dbfm (DBEx x)\\<rbrakk>e\n        \\<lbrakk>quot_dbfm (subst_dbfm u i (DBEx x))\\<rbrakk>e", "apply (force simp: u SubstForm_def SeqSubstForm_def SubstAtomic_def SubstMakeForm_def \n                   SubstTerm_subst_dbtm q_defs simp del: q_Var_def\n           intro: BuildSeq2_exI BuildSeq2_combine)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary SubstForm_subst_dbfm_eq:\n  \"\\<lbrakk>v = q_Var i; Term ux; ux = \\<lbrakk>quot_dbtm u\\<rbrakk>e; A' = subst_dbfm u i A\\<rbrakk>\n   \\<Longrightarrow> SubstForm v ux \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<lbrakk>quot_dbfm A'\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v = q_Var i; Term ux; ux = \\<lbrakk>quot_dbtm u\\<rbrakk>e;\n     A' = subst_dbfm u i A\\<rbrakk>\n    \\<Longrightarrow> SubstForm v ux \\<lbrakk>quot_dbfm A\\<rbrakk>e\n                       \\<lbrakk>quot_dbfm A'\\<rbrakk>e", "by (metis SubstForm_subst_dbfm Term_imp_is_tm quot_dbtm_inject_lemma quot_tm_def wf_dbtm_iff_is_tm)"], ["", "section \\<open>The predicate \\<open>AtomicP\\<close>\\<close>"], ["", "definition Atomic :: \"hf \\<Rightarrow> bool\"\n  where \"Atomic y \\<equiv>\\<exists>t u. Term t \\<and> Term u \\<and> (y = q_Eq t u \\<or> y = q_Mem t u)\""], ["", "nominal_function AtomicP :: \"tm \\<Rightarrow> fm\"\n  where \"\\<lbrakk>atom t \\<sharp> (u,y); atom u \\<sharp> y\\<rbrakk> \\<Longrightarrow>\n    AtomicP y = Ex t (Ex u (TermP (Var t) AND TermP (Var u) AND\n                      (y EQ Q_Eq (Var t) (Var u) OR\n                       y EQ Q_Mem (Var t) (Var u))))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt AtomicP_graph_aux\n 2. \\<And>x y. AtomicP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>t u y.\n           \\<lbrakk>atom t \\<sharp> (u, y); atom u \\<sharp> y;\n            x = y\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>t u y ta ua ya.\n       \\<lbrakk>atom t \\<sharp> (u, y); atom u \\<sharp> y;\n        atom ta \\<sharp> (ua, ya); atom ua \\<sharp> ya; y = ya\\<rbrakk>\n       \\<Longrightarrow> SyntaxN.Ex t\n                          (SyntaxN.Ex u\n                            (TermP (Var t) AND\n                             TermP (Var u) AND\n                             (y EQ Q_Eq (Var t) (Var u) OR\n                              y EQ Q_Mem (Var t) (Var u)))) =\n                         SyntaxN.Ex ta\n                          (SyntaxN.Ex ua\n                            (TermP (Var ta) AND\n                             TermP (Var ua) AND\n                             (ya EQ Q_Eq (Var ta) (Var ua) OR\n                              ya EQ Q_Mem (Var ta) (Var ua))))", "by (auto simp: eqvt_def AtomicP_graph_aux_def flip_fresh_fresh) (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All AtomicP_dom", "by lexicographic_order"], ["", "lemma\n  shows AtomicP_fresh_iff [simp]: \"a \\<sharp> AtomicP y \\<longleftrightarrow> a \\<sharp> y\"    (is ?thesis1)\n    and eval_fm_AtomicP [simp]: \"eval_fm e (AtomicP y) \\<longleftrightarrow> Atomic\\<lbrakk>y\\<rbrakk>e\"    (is ?thesis2)\n    and AtomicP_sf [iff]: \"Sigma_fm (AtomicP y)\"  (is ?thsf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> AtomicP y = a \\<sharp> y &&&\n    eval_fm e (AtomicP y) = Atomic \\<lbrakk>y\\<rbrakk>e &&&\n    Sigma_fm (AtomicP y)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. a \\<sharp> AtomicP y = a \\<sharp> y\n 2. eval_fm e (AtomicP y) = Atomic \\<lbrakk>y\\<rbrakk>e\n 3. Sigma_fm (AtomicP y)", "obtain t::name and u::name  where \"atom t \\<sharp> (u,y)\"  \"atom u \\<sharp> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t u.\n        \\<lbrakk>atom t \\<sharp> (u, y); atom u \\<sharp> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom t \\<sharp> (u, y)\n  atom u \\<sharp> y\n\ngoal (3 subgoals):\n 1. a \\<sharp> AtomicP y = a \\<sharp> y\n 2. eval_fm e (AtomicP y) = Atomic \\<lbrakk>y\\<rbrakk>e\n 3. Sigma_fm (AtomicP y)", "thus ?thesis1 ?thesis2 ?thsf"], ["proof (prove)\nusing this:\n  atom t \\<sharp> (u, y)\n  atom u \\<sharp> y\n\ngoal (1 subgoal):\n 1. a \\<sharp> AtomicP y = a \\<sharp> y &&&\n    eval_fm e (AtomicP y) = Atomic \\<lbrakk>y\\<rbrakk>e &&&\n    Sigma_fm (AtomicP y)", "by (auto simp: Atomic_def q_defs)"], ["proof (state)\nthis:\n  a \\<sharp> AtomicP y = a \\<sharp> y\n  eval_fm e (AtomicP y) = Atomic \\<lbrakk>y\\<rbrakk>e\n  Sigma_fm (AtomicP y)\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>The predicate \\<open>MakeForm\\<close>\\<close>"], ["", "definition MakeForm :: \"hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> bool\"\n  where \"MakeForm y u w \\<equiv>\n         y = q_Disj u w \\<or> y = q_Neg u \\<or>\n         (\\<exists>v u'. AbstForm v 0 u u' \\<and> y = q_Ex u')\""], ["", "nominal_function MakeFormP :: \"tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> fm\"\n  where \"\\<lbrakk>atom v \\<sharp> (y,u,w,au); atom au \\<sharp> (y,u,w)\\<rbrakk> \\<Longrightarrow>\n    MakeFormP y u w =\n      y EQ Q_Disj u w OR y EQ Q_Neg u OR\n      Ex v (Ex au (AbstFormP (Var v) Zero u (Var au) AND y EQ Q_Ex (Var au)))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt MakeFormP_graph_aux\n 2. \\<And>x y. MakeFormP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>v y u w au.\n           \\<lbrakk>atom v \\<sharp> (y, u, w, au);\n            atom au \\<sharp> (y, u, w); x = (y, u, w)\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>v y u w au va ya ua wa aua.\n       \\<lbrakk>atom v \\<sharp> (y, u, w, au); atom au \\<sharp> (y, u, w);\n        atom va \\<sharp> (ya, ua, wa, aua); atom aua \\<sharp> (ya, ua, wa);\n        (y, u, w) = (ya, ua, wa)\\<rbrakk>\n       \\<Longrightarrow> y EQ Q_Disj u w OR\n                         y EQ Q_Neg u OR\n                         SyntaxN.Ex v\n                          (SyntaxN.Ex au\n                            (AbstFormP (Var v) Zero u (Var au) AND\n                             y EQ Q_Ex (Var au))) =\n                         ya EQ Q_Disj ua wa OR\n                         ya EQ Q_Neg ua OR\n                         SyntaxN.Ex va\n                          (SyntaxN.Ex aua\n                            (AbstFormP (Var va) Zero ua (Var aua) AND\n                             ya EQ Q_Ex (Var aua)))", "by (auto simp: eqvt_def MakeFormP_graph_aux_def flip_fresh_fresh) (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All MakeFormP_dom", "by lexicographic_order"], ["", "lemma\n  shows MakeFormP_fresh_iff [simp]:\n       \"a \\<sharp> MakeFormP y u w \\<longleftrightarrow> a \\<sharp> y \\<and> a \\<sharp> u \\<and> a \\<sharp> w\"  (is ?thesis1)\n    and eval_fm_MakeFormP [simp]:\n       \"eval_fm e (MakeFormP y u w) \\<longleftrightarrow> MakeForm \\<lbrakk>y\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e \\<lbrakk>w\\<rbrakk>e\"  (is ?thesis2)\n    and MakeFormP_sf [iff]:\n       \"Sigma_fm (MakeFormP y u w)\"  (is ?thsf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> MakeFormP y u w =\n    (a \\<sharp> y \\<and> a \\<sharp> u \\<and> a \\<sharp> w) &&&\n    eval_fm e (MakeFormP y u w) =\n    MakeForm \\<lbrakk>y\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e\n     \\<lbrakk>w\\<rbrakk>e &&&\n    Sigma_fm (MakeFormP y u w)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. a \\<sharp> MakeFormP y u w =\n    (a \\<sharp> y \\<and> a \\<sharp> u \\<and> a \\<sharp> w)\n 2. eval_fm e (MakeFormP y u w) =\n    MakeForm \\<lbrakk>y\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e \\<lbrakk>w\\<rbrakk>e\n 3. Sigma_fm (MakeFormP y u w)", "obtain v::name and au::name  where \"atom v \\<sharp> (y,u,w,au)\"  \"atom au \\<sharp> (y,u,w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v au.\n        \\<lbrakk>atom v \\<sharp> (y, u, w, au);\n         atom au \\<sharp> (y, u, w)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom v \\<sharp> (y, u, w, au)\n  atom au \\<sharp> (y, u, w)\n\ngoal (3 subgoals):\n 1. a \\<sharp> MakeFormP y u w =\n    (a \\<sharp> y \\<and> a \\<sharp> u \\<and> a \\<sharp> w)\n 2. eval_fm e (MakeFormP y u w) =\n    MakeForm \\<lbrakk>y\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e \\<lbrakk>w\\<rbrakk>e\n 3. Sigma_fm (MakeFormP y u w)", "thus ?thesis1 ?thesis2 ?thsf"], ["proof (prove)\nusing this:\n  atom v \\<sharp> (y, u, w, au)\n  atom au \\<sharp> (y, u, w)\n\ngoal (1 subgoal):\n 1. a \\<sharp> MakeFormP y u w =\n    (a \\<sharp> y \\<and> a \\<sharp> u \\<and> a \\<sharp> w) &&&\n    eval_fm e (MakeFormP y u w) =\n    MakeForm \\<lbrakk>y\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e\n     \\<lbrakk>w\\<rbrakk>e &&&\n    Sigma_fm (MakeFormP y u w)", "by (auto simp: MakeForm_def q_defs)"], ["proof (state)\nthis:\n  a \\<sharp> MakeFormP y u w =\n  (a \\<sharp> y \\<and> a \\<sharp> u \\<and> a \\<sharp> w)\n  eval_fm e (MakeFormP y u w) =\n  MakeForm \\<lbrakk>y\\<rbrakk>e \\<lbrakk>u\\<rbrakk>e \\<lbrakk>w\\<rbrakk>e\n  Sigma_fm (MakeFormP y u w)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare MakeFormP.simps [simp del]"], ["", "section \\<open>The predicate \\<open>SeqFormP\\<close>\\<close>"], ["", "(*SeqForm(s,k,t) \\<equiv> LstSeq(s,k,t) \\<and> (\\<forall>n\\<in>k)[Atomic (s n) \\<or> (\\<exists>m,l\\<in>n)[MakeForm (s m) (s l) (s n)]]*)"], ["", "definition SeqForm :: \"hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> bool\"\n  where \"SeqForm s k y \\<equiv> BuildSeq Atomic MakeForm s k y\""], ["", "nominal_function SeqFormP :: \"tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> fm\"\n  where \"\\<lbrakk>atom l \\<sharp> (s,k,t,sl,m,n,sm,sn); atom sl \\<sharp> (s,k,t,m,n,sm,sn);\n          atom m \\<sharp> (s,k,t,n,sm,sn); atom n \\<sharp> (s,k,t,sm,sn);\n          atom sm \\<sharp> (s,k,t,sn); atom sn \\<sharp> (s,k,t)\\<rbrakk> \\<Longrightarrow>\n    SeqFormP s k t =\n      LstSeqP s k t AND\n      All2 n (SUCC k) (Ex sn (HPair (Var n) (Var sn) IN s AND (AtomicP (Var sn) OR\n                Ex m (Ex l (Ex sm (Ex sl (Var m IN Var n AND Var l IN Var n AND\n                       HPair (Var m) (Var sm) IN s AND HPair (Var l) (Var sl) IN s AND\n                       MakeFormP (Var sn) (Var sm) (Var sl))))))))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt SeqFormP_graph_aux\n 2. \\<And>x y. SeqFormP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>l s k t sl m n sm sn.\n           \\<lbrakk>atom l \\<sharp> (s, k, t, sl, m, n, sm, sn);\n            atom sl \\<sharp> (s, k, t, m, n, sm, sn);\n            atom m \\<sharp> (s, k, t, n, sm, sn);\n            atom n \\<sharp> (s, k, t, sm, sn);\n            atom sm \\<sharp> (s, k, t, sn); atom sn \\<sharp> (s, k, t);\n            x = (s, k, t)\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>l s k t sl m n sm sn la sa ka ta sla ma na sma sna.\n       \\<lbrakk>atom l \\<sharp> (s, k, t, sl, m, n, sm, sn);\n        atom sl \\<sharp> (s, k, t, m, n, sm, sn);\n        atom m \\<sharp> (s, k, t, n, sm, sn);\n        atom n \\<sharp> (s, k, t, sm, sn); atom sm \\<sharp> (s, k, t, sn);\n        atom sn \\<sharp> (s, k, t);\n        atom la \\<sharp> (sa, ka, ta, sla, ma, na, sma, sna);\n        atom sla \\<sharp> (sa, ka, ta, ma, na, sma, sna);\n        atom ma \\<sharp> (sa, ka, ta, na, sma, sna);\n        atom na \\<sharp> (sa, ka, ta, sma, sna);\n        atom sma \\<sharp> (sa, ka, ta, sna); atom sna \\<sharp> (sa, ka, ta);\n        (s, k, t) = (sa, ka, ta)\\<rbrakk>\n       \\<Longrightarrow> LstSeqP s k t AND\n                         All2 n (SUCC k)\n                          (SyntaxN.Ex sn\n                            (HPair (Var n) (Var sn) IN s AND\n                             (AtomicP (Var sn) OR\n                              SyntaxN.Ex m\n                               (SyntaxN.Ex l\n                                 (SyntaxN.Ex sm\n                                   (SyntaxN.Ex sl\n                                     (Var m IN Var n AND\nVar l IN Var n AND\nHPair (Var m) (Var sm) IN s AND\nHPair (Var l) (Var sl) IN s AND\nMakeFormP (Var sn) (Var sm) (Var sl)))))))) =\n                         LstSeqP sa ka ta AND\n                         All2 na (SUCC ka)\n                          (SyntaxN.Ex sna\n                            (HPair (Var na) (Var sna) IN sa AND\n                             (AtomicP (Var sna) OR\n                              SyntaxN.Ex ma\n                               (SyntaxN.Ex la\n                                 (SyntaxN.Ex sma\n                                   (SyntaxN.Ex sla\n                                     (Var ma IN Var na AND\nVar la IN Var na AND\nHPair (Var ma) (Var sma) IN sa AND\nHPair (Var la) (Var sla) IN sa AND\nMakeFormP (Var sna) (Var sma) (Var sla))))))))", "by (auto simp: eqvt_def SeqFormP_graph_aux_def flip_fresh_fresh) (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All SeqFormP_dom", "by lexicographic_order"], ["", "lemma\n  shows SeqFormP_fresh_iff [simp]:\n       \"a \\<sharp> SeqFormP s k t \\<longleftrightarrow> a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> t\" (is ?thesis1)\n    and eval_fm_SeqFormP [simp]:\n       \"eval_fm e (SeqFormP s k t) \\<longleftrightarrow> SeqForm \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\"   (is ?thesis2)\n    and SeqFormP_sf [iff]: \"Sigma_fm (SeqFormP s k t)\"          (is ?thsf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> SeqFormP s k t =\n    (a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> t) &&&\n    eval_fm e (SeqFormP s k t) =\n    SeqForm \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e\n     \\<lbrakk>t\\<rbrakk>e &&&\n    Sigma_fm (SeqFormP s k t)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. a \\<sharp> SeqFormP s k t =\n    (a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> t)\n 2. eval_fm e (SeqFormP s k t) =\n    SeqForm \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\n 3. Sigma_fm (SeqFormP s k t)", "obtain l::name and sl::name and m::name and n::name and sm::name and sn::name\n    where atoms: \"atom l \\<sharp> (s,k,t,sl,m,n,sm,sn)\"   \"atom sl \\<sharp> (s,k,t,m,n,sm,sn)\"\n        \"atom m \\<sharp> (s,k,t,n,sm,sn)\"   \"atom n \\<sharp> (s,k,t,sm,sn)\"\n        \"atom sm \\<sharp> (s,k,t,sn)\"       \"atom sn \\<sharp> (s,k,t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l sl m n sm sn.\n        \\<lbrakk>atom l \\<sharp> (s, k, t, sl, m, n, sm, sn);\n         atom sl \\<sharp> (s, k, t, m, n, sm, sn);\n         atom m \\<sharp> (s, k, t, n, sm, sn);\n         atom n \\<sharp> (s, k, t, sm, sn); atom sm \\<sharp> (s, k, t, sn);\n         atom sn \\<sharp> (s, k, t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom l \\<sharp> (s, k, t, sl, m, n, sm, sn)\n  atom sl \\<sharp> (s, k, t, m, n, sm, sn)\n  atom m \\<sharp> (s, k, t, n, sm, sn)\n  atom n \\<sharp> (s, k, t, sm, sn)\n  atom sm \\<sharp> (s, k, t, sn)\n  atom sn \\<sharp> (s, k, t)\n\ngoal (3 subgoals):\n 1. a \\<sharp> SeqFormP s k t =\n    (a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> t)\n 2. eval_fm e (SeqFormP s k t) =\n    SeqForm \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\n 3. Sigma_fm (SeqFormP s k t)", "thus ?thesis1 ?thsf"], ["proof (prove)\nusing this:\n  atom l \\<sharp> (s, k, t, sl, m, n, sm, sn)\n  atom sl \\<sharp> (s, k, t, m, n, sm, sn)\n  atom m \\<sharp> (s, k, t, n, sm, sn)\n  atom n \\<sharp> (s, k, t, sm, sn)\n  atom sm \\<sharp> (s, k, t, sn)\n  atom sn \\<sharp> (s, k, t)\n\ngoal (1 subgoal):\n 1. a \\<sharp> SeqFormP s k t =\n    (a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> t) &&&\n    Sigma_fm (SeqFormP s k t)", "by auto"], ["proof (state)\nthis:\n  a \\<sharp> SeqFormP s k t =\n  (a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> t)\n  Sigma_fm (SeqFormP s k t)\n\ngoal (1 subgoal):\n 1. eval_fm e (SeqFormP s k t) =\n    SeqForm \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e", "show ?thesis2"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_fm e (SeqFormP s k t) =\n    SeqForm \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e", "using atoms"], ["proof (prove)\nusing this:\n  atom l \\<sharp> (s, k, t, sl, m, n, sm, sn)\n  atom sl \\<sharp> (s, k, t, m, n, sm, sn)\n  atom m \\<sharp> (s, k, t, n, sm, sn)\n  atom n \\<sharp> (s, k, t, sm, sn)\n  atom sm \\<sharp> (s, k, t, sn)\n  atom sn \\<sharp> (s, k, t)\n\ngoal (1 subgoal):\n 1. eval_fm e (SeqFormP s k t) =\n    SeqForm \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e", "by (simp cong: conj_cong add: LstSeq_imp_Ord SeqForm_def BuildSeq_def Builds_def\n             HBall_def HBex_def q_defs \n             Seq_iff_app [of \"\\<lbrakk>s\\<rbrakk>e\", OF LstSeq_imp_Seq_succ]\n             Ord_trans [of _ _ \"succ \\<lbrakk>k\\<rbrakk>e\"])"], ["proof (state)\nthis:\n  eval_fm e (SeqFormP s k t) =\n  SeqForm \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SeqFormP_subst [simp]:\n      \"(SeqFormP s k t)(j::=w) = SeqFormP (subst j w s) (subst j w k) (subst j w t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SeqFormP s k t)(j::=w) =\n    SeqFormP (subst j w s) (subst j w k) (subst j w t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (SeqFormP s k t)(j::=w) =\n    SeqFormP (subst j w s) (subst j w k) (subst j w t)", "obtain l::name and sl::name and m::name and n::name and sm::name and sn::name\n    where \"atom l \\<sharp> (j,w,s,t,k,sl,m,n,sm,sn)\"   \"atom sl \\<sharp> (j,w,s,k,t,m,n,sm,sn)\"\n        \"atom m \\<sharp> (j,w,s,k,t,n,sm,sn)\"   \"atom n \\<sharp> (j,w,s,k,t,sm,sn)\"\n        \"atom sm \\<sharp> (j,w,s,k,t,sn)\"   \"atom sn \\<sharp> (j,w,s,k,t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l sl m n sm sn.\n        \\<lbrakk>atom l \\<sharp> (j, w, s, t, k, sl, m, n, sm, sn);\n         atom sl \\<sharp> (j, w, s, k, t, m, n, sm, sn);\n         atom m \\<sharp> (j, w, s, k, t, n, sm, sn);\n         atom n \\<sharp> (j, w, s, k, t, sm, sn);\n         atom sm \\<sharp> (j, w, s, k, t, sn);\n         atom sn \\<sharp> (j, w, s, k, t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom l \\<sharp> (j, w, s, t, k, sl, m, n, sm, sn)\n  atom sl \\<sharp> (j, w, s, k, t, m, n, sm, sn)\n  atom m \\<sharp> (j, w, s, k, t, n, sm, sn)\n  atom n \\<sharp> (j, w, s, k, t, sm, sn)\n  atom sm \\<sharp> (j, w, s, k, t, sn)\n  atom sn \\<sharp> (j, w, s, k, t)\n\ngoal (1 subgoal):\n 1. (SeqFormP s k t)(j::=w) =\n    SeqFormP (subst j w s) (subst j w k) (subst j w t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom l \\<sharp> (j, w, s, t, k, sl, m, n, sm, sn)\n  atom sl \\<sharp> (j, w, s, k, t, m, n, sm, sn)\n  atom m \\<sharp> (j, w, s, k, t, n, sm, sn)\n  atom n \\<sharp> (j, w, s, k, t, sm, sn)\n  atom sm \\<sharp> (j, w, s, k, t, sn)\n  atom sn \\<sharp> (j, w, s, k, t)\n\ngoal (1 subgoal):\n 1. (SeqFormP s k t)(j::=w) =\n    SeqFormP (subst j w s) (subst j w k) (subst j w t)", "by (auto simp: SeqFormP.simps [of l _ _ _ sl m n sm sn])"], ["proof (state)\nthis:\n  (SeqFormP s k t)(j::=w) =\n  SeqFormP (subst j w s) (subst j w k) (subst j w t)\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>The predicate \\<open>FormP\\<close>\\<close>"], ["", "subsection \\<open>Definition\\<close>"], ["", "definition Form :: \"hf \\<Rightarrow> bool\"\n  where \"Form y \\<equiv> (\\<exists>s k. SeqForm s k y)\""], ["", "nominal_function FormP :: \"tm \\<Rightarrow> fm\"\n  where \"\\<lbrakk>atom k \\<sharp> (s,y); atom s \\<sharp> y\\<rbrakk> \\<Longrightarrow>\n    FormP y = Ex k (Ex s (SeqFormP (Var s) (Var k) y))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt FormP_graph_aux\n 2. \\<And>x y. FormP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>k s y.\n           \\<lbrakk>atom k \\<sharp> (s, y); atom s \\<sharp> y;\n            x = y\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>k s y ka sa ya.\n       \\<lbrakk>atom k \\<sharp> (s, y); atom s \\<sharp> y;\n        atom ka \\<sharp> (sa, ya); atom sa \\<sharp> ya; y = ya\\<rbrakk>\n       \\<Longrightarrow> SyntaxN.Ex k\n                          (SyntaxN.Ex s (SeqFormP (Var s) (Var k) y)) =\n                         SyntaxN.Ex ka\n                          (SyntaxN.Ex sa (SeqFormP (Var sa) (Var ka) ya))", "by (auto simp: eqvt_def FormP_graph_aux_def flip_fresh_fresh) (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All FormP_dom", "by lexicographic_order"], ["", "lemma\n  shows FormP_fresh_iff [simp]: \"a \\<sharp> FormP y \\<longleftrightarrow> a \\<sharp> y\"              (is ?thesis1)\n    and eval_fm_FormP [simp]:   \"eval_fm e (FormP y) \\<longleftrightarrow> Form \\<lbrakk>y\\<rbrakk>e\"  (is ?thesis2)\n    and FormP_sf [iff]:         \"Sigma_fm (FormP y)\"                 (is ?thsf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> FormP y = a \\<sharp> y &&&\n    eval_fm e (FormP y) = Form \\<lbrakk>y\\<rbrakk>e &&& Sigma_fm (FormP y)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. a \\<sharp> FormP y = a \\<sharp> y\n 2. eval_fm e (FormP y) = Form \\<lbrakk>y\\<rbrakk>e\n 3. Sigma_fm (FormP y)", "obtain k::name and s::name  where k: \"atom k \\<sharp> (s,y)\" \"atom s \\<sharp> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k s.\n        \\<lbrakk>atom k \\<sharp> (s, y); atom s \\<sharp> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom k \\<sharp> (s, y)\n  atom s \\<sharp> y\n\ngoal (3 subgoals):\n 1. a \\<sharp> FormP y = a \\<sharp> y\n 2. eval_fm e (FormP y) = Form \\<lbrakk>y\\<rbrakk>e\n 3. Sigma_fm (FormP y)", "thus ?thesis1 ?thesis2 ?thsf"], ["proof (prove)\nusing this:\n  atom k \\<sharp> (s, y)\n  atom s \\<sharp> y\n\ngoal (1 subgoal):\n 1. a \\<sharp> FormP y = a \\<sharp> y &&&\n    eval_fm e (FormP y) = Form \\<lbrakk>y\\<rbrakk>e &&& Sigma_fm (FormP y)", "by (auto simp: Form_def)"], ["proof (state)\nthis:\n  a \\<sharp> FormP y = a \\<sharp> y\n  eval_fm e (FormP y) = Form \\<lbrakk>y\\<rbrakk>e\n  Sigma_fm (FormP y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma FormP_subst [simp]: \"(FormP y)(j::=w) = FormP (subst j w y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (FormP y)(j::=w) = FormP (subst j w y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (FormP y)(j::=w) = FormP (subst j w y)", "obtain k::name and s::name where \"atom k \\<sharp> (s,j,w,y)\"  \"atom s \\<sharp> (j,w,y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k s.\n        \\<lbrakk>atom k \\<sharp> (s, j, w, y);\n         atom s \\<sharp> (j, w, y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom k \\<sharp> (s, j, w, y)\n  atom s \\<sharp> (j, w, y)\n\ngoal (1 subgoal):\n 1. (FormP y)(j::=w) = FormP (subst j w y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom k \\<sharp> (s, j, w, y)\n  atom s \\<sharp> (j, w, y)\n\ngoal (1 subgoal):\n 1. (FormP y)(j::=w) = FormP (subst j w y)", "by (auto simp: FormP.simps [of k s])"], ["proof (state)\nthis:\n  (FormP y)(j::=w) = FormP (subst j w y)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Correctness: It Corresponds to Quotations of Real Formulas\\<close>"], ["", "lemma AbstForm_trans_fm:\n  \"AbstForm (q_Var i) 0 \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AbstForm (q_Var i) 0\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n     \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e", "by (metis abst_trans_fm ord_of.simps(1) quot_fm_def AbstForm_abst_dbfm)"], ["", "corollary AbstForm_trans_fm_eq:\n  \"\\<lbrakk>x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk> e;  x' = \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e\\<rbrakk> \\<Longrightarrow> AbstForm (q_Var i) 0 x x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n     x' = \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> AbstForm (q_Var i) 0 x x'", "by (metis AbstForm_trans_fm)"], ["", "lemma wf_Form_quot_dbfm [simp]:\n  assumes \"wf_dbfm A\" shows \"Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Form \\<lbrakk>quot_dbfm A\\<rbrakk>e", "using assms"], ["proof (prove)\nusing this:\n  wf_dbfm A\n\ngoal (1 subgoal):\n 1. Form \\<lbrakk>quot_dbfm A\\<rbrakk>e", "proof (induct rule: wf_dbfm.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>wf_dbtm t1; wf_dbtm t2\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBMem t1 t2)\\<rbrakk>e\n 2. \\<And>t1 t2.\n       \\<lbrakk>wf_dbtm t1; wf_dbtm t2\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBEq t1 t2)\\<rbrakk>e\n 3. \\<And>A1 A2.\n       \\<lbrakk>wf_dbfm A1; Form \\<lbrakk>quot_dbfm A1\\<rbrakk>e;\n        wf_dbfm A2; Form \\<lbrakk>quot_dbfm A2\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBDisj A1 A2)\\<rbrakk>e\n 4. \\<And>A.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e\n 5. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form\n                          \\<lbrakk>quot_dbfm\n                                    (DBEx (abst_dbfm name 0 A))\\<rbrakk>e", "case (Mem tm1 tm2)"], ["proof (state)\nthis:\n  wf_dbtm tm1\n  wf_dbtm tm2\n\ngoal (5 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>wf_dbtm t1; wf_dbtm t2\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBMem t1 t2)\\<rbrakk>e\n 2. \\<And>t1 t2.\n       \\<lbrakk>wf_dbtm t1; wf_dbtm t2\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBEq t1 t2)\\<rbrakk>e\n 3. \\<And>A1 A2.\n       \\<lbrakk>wf_dbfm A1; Form \\<lbrakk>quot_dbfm A1\\<rbrakk>e;\n        wf_dbfm A2; Form \\<lbrakk>quot_dbfm A2\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBDisj A1 A2)\\<rbrakk>e\n 4. \\<And>A.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e\n 5. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form\n                          \\<lbrakk>quot_dbfm\n                                    (DBEx (abst_dbfm name 0 A))\\<rbrakk>e", "hence \"Atomic \\<lbrakk>quot_dbfm (DBMem tm1 tm2)\\<rbrakk>e\""], ["proof (prove)\nusing this:\n  wf_dbtm tm1\n  wf_dbtm tm2\n\ngoal (1 subgoal):\n 1. Atomic \\<lbrakk>quot_dbfm (DBMem tm1 tm2)\\<rbrakk>e", "by (auto simp: Atomic_def quot_Mem q_Mem_def dest: wf_Term_quot_dbtm)"], ["proof (state)\nthis:\n  Atomic \\<lbrakk>quot_dbfm (DBMem tm1 tm2)\\<rbrakk>e\n\ngoal (5 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>wf_dbtm t1; wf_dbtm t2\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBMem t1 t2)\\<rbrakk>e\n 2. \\<And>t1 t2.\n       \\<lbrakk>wf_dbtm t1; wf_dbtm t2\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBEq t1 t2)\\<rbrakk>e\n 3. \\<And>A1 A2.\n       \\<lbrakk>wf_dbfm A1; Form \\<lbrakk>quot_dbfm A1\\<rbrakk>e;\n        wf_dbfm A2; Form \\<lbrakk>quot_dbfm A2\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBDisj A1 A2)\\<rbrakk>e\n 4. \\<And>A.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e\n 5. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form\n                          \\<lbrakk>quot_dbfm\n                                    (DBEx (abst_dbfm name 0 A))\\<rbrakk>e", "thus ?case"], ["proof (prove)\nusing this:\n  Atomic \\<lbrakk>quot_dbfm (DBMem tm1 tm2)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. Form \\<lbrakk>quot_dbfm (DBMem tm1 tm2)\\<rbrakk>e", "by (auto simp: Form_def SeqForm_def BuildSeq_exI)"], ["proof (state)\nthis:\n  Form \\<lbrakk>quot_dbfm (DBMem tm1 tm2)\\<rbrakk>e\n\ngoal (4 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>wf_dbtm t1; wf_dbtm t2\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBEq t1 t2)\\<rbrakk>e\n 2. \\<And>A1 A2.\n       \\<lbrakk>wf_dbfm A1; Form \\<lbrakk>quot_dbfm A1\\<rbrakk>e;\n        wf_dbfm A2; Form \\<lbrakk>quot_dbfm A2\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBDisj A1 A2)\\<rbrakk>e\n 3. \\<And>A.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e\n 4. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form\n                          \\<lbrakk>quot_dbfm\n                                    (DBEx (abst_dbfm name 0 A))\\<rbrakk>e", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>wf_dbtm t1; wf_dbtm t2\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBEq t1 t2)\\<rbrakk>e\n 2. \\<And>A1 A2.\n       \\<lbrakk>wf_dbfm A1; Form \\<lbrakk>quot_dbfm A1\\<rbrakk>e;\n        wf_dbfm A2; Form \\<lbrakk>quot_dbfm A2\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBDisj A1 A2)\\<rbrakk>e\n 3. \\<And>A.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e\n 4. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form\n                          \\<lbrakk>quot_dbfm\n                                    (DBEx (abst_dbfm name 0 A))\\<rbrakk>e", "case (Eq tm1 tm2)"], ["proof (state)\nthis:\n  wf_dbtm tm1\n  wf_dbtm tm2\n\ngoal (4 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>wf_dbtm t1; wf_dbtm t2\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBEq t1 t2)\\<rbrakk>e\n 2. \\<And>A1 A2.\n       \\<lbrakk>wf_dbfm A1; Form \\<lbrakk>quot_dbfm A1\\<rbrakk>e;\n        wf_dbfm A2; Form \\<lbrakk>quot_dbfm A2\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBDisj A1 A2)\\<rbrakk>e\n 3. \\<And>A.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e\n 4. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form\n                          \\<lbrakk>quot_dbfm\n                                    (DBEx (abst_dbfm name 0 A))\\<rbrakk>e", "hence \"Atomic \\<lbrakk>quot_dbfm (DBEq tm1 tm2)\\<rbrakk>e\""], ["proof (prove)\nusing this:\n  wf_dbtm tm1\n  wf_dbtm tm2\n\ngoal (1 subgoal):\n 1. Atomic \\<lbrakk>quot_dbfm (DBEq tm1 tm2)\\<rbrakk>e", "by (auto simp: Atomic_def quot_Eq q_Eq_def dest: wf_Term_quot_dbtm)"], ["proof (state)\nthis:\n  Atomic \\<lbrakk>quot_dbfm (DBEq tm1 tm2)\\<rbrakk>e\n\ngoal (4 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>wf_dbtm t1; wf_dbtm t2\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBEq t1 t2)\\<rbrakk>e\n 2. \\<And>A1 A2.\n       \\<lbrakk>wf_dbfm A1; Form \\<lbrakk>quot_dbfm A1\\<rbrakk>e;\n        wf_dbfm A2; Form \\<lbrakk>quot_dbfm A2\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBDisj A1 A2)\\<rbrakk>e\n 3. \\<And>A.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e\n 4. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form\n                          \\<lbrakk>quot_dbfm\n                                    (DBEx (abst_dbfm name 0 A))\\<rbrakk>e", "thus ?case"], ["proof (prove)\nusing this:\n  Atomic \\<lbrakk>quot_dbfm (DBEq tm1 tm2)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. Form \\<lbrakk>quot_dbfm (DBEq tm1 tm2)\\<rbrakk>e", "by (auto simp: Form_def SeqForm_def BuildSeq_exI)"], ["proof (state)\nthis:\n  Form \\<lbrakk>quot_dbfm (DBEq tm1 tm2)\\<rbrakk>e\n\ngoal (3 subgoals):\n 1. \\<And>A1 A2.\n       \\<lbrakk>wf_dbfm A1; Form \\<lbrakk>quot_dbfm A1\\<rbrakk>e;\n        wf_dbfm A2; Form \\<lbrakk>quot_dbfm A2\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBDisj A1 A2)\\<rbrakk>e\n 2. \\<And>A.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e\n 3. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form\n                          \\<lbrakk>quot_dbfm\n                                    (DBEx (abst_dbfm name 0 A))\\<rbrakk>e", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A1 A2.\n       \\<lbrakk>wf_dbfm A1; Form \\<lbrakk>quot_dbfm A1\\<rbrakk>e;\n        wf_dbfm A2; Form \\<lbrakk>quot_dbfm A2\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBDisj A1 A2)\\<rbrakk>e\n 2. \\<And>A.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e\n 3. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form\n                          \\<lbrakk>quot_dbfm\n                                    (DBEx (abst_dbfm name 0 A))\\<rbrakk>e", "case (Disj A1 A2)"], ["proof (state)\nthis:\n  wf_dbfm A1\n  Form \\<lbrakk>quot_dbfm A1\\<rbrakk>e\n  wf_dbfm A2\n  Form \\<lbrakk>quot_dbfm A2\\<rbrakk>e\n\ngoal (3 subgoals):\n 1. \\<And>A1 A2.\n       \\<lbrakk>wf_dbfm A1; Form \\<lbrakk>quot_dbfm A1\\<rbrakk>e;\n        wf_dbfm A2; Form \\<lbrakk>quot_dbfm A2\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBDisj A1 A2)\\<rbrakk>e\n 2. \\<And>A.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e\n 3. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form\n                          \\<lbrakk>quot_dbfm\n                                    (DBEx (abst_dbfm name 0 A))\\<rbrakk>e", "have \"MakeForm \\<lbrakk>quot_dbfm (DBDisj A1 A2)\\<rbrakk>e \\<lbrakk>quot_dbfm A1\\<rbrakk>e \\<lbrakk>quot_dbfm A2\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MakeForm \\<lbrakk>quot_dbfm (DBDisj A1 A2)\\<rbrakk>e\n     \\<lbrakk>quot_dbfm A1\\<rbrakk>e \\<lbrakk>quot_dbfm A2\\<rbrakk>e", "by (simp add: quot_Disj q_Disj_def MakeForm_def)"], ["proof (state)\nthis:\n  MakeForm \\<lbrakk>quot_dbfm (DBDisj A1 A2)\\<rbrakk>e\n   \\<lbrakk>quot_dbfm A1\\<rbrakk>e \\<lbrakk>quot_dbfm A2\\<rbrakk>e\n\ngoal (3 subgoals):\n 1. \\<And>A1 A2.\n       \\<lbrakk>wf_dbfm A1; Form \\<lbrakk>quot_dbfm A1\\<rbrakk>e;\n        wf_dbfm A2; Form \\<lbrakk>quot_dbfm A2\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBDisj A1 A2)\\<rbrakk>e\n 2. \\<And>A.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e\n 3. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form\n                          \\<lbrakk>quot_dbfm\n                                    (DBEx (abst_dbfm name 0 A))\\<rbrakk>e", "thus ?case"], ["proof (prove)\nusing this:\n  MakeForm \\<lbrakk>quot_dbfm (DBDisj A1 A2)\\<rbrakk>e\n   \\<lbrakk>quot_dbfm A1\\<rbrakk>e \\<lbrakk>quot_dbfm A2\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. Form \\<lbrakk>quot_dbfm (DBDisj A1 A2)\\<rbrakk>e", "using Disj"], ["proof (prove)\nusing this:\n  MakeForm \\<lbrakk>quot_dbfm (DBDisj A1 A2)\\<rbrakk>e\n   \\<lbrakk>quot_dbfm A1\\<rbrakk>e \\<lbrakk>quot_dbfm A2\\<rbrakk>e\n  wf_dbfm A1\n  Form \\<lbrakk>quot_dbfm A1\\<rbrakk>e\n  wf_dbfm A2\n  Form \\<lbrakk>quot_dbfm A2\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. Form \\<lbrakk>quot_dbfm (DBDisj A1 A2)\\<rbrakk>e", "by (force simp add: Form_def SeqForm_def intro: BuildSeq_combine)"], ["proof (state)\nthis:\n  Form \\<lbrakk>quot_dbfm (DBDisj A1 A2)\\<rbrakk>e\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e\n 2. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form\n                          \\<lbrakk>quot_dbfm\n                                    (DBEx (abst_dbfm name 0 A))\\<rbrakk>e", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e\n 2. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form\n                          \\<lbrakk>quot_dbfm\n                                    (DBEx (abst_dbfm name 0 A))\\<rbrakk>e", "case (Neg A)"], ["proof (state)\nthis:\n  wf_dbfm A\n  Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e\n 2. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form\n                          \\<lbrakk>quot_dbfm\n                                    (DBEx (abst_dbfm name 0 A))\\<rbrakk>e", "have \"\\<And>y. MakeForm \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e \\<lbrakk>quot_dbfm A\\<rbrakk>e y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       MakeForm \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e\n        \\<lbrakk>quot_dbfm A\\<rbrakk>e y", "by (simp add: quot_Neg q_Neg_def MakeForm_def)"], ["proof (state)\nthis:\n  MakeForm \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e\n   \\<lbrakk>quot_dbfm A\\<rbrakk>e ?y\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e\n 2. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form\n                          \\<lbrakk>quot_dbfm\n                                    (DBEx (abst_dbfm name 0 A))\\<rbrakk>e", "thus ?case"], ["proof (prove)\nusing this:\n  MakeForm \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e\n   \\<lbrakk>quot_dbfm A\\<rbrakk>e ?y\n\ngoal (1 subgoal):\n 1. Form \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e", "using Neg"], ["proof (prove)\nusing this:\n  MakeForm \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e\n   \\<lbrakk>quot_dbfm A\\<rbrakk>e ?y\n  wf_dbfm A\n  Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. Form \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e", "by (force simp add: Form_def SeqForm_def intro: BuildSeq_combine)"], ["proof (state)\nthis:\n  Form \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form\n                          \\<lbrakk>quot_dbfm\n                                    (DBEx (abst_dbfm name 0 A))\\<rbrakk>e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form\n                          \\<lbrakk>quot_dbfm\n                                    (DBEx (abst_dbfm name 0 A))\\<rbrakk>e", "case (Ex A i)"], ["proof (state)\nthis:\n  wf_dbfm A\n  Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form\n                          \\<lbrakk>quot_dbfm\n                                    (DBEx (abst_dbfm name 0 A))\\<rbrakk>e", "have \"\\<And>A y. MakeForm \\<lbrakk>quot_dbfm (DBEx (abst_dbfm i 0 A))\\<rbrakk>e \\<lbrakk>quot_dbfm A\\<rbrakk>e y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A y.\n       MakeForm \\<lbrakk>quot_dbfm (DBEx (abst_dbfm i 0 A))\\<rbrakk>e\n        \\<lbrakk>quot_dbfm A\\<rbrakk>e y", "by (simp add: quot_Ex q_defs MakeForm_def) (metis AbstForm_abst_dbfm ord_of.simps(1))"], ["proof (state)\nthis:\n  MakeForm \\<lbrakk>quot_dbfm (DBEx (abst_dbfm i 0 ?A))\\<rbrakk>e\n   \\<lbrakk>quot_dbfm ?A\\<rbrakk>e ?y\n\ngoal (1 subgoal):\n 1. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> Form\n                          \\<lbrakk>quot_dbfm\n                                    (DBEx (abst_dbfm name 0 A))\\<rbrakk>e", "thus ?case"], ["proof (prove)\nusing this:\n  MakeForm \\<lbrakk>quot_dbfm (DBEx (abst_dbfm i 0 ?A))\\<rbrakk>e\n   \\<lbrakk>quot_dbfm ?A\\<rbrakk>e ?y\n\ngoal (1 subgoal):\n 1. Form \\<lbrakk>quot_dbfm (DBEx (abst_dbfm i 0 A))\\<rbrakk>e", "using Ex"], ["proof (prove)\nusing this:\n  MakeForm \\<lbrakk>quot_dbfm (DBEx (abst_dbfm i 0 ?A))\\<rbrakk>e\n   \\<lbrakk>quot_dbfm ?A\\<rbrakk>e ?y\n  wf_dbfm A\n  Form \\<lbrakk>quot_dbfm A\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. Form \\<lbrakk>quot_dbfm (DBEx (abst_dbfm i 0 A))\\<rbrakk>e", "by (force simp add: Form_def SeqForm_def intro: BuildSeq_combine)"], ["proof (state)\nthis:\n  Form \\<lbrakk>quot_dbfm (DBEx (abst_dbfm i 0 A))\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Form_quot_fm [iff]: fixes A :: fm  shows \"Form \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Form \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e", "by (metis quot_fm_def wf_Form_quot_dbfm wf_dbfm_trans_fm)"], ["", "lemma Atomic_Form_is_wf_dbfm: \"Atomic x \\<Longrightarrow> \\<exists>A. wf_dbfm A \\<and> x = \\<lbrakk>quot_dbfm A\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Atomic x \\<Longrightarrow>\n    \\<exists>A. wf_dbfm A \\<and> x = \\<lbrakk>quot_dbfm A\\<rbrakk>e", "proof (auto simp: Atomic_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t u.\n       \\<lbrakk>Term t; Term u; x = q_Eq t u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            wf_dbfm A \\<and>\n                            q_Eq t u = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n 2. \\<And>t u.\n       \\<lbrakk>Term t; Term u; x = q_Mem t u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            wf_dbfm A \\<and>\n                            q_Mem t u = \\<lbrakk>quot_dbfm A\\<rbrakk>e", "fix t u"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t u.\n       \\<lbrakk>Term t; Term u; x = q_Eq t u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            wf_dbfm A \\<and>\n                            q_Eq t u = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n 2. \\<And>t u.\n       \\<lbrakk>Term t; Term u; x = q_Mem t u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            wf_dbfm A \\<and>\n                            q_Mem t u = \\<lbrakk>quot_dbfm A\\<rbrakk>e", "assume t: \"Term t\" and  u: \"Term u\""], ["proof (state)\nthis:\n  Term t\n  Term u\n\ngoal (2 subgoals):\n 1. \\<And>t u.\n       \\<lbrakk>Term t; Term u; x = q_Eq t u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            wf_dbfm A \\<and>\n                            q_Eq t u = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n 2. \\<And>t u.\n       \\<lbrakk>Term t; Term u; x = q_Mem t u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            wf_dbfm A \\<and>\n                            q_Mem t u = \\<lbrakk>quot_dbfm A\\<rbrakk>e", "then"], ["proof (chain)\npicking this:\n  Term t\n  Term u", "obtain tm1 and tm2\n    where tm1: \"wf_dbtm tm1\" \"t = \\<lbrakk>quot_dbtm tm1\\<rbrakk>e\"\n      and tm2: \"wf_dbtm tm2\" \"u = \\<lbrakk>quot_dbtm tm2\\<rbrakk>e\""], ["proof (prove)\nusing this:\n  Term t\n  Term u\n\ngoal (1 subgoal):\n 1. (\\<And>tm1 tm2.\n        \\<lbrakk>wf_dbtm tm1; t = \\<lbrakk>quot_dbtm tm1\\<rbrakk>e;\n         wf_dbtm tm2; u = \\<lbrakk>quot_dbtm tm2\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Term_imp_is_tm quot_tm_def wf_dbtm_trans_tm)+"], ["proof (state)\nthis:\n  wf_dbtm tm1\n  t = \\<lbrakk>quot_dbtm tm1\\<rbrakk>e\n  wf_dbtm tm2\n  u = \\<lbrakk>quot_dbtm tm2\\<rbrakk>e\n\ngoal (2 subgoals):\n 1. \\<And>t u.\n       \\<lbrakk>Term t; Term u; x = q_Eq t u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            wf_dbfm A \\<and>\n                            q_Eq t u = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n 2. \\<And>t u.\n       \\<lbrakk>Term t; Term u; x = q_Mem t u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            wf_dbfm A \\<and>\n                            q_Mem t u = \\<lbrakk>quot_dbfm A\\<rbrakk>e", "thus \"\\<exists>A. wf_dbfm A \\<and> q_Eq t u = \\<lbrakk>quot_dbfm A\\<rbrakk>e\""], ["proof (prove)\nusing this:\n  wf_dbtm tm1\n  t = \\<lbrakk>quot_dbtm tm1\\<rbrakk>e\n  wf_dbtm tm2\n  u = \\<lbrakk>quot_dbtm tm2\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<exists>A. wf_dbfm A \\<and> q_Eq t u = \\<lbrakk>quot_dbfm A\\<rbrakk>e", "by (auto simp: quot_Eq q_Eq_def)"], ["proof (state)\nthis:\n  \\<exists>A. wf_dbfm A \\<and> q_Eq t u = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>t u.\n       \\<lbrakk>Term t; Term u; x = q_Mem t u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            wf_dbfm A \\<and>\n                            q_Mem t u = \\<lbrakk>quot_dbfm A\\<rbrakk>e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t u.\n       \\<lbrakk>Term t; Term u; x = q_Mem t u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            wf_dbfm A \\<and>\n                            q_Mem t u = \\<lbrakk>quot_dbfm A\\<rbrakk>e", "fix t u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t u.\n       \\<lbrakk>Term t; Term u; x = q_Mem t u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            wf_dbfm A \\<and>\n                            q_Mem t u = \\<lbrakk>quot_dbfm A\\<rbrakk>e", "assume t: \"Term t\" and  u: \"Term u\""], ["proof (state)\nthis:\n  Term t\n  Term u\n\ngoal (1 subgoal):\n 1. \\<And>t u.\n       \\<lbrakk>Term t; Term u; x = q_Mem t u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            wf_dbfm A \\<and>\n                            q_Mem t u = \\<lbrakk>quot_dbfm A\\<rbrakk>e", "then"], ["proof (chain)\npicking this:\n  Term t\n  Term u", "obtain tm1 and tm2\n    where tm1: \"wf_dbtm tm1\" \"t = \\<lbrakk>quot_dbtm tm1\\<rbrakk>e\"\n      and tm2: \"wf_dbtm tm2\" \"u = \\<lbrakk>quot_dbtm tm2\\<rbrakk>e\""], ["proof (prove)\nusing this:\n  Term t\n  Term u\n\ngoal (1 subgoal):\n 1. (\\<And>tm1 tm2.\n        \\<lbrakk>wf_dbtm tm1; t = \\<lbrakk>quot_dbtm tm1\\<rbrakk>e;\n         wf_dbtm tm2; u = \\<lbrakk>quot_dbtm tm2\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Term_imp_is_tm quot_tm_def wf_dbtm_trans_tm)+"], ["proof (state)\nthis:\n  wf_dbtm tm1\n  t = \\<lbrakk>quot_dbtm tm1\\<rbrakk>e\n  wf_dbtm tm2\n  u = \\<lbrakk>quot_dbtm tm2\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>t u.\n       \\<lbrakk>Term t; Term u; x = q_Mem t u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            wf_dbfm A \\<and>\n                            q_Mem t u = \\<lbrakk>quot_dbfm A\\<rbrakk>e", "thus \"\\<exists>A. wf_dbfm A \\<and> q_Mem t u = \\<lbrakk>quot_dbfm A\\<rbrakk>e\""], ["proof (prove)\nusing this:\n  wf_dbtm tm1\n  t = \\<lbrakk>quot_dbtm tm1\\<rbrakk>e\n  wf_dbtm tm2\n  u = \\<lbrakk>quot_dbtm tm2\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<exists>A. wf_dbfm A \\<and> q_Mem t u = \\<lbrakk>quot_dbfm A\\<rbrakk>e", "by (auto simp: quot_Mem q_Mem_def)"], ["proof (state)\nthis:\n  \\<exists>A. wf_dbfm A \\<and> q_Mem t u = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SeqForm_imp_wf_dbfm:\n  assumes \"SeqForm s k x\"\n  shows \"\\<exists>A. wf_dbfm A \\<and> x = \\<lbrakk>quot_dbfm A\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A. wf_dbfm A \\<and> x = \\<lbrakk>quot_dbfm A\\<rbrakk>e", "using assms [unfolded SeqForm_def]"], ["proof (prove)\nusing this:\n  BuildSeq Atomic MakeForm s k x\n\ngoal (1 subgoal):\n 1. \\<exists>A. wf_dbfm A \\<and> x = \\<lbrakk>quot_dbfm A\\<rbrakk>e", "proof (induct x rule: BuildSeq_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       Atomic x \\<Longrightarrow>\n       \\<exists>A. wf_dbfm A \\<and> x = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n 2. \\<And>x y z.\n       \\<lbrakk>MakeForm x y z;\n        \\<exists>A. wf_dbfm A \\<and> y = \\<lbrakk>quot_dbfm A\\<rbrakk>e;\n        \\<exists>A.\n           wf_dbfm A \\<and> z = \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            wf_dbfm A \\<and>\n                            x = \\<lbrakk>quot_dbfm A\\<rbrakk>e", "case (B x)"], ["proof (state)\nthis:\n  Atomic x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       Atomic x \\<Longrightarrow>\n       \\<exists>A. wf_dbfm A \\<and> x = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n 2. \\<And>x y z.\n       \\<lbrakk>MakeForm x y z;\n        \\<exists>A. wf_dbfm A \\<and> y = \\<lbrakk>quot_dbfm A\\<rbrakk>e;\n        \\<exists>A.\n           wf_dbfm A \\<and> z = \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            wf_dbfm A \\<and>\n                            x = \\<lbrakk>quot_dbfm A\\<rbrakk>e", "thus ?case"], ["proof (prove)\nusing this:\n  Atomic x\n\ngoal (1 subgoal):\n 1. \\<exists>A. wf_dbfm A \\<and> x = \\<lbrakk>quot_dbfm A\\<rbrakk>e", "by (rule Atomic_Form_is_wf_dbfm)"], ["proof (state)\nthis:\n  \\<exists>A. wf_dbfm A \\<and> x = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>MakeForm x y z;\n        \\<exists>A. wf_dbfm A \\<and> y = \\<lbrakk>quot_dbfm A\\<rbrakk>e;\n        \\<exists>A.\n           wf_dbfm A \\<and> z = \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            wf_dbfm A \\<and>\n                            x = \\<lbrakk>quot_dbfm A\\<rbrakk>e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>MakeForm x y z;\n        \\<exists>A. wf_dbfm A \\<and> y = \\<lbrakk>quot_dbfm A\\<rbrakk>e;\n        \\<exists>A.\n           wf_dbfm A \\<and> z = \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            wf_dbfm A \\<and>\n                            x = \\<lbrakk>quot_dbfm A\\<rbrakk>e", "case (C x y z)"], ["proof (state)\nthis:\n  MakeForm x y z\n  \\<exists>A. wf_dbfm A \\<and> y = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n  \\<exists>A. wf_dbfm A \\<and> z = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>MakeForm x y z;\n        \\<exists>A. wf_dbfm A \\<and> y = \\<lbrakk>quot_dbfm A\\<rbrakk>e;\n        \\<exists>A.\n           wf_dbfm A \\<and> z = \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            wf_dbfm A \\<and>\n                            x = \\<lbrakk>quot_dbfm A\\<rbrakk>e", "then"], ["proof (chain)\npicking this:\n  MakeForm x y z\n  \\<exists>A. wf_dbfm A \\<and> y = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n  \\<exists>A. wf_dbfm A \\<and> z = \\<lbrakk>quot_dbfm A\\<rbrakk>e", "obtain A B where \"wf_dbfm A\" \"y = \\<lbrakk>quot_dbfm A\\<rbrakk>e\"\n                        \"wf_dbfm B\" \"z = \\<lbrakk>quot_dbfm B\\<rbrakk>e\""], ["proof (prove)\nusing this:\n  MakeForm x y z\n  \\<exists>A. wf_dbfm A \\<and> y = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n  \\<exists>A. wf_dbfm A \\<and> z = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>wf_dbfm A; y = \\<lbrakk>quot_dbfm A\\<rbrakk>e; wf_dbfm B;\n         z = \\<lbrakk>quot_dbfm B\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  wf_dbfm A\n  y = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n  wf_dbfm B\n  z = \\<lbrakk>quot_dbfm B\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>MakeForm x y z;\n        \\<exists>A. wf_dbfm A \\<and> y = \\<lbrakk>quot_dbfm A\\<rbrakk>e;\n        \\<exists>A.\n           wf_dbfm A \\<and> z = \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            wf_dbfm A \\<and>\n                            x = \\<lbrakk>quot_dbfm A\\<rbrakk>e", "thus ?case"], ["proof (prove)\nusing this:\n  wf_dbfm A\n  y = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n  wf_dbfm B\n  z = \\<lbrakk>quot_dbfm B\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<exists>A. wf_dbfm A \\<and> x = \\<lbrakk>quot_dbfm A\\<rbrakk>e", "using C"], ["proof (prove)\nusing this:\n  wf_dbfm A\n  y = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n  wf_dbfm B\n  z = \\<lbrakk>quot_dbfm B\\<rbrakk>e\n  MakeForm x y z\n  \\<exists>A. wf_dbfm A \\<and> y = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n  \\<exists>A. wf_dbfm A \\<and> z = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<exists>A. wf_dbfm A \\<and> x = \\<lbrakk>quot_dbfm A\\<rbrakk>e", "apply (auto simp: MakeForm_def dest!: AbstForm_imp_abst_dbfm [where e=e])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>wf_dbfm A; y = \\<lbrakk>quot_dbfm A\\<rbrakk>e; wf_dbfm B;\n     z = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n     x =\n     q_Disj \\<lbrakk>quot_dbfm A\\<rbrakk>e\n      \\<lbrakk>quot_dbfm B\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Aa.\n                         wf_dbfm Aa \\<and>\n                         q_Disj \\<lbrakk>quot_dbfm A\\<rbrakk>e\n                          \\<lbrakk>quot_dbfm B\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm Aa\\<rbrakk>e\n 2. \\<lbrakk>wf_dbfm A; y = \\<lbrakk>quot_dbfm A\\<rbrakk>e; wf_dbfm B;\n     z = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n     x = q_Neg \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Aa.\n                         wf_dbfm Aa \\<and>\n                         q_Neg \\<lbrakk>quot_dbfm A\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm Aa\\<rbrakk>e\n 3. \\<And>v.\n       \\<lbrakk>wf_dbfm A; y = \\<lbrakk>quot_dbfm A\\<rbrakk>e; wf_dbfm B;\n        z = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n        x =\n        q_Ex\n         \\<lbrakk>quot_dbfm\n                   (abst_dbfm (decode_Var v) 0 A)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa.\n                            wf_dbfm Aa \\<and>\n                            q_Ex\n                             \\<lbrakk>quot_dbfm\n (abst_dbfm (decode_Var v) 0 A)\\<rbrakk>e =\n                            \\<lbrakk>quot_dbfm Aa\\<rbrakk>e", "apply (rule exI [where x=\"DBDisj A B\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>wf_dbfm A; y = \\<lbrakk>quot_dbfm A\\<rbrakk>e; wf_dbfm B;\n     z = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n     x =\n     q_Disj \\<lbrakk>quot_dbfm A\\<rbrakk>e\n      \\<lbrakk>quot_dbfm B\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> wf_dbfm (DBDisj A B) \\<and>\n                      q_Disj \\<lbrakk>quot_dbfm A\\<rbrakk>e\n                       \\<lbrakk>quot_dbfm B\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm (DBDisj A B)\\<rbrakk>e\n 2. \\<lbrakk>wf_dbfm A; y = \\<lbrakk>quot_dbfm A\\<rbrakk>e; wf_dbfm B;\n     z = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n     x = q_Neg \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Aa.\n                         wf_dbfm Aa \\<and>\n                         q_Neg \\<lbrakk>quot_dbfm A\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm Aa\\<rbrakk>e\n 3. \\<And>v.\n       \\<lbrakk>wf_dbfm A; y = \\<lbrakk>quot_dbfm A\\<rbrakk>e; wf_dbfm B;\n        z = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n        x =\n        q_Ex\n         \\<lbrakk>quot_dbfm\n                   (abst_dbfm (decode_Var v) 0 A)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa.\n                            wf_dbfm Aa \\<and>\n                            q_Ex\n                             \\<lbrakk>quot_dbfm\n (abst_dbfm (decode_Var v) 0 A)\\<rbrakk>e =\n                            \\<lbrakk>quot_dbfm Aa\\<rbrakk>e", "apply (rule_tac [2] x=\"DBNeg A\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>wf_dbfm A; y = \\<lbrakk>quot_dbfm A\\<rbrakk>e; wf_dbfm B;\n     z = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n     x =\n     q_Disj \\<lbrakk>quot_dbfm A\\<rbrakk>e\n      \\<lbrakk>quot_dbfm B\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> wf_dbfm (DBDisj A B) \\<and>\n                      q_Disj \\<lbrakk>quot_dbfm A\\<rbrakk>e\n                       \\<lbrakk>quot_dbfm B\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm (DBDisj A B)\\<rbrakk>e\n 2. \\<lbrakk>wf_dbfm A; y = \\<lbrakk>quot_dbfm A\\<rbrakk>e; wf_dbfm B;\n     z = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n     x = q_Neg \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> wf_dbfm (DBNeg A) \\<and>\n                      q_Neg \\<lbrakk>quot_dbfm A\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e\n 3. \\<And>v.\n       \\<lbrakk>wf_dbfm A; y = \\<lbrakk>quot_dbfm A\\<rbrakk>e; wf_dbfm B;\n        z = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n        x =\n        q_Ex\n         \\<lbrakk>quot_dbfm\n                   (abst_dbfm (decode_Var v) 0 A)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa.\n                            wf_dbfm Aa \\<and>\n                            q_Ex\n                             \\<lbrakk>quot_dbfm\n (abst_dbfm (decode_Var v) 0 A)\\<rbrakk>e =\n                            \\<lbrakk>quot_dbfm Aa\\<rbrakk>e", "apply (rule_tac [3] x=\"DBEx (abst_dbfm (decode_Var v) 0 A)\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>wf_dbfm A; y = \\<lbrakk>quot_dbfm A\\<rbrakk>e; wf_dbfm B;\n     z = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n     x =\n     q_Disj \\<lbrakk>quot_dbfm A\\<rbrakk>e\n      \\<lbrakk>quot_dbfm B\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> wf_dbfm (DBDisj A B) \\<and>\n                      q_Disj \\<lbrakk>quot_dbfm A\\<rbrakk>e\n                       \\<lbrakk>quot_dbfm B\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm (DBDisj A B)\\<rbrakk>e\n 2. \\<lbrakk>wf_dbfm A; y = \\<lbrakk>quot_dbfm A\\<rbrakk>e; wf_dbfm B;\n     z = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n     x = q_Neg \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> wf_dbfm (DBNeg A) \\<and>\n                      q_Neg \\<lbrakk>quot_dbfm A\\<rbrakk>e =\n                      \\<lbrakk>quot_dbfm (DBNeg A)\\<rbrakk>e\n 3. \\<And>v.\n       \\<lbrakk>wf_dbfm A; y = \\<lbrakk>quot_dbfm A\\<rbrakk>e; wf_dbfm B;\n        z = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n        x =\n        q_Ex\n         \\<lbrakk>quot_dbfm\n                   (abst_dbfm (decode_Var v) 0 A)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> wf_dbfm\n                          (DBEx (abst_dbfm (decode_Var v) 0 A)) \\<and>\n                         q_Ex\n                          \\<lbrakk>quot_dbfm\n                                    (abst_dbfm (decode_Var v) 0\nA)\\<rbrakk>e =\n                         \\<lbrakk>quot_dbfm\n                                   (DBEx\n                                     (abst_dbfm (decode_Var v) 0\n A))\\<rbrakk>e", "apply (auto simp: q_defs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>A. wf_dbfm A \\<and> x = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Form_imp_wf_dbfm:\n  assumes \"Form x\" obtains A where \"wf_dbfm A\" \"x = \\<lbrakk>quot_dbfm A\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>wf_dbfm A; x = \\<lbrakk>quot_dbfm A\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis assms SeqForm_imp_wf_dbfm Form_def)"], ["", "lemma Form_imp_is_fm: assumes \"Form x\" obtains A::fm where \"x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        x =\n        \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis assms Form_imp_wf_dbfm quot_fm_def wf_dbfm_imp_is_fm)"], ["", "lemma SubstForm_imp_subst_fm:\n  assumes \"SubstForm v \\<lbrakk>\\<guillemotleft>u\\<guillemotright>\\<rbrakk>e x x'\" \"Form x\"\n  obtains A::fm where \"x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk> e\" \"x' = \\<lbrakk>\\<guillemotleft>A(decode_Var v::=u)\\<guillemotright>\\<rbrakk> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n         x' =\n         \\<lbrakk>\\<guillemotleft>A(decode_Var\n                                     v::=u)\\<guillemotright>\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms [unfolded quot_tm_def]"], ["proof (prove)\nusing this:\n  SubstForm v \\<lbrakk>quot_dbtm (trans_tm [] u)\\<rbrakk>e x x'\n  Form x\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n         x' =\n         \\<lbrakk>\\<guillemotleft>A(decode_Var\n                                     v::=u)\\<guillemotright>\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: quot_fm_def dest!: SubstForm_imp_subst_dbfm_lemma)\n     (metis Form_imp_is_fm eval_quot_dbfm_ignore quot_dbfm_inject_lemma quot_fm_def)"], ["", "lemma SubstForm_unique:\n  assumes \"is_Var v\" and \"Term y\" and \"Form x\"\n     shows \"SubstForm v y x x' \\<longleftrightarrow>\n            (\\<exists>t::tm. y = \\<lbrakk>\\<guillemotleft>t\\<guillemotright>\\<rbrakk>e \\<and> (\\<exists>A::fm. x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and> x' = \\<lbrakk>\\<guillemotleft>A(decode_Var v::=t)\\<guillemotright>\\<rbrakk>e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SubstForm v y x x' =\n    (\\<exists>t.\n        y = \\<lbrakk>\\<guillemotleft>t\\<guillemotright>\\<rbrakk>e \\<and>\n        (\\<exists>A.\n            x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n            x' =\n            \\<lbrakk>\\<guillemotleft>A(decode_Var\n  v::=t)\\<guillemotright>\\<rbrakk>e))", "using assms"], ["proof (prove)\nusing this:\n  is_Var v\n  Term y\n  Form x\n\ngoal (1 subgoal):\n 1. SubstForm v y x x' =\n    (\\<exists>t.\n        y = \\<lbrakk>\\<guillemotleft>t\\<guillemotright>\\<rbrakk>e \\<and>\n        (\\<exists>A.\n            x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n            x' =\n            \\<lbrakk>\\<guillemotleft>A(decode_Var\n  v::=t)\\<guillemotright>\\<rbrakk>e))", "apply (auto elim!: Term_imp_wf_dbtm [where e=e] Form_imp_is_fm [where e=e] \n                     SubstForm_imp_subst_dbfm [where e=e])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A ta Aa.\n       \\<lbrakk>is_Var v; x = \\<lbrakk>quot_dbfm Aa\\<rbrakk>e; wf_dbtm ta;\n        y = \\<lbrakk>quot_dbtm ta\\<rbrakk>e;\n        \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e =\n        \\<lbrakk>quot_dbfm Aa\\<rbrakk>e;\n        x' =\n        \\<lbrakk>quot_dbfm\n                  (subst_dbfm ta (decode_Var v) Aa)\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            \\<lbrakk>quot_dbtm ta\\<rbrakk>e =\n                            \\<lbrakk>\\<guillemotleft>t\\<guillemotright>\\<rbrakk>e \\<and>\n                            (\\<exists>A.\n                                \\<lbrakk>quot_dbfm Aa\\<rbrakk>e =\n                                \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                                \\<lbrakk>quot_dbfm\n    (subst_dbfm ta (decode_Var v) Aa)\\<rbrakk>e =\n                                \\<lbrakk>\\<guillemotleft>A(decode_Var\n                      v::=t)\\<guillemotright>\\<rbrakk>e)\n 2. \\<And>t ta Aa.\n       \\<lbrakk>is_Var v;\n        x = \\<lbrakk>\\<guillemotleft>Aa\\<guillemotright>\\<rbrakk>e;\n        wf_dbtm t;\n        y = \\<lbrakk>\\<guillemotleft>ta\\<guillemotright>\\<rbrakk>e;\n        \\<lbrakk>quot_dbtm t\\<rbrakk>e =\n        \\<lbrakk>\\<guillemotleft>ta\\<guillemotright>\\<rbrakk>e;\n        x' =\n        \\<lbrakk>\\<guillemotleft>Aa(decode_Var\n                                     v::=ta)\\<guillemotright>\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> SubstForm v\n                          \\<lbrakk>\\<guillemotleft>ta\\<guillemotright>\\<rbrakk>e\n                          \\<lbrakk>\\<guillemotleft>Aa\\<guillemotright>\\<rbrakk>e\n                          \\<lbrakk>\\<guillemotleft>Aa(decode_Var\n                 v::=ta)\\<guillemotright>\\<rbrakk>e", "apply (auto simp: quot_tm_def quot_fm_def is_Var_iff q_Var_def intro: SubstForm_subst_dbfm_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A ta.\n       \\<lbrakk>v = succ (ord_of (nat_of_name (decode_Var v)));\n        x = \\<lbrakk>quot_dbfm (trans_fm [] A)\\<rbrakk>e; wf_dbtm ta;\n        y = \\<lbrakk>quot_dbtm ta\\<rbrakk>e;\n        x' =\n        \\<lbrakk>quot_dbfm\n                  (subst_dbfm ta (decode_Var v)\n                    (trans_fm [] A))\\<rbrakk>e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            ta = trans_tm [] t \\<and>\n                            subst_dbfm ta (decode_Var v) (trans_fm [] A) =\n                            trans_fm [] (A(decode_Var v::=t))", "apply (metis subst_fm_trans_commute wf_dbtm_imp_is_tm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma SubstForm_quot_unique: \"SubstForm (q_Var i) \\<lbrakk>\\<guillemotleft>t\\<guillemotright>\\<rbrakk>e \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e x' \\<longleftrightarrow> x' = \\<lbrakk>\\<guillemotleft>A(i::=t)\\<guillemotright>\\<rbrakk> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SubstForm (q_Var i)\n     \\<lbrakk>\\<guillemotleft>t\\<guillemotright>\\<rbrakk>e\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e x' =\n    (x' = \\<lbrakk>\\<guillemotleft>A(i::=t)\\<guillemotright>\\<rbrakk>e)", "by (subst SubstForm_unique [where e=e]) auto"], ["", "lemma SubstForm_quot: \"SubstForm \\<lbrakk>\\<guillemotleft>Var i\\<guillemotright>\\<rbrakk>e \\<lbrakk>\\<guillemotleft>t\\<guillemotright>\\<rbrakk>e \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<lbrakk>\\<guillemotleft>A(i::=t)\\<guillemotright>\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SubstForm \\<lbrakk>\\<guillemotleft>Var i\\<guillemotright>\\<rbrakk>e\n     \\<lbrakk>\\<guillemotleft>t\\<guillemotright>\\<rbrakk>e\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n     \\<lbrakk>\\<guillemotleft>A(i::=t)\\<guillemotright>\\<rbrakk>e", "by (metis SubstForm_quot_unique eval_Var_q)"], ["", "subsection \\<open>The predicate \\<open>VarNonOccFormP\\<close> (Derived from \\<open>SubstFormP\\<close>)\\<close>"], ["", "definition VarNonOccForm :: \"hf \\<Rightarrow> hf \\<Rightarrow> bool\"\nwhere \"VarNonOccForm v x \\<equiv> Form x \\<and> SubstForm v 0 x x\""], ["", "nominal_function VarNonOccFormP :: \"tm \\<Rightarrow> tm \\<Rightarrow> fm\"\n  where \"VarNonOccFormP v x = FormP x AND SubstFormP v Zero x x\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt VarNonOccFormP_graph_aux\n 2. \\<And>x y. VarNonOccFormP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>v xa. x = (v, xa) \\<Longrightarrow> P) \\<Longrightarrow> P\n 4. \\<And>v x va xa.\n       (v, x) = (va, xa) \\<Longrightarrow>\n       FormP x AND SubstFormP v Zero x x =\n       FormP xa AND SubstFormP va Zero xa xa", "by (auto simp: eqvt_def VarNonOccFormP_graph_aux_def)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All VarNonOccFormP_dom", "by lexicographic_order"], ["", "lemma\n  shows VarNonOccFormP_fresh_iff [simp]: \"a \\<sharp> VarNonOccFormP v y \\<longleftrightarrow> a \\<sharp> v \\<and> a \\<sharp> y\" (is ?thesis1)\n    and eval_fm_VarNonOccFormP [simp]:\n       \"eval_fm e (VarNonOccFormP v y) \\<longleftrightarrow> VarNonOccForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>y\\<rbrakk>e\"    (is ?thesis2)\n    and VarNonOccFormP_sf [iff]: \"Sigma_fm (VarNonOccFormP v y)\" (is ?thsf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> VarNonOccFormP v y = (a \\<sharp> v \\<and> a \\<sharp> y) &&&\n    eval_fm e (VarNonOccFormP v y) =\n    VarNonOccForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>y\\<rbrakk>e &&&\n    Sigma_fm (VarNonOccFormP v y)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. a \\<sharp> VarNonOccFormP v y = (a \\<sharp> v \\<and> a \\<sharp> y)\n 2. eval_fm e (VarNonOccFormP v y) =\n    VarNonOccForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>y\\<rbrakk>e\n 3. Sigma_fm (VarNonOccFormP v y)", "show ?thesis1 ?thsf ?thesis2"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> VarNonOccFormP v y = (a \\<sharp> v \\<and> a \\<sharp> y) &&&\n    Sigma_fm (VarNonOccFormP v y) &&&\n    eval_fm e (VarNonOccFormP v y) =\n    VarNonOccForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>y\\<rbrakk>e", "by (auto simp add: VarNonOccForm_def)"], ["proof (state)\nthis:\n  a \\<sharp> VarNonOccFormP v y = (a \\<sharp> v \\<and> a \\<sharp> y)\n  Sigma_fm (VarNonOccFormP v y)\n  eval_fm e (VarNonOccFormP v y) =\n  VarNonOccForm \\<lbrakk>v\\<rbrakk>e \\<lbrakk>y\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Correctness for Real Terms and Formulas\\<close>"], ["", "lemma VarNonOccForm_imp_dbfm_fresh:\n  assumes \"VarNonOccForm v x\" \n  shows \"\\<exists>A. wf_dbfm A \\<and> x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and> atom (decode_Var v) \\<sharp> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       wf_dbfm A \\<and>\n       x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n       atom (decode_Var v) \\<sharp> A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       wf_dbfm A \\<and>\n       x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n       atom (decode_Var v) \\<sharp> A", "obtain A' where A': \"wf_dbfm A'\" \"x = \\<lbrakk>quot_dbfm A'\\<rbrakk>e\" \"SubstForm v \\<lbrakk>quot_dbtm DBZero\\<rbrakk>e x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A'.\n        \\<lbrakk>wf_dbfm A'; x = \\<lbrakk>quot_dbfm A'\\<rbrakk>e;\n         SubstForm v \\<lbrakk>quot_dbtm DBZero\\<rbrakk>e x x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms [unfolded VarNonOccForm_def]"], ["proof (prove)\nusing this:\n  Form x \\<and> SubstForm v 0 x x\n\ngoal (1 subgoal):\n 1. (\\<And>A'.\n        \\<lbrakk>wf_dbfm A'; x = \\<lbrakk>quot_dbfm A'\\<rbrakk>e;\n         SubstForm v \\<lbrakk>quot_dbtm DBZero\\<rbrakk>e x x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto (metis Form_imp_wf_dbfm)"], ["proof (state)\nthis:\n  wf_dbfm A'\n  x = \\<lbrakk>quot_dbfm A'\\<rbrakk>e\n  SubstForm v \\<lbrakk>quot_dbtm DBZero\\<rbrakk>e x x\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       wf_dbfm A \\<and>\n       x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n       atom (decode_Var v) \\<sharp> A", "then"], ["proof (chain)\npicking this:\n  wf_dbfm A'\n  x = \\<lbrakk>quot_dbfm A'\\<rbrakk>e\n  SubstForm v \\<lbrakk>quot_dbtm DBZero\\<rbrakk>e x x", "obtain A where \"x = \\<lbrakk>quot_dbfm A\\<rbrakk>e\"\n                      \"x = \\<lbrakk>quot_dbfm (subst_dbfm DBZero (decode_Var v) A)\\<rbrakk>e\""], ["proof (prove)\nusing this:\n  wf_dbfm A'\n  x = \\<lbrakk>quot_dbfm A'\\<rbrakk>e\n  SubstForm v \\<lbrakk>quot_dbtm DBZero\\<rbrakk>e x x\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>x = \\<lbrakk>quot_dbfm A\\<rbrakk>e;\n         x =\n         \\<lbrakk>quot_dbfm\n                   (subst_dbfm DBZero (decode_Var v) A)\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis SubstForm_imp_subst_dbfm_lemma)"], ["proof (state)\nthis:\n  x = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n  x = \\<lbrakk>quot_dbfm (subst_dbfm DBZero (decode_Var v) A)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       wf_dbfm A \\<and>\n       x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n       atom (decode_Var v) \\<sharp> A", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n  x = \\<lbrakk>quot_dbfm (subst_dbfm DBZero (decode_Var v) A)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       wf_dbfm A \\<and>\n       x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n       atom (decode_Var v) \\<sharp> A", "using A'"], ["proof (prove)\nusing this:\n  x = \\<lbrakk>quot_dbfm A\\<rbrakk>e\n  x = \\<lbrakk>quot_dbfm (subst_dbfm DBZero (decode_Var v) A)\\<rbrakk>e\n  wf_dbfm A'\n  x = \\<lbrakk>quot_dbfm A'\\<rbrakk>e\n  SubstForm v \\<lbrakk>quot_dbtm DBZero\\<rbrakk>e x x\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       wf_dbfm A \\<and>\n       x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n       atom (decode_Var v) \\<sharp> A", "by auto (metis fresh_iff_non_subst_dbfm)"], ["proof (state)\nthis:\n  \\<exists>A.\n     wf_dbfm A \\<and>\n     x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     atom (decode_Var v) \\<sharp> A\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary VarNonOccForm_imp_fresh:\n  assumes \"VarNonOccForm v x\"  obtains A::fm where \"x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\" \"atom (decode_Var v) \\<sharp> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n         atom (decode_Var v) \\<sharp> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using VarNonOccForm_imp_dbfm_fresh [OF assms, where e=e]"], ["proof (prove)\nusing this:\n  \\<exists>A.\n     wf_dbfm A \\<and>\n     x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     atom (decode_Var v) \\<sharp> A\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n         atom (decode_Var v) \\<sharp> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: quot_fm_def wf_dbfm_iff_is_fm)"], ["", "lemma VarNonOccForm_dbfm:\n  \"wf_dbfm A \\<Longrightarrow> atom i \\<sharp> A \\<Longrightarrow> VarNonOccForm (q_Var i) \\<lbrakk>quot_dbfm A\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_dbfm A; atom i \\<sharp> A\\<rbrakk>\n    \\<Longrightarrow> VarNonOccForm (q_Var i) \\<lbrakk>quot_dbfm A\\<rbrakk>e", "by (auto intro: SubstForm_subst_dbfm_eq [where u=DBZero] \n    simp add: VarNonOccForm_def Const_0 Const_imp_Term fresh_iff_non_subst_dbfm [symmetric])"], ["", "corollary fresh_imp_VarNonOccForm:\n  fixes A::fm  shows \"atom i \\<sharp> A \\<Longrightarrow> VarNonOccForm (q_Var i) \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom i \\<sharp> A \\<Longrightarrow>\n    VarNonOccForm (q_Var i)\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e", "by (simp add: quot_fm_def wf_dbfm_trans_fm VarNonOccForm_dbfm)"], ["", "declare VarNonOccFormP.simps [simp del]"], ["", "end"]]}