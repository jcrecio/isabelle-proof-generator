{"file_name": "/home/qj213/afp-2021-10-22/thys/Incompleteness/Pf_Predicates.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Incompleteness", "problem_names": ["lemma\n shows SentP_fresh_iff [simp]: \"a \\<sharp> SentP x \\<longleftrightarrow> a \\<sharp> x\"                  (is ?thesis1)\n   and eval_fm_SentP [simp]:   \"eval_fm e (SentP x) \\<longleftrightarrow> \\<lbrakk>x\\<rbrakk>e \\<in> Sent\"    (is ?thesis2)\n   and SentP_sf [iff]:         \"Sigma_fm (SentP x)\"                     (is ?thsf)", "lemma eval_fm_Equality_axP [simp]: \"eval_fm e (Equality_axP x) \\<longleftrightarrow> \\<lbrakk>x\\<rbrakk>e \\<in> Equality_ax\"", "lemma eval_fm_HF_axP [simp]: \"eval_fm e (HF_axP x) \\<longleftrightarrow> \\<lbrakk>x\\<rbrakk>e \\<in> HF_ax\"", "lemma HF_axP_sf [iff]: \"Sigma_fm (HF_axP t)\"", "lemma\n shows Special_axP_fresh_iff [simp]: \"a \\<sharp> Special_axP p \\<longleftrightarrow> a \\<sharp> p\" (is ?thesis1)\n   and eval_fm_Special_axP [simp]: \"eval_fm e (Special_axP p) \\<longleftrightarrow> \\<lbrakk>p\\<rbrakk>e \\<in> Special_ax\" (is ?thesis2)\n   and Special_axP_sf [iff]:       \"Sigma_fm (Special_axP p)\" (is ?thesis3)", "lemma Special_ax_imp_special_axioms:\n  assumes \"x \\<in> Special_ax\" shows \"\\<exists>A. x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and> A \\<in> special_axioms\"", "lemma special_axioms_into_Special_ax: \"A \\<in> special_axioms \\<Longrightarrow> \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<in> Special_ax\"", "lemma\n shows Induction_axP_fresh_iff [simp]: \"a \\<sharp> Induction_axP p \\<longleftrightarrow> a \\<sharp> p\" (is ?thesis1)\n   and eval_fm_Induction_axP [simp]:\n      \"eval_fm e (Induction_axP p) \\<longleftrightarrow> \\<lbrakk>p\\<rbrakk>e \\<in> Induction_ax\"    (is ?thesis2)\n   and Induction_axP_sf [iff]: \"Sigma_fm (Induction_axP p)\" (is ?thesis3)", "lemma Induction_ax_imp_induction_axioms:\n  assumes \"x \\<in> Induction_ax\" shows \"\\<exists>A. x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and> A \\<in> induction_axioms\"", "lemma induction_axioms_into_Induction_ax:\n  \"A \\<in> induction_axioms \\<Longrightarrow> \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<in> Induction_ax\"", "lemma AxiomP_eqvt [eqvt]: \"(p \\<bullet> AxiomP x) = AxiomP (p \\<bullet> x)\"", "lemma AxiomP_fresh_iff [simp]: \"a \\<sharp> AxiomP x \\<longleftrightarrow> a \\<sharp> x\"", "lemma eval_fm_AxiomP [simp]: \"eval_fm e (AxiomP x) \\<longleftrightarrow> \\<lbrakk>x\\<rbrakk>e \\<in> Axiom\"", "lemma AxiomP_sf [iff]: \"Sigma_fm (AxiomP t)\"", "lemma ModPonP_eqvt [eqvt]: \"(p \\<bullet> ModPonP x y z) = ModPonP (p \\<bullet> x) (p \\<bullet> y) (p \\<bullet> z)\"", "lemma ModPonP_fresh_iff [simp]: \"a \\<sharp> ModPonP x y z \\<longleftrightarrow> a \\<sharp> x \\<and> a \\<sharp> y \\<and> a \\<sharp> z\"", "lemma eval_fm_ModPonP [simp]: \"eval_fm e (ModPonP x y z) \\<longleftrightarrow> ModPon \\<lbrakk>x\\<rbrakk>e \\<lbrakk>y\\<rbrakk>e \\<lbrakk>z\\<rbrakk>e\"", "lemma ModPonP_sf [iff]: \"Sigma_fm (ModPonP t u v)\"", "lemma ModPonP_subst [simp]:\n  \"(ModPonP t u v)(i::=w) = ModPonP (subst i w t) (subst i w u) (subst i w v)\"", "lemma\n shows ExistsP_fresh_iff [simp]: \"a \\<sharp> ExistsP p q \\<longleftrightarrow> a \\<sharp> p \\<and> a \\<sharp> q\"    (is ?thesis1)\n   and eval_fm_ExistsP [simp]: \"eval_fm e (ExistsP p q) \\<longleftrightarrow> Exists \\<lbrakk>p\\<rbrakk>e \\<lbrakk>q\\<rbrakk>e\"  (is ?thesis2)\n   and ExistsP_sf [iff]:       \"Sigma_fm (ExistsP p q)\"   (is ?thesis3)", "lemma ExistsP_subst [simp]: \"(ExistsP p q)(j::=w) = ExistsP (subst j w p) (subst j w q)\"", "lemma Exists_imp_exists:\n  assumes \"Exists p q\"\n  shows \"\\<exists>A B i. p = \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e \\<and> q = \\<lbrakk>\\<guillemotleft>(Ex i A) IMP B\\<guillemotright>\\<rbrakk>e \\<and> atom i \\<sharp> B\"", "lemma Exists_intro: \"atom i \\<sharp> B \\<Longrightarrow> Exists (\\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e) \\<lbrakk>\\<guillemotleft>(Ex i A) IMP B\\<guillemotright>\\<rbrakk>e\"", "lemma\n shows SubstP_fresh_iff [simp]: \"a \\<sharp> SubstP p q \\<longleftrightarrow> a \\<sharp> p \\<and> a \\<sharp> q\"        (is ?thesis1)\n   and eval_fm_SubstP [simp]: \"eval_fm e (SubstP p q) \\<longleftrightarrow> Subst \\<lbrakk>p\\<rbrakk>e \\<lbrakk>q\\<rbrakk>e\" (is ?thesis2)\n   and SubstP_sf [iff]: \"Sigma_fm (SubstP p q)\"                           (is ?thesis3)", "lemma SubstP_subst [simp]: \"(SubstP p q)(j::=w) = SubstP (subst j w p) (subst j w q)\"", "lemma Subst_imp_subst:\n  assumes \"Subst p q\" \"Form p\"\n  shows \"\\<exists>A::fm. \\<exists>i t. p = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and> q = \\<lbrakk>\\<guillemotleft>A(i::=t)\\<guillemotright>\\<rbrakk>e\"", "lemma\n  shows PrfP_fresh_iff [simp]: \"a \\<sharp> PrfP s k t \\<longleftrightarrow> a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> t\"      (is ?thesis1)\n  and eval_fm_PrfP [simp]:     \"eval_fm e (PrfP s k t) \\<longleftrightarrow> Prf \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\"  (is ?thesis2)\n  and PrfP_imp_OrdP [simp]:    \"{PrfP s k t} \\<turnstile> OrdP k\"         (is ?thord)\n  and PrfP_imp_LstSeqP [simp]: \"{PrfP s k t} \\<turnstile> LstSeqP s k t\"  (is ?thlstseq)\n  and PrfP_sf [iff]:           \"Sigma_fm (PrfP s k t)\"         (is ?thsf)", "lemma PrfP_subst [simp]:\n     \"(PrfP t u v)(j::=w) = PrfP (subst j w t) (subst j w u) (subst j w v)\"", "lemma\n shows PfP_fresh_iff [simp]: \"a \\<sharp> PfP y \\<longleftrightarrow> a \\<sharp> y\"           (is ?thesis1)\n   and eval_fm_PfP [simp]:  \"eval_fm e (PfP y) \\<longleftrightarrow> Pf \\<lbrakk>y\\<rbrakk>e\"  (is ?thesis2)\n   and PfP_sf [iff]: \"Sigma_fm (PfP y)\"                      (is ?thsf)", "lemma PfP_subst [simp]: \"(PfP t)(j::=w) = PfP (subst j w t)\"", "lemma ground_PfP [simp]: \"ground_fm (PfP y) = ground y\"", "lemma extra_axiom_imp_Pf: \"Pf \\<lbrakk>\\<guillemotleft>extra_axiom\\<guillemotright>\\<rbrakk>e\"", "lemma boolean_axioms_imp_Pf:\n  assumes \"\\<alpha> \\<in> boolean_axioms\" shows \"Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\"", "lemma equality_axioms_imp_Pf:\n  assumes \"\\<alpha> \\<in> equality_axioms\" shows \"Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\"", "lemma HF_axioms_imp_Pf:\n  assumes \"\\<alpha> \\<in> HF_axioms\" shows \"Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\"", "lemma special_axioms_imp_Pf:\n  assumes \"\\<alpha> \\<in> special_axioms\" shows \"Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\"", "lemma induction_axioms_imp_Pf:\n  assumes \"\\<alpha> \\<in> induction_axioms\" shows \"Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\"", "lemma ModPon_imp_Pf: \"\\<lbrakk>Pf \\<lbrakk>Q_Imp x y\\<rbrakk>e; Pf \\<lbrakk>x\\<rbrakk>e\\<rbrakk> \\<Longrightarrow> Pf \\<lbrakk>y\\<rbrakk>e\"", "lemma quot_ModPon_imp_Pf: \"\\<lbrakk>Pf \\<lbrakk>\\<guillemotleft>\\<alpha> IMP \\<beta>\\<guillemotright>\\<rbrakk>e; Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\\<rbrakk> \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>\\<beta>\\<guillemotright>\\<rbrakk>e\"", "lemma quot_Exists_imp_Pf: \"\\<lbrakk>Pf \\<lbrakk>\\<guillemotleft>\\<alpha> IMP \\<beta>\\<guillemotright>\\<rbrakk>e; atom i \\<sharp> \\<beta>\\<rbrakk> \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>Ex i \\<alpha> IMP \\<beta>\\<guillemotright>\\<rbrakk>e\"", "lemma proved_imp_Pf: assumes \"H \\<turnstile> \\<alpha>\" \"H={}\" shows \"Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\"", "lemma Sent_imp_hfthm:\n  assumes \"x \\<in> Sent\" shows \"\\<exists>A. x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and> {} \\<turnstile> A\"", "lemma Extra_ax_imp_hfthm:\n  assumes \"x \\<in> Extra_ax\" obtains A where \"x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and> {} \\<turnstile> A\"", "lemma Equality_ax_imp_hfthm:\n  assumes \"x \\<in> Equality_ax\" obtains A where \"x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and> {} \\<turnstile> A\"", "lemma HF_ax_imp_hfthm:\n  assumes \"x \\<in> HF_ax\" obtains A where \"x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and> {} \\<turnstile> A\"", "lemma Special_ax_imp_hfthm:\n  assumes \"x \\<in> Special_ax\" obtains A where \"x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\" \"{} \\<turnstile> A\"", "lemma Induction_ax_imp_hfthm:\n  assumes \"x \\<in> Induction_ax\" obtains A where \"x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\" \"{} \\<turnstile> A\"", "lemma Exists_imp_hfthm: \"\\<lbrakk>Exists \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e y; {} \\<turnstile> A\\<rbrakk> \\<Longrightarrow> \\<exists>B. y = \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e \\<and> {} \\<turnstile> B\"", "lemma Subst_imp_hfthm:  \"\\<lbrakk>Subst \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e y; {} \\<turnstile> A\\<rbrakk> \\<Longrightarrow> \\<exists>B. y = \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e \\<and> {} \\<turnstile> B\"", "lemma eval_Neg_imp_Neg: \"\\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e = q_Neg x \\<Longrightarrow> \\<exists>A. \\<alpha> = Neg A \\<and> \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e = x\"", "lemma eval_Disj_imp_Disj: \"\\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e = q_Disj x y \\<Longrightarrow> \\<exists>A B. \\<alpha> = A OR B \\<and> \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e = x \\<and> \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e = y\"", "lemma Prf_imp_proved: assumes \"Prf s k x\" shows \"\\<exists>A. x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and> {} \\<turnstile> A\"", "theorem proved_iff_proved_PfP: \"{} \\<turnstile> \\<alpha> \\<longleftrightarrow> {} \\<turnstile> PfP \\<guillemotleft>\\<alpha>\\<guillemotright>\""], "translations": [["", "lemma\n shows SentP_fresh_iff [simp]: \"a \\<sharp> SentP x \\<longleftrightarrow> a \\<sharp> x\"                  (is ?thesis1)\n   and eval_fm_SentP [simp]:   \"eval_fm e (SentP x) \\<longleftrightarrow> \\<lbrakk>x\\<rbrakk>e \\<in> Sent\"    (is ?thesis2)\n   and SentP_sf [iff]:         \"Sigma_fm (SentP x)\"                     (is ?thsf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> SentP x = a \\<sharp> x &&&\n    eval_fm e (SentP x) = (\\<lbrakk>x\\<rbrakk>e \\<in> Sent) &&&\n    Sigma_fm (SentP x)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. a \\<sharp> SentP x = a \\<sharp> x\n 2. eval_fm e (SentP x) = (\\<lbrakk>x\\<rbrakk>e \\<in> Sent)\n 3. Sigma_fm (SentP x)", "obtain y::name and z::name and w::name  where \"atom y \\<sharp> (z,w,x)\" \"atom z \\<sharp> (w,x)\" \"atom w \\<sharp> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y z w.\n        \\<lbrakk>atom y \\<sharp> (z, w, x); atom z \\<sharp> (w, x);\n         atom w \\<sharp> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom y \\<sharp> (z, w, x)\n  atom z \\<sharp> (w, x)\n  atom w \\<sharp> x\n\ngoal (3 subgoals):\n 1. a \\<sharp> SentP x = a \\<sharp> x\n 2. eval_fm e (SentP x) = (\\<lbrakk>x\\<rbrakk>e \\<in> Sent)\n 3. Sigma_fm (SentP x)", "thus ?thesis1 ?thesis2 ?thsf"], ["proof (prove)\nusing this:\n  atom y \\<sharp> (z, w, x)\n  atom z \\<sharp> (w, x)\n  atom w \\<sharp> x\n\ngoal (1 subgoal):\n 1. a \\<sharp> SentP x = a \\<sharp> x &&&\n    eval_fm e (SentP x) = (\\<lbrakk>x\\<rbrakk>e \\<in> Sent) &&&\n    Sigma_fm (SentP x)", "by (auto simp: Sent_def Sent_axioms_def q_defs)"], ["proof (state)\nthis:\n  a \\<sharp> SentP x = a \\<sharp> x\n  eval_fm e (SentP x) = (\\<lbrakk>x\\<rbrakk>e \\<in> Sent)\n  Sigma_fm (SentP x)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The predicate \\<open>Equality_axP\\<close>, for the Equality Axioms\\<close>"], ["", "definition Equality_ax :: \"hf set\" where\n \"Equality_ax \\<equiv> { \\<lbrakk>\\<guillemotleft>refl_ax\\<guillemotright>\\<rbrakk>e0, \\<lbrakk>\\<guillemotleft>eq_cong_ax\\<guillemotright>\\<rbrakk>e0, \\<lbrakk>\\<guillemotleft>mem_cong_ax\\<guillemotright>\\<rbrakk>e0, \\<lbrakk>\\<guillemotleft>eats_cong_ax\\<guillemotright>\\<rbrakk>e0 }\""], ["", "function Equality_axP :: \"tm \\<Rightarrow> fm\"\n  where \"Equality_axP x =\n    x EQ \\<guillemotleft>refl_ax\\<guillemotright> OR x EQ \\<guillemotleft>eq_cong_ax\\<guillemotright> OR x EQ \\<guillemotleft>mem_cong_ax\\<guillemotright> OR x EQ \\<guillemotleft>eats_cong_ax\\<guillemotright>\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>xa. x = xa \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>x xa.\n       x = xa \\<Longrightarrow>\n       x EQ \\<guillemotleft>refl_ax\\<guillemotright> OR\n       x EQ \\<guillemotleft>eq_cong_ax\\<guillemotright> OR\n       x EQ \\<guillemotleft>mem_cong_ax\\<guillemotright> OR\n       x EQ \\<guillemotleft>eats_cong_ax\\<guillemotright> =\n       xa EQ \\<guillemotleft>refl_ax\\<guillemotright> OR\n       xa EQ \\<guillemotleft>eq_cong_ax\\<guillemotright> OR\n       xa EQ \\<guillemotleft>mem_cong_ax\\<guillemotright> OR\n       xa EQ \\<guillemotleft>eats_cong_ax\\<guillemotright>", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All Equality_axP_dom", "by lexicographic_order"], ["", "lemma eval_fm_Equality_axP [simp]: \"eval_fm e (Equality_axP x) \\<longleftrightarrow> \\<lbrakk>x\\<rbrakk>e \\<in> Equality_ax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_fm e (Equality_axP x) = (\\<lbrakk>x\\<rbrakk>e \\<in> Equality_ax)", "by (auto simp: Equality_ax_def intro: eval_quot_fm_ignore)"], ["", "subsection \\<open>The predicate \\<open>HF_axP\\<close>, for the HF Axioms\\<close>"], ["", "definition HF_ax :: \"hf set\" where\n  \"HF_ax \\<equiv> {\\<lbrakk>\\<guillemotleft>HF1\\<guillemotright>\\<rbrakk>e0, \\<lbrakk>\\<guillemotleft>HF2\\<guillemotright>\\<rbrakk>e0}\""], ["", "function HF_axP :: \"tm \\<Rightarrow> fm\"\n  where \"HF_axP x = x EQ \\<guillemotleft>HF1\\<guillemotright> OR x EQ \\<guillemotleft>HF2\\<guillemotright>\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>xa. x = xa \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>x xa.\n       x = xa \\<Longrightarrow>\n       x EQ \\<guillemotleft>HF1\\<guillemotright> OR\n       x EQ \\<guillemotleft>HF2\\<guillemotright> =\n       xa EQ \\<guillemotleft>HF1\\<guillemotright> OR\n       xa EQ \\<guillemotleft>HF2\\<guillemotright>", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All HF_axP_dom", "by lexicographic_order"], ["", "lemma eval_fm_HF_axP [simp]: \"eval_fm e (HF_axP x) \\<longleftrightarrow> \\<lbrakk>x\\<rbrakk>e \\<in> HF_ax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_fm e (HF_axP x) = (\\<lbrakk>x\\<rbrakk>e \\<in> HF_ax)", "by (auto simp: HF_ax_def intro: eval_quot_fm_ignore)"], ["", "lemma HF_axP_sf [iff]: \"Sigma_fm (HF_axP t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_fm (HF_axP t)", "by auto"], ["", "subsection \\<open>The specialisation axioms\\<close>"], ["", "inductive_set Special_ax :: \"hf set\" where\n  I: \"\\<lbrakk>AbstForm v 0 x ax; SubstForm v y x sx; Form x; is_Var v; Term y\\<rbrakk>\n      \\<Longrightarrow> q_Imp sx (q_Ex ax) \\<in> Special_ax\""], ["", "subsubsection \\<open>Defining the syntax\\<close>"], ["", "nominal_function Special_axP :: \"tm \\<Rightarrow> fm\" where\n  \"\\<lbrakk>atom v \\<sharp> (p,sx,y,ax,x); atom x \\<sharp> (p,sx,y,ax);\n    atom ax \\<sharp> (p,sx,y); atom y \\<sharp> (p,sx); atom sx \\<sharp> p\\<rbrakk> \\<Longrightarrow>\n  Special_axP p = Ex v (Ex x (Ex ax (Ex y (Ex sx\n                   (FormP (Var x) AND VarP (Var v) AND TermP (Var y) AND\n                    AbstFormP (Var v) Zero (Var x) (Var ax) AND\n                    SubstFormP (Var v) (Var y) (Var x) (Var sx) AND\n                    p EQ Q_Imp (Var sx) (Q_Ex (Var ax)))))))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt Special_axP_graph_aux\n 2. \\<And>x y. Special_axP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>v p sx y ax xa.\n           \\<lbrakk>atom v \\<sharp> (p, sx, y, ax, xa);\n            atom xa \\<sharp> (p, sx, y, ax); atom ax \\<sharp> (p, sx, y);\n            atom y \\<sharp> (p, sx); atom sx \\<sharp> p; x = p\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>v p sx y ax x va pa sxa ya axa xa.\n       \\<lbrakk>atom v \\<sharp> (p, sx, y, ax, x);\n        atom x \\<sharp> (p, sx, y, ax); atom ax \\<sharp> (p, sx, y);\n        atom y \\<sharp> (p, sx); atom sx \\<sharp> p;\n        atom va \\<sharp> (pa, sxa, ya, axa, xa);\n        atom xa \\<sharp> (pa, sxa, ya, axa);\n        atom axa \\<sharp> (pa, sxa, ya); atom ya \\<sharp> (pa, sxa);\n        atom sxa \\<sharp> pa; p = pa\\<rbrakk>\n       \\<Longrightarrow> SyntaxN.Ex v\n                          (SyntaxN.Ex x\n                            (SyntaxN.Ex ax\n                              (SyntaxN.Ex y\n                                (SyntaxN.Ex sx\n                                  (FormP (Var x) AND\n                                   VarP (Var v) AND\n                                   TermP (Var y) AND\n                                   AbstFormP (Var v) Zero (Var x)\n                                    (Var ax) AND\n                                   SubstFormP (Var v) (Var y) (Var x)\n                                    (Var sx) AND\n                                   p EQ\n                                   Q_Imp (Var sx) (Q_Ex (Var ax))))))) =\n                         SyntaxN.Ex va\n                          (SyntaxN.Ex xa\n                            (SyntaxN.Ex axa\n                              (SyntaxN.Ex ya\n                                (SyntaxN.Ex sxa\n                                  (FormP (Var xa) AND\n                                   VarP (Var va) AND\n                                   TermP (Var ya) AND\n                                   AbstFormP (Var va) Zero (Var xa)\n                                    (Var axa) AND\n                                   SubstFormP (Var va) (Var ya) (Var xa)\n                                    (Var sxa) AND\n                                   pa EQ\n                                   Q_Imp (Var sxa) (Q_Ex (Var axa)))))))", "by (auto simp: eqvt_def Special_axP_graph_aux_def flip_fresh_fresh) (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All Special_axP_dom", "by lexicographic_order"], ["", "lemma\n shows Special_axP_fresh_iff [simp]: \"a \\<sharp> Special_axP p \\<longleftrightarrow> a \\<sharp> p\" (is ?thesis1)\n   and eval_fm_Special_axP [simp]: \"eval_fm e (Special_axP p) \\<longleftrightarrow> \\<lbrakk>p\\<rbrakk>e \\<in> Special_ax\" (is ?thesis2)\n   and Special_axP_sf [iff]:       \"Sigma_fm (Special_axP p)\" (is ?thesis3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> Special_axP p = a \\<sharp> p &&&\n    eval_fm e (Special_axP p) = (\\<lbrakk>p\\<rbrakk>e \\<in> Special_ax) &&&\n    Sigma_fm (Special_axP p)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. a \\<sharp> Special_axP p = a \\<sharp> p\n 2. eval_fm e (Special_axP p) = (\\<lbrakk>p\\<rbrakk>e \\<in> Special_ax)\n 3. Sigma_fm (Special_axP p)", "obtain v::name and x::name and ax::name and y::name and sx::name\n    where \"atom v \\<sharp> (p,sx,y,ax,x)\" \"atom x \\<sharp> (p,sx,y,ax)\"\n          \"atom ax \\<sharp> (p,sx,y)\" \"atom y \\<sharp> (p,sx)\" \"atom sx \\<sharp> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v sx y ax x.\n        \\<lbrakk>atom v \\<sharp> (p, sx, y, ax, x);\n         atom x \\<sharp> (p, sx, y, ax); atom ax \\<sharp> (p, sx, y);\n         atom y \\<sharp> (p, sx); atom sx \\<sharp> p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom v \\<sharp> (p, sx, y, ax, x)\n  atom x \\<sharp> (p, sx, y, ax)\n  atom ax \\<sharp> (p, sx, y)\n  atom y \\<sharp> (p, sx)\n  atom sx \\<sharp> p\n\ngoal (3 subgoals):\n 1. a \\<sharp> Special_axP p = a \\<sharp> p\n 2. eval_fm e (Special_axP p) = (\\<lbrakk>p\\<rbrakk>e \\<in> Special_ax)\n 3. Sigma_fm (Special_axP p)", "thus ?thesis1 ?thesis2 ?thesis3"], ["proof (prove)\nusing this:\n  atom v \\<sharp> (p, sx, y, ax, x)\n  atom x \\<sharp> (p, sx, y, ax)\n  atom ax \\<sharp> (p, sx, y)\n  atom y \\<sharp> (p, sx)\n  atom sx \\<sharp> p\n\ngoal (1 subgoal):\n 1. a \\<sharp> Special_axP p = a \\<sharp> p &&&\n    eval_fm e (Special_axP p) = (\\<lbrakk>p\\<rbrakk>e \\<in> Special_ax) &&&\n    Sigma_fm (Special_axP p)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xaa xb xc xd.\n       \\<lbrakk>atom v \\<sharp> (p, sx, y, ax, x);\n        atom x \\<sharp> (p, sx, y, ax); atom ax \\<sharp> (p, sx, y);\n        atom y \\<sharp> (p, sx); atom sx \\<sharp> p; Form xaa; is_Var xa;\n        Term xc; AbstForm xa 0 xaa xb; SubstForm xa xc xaa xd;\n        \\<lbrakk>p\\<rbrakk>e =\n        \\<langle>htuple 3, \\<langle>htuple 4, xd\\<rangle>, htuple 5,\n                 xb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<langle>htuple 3, \\<langle>htuple 4, xd\\<rangle>,\n                                  htuple 5, xb\\<rangle>\n                         \\<in> Special_ax\n 2. \\<lbrakk>atom v \\<sharp> (p, sx, y, ax, x);\n     atom x \\<sharp> (p, sx, y, ax); atom ax \\<sharp> (p, sx, y);\n     atom y \\<sharp> (p, sx); atom sx \\<sharp> p;\n     \\<lbrakk>p\\<rbrakk>e \\<in> Special_ax\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x xa.\n                         Form xa \\<and>\n                         is_Var x \\<and>\n                         (\\<exists>xb xc.\n                             Term xc \\<and>\n                             AbstForm x 0 xa xb \\<and>\n                             (\\<exists>xd.\n                                 SubstForm x xc xa xd \\<and>\n                                 \\<lbrakk>p\\<rbrakk>e =\n                                 \\<langle>htuple 3,\n    \\<langle>htuple 4, xd\\<rangle>, htuple 5, xb\\<rangle>))", "apply (metis q_Disj_def q_Ex_def q_Imp_def q_Neg_def Special_ax.intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom v \\<sharp> (p, sx, y, ax, x);\n     atom x \\<sharp> (p, sx, y, ax); atom ax \\<sharp> (p, sx, y);\n     atom y \\<sharp> (p, sx); atom sx \\<sharp> p;\n     \\<lbrakk>p\\<rbrakk>e \\<in> Special_ax\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x xa.\n                         Form xa \\<and>\n                         is_Var x \\<and>\n                         (\\<exists>xb xc.\n                             Term xc \\<and>\n                             AbstForm x 0 xa xb \\<and>\n                             (\\<exists>xd.\n                                 SubstForm x xc xa xd \\<and>\n                                 \\<lbrakk>p\\<rbrakk>e =\n                                 \\<langle>htuple 3,\n    \\<langle>htuple 4, xd\\<rangle>, htuple 5, xb\\<rangle>))", "apply (metis q_Disj_def q_Ex_def q_Imp_def q_Neg_def Special_ax.cases)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  a \\<sharp> Special_axP p = a \\<sharp> p\n  eval_fm e (Special_axP p) = (\\<lbrakk>p\\<rbrakk>e \\<in> Special_ax)\n  Sigma_fm (Special_axP p)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Correctness (or, correspondence)\\<close>"], ["", "lemma Special_ax_imp_special_axioms:\n  assumes \"x \\<in> Special_ax\" shows \"\\<exists>A. x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and> A \\<in> special_axioms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       A \\<in> special_axioms", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> Special_ax\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       A \\<in> special_axioms", "proof (induction rule: Special_ax.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v x ax y sx.\n       \\<lbrakk>AbstForm v 0 x ax; SubstForm v y x sx; Form x; is_Var v;\n        Term y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp sx (q_Ex ax) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> special_axioms", "case (I v x ax y sx)"], ["proof (state)\nthis:\n  AbstForm v 0 x ax\n  SubstForm v y x sx\n  Form x\n  is_Var v\n  Term y\n\ngoal (1 subgoal):\n 1. \\<And>v x ax y sx.\n       \\<lbrakk>AbstForm v 0 x ax; SubstForm v y x sx; Form x; is_Var v;\n        Term y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp sx (q_Ex ax) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> special_axioms", "obtain fm::fm and u::tm where fm: \"x = \\<lbrakk>\\<guillemotleft>fm\\<guillemotright>\\<rbrakk>e\" and  u: \"y = \\<lbrakk>\\<guillemotleft>u\\<guillemotright>\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fm u.\n        \\<lbrakk>x = \\<lbrakk>\\<guillemotleft>fm\\<guillemotright>\\<rbrakk>e;\n         y = \\<lbrakk>\\<guillemotleft>u\\<guillemotright>\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using I"], ["proof (prove)\nusing this:\n  AbstForm v 0 x ax\n  SubstForm v y x sx\n  Form x\n  is_Var v\n  Term y\n\ngoal (1 subgoal):\n 1. (\\<And>fm u.\n        \\<lbrakk>x = \\<lbrakk>\\<guillemotleft>fm\\<guillemotright>\\<rbrakk>e;\n         y = \\<lbrakk>\\<guillemotleft>u\\<guillemotright>\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: Form_imp_is_fm Term_imp_is_tm)"], ["proof (state)\nthis:\n  x = \\<lbrakk>\\<guillemotleft>fm\\<guillemotright>\\<rbrakk>e\n  y = \\<lbrakk>\\<guillemotleft>u\\<guillemotright>\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>v x ax y sx.\n       \\<lbrakk>AbstForm v 0 x ax; SubstForm v y x sx; Form x; is_Var v;\n        Term y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp sx (q_Ex ax) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> special_axioms", "obtain B where x: \"x  = \\<lbrakk>quot_dbfm B\\<rbrakk>e\"\n            and ax: \"ax = \\<lbrakk>quot_dbfm (abst_dbfm (decode_Var v) 0 B)\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>x = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n         ax =\n         \\<lbrakk>quot_dbfm\n                   (abst_dbfm (decode_Var v) 0 B)\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using I AbstForm_imp_abst_dbfm"], ["proof (prove)\nusing this:\n  AbstForm v 0 x ax\n  SubstForm v y x sx\n  Form x\n  is_Var v\n  Term y\n  AbstForm ?v ?i ?x ?x' \\<Longrightarrow>\n  \\<exists>A.\n     ?x = \\<lbrakk>quot_dbfm A\\<rbrakk>?e \\<and>\n     ?x' =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var ?v) (nat_of_ord ?i) A)\\<rbrakk>?e\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>x = \\<lbrakk>quot_dbfm B\\<rbrakk>e;\n         ax =\n         \\<lbrakk>quot_dbfm\n                   (abst_dbfm (decode_Var v) 0 B)\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  x = \\<lbrakk>quot_dbfm B\\<rbrakk>e\n  ax = \\<lbrakk>quot_dbfm (abst_dbfm (decode_Var v) 0 B)\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>v x ax y sx.\n       \\<lbrakk>AbstForm v 0 x ax; SubstForm v y x sx; Form x; is_Var v;\n        Term y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp sx (q_Ex ax) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> special_axioms", "obtain B' where x': \"x = \\<lbrakk>quot_dbfm B'\\<rbrakk>e\"\n             and sx: \"sx = \\<lbrakk>quot_dbfm (subst_dbfm (trans_tm [] u) (decode_Var v) B')\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B'.\n        \\<lbrakk>x = \\<lbrakk>quot_dbfm B'\\<rbrakk>e;\n         sx =\n         \\<lbrakk>quot_dbfm\n                   (subst_dbfm (trans_tm [] u) (decode_Var v)\n                     B')\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using I"], ["proof (prove)\nusing this:\n  AbstForm v 0 x ax\n  SubstForm v y x sx\n  Form x\n  is_Var v\n  Term y\n\ngoal (1 subgoal):\n 1. (\\<And>B'.\n        \\<lbrakk>x = \\<lbrakk>quot_dbfm B'\\<rbrakk>e;\n         sx =\n         \\<lbrakk>quot_dbfm\n                   (subst_dbfm (trans_tm [] u) (decode_Var v)\n                     B')\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis u SubstForm_imp_subst_dbfm_lemma quot_tm_def)"], ["proof (state)\nthis:\n  x = \\<lbrakk>quot_dbfm B'\\<rbrakk>e\n  sx =\n  \\<lbrakk>quot_dbfm\n            (subst_dbfm (trans_tm [] u) (decode_Var v) B')\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>v x ax y sx.\n       \\<lbrakk>AbstForm v 0 x ax; SubstForm v y x sx; Form x; is_Var v;\n        Term y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp sx (q_Ex ax) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> special_axioms", "have eq: \"B'=B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B' = B", "by (metis quot_dbfm_inject_lemma x x')"], ["proof (state)\nthis:\n  B' = B\n\ngoal (1 subgoal):\n 1. \\<And>v x ax y sx.\n       \\<lbrakk>AbstForm v 0 x ax; SubstForm v y x sx; Form x; is_Var v;\n        Term y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp sx (q_Ex ax) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> special_axioms", "have \"fm(decode_Var v::=u) IMP SyntaxN.Ex (decode_Var v) fm \\<in> special_axioms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fm(decode_Var v::=u) IMP SyntaxN.Ex (decode_Var v) fm\n    \\<in> special_axioms", "by (metis special_axioms.intros)"], ["proof (state)\nthis:\n  fm(decode_Var v::=u) IMP SyntaxN.Ex (decode_Var v) fm \\<in> special_axioms\n\ngoal (1 subgoal):\n 1. \\<And>v x ax y sx.\n       \\<lbrakk>AbstForm v 0 x ax; SubstForm v y x sx; Form x; is_Var v;\n        Term y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp sx (q_Ex ax) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> special_axioms", "thus ?case"], ["proof (prove)\nusing this:\n  fm(decode_Var v::=u) IMP SyntaxN.Ex (decode_Var v) fm \\<in> special_axioms\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       q_Imp sx (q_Ex ax) =\n       \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       A \\<in> special_axioms", "using eq"], ["proof (prove)\nusing this:\n  fm(decode_Var v::=u) IMP SyntaxN.Ex (decode_Var v) fm \\<in> special_axioms\n  B' = B\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       q_Imp sx (q_Ex ax) =\n       \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       A \\<in> special_axioms", "apply (auto simp: quot_simps q_defs \n                intro!: exI [where x = \"fm((decode_Var v)::=u) IMP (Ex (decode_Var v) fm)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fm(decode_Var v::=u) IMP SyntaxN.Ex (decode_Var v) fm\n             \\<in> special_axioms;\n     B' = B\\<rbrakk>\n    \\<Longrightarrow> sx =\n                      \\<lbrakk>\\<guillemotleft>fm(decode_Var\n             v::=u)\\<guillemotright>\\<rbrakk>e\n 2. \\<lbrakk>fm(decode_Var v::=u) IMP SyntaxN.Ex (decode_Var v) fm\n             \\<in> special_axioms;\n     B' = B\\<rbrakk>\n    \\<Longrightarrow> ax =\n                      \\<lbrakk>quot_dbfm\n                                (trans_fm [decode_Var v] fm)\\<rbrakk>e", "apply (metis fm quot_dbfm_inject_lemma quot_fm_def subst_fm_trans_commute sx x')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fm(decode_Var v::=u) IMP SyntaxN.Ex (decode_Var v) fm\n             \\<in> special_axioms;\n     B' = B\\<rbrakk>\n    \\<Longrightarrow> ax =\n                      \\<lbrakk>quot_dbfm\n                                (trans_fm [decode_Var v] fm)\\<rbrakk>e", "apply (metis abst_trans_fm ax fm quot_dbfm_inject_lemma quot_fm_def x)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>A.\n     q_Imp sx (q_Ex ax) =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     A \\<in> special_axioms\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma special_axioms_into_Special_ax: \"A \\<in> special_axioms \\<Longrightarrow> \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<in> Special_ax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> special_axioms \\<Longrightarrow>\n    \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<in> Special_ax", "proof (induct rule: special_axioms.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A i x.\n       \\<lbrakk>\\<guillemotleft>A(i::=x) IMP\n                                SyntaxN.Ex i A\\<guillemotright>\\<rbrakk>e\n       \\<in> Special_ax", "case (I A i t)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>A i x.\n       \\<lbrakk>\\<guillemotleft>A(i::=x) IMP\n                                SyntaxN.Ex i A\\<guillemotright>\\<rbrakk>e\n       \\<in> Special_ax", "have \"\\<lbrakk>\\<guillemotleft>A(i::=t) IMP SyntaxN.Ex i A\\<guillemotright>\\<rbrakk>e =\n        q_Imp \\<lbrakk>quot_dbfm (subst_dbfm (trans_tm [] t) i (trans_fm [] A))\\<rbrakk>e\n              (q_Ex \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<guillemotleft>A(i::=t) IMP\n                             SyntaxN.Ex i A\\<guillemotright>\\<rbrakk>e =\n    q_Imp\n     \\<lbrakk>quot_dbfm\n               (subst_dbfm (trans_tm [] t) i (trans_fm [] A))\\<rbrakk>e\n     (q_Ex \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e)", "by (simp add: quot_fm_def q_defs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<guillemotleft>A(i::=t) IMP\n                           SyntaxN.Ex i A\\<guillemotright>\\<rbrakk>e =\n  q_Imp\n   \\<lbrakk>quot_dbfm\n             (subst_dbfm (trans_tm [] t) i (trans_fm [] A))\\<rbrakk>e\n   (q_Ex \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e)\n\ngoal (1 subgoal):\n 1. \\<And>A i x.\n       \\<lbrakk>\\<guillemotleft>A(i::=x) IMP\n                                SyntaxN.Ex i A\\<guillemotright>\\<rbrakk>e\n       \\<in> Special_ax", "also"], ["proof (state)\nthis:\n  \\<lbrakk>\\<guillemotleft>A(i::=t) IMP\n                           SyntaxN.Ex i A\\<guillemotright>\\<rbrakk>e =\n  q_Imp\n   \\<lbrakk>quot_dbfm\n             (subst_dbfm (trans_tm [] t) i (trans_fm [] A))\\<rbrakk>e\n   (q_Ex \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e)\n\ngoal (1 subgoal):\n 1. \\<And>A i x.\n       \\<lbrakk>\\<guillemotleft>A(i::=x) IMP\n                                SyntaxN.Ex i A\\<guillemotright>\\<rbrakk>e\n       \\<in> Special_ax", "have \"... \\<in> Special_ax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q_Imp\n     \\<lbrakk>quot_dbfm\n               (subst_dbfm (trans_tm [] t) i (trans_fm [] A))\\<rbrakk>e\n     (q_Ex \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e)\n    \\<in> Special_ax", "apply (rule Special_ax.intros [OF AbstForm_trans_fm])"], ["proof (prove)\ngoal (4 subgoals):\n 1. SubstForm (q_Var i) ?y\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n     \\<lbrakk>quot_dbfm\n               (subst_dbfm (trans_tm [] t) i (trans_fm [] A))\\<rbrakk>e\n 2. Form \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 3. is_Var (q_Var i)\n 4. Term ?y", "apply (auto simp: quot_fm_def [symmetric] intro: SubstForm_quot [unfolded eval_Var_q])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  q_Imp\n   \\<lbrakk>quot_dbfm\n             (subst_dbfm (trans_tm [] t) i (trans_fm [] A))\\<rbrakk>e\n   (q_Ex \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e)\n  \\<in> Special_ax\n\ngoal (1 subgoal):\n 1. \\<And>A i x.\n       \\<lbrakk>\\<guillemotleft>A(i::=x) IMP\n                                SyntaxN.Ex i A\\<guillemotright>\\<rbrakk>e\n       \\<in> Special_ax", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<guillemotleft>A(i::=t) IMP\n                           SyntaxN.Ex i A\\<guillemotright>\\<rbrakk>e\n  \\<in> Special_ax", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<guillemotleft>A(i::=t) IMP\n                           SyntaxN.Ex i A\\<guillemotright>\\<rbrakk>e\n  \\<in> Special_ax\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<guillemotleft>A(i::=t) IMP\n                             SyntaxN.Ex i A\\<guillemotright>\\<rbrakk>e\n    \\<in> Special_ax", "."], ["proof (state)\nthis:\n  \\<lbrakk>\\<guillemotleft>A(i::=t) IMP\n                           SyntaxN.Ex i A\\<guillemotright>\\<rbrakk>e\n  \\<in> Special_ax\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>We have precisely captured the codes of the specialisation axioms.\\<close>"], ["", "corollary Special_ax_eq_special_axioms: \"Special_ax = (\\<Union>A \\<in> special_axioms. { \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Special_ax =\n    (\\<Union>A\\<in>special_axioms.\n        {\\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e})", "by (force dest: special_axioms_into_Special_ax Special_ax_imp_special_axioms)"], ["", "subsection \\<open>The induction axioms\\<close>"], ["", "inductive_set Induction_ax :: \"hf set\" where\n  I: \"\\<lbrakk>SubstForm v 0 x x0;\n       SubstForm v w x xw;\n       SubstForm v (q_Eats v w) x xevw;\n       AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw;\n       AbstForm v 0 (q_All allw) allvw;\n       AbstForm v 0 x ax;\n       v \\<noteq> w; VarNonOccForm w x\\<rbrakk>\n      \\<Longrightarrow> q_Imp x0 (q_Imp (q_All allvw) (q_All ax)) \\<in> Induction_ax\""], ["", "subsubsection \\<open>Defining the syntax\\<close>"], ["", "nominal_function Induction_axP :: \"tm \\<Rightarrow> fm\" where\n  \"\\<lbrakk>atom ax \\<sharp> (p,v,w,x,x0,xw,xevw,allw,allvw);\n    atom allvw \\<sharp> (p,v,w,x,x0,xw,xevw,allw); atom allw \\<sharp> (p,v,w,x,x0,xw,xevw);\n    atom xevw \\<sharp> (p,v,w,x,x0,xw); atom xw \\<sharp> (p,v,w,x,x0);\n    atom x0 \\<sharp> (p,v,w,x); atom x \\<sharp> (p,v,w);\n    atom w \\<sharp> (p,v); atom v \\<sharp> p\\<rbrakk> \\<Longrightarrow>\n  Induction_axP p = Ex v (Ex w (Ex x (Ex x0 (Ex xw (Ex xevw (Ex allw (Ex allvw (Ex ax\n               ((Var v NEQ Var w) AND VarNonOccFormP (Var w) (Var x) AND\n                SubstFormP (Var v) Zero (Var x) (Var x0) AND\n                SubstFormP (Var v) (Var w) (Var x) (Var xw) AND\n                SubstFormP (Var v) (Q_Eats (Var v) (Var w)) (Var x) (Var xevw) AND\n                AbstFormP (Var w) Zero (Q_Imp (Var x) (Q_Imp (Var xw) (Var xevw))) (Var allw) AND\n                AbstFormP (Var v) Zero (Q_All (Var allw)) (Var allvw) AND\n                AbstFormP (Var v) Zero (Var x) (Var ax) AND\n                p EQ Q_Imp (Var x0) (Q_Imp (Q_All (Var allvw)) (Q_All (Var ax))))))))))))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt Induction_axP_graph_aux\n 2. \\<And>x y. Induction_axP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>ax p v w xa x0 xw xevw allw allvw.\n           \\<lbrakk>atom\n                     ax \\<sharp> (p, v, w, xa, x0, xw, xevw, allw, allvw);\n            atom allvw \\<sharp> (p, v, w, xa, x0, xw, xevw, allw);\n            atom allw \\<sharp> (p, v, w, xa, x0, xw, xevw);\n            atom xevw \\<sharp> (p, v, w, xa, x0, xw);\n            atom xw \\<sharp> (p, v, w, xa, x0);\n            atom x0 \\<sharp> (p, v, w, xa); atom xa \\<sharp> (p, v, w);\n            atom w \\<sharp> (p, v); atom v \\<sharp> p; x = p\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>ax p v w x x0 xw xevw allw allvw axa pa va wa xa x0a xwa xevwa\n       allwa allvwa.\n       \\<lbrakk>atom ax \\<sharp> (p, v, w, x, x0, xw, xevw, allw, allvw);\n        atom allvw \\<sharp> (p, v, w, x, x0, xw, xevw, allw);\n        atom allw \\<sharp> (p, v, w, x, x0, xw, xevw);\n        atom xevw \\<sharp> (p, v, w, x, x0, xw);\n        atom xw \\<sharp> (p, v, w, x, x0); atom x0 \\<sharp> (p, v, w, x);\n        atom x \\<sharp> (p, v, w); atom w \\<sharp> (p, v);\n        atom v \\<sharp> p;\n        atom axa \\<sharp> (pa, va, wa, xa, x0a, xwa, xevwa, allwa, allvwa);\n        atom allvwa \\<sharp> (pa, va, wa, xa, x0a, xwa, xevwa, allwa);\n        atom allwa \\<sharp> (pa, va, wa, xa, x0a, xwa, xevwa);\n        atom xevwa \\<sharp> (pa, va, wa, xa, x0a, xwa);\n        atom xwa \\<sharp> (pa, va, wa, xa, x0a);\n        atom x0a \\<sharp> (pa, va, wa, xa); atom xa \\<sharp> (pa, va, wa);\n        atom wa \\<sharp> (pa, va); atom va \\<sharp> pa; p = pa\\<rbrakk>\n       \\<Longrightarrow> SyntaxN.Ex v\n                          (SyntaxN.Ex w\n                            (SyntaxN.Ex x\n                              (SyntaxN.Ex x0\n                                (SyntaxN.Ex xw\n                                  (SyntaxN.Ex xevw\n                                    (SyntaxN.Ex allw\n(SyntaxN.Ex allvw\n  (SyntaxN.Ex ax\n    (Var v NEQ Var w AND\n     VarNonOccFormP (Var w) (Var x) AND\n     SubstFormP (Var v) Zero (Var x) (Var x0) AND\n     SubstFormP (Var v) (Var w) (Var x) (Var xw) AND\n     SubstFormP (Var v) (Q_Eats (Var v) (Var w)) (Var x) (Var xevw) AND\n     AbstFormP (Var w) Zero (Q_Imp (Var x) (Q_Imp (Var xw) (Var xevw)))\n      (Var allw) AND\n     AbstFormP (Var v) Zero (Q_All (Var allw)) (Var allvw) AND\n     AbstFormP (Var v) Zero (Var x) (Var ax) AND\n     p EQ\n     Q_Imp (Var x0) (Q_Imp (Q_All (Var allvw)) (Q_All (Var ax)))))))))))) =\n                         SyntaxN.Ex va\n                          (SyntaxN.Ex wa\n                            (SyntaxN.Ex xa\n                              (SyntaxN.Ex x0a\n                                (SyntaxN.Ex xwa\n                                  (SyntaxN.Ex xevwa\n                                    (SyntaxN.Ex allwa\n(SyntaxN.Ex allvwa\n  (SyntaxN.Ex axa\n    (Var va NEQ Var wa AND\n     VarNonOccFormP (Var wa) (Var xa) AND\n     SubstFormP (Var va) Zero (Var xa) (Var x0a) AND\n     SubstFormP (Var va) (Var wa) (Var xa) (Var xwa) AND\n     SubstFormP (Var va) (Q_Eats (Var va) (Var wa)) (Var xa) (Var xevwa) AND\n     AbstFormP (Var wa) Zero (Q_Imp (Var xa) (Q_Imp (Var xwa) (Var xevwa)))\n      (Var allwa) AND\n     AbstFormP (Var va) Zero (Q_All (Var allwa)) (Var allvwa) AND\n     AbstFormP (Var va) Zero (Var xa) (Var axa) AND\n     pa EQ\n     Q_Imp (Var x0a) (Q_Imp (Q_All (Var allvwa)) (Q_All (Var axa))))))))))))", "by (auto simp: eqvt_def Induction_axP_graph_aux_def flip_fresh_fresh) (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All Induction_axP_dom", "by lexicographic_order"], ["", "lemma\n shows Induction_axP_fresh_iff [simp]: \"a \\<sharp> Induction_axP p \\<longleftrightarrow> a \\<sharp> p\" (is ?thesis1)\n   and eval_fm_Induction_axP [simp]:\n      \"eval_fm e (Induction_axP p) \\<longleftrightarrow> \\<lbrakk>p\\<rbrakk>e \\<in> Induction_ax\"    (is ?thesis2)\n   and Induction_axP_sf [iff]: \"Sigma_fm (Induction_axP p)\" (is ?thesis3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> Induction_axP p = a \\<sharp> p &&&\n    eval_fm e (Induction_axP p) =\n    (\\<lbrakk>p\\<rbrakk>e \\<in> Induction_ax) &&&\n    Sigma_fm (Induction_axP p)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. a \\<sharp> Induction_axP p = a \\<sharp> p\n 2. eval_fm e (Induction_axP p) = (\\<lbrakk>p\\<rbrakk>e \\<in> Induction_ax)\n 3. Sigma_fm (Induction_axP p)", "obtain v::name and w::name and x::name and x0::name and xw::name and xevw::name\n                 and allw::name and allvw::name and ax::name\n    where atoms: \"atom ax \\<sharp> (p,v,w,x,x0,xw,xevw,allw,allvw)\"\n                 \"atom allvw \\<sharp> (p,v,w,x,x0,xw,xevw,allw)\" \"atom allw \\<sharp> (p,v,w,x,x0,xw,xevw)\"\n                 \"atom xevw \\<sharp> (p,v,w,x,x0,xw)\" \"atom xw \\<sharp> (p,v,w,x,x0)\" \"atom x0 \\<sharp> (p,v,w,x)\"\n                 \"atom x \\<sharp> (p,v,w)\" \"atom w \\<sharp> (p,v)\" \"atom v \\<sharp> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ax v w x x0 xw xevw allw allvw.\n        \\<lbrakk>atom ax \\<sharp> (p, v, w, x, x0, xw, xevw, allw, allvw);\n         atom allvw \\<sharp> (p, v, w, x, x0, xw, xevw, allw);\n         atom allw \\<sharp> (p, v, w, x, x0, xw, xevw);\n         atom xevw \\<sharp> (p, v, w, x, x0, xw);\n         atom xw \\<sharp> (p, v, w, x, x0); atom x0 \\<sharp> (p, v, w, x);\n         atom x \\<sharp> (p, v, w); atom w \\<sharp> (p, v);\n         atom v \\<sharp> p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom ax \\<sharp> (p, v, w, x, x0, xw, xevw, allw, allvw)\n  atom allvw \\<sharp> (p, v, w, x, x0, xw, xevw, allw)\n  atom allw \\<sharp> (p, v, w, x, x0, xw, xevw)\n  atom xevw \\<sharp> (p, v, w, x, x0, xw)\n  atom xw \\<sharp> (p, v, w, x, x0)\n  atom x0 \\<sharp> (p, v, w, x)\n  atom x \\<sharp> (p, v, w)\n  atom w \\<sharp> (p, v)\n  atom v \\<sharp> p\n\ngoal (3 subgoals):\n 1. a \\<sharp> Induction_axP p = a \\<sharp> p\n 2. eval_fm e (Induction_axP p) = (\\<lbrakk>p\\<rbrakk>e \\<in> Induction_ax)\n 3. Sigma_fm (Induction_axP p)", "thus ?thesis1 ?thesis3"], ["proof (prove)\nusing this:\n  atom ax \\<sharp> (p, v, w, x, x0, xw, xevw, allw, allvw)\n  atom allvw \\<sharp> (p, v, w, x, x0, xw, xevw, allw)\n  atom allw \\<sharp> (p, v, w, x, x0, xw, xevw)\n  atom xevw \\<sharp> (p, v, w, x, x0, xw)\n  atom xw \\<sharp> (p, v, w, x, x0)\n  atom x0 \\<sharp> (p, v, w, x)\n  atom x \\<sharp> (p, v, w)\n  atom w \\<sharp> (p, v)\n  atom v \\<sharp> p\n\ngoal (1 subgoal):\n 1. a \\<sharp> Induction_axP p = a \\<sharp> p &&& Sigma_fm (Induction_axP p)", "by auto"], ["proof (state)\nthis:\n  a \\<sharp> Induction_axP p = a \\<sharp> p\n  Sigma_fm (Induction_axP p)\n\ngoal (1 subgoal):\n 1. eval_fm e (Induction_axP p) = (\\<lbrakk>p\\<rbrakk>e \\<in> Induction_ax)", "show ?thesis2"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_fm e (Induction_axP p) = (\\<lbrakk>p\\<rbrakk>e \\<in> Induction_ax)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. eval_fm e (Induction_axP p) \\<Longrightarrow>\n    \\<lbrakk>p\\<rbrakk>e \\<in> Induction_ax\n 2. \\<lbrakk>p\\<rbrakk>e \\<in> Induction_ax \\<Longrightarrow>\n    eval_fm e (Induction_axP p)", "assume \"eval_fm e (Induction_axP p)\""], ["proof (state)\nthis:\n  eval_fm e (Induction_axP p)\n\ngoal (2 subgoals):\n 1. eval_fm e (Induction_axP p) \\<Longrightarrow>\n    \\<lbrakk>p\\<rbrakk>e \\<in> Induction_ax\n 2. \\<lbrakk>p\\<rbrakk>e \\<in> Induction_ax \\<Longrightarrow>\n    eval_fm e (Induction_axP p)", "thus \"\\<lbrakk>p\\<rbrakk>e \\<in> Induction_ax\""], ["proof (prove)\nusing this:\n  eval_fm e (Induction_axP p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p\\<rbrakk>e \\<in> Induction_ax", "using atoms"], ["proof (prove)\nusing this:\n  eval_fm e (Induction_axP p)\n  atom ax \\<sharp> (p, v, w, x, x0, xw, xevw, allw, allvw)\n  atom allvw \\<sharp> (p, v, w, x, x0, xw, xevw, allw)\n  atom allw \\<sharp> (p, v, w, x, x0, xw, xevw)\n  atom xevw \\<sharp> (p, v, w, x, x0, xw)\n  atom xw \\<sharp> (p, v, w, x, x0)\n  atom x0 \\<sharp> (p, v, w, x)\n  atom x \\<sharp> (p, v, w)\n  atom w \\<sharp> (p, v)\n  atom v \\<sharp> p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p\\<rbrakk>e \\<in> Induction_ax", "by (auto intro!: Induction_ax.I [unfolded q_defs])"], ["proof (state)\nthis:\n  \\<lbrakk>p\\<rbrakk>e \\<in> Induction_ax\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p\\<rbrakk>e \\<in> Induction_ax \\<Longrightarrow>\n    eval_fm e (Induction_axP p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p\\<rbrakk>e \\<in> Induction_ax \\<Longrightarrow>\n    eval_fm e (Induction_axP p)", "assume \"\\<lbrakk>p\\<rbrakk>e \\<in> Induction_ax\""], ["proof (state)\nthis:\n  \\<lbrakk>p\\<rbrakk>e \\<in> Induction_ax\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p\\<rbrakk>e \\<in> Induction_ax \\<Longrightarrow>\n    eval_fm e (Induction_axP p)", "thus \"eval_fm e (Induction_axP p)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>p\\<rbrakk>e \\<in> Induction_ax\n\ngoal (1 subgoal):\n 1. eval_fm e (Induction_axP p)", "apply (rule Induction_ax.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v x x0 w xw xevw allw allvw ax.\n       \\<lbrakk>\\<lbrakk>p\\<rbrakk>e =\n                q_Imp x0 (q_Imp (q_All allvw) (q_All ax));\n        SubstForm v 0 x x0; SubstForm v w x xw;\n        SubstForm v (q_Eats v w) x xevw;\n        AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw;\n        AbstForm v 0 (q_All allw) allvw; AbstForm v 0 x ax; v \\<noteq> w;\n        VarNonOccForm w x\\<rbrakk>\n       \\<Longrightarrow> eval_fm e (Induction_axP p)", "using atoms"], ["proof (prove)\nusing this:\n  atom ax \\<sharp> (p, v, w, x, x0, xw, xevw, allw, allvw)\n  atom allvw \\<sharp> (p, v, w, x, x0, xw, xevw, allw)\n  atom allw \\<sharp> (p, v, w, x, x0, xw, xevw)\n  atom xevw \\<sharp> (p, v, w, x, x0, xw)\n  atom xw \\<sharp> (p, v, w, x, x0)\n  atom x0 \\<sharp> (p, v, w, x)\n  atom x \\<sharp> (p, v, w)\n  atom w \\<sharp> (p, v)\n  atom v \\<sharp> p\n\ngoal (1 subgoal):\n 1. \\<And>v x x0 w xw xevw allw allvw ax.\n       \\<lbrakk>\\<lbrakk>p\\<rbrakk>e =\n                q_Imp x0 (q_Imp (q_All allvw) (q_All ax));\n        SubstForm v 0 x x0; SubstForm v w x xw;\n        SubstForm v (q_Eats v w) x xevw;\n        AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw;\n        AbstForm v 0 (q_All allw) allvw; AbstForm v 0 x ax; v \\<noteq> w;\n        VarNonOccForm w x\\<rbrakk>\n       \\<Longrightarrow> eval_fm e (Induction_axP p)", "apply (force simp: q_defs htuple_minus_1 intro!: AbstForm_imp_Ord)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eval_fm e (Induction_axP p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_fm e (Induction_axP p) = (\\<lbrakk>p\\<rbrakk>e \\<in> Induction_ax)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Correctness (or, correspondence)\\<close>"], ["", "lemma Induction_ax_imp_induction_axioms:\n  assumes \"x \\<in> Induction_ax\" shows \"\\<exists>A. x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and> A \\<in> induction_axioms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       A \\<in> induction_axioms", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> Induction_ax\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       A \\<in> induction_axioms", "proof (induction rule: Induction_ax.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v x x0 w xw xevw allw allvw ax.\n       \\<lbrakk>SubstForm v 0 x x0; SubstForm v w x xw;\n        SubstForm v (q_Eats v w) x xevw;\n        AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw;\n        AbstForm v 0 (q_All allw) allvw; AbstForm v 0 x ax; v \\<noteq> w;\n        VarNonOccForm w x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp x0 (q_Imp (q_All allvw) (q_All ax)) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> induction_axioms", "case (I v x x0 w xw xevw allw allvw ax)"], ["proof (state)\nthis:\n  SubstForm v 0 x x0\n  SubstForm v w x xw\n  SubstForm v (q_Eats v w) x xevw\n  AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw\n  AbstForm v 0 (q_All allw) allvw\n  AbstForm v 0 x ax\n  v \\<noteq> w\n  VarNonOccForm w x\n\ngoal (1 subgoal):\n 1. \\<And>v x x0 w xw xevw allw allvw ax.\n       \\<lbrakk>SubstForm v 0 x x0; SubstForm v w x xw;\n        SubstForm v (q_Eats v w) x xevw;\n        AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw;\n        AbstForm v 0 (q_All allw) allvw; AbstForm v 0 x ax; v \\<noteq> w;\n        VarNonOccForm w x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp x0 (q_Imp (q_All allvw) (q_All ax)) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> induction_axioms", "then"], ["proof (chain)\npicking this:\n  SubstForm v 0 x x0\n  SubstForm v w x xw\n  SubstForm v (q_Eats v w) x xevw\n  AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw\n  AbstForm v 0 (q_All allw) allvw\n  AbstForm v 0 x ax\n  v \\<noteq> w\n  VarNonOccForm w x", "have v: \"is_Var v\" and w: \"is_Var w\"\n        and dvw [simp]: \"decode_Var v \\<noteq> decode_Var w\"  \"atom (decode_Var w) \\<sharp> [decode_Var v]\""], ["proof (prove)\nusing this:\n  SubstForm v 0 x x0\n  SubstForm v w x xw\n  SubstForm v (q_Eats v w) x xevw\n  AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw\n  AbstForm v 0 (q_All allw) allvw\n  AbstForm v 0 x ax\n  v \\<noteq> w\n  VarNonOccForm w x\n\ngoal (1 subgoal):\n 1. is_Var v &&&\n    is_Var w &&&\n    decode_Var v \\<noteq> decode_Var w &&&\n    atom (decode_Var w) \\<sharp> [decode_Var v]", "by (auto simp: AbstForm_def fresh_Cons)"], ["proof (state)\nthis:\n  is_Var v\n  is_Var w\n  decode_Var v \\<noteq> decode_Var w\n  atom (decode_Var w) \\<sharp> [decode_Var v]\n\ngoal (1 subgoal):\n 1. \\<And>v x x0 w xw xevw allw allvw ax.\n       \\<lbrakk>SubstForm v 0 x x0; SubstForm v w x xw;\n        SubstForm v (q_Eats v w) x xevw;\n        AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw;\n        AbstForm v 0 (q_All allw) allvw; AbstForm v 0 x ax; v \\<noteq> w;\n        VarNonOccForm w x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp x0 (q_Imp (q_All allvw) (q_All ax)) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> induction_axioms", "obtain A::fm where A: \"x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\" and wfresh: \"atom (decode_Var w) \\<sharp> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n         atom (decode_Var w) \\<sharp> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using I VarNonOccForm_imp_fresh"], ["proof (prove)\nusing this:\n  SubstForm v 0 x x0\n  SubstForm v w x xw\n  SubstForm v (q_Eats v w) x xevw\n  AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw\n  AbstForm v 0 (q_All allw) allvw\n  AbstForm v 0 x ax\n  v \\<noteq> w\n  VarNonOccForm w x\n  \\<lbrakk>VarNonOccForm ?v ?x;\n   \\<And>A.\n      \\<lbrakk>?x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>?e;\n       atom (decode_Var ?v) \\<sharp> A\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n         atom (decode_Var w) \\<sharp> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n  atom (decode_Var w) \\<sharp> A\n\ngoal (1 subgoal):\n 1. \\<And>v x x0 w xw xevw allw allvw ax.\n       \\<lbrakk>SubstForm v 0 x x0; SubstForm v w x xw;\n        SubstForm v (q_Eats v w) x xevw;\n        AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw;\n        AbstForm v 0 (q_All allw) allvw; AbstForm v 0 x ax; v \\<noteq> w;\n        VarNonOccForm w x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp x0 (q_Imp (q_All allvw) (q_All ax)) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> induction_axioms", "then"], ["proof (chain)\npicking this:\n  x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n  atom (decode_Var w) \\<sharp> A", "obtain A' A'' where A': \"q_Imp (\\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e) (q_Imp xw xevw) = \\<lbrakk>quot_dbfm A'\\<rbrakk>e\"\n                       and A'': \"q_All allw = \\<lbrakk>quot_dbfm A''\\<rbrakk>e\""], ["proof (prove)\nusing this:\n  x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n  atom (decode_Var w) \\<sharp> A\n\ngoal (1 subgoal):\n 1. (\\<And>A' A''.\n        \\<lbrakk>q_Imp \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n                  (q_Imp xw xevw) =\n                 \\<lbrakk>quot_dbfm A'\\<rbrakk>e;\n         q_All allw = \\<lbrakk>quot_dbfm A''\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using I VarNonOccForm_imp_fresh"], ["proof (prove)\nusing this:\n  x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n  atom (decode_Var w) \\<sharp> A\n  SubstForm v 0 x x0\n  SubstForm v w x xw\n  SubstForm v (q_Eats v w) x xevw\n  AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw\n  AbstForm v 0 (q_All allw) allvw\n  AbstForm v 0 x ax\n  v \\<noteq> w\n  VarNonOccForm w x\n  \\<lbrakk>VarNonOccForm ?v ?x;\n   \\<And>A.\n      \\<lbrakk>?x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>?e;\n       atom (decode_Var ?v) \\<sharp> A\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>A' A''.\n        \\<lbrakk>q_Imp \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n                  (q_Imp xw xevw) =\n                 \\<lbrakk>quot_dbfm A'\\<rbrakk>e;\n         q_All allw = \\<lbrakk>quot_dbfm A''\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest!: AbstForm_imp_abst_dbfm)"], ["proof (state)\nthis:\n  q_Imp \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n   (q_Imp xw xevw) =\n  \\<lbrakk>quot_dbfm A'\\<rbrakk>e\n  q_All allw = \\<lbrakk>quot_dbfm A''\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>v x x0 w xw xevw allw allvw ax.\n       \\<lbrakk>SubstForm v 0 x x0; SubstForm v w x xw;\n        SubstForm v (q_Eats v w) x xevw;\n        AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw;\n        AbstForm v 0 (q_All allw) allvw; AbstForm v 0 x ax; v \\<noteq> w;\n        VarNonOccForm w x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp x0 (q_Imp (q_All allvw) (q_All ax)) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> induction_axioms", "define Aw where \"Aw = A(decode_Var v::=Var (decode_Var w))\""], ["proof (state)\nthis:\n  Aw = A(decode_Var v::=Var (decode_Var w))\n\ngoal (1 subgoal):\n 1. \\<And>v x x0 w xw xevw allw allvw ax.\n       \\<lbrakk>SubstForm v 0 x x0; SubstForm v w x xw;\n        SubstForm v (q_Eats v w) x xevw;\n        AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw;\n        AbstForm v 0 (q_All allw) allvw; AbstForm v 0 x ax; v \\<noteq> w;\n        VarNonOccForm w x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp x0 (q_Imp (q_All allvw) (q_All ax)) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> induction_axioms", "define Ae where \"Ae = A(decode_Var v::= Eats (Var (decode_Var v)) (Var (decode_Var w)))\""], ["proof (state)\nthis:\n  Ae = A(decode_Var v::=Eats (Var (decode_Var v)) (Var (decode_Var w)))\n\ngoal (1 subgoal):\n 1. \\<And>v x x0 w xw xevw allw allvw ax.\n       \\<lbrakk>SubstForm v 0 x x0; SubstForm v w x xw;\n        SubstForm v (q_Eats v w) x xevw;\n        AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw;\n        AbstForm v 0 (q_All allw) allvw; AbstForm v 0 x ax; v \\<noteq> w;\n        VarNonOccForm w x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp x0 (q_Imp (q_All allvw) (q_All ax)) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> induction_axioms", "have x0: \"x0 = \\<lbrakk>\\<guillemotleft>A(decode_Var v::=Zero)\\<guillemotright>\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x0 =\n    \\<lbrakk>\\<guillemotleft>A(decode_Var\n                                v::=Zero)\\<guillemotright>\\<rbrakk>e", "using I SubstForm_imp_subst_fm"], ["proof (prove)\nusing this:\n  SubstForm v 0 x x0\n  SubstForm v w x xw\n  SubstForm v (q_Eats v w) x xevw\n  AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw\n  AbstForm v 0 (q_All allw) allvw\n  AbstForm v 0 x ax\n  v \\<noteq> w\n  VarNonOccForm w x\n  \\<lbrakk>SubstForm ?v\n            \\<lbrakk>\\<guillemotleft>?u\\<guillemotright>\\<rbrakk>?e ?x ?x';\n   Form ?x;\n   \\<And>A.\n      \\<lbrakk>?x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>?e;\n       ?x' =\n       \\<lbrakk>\\<guillemotleft>A(decode_Var\n                                   ?v::=?u)\\<guillemotright>\\<rbrakk>?e\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. x0 =\n    \\<lbrakk>\\<guillemotleft>A(decode_Var\n                                v::=Zero)\\<guillemotright>\\<rbrakk>e", "by (metis A Form_quot_fm eval_fm_inject eval_tm.simps(1) quot_Zero)"], ["proof (state)\nthis:\n  x0 =\n  \\<lbrakk>\\<guillemotleft>A(decode_Var v::=Zero)\\<guillemotright>\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>v x x0 w xw xevw allw allvw ax.\n       \\<lbrakk>SubstForm v 0 x x0; SubstForm v w x xw;\n        SubstForm v (q_Eats v w) x xevw;\n        AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw;\n        AbstForm v 0 (q_All allw) allvw; AbstForm v 0 x ax; v \\<noteq> w;\n        VarNonOccForm w x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp x0 (q_Imp (q_All allvw) (q_All ax)) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> induction_axioms", "have xw: \"xw = \\<lbrakk>\\<guillemotleft>Aw\\<guillemotright>\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xw = \\<lbrakk>\\<guillemotleft>Aw\\<guillemotright>\\<rbrakk>e", "using I SubstForm_imp_subst_fm"], ["proof (prove)\nusing this:\n  SubstForm v 0 x x0\n  SubstForm v w x xw\n  SubstForm v (q_Eats v w) x xevw\n  AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw\n  AbstForm v 0 (q_All allw) allvw\n  AbstForm v 0 x ax\n  v \\<noteq> w\n  VarNonOccForm w x\n  \\<lbrakk>SubstForm ?v\n            \\<lbrakk>\\<guillemotleft>?u\\<guillemotright>\\<rbrakk>?e ?x ?x';\n   Form ?x;\n   \\<And>A.\n      \\<lbrakk>?x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>?e;\n       ?x' =\n       \\<lbrakk>\\<guillemotleft>A(decode_Var\n                                   ?v::=?u)\\<guillemotright>\\<rbrakk>?e\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. xw = \\<lbrakk>\\<guillemotleft>Aw\\<guillemotright>\\<rbrakk>e", "by (metis A Form_quot_fm eval_fm_inject is_Var_imp_decode_Var w Aw_def)"], ["proof (state)\nthis:\n  xw = \\<lbrakk>\\<guillemotleft>Aw\\<guillemotright>\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>v x x0 w xw xevw allw allvw ax.\n       \\<lbrakk>SubstForm v 0 x x0; SubstForm v w x xw;\n        SubstForm v (q_Eats v w) x xevw;\n        AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw;\n        AbstForm v 0 (q_All allw) allvw; AbstForm v 0 x ax; v \\<noteq> w;\n        VarNonOccForm w x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp x0 (q_Imp (q_All allvw) (q_All ax)) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> induction_axioms", "have \"SubstForm v (\\<lbrakk>\\<guillemotleft>Eats (Var (decode_Var v)) (Var (decode_Var w))\\<guillemotright>\\<rbrakk>e) x xevw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SubstForm v\n     \\<lbrakk>\\<guillemotleft>Eats (Var (decode_Var v))\n                               (Var (decode_Var\nw))\\<guillemotright>\\<rbrakk>e\n     x xevw", "using I"], ["proof (prove)\nusing this:\n  SubstForm v 0 x x0\n  SubstForm v w x xw\n  SubstForm v (q_Eats v w) x xevw\n  AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw\n  AbstForm v 0 (q_All allw) allvw\n  AbstForm v 0 x ax\n  v \\<noteq> w\n  VarNonOccForm w x\n\ngoal (1 subgoal):\n 1. SubstForm v\n     \\<lbrakk>\\<guillemotleft>Eats (Var (decode_Var v))\n                               (Var (decode_Var\nw))\\<guillemotright>\\<rbrakk>e\n     x xevw", "by (simp add: quot_simps q_defs) (metis is_Var_iff v w)"], ["proof (state)\nthis:\n  SubstForm v\n   \\<lbrakk>\\<guillemotleft>Eats (Var (decode_Var v))\n                             (Var (decode_Var w))\\<guillemotright>\\<rbrakk>e\n   x xevw\n\ngoal (1 subgoal):\n 1. \\<And>v x x0 w xw xevw allw allvw ax.\n       \\<lbrakk>SubstForm v 0 x x0; SubstForm v w x xw;\n        SubstForm v (q_Eats v w) x xevw;\n        AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw;\n        AbstForm v 0 (q_All allw) allvw; AbstForm v 0 x ax; v \\<noteq> w;\n        VarNonOccForm w x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp x0 (q_Imp (q_All allvw) (q_All ax)) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> induction_axioms", "hence xevw: \"xevw = \\<lbrakk>\\<guillemotleft>Ae\\<guillemotright>\\<rbrakk>e\""], ["proof (prove)\nusing this:\n  SubstForm v\n   \\<lbrakk>\\<guillemotleft>Eats (Var (decode_Var v))\n                             (Var (decode_Var w))\\<guillemotright>\\<rbrakk>e\n   x xevw\n\ngoal (1 subgoal):\n 1. xevw = \\<lbrakk>\\<guillemotleft>Ae\\<guillemotright>\\<rbrakk>e", "by (metis A Ae_def Form_quot_fm SubstForm_imp_subst_fm eval_fm_inject)"], ["proof (state)\nthis:\n  xevw = \\<lbrakk>\\<guillemotleft>Ae\\<guillemotright>\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>v x x0 w xw xevw allw allvw ax.\n       \\<lbrakk>SubstForm v 0 x x0; SubstForm v w x xw;\n        SubstForm v (q_Eats v w) x xevw;\n        AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw;\n        AbstForm v 0 (q_All allw) allvw; AbstForm v 0 x ax; v \\<noteq> w;\n        VarNonOccForm w x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp x0 (q_Imp (q_All allvw) (q_All ax)) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> induction_axioms", "have ax: \"ax = \\<lbrakk>quot_dbfm (abst_dbfm (decode_Var v) 0 (trans_fm [] A))\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ax =\n    \\<lbrakk>quot_dbfm\n              (abst_dbfm (decode_Var v) 0 (trans_fm [] A))\\<rbrakk>e", "using I"], ["proof (prove)\nusing this:\n  SubstForm v 0 x x0\n  SubstForm v w x xw\n  SubstForm v (q_Eats v w) x xevw\n  AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw\n  AbstForm v 0 (q_All allw) allvw\n  AbstForm v 0 x ax\n  v \\<noteq> w\n  VarNonOccForm w x\n\ngoal (1 subgoal):\n 1. ax =\n    \\<lbrakk>quot_dbfm\n              (abst_dbfm (decode_Var v) 0 (trans_fm [] A))\\<rbrakk>e", "by (metis A AbstForm_imp_abst_dbfm nat_of_ord_0 quot_dbfm_inject_lemma quot_fm_def)"], ["proof (state)\nthis:\n  ax =\n  \\<lbrakk>quot_dbfm (abst_dbfm (decode_Var v) 0 (trans_fm [] A))\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>v x x0 w xw xevw allw allvw ax.\n       \\<lbrakk>SubstForm v 0 x x0; SubstForm v w x xw;\n        SubstForm v (q_Eats v w) x xevw;\n        AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw;\n        AbstForm v 0 (q_All allw) allvw; AbstForm v 0 x ax; v \\<noteq> w;\n        VarNonOccForm w x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp x0 (q_Imp (q_All allvw) (q_All ax)) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> induction_axioms", "have evw: \"q_Imp x (q_Imp xw xevw) =\n             \\<lbrakk>quot_dbfm (trans_fm [] (A IMP (Aw IMP Ae)))\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q_Imp x (q_Imp xw xevw) =\n    \\<lbrakk>quot_dbfm (trans_fm [] (A IMP Aw IMP Ae))\\<rbrakk>e", "using A xw xevw"], ["proof (prove)\nusing this:\n  x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n  xw = \\<lbrakk>\\<guillemotleft>Aw\\<guillemotright>\\<rbrakk>e\n  xevw = \\<lbrakk>\\<guillemotleft>Ae\\<guillemotright>\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. q_Imp x (q_Imp xw xevw) =\n    \\<lbrakk>quot_dbfm (trans_fm [] (A IMP Aw IMP Ae))\\<rbrakk>e", "by (auto simp: quot_simps q_defs quot_fm_def)"], ["proof (state)\nthis:\n  q_Imp x (q_Imp xw xevw) =\n  \\<lbrakk>quot_dbfm (trans_fm [] (A IMP Aw IMP Ae))\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>v x x0 w xw xevw allw allvw ax.\n       \\<lbrakk>SubstForm v 0 x x0; SubstForm v w x xw;\n        SubstForm v (q_Eats v w) x xevw;\n        AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw;\n        AbstForm v 0 (q_All allw) allvw; AbstForm v 0 x ax; v \\<noteq> w;\n        VarNonOccForm w x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp x0 (q_Imp (q_All allvw) (q_All ax)) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> induction_axioms", "hence allw: \"allw = \\<lbrakk>quot_dbfm (abst_dbfm (decode_Var w) 0\n                                    (trans_fm [] (A IMP (Aw IMP Ae))))\\<rbrakk>e\""], ["proof (prove)\nusing this:\n  q_Imp x (q_Imp xw xevw) =\n  \\<lbrakk>quot_dbfm (trans_fm [] (A IMP Aw IMP Ae))\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. allw =\n    \\<lbrakk>quot_dbfm\n              (abst_dbfm (decode_Var w) 0\n                (trans_fm [] (A IMP Aw IMP Ae)))\\<rbrakk>e", "using I"], ["proof (prove)\nusing this:\n  q_Imp x (q_Imp xw xevw) =\n  \\<lbrakk>quot_dbfm (trans_fm [] (A IMP Aw IMP Ae))\\<rbrakk>e\n  SubstForm v 0 x x0\n  SubstForm v w x xw\n  SubstForm v (q_Eats v w) x xevw\n  AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw\n  AbstForm v 0 (q_All allw) allvw\n  AbstForm v 0 x ax\n  v \\<noteq> w\n  VarNonOccForm w x\n\ngoal (1 subgoal):\n 1. allw =\n    \\<lbrakk>quot_dbfm\n              (abst_dbfm (decode_Var w) 0\n                (trans_fm [] (A IMP Aw IMP Ae)))\\<rbrakk>e", "by (metis AbstForm_imp_abst_dbfm nat_of_ord_0 quot_dbfm_inject_lemma)"], ["proof (state)\nthis:\n  allw =\n  \\<lbrakk>quot_dbfm\n            (abst_dbfm (decode_Var w) 0\n              (trans_fm [] (A IMP Aw IMP Ae)))\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>v x x0 w xw xevw allw allvw ax.\n       \\<lbrakk>SubstForm v 0 x x0; SubstForm v w x xw;\n        SubstForm v (q_Eats v w) x xevw;\n        AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw;\n        AbstForm v 0 (q_All allw) allvw; AbstForm v 0 x ax; v \\<noteq> w;\n        VarNonOccForm w x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp x0 (q_Imp (q_All allvw) (q_All ax)) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> induction_axioms", "then"], ["proof (chain)\npicking this:\n  allw =\n  \\<lbrakk>quot_dbfm\n            (abst_dbfm (decode_Var w) 0\n              (trans_fm [] (A IMP Aw IMP Ae)))\\<rbrakk>e", "have evw: \"q_All allw = \\<lbrakk>quot_dbfm (trans_fm [] (All (decode_Var w) (A IMP (Aw IMP Ae))))\\<rbrakk>e\""], ["proof (prove)\nusing this:\n  allw =\n  \\<lbrakk>quot_dbfm\n            (abst_dbfm (decode_Var w) 0\n              (trans_fm [] (A IMP Aw IMP Ae)))\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. q_All allw =\n    \\<lbrakk>quot_dbfm\n              (trans_fm []\n                (SyntaxN.All (decode_Var w) (A IMP Aw IMP Ae)))\\<rbrakk>e", "by (auto simp: q_defs abst_trans_fm)"], ["proof (state)\nthis:\n  q_All allw =\n  \\<lbrakk>quot_dbfm\n            (trans_fm []\n              (SyntaxN.All (decode_Var w) (A IMP Aw IMP Ae)))\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>v x x0 w xw xevw allw allvw ax.\n       \\<lbrakk>SubstForm v 0 x x0; SubstForm v w x xw;\n        SubstForm v (q_Eats v w) x xevw;\n        AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw;\n        AbstForm v 0 (q_All allw) allvw; AbstForm v 0 x ax; v \\<noteq> w;\n        VarNonOccForm w x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp x0 (q_Imp (q_All allvw) (q_All ax)) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> induction_axioms", "hence allvw: \"allvw = \\<lbrakk>quot_dbfm (abst_dbfm (decode_Var v) 0\n                                     (trans_fm [] (All (decode_Var w) (A IMP (Aw IMP Ae)))))\\<rbrakk>e\""], ["proof (prove)\nusing this:\n  q_All allw =\n  \\<lbrakk>quot_dbfm\n            (trans_fm []\n              (SyntaxN.All (decode_Var w) (A IMP Aw IMP Ae)))\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. allvw =\n    \\<lbrakk>quot_dbfm\n              (abst_dbfm (decode_Var v) 0\n                (trans_fm []\n                  (SyntaxN.All (decode_Var w) (A IMP Aw IMP Ae))))\\<rbrakk>e", "using I"], ["proof (prove)\nusing this:\n  q_All allw =\n  \\<lbrakk>quot_dbfm\n            (trans_fm []\n              (SyntaxN.All (decode_Var w) (A IMP Aw IMP Ae)))\\<rbrakk>e\n  SubstForm v 0 x x0\n  SubstForm v w x xw\n  SubstForm v (q_Eats v w) x xevw\n  AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw\n  AbstForm v 0 (q_All allw) allvw\n  AbstForm v 0 x ax\n  v \\<noteq> w\n  VarNonOccForm w x\n\ngoal (1 subgoal):\n 1. allvw =\n    \\<lbrakk>quot_dbfm\n              (abst_dbfm (decode_Var v) 0\n                (trans_fm []\n                  (SyntaxN.All (decode_Var w) (A IMP Aw IMP Ae))))\\<rbrakk>e", "by (metis AbstForm_imp_abst_dbfm nat_of_ord_0 quot_dbfm_inject_lemma)"], ["proof (state)\nthis:\n  allvw =\n  \\<lbrakk>quot_dbfm\n            (abst_dbfm (decode_Var v) 0\n              (trans_fm []\n                (SyntaxN.All (decode_Var w) (A IMP Aw IMP Ae))))\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>v x x0 w xw xevw allw allvw ax.\n       \\<lbrakk>SubstForm v 0 x x0; SubstForm v w x xw;\n        SubstForm v (q_Eats v w) x xevw;\n        AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw;\n        AbstForm v 0 (q_All allw) allvw; AbstForm v 0 x ax; v \\<noteq> w;\n        VarNonOccForm w x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp x0 (q_Imp (q_All allvw) (q_All ax)) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> induction_axioms", "define ind_ax\n    where \"ind_ax =\n        A(decode_Var v::=Zero) IMP\n        ((All (decode_Var v) (All (decode_Var w) (A IMP (Aw IMP Ae)))) IMP\n        (All (decode_Var v) A))\""], ["proof (state)\nthis:\n  ind_ax =\n  A(decode_Var v::=Zero) IMP\n  SyntaxN.All (decode_Var v)\n   (SyntaxN.All (decode_Var w) (A IMP Aw IMP Ae)) IMP\n  SyntaxN.All (decode_Var v) A\n\ngoal (1 subgoal):\n 1. \\<And>v x x0 w xw xevw allw allvw ax.\n       \\<lbrakk>SubstForm v 0 x x0; SubstForm v w x xw;\n        SubstForm v (q_Eats v w) x xevw;\n        AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw;\n        AbstForm v 0 (q_All allw) allvw; AbstForm v 0 x ax; v \\<noteq> w;\n        VarNonOccForm w x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp x0 (q_Imp (q_All allvw) (q_All ax)) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> induction_axioms", "have \"atom (decode_Var w) \\<sharp> (decode_Var v, A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom (decode_Var w) \\<sharp> (decode_Var v, A)", "using I wfresh v w"], ["proof (prove)\nusing this:\n  SubstForm v 0 x x0\n  SubstForm v w x xw\n  SubstForm v (q_Eats v w) x xevw\n  AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw\n  AbstForm v 0 (q_All allw) allvw\n  AbstForm v 0 x ax\n  v \\<noteq> w\n  VarNonOccForm w x\n  atom (decode_Var w) \\<sharp> A\n  is_Var v\n  is_Var w\n\ngoal (1 subgoal):\n 1. atom (decode_Var w) \\<sharp> (decode_Var v, A)", "by (metis atom_eq_iff decode_Var_inject fresh_Pair fresh_ineq_at_base)"], ["proof (state)\nthis:\n  atom (decode_Var w) \\<sharp> (decode_Var v, A)\n\ngoal (1 subgoal):\n 1. \\<And>v x x0 w xw xevw allw allvw ax.\n       \\<lbrakk>SubstForm v 0 x x0; SubstForm v w x xw;\n        SubstForm v (q_Eats v w) x xevw;\n        AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw;\n        AbstForm v 0 (q_All allw) allvw; AbstForm v 0 x ax; v \\<noteq> w;\n        VarNonOccForm w x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp x0 (q_Imp (q_All allvw) (q_All ax)) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> induction_axioms", "hence \"ind_ax \\<in> induction_axioms\""], ["proof (prove)\nusing this:\n  atom (decode_Var w) \\<sharp> (decode_Var v, A)\n\ngoal (1 subgoal):\n 1. ind_ax \\<in> induction_axioms", "by (auto simp: ind_ax_def Aw_def Ae_def induction_axioms.intros)"], ["proof (state)\nthis:\n  ind_ax \\<in> induction_axioms\n\ngoal (1 subgoal):\n 1. \\<And>v x x0 w xw xevw allw allvw ax.\n       \\<lbrakk>SubstForm v 0 x x0; SubstForm v w x xw;\n        SubstForm v (q_Eats v w) x xevw;\n        AbstForm w 0 (q_Imp x (q_Imp xw xevw)) allw;\n        AbstForm v 0 (q_All allw) allvw; AbstForm v 0 x ax; v \\<noteq> w;\n        VarNonOccForm w x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            q_Imp x0 (q_Imp (q_All allvw) (q_All ax)) =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            A \\<in> induction_axioms", "thus ?case"], ["proof (prove)\nusing this:\n  ind_ax \\<in> induction_axioms\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       q_Imp x0 (q_Imp (q_All allvw) (q_All ax)) =\n       \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       A \\<in> induction_axioms", "by (force simp: quot_simps q_defs ind_ax_def allvw ax x0 abst_trans_fm2 abst_trans_fm)"], ["proof (state)\nthis:\n  \\<exists>A.\n     q_Imp x0 (q_Imp (q_All allvw) (q_All ax)) =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     A \\<in> induction_axioms\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma induction_axioms_into_Induction_ax:\n  \"A \\<in> induction_axioms \\<Longrightarrow> \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<in> Induction_ax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> induction_axioms \\<Longrightarrow>\n    \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<in> Induction_ax", "proof (induct rule: induction_axioms.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j i A.\n       atom j \\<sharp> (i, A) \\<Longrightarrow>\n       \\<lbrakk>\\<guillemotleft>A(i::=Zero) IMP\n                                SyntaxN.All i\n                                 (SyntaxN.All j\n                                   (A IMP\n                                    A(i::=Var j) IMP\n                                    A(i::=Eats (Var i) (Var j)))) IMP\n                                SyntaxN.All i A\\<guillemotright>\\<rbrakk>e\n       \\<in> Induction_ax", "case (ind j i A)"], ["proof (state)\nthis:\n  atom j \\<sharp> (i, A)\n\ngoal (1 subgoal):\n 1. \\<And>j i A.\n       atom j \\<sharp> (i, A) \\<Longrightarrow>\n       \\<lbrakk>\\<guillemotleft>A(i::=Zero) IMP\n                                SyntaxN.All i\n                                 (SyntaxN.All j\n                                   (A IMP\n                                    A(i::=Var j) IMP\n                                    A(i::=Eats (Var i) (Var j)))) IMP\n                                SyntaxN.All i A\\<guillemotright>\\<rbrakk>e\n       \\<in> Induction_ax", "hence eq: \"\\<lbrakk>\\<guillemotleft>A(i::=Zero) IMP All i (All j (A IMP A(i::=Var j) IMP A(i::=Eats (Var i) (Var j)))) IMP All i A\\<guillemotright>\\<rbrakk>e =\n            q_Imp \\<lbrakk>quot_dbfm (subst_dbfm (trans_tm [] Zero) i (trans_fm [] A))\\<rbrakk>e\n            (q_Imp (q_All (q_All\n                  (q_Imp \\<lbrakk>quot_dbfm (trans_fm [j, i] A)\\<rbrakk>e\n                    (q_Imp\n                      \\<lbrakk>quot_dbfm (trans_fm [j, i] (A(i::=Var j)))\\<rbrakk>e\n                      \\<lbrakk>quot_dbfm (trans_fm [j, i] (A(i::=Eats (Var i) (Var j))))\\<rbrakk>e))))\n              (q_All \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e))\""], ["proof (prove)\nusing this:\n  atom j \\<sharp> (i, A)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<guillemotleft>A(i::=Zero) IMP\n                             SyntaxN.All i\n                              (SyntaxN.All j\n                                (A IMP\n                                 A(i::=Var j) IMP\n                                 A(i::=Eats (Var i) (Var j)))) IMP\n                             SyntaxN.All i A\\<guillemotright>\\<rbrakk>e =\n    q_Imp\n     \\<lbrakk>quot_dbfm\n               (subst_dbfm (trans_tm [] Zero) i (trans_fm [] A))\\<rbrakk>e\n     (q_Imp\n       (q_All\n         (q_All\n           (q_Imp \\<lbrakk>quot_dbfm (trans_fm [j, i] A)\\<rbrakk>e\n             (q_Imp\n               \\<lbrakk>quot_dbfm (trans_fm [j, i] (A(i::=Var j)))\\<rbrakk>e\n               \\<lbrakk>quot_dbfm\n                         (trans_fm [j, i]\n                           (A(i::=Eats (Var i) (Var j))))\\<rbrakk>e))))\n       (q_All \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e))", "by (simp add: quot_simps q_defs quot_subst_eq fresh_Cons fresh_Pair)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<guillemotleft>A(i::=Zero) IMP\n                           SyntaxN.All i\n                            (SyntaxN.All j\n                              (A IMP\n                               A(i::=Var j) IMP\n                               A(i::=Eats (Var i) (Var j)))) IMP\n                           SyntaxN.All i A\\<guillemotright>\\<rbrakk>e =\n  q_Imp\n   \\<lbrakk>quot_dbfm\n             (subst_dbfm (trans_tm [] Zero) i (trans_fm [] A))\\<rbrakk>e\n   (q_Imp\n     (q_All\n       (q_All\n         (q_Imp \\<lbrakk>quot_dbfm (trans_fm [j, i] A)\\<rbrakk>e\n           (q_Imp\n             \\<lbrakk>quot_dbfm (trans_fm [j, i] (A(i::=Var j)))\\<rbrakk>e\n             \\<lbrakk>quot_dbfm\n                       (trans_fm [j, i]\n                         (A(i::=Eats (Var i) (Var j))))\\<rbrakk>e))))\n     (q_All \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e))\n\ngoal (1 subgoal):\n 1. \\<And>j i A.\n       atom j \\<sharp> (i, A) \\<Longrightarrow>\n       \\<lbrakk>\\<guillemotleft>A(i::=Zero) IMP\n                                SyntaxN.All i\n                                 (SyntaxN.All j\n                                   (A IMP\n                                    A(i::=Var j) IMP\n                                    A(i::=Eats (Var i) (Var j)))) IMP\n                                SyntaxN.All i A\\<guillemotright>\\<rbrakk>e\n       \\<in> Induction_ax", "have [simp]: \"atom j \\<sharp> [i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom j \\<sharp> [i]", "using ind"], ["proof (prove)\nusing this:\n  atom j \\<sharp> (i, A)\n\ngoal (1 subgoal):\n 1. atom j \\<sharp> [i]", "by (metis fresh_Cons fresh_Nil fresh_Pair)"], ["proof (state)\nthis:\n  atom j \\<sharp> [i]\n\ngoal (1 subgoal):\n 1. \\<And>j i A.\n       atom j \\<sharp> (i, A) \\<Longrightarrow>\n       \\<lbrakk>\\<guillemotleft>A(i::=Zero) IMP\n                                SyntaxN.All i\n                                 (SyntaxN.All j\n                                   (A IMP\n                                    A(i::=Var j) IMP\n                                    A(i::=Eats (Var i) (Var j)))) IMP\n                                SyntaxN.All i A\\<guillemotright>\\<rbrakk>e\n       \\<in> Induction_ax", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<guillemotleft>A(i::=Zero) IMP\n                             SyntaxN.All i\n                              (SyntaxN.All j\n                                (A IMP\n                                 A(i::=Var j) IMP\n                                 A(i::=Eats (Var i) (Var j)))) IMP\n                             SyntaxN.All i A\\<guillemotright>\\<rbrakk>e\n    \\<in> Induction_ax", "proof (simp only: eq, rule Induction_ax.intros [where v = \"q_Var i\" and w = \"q_Var j\"])"], ["proof (state)\ngoal (8 subgoals):\n 1. SubstForm (q_Var i) 0 ?x1\n     \\<lbrakk>quot_dbfm\n               (subst_dbfm (trans_tm [] Zero) i (trans_fm [] A))\\<rbrakk>e\n 2. SubstForm (q_Var i) (q_Var j) ?x1 ?xw1\n 3. SubstForm (q_Var i) (q_Eats (q_Var i) (q_Var j)) ?x1 ?xevw1\n 4. AbstForm (q_Var j) 0 (q_Imp ?x1 (q_Imp ?xw1 ?xevw1)) ?allw1\n 5. AbstForm (q_Var i) 0 (q_All ?allw1)\n     (q_All\n       (q_Imp \\<lbrakk>quot_dbfm (trans_fm [j, i] A)\\<rbrakk>e\n         (q_Imp\n           \\<lbrakk>quot_dbfm (trans_fm [j, i] (A(i::=Var j)))\\<rbrakk>e\n           \\<lbrakk>quot_dbfm\n                     (trans_fm [j, i]\n                       (A(i::=Eats (Var i) (Var j))))\\<rbrakk>e)))\n 6. AbstForm (q_Var i) 0 ?x1 \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e\n 7. q_Var i \\<noteq> q_Var j\n 8. VarNonOccForm (q_Var j) ?x1", "show \"SubstForm (q_Var i) 0 \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n           \\<lbrakk>quot_dbfm (subst_dbfm (trans_tm [] Zero) i (trans_fm [] A))\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SubstForm (q_Var i) 0\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n     \\<lbrakk>quot_dbfm\n               (subst_dbfm (trans_tm [] Zero) i (trans_fm [] A))\\<rbrakk>e", "by (metis SubstForm_subst_dbfm_eq Term_quot_tm eval_tm.simps(1) quot_Zero quot_fm_def quot_tm_def)"], ["proof (state)\nthis:\n  SubstForm (q_Var i) 0\n   \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n   \\<lbrakk>quot_dbfm\n             (subst_dbfm (trans_tm [] Zero) i (trans_fm [] A))\\<rbrakk>e\n\ngoal (7 subgoals):\n 1. SubstForm (q_Var i) (q_Var j)\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e ?xw1\n 2. SubstForm (q_Var i) (q_Eats (q_Var i) (q_Var j))\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e ?xevw1\n 3. AbstForm (q_Var j) 0\n     (q_Imp \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n       (q_Imp ?xw1 ?xevw1))\n     ?allw1\n 4. AbstForm (q_Var i) 0 (q_All ?allw1)\n     (q_All\n       (q_Imp \\<lbrakk>quot_dbfm (trans_fm [j, i] A)\\<rbrakk>e\n         (q_Imp\n           \\<lbrakk>quot_dbfm (trans_fm [j, i] (A(i::=Var j)))\\<rbrakk>e\n           \\<lbrakk>quot_dbfm\n                     (trans_fm [j, i]\n                       (A(i::=Eats (Var i) (Var j))))\\<rbrakk>e)))\n 5. AbstForm (q_Var i) 0\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n     \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e\n 6. q_Var i \\<noteq> q_Var j\n 7. VarNonOccForm (q_Var j)\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. SubstForm (q_Var i) (q_Var j)\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e ?xw1\n 2. SubstForm (q_Var i) (q_Eats (q_Var i) (q_Var j))\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e ?xevw1\n 3. AbstForm (q_Var j) 0\n     (q_Imp \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n       (q_Imp ?xw1 ?xevw1))\n     ?allw1\n 4. AbstForm (q_Var i) 0 (q_All ?allw1)\n     (q_All\n       (q_Imp \\<lbrakk>quot_dbfm (trans_fm [j, i] A)\\<rbrakk>e\n         (q_Imp\n           \\<lbrakk>quot_dbfm (trans_fm [j, i] (A(i::=Var j)))\\<rbrakk>e\n           \\<lbrakk>quot_dbfm\n                     (trans_fm [j, i]\n                       (A(i::=Eats (Var i) (Var j))))\\<rbrakk>e)))\n 5. AbstForm (q_Var i) 0\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n     \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e\n 6. q_Var i \\<noteq> q_Var j\n 7. VarNonOccForm (q_Var j)\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e", "show \"SubstForm (q_Var i) (q_Var j) \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<lbrakk>quot_dbfm (subst_dbfm (DBVar j) i (trans_fm [] A))\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SubstForm (q_Var i) (q_Var j)\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n     \\<lbrakk>quot_dbfm (subst_dbfm (DBVar j) i (trans_fm [] A))\\<rbrakk>e", "by (auto simp: quot_fm_def intro!: SubstForm_subst_dbfm_eq Term_Var)\n         (metis q_Var_def)"], ["proof (state)\nthis:\n  SubstForm (q_Var i) (q_Var j)\n   \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n   \\<lbrakk>quot_dbfm (subst_dbfm (DBVar j) i (trans_fm [] A))\\<rbrakk>e\n\ngoal (6 subgoals):\n 1. SubstForm (q_Var i) (q_Eats (q_Var i) (q_Var j))\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e ?xevw1\n 2. AbstForm (q_Var j) 0\n     (q_Imp \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n       (q_Imp\n         \\<lbrakk>quot_dbfm\n                   (subst_dbfm (DBVar j) i (trans_fm [] A))\\<rbrakk>e\n         ?xevw1))\n     ?allw1\n 3. AbstForm (q_Var i) 0 (q_All ?allw1)\n     (q_All\n       (q_Imp \\<lbrakk>quot_dbfm (trans_fm [j, i] A)\\<rbrakk>e\n         (q_Imp\n           \\<lbrakk>quot_dbfm (trans_fm [j, i] (A(i::=Var j)))\\<rbrakk>e\n           \\<lbrakk>quot_dbfm\n                     (trans_fm [j, i]\n                       (A(i::=Eats (Var i) (Var j))))\\<rbrakk>e)))\n 4. AbstForm (q_Var i) 0\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n     \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e\n 5. q_Var i \\<noteq> q_Var j\n 6. VarNonOccForm (q_Var j)\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. SubstForm (q_Var i) (q_Eats (q_Var i) (q_Var j))\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e ?xevw1\n 2. AbstForm (q_Var j) 0\n     (q_Imp \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n       (q_Imp\n         \\<lbrakk>quot_dbfm\n                   (subst_dbfm (DBVar j) i (trans_fm [] A))\\<rbrakk>e\n         ?xevw1))\n     ?allw1\n 3. AbstForm (q_Var i) 0 (q_All ?allw1)\n     (q_All\n       (q_Imp \\<lbrakk>quot_dbfm (trans_fm [j, i] A)\\<rbrakk>e\n         (q_Imp\n           \\<lbrakk>quot_dbfm (trans_fm [j, i] (A(i::=Var j)))\\<rbrakk>e\n           \\<lbrakk>quot_dbfm\n                     (trans_fm [j, i]\n                       (A(i::=Eats (Var i) (Var j))))\\<rbrakk>e)))\n 4. AbstForm (q_Var i) 0\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n     \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e\n 5. q_Var i \\<noteq> q_Var j\n 6. VarNonOccForm (q_Var j)\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e", "show \"SubstForm (q_Var i) (q_Eats (q_Var i) (q_Var j)) \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n              \\<lbrakk>quot_dbfm (subst_dbfm (DBEats (DBVar i) (DBVar j)) i (trans_fm [] A))\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SubstForm (q_Var i) (q_Eats (q_Var i) (q_Var j))\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n     \\<lbrakk>quot_dbfm\n               (subst_dbfm (DBEats (DBVar i) (DBVar j)) i\n                 (trans_fm [] A))\\<rbrakk>e", "unfolding quot_fm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. SubstForm (q_Var i) (q_Eats (q_Var i) (q_Var j))\n     \\<lbrakk>quot_dbfm (trans_fm [] A)\\<rbrakk>e\n     \\<lbrakk>quot_dbfm\n               (subst_dbfm (DBEats (DBVar i) (DBVar j)) i\n                 (trans_fm [] A))\\<rbrakk>e", "by (auto intro!: SubstForm_subst_dbfm_eq Term_Eats Term_Var) (simp add: q_defs)"], ["proof (state)\nthis:\n  SubstForm (q_Var i) (q_Eats (q_Var i) (q_Var j))\n   \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n   \\<lbrakk>quot_dbfm\n             (subst_dbfm (DBEats (DBVar i) (DBVar j)) i\n               (trans_fm [] A))\\<rbrakk>e\n\ngoal (5 subgoals):\n 1. AbstForm (q_Var j) 0\n     (q_Imp \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n       (q_Imp\n         \\<lbrakk>quot_dbfm\n                   (subst_dbfm (DBVar j) i (trans_fm [] A))\\<rbrakk>e\n         \\<lbrakk>quot_dbfm\n                   (subst_dbfm (DBEats (DBVar i) (DBVar j)) i\n                     (trans_fm [] A))\\<rbrakk>e))\n     ?allw1\n 2. AbstForm (q_Var i) 0 (q_All ?allw1)\n     (q_All\n       (q_Imp \\<lbrakk>quot_dbfm (trans_fm [j, i] A)\\<rbrakk>e\n         (q_Imp\n           \\<lbrakk>quot_dbfm (trans_fm [j, i] (A(i::=Var j)))\\<rbrakk>e\n           \\<lbrakk>quot_dbfm\n                     (trans_fm [j, i]\n                       (A(i::=Eats (Var i) (Var j))))\\<rbrakk>e)))\n 3. AbstForm (q_Var i) 0\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n     \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e\n 4. q_Var i \\<noteq> q_Var j\n 5. VarNonOccForm (q_Var j)\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. AbstForm (q_Var j) 0\n     (q_Imp \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n       (q_Imp\n         \\<lbrakk>quot_dbfm\n                   (subst_dbfm (DBVar j) i (trans_fm [] A))\\<rbrakk>e\n         \\<lbrakk>quot_dbfm\n                   (subst_dbfm (DBEats (DBVar i) (DBVar j)) i\n                     (trans_fm [] A))\\<rbrakk>e))\n     ?allw1\n 2. AbstForm (q_Var i) 0 (q_All ?allw1)\n     (q_All\n       (q_Imp \\<lbrakk>quot_dbfm (trans_fm [j, i] A)\\<rbrakk>e\n         (q_Imp\n           \\<lbrakk>quot_dbfm (trans_fm [j, i] (A(i::=Var j)))\\<rbrakk>e\n           \\<lbrakk>quot_dbfm\n                     (trans_fm [j, i]\n                       (A(i::=Eats (Var i) (Var j))))\\<rbrakk>e)))\n 3. AbstForm (q_Var i) 0\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n     \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e\n 4. q_Var i \\<noteq> q_Var j\n 5. VarNonOccForm (q_Var j)\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e", "show \"AbstForm (q_Var j) 0\n           (q_Imp \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n              (q_Imp \\<lbrakk>quot_dbfm (subst_dbfm (DBVar j) i (trans_fm [] A))\\<rbrakk>e\n                     \\<lbrakk>quot_dbfm (subst_dbfm (DBEats (DBVar i) (DBVar j)) i (trans_fm [] A))\\<rbrakk>e))\n           \\<lbrakk>quot_dbfm (trans_fm [j] (A IMP (A(i::= Var j) IMP A(i::= Eats(Var i)(Var j)))))\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AbstForm (q_Var j) 0\n     (q_Imp \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n       (q_Imp\n         \\<lbrakk>quot_dbfm\n                   (subst_dbfm (DBVar j) i (trans_fm [] A))\\<rbrakk>e\n         \\<lbrakk>quot_dbfm\n                   (subst_dbfm (DBEats (DBVar i) (DBVar j)) i\n                     (trans_fm [] A))\\<rbrakk>e))\n     \\<lbrakk>quot_dbfm\n               (trans_fm [j]\n                 (A IMP\n                  A(i::=Var j) IMP A(i::=Eats (Var i) (Var j))))\\<rbrakk>e", "by (rule AbstForm_trans_fm_eq [where A = \"(A IMP A(i::= Var j) IMP A(i::= Eats(Var i)(Var j)))\"])\n         (auto simp: quot_simps q_defs quot_fm_def subst_fm_trans_commute_eq)"], ["proof (state)\nthis:\n  AbstForm (q_Var j) 0\n   (q_Imp \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n     (q_Imp\n       \\<lbrakk>quot_dbfm (subst_dbfm (DBVar j) i (trans_fm [] A))\\<rbrakk>e\n       \\<lbrakk>quot_dbfm\n                 (subst_dbfm (DBEats (DBVar i) (DBVar j)) i\n                   (trans_fm [] A))\\<rbrakk>e))\n   \\<lbrakk>quot_dbfm\n             (trans_fm [j]\n               (A IMP\n                A(i::=Var j) IMP A(i::=Eats (Var i) (Var j))))\\<rbrakk>e\n\ngoal (4 subgoals):\n 1. AbstForm (q_Var i) 0\n     (q_All\n       \\<lbrakk>quot_dbfm\n                 (trans_fm [j]\n                   (A IMP\n                    A(i::=Var j) IMP\n                    A(i::=Eats (Var i) (Var j))))\\<rbrakk>e)\n     (q_All\n       (q_Imp \\<lbrakk>quot_dbfm (trans_fm [j, i] A)\\<rbrakk>e\n         (q_Imp\n           \\<lbrakk>quot_dbfm (trans_fm [j, i] (A(i::=Var j)))\\<rbrakk>e\n           \\<lbrakk>quot_dbfm\n                     (trans_fm [j, i]\n                       (A(i::=Eats (Var i) (Var j))))\\<rbrakk>e)))\n 2. AbstForm (q_Var i) 0\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n     \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e\n 3. q_Var i \\<noteq> q_Var j\n 4. VarNonOccForm (q_Var j)\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. AbstForm (q_Var i) 0\n     (q_All\n       \\<lbrakk>quot_dbfm\n                 (trans_fm [j]\n                   (A IMP\n                    A(i::=Var j) IMP\n                    A(i::=Eats (Var i) (Var j))))\\<rbrakk>e)\n     (q_All\n       (q_Imp \\<lbrakk>quot_dbfm (trans_fm [j, i] A)\\<rbrakk>e\n         (q_Imp\n           \\<lbrakk>quot_dbfm (trans_fm [j, i] (A(i::=Var j)))\\<rbrakk>e\n           \\<lbrakk>quot_dbfm\n                     (trans_fm [j, i]\n                       (A(i::=Eats (Var i) (Var j))))\\<rbrakk>e)))\n 2. AbstForm (q_Var i) 0\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n     \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e\n 3. q_Var i \\<noteq> q_Var j\n 4. VarNonOccForm (q_Var j)\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e", "show \"AbstForm (q_Var i) 0\n     (q_All \\<lbrakk>quot_dbfm (trans_fm [j] (A IMP A(i::=Var j) IMP A(i::=Eats (Var i) (Var j))))\\<rbrakk>e)\n     (q_All\n       (q_Imp \\<lbrakk>quot_dbfm (trans_fm [j, i] A)\\<rbrakk>e\n         (q_Imp \\<lbrakk>quot_dbfm (trans_fm [j, i] (A(i::=Var j)))\\<rbrakk>e\n                \\<lbrakk>quot_dbfm (trans_fm [j, i] (A(i::=Eats (Var i) (Var j))))\\<rbrakk>e)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AbstForm (q_Var i) 0\n     (q_All\n       \\<lbrakk>quot_dbfm\n                 (trans_fm [j]\n                   (A IMP\n                    A(i::=Var j) IMP\n                    A(i::=Eats (Var i) (Var j))))\\<rbrakk>e)\n     (q_All\n       (q_Imp \\<lbrakk>quot_dbfm (trans_fm [j, i] A)\\<rbrakk>e\n         (q_Imp\n           \\<lbrakk>quot_dbfm (trans_fm [j, i] (A(i::=Var j)))\\<rbrakk>e\n           \\<lbrakk>quot_dbfm\n                     (trans_fm [j, i]\n                       (A(i::=Eats (Var i) (Var j))))\\<rbrakk>e)))", "apply (rule AbstForm_trans_fm_eq\n               [where A = \"All j (A IMP (A(i::= Var j) IMP A(i::= Eats(Var i)(Var j))))\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. q_All\n     \\<lbrakk>quot_dbfm\n               (trans_fm [j]\n                 (A IMP\n                  A(i::=Var j) IMP A(i::=Eats (Var i) (Var j))))\\<rbrakk>e =\n    \\<lbrakk>\\<guillemotleft>SyntaxN.All j\n                              (A IMP\n                               A(i::=Var j) IMP\n                               A(i::=Eats (Var i)\n(Var j)))\\<guillemotright>\\<rbrakk>?e\n 2. q_All\n     (q_Imp \\<lbrakk>quot_dbfm (trans_fm [j, i] A)\\<rbrakk>e\n       (q_Imp \\<lbrakk>quot_dbfm (trans_fm [j, i] (A(i::=Var j)))\\<rbrakk>e\n         \\<lbrakk>quot_dbfm\n                   (trans_fm [j, i]\n                     (A(i::=Eats (Var i) (Var j))))\\<rbrakk>e)) =\n    \\<lbrakk>quot_dbfm\n              (trans_fm [i]\n                (SyntaxN.All j\n                  (A IMP\n                   A(i::=Var j) IMP\n                   A(i::=Eats (Var i) (Var j)))))\\<rbrakk>?e", "apply (auto simp: q_defs quot_fm_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  AbstForm (q_Var i) 0\n   (q_All\n     \\<lbrakk>quot_dbfm\n               (trans_fm [j]\n                 (A IMP\n                  A(i::=Var j) IMP A(i::=Eats (Var i) (Var j))))\\<rbrakk>e)\n   (q_All\n     (q_Imp \\<lbrakk>quot_dbfm (trans_fm [j, i] A)\\<rbrakk>e\n       (q_Imp \\<lbrakk>quot_dbfm (trans_fm [j, i] (A(i::=Var j)))\\<rbrakk>e\n         \\<lbrakk>quot_dbfm\n                   (trans_fm [j, i]\n                     (A(i::=Eats (Var i) (Var j))))\\<rbrakk>e)))\n\ngoal (3 subgoals):\n 1. AbstForm (q_Var i) 0\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n     \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e\n 2. q_Var i \\<noteq> q_Var j\n 3. VarNonOccForm (q_Var j)\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. AbstForm (q_Var i) 0\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n     \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e\n 2. q_Var i \\<noteq> q_Var j\n 3. VarNonOccForm (q_Var j)\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e", "show \"AbstForm (q_Var i) 0 (\\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e) \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AbstForm (q_Var i) 0\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n     \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e", "by (metis AbstForm_trans_fm)"], ["proof (state)\nthis:\n  AbstForm (q_Var i) 0 \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n   \\<lbrakk>quot_dbfm (trans_fm [i] A)\\<rbrakk>e\n\ngoal (2 subgoals):\n 1. q_Var i \\<noteq> q_Var j\n 2. VarNonOccForm (q_Var j)\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. q_Var i \\<noteq> q_Var j\n 2. VarNonOccForm (q_Var j)\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e", "show \"q_Var i \\<noteq> q_Var j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q_Var i \\<noteq> q_Var j", "using ind"], ["proof (prove)\nusing this:\n  atom j \\<sharp> (i, A)\n\ngoal (1 subgoal):\n 1. q_Var i \\<noteq> q_Var j", "by (simp add: q_Var_def)"], ["proof (state)\nthis:\n  q_Var i \\<noteq> q_Var j\n\ngoal (1 subgoal):\n 1. VarNonOccForm (q_Var j)\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. VarNonOccForm (q_Var j)\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e", "show \"VarNonOccForm (q_Var j) (\\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. VarNonOccForm (q_Var j)\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e", "by (metis fresh_Pair fresh_imp_VarNonOccForm ind)"], ["proof (state)\nthis:\n  VarNonOccForm (q_Var j)\n   \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<guillemotleft>A(i::=Zero) IMP\n                           SyntaxN.All i\n                            (SyntaxN.All j\n                              (A IMP\n                               A(i::=Var j) IMP\n                               A(i::=Eats (Var i) (Var j)))) IMP\n                           SyntaxN.All i A\\<guillemotright>\\<rbrakk>e\n  \\<in> Induction_ax\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>We have captured the codes of the induction axioms.\\<close>"], ["", "corollary Induction_ax_eq_induction_axioms:\n  \"Induction_ax = (\\<Union>A \\<in> induction_axioms. {\\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Induction_ax =\n    (\\<Union>A\\<in>induction_axioms.\n        {\\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e})", "by (force dest: induction_axioms_into_Induction_ax Induction_ax_imp_induction_axioms)"], ["", "subsection \\<open>The predicate \\<open>AxiomP\\<close>, for any Axioms\\<close>"], ["", "definition Extra_ax :: \"hf set\" where\n \"Extra_ax \\<equiv> {\\<lbrakk>\\<guillemotleft>extra_axiom\\<guillemotright>\\<rbrakk>e0}\""], ["", "definition Axiom :: \"hf set\" where\n  \"Axiom \\<equiv> Extra_ax \\<union> Sent \\<union> Equality_ax \\<union> HF_ax \\<union> Special_ax \\<union> Induction_ax\""], ["", "definition AxiomP :: \"tm \\<Rightarrow> fm\"\n  where \"AxiomP x \\<equiv> x EQ \\<guillemotleft>extra_axiom\\<guillemotright> OR SentP x OR Equality_axP x OR\n                    HF_axP x OR Special_axP x OR Induction_axP x\""], ["", "lemma AxiomP_eqvt [eqvt]: \"(p \\<bullet> AxiomP x) = AxiomP (p \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> AxiomP x = AxiomP (p \\<bullet> x)", "by (simp add: AxiomP_def)"], ["", "lemma AxiomP_fresh_iff [simp]: \"a \\<sharp> AxiomP x \\<longleftrightarrow> a \\<sharp> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> AxiomP x = a \\<sharp> x", "by (auto simp: AxiomP_def)"], ["", "lemma eval_fm_AxiomP [simp]: \"eval_fm e (AxiomP x) \\<longleftrightarrow> \\<lbrakk>x\\<rbrakk>e \\<in> Axiom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_fm e (AxiomP x) = (\\<lbrakk>x\\<rbrakk>e \\<in> Axiom)", "unfolding AxiomP_def Axiom_def Extra_ax_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_fm e\n     (x EQ \\<guillemotleft>extra_axiom\\<guillemotright> OR\n      SentP x OR\n      Equality_axP x OR HF_axP x OR Special_axP x OR Induction_axP x) =\n    (\\<lbrakk>x\\<rbrakk>e\n     \\<in> {\\<lbrakk>\\<guillemotleft>extra_axiom\\<guillemotright>\\<rbrakk>e0} \\<union>\n           Sent \\<union>\n           Equality_ax \\<union>\n           HF_ax \\<union>\n           Special_ax \\<union>\n           Induction_ax)", "by (auto simp del: Equality_axP.simps HF_axP.simps intro: eval_quot_fm_ignore)"], ["", "lemma AxiomP_sf [iff]: \"Sigma_fm (AxiomP t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_fm (AxiomP t)", "by (auto simp: AxiomP_def)"], ["", "subsection \\<open>The predicate \\<open>ModPonP\\<close>, for the inference rule Modus Ponens\\<close>"], ["", "definition ModPon :: \"hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> bool\" where\n  \"ModPon x y z \\<equiv> (y = q_Imp x z)\""], ["", "definition ModPonP :: \"tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> fm\"\n  where \"ModPonP x y z = (y EQ Q_Imp x z)\""], ["", "lemma ModPonP_eqvt [eqvt]: \"(p \\<bullet> ModPonP x y z) = ModPonP (p \\<bullet> x) (p \\<bullet> y) (p \\<bullet> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> ModPonP x y z =\n    ModPonP (p \\<bullet> x) (p \\<bullet> y) (p \\<bullet> z)", "by (simp add: ModPonP_def)"], ["", "lemma ModPonP_fresh_iff [simp]: \"a \\<sharp> ModPonP x y z \\<longleftrightarrow> a \\<sharp> x \\<and> a \\<sharp> y \\<and> a \\<sharp> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> ModPonP x y z =\n    (a \\<sharp> x \\<and> a \\<sharp> y \\<and> a \\<sharp> z)", "by (auto simp: ModPonP_def)"], ["", "lemma eval_fm_ModPonP [simp]: \"eval_fm e (ModPonP x y z) \\<longleftrightarrow> ModPon \\<lbrakk>x\\<rbrakk>e \\<lbrakk>y\\<rbrakk>e \\<lbrakk>z\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_fm e (ModPonP x y z) =\n    ModPon \\<lbrakk>x\\<rbrakk>e \\<lbrakk>y\\<rbrakk>e \\<lbrakk>z\\<rbrakk>e", "by (auto simp: ModPon_def ModPonP_def q_defs)"], ["", "lemma ModPonP_sf [iff]: \"Sigma_fm (ModPonP t u v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_fm (ModPonP t u v)", "by (auto simp: ModPonP_def)"], ["", "lemma ModPonP_subst [simp]:\n  \"(ModPonP t u v)(i::=w) = ModPonP (subst i w t) (subst i w u) (subst i w v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ModPonP t u v)(i::=w) =\n    ModPonP (subst i w t) (subst i w u) (subst i w v)", "by (auto simp: ModPonP_def)"], ["", "subsection \\<open>The predicate \\<open>ExistsP\\<close>, for the existential rule\\<close>"], ["", "subsubsection \\<open>Definition\\<close>"], ["", "(*  \"\\<turnstile> A IMP B \\<Longrightarrow> atom i \\<sharp> B \\<Longrightarrow>  \\<turnstile> (Ex i A) IMP B\" *)"], ["", "definition Exists :: \"hf \\<Rightarrow> hf \\<Rightarrow> bool\" where\n \"Exists p q \\<equiv> (\\<exists>x x' y v. Form x \\<and> VarNonOccForm v y \\<and> AbstForm v 0 x x' \\<and>\n                p = q_Imp x y \\<and> q = q_Imp (q_Ex x') y)\""], ["", "nominal_function ExistsP :: \"tm \\<Rightarrow> tm \\<Rightarrow> fm\" where\n  \"\\<lbrakk>atom x \\<sharp> (p,q,v,y,x'); atom x' \\<sharp> (p,q,v,y);\n    atom y \\<sharp> (p,q,v); atom v \\<sharp> (p,q)\\<rbrakk> \\<Longrightarrow>\n  ExistsP p q = Ex x (Ex x' (Ex y (Ex v (FormP (Var x) AND\n                    VarNonOccFormP (Var v) (Var y) AND\n                    AbstFormP (Var v) Zero (Var x) (Var x') AND\n                    p EQ Q_Imp (Var x) (Var y) AND\n                    q EQ Q_Imp (Q_Ex (Var x')) (Var y)))))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt ExistsP_graph_aux\n 2. \\<And>x y. ExistsP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>xa p q v y x'.\n           \\<lbrakk>atom xa \\<sharp> (p, q, v, y, x');\n            atom x' \\<sharp> (p, q, v, y); atom y \\<sharp> (p, q, v);\n            atom v \\<sharp> (p, q); x = (p, q)\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>x p q v y x' xa pa qa va ya x'a.\n       \\<lbrakk>atom x \\<sharp> (p, q, v, y, x');\n        atom x' \\<sharp> (p, q, v, y); atom y \\<sharp> (p, q, v);\n        atom v \\<sharp> (p, q); atom xa \\<sharp> (pa, qa, va, ya, x'a);\n        atom x'a \\<sharp> (pa, qa, va, ya); atom ya \\<sharp> (pa, qa, va);\n        atom va \\<sharp> (pa, qa); (p, q) = (pa, qa)\\<rbrakk>\n       \\<Longrightarrow> SyntaxN.Ex x\n                          (SyntaxN.Ex x'\n                            (SyntaxN.Ex y\n                              (SyntaxN.Ex v\n                                (FormP (Var x) AND\n                                 VarNonOccFormP (Var v) (Var y) AND\n                                 AbstFormP (Var v) Zero (Var x) (Var x') AND\n                                 p EQ Q_Imp (Var x) (Var y) AND\n                                 q EQ Q_Imp (Q_Ex (Var x')) (Var y))))) =\n                         SyntaxN.Ex xa\n                          (SyntaxN.Ex x'a\n                            (SyntaxN.Ex ya\n                              (SyntaxN.Ex va\n                                (FormP (Var xa) AND\n                                 VarNonOccFormP (Var va) (Var ya) AND\n                                 AbstFormP (Var va) Zero (Var xa)\n                                  (Var x'a) AND\n                                 pa EQ Q_Imp (Var xa) (Var ya) AND\n                                 qa EQ Q_Imp (Q_Ex (Var x'a)) (Var ya)))))", "by (auto simp: eqvt_def ExistsP_graph_aux_def flip_fresh_fresh) (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All ExistsP_dom", "by lexicographic_order"], ["", "lemma\n shows ExistsP_fresh_iff [simp]: \"a \\<sharp> ExistsP p q \\<longleftrightarrow> a \\<sharp> p \\<and> a \\<sharp> q\"    (is ?thesis1)\n   and eval_fm_ExistsP [simp]: \"eval_fm e (ExistsP p q) \\<longleftrightarrow> Exists \\<lbrakk>p\\<rbrakk>e \\<lbrakk>q\\<rbrakk>e\"  (is ?thesis2)\n   and ExistsP_sf [iff]:       \"Sigma_fm (ExistsP p q)\"   (is ?thesis3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> ExistsP p q = (a \\<sharp> p \\<and> a \\<sharp> q) &&&\n    eval_fm e (ExistsP p q) =\n    Exists \\<lbrakk>p\\<rbrakk>e \\<lbrakk>q\\<rbrakk>e &&&\n    Sigma_fm (ExistsP p q)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. a \\<sharp> ExistsP p q = (a \\<sharp> p \\<and> a \\<sharp> q)\n 2. eval_fm e (ExistsP p q) =\n    Exists \\<lbrakk>p\\<rbrakk>e \\<lbrakk>q\\<rbrakk>e\n 3. Sigma_fm (ExistsP p q)", "obtain x::name and x'::name and y::name and v::name\n    where \"atom x \\<sharp> (p,q,v,y,x')\"  \"atom x' \\<sharp> (p,q,v,y)\" \"atom y \\<sharp> (p,q,v)\"  \"atom v \\<sharp> (p,q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x v y x'.\n        \\<lbrakk>atom x \\<sharp> (p, q, v, y, x');\n         atom x' \\<sharp> (p, q, v, y); atom y \\<sharp> (p, q, v);\n         atom v \\<sharp> (p, q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom x \\<sharp> (p, q, v, y, x')\n  atom x' \\<sharp> (p, q, v, y)\n  atom y \\<sharp> (p, q, v)\n  atom v \\<sharp> (p, q)\n\ngoal (3 subgoals):\n 1. a \\<sharp> ExistsP p q = (a \\<sharp> p \\<and> a \\<sharp> q)\n 2. eval_fm e (ExistsP p q) =\n    Exists \\<lbrakk>p\\<rbrakk>e \\<lbrakk>q\\<rbrakk>e\n 3. Sigma_fm (ExistsP p q)", "thus ?thesis1 ?thesis2 ?thesis3"], ["proof (prove)\nusing this:\n  atom x \\<sharp> (p, q, v, y, x')\n  atom x' \\<sharp> (p, q, v, y)\n  atom y \\<sharp> (p, q, v)\n  atom v \\<sharp> (p, q)\n\ngoal (1 subgoal):\n 1. a \\<sharp> ExistsP p q = (a \\<sharp> p \\<and> a \\<sharp> q) &&&\n    eval_fm e (ExistsP p q) =\n    Exists \\<lbrakk>p\\<rbrakk>e \\<lbrakk>q\\<rbrakk>e &&&\n    Sigma_fm (ExistsP p q)", "by (auto simp: Exists_def q_defs)"], ["proof (state)\nthis:\n  a \\<sharp> ExistsP p q = (a \\<sharp> p \\<and> a \\<sharp> q)\n  eval_fm e (ExistsP p q) = Exists \\<lbrakk>p\\<rbrakk>e \\<lbrakk>q\\<rbrakk>e\n  Sigma_fm (ExistsP p q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ExistsP_subst [simp]: \"(ExistsP p q)(j::=w) = ExistsP (subst j w p) (subst j w q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ExistsP p q)(j::=w) = ExistsP (subst j w p) (subst j w q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (ExistsP p q)(j::=w) = ExistsP (subst j w p) (subst j w q)", "obtain x::name and x'::name and y::name and v::name\n    where \"atom x \\<sharp> (j,w,p,q,v,y,x')\"   \"atom x' \\<sharp> (j,w,p,q,v,y)\"\n          \"atom y \\<sharp> (j,w,p,q,v)\"   \"atom v \\<sharp> (j,w,p,q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x v y x'.\n        \\<lbrakk>atom x \\<sharp> (j, w, p, q, v, y, x');\n         atom x' \\<sharp> (j, w, p, q, v, y);\n         atom y \\<sharp> (j, w, p, q, v);\n         atom v \\<sharp> (j, w, p, q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom x \\<sharp> (j, w, p, q, v, y, x')\n  atom x' \\<sharp> (j, w, p, q, v, y)\n  atom y \\<sharp> (j, w, p, q, v)\n  atom v \\<sharp> (j, w, p, q)\n\ngoal (1 subgoal):\n 1. (ExistsP p q)(j::=w) = ExistsP (subst j w p) (subst j w q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom x \\<sharp> (j, w, p, q, v, y, x')\n  atom x' \\<sharp> (j, w, p, q, v, y)\n  atom y \\<sharp> (j, w, p, q, v)\n  atom v \\<sharp> (j, w, p, q)\n\ngoal (1 subgoal):\n 1. (ExistsP p q)(j::=w) = ExistsP (subst j w p) (subst j w q)", "by (auto simp: ExistsP.simps [of x _ _ x' y v])"], ["proof (state)\nthis:\n  (ExistsP p q)(j::=w) = ExistsP (subst j w p) (subst j w q)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Correctness\\<close>"], ["", "lemma Exists_imp_exists:\n  assumes \"Exists p q\"\n  shows \"\\<exists>A B i. p = \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e \\<and> q = \\<lbrakk>\\<guillemotleft>(Ex i A) IMP B\\<guillemotright>\\<rbrakk>e \\<and> atom i \\<sharp> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A B i.\n       p =\n       \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e \\<and>\n       q =\n       \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n                                B\\<guillemotright>\\<rbrakk>e \\<and>\n       atom i \\<sharp> B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>A B i.\n       p =\n       \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e \\<and>\n       q =\n       \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n                                B\\<guillemotright>\\<rbrakk>e \\<and>\n       atom i \\<sharp> B", "obtain x ax y v\n    where x:    \"Form x\"\n      and noc:  \"VarNonOccForm v y\"\n      and abst: \"AbstForm v 0 x ax\"\n      and p: \"p = q_Imp x y\"\n      and q: \"q = q_Imp (q_Ex ax) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x v y ax.\n        \\<lbrakk>Form x; VarNonOccForm v y; AbstForm v 0 x ax;\n         p = q_Imp x y; q = q_Imp (q_Ex ax) y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  Exists p q\n\ngoal (1 subgoal):\n 1. (\\<And>x v y ax.\n        \\<lbrakk>Form x; VarNonOccForm v y; AbstForm v 0 x ax;\n         p = q_Imp x y; q = q_Imp (q_Ex ax) y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Exists_def)"], ["proof (state)\nthis:\n  Form x\n  VarNonOccForm v y\n  AbstForm v 0 x ax\n  p = q_Imp x y\n  q = q_Imp (q_Ex ax) y\n\ngoal (1 subgoal):\n 1. \\<exists>A B i.\n       p =\n       \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e \\<and>\n       q =\n       \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n                                B\\<guillemotright>\\<rbrakk>e \\<and>\n       atom i \\<sharp> B", "then"], ["proof (chain)\npicking this:\n  Form x\n  VarNonOccForm v y\n  AbstForm v 0 x ax\n  p = q_Imp x y\n  q = q_Imp (q_Ex ax) y", "obtain B::fm where B: \"y = \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\" and vfresh: \"atom (decode_Var v) \\<sharp> B\""], ["proof (prove)\nusing this:\n  Form x\n  VarNonOccForm v y\n  AbstForm v 0 x ax\n  p = q_Imp x y\n  q = q_Imp (q_Ex ax) y\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>y = \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e;\n         atom (decode_Var v) \\<sharp> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis VarNonOccForm_imp_fresh)"], ["proof (state)\nthis:\n  y = \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n  atom (decode_Var v) \\<sharp> B\n\ngoal (1 subgoal):\n 1. \\<exists>A B i.\n       p =\n       \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e \\<and>\n       q =\n       \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n                                B\\<guillemotright>\\<rbrakk>e \\<and>\n       atom i \\<sharp> B", "obtain A::fm where A: \"x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        x =\n        \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis Form_imp_is_fm x)"], ["proof (state)\nthis:\n  x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<exists>A B i.\n       p =\n       \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e \\<and>\n       q =\n       \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n                                B\\<guillemotright>\\<rbrakk>e \\<and>\n       atom i \\<sharp> B", "with AbstForm_imp_abst_dbfm [OF abst, of e]"], ["proof (chain)\npicking this:\n  \\<exists>A.\n     x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     ax =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord 0) A)\\<rbrakk>e\n  x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e", "have ax: \"ax = \\<lbrakk>quot_dbfm (abst_dbfm (decode_Var v) 0 (trans_fm [] A))\\<rbrakk>e\"\n           \"p = \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e\""], ["proof (prove)\nusing this:\n  \\<exists>A.\n     x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     ax =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord 0) A)\\<rbrakk>e\n  x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. ax =\n    \\<lbrakk>quot_dbfm\n              (abst_dbfm (decode_Var v) 0 (trans_fm [] A))\\<rbrakk>e &&&\n    p = \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e", "using p A B"], ["proof (prove)\nusing this:\n  \\<exists>A.\n     x = \\<lbrakk>quot_dbfm A\\<rbrakk>e \\<and>\n     ax =\n     \\<lbrakk>quot_dbfm\n               (abst_dbfm (decode_Var v) (nat_of_ord 0) A)\\<rbrakk>e\n  x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n  p = q_Imp x y\n  x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n  y = \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. ax =\n    \\<lbrakk>quot_dbfm\n              (abst_dbfm (decode_Var v) 0 (trans_fm [] A))\\<rbrakk>e &&&\n    p = \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e", "by (auto simp: quot_simps quot_fm_def q_defs)"], ["proof (state)\nthis:\n  ax =\n  \\<lbrakk>quot_dbfm (abst_dbfm (decode_Var v) 0 (trans_fm [] A))\\<rbrakk>e\n  p = \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<exists>A B i.\n       p =\n       \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e \\<and>\n       q =\n       \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n                                B\\<guillemotright>\\<rbrakk>e \\<and>\n       atom i \\<sharp> B", "have \"q = \\<lbrakk>\\<guillemotleft>(Ex (decode_Var v) A) IMP B\\<guillemotright>\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q =\n    \\<lbrakk>\\<guillemotleft>SyntaxN.Ex (decode_Var v) A IMP\n                             B\\<guillemotright>\\<rbrakk>e", "using q A B ax"], ["proof (prove)\nusing this:\n  q = q_Imp (q_Ex ax) y\n  x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n  y = \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n  ax =\n  \\<lbrakk>quot_dbfm (abst_dbfm (decode_Var v) 0 (trans_fm [] A))\\<rbrakk>e\n  p = \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. q =\n    \\<lbrakk>\\<guillemotleft>SyntaxN.Ex (decode_Var v) A IMP\n                             B\\<guillemotright>\\<rbrakk>e", "by (auto simp: abst_trans_fm quot_simps q_defs)"], ["proof (state)\nthis:\n  q =\n  \\<lbrakk>\\<guillemotleft>SyntaxN.Ex (decode_Var v) A IMP\n                           B\\<guillemotright>\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<exists>A B i.\n       p =\n       \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e \\<and>\n       q =\n       \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n                                B\\<guillemotright>\\<rbrakk>e \\<and>\n       atom i \\<sharp> B", "then"], ["proof (chain)\npicking this:\n  q =\n  \\<lbrakk>\\<guillemotleft>SyntaxN.Ex (decode_Var v) A IMP\n                           B\\<guillemotright>\\<rbrakk>e", "show ?thesis"], ["proof (prove)\nusing this:\n  q =\n  \\<lbrakk>\\<guillemotleft>SyntaxN.Ex (decode_Var v) A IMP\n                           B\\<guillemotright>\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<exists>A B i.\n       p =\n       \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e \\<and>\n       q =\n       \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n                                B\\<guillemotright>\\<rbrakk>e \\<and>\n       atom i \\<sharp> B", "using vfresh ax"], ["proof (prove)\nusing this:\n  q =\n  \\<lbrakk>\\<guillemotleft>SyntaxN.Ex (decode_Var v) A IMP\n                           B\\<guillemotright>\\<rbrakk>e\n  atom (decode_Var v) \\<sharp> B\n  ax =\n  \\<lbrakk>quot_dbfm (abst_dbfm (decode_Var v) 0 (trans_fm [] A))\\<rbrakk>e\n  p = \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<exists>A B i.\n       p =\n       \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e \\<and>\n       q =\n       \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n                                B\\<guillemotright>\\<rbrakk>e \\<and>\n       atom i \\<sharp> B", "by blast"], ["proof (state)\nthis:\n  \\<exists>A B i.\n     p = \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e \\<and>\n     q =\n     \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n                              B\\<guillemotright>\\<rbrakk>e \\<and>\n     atom i \\<sharp> B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Exists_intro: \"atom i \\<sharp> B \\<Longrightarrow> Exists (\\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e) \\<lbrakk>\\<guillemotleft>(Ex i A) IMP B\\<guillemotright>\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom i \\<sharp> B \\<Longrightarrow>\n    Exists \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e\n     \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n                              B\\<guillemotright>\\<rbrakk>e", "by (simp add: Exists_def quot_simps q_defs)\n     (metis AbstForm_trans_fm Form_quot_fm fresh_imp_VarNonOccForm)"], ["", "text\\<open>Thus, we have precisely captured the codes of the specialisation axioms.\\<close>"], ["", "corollary Exists_iff_exists:\n  \"Exists p q \\<longleftrightarrow> (\\<exists>A B i. p = \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e \\<and> q = \\<lbrakk>\\<guillemotleft>(Ex i A) IMP B\\<guillemotright>\\<rbrakk>e \\<and> atom i \\<sharp> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Exists p q =\n    (\\<exists>A B i.\n        p =\n        \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e \\<and>\n        q =\n        \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n                                 B\\<guillemotright>\\<rbrakk>e \\<and>\n        atom i \\<sharp> B)", "by (force dest: Exists_imp_exists Exists_intro)"], ["", "subsection \\<open>The predicate \\<open>SubstP\\<close>, for the substitution rule\\<close>"], ["", "text\\<open>Although the substitution rule is derivable in the calculus, the derivation is\ntoo complicated to reproduce within the proof function. It is much easier to\nprovide it as an immediate inference step, justifying its soundness in terms\nof other inference rules.\\<close>"], ["", "subsubsection \\<open>Definition\\<close>"], ["", "text\\<open>This is the inference \\<open>H \\<turnstile> A \\<Longrightarrow> H \\<turnstile> A (i::=x)\\<close>\\<close>"], ["", "definition Subst :: \"hf \\<Rightarrow> hf \\<Rightarrow> bool\" where\n  \"Subst p q \\<equiv> (\\<exists>v u. SubstForm v u p q)\""], ["", "nominal_function SubstP :: \"tm \\<Rightarrow> tm \\<Rightarrow> fm\" where\n  \"\\<lbrakk>atom u \\<sharp> (p,q,v); atom v \\<sharp> (p,q)\\<rbrakk> \\<Longrightarrow>\n   SubstP p q = Ex v (Ex u (SubstFormP (Var v) (Var u) p q))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt SubstP_graph_aux\n 2. \\<And>x y. SubstP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>u p q v.\n           \\<lbrakk>atom u \\<sharp> (p, q, v); atom v \\<sharp> (p, q);\n            x = (p, q)\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>u p q v ua pa qa va.\n       \\<lbrakk>atom u \\<sharp> (p, q, v); atom v \\<sharp> (p, q);\n        atom ua \\<sharp> (pa, qa, va); atom va \\<sharp> (pa, qa);\n        (p, q) = (pa, qa)\\<rbrakk>\n       \\<Longrightarrow> SyntaxN.Ex v\n                          (SyntaxN.Ex u (SubstFormP (Var v) (Var u) p q)) =\n                         SyntaxN.Ex va\n                          (SyntaxN.Ex ua\n                            (SubstFormP (Var va) (Var ua) pa qa))", "by (auto simp: eqvt_def SubstP_graph_aux_def flip_fresh_fresh) (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All SubstP_dom", "by lexicographic_order"], ["", "lemma\n shows SubstP_fresh_iff [simp]: \"a \\<sharp> SubstP p q \\<longleftrightarrow> a \\<sharp> p \\<and> a \\<sharp> q\"        (is ?thesis1)\n   and eval_fm_SubstP [simp]: \"eval_fm e (SubstP p q) \\<longleftrightarrow> Subst \\<lbrakk>p\\<rbrakk>e \\<lbrakk>q\\<rbrakk>e\" (is ?thesis2)\n   and SubstP_sf [iff]: \"Sigma_fm (SubstP p q)\"                           (is ?thesis3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> SubstP p q = (a \\<sharp> p \\<and> a \\<sharp> q) &&&\n    eval_fm e (SubstP p q) =\n    Subst \\<lbrakk>p\\<rbrakk>e \\<lbrakk>q\\<rbrakk>e &&&\n    Sigma_fm (SubstP p q)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. a \\<sharp> SubstP p q = (a \\<sharp> p \\<and> a \\<sharp> q)\n 2. eval_fm e (SubstP p q) = Subst \\<lbrakk>p\\<rbrakk>e \\<lbrakk>q\\<rbrakk>e\n 3. Sigma_fm (SubstP p q)", "obtain u::name and v::name  where \"atom u \\<sharp> (p,q,v)\" \"atom v \\<sharp> (p,q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>atom u \\<sharp> (p, q, v); atom v \\<sharp> (p, q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom u \\<sharp> (p, q, v)\n  atom v \\<sharp> (p, q)\n\ngoal (3 subgoals):\n 1. a \\<sharp> SubstP p q = (a \\<sharp> p \\<and> a \\<sharp> q)\n 2. eval_fm e (SubstP p q) = Subst \\<lbrakk>p\\<rbrakk>e \\<lbrakk>q\\<rbrakk>e\n 3. Sigma_fm (SubstP p q)", "thus ?thesis1 ?thesis2 ?thesis3"], ["proof (prove)\nusing this:\n  atom u \\<sharp> (p, q, v)\n  atom v \\<sharp> (p, q)\n\ngoal (1 subgoal):\n 1. a \\<sharp> SubstP p q = (a \\<sharp> p \\<and> a \\<sharp> q) &&&\n    eval_fm e (SubstP p q) =\n    Subst \\<lbrakk>p\\<rbrakk>e \\<lbrakk>q\\<rbrakk>e &&&\n    Sigma_fm (SubstP p q)", "by (auto simp: Subst_def q_defs)"], ["proof (state)\nthis:\n  a \\<sharp> SubstP p q = (a \\<sharp> p \\<and> a \\<sharp> q)\n  eval_fm e (SubstP p q) = Subst \\<lbrakk>p\\<rbrakk>e \\<lbrakk>q\\<rbrakk>e\n  Sigma_fm (SubstP p q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SubstP_subst [simp]: \"(SubstP p q)(j::=w) = SubstP (subst j w p) (subst j w q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SubstP p q)(j::=w) = SubstP (subst j w p) (subst j w q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (SubstP p q)(j::=w) = SubstP (subst j w p) (subst j w q)", "obtain u::name and v::name  where \"atom u \\<sharp> (j,w,p,q,v)\"  \"atom v \\<sharp> (j,w,p,q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>atom u \\<sharp> (j, w, p, q, v);\n         atom v \\<sharp> (j, w, p, q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom u \\<sharp> (j, w, p, q, v)\n  atom v \\<sharp> (j, w, p, q)\n\ngoal (1 subgoal):\n 1. (SubstP p q)(j::=w) = SubstP (subst j w p) (subst j w q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom u \\<sharp> (j, w, p, q, v)\n  atom v \\<sharp> (j, w, p, q)\n\ngoal (1 subgoal):\n 1. (SubstP p q)(j::=w) = SubstP (subst j w p) (subst j w q)", "by (simp add: SubstP.simps [of u _ _ v])"], ["proof (state)\nthis:\n  (SubstP p q)(j::=w) = SubstP (subst j w p) (subst j w q)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Correctness\\<close>"], ["", "lemma Subst_imp_subst:\n  assumes \"Subst p q\" \"Form p\"\n  shows \"\\<exists>A::fm. \\<exists>i t. p = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and> q = \\<lbrakk>\\<guillemotleft>A(i::=t)\\<guillemotright>\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A i t.\n       p = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       q = \\<lbrakk>\\<guillemotleft>A(i::=t)\\<guillemotright>\\<rbrakk>e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>A i t.\n       p = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       q = \\<lbrakk>\\<guillemotleft>A(i::=t)\\<guillemotright>\\<rbrakk>e", "obtain v u where subst: \"SubstForm v u p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v u.\n        SubstForm v u p q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  Subst p q\n  Form p\n\ngoal (1 subgoal):\n 1. (\\<And>v u.\n        SubstForm v u p q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Subst_def)"], ["proof (state)\nthis:\n  SubstForm v u p q\n\ngoal (1 subgoal):\n 1. \\<exists>A i t.\n       p = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       q = \\<lbrakk>\\<guillemotleft>A(i::=t)\\<guillemotright>\\<rbrakk>e", "then"], ["proof (chain)\npicking this:\n  SubstForm v u p q", "obtain t::tm where substt: \"SubstForm v \\<lbrakk>\\<guillemotleft>t\\<guillemotright>\\<rbrakk>e p q\""], ["proof (prove)\nusing this:\n  SubstForm v u p q\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        SubstForm v \\<lbrakk>\\<guillemotleft>t\\<guillemotright>\\<rbrakk>e p\n         q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis SubstForm_def Term_imp_is_tm)"], ["proof (state)\nthis:\n  SubstForm v \\<lbrakk>\\<guillemotleft>t\\<guillemotright>\\<rbrakk>e p q\n\ngoal (1 subgoal):\n 1. \\<exists>A i t.\n       p = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       q = \\<lbrakk>\\<guillemotleft>A(i::=t)\\<guillemotright>\\<rbrakk>e", "with SubstForm_imp_subst_fm [OF substt] assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>Form p;\n   \\<And>A.\n      \\<lbrakk>p = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n       q =\n       \\<lbrakk>\\<guillemotleft>A(decode_Var\n                                   v::=t)\\<guillemotright>\\<rbrakk>e\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  Subst p q\n  Form p\n  SubstForm v \\<lbrakk>\\<guillemotleft>t\\<guillemotright>\\<rbrakk>e p q", "obtain A where \"p = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\"  \"q = \\<lbrakk>\\<guillemotleft>A(decode_Var v::=t)\\<guillemotright>\\<rbrakk>e\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Form p;\n   \\<And>A.\n      \\<lbrakk>p = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n       q =\n       \\<lbrakk>\\<guillemotleft>A(decode_Var\n                                   v::=t)\\<guillemotright>\\<rbrakk>e\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  Subst p q\n  Form p\n  SubstForm v \\<lbrakk>\\<guillemotleft>t\\<guillemotright>\\<rbrakk>e p q\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>p = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n         q =\n         \\<lbrakk>\\<guillemotleft>A(decode_Var\n                                     v::=t)\\<guillemotright>\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n  q =\n  \\<lbrakk>\\<guillemotleft>A(decode_Var v::=t)\\<guillemotright>\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<exists>A i t.\n       p = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       q = \\<lbrakk>\\<guillemotleft>A(i::=t)\\<guillemotright>\\<rbrakk>e", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n  q =\n  \\<lbrakk>\\<guillemotleft>A(decode_Var v::=t)\\<guillemotright>\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<exists>A i t.\n       p = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       q = \\<lbrakk>\\<guillemotleft>A(i::=t)\\<guillemotright>\\<rbrakk>e", "by blast"], ["proof (state)\nthis:\n  \\<exists>A i t.\n     p = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     q = \\<lbrakk>\\<guillemotleft>A(i::=t)\\<guillemotright>\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The predicate \\<open>PrfP\\<close>\\<close>"], ["", "(*Prf(s,k,t) \\<equiv> LstSeq(s,k,t) \\<and> (\\<forall>n\\<in>k)[Sent (s n) \\<or> (\\<exists>m,l\\<in>n)[ModPon (s m) (s l) (s n)]]*)"], ["", "definition Prf :: \"hf \\<Rightarrow> hf \\<Rightarrow> hf \\<Rightarrow> bool\"\n  where \"Prf s k y \\<equiv> BuildSeq (\\<lambda>x. x \\<in> Axiom) (\\<lambda>u v w. ModPon v w u \\<or> Exists v u \\<or> Subst v u) s k y\""], ["", "nominal_function PrfP :: \"tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> fm\"\n  where \"\\<lbrakk>atom l \\<sharp> (s,sl,m,n,sm,sn); atom sl \\<sharp> (s,m,n,sm,sn);\n          atom m \\<sharp> (s,n,sm,sn); atom n \\<sharp> (s,k,sm,sn);\n          atom sm \\<sharp> (s,sn); atom sn \\<sharp> (s)\\<rbrakk> \\<Longrightarrow>\n    PrfP s k t =\n      LstSeqP s k t AND\n      All2 n (SUCC k) (Ex sn (HPair (Var n) (Var sn) IN s AND (AxiomP (Var sn) OR\n                Ex m (Ex l (Ex sm (Ex sl (Var m IN Var n AND Var l IN Var n AND\n                       HPair (Var m) (Var sm) IN s AND HPair (Var l) (Var sl) IN s AND\n                       (ModPonP (Var sm) (Var sl) (Var sn) OR\n                        ExistsP (Var sm) (Var sn) OR\n                        SubstP (Var sm) (Var sn)))))))))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt PrfP_graph_aux\n 2. \\<And>x y. PrfP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>l s sl m n sm sn k t.\n           \\<lbrakk>atom l \\<sharp> (s, sl, m, n, sm, sn);\n            atom sl \\<sharp> (s, m, n, sm, sn);\n            atom m \\<sharp> (s, n, sm, sn); atom n \\<sharp> (s, k, sm, sn);\n            atom sm \\<sharp> (s, sn); atom sn \\<sharp> s;\n            x = (s, k, t)\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>l s sl m n sm sn k t la sa sla ma na sma sna ka ta.\n       \\<lbrakk>atom l \\<sharp> (s, sl, m, n, sm, sn);\n        atom sl \\<sharp> (s, m, n, sm, sn); atom m \\<sharp> (s, n, sm, sn);\n        atom n \\<sharp> (s, k, sm, sn); atom sm \\<sharp> (s, sn);\n        atom sn \\<sharp> s; atom la \\<sharp> (sa, sla, ma, na, sma, sna);\n        atom sla \\<sharp> (sa, ma, na, sma, sna);\n        atom ma \\<sharp> (sa, na, sma, sna);\n        atom na \\<sharp> (sa, ka, sma, sna); atom sma \\<sharp> (sa, sna);\n        atom sna \\<sharp> sa; (s, k, t) = (sa, ka, ta)\\<rbrakk>\n       \\<Longrightarrow> LstSeqP s k t AND\n                         All2 n (SUCC k)\n                          (SyntaxN.Ex sn\n                            (HPair (Var n) (Var sn) IN s AND\n                             (AxiomP (Var sn) OR\n                              SyntaxN.Ex m\n                               (SyntaxN.Ex l\n                                 (SyntaxN.Ex sm\n                                   (SyntaxN.Ex sl\n                                     (Var m IN Var n AND\nVar l IN Var n AND\nHPair (Var m) (Var sm) IN s AND\nHPair (Var l) (Var sl) IN s AND\n(ModPonP (Var sm) (Var sl) (Var sn) OR\n ExistsP (Var sm) (Var sn) OR SubstP (Var sm) (Var sn))))))))) =\n                         LstSeqP sa ka ta AND\n                         All2 na (SUCC ka)\n                          (SyntaxN.Ex sna\n                            (HPair (Var na) (Var sna) IN sa AND\n                             (AxiomP (Var sna) OR\n                              SyntaxN.Ex ma\n                               (SyntaxN.Ex la\n                                 (SyntaxN.Ex sma\n                                   (SyntaxN.Ex sla\n                                     (Var ma IN Var na AND\nVar la IN Var na AND\nHPair (Var ma) (Var sma) IN sa AND\nHPair (Var la) (Var sla) IN sa AND\n(ModPonP (Var sma) (Var sla) (Var sna) OR\n ExistsP (Var sma) (Var sna) OR SubstP (Var sma) (Var sna)))))))))", "by (auto simp: eqvt_def PrfP_graph_aux_def flip_fresh_fresh) (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All PrfP_dom", "by lexicographic_order"], ["", "lemma\n  shows PrfP_fresh_iff [simp]: \"a \\<sharp> PrfP s k t \\<longleftrightarrow> a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> t\"      (is ?thesis1)\n  and eval_fm_PrfP [simp]:     \"eval_fm e (PrfP s k t) \\<longleftrightarrow> Prf \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\"  (is ?thesis2)\n  and PrfP_imp_OrdP [simp]:    \"{PrfP s k t} \\<turnstile> OrdP k\"         (is ?thord)\n  and PrfP_imp_LstSeqP [simp]: \"{PrfP s k t} \\<turnstile> LstSeqP s k t\"  (is ?thlstseq)\n  and PrfP_sf [iff]:           \"Sigma_fm (PrfP s k t)\"         (is ?thsf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<sharp> PrfP s k t =\n     (a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> t) &&&\n     eval_fm e (PrfP s k t) =\n     Prf \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e) &&&\n    {PrfP s k t} \\<turnstile> OrdP k &&&\n    {PrfP s k t} \\<turnstile> LstSeqP s k t &&& Sigma_fm (PrfP s k t)", "proof -"], ["proof (state)\ngoal (5 subgoals):\n 1. a \\<sharp> PrfP s k t =\n    (a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> t)\n 2. eval_fm e (PrfP s k t) =\n    Prf \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\n 3. {PrfP s k t} \\<turnstile> OrdP k\n 4. {PrfP s k t} \\<turnstile> LstSeqP s k t\n 5. Sigma_fm (PrfP s k t)", "obtain l::name and sl::name and m::name and n::name and sm::name and sn::name\n    where atoms: \"atom l \\<sharp> (s,sl,m,n,sm,sn)\"   \"atom sl \\<sharp> (s,m,n,sm,sn)\"\n        \"atom m \\<sharp> (s,n,sm,sn)\"   \"atom n \\<sharp> (s,k,sm,sn)\"\n        \"atom sm \\<sharp> (s,sn)\"   \"atom sn \\<sharp> (s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l sl m n sm sn.\n        \\<lbrakk>atom l \\<sharp> (s, sl, m, n, sm, sn);\n         atom sl \\<sharp> (s, m, n, sm, sn); atom m \\<sharp> (s, n, sm, sn);\n         atom n \\<sharp> (s, k, sm, sn); atom sm \\<sharp> (s, sn);\n         atom sn \\<sharp> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom l \\<sharp> (s, sl, m, n, sm, sn)\n  atom sl \\<sharp> (s, m, n, sm, sn)\n  atom m \\<sharp> (s, n, sm, sn)\n  atom n \\<sharp> (s, k, sm, sn)\n  atom sm \\<sharp> (s, sn)\n  atom sn \\<sharp> s\n\ngoal (5 subgoals):\n 1. a \\<sharp> PrfP s k t =\n    (a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> t)\n 2. eval_fm e (PrfP s k t) =\n    Prf \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\n 3. {PrfP s k t} \\<turnstile> OrdP k\n 4. {PrfP s k t} \\<turnstile> LstSeqP s k t\n 5. Sigma_fm (PrfP s k t)", "thus ?thesis1 ?thord ?thlstseq ?thsf"], ["proof (prove)\nusing this:\n  atom l \\<sharp> (s, sl, m, n, sm, sn)\n  atom sl \\<sharp> (s, m, n, sm, sn)\n  atom m \\<sharp> (s, n, sm, sn)\n  atom n \\<sharp> (s, k, sm, sn)\n  atom sm \\<sharp> (s, sn)\n  atom sn \\<sharp> s\n\ngoal (1 subgoal):\n 1. (a \\<sharp> PrfP s k t =\n     (a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> t) &&&\n     {PrfP s k t} \\<turnstile> OrdP k) &&&\n    {PrfP s k t} \\<turnstile> LstSeqP s k t &&& Sigma_fm (PrfP s k t)", "by (auto intro: LstSeqP_OrdP)"], ["proof (state)\nthis:\n  a \\<sharp> PrfP s k t =\n  (a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> t)\n  {PrfP s k t} \\<turnstile> OrdP k\n  {PrfP s k t} \\<turnstile> LstSeqP s k t\n  Sigma_fm (PrfP s k t)\n\ngoal (1 subgoal):\n 1. eval_fm e (PrfP s k t) =\n    Prf \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e", "show ?thesis2"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_fm e (PrfP s k t) =\n    Prf \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e", "using atoms"], ["proof (prove)\nusing this:\n  atom l \\<sharp> (s, sl, m, n, sm, sn)\n  atom sl \\<sharp> (s, m, n, sm, sn)\n  atom m \\<sharp> (s, n, sm, sn)\n  atom n \\<sharp> (s, k, sm, sn)\n  atom sm \\<sharp> (s, sn)\n  atom sn \\<sharp> s\n\ngoal (1 subgoal):\n 1. eval_fm e (PrfP s k t) =\n    Prf \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e", "by simp\n       (simp cong: conj_cong add: LstSeq_imp_Ord Prf_def BuildSeq_def Builds_def\n             ModPon_def Exists_def HBall_def HBex_def\n             Seq_iff_app [OF LstSeq_imp_Seq_succ]\n             Ord_trans [of _ _ \"succ \\<lbrakk>k\\<rbrakk>e\"])"], ["proof (state)\nthis:\n  eval_fm e (PrfP s k t) =\n  Prf \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>t\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma PrfP_subst [simp]:\n     \"(PrfP t u v)(j::=w) = PrfP (subst j w t) (subst j w u) (subst j w v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (PrfP t u v)(j::=w) = PrfP (subst j w t) (subst j w u) (subst j w v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (PrfP t u v)(j::=w) = PrfP (subst j w t) (subst j w u) (subst j w v)", "obtain l::name and sl::name and m::name and n::name and sm::name and sn::name\n    where \"atom l \\<sharp> (t,u,v,j,w,sl,m,n,sm,sn)\"   \"atom sl \\<sharp> (t,u,v,j,w,m,n,sm,sn)\"\n          \"atom m \\<sharp> (t,u,v,j,w,n,sm,sn)\"   \"atom n \\<sharp> (t,u,v,j,w,sm,sn)\"\n          \"atom sm \\<sharp> (t,u,v,j,w,sn)\"   \"atom sn \\<sharp> (t,u,v,j,w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l sl m n sm sn.\n        \\<lbrakk>atom l \\<sharp> (t, u, v, j, w, sl, m, n, sm, sn);\n         atom sl \\<sharp> (t, u, v, j, w, m, n, sm, sn);\n         atom m \\<sharp> (t, u, v, j, w, n, sm, sn);\n         atom n \\<sharp> (t, u, v, j, w, sm, sn);\n         atom sm \\<sharp> (t, u, v, j, w, sn);\n         atom sn \\<sharp> (t, u, v, j, w)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom l \\<sharp> (t, u, v, j, w, sl, m, n, sm, sn)\n  atom sl \\<sharp> (t, u, v, j, w, m, n, sm, sn)\n  atom m \\<sharp> (t, u, v, j, w, n, sm, sn)\n  atom n \\<sharp> (t, u, v, j, w, sm, sn)\n  atom sm \\<sharp> (t, u, v, j, w, sn)\n  atom sn \\<sharp> (t, u, v, j, w)\n\ngoal (1 subgoal):\n 1. (PrfP t u v)(j::=w) = PrfP (subst j w t) (subst j w u) (subst j w v)", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom l \\<sharp> (t, u, v, j, w, sl, m, n, sm, sn)\n  atom sl \\<sharp> (t, u, v, j, w, m, n, sm, sn)\n  atom m \\<sharp> (t, u, v, j, w, n, sm, sn)\n  atom n \\<sharp> (t, u, v, j, w, sm, sn)\n  atom sm \\<sharp> (t, u, v, j, w, sn)\n  atom sn \\<sharp> (t, u, v, j, w)\n\ngoal (1 subgoal):\n 1. (PrfP t u v)(j::=w) = PrfP (subst j w t) (subst j w u) (subst j w v)", "by (simp add: PrfP.simps [of l _ sl m n sm sn])"], ["proof (state)\nthis:\n  (PrfP t u v)(j::=w) = PrfP (subst j w t) (subst j w u) (subst j w v)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The predicate \\<open>PfP\\<close>\\<close>"], ["", "definition Pf :: \"hf \\<Rightarrow> bool\"\n  where \"Pf y \\<equiv> (\\<exists>s k. Prf s k y)\""], ["", "nominal_function PfP :: \"tm \\<Rightarrow> fm\"\n  where \"\\<lbrakk>atom k \\<sharp> (s,y); atom s \\<sharp> y\\<rbrakk> \\<Longrightarrow>\n    PfP y = Ex k (Ex s (PrfP (Var s) (Var k) y))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt PfP_graph_aux\n 2. \\<And>x y. PfP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>k s y.\n           \\<lbrakk>atom k \\<sharp> (s, y); atom s \\<sharp> y;\n            x = y\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>k s y ka sa ya.\n       \\<lbrakk>atom k \\<sharp> (s, y); atom s \\<sharp> y;\n        atom ka \\<sharp> (sa, ya); atom sa \\<sharp> ya; y = ya\\<rbrakk>\n       \\<Longrightarrow> SyntaxN.Ex k\n                          (SyntaxN.Ex s (PrfP (Var s) (Var k) y)) =\n                         SyntaxN.Ex ka\n                          (SyntaxN.Ex sa (PrfP (Var sa) (Var ka) ya))", "by (auto simp: eqvt_def PfP_graph_aux_def flip_fresh_fresh) (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All PfP_dom", "by lexicographic_order"], ["", "lemma\n shows PfP_fresh_iff [simp]: \"a \\<sharp> PfP y \\<longleftrightarrow> a \\<sharp> y\"           (is ?thesis1)\n   and eval_fm_PfP [simp]:  \"eval_fm e (PfP y) \\<longleftrightarrow> Pf \\<lbrakk>y\\<rbrakk>e\"  (is ?thesis2)\n   and PfP_sf [iff]: \"Sigma_fm (PfP y)\"                      (is ?thsf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> PfP y = a \\<sharp> y &&&\n    eval_fm e (PfP y) = Pf \\<lbrakk>y\\<rbrakk>e &&& Sigma_fm (PfP y)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. a \\<sharp> PfP y = a \\<sharp> y\n 2. eval_fm e (PfP y) = Pf \\<lbrakk>y\\<rbrakk>e\n 3. Sigma_fm (PfP y)", "obtain k::name and s::name where \"atom k \\<sharp> (s,y)\" \"atom s \\<sharp> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k s.\n        \\<lbrakk>atom k \\<sharp> (s, y); atom s \\<sharp> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom k \\<sharp> (s, y)\n  atom s \\<sharp> y\n\ngoal (3 subgoals):\n 1. a \\<sharp> PfP y = a \\<sharp> y\n 2. eval_fm e (PfP y) = Pf \\<lbrakk>y\\<rbrakk>e\n 3. Sigma_fm (PfP y)", "thus ?thesis1 ?thesis2 ?thsf"], ["proof (prove)\nusing this:\n  atom k \\<sharp> (s, y)\n  atom s \\<sharp> y\n\ngoal (1 subgoal):\n 1. a \\<sharp> PfP y = a \\<sharp> y &&&\n    eval_fm e (PfP y) = Pf \\<lbrakk>y\\<rbrakk>e &&& Sigma_fm (PfP y)", "by (auto simp: Pf_def)"], ["proof (state)\nthis:\n  a \\<sharp> PfP y = a \\<sharp> y\n  eval_fm e (PfP y) = Pf \\<lbrakk>y\\<rbrakk>e\n  Sigma_fm (PfP y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma PfP_subst [simp]: \"(PfP t)(j::=w) = PfP (subst j w t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (PfP t)(j::=w) = PfP (subst j w t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (PfP t)(j::=w) = PfP (subst j w t)", "obtain k::name and s::name where \"atom k \\<sharp> (s,t,j,w)\" \"atom s \\<sharp> (t,j,w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k s.\n        \\<lbrakk>atom k \\<sharp> (s, t, j, w);\n         atom s \\<sharp> (t, j, w)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom k \\<sharp> (s, t, j, w)\n  atom s \\<sharp> (t, j, w)\n\ngoal (1 subgoal):\n 1. (PfP t)(j::=w) = PfP (subst j w t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom k \\<sharp> (s, t, j, w)\n  atom s \\<sharp> (t, j, w)\n\ngoal (1 subgoal):\n 1. (PfP t)(j::=w) = PfP (subst j w t)", "by (auto simp: PfP.simps [of k s])"], ["proof (state)\nthis:\n  (PfP t)(j::=w) = PfP (subst j w t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ground_PfP [simp]: \"ground_fm (PfP y) = ground y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ground_fm (PfP y) = ground y", "by (simp add: ground_aux_def ground_fm_aux_def supp_conv_fresh)"], ["", "section\\<open>Proposition 4.4\\<close>"], ["", "subsection\\<open>Left-to-Right Proof\\<close>"], ["", "lemma extra_axiom_imp_Pf: \"Pf \\<lbrakk>\\<guillemotleft>extra_axiom\\<guillemotright>\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>extra_axiom\\<guillemotright>\\<rbrakk>e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>extra_axiom\\<guillemotright>\\<rbrakk>e", "have \"\\<lbrakk>\\<guillemotleft>extra_axiom\\<guillemotright>\\<rbrakk>e \\<in> Extra_ax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<guillemotleft>extra_axiom\\<guillemotright>\\<rbrakk>e\n    \\<in> Extra_ax", "by (simp add: Extra_ax_def) (rule eval_quot_fm_ignore)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<guillemotleft>extra_axiom\\<guillemotright>\\<rbrakk>e\n  \\<in> Extra_ax\n\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>extra_axiom\\<guillemotright>\\<rbrakk>e", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<guillemotleft>extra_axiom\\<guillemotright>\\<rbrakk>e\n  \\<in> Extra_ax\n\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>extra_axiom\\<guillemotright>\\<rbrakk>e", "by (force simp add: Pf_def Prf_def Axiom_def intro: BuildSeq_exI)"], ["proof (state)\nthis:\n  Pf \\<lbrakk>\\<guillemotleft>extra_axiom\\<guillemotright>\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma boolean_axioms_imp_Pf:\n  assumes \"\\<alpha> \\<in> boolean_axioms\" shows \"Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e", "have \"\\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e \\<in> Sent\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e \\<in> Sent", "using assms"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> boolean_axioms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e \\<in> Sent", "by (rule boolean_axioms.cases)\n       (auto simp: Sent_def Sent_axioms_def quot_Disj quot_Neg q_defs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e \\<in> Sent\n\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e \\<in> Sent\n\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e", "by (force simp add: Pf_def Prf_def Axiom_def intro: BuildSeq_exI)"], ["proof (state)\nthis:\n  Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma equality_axioms_imp_Pf:\n  assumes \"\\<alpha> \\<in> equality_axioms\" shows \"Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e", "have \"\\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e \\<in> Equality_ax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\n    \\<in> Equality_ax", "using assms [unfolded equality_axioms_def]"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> {refl_ax, eq_cong_ax, mem_cong_ax, eats_cong_ax}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\n    \\<in> Equality_ax", "by (auto simp: Equality_ax_def eval_quot_fm_ignore)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\n  \\<in> Equality_ax\n\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\n  \\<in> Equality_ax\n\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e", "by (force simp add: Pf_def Prf_def Axiom_def intro: BuildSeq_exI)"], ["proof (state)\nthis:\n  Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HF_axioms_imp_Pf:\n  assumes \"\\<alpha> \\<in> HF_axioms\" shows \"Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e", "have \"\\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e \\<in> HF_ax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e \\<in> HF_ax", "using assms [unfolded HF_axioms_def]"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> {HF1, HF2}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e \\<in> HF_ax", "by (auto simp: HF_ax_def eval_quot_fm_ignore)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e \\<in> HF_ax\n\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e \\<in> HF_ax\n\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e", "by (force simp add: Pf_def Prf_def Axiom_def intro: BuildSeq_exI)"], ["proof (state)\nthis:\n  Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma special_axioms_imp_Pf:\n  assumes \"\\<alpha> \\<in> special_axioms\" shows \"Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e", "have \"\\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e \\<in> Special_ax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\n    \\<in> Special_ax", "by (metis special_axioms_into_Special_ax assms)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\n  \\<in> Special_ax\n\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\n  \\<in> Special_ax\n\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e", "by (force simp add: Pf_def Prf_def Axiom_def intro: BuildSeq_exI)"], ["proof (state)\nthis:\n  Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma induction_axioms_imp_Pf:\n  assumes \"\\<alpha> \\<in> induction_axioms\" shows \"Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e", "have \"\\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e \\<in> Induction_ax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\n    \\<in> Induction_ax", "by (metis induction_axioms_into_Induction_ax assms)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\n  \\<in> Induction_ax\n\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\n  \\<in> Induction_ax\n\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e", "by (force simp add: Pf_def Prf_def Axiom_def intro: BuildSeq_exI)"], ["proof (state)\nthis:\n  Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ModPon_imp_Pf: \"\\<lbrakk>Pf \\<lbrakk>Q_Imp x y\\<rbrakk>e; Pf \\<lbrakk>x\\<rbrakk>e\\<rbrakk> \\<Longrightarrow> Pf \\<lbrakk>y\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Pf \\<lbrakk>Q_Imp x y\\<rbrakk>e;\n     Pf \\<lbrakk>x\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> Pf \\<lbrakk>y\\<rbrakk>e", "by (auto simp: Pf_def Prf_def ModPon_def q_defs intro: BuildSeq_combine)"], ["", "lemma quot_ModPon_imp_Pf: \"\\<lbrakk>Pf \\<lbrakk>\\<guillemotleft>\\<alpha> IMP \\<beta>\\<guillemotright>\\<rbrakk>e; Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\\<rbrakk> \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>\\<beta>\\<guillemotright>\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Pf \\<lbrakk>\\<guillemotleft>\\<alpha> IMP\n   \\<beta>\\<guillemotright>\\<rbrakk>e;\n     Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\\<rbrakk>\n    \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>\\<beta>\\<guillemotright>\\<rbrakk>e", "by (simp add: ModPon_imp_Pf quot_fm_def quot_simps q_defs)"], ["", "lemma quot_Exists_imp_Pf: \"\\<lbrakk>Pf \\<lbrakk>\\<guillemotleft>\\<alpha> IMP \\<beta>\\<guillemotright>\\<rbrakk>e; atom i \\<sharp> \\<beta>\\<rbrakk> \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>Ex i \\<alpha> IMP \\<beta>\\<guillemotright>\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Pf \\<lbrakk>\\<guillemotleft>\\<alpha> IMP\n   \\<beta>\\<guillemotright>\\<rbrakk>e;\n     atom i \\<sharp> \\<beta>\\<rbrakk>\n    \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i \\<alpha> IMP\n            \\<beta>\\<guillemotright>\\<rbrakk>e", "by (force simp: Pf_def Prf_def Exists_def quot_simps q_defs \n            intro: BuildSeq_combine AbstForm_trans_fm_eq fresh_imp_VarNonOccForm)"], ["", "lemma proved_imp_Pf: assumes \"H \\<turnstile> \\<alpha>\" \"H={}\" shows \"Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e", "using assms"], ["proof (prove)\nusing this:\n  H \\<turnstile> \\<alpha>\n  H = {}\n\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e", "proof (induct)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>A H.\n       \\<lbrakk>A \\<in> H; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 2. \\<And>H.\n       H = {} \\<Longrightarrow>\n       Pf \\<lbrakk>\\<guillemotleft>extra_axiom\\<guillemotright>\\<rbrakk>e\n 3. \\<And>A H.\n       \\<lbrakk>A \\<in> boolean_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 4. \\<And>A H.\n       \\<lbrakk>A \\<in> equality_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 5. \\<And>A H.\n       \\<lbrakk>A \\<in> special_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 6. \\<And>A H.\n       \\<lbrakk>A \\<in> HF_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 7. \\<And>A H.\n       \\<lbrakk>A \\<in> induction_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 8. \\<And>H A B H'.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        H' \\<turnstile> A;\n        H' = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n        H \\<union> H' = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n 9. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "case (Hyp A H)"], ["proof (state)\nthis:\n  A \\<in> H\n  H = {}\n\ngoal (9 subgoals):\n 1. \\<And>A H.\n       \\<lbrakk>A \\<in> H; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 2. \\<And>H.\n       H = {} \\<Longrightarrow>\n       Pf \\<lbrakk>\\<guillemotleft>extra_axiom\\<guillemotright>\\<rbrakk>e\n 3. \\<And>A H.\n       \\<lbrakk>A \\<in> boolean_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 4. \\<And>A H.\n       \\<lbrakk>A \\<in> equality_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 5. \\<And>A H.\n       \\<lbrakk>A \\<in> special_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 6. \\<And>A H.\n       \\<lbrakk>A \\<in> HF_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 7. \\<And>A H.\n       \\<lbrakk>A \\<in> induction_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 8. \\<And>H A B H'.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        H' \\<turnstile> A;\n        H' = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n        H \\<union> H' = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n 9. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "thus ?case"], ["proof (prove)\nusing this:\n  A \\<in> H\n  H = {}\n\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e", "by auto"], ["proof (state)\nthis:\n  Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n\ngoal (8 subgoals):\n 1. \\<And>H.\n       H = {} \\<Longrightarrow>\n       Pf \\<lbrakk>\\<guillemotleft>extra_axiom\\<guillemotright>\\<rbrakk>e\n 2. \\<And>A H.\n       \\<lbrakk>A \\<in> boolean_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 3. \\<And>A H.\n       \\<lbrakk>A \\<in> equality_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 4. \\<And>A H.\n       \\<lbrakk>A \\<in> special_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 5. \\<And>A H.\n       \\<lbrakk>A \\<in> HF_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 6. \\<And>A H.\n       \\<lbrakk>A \\<in> induction_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 7. \\<And>H A B H'.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        H' \\<turnstile> A;\n        H' = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n        H \\<union> H' = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n 8. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>H.\n       H = {} \\<Longrightarrow>\n       Pf \\<lbrakk>\\<guillemotleft>extra_axiom\\<guillemotright>\\<rbrakk>e\n 2. \\<And>A H.\n       \\<lbrakk>A \\<in> boolean_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 3. \\<And>A H.\n       \\<lbrakk>A \\<in> equality_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 4. \\<And>A H.\n       \\<lbrakk>A \\<in> special_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 5. \\<And>A H.\n       \\<lbrakk>A \\<in> HF_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 6. \\<And>A H.\n       \\<lbrakk>A \\<in> induction_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 7. \\<And>H A B H'.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        H' \\<turnstile> A;\n        H' = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n        H \\<union> H' = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n 8. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "case (Extra H)"], ["proof (state)\nthis:\n  H = {}\n\ngoal (8 subgoals):\n 1. \\<And>H.\n       H = {} \\<Longrightarrow>\n       Pf \\<lbrakk>\\<guillemotleft>extra_axiom\\<guillemotright>\\<rbrakk>e\n 2. \\<And>A H.\n       \\<lbrakk>A \\<in> boolean_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 3. \\<And>A H.\n       \\<lbrakk>A \\<in> equality_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 4. \\<And>A H.\n       \\<lbrakk>A \\<in> special_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 5. \\<And>A H.\n       \\<lbrakk>A \\<in> HF_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 6. \\<And>A H.\n       \\<lbrakk>A \\<in> induction_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 7. \\<And>H A B H'.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        H' \\<turnstile> A;\n        H' = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n        H \\<union> H' = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n 8. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "thus ?case"], ["proof (prove)\nusing this:\n  H = {}\n\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>extra_axiom\\<guillemotright>\\<rbrakk>e", "by (metis extra_axiom_imp_Pf)"], ["proof (state)\nthis:\n  Pf \\<lbrakk>\\<guillemotleft>extra_axiom\\<guillemotright>\\<rbrakk>e\n\ngoal (7 subgoals):\n 1. \\<And>A H.\n       \\<lbrakk>A \\<in> boolean_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 2. \\<And>A H.\n       \\<lbrakk>A \\<in> equality_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 3. \\<And>A H.\n       \\<lbrakk>A \\<in> special_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 4. \\<And>A H.\n       \\<lbrakk>A \\<in> HF_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 5. \\<And>A H.\n       \\<lbrakk>A \\<in> induction_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 6. \\<And>H A B H'.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        H' \\<turnstile> A;\n        H' = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n        H \\<union> H' = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n 7. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>A H.\n       \\<lbrakk>A \\<in> boolean_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 2. \\<And>A H.\n       \\<lbrakk>A \\<in> equality_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 3. \\<And>A H.\n       \\<lbrakk>A \\<in> special_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 4. \\<And>A H.\n       \\<lbrakk>A \\<in> HF_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 5. \\<And>A H.\n       \\<lbrakk>A \\<in> induction_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 6. \\<And>H A B H'.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        H' \\<turnstile> A;\n        H' = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n        H \\<union> H' = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n 7. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "case (Bool A H)"], ["proof (state)\nthis:\n  A \\<in> boolean_axioms\n  H = {}\n\ngoal (7 subgoals):\n 1. \\<And>A H.\n       \\<lbrakk>A \\<in> boolean_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 2. \\<And>A H.\n       \\<lbrakk>A \\<in> equality_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 3. \\<And>A H.\n       \\<lbrakk>A \\<in> special_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 4. \\<And>A H.\n       \\<lbrakk>A \\<in> HF_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 5. \\<And>A H.\n       \\<lbrakk>A \\<in> induction_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 6. \\<And>H A B H'.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        H' \\<turnstile> A;\n        H' = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n        H \\<union> H' = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n 7. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "thus ?case"], ["proof (prove)\nusing this:\n  A \\<in> boolean_axioms\n  H = {}\n\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e", "by (metis boolean_axioms_imp_Pf)"], ["proof (state)\nthis:\n  Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n\ngoal (6 subgoals):\n 1. \\<And>A H.\n       \\<lbrakk>A \\<in> equality_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 2. \\<And>A H.\n       \\<lbrakk>A \\<in> special_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 3. \\<And>A H.\n       \\<lbrakk>A \\<in> HF_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 4. \\<And>A H.\n       \\<lbrakk>A \\<in> induction_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 5. \\<And>H A B H'.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        H' \\<turnstile> A;\n        H' = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n        H \\<union> H' = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n 6. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>A H.\n       \\<lbrakk>A \\<in> equality_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 2. \\<And>A H.\n       \\<lbrakk>A \\<in> special_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 3. \\<And>A H.\n       \\<lbrakk>A \\<in> HF_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 4. \\<And>A H.\n       \\<lbrakk>A \\<in> induction_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 5. \\<And>H A B H'.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        H' \\<turnstile> A;\n        H' = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n        H \\<union> H' = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n 6. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "case (Eq A H)"], ["proof (state)\nthis:\n  A \\<in> equality_axioms\n  H = {}\n\ngoal (6 subgoals):\n 1. \\<And>A H.\n       \\<lbrakk>A \\<in> equality_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 2. \\<And>A H.\n       \\<lbrakk>A \\<in> special_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 3. \\<And>A H.\n       \\<lbrakk>A \\<in> HF_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 4. \\<And>A H.\n       \\<lbrakk>A \\<in> induction_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 5. \\<And>H A B H'.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        H' \\<turnstile> A;\n        H' = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n        H \\<union> H' = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n 6. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "thus ?case"], ["proof (prove)\nusing this:\n  A \\<in> equality_axioms\n  H = {}\n\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e", "by (metis equality_axioms_imp_Pf)"], ["proof (state)\nthis:\n  Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n\ngoal (5 subgoals):\n 1. \\<And>A H.\n       \\<lbrakk>A \\<in> special_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 2. \\<And>A H.\n       \\<lbrakk>A \\<in> HF_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 3. \\<And>A H.\n       \\<lbrakk>A \\<in> induction_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 4. \\<And>H A B H'.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        H' \\<turnstile> A;\n        H' = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n        H \\<union> H' = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n 5. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>A H.\n       \\<lbrakk>A \\<in> special_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 2. \\<And>A H.\n       \\<lbrakk>A \\<in> HF_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 3. \\<And>A H.\n       \\<lbrakk>A \\<in> induction_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 4. \\<And>H A B H'.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        H' \\<turnstile> A;\n        H' = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n        H \\<union> H' = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n 5. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "case (HF A H)"], ["proof (state)\nthis:\n  A \\<in> HF_axioms\n  H = {}\n\ngoal (5 subgoals):\n 1. \\<And>A H.\n       \\<lbrakk>A \\<in> special_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 2. \\<And>A H.\n       \\<lbrakk>A \\<in> HF_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 3. \\<And>A H.\n       \\<lbrakk>A \\<in> induction_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 4. \\<And>H A B H'.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        H' \\<turnstile> A;\n        H' = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n        H \\<union> H' = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n 5. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "thus ?case"], ["proof (prove)\nusing this:\n  A \\<in> HF_axioms\n  H = {}\n\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e", "by (metis HF_axioms_imp_Pf)"], ["proof (state)\nthis:\n  Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n\ngoal (4 subgoals):\n 1. \\<And>A H.\n       \\<lbrakk>A \\<in> special_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 2. \\<And>A H.\n       \\<lbrakk>A \\<in> induction_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 3. \\<And>H A B H'.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        H' \\<turnstile> A;\n        H' = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n        H \\<union> H' = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n 4. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>A H.\n       \\<lbrakk>A \\<in> special_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 2. \\<And>A H.\n       \\<lbrakk>A \\<in> induction_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 3. \\<And>H A B H'.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        H' \\<turnstile> A;\n        H' = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n        H \\<union> H' = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n 4. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "case (Spec A H)"], ["proof (state)\nthis:\n  A \\<in> special_axioms\n  H = {}\n\ngoal (4 subgoals):\n 1. \\<And>A H.\n       \\<lbrakk>A \\<in> special_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 2. \\<And>A H.\n       \\<lbrakk>A \\<in> induction_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 3. \\<And>H A B H'.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        H' \\<turnstile> A;\n        H' = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n        H \\<union> H' = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n 4. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "thus ?case"], ["proof (prove)\nusing this:\n  A \\<in> special_axioms\n  H = {}\n\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e", "by (metis special_axioms_imp_Pf)"], ["proof (state)\nthis:\n  Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n\ngoal (3 subgoals):\n 1. \\<And>A H.\n       \\<lbrakk>A \\<in> induction_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 2. \\<And>H A B H'.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        H' \\<turnstile> A;\n        H' = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n        H \\<union> H' = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n 3. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A H.\n       \\<lbrakk>A \\<in> induction_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 2. \\<And>H A B H'.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        H' \\<turnstile> A;\n        H' = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n        H \\<union> H' = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n 3. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "case (Ind A H)"], ["proof (state)\nthis:\n  A \\<in> induction_axioms\n  H = {}\n\ngoal (3 subgoals):\n 1. \\<And>A H.\n       \\<lbrakk>A \\<in> induction_axioms; H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n 2. \\<And>H A B H'.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        H' \\<turnstile> A;\n        H' = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n        H \\<union> H' = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n 3. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "thus ?case"], ["proof (prove)\nusing this:\n  A \\<in> induction_axioms\n  H = {}\n\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e", "by (metis induction_axioms_imp_Pf)"], ["proof (state)\nthis:\n  Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n\ngoal (2 subgoals):\n 1. \\<And>H A B H'.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        H' \\<turnstile> A;\n        H' = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n        H \\<union> H' = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n 2. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>H A B H'.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        H' \\<turnstile> A;\n        H' = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n        H \\<union> H' = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n 2. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "case (MP H A B H')"], ["proof (state)\nthis:\n  H \\<turnstile> A IMP B\n  H = {} \\<Longrightarrow>\n  Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e\n  H' \\<turnstile> A\n  H' = {} \\<Longrightarrow>\n  Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n  H \\<union> H' = {}\n\ngoal (2 subgoals):\n 1. \\<And>H A B H'.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        H' \\<turnstile> A;\n        H' = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n        H \\<union> H' = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n 2. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "thus ?case"], ["proof (prove)\nusing this:\n  H \\<turnstile> A IMP B\n  H = {} \\<Longrightarrow>\n  Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e\n  H' \\<turnstile> A\n  H' = {} \\<Longrightarrow>\n  Pf \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n  H \\<union> H' = {}\n\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e", "by (metis quot_ModPon_imp_Pf Un_empty)"], ["proof (state)\nthis:\n  Pf \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "case (Exists H A B i)"], ["proof (state)\nthis:\n  H \\<turnstile> A IMP B\n  H = {} \\<Longrightarrow>\n  Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e\n  atom i \\<sharp> B\n  \\<forall>C\\<in>H. atom i \\<sharp> C\n  H = {}\n\ngoal (1 subgoal):\n 1. \\<And>H A B i.\n       \\<lbrakk>H \\<turnstile> A IMP B;\n        H = {} \\<Longrightarrow>\n        Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e;\n        atom i \\<sharp> B; \\<forall>C\\<in>H. atom i \\<sharp> C;\n        H = {}\\<rbrakk>\n       \\<Longrightarrow> Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n               B\\<guillemotright>\\<rbrakk>e", "thus ?case"], ["proof (prove)\nusing this:\n  H \\<turnstile> A IMP B\n  H = {} \\<Longrightarrow>\n  Pf \\<lbrakk>\\<guillemotleft>A IMP B\\<guillemotright>\\<rbrakk>e\n  atom i \\<sharp> B\n  \\<forall>C\\<in>H. atom i \\<sharp> C\n  H = {}\n\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n                                B\\<guillemotright>\\<rbrakk>e", "by (metis quot_Exists_imp_Pf)"], ["proof (state)\nthis:\n  Pf \\<lbrakk>\\<guillemotleft>SyntaxN.Ex i A IMP\n                              B\\<guillemotright>\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary proved_imp_proved_PfP: \"{} \\<turnstile> \\<alpha> \\<Longrightarrow> {} \\<turnstile> PfP \\<guillemotleft>\\<alpha>\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<turnstile> \\<alpha> \\<Longrightarrow>\n    {} \\<turnstile> PfP \\<guillemotleft>\\<alpha>\\<guillemotright>", "by (rule Sigma_fm_imp_thm [OF PfP_sf]) \n     (auto simp: ground_aux_def supp_conv_fresh proved_imp_Pf)"], ["", "subsection\\<open>Right-to-Left Proof\\<close>"], ["", "lemma Sent_imp_hfthm:\n  assumes \"x \\<in> Sent\" shows \"\\<exists>A. x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and> {} \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       {} \\<turnstile> A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       {} \\<turnstile> A", "obtain y z w where \"Form y\" \"Form z\" \"Form w\" and axs: \"Sent_axioms x y z w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y z w.\n        \\<lbrakk>Form y; Form z; Form w; Sent_axioms x y z w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> Sent\n\ngoal (1 subgoal):\n 1. (\\<And>y z w.\n        \\<lbrakk>Form y; Form z; Form w; Sent_axioms x y z w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Sent_def)"], ["proof (state)\nthis:\n  Form y\n  Form z\n  Form w\n  Sent_axioms x y z w\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       {} \\<turnstile> A", "then"], ["proof (chain)\npicking this:\n  Form y\n  Form z\n  Form w\n  Sent_axioms x y z w", "obtain A::fm and B::fm and C::fm \n         where A: \"y = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\" and B: \"z = \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\" and C: \"w = \\<lbrakk>\\<guillemotleft>C\\<guillemotright>\\<rbrakk>e\""], ["proof (prove)\nusing this:\n  Form y\n  Form z\n  Form w\n  Sent_axioms x y z w\n\ngoal (1 subgoal):\n 1. (\\<And>A B C.\n        \\<lbrakk>y = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n         z = \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e;\n         w = \\<lbrakk>\\<guillemotleft>C\\<guillemotright>\\<rbrakk>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Form_imp_is_fm)"], ["proof (state)\nthis:\n  y = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n  z = \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n  w = \\<lbrakk>\\<guillemotleft>C\\<guillemotright>\\<rbrakk>e\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       {} \\<turnstile> A", "have \"\\<exists>A. q_Imp y y = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and> {} \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       q_Imp y y =\n       \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       {} \\<turnstile> A", "by (force simp add: A quot_Disj quot_Neg q_defs hfthm.Bool boolean_axioms.intros)"], ["proof (state)\nthis:\n  \\<exists>A.\n     q_Imp y y =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       {} \\<turnstile> A", "moreover"], ["proof (state)\nthis:\n  \\<exists>A.\n     q_Imp y y =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       {} \\<turnstile> A", "have \"\\<exists>A. q_Imp y (q_Disj y z) = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and> {} \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       q_Imp y (q_Disj y z) =\n       \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       {} \\<turnstile> A", "by (force intro!: exI [where x=\"A IMP (A OR B)\"]\n                simp add: A B quot_Disj quot_Neg q_defs hfthm.Bool boolean_axioms.intros)"], ["proof (state)\nthis:\n  \\<exists>A.\n     q_Imp y (q_Disj y z) =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       {} \\<turnstile> A", "moreover"], ["proof (state)\nthis:\n  \\<exists>A.\n     q_Imp y (q_Disj y z) =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       {} \\<turnstile> A", "have \"\\<exists>A. q_Imp (q_Disj y y) y = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and> {} \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       q_Imp (q_Disj y y) y =\n       \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       {} \\<turnstile> A", "by (force intro!: exI [where x=\"(A OR A) IMP A\"]\n                simp add: A quot_Disj quot_Neg q_defs hfthm.Bool boolean_axioms.intros)"], ["proof (state)\nthis:\n  \\<exists>A.\n     q_Imp (q_Disj y y) y =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       {} \\<turnstile> A", "moreover"], ["proof (state)\nthis:\n  \\<exists>A.\n     q_Imp (q_Disj y y) y =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       {} \\<turnstile> A", "have \"\\<exists>A. q_Imp (q_Disj y (q_Disj z w)) (q_Disj (q_Disj y z) w) = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and> {} \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       q_Imp (q_Disj y (q_Disj z w)) (q_Disj (q_Disj y z) w) =\n       \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       {} \\<turnstile> A", "by (force intro!: exI [where x=\"(A OR (B OR C)) IMP ((A OR B) OR C)\"]\n                simp add: A B C quot_Disj quot_Neg q_defs hfthm.Bool boolean_axioms.intros)"], ["proof (state)\nthis:\n  \\<exists>A.\n     q_Imp (q_Disj y (q_Disj z w)) (q_Disj (q_Disj y z) w) =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       {} \\<turnstile> A", "moreover"], ["proof (state)\nthis:\n  \\<exists>A.\n     q_Imp (q_Disj y (q_Disj z w)) (q_Disj (q_Disj y z) w) =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       {} \\<turnstile> A", "have \"\\<exists>A. q_Imp (q_Disj y z) (q_Imp (q_Disj (q_Neg y) w) (q_Disj z w)) = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and> {} \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       q_Imp (q_Disj y z) (q_Imp (q_Disj (q_Neg y) w) (q_Disj z w)) =\n       \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       {} \\<turnstile> A", "by (force intro!: exI [where x=\"(A OR B) IMP ((Neg A OR C) IMP (B OR C))\"]\n                simp add: A B C quot_Disj quot_Neg q_defs hfthm.Bool boolean_axioms.intros)"], ["proof (state)\nthis:\n  \\<exists>A.\n     q_Imp (q_Disj y z) (q_Imp (q_Disj (q_Neg y) w) (q_Disj z w)) =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       {} \\<turnstile> A", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>A.\n     q_Imp y y =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n  \\<exists>A.\n     q_Imp y (q_Disj y z) =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n  \\<exists>A.\n     q_Imp (q_Disj y y) y =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n  \\<exists>A.\n     q_Imp (q_Disj y (q_Disj z w)) (q_Disj (q_Disj y z) w) =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n  \\<exists>A.\n     q_Imp (q_Disj y z) (q_Imp (q_Disj (q_Neg y) w) (q_Disj z w)) =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>A.\n     q_Imp y y =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n  \\<exists>A.\n     q_Imp y (q_Disj y z) =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n  \\<exists>A.\n     q_Imp (q_Disj y y) y =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n  \\<exists>A.\n     q_Imp (q_Disj y (q_Disj z w)) (q_Disj (q_Disj y z) w) =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n  \\<exists>A.\n     q_Imp (q_Disj y z) (q_Imp (q_Disj (q_Neg y) w) (q_Disj z w)) =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       {} \\<turnstile> A", "using axs [unfolded Sent_axioms_def]"], ["proof (prove)\nusing this:\n  \\<exists>A.\n     q_Imp y y =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n  \\<exists>A.\n     q_Imp y (q_Disj y z) =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n  \\<exists>A.\n     q_Imp (q_Disj y y) y =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n  \\<exists>A.\n     q_Imp (q_Disj y (q_Disj z w)) (q_Disj (q_Disj y z) w) =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n  \\<exists>A.\n     q_Imp (q_Disj y z) (q_Imp (q_Disj (q_Neg y) w) (q_Disj z w)) =\n     \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n  x = q_Imp y y \\<or>\n  x = q_Imp y (q_Disj y z) \\<or>\n  x = q_Imp (q_Disj y y) y \\<or>\n  x = q_Imp (q_Disj y (q_Disj z w)) (q_Disj (q_Disj y z) w) \\<or>\n  x = q_Imp (q_Disj y z) (q_Imp (q_Disj (q_Neg y) w) (q_Disj z w))\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       {} \\<turnstile> A", "by blast"], ["proof (state)\nthis:\n  \\<exists>A.\n     x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Extra_ax_imp_hfthm:\n  assumes \"x \\<in> Extra_ax\" obtains A where \"x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and> {} \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n        {} \\<turnstile> A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> Extra_ax\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n        {} \\<turnstile> A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding Extra_ax_def"], ["proof (prove)\nusing this:\n  x \\<in> {\\<lbrakk>\\<guillemotleft>extra_axiom\\<guillemotright>\\<rbrakk>e0}\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n        {} \\<turnstile> A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: eval_quot_fm_ignore hfthm.Extra)"], ["", "lemma Equality_ax_imp_hfthm:\n  assumes \"x \\<in> Equality_ax\" obtains A where \"x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and> {} \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n        {} \\<turnstile> A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> Equality_ax\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n        {} \\<turnstile> A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding Equality_ax_def"], ["proof (prove)\nusing this:\n  x \\<in> {\\<lbrakk>\\<guillemotleft>refl_ax\\<guillemotright>\\<rbrakk>e0,\n           \\<lbrakk>\\<guillemotleft>eq_cong_ax\\<guillemotright>\\<rbrakk>e0,\n           \\<lbrakk>\\<guillemotleft>mem_cong_ax\\<guillemotright>\\<rbrakk>e0,\n           \\<lbrakk>\\<guillemotleft>eats_cong_ax\\<guillemotright>\\<rbrakk>e0}\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n        {} \\<turnstile> A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: eval_quot_fm_ignore hfthm.Eq [unfolded equality_axioms_def])"], ["", "lemma HF_ax_imp_hfthm:\n  assumes \"x \\<in> HF_ax\" obtains A where \"x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and> {} \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n        {} \\<turnstile> A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> HF_ax\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n        {} \\<turnstile> A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding HF_ax_def"], ["proof (prove)\nusing this:\n  x \\<in> {\\<lbrakk>\\<guillemotleft>HF1\\<guillemotright>\\<rbrakk>e0,\n           \\<lbrakk>\\<guillemotleft>HF2\\<guillemotright>\\<rbrakk>e0}\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n        {} \\<turnstile> A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: eval_quot_fm_ignore hfthm.HF [unfolded HF_axioms_def])"], ["", "lemma Special_ax_imp_hfthm:\n  assumes \"x \\<in> Special_ax\" obtains A where \"x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\" \"{} \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n         {} \\<turnstile> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Spec Special_ax_imp_special_axioms assms)"], ["", "lemma Induction_ax_imp_hfthm:\n  assumes \"x \\<in> Induction_ax\" obtains A where \"x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\" \"{} \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n         {} \\<turnstile> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Induction_ax_imp_induction_axioms assms hfthm.Ind)"], ["", "lemma Exists_imp_hfthm: \"\\<lbrakk>Exists \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e y; {} \\<turnstile> A\\<rbrakk> \\<Longrightarrow> \\<exists>B. y = \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e \\<and> {} \\<turnstile> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Exists \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e y;\n     {} \\<turnstile> A\\<rbrakk>\n    \\<Longrightarrow> \\<exists>B.\n                         y =\n                         \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e \\<and>\n                         {} \\<turnstile> B", "by (drule Exists_imp_exists [where e=e]) (auto intro: anti_deduction)"], ["", "lemma Subst_imp_hfthm:  \"\\<lbrakk>Subst \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e y; {} \\<turnstile> A\\<rbrakk> \\<Longrightarrow> \\<exists>B. y = \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e \\<and> {} \\<turnstile> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Subst \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e y;\n     {} \\<turnstile> A\\<rbrakk>\n    \\<Longrightarrow> \\<exists>B.\n                         y =\n                         \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e \\<and>\n                         {} \\<turnstile> B", "by (drule Subst_imp_subst [where e=e], auto intro: Subst)"], ["", "lemma eval_Neg_imp_Neg: \"\\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e = q_Neg x \\<Longrightarrow> \\<exists>A. \\<alpha> = Neg A \\<and> \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e =\n    q_Neg x \\<Longrightarrow>\n    \\<exists>A.\n       \\<alpha> = Neg A \\<and>\n       \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e = x", "by (cases \\<alpha> rule: fm.exhaust) (auto simp: quot_simps q_defs htuple_minus_1)"], ["", "lemma eval_Disj_imp_Disj: \"\\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e = q_Disj x y \\<Longrightarrow> \\<exists>A B. \\<alpha> = A OR B \\<and> \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e = x \\<and> \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e =\n    q_Disj x y \\<Longrightarrow>\n    \\<exists>A B.\n       \\<alpha> = A OR B \\<and>\n       \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e = x \\<and>\n       \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e = y", "by (cases \\<alpha> rule: fm.exhaust) (auto simp: quot_simps q_defs htuple_minus_1)"], ["", "lemma Prf_imp_proved: assumes \"Prf s k x\" shows \"\\<exists>A. x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and> {} \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       {} \\<turnstile> A", "using assms [unfolded Prf_def Axiom_def]"], ["proof (prove)\nusing this:\n  BuildSeq\n   (\\<lambda>x.\n       x \\<in> Extra_ax \\<union> Sent \\<union> Equality_ax \\<union>\n               HF_ax \\<union>\n               Special_ax \\<union>\n               Induction_ax)\n   (\\<lambda>u v w. ModPon v w u \\<or> Exists v u \\<or> Subst v u) s k x\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       {} \\<turnstile> A", "proof (induction x rule: BuildSeq_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Extra_ax \\<union> Sent \\<union> Equality_ax \\<union>\n               HF_ax \\<union>\n               Special_ax \\<union>\n               Induction_ax \\<Longrightarrow>\n       \\<exists>A.\n          x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n          {} \\<turnstile> A\n 2. \\<And>x y z.\n       \\<lbrakk>ModPon y z x \\<or> Exists y x \\<or> Subst y x;\n        \\<exists>A.\n           y = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n           {} \\<turnstile> A;\n        \\<exists>A.\n           z = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n           {} \\<turnstile> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            x =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            {} \\<turnstile> A", "case (B x)"], ["proof (state)\nthis:\n  x \\<in> Extra_ax \\<union> Sent \\<union> Equality_ax \\<union>\n          HF_ax \\<union>\n          Special_ax \\<union>\n          Induction_ax\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Extra_ax \\<union> Sent \\<union> Equality_ax \\<union>\n               HF_ax \\<union>\n               Special_ax \\<union>\n               Induction_ax \\<Longrightarrow>\n       \\<exists>A.\n          x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n          {} \\<turnstile> A\n 2. \\<And>x y z.\n       \\<lbrakk>ModPon y z x \\<or> Exists y x \\<or> Subst y x;\n        \\<exists>A.\n           y = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n           {} \\<turnstile> A;\n        \\<exists>A.\n           z = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n           {} \\<turnstile> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            x =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            {} \\<turnstile> A", "thus ?case"], ["proof (prove)\nusing this:\n  x \\<in> Extra_ax \\<union> Sent \\<union> Equality_ax \\<union>\n          HF_ax \\<union>\n          Special_ax \\<union>\n          Induction_ax\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       {} \\<turnstile> A", "by (auto intro: Extra_ax_imp_hfthm Sent_imp_hfthm Equality_ax_imp_hfthm HF_ax_imp_hfthm\n                    Special_ax_imp_hfthm Induction_ax_imp_hfthm)"], ["proof (state)\nthis:\n  \\<exists>A.\n     x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>ModPon y z x \\<or> Exists y x \\<or> Subst y x;\n        \\<exists>A.\n           y = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n           {} \\<turnstile> A;\n        \\<exists>A.\n           z = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n           {} \\<turnstile> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            x =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            {} \\<turnstile> A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>ModPon y z x \\<or> Exists y x \\<or> Subst y x;\n        \\<exists>A.\n           y = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n           {} \\<turnstile> A;\n        \\<exists>A.\n           z = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n           {} \\<turnstile> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            x =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            {} \\<turnstile> A", "case (C x y z)"], ["proof (state)\nthis:\n  ModPon y z x \\<or> Exists y x \\<or> Subst y x\n  \\<exists>A.\n     y = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n  \\<exists>A.\n     z = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>ModPon y z x \\<or> Exists y x \\<or> Subst y x;\n        \\<exists>A.\n           y = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n           {} \\<turnstile> A;\n        \\<exists>A.\n           z = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n           {} \\<turnstile> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            x =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            {} \\<turnstile> A", "then"], ["proof (chain)\npicking this:\n  ModPon y z x \\<or> Exists y x \\<or> Subst y x\n  \\<exists>A.\n     y = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n  \\<exists>A.\n     z = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A", "obtain A::fm and B::fm where \"y = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\" \"{} \\<turnstile> A\" \"z = \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\" \"{} \\<turnstile> B\""], ["proof (prove)\nusing this:\n  ModPon y z x \\<or> Exists y x \\<or> Subst y x\n  \\<exists>A.\n     y = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n  \\<exists>A.\n     z = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>y = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e;\n         {} \\<turnstile> A;\n         z = \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e;\n         {} \\<turnstile> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n  {} \\<turnstile> A\n  z = \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n  {} \\<turnstile> B\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>ModPon y z x \\<or> Exists y x \\<or> Subst y x;\n        \\<exists>A.\n           y = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n           {} \\<turnstile> A;\n        \\<exists>A.\n           z = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n           {} \\<turnstile> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            x =\n                            \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n                            {} \\<turnstile> A", "thus ?case"], ["proof (prove)\nusing this:\n  y = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n  {} \\<turnstile> A\n  z = \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n  {} \\<turnstile> B\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       {} \\<turnstile> A", "using C.hyps ModPon_def q_Imp_def"], ["proof (prove)\nusing this:\n  y = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e\n  {} \\<turnstile> A\n  z = \\<lbrakk>\\<guillemotleft>B\\<guillemotright>\\<rbrakk>e\n  {} \\<turnstile> B\n  ModPon y z x \\<or> Exists y x \\<or> Subst y x\n  ModPon ?x ?y ?z \\<equiv> ?y = q_Imp ?x ?z\n  q_Imp ?t ?u \\<equiv> q_Disj (q_Neg ?t) ?u\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n       {} \\<turnstile> A", "by (auto dest!: MP_same eval_Neg_imp_Neg eval_Disj_imp_Disj Exists_imp_hfthm Subst_imp_hfthm)"], ["proof (state)\nthis:\n  \\<exists>A.\n     x = \\<lbrakk>\\<guillemotleft>A\\<guillemotright>\\<rbrakk>e \\<and>\n     {} \\<turnstile> A\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary Pf_quot_imp_is_proved: \"Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e \\<Longrightarrow> {} \\<turnstile> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pf \\<lbrakk>\\<guillemotleft>\\<alpha>\\<guillemotright>\\<rbrakk>e \\<Longrightarrow>\n    {} \\<turnstile> \\<alpha>", "by (metis Pf_def Prf_imp_proved eval_fm_inject)"], ["", "text\\<open>Proposition 4.4!\\<close>"], ["", "theorem proved_iff_proved_PfP: \"{} \\<turnstile> \\<alpha> \\<longleftrightarrow> {} \\<turnstile> PfP \\<guillemotleft>\\<alpha>\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<turnstile> \\<alpha> =\n    {} \\<turnstile> PfP \\<guillemotleft>\\<alpha>\\<guillemotright>", "by (metis Pf_quot_imp_is_proved emptyE eval_fm_PfP hfthm_sound proved_imp_proved_PfP)"], ["", "end"]]}