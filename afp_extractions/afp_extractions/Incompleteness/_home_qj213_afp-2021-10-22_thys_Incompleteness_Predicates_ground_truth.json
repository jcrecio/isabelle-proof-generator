{"file_name": "/home/qj213/afp-2021-10-22/thys/Incompleteness/Predicates.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Incompleteness", "problem_names": ["lemma Subset_fresh_iff [simp]: \"a \\<sharp> t SUBS u \\<longleftrightarrow> a \\<sharp> t \\<and> a \\<sharp> u\"", "lemma eval_fm_Subset [simp]: \"eval_fm e (Subset t u) \\<longleftrightarrow> (\\<lbrakk>t\\<rbrakk>e \\<le> \\<lbrakk>u\\<rbrakk>e)\"", "lemma subst_fm_Subset [simp]: \"(t SUBS u)(i::=x) = (subst i x t) SUBS (subst i x u)\"", "lemma Subset_I:\n  assumes \"insert ((Var i) IN t) H \\<turnstile> (Var i) IN u\" \"atom i \\<sharp> (t,u)\" \"\\<forall>B \\<in> H. atom i \\<sharp> B\"\n  shows \"H \\<turnstile> t SUBS u\"", "lemma Subset_D:\n  assumes major: \"H \\<turnstile> t SUBS u\" and minor: \"H \\<turnstile> a IN t\" shows \"H \\<turnstile> a IN u\"", "lemma Subset_E: \"H \\<turnstile> t SUBS u \\<Longrightarrow> H \\<turnstile> a IN t \\<Longrightarrow> insert (a IN u) H \\<turnstile> A \\<Longrightarrow> H \\<turnstile> A\"", "lemma Subset_cong: \"H \\<turnstile> t EQ t' \\<Longrightarrow> H \\<turnstile> u EQ u' \\<Longrightarrow> H \\<turnstile> t SUBS u IFF t' SUBS u'\"", "lemma Set_MP: \"x SUBS y \\<in> H \\<Longrightarrow> z IN x \\<in> H \\<Longrightarrow> insert (z IN y) H \\<turnstile> A \\<Longrightarrow> H \\<turnstile> A\"", "lemma Zero_Subset_I [intro!]: \"H \\<turnstile> Zero SUBS t\"", "lemma Zero_SubsetE: \"H \\<turnstile> A \\<Longrightarrow> insert (Zero SUBS X) H \\<turnstile> A\"", "lemma Subset_Zero_D:\n   assumes \"H \\<turnstile> t SUBS Zero\" shows \"H \\<turnstile> t EQ Zero\"", "lemma Subset_refl: \"H \\<turnstile> t SUBS t\"", "lemma Eats_Subset_Iff: \"H \\<turnstile> Eats x y SUBS z IFF (x SUBS z) AND (y IN z)\"", "lemma Eats_Subset_I [intro!]: \"H \\<turnstile> x SUBS z \\<Longrightarrow> H \\<turnstile> y IN z \\<Longrightarrow> H \\<turnstile> Eats x y SUBS z\"", "lemma Eats_Subset_E [intro!]:\n  \"insert (x SUBS z) (insert (y IN z) H) \\<turnstile> C \\<Longrightarrow> insert (Eats x y SUBS z) H \\<turnstile> C\"", "lemma Subset_Eats_I [intro!]: \"H \\<turnstile> x SUBS Eats x y\"", "lemma SUCC_Subset_I [intro!]: \"H \\<turnstile> x SUBS z \\<Longrightarrow> H \\<turnstile> x IN z \\<Longrightarrow> H \\<turnstile> SUCC x SUBS z\"", "lemma SUCC_Subset_E [intro!]:\n  \"insert (x SUBS z) (insert (x IN z) H) \\<turnstile> C \\<Longrightarrow> insert (SUCC x SUBS z) H \\<turnstile> C\"", "lemma Subset_trans0: \"{ a SUBS b, b SUBS c } \\<turnstile> a SUBS c\"", "lemma Subset_trans: \"H \\<turnstile> a SUBS b \\<Longrightarrow> H \\<turnstile> b SUBS c \\<Longrightarrow> H \\<turnstile> a SUBS c\"", "lemma Subset_SUCC: \"H \\<turnstile> a SUBS (SUCC a)\"", "lemma All2_Subset_lemma: \"atom l \\<sharp> (k',k) \\<Longrightarrow> {P} \\<turnstile> P' \\<Longrightarrow> {All2 l k P, k' SUBS k} \\<turnstile> All2 l k' P'\"", "lemma All2_Subset: \"\\<lbrakk>H \\<turnstile> All2 l k P; H \\<turnstile> k' SUBS k; {P} \\<turnstile> P'; atom l \\<sharp> (k', k)\\<rbrakk> \\<Longrightarrow> H \\<turnstile> All2 l k' P'\"", "lemma Extensionality: \"H \\<turnstile> x EQ y IFF x SUBS y AND y SUBS x\"", "lemma Equality_I: \"H \\<turnstile> y SUBS x \\<Longrightarrow> H \\<turnstile> x SUBS y \\<Longrightarrow> H \\<turnstile> x EQ y\"", "lemma EQ_imp_SUBS: \"insert (t EQ u) H \\<turnstile> (t SUBS u)\"", "lemma EQ_imp_SUBS2: \"insert (u EQ t) H \\<turnstile> (t SUBS u)\"", "lemma Equality_E: \"insert (t SUBS u) (insert (u SUBS t) H) \\<turnstile> A \\<Longrightarrow> insert (t EQ u) H \\<turnstile> A\"", "lemma Disjoint_fresh_iff [simp]: \"a \\<sharp> Disjoint t u \\<longleftrightarrow> a \\<sharp> t \\<and> a \\<sharp> u\"", "lemma subst_fm_Disjoint [simp]:\n  \"(Disjoint t u)(i::=x) = Disjoint (subst i x t) (subst i x u)\"", "lemma Disjoint_cong: \"H \\<turnstile> t EQ t' \\<Longrightarrow> H \\<turnstile> u EQ u' \\<Longrightarrow> H \\<turnstile> Disjoint t u IFF Disjoint t' u'\"", "lemma Disjoint_I:\n  assumes \"insert ((Var i) IN t) (insert ((Var i) IN u) H) \\<turnstile> Fls\"\n          \"atom i \\<sharp> (t,u)\" \"\\<forall>B \\<in> H. atom i \\<sharp> B\"\n  shows \"H \\<turnstile> Disjoint t u\"", "lemma Disjoint_E:\n  assumes major: \"H \\<turnstile> Disjoint t u\" and minor: \"H \\<turnstile> a IN t\" \"H \\<turnstile> a IN u\" shows \"H \\<turnstile> A\"", "lemma Disjoint_commute: \"{ Disjoint t u } \\<turnstile> Disjoint u t\"", "lemma Disjoint_commute_I: \"H \\<turnstile> Disjoint t u \\<Longrightarrow> H \\<turnstile> Disjoint u t\"", "lemma Disjoint_commute_D: \"insert (Disjoint t u) H \\<turnstile> A \\<Longrightarrow> insert (Disjoint u t) H \\<turnstile> A\"", "lemma Zero_Disjoint_I1 [iff]: \"H \\<turnstile> Disjoint Zero t\"", "lemma Zero_Disjoint_I2 [iff]: \"H \\<turnstile> Disjoint t Zero\"", "lemma Disjoint_Eats_D1: \"{ Disjoint (Eats x y) z } \\<turnstile> Disjoint x z\"", "lemma Disjoint_Eats_D2: \"{ Disjoint (Eats x y) z } \\<turnstile> Neg(y IN z)\"", "lemma Disjoint_Eats_E: \n  \"insert (Disjoint x z) (insert (Neg(y IN z)) H) \\<turnstile> A \\<Longrightarrow> insert (Disjoint (Eats x y) z) H \\<turnstile> A\"", "lemma Disjoint_Eats_E2: \n  \"insert (Disjoint z x) (insert (Neg(y IN z)) H) \\<turnstile> A \\<Longrightarrow> insert (Disjoint z (Eats x y)) H \\<turnstile> A\"", "lemma Disjoint_Eats_Imp: \"{ Disjoint x z, Neg(y IN z) } \\<turnstile> Disjoint (Eats x y) z\"", "lemma Disjoint_Eats_I [intro!]: \"H \\<turnstile> Disjoint x z \\<Longrightarrow> insert (y IN z) H \\<turnstile> Fls \\<Longrightarrow> H \\<turnstile> Disjoint (Eats x y) z\"", "lemma Disjoint_Eats_I2 [intro!]: \"H \\<turnstile> Disjoint z x \\<Longrightarrow> insert (y IN z) H \\<turnstile> Fls \\<Longrightarrow> H \\<turnstile> Disjoint z (Eats x y)\"", "lemma Foundation_lemma: \n  assumes i: \"atom i \\<sharp> z\"\n  shows \"{ All2 i z (Neg (Disjoint (Var i) z)) } \\<turnstile> Neg (Var i IN z) AND Disjoint (Var i) z\"", "theorem Foundation: \"atom i \\<sharp> z \\<Longrightarrow> {} \\<turnstile> All2 i z (Neg (Disjoint (Var i) z)) IMP z EQ Zero\"", "lemma Mem_Neg_refl: \"{} \\<turnstile> Neg (x IN x)\"", "lemma Mem_refl_E [intro!]: \"insert (x IN x) H \\<turnstile> A\"", "lemma Mem_non_refl: assumes \"H \\<turnstile> x IN x\" shows \"H \\<turnstile> A\"", "lemma Mem_Neg_sym: \"{ x IN y, y IN x } \\<turnstile> Fls\"", "lemma Mem_not_sym: \"insert (x IN y) (insert (y IN x) H) \\<turnstile> A\"", "lemma\n shows OrdP_fresh_iff [simp]: \"a \\<sharp> OrdP x \\<longleftrightarrow> a \\<sharp> x\"       (is ?thesis1)\n   and eval_fm_OrdP [simp]:  \"eval_fm e (OrdP x) \\<longleftrightarrow> Ord \\<lbrakk>x\\<rbrakk>e\"  (is ?thesis2)", "lemma subst_fm_OrdP [simp]: \"(OrdP t)(i::=x) = OrdP (subst i x t)\"", "lemma OrdP_cong: \"H \\<turnstile> x EQ x' \\<Longrightarrow> H \\<turnstile> OrdP x IFF OrdP x'\"", "lemma OrdP_Mem_lemma:\n  assumes z: \"atom z \\<sharp> (k,l)\" and l: \"insert (OrdP k) H \\<turnstile> l IN k\"\n  shows \"insert (OrdP k) H \\<turnstile> l SUBS k AND All2 z l (Var z SUBS l)\"", "lemma OrdP_Mem_E:\n  assumes \"atom z \\<sharp> (k,l)\" \n          \"insert (OrdP k) H \\<turnstile> l IN k\"\n          \"insert (l SUBS k) (insert (All2 z l (Var z SUBS l)) H) \\<turnstile> A\"\n  shows \"insert (OrdP k) H \\<turnstile> A\"", "lemma OrdP_Mem_imp_Subset:\n  assumes k: \"H \\<turnstile> k IN l\" and l: \"H \\<turnstile> OrdP l\" shows \"H \\<turnstile> k SUBS l\"", "lemma SUCC_Subset_Ord_lemma: \"{ k' IN k, OrdP k } \\<turnstile> SUCC k' SUBS k\"", "lemma SUCC_Subset_Ord: \"H \\<turnstile> k' IN k \\<Longrightarrow> H \\<turnstile> OrdP k \\<Longrightarrow> H \\<turnstile> SUCC k' SUBS k\"", "lemma OrdP_Trans_lemma: \"{ OrdP k, i IN j, j IN k } \\<turnstile> i IN k\"", "lemma OrdP_Trans: \"H \\<turnstile>  OrdP k \\<Longrightarrow> H \\<turnstile> i IN j \\<Longrightarrow> H \\<turnstile> j IN k \\<Longrightarrow> H  \\<turnstile> i IN k\"", "lemma Ord_IN_Ord0:\n  assumes l: \"H \\<turnstile> l IN k\"\n  shows \"insert (OrdP k) H \\<turnstile> OrdP l\"", "lemma Ord_IN_Ord: \"H \\<turnstile> l IN k \\<Longrightarrow> H \\<turnstile> OrdP k \\<Longrightarrow> H \\<turnstile> OrdP l\"", "lemma OrdP_I:\n  assumes \"insert (Var y IN x) H \\<turnstile> (Var y) SUBS x\"\n      and \"insert (Var z IN Var y) (insert (Var y IN x) H) \\<turnstile> (Var z) SUBS (Var y)\"\n      and \"atom y \\<sharp> (x, z)\" \"\\<forall>B \\<in> H. atom y \\<sharp> B\"  \"atom z \\<sharp> x\" \"\\<forall>B \\<in> H. atom z \\<sharp> B\"\n    shows \"H \\<turnstile> OrdP x\"", "lemma OrdP_Zero [simp]: \"H \\<turnstile> OrdP Zero\"", "lemma OrdP_SUCC_I0: \"{ OrdP k } \\<turnstile> OrdP (SUCC k)\"", "lemma OrdP_SUCC_I: \"H \\<turnstile> OrdP k \\<Longrightarrow> H \\<turnstile> OrdP (SUCC k)\"", "lemma Zero_In_OrdP: \"{ OrdP x } \\<turnstile> x EQ Zero OR Zero IN x\"", "lemma OrdP_HPairE: \"insert (OrdP (HPair x y)) H \\<turnstile> A\"", "lemmas OrdP_HPairEH = OrdP_HPairE OrdP_HPairE [THEN rotate2] OrdP_HPairE [THEN rotate3] OrdP_HPairE [THEN rotate4] OrdP_HPairE [THEN rotate5] \n                 OrdP_HPairE [THEN rotate6] OrdP_HPairE [THEN rotate7] OrdP_HPairE [THEN rotate8] OrdP_HPairE [THEN rotate9] OrdP_HPairE [THEN rotate10]", "lemma Zero_Eq_HPairE: \"insert (Zero EQ HPair x y) H \\<turnstile> A\"", "lemmas Zero_Eq_HPairEH = Zero_Eq_HPairE Zero_Eq_HPairE [THEN rotate2] Zero_Eq_HPairE [THEN rotate3] Zero_Eq_HPairE [THEN rotate4] Zero_Eq_HPairE [THEN rotate5] \n                 Zero_Eq_HPairE [THEN rotate6] Zero_Eq_HPairE [THEN rotate7] Zero_Eq_HPairE [THEN rotate8] Zero_Eq_HPairE [THEN rotate9] Zero_Eq_HPairE [THEN rotate10]", "lemma HPair_Eq_ZeroE: \"insert (HPair x y EQ Zero) H \\<turnstile> A\"", "lemmas HPair_Eq_ZeroEH = HPair_Eq_ZeroE HPair_Eq_ZeroE [THEN rotate2] HPair_Eq_ZeroE [THEN rotate3] HPair_Eq_ZeroE [THEN rotate4] HPair_Eq_ZeroE [THEN rotate5] \n                 HPair_Eq_ZeroE [THEN rotate6] HPair_Eq_ZeroE [THEN rotate7] HPair_Eq_ZeroE [THEN rotate8] HPair_Eq_ZeroE [THEN rotate9] HPair_Eq_ZeroE [THEN rotate10]", "lemma OrdInd_lemma:\n  assumes j: \"atom (j::name) \\<sharp> (i,A)\"\n  shows \"{ OrdP (Var i) } \\<turnstile> (All i (OrdP (Var i) IMP ((All2 j (Var i) (A(i::= Var j))) IMP A))) IMP A\"", "lemma OrdInd:\n  assumes j: \"atom (j::name) \\<sharp> (i,A)\"\n  and x: \"H \\<turnstile> OrdP (Var i)\" and step: \"H \\<turnstile> All i (OrdP (Var i) IMP (All2 j (Var i) (A(i::= Var j)) IMP A))\"\n  shows \"H \\<turnstile> A\"", "lemma OrdIndH:\n  assumes \"atom (j::name) \\<sharp> (i,A)\"\n      and \"H \\<turnstile> All i (OrdP (Var i) IMP (All2 j (Var i) (A(i::= Var j)) IMP A))\"\n    shows \"insert (OrdP (Var i)) H \\<turnstile> A\"", "lemma OrdP_linear_lemma:\n  assumes j: \"atom j \\<sharp> i\"\n  shows \"{ OrdP (Var i) } \\<turnstile> All j (OrdP (Var j) IMP (Var i IN Var j OR Var i EQ Var j OR Var j IN Var i))\"\n         (is \"_ \\<turnstile> ?scheme\")", "lemma OrdP_linear_imp: \"{} \\<turnstile> OrdP x IMP OrdP y IMP x IN y OR x EQ y OR y IN x\"", "lemma OrdP_linear:\n  assumes \"H \\<turnstile> OrdP x\" \"H \\<turnstile> OrdP y\" \n          \"insert (x IN y) H \\<turnstile> A\" \"insert (x EQ y) H \\<turnstile> A\" \"insert (y IN x) H \\<turnstile> A\" \n    shows \"H \\<turnstile> A\"", "lemma Zero_In_SUCC: \"{OrdP k} \\<turnstile> Zero IN SUCC k\"", "lemma OrdNotEqP_fresh_iff [simp]: \"a \\<sharp> OrdNotEqP x y \\<longleftrightarrow> a \\<sharp> x \\<and> a \\<sharp> y\"", "lemma eval_fm_OrdNotEqP [simp]: \"eval_fm e (OrdNotEqP x y) \\<longleftrightarrow> Ord \\<lbrakk>x\\<rbrakk>e \\<and> Ord \\<lbrakk>y\\<rbrakk>e \\<and> \\<lbrakk>x\\<rbrakk>e \\<noteq> \\<lbrakk>y\\<rbrakk>e\"", "lemma OrdNotEqP_subst [simp]: \"(OrdNotEqP x y)(i::=t) = OrdNotEqP (subst i t x) (subst i t y)\"", "lemma OrdNotEqP_cong: \"H \\<turnstile> x EQ x' \\<Longrightarrow> H \\<turnstile> y EQ y' \\<Longrightarrow> H \\<turnstile> OrdNotEqP x y IFF OrdNotEqP x' y'\"", "lemma OrdNotEqP_self_contra: \"{x NEQ x} \\<turnstile> Fls\"", "lemma OrdNotEqP_OrdP_E: \"insert (OrdP x) (insert (OrdP y) H) \\<turnstile> A \\<Longrightarrow> insert (x NEQ y) H \\<turnstile> A\"", "lemma OrdNotEqP_I: \"insert (x EQ y) H \\<turnstile> Fls \\<Longrightarrow> H \\<turnstile> OrdP x \\<Longrightarrow> H \\<turnstile> OrdP y \\<Longrightarrow> H \\<turnstile> x NEQ y\"", "lemma OrdNotEqP_imp_Neg_Eq: \"{x NEQ y} \\<turnstile> Neg (x EQ y)\"", "lemma OrdNotEqP_E: \"H \\<turnstile> x EQ y \\<Longrightarrow> insert (x NEQ y) H \\<turnstile> A\"", "lemma OrdP_set_max_lemma:\n  assumes j: \"atom (j::name) \\<sharp> i\" and k: \"atom (k::name) \\<sharp> (i,j)\"\n  shows \"{} \\<turnstile> (Neg (Var i EQ Zero) AND (All2 j (Var i) (OrdP (Var j)))) IMP \n              (Ex j (Var j IN Var i AND (All2 k (Var i) (Var k SUBS Var j))))\"", "lemma OrdP_max_imp:\n  assumes j: \"atom j \\<sharp> (x)\" and k: \"atom k \\<sharp> (x,j)\"\n  shows  \"{ OrdP x, Neg (x EQ Zero) } \\<turnstile> Ex j (Var j IN x AND (All2 k x (Var k SUBS Var j)))\"", "lemma OrdP_cases_lemma:\n  assumes p: \"atom p \\<sharp> x\" \n  shows  \"{ OrdP x, Neg (x EQ Zero) } \\<turnstile> Ex p (OrdP (Var p) AND x EQ SUCC (Var p))\"", "lemma OrdP_cases_disj:\n  assumes p: \"atom p \\<sharp> x\" \n  shows  \"insert (OrdP x) H \\<turnstile> x EQ Zero OR Ex p (OrdP (Var p) AND x EQ SUCC (Var p))\"", "lemma OrdP_cases_E:\n  \"\\<lbrakk>insert (x EQ Zero) H \\<turnstile> A;\n    insert (x EQ SUCC (Var k)) (insert (OrdP (Var k)) H) \\<turnstile> A; \n    atom k \\<sharp> (x,A);   \\<forall>C \\<in> H. atom k \\<sharp> C\\<rbrakk>\n   \\<Longrightarrow> insert (OrdP x) H \\<turnstile> A\"", "lemma OrdInd2_lemma:\n  \"{ OrdP (Var i), A(i::= Zero), (All i (OrdP (Var i) IMP A IMP (A(i::= SUCC (Var i))))) } \\<turnstile> A\"", "lemma OrdInd2:\n  assumes \"H \\<turnstile> OrdP (Var i)\"\n      and \"H \\<turnstile> A(i::= Zero)\"\n      and \"H \\<turnstile> All i (OrdP (Var i) IMP A IMP (A(i::= SUCC (Var i))))\"\n    shows \"H \\<turnstile> A\"", "lemma OrdInd2H:\n  assumes \"H \\<turnstile> A(i::= Zero)\"\n      and \"H \\<turnstile> All i (OrdP (Var i) IMP A IMP (A(i::= SUCC (Var i))))\"\n    shows \"insert (OrdP (Var i)) H \\<turnstile> A\"", "lemma\n  shows HFun_Sigma_fresh_iff [simp]: \"a \\<sharp> HFun_Sigma r \\<longleftrightarrow> a \\<sharp> r\" (is ?thesis1)\n    and eval_fm_HFun_Sigma [simp]:\n         \"eval_fm e (HFun_Sigma r) \\<longleftrightarrow> hfun_sigma_ord \\<lbrakk>r\\<rbrakk>e\" (is ?thesis2)", "lemma HFun_Sigma_subst [simp]: \"(HFun_Sigma r)(i::=t) = HFun_Sigma (subst i t r)\"", "lemma HFun_Sigma_Zero: \"H \\<turnstile> HFun_Sigma Zero\"", "lemma Subset_HFun_Sigma: \"{HFun_Sigma s, s' SUBS s} \\<turnstile> HFun_Sigma s'\"", "lemma HFun_Sigma_Mem_imp_HPair:\n  assumes \"H \\<turnstile> HFun_Sigma r\" \"H \\<turnstile> a IN r\"\n      and xy: \"atom x \\<sharp> (y,a,r)\" \"atom y \\<sharp> (a,r)\"\n    shows \"H \\<turnstile> (Ex x (Ex y (a EQ HPair (Var x) (Var y))))\"  (is \"_ \\<turnstile> ?concl\")", "lemma\n  shows HDomain_Incl_fresh_iff [simp]:\n      \"a \\<sharp> HDomain_Incl r d \\<longleftrightarrow> a \\<sharp> r \\<and> a \\<sharp> d\" (is ?thesis1)\n  and   eval_fm_HDomain_Incl [simp]:\n      \"eval_fm e (HDomain_Incl r d) \\<longleftrightarrow> \\<lbrakk>d\\<rbrakk>e \\<le> hdomain \\<lbrakk>r\\<rbrakk>e\" (is ?thesis2)", "lemma HDomain_Incl_subst [simp]:\n      \"(HDomain_Incl r d)(i::=t) = HDomain_Incl (subst i t r) (subst i t d)\"", "lemma HDomain_Incl_Subset_lemma: \"{ HDomain_Incl r k, k' SUBS k } \\<turnstile> HDomain_Incl r k'\"", "lemma HDomain_Incl_Subset: \"H \\<turnstile> HDomain_Incl r k \\<Longrightarrow> H \\<turnstile> k' SUBS k \\<Longrightarrow> H \\<turnstile> HDomain_Incl r k'\"", "lemma HDomain_Incl_Mem_Ord: \"H \\<turnstile> HDomain_Incl r k \\<Longrightarrow> H \\<turnstile> k' IN k \\<Longrightarrow> H \\<turnstile> OrdP k \\<Longrightarrow> H \\<turnstile> HDomain_Incl r k'\"", "lemma HDomain_Incl_Zero [simp]: \"H \\<turnstile> HDomain_Incl r Zero\"", "lemma HDomain_Incl_Eats: \"{ HDomain_Incl r d } \\<turnstile> HDomain_Incl (Eats r (HPair d d')) (SUCC d)\"", "lemma HDomain_Incl_Eats_I: \"H \\<turnstile> HDomain_Incl r d \\<Longrightarrow> H \\<turnstile> HDomain_Incl (Eats r (HPair d d')) (SUCC d)\"", "lemma Doubleton_E:\n  assumes \"insert (a EQ c) (insert (b EQ d) H) \\<turnstile> A\"\n          \"insert (a EQ d) (insert (b EQ c) H) \\<turnstile> A\"\n    shows    \"insert ((Eats (Eats Zero b) a) EQ (Eats (Eats Zero d) c)) H \\<turnstile> A\"", "lemma HFST: \"{HPair a b EQ HPair c d} \\<turnstile> a EQ c\"", "lemma b_EQ_d_1: \"{a EQ c, a EQ d, b EQ c} \\<turnstile> b EQ d\"", "lemma HSND: \"{HPair a b EQ HPair c d} \\<turnstile> b EQ d\"", "lemma HPair_E [intro!]:\n  assumes \"insert (a EQ c) (insert (b EQ d) H) \\<turnstile> A\"\n    shows \"insert (HPair a b EQ HPair c d) H \\<turnstile> A\"", "lemma HFun_Sigma_E:\n  assumes r: \"H \\<turnstile> HFun_Sigma r\"\n      and b: \"H \\<turnstile> HPair a b IN r\"\n      and b': \"H \\<turnstile> HPair a b' IN r\"\n    shows \"H \\<turnstile> b EQ b'\"", "lemma SUCC_SUBS_lemma: \"{SUCC x SUBS SUCC y} \\<turnstile> x SUBS y\"", "lemma SUCC_SUBS: \"insert (SUCC x SUBS SUCC y) H \\<turnstile> x SUBS y\"", "lemma SUCC_inject: \"insert (SUCC x EQ SUCC y) H \\<turnstile> x EQ y\"", "lemma SUCC_inject_E [intro!]: \"insert (x EQ y) H \\<turnstile> A \\<Longrightarrow> insert (SUCC x EQ SUCC y) H \\<turnstile> A\"", "lemma OrdP_IN_SUCC_lemma: \"{OrdP x, y IN x} \\<turnstile> SUCC y IN SUCC x\"", "lemma OrdP_IN_SUCC: \"H \\<turnstile> OrdP x \\<Longrightarrow> H \\<turnstile> y IN x \\<Longrightarrow> H \\<turnstile> SUCC y IN SUCC x\"", "lemma OrdP_IN_SUCC_D_lemma: \"{OrdP x, SUCC y IN SUCC x} \\<turnstile> y IN x\"", "lemma OrdP_IN_SUCC_D: \"H \\<turnstile> OrdP x \\<Longrightarrow> H \\<turnstile> SUCC y IN SUCC x \\<Longrightarrow> H \\<turnstile> y IN x\"", "lemma OrdP_IN_SUCC_Iff: \"H \\<turnstile> OrdP y \\<Longrightarrow> H \\<turnstile> SUCC x IN SUCC y IFF x IN y\"", "lemma hfun_sigma_ord_iff: \"hfun_sigma_ord s \\<longleftrightarrow> OrdDom s \\<and> hfun_sigma s\"", "lemma hfun_sigma_iff: \"hfun_sigma r \\<longleftrightarrow> hfunction r \\<and> hrelation r\"", "lemma Seq_iff: \"Seq r d \\<longleftrightarrow> d \\<le> hdomain r \\<and> hfun_sigma r\"", "lemma LstSeq_iff: \"LstSeq s k y \\<longleftrightarrow> succ k \\<le> hdomain s \\<and> \\<langle>k,y\\<rangle> \\<^bold>\\<in> s \\<and> hfun_sigma_ord s\"", "lemma\n shows LstSeqP_fresh_iff [simp]:\n      \"a \\<sharp> LstSeqP s k y \\<longleftrightarrow> a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> y\"         (is ?thesis1)\n   and eval_fm_LstSeqP [simp]: \n      \"eval_fm e (LstSeqP s k y) \\<longleftrightarrow> LstSeq \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>y\\<rbrakk>e\"  (is ?thesis2)", "lemma LstSeqP_subst [simp]:\n  \"(LstSeqP s k y)(i::=t) = LstSeqP (subst i t s) (subst i t k) (subst i t y)\"", "lemma LstSeqP_E: \n  assumes \"insert (HDomain_Incl s (SUCC k)) \n            (insert (OrdP k) (insert (HFun_Sigma s)\n              (insert (HPair k y IN s) H))) \\<turnstile> B\" \n    shows \"insert (LstSeqP s k y) H \\<turnstile> B\"", "lemma LstSeqP_cong:\n  assumes \"H \\<turnstile> s EQ s'\" \"H \\<turnstile> k EQ k'\" \"H \\<turnstile> y EQ y'\" \n  shows \"H \\<turnstile> LstSeqP s k y IFF LstSeqP s' k' y'\"", "lemma LstSeqP_OrdP: \"H \\<turnstile> LstSeqP r k y \\<Longrightarrow> H \\<turnstile> OrdP k\"", "lemma LstSeqP_Mem_lemma: \"{ LstSeqP r k y, HPair k' z IN r, k' IN k } \\<turnstile> LstSeqP r k' z\"", "lemma LstSeqP_Mem: \"H \\<turnstile> LstSeqP r k y \\<Longrightarrow> H \\<turnstile> HPair k' z IN r \\<Longrightarrow> H \\<turnstile> k' IN k \\<Longrightarrow> H \\<turnstile> LstSeqP r k' z\"", "lemma LstSeqP_imp_Mem: \"H \\<turnstile> LstSeqP s k y \\<Longrightarrow> H \\<turnstile> HPair k y IN s\"", "lemma LstSeqP_SUCC: \"H \\<turnstile> LstSeqP r (SUCC d) y \\<Longrightarrow> H \\<turnstile> HPair d z IN r \\<Longrightarrow> H \\<turnstile> LstSeqP r d z\"", "lemma LstSeqP_EQ: \"\\<lbrakk>H \\<turnstile> LstSeqP s k y; H \\<turnstile> HPair k y' IN s\\<rbrakk> \\<Longrightarrow> H \\<turnstile> y EQ y'\""], "translations": [["", "lemma Subset_fresh_iff [simp]: \"a \\<sharp> t SUBS u \\<longleftrightarrow> a \\<sharp> t \\<and> a \\<sharp> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> t SUBS u = (a \\<sharp> t \\<and> a \\<sharp> u)", "apply (rule obtain_fresh [where x=\"(t, u)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       atom aa \\<sharp> (t, u) \\<Longrightarrow>\n       a \\<sharp> t SUBS u = (a \\<sharp> t \\<and> a \\<sharp> u)", "apply (subst Subset.simps, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma eval_fm_Subset [simp]: \"eval_fm e (Subset t u) \\<longleftrightarrow> (\\<lbrakk>t\\<rbrakk>e \\<le> \\<lbrakk>u\\<rbrakk>e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_fm e (t SUBS u) = (\\<lbrakk>t\\<rbrakk>e \\<le> \\<lbrakk>u\\<rbrakk>e)", "apply (rule obtain_fresh [where x=\"(t, u)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       atom a \\<sharp> (t, u) \\<Longrightarrow>\n       eval_fm e (t SUBS u) =\n       (\\<lbrakk>t\\<rbrakk>e \\<le> \\<lbrakk>u\\<rbrakk>e)", "apply (subst Subset.simps, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma subst_fm_Subset [simp]: \"(t SUBS u)(i::=x) = (subst i x t) SUBS (subst i x u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t SUBS u)(i::=x) = subst i x t SUBS subst i x u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (t SUBS u)(i::=x) = subst i x t SUBS subst i x u", "obtain j::name where \"atom j \\<sharp> (i,x,t,u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        atom j \\<sharp> (i, x, t, u) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_fresh)"], ["proof (state)\nthis:\n  atom j \\<sharp> (i, x, t, u)\n\ngoal (1 subgoal):\n 1. (t SUBS u)(i::=x) = subst i x t SUBS subst i x u", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom j \\<sharp> (i, x, t, u)\n\ngoal (1 subgoal):\n 1. (t SUBS u)(i::=x) = subst i x t SUBS subst i x u", "by (auto simp: Subset.simps [of j])"], ["proof (state)\nthis:\n  (t SUBS u)(i::=x) = subst i x t SUBS subst i x u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Subset_I:\n  assumes \"insert ((Var i) IN t) H \\<turnstile> (Var i) IN u\" \"atom i \\<sharp> (t,u)\" \"\\<forall>B \\<in> H. atom i \\<sharp> B\"\n  shows \"H \\<turnstile> t SUBS u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> t SUBS u", "by (subst Subset.simps [of i]) (auto simp: assms)"], ["", "lemma Subset_D:\n  assumes major: \"H \\<turnstile> t SUBS u\" and minor: \"H \\<turnstile> a IN t\" shows \"H \\<turnstile> a IN u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> a IN u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H \\<turnstile> a IN u", "obtain i::name where i: \"atom i \\<sharp> (t, u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        atom i \\<sharp> (t, u) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_fresh)"], ["proof (state)\nthis:\n  atom i \\<sharp> (t, u)\n\ngoal (1 subgoal):\n 1. H \\<turnstile> a IN u", "hence \"H \\<turnstile> (Var i IN t IMP Var i IN u) (i::=a)\""], ["proof (prove)\nusing this:\n  atom i \\<sharp> (t, u)\n\ngoal (1 subgoal):\n 1. H \\<turnstile> (Var i IN t IMP Var i IN u)(i::=a)", "by (metis Subset.simps major All_D)"], ["proof (state)\nthis:\n  H \\<turnstile> (Var i IN t IMP Var i IN u)(i::=a)\n\ngoal (1 subgoal):\n 1. H \\<turnstile> a IN u", "thus ?thesis"], ["proof (prove)\nusing this:\n  H \\<turnstile> (Var i IN t IMP Var i IN u)(i::=a)\n\ngoal (1 subgoal):\n 1. H \\<turnstile> a IN u", "using i"], ["proof (prove)\nusing this:\n  H \\<turnstile> (Var i IN t IMP Var i IN u)(i::=a)\n  atom i \\<sharp> (t, u)\n\ngoal (1 subgoal):\n 1. H \\<turnstile> a IN u", "by simp (metis MP_same minor)"], ["proof (state)\nthis:\n  H \\<turnstile> a IN u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Subset_E: \"H \\<turnstile> t SUBS u \\<Longrightarrow> H \\<turnstile> a IN t \\<Longrightarrow> insert (a IN u) H \\<turnstile> A \\<Longrightarrow> H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> t SUBS u; H \\<turnstile> a IN t;\n     insert (a IN u) H \\<turnstile> A\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile> A", "by (metis Subset_D cut_same)"], ["", "lemma Subset_cong: \"H \\<turnstile> t EQ t' \\<Longrightarrow> H \\<turnstile> u EQ u' \\<Longrightarrow> H \\<turnstile> t SUBS u IFF t' SUBS u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> t EQ t'; H \\<turnstile> u EQ u'\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile> t SUBS u IFF t' SUBS u'", "by (rule P2_cong) auto"], ["", "lemma Set_MP: \"x SUBS y \\<in> H \\<Longrightarrow> z IN x \\<in> H \\<Longrightarrow> insert (z IN y) H \\<turnstile> A \\<Longrightarrow> H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x SUBS y \\<in> H; z IN x \\<in> H;\n     insert (z IN y) H \\<turnstile> A\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile> A", "by (metis Assume Subset_D cut_same insert_absorb)"], ["", "lemma Zero_Subset_I [intro!]: \"H \\<turnstile> Zero SUBS t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> Zero SUBS t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H \\<turnstile> Zero SUBS t", "have \"{} \\<turnstile> Zero SUBS t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<turnstile> Zero SUBS t", "by (rule obtain_fresh [where x=\"(Zero,t)\"]) (auto intro: Subset_I)"], ["proof (state)\nthis:\n  {} \\<turnstile> Zero SUBS t\n\ngoal (1 subgoal):\n 1. H \\<turnstile> Zero SUBS t", "thus ?thesis"], ["proof (prove)\nusing this:\n  {} \\<turnstile> Zero SUBS t\n\ngoal (1 subgoal):\n 1. H \\<turnstile> Zero SUBS t", "by (auto intro: thin)"], ["proof (state)\nthis:\n  H \\<turnstile> Zero SUBS t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Zero_SubsetE: \"H \\<turnstile> A \\<Longrightarrow> insert (Zero SUBS X) H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> A \\<Longrightarrow> insert (Zero SUBS X) H \\<turnstile> A", "by (rule thin1)"], ["", "lemma Subset_Zero_D:\n   assumes \"H \\<turnstile> t SUBS Zero\" shows \"H \\<turnstile> t EQ Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> t EQ Zero", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H \\<turnstile> t EQ Zero", "obtain i::name where i [iff]: \"atom i \\<sharp> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. atom i \\<sharp> t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_fresh)"], ["proof (state)\nthis:\n  atom i \\<sharp> t\n\ngoal (1 subgoal):\n 1. H \\<turnstile> t EQ Zero", "have \"{t SUBS Zero} \\<turnstile> t EQ Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t SUBS Zero} \\<turnstile> t EQ Zero", "proof (rule Eq_Zero_I)"], ["proof (state)\ngoal (3 subgoals):\n 1. {Var ?i IN t, t SUBS Zero} \\<turnstile> Fls\n 2. atom ?i \\<sharp> t\n 3. \\<forall>B\\<in>{t SUBS Zero}. atom ?i \\<sharp> B", "fix A"], ["proof (state)\ngoal (3 subgoals):\n 1. {Var ?i IN t, t SUBS Zero} \\<turnstile> Fls\n 2. atom ?i \\<sharp> t\n 3. \\<forall>B\\<in>{t SUBS Zero}. atom ?i \\<sharp> B", "show \"{Var i IN t, t SUBS Zero} \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Var i IN t, t SUBS Zero} \\<turnstile> A", "by (metis Hyp Subset_D insertI1 thin1 Mem_Zero_E cut1)"], ["proof (state)\nthis:\n  {Var i IN t, t SUBS Zero} \\<turnstile> A\n\ngoal (2 subgoals):\n 1. atom i \\<sharp> t\n 2. \\<forall>B\\<in>{t SUBS Zero}. atom i \\<sharp> B", "qed auto"], ["proof (state)\nthis:\n  {t SUBS Zero} \\<turnstile> t EQ Zero\n\ngoal (1 subgoal):\n 1. H \\<turnstile> t EQ Zero", "thus ?thesis"], ["proof (prove)\nusing this:\n  {t SUBS Zero} \\<turnstile> t EQ Zero\n\ngoal (1 subgoal):\n 1. H \\<turnstile> t EQ Zero", "by (metis assms cut1)"], ["proof (state)\nthis:\n  H \\<turnstile> t EQ Zero\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Subset_refl: \"H \\<turnstile> t SUBS t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> t SUBS t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H \\<turnstile> t SUBS t", "obtain i::name where \"atom i \\<sharp> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. atom i \\<sharp> t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_fresh)"], ["proof (state)\nthis:\n  atom i \\<sharp> t\n\ngoal (1 subgoal):\n 1. H \\<turnstile> t SUBS t", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom i \\<sharp> t\n\ngoal (1 subgoal):\n 1. H \\<turnstile> t SUBS t", "by (metis Assume Subset_I empty_iff fresh_Pair thin0)"], ["proof (state)\nthis:\n  H \\<turnstile> t SUBS t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Eats_Subset_Iff: \"H \\<turnstile> Eats x y SUBS z IFF (x SUBS z) AND (y IN z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> Eats x y SUBS z IFF x SUBS z AND y IN z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H \\<turnstile> Eats x y SUBS z IFF x SUBS z AND y IN z", "obtain i::name where i: \"atom i \\<sharp> (x,y,z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        atom i \\<sharp> (x, y, z) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_fresh)"], ["proof (state)\nthis:\n  atom i \\<sharp> (x, y, z)\n\ngoal (1 subgoal):\n 1. H \\<turnstile> Eats x y SUBS z IFF x SUBS z AND y IN z", "have \"{} \\<turnstile> (Eats x y SUBS z) IFF (x SUBS z AND y IN z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<turnstile> Eats x y SUBS z IFF x SUBS z AND y IN z", "proof (rule Iff_I)"], ["proof (state)\ngoal (2 subgoals):\n 1. {Eats x y SUBS z} \\<turnstile> x SUBS z AND y IN z\n 2. {x SUBS z AND y IN z} \\<turnstile> Eats x y SUBS z", "show \"{Eats x y SUBS z} \\<turnstile> x SUBS z AND y IN z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Eats x y SUBS z} \\<turnstile> x SUBS z AND y IN z", "proof (rule Conj_I)"], ["proof (state)\ngoal (2 subgoals):\n 1. {Eats x y SUBS z} \\<turnstile> x SUBS z\n 2. {Eats x y SUBS z} \\<turnstile> y IN z", "show \"{Eats x y SUBS z} \\<turnstile> x SUBS z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Eats x y SUBS z} \\<turnstile> x SUBS z", "apply (rule Subset_I [where i=i])"], ["proof (prove)\ngoal (3 subgoals):\n 1. {Var i IN x, Eats x y SUBS z} \\<turnstile> Var i IN z\n 2. atom i \\<sharp> (x, z)\n 3. \\<forall>B\\<in>{Eats x y SUBS z}. atom i \\<sharp> B", "using i"], ["proof (prove)\nusing this:\n  atom i \\<sharp> (x, y, z)\n\ngoal (3 subgoals):\n 1. {Var i IN x, Eats x y SUBS z} \\<turnstile> Var i IN z\n 2. atom i \\<sharp> (x, z)\n 3. \\<forall>B\\<in>{Eats x y SUBS z}. atom i \\<sharp> B", "apply (auto intro: Subset_D Mem_Eats_I1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {Eats x y SUBS z} \\<turnstile> x SUBS z\n\ngoal (1 subgoal):\n 1. {Eats x y SUBS z} \\<turnstile> y IN z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {Eats x y SUBS z} \\<turnstile> y IN z", "show \"{Eats x y SUBS z} \\<turnstile> y IN z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Eats x y SUBS z} \\<turnstile> y IN z", "by (metis Subset_D Assume Mem_Eats_I2 Refl)"], ["proof (state)\nthis:\n  {Eats x y SUBS z} \\<turnstile> y IN z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {Eats x y SUBS z} \\<turnstile> x SUBS z AND y IN z\n\ngoal (1 subgoal):\n 1. {x SUBS z AND y IN z} \\<turnstile> Eats x y SUBS z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {x SUBS z AND y IN z} \\<turnstile> Eats x y SUBS z", "show \"{x SUBS z AND y IN z} \\<turnstile> Eats x y SUBS z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x SUBS z AND y IN z} \\<turnstile> Eats x y SUBS z", "using i"], ["proof (prove)\nusing this:\n  atom i \\<sharp> (x, y, z)\n\ngoal (1 subgoal):\n 1. {x SUBS z AND y IN z} \\<turnstile> Eats x y SUBS z", "by (auto intro!: Subset_I [where i=i] intro: Subset_D Mem_cong [THEN Iff_MP2_same])"], ["proof (state)\nthis:\n  {x SUBS z AND y IN z} \\<turnstile> Eats x y SUBS z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {} \\<turnstile> Eats x y SUBS z IFF x SUBS z AND y IN z\n\ngoal (1 subgoal):\n 1. H \\<turnstile> Eats x y SUBS z IFF x SUBS z AND y IN z", "thus ?thesis"], ["proof (prove)\nusing this:\n  {} \\<turnstile> Eats x y SUBS z IFF x SUBS z AND y IN z\n\ngoal (1 subgoal):\n 1. H \\<turnstile> Eats x y SUBS z IFF x SUBS z AND y IN z", "by (rule thin0)"], ["proof (state)\nthis:\n  H \\<turnstile> Eats x y SUBS z IFF x SUBS z AND y IN z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Eats_Subset_I [intro!]: \"H \\<turnstile> x SUBS z \\<Longrightarrow> H \\<turnstile> y IN z \\<Longrightarrow> H \\<turnstile> Eats x y SUBS z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> x SUBS z; H \\<turnstile> y IN z\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile> Eats x y SUBS z", "by (metis Conj_I Eats_Subset_Iff Iff_MP2_same)"], ["", "lemma Eats_Subset_E [intro!]:\n  \"insert (x SUBS z) (insert (y IN z) H) \\<turnstile> C \\<Longrightarrow> insert (Eats x y SUBS z) H \\<turnstile> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (x SUBS z) (insert (y IN z) H) \\<turnstile> C \\<Longrightarrow>\n    insert (Eats x y SUBS z) H \\<turnstile> C", "by (metis Conj_E Eats_Subset_Iff Iff_MP_left')"], ["", "text\\<open>A surprising proof: a consequence of @{thm Eats_Subset_Iff} and reflexivity!\\<close>"], ["", "lemma Subset_Eats_I [intro!]: \"H \\<turnstile> x SUBS Eats x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> x SUBS Eats x y", "by (metis Conj_E1 Eats_Subset_Iff Iff_MP_same Subset_refl)"], ["", "lemma SUCC_Subset_I [intro!]: \"H \\<turnstile> x SUBS z \\<Longrightarrow> H \\<turnstile> x IN z \\<Longrightarrow> H \\<turnstile> SUCC x SUBS z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> x SUBS z; H \\<turnstile> x IN z\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile> SUCC x SUBS z", "by (metis Eats_Subset_I SUCC_def)"], ["", "lemma SUCC_Subset_E [intro!]:\n  \"insert (x SUBS z) (insert (x IN z) H) \\<turnstile> C \\<Longrightarrow> insert (SUCC x SUBS z) H \\<turnstile> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (x SUBS z) (insert (x IN z) H) \\<turnstile> C \\<Longrightarrow>\n    insert (SUCC x SUBS z) H \\<turnstile> C", "by (metis Eats_Subset_E SUCC_def)"], ["", "lemma Subset_trans0: \"{ a SUBS b, b SUBS c } \\<turnstile> a SUBS c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a SUBS b, b SUBS c} \\<turnstile> a SUBS c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {a SUBS b, b SUBS c} \\<turnstile> a SUBS c", "obtain i::name where [simp]: \"atom i \\<sharp> (a,b,c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        atom i \\<sharp> (a, b, c) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_fresh)"], ["proof (state)\nthis:\n  atom i \\<sharp> (a, b, c)\n\ngoal (1 subgoal):\n 1. {a SUBS b, b SUBS c} \\<turnstile> a SUBS c", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a SUBS b, b SUBS c} \\<turnstile> a SUBS c", "by (rule Subset_I [of i]) (auto intro: Subset_D)"], ["proof (state)\nthis:\n  {a SUBS b, b SUBS c} \\<turnstile> a SUBS c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Subset_trans: \"H \\<turnstile> a SUBS b \\<Longrightarrow> H \\<turnstile> b SUBS c \\<Longrightarrow> H \\<turnstile> a SUBS c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> a SUBS b; H \\<turnstile> b SUBS c\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile> a SUBS c", "by (metis Subset_trans0 cut2)"], ["", "lemma Subset_SUCC: \"H \\<turnstile> a SUBS (SUCC a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> a SUBS SUCC a", "by (metis SUCC_def Subset_Eats_I)"], ["", "lemma All2_Subset_lemma: \"atom l \\<sharp> (k',k) \\<Longrightarrow> {P} \\<turnstile> P' \\<Longrightarrow> {All2 l k P, k' SUBS k} \\<turnstile> All2 l k' P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom l \\<sharp> (k', k); {P} \\<turnstile> P'\\<rbrakk>\n    \\<Longrightarrow> {All2 l k P, k' SUBS k} \\<turnstile> All2 l k' P'", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom l \\<sharp> (k', k); {P} \\<turnstile> P'\\<rbrakk>\n    \\<Longrightarrow> {Neg P', Var l IN k', k' SUBS k} \\<turnstile>\n                      SyntaxN.Ex l (Neg (Var l IN k IMP P))", "apply (rule Ex_I [where x = \"Var l\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom l \\<sharp> (k', k); {P} \\<turnstile> P'\\<rbrakk>\n    \\<Longrightarrow> {Neg P', Var l IN k', k' SUBS k} \\<turnstile>\n                      (Neg (Var l IN k IMP P))(l::=Var l)", "apply (auto intro: ContraProve Set_MP cut1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma All2_Subset: \"\\<lbrakk>H \\<turnstile> All2 l k P; H \\<turnstile> k' SUBS k; {P} \\<turnstile> P'; atom l \\<sharp> (k', k)\\<rbrakk> \\<Longrightarrow> H \\<turnstile> All2 l k' P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> All2 l k P; H \\<turnstile> k' SUBS k;\n     {P} \\<turnstile> P'; atom l \\<sharp> (k', k)\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile> All2 l k' P'", "by (rule cut2 [OF All2_Subset_lemma]) auto"], ["", "section\\<open>Extensionality\\<close>"], ["", "lemma Extensionality: \"H \\<turnstile> x EQ y IFF x SUBS y AND y SUBS x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> x EQ y IFF x SUBS y AND y SUBS x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H \\<turnstile> x EQ y IFF x SUBS y AND y SUBS x", "obtain i::name and j::name and k::name\n    where atoms: \"atom i \\<sharp> (x,y)\"  \"atom j \\<sharp> (i,x,y)\"  \"atom k \\<sharp> (i,j,y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i j k.\n        \\<lbrakk>atom i \\<sharp> (x, y); atom j \\<sharp> (i, x, y);\n         atom k \\<sharp> (i, j, y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom i \\<sharp> (x, y)\n  atom j \\<sharp> (i, x, y)\n  atom k \\<sharp> (i, j, y)\n\ngoal (1 subgoal):\n 1. H \\<turnstile> x EQ y IFF x SUBS y AND y SUBS x", "have \"{} \\<turnstile> (Var i EQ y IFF Var i SUBS y AND y SUBS Var i)\" (is \"{} \\<turnstile> ?scheme\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<turnstile> Var i EQ y IFF Var i SUBS y AND y SUBS Var i", "proof (rule Ind [of j])"], ["proof (state)\ngoal (3 subgoals):\n 1. atom j \\<sharp> (?i, Var i EQ y IFF Var i SUBS y AND y SUBS Var i)\n 2. {} \\<turnstile>\n    (Var i EQ y IFF Var i SUBS y AND y SUBS Var i)(?i::=Zero)\n 3. {} \\<turnstile>\n    SyntaxN.All ?i\n     (SyntaxN.All j\n       ((Var i EQ y IFF Var i SUBS y AND y SUBS Var i) IMP\n        (Var i EQ y IFF Var i SUBS y AND y SUBS Var i)(?i::=Var j) IMP\n        (Var i EQ y IFF\n         Var i SUBS y AND y SUBS Var i)(?i::=Eats (Var ?i) (Var j))))", "show \"atom j \\<sharp> (i, ?scheme)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom j \\<sharp> (i, Var i EQ y IFF Var i SUBS y AND y SUBS Var i)", "using atoms"], ["proof (prove)\nusing this:\n  atom i \\<sharp> (x, y)\n  atom j \\<sharp> (i, x, y)\n  atom k \\<sharp> (i, j, y)\n\ngoal (1 subgoal):\n 1. atom j \\<sharp> (i, Var i EQ y IFF Var i SUBS y AND y SUBS Var i)", "by simp"], ["proof (state)\nthis:\n  atom j \\<sharp> (i, Var i EQ y IFF Var i SUBS y AND y SUBS Var i)\n\ngoal (2 subgoals):\n 1. {} \\<turnstile> (Var i EQ y IFF Var i SUBS y AND y SUBS Var i)(i::=Zero)\n 2. {} \\<turnstile>\n    SyntaxN.All i\n     (SyntaxN.All j\n       ((Var i EQ y IFF Var i SUBS y AND y SUBS Var i) IMP\n        (Var i EQ y IFF Var i SUBS y AND y SUBS Var i)(i::=Var j) IMP\n        (Var i EQ y IFF\n         Var i SUBS y AND y SUBS Var i)(i::=Eats (Var i) (Var j))))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. {} \\<turnstile> (Var i EQ y IFF Var i SUBS y AND y SUBS Var i)(i::=Zero)\n 2. {} \\<turnstile>\n    SyntaxN.All i\n     (SyntaxN.All j\n       ((Var i EQ y IFF Var i SUBS y AND y SUBS Var i) IMP\n        (Var i EQ y IFF Var i SUBS y AND y SUBS Var i)(i::=Var j) IMP\n        (Var i EQ y IFF\n         Var i SUBS y AND y SUBS Var i)(i::=Eats (Var i) (Var j))))", "show \"{} \\<turnstile> ?scheme(i::=Zero)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<turnstile> (Var i EQ y IFF Var i SUBS y AND y SUBS Var i)(i::=Zero)", "using atoms"], ["proof (prove)\nusing this:\n  atom i \\<sharp> (x, y)\n  atom j \\<sharp> (i, x, y)\n  atom k \\<sharp> (i, j, y)\n\ngoal (1 subgoal):\n 1. {} \\<turnstile> (Var i EQ y IFF Var i SUBS y AND y SUBS Var i)(i::=Zero)", "proof auto"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom i \\<sharp> (x, y); atom j \\<sharp> (i, x, y);\n     atom k \\<sharp> (i, j, y)\\<rbrakk>\n    \\<Longrightarrow> {Zero EQ y} \\<turnstile> y SUBS Zero\n 2. \\<lbrakk>atom i \\<sharp> (x, y); atom j \\<sharp> (i, x, y);\n     atom k \\<sharp> (i, j, y)\\<rbrakk>\n    \\<Longrightarrow> {Zero SUBS y, y SUBS Zero} \\<turnstile> Zero EQ y", "show \"{Zero EQ y} \\<turnstile> y SUBS Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Zero EQ y} \\<turnstile> y SUBS Zero", "by (rule Subset_cong [OF Assume Refl, THEN Iff_MP_same]) (rule Subset_refl)"], ["proof (state)\nthis:\n  {Zero EQ y} \\<turnstile> y SUBS Zero\n\ngoal (1 subgoal):\n 1. \\<lbrakk>atom i \\<sharp> (x, y); atom j \\<sharp> (i, x, y);\n     atom k \\<sharp> (i, j, y)\\<rbrakk>\n    \\<Longrightarrow> {Zero SUBS y, y SUBS Zero} \\<turnstile> Zero EQ y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom i \\<sharp> (x, y); atom j \\<sharp> (i, x, y);\n     atom k \\<sharp> (i, j, y)\\<rbrakk>\n    \\<Longrightarrow> {Zero SUBS y, y SUBS Zero} \\<turnstile> Zero EQ y", "show \"{Zero SUBS y, y SUBS Zero} \\<turnstile> Zero EQ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Zero SUBS y, y SUBS Zero} \\<turnstile> Zero EQ y", "by (metis AssumeH(2) Subset_Zero_D Sym)"], ["proof (state)\nthis:\n  {Zero SUBS y, y SUBS Zero} \\<turnstile> Zero EQ y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {} \\<turnstile> (Var i EQ y IFF Var i SUBS y AND y SUBS Var i)(i::=Zero)\n\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    SyntaxN.All i\n     (SyntaxN.All j\n       ((Var i EQ y IFF Var i SUBS y AND y SUBS Var i) IMP\n        (Var i EQ y IFF Var i SUBS y AND y SUBS Var i)(i::=Var j) IMP\n        (Var i EQ y IFF\n         Var i SUBS y AND y SUBS Var i)(i::=Eats (Var i) (Var j))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    SyntaxN.All i\n     (SyntaxN.All j\n       ((Var i EQ y IFF Var i SUBS y AND y SUBS Var i) IMP\n        (Var i EQ y IFF Var i SUBS y AND y SUBS Var i)(i::=Var j) IMP\n        (Var i EQ y IFF\n         Var i SUBS y AND y SUBS Var i)(i::=Eats (Var i) (Var j))))", "show \"{} \\<turnstile> All i (All j (?scheme IMP ?scheme(i::=Var j) IMP ?scheme(i::=Eats (Var i) (Var j))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    SyntaxN.All i\n     (SyntaxN.All j\n       ((Var i EQ y IFF Var i SUBS y AND y SUBS Var i) IMP\n        (Var i EQ y IFF Var i SUBS y AND y SUBS Var i)(i::=Var j) IMP\n        (Var i EQ y IFF\n         Var i SUBS y AND y SUBS Var i)(i::=Eats (Var i) (Var j))))", "using atoms"], ["proof (prove)\nusing this:\n  atom i \\<sharp> (x, y)\n  atom j \\<sharp> (i, x, y)\n  atom k \\<sharp> (i, j, y)\n\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    SyntaxN.All i\n     (SyntaxN.All j\n       ((Var i EQ y IFF Var i SUBS y AND y SUBS Var i) IMP\n        (Var i EQ y IFF Var i SUBS y AND y SUBS Var i)(i::=Var j) IMP\n        (Var i EQ y IFF\n         Var i SUBS y AND y SUBS Var i)(i::=Eats (Var i) (Var j))))", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>atom i \\<sharp> (x, y); atom j \\<sharp> (i, x, y);\n     atom k \\<sharp> (i, j, y)\\<rbrakk>\n    \\<Longrightarrow> {Eats (Var i) (Var j) EQ y,\n                       Var j EQ y IFF Var j SUBS y AND y SUBS Var j,\n                       Var i EQ y IFF\n                       Var i SUBS y AND y SUBS Var i} \\<turnstile>\n                      Var i SUBS y\n 2. \\<lbrakk>atom i \\<sharp> (x, y); atom j \\<sharp> (i, x, y);\n     atom k \\<sharp> (i, j, y)\\<rbrakk>\n    \\<Longrightarrow> {Eats (Var i) (Var j) EQ y,\n                       Var j EQ y IFF Var j SUBS y AND y SUBS Var j,\n                       Var i EQ y IFF\n                       Var i SUBS y AND y SUBS Var i} \\<turnstile>\n                      Var j IN y\n 3. \\<lbrakk>atom i \\<sharp> (x, y); atom j \\<sharp> (i, x, y);\n     atom k \\<sharp> (i, j, y)\\<rbrakk>\n    \\<Longrightarrow> {Eats (Var i) (Var j) EQ y,\n                       Var j EQ y IFF Var j SUBS y AND y SUBS Var j,\n                       Var i EQ y IFF\n                       Var i SUBS y AND y SUBS Var i} \\<turnstile>\n                      y SUBS Eats (Var i) (Var j)\n 4. \\<lbrakk>atom i \\<sharp> (x, y); atom j \\<sharp> (i, x, y);\n     atom k \\<sharp> (i, j, y)\\<rbrakk>\n    \\<Longrightarrow> {Var i SUBS y, Var j IN y,\n                       y SUBS Eats (Var i) (Var j),\n                       Var j EQ y IFF Var j SUBS y AND y SUBS Var j,\n                       Var i EQ y IFF\n                       Var i SUBS y AND y SUBS Var i} \\<turnstile>\n                      Eats (Var i) (Var j) EQ y", "apply (metis Subset_cong [OF Refl Assume, THEN Iff_MP_same] Subset_Eats_I)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>atom i \\<sharp> (x, y); atom j \\<sharp> (i, x, y);\n     atom k \\<sharp> (i, j, y)\\<rbrakk>\n    \\<Longrightarrow> {Eats (Var i) (Var j) EQ y,\n                       Var j EQ y IFF Var j SUBS y AND y SUBS Var j,\n                       Var i EQ y IFF\n                       Var i SUBS y AND y SUBS Var i} \\<turnstile>\n                      Var j IN y\n 2. \\<lbrakk>atom i \\<sharp> (x, y); atom j \\<sharp> (i, x, y);\n     atom k \\<sharp> (i, j, y)\\<rbrakk>\n    \\<Longrightarrow> {Eats (Var i) (Var j) EQ y,\n                       Var j EQ y IFF Var j SUBS y AND y SUBS Var j,\n                       Var i EQ y IFF\n                       Var i SUBS y AND y SUBS Var i} \\<turnstile>\n                      y SUBS Eats (Var i) (Var j)\n 3. \\<lbrakk>atom i \\<sharp> (x, y); atom j \\<sharp> (i, x, y);\n     atom k \\<sharp> (i, j, y)\\<rbrakk>\n    \\<Longrightarrow> {Var i SUBS y, Var j IN y,\n                       y SUBS Eats (Var i) (Var j),\n                       Var j EQ y IFF Var j SUBS y AND y SUBS Var j,\n                       Var i EQ y IFF\n                       Var i SUBS y AND y SUBS Var i} \\<turnstile>\n                      Eats (Var i) (Var j) EQ y", "apply (metis Mem_cong [OF Refl Assume, THEN Iff_MP_same] Mem_Eats_I2 Refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom i \\<sharp> (x, y); atom j \\<sharp> (i, x, y);\n     atom k \\<sharp> (i, j, y)\\<rbrakk>\n    \\<Longrightarrow> {Eats (Var i) (Var j) EQ y,\n                       Var j EQ y IFF Var j SUBS y AND y SUBS Var j,\n                       Var i EQ y IFF\n                       Var i SUBS y AND y SUBS Var i} \\<turnstile>\n                      y SUBS Eats (Var i) (Var j)\n 2. \\<lbrakk>atom i \\<sharp> (x, y); atom j \\<sharp> (i, x, y);\n     atom k \\<sharp> (i, j, y)\\<rbrakk>\n    \\<Longrightarrow> {Var i SUBS y, Var j IN y,\n                       y SUBS Eats (Var i) (Var j),\n                       Var j EQ y IFF Var j SUBS y AND y SUBS Var j,\n                       Var i EQ y IFF\n                       Var i SUBS y AND y SUBS Var i} \\<turnstile>\n                      Eats (Var i) (Var j) EQ y", "apply (metis Subset_cong [OF Assume Refl, THEN Iff_MP_same] Subset_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom i \\<sharp> (x, y); atom j \\<sharp> (i, x, y);\n     atom k \\<sharp> (i, j, y)\\<rbrakk>\n    \\<Longrightarrow> {Var i SUBS y, Var j IN y,\n                       y SUBS Eats (Var i) (Var j),\n                       Var j EQ y IFF Var j SUBS y AND y SUBS Var j,\n                       Var i EQ y IFF\n                       Var i SUBS y AND y SUBS Var i} \\<turnstile>\n                      Eats (Var i) (Var j) EQ y", "apply (rule Eq_Eats_I [of _ k, THEN Sym])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom i \\<sharp> (x, y); atom j \\<sharp> (i, x, y);\n     atom k \\<sharp> (i, j, y)\\<rbrakk>\n    \\<Longrightarrow> {Var i SUBS y, Var j IN y,\n                       y SUBS Eats (Var i) (Var j),\n                       Var j EQ y IFF Var j SUBS y AND y SUBS Var j,\n                       Var i EQ y IFF\n                       Var i SUBS y AND y SUBS Var i} \\<turnstile>\n                      SyntaxN.All k\n                       (Var k IN y IFF Var k IN Var i OR Var k EQ Var j)\n 2. \\<lbrakk>atom i \\<sharp> (x, y); atom j \\<sharp> (i, x, y);\n     atom k \\<sharp> (i, j, y)\\<rbrakk>\n    \\<Longrightarrow> atom k \\<sharp> (y, Var i, Var j)", "apply (auto intro: Set_MP [where x=y] Subset_D [where t = \"Var i\"] Disj_I1 Disj_I2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom i \\<sharp> (x, y); atom j \\<sharp> (i, x, y);\n     atom k \\<sharp> (i, j, y)\\<rbrakk>\n    \\<Longrightarrow> {Var k EQ Var j, Var i SUBS y, Var j IN y,\n                       y SUBS Eats (Var i) (Var j),\n                       Var j EQ y IFF Var j SUBS y AND y SUBS Var j,\n                       Var i EQ y IFF\n                       Var i SUBS y AND y SUBS Var i} \\<turnstile>\n                      Var k IN y", "apply (rule Var_Eq_subst_Iff [THEN Iff_MP_same], auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {} \\<turnstile>\n  SyntaxN.All i\n   (SyntaxN.All j\n     ((Var i EQ y IFF Var i SUBS y AND y SUBS Var i) IMP\n      (Var i EQ y IFF Var i SUBS y AND y SUBS Var i)(i::=Var j) IMP\n      (Var i EQ y IFF\n       Var i SUBS y AND y SUBS Var i)(i::=Eats (Var i) (Var j))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {} \\<turnstile> Var i EQ y IFF Var i SUBS y AND y SUBS Var i\n\ngoal (1 subgoal):\n 1. H \\<turnstile> x EQ y IFF x SUBS y AND y SUBS x", "hence \"{} \\<turnstile> (Var i EQ y IFF Var i SUBS y AND y SUBS Var i)(i::=x)\""], ["proof (prove)\nusing this:\n  {} \\<turnstile> Var i EQ y IFF Var i SUBS y AND y SUBS Var i\n\ngoal (1 subgoal):\n 1. {} \\<turnstile> (Var i EQ y IFF Var i SUBS y AND y SUBS Var i)(i::=x)", "by (metis Subst emptyE)"], ["proof (state)\nthis:\n  {} \\<turnstile> (Var i EQ y IFF Var i SUBS y AND y SUBS Var i)(i::=x)\n\ngoal (1 subgoal):\n 1. H \\<turnstile> x EQ y IFF x SUBS y AND y SUBS x", "thus ?thesis"], ["proof (prove)\nusing this:\n  {} \\<turnstile> (Var i EQ y IFF Var i SUBS y AND y SUBS Var i)(i::=x)\n\ngoal (1 subgoal):\n 1. H \\<turnstile> x EQ y IFF x SUBS y AND y SUBS x", "using atoms"], ["proof (prove)\nusing this:\n  {} \\<turnstile> (Var i EQ y IFF Var i SUBS y AND y SUBS Var i)(i::=x)\n  atom i \\<sharp> (x, y)\n  atom j \\<sharp> (i, x, y)\n  atom k \\<sharp> (i, j, y)\n\ngoal (1 subgoal):\n 1. H \\<turnstile> x EQ y IFF x SUBS y AND y SUBS x", "by (simp add: thin0)"], ["proof (state)\nthis:\n  H \\<turnstile> x EQ y IFF x SUBS y AND y SUBS x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Equality_I: \"H \\<turnstile> y SUBS x \\<Longrightarrow> H \\<turnstile> x SUBS y \\<Longrightarrow> H \\<turnstile> x EQ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> y SUBS x; H \\<turnstile> x SUBS y\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile> x EQ y", "by (metis Conj_I Extensionality Iff_MP2_same)"], ["", "lemma EQ_imp_SUBS: \"insert (t EQ u) H \\<turnstile> (t SUBS u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (t EQ u) H \\<turnstile> t SUBS u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. insert (t EQ u) H \\<turnstile> t SUBS u", "have \"{t EQ u} \\<turnstile> (t SUBS u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t EQ u} \\<turnstile> t SUBS u", "by (metis Assume Conj_E Extensionality Iff_MP_left')"], ["proof (state)\nthis:\n  {t EQ u} \\<turnstile> t SUBS u\n\ngoal (1 subgoal):\n 1. insert (t EQ u) H \\<turnstile> t SUBS u", "thus ?thesis"], ["proof (prove)\nusing this:\n  {t EQ u} \\<turnstile> t SUBS u\n\ngoal (1 subgoal):\n 1. insert (t EQ u) H \\<turnstile> t SUBS u", "by (metis Assume cut1)"], ["proof (state)\nthis:\n  insert (t EQ u) H \\<turnstile> t SUBS u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma EQ_imp_SUBS2: \"insert (u EQ t) H \\<turnstile> (t SUBS u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (u EQ t) H \\<turnstile> t SUBS u", "by (metis EQ_imp_SUBS Sym_L)"], ["", "lemma Equality_E: \"insert (t SUBS u) (insert (u SUBS t) H) \\<turnstile> A \\<Longrightarrow> insert (t EQ u) H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (t SUBS u) (insert (u SUBS t) H) \\<turnstile> A \\<Longrightarrow>\n    insert (t EQ u) H \\<turnstile> A", "by (metis Conj_E Extensionality Iff_MP_left')"], ["", "section \\<open>The Disjointness Relation\\<close>"], ["", "text\\<open>The following predicate is defined in order to prove Lemma 2.3, Foundation\\<close>"], ["", "nominal_function Disjoint :: \"tm \\<Rightarrow> tm \\<Rightarrow> fm\"\n  where \"atom z \\<sharp> (t, u) \\<Longrightarrow> Disjoint t u = All2 z t (Neg ((Var z) IN u))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt Disjoint_graph_aux\n 2. \\<And>x y. Disjoint_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>z t u.\n           \\<lbrakk>atom z \\<sharp> (t, u); x = (t, u)\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>z t u za ta ua.\n       \\<lbrakk>atom z \\<sharp> (t, u); atom za \\<sharp> (ta, ua);\n        (t, u) = (ta, ua)\\<rbrakk>\n       \\<Longrightarrow> All2 z t (Neg (Var z IN u)) =\n                         All2 za ta (Neg (Var za IN ua))", "by (auto simp: eqvt_def Disjoint_graph_aux_def flip_fresh_fresh) (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All Disjoint_dom", "by lexicographic_order"], ["", "declare Disjoint.simps [simp del]"], ["", "lemma Disjoint_fresh_iff [simp]: \"a \\<sharp> Disjoint t u \\<longleftrightarrow> a \\<sharp> t \\<and> a \\<sharp> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> Disjoint t u = (a \\<sharp> t \\<and> a \\<sharp> u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<sharp> Disjoint t u = (a \\<sharp> t \\<and> a \\<sharp> u)", "obtain j::name where j: \"atom j \\<sharp> (a,t,u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        atom j \\<sharp> (a, t, u) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_fresh)"], ["proof (state)\nthis:\n  atom j \\<sharp> (a, t, u)\n\ngoal (1 subgoal):\n 1. a \\<sharp> Disjoint t u = (a \\<sharp> t \\<and> a \\<sharp> u)", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom j \\<sharp> (a, t, u)\n\ngoal (1 subgoal):\n 1. a \\<sharp> Disjoint t u = (a \\<sharp> t \\<and> a \\<sharp> u)", "by (auto simp: Disjoint.simps [of j])"], ["proof (state)\nthis:\n  a \\<sharp> Disjoint t u = (a \\<sharp> t \\<and> a \\<sharp> u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst_fm_Disjoint [simp]:\n  \"(Disjoint t u)(i::=x) = Disjoint (subst i x t) (subst i x u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Disjoint t u)(i::=x) = Disjoint (subst i x t) (subst i x u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (Disjoint t u)(i::=x) = Disjoint (subst i x t) (subst i x u)", "obtain j::name where j: \"atom j \\<sharp> (i,x,t,u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        atom j \\<sharp> (i, x, t, u) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_fresh)"], ["proof (state)\nthis:\n  atom j \\<sharp> (i, x, t, u)\n\ngoal (1 subgoal):\n 1. (Disjoint t u)(i::=x) = Disjoint (subst i x t) (subst i x u)", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom j \\<sharp> (i, x, t, u)\n\ngoal (1 subgoal):\n 1. (Disjoint t u)(i::=x) = Disjoint (subst i x t) (subst i x u)", "by (auto simp: Disjoint.simps [of j])"], ["proof (state)\nthis:\n  (Disjoint t u)(i::=x) = Disjoint (subst i x t) (subst i x u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Disjoint_cong: \"H \\<turnstile> t EQ t' \\<Longrightarrow> H \\<turnstile> u EQ u' \\<Longrightarrow> H \\<turnstile> Disjoint t u IFF Disjoint t' u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> t EQ t'; H \\<turnstile> u EQ u'\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile> Disjoint t u IFF Disjoint t' u'", "by (rule P2_cong) auto"], ["", "lemma Disjoint_I:\n  assumes \"insert ((Var i) IN t) (insert ((Var i) IN u) H) \\<turnstile> Fls\"\n          \"atom i \\<sharp> (t,u)\" \"\\<forall>B \\<in> H. atom i \\<sharp> B\"\n  shows \"H \\<turnstile> Disjoint t u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> Disjoint t u", "by (subst Disjoint.simps [of i]) (auto simp: assms insert_commute)"], ["", "lemma Disjoint_E:\n  assumes major: \"H \\<turnstile> Disjoint t u\" and minor: \"H \\<turnstile> a IN t\" \"H \\<turnstile> a IN u\" shows \"H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H \\<turnstile> A", "obtain i::name where i: \"atom i \\<sharp> (t, u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        atom i \\<sharp> (t, u) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_fresh)"], ["proof (state)\nthis:\n  atom i \\<sharp> (t, u)\n\ngoal (1 subgoal):\n 1. H \\<turnstile> A", "hence \"H \\<turnstile> (Var i IN t IMP Neg (Var i IN u)) (i::=a)\""], ["proof (prove)\nusing this:\n  atom i \\<sharp> (t, u)\n\ngoal (1 subgoal):\n 1. H \\<turnstile> (Var i IN t IMP Neg (Var i IN u))(i::=a)", "by (metis Disjoint.simps major All_D)"], ["proof (state)\nthis:\n  H \\<turnstile> (Var i IN t IMP Neg (Var i IN u))(i::=a)\n\ngoal (1 subgoal):\n 1. H \\<turnstile> A", "thus ?thesis"], ["proof (prove)\nusing this:\n  H \\<turnstile> (Var i IN t IMP Neg (Var i IN u))(i::=a)\n\ngoal (1 subgoal):\n 1. H \\<turnstile> A", "using i"], ["proof (prove)\nusing this:\n  H \\<turnstile> (Var i IN t IMP Neg (Var i IN u))(i::=a)\n  atom i \\<sharp> (t, u)\n\ngoal (1 subgoal):\n 1. H \\<turnstile> A", "by simp (metis MP_same Neg_D minor)"], ["proof (state)\nthis:\n  H \\<turnstile> A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Disjoint_commute: \"{ Disjoint t u } \\<turnstile> Disjoint u t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Disjoint t u} \\<turnstile> Disjoint u t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {Disjoint t u} \\<turnstile> Disjoint u t", "obtain i::name where \"atom i \\<sharp> (t,u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        atom i \\<sharp> (t, u) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_fresh)"], ["proof (state)\nthis:\n  atom i \\<sharp> (t, u)\n\ngoal (1 subgoal):\n 1. {Disjoint t u} \\<turnstile> Disjoint u t", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom i \\<sharp> (t, u)\n\ngoal (1 subgoal):\n 1. {Disjoint t u} \\<turnstile> Disjoint u t", "by (auto simp: fresh_Pair intro: Disjoint_I Disjoint_E)"], ["proof (state)\nthis:\n  {Disjoint t u} \\<turnstile> Disjoint u t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Disjoint_commute_I: \"H \\<turnstile> Disjoint t u \\<Longrightarrow> H \\<turnstile> Disjoint u t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> Disjoint t u \\<Longrightarrow>\n    H \\<turnstile> Disjoint u t", "by (metis Disjoint_commute cut1)"], ["", "lemma Disjoint_commute_D: \"insert (Disjoint t u) H \\<turnstile> A \\<Longrightarrow> insert (Disjoint u t) H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (Disjoint t u) H \\<turnstile> A \\<Longrightarrow>\n    insert (Disjoint u t) H \\<turnstile> A", "by (metis Assume Disjoint_commute_I cut_same insert_commute thin1)"], ["", "lemma Zero_Disjoint_I1 [iff]: \"H \\<turnstile> Disjoint Zero t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> Disjoint Zero t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H \\<turnstile> Disjoint Zero t", "obtain i::name where i: \"atom i \\<sharp> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. atom i \\<sharp> t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_fresh)"], ["proof (state)\nthis:\n  atom i \\<sharp> t\n\ngoal (1 subgoal):\n 1. H \\<turnstile> Disjoint Zero t", "hence \"{} \\<turnstile> Disjoint Zero t\""], ["proof (prove)\nusing this:\n  atom i \\<sharp> t\n\ngoal (1 subgoal):\n 1. {} \\<turnstile> Disjoint Zero t", "by (auto intro: Disjoint_I [of i])"], ["proof (state)\nthis:\n  {} \\<turnstile> Disjoint Zero t\n\ngoal (1 subgoal):\n 1. H \\<turnstile> Disjoint Zero t", "thus ?thesis"], ["proof (prove)\nusing this:\n  {} \\<turnstile> Disjoint Zero t\n\ngoal (1 subgoal):\n 1. H \\<turnstile> Disjoint Zero t", "by (metis thin0)"], ["proof (state)\nthis:\n  H \\<turnstile> Disjoint Zero t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Zero_Disjoint_I2 [iff]: \"H \\<turnstile> Disjoint t Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> Disjoint t Zero", "by (metis Disjoint_commute Zero_Disjoint_I1 cut1)"], ["", "lemma Disjoint_Eats_D1: \"{ Disjoint (Eats x y) z } \\<turnstile> Disjoint x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Disjoint (Eats x y) z} \\<turnstile> Disjoint x z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {Disjoint (Eats x y) z} \\<turnstile> Disjoint x z", "obtain i::name where i: \"atom i \\<sharp> (x,y,z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        atom i \\<sharp> (x, y, z) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_fresh)"], ["proof (state)\nthis:\n  atom i \\<sharp> (x, y, z)\n\ngoal (1 subgoal):\n 1. {Disjoint (Eats x y) z} \\<turnstile> Disjoint x z", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. {Disjoint (Eats x y) z} \\<turnstile> Disjoint x z", "apply (rule Disjoint_I [of i])"], ["proof (prove)\ngoal (3 subgoals):\n 1. {Var i IN x, Var i IN z, Disjoint (Eats x y) z} \\<turnstile> Fls\n 2. atom i \\<sharp> (x, z)\n 3. \\<forall>B\\<in>{Disjoint (Eats x y) z}. atom i \\<sharp> B", "apply (blast intro: Disjoint_E Mem_Eats_I1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. atom i \\<sharp> (x, z)\n 2. \\<forall>B\\<in>{Disjoint (Eats x y) z}. atom i \\<sharp> B", "using i"], ["proof (prove)\nusing this:\n  atom i \\<sharp> (x, y, z)\n\ngoal (2 subgoals):\n 1. atom i \\<sharp> (x, z)\n 2. \\<forall>B\\<in>{Disjoint (Eats x y) z}. atom i \\<sharp> B", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {Disjoint (Eats x y) z} \\<turnstile> Disjoint x z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Disjoint_Eats_D2: \"{ Disjoint (Eats x y) z } \\<turnstile> Neg(y IN z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Disjoint (Eats x y) z} \\<turnstile> Neg (y IN z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {Disjoint (Eats x y) z} \\<turnstile> Neg (y IN z)", "obtain i::name where i: \"atom i \\<sharp> (x,y,z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        atom i \\<sharp> (x, y, z) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_fresh)"], ["proof (state)\nthis:\n  atom i \\<sharp> (x, y, z)\n\ngoal (1 subgoal):\n 1. {Disjoint (Eats x y) z} \\<turnstile> Neg (y IN z)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. {Disjoint (Eats x y) z} \\<turnstile> Neg (y IN z)", "by (force intro: Disjoint_E [THEN rotate2] Mem_Eats_I2)"], ["proof (state)\nthis:\n  {Disjoint (Eats x y) z} \\<turnstile> Neg (y IN z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Disjoint_Eats_E: \n  \"insert (Disjoint x z) (insert (Neg(y IN z)) H) \\<turnstile> A \\<Longrightarrow> insert (Disjoint (Eats x y) z) H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (Disjoint x z) (insert (Neg (y IN z)) H) \\<turnstile>\n    A \\<Longrightarrow>\n    insert (Disjoint (Eats x y) z) H \\<turnstile> A", "apply (rule cut_same [OF cut1 [OF Disjoint_Eats_D2, OF Assume]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (Disjoint x z) (insert (Neg (y IN z)) H) \\<turnstile>\n    A \\<Longrightarrow>\n    insert (Neg (y IN z)) (insert (Disjoint (Eats x y) z) H) \\<turnstile> A", "apply (rule cut_same [OF cut1 [OF Disjoint_Eats_D1, OF Hyp]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. insert (Disjoint x z) (insert (Neg (y IN z)) H) \\<turnstile>\n    A \\<Longrightarrow>\n    Disjoint (Eats ?x7 ?y7) ?z7\n    \\<in> insert (Neg (y IN z)) (insert (Disjoint (Eats x y) z) H)\n 2. insert (Disjoint x z) (insert (Neg (y IN z)) H) \\<turnstile>\n    A \\<Longrightarrow>\n    insert (Disjoint ?x7 ?z7)\n     (insert (Neg (y IN z)) (insert (Disjoint (Eats x y) z) H)) \\<turnstile>\n    A", "apply (auto intro: thin)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Disjoint_Eats_E2: \n  \"insert (Disjoint z x) (insert (Neg(y IN z)) H) \\<turnstile> A \\<Longrightarrow> insert (Disjoint z (Eats x y)) H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (Disjoint z x) (insert (Neg (y IN z)) H) \\<turnstile>\n    A \\<Longrightarrow>\n    insert (Disjoint z (Eats x y)) H \\<turnstile> A", "by (metis Disjoint_Eats_E Disjoint_commute_D)"], ["", "lemma Disjoint_Eats_Imp: \"{ Disjoint x z, Neg(y IN z) } \\<turnstile> Disjoint (Eats x y) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Disjoint x z, Neg (y IN z)} \\<turnstile> Disjoint (Eats x y) z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {Disjoint x z, Neg (y IN z)} \\<turnstile> Disjoint (Eats x y) z", "obtain i::name where\"atom i \\<sharp> (x,y,z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        atom i \\<sharp> (x, y, z) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_fresh)"], ["proof (state)\nthis:\n  atom i \\<sharp> (x, y, z)\n\ngoal (1 subgoal):\n 1. {Disjoint x z, Neg (y IN z)} \\<turnstile> Disjoint (Eats x y) z", "then"], ["proof (chain)\npicking this:\n  atom i \\<sharp> (x, y, z)", "show ?thesis"], ["proof (prove)\nusing this:\n  atom i \\<sharp> (x, y, z)\n\ngoal (1 subgoal):\n 1. {Disjoint x z, Neg (y IN z)} \\<turnstile> Disjoint (Eats x y) z", "by (auto intro: Disjoint_I [of i]  Disjoint_E [THEN rotate3] \n                    Mem_cong [OF Assume Refl, THEN Iff_MP_same])"], ["proof (state)\nthis:\n  {Disjoint x z, Neg (y IN z)} \\<turnstile> Disjoint (Eats x y) z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Disjoint_Eats_I [intro!]: \"H \\<turnstile> Disjoint x z \\<Longrightarrow> insert (y IN z) H \\<turnstile> Fls \\<Longrightarrow> H \\<turnstile> Disjoint (Eats x y) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> Disjoint x z;\n     insert (y IN z) H \\<turnstile> Fls\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile> Disjoint (Eats x y) z", "by (metis Neg_I cut2 [OF Disjoint_Eats_Imp])"], ["", "lemma Disjoint_Eats_I2 [intro!]: \"H \\<turnstile> Disjoint z x \\<Longrightarrow> insert (y IN z) H \\<turnstile> Fls \\<Longrightarrow> H \\<turnstile> Disjoint z (Eats x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> Disjoint z x;\n     insert (y IN z) H \\<turnstile> Fls\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile> Disjoint z (Eats x y)", "by (metis Disjoint_Eats_I Disjoint_commute cut1)"], ["", "section \\<open>The Foundation Theorem\\<close>"], ["", "lemma Foundation_lemma: \n  assumes i: \"atom i \\<sharp> z\"\n  shows \"{ All2 i z (Neg (Disjoint (Var i) z)) } \\<turnstile> Neg (Var i IN z) AND Disjoint (Var i) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {All2 i z (Neg (Disjoint (Var i) z))} \\<turnstile>\n    Neg (Var i IN z) AND Disjoint (Var i) z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {All2 i z (Neg (Disjoint (Var i) z))} \\<turnstile>\n    Neg (Var i IN z) AND Disjoint (Var i) z", "obtain j::name  where j: \"atom j \\<sharp> (z,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        atom j \\<sharp> (z, i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom j \\<sharp> (z, i)\n\ngoal (1 subgoal):\n 1. {All2 i z (Neg (Disjoint (Var i) z))} \\<turnstile>\n    Neg (Var i IN z) AND Disjoint (Var i) z", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. {All2 i z (Neg (Disjoint (Var i) z))} \\<turnstile>\n    Neg (Var i IN z) AND Disjoint (Var i) z", "apply (rule Ind [of j])"], ["proof (prove)\ngoal (3 subgoals):\n 1. atom j \\<sharp> (?i, Neg (Var i IN z) AND Disjoint (Var i) z)\n 2. {All2 i z (Neg (Disjoint (Var i) z))} \\<turnstile>\n    (Neg (Var i IN z) AND Disjoint (Var i) z)(?i::=Zero)\n 3. {All2 i z (Neg (Disjoint (Var i) z))} \\<turnstile>\n    SyntaxN.All ?i\n     (SyntaxN.All j\n       (Neg (Var i IN z) AND Disjoint (Var i) z IMP\n        (Neg (Var i IN z) AND Disjoint (Var i) z)(?i::=Var j) IMP\n        (Neg (Var i IN z) AND\n         Disjoint (Var i) z)(?i::=Eats (Var ?i) (Var j))))", "using i j"], ["proof (prove)\nusing this:\n  atom i \\<sharp> z\n  atom j \\<sharp> (z, i)\n\ngoal (3 subgoals):\n 1. atom j \\<sharp> (?i, Neg (Var i IN z) AND Disjoint (Var i) z)\n 2. {All2 i z (Neg (Disjoint (Var i) z))} \\<turnstile>\n    (Neg (Var i IN z) AND Disjoint (Var i) z)(?i::=Zero)\n 3. {All2 i z (Neg (Disjoint (Var i) z))} \\<turnstile>\n    SyntaxN.All ?i\n     (SyntaxN.All j\n       (Neg (Var i IN z) AND Disjoint (Var i) z IMP\n        (Neg (Var i IN z) AND Disjoint (Var i) z)(?i::=Var j) IMP\n        (Neg (Var i IN z) AND\n         Disjoint (Var i) z)(?i::=Eats (Var ?i) (Var j))))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom i \\<sharp> z; atom j \\<sharp> (z, i)\\<rbrakk>\n    \\<Longrightarrow> {Zero IN z} \\<turnstile>\n                      SyntaxN.Ex i\n                       (Neg (Var i IN z IMP Neg (Disjoint (Var i) z)))\n 2. \\<lbrakk>atom i \\<sharp> z; atom j \\<sharp> (z, i)\\<rbrakk>\n    \\<Longrightarrow> {Neg (Var j IN z), Disjoint (Var j) z,\n                       Neg (Var i IN z), Disjoint (Var i) z,\n                       Neg (Neg (Eats (Var i) (Var j) IN z) AND\n                            Disjoint (Eats (Var i) (Var j)) z)} \\<turnstile>\n                      SyntaxN.Ex i\n                       (Neg (Var i IN z IMP Neg (Disjoint (Var i) z)))", "apply (rule Ex_I [where x=Zero], auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom i \\<sharp> z; atom j \\<sharp> (z, i)\\<rbrakk>\n    \\<Longrightarrow> {Neg (Var j IN z), Disjoint (Var j) z,\n                       Neg (Var i IN z), Disjoint (Var i) z,\n                       Neg (Neg (Eats (Var i) (Var j) IN z) AND\n                            Disjoint (Eats (Var i) (Var j)) z)} \\<turnstile>\n                      SyntaxN.Ex i\n                       (Neg (Var i IN z IMP Neg (Disjoint (Var i) z)))", "apply (rule Ex_I [where x=\"Eats (Var i) (Var j)\"], auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>atom i \\<sharp> z; atom j \\<sharp> (z, i)\\<rbrakk>\n    \\<Longrightarrow> {Var j IN z, Neg (Eats (Var i) (Var j) IN z),\n                       Neg (Var j IN z), Disjoint (Var j) z,\n                       Disjoint (Var i) z} \\<turnstile>\n                      Var i IN z\n 2. \\<lbrakk>atom i \\<sharp> z; atom j \\<sharp> (z, i)\\<rbrakk>\n    \\<Longrightarrow> {Eats (Var i) (Var j) IN z,\n                       Neg (Disjoint (Eats (Var i) (Var j)) z),\n                       Neg (Var j IN z), Disjoint (Var j) z,\n                       Disjoint (Var i) z} \\<turnstile>\n                      Var i IN z\n 3. \\<lbrakk>atom i \\<sharp> z; atom j \\<sharp> (z, i)\\<rbrakk>\n    \\<Longrightarrow> {Var j IN z, Neg (Disjoint (Eats (Var i) (Var j)) z),\n                       Neg (Var j IN z), Disjoint (Var j) z,\n                       Disjoint (Var i) z} \\<turnstile>\n                      Var i IN z", "apply (metis ContraAssume insertI1 insert_commute)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom i \\<sharp> z; atom j \\<sharp> (z, i)\\<rbrakk>\n    \\<Longrightarrow> {Eats (Var i) (Var j) IN z,\n                       Neg (Disjoint (Eats (Var i) (Var j)) z),\n                       Neg (Var j IN z), Disjoint (Var j) z,\n                       Disjoint (Var i) z} \\<turnstile>\n                      Var i IN z\n 2. \\<lbrakk>atom i \\<sharp> z; atom j \\<sharp> (z, i)\\<rbrakk>\n    \\<Longrightarrow> {Var j IN z, Neg (Disjoint (Eats (Var i) (Var j)) z),\n                       Neg (Var j IN z), Disjoint (Var j) z,\n                       Disjoint (Var i) z} \\<turnstile>\n                      Var i IN z", "apply (metis ContraProve Disjoint_Eats_Imp rotate2 thin1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom i \\<sharp> z; atom j \\<sharp> (z, i)\\<rbrakk>\n    \\<Longrightarrow> {Var j IN z, Neg (Disjoint (Eats (Var i) (Var j)) z),\n                       Neg (Var j IN z), Disjoint (Var j) z,\n                       Disjoint (Var i) z} \\<turnstile>\n                      Var i IN z", "apply (metis Assume Disj_I1 anti_deduction rotate3)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {All2 i z (Neg (Disjoint (Var i) z))} \\<turnstile>\n  Neg (Var i IN z) AND Disjoint (Var i) z\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem Foundation: \"atom i \\<sharp> z \\<Longrightarrow> {} \\<turnstile> All2 i z (Neg (Disjoint (Var i) z)) IMP z EQ Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom i \\<sharp> z \\<Longrightarrow>\n    {} \\<turnstile> All2 i z (Neg (Disjoint (Var i) z)) IMP z EQ Zero", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. atom i \\<sharp> z \\<Longrightarrow>\n    {All2 i z (Neg (Disjoint (Var i) z))} \\<turnstile> z EQ Zero", "apply (rule Eq_Zero_I)"], ["proof (prove)\ngoal (3 subgoals):\n 1. atom i \\<sharp> z \\<Longrightarrow>\n    {Var ?i1 IN z, All2 i z (Neg (Disjoint (Var i) z))} \\<turnstile> Fls\n 2. atom i \\<sharp> z \\<Longrightarrow> atom ?i1 \\<sharp> z\n 3. atom i \\<sharp> z \\<Longrightarrow>\n    \\<forall>B\\<in>{All2 i z (Neg (Disjoint (Var i) z))}.\n       atom ?i1 \\<sharp> B", "apply (rule cut_same [where A = \"(Neg ((Var i) IN z) AND Disjoint (Var i) z)\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. atom i \\<sharp> z \\<Longrightarrow>\n    {Var ?i1 IN z, All2 i z (Neg (Disjoint (Var i) z))} \\<turnstile>\n    Neg (Var i IN z) AND Disjoint (Var i) z\n 2. atom i \\<sharp> z \\<Longrightarrow>\n    {Neg (Var i IN z) AND Disjoint (Var i) z, Var ?i1 IN z,\n     All2 i z (Neg (Disjoint (Var i) z))} \\<turnstile>\n    Fls\n 3. atom i \\<sharp> z \\<Longrightarrow> atom ?i1 \\<sharp> z\n 4. atom i \\<sharp> z \\<Longrightarrow>\n    \\<forall>B\\<in>{All2 i z (Neg (Disjoint (Var i) z))}.\n       atom ?i1 \\<sharp> B", "apply (rule Foundation_lemma [THEN cut1], auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Mem_Neg_refl: \"{} \\<turnstile> Neg (x IN x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<turnstile> Neg (x IN x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {} \\<turnstile> Neg (x IN x)", "obtain i::name where i: \"atom i \\<sharp> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. atom i \\<sharp> x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom i \\<sharp> x\n\ngoal (1 subgoal):\n 1. {} \\<turnstile> Neg (x IN x)", "have \"{} \\<turnstile> Disjoint x (Eats Zero x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<turnstile> Disjoint x (Eats Zero x)", "apply (rule cut_same [OF Foundation [where z = \"Eats Zero x\"]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. atom ?i1 \\<sharp> Eats Zero x\n 2. {All2 ?i1 (Eats Zero x) (Neg (Disjoint (Var ?i1) (Eats Zero x))) IMP\n     Eats Zero x EQ Zero} \\<turnstile>\n    Disjoint x (Eats Zero x)", "using i"], ["proof (prove)\nusing this:\n  atom i \\<sharp> x\n\ngoal (2 subgoals):\n 1. atom ?i1 \\<sharp> Eats Zero x\n 2. {All2 ?i1 (Eats Zero x) (Neg (Disjoint (Var ?i1) (Eats Zero x))) IMP\n     Eats Zero x EQ Zero} \\<turnstile>\n    Disjoint x (Eats Zero x)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. atom i \\<sharp> x \\<Longrightarrow>\n    {Var i EQ x, Disjoint (Var i) (Eats Zero x), x IN x} \\<turnstile> Fls", "apply (rule cut_same [where A = \"Disjoint x (Eats Zero x)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. atom i \\<sharp> x \\<Longrightarrow>\n    {Var i EQ x, Disjoint (Var i) (Eats Zero x), x IN x} \\<turnstile>\n    Disjoint x (Eats Zero x)\n 2. atom i \\<sharp> x \\<Longrightarrow>\n    {Disjoint x (Eats Zero x), Var i EQ x, Disjoint (Var i) (Eats Zero x),\n     x IN x} \\<turnstile>\n    Fls", "apply (metis Assume thin1 Disjoint_cong [OF Assume Refl, THEN Iff_MP_same])"], ["proof (prove)\ngoal (1 subgoal):\n 1. atom i \\<sharp> x \\<Longrightarrow>\n    {Disjoint x (Eats Zero x), Var i EQ x, Disjoint (Var i) (Eats Zero x),\n     x IN x} \\<turnstile>\n    Fls", "apply (metis Assume AssumeH(4) Disjoint_E Mem_Eats_I2 Refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {} \\<turnstile> Disjoint x (Eats Zero x)\n\ngoal (1 subgoal):\n 1. {} \\<turnstile> Neg (x IN x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  {} \\<turnstile> Disjoint x (Eats Zero x)\n\ngoal (1 subgoal):\n 1. {} \\<turnstile> Neg (x IN x)", "by (metis Disjoint_Eats_D2 Disjoint_commute cut_same)"], ["proof (state)\nthis:\n  {} \\<turnstile> Neg (x IN x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Mem_refl_E [intro!]: \"insert (x IN x) H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (x IN x) H \\<turnstile> A", "by (metis Disj_I1 Mem_Neg_refl anti_deduction thin0)"], ["", "lemma Mem_non_refl: assumes \"H \\<turnstile> x IN x\" shows \"H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> A", "by (metis Mem_refl_E assms cut_same)"], ["", "lemma Mem_Neg_sym: \"{ x IN y, y IN x } \\<turnstile> Fls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x IN y, y IN x} \\<turnstile> Fls", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {x IN y, y IN x} \\<turnstile> Fls", "obtain i::name where i: \"atom i \\<sharp> (x,y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        atom i \\<sharp> (x, y) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom i \\<sharp> (x, y)\n\ngoal (1 subgoal):\n 1. {x IN y, y IN x} \\<turnstile> Fls", "have \"{} \\<turnstile> Disjoint x (Eats Zero y) OR Disjoint y (Eats Zero x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<turnstile> Disjoint x (Eats Zero y) OR Disjoint y (Eats Zero x)", "apply (rule cut_same [OF Foundation [where i=i and z = \"Eats (Eats Zero y) x\"]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. atom i \\<sharp> Eats (Eats Zero y) x\n 2. {All2 i (Eats (Eats Zero y) x)\n      (Neg (Disjoint (Var i) (Eats (Eats Zero y) x))) IMP\n     Eats (Eats Zero y) x EQ Zero} \\<turnstile>\n    Disjoint x (Eats Zero y) OR Disjoint y (Eats Zero x)", "using i"], ["proof (prove)\nusing this:\n  atom i \\<sharp> (x, y)\n\ngoal (2 subgoals):\n 1. atom i \\<sharp> Eats (Eats Zero y) x\n 2. {All2 i (Eats (Eats Zero y) x)\n      (Neg (Disjoint (Var i) (Eats (Eats Zero y) x))) IMP\n     Eats (Eats Zero y) x EQ Zero} \\<turnstile>\n    Disjoint x (Eats Zero y) OR Disjoint y (Eats Zero x)", "apply (auto intro!: Disjoint_Eats_E2 [THEN rotate2])"], ["proof (prove)\ngoal (2 subgoals):\n 1. atom i \\<sharp> (x, y) \\<Longrightarrow>\n    {Disjoint (Var i) Zero, Neg (y IN Var i), Var i EQ y,\n     Neg (x IN Var i)} \\<turnstile>\n    Disjoint x (Eats Zero y) OR Disjoint y (Eats Zero x)\n 2. atom i \\<sharp> (x, y) \\<Longrightarrow>\n    {Disjoint (Var i) (Eats Zero y), Neg (x IN Var i),\n     Var i EQ x} \\<turnstile>\n    Disjoint x (Eats Zero y) OR Disjoint y (Eats Zero x)", "apply (rule Disj_I2, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. atom i \\<sharp> (x, y) \\<Longrightarrow>\n    {x IN y, Disjoint (Var i) Zero, Neg (y IN Var i),\n     Var i EQ y} \\<turnstile>\n    x IN Var i\n 2. atom i \\<sharp> (x, y) \\<Longrightarrow>\n    {Disjoint (Var i) (Eats Zero y), Neg (x IN Var i),\n     Var i EQ x} \\<turnstile>\n    Disjoint x (Eats Zero y) OR Disjoint y (Eats Zero x)", "apply (metis Assume EQ_imp_SUBS2 Subset_D insert_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. atom i \\<sharp> (x, y) \\<Longrightarrow>\n    {Disjoint (Var i) (Eats Zero y), Neg (x IN Var i),\n     Var i EQ x} \\<turnstile>\n    Disjoint x (Eats Zero y) OR Disjoint y (Eats Zero x)", "apply (blast intro!: Disj_I1 Disjoint_cong [OF Hyp Refl, THEN Iff_MP_same])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {} \\<turnstile> Disjoint x (Eats Zero y) OR Disjoint y (Eats Zero x)\n\ngoal (1 subgoal):\n 1. {x IN y, y IN x} \\<turnstile> Fls", "thus ?thesis"], ["proof (prove)\nusing this:\n  {} \\<turnstile> Disjoint x (Eats Zero y) OR Disjoint y (Eats Zero x)\n\ngoal (1 subgoal):\n 1. {x IN y, y IN x} \\<turnstile> Fls", "by (auto intro: cut0 Disjoint_Eats_E2)"], ["proof (state)\nthis:\n  {x IN y, y IN x} \\<turnstile> Fls\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Mem_not_sym: \"insert (x IN y) (insert (y IN x) H) \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (x IN y) (insert (y IN x) H) \\<turnstile> A", "by (rule cut_thin [OF Mem_Neg_sym]) auto"], ["", "section \\<open>The Ordinal Property\\<close>"], ["", "nominal_function OrdP :: \"tm \\<Rightarrow> fm\"\n  where \"\\<lbrakk>atom y \\<sharp> (x, z); atom z \\<sharp> x\\<rbrakk> \\<Longrightarrow>\n    OrdP x = All2 y x ((Var y) SUBS x AND  All2 z (Var y) ((Var z) SUBS (Var y)))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt OrdP_graph_aux\n 2. \\<And>x y. OrdP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>y xa z.\n           \\<lbrakk>atom y \\<sharp> (xa, z); atom z \\<sharp> xa;\n            x = xa\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>y x z ya xa za.\n       \\<lbrakk>atom y \\<sharp> (x, z); atom z \\<sharp> x;\n        atom ya \\<sharp> (xa, za); atom za \\<sharp> xa; x = xa\\<rbrakk>\n       \\<Longrightarrow> All2 y x\n                          (Var y SUBS x AND\n                           All2 z (Var y) (Var z SUBS Var y)) =\n                         All2 ya xa\n                          (Var ya SUBS xa AND\n                           All2 za (Var ya) (Var za SUBS Var ya))", "by (auto simp: eqvt_def OrdP_graph_aux_def flip_fresh_fresh) (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All OrdP_dom", "by lexicographic_order"], ["", "lemma\n shows OrdP_fresh_iff [simp]: \"a \\<sharp> OrdP x \\<longleftrightarrow> a \\<sharp> x\"       (is ?thesis1)\n   and eval_fm_OrdP [simp]:  \"eval_fm e (OrdP x) \\<longleftrightarrow> Ord \\<lbrakk>x\\<rbrakk>e\"  (is ?thesis2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> OrdP x = a \\<sharp> x &&&\n    eval_fm e (OrdP x) = Ord \\<lbrakk>x\\<rbrakk>e", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<sharp> OrdP x = a \\<sharp> x\n 2. eval_fm e (OrdP x) = Ord \\<lbrakk>x\\<rbrakk>e", "obtain z::name and y::name where \"atom z \\<sharp> x\" \"atom y \\<sharp> (x, z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z y.\n        \\<lbrakk>atom z \\<sharp> x; atom y \\<sharp> (x, z)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom z \\<sharp> x\n  atom y \\<sharp> (x, z)\n\ngoal (2 subgoals):\n 1. a \\<sharp> OrdP x = a \\<sharp> x\n 2. eval_fm e (OrdP x) = Ord \\<lbrakk>x\\<rbrakk>e", "thus ?thesis1 ?thesis2"], ["proof (prove)\nusing this:\n  atom z \\<sharp> x\n  atom y \\<sharp> (x, z)\n\ngoal (1 subgoal):\n 1. a \\<sharp> OrdP x = a \\<sharp> x &&&\n    eval_fm e (OrdP x) = Ord \\<lbrakk>x\\<rbrakk>e", "by (auto simp: OrdP.simps [of y _ z] Ord_def Transset_def)"], ["proof (state)\nthis:\n  a \\<sharp> OrdP x = a \\<sharp> x\n  eval_fm e (OrdP x) = Ord \\<lbrakk>x\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst_fm_OrdP [simp]: \"(OrdP t)(i::=x) = OrdP (subst i x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (OrdP t)(i::=x) = OrdP (subst i x t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (OrdP t)(i::=x) = OrdP (subst i x t)", "obtain z::name and y::name where \"atom z \\<sharp> (t,i,x)\" \"atom y \\<sharp> (t,i,x,z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z y.\n        \\<lbrakk>atom z \\<sharp> (t, i, x);\n         atom y \\<sharp> (t, i, x, z)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom z \\<sharp> (t, i, x)\n  atom y \\<sharp> (t, i, x, z)\n\ngoal (1 subgoal):\n 1. (OrdP t)(i::=x) = OrdP (subst i x t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom z \\<sharp> (t, i, x)\n  atom y \\<sharp> (t, i, x, z)\n\ngoal (1 subgoal):\n 1. (OrdP t)(i::=x) = OrdP (subst i x t)", "by (auto simp: OrdP.simps [of y _ z])"], ["proof (state)\nthis:\n  (OrdP t)(i::=x) = OrdP (subst i x t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OrdP_cong: \"H \\<turnstile> x EQ x' \\<Longrightarrow> H \\<turnstile> OrdP x IFF OrdP x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> x EQ x' \\<Longrightarrow>\n    H \\<turnstile> OrdP x IFF OrdP x'", "by (rule P1_cong) auto"], ["", "lemma OrdP_Mem_lemma:\n  assumes z: \"atom z \\<sharp> (k,l)\" and l: \"insert (OrdP k) H \\<turnstile> l IN k\"\n  shows \"insert (OrdP k) H \\<turnstile> l SUBS k AND All2 z l (Var z SUBS l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (OrdP k) H \\<turnstile> l SUBS k AND All2 z l (Var z SUBS l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. insert (OrdP k) H \\<turnstile> l SUBS k AND All2 z l (Var z SUBS l)", "obtain y::name where y: \"atom y \\<sharp> (k,l,z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        atom y \\<sharp> (k, l, z) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom y \\<sharp> (k, l, z)\n\ngoal (1 subgoal):\n 1. insert (OrdP k) H \\<turnstile> l SUBS k AND All2 z l (Var z SUBS l)", "have \"insert (OrdP k) H \n        \\<turnstile> (Var y IN k IMP (Var y SUBS k AND All2 z (Var y) (Var z SUBS Var y)))(y::=l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (OrdP k) H \\<turnstile>\n    (Var y IN k IMP\n     Var y SUBS k AND All2 z (Var y) (Var z SUBS Var y))(y::=l)", "by (rule All_D) (simp add: OrdP.simps [of y _ z] y z Assume)"], ["proof (state)\nthis:\n  insert (OrdP k) H \\<turnstile>\n  (Var y IN k IMP Var y SUBS k AND All2 z (Var y) (Var z SUBS Var y))(y::=l)\n\ngoal (1 subgoal):\n 1. insert (OrdP k) H \\<turnstile> l SUBS k AND All2 z l (Var z SUBS l)", "also"], ["proof (state)\nthis:\n  insert (OrdP k) H \\<turnstile>\n  (Var y IN k IMP Var y SUBS k AND All2 z (Var y) (Var z SUBS Var y))(y::=l)\n\ngoal (1 subgoal):\n 1. insert (OrdP k) H \\<turnstile> l SUBS k AND All2 z l (Var z SUBS l)", "have \"... = l IN k IMP (l SUBS k AND All2 z l (Var z SUBS l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Var y IN k IMP\n     Var y SUBS k AND All2 z (Var y) (Var z SUBS Var y))(y::=l) =\n    l IN k IMP l SUBS k AND All2 z l (Var z SUBS l)", "using y z"], ["proof (prove)\nusing this:\n  atom y \\<sharp> (k, l, z)\n  atom z \\<sharp> (k, l)\n\ngoal (1 subgoal):\n 1. (Var y IN k IMP\n     Var y SUBS k AND All2 z (Var y) (Var z SUBS Var y))(y::=l) =\n    l IN k IMP l SUBS k AND All2 z l (Var z SUBS l)", "by simp"], ["proof (state)\nthis:\n  (Var y IN k IMP\n   Var y SUBS k AND All2 z (Var y) (Var z SUBS Var y))(y::=l) =\n  l IN k IMP l SUBS k AND All2 z l (Var z SUBS l)\n\ngoal (1 subgoal):\n 1. insert (OrdP k) H \\<turnstile> l SUBS k AND All2 z l (Var z SUBS l)", "finally"], ["proof (chain)\npicking this:\n  insert (OrdP k) H \\<turnstile>\n  l IN k IMP l SUBS k AND All2 z l (Var z SUBS l)", "show ?thesis"], ["proof (prove)\nusing this:\n  insert (OrdP k) H \\<turnstile>\n  l IN k IMP l SUBS k AND All2 z l (Var z SUBS l)\n\ngoal (1 subgoal):\n 1. insert (OrdP k) H \\<turnstile> l SUBS k AND All2 z l (Var z SUBS l)", "by (metis MP_same l)"], ["proof (state)\nthis:\n  insert (OrdP k) H \\<turnstile> l SUBS k AND All2 z l (Var z SUBS l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OrdP_Mem_E:\n  assumes \"atom z \\<sharp> (k,l)\" \n          \"insert (OrdP k) H \\<turnstile> l IN k\"\n          \"insert (l SUBS k) (insert (All2 z l (Var z SUBS l)) H) \\<turnstile> A\"\n  shows \"insert (OrdP k) H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (OrdP k) H \\<turnstile> A", "apply (rule OrdP_Mem_lemma [THEN cut_same])"], ["proof (prove)\ngoal (3 subgoals):\n 1. atom ?z1 \\<sharp> (k, ?l1)\n 2. insert (OrdP k) H \\<turnstile> ?l1 IN k\n 3. insert (?l1 SUBS k AND All2 ?z1 ?l1 (Var ?z1 SUBS ?l1))\n     (insert (OrdP k) H) \\<turnstile>\n    A", "apply (auto simp: insert_commute)"], ["proof (prove)\ngoal (3 subgoals):\n 1. atom ?z1 \\<sharp> (k, ?l1)\n 2. insert (OrdP k) H \\<turnstile> ?l1 IN k\n 3. insert (OrdP k)\n     (insert (?l1 SUBS k)\n       (insert (All2 ?z1 ?l1 (Var ?z1 SUBS ?l1)) H)) \\<turnstile>\n    A", "apply (blast intro: assms thin1)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma OrdP_Mem_imp_Subset:\n  assumes k: \"H \\<turnstile> k IN l\" and l: \"H \\<turnstile> OrdP l\" shows \"H \\<turnstile> k SUBS l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> k SUBS l", "apply (rule obtain_fresh [of \"(l,k)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       atom a \\<sharp> (l, k) \\<Longrightarrow> H \\<turnstile> k SUBS l", "apply (rule cut_same [OF l])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       atom a \\<sharp> (l, k) \\<Longrightarrow>\n       insert (OrdP l) H \\<turnstile> k SUBS l", "using k"], ["proof (prove)\nusing this:\n  H \\<turnstile> k IN l\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       atom a \\<sharp> (l, k) \\<Longrightarrow>\n       insert (OrdP l) H \\<turnstile> k SUBS l", "apply (auto intro: OrdP_Mem_E thin1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma SUCC_Subset_Ord_lemma: \"{ k' IN k, OrdP k } \\<turnstile> SUCC k' SUBS k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {k' IN k, OrdP k} \\<turnstile> SUCC k' SUBS k", "by auto (metis Assume thin1 OrdP_Mem_imp_Subset)"], ["", "lemma SUCC_Subset_Ord: \"H \\<turnstile> k' IN k \\<Longrightarrow> H \\<turnstile> OrdP k \\<Longrightarrow> H \\<turnstile> SUCC k' SUBS k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> k' IN k; H \\<turnstile> OrdP k\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile> SUCC k' SUBS k", "by (blast intro!: cut2 [OF SUCC_Subset_Ord_lemma])"], ["", "lemma OrdP_Trans_lemma: \"{ OrdP k, i IN j, j IN k } \\<turnstile> i IN k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {OrdP k, i IN j, j IN k} \\<turnstile> i IN k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {OrdP k, i IN j, j IN k} \\<turnstile> i IN k", "obtain m::name where \"atom m \\<sharp> (i,j,k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m.\n        atom m \\<sharp> (i, j, k) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom m \\<sharp> (i, j, k)\n\ngoal (1 subgoal):\n 1. {OrdP k, i IN j, j IN k} \\<turnstile> i IN k", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom m \\<sharp> (i, j, k)\n\ngoal (1 subgoal):\n 1. {OrdP k, i IN j, j IN k} \\<turnstile> i IN k", "by (auto intro: OrdP_Mem_E [of m k j] Subset_D [THEN rotate3])"], ["proof (state)\nthis:\n  {OrdP k, i IN j, j IN k} \\<turnstile> i IN k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OrdP_Trans: \"H \\<turnstile>  OrdP k \\<Longrightarrow> H \\<turnstile> i IN j \\<Longrightarrow> H \\<turnstile> j IN k \\<Longrightarrow> H  \\<turnstile> i IN k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> OrdP k; H \\<turnstile> i IN j;\n     H \\<turnstile> j IN k\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile> i IN k", "by (blast intro: cut3 [OF OrdP_Trans_lemma])"], ["", "lemma Ord_IN_Ord0:\n  assumes l: \"H \\<turnstile> l IN k\"\n  shows \"insert (OrdP k) H \\<turnstile> OrdP l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (OrdP k) H \\<turnstile> OrdP l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. insert (OrdP k) H \\<turnstile> OrdP l", "obtain z::name and y::name where z: \"atom z \\<sharp> (k,l)\" and y: \"atom y \\<sharp> (k,l,z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z y.\n        \\<lbrakk>atom z \\<sharp> (k, l); atom y \\<sharp> (k, l, z)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom z \\<sharp> (k, l)\n  atom y \\<sharp> (k, l, z)\n\ngoal (1 subgoal):\n 1. insert (OrdP k) H \\<turnstile> OrdP l", "have \"{Var y IN l, OrdP k, l IN k} \\<turnstile> All2 z (Var y) (Var z SUBS Var y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Var y IN l, OrdP k, l IN k} \\<turnstile>\n    All2 z (Var y) (Var z SUBS Var y)", "using y z"], ["proof (prove)\nusing this:\n  atom y \\<sharp> (k, l, z)\n  atom z \\<sharp> (k, l)\n\ngoal (1 subgoal):\n 1. {Var y IN l, OrdP k, l IN k} \\<turnstile>\n    All2 z (Var y) (Var z SUBS Var y)", "apply (simp add: insert_commute [of _ \"OrdP k\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom y \\<sharp> (k, l, z); atom z \\<sharp> (k, l)\\<rbrakk>\n    \\<Longrightarrow> {OrdP k, Var y IN l, l IN k} \\<turnstile>\n                      All2 z (Var y) (Var z SUBS Var y)", "apply (auto intro: OrdP_Mem_E [of z k \"Var y\"] OrdP_Trans_lemma del: All_I Neg_I)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {Var y IN l, OrdP k, l IN k} \\<turnstile>\n  All2 z (Var y) (Var z SUBS Var y)\n\ngoal (1 subgoal):\n 1. insert (OrdP k) H \\<turnstile> OrdP l", "hence \"{OrdP k, l IN k} \\<turnstile> OrdP l\""], ["proof (prove)\nusing this:\n  {Var y IN l, OrdP k, l IN k} \\<turnstile>\n  All2 z (Var y) (Var z SUBS Var y)\n\ngoal (1 subgoal):\n 1. {OrdP k, l IN k} \\<turnstile> OrdP l", "using z y"], ["proof (prove)\nusing this:\n  {Var y IN l, OrdP k, l IN k} \\<turnstile>\n  All2 z (Var y) (Var z SUBS Var y)\n  atom z \\<sharp> (k, l)\n  atom y \\<sharp> (k, l, z)\n\ngoal (1 subgoal):\n 1. {OrdP k, l IN k} \\<turnstile> OrdP l", "apply (auto simp: OrdP.simps [of y l z])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{Var y IN l, OrdP k, l IN k} \\<turnstile>\n             All2 z (Var y) (Var z SUBS Var y);\n     atom z \\<sharp> (k, l); atom y \\<sharp> (k, l, z)\\<rbrakk>\n    \\<Longrightarrow> {Var y IN l, OrdP k, l IN k} \\<turnstile> Var y SUBS l", "apply (simp add: insert_commute [of _ \"OrdP k\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{OrdP k, Var y IN l, l IN k} \\<turnstile>\n             All2 z (Var y) (Var z SUBS Var y);\n     atom z \\<sharp> (k, l); atom y \\<sharp> (k, l, z)\\<rbrakk>\n    \\<Longrightarrow> {OrdP k, Var y IN l, l IN k} \\<turnstile> Var y SUBS l", "apply (rule OrdP_Mem_E [of y k l], simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{OrdP k, Var y IN l, l IN k} \\<turnstile>\n             All2 z (Var y) (Var z SUBS Var y);\n     atom z \\<sharp> (k, l); atom y \\<sharp> (k, l, z)\\<rbrakk>\n    \\<Longrightarrow> {OrdP k, Var y IN l, l IN k} \\<turnstile> l IN k\n 2. \\<lbrakk>{OrdP k, Var y IN l, l IN k} \\<turnstile>\n             All2 z (Var y) (Var z SUBS Var y);\n     atom z \\<sharp> (k, l); atom y \\<sharp> (k, l, z)\\<rbrakk>\n    \\<Longrightarrow> {l SUBS k, All2 y l (Var y SUBS l), Var y IN l,\n                       l IN k} \\<turnstile>\n                      Var y SUBS l", "apply (metis Assume thin1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{OrdP k, Var y IN l, l IN k} \\<turnstile>\n             All2 z (Var y) (Var z SUBS Var y);\n     atom z \\<sharp> (k, l); atom y \\<sharp> (k, l, z)\\<rbrakk>\n    \\<Longrightarrow> {l SUBS k, All2 y l (Var y SUBS l), Var y IN l,\n                       l IN k} \\<turnstile>\n                      Var y SUBS l", "apply (rule All_E [where x= \"Var y\", THEN thin1], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{OrdP k, Var y IN l, l IN k} \\<turnstile>\n             All2 z (Var y) (Var z SUBS Var y);\n     atom z \\<sharp> (k, l); atom y \\<sharp> (k, l, z)\\<rbrakk>\n    \\<Longrightarrow> {Var y IN l IMP Var y SUBS l, Var y IN l,\n                       l IN k} \\<turnstile>\n                      Var y SUBS l", "apply (metis Assume anti_deduction insert_commute)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {OrdP k, l IN k} \\<turnstile> OrdP l\n\ngoal (1 subgoal):\n 1. insert (OrdP k) H \\<turnstile> OrdP l", "thus ?thesis"], ["proof (prove)\nusing this:\n  {OrdP k, l IN k} \\<turnstile> OrdP l\n\ngoal (1 subgoal):\n 1. insert (OrdP k) H \\<turnstile> OrdP l", "by (metis (full_types) Assume l cut2 thin1)"], ["proof (state)\nthis:\n  insert (OrdP k) H \\<turnstile> OrdP l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Ord_IN_Ord: \"H \\<turnstile> l IN k \\<Longrightarrow> H \\<turnstile> OrdP k \\<Longrightarrow> H \\<turnstile> OrdP l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> l IN k; H \\<turnstile> OrdP k\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile> OrdP l", "by (metis Ord_IN_Ord0 cut_same)"], ["", "lemma OrdP_I:\n  assumes \"insert (Var y IN x) H \\<turnstile> (Var y) SUBS x\"\n      and \"insert (Var z IN Var y) (insert (Var y IN x) H) \\<turnstile> (Var z) SUBS (Var y)\"\n      and \"atom y \\<sharp> (x, z)\" \"\\<forall>B \\<in> H. atom y \\<sharp> B\"  \"atom z \\<sharp> x\" \"\\<forall>B \\<in> H. atom z \\<sharp> B\"\n    shows \"H \\<turnstile> OrdP x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> OrdP x", "using assms"], ["proof (prove)\nusing this:\n  insert (Var y IN x) H \\<turnstile> Var y SUBS x\n  insert (Var z IN Var y) (insert (Var y IN x) H) \\<turnstile>\n  Var z SUBS Var y\n  atom y \\<sharp> (x, z)\n  \\<forall>B\\<in>H. atom y \\<sharp> B\n  atom z \\<sharp> x\n  \\<forall>B\\<in>H. atom z \\<sharp> B\n\ngoal (1 subgoal):\n 1. H \\<turnstile> OrdP x", "by auto"], ["", "lemma OrdP_Zero [simp]: \"H \\<turnstile> OrdP Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> OrdP Zero", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H \\<turnstile> OrdP Zero", "obtain y::name and z::name where \"atom y \\<sharp> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y z.\n        atom y \\<sharp> z \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_fresh)"], ["proof (state)\nthis:\n  atom y \\<sharp> z\n\ngoal (1 subgoal):\n 1. H \\<turnstile> OrdP Zero", "hence \"{} \\<turnstile> OrdP Zero\""], ["proof (prove)\nusing this:\n  atom y \\<sharp> z\n\ngoal (1 subgoal):\n 1. {} \\<turnstile> OrdP Zero", "by (auto intro: OrdP_I [of y _ _ z])"], ["proof (state)\nthis:\n  {} \\<turnstile> OrdP Zero\n\ngoal (1 subgoal):\n 1. H \\<turnstile> OrdP Zero", "thus ?thesis"], ["proof (prove)\nusing this:\n  {} \\<turnstile> OrdP Zero\n\ngoal (1 subgoal):\n 1. H \\<turnstile> OrdP Zero", "by (metis thin0)"], ["proof (state)\nthis:\n  H \\<turnstile> OrdP Zero\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OrdP_SUCC_I0: \"{ OrdP k } \\<turnstile> OrdP (SUCC k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {OrdP k} \\<turnstile> OrdP (SUCC k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {OrdP k} \\<turnstile> OrdP (SUCC k)", "obtain w::name and y::name and z::name where atoms: \"atom w \\<sharp> (k,y,z)\" \"atom y \\<sharp> (k,z)\" \"atom z \\<sharp> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w y z.\n        \\<lbrakk>atom w \\<sharp> (k, y, z); atom y \\<sharp> (k, z);\n         atom z \\<sharp> k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom w \\<sharp> (k, y, z)\n  atom y \\<sharp> (k, z)\n  atom z \\<sharp> k\n\ngoal (1 subgoal):\n 1. {OrdP k} \\<turnstile> OrdP (SUCC k)", "have 1: \"{Var y IN SUCC k, OrdP k} \\<turnstile> Var y SUBS SUCC k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Var y IN SUCC k, OrdP k} \\<turnstile> Var y SUBS SUCC k", "apply (rule Mem_SUCC_E)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {Var y IN k, OrdP k} \\<turnstile> Var y SUBS SUCC k\n 2. {Var y EQ k, OrdP k} \\<turnstile> Var y SUBS SUCC k", "apply (rule OrdP_Mem_E [of w _ \"Var y\", THEN rotate2])"], ["proof (prove)\ngoal (4 subgoals):\n 1. atom w \\<sharp> (k, Var y)\n 2. {OrdP k, Var y IN k} \\<turnstile> Var y IN k\n 3. {Var y SUBS k, All2 w (Var y) (Var w SUBS Var y),\n     Var y IN k} \\<turnstile>\n    Var y SUBS SUCC k\n 4. {Var y EQ k, OrdP k} \\<turnstile> Var y SUBS SUCC k", "using atoms"], ["proof (prove)\nusing this:\n  atom w \\<sharp> (k, y, z)\n  atom y \\<sharp> (k, z)\n  atom z \\<sharp> k\n\ngoal (4 subgoals):\n 1. atom w \\<sharp> (k, Var y)\n 2. {OrdP k, Var y IN k} \\<turnstile> Var y IN k\n 3. {Var y SUBS k, All2 w (Var y) (Var w SUBS Var y),\n     Var y IN k} \\<turnstile>\n    Var y SUBS SUCC k\n 4. {Var y EQ k, OrdP k} \\<turnstile> Var y SUBS SUCC k", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom w \\<sharp> (k, y, z); atom y \\<sharp> (k, z);\n     atom z \\<sharp> k\\<rbrakk>\n    \\<Longrightarrow> {Var y SUBS k, All2 w (Var y) (Var w SUBS Var y),\n                       Var y IN k} \\<turnstile>\n                      Var y SUBS SUCC k\n 2. \\<lbrakk>atom w \\<sharp> (k, y, z); atom y \\<sharp> (k, z);\n     atom z \\<sharp> k\\<rbrakk>\n    \\<Longrightarrow> {Var y EQ k,\n                       All2 y k\n                        (Var y SUBS k AND\n                         All2 z (Var y) (Var z SUBS Var y))} \\<turnstile>\n                      Var y SUBS SUCC k", "apply (metis Assume Subset_SUCC Subset_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom w \\<sharp> (k, y, z); atom y \\<sharp> (k, z);\n     atom z \\<sharp> k\\<rbrakk>\n    \\<Longrightarrow> {Var y EQ k,\n                       All2 y k\n                        (Var y SUBS k AND\n                         All2 z (Var y) (Var z SUBS Var y))} \\<turnstile>\n                      Var y SUBS SUCC k", "apply (metis EQ_imp_SUBS Subset_SUCC Subset_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {Var y IN SUCC k, OrdP k} \\<turnstile> Var y SUBS SUCC k\n\ngoal (1 subgoal):\n 1. {OrdP k} \\<turnstile> OrdP (SUCC k)", "have in_case: \"{Var y IN k, Var z IN Var y, OrdP k} \\<turnstile> Var z SUBS Var y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Var y IN k, Var z IN Var y, OrdP k} \\<turnstile> Var z SUBS Var y", "apply (rule OrdP_Mem_E [of w _ \"Var y\", THEN rotate3])"], ["proof (prove)\ngoal (3 subgoals):\n 1. atom w \\<sharp> (k, Var y)\n 2. {OrdP k, Var y IN k, Var z IN Var y} \\<turnstile> Var y IN k\n 3. {Var y SUBS k, All2 w (Var y) (Var w SUBS Var y), Var y IN k,\n     Var z IN Var y} \\<turnstile>\n    Var z SUBS Var y", "using atoms"], ["proof (prove)\nusing this:\n  atom w \\<sharp> (k, y, z)\n  atom y \\<sharp> (k, z)\n  atom z \\<sharp> k\n\ngoal (3 subgoals):\n 1. atom w \\<sharp> (k, Var y)\n 2. {OrdP k, Var y IN k, Var z IN Var y} \\<turnstile> Var y IN k\n 3. {Var y SUBS k, All2 w (Var y) (Var w SUBS Var y), Var y IN k,\n     Var z IN Var y} \\<turnstile>\n    Var z SUBS Var y", "apply (auto intro:  All2_E [THEN thin1])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {Var y IN k, Var z IN Var y, OrdP k} \\<turnstile> Var z SUBS Var y\n\ngoal (1 subgoal):\n 1. {OrdP k} \\<turnstile> OrdP (SUCC k)", "have \"{Var y EQ k, Var z IN k, OrdP k} \\<turnstile> Var z SUBS Var y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Var y EQ k, Var z IN k, OrdP k} \\<turnstile> Var z SUBS Var y", "by (metis AssumeH(2) AssumeH(3) EQ_imp_SUBS2 OrdP_Mem_imp_Subset Subset_trans)"], ["proof (state)\nthis:\n  {Var y EQ k, Var z IN k, OrdP k} \\<turnstile> Var z SUBS Var y\n\ngoal (1 subgoal):\n 1. {OrdP k} \\<turnstile> OrdP (SUCC k)", "hence eq_case: \"{Var y EQ k, Var z IN Var y, OrdP k} \\<turnstile> Var z SUBS Var y\""], ["proof (prove)\nusing this:\n  {Var y EQ k, Var z IN k, OrdP k} \\<turnstile> Var z SUBS Var y\n\ngoal (1 subgoal):\n 1. {Var y EQ k, Var z IN Var y, OrdP k} \\<turnstile> Var z SUBS Var y", "by (rule cut3) (auto intro: EQ_imp_SUBS [THEN cut1] Subset_D)"], ["proof (state)\nthis:\n  {Var y EQ k, Var z IN Var y, OrdP k} \\<turnstile> Var z SUBS Var y\n\ngoal (1 subgoal):\n 1. {OrdP k} \\<turnstile> OrdP (SUCC k)", "have 2: \"{Var z IN Var y, Var y IN SUCC k, OrdP k} \\<turnstile> Var z SUBS Var y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Var z IN Var y, Var y IN SUCC k, OrdP k} \\<turnstile> Var z SUBS Var y", "by (metis rotate2 Mem_SUCC_E in_case eq_case)"], ["proof (state)\nthis:\n  {Var z IN Var y, Var y IN SUCC k, OrdP k} \\<turnstile> Var z SUBS Var y\n\ngoal (1 subgoal):\n 1. {OrdP k} \\<turnstile> OrdP (SUCC k)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. {OrdP k} \\<turnstile> OrdP (SUCC k)", "apply (rule OrdP_I [OF 1 2])"], ["proof (prove)\ngoal (4 subgoals):\n 1. atom y \\<sharp> (SUCC k, z)\n 2. \\<forall>B\\<in>{OrdP k}. atom y \\<sharp> B\n 3. atom z \\<sharp> SUCC k\n 4. \\<forall>B\\<in>{OrdP k}. atom z \\<sharp> B", "using atoms"], ["proof (prove)\nusing this:\n  atom w \\<sharp> (k, y, z)\n  atom y \\<sharp> (k, z)\n  atom z \\<sharp> k\n\ngoal (4 subgoals):\n 1. atom y \\<sharp> (SUCC k, z)\n 2. \\<forall>B\\<in>{OrdP k}. atom y \\<sharp> B\n 3. atom z \\<sharp> SUCC k\n 4. \\<forall>B\\<in>{OrdP k}. atom z \\<sharp> B", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {OrdP k} \\<turnstile> OrdP (SUCC k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OrdP_SUCC_I: \"H \\<turnstile> OrdP k \\<Longrightarrow> H \\<turnstile> OrdP (SUCC k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> OrdP k \\<Longrightarrow> H \\<turnstile> OrdP (SUCC k)", "by (metis OrdP_SUCC_I0 cut1)"], ["", "lemma Zero_In_OrdP: \"{ OrdP x } \\<turnstile> x EQ Zero OR Zero IN x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {OrdP x} \\<turnstile> x EQ Zero OR Zero IN x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {OrdP x} \\<turnstile> x EQ Zero OR Zero IN x", "obtain i::name and j::name\n    where i: \"atom i \\<sharp> x\" and j: \"atom j \\<sharp> (x,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>atom i \\<sharp> x; atom j \\<sharp> (x, i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom i \\<sharp> x\n  atom j \\<sharp> (x, i)\n\ngoal (1 subgoal):\n 1. {OrdP x} \\<turnstile> x EQ Zero OR Zero IN x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. {OrdP x} \\<turnstile> x EQ Zero OR Zero IN x", "apply (rule cut_thin [where HB = \"{OrdP x}\", OF Foundation [where i=i and z = x]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. atom i \\<sharp> x\n 2. {All2 i x (Neg (Disjoint (Var i) x)) IMP x EQ Zero, OrdP x} \\<turnstile>\n    x EQ Zero OR Zero IN x\n 3. {} \\<union> {OrdP x} \\<subseteq> {OrdP x}", "using i j"], ["proof (prove)\nusing this:\n  atom i \\<sharp> x\n  atom j \\<sharp> (x, i)\n\ngoal (3 subgoals):\n 1. atom i \\<sharp> x\n 2. {All2 i x (Neg (Disjoint (Var i) x)) IMP x EQ Zero, OrdP x} \\<turnstile>\n    x EQ Zero OR Zero IN x\n 3. {} \\<union> {OrdP x} \\<subseteq> {OrdP x}", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom i \\<sharp> x; atom j \\<sharp> (x, i)\\<rbrakk>\n    \\<Longrightarrow> {Disjoint (Var i) x, Var i IN x,\n                       All2 j x\n                        (Var j SUBS x AND\n                         All2 i (Var j) (Var i SUBS Var j))} \\<turnstile>\n                      x EQ Zero OR Zero IN x\n 2. \\<lbrakk>atom i \\<sharp> x; atom j \\<sharp> (x, i)\\<rbrakk>\n    \\<Longrightarrow> {x EQ Zero,\n                       All2 j x\n                        (Var j SUBS x AND\n                         All2 i (Var j) (Var i SUBS Var j))} \\<turnstile>\n                      x EQ Zero OR Zero IN x", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom i \\<sharp> x; atom j \\<sharp> (x, i)\\<rbrakk>\n    \\<Longrightarrow> {x EQ Zero,\n                       All2 j x\n                        (Var j SUBS x AND\n                         All2 i (Var j) (Var i SUBS Var j))} \\<turnstile>\n                      x EQ Zero OR Zero IN x\n 2. \\<lbrakk>atom i \\<sharp> x; atom j \\<sharp> (x, i)\\<rbrakk>\n    \\<Longrightarrow> {Disjoint (Var i) x, Var i IN x,\n                       All2 j x\n                        (Var j SUBS x AND\n                         All2 i (Var j) (Var i SUBS Var j))} \\<turnstile>\n                      x EQ Zero OR Zero IN x", "apply (metis Assume Disj_I1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom i \\<sharp> x; atom j \\<sharp> (x, i)\\<rbrakk>\n    \\<Longrightarrow> {Disjoint (Var i) x, Var i IN x,\n                       All2 j x\n                        (Var j SUBS x AND\n                         All2 i (Var j) (Var i SUBS Var j))} \\<turnstile>\n                      x EQ Zero OR Zero IN x", "apply (rule Disj_I2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom i \\<sharp> x; atom j \\<sharp> (x, i)\\<rbrakk>\n    \\<Longrightarrow> {Disjoint (Var i) x, Var i IN x,\n                       All2 j x\n                        (Var j SUBS x AND\n                         All2 i (Var j) (Var i SUBS Var j))} \\<turnstile>\n                      Zero IN x", "apply (rule cut_same [where A = \"Var i EQ Zero\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom i \\<sharp> x; atom j \\<sharp> (x, i)\\<rbrakk>\n    \\<Longrightarrow> {Disjoint (Var i) x, Var i IN x,\n                       All2 j x\n                        (Var j SUBS x AND\n                         All2 i (Var j) (Var i SUBS Var j))} \\<turnstile>\n                      Var i EQ Zero\n 2. \\<lbrakk>atom i \\<sharp> x; atom j \\<sharp> (x, i)\\<rbrakk>\n    \\<Longrightarrow> {Var i EQ Zero, Disjoint (Var i) x, Var i IN x,\n                       All2 j x\n                        (Var j SUBS x AND\n                         All2 i (Var j) (Var i SUBS Var j))} \\<turnstile>\n                      Zero IN x", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom i \\<sharp> x; atom j \\<sharp> (x, i)\\<rbrakk>\n    \\<Longrightarrow> {Var i EQ Zero, Disjoint (Var i) x, Var i IN x,\n                       All2 j x\n                        (Var j SUBS x AND\n                         All2 i (Var j) (Var i SUBS Var j))} \\<turnstile>\n                      Zero IN x\n 2. \\<lbrakk>atom i \\<sharp> x; atom j \\<sharp> (x, i)\\<rbrakk>\n    \\<Longrightarrow> {Disjoint (Var i) x, Var i IN x,\n                       All2 j x\n                        (Var j SUBS x AND\n                         All2 i (Var j) (Var i SUBS Var j))} \\<turnstile>\n                      Var i EQ Zero", "apply (blast intro: Iff_MP_same [OF Mem_cong [OF Assume Refl]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom i \\<sharp> x; atom j \\<sharp> (x, i)\\<rbrakk>\n    \\<Longrightarrow> {Disjoint (Var i) x, Var i IN x,\n                       All2 j x\n                        (Var j SUBS x AND\n                         All2 i (Var j) (Var i SUBS Var j))} \\<turnstile>\n                      Var i EQ Zero", "apply (auto intro!: Eq_Zero_I [where i=j] Ex_I [where x=\"Var i\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom i \\<sharp> x; atom j \\<sharp> (x, i)\\<rbrakk>\n    \\<Longrightarrow> {Var i SUBS x, Var j IN Var i, Disjoint (Var i) x,\n                       Var i IN x} \\<turnstile>\n                      (SyntaxN.Ex i\n                        (Neg (Var i IN Var j IMP\n                              Var i SUBS Var j)))(j::=Var i)", "apply (blast intro: Disjoint_E Subset_D)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {OrdP x} \\<turnstile> x EQ Zero OR Zero IN x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OrdP_HPairE: \"insert (OrdP (HPair x y)) H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (OrdP (HPair x y)) H \\<turnstile> A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. insert (OrdP (HPair x y)) H \\<turnstile> A", "have \"{ OrdP (HPair x y) } \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {OrdP (HPair x y)} \\<turnstile> A", "by (rule cut_same [OF Zero_In_OrdP]) (auto simp: HPair_def)"], ["proof (state)\nthis:\n  {OrdP (HPair x y)} \\<turnstile> A\n\ngoal (1 subgoal):\n 1. insert (OrdP (HPair x y)) H \\<turnstile> A", "thus ?thesis"], ["proof (prove)\nusing this:\n  {OrdP (HPair x y)} \\<turnstile> A\n\ngoal (1 subgoal):\n 1. insert (OrdP (HPair x y)) H \\<turnstile> A", "by (metis Assume cut1)"], ["proof (state)\nthis:\n  insert (OrdP (HPair x y)) H \\<turnstile> A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas OrdP_HPairEH = OrdP_HPairE OrdP_HPairE [THEN rotate2] OrdP_HPairE [THEN rotate3] OrdP_HPairE [THEN rotate4] OrdP_HPairE [THEN rotate5] \n                 OrdP_HPairE [THEN rotate6] OrdP_HPairE [THEN rotate7] OrdP_HPairE [THEN rotate8] OrdP_HPairE [THEN rotate9] OrdP_HPairE [THEN rotate10]"], ["", "declare OrdP_HPairEH [intro!]"], ["", "lemma Zero_Eq_HPairE: \"insert (Zero EQ HPair x y) H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (Zero EQ HPair x y) H \\<turnstile> A", "by (metis Eats_EQ_Zero_E2 HPair_def)"], ["", "lemmas Zero_Eq_HPairEH = Zero_Eq_HPairE Zero_Eq_HPairE [THEN rotate2] Zero_Eq_HPairE [THEN rotate3] Zero_Eq_HPairE [THEN rotate4] Zero_Eq_HPairE [THEN rotate5] \n                 Zero_Eq_HPairE [THEN rotate6] Zero_Eq_HPairE [THEN rotate7] Zero_Eq_HPairE [THEN rotate8] Zero_Eq_HPairE [THEN rotate9] Zero_Eq_HPairE [THEN rotate10]"], ["", "declare Zero_Eq_HPairEH [intro!]"], ["", "lemma HPair_Eq_ZeroE: \"insert (HPair x y EQ Zero) H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (HPair x y EQ Zero) H \\<turnstile> A", "by (metis Sym_L Zero_Eq_HPairE)"], ["", "lemmas HPair_Eq_ZeroEH = HPair_Eq_ZeroE HPair_Eq_ZeroE [THEN rotate2] HPair_Eq_ZeroE [THEN rotate3] HPair_Eq_ZeroE [THEN rotate4] HPair_Eq_ZeroE [THEN rotate5] \n                 HPair_Eq_ZeroE [THEN rotate6] HPair_Eq_ZeroE [THEN rotate7] HPair_Eq_ZeroE [THEN rotate8] HPair_Eq_ZeroE [THEN rotate9] HPair_Eq_ZeroE [THEN rotate10]"], ["", "declare HPair_Eq_ZeroEH [intro!]"], ["", "section \\<open>Induction on Ordinals\\<close>"], ["", "lemma OrdInd_lemma:\n  assumes j: \"atom (j::name) \\<sharp> (i,A)\"\n  shows \"{ OrdP (Var i) } \\<turnstile> (All i (OrdP (Var i) IMP ((All2 j (Var i) (A(i::= Var j))) IMP A))) IMP A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {OrdP (Var i)} \\<turnstile>\n    SyntaxN.All i (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A) IMP\n    A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {OrdP (Var i)} \\<turnstile>\n    SyntaxN.All i (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A) IMP\n    A", "obtain l::name and k::name\n      where l: \"atom l \\<sharp> (i,j,A)\" and k: \"atom k \\<sharp> (i,j,l,A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l k.\n        \\<lbrakk>atom l \\<sharp> (i, j, A);\n         atom k \\<sharp> (i, j, l, A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom l \\<sharp> (i, j, A)\n  atom k \\<sharp> (i, j, l, A)\n\ngoal (1 subgoal):\n 1. {OrdP (Var i)} \\<turnstile>\n    SyntaxN.All i (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A) IMP\n    A", "have \"{ (All i (OrdP (Var i) IMP ((All2 j (Var i) (A(i::= Var j))) IMP A))) } \n        \\<turnstile> (All2 l (Var i) (OrdP (Var l) IMP A(i::= Var l)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {SyntaxN.All i\n      (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A)} \\<turnstile>\n    All2 l (Var i) (OrdP (Var l) IMP A(i::=Var l))", "apply (rule Ind [of k])"], ["proof (prove)\ngoal (3 subgoals):\n 1. atom k \\<sharp> (?i, All2 l (Var i) (OrdP (Var l) IMP A(i::=Var l)))\n 2. {SyntaxN.All i\n      (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A)} \\<turnstile>\n    (All2 l (Var i) (OrdP (Var l) IMP A(i::=Var l)))(?i::=Zero)\n 3. {SyntaxN.All i\n      (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A)} \\<turnstile>\n    SyntaxN.All ?i\n     (SyntaxN.All k\n       (All2 l (Var i) (OrdP (Var l) IMP A(i::=Var l)) IMP\n        (All2 l (Var i) (OrdP (Var l) IMP A(i::=Var l)))(?i::=Var k) IMP\n        (All2 l (Var i)\n          (OrdP (Var l) IMP A(i::=Var l)))(?i::=Eats (Var ?i) (Var k))))", "using j k l"], ["proof (prove)\nusing this:\n  atom j \\<sharp> (i, A)\n  atom k \\<sharp> (i, j, l, A)\n  atom l \\<sharp> (i, j, A)\n\ngoal (3 subgoals):\n 1. atom k \\<sharp> (?i, All2 l (Var i) (OrdP (Var l) IMP A(i::=Var l)))\n 2. {SyntaxN.All i\n      (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A)} \\<turnstile>\n    (All2 l (Var i) (OrdP (Var l) IMP A(i::=Var l)))(?i::=Zero)\n 3. {SyntaxN.All i\n      (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A)} \\<turnstile>\n    SyntaxN.All ?i\n     (SyntaxN.All k\n       (All2 l (Var i) (OrdP (Var l) IMP A(i::=Var l)) IMP\n        (All2 l (Var i) (OrdP (Var l) IMP A(i::=Var l)))(?i::=Var k) IMP\n        (All2 l (Var i)\n          (OrdP (Var l) IMP A(i::=Var l)))(?i::=Eats (Var ?i) (Var k))))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, l, A);\n     atom l \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {Var l IN Var i, Neg (A(i::=Var l)), OrdP (Var l),\n                       All2 l (Var k) (OrdP (Var l) IMP A(i::=Var l)),\n                       All2 l (Var i)\n                        (OrdP (Var l) IMP A(i::=Var l))} \\<turnstile>\n                      SyntaxN.Ex i\n                       (Neg (OrdP (Var i) IMP\n                             All2 j (Var i) (A(i::=Var j)) IMP A))\n 2. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, l, A);\n     atom l \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {Var l EQ Var k, Neg (A(i::=Var l)), OrdP (Var l),\n                       All2 l (Var k) (OrdP (Var l) IMP A(i::=Var l)),\n                       All2 l (Var i)\n                        (OrdP (Var l) IMP A(i::=Var l))} \\<turnstile>\n                      SyntaxN.Ex i\n                       (Neg (OrdP (Var i) IMP\n                             All2 j (Var i) (A(i::=Var j)) IMP A))", "apply (rule All_E [where x=\"Var l\", THEN rotate5], auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, l, A);\n     atom l \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {A(i::=Var l), Var l IN Var i, Neg (A(i::=Var l)),\n                       OrdP (Var l),\n                       All2 l (Var k)\n                        (OrdP (Var l) IMP A(i::=Var l))} \\<turnstile>\n                      SyntaxN.Ex i\n                       (Neg (OrdP (Var i) IMP\n                             All2 j (Var i) (A(i::=Var j)) IMP A))\n 2. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, l, A);\n     atom l \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {Var l EQ Var k, Neg (A(i::=Var l)), OrdP (Var l),\n                       All2 l (Var k) (OrdP (Var l) IMP A(i::=Var l)),\n                       All2 l (Var i)\n                        (OrdP (Var l) IMP A(i::=Var l))} \\<turnstile>\n                      SyntaxN.Ex i\n                       (Neg (OrdP (Var i) IMP\n                             All2 j (Var i) (A(i::=Var j)) IMP A))", "apply (metis Assume Disj_I1 anti_deduction thin1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, l, A);\n     atom l \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {Var l EQ Var k, Neg (A(i::=Var l)), OrdP (Var l),\n                       All2 l (Var k) (OrdP (Var l) IMP A(i::=Var l)),\n                       All2 l (Var i)\n                        (OrdP (Var l) IMP A(i::=Var l))} \\<turnstile>\n                      SyntaxN.Ex i\n                       (Neg (OrdP (Var i) IMP\n                             All2 j (Var i) (A(i::=Var j)) IMP A))", "apply (rule Ex_I [where x=\"Var l\"], auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, l, A);\n     atom l \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {Neg (A(i::=Var j)), Var j IN Var l, Var l EQ Var k,\n                       Neg (A(i::=Var l)), OrdP (Var l),\n                       All2 l (Var k)\n                        (OrdP (Var l) IMP A(i::=Var l))} \\<turnstile>\n                      SyntaxN.Ex l\n                       (Neg (Var l IN Var i IMP\n                             OrdP (Var l) IMP A(i::=Var l)))\n 2. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, l, A);\n     atom l \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {A(i::=Var l), Var l EQ Var k, Neg (A(i::=Var l)),\n                       OrdP (Var l),\n                       All2 l (Var k)\n                        (OrdP (Var l) IMP A(i::=Var l))} \\<turnstile>\n                      SyntaxN.Ex l\n                       (Neg (Var l IN Var i IMP\n                             OrdP (Var l) IMP A(i::=Var l)))", "apply (rule All_E [where x=\"Var j\", THEN rotate6], auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, l, A);\n     atom l \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {Neg (Var j IN Var k), Neg (A(i::=Var j)),\n                       Var j IN Var l, Var l EQ Var k, Neg (A(i::=Var l)),\n                       OrdP (Var l)} \\<turnstile>\n                      SyntaxN.Ex l\n                       (Neg (Var l IN Var i IMP\n                             OrdP (Var l) IMP A(i::=Var l)))\n 2. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, l, A);\n     atom l \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {Neg (OrdP (Var j)), Neg (A(i::=Var j)),\n                       Var j IN Var l, Var l EQ Var k, Neg (A(i::=Var l)),\n                       OrdP (Var l)} \\<turnstile>\n                      SyntaxN.Ex l\n                       (Neg (Var l IN Var i IMP\n                             OrdP (Var l) IMP A(i::=Var l)))\n 3. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, l, A);\n     atom l \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {A(i::=Var j), Neg (A(i::=Var j)), Var j IN Var l,\n                       Var l EQ Var k, Neg (A(i::=Var l)),\n                       OrdP (Var l)} \\<turnstile>\n                      SyntaxN.Ex l\n                       (Neg (Var l IN Var i IMP\n                             OrdP (Var l) IMP A(i::=Var l)))\n 4. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, l, A);\n     atom l \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {A(i::=Var l), Var l EQ Var k, Neg (A(i::=Var l)),\n                       OrdP (Var l),\n                       All2 l (Var k)\n                        (OrdP (Var l) IMP A(i::=Var l))} \\<turnstile>\n                      SyntaxN.Ex l\n                       (Neg (Var l IN Var i IMP\n                             OrdP (Var l) IMP A(i::=Var l)))", "apply (blast intro: ContraProve Iff_MP_same [OF Mem_cong [OF Refl]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, l, A);\n     atom l \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {Neg (OrdP (Var j)), Neg (A(i::=Var j)),\n                       Var j IN Var l, Var l EQ Var k, Neg (A(i::=Var l)),\n                       OrdP (Var l)} \\<turnstile>\n                      SyntaxN.Ex l\n                       (Neg (Var l IN Var i IMP\n                             OrdP (Var l) IMP A(i::=Var l)))\n 2. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, l, A);\n     atom l \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {A(i::=Var j), Neg (A(i::=Var j)), Var j IN Var l,\n                       Var l EQ Var k, Neg (A(i::=Var l)),\n                       OrdP (Var l)} \\<turnstile>\n                      SyntaxN.Ex l\n                       (Neg (Var l IN Var i IMP\n                             OrdP (Var l) IMP A(i::=Var l)))\n 3. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, l, A);\n     atom l \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {A(i::=Var l), Var l EQ Var k, Neg (A(i::=Var l)),\n                       OrdP (Var l),\n                       All2 l (Var k)\n                        (OrdP (Var l) IMP A(i::=Var l))} \\<turnstile>\n                      SyntaxN.Ex l\n                       (Neg (Var l IN Var i IMP\n                             OrdP (Var l) IMP A(i::=Var l)))", "apply (metis Assume Ord_IN_Ord0 ContraProve insert_commute)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, l, A);\n     atom l \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {A(i::=Var j), Neg (A(i::=Var j)), Var j IN Var l,\n                       Var l EQ Var k, Neg (A(i::=Var l)),\n                       OrdP (Var l)} \\<turnstile>\n                      SyntaxN.Ex l\n                       (Neg (Var l IN Var i IMP\n                             OrdP (Var l) IMP A(i::=Var l)))\n 2. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, l, A);\n     atom l \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {A(i::=Var l), Var l EQ Var k, Neg (A(i::=Var l)),\n                       OrdP (Var l),\n                       All2 l (Var k)\n                        (OrdP (Var l) IMP A(i::=Var l))} \\<turnstile>\n                      SyntaxN.Ex l\n                       (Neg (Var l IN Var i IMP\n                             OrdP (Var l) IMP A(i::=Var l)))", "apply (metis Assume Neg_D thin1)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {SyntaxN.All i\n    (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A)} \\<turnstile>\n  All2 l (Var i) (OrdP (Var l) IMP A(i::=Var l))\n\ngoal (1 subgoal):\n 1. {OrdP (Var i)} \\<turnstile>\n    SyntaxN.All i (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A) IMP\n    A", "hence \"{ (All i (OrdP (Var i) IMP ((All2 j (Var i) (A(i::= Var j))) IMP A))) } \n          \\<turnstile> (All2 l (Var i) (OrdP (Var l) IMP A(i::= Var l)))(i::= Eats Zero (Var i))\""], ["proof (prove)\nusing this:\n  {SyntaxN.All i\n    (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A)} \\<turnstile>\n  All2 l (Var i) (OrdP (Var l) IMP A(i::=Var l))\n\ngoal (1 subgoal):\n 1. {SyntaxN.All i\n      (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A)} \\<turnstile>\n    (All2 l (Var i) (OrdP (Var l) IMP A(i::=Var l)))(i::=Eats Zero (Var i))", "by (rule Subst, auto)"], ["proof (state)\nthis:\n  {SyntaxN.All i\n    (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A)} \\<turnstile>\n  (All2 l (Var i) (OrdP (Var l) IMP A(i::=Var l)))(i::=Eats Zero (Var i))\n\ngoal (1 subgoal):\n 1. {OrdP (Var i)} \\<turnstile>\n    SyntaxN.All i (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A) IMP\n    A", "hence indlem: \"{ All i (OrdP (Var i) IMP ((All2 j (Var i) (A(i::= Var j))) IMP A)) } \n             \\<turnstile> All2 l (Eats Zero (Var i)) (OrdP (Var l) IMP A(i::=Var l))\""], ["proof (prove)\nusing this:\n  {SyntaxN.All i\n    (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A)} \\<turnstile>\n  (All2 l (Var i) (OrdP (Var l) IMP A(i::=Var l)))(i::=Eats Zero (Var i))\n\ngoal (1 subgoal):\n 1. {SyntaxN.All i\n      (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A)} \\<turnstile>\n    All2 l (Eats Zero (Var i)) (OrdP (Var l) IMP A(i::=Var l))", "using j l"], ["proof (prove)\nusing this:\n  {SyntaxN.All i\n    (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A)} \\<turnstile>\n  (All2 l (Var i) (OrdP (Var l) IMP A(i::=Var l)))(i::=Eats Zero (Var i))\n  atom j \\<sharp> (i, A)\n  atom l \\<sharp> (i, j, A)\n\ngoal (1 subgoal):\n 1. {SyntaxN.All i\n      (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A)} \\<turnstile>\n    All2 l (Eats Zero (Var i)) (OrdP (Var l) IMP A(i::=Var l))", "by simp"], ["proof (state)\nthis:\n  {SyntaxN.All i\n    (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A)} \\<turnstile>\n  All2 l (Eats Zero (Var i)) (OrdP (Var l) IMP A(i::=Var l))\n\ngoal (1 subgoal):\n 1. {OrdP (Var i)} \\<turnstile>\n    SyntaxN.All i (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A) IMP\n    A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. {OrdP (Var i)} \\<turnstile>\n    SyntaxN.All i (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A) IMP\n    A", "apply (rule Imp_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {SyntaxN.All i (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A),\n     OrdP (Var i)} \\<turnstile>\n    A", "apply (rule cut_thin [OF indlem, where HB = \"{OrdP (Var i)}\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. {All2 l (Eats Zero (Var i)) (OrdP (Var l) IMP A(i::=Var l)),\n     OrdP (Var i)} \\<turnstile>\n    A\n 2. {SyntaxN.All i\n      (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A)} \\<union>\n    {OrdP (Var i)}\n    \\<subseteq> {SyntaxN.All i\n                  (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A),\n                 OrdP (Var i)}", "apply (rule All2_Eats_E)"], ["proof (prove)\ngoal (3 subgoals):\n 1. atom l \\<sharp> (Zero, Var i)\n 2. {All2 l Zero (OrdP (Var l) IMP A(i::=Var l)),\n     (OrdP (Var l) IMP A(i::=Var l))(l::=Var i), OrdP (Var i)} \\<turnstile>\n    A\n 3. {SyntaxN.All i\n      (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A)} \\<union>\n    {OrdP (Var i)}\n    \\<subseteq> {SyntaxN.All i\n                  (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A),\n                 OrdP (Var i)}", "using j l"], ["proof (prove)\nusing this:\n  atom j \\<sharp> (i, A)\n  atom l \\<sharp> (i, j, A)\n\ngoal (3 subgoals):\n 1. atom l \\<sharp> (Zero, Var i)\n 2. {All2 l Zero (OrdP (Var l) IMP A(i::=Var l)),\n     (OrdP (Var l) IMP A(i::=Var l))(l::=Var i), OrdP (Var i)} \\<turnstile>\n    A\n 3. {SyntaxN.All i\n      (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A)} \\<union>\n    {OrdP (Var i)}\n    \\<subseteq> {SyntaxN.All i\n                  (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A),\n                 OrdP (Var i)}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {OrdP (Var i)} \\<turnstile>\n  SyntaxN.All i (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A) IMP A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OrdInd:\n  assumes j: \"atom (j::name) \\<sharp> (i,A)\"\n  and x: \"H \\<turnstile> OrdP (Var i)\" and step: \"H \\<turnstile> All i (OrdP (Var i) IMP (All2 j (Var i) (A(i::= Var j)) IMP A))\"\n  shows \"H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> A", "apply (rule cut_thin [OF x, where HB=H])"], ["proof (prove)\ngoal (2 subgoals):\n 1. insert (OrdP (Var i)) H \\<turnstile> A\n 2. H \\<union> H \\<subseteq> H", "apply (rule MP_thin [OF OrdInd_lemma step])"], ["proof (prove)\ngoal (3 subgoals):\n 1. atom j \\<sharp> (i, A)\n 2. {OrdP (Var i)} \\<union> H \\<subseteq> insert (OrdP (Var i)) H\n 3. H \\<union> H \\<subseteq> H", "apply (auto simp: j)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma OrdIndH:\n  assumes \"atom (j::name) \\<sharp> (i,A)\"\n      and \"H \\<turnstile> All i (OrdP (Var i) IMP (All2 j (Var i) (A(i::= Var j)) IMP A))\"\n    shows \"insert (OrdP (Var i)) H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (OrdP (Var i)) H \\<turnstile> A", "by (metis assms thin1 Assume OrdInd)"], ["", "section \\<open>Linearity of Ordinals\\<close>"], ["", "lemma OrdP_linear_lemma:\n  assumes j: \"atom j \\<sharp> i\"\n  shows \"{ OrdP (Var i) } \\<turnstile> All j (OrdP (Var j) IMP (Var i IN Var j OR Var i EQ Var j OR Var j IN Var i))\"\n         (is \"_ \\<turnstile> ?scheme\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {OrdP (Var i)} \\<turnstile>\n    SyntaxN.All j\n     (OrdP (Var j) IMP Var i IN Var j OR Var i EQ Var j OR Var j IN Var i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {OrdP (Var i)} \\<turnstile>\n    SyntaxN.All j\n     (OrdP (Var j) IMP Var i IN Var j OR Var i EQ Var j OR Var j IN Var i)", "obtain k::name and l::name and m::name\n    where k: \"atom k \\<sharp> (i,j)\" and l: \"atom l \\<sharp> (i,j,k)\" and m: \"atom m \\<sharp> (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k l m.\n        \\<lbrakk>atom k \\<sharp> (i, j); atom l \\<sharp> (i, j, k);\n         atom m \\<sharp> (i, j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom k \\<sharp> (i, j)\n  atom l \\<sharp> (i, j, k)\n  atom m \\<sharp> (i, j)\n\ngoal (1 subgoal):\n 1. {OrdP (Var i)} \\<turnstile>\n    SyntaxN.All j\n     (OrdP (Var j) IMP Var i IN Var j OR Var i EQ Var j OR Var j IN Var i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. {OrdP (Var i)} \\<turnstile>\n    SyntaxN.All j\n     (OrdP (Var j) IMP Var i IN Var j OR Var i EQ Var j OR Var j IN Var i)", "proof (rule OrdIndH [where i=i and j=k])"], ["proof (state)\ngoal (2 subgoals):\n 1. atom\n     k \\<sharp> (i, SyntaxN.All j\n                     (OrdP (Var j) IMP\n                      Var i IN Var j OR Var i EQ Var j OR Var j IN Var i))\n 2. {} \\<turnstile>\n    SyntaxN.All i\n     (OrdP (Var i) IMP\n      All2 k (Var i)\n       ((SyntaxN.All j\n          (OrdP (Var j) IMP\n           Var i IN Var j OR\n           Var i EQ Var j OR Var j IN Var i))(i::=Var k)) IMP\n      SyntaxN.All j\n       (OrdP (Var j) IMP\n        Var i IN Var j OR Var i EQ Var j OR Var j IN Var i))", "show \"atom k \\<sharp> (i, ?scheme)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom\n     k \\<sharp> (i, SyntaxN.All j\n                     (OrdP (Var j) IMP\n                      Var i IN Var j OR Var i EQ Var j OR Var j IN Var i))", "using k"], ["proof (prove)\nusing this:\n  atom k \\<sharp> (i, j)\n\ngoal (1 subgoal):\n 1. atom\n     k \\<sharp> (i, SyntaxN.All j\n                     (OrdP (Var j) IMP\n                      Var i IN Var j OR Var i EQ Var j OR Var j IN Var i))", "by (force simp add: fresh_Pair)"], ["proof (state)\nthis:\n  atom\n   k \\<sharp> (i, SyntaxN.All j\n                   (OrdP (Var j) IMP\n                    Var i IN Var j OR Var i EQ Var j OR Var j IN Var i))\n\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    SyntaxN.All i\n     (OrdP (Var i) IMP\n      All2 k (Var i)\n       ((SyntaxN.All j\n          (OrdP (Var j) IMP\n           Var i IN Var j OR\n           Var i EQ Var j OR Var j IN Var i))(i::=Var k)) IMP\n      SyntaxN.All j\n       (OrdP (Var j) IMP\n        Var i IN Var j OR Var i EQ Var j OR Var j IN Var i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    SyntaxN.All i\n     (OrdP (Var i) IMP\n      All2 k (Var i)\n       ((SyntaxN.All j\n          (OrdP (Var j) IMP\n           Var i IN Var j OR\n           Var i EQ Var j OR Var j IN Var i))(i::=Var k)) IMP\n      SyntaxN.All j\n       (OrdP (Var j) IMP\n        Var i IN Var j OR Var i EQ Var j OR Var j IN Var i))", "show \"{} \\<turnstile> All i (OrdP (Var i) IMP (All2 k (Var i) (?scheme(i::= Var k)) IMP ?scheme))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    SyntaxN.All i\n     (OrdP (Var i) IMP\n      All2 k (Var i)\n       ((SyntaxN.All j\n          (OrdP (Var j) IMP\n           Var i IN Var j OR\n           Var i EQ Var j OR Var j IN Var i))(i::=Var k)) IMP\n      SyntaxN.All j\n       (OrdP (Var j) IMP\n        Var i IN Var j OR Var i EQ Var j OR Var j IN Var i))", "using j k"], ["proof (prove)\nusing this:\n  atom j \\<sharp> i\n  atom k \\<sharp> (i, j)\n\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    SyntaxN.All i\n     (OrdP (Var i) IMP\n      All2 k (Var i)\n       ((SyntaxN.All j\n          (OrdP (Var j) IMP\n           Var i IN Var j OR\n           Var i EQ Var j OR Var j IN Var i))(i::=Var k)) IMP\n      SyntaxN.All j\n       (OrdP (Var j) IMP\n        Var i IN Var j OR Var i EQ Var j OR Var j IN Var i))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {} \\<turnstile>\n                      SyntaxN.All i\n                       (OrdP (Var i) IMP\n                        All2 k (Var i)\n                         (SyntaxN.All j\n                           (OrdP (Var j) IMP\n                            Var k IN Var j OR\n                            Var k EQ Var j OR Var j IN Var k)) IMP\n                        SyntaxN.All j\n                         (OrdP (Var j) IMP\n                          Var i IN Var j OR\n                          Var i EQ Var j OR Var j IN Var i))", "apply (rule All_I Imp_I)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {OrdP (Var j),\n                       All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      Var i IN Var j OR Var i EQ Var j OR Var j IN Var i\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>{All2 k (Var i)\n (SyntaxN.All j\n   (OrdP (Var j) IMP Var k IN Var j OR Var k EQ Var j OR Var j IN Var k)),\nOrdP (Var i)}.\n                         atom j \\<sharp> C\n 3. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>{}. atom i \\<sharp> C", "defer 1"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>{All2 k (Var i)\n (SyntaxN.All j\n   (OrdP (Var j) IMP Var k IN Var j OR Var k EQ Var j OR Var j IN Var k)),\nOrdP (Var i)}.\n                         atom j \\<sharp> C\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>{}. atom i \\<sharp> C\n 3. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {OrdP (Var j),\n                       All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      Var i IN Var j OR Var i EQ Var j OR Var j IN Var i", "apply auto [2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {OrdP (Var j),\n                       All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      Var i IN Var j OR Var i EQ Var j OR Var j IN Var i", "apply (rule OrdIndH [where i=j and j=l])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> atom\n                       l \\<sharp> (j, Var i IN Var j OR\nVar i EQ Var j OR Var j IN Var i)\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      SyntaxN.All j\n                       (OrdP (Var j) IMP\n                        All2 l (Var j)\n                         ((Var i IN Var j OR\n                           Var i EQ Var j OR Var j IN Var i)(j::=Var l)) IMP\n                        Var i IN Var j OR Var i EQ Var j OR Var j IN Var i)", "using l\n      \\<comment> \\<open>nested induction\\<close>"], ["proof (prove)\nusing this:\n  atom l \\<sharp> (i, j, k)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> atom\n                       l \\<sharp> (j, Var i IN Var j OR\nVar i EQ Var j OR Var j IN Var i)\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      SyntaxN.All j\n                       (OrdP (Var j) IMP\n                        All2 l (Var j)\n                         ((Var i IN Var j OR\n                           Var i EQ Var j OR Var j IN Var i)(j::=Var l)) IMP\n                        Var i IN Var j OR Var i EQ Var j OR Var j IN Var i)", "apply (force simp add: fresh_Pair)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      SyntaxN.All j\n                       (OrdP (Var j) IMP\n                        All2 l (Var j)\n                         ((Var i IN Var j OR\n                           Var i EQ Var j OR Var j IN Var i)(j::=Var l)) IMP\n                        Var i IN Var j OR Var i EQ Var j OR Var j IN Var i)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      SyntaxN.All j\n                       (OrdP (Var j) IMP\n                        All2 l (Var j)\n                         (Var i IN Var l OR\n                          Var i EQ Var l OR Var l IN Var i) IMP\n                        Var i IN Var j OR Var i EQ Var j OR Var j IN Var i)", "apply (rule All_I Imp_I)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {All2 l (Var j)\n                        (Var i IN Var l OR\n                         Var i EQ Var l OR Var l IN Var i),\n                       OrdP (Var j),\n                       All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      Var i IN Var j OR Var i EQ Var j OR Var j IN Var i\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>{All2 k (Var i)\n (SyntaxN.All j\n   (OrdP (Var j) IMP Var k IN Var j OR Var k EQ Var j OR Var j IN Var k)),\nOrdP (Var i)}.\n                         atom j \\<sharp> C", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>{All2 k (Var i)\n (SyntaxN.All j\n   (OrdP (Var j) IMP Var k IN Var j OR Var k EQ Var j OR Var j IN Var k)),\nOrdP (Var i)}.\n                         atom j \\<sharp> C\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {All2 l (Var j)\n                        (Var i IN Var l OR\n                         Var i EQ Var l OR Var l IN Var i),\n                       OrdP (Var j),\n                       All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      Var i IN Var j OR Var i EQ Var j OR Var j IN Var i", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {All2 l (Var j)\n                        (Var i IN Var l OR\n                         Var i EQ Var l OR Var l IN Var i),\n                       OrdP (Var j),\n                       All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      Var i IN Var j OR Var i EQ Var j OR Var j IN Var i", "apply (rule Disj_3I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {Neg (Var i IN Var j), Neg (Var j IN Var i),\n                       All2 l (Var j)\n                        (Var i IN Var l OR\n                         Var i EQ Var l OR Var l IN Var i),\n                       OrdP (Var j),\n                       All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      Var i EQ Var j", "apply (rule Equality_I)\n      \\<comment> \\<open>Now the opposite inclusion, @{term\"Var j SUBS Var i\"}\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {Neg (Var i IN Var j), Neg (Var j IN Var i),\n                       All2 l (Var j)\n                        (Var i IN Var l OR\n                         Var i EQ Var l OR Var l IN Var i),\n                       OrdP (Var j),\n                       All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      Var j SUBS Var i\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {Neg (Var i IN Var j), Neg (Var j IN Var i),\n                       All2 l (Var j)\n                        (Var i IN Var l OR\n                         Var i EQ Var l OR Var l IN Var i),\n                       OrdP (Var j),\n                       All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      Var i SUBS Var j", "apply (rule Subset_I [where i=m])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {Var m IN Var j, Neg (Var i IN Var j),\n                       Neg (Var j IN Var i),\n                       All2 l (Var j)\n                        (Var i IN Var l OR\n                         Var i EQ Var l OR Var l IN Var i),\n                       OrdP (Var j),\n                       All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      Var m IN Var i\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> atom m \\<sharp> (Var j, Var i)\n 3. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>B\\<in>{Neg (Var i IN Var j),\nNeg (Var j IN Var i),\nAll2 l (Var j) (Var i IN Var l OR Var i EQ Var l OR Var l IN Var i),\nOrdP (Var j),\nAll2 k (Var i)\n (SyntaxN.All j\n   (OrdP (Var j) IMP Var k IN Var j OR Var k EQ Var j OR Var j IN Var k)),\nOrdP (Var i)}.\n                         atom m \\<sharp> B\n 4. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {Neg (Var i IN Var j), Neg (Var j IN Var i),\n                       All2 l (Var j)\n                        (Var i IN Var l OR\n                         Var i EQ Var l OR Var l IN Var i),\n                       OrdP (Var j),\n                       All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      Var i SUBS Var j", "apply (rule All2_E [THEN rotate4])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> atom l \\<sharp> Var j\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {Var m IN Var j, Neg (Var i IN Var j),\n                       Neg (Var j IN Var i), OrdP (Var j),\n                       All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      ?x46 IN Var j\n 3. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {(Var i IN Var l OR\n                        Var i EQ Var l OR Var l IN Var i)(l::=?x46),\n                       Var m IN Var j, Neg (Var i IN Var j),\n                       Neg (Var j IN Var i), OrdP (Var j),\n                       All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      Var m IN Var i\n 4. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> atom m \\<sharp> (Var j, Var i)\n 5. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>B\\<in>{Neg (Var i IN Var j),\nNeg (Var j IN Var i),\nAll2 l (Var j) (Var i IN Var l OR Var i EQ Var l OR Var l IN Var i),\nOrdP (Var j),\nAll2 k (Var i)\n (SyntaxN.All j\n   (OrdP (Var j) IMP Var k IN Var j OR Var k EQ Var j OR Var j IN Var k)),\nOrdP (Var i)}.\n                         atom m \\<sharp> B\n 6. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {Neg (Var i IN Var j), Neg (Var j IN Var i),\n                       All2 l (Var j)\n                        (Var i IN Var l OR\n                         Var i EQ Var l OR Var l IN Var i),\n                       OrdP (Var j),\n                       All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      Var i SUBS Var j", "using l m"], ["proof (prove)\nusing this:\n  atom l \\<sharp> (i, j, k)\n  atom m \\<sharp> (i, j)\n\ngoal (6 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> atom l \\<sharp> Var j\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {Var m IN Var j, Neg (Var i IN Var j),\n                       Neg (Var j IN Var i), OrdP (Var j),\n                       All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      ?x46 IN Var j\n 3. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {(Var i IN Var l OR\n                        Var i EQ Var l OR Var l IN Var i)(l::=?x46),\n                       Var m IN Var j, Neg (Var i IN Var j),\n                       Neg (Var j IN Var i), OrdP (Var j),\n                       All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      Var m IN Var i\n 4. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> atom m \\<sharp> (Var j, Var i)\n 5. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>B\\<in>{Neg (Var i IN Var j),\nNeg (Var j IN Var i),\nAll2 l (Var j) (Var i IN Var l OR Var i EQ Var l OR Var l IN Var i),\nOrdP (Var j),\nAll2 k (Var i)\n (SyntaxN.All j\n   (OrdP (Var j) IMP Var k IN Var j OR Var k EQ Var j OR Var j IN Var k)),\nOrdP (Var i)}.\n                         atom m \\<sharp> B\n 6. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {Neg (Var i IN Var j), Neg (Var j IN Var i),\n                       All2 l (Var j)\n                        (Var i IN Var l OR\n                         Var i EQ Var l OR Var l IN Var i),\n                       OrdP (Var j),\n                       All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      Var i SUBS Var j", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k); atom m \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {Var i IN Var m, Var m IN Var j, Neg (Var i IN Var j),\n                       Neg (Var j IN Var i), OrdP (Var j),\n                       All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      Var m IN Var i\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k); atom m \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {Var i EQ Var m, Var m IN Var j, Neg (Var i IN Var j),\n                       Neg (Var j IN Var i), OrdP (Var j),\n                       All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      Var m IN Var i\n 3. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k); atom m \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {Neg (Var i IN Var j), Neg (Var j IN Var i),\n                       All2 l (Var j)\n                        (Var i IN Var l OR\n                         Var i EQ Var l OR Var l IN Var i),\n                       OrdP (Var j),\n                       All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      Var i SUBS Var j", "apply (blast intro: ContraProve [THEN rotate3] OrdP_Trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k); atom m \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {Var i EQ Var m, Var m IN Var j, Neg (Var i IN Var j),\n                       Neg (Var j IN Var i), OrdP (Var j),\n                       All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      Var m IN Var i\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k); atom m \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {Neg (Var i IN Var j), Neg (Var j IN Var i),\n                       All2 l (Var j)\n                        (Var i IN Var l OR\n                         Var i EQ Var l OR Var l IN Var i),\n                       OrdP (Var j),\n                       All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      Var i SUBS Var j", "apply (blast intro: ContraProve [THEN rotate3] Mem_cong [OF Hyp Refl, THEN Iff_MP2_same])\n      \\<comment> \\<open>Now the opposite inclusion, @{term\"Var i SUBS Var j\"}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k); atom m \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {Neg (Var i IN Var j), Neg (Var j IN Var i),\n                       All2 l (Var j)\n                        (Var i IN Var l OR\n                         Var i EQ Var l OR Var l IN Var i),\n                       OrdP (Var j),\n                       All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      Var i SUBS Var j", "apply (rule Subset_I [where i=m])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k); atom m \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {Var m IN Var i, Neg (Var i IN Var j),\n                       Neg (Var j IN Var i),\n                       All2 l (Var j)\n                        (Var i IN Var l OR\n                         Var i EQ Var l OR Var l IN Var i),\n                       OrdP (Var j),\n                       All2 k (Var i)\n                        (SyntaxN.All j\n                          (OrdP (Var j) IMP\n                           Var k IN Var j OR\n                           Var k EQ Var j OR Var j IN Var k)),\n                       OrdP (Var i)} \\<turnstile>\n                      Var m IN Var j\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k); atom m \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> atom m \\<sharp> (Var i, Var j)\n 3. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k); atom m \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>B\\<in>{Neg (Var i IN Var j),\nNeg (Var j IN Var i),\nAll2 l (Var j) (Var i IN Var l OR Var i EQ Var l OR Var l IN Var i),\nOrdP (Var j),\nAll2 k (Var i)\n (SyntaxN.All j\n   (OrdP (Var j) IMP Var k IN Var j OR Var k EQ Var j OR Var j IN Var k)),\nOrdP (Var i)}.\n                         atom m \\<sharp> B", "apply (rule All2_E [THEN rotate6], auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k); atom m \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {SyntaxN.All j\n                        (OrdP (Var j) IMP\n                         Var m IN Var j OR\n                         Var m EQ Var j OR Var j IN Var m),\n                       Var m IN Var i, Neg (Var i IN Var j),\n                       Neg (Var j IN Var i),\n                       All2 l (Var j)\n                        (Var i IN Var l OR\n                         Var i EQ Var l OR Var l IN Var i),\n                       OrdP (Var j), OrdP (Var i)} \\<turnstile>\n                      Var m IN Var j", "apply (rule All_E [where x = \"Var j\"], auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k); atom m \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {Var m EQ Var j, Var m IN Var i, Neg (Var i IN Var j),\n                       Neg (Var j IN Var i),\n                       All2 l (Var j)\n                        (Var i IN Var l OR\n                         Var i EQ Var l OR Var l IN Var i),\n                       OrdP (Var j), OrdP (Var i)} \\<turnstile>\n                      Var m IN Var j\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k); atom m \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {Var j IN Var m, Var m IN Var i, Neg (Var i IN Var j),\n                       Neg (Var j IN Var i),\n                       All2 l (Var j)\n                        (Var i IN Var l OR\n                         Var i EQ Var l OR Var l IN Var i),\n                       OrdP (Var j), OrdP (Var i)} \\<turnstile>\n                      Var m IN Var j", "apply (blast intro: ContraProve [THEN rotate4] Mem_cong [OF Hyp Refl, THEN Iff_MP_same])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k); atom m \\<sharp> (i, j)\\<rbrakk>\n    \\<Longrightarrow> {Var j IN Var m, Var m IN Var i, Neg (Var i IN Var j),\n                       Neg (Var j IN Var i),\n                       All2 l (Var j)\n                        (Var i IN Var l OR\n                         Var i EQ Var l OR Var l IN Var i),\n                       OrdP (Var j), OrdP (Var i)} \\<turnstile>\n                      Var m IN Var j", "apply (blast intro: ContraProve [THEN rotate4] OrdP_Trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {} \\<turnstile>\n  SyntaxN.All i\n   (OrdP (Var i) IMP\n    All2 k (Var i)\n     ((SyntaxN.All j\n        (OrdP (Var j) IMP\n         Var i IN Var j OR\n         Var i EQ Var j OR Var j IN Var i))(i::=Var k)) IMP\n    SyntaxN.All j\n     (OrdP (Var j) IMP Var i IN Var j OR Var i EQ Var j OR Var j IN Var i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {OrdP (Var i)} \\<turnstile>\n  SyntaxN.All j\n   (OrdP (Var j) IMP Var i IN Var j OR Var i EQ Var j OR Var j IN Var i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OrdP_linear_imp: \"{} \\<turnstile> OrdP x IMP OrdP y IMP x IN y OR x EQ y OR y IN x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<turnstile> OrdP x IMP OrdP y IMP x IN y OR x EQ y OR y IN x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {} \\<turnstile> OrdP x IMP OrdP y IMP x IN y OR x EQ y OR y IN x", "obtain i::name and j::name\n    where atoms: \"atom i \\<sharp> (x,y)\" \"atom j \\<sharp> (x,y,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>atom i \\<sharp> (x, y); atom j \\<sharp> (x, y, i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom i \\<sharp> (x, y)\n  atom j \\<sharp> (x, y, i)\n\ngoal (1 subgoal):\n 1. {} \\<turnstile> OrdP x IMP OrdP y IMP x IN y OR x EQ y OR y IN x", "have \"{ OrdP (Var i) } \\<turnstile> (OrdP (Var j) IMP (Var i IN Var j OR Var i EQ Var j OR Var j IN Var i))(j::=y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {OrdP (Var i)} \\<turnstile>\n    (OrdP (Var j) IMP\n     Var i IN Var j OR Var i EQ Var j OR Var j IN Var i)(j::=y)", "using atoms"], ["proof (prove)\nusing this:\n  atom i \\<sharp> (x, y)\n  atom j \\<sharp> (x, y, i)\n\ngoal (1 subgoal):\n 1. {OrdP (Var i)} \\<turnstile>\n    (OrdP (Var j) IMP\n     Var i IN Var j OR Var i EQ Var j OR Var j IN Var i)(j::=y)", "by (metis All_D OrdP_linear_lemma fresh_Pair)"], ["proof (state)\nthis:\n  {OrdP (Var i)} \\<turnstile>\n  (OrdP (Var j) IMP\n   Var i IN Var j OR Var i EQ Var j OR Var j IN Var i)(j::=y)\n\ngoal (1 subgoal):\n 1. {} \\<turnstile> OrdP x IMP OrdP y IMP x IN y OR x EQ y OR y IN x", "hence \"{} \\<turnstile> OrdP (Var i) IMP OrdP y IMP (Var i IN y OR Var i EQ y OR y IN Var i)\""], ["proof (prove)\nusing this:\n  {OrdP (Var i)} \\<turnstile>\n  (OrdP (Var j) IMP\n   Var i IN Var j OR Var i EQ Var j OR Var j IN Var i)(j::=y)\n\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    OrdP (Var i) IMP OrdP y IMP Var i IN y OR Var i EQ y OR y IN Var i", "using atoms"], ["proof (prove)\nusing this:\n  {OrdP (Var i)} \\<turnstile>\n  (OrdP (Var j) IMP\n   Var i IN Var j OR Var i EQ Var j OR Var j IN Var i)(j::=y)\n  atom i \\<sharp> (x, y)\n  atom j \\<sharp> (x, y, i)\n\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    OrdP (Var i) IMP OrdP y IMP Var i IN y OR Var i EQ y OR y IN Var i", "by auto"], ["proof (state)\nthis:\n  {} \\<turnstile>\n  OrdP (Var i) IMP OrdP y IMP Var i IN y OR Var i EQ y OR y IN Var i\n\ngoal (1 subgoal):\n 1. {} \\<turnstile> OrdP x IMP OrdP y IMP x IN y OR x EQ y OR y IN x", "hence \"{} \\<turnstile> (OrdP (Var i) IMP OrdP y IMP (Var i IN y OR Var i EQ y OR y IN Var i))(i::=x)\""], ["proof (prove)\nusing this:\n  {} \\<turnstile>\n  OrdP (Var i) IMP OrdP y IMP Var i IN y OR Var i EQ y OR y IN Var i\n\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    (OrdP (Var i) IMP\n     OrdP y IMP Var i IN y OR Var i EQ y OR y IN Var i)(i::=x)", "by (metis Subst empty_iff)"], ["proof (state)\nthis:\n  {} \\<turnstile>\n  (OrdP (Var i) IMP\n   OrdP y IMP Var i IN y OR Var i EQ y OR y IN Var i)(i::=x)\n\ngoal (1 subgoal):\n 1. {} \\<turnstile> OrdP x IMP OrdP y IMP x IN y OR x EQ y OR y IN x", "thus ?thesis"], ["proof (prove)\nusing this:\n  {} \\<turnstile>\n  (OrdP (Var i) IMP\n   OrdP y IMP Var i IN y OR Var i EQ y OR y IN Var i)(i::=x)\n\ngoal (1 subgoal):\n 1. {} \\<turnstile> OrdP x IMP OrdP y IMP x IN y OR x EQ y OR y IN x", "using atoms"], ["proof (prove)\nusing this:\n  {} \\<turnstile>\n  (OrdP (Var i) IMP\n   OrdP y IMP Var i IN y OR Var i EQ y OR y IN Var i)(i::=x)\n  atom i \\<sharp> (x, y)\n  atom j \\<sharp> (x, y, i)\n\ngoal (1 subgoal):\n 1. {} \\<turnstile> OrdP x IMP OrdP y IMP x IN y OR x EQ y OR y IN x", "by auto"], ["proof (state)\nthis:\n  {} \\<turnstile> OrdP x IMP OrdP y IMP x IN y OR x EQ y OR y IN x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OrdP_linear:\n  assumes \"H \\<turnstile> OrdP x\" \"H \\<turnstile> OrdP y\" \n          \"insert (x IN y) H \\<turnstile> A\" \"insert (x EQ y) H \\<turnstile> A\" \"insert (y IN x) H \\<turnstile> A\" \n    shows \"H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H \\<turnstile> A", "have \"{ OrdP x, OrdP y } \\<turnstile> x IN y OR x EQ y OR y IN x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {OrdP x, OrdP y} \\<turnstile> x IN y OR x EQ y OR y IN x", "by (metis OrdP_linear_imp Imp_Imp_commute anti_deduction)"], ["proof (state)\nthis:\n  {OrdP x, OrdP y} \\<turnstile> x IN y OR x EQ y OR y IN x\n\ngoal (1 subgoal):\n 1. H \\<turnstile> A", "thus ?thesis"], ["proof (prove)\nusing this:\n  {OrdP x, OrdP y} \\<turnstile> x IN y OR x EQ y OR y IN x\n\ngoal (1 subgoal):\n 1. H \\<turnstile> A", "using assms"], ["proof (prove)\nusing this:\n  {OrdP x, OrdP y} \\<turnstile> x IN y OR x EQ y OR y IN x\n  H \\<turnstile> OrdP x\n  H \\<turnstile> OrdP y\n  insert (x IN y) H \\<turnstile> A\n  insert (x EQ y) H \\<turnstile> A\n  insert (y IN x) H \\<turnstile> A\n\ngoal (1 subgoal):\n 1. H \\<turnstile> A", "by (metis cut2 Disj_E cut_same)"], ["proof (state)\nthis:\n  H \\<turnstile> A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Zero_In_SUCC: \"{OrdP k} \\<turnstile> Zero IN SUCC k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {OrdP k} \\<turnstile> Zero IN SUCC k", "by (rule OrdP_linear [OF OrdP_Zero OrdP_SUCC_I]) (force simp: SUCC_def)+"], ["", "section \\<open>The predicate \\<open>OrdNotEqP\\<close>\\<close>"], ["", "nominal_function OrdNotEqP :: \"tm \\<Rightarrow> tm \\<Rightarrow> fm\"  (infixr \"NEQ\" 150)\n  where \"OrdNotEqP x y = OrdP x AND OrdP y AND (x IN y OR y IN x)\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt OrdNotEqP_graph_aux\n 2. \\<And>x y. OrdNotEqP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>xa y. x = (xa, y) \\<Longrightarrow> P) \\<Longrightarrow> P\n 4. \\<And>x y xa ya.\n       (x, y) = (xa, ya) \\<Longrightarrow>\n       OrdP x AND OrdP y AND (x IN y OR y IN x) =\n       OrdP xa AND OrdP ya AND (xa IN ya OR ya IN xa)", "by (auto simp: eqvt_def OrdNotEqP_graph_aux_def)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All OrdNotEqP_dom", "by lexicographic_order"], ["", "lemma OrdNotEqP_fresh_iff [simp]: \"a \\<sharp> OrdNotEqP x y \\<longleftrightarrow> a \\<sharp> x \\<and> a \\<sharp> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> x NEQ y = (a \\<sharp> x \\<and> a \\<sharp> y)", "by auto"], ["", "lemma eval_fm_OrdNotEqP [simp]: \"eval_fm e (OrdNotEqP x y) \\<longleftrightarrow> Ord \\<lbrakk>x\\<rbrakk>e \\<and> Ord \\<lbrakk>y\\<rbrakk>e \\<and> \\<lbrakk>x\\<rbrakk>e \\<noteq> \\<lbrakk>y\\<rbrakk>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_fm e (x NEQ y) =\n    (Ord \\<lbrakk>x\\<rbrakk>e \\<and>\n     Ord \\<lbrakk>y\\<rbrakk>e \\<and>\n     \\<lbrakk>x\\<rbrakk>e \\<noteq> \\<lbrakk>y\\<rbrakk>e)", "by (auto simp: hmem_not_refl) (metis Ord_linear)"], ["", "lemma OrdNotEqP_subst [simp]: \"(OrdNotEqP x y)(i::=t) = OrdNotEqP (subst i t x) (subst i t y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x NEQ y)(i::=t) = subst i t x NEQ subst i t y", "by simp"], ["", "lemma OrdNotEqP_cong: \"H \\<turnstile> x EQ x' \\<Longrightarrow> H \\<turnstile> y EQ y' \\<Longrightarrow> H \\<turnstile> OrdNotEqP x y IFF OrdNotEqP x' y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> x EQ x'; H \\<turnstile> y EQ y'\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile> x NEQ y IFF x' NEQ y'", "by (rule P2_cong) auto"], ["", "lemma OrdNotEqP_self_contra: \"{x NEQ x} \\<turnstile> Fls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x NEQ x} \\<turnstile> Fls", "by auto"], ["", "lemma OrdNotEqP_OrdP_E: \"insert (OrdP x) (insert (OrdP y) H) \\<turnstile> A \\<Longrightarrow> insert (x NEQ y) H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (OrdP x) (insert (OrdP y) H) \\<turnstile> A \\<Longrightarrow>\n    insert (x NEQ y) H \\<turnstile> A", "by (auto intro: thin1 rotate2)"], ["", "lemma OrdNotEqP_I: \"insert (x EQ y) H \\<turnstile> Fls \\<Longrightarrow> H \\<turnstile> OrdP x \\<Longrightarrow> H \\<turnstile> OrdP y \\<Longrightarrow> H \\<turnstile> x NEQ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>insert (x EQ y) H \\<turnstile> Fls; H \\<turnstile> OrdP x;\n     H \\<turnstile> OrdP y\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile> x NEQ y", "by (rule OrdP_linear [of _ x y]) (auto intro: ExFalso thin1 Disj_I1 Disj_I2)"], ["", "declare OrdNotEqP.simps [simp del]"], ["", "lemma OrdNotEqP_imp_Neg_Eq: \"{x NEQ y} \\<turnstile> Neg (x EQ y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x NEQ y} \\<turnstile> Neg (x EQ y)", "by (blast intro: OrdNotEqP_cong [THEN Iff_MP2_same]  OrdNotEqP_self_contra [of x, THEN cut1])"], ["", "lemma OrdNotEqP_E: \"H \\<turnstile> x EQ y \\<Longrightarrow> insert (x NEQ y) H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> x EQ y \\<Longrightarrow>\n    insert (x NEQ y) H \\<turnstile> A", "by (metis ContraProve OrdNotEqP_imp_Neg_Eq rcut1)"], ["", "section \\<open>Predecessor of an Ordinal\\<close>"], ["", "lemma OrdP_set_max_lemma:\n  assumes j: \"atom (j::name) \\<sharp> i\" and k: \"atom (k::name) \\<sharp> (i,j)\"\n  shows \"{} \\<turnstile> (Neg (Var i EQ Zero) AND (All2 j (Var i) (OrdP (Var j)))) IMP \n              (Ex j (Var j IN Var i AND (All2 k (Var i) (Var k SUBS Var j))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    Neg (Var i EQ Zero) AND All2 j (Var i) (OrdP (Var j)) IMP\n    SyntaxN.Ex j (Var j IN Var i AND All2 k (Var i) (Var k SUBS Var j))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    Neg (Var i EQ Zero) AND All2 j (Var i) (OrdP (Var j)) IMP\n    SyntaxN.Ex j (Var j IN Var i AND All2 k (Var i) (Var k SUBS Var j))", "obtain l::name where l: \"atom l \\<sharp> (i,j,k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        atom l \\<sharp> (i, j, k) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom l \\<sharp> (i, j, k)\n\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    Neg (Var i EQ Zero) AND All2 j (Var i) (OrdP (Var j)) IMP\n    SyntaxN.Ex j (Var j IN Var i AND All2 k (Var i) (Var k SUBS Var j))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    Neg (Var i EQ Zero) AND All2 j (Var i) (OrdP (Var j)) IMP\n    SyntaxN.Ex j (Var j IN Var i AND All2 k (Var i) (Var k SUBS Var j))", "apply (rule Ind [of l i])"], ["proof (prove)\ngoal (3 subgoals):\n 1. atom\n     l \\<sharp> (i, Neg (Var i EQ Zero) AND\n                    All2 j (Var i) (OrdP (Var j)) IMP\n                    SyntaxN.Ex j\n                     (Var j IN Var i AND All2 k (Var i) (Var k SUBS Var j)))\n 2. {} \\<turnstile>\n    (Neg (Var i EQ Zero) AND All2 j (Var i) (OrdP (Var j)) IMP\n     SyntaxN.Ex j\n      (Var j IN Var i AND All2 k (Var i) (Var k SUBS Var j)))(i::=Zero)\n 3. {} \\<turnstile>\n    SyntaxN.All i\n     (SyntaxN.All l\n       ((Neg (Var i EQ Zero) AND All2 j (Var i) (OrdP (Var j)) IMP\n         SyntaxN.Ex j\n          (Var j IN Var i AND All2 k (Var i) (Var k SUBS Var j))) IMP\n        (Neg (Var i EQ Zero) AND All2 j (Var i) (OrdP (Var j)) IMP\n         SyntaxN.Ex j\n          (Var j IN Var i AND\n           All2 k (Var i) (Var k SUBS Var j)))(i::=Var l) IMP\n        (Neg (Var i EQ Zero) AND All2 j (Var i) (OrdP (Var j)) IMP\n         SyntaxN.Ex j\n          (Var j IN Var i AND\n           All2 k (Var i) (Var k SUBS Var j)))(i::=Eats (Var i) (Var l))))", "using j k l"], ["proof (prove)\nusing this:\n  atom j \\<sharp> i\n  atom k \\<sharp> (i, j)\n  atom l \\<sharp> (i, j, k)\n\ngoal (3 subgoals):\n 1. atom\n     l \\<sharp> (i, Neg (Var i EQ Zero) AND\n                    All2 j (Var i) (OrdP (Var j)) IMP\n                    SyntaxN.Ex j\n                     (Var j IN Var i AND All2 k (Var i) (Var k SUBS Var j)))\n 2. {} \\<turnstile>\n    (Neg (Var i EQ Zero) AND All2 j (Var i) (OrdP (Var j)) IMP\n     SyntaxN.Ex j\n      (Var j IN Var i AND All2 k (Var i) (Var k SUBS Var j)))(i::=Zero)\n 3. {} \\<turnstile>\n    SyntaxN.All i\n     (SyntaxN.All l\n       ((Neg (Var i EQ Zero) AND All2 j (Var i) (OrdP (Var j)) IMP\n         SyntaxN.Ex j\n          (Var j IN Var i AND All2 k (Var i) (Var k SUBS Var j))) IMP\n        (Neg (Var i EQ Zero) AND All2 j (Var i) (OrdP (Var j)) IMP\n         SyntaxN.Ex j\n          (Var j IN Var i AND\n           All2 k (Var i) (Var k SUBS Var j)))(i::=Var l) IMP\n        (Neg (Var i EQ Zero) AND All2 j (Var i) (OrdP (Var j)) IMP\n         SyntaxN.Ex j\n          (Var j IN Var i AND\n           All2 k (Var i) (Var k SUBS Var j)))(i::=Eats (Var i) (Var l))))", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {} \\<turnstile>\n                      Neg (Zero EQ Zero) AND All2 j Zero (OrdP (Var j)) IMP\n                      SyntaxN.Ex j\n                       (Var j IN Zero AND All2 k Zero (Var k SUBS Var j))\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {} \\<turnstile>\n                      SyntaxN.All i\n                       (SyntaxN.All l\n                         ((Neg (Var i EQ Zero) AND\n                           All2 j (Var i) (OrdP (Var j)) IMP\n                           SyntaxN.Ex j\n                            (Var j IN Var i AND\n                             All2 k (Var i) (Var k SUBS Var j))) IMP\n                          (Neg (Var l EQ Zero) AND\n                           All2 j (Var l) (OrdP (Var j)) IMP\n                           SyntaxN.Ex j\n                            (Var j IN Var l AND\n                             All2 k (Var l) (Var k SUBS Var j))) IMP\n                          Neg (Eats (Var i) (Var l) EQ Zero) AND\n                          All2 j (Eats (Var i) (Var l)) (OrdP (Var j)) IMP\n                          SyntaxN.Ex j\n                           (Var j IN Eats (Var i) (Var l) AND\n                            All2 k (Eats (Var i) (Var l))\n                             (Var k SUBS Var j))))", "apply (metis Conj_E Refl Swap Imp_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {} \\<turnstile>\n                      SyntaxN.All i\n                       (SyntaxN.All l\n                         ((Neg (Var i EQ Zero) AND\n                           All2 j (Var i) (OrdP (Var j)) IMP\n                           SyntaxN.Ex j\n                            (Var j IN Var i AND\n                             All2 k (Var i) (Var k SUBS Var j))) IMP\n                          (Neg (Var l EQ Zero) AND\n                           All2 j (Var l) (OrdP (Var j)) IMP\n                           SyntaxN.Ex j\n                            (Var j IN Var l AND\n                             All2 k (Var l) (Var k SUBS Var j))) IMP\n                          Neg (Eats (Var i) (Var l) EQ Zero) AND\n                          All2 j (Eats (Var i) (Var l)) (OrdP (Var j)) IMP\n                          SyntaxN.Ex j\n                           (Var j IN Eats (Var i) (Var l) AND\n                            All2 k (Eats (Var i) (Var l))\n                             (Var k SUBS Var j))))", "apply (rule All_I Imp_I)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Neg (Eats (Var i) (Var l) EQ Zero) AND\n                       All2 j (Eats (Var i) (Var l)) (OrdP (Var j)),\n                       Neg (Var l EQ Zero) AND\n                       All2 j (Var l) (OrdP (Var j)) IMP\n                       SyntaxN.Ex j\n                        (Var j IN Var l AND\n                         All2 k (Var l) (Var k SUBS Var j)),\n                       Neg (Var i EQ Zero) AND\n                       All2 j (Var i) (OrdP (Var j)) IMP\n                       SyntaxN.Ex j\n                        (Var j IN Var i AND\n                         All2 k (Var i) (Var k SUBS Var j))} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Var j IN Eats (Var i) (Var l) AND\n                        All2 k (Eats (Var i) (Var l)) (Var k SUBS Var j))\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>{}. atom l \\<sharp> C\n 3. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>{}. atom i \\<sharp> C", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Neg (Eats (Var i) (Var l) EQ Zero) AND\n                       All2 j (Eats (Var i) (Var l)) (OrdP (Var j)),\n                       Neg (Var l EQ Zero) AND\n                       All2 j (Var l) (OrdP (Var j)) IMP\n                       SyntaxN.Ex j\n                        (Var j IN Var l AND\n                         All2 k (Var l) (Var k SUBS Var j)),\n                       Neg (Var i EQ Zero) AND\n                       All2 j (Var i) (OrdP (Var j)) IMP\n                       SyntaxN.Ex j\n                        (Var j IN Var i AND\n                         All2 k (Var i) (Var k SUBS Var j))} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Var j IN Eats (Var i) (Var l) AND\n                        All2 k (Eats (Var i) (Var l)) (Var k SUBS Var j))", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Neg (Eats (Var i) (Var l) EQ Zero),\n                       All2 j (Eats (Var i) (Var l)) (OrdP (Var j)),\n                       Neg (Var l EQ Zero) AND\n                       All2 j (Var l) (OrdP (Var j)) IMP\n                       SyntaxN.Ex j\n                        (Var j IN Var l AND\n                         All2 k (Var l) (Var k SUBS Var j)),\n                       Neg (Var i EQ Zero) AND\n                       All2 j (Var i) (OrdP (Var j)) IMP\n                       SyntaxN.Ex j\n                        (Var j IN Var i AND\n                         All2 k (Var i) (Var k SUBS Var j))} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Var j IN Eats (Var i) (Var l) AND\n                        All2 k (Eats (Var i) (Var l)) (Var k SUBS Var j))", "apply (rule thin1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {All2 j (Eats (Var i) (Var l)) (OrdP (Var j)),\n                       Neg (Var l EQ Zero) AND\n                       All2 j (Var l) (OrdP (Var j)) IMP\n                       SyntaxN.Ex j\n                        (Var j IN Var l AND\n                         All2 k (Var l) (Var k SUBS Var j)),\n                       Neg (Var i EQ Zero) AND\n                       All2 j (Var i) (OrdP (Var j)) IMP\n                       SyntaxN.Ex j\n                        (Var j IN Var i AND\n                         All2 k (Var i) (Var k SUBS Var j))} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Var j IN Eats (Var i) (Var l) AND\n                        All2 k (Eats (Var i) (Var l)) (Var k SUBS Var j))", "apply (rule thin1 [THEN rotate2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {All2 j (Eats (Var i) (Var l)) (OrdP (Var j)),\n                       Neg (Var i EQ Zero) AND\n                       All2 j (Var i) (OrdP (Var j)) IMP\n                       SyntaxN.Ex j\n                        (Var j IN Var i AND\n                         All2 k (Var i) (Var k SUBS Var j))} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Var j IN Eats (Var i) (Var l) AND\n                        All2 k (Eats (Var i) (Var l)) (Var k SUBS Var j))", "apply (rule Disj_EH)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Neg (Neg (Var i EQ Zero) AND\n                            All2 j (Var i) (OrdP (Var j))),\n                       All2 j (Eats (Var i) (Var l))\n                        (OrdP (Var j))} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Var j IN Eats (Var i) (Var l) AND\n                        All2 k (Eats (Var i) (Var l)) (Var k SUBS Var j))\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {SyntaxN.Ex j\n                        (Var j IN Var i AND\n                         All2 k (Var i) (Var k SUBS Var j)),\n                       All2 j (Eats (Var i) (Var l))\n                        (OrdP (Var j))} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Var j IN Eats (Var i) (Var l) AND\n                        All2 k (Eats (Var i) (Var l)) (Var k SUBS Var j))", "apply (rule Neg_Conj_E)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {All2 j (Eats (Var i) (Var l))\n                        (OrdP (Var j))} \\<turnstile>\n                      All2 j (Var i) (OrdP (Var j))\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Neg (Neg (Var i EQ Zero)),\n                       All2 j (Eats (Var i) (Var l))\n                        (OrdP (Var j))} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Var j IN Eats (Var i) (Var l) AND\n                        All2 k (Eats (Var i) (Var l)) (Var k SUBS Var j))\n 3. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {SyntaxN.Ex j\n                        (Var j IN Var i AND\n                         All2 k (Var i) (Var k SUBS Var j)),\n                       All2 j (Eats (Var i) (Var l))\n                        (OrdP (Var j))} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Var j IN Eats (Var i) (Var l) AND\n                        All2 k (Eats (Var i) (Var l)) (Var k SUBS Var j))", "apply (auto simp: All2_Eats_E1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var i EQ Zero,\n                       All2 j (Eats (Var i) (Var l))\n                        (OrdP (Var j))} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Var j IN Eats (Var i) (Var l) AND\n                        All2 k (Eats (Var i) (Var l)) (Var k SUBS Var j))\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var j IN Var i, All2 k (Var i) (Var k SUBS Var j),\n                       All2 j (Eats (Var i) (Var l))\n                        (OrdP (Var j))} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Var j IN Eats (Var i) (Var l) AND\n                        All2 k (Eats (Var i) (Var l)) (Var k SUBS Var j))", "apply (rule Ex_I [where x=\"Var l\"], auto intro: Mem_Eats_I2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var k IN Var i, Neg (Var k SUBS Var l),\n                       Var i EQ Zero} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Neg (Var j IN Eats (Var i) (Var l) IMP\n                             OrdP (Var j)))\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var k EQ Var l, Neg (Var k SUBS Var l),\n                       Var i EQ Zero} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Neg (Var j IN Eats (Var i) (Var l) IMP\n                             OrdP (Var j)))\n 3. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var j IN Var i, All2 k (Var i) (Var k SUBS Var j),\n                       All2 j (Eats (Var i) (Var l))\n                        (OrdP (Var j))} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Var j IN Eats (Var i) (Var l) AND\n                        All2 k (Eats (Var i) (Var l)) (Var k SUBS Var j))", "apply (metis Assume Eq_Zero_D rotate3)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var k EQ Var l, Neg (Var k SUBS Var l),\n                       Var i EQ Zero} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Neg (Var j IN Eats (Var i) (Var l) IMP\n                             OrdP (Var j)))\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var j IN Var i, All2 k (Var i) (Var k SUBS Var j),\n                       All2 j (Eats (Var i) (Var l))\n                        (OrdP (Var j))} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Var j IN Eats (Var i) (Var l) AND\n                        All2 k (Eats (Var i) (Var l)) (Var k SUBS Var j))", "apply (metis Assume EQ_imp_SUBS Neg_D thin1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var j IN Var i, All2 k (Var i) (Var k SUBS Var j),\n                       All2 j (Eats (Var i) (Var l))\n                        (OrdP (Var j))} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Var j IN Eats (Var i) (Var l) AND\n                        All2 k (Eats (Var i) (Var l)) (Var k SUBS Var j))", "apply (rule Cases [where A = \"Var j IN Var l\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var j IN Var l, Var j IN Var i,\n                       All2 k (Var i) (Var k SUBS Var j),\n                       All2 j (Eats (Var i) (Var l))\n                        (OrdP (Var j))} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Var j IN Eats (Var i) (Var l) AND\n                        All2 k (Eats (Var i) (Var l)) (Var k SUBS Var j))\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Neg (Var j IN Var l), Var j IN Var i,\n                       All2 k (Var i) (Var k SUBS Var j),\n                       All2 j (Eats (Var i) (Var l))\n                        (OrdP (Var j))} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Var j IN Eats (Var i) (Var l) AND\n                        All2 k (Eats (Var i) (Var l)) (Var k SUBS Var j))", "apply (rule Ex_I [where x=\"Var l\"], auto intro: Mem_Eats_I2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var k IN Var i, Neg (Var k SUBS Var l),\n                       Var j IN Var l, Var j IN Var i,\n                       All2 k (Var i) (Var k SUBS Var j)} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Neg (Var j IN Eats (Var i) (Var l) IMP\n                             OrdP (Var j)))\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var k EQ Var l, Neg (Var k SUBS Var l),\n                       Var j IN Var l, Var j IN Var i,\n                       All2 k (Var i) (Var k SUBS Var j)} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Neg (Var j IN Eats (Var i) (Var l) IMP\n                             OrdP (Var j)))\n 3. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Neg (Var j IN Var l), Var j IN Var i,\n                       All2 k (Var i) (Var k SUBS Var j),\n                       All2 j (Eats (Var i) (Var l))\n                        (OrdP (Var j))} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Var j IN Eats (Var i) (Var l) AND\n                        All2 k (Eats (Var i) (Var l)) (Var k SUBS Var j))", "apply (rule Ex_I [where x=\"Var l\"], auto intro: Mem_Eats_I2 ContraProve)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {OrdP (Var l), Var k IN Var i, Neg (Var k SUBS Var l),\n                       Var j IN Var l, Var j IN Var i} \\<turnstile>\n                      SyntaxN.Ex k\n                       (Neg (Var k IN Var i IMP Var k SUBS Var j))\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var k EQ Var l, Neg (Var k SUBS Var l),\n                       Var j IN Var l, Var j IN Var i,\n                       All2 k (Var i) (Var k SUBS Var j)} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Neg (Var j IN Eats (Var i) (Var l) IMP\n                             OrdP (Var j)))\n 3. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Neg (Var j IN Var l), Var j IN Var i,\n                       All2 k (Var i) (Var k SUBS Var j),\n                       All2 j (Eats (Var i) (Var l))\n                        (OrdP (Var j))} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Var j IN Eats (Var i) (Var l) AND\n                        All2 k (Eats (Var i) (Var l)) (Var k SUBS Var j))", "apply (rule Ex_I [where x=\"Var k\"], auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var k SUBS Var j, OrdP (Var l), Var k IN Var i,\n                       Var j IN Var l, Var j IN Var i} \\<turnstile>\n                      Var k SUBS Var l\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var k EQ Var l, Neg (Var k SUBS Var l),\n                       Var j IN Var l, Var j IN Var i,\n                       All2 k (Var i) (Var k SUBS Var j)} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Neg (Var j IN Eats (Var i) (Var l) IMP\n                             OrdP (Var j)))\n 3. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Neg (Var j IN Var l), Var j IN Var i,\n                       All2 k (Var i) (Var k SUBS Var j),\n                       All2 j (Eats (Var i) (Var l))\n                        (OrdP (Var j))} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Var j IN Eats (Var i) (Var l) AND\n                        All2 k (Eats (Var i) (Var l)) (Var k SUBS Var j))", "apply (metis Assume Subset_trans OrdP_Mem_imp_Subset thin1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var k EQ Var l, Neg (Var k SUBS Var l),\n                       Var j IN Var l, Var j IN Var i,\n                       All2 k (Var i) (Var k SUBS Var j)} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Neg (Var j IN Eats (Var i) (Var l) IMP\n                             OrdP (Var j)))\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Neg (Var j IN Var l), Var j IN Var i,\n                       All2 k (Var i) (Var k SUBS Var j),\n                       All2 j (Eats (Var i) (Var l))\n                        (OrdP (Var j))} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Var j IN Eats (Var i) (Var l) AND\n                        All2 k (Eats (Var i) (Var l)) (Var k SUBS Var j))", "apply (rule Ex_I [where x=\"Var l\"], auto intro: Mem_Eats_I2 ContraProve)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {OrdP (Var l), Var k EQ Var l, Neg (Var k SUBS Var l),\n                       Var j IN Var l, Var j IN Var i} \\<turnstile>\n                      SyntaxN.Ex k\n                       (Neg (Var k IN Var i IMP Var k SUBS Var j))\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Neg (Var j IN Var l), Var j IN Var i,\n                       All2 k (Var i) (Var k SUBS Var j),\n                       All2 j (Eats (Var i) (Var l))\n                        (OrdP (Var j))} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Var j IN Eats (Var i) (Var l) AND\n                        All2 k (Eats (Var i) (Var l)) (Var k SUBS Var j))", "apply (metis ContraProve EQ_imp_SUBS rotate3)\n    \\<comment> \\<open>final case\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Neg (Var j IN Var l), Var j IN Var i,\n                       All2 k (Var i) (Var k SUBS Var j),\n                       All2 j (Eats (Var i) (Var l))\n                        (OrdP (Var j))} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Var j IN Eats (Var i) (Var l) AND\n                        All2 k (Eats (Var i) (Var l)) (Var k SUBS Var j))", "apply (rule All2_Eats_E [THEN rotate4], simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {All2 j (Var i) (OrdP (Var j)), OrdP (Var l),\n                       Neg (Var j IN Var l), Var j IN Var i,\n                       All2 k (Var i) (Var k SUBS Var j)} \\<turnstile>\n                      SyntaxN.Ex j\n                       (Var j IN Eats (Var i) (Var l) AND\n                        All2 k (Eats (Var i) (Var l)) (Var k SUBS Var j))", "apply (rule Ex_I [where x=\"Var j\"], auto intro: Mem_Eats_I1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var k IN Var i, Neg (Var k SUBS Var j),\n                       All2 j (Var i) (OrdP (Var j)), OrdP (Var l),\n                       Neg (Var j IN Var l), Var j IN Var i} \\<turnstile>\n                      SyntaxN.Ex k\n                       (Neg (Var k IN Var i IMP Var k SUBS Var j))\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var k EQ Var l, Neg (Var k SUBS Var j),\n                       All2 j (Var i) (OrdP (Var j)), OrdP (Var l),\n                       Neg (Var j IN Var l), Var j IN Var i} \\<turnstile>\n                      SyntaxN.Ex k\n                       (Neg (Var k IN Var i IMP Var k SUBS Var j))", "apply (rule All2_E [where x = \"Var k\", THEN rotate3], auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {OrdP (Var k), Var k IN Var i, Neg (Var k SUBS Var j),\n                       OrdP (Var l), Neg (Var j IN Var l),\n                       Var j IN Var i} \\<turnstile>\n                      SyntaxN.Ex k\n                       (Neg (Var k IN Var i IMP Var k SUBS Var j))\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var k EQ Var l, Neg (Var k SUBS Var j),\n                       All2 j (Var i) (OrdP (Var j)), OrdP (Var l),\n                       Neg (Var j IN Var l), Var j IN Var i} \\<turnstile>\n                      SyntaxN.Ex k\n                       (Neg (Var k IN Var i IMP Var k SUBS Var j))", "apply (rule Ex_I [where x=\"Var k\"], simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {OrdP (Var k), Var k IN Var i, Neg (Var k SUBS Var j),\n                       OrdP (Var l), Neg (Var j IN Var l),\n                       Var j IN Var i} \\<turnstile>\n                      Neg (Var k IN Var i IMP Var k SUBS Var j)\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var k EQ Var l, Neg (Var k SUBS Var j),\n                       All2 j (Var i) (OrdP (Var j)), OrdP (Var l),\n                       Neg (Var j IN Var l), Var j IN Var i} \\<turnstile>\n                      SyntaxN.Ex k\n                       (Neg (Var k IN Var i IMP Var k SUBS Var j))", "apply (metis Assume NegNeg_I Neg_Disj_I rotate3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var k EQ Var l, Neg (Var k SUBS Var j),\n                       All2 j (Var i) (OrdP (Var j)), OrdP (Var l),\n                       Neg (Var j IN Var l), Var j IN Var i} \\<turnstile>\n                      SyntaxN.Ex k\n                       (Neg (Var k IN Var i IMP Var k SUBS Var j))", "apply (rule cut_same [where A = \"OrdP (Var j)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var k EQ Var l, Neg (Var k SUBS Var j),\n                       All2 j (Var i) (OrdP (Var j)), OrdP (Var l),\n                       Neg (Var j IN Var l), Var j IN Var i} \\<turnstile>\n                      OrdP (Var j)\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {OrdP (Var j), Var k EQ Var l, Neg (Var k SUBS Var j),\n                       All2 j (Var i) (OrdP (Var j)), OrdP (Var l),\n                       Neg (Var j IN Var l), Var j IN Var i} \\<turnstile>\n                      SyntaxN.Ex k\n                       (Neg (Var k IN Var i IMP Var k SUBS Var j))", "apply (rule All2_E [where x = \"Var j\", THEN rotate3], auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {OrdP (Var j), Var k EQ Var l, Neg (Var k SUBS Var j),\n                       All2 j (Var i) (OrdP (Var j)), OrdP (Var l),\n                       Neg (Var j IN Var l), Var j IN Var i} \\<turnstile>\n                      SyntaxN.Ex k\n                       (Neg (Var k IN Var i IMP Var k SUBS Var j))", "apply (rule cut_same [where A = \"Var l EQ Var j OR Var l IN Var j\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {OrdP (Var j), Var k EQ Var l, Neg (Var k SUBS Var j),\n                       All2 j (Var i) (OrdP (Var j)), OrdP (Var l),\n                       Neg (Var j IN Var l), Var j IN Var i} \\<turnstile>\n                      Var l EQ Var j OR Var l IN Var j\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var l EQ Var j OR Var l IN Var j, OrdP (Var j),\n                       Var k EQ Var l, Neg (Var k SUBS Var j),\n                       All2 j (Var i) (OrdP (Var j)), OrdP (Var l),\n                       Neg (Var j IN Var l), Var j IN Var i} \\<turnstile>\n                      SyntaxN.Ex k\n                       (Neg (Var k IN Var i IMP Var k SUBS Var j))", "apply (rule OrdP_linear [of _ \"Var l\" \"Var j\"], auto intro: Disj_CI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var j IN Var l, OrdP (Var j), Var k EQ Var l,\n                       Neg (Var k SUBS Var j),\n                       All2 j (Var i) (OrdP (Var j)), OrdP (Var l),\n                       Neg (Var j IN Var l), Var j IN Var i} \\<turnstile>\n                      Var l EQ Var j OR Var l IN Var j\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var l EQ Var j, OrdP (Var j), Var k EQ Var l,\n                       Neg (Var k SUBS Var j),\n                       All2 j (Var i) (OrdP (Var j)), OrdP (Var l),\n                       Neg (Var j IN Var l), Var j IN Var i} \\<turnstile>\n                      SyntaxN.Ex k\n                       (Neg (Var k IN Var i IMP Var k SUBS Var j))\n 3. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var l IN Var j, OrdP (Var j), Var k EQ Var l,\n                       Neg (Var k SUBS Var j),\n                       All2 j (Var i) (OrdP (Var j)), OrdP (Var l),\n                       Neg (Var j IN Var l), Var j IN Var i} \\<turnstile>\n                      SyntaxN.Ex k\n                       (Neg (Var k IN Var i IMP Var k SUBS Var j))", "apply (metis Assume ContraProve rotate7)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var l EQ Var j, OrdP (Var j), Var k EQ Var l,\n                       Neg (Var k SUBS Var j),\n                       All2 j (Var i) (OrdP (Var j)), OrdP (Var l),\n                       Neg (Var j IN Var l), Var j IN Var i} \\<turnstile>\n                      SyntaxN.Ex k\n                       (Neg (Var k IN Var i IMP Var k SUBS Var j))\n 2. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var l IN Var j, OrdP (Var j), Var k EQ Var l,\n                       Neg (Var k SUBS Var j),\n                       All2 j (Var i) (OrdP (Var j)), OrdP (Var l),\n                       Neg (Var j IN Var l), Var j IN Var i} \\<turnstile>\n                      SyntaxN.Ex k\n                       (Neg (Var k IN Var i IMP Var k SUBS Var j))", "apply (metis ContraProve [THEN rotate4] EQ_imp_SUBS Subset_trans rotate3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom j \\<sharp> i; atom k \\<sharp> (i, j);\n     atom l \\<sharp> (i, j, k)\\<rbrakk>\n    \\<Longrightarrow> {Var l IN Var j, OrdP (Var j), Var k EQ Var l,\n                       Neg (Var k SUBS Var j),\n                       All2 j (Var i) (OrdP (Var j)), OrdP (Var l),\n                       Neg (Var j IN Var l), Var j IN Var i} \\<turnstile>\n                      SyntaxN.Ex k\n                       (Neg (Var k IN Var i IMP Var k SUBS Var j))", "apply (blast intro: ContraProve [THEN rotate4] OrdP_Mem_imp_Subset Iff_MP2_same [OF Mem_cong])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {} \\<turnstile>\n  Neg (Var i EQ Zero) AND All2 j (Var i) (OrdP (Var j)) IMP\n  SyntaxN.Ex j (Var j IN Var i AND All2 k (Var i) (Var k SUBS Var j))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OrdP_max_imp:\n  assumes j: \"atom j \\<sharp> (x)\" and k: \"atom k \\<sharp> (x,j)\"\n  shows  \"{ OrdP x, Neg (x EQ Zero) } \\<turnstile> Ex j (Var j IN x AND (All2 k x (Var k SUBS Var j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {OrdP x, Neg (x EQ Zero)} \\<turnstile>\n    SyntaxN.Ex j (Var j IN x AND All2 k x (Var k SUBS Var j))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {OrdP x, Neg (x EQ Zero)} \\<turnstile>\n    SyntaxN.Ex j (Var j IN x AND All2 k x (Var k SUBS Var j))", "obtain i::name where i: \"atom i \\<sharp> (x,j,k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        atom i \\<sharp> (x, j, k) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom i \\<sharp> (x, j, k)\n\ngoal (1 subgoal):\n 1. {OrdP x, Neg (x EQ Zero)} \\<turnstile>\n    SyntaxN.Ex j (Var j IN x AND All2 k x (Var k SUBS Var j))", "have \"{} \\<turnstile> ((Neg (Var i EQ Zero) AND (All2 j (Var i) (OrdP (Var j)))) IMP \n              (Ex j (Var j IN Var i AND (All2 k (Var i) (Var k SUBS Var j)))))(i::=x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<turnstile>\n    (Neg (Var i EQ Zero) AND All2 j (Var i) (OrdP (Var j)) IMP\n     SyntaxN.Ex j\n      (Var j IN Var i AND All2 k (Var i) (Var k SUBS Var j)))(i::=x)", "apply (rule Subst [OF OrdP_set_max_lemma])"], ["proof (prove)\ngoal (3 subgoals):\n 1. atom j \\<sharp> i\n 2. atom k \\<sharp> (i, j)\n 3. \\<forall>B\\<in>{}. atom i \\<sharp> B", "using i k"], ["proof (prove)\nusing this:\n  atom i \\<sharp> (x, j, k)\n  atom k \\<sharp> (x, j)\n\ngoal (3 subgoals):\n 1. atom j \\<sharp> i\n 2. atom k \\<sharp> (i, j)\n 3. \\<forall>B\\<in>{}. atom i \\<sharp> B", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {} \\<turnstile>\n  (Neg (Var i EQ Zero) AND All2 j (Var i) (OrdP (Var j)) IMP\n   SyntaxN.Ex j\n    (Var j IN Var i AND All2 k (Var i) (Var k SUBS Var j)))(i::=x)\n\ngoal (1 subgoal):\n 1. {OrdP x, Neg (x EQ Zero)} \\<turnstile>\n    SyntaxN.Ex j (Var j IN x AND All2 k x (Var k SUBS Var j))", "hence \"{ Neg (x EQ Zero) AND (All2 j x (OrdP (Var j))) } \n         \\<turnstile> Ex j (Var j IN x AND (All2 k x (Var k SUBS Var j)))\""], ["proof (prove)\nusing this:\n  {} \\<turnstile>\n  (Neg (Var i EQ Zero) AND All2 j (Var i) (OrdP (Var j)) IMP\n   SyntaxN.Ex j\n    (Var j IN Var i AND All2 k (Var i) (Var k SUBS Var j)))(i::=x)\n\ngoal (1 subgoal):\n 1. {Neg (x EQ Zero) AND All2 j x (OrdP (Var j))} \\<turnstile>\n    SyntaxN.Ex j (Var j IN x AND All2 k x (Var k SUBS Var j))", "using i j k"], ["proof (prove)\nusing this:\n  {} \\<turnstile>\n  (Neg (Var i EQ Zero) AND All2 j (Var i) (OrdP (Var j)) IMP\n   SyntaxN.Ex j\n    (Var j IN Var i AND All2 k (Var i) (Var k SUBS Var j)))(i::=x)\n  atom i \\<sharp> (x, j, k)\n  atom j \\<sharp> x\n  atom k \\<sharp> (x, j)\n\ngoal (1 subgoal):\n 1. {Neg (x EQ Zero) AND All2 j x (OrdP (Var j))} \\<turnstile>\n    SyntaxN.Ex j (Var j IN x AND All2 k x (Var k SUBS Var j))", "by simp (metis anti_deduction)"], ["proof (state)\nthis:\n  {Neg (x EQ Zero) AND All2 j x (OrdP (Var j))} \\<turnstile>\n  SyntaxN.Ex j (Var j IN x AND All2 k x (Var k SUBS Var j))\n\ngoal (1 subgoal):\n 1. {OrdP x, Neg (x EQ Zero)} \\<turnstile>\n    SyntaxN.Ex j (Var j IN x AND All2 k x (Var k SUBS Var j))", "hence \"{ All2 j x (OrdP (Var j)), Neg (x EQ Zero) } \n             \\<turnstile> Ex j (Var j IN x AND (All2 k x (Var k SUBS Var j)))\""], ["proof (prove)\nusing this:\n  {Neg (x EQ Zero) AND All2 j x (OrdP (Var j))} \\<turnstile>\n  SyntaxN.Ex j (Var j IN x AND All2 k x (Var k SUBS Var j))\n\ngoal (1 subgoal):\n 1. {All2 j x (OrdP (Var j)), Neg (x EQ Zero)} \\<turnstile>\n    SyntaxN.Ex j (Var j IN x AND All2 k x (Var k SUBS Var j))", "by (rule cut1) (metis Assume Conj_I thin1)"], ["proof (state)\nthis:\n  {All2 j x (OrdP (Var j)), Neg (x EQ Zero)} \\<turnstile>\n  SyntaxN.Ex j (Var j IN x AND All2 k x (Var k SUBS Var j))\n\ngoal (1 subgoal):\n 1. {OrdP x, Neg (x EQ Zero)} \\<turnstile>\n    SyntaxN.Ex j (Var j IN x AND All2 k x (Var k SUBS Var j))", "moreover"], ["proof (state)\nthis:\n  {All2 j x (OrdP (Var j)), Neg (x EQ Zero)} \\<turnstile>\n  SyntaxN.Ex j (Var j IN x AND All2 k x (Var k SUBS Var j))\n\ngoal (1 subgoal):\n 1. {OrdP x, Neg (x EQ Zero)} \\<turnstile>\n    SyntaxN.Ex j (Var j IN x AND All2 k x (Var k SUBS Var j))", "have \"{ OrdP x } \\<turnstile> All2 j x (OrdP (Var j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {OrdP x} \\<turnstile> All2 j x (OrdP (Var j))", "using j"], ["proof (prove)\nusing this:\n  atom j \\<sharp> x\n\ngoal (1 subgoal):\n 1. {OrdP x} \\<turnstile> All2 j x (OrdP (Var j))", "by auto (metis Assume Ord_IN_Ord thin1)"], ["proof (state)\nthis:\n  {OrdP x} \\<turnstile> All2 j x (OrdP (Var j))\n\ngoal (1 subgoal):\n 1. {OrdP x, Neg (x EQ Zero)} \\<turnstile>\n    SyntaxN.Ex j (Var j IN x AND All2 k x (Var k SUBS Var j))", "ultimately"], ["proof (chain)\npicking this:\n  {All2 j x (OrdP (Var j)), Neg (x EQ Zero)} \\<turnstile>\n  SyntaxN.Ex j (Var j IN x AND All2 k x (Var k SUBS Var j))\n  {OrdP x} \\<turnstile> All2 j x (OrdP (Var j))", "show ?thesis"], ["proof (prove)\nusing this:\n  {All2 j x (OrdP (Var j)), Neg (x EQ Zero)} \\<turnstile>\n  SyntaxN.Ex j (Var j IN x AND All2 k x (Var k SUBS Var j))\n  {OrdP x} \\<turnstile> All2 j x (OrdP (Var j))\n\ngoal (1 subgoal):\n 1. {OrdP x, Neg (x EQ Zero)} \\<turnstile>\n    SyntaxN.Ex j (Var j IN x AND All2 k x (Var k SUBS Var j))", "by (metis rcut1)"], ["proof (state)\nthis:\n  {OrdP x, Neg (x EQ Zero)} \\<turnstile>\n  SyntaxN.Ex j (Var j IN x AND All2 k x (Var k SUBS Var j))\n\ngoal:\nNo subgoals!", "qed"], ["", "declare OrdP.simps [simp del]"], ["", "section \\<open>Case Analysis and Zero/SUCC Induction\\<close>"], ["", "lemma OrdP_cases_lemma:\n  assumes p: \"atom p \\<sharp> x\" \n  shows  \"{ OrdP x, Neg (x EQ Zero) } \\<turnstile> Ex p (OrdP (Var p) AND x EQ SUCC (Var p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {OrdP x, Neg (x EQ Zero)} \\<turnstile>\n    SyntaxN.Ex p (OrdP (Var p) AND x EQ SUCC (Var p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {OrdP x, Neg (x EQ Zero)} \\<turnstile>\n    SyntaxN.Ex p (OrdP (Var p) AND x EQ SUCC (Var p))", "obtain j::name and k::name where j: \"atom j \\<sharp> (x,p)\" and k: \"atom k \\<sharp> (x,j,p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j k.\n        \\<lbrakk>atom j \\<sharp> (x, p); atom k \\<sharp> (x, j, p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom j \\<sharp> (x, p)\n  atom k \\<sharp> (x, j, p)\n\ngoal (1 subgoal):\n 1. {OrdP x, Neg (x EQ Zero)} \\<turnstile>\n    SyntaxN.Ex p (OrdP (Var p) AND x EQ SUCC (Var p))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. {OrdP x, Neg (x EQ Zero)} \\<turnstile>\n    SyntaxN.Ex p (OrdP (Var p) AND x EQ SUCC (Var p))", "apply (rule cut_same [OF OrdP_max_imp [of j x k]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. atom j \\<sharp> x\n 2. atom k \\<sharp> (x, j)\n 3. {SyntaxN.Ex j (Var j IN x AND All2 k x (Var k SUBS Var j)), OrdP x,\n     Neg (x EQ Zero)} \\<turnstile>\n    SyntaxN.Ex p (OrdP (Var p) AND x EQ SUCC (Var p))", "using p j k"], ["proof (prove)\nusing this:\n  atom p \\<sharp> x\n  atom j \\<sharp> (x, p)\n  atom k \\<sharp> (x, j, p)\n\ngoal (3 subgoals):\n 1. atom j \\<sharp> x\n 2. atom k \\<sharp> (x, j)\n 3. {SyntaxN.Ex j (Var j IN x AND All2 k x (Var k SUBS Var j)), OrdP x,\n     Neg (x EQ Zero)} \\<turnstile>\n    SyntaxN.Ex p (OrdP (Var p) AND x EQ SUCC (Var p))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom p \\<sharp> x; atom j \\<sharp> (x, p);\n     atom k \\<sharp> (x, j, p)\\<rbrakk>\n    \\<Longrightarrow> {Var j IN x, All2 k x (Var k SUBS Var j), OrdP x,\n                       Neg (x EQ Zero)} \\<turnstile>\n                      SyntaxN.Ex p (OrdP (Var p) AND x EQ SUCC (Var p))", "apply (rule Ex_I [where x=\"Var j\"], auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom p \\<sharp> x; atom j \\<sharp> (x, p);\n     atom k \\<sharp> (x, j, p)\\<rbrakk>\n    \\<Longrightarrow> {Var j IN x, All2 k x (Var k SUBS Var j), OrdP x,\n                       Neg (x EQ Zero)} \\<turnstile>\n                      OrdP (Var j)\n 2. \\<lbrakk>atom p \\<sharp> x; atom j \\<sharp> (x, p);\n     atom k \\<sharp> (x, j, p)\\<rbrakk>\n    \\<Longrightarrow> {Var j IN x, All2 k x (Var k SUBS Var j), OrdP x,\n                       Neg (x EQ Zero)} \\<turnstile>\n                      x EQ SUCC (Var j)", "apply (metis Assume Ord_IN_Ord thin1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom p \\<sharp> x; atom j \\<sharp> (x, p);\n     atom k \\<sharp> (x, j, p)\\<rbrakk>\n    \\<Longrightarrow> {Var j IN x, All2 k x (Var k SUBS Var j), OrdP x,\n                       Neg (x EQ Zero)} \\<turnstile>\n                      x EQ SUCC (Var j)", "apply (rule cut_same [where A = \"OrdP (SUCC (Var j))\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom p \\<sharp> x; atom j \\<sharp> (x, p);\n     atom k \\<sharp> (x, j, p)\\<rbrakk>\n    \\<Longrightarrow> {Var j IN x, All2 k x (Var k SUBS Var j), OrdP x,\n                       Neg (x EQ Zero)} \\<turnstile>\n                      OrdP (SUCC (Var j))\n 2. \\<lbrakk>atom p \\<sharp> x; atom j \\<sharp> (x, p);\n     atom k \\<sharp> (x, j, p)\\<rbrakk>\n    \\<Longrightarrow> {OrdP (SUCC (Var j)), Var j IN x,\n                       All2 k x (Var k SUBS Var j), OrdP x,\n                       Neg (x EQ Zero)} \\<turnstile>\n                      x EQ SUCC (Var j)", "apply (metis Assume Ord_IN_Ord0 OrdP_SUCC_I rotate2 thin1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom p \\<sharp> x; atom j \\<sharp> (x, p);\n     atom k \\<sharp> (x, j, p)\\<rbrakk>\n    \\<Longrightarrow> {OrdP (SUCC (Var j)), Var j IN x,\n                       All2 k x (Var k SUBS Var j), OrdP x,\n                       Neg (x EQ Zero)} \\<turnstile>\n                      x EQ SUCC (Var j)", "apply (rule OrdP_linear [where x = x, OF _ Assume], auto intro!: Mem_SUCC_EH)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>atom p \\<sharp> x; atom j \\<sharp> (x, p);\n     atom k \\<sharp> (x, j, p)\\<rbrakk>\n    \\<Longrightarrow> {x IN Var j, OrdP (SUCC (Var j)), Var j IN x,\n                       All2 k x (Var k SUBS Var j), OrdP x,\n                       Neg (x EQ Zero)} \\<turnstile>\n                      x EQ SUCC (Var j)\n 2. \\<lbrakk>atom p \\<sharp> x; atom j \\<sharp> (x, p);\n     atom k \\<sharp> (x, j, p)\\<rbrakk>\n    \\<Longrightarrow> {x EQ Var j, OrdP (SUCC (Var j)), Var j IN x,\n                       All2 k x (Var k SUBS Var j), OrdP x,\n                       Neg (x EQ Zero)} \\<turnstile>\n                      x EQ SUCC (Var j)\n 3. \\<lbrakk>atom p \\<sharp> x; atom j \\<sharp> (x, p);\n     atom k \\<sharp> (x, j, p)\\<rbrakk>\n    \\<Longrightarrow> {SUCC (Var j) IN x, OrdP (SUCC (Var j)), Var j IN x,\n                       All2 k x (Var k SUBS Var j), OrdP x,\n                       Neg (x EQ Zero)} \\<turnstile>\n                      x EQ SUCC (Var j)", "apply (metis Mem_not_sym rotate3)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom p \\<sharp> x; atom j \\<sharp> (x, p);\n     atom k \\<sharp> (x, j, p)\\<rbrakk>\n    \\<Longrightarrow> {x EQ Var j, OrdP (SUCC (Var j)), Var j IN x,\n                       All2 k x (Var k SUBS Var j), OrdP x,\n                       Neg (x EQ Zero)} \\<turnstile>\n                      x EQ SUCC (Var j)\n 2. \\<lbrakk>atom p \\<sharp> x; atom j \\<sharp> (x, p);\n     atom k \\<sharp> (x, j, p)\\<rbrakk>\n    \\<Longrightarrow> {SUCC (Var j) IN x, OrdP (SUCC (Var j)), Var j IN x,\n                       All2 k x (Var k SUBS Var j), OrdP x,\n                       Neg (x EQ Zero)} \\<turnstile>\n                      x EQ SUCC (Var j)", "apply (rule Mem_non_refl, blast intro: Mem_cong [OF Assume Refl, THEN Iff_MP2_same])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom p \\<sharp> x; atom j \\<sharp> (x, p);\n     atom k \\<sharp> (x, j, p)\\<rbrakk>\n    \\<Longrightarrow> {SUCC (Var j) IN x, OrdP (SUCC (Var j)), Var j IN x,\n                       All2 k x (Var k SUBS Var j), OrdP x,\n                       Neg (x EQ Zero)} \\<turnstile>\n                      x EQ SUCC (Var j)", "apply (force intro: thin1 All2_E [where x = \"SUCC (Var j)\", THEN rotate4])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {OrdP x, Neg (x EQ Zero)} \\<turnstile>\n  SyntaxN.Ex p (OrdP (Var p) AND x EQ SUCC (Var p))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OrdP_cases_disj:\n  assumes p: \"atom p \\<sharp> x\" \n  shows  \"insert (OrdP x) H \\<turnstile> x EQ Zero OR Ex p (OrdP (Var p) AND x EQ SUCC (Var p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (OrdP x) H \\<turnstile>\n    x EQ Zero OR SyntaxN.Ex p (OrdP (Var p) AND x EQ SUCC (Var p))", "by (metis Disj_CI Assume cut2 [OF OrdP_cases_lemma [OF p]] Swap thin1)"], ["", "lemma OrdP_cases_E:\n  \"\\<lbrakk>insert (x EQ Zero) H \\<turnstile> A;\n    insert (x EQ SUCC (Var k)) (insert (OrdP (Var k)) H) \\<turnstile> A; \n    atom k \\<sharp> (x,A);   \\<forall>C \\<in> H. atom k \\<sharp> C\\<rbrakk>\n   \\<Longrightarrow> insert (OrdP x) H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>insert (x EQ Zero) H \\<turnstile> A;\n     insert (x EQ SUCC (Var k)) (insert (OrdP (Var k)) H) \\<turnstile> A;\n     atom k \\<sharp> (x, A); \\<forall>C\\<in>H. atom k \\<sharp> C\\<rbrakk>\n    \\<Longrightarrow> insert (OrdP x) H \\<turnstile> A", "by (rule cut_same [OF OrdP_cases_disj [of k]]) (auto simp: insert_commute intro: thin1)"], ["", "lemma OrdInd2_lemma:\n  \"{ OrdP (Var i), A(i::= Zero), (All i (OrdP (Var i) IMP A IMP (A(i::= SUCC (Var i))))) } \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {OrdP (Var i), A(i::=Zero),\n     SyntaxN.All i\n      (OrdP (Var i) IMP A IMP A(i::=SUCC (Var i)))} \\<turnstile>\n    A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {OrdP (Var i), A(i::=Zero),\n     SyntaxN.All i\n      (OrdP (Var i) IMP A IMP A(i::=SUCC (Var i)))} \\<turnstile>\n    A", "obtain j::name and k::name  where atoms: \"atom j \\<sharp> (i,A)\" \"atom k \\<sharp> (i,j,A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j k.\n        \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom j \\<sharp> (i, A)\n  atom k \\<sharp> (i, j, A)\n\ngoal (1 subgoal):\n 1. {OrdP (Var i), A(i::=Zero),\n     SyntaxN.All i\n      (OrdP (Var i) IMP A IMP A(i::=SUCC (Var i)))} \\<turnstile>\n    A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. {OrdP (Var i), A(i::=Zero),\n     SyntaxN.All i\n      (OrdP (Var i) IMP A IMP A(i::=SUCC (Var i)))} \\<turnstile>\n    A", "apply (rule OrdIndH [where i=i and j=j])"], ["proof (prove)\ngoal (2 subgoals):\n 1. atom j \\<sharp> (i, A)\n 2. {A(i::=Zero),\n     SyntaxN.All i\n      (OrdP (Var i) IMP A IMP A(i::=SUCC (Var i)))} \\<turnstile>\n    SyntaxN.All i (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A)", "using atoms"], ["proof (prove)\nusing this:\n  atom j \\<sharp> (i, A)\n  atom k \\<sharp> (i, j, A)\n\ngoal (2 subgoals):\n 1. atom j \\<sharp> (i, A)\n 2. {A(i::=Zero),\n     SyntaxN.All i\n      (OrdP (Var i) IMP A IMP A(i::=SUCC (Var i)))} \\<turnstile>\n    SyntaxN.All i (OrdP (Var i) IMP All2 j (Var i) (A(i::=Var j)) IMP A)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {Neg A, All2 j (Var i) (A(i::=Var j)), OrdP (Var i),\n                       A(i::=Zero)} \\<turnstile>\n                      SyntaxN.Ex i\n                       (Neg (OrdP (Var i) IMP A IMP A(i::=SUCC (Var i))))", "apply (rule OrdP_cases_E [where k=k, THEN rotate3])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {Var i EQ Zero, Neg A, All2 j (Var i) (A(i::=Var j)),\n                       A(i::=Zero)} \\<turnstile>\n                      SyntaxN.Ex i\n                       (Neg (OrdP (Var i) IMP A IMP A(i::=SUCC (Var i))))\n 2. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {Var i EQ SUCC (Var k), OrdP (Var k), Neg A,\n                       All2 j (Var i) (A(i::=Var j)),\n                       A(i::=Zero)} \\<turnstile>\n                      SyntaxN.Ex i\n                       (Neg (OrdP (Var i) IMP A IMP A(i::=SUCC (Var i))))\n 3. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> atom\n                       k \\<sharp> (Var i,\n                                   SyntaxN.Ex i\n                                    (Neg\n(OrdP (Var i) IMP A IMP A(i::=SUCC (Var i)))))\n 4. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>{Neg A, All2 j (Var i) (A(i::=Var j)),\nA(i::=Zero)}.\n                         atom k \\<sharp> C", "apply (rule ContraProve [THEN rotate2])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {Var i EQ Zero, All2 j (Var i) (A(i::=Var j)),\n                       A(i::=Zero)} \\<turnstile>\n                      A\n 2. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {Var i EQ SUCC (Var k), OrdP (Var k), Neg A,\n                       All2 j (Var i) (A(i::=Var j)),\n                       A(i::=Zero)} \\<turnstile>\n                      SyntaxN.Ex i\n                       (Neg (OrdP (Var i) IMP A IMP A(i::=SUCC (Var i))))\n 3. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> atom\n                       k \\<sharp> (Var i,\n                                   SyntaxN.Ex i\n                                    (Neg\n(OrdP (Var i) IMP A IMP A(i::=SUCC (Var i)))))\n 4. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>{Neg A, All2 j (Var i) (A(i::=Var j)),\nA(i::=Zero)}.\n                         atom k \\<sharp> C", "using Var_Eq_imp_subst_Iff"], ["proof (prove)\nusing this:\n  ?H \\<turnstile> Var ?i EQ ?t \\<Longrightarrow>\n  ?H \\<turnstile> ?A(?i::=?t) IFF ?A\n\ngoal (4 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {Var i EQ Zero, All2 j (Var i) (A(i::=Var j)),\n                       A(i::=Zero)} \\<turnstile>\n                      A\n 2. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {Var i EQ SUCC (Var k), OrdP (Var k), Neg A,\n                       All2 j (Var i) (A(i::=Var j)),\n                       A(i::=Zero)} \\<turnstile>\n                      SyntaxN.Ex i\n                       (Neg (OrdP (Var i) IMP A IMP A(i::=SUCC (Var i))))\n 3. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> atom\n                       k \\<sharp> (Var i,\n                                   SyntaxN.Ex i\n                                    (Neg\n(OrdP (Var i) IMP A IMP A(i::=SUCC (Var i)))))\n 4. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>{Neg A, All2 j (Var i) (A(i::=Var j)),\nA(i::=Zero)}.\n                         atom k \\<sharp> C", "apply (metis Assume AssumeH(3) Iff_MP_same)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {Var i EQ SUCC (Var k), OrdP (Var k), Neg A,\n                       All2 j (Var i) (A(i::=Var j)),\n                       A(i::=Zero)} \\<turnstile>\n                      SyntaxN.Ex i\n                       (Neg (OrdP (Var i) IMP A IMP A(i::=SUCC (Var i))))\n 2. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> atom\n                       k \\<sharp> (Var i,\n                                   SyntaxN.Ex i\n                                    (Neg\n(OrdP (Var i) IMP A IMP A(i::=SUCC (Var i)))))\n 3. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>{Neg A, All2 j (Var i) (A(i::=Var j)),\nA(i::=Zero)}.\n                         atom k \\<sharp> C", "apply (rule Ex_I [where x=\"Var k\"], simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {Var i EQ SUCC (Var k), OrdP (Var k), Neg A,\n                       All2 j (Var i) (A(i::=Var j)),\n                       A(i::=Zero)} \\<turnstile>\n                      Neg (OrdP (Var k) IMP\n                           A(i::=Var k) IMP A(i::=SUCC (Var k)))\n 2. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> atom\n                       k \\<sharp> (Var i,\n                                   SyntaxN.Ex i\n                                    (Neg\n(OrdP (Var i) IMP A IMP A(i::=SUCC (Var i)))))\n 3. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>{Neg A, All2 j (Var i) (A(i::=Var j)),\nA(i::=Zero)}.\n                         atom k \\<sharp> C", "apply (rule Neg_Imp_I, blast)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {A(i::=Var k) IMP A(i::=SUCC (Var k)),\n                       Var i EQ SUCC (Var k), OrdP (Var k), Neg A,\n                       All2 j (Var i) (A(i::=Var j)),\n                       A(i::=Zero)} \\<turnstile>\n                      Fls\n 2. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> atom\n                       k \\<sharp> (Var i,\n                                   SyntaxN.Ex i\n                                    (Neg\n(OrdP (Var i) IMP A IMP A(i::=SUCC (Var i)))))\n 3. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>{Neg A, All2 j (Var i) (A(i::=Var j)),\nA(i::=Zero)}.\n                         atom k \\<sharp> C", "apply (rule cut_same [where A = \"A(i::=Var k)\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {A(i::=Var k) IMP A(i::=SUCC (Var k)),\n                       Var i EQ SUCC (Var k), OrdP (Var k), Neg A,\n                       All2 j (Var i) (A(i::=Var j)),\n                       A(i::=Zero)} \\<turnstile>\n                      A(i::=Var k)\n 2. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {A(i::=Var k), A(i::=Var k) IMP A(i::=SUCC (Var k)),\n                       Var i EQ SUCC (Var k), OrdP (Var k), Neg A,\n                       All2 j (Var i) (A(i::=Var j)),\n                       A(i::=Zero)} \\<turnstile>\n                      Fls\n 3. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> atom\n                       k \\<sharp> (Var i,\n                                   SyntaxN.Ex i\n                                    (Neg\n(OrdP (Var i) IMP A IMP A(i::=SUCC (Var i)))))\n 4. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>{Neg A, All2 j (Var i) (A(i::=Var j)),\nA(i::=Zero)}.\n                         atom k \\<sharp> C", "apply (rule All2_E [where x = \"Var k\", THEN rotate5])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> atom j \\<sharp> Var i\n 2. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {A(i::=Var k) IMP A(i::=SUCC (Var k)),\n                       Var i EQ SUCC (Var k), OrdP (Var k), Neg A,\n                       A(i::=Zero)} \\<turnstile>\n                      Var k IN Var i\n 3. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {(A(i::=Var j))(j::=Var k),\n                       A(i::=Var k) IMP A(i::=SUCC (Var k)),\n                       Var i EQ SUCC (Var k), OrdP (Var k), Neg A,\n                       A(i::=Zero)} \\<turnstile>\n                      A(i::=Var k)\n 4. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {A(i::=Var k), A(i::=Var k) IMP A(i::=SUCC (Var k)),\n                       Var i EQ SUCC (Var k), OrdP (Var k), Neg A,\n                       All2 j (Var i) (A(i::=Var j)),\n                       A(i::=Zero)} \\<turnstile>\n                      Fls\n 5. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> atom\n                       k \\<sharp> (Var i,\n                                   SyntaxN.Ex i\n                                    (Neg\n(OrdP (Var i) IMP A IMP A(i::=SUCC (Var i)))))\n 6. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>{Neg A, All2 j (Var i) (A(i::=Var j)),\nA(i::=Zero)}.\n                         atom k \\<sharp> C", "apply (auto intro: Mem_SUCC_I2 Mem_cong [OF Refl, THEN Iff_MP2_same])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {A(i::=SUCC (Var k)), A(i::=Var k),\n                       Var i EQ SUCC (Var k), OrdP (Var k), Neg A,\n                       A(i::=Zero)} \\<turnstile>\n                      SyntaxN.Ex j (Neg (Var j IN Var i IMP A(i::=Var j)))", "apply (rule ContraProve [THEN rotate5])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom j \\<sharp> (i, A); atom k \\<sharp> (i, j, A)\\<rbrakk>\n    \\<Longrightarrow> {A(i::=SUCC (Var k)), A(i::=Var k),\n                       Var i EQ SUCC (Var k), OrdP (Var k),\n                       A(i::=Zero)} \\<turnstile>\n                      A", "by (metis Assume Iff_MP_left' Var_Eq_subst_Iff thin1)"], ["proof (state)\nthis:\n  {OrdP (Var i), A(i::=Zero),\n   SyntaxN.All i (OrdP (Var i) IMP A IMP A(i::=SUCC (Var i)))} \\<turnstile>\n  A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OrdInd2:\n  assumes \"H \\<turnstile> OrdP (Var i)\"\n      and \"H \\<turnstile> A(i::= Zero)\"\n      and \"H \\<turnstile> All i (OrdP (Var i) IMP A IMP (A(i::= SUCC (Var i))))\"\n    shows \"H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> A", "by (metis cut3 [OF OrdInd2_lemma] assms)"], ["", "lemma OrdInd2H:\n  assumes \"H \\<turnstile> A(i::= Zero)\"\n      and \"H \\<turnstile> All i (OrdP (Var i) IMP A IMP (A(i::= SUCC (Var i))))\"\n    shows \"insert (OrdP (Var i)) H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (OrdP (Var i)) H \\<turnstile> A", "by (metis assms thin1 Assume OrdInd2)"], ["", "section \\<open>The predicate \\<open>HFun_Sigma\\<close>\\<close>"], ["", "text\\<open>To characterise the concept of a function using only bounded universal quantifiers.\\<close>"], ["", "text\\<open>See the note after the proof of Lemma 2.3.\\<close>"], ["", "definition hfun_sigma where\n \"hfun_sigma r \\<equiv> \\<forall>z \\<^bold>\\<in> r. \\<forall>z' \\<^bold>\\<in> r. \\<exists>x y x' y'. z = \\<langle>x,y\\<rangle> \\<and> z' = \\<langle>x',y'\\<rangle> \\<and> (x=x' \\<longrightarrow> y=y')\""], ["", "definition hfun_sigma_ord where\n \"hfun_sigma_ord r \\<equiv> \\<forall>z \\<^bold>\\<in> r. \\<forall>z' \\<^bold>\\<in> r. \\<exists>x y x' y'. z = \\<langle>x,y\\<rangle> \\<and> z' = \\<langle>x',y'\\<rangle> \\<and> Ord x \\<and> Ord x' \\<and> (x=x' \\<longrightarrow> y=y')\""], ["", "nominal_function HFun_Sigma :: \"tm \\<Rightarrow> fm\"\n  where \"\\<lbrakk>atom z \\<sharp> (r,z',x,y,x',y'); atom z' \\<sharp> (r,x,y,x',y'); \n          atom x \\<sharp> (r,y,x',y'); atom y \\<sharp> (r,x',y'); atom x' \\<sharp> (r,y'); atom y' \\<sharp> (r) \\<rbrakk> \\<Longrightarrow>\n    HFun_Sigma r = \n         All2 z r (All2 z' r (Ex x (Ex y (Ex x' (Ex y'\n             (Var z EQ HPair (Var x) (Var y) AND Var z' EQ HPair (Var x') (Var y')\n              AND OrdP (Var x) AND OrdP (Var x') AND \n              ((Var x EQ Var x') IMP (Var y EQ Var y'))))))))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt HFun_Sigma_graph_aux\n 2. \\<And>x y. HFun_Sigma_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>z r z' xa y x' y'.\n           \\<lbrakk>atom z \\<sharp> (r, z', xa, y, x', y');\n            atom z' \\<sharp> (r, xa, y, x', y');\n            atom xa \\<sharp> (r, y, x', y'); atom y \\<sharp> (r, x', y');\n            atom x' \\<sharp> (r, y'); atom y' \\<sharp> r; x = r\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>z r z' x y x' y' za ra z'a xa ya x'a y'a.\n       \\<lbrakk>atom z \\<sharp> (r, z', x, y, x', y');\n        atom z' \\<sharp> (r, x, y, x', y'); atom x \\<sharp> (r, y, x', y');\n        atom y \\<sharp> (r, x', y'); atom x' \\<sharp> (r, y');\n        atom y' \\<sharp> r; atom za \\<sharp> (ra, z'a, xa, ya, x'a, y'a);\n        atom z'a \\<sharp> (ra, xa, ya, x'a, y'a);\n        atom xa \\<sharp> (ra, ya, x'a, y'a);\n        atom ya \\<sharp> (ra, x'a, y'a); atom x'a \\<sharp> (ra, y'a);\n        atom y'a \\<sharp> ra; r = ra\\<rbrakk>\n       \\<Longrightarrow> All2 z r\n                          (All2 z' r\n                            (SyntaxN.Ex x\n                              (SyntaxN.Ex y\n                                (SyntaxN.Ex x'\n                                  (SyntaxN.Ex y'\n                                    (Var z EQ HPair (Var x) (Var y) AND\n                                     Var z' EQ HPair (Var x') (Var y') AND\n                                     OrdP (Var x) AND\n                                     OrdP (Var x') AND\n                                     (Var x EQ Var x' IMP\nVar y EQ Var y'))))))) =\n                         All2 za ra\n                          (All2 z'a ra\n                            (SyntaxN.Ex xa\n                              (SyntaxN.Ex ya\n                                (SyntaxN.Ex x'a\n                                  (SyntaxN.Ex y'a\n                                    (Var za EQ HPair (Var xa) (Var ya) AND\n                                     Var z'a EQ\n                                     HPair (Var x'a) (Var y'a) AND\n                                     OrdP (Var xa) AND\n                                     OrdP (Var x'a) AND\n                                     (Var xa EQ Var x'a IMP\nVar ya EQ Var y'a)))))))", "by (auto simp: eqvt_def HFun_Sigma_graph_aux_def flip_fresh_fresh) (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All HFun_Sigma_dom", "by lexicographic_order"], ["", "lemma\n  shows HFun_Sigma_fresh_iff [simp]: \"a \\<sharp> HFun_Sigma r \\<longleftrightarrow> a \\<sharp> r\" (is ?thesis1)\n    and eval_fm_HFun_Sigma [simp]:\n         \"eval_fm e (HFun_Sigma r) \\<longleftrightarrow> hfun_sigma_ord \\<lbrakk>r\\<rbrakk>e\" (is ?thesis2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> HFun_Sigma r = a \\<sharp> r &&&\n    eval_fm e (HFun_Sigma r) = hfun_sigma_ord \\<lbrakk>r\\<rbrakk>e", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<sharp> HFun_Sigma r = a \\<sharp> r\n 2. eval_fm e (HFun_Sigma r) = hfun_sigma_ord \\<lbrakk>r\\<rbrakk>e", "obtain x::name and y::name and z::name and x'::name and y'::name and z'::name\n    where \"atom z \\<sharp> (r,z',x,y,x',y')\"  \"atom z' \\<sharp> (r,x,y,x',y')\"\n          \"atom x \\<sharp> (r,y,x',y')\"  \"atom y \\<sharp> (r,x',y')\" \n          \"atom x' \\<sharp> (r,y')\"  \"atom y' \\<sharp> (r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z z' x y x' y'.\n        \\<lbrakk>atom z \\<sharp> (r, z', x, y, x', y');\n         atom z' \\<sharp> (r, x, y, x', y'); atom x \\<sharp> (r, y, x', y');\n         atom y \\<sharp> (r, x', y'); atom x' \\<sharp> (r, y');\n         atom y' \\<sharp> r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom z \\<sharp> (r, z', x, y, x', y')\n  atom z' \\<sharp> (r, x, y, x', y')\n  atom x \\<sharp> (r, y, x', y')\n  atom y \\<sharp> (r, x', y')\n  atom x' \\<sharp> (r, y')\n  atom y' \\<sharp> r\n\ngoal (2 subgoals):\n 1. a \\<sharp> HFun_Sigma r = a \\<sharp> r\n 2. eval_fm e (HFun_Sigma r) = hfun_sigma_ord \\<lbrakk>r\\<rbrakk>e", "thus ?thesis1 ?thesis2"], ["proof (prove)\nusing this:\n  atom z \\<sharp> (r, z', x, y, x', y')\n  atom z' \\<sharp> (r, x, y, x', y')\n  atom x \\<sharp> (r, y, x', y')\n  atom y \\<sharp> (r, x', y')\n  atom x' \\<sharp> (r, y')\n  atom y' \\<sharp> r\n\ngoal (1 subgoal):\n 1. a \\<sharp> HFun_Sigma r = a \\<sharp> r &&&\n    eval_fm e (HFun_Sigma r) = hfun_sigma_ord \\<lbrakk>r\\<rbrakk>e", "by (auto simp: HBall_def hfun_sigma_ord_def, metis+)"], ["proof (state)\nthis:\n  a \\<sharp> HFun_Sigma r = a \\<sharp> r\n  eval_fm e (HFun_Sigma r) = hfun_sigma_ord \\<lbrakk>r\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HFun_Sigma_subst [simp]: \"(HFun_Sigma r)(i::=t) = HFun_Sigma (subst i t r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HFun_Sigma r)(i::=t) = HFun_Sigma (subst i t r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (HFun_Sigma r)(i::=t) = HFun_Sigma (subst i t r)", "obtain x::name and y::name and z::name and x'::name and y'::name and z'::name\n    where \"atom z \\<sharp> (r,t,i,z',x,y,x',y')\" \"atom z' \\<sharp> (r,t,i,x,y,x',y')\"\n          \"atom x \\<sharp> (r,t,i,y,x',y')\" \"atom y \\<sharp> (r,t,i,x',y')\" \n          \"atom x' \\<sharp> (r,t,i,y')\" \"atom y' \\<sharp> (r,t,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z z' x y x' y'.\n        \\<lbrakk>atom z \\<sharp> (r, t, i, z', x, y, x', y');\n         atom z' \\<sharp> (r, t, i, x, y, x', y');\n         atom x \\<sharp> (r, t, i, y, x', y');\n         atom y \\<sharp> (r, t, i, x', y'); atom x' \\<sharp> (r, t, i, y');\n         atom y' \\<sharp> (r, t, i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom z \\<sharp> (r, t, i, z', x, y, x', y')\n  atom z' \\<sharp> (r, t, i, x, y, x', y')\n  atom x \\<sharp> (r, t, i, y, x', y')\n  atom y \\<sharp> (r, t, i, x', y')\n  atom x' \\<sharp> (r, t, i, y')\n  atom y' \\<sharp> (r, t, i)\n\ngoal (1 subgoal):\n 1. (HFun_Sigma r)(i::=t) = HFun_Sigma (subst i t r)", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom z \\<sharp> (r, t, i, z', x, y, x', y')\n  atom z' \\<sharp> (r, t, i, x, y, x', y')\n  atom x \\<sharp> (r, t, i, y, x', y')\n  atom y \\<sharp> (r, t, i, x', y')\n  atom x' \\<sharp> (r, t, i, y')\n  atom y' \\<sharp> (r, t, i)\n\ngoal (1 subgoal):\n 1. (HFun_Sigma r)(i::=t) = HFun_Sigma (subst i t r)", "by (auto simp: HFun_Sigma.simps [of z _ z' x y x' y'])"], ["proof (state)\nthis:\n  (HFun_Sigma r)(i::=t) = HFun_Sigma (subst i t r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HFun_Sigma_Zero: \"H \\<turnstile> HFun_Sigma Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> HFun_Sigma Zero", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H \\<turnstile> HFun_Sigma Zero", "obtain x::name and y::name and z::name and x'::name and y'::name and z'::name and z''::name\n    where \"atom z'' \\<sharp> (z,z',x,y,x',y')\" \"atom z \\<sharp> (z',x,y,x',y')\" \"atom z' \\<sharp> (x,y,x',y')\"\n      \"atom x \\<sharp> (y,x',y')\" \"atom y \\<sharp> (x',y')\" \"atom x' \\<sharp> y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z'' z z' x y x' y'.\n        \\<lbrakk>atom z'' \\<sharp> (z, z', x, y, x', y');\n         atom z \\<sharp> (z', x, y, x', y');\n         atom z' \\<sharp> (x, y, x', y'); atom x \\<sharp> (y, x', y');\n         atom y \\<sharp> (x', y'); atom x' \\<sharp> y'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom z'' \\<sharp> (z, z', x, y, x', y')\n  atom z \\<sharp> (z', x, y, x', y')\n  atom z' \\<sharp> (x, y, x', y')\n  atom x \\<sharp> (y, x', y')\n  atom y \\<sharp> (x', y')\n  atom x' \\<sharp> y'\n\ngoal (1 subgoal):\n 1. H \\<turnstile> HFun_Sigma Zero", "hence \"{} \\<turnstile> HFun_Sigma Zero\""], ["proof (prove)\nusing this:\n  atom z'' \\<sharp> (z, z', x, y, x', y')\n  atom z \\<sharp> (z', x, y, x', y')\n  atom z' \\<sharp> (x, y, x', y')\n  atom x \\<sharp> (y, x', y')\n  atom y \\<sharp> (x', y')\n  atom x' \\<sharp> y'\n\ngoal (1 subgoal):\n 1. {} \\<turnstile> HFun_Sigma Zero", "by (auto simp: HFun_Sigma.simps [of z _ z' x y x' y'])"], ["proof (state)\nthis:\n  {} \\<turnstile> HFun_Sigma Zero\n\ngoal (1 subgoal):\n 1. H \\<turnstile> HFun_Sigma Zero", "thus ?thesis"], ["proof (prove)\nusing this:\n  {} \\<turnstile> HFun_Sigma Zero\n\ngoal (1 subgoal):\n 1. H \\<turnstile> HFun_Sigma Zero", "by (metis thin0)"], ["proof (state)\nthis:\n  H \\<turnstile> HFun_Sigma Zero\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Subset_HFun_Sigma: \"{HFun_Sigma s, s' SUBS s} \\<turnstile> HFun_Sigma s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {HFun_Sigma s, s' SUBS s} \\<turnstile> HFun_Sigma s'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {HFun_Sigma s, s' SUBS s} \\<turnstile> HFun_Sigma s'", "obtain x::name and y::name and z::name and x'::name and y'::name and z'::name and z''::name\n    where \"atom z'' \\<sharp> (z,z',x,y,x',y',s,s')\" \n      \"atom z \\<sharp> (z',x,y,x',y',s,s')\" \"atom z' \\<sharp> (x,y,x',y',s,s')\"\n      \"atom x \\<sharp> (y,x',y',s,s')\" \"atom y \\<sharp> (x',y',s,s')\" \n      \"atom x' \\<sharp> (y',s,s')\" \"atom y' \\<sharp> (s,s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z'' z z' x y x' y'.\n        \\<lbrakk>atom z'' \\<sharp> (z, z', x, y, x', y', s, s');\n         atom z \\<sharp> (z', x, y, x', y', s, s');\n         atom z' \\<sharp> (x, y, x', y', s, s');\n         atom x \\<sharp> (y, x', y', s, s');\n         atom y \\<sharp> (x', y', s, s'); atom x' \\<sharp> (y', s, s');\n         atom y' \\<sharp> (s, s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom z'' \\<sharp> (z, z', x, y, x', y', s, s')\n  atom z \\<sharp> (z', x, y, x', y', s, s')\n  atom z' \\<sharp> (x, y, x', y', s, s')\n  atom x \\<sharp> (y, x', y', s, s')\n  atom y \\<sharp> (x', y', s, s')\n  atom x' \\<sharp> (y', s, s')\n  atom y' \\<sharp> (s, s')\n\ngoal (1 subgoal):\n 1. {HFun_Sigma s, s' SUBS s} \\<turnstile> HFun_Sigma s'", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom z'' \\<sharp> (z, z', x, y, x', y', s, s')\n  atom z \\<sharp> (z', x, y, x', y', s, s')\n  atom z' \\<sharp> (x, y, x', y', s, s')\n  atom x \\<sharp> (y, x', y', s, s')\n  atom y \\<sharp> (x', y', s, s')\n  atom x' \\<sharp> (y', s, s')\n  atom y' \\<sharp> (s, s')\n\ngoal (1 subgoal):\n 1. {HFun_Sigma s, s' SUBS s} \\<turnstile> HFun_Sigma s'", "apply (auto simp: HFun_Sigma.simps [of z _ z' x y x' y'])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom z'' \\<sharp> (z, z', x, y, x', y', s, s');\n     atom z \\<sharp> (z', x, y, x', y', s, s');\n     atom z' \\<sharp> (x, y, x', y', s, s');\n     atom x \\<sharp> (y, x', y', s, s'); atom y \\<sharp> (x', y', s, s');\n     atom x' \\<sharp> (y', s, s'); atom y' \\<sharp> (s, s')\\<rbrakk>\n    \\<Longrightarrow> {Neg (SyntaxN.Ex x\n                             (SyntaxN.Ex y\n                               (SyntaxN.Ex x'\n                                 (SyntaxN.Ex y'\n                                   (Var z EQ HPair (Var x) (Var y) AND\n                                    Var z' EQ HPair (Var x') (Var y') AND\n                                    OrdP (Var x) AND\n                                    OrdP (Var x') AND\n                                    (Var x EQ Var x' IMP\n                                     Var y EQ Var y')))))),\n                       Var z' IN s', Var z IN s', s' SUBS s} \\<turnstile>\n                      SyntaxN.Ex z\n                       (Neg (Var z IN s IMP\n                             All2 z' s\n                              (SyntaxN.Ex x\n                                (SyntaxN.Ex y\n                                  (SyntaxN.Ex x'\n                                    (SyntaxN.Ex y'\n(Var z EQ HPair (Var x) (Var y) AND\n Var z' EQ HPair (Var x') (Var y') AND\n OrdP (Var x) AND\n OrdP (Var x') AND (Var x EQ Var x' IMP Var y EQ Var y'))))))))", "apply (rule Ex_I [where x=\"Var z\"], auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom z'' \\<sharp> (z, z', x, y, x', y', s, s');\n     atom z \\<sharp> (z', x, y, x', y', s, s');\n     atom z' \\<sharp> (x, y, x', y', s, s');\n     atom x \\<sharp> (y, x', y', s, s'); atom y \\<sharp> (x', y', s, s');\n     atom x' \\<sharp> (y', s, s'); atom y' \\<sharp> (s, s')\\<rbrakk>\n    \\<Longrightarrow> {Neg (Var z IN s), Var z' IN s', Var z IN s',\n                       s' SUBS s} \\<turnstile>\n                      SyntaxN.Ex x\n                       (SyntaxN.Ex y\n                         (SyntaxN.Ex x'\n                           (SyntaxN.Ex y'\n                             (Var z EQ HPair (Var x) (Var y) AND\n                              Var z' EQ HPair (Var x') (Var y') AND\n                              OrdP (Var x) AND\n                              OrdP (Var x') AND\n                              (Var x EQ Var x' IMP Var y EQ Var y')))))\n 2. \\<lbrakk>atom z'' \\<sharp> (z, z', x, y, x', y', s, s');\n     atom z \\<sharp> (z', x, y, x', y', s, s');\n     atom z' \\<sharp> (x, y, x', y', s, s');\n     atom x \\<sharp> (y, x', y', s, s'); atom y \\<sharp> (x', y', s, s');\n     atom x' \\<sharp> (y', s, s'); atom y' \\<sharp> (s, s')\\<rbrakk>\n    \\<Longrightarrow> {All2 z' s\n                        (SyntaxN.Ex x\n                          (SyntaxN.Ex y\n                            (SyntaxN.Ex x'\n                              (SyntaxN.Ex y'\n                                (Var z EQ HPair (Var x) (Var y) AND\n                                 Var z' EQ HPair (Var x') (Var y') AND\n                                 OrdP (Var x) AND\n                                 OrdP (Var x') AND\n                                 (Var x EQ Var x' IMP Var y EQ Var y')))))),\n                       Var z' IN s', Var z IN s', s' SUBS s} \\<turnstile>\n                      SyntaxN.Ex x\n                       (SyntaxN.Ex y\n                         (SyntaxN.Ex x'\n                           (SyntaxN.Ex y'\n                             (Var z EQ HPair (Var x) (Var y) AND\n                              Var z' EQ HPair (Var x') (Var y') AND\n                              OrdP (Var x) AND\n                              OrdP (Var x') AND\n                              (Var x EQ Var x' IMP Var y EQ Var y')))))", "apply (blast intro: Subset_D ContraProve)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom z'' \\<sharp> (z, z', x, y, x', y', s, s');\n     atom z \\<sharp> (z', x, y, x', y', s, s');\n     atom z' \\<sharp> (x, y, x', y', s, s');\n     atom x \\<sharp> (y, x', y', s, s'); atom y \\<sharp> (x', y', s, s');\n     atom x' \\<sharp> (y', s, s'); atom y' \\<sharp> (s, s')\\<rbrakk>\n    \\<Longrightarrow> {All2 z' s\n                        (SyntaxN.Ex x\n                          (SyntaxN.Ex y\n                            (SyntaxN.Ex x'\n                              (SyntaxN.Ex y'\n                                (Var z EQ HPair (Var x) (Var y) AND\n                                 Var z' EQ HPair (Var x') (Var y') AND\n                                 OrdP (Var x) AND\n                                 OrdP (Var x') AND\n                                 (Var x EQ Var x' IMP Var y EQ Var y')))))),\n                       Var z' IN s', Var z IN s', s' SUBS s} \\<turnstile>\n                      SyntaxN.Ex x\n                       (SyntaxN.Ex y\n                         (SyntaxN.Ex x'\n                           (SyntaxN.Ex y'\n                             (Var z EQ HPair (Var x) (Var y) AND\n                              Var z' EQ HPair (Var x') (Var y') AND\n                              OrdP (Var x) AND\n                              OrdP (Var x') AND\n                              (Var x EQ Var x' IMP Var y EQ Var y')))))", "apply (rule All_E [where x=\"Var z'\"], auto intro: Subset_D ContraProve)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {HFun_Sigma s, s' SUBS s} \\<turnstile> HFun_Sigma s'\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Captures the property of being a relation, using fewer variables than the full definition\\<close>"], ["", "lemma HFun_Sigma_Mem_imp_HPair:\n  assumes \"H \\<turnstile> HFun_Sigma r\" \"H \\<turnstile> a IN r\"\n      and xy: \"atom x \\<sharp> (y,a,r)\" \"atom y \\<sharp> (a,r)\"\n    shows \"H \\<turnstile> (Ex x (Ex y (a EQ HPair (Var x) (Var y))))\"  (is \"_ \\<turnstile> ?concl\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> SyntaxN.Ex x (SyntaxN.Ex y (a EQ HPair (Var x) (Var y)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H \\<turnstile> SyntaxN.Ex x (SyntaxN.Ex y (a EQ HPair (Var x) (Var y)))", "obtain x'::name and y'::name and z::name and z'::name\n    where atoms: \"atom z \\<sharp> (z',x',y',x,y,a,r)\" \"atom z' \\<sharp> (x',y',x,y,a,r)\"\n                 \"atom x' \\<sharp> (y',x,y,a,r)\" \"atom y' \\<sharp> (x,y,a,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z z' x' y'.\n        \\<lbrakk>atom z \\<sharp> (z', x', y', x, y, a, r);\n         atom z' \\<sharp> (x', y', x, y, a, r);\n         atom x' \\<sharp> (y', x, y, a, r);\n         atom y' \\<sharp> (x, y, a, r)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom z \\<sharp> (z', x', y', x, y, a, r)\n  atom z' \\<sharp> (x', y', x, y, a, r)\n  atom x' \\<sharp> (y', x, y, a, r)\n  atom y' \\<sharp> (x, y, a, r)\n\ngoal (1 subgoal):\n 1. H \\<turnstile> SyntaxN.Ex x (SyntaxN.Ex y (a EQ HPair (Var x) (Var y)))", "hence \"{HFun_Sigma r, a IN r} \\<turnstile> ?concl\""], ["proof (prove)\nusing this:\n  atom z \\<sharp> (z', x', y', x, y, a, r)\n  atom z' \\<sharp> (x', y', x, y, a, r)\n  atom x' \\<sharp> (y', x, y, a, r)\n  atom y' \\<sharp> (x, y, a, r)\n\ngoal (1 subgoal):\n 1. {HFun_Sigma r, a IN r} \\<turnstile>\n    SyntaxN.Ex x (SyntaxN.Ex y (a EQ HPair (Var x) (Var y)))", "using xy"], ["proof (prove)\nusing this:\n  atom z \\<sharp> (z', x', y', x, y, a, r)\n  atom z' \\<sharp> (x', y', x, y, a, r)\n  atom x' \\<sharp> (y', x, y, a, r)\n  atom y' \\<sharp> (x, y, a, r)\n  atom x \\<sharp> (y, a, r)\n  atom y \\<sharp> (a, r)\n\ngoal (1 subgoal):\n 1. {HFun_Sigma r, a IN r} \\<turnstile>\n    SyntaxN.Ex x (SyntaxN.Ex y (a EQ HPair (Var x) (Var y)))", "apply (auto simp: HFun_Sigma.simps [of z r z' x y x' y'])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom z \\<sharp> (z', x', y', x, y, a, r);\n     atom z' \\<sharp> (x', y', x, y, a, r);\n     atom x' \\<sharp> (y', x, y, a, r); atom y' \\<sharp> (x, y, a, r);\n     atom x \\<sharp> (y, a, r); atom y \\<sharp> (a, r)\\<rbrakk>\n    \\<Longrightarrow> {All2 z r\n                        (All2 z' r\n                          (SyntaxN.Ex x\n                            (SyntaxN.Ex y\n                              (SyntaxN.Ex x'\n                                (SyntaxN.Ex y'\n                                  (Var z EQ HPair (Var x) (Var y) AND\n                                   Var z' EQ HPair (Var x') (Var y') AND\n                                   OrdP (Var x) AND\n                                   OrdP (Var x') AND\n                                   (Var x EQ Var x' IMP\n                                    Var y EQ Var y'))))))),\n                       a IN r} \\<turnstile>\n                      SyntaxN.Ex x\n                       (SyntaxN.Ex y (a EQ HPair (Var x) (Var y)))", "apply (rule All_E [where x=a], auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom z \\<sharp> (z', x', y', x, y, a, r);\n     atom z' \\<sharp> (x', y', x, y, a, r);\n     atom x' \\<sharp> (y', x, y, a, r); atom y' \\<sharp> (x, y, a, r);\n     atom x \\<sharp> (y, a, r); atom y \\<sharp> (a, r)\\<rbrakk>\n    \\<Longrightarrow> {All2 z' r\n                        (SyntaxN.Ex x\n                          (SyntaxN.Ex y\n                            (SyntaxN.Ex x'\n                              (SyntaxN.Ex y'\n                                (a EQ HPair (Var x) (Var y) AND\n                                 Var z' EQ HPair (Var x') (Var y') AND\n                                 OrdP (Var x) AND\n                                 OrdP (Var x') AND\n                                 (Var x EQ Var x' IMP Var y EQ Var y')))))),\n                       a IN r} \\<turnstile>\n                      SyntaxN.Ex x\n                       (SyntaxN.Ex y (a EQ HPair (Var x) (Var y)))", "apply (rule All_E [where x=a], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom z \\<sharp> (z', x', y', x, y, a, r);\n     atom z' \\<sharp> (x', y', x, y, a, r);\n     atom x' \\<sharp> (y', x, y, a, r); atom y' \\<sharp> (x, y, a, r);\n     atom x \\<sharp> (y, a, r); atom y \\<sharp> (a, r)\\<rbrakk>\n    \\<Longrightarrow> {a IN r IMP\n                       SyntaxN.Ex x\n                        (SyntaxN.Ex y\n                          (SyntaxN.Ex x'\n                            (SyntaxN.Ex y'\n                              (a EQ HPair (Var x) (Var y) AND\n                               a EQ HPair (Var x') (Var y') AND\n                               OrdP (Var x) AND\n                               OrdP (Var x') AND\n                               (Var x EQ Var x' IMP Var y EQ Var y'))))),\n                       a IN r} \\<turnstile>\n                      SyntaxN.Ex x\n                       (SyntaxN.Ex y (a EQ HPair (Var x) (Var y)))", "apply (rule Imp_E, blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom z \\<sharp> (z', x', y', x, y, a, r);\n     atom z' \\<sharp> (x', y', x, y, a, r);\n     atom x' \\<sharp> (y', x, y, a, r); atom y' \\<sharp> (x, y, a, r);\n     atom x \\<sharp> (y, a, r); atom y \\<sharp> (a, r)\\<rbrakk>\n    \\<Longrightarrow> {SyntaxN.Ex x\n                        (SyntaxN.Ex y\n                          (SyntaxN.Ex x'\n                            (SyntaxN.Ex y'\n                              (a EQ HPair (Var x) (Var y) AND\n                               a EQ HPair (Var x') (Var y') AND\n                               OrdP (Var x) AND\n                               OrdP (Var x') AND\n                               (Var x EQ Var x' IMP Var y EQ Var y'))))),\n                       a IN r} \\<turnstile>\n                      SyntaxN.Ex x\n                       (SyntaxN.Ex y (a EQ HPair (Var x) (Var y)))", "apply (rule Ex_EH Conj_EH)+"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>atom z \\<sharp> (z', x', y', x, y, a, r);\n     atom z' \\<sharp> (x', y', x, y, a, r);\n     atom x' \\<sharp> (y', x, y, a, r); atom y' \\<sharp> (x, y, a, r);\n     atom x \\<sharp> (y, a, r); atom y \\<sharp> (a, r)\\<rbrakk>\n    \\<Longrightarrow> {OrdP (Var x'), Var x EQ Var x' IMP Var y EQ Var y',\n                       OrdP (Var x), a EQ HPair (Var x') (Var y'),\n                       a EQ HPair (Var x) (Var y), a IN r} \\<turnstile>\n                      SyntaxN.Ex x\n                       (SyntaxN.Ex y (a EQ HPair (Var x) (Var y)))\n 2. \\<lbrakk>atom z \\<sharp> (z', x', y', x, y, a, r);\n     atom z' \\<sharp> (x', y', x, y, a, r);\n     atom x' \\<sharp> (y', x, y, a, r); atom y' \\<sharp> (x, y, a, r);\n     atom x \\<sharp> (y, a, r); atom y \\<sharp> (a, r)\\<rbrakk>\n    \\<Longrightarrow> atom\n                       y' \\<sharp> SyntaxN.Ex x\n                                    (SyntaxN.Ex y\n(a EQ HPair (Var x) (Var y)))\n 3. \\<lbrakk>atom z \\<sharp> (z', x', y', x, y, a, r);\n     atom z' \\<sharp> (x', y', x, y, a, r);\n     atom x' \\<sharp> (y', x, y, a, r); atom y' \\<sharp> (x, y, a, r);\n     atom x \\<sharp> (y, a, r); atom y \\<sharp> (a, r)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>{a IN r}. atom y' \\<sharp> C\n 4. \\<lbrakk>atom z \\<sharp> (z', x', y', x, y, a, r);\n     atom z' \\<sharp> (x', y', x, y, a, r);\n     atom x' \\<sharp> (y', x, y, a, r); atom y' \\<sharp> (x, y, a, r);\n     atom x \\<sharp> (y, a, r); atom y \\<sharp> (a, r)\\<rbrakk>\n    \\<Longrightarrow> atom\n                       x' \\<sharp> SyntaxN.Ex x\n                                    (SyntaxN.Ex y\n(a EQ HPair (Var x) (Var y)))\n 5. \\<lbrakk>atom z \\<sharp> (z', x', y', x, y, a, r);\n     atom z' \\<sharp> (x', y', x, y, a, r);\n     atom x' \\<sharp> (y', x, y, a, r); atom y' \\<sharp> (x, y, a, r);\n     atom x \\<sharp> (y, a, r); atom y \\<sharp> (a, r)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>{a IN r}. atom x' \\<sharp> C\n 6. \\<lbrakk>atom z \\<sharp> (z', x', y', x, y, a, r);\n     atom z' \\<sharp> (x', y', x, y, a, r);\n     atom x' \\<sharp> (y', x, y, a, r); atom y' \\<sharp> (x, y, a, r);\n     atom x \\<sharp> (y, a, r); atom y \\<sharp> (a, r)\\<rbrakk>\n    \\<Longrightarrow> atom\n                       y \\<sharp> SyntaxN.Ex x\n                                   (SyntaxN.Ex y\n                                     (a EQ HPair (Var x) (Var y)))\n 7. \\<lbrakk>atom z \\<sharp> (z', x', y', x, y, a, r);\n     atom z' \\<sharp> (x', y', x, y, a, r);\n     atom x' \\<sharp> (y', x, y, a, r); atom y' \\<sharp> (x, y, a, r);\n     atom x \\<sharp> (y, a, r); atom y \\<sharp> (a, r)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>{a IN r}. atom y \\<sharp> C\n 8. \\<lbrakk>atom z \\<sharp> (z', x', y', x, y, a, r);\n     atom z' \\<sharp> (x', y', x, y, a, r);\n     atom x' \\<sharp> (y', x, y, a, r); atom y' \\<sharp> (x, y, a, r);\n     atom x \\<sharp> (y, a, r); atom y \\<sharp> (a, r)\\<rbrakk>\n    \\<Longrightarrow> atom\n                       x \\<sharp> SyntaxN.Ex x\n                                   (SyntaxN.Ex y\n                                     (a EQ HPair (Var x) (Var y)))\n 9. \\<lbrakk>atom z \\<sharp> (z', x', y', x, y, a, r);\n     atom z' \\<sharp> (x', y', x, y, a, r);\n     atom x' \\<sharp> (y', x, y, a, r); atom y' \\<sharp> (x, y, a, r);\n     atom x \\<sharp> (y, a, r); atom y \\<sharp> (a, r)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>{a IN r}. atom x \\<sharp> C", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom z \\<sharp> (z', x', y', x, y, a, r);\n     atom z' \\<sharp> (x', y', x, y, a, r);\n     atom x' \\<sharp> (y', x, y, a, r); atom y' \\<sharp> (x, y, a, r);\n     atom x \\<sharp> (y, a, r); atom y \\<sharp> (a, r)\\<rbrakk>\n    \\<Longrightarrow> {OrdP (Var x'), Var x EQ Var x' IMP Var y EQ Var y',\n                       OrdP (Var x), a EQ HPair (Var x') (Var y'),\n                       a EQ HPair (Var x) (Var y), a IN r} \\<turnstile>\n                      SyntaxN.Ex x\n                       (SyntaxN.Ex y (a EQ HPair (Var x) (Var y)))", "apply (rule Ex_I [where x=\"Var x\"], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom z \\<sharp> (z', x', y', x, y, a, r);\n     atom z' \\<sharp> (x', y', x, y, a, r);\n     atom x' \\<sharp> (y', x, y, a, r); atom y' \\<sharp> (x, y, a, r);\n     atom x \\<sharp> (y, a, r); atom y \\<sharp> (a, r)\\<rbrakk>\n    \\<Longrightarrow> {OrdP (Var x'), Var x EQ Var x' IMP Var y EQ Var y',\n                       OrdP (Var x), a EQ HPair (Var x') (Var y'),\n                       a EQ HPair (Var x) (Var y), a IN r} \\<turnstile>\n                      SyntaxN.Ex y (a EQ HPair (Var x) (Var y))", "apply (rule Ex_I [where x=\"Var y\"], auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {HFun_Sigma r, a IN r} \\<turnstile>\n  SyntaxN.Ex x (SyntaxN.Ex y (a EQ HPair (Var x) (Var y)))\n\ngoal (1 subgoal):\n 1. H \\<turnstile> SyntaxN.Ex x (SyntaxN.Ex y (a EQ HPair (Var x) (Var y)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  {HFun_Sigma r, a IN r} \\<turnstile>\n  SyntaxN.Ex x (SyntaxN.Ex y (a EQ HPair (Var x) (Var y)))\n\ngoal (1 subgoal):\n 1. H \\<turnstile> SyntaxN.Ex x (SyntaxN.Ex y (a EQ HPair (Var x) (Var y)))", "by (rule cut2) (rule assms)+"], ["proof (state)\nthis:\n  H \\<turnstile> SyntaxN.Ex x (SyntaxN.Ex y (a EQ HPair (Var x) (Var y)))\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>The predicate \\<open>HDomain_Incl\\<close>\\<close>"], ["", "text \\<open>This is an internal version of @{term \"\\<forall>x \\<^bold>\\<in> d. \\<exists>y z. z \\<^bold>\\<in> r \\<and> z = \\<langle>x,y\\<rangle>\"}.\\<close>"], ["", "nominal_function HDomain_Incl :: \"tm \\<Rightarrow> tm \\<Rightarrow> fm\"\n  where \"\\<lbrakk>atom x \\<sharp> (r,d,y,z); atom y \\<sharp> (r,d,z); atom z \\<sharp> (r,d)\\<rbrakk> \\<Longrightarrow>\n    HDomain_Incl r d = All2 x d (Ex y (Ex z (Var z IN r AND Var z EQ HPair (Var x) (Var y))))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt HDomain_Incl_graph_aux\n 2. \\<And>x y. HDomain_Incl_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>xa r d y z.\n           \\<lbrakk>atom xa \\<sharp> (r, d, y, z);\n            atom y \\<sharp> (r, d, z); atom z \\<sharp> (r, d);\n            x = (r, d)\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 4. \\<And>x r d y z xa ra da ya za.\n       \\<lbrakk>atom x \\<sharp> (r, d, y, z); atom y \\<sharp> (r, d, z);\n        atom z \\<sharp> (r, d); atom xa \\<sharp> (ra, da, ya, za);\n        atom ya \\<sharp> (ra, da, za); atom za \\<sharp> (ra, da);\n        (r, d) = (ra, da)\\<rbrakk>\n       \\<Longrightarrow> All2 x d\n                          (SyntaxN.Ex y\n                            (SyntaxN.Ex z\n                              (Var z IN r AND\n                               Var z EQ HPair (Var x) (Var y)))) =\n                         All2 xa da\n                          (SyntaxN.Ex ya\n                            (SyntaxN.Ex za\n                              (Var za IN ra AND\n                               Var za EQ HPair (Var xa) (Var ya))))", "by (auto simp: eqvt_def HDomain_Incl_graph_aux_def flip_fresh_fresh) (metis obtain_fresh)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All HDomain_Incl_dom", "by lexicographic_order"], ["", "lemma\n  shows HDomain_Incl_fresh_iff [simp]:\n      \"a \\<sharp> HDomain_Incl r d \\<longleftrightarrow> a \\<sharp> r \\<and> a \\<sharp> d\" (is ?thesis1)\n  and   eval_fm_HDomain_Incl [simp]:\n      \"eval_fm e (HDomain_Incl r d) \\<longleftrightarrow> \\<lbrakk>d\\<rbrakk>e \\<le> hdomain \\<lbrakk>r\\<rbrakk>e\" (is ?thesis2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> HDomain_Incl r d = (a \\<sharp> r \\<and> a \\<sharp> d) &&&\n    eval_fm e (HDomain_Incl r d) =\n    (\\<lbrakk>d\\<rbrakk>e \\<le> hdomain \\<lbrakk>r\\<rbrakk>e)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<sharp> HDomain_Incl r d = (a \\<sharp> r \\<and> a \\<sharp> d)\n 2. eval_fm e (HDomain_Incl r d) =\n    (\\<lbrakk>d\\<rbrakk>e \\<le> hdomain \\<lbrakk>r\\<rbrakk>e)", "obtain x::name and y::name and z::name \n    where \"atom x \\<sharp> (r,d,y,z)\" \"atom y \\<sharp> (r,d,z)\" \"atom z \\<sharp> (r,d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y z.\n        \\<lbrakk>atom x \\<sharp> (r, d, y, z); atom y \\<sharp> (r, d, z);\n         atom z \\<sharp> (r, d)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom x \\<sharp> (r, d, y, z)\n  atom y \\<sharp> (r, d, z)\n  atom z \\<sharp> (r, d)\n\ngoal (2 subgoals):\n 1. a \\<sharp> HDomain_Incl r d = (a \\<sharp> r \\<and> a \\<sharp> d)\n 2. eval_fm e (HDomain_Incl r d) =\n    (\\<lbrakk>d\\<rbrakk>e \\<le> hdomain \\<lbrakk>r\\<rbrakk>e)", "thus ?thesis1 ?thesis2"], ["proof (prove)\nusing this:\n  atom x \\<sharp> (r, d, y, z)\n  atom y \\<sharp> (r, d, z)\n  atom z \\<sharp> (r, d)\n\ngoal (1 subgoal):\n 1. a \\<sharp> HDomain_Incl r d = (a \\<sharp> r \\<and> a \\<sharp> d) &&&\n    eval_fm e (HDomain_Incl r d) =\n    (\\<lbrakk>d\\<rbrakk>e \\<le> hdomain \\<lbrakk>r\\<rbrakk>e)", "by (auto simp: HDomain_Incl.simps [of x _ _ y z] hdomain_def)"], ["proof (state)\nthis:\n  a \\<sharp> HDomain_Incl r d = (a \\<sharp> r \\<and> a \\<sharp> d)\n  eval_fm e (HDomain_Incl r d) =\n  (\\<lbrakk>d\\<rbrakk>e \\<le> hdomain \\<lbrakk>r\\<rbrakk>e)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HDomain_Incl_subst [simp]:\n      \"(HDomain_Incl r d)(i::=t) = HDomain_Incl (subst i t r) (subst i t d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HDomain_Incl r d)(i::=t) = HDomain_Incl (subst i t r) (subst i t d)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (HDomain_Incl r d)(i::=t) = HDomain_Incl (subst i t r) (subst i t d)", "obtain x::name and y::name and z::name \n    where \"atom x \\<sharp> (r,d,y,z,t,i)\"  \"atom y \\<sharp> (r,d,z,t,i)\" \"atom z \\<sharp> (r,d,t,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y z.\n        \\<lbrakk>atom x \\<sharp> (r, d, y, z, t, i);\n         atom y \\<sharp> (r, d, z, t, i);\n         atom z \\<sharp> (r, d, t, i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom x \\<sharp> (r, d, y, z, t, i)\n  atom y \\<sharp> (r, d, z, t, i)\n  atom z \\<sharp> (r, d, t, i)\n\ngoal (1 subgoal):\n 1. (HDomain_Incl r d)(i::=t) = HDomain_Incl (subst i t r) (subst i t d)", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom x \\<sharp> (r, d, y, z, t, i)\n  atom y \\<sharp> (r, d, z, t, i)\n  atom z \\<sharp> (r, d, t, i)\n\ngoal (1 subgoal):\n 1. (HDomain_Incl r d)(i::=t) = HDomain_Incl (subst i t r) (subst i t d)", "by (auto simp: HDomain_Incl.simps [of x _ _ y z])"], ["proof (state)\nthis:\n  (HDomain_Incl r d)(i::=t) = HDomain_Incl (subst i t r) (subst i t d)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HDomain_Incl_Subset_lemma: \"{ HDomain_Incl r k, k' SUBS k } \\<turnstile> HDomain_Incl r k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {HDomain_Incl r k, k' SUBS k} \\<turnstile> HDomain_Incl r k'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {HDomain_Incl r k, k' SUBS k} \\<turnstile> HDomain_Incl r k'", "obtain x::name and y::name and z::name \n    where \"atom x \\<sharp> (r,k,k',y,z)\" \"atom y \\<sharp> (r,k,k',z)\" \"atom z \\<sharp> (r,k,k')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y z.\n        \\<lbrakk>atom x \\<sharp> (r, k, k', y, z);\n         atom y \\<sharp> (r, k, k', z); atom z \\<sharp> (r, k, k')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom x \\<sharp> (r, k, k', y, z)\n  atom y \\<sharp> (r, k, k', z)\n  atom z \\<sharp> (r, k, k')\n\ngoal (1 subgoal):\n 1. {HDomain_Incl r k, k' SUBS k} \\<turnstile> HDomain_Incl r k'", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom x \\<sharp> (r, k, k', y, z)\n  atom y \\<sharp> (r, k, k', z)\n  atom z \\<sharp> (r, k, k')\n\ngoal (1 subgoal):\n 1. {HDomain_Incl r k, k' SUBS k} \\<turnstile> HDomain_Incl r k'", "apply (simp add: HDomain_Incl.simps [of x _ _ y z], auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom x \\<sharp> (r, k, k', y, z);\n     atom y \\<sharp> (r, k, k', z); atom z \\<sharp> (r, k, k')\\<rbrakk>\n    \\<Longrightarrow> {Neg (SyntaxN.Ex y\n                             (SyntaxN.Ex z\n                               (Var z IN r AND\n                                Var z EQ HPair (Var x) (Var y)))),\n                       Var x IN k', k' SUBS k} \\<turnstile>\n                      SyntaxN.Ex x\n                       (Neg (Var x IN k IMP\n                             SyntaxN.Ex y\n                              (SyntaxN.Ex z\n                                (Var z IN r AND\n                                 Var z EQ HPair (Var x) (Var y)))))", "apply (rule Ex_I [where x = \"Var x\"], auto intro: ContraProve Subset_D)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {HDomain_Incl r k, k' SUBS k} \\<turnstile> HDomain_Incl r k'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HDomain_Incl_Subset: \"H \\<turnstile> HDomain_Incl r k \\<Longrightarrow> H \\<turnstile> k' SUBS k \\<Longrightarrow> H \\<turnstile> HDomain_Incl r k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> HDomain_Incl r k;\n     H \\<turnstile> k' SUBS k\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile> HDomain_Incl r k'", "by (metis HDomain_Incl_Subset_lemma cut2)"], ["", "lemma HDomain_Incl_Mem_Ord: \"H \\<turnstile> HDomain_Incl r k \\<Longrightarrow> H \\<turnstile> k' IN k \\<Longrightarrow> H \\<turnstile> OrdP k \\<Longrightarrow> H \\<turnstile> HDomain_Incl r k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> HDomain_Incl r k; H \\<turnstile> k' IN k;\n     H \\<turnstile> OrdP k\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile> HDomain_Incl r k'", "by (metis HDomain_Incl_Subset OrdP_Mem_imp_Subset)"], ["", "lemma HDomain_Incl_Zero [simp]: \"H \\<turnstile> HDomain_Incl r Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> HDomain_Incl r Zero", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H \\<turnstile> HDomain_Incl r Zero", "obtain x::name and y::name and z::name \n    where \"atom x \\<sharp> (r,y,z)\" \"atom y \\<sharp> (r,z)\" \"atom z \\<sharp> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y z.\n        \\<lbrakk>atom x \\<sharp> (r, y, z); atom y \\<sharp> (r, z);\n         atom z \\<sharp> r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom x \\<sharp> (r, y, z)\n  atom y \\<sharp> (r, z)\n  atom z \\<sharp> r\n\ngoal (1 subgoal):\n 1. H \\<turnstile> HDomain_Incl r Zero", "hence \"{} \\<turnstile> HDomain_Incl r Zero\""], ["proof (prove)\nusing this:\n  atom x \\<sharp> (r, y, z)\n  atom y \\<sharp> (r, z)\n  atom z \\<sharp> r\n\ngoal (1 subgoal):\n 1. {} \\<turnstile> HDomain_Incl r Zero", "by (auto simp: HDomain_Incl.simps [of x _ _ y z])"], ["proof (state)\nthis:\n  {} \\<turnstile> HDomain_Incl r Zero\n\ngoal (1 subgoal):\n 1. H \\<turnstile> HDomain_Incl r Zero", "thus ?thesis"], ["proof (prove)\nusing this:\n  {} \\<turnstile> HDomain_Incl r Zero\n\ngoal (1 subgoal):\n 1. H \\<turnstile> HDomain_Incl r Zero", "by (metis thin0)"], ["proof (state)\nthis:\n  H \\<turnstile> HDomain_Incl r Zero\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HDomain_Incl_Eats: \"{ HDomain_Incl r d } \\<turnstile> HDomain_Incl (Eats r (HPair d d')) (SUCC d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {HDomain_Incl r d} \\<turnstile>\n    HDomain_Incl (Eats r (HPair d d')) (SUCC d)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {HDomain_Incl r d} \\<turnstile>\n    HDomain_Incl (Eats r (HPair d d')) (SUCC d)", "obtain x::name and y::name and z::name \n    where x: \"atom x \\<sharp> (r,d,d',y,z)\" and y: \"atom y \\<sharp> (r,d,d',z)\" and z: \"atom z \\<sharp> (r,d,d')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y z.\n        \\<lbrakk>atom x \\<sharp> (r, d, d', y, z);\n         atom y \\<sharp> (r, d, d', z); atom z \\<sharp> (r, d, d')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom x \\<sharp> (r, d, d', y, z)\n  atom y \\<sharp> (r, d, d', z)\n  atom z \\<sharp> (r, d, d')\n\ngoal (1 subgoal):\n 1. {HDomain_Incl r d} \\<turnstile>\n    HDomain_Incl (Eats r (HPair d d')) (SUCC d)", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom x \\<sharp> (r, d, d', y, z)\n  atom y \\<sharp> (r, d, d', z)\n  atom z \\<sharp> (r, d, d')\n\ngoal (1 subgoal):\n 1. {HDomain_Incl r d} \\<turnstile>\n    HDomain_Incl (Eats r (HPair d d')) (SUCC d)", "apply (auto simp: HDomain_Incl.simps [of x _ _ y z] intro!: Mem_SUCC_EH)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom x \\<sharp> (r, d, d', y, z);\n     atom y \\<sharp> (r, d, d', z); atom z \\<sharp> (r, d, d')\\<rbrakk>\n    \\<Longrightarrow> {Var x IN d,\n                       Neg (SyntaxN.Ex y\n                             (SyntaxN.Ex z\n                               (Var z IN Eats r (HPair d d') AND\n                                Var z EQ\n                                HPair (Var x) (Var y))))} \\<turnstile>\n                      SyntaxN.Ex x\n                       (Neg (Var x IN d IMP\n                             SyntaxN.Ex y\n                              (SyntaxN.Ex z\n                                (Var z IN r AND\n                                 Var z EQ HPair (Var x) (Var y)))))\n 2. \\<lbrakk>atom x \\<sharp> (r, d, d', y, z);\n     atom y \\<sharp> (r, d, d', z); atom z \\<sharp> (r, d, d')\\<rbrakk>\n    \\<Longrightarrow> {Var x EQ d,\n                       Neg (SyntaxN.Ex y\n                             (SyntaxN.Ex z\n                               (Var z IN Eats r (HPair d d') AND\n                                Var z EQ\n                                HPair (Var x) (Var y))))} \\<turnstile>\n                      SyntaxN.Ex x\n                       (Neg (Var x IN d IMP\n                             SyntaxN.Ex y\n                              (SyntaxN.Ex z\n                                (Var z IN r AND\n                                 Var z EQ HPair (Var x) (Var y)))))", "apply (rule Ex_I [where x = \"Var x\"], auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom x \\<sharp> (r, d, d', y, z);\n     atom y \\<sharp> (r, d, d', z); atom z \\<sharp> (r, d, d')\\<rbrakk>\n    \\<Longrightarrow> {Var z IN r, Var z EQ HPair (Var x) (Var y),\n                       Var x IN d} \\<turnstile>\n                      SyntaxN.Ex y\n                       (SyntaxN.Ex z\n                         (Var z IN Eats r (HPair d d') AND\n                          Var z EQ HPair (Var x) (Var y)))\n 2. \\<lbrakk>atom x \\<sharp> (r, d, d', y, z);\n     atom y \\<sharp> (r, d, d', z); atom z \\<sharp> (r, d, d')\\<rbrakk>\n    \\<Longrightarrow> {Var x EQ d,\n                       Neg (SyntaxN.Ex y\n                             (SyntaxN.Ex z\n                               (Var z IN Eats r (HPair d d') AND\n                                Var z EQ\n                                HPair (Var x) (Var y))))} \\<turnstile>\n                      SyntaxN.Ex x\n                       (Neg (Var x IN d IMP\n                             SyntaxN.Ex y\n                              (SyntaxN.Ex z\n                                (Var z IN r AND\n                                 Var z EQ HPair (Var x) (Var y)))))", "apply (rule Ex_I [where x = \"Var y\"], auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>atom x \\<sharp> (r, d, d', y, z);\n     atom y \\<sharp> (r, d, d', z); atom z \\<sharp> (r, d, d')\\<rbrakk>\n    \\<Longrightarrow> {Var z IN r, Var z EQ HPair (Var x) (Var y),\n                       Var x IN d} \\<turnstile>\n                      SyntaxN.Ex z\n                       (Var z IN Eats r (HPair d d') AND\n                        Var z EQ HPair (Var x) (Var y))\n 2. \\<lbrakk>atom x \\<sharp> (r, d, d', y, z);\n     atom y \\<sharp> (r, d, d', z); atom z \\<sharp> (r, d, d')\\<rbrakk>\n    \\<Longrightarrow> {Var x EQ d,\n                       Neg (SyntaxN.Ex y\n                             (SyntaxN.Ex z\n                               (Var z IN Eats r (HPair d d') AND\n                                Var z EQ\n                                HPair (Var x) (Var y))))} \\<turnstile>\n                      SyntaxN.Ex x\n                       (Neg (Var x IN d IMP\n                             SyntaxN.Ex y\n                              (SyntaxN.Ex z\n                                (Var z IN r AND\n                                 Var z EQ HPair (Var x) (Var y)))))", "apply (rule Ex_I [where x = \"Var z\"], auto intro: Mem_Eats_I1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom x \\<sharp> (r, d, d', y, z);\n     atom y \\<sharp> (r, d, d', z); atom z \\<sharp> (r, d, d')\\<rbrakk>\n    \\<Longrightarrow> {Var x EQ d,\n                       Neg (SyntaxN.Ex y\n                             (SyntaxN.Ex z\n                               (Var z IN Eats r (HPair d d') AND\n                                Var z EQ\n                                HPair (Var x) (Var y))))} \\<turnstile>\n                      SyntaxN.Ex x\n                       (Neg (Var x IN d IMP\n                             SyntaxN.Ex y\n                              (SyntaxN.Ex z\n                                (Var z IN r AND\n                                 Var z EQ HPair (Var x) (Var y)))))", "apply (rule rotate2 [OF Swap])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom x \\<sharp> (r, d, d', y, z);\n     atom y \\<sharp> (r, d, d', z); atom z \\<sharp> (r, d, d')\\<rbrakk>\n    \\<Longrightarrow> {All2 x d\n                        (SyntaxN.Ex y\n                          (SyntaxN.Ex z\n                            (Var z IN r AND\n                             Var z EQ HPair (Var x) (Var y)))),\n                       Var x EQ d} \\<turnstile>\n                      SyntaxN.Ex y\n                       (SyntaxN.Ex z\n                         (Var z IN Eats r (HPair d d') AND\n                          Var z EQ HPair (Var x) (Var y)))", "apply (rule Ex_I [where x = d'], auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom x \\<sharp> (r, d, d', y, z);\n     atom y \\<sharp> (r, d, d', z); atom z \\<sharp> (r, d, d')\\<rbrakk>\n    \\<Longrightarrow> {All2 x d\n                        (SyntaxN.Ex y\n                          (SyntaxN.Ex z\n                            (Var z IN r AND\n                             Var z EQ HPair (Var x) (Var y)))),\n                       Var x EQ d} \\<turnstile>\n                      SyntaxN.Ex z\n                       (Var z IN Eats r (HPair d d') AND\n                        Var z EQ HPair (Var x) d')", "apply (rule Ex_I [where x = \"HPair d d'\"], auto intro: Mem_Eats_I2 HPair_cong Sym)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {HDomain_Incl r d} \\<turnstile>\n  HDomain_Incl (Eats r (HPair d d')) (SUCC d)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HDomain_Incl_Eats_I: \"H \\<turnstile> HDomain_Incl r d \\<Longrightarrow> H \\<turnstile> HDomain_Incl (Eats r (HPair d d')) (SUCC d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> HDomain_Incl r d \\<Longrightarrow>\n    H \\<turnstile> HDomain_Incl (Eats r (HPair d d')) (SUCC d)", "by (metis HDomain_Incl_Eats cut1)"], ["", "section \\<open>@{term HPair} is Provably Injective\\<close>"], ["", "lemma Doubleton_E:\n  assumes \"insert (a EQ c) (insert (b EQ d) H) \\<turnstile> A\"\n          \"insert (a EQ d) (insert (b EQ c) H) \\<turnstile> A\"\n    shows    \"insert ((Eats (Eats Zero b) a) EQ (Eats (Eats Zero d) c)) H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (Eats (Eats Zero b) a EQ Eats (Eats Zero d) c) H \\<turnstile> A", "apply (rule Equality_E)"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (Eats (Eats Zero b) a SUBS Eats (Eats Zero d) c)\n     (insert (Eats (Eats Zero d) c SUBS Eats (Eats Zero b) a)\n       H) \\<turnstile>\n    A", "using assms"], ["proof (prove)\nusing this:\n  insert (a EQ c) (insert (b EQ d) H) \\<turnstile> A\n  insert (a EQ d) (insert (b EQ c) H) \\<turnstile> A\n\ngoal (1 subgoal):\n 1. insert (Eats (Eats Zero b) a SUBS Eats (Eats Zero d) c)\n     (insert (Eats (Eats Zero d) c SUBS Eats (Eats Zero b) a)\n       H) \\<turnstile>\n    A", "apply (auto intro!: Zero_SubsetE rotate2 [of \"a IN b\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>insert (a EQ c) (insert (b EQ d) H) \\<turnstile> A;\n     insert (a EQ d) (insert (b EQ c) H) \\<turnstile> A\\<rbrakk>\n    \\<Longrightarrow> insert (b EQ d)\n                       (insert (a EQ d)\n                         (insert\n                           (Eats (Eats Zero d) c SUBS Eats (Eats Zero b) a)\n                           H)) \\<turnstile>\n                      A\n 2. \\<lbrakk>insert (a EQ c) (insert (b EQ d) H) \\<turnstile> A;\n     insert (a EQ d) (insert (b EQ c) H) \\<turnstile> A\\<rbrakk>\n    \\<Longrightarrow> insert (a EQ d)\n                       (insert (b EQ c)\n                         (insert\n                           (Eats (Eats Zero d) c SUBS Eats (Eats Zero b) a)\n                           H)) \\<turnstile>\n                      A\n 3. \\<lbrakk>insert (a EQ c) (insert (b EQ d) H) \\<turnstile> A;\n     insert (a EQ d) (insert (b EQ c) H) \\<turnstile> A\\<rbrakk>\n    \\<Longrightarrow> insert (b EQ d)\n                       (insert (a EQ c)\n                         (insert\n                           (Eats (Eats Zero d) c SUBS Eats (Eats Zero b) a)\n                           H)) \\<turnstile>\n                      A\n 4. \\<lbrakk>insert (a EQ c) (insert (b EQ d) H) \\<turnstile> A;\n     insert (a EQ d) (insert (b EQ c) H) \\<turnstile> A\\<rbrakk>\n    \\<Longrightarrow> insert (b EQ c)\n                       (insert (a EQ c)\n                         (insert\n                           (Eats (Eats Zero d) c SUBS Eats (Eats Zero b) a)\n                           H)) \\<turnstile>\n                      A", "apply (rule_tac [!] rotate3)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>insert (a EQ c) (insert (b EQ d) H) \\<turnstile> A;\n     insert (a EQ d) (insert (b EQ c) H) \\<turnstile> A\\<rbrakk>\n    \\<Longrightarrow> insert\n                       (Eats (Eats Zero d) c SUBS Eats (Eats Zero b) a)\n                       (insert (b EQ d) (insert (a EQ d) H)) \\<turnstile>\n                      A\n 2. \\<lbrakk>insert (a EQ c) (insert (b EQ d) H) \\<turnstile> A;\n     insert (a EQ d) (insert (b EQ c) H) \\<turnstile> A\\<rbrakk>\n    \\<Longrightarrow> insert\n                       (Eats (Eats Zero d) c SUBS Eats (Eats Zero b) a)\n                       (insert (a EQ d) (insert (b EQ c) H)) \\<turnstile>\n                      A\n 3. \\<lbrakk>insert (a EQ c) (insert (b EQ d) H) \\<turnstile> A;\n     insert (a EQ d) (insert (b EQ c) H) \\<turnstile> A\\<rbrakk>\n    \\<Longrightarrow> insert\n                       (Eats (Eats Zero d) c SUBS Eats (Eats Zero b) a)\n                       (insert (b EQ d) (insert (a EQ c) H)) \\<turnstile>\n                      A\n 4. \\<lbrakk>insert (a EQ c) (insert (b EQ d) H) \\<turnstile> A;\n     insert (a EQ d) (insert (b EQ c) H) \\<turnstile> A\\<rbrakk>\n    \\<Longrightarrow> insert\n                       (Eats (Eats Zero d) c SUBS Eats (Eats Zero b) a)\n                       (insert (b EQ c) (insert (a EQ c) H)) \\<turnstile>\n                      A", "apply (auto intro!: Zero_SubsetE rotate2 [of \"a IN b\"])"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<lbrakk>insert (a EQ c) (insert (b EQ d) H) \\<turnstile> A;\n     insert (a EQ d) (insert (b EQ c) H) \\<turnstile> A\\<rbrakk>\n    \\<Longrightarrow> insert (d EQ b)\n                       (insert (c EQ b)\n                         (insert (b EQ d) (insert (a EQ d) H))) \\<turnstile>\n                      A\n 2. \\<lbrakk>insert (a EQ c) (insert (b EQ d) H) \\<turnstile> A;\n     insert (a EQ d) (insert (b EQ c) H) \\<turnstile> A\\<rbrakk>\n    \\<Longrightarrow> insert (c EQ b)\n                       (insert (d EQ a)\n                         (insert (b EQ d) (insert (a EQ d) H))) \\<turnstile>\n                      A\n 3. \\<lbrakk>insert (a EQ c) (insert (b EQ d) H) \\<turnstile> A;\n     insert (a EQ d) (insert (b EQ c) H) \\<turnstile> A\\<rbrakk>\n    \\<Longrightarrow> insert (d EQ b)\n                       (insert (c EQ a)\n                         (insert (b EQ d) (insert (a EQ d) H))) \\<turnstile>\n                      A\n 4. \\<lbrakk>insert (a EQ c) (insert (b EQ d) H) \\<turnstile> A;\n     insert (a EQ d) (insert (b EQ c) H) \\<turnstile> A\\<rbrakk>\n    \\<Longrightarrow> insert (d EQ a)\n                       (insert (c EQ a)\n                         (insert (b EQ d) (insert (a EQ d) H))) \\<turnstile>\n                      A\n 5. \\<lbrakk>insert (a EQ c) (insert (b EQ d) H) \\<turnstile> A;\n     insert (a EQ d) (insert (b EQ c) H) \\<turnstile> A\\<rbrakk>\n    \\<Longrightarrow> insert (d EQ b)\n                       (insert (c EQ b)\n                         (insert (a EQ d) (insert (b EQ c) H))) \\<turnstile>\n                      A\n 6. \\<lbrakk>insert (a EQ c) (insert (b EQ d) H) \\<turnstile> A;\n     insert (a EQ d) (insert (b EQ c) H) \\<turnstile> A\\<rbrakk>\n    \\<Longrightarrow> insert (c EQ b)\n                       (insert (d EQ a)\n                         (insert (a EQ d) (insert (b EQ c) H))) \\<turnstile>\n                      A\n 7. \\<lbrakk>insert (a EQ c) (insert (b EQ d) H) \\<turnstile> A;\n     insert (a EQ d) (insert (b EQ c) H) \\<turnstile> A\\<rbrakk>\n    \\<Longrightarrow> insert (d EQ b)\n                       (insert (c EQ a)\n                         (insert (a EQ d) (insert (b EQ c) H))) \\<turnstile>\n                      A\n 8. \\<lbrakk>insert (a EQ c) (insert (b EQ d) H) \\<turnstile> A;\n     insert (a EQ d) (insert (b EQ c) H) \\<turnstile> A\\<rbrakk>\n    \\<Longrightarrow> insert (d EQ a)\n                       (insert (c EQ a)\n                         (insert (a EQ d) (insert (b EQ c) H))) \\<turnstile>\n                      A\n 9. \\<lbrakk>insert (a EQ c) (insert (b EQ d) H) \\<turnstile> A;\n     insert (a EQ d) (insert (b EQ c) H) \\<turnstile> A\\<rbrakk>\n    \\<Longrightarrow> insert (d EQ b)\n                       (insert (c EQ b)\n                         (insert (b EQ d) (insert (a EQ c) H))) \\<turnstile>\n                      A\n 10. \\<lbrakk>insert (a EQ c) (insert (b EQ d) H) \\<turnstile> A;\n      insert (a EQ d) (insert (b EQ c) H) \\<turnstile> A\\<rbrakk>\n     \\<Longrightarrow> insert (c EQ b)\n                        (insert (d EQ a)\n                          (insert (b EQ d)\n                            (insert (a EQ c) H))) \\<turnstile>\n                       A\nA total of 16 subgoals...", "apply (metis Sym_L insert_commute thin1)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma HFST: \"{HPair a b EQ HPair c d} \\<turnstile> a EQ c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {HPair a b EQ HPair c d} \\<turnstile> a EQ c", "unfolding HPair_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {Eats (Eats Zero (Eats (Eats Zero b) a)) (Eats (Eats Zero a) a) EQ\n     Eats (Eats Zero (Eats (Eats Zero d) c))\n      (Eats (Eats Zero c) c)} \\<turnstile>\n    a EQ c", "by (metis Assume Doubleton_E thin1)"], ["", "lemma b_EQ_d_1: \"{a EQ c, a EQ d, b EQ c} \\<turnstile> b EQ d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a EQ c, a EQ d, b EQ c} \\<turnstile> b EQ d", "by (metis Assume thin1 Sym Trans)"], ["", "lemma HSND: \"{HPair a b EQ HPair c d} \\<turnstile> b EQ d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {HPair a b EQ HPair c d} \\<turnstile> b EQ d", "unfolding HPair_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {Eats (Eats Zero (Eats (Eats Zero b) a)) (Eats (Eats Zero a) a) EQ\n     Eats (Eats Zero (Eats (Eats Zero d) c))\n      (Eats (Eats Zero c) c)} \\<turnstile>\n    b EQ d", "by (metis  AssumeH(2) Doubleton_E b_EQ_d_1 rotate3 thin2)"], ["", "lemma HPair_E [intro!]:\n  assumes \"insert (a EQ c) (insert (b EQ d) H) \\<turnstile> A\"\n    shows \"insert (HPair a b EQ HPair c d) H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (HPair a b EQ HPair c d) H \\<turnstile> A", "by (metis Conj_E [OF assms] Conj_I [OF HFST HSND] rcut1)"], ["", "declare HPair_E [THEN rotate2, intro!]"], ["", "declare HPair_E [THEN rotate3, intro!]"], ["", "declare HPair_E [THEN rotate4, intro!]"], ["", "declare HPair_E [THEN rotate5, intro!]"], ["", "declare HPair_E [THEN rotate6, intro!]"], ["", "declare HPair_E [THEN rotate7, intro!]"], ["", "declare HPair_E [THEN rotate8, intro!]"], ["", "lemma HFun_Sigma_E:\n  assumes r: \"H \\<turnstile> HFun_Sigma r\"\n      and b: \"H \\<turnstile> HPair a b IN r\"\n      and b': \"H \\<turnstile> HPair a b' IN r\"\n    shows \"H \\<turnstile> b EQ b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> b EQ b'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H \\<turnstile> b EQ b'", "obtain x::name and y::name and z::name and x'::name and y'::name and z'::name\n    where atoms: \"atom z \\<sharp> (r,a,b,b',z',x,y,x',y')\"  \"atom z' \\<sharp> (r,a,b,b',x,y,x',y')\"\n       \"atom x \\<sharp> (r,a,b,b',y,x',y')\"  \"atom y \\<sharp> (r,a,b,b',x',y')\" \n       \"atom x' \\<sharp> (r,a,b,b',y')\"  \"atom y' \\<sharp> (r,a,b,b')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z z' x y x' y'.\n        \\<lbrakk>atom z \\<sharp> (r, a, b, b', z', x, y, x', y');\n         atom z' \\<sharp> (r, a, b, b', x, y, x', y');\n         atom x \\<sharp> (r, a, b, b', y, x', y');\n         atom y \\<sharp> (r, a, b, b', x', y');\n         atom x' \\<sharp> (r, a, b, b', y');\n         atom y' \\<sharp> (r, a, b, b')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis obtain_fresh)"], ["proof (state)\nthis:\n  atom z \\<sharp> (r, a, b, b', z', x, y, x', y')\n  atom z' \\<sharp> (r, a, b, b', x, y, x', y')\n  atom x \\<sharp> (r, a, b, b', y, x', y')\n  atom y \\<sharp> (r, a, b, b', x', y')\n  atom x' \\<sharp> (r, a, b, b', y')\n  atom y' \\<sharp> (r, a, b, b')\n\ngoal (1 subgoal):\n 1. H \\<turnstile> b EQ b'", "hence d1: \"H \\<turnstile> All2 z r (All2 z' r (Ex x (Ex y (Ex x' (Ex y'\n                  (Var z EQ HPair (Var x) (Var y) AND Var z' EQ HPair (Var x') (Var y')\n                   AND OrdP (Var x) AND OrdP (Var x') AND ((Var x EQ Var x') IMP (Var y EQ Var y'))))))))\""], ["proof (prove)\nusing this:\n  atom z \\<sharp> (r, a, b, b', z', x, y, x', y')\n  atom z' \\<sharp> (r, a, b, b', x, y, x', y')\n  atom x \\<sharp> (r, a, b, b', y, x', y')\n  atom y \\<sharp> (r, a, b, b', x', y')\n  atom x' \\<sharp> (r, a, b, b', y')\n  atom y' \\<sharp> (r, a, b, b')\n\ngoal (1 subgoal):\n 1. H \\<turnstile>\n    All2 z r\n     (All2 z' r\n       (SyntaxN.Ex x\n         (SyntaxN.Ex y\n           (SyntaxN.Ex x'\n             (SyntaxN.Ex y'\n               (Var z EQ HPair (Var x) (Var y) AND\n                Var z' EQ HPair (Var x') (Var y') AND\n                OrdP (Var x) AND\n                OrdP (Var x') AND\n                (Var x EQ Var x' IMP Var y EQ Var y')))))))", "using r HFun_Sigma.simps [of z r z' x y x' y']"], ["proof (prove)\nusing this:\n  atom z \\<sharp> (r, a, b, b', z', x, y, x', y')\n  atom z' \\<sharp> (r, a, b, b', x, y, x', y')\n  atom x \\<sharp> (r, a, b, b', y, x', y')\n  atom y \\<sharp> (r, a, b, b', x', y')\n  atom x' \\<sharp> (r, a, b, b', y')\n  atom y' \\<sharp> (r, a, b, b')\n  H \\<turnstile> HFun_Sigma r\n  \\<lbrakk>atom z \\<sharp> (r, z', x, y, x', y');\n   atom z' \\<sharp> (r, x, y, x', y'); atom x \\<sharp> (r, y, x', y');\n   atom y \\<sharp> (r, x', y'); atom x' \\<sharp> (r, y');\n   atom y' \\<sharp> r\\<rbrakk>\n  \\<Longrightarrow> HFun_Sigma r =\n                    All2 z r\n                     (All2 z' r\n                       (SyntaxN.Ex x\n                         (SyntaxN.Ex y\n                           (SyntaxN.Ex x'\n                             (SyntaxN.Ex y'\n                               (Var z EQ HPair (Var x) (Var y) AND\n                                Var z' EQ HPair (Var x') (Var y') AND\n                                OrdP (Var x) AND\n                                OrdP (Var x') AND\n                                (Var x EQ Var x' IMP Var y EQ Var y')))))))\n\ngoal (1 subgoal):\n 1. H \\<turnstile>\n    All2 z r\n     (All2 z' r\n       (SyntaxN.Ex x\n         (SyntaxN.Ex y\n           (SyntaxN.Ex x'\n             (SyntaxN.Ex y'\n               (Var z EQ HPair (Var x) (Var y) AND\n                Var z' EQ HPair (Var x') (Var y') AND\n                OrdP (Var x) AND\n                OrdP (Var x') AND\n                (Var x EQ Var x' IMP Var y EQ Var y')))))))", "by simp"], ["proof (state)\nthis:\n  H \\<turnstile>\n  All2 z r\n   (All2 z' r\n     (SyntaxN.Ex x\n       (SyntaxN.Ex y\n         (SyntaxN.Ex x'\n           (SyntaxN.Ex y'\n             (Var z EQ HPair (Var x) (Var y) AND\n              Var z' EQ HPair (Var x') (Var y') AND\n              OrdP (Var x) AND\n              OrdP (Var x') AND (Var x EQ Var x' IMP Var y EQ Var y')))))))\n\ngoal (1 subgoal):\n 1. H \\<turnstile> b EQ b'", "have d2: \"H \\<turnstile> All2 z' r (Ex x (Ex y (Ex x' (Ex y'\n             (HPair a b EQ HPair (Var x) (Var y) AND Var z' EQ HPair (Var x') (Var y')\n                   AND OrdP (Var x) AND OrdP (Var x') AND ((Var x EQ Var x') IMP (Var y EQ Var y')))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile>\n    All2 z' r\n     (SyntaxN.Ex x\n       (SyntaxN.Ex y\n         (SyntaxN.Ex x'\n           (SyntaxN.Ex y'\n             (HPair a b EQ HPair (Var x) (Var y) AND\n              Var z' EQ HPair (Var x') (Var y') AND\n              OrdP (Var x) AND\n              OrdP (Var x') AND (Var x EQ Var x' IMP Var y EQ Var y'))))))", "using All_D [where x = \"HPair a b\", OF d1]  atoms"], ["proof (prove)\nusing this:\n  H \\<turnstile>\n  (Var z IN r IMP\n   All2 z' r\n    (SyntaxN.Ex x\n      (SyntaxN.Ex y\n        (SyntaxN.Ex x'\n          (SyntaxN.Ex y'\n            (Var z EQ HPair (Var x) (Var y) AND\n             Var z' EQ HPair (Var x') (Var y') AND\n             OrdP (Var x) AND\n             OrdP (Var x') AND\n             (Var x EQ Var x' IMP Var y EQ Var y')))))))(z::=HPair a b)\n  atom z \\<sharp> (r, a, b, b', z', x, y, x', y')\n  atom z' \\<sharp> (r, a, b, b', x, y, x', y')\n  atom x \\<sharp> (r, a, b, b', y, x', y')\n  atom y \\<sharp> (r, a, b, b', x', y')\n  atom x' \\<sharp> (r, a, b, b', y')\n  atom y' \\<sharp> (r, a, b, b')\n\ngoal (1 subgoal):\n 1. H \\<turnstile>\n    All2 z' r\n     (SyntaxN.Ex x\n       (SyntaxN.Ex y\n         (SyntaxN.Ex x'\n           (SyntaxN.Ex y'\n             (HPair a b EQ HPair (Var x) (Var y) AND\n              Var z' EQ HPair (Var x') (Var y') AND\n              OrdP (Var x) AND\n              OrdP (Var x') AND (Var x EQ Var x' IMP Var y EQ Var y'))))))", "by simp (metis MP_same b)"], ["proof (state)\nthis:\n  H \\<turnstile>\n  All2 z' r\n   (SyntaxN.Ex x\n     (SyntaxN.Ex y\n       (SyntaxN.Ex x'\n         (SyntaxN.Ex y'\n           (HPair a b EQ HPair (Var x) (Var y) AND\n            Var z' EQ HPair (Var x') (Var y') AND\n            OrdP (Var x) AND\n            OrdP (Var x') AND (Var x EQ Var x' IMP Var y EQ Var y'))))))\n\ngoal (1 subgoal):\n 1. H \\<turnstile> b EQ b'", "have d4: \"H \\<turnstile> Ex x (Ex y (Ex x' (Ex y'\n             (HPair a b EQ HPair (Var x) (Var y) AND HPair a b' EQ HPair (Var x') (Var y')\n               AND OrdP (Var x) AND OrdP (Var x') AND ((Var x EQ Var x') IMP (Var y EQ Var y'))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile>\n    SyntaxN.Ex x\n     (SyntaxN.Ex y\n       (SyntaxN.Ex x'\n         (SyntaxN.Ex y'\n           (HPair a b EQ HPair (Var x) (Var y) AND\n            HPair a b' EQ HPair (Var x') (Var y') AND\n            OrdP (Var x) AND\n            OrdP (Var x') AND (Var x EQ Var x' IMP Var y EQ Var y')))))", "using All_D [where x = \"HPair a b'\", OF d2]  atoms"], ["proof (prove)\nusing this:\n  H \\<turnstile>\n  (Var z' IN r IMP\n   SyntaxN.Ex x\n    (SyntaxN.Ex y\n      (SyntaxN.Ex x'\n        (SyntaxN.Ex y'\n          (HPair a b EQ HPair (Var x) (Var y) AND\n           Var z' EQ HPair (Var x') (Var y') AND\n           OrdP (Var x) AND\n           OrdP (Var x') AND\n           (Var x EQ Var x' IMP Var y EQ Var y'))))))(z'::=HPair a b')\n  atom z \\<sharp> (r, a, b, b', z', x, y, x', y')\n  atom z' \\<sharp> (r, a, b, b', x, y, x', y')\n  atom x \\<sharp> (r, a, b, b', y, x', y')\n  atom y \\<sharp> (r, a, b, b', x', y')\n  atom x' \\<sharp> (r, a, b, b', y')\n  atom y' \\<sharp> (r, a, b, b')\n\ngoal (1 subgoal):\n 1. H \\<turnstile>\n    SyntaxN.Ex x\n     (SyntaxN.Ex y\n       (SyntaxN.Ex x'\n         (SyntaxN.Ex y'\n           (HPair a b EQ HPair (Var x) (Var y) AND\n            HPair a b' EQ HPair (Var x') (Var y') AND\n            OrdP (Var x) AND\n            OrdP (Var x') AND (Var x EQ Var x' IMP Var y EQ Var y')))))", "by simp (metis MP_same b')"], ["proof (state)\nthis:\n  H \\<turnstile>\n  SyntaxN.Ex x\n   (SyntaxN.Ex y\n     (SyntaxN.Ex x'\n       (SyntaxN.Ex y'\n         (HPair a b EQ HPair (Var x) (Var y) AND\n          HPair a b' EQ HPair (Var x') (Var y') AND\n          OrdP (Var x) AND\n          OrdP (Var x') AND (Var x EQ Var x' IMP Var y EQ Var y')))))\n\ngoal (1 subgoal):\n 1. H \\<turnstile> b EQ b'", "have d': \"{ Ex x (Ex y (Ex x' (Ex y'\n             (HPair a b EQ HPair (Var x) (Var y) AND HPair a b' EQ HPair (Var x') (Var y')\n              AND OrdP (Var x) AND OrdP (Var x') AND ((Var x EQ Var x') IMP (Var y EQ Var y')))))) } \\<turnstile> b EQ b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {SyntaxN.Ex x\n      (SyntaxN.Ex y\n        (SyntaxN.Ex x'\n          (SyntaxN.Ex y'\n            (HPair a b EQ HPair (Var x) (Var y) AND\n             HPair a b' EQ HPair (Var x') (Var y') AND\n             OrdP (Var x) AND\n             OrdP (Var x') AND\n             (Var x EQ Var x' IMP Var y EQ Var y')))))} \\<turnstile>\n    b EQ b'", "using atoms"], ["proof (prove)\nusing this:\n  atom z \\<sharp> (r, a, b, b', z', x, y, x', y')\n  atom z' \\<sharp> (r, a, b, b', x, y, x', y')\n  atom x \\<sharp> (r, a, b, b', y, x', y')\n  atom y \\<sharp> (r, a, b, b', x', y')\n  atom x' \\<sharp> (r, a, b, b', y')\n  atom y' \\<sharp> (r, a, b, b')\n\ngoal (1 subgoal):\n 1. {SyntaxN.Ex x\n      (SyntaxN.Ex y\n        (SyntaxN.Ex x'\n          (SyntaxN.Ex y'\n            (HPair a b EQ HPair (Var x) (Var y) AND\n             HPair a b' EQ HPair (Var x') (Var y') AND\n             OrdP (Var x) AND\n             OrdP (Var x') AND\n             (Var x EQ Var x' IMP Var y EQ Var y')))))} \\<turnstile>\n    b EQ b'", "by (auto intro: ContraProve Trans Sym)"], ["proof (state)\nthis:\n  {SyntaxN.Ex x\n    (SyntaxN.Ex y\n      (SyntaxN.Ex x'\n        (SyntaxN.Ex y'\n          (HPair a b EQ HPair (Var x) (Var y) AND\n           HPair a b' EQ HPair (Var x') (Var y') AND\n           OrdP (Var x) AND\n           OrdP (Var x') AND\n           (Var x EQ Var x' IMP Var y EQ Var y')))))} \\<turnstile>\n  b EQ b'\n\ngoal (1 subgoal):\n 1. H \\<turnstile> b EQ b'", "thus ?thesis"], ["proof (prove)\nusing this:\n  {SyntaxN.Ex x\n    (SyntaxN.Ex y\n      (SyntaxN.Ex x'\n        (SyntaxN.Ex y'\n          (HPair a b EQ HPair (Var x) (Var y) AND\n           HPair a b' EQ HPair (Var x') (Var y') AND\n           OrdP (Var x) AND\n           OrdP (Var x') AND\n           (Var x EQ Var x' IMP Var y EQ Var y')))))} \\<turnstile>\n  b EQ b'\n\ngoal (1 subgoal):\n 1. H \\<turnstile> b EQ b'", "by (rule cut_thin [OF d4], auto)"], ["proof (state)\nthis:\n  H \\<turnstile> b EQ b'\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>@{term SUCC} is Provably Injective\\<close>"], ["", "lemma SUCC_SUBS_lemma: \"{SUCC x SUBS SUCC y} \\<turnstile> x SUBS y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {SUCC x SUBS SUCC y} \\<turnstile> x SUBS y", "apply (rule obtain_fresh [where x=\"(x,y)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       atom a \\<sharp> (x, y) \\<Longrightarrow>\n       {SUCC x SUBS SUCC y} \\<turnstile> x SUBS y", "apply (auto simp: SUCC_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       atom a \\<sharp> (x, y) \\<Longrightarrow>\n       {x IN y, x SUBS Eats y y} \\<turnstile> x SUBS y\n 2. \\<And>a.\n       atom a \\<sharp> (x, y) \\<Longrightarrow>\n       {x EQ y, x SUBS Eats y y} \\<turnstile> x SUBS y", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       atom a \\<sharp> (x, y) \\<Longrightarrow>\n       {x EQ y, x SUBS Eats y y} \\<turnstile> x SUBS y\n 2. \\<And>a.\n       atom a \\<sharp> (x, y) \\<Longrightarrow>\n       {x IN y, x SUBS Eats y y} \\<turnstile> x SUBS y", "apply (metis Assume Conj_E1 Extensionality Iff_MP_same)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       atom a \\<sharp> (x, y) \\<Longrightarrow>\n       {x IN y, x SUBS Eats y y} \\<turnstile> x SUBS y", "apply (auto intro!: Subset_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       atom a \\<sharp> (x, y) \\<Longrightarrow>\n       {Var a IN x, x IN y, x SUBS Eats y y} \\<turnstile> Var a IN y", "apply (blast intro: Set_MP cut_same [OF Mem_cong [OF Refl Assume, THEN Iff_MP2_same]] \n            Mem_not_sym thin2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma SUCC_SUBS: \"insert (SUCC x SUBS SUCC y) H \\<turnstile> x SUBS y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (SUCC x SUBS SUCC y) H \\<turnstile> x SUBS y", "by (metis Assume SUCC_SUBS_lemma cut1)"], ["", "lemma SUCC_inject: \"insert (SUCC x EQ SUCC y) H \\<turnstile> x EQ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (SUCC x EQ SUCC y) H \\<turnstile> x EQ y", "by (metis Equality_I EQ_imp_SUBS SUCC_SUBS Sym_L cut1)"], ["", "lemma SUCC_inject_E [intro!]: \"insert (x EQ y) H \\<turnstile> A \\<Longrightarrow> insert (SUCC x EQ SUCC y) H \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (x EQ y) H \\<turnstile> A \\<Longrightarrow>\n    insert (SUCC x EQ SUCC y) H \\<turnstile> A", "by (metis SUCC_inject cut_same insert_commute thin1)"], ["", "declare SUCC_inject_E [THEN rotate2, intro!]"], ["", "declare SUCC_inject_E [THEN rotate3, intro!]"], ["", "declare SUCC_inject_E [THEN rotate4, intro!]"], ["", "declare SUCC_inject_E [THEN rotate5, intro!]"], ["", "declare SUCC_inject_E [THEN rotate6, intro!]"], ["", "declare SUCC_inject_E [THEN rotate7, intro!]"], ["", "declare SUCC_inject_E [THEN rotate8, intro!]"], ["", "lemma OrdP_IN_SUCC_lemma: \"{OrdP x, y IN x} \\<turnstile> SUCC y IN SUCC x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {OrdP x, y IN x} \\<turnstile> SUCC y IN SUCC x", "apply (rule OrdP_linear [of _ \"SUCC x\" \"SUCC y\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. {OrdP x, y IN x} \\<turnstile> OrdP (SUCC x)\n 2. {OrdP x, y IN x} \\<turnstile> OrdP (SUCC y)\n 3. {SUCC x IN SUCC y, OrdP x, y IN x} \\<turnstile> SUCC y IN SUCC x\n 4. {SUCC x EQ SUCC y, OrdP x, y IN x} \\<turnstile> SUCC y IN SUCC x\n 5. {SUCC y IN SUCC x, OrdP x, y IN x} \\<turnstile> SUCC y IN SUCC x", "apply (auto intro!: Mem_SUCC_EH  intro: OrdP_SUCC_I Ord_IN_Ord0)"], ["proof (prove)\ngoal (3 subgoals):\n 1. {SUCC x IN y, OrdP x, y IN x} \\<turnstile> SUCC y IN SUCC x\n 2. {SUCC x EQ y, OrdP x, y IN x} \\<turnstile> SUCC y IN SUCC x\n 3. {x EQ y, OrdP x, y IN x} \\<turnstile> SUCC y IN SUCC x", "apply (metis Hyp Mem_SUCC_I1 Mem_not_sym cut_same insertCI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {SUCC x EQ y, OrdP x, y IN x} \\<turnstile> SUCC y IN SUCC x\n 2. {x EQ y, OrdP x, y IN x} \\<turnstile> SUCC y IN SUCC x", "apply (metis Assume EQ_imp_SUBS Mem_SUCC_I1 Mem_non_refl Subset_D thin1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x EQ y, OrdP x, y IN x} \\<turnstile> SUCC y IN SUCC x", "apply (blast intro: cut_same [OF Mem_cong [THEN Iff_MP2_same]])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma OrdP_IN_SUCC: \"H \\<turnstile> OrdP x \\<Longrightarrow> H \\<turnstile> y IN x \\<Longrightarrow> H \\<turnstile> SUCC y IN SUCC x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> OrdP x; H \\<turnstile> y IN x\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile> SUCC y IN SUCC x", "by (rule cut2 [OF OrdP_IN_SUCC_lemma])"], ["", "lemma OrdP_IN_SUCC_D_lemma: \"{OrdP x, SUCC y IN SUCC x} \\<turnstile> y IN x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {OrdP x, SUCC y IN SUCC x} \\<turnstile> y IN x", "apply (rule OrdP_linear [of _ \"x\" \"y\"], auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. {OrdP x, SUCC y IN SUCC x} \\<turnstile> OrdP y\n 2. {x IN y, OrdP x, SUCC y IN SUCC x} \\<turnstile> y IN x\n 3. {x EQ y, OrdP x, SUCC y IN SUCC x} \\<turnstile> y IN x", "apply (metis Assume AssumeH(2) Mem_SUCC_Refl OrdP_SUCC_I Ord_IN_Ord)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {x IN y, OrdP x, SUCC y IN SUCC x} \\<turnstile> y IN x\n 2. {x EQ y, OrdP x, SUCC y IN SUCC x} \\<turnstile> y IN x", "apply (rule Mem_SUCC_E [THEN rotate3])"], ["proof (prove)\ngoal (3 subgoals):\n 1. {SUCC y IN x, x IN y, OrdP x} \\<turnstile> y IN x\n 2. {SUCC y EQ x, x IN y, OrdP x} \\<turnstile> y IN x\n 3. {x EQ y, OrdP x, SUCC y IN SUCC x} \\<turnstile> y IN x", "apply (blast intro: Mem_SUCC_Refl OrdP_Trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {SUCC y EQ x, x IN y, OrdP x} \\<turnstile> y IN x\n 2. {x EQ y, OrdP x, SUCC y IN SUCC x} \\<turnstile> y IN x", "apply (metis AssumeH(2) EQ_imp_SUBS Mem_SUCC_I1 Mem_non_refl Subset_D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x EQ y, OrdP x, SUCC y IN SUCC x} \\<turnstile> y IN x", "apply (metis EQ_imp_SUBS Mem_SUCC_I2 Mem_SUCC_EH(2) Mem_SUCC_I1 Refl SUCC_Subset_Ord_lemma Subset_D thin1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma OrdP_IN_SUCC_D: \"H \\<turnstile> OrdP x \\<Longrightarrow> H \\<turnstile> SUCC y IN SUCC x \\<Longrightarrow> H \\<turnstile> y IN x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> OrdP x; H \\<turnstile> SUCC y IN SUCC x\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile> y IN x", "by (rule cut2 [OF OrdP_IN_SUCC_D_lemma])"], ["", "lemma OrdP_IN_SUCC_Iff: \"H \\<turnstile> OrdP y \\<Longrightarrow> H \\<turnstile> SUCC x IN SUCC y IFF x IN y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> OrdP y \\<Longrightarrow>\n    H \\<turnstile> SUCC x IN SUCC y IFF x IN y", "by (metis Assume Iff_I OrdP_IN_SUCC OrdP_IN_SUCC_D thin1)"], ["", "section \\<open>The predicate \\<open>LstSeqP\\<close>\\<close>"], ["", "lemma hfun_sigma_ord_iff: \"hfun_sigma_ord s \\<longleftrightarrow> OrdDom s \\<and> hfun_sigma s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hfun_sigma_ord s = (OrdDom s \\<and> hfun_sigma s)", "by (auto simp: hfun_sigma_ord_def OrdDom_def hfun_sigma_def HBall_def, metis+)"], ["", "lemma hfun_sigma_iff: \"hfun_sigma r \\<longleftrightarrow> hfunction r \\<and> hrelation r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hfun_sigma r = (hfunction r \\<and> hrelation r)", "by (auto simp add: HBall_def hfun_sigma_def hfunction_def hrelation_def is_hpair_def, metis+)"], ["", "lemma Seq_iff: \"Seq r d \\<longleftrightarrow> d \\<le> hdomain r \\<and> hfun_sigma r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Seq r d = (d \\<le> hdomain r \\<and> hfun_sigma r)", "by (auto simp: Seq_def hfun_sigma_iff)"], ["", "lemma LstSeq_iff: \"LstSeq s k y \\<longleftrightarrow> succ k \\<le> hdomain s \\<and> \\<langle>k,y\\<rangle> \\<^bold>\\<in> s \\<and> hfun_sigma_ord s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LstSeq s k y =\n    (succ k \\<le> hdomain s \\<and>\n     \\<langle>k, y\\<rangle> \\<^bold>\\<in> s \\<and> hfun_sigma_ord s)", "by (auto simp: OrdDom_def LstSeq_def Seq_iff hfun_sigma_ord_iff)"], ["", "nominal_function LstSeqP :: \"tm \\<Rightarrow> tm \\<Rightarrow> tm \\<Rightarrow> fm\"\n  where\n    \"LstSeqP s k y = OrdP k AND HDomain_Incl s (SUCC k) AND HFun_Sigma s AND HPair k y IN s\""], ["proof (prove)\ngoal (4 subgoals):\n 1. eqvt LstSeqP_graph_aux\n 2. \\<And>x y. LstSeqP_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       (\\<And>s k y. x = (s, k, y) \\<Longrightarrow> P) \\<Longrightarrow> P\n 4. \\<And>s k y sa ka ya.\n       (s, k, y) = (sa, ka, ya) \\<Longrightarrow>\n       OrdP k AND\n       HDomain_Incl s (SUCC k) AND HFun_Sigma s AND HPair k y IN s =\n       OrdP ka AND\n       HDomain_Incl sa (SUCC ka) AND HFun_Sigma sa AND HPair ka ya IN sa", "by (auto simp: eqvt_def LstSeqP_graph_aux_def)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All LstSeqP_dom", "by lexicographic_order"], ["", "lemma\n shows LstSeqP_fresh_iff [simp]:\n      \"a \\<sharp> LstSeqP s k y \\<longleftrightarrow> a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> y\"         (is ?thesis1)\n   and eval_fm_LstSeqP [simp]: \n      \"eval_fm e (LstSeqP s k y) \\<longleftrightarrow> LstSeq \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>y\\<rbrakk>e\"  (is ?thesis2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> LstSeqP s k y =\n    (a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> y) &&&\n    eval_fm e (LstSeqP s k y) =\n    LstSeq \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>y\\<rbrakk>e", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<sharp> LstSeqP s k y =\n    (a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> y)\n 2. eval_fm e (LstSeqP s k y) =\n    LstSeq \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>y\\<rbrakk>e", "show ?thesis1 ?thesis2"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> LstSeqP s k y =\n    (a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> y) &&&\n    eval_fm e (LstSeqP s k y) =\n    LstSeq \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>y\\<rbrakk>e", "by (auto simp: LstSeq_iff OrdDom_def hfun_sigma_ord_iff)"], ["proof (state)\nthis:\n  a \\<sharp> LstSeqP s k y =\n  (a \\<sharp> s \\<and> a \\<sharp> k \\<and> a \\<sharp> y)\n  eval_fm e (LstSeqP s k y) =\n  LstSeq \\<lbrakk>s\\<rbrakk>e \\<lbrakk>k\\<rbrakk>e \\<lbrakk>y\\<rbrakk>e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LstSeqP_subst [simp]:\n  \"(LstSeqP s k y)(i::=t) = LstSeqP (subst i t s) (subst i t k) (subst i t y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LstSeqP s k y)(i::=t) =\n    LstSeqP (subst i t s) (subst i t k) (subst i t y)", "by (auto simp: fresh_Pair fresh_at_base)"], ["", "lemma LstSeqP_E: \n  assumes \"insert (HDomain_Incl s (SUCC k)) \n            (insert (OrdP k) (insert (HFun_Sigma s)\n              (insert (HPair k y IN s) H))) \\<turnstile> B\" \n    shows \"insert (LstSeqP s k y) H \\<turnstile> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (LstSeqP s k y) H \\<turnstile> B", "using assms"], ["proof (prove)\nusing this:\n  insert (HDomain_Incl s (SUCC k))\n   (insert (OrdP k)\n     (insert (HFun_Sigma s) (insert (HPair k y IN s) H))) \\<turnstile>\n  B\n\ngoal (1 subgoal):\n 1. insert (LstSeqP s k y) H \\<turnstile> B", "by (auto simp: insert_commute)"], ["", "declare LstSeqP.simps [simp del]"], ["", "lemma LstSeqP_cong:\n  assumes \"H \\<turnstile> s EQ s'\" \"H \\<turnstile> k EQ k'\" \"H \\<turnstile> y EQ y'\" \n  shows \"H \\<turnstile> LstSeqP s k y IFF LstSeqP s' k' y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> LstSeqP s k y IFF LstSeqP s' k' y'", "by (rule P3_cong [OF _ assms], auto)"], ["", "lemma LstSeqP_OrdP: \"H \\<turnstile> LstSeqP r k y \\<Longrightarrow> H \\<turnstile> OrdP k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> LstSeqP r k y \\<Longrightarrow> H \\<turnstile> OrdP k", "by (metis Conj_E1 LstSeqP.simps)"], ["", "lemma LstSeqP_Mem_lemma: \"{ LstSeqP r k y, HPair k' z IN r, k' IN k } \\<turnstile> LstSeqP r k' z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {LstSeqP r k y, HPair k' z IN r, k' IN k} \\<turnstile> LstSeqP r k' z", "by (auto simp: LstSeqP.simps intro: Ord_IN_Ord OrdP_SUCC_I OrdP_IN_SUCC HDomain_Incl_Mem_Ord)"], ["", "lemma LstSeqP_Mem: \"H \\<turnstile> LstSeqP r k y \\<Longrightarrow> H \\<turnstile> HPair k' z IN r \\<Longrightarrow> H \\<turnstile> k' IN k \\<Longrightarrow> H \\<turnstile> LstSeqP r k' z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> LstSeqP r k y; H \\<turnstile> HPair k' z IN r;\n     H \\<turnstile> k' IN k\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile> LstSeqP r k' z", "by (rule cut3 [OF LstSeqP_Mem_lemma])"], ["", "lemma LstSeqP_imp_Mem: \"H \\<turnstile> LstSeqP s k y \\<Longrightarrow> H \\<turnstile> HPair k y IN s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> LstSeqP s k y \\<Longrightarrow>\n    H \\<turnstile> HPair k y IN s", "by (auto simp: LstSeqP.simps) (metis Conj_E2)"], ["", "lemma LstSeqP_SUCC: \"H \\<turnstile> LstSeqP r (SUCC d) y \\<Longrightarrow> H \\<turnstile> HPair d z IN r \\<Longrightarrow> H \\<turnstile> LstSeqP r d z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> LstSeqP r (SUCC d) y;\n     H \\<turnstile> HPair d z IN r\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile> LstSeqP r d z", "by (metis LstSeqP_Mem Mem_SUCC_I2 Refl)"], ["", "lemma LstSeqP_EQ: \"\\<lbrakk>H \\<turnstile> LstSeqP s k y; H \\<turnstile> HPair k y' IN s\\<rbrakk> \\<Longrightarrow> H \\<turnstile> y EQ y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<turnstile> LstSeqP s k y;\n     H \\<turnstile> HPair k y' IN s\\<rbrakk>\n    \\<Longrightarrow> H \\<turnstile> y EQ y'", "by (metis AssumeH(2) HFun_Sigma_E LstSeqP_E cut1 insert_commute)"], ["", "end"]]}