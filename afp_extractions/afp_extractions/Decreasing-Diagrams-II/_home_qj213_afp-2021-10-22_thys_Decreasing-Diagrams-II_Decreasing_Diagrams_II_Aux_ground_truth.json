{"file_name": "/home/qj213/afp-2021-10-22/thys/Decreasing-Diagrams-II/Decreasing_Diagrams_II_Aux.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Decreasing-Diagrams-II", "problem_names": ["lemma asymI2: \"(\\<And>a b. (a,b) \\<in> R \\<Longrightarrow> (b,a) \\<notin> R) \\<Longrightarrow> asym R\"", "lemma order_asym: \"trans R \\<Longrightarrow> asym R = irrefl R\"", "lemma strict_order_strict: \"strict_order q \\<Longrightarrow> strict (\\<lambda>a b. (a, b) \\<in> q\\<^sup>=) = (\\<lambda>a b. (a, b) \\<in> q)\"", "lemma mono_lex1: \"mono (\\<lambda>r. lex_prod r s)\"", "lemma mono_lex2: \"mono (lex_prod r)\"", "lemma irrefl_lex_prod: \"irrefl R \\<Longrightarrow> irrefl S \\<Longrightarrow> irrefl (R <*lex*> S)\"", "lemmas converse_inward = rtrancl_converse[symmetric] converse_Un converse_UNION converse_relcomp\n  converse_converse converse_Id", "lemma lfp_chain_induct:\n  assumes mono: \"mono f\"\n  and step: \"\\<And>x. P x \\<Longrightarrow> P (f x)\"\n  and chain: \"\\<And>C. set_chain C \\<Longrightarrow> \\<forall> x \\<in> C. P x \\<Longrightarrow> P (Sup C)\" \n  shows \"P (lfp f)\"", "lemma trans_Sup_of_chain:\n  assumes \"set_chain C\" and trans: \"\\<And>R. R \\<in> C \\<Longrightarrow> trans R\"\n  shows \"trans (Sup C)\"", "lemma asym_Sup_of_chain:\n  assumes \"set_chain C\" and asym: \"\\<And> R. R \\<in> C \\<Longrightarrow> asym R\"\n  shows \"asym (Sup C)\"", "lemma strict_order_lfp:\n  assumes \"mono f\" and \"\\<And>R. strict_order R \\<Longrightarrow> strict_order (f R)\"\n  shows \"strict_order (lfp f)\"", "lemma trans_lfp:\n  assumes \"mono f\" and \"\\<And>R. trans R \\<Longrightarrow> trans (f R)\"\n  shows \"trans (lfp f)\"", "lemma mulex_iff_mult: \"mulex r M N \\<longleftrightarrow> (M,N) \\<in> mult {(M,N) . r M N}\"", "lemma multI:\n  assumes \"trans r\" \"M = I + K\" \"N = I + J\" \"J \\<noteq> {#}\" \"\\<forall>k \\<in> set_mset K. \\<exists>j \\<in> set_mset J. (k,j) \\<in> r\"\n  shows \"(M,N) \\<in> mult r\"", "lemma multE:\n  assumes \"trans r\" and \"(M,N) \\<in> mult r\"\n  obtains I J K where \"M = I + K\" \"N = I + J\" \"J \\<noteq> {#}\" \"\\<forall>k \\<in> set_mset K. \\<exists>j \\<in> set_mset J. (k,j) \\<in> r\"", "lemma mult_on_union: \"(M,N) \\<in> mult r \\<Longrightarrow> (K + M, K + N) \\<in> mult r\"", "lemma mult_on_union': \"(M,N) \\<in> mult r \\<Longrightarrow> (M + K, N + K) \\<in> mult r\"", "lemma mult_on_add_mset: \"(M,N) \\<in> mult r \\<Longrightarrow> (add_mset k M, add_mset k N) \\<in> mult r\"", "lemma mult_empty[simp]: \"(M,{#}) \\<notin> mult R\"", "lemma mult_singleton[simp]: \"(x, y) \\<in> r \\<Longrightarrow> (add_mset x M, add_mset y M) \\<in> mult r\"", "lemma empty_mult[simp]: \"({#},N) \\<in> mult R \\<longleftrightarrow> N \\<noteq> {#}\"", "lemma trans_mult: \"trans (mult R)\"", "lemma strict_order_mult:\n  assumes \"irrefl R\" and \"trans R\"\n  shows \"irrefl (mult R)\" and \"trans (mult R)\"", "lemma mult_of_image_mset:\n  assumes \"trans R\" and \"trans R'\"\n  and \"\\<And>x y. x \\<in> set_mset N \\<Longrightarrow> y \\<in> set_mset M \\<Longrightarrow> (x,y) \\<in> R \\<Longrightarrow> (f x, f y) \\<in> R'\"\n  and \"(N, M) \\<in> mult R\"\n  shows \"(image_mset f N, image_mset f M) \\<in> mult R'\"", "lemma mono_mult1: \"mono mult1\"", "lemma mono_mult: \"mono mult\"", "lemma wf_iff_wfp_on:\n  \"wf p \\<longleftrightarrow> wfp_on (\\<lambda>a b. (a, b) \\<in> p) UNIV\"", "lemma well_order_implies_wqo:\n  assumes \"well_order r\"\n  shows \"wqo_on (\\<lambda>a b. (a, b) \\<in> r) UNIV\"", "lemma list_splits_empty[simp]:\n  \"list_splits xs = [] \\<longleftrightarrow> xs = []\"", "lemma elem_list_splits_append:\n  assumes \"(ys, y, zs) \\<in> set (list_splits xs)\"\n  shows \"ys @ [y] @ zs = xs\"", "lemma elem_list_splits_length:\n  assumes \"(ys, y, zs) \\<in> set (list_splits xs)\"\n  shows \"length ys < length xs\" and \"length zs < length xs\"", "lemma elem_list_splits_elem:\n  assumes \"(xs, y, ys) \\<in> set (list_splits zs)\"\n  shows \"y \\<in> set zs\"", "lemma list_splits_append:\n  \"list_splits (xs @ ys) = map (\\<lambda>(xs', x', ys'). (xs', x', ys' @ ys)) (list_splits xs) @\n                           map (\\<lambda>(xs', x', ys'). (xs @ xs', x', ys')) (list_splits ys)\"", "lemma list_splits_rev:\n  \"list_splits (rev xs) = map (\\<lambda>(xs, x, ys). (rev ys, x, rev xs)) (rev (list_splits xs))\"", "lemma list_splits_map:\n  \"list_splits (map f xs) = map (\\<lambda>(xs, x, ys). (map f xs, f x, map f ys)) (list_splits xs)\""], "translations": [["", "lemma asymI2: \"(\\<And>a b. (a,b) \\<in> R \\<Longrightarrow> (b,a) \\<notin> R) \\<Longrightarrow> asym R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        (a, b) \\<in> R \\<Longrightarrow>\n        (b, a) \\<notin> R) \\<Longrightarrow>\n    asym R", "by (metis asymI irrefl_def)"], ["", "(* move to Relation.thy? *)"], ["", "abbreviation \"strict_order R \\<equiv> irrefl R \\<and> trans R\""], ["", "(* move to Relation.thy? *)"], ["", "lemma order_asym: \"trans R \\<Longrightarrow> asym R = irrefl R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans R \\<Longrightarrow> asym R = irrefl R", "unfolding asym.simps irrefl_def trans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       (x, y) \\<in> R \\<longrightarrow>\n       (y, z) \\<in> R \\<longrightarrow> (x, z) \\<in> R \\<Longrightarrow>\n    (\\<exists>Ra.\n        R = Ra \\<and>\n        (\\<forall>x xa.\n            (x, xa) \\<in> Ra \\<longrightarrow> (xa, x) \\<notin> Ra)) =\n    (\\<forall>a. (a, a) \\<notin> R)", "by meson"], ["", "(* move to Relation.thy? *)"], ["", "lemma strict_order_strict: \"strict_order q \\<Longrightarrow> strict (\\<lambda>a b. (a, b) \\<in> q\\<^sup>=) = (\\<lambda>a b. (a, b) \\<in> q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_order q \\<Longrightarrow>\n    (\\<lambda>x y.\n        (x, y) \\<in> q\\<^sup>= \\<and> (y, x) \\<notin> q\\<^sup>=) =\n    (\\<lambda>a b. (a, b) \\<in> q)", "unfolding trans_def irrefl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a. (a, a) \\<notin> q) \\<and>\n    (\\<forall>x y z.\n        (x, y) \\<in> q \\<longrightarrow>\n        (y, z) \\<in> q \\<longrightarrow> (x, z) \\<in> q) \\<Longrightarrow>\n    (\\<lambda>x y.\n        (x, y) \\<in> q\\<^sup>= \\<and> (y, x) \\<notin> q\\<^sup>=) =\n    (\\<lambda>a b. (a, b) \\<in> q)", "by fast"], ["", "(* move to Wellfounded.thy? *)"], ["", "lemma mono_lex1: \"mono (\\<lambda>r. lex_prod r s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (\\<lambda>r. r <*lex*> s)", "by (auto simp add: mono_def)"], ["", "(* move to Wellfounded.thy? *)"], ["", "lemma mono_lex2: \"mono (lex_prod r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono ((<*lex*>) r)", "by (auto simp add: mono_def)"], ["", "(* move to Wellfounded.thy? *)"], ["", "lemma irrefl_lex_prod: \"irrefl R \\<Longrightarrow> irrefl S \\<Longrightarrow> irrefl (R <*lex*> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>irrefl R; irrefl S\\<rbrakk>\n    \\<Longrightarrow> irrefl (R <*lex*> S)", "by (auto simp add: lex_prod_def irrefl_def)"], ["", "lemmas converse_inward = rtrancl_converse[symmetric] converse_Un converse_UNION converse_relcomp\n  converse_converse converse_Id"], ["", "subsection \\<open>Complete lattices and least fixed points\\<close>"], ["", "context complete_lattice\nbegin"], ["", "subsubsection \\<open>A chain-based induction principle\\<close>"], ["", "abbreviation set_chain :: \"'a set \\<Rightarrow> bool\" where\n  \"set_chain C \\<equiv> \\<forall>x \\<in> C. \\<forall>y \\<in> C. x \\<le> y \\<or> y \\<le> x\""], ["", "lemma lfp_chain_induct:\n  assumes mono: \"mono f\"\n  and step: \"\\<And>x. P x \\<Longrightarrow> P (f x)\"\n  and chain: \"\\<And>C. set_chain C \\<Longrightarrow> \\<forall> x \\<in> C. P x \\<Longrightarrow> P (Sup C)\" \n  shows \"P (lfp f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (lfp f)", "unfolding lfp_eq_fixp[OF mono]"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (ccpo_class.fixp f)", "proof (rule fixp_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. ccpo.admissible Sup (\\<le>) P\n 2. monotone (\\<le>) (\\<le>) f\n 3. P (Sup {})\n 4. \\<And>x. P x \\<Longrightarrow> P (f x)", "show \"monotone (\\<le>) (\\<le>) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<le>) (\\<le>) f", "using mono"], ["proof (prove)\nusing this:\n  mono f\n\ngoal (1 subgoal):\n 1. monotone (\\<le>) (\\<le>) f", "unfolding order_class.mono_def monotone_def"], ["proof (prove)\nusing this:\n  \\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y\n\ngoal (1 subgoal):\n 1. \\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y", "."], ["proof (state)\nthis:\n  monotone (\\<le>) (\\<le>) f\n\ngoal (3 subgoals):\n 1. ccpo.admissible Sup (\\<le>) P\n 2. P (Sup {})\n 3. \\<And>x. P x \\<Longrightarrow> P (f x)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible Sup (\\<le>) P\n 2. P (Sup {})\n 3. \\<And>x. P x \\<Longrightarrow> P (f x)", "show \"P (Sup {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (Sup {})", "using chain[of \"{}\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>set_chain {}; \\<forall>x\\<in>{}. P x\\<rbrakk>\n  \\<Longrightarrow> P (Sup {})\n\ngoal (1 subgoal):\n 1. P (Sup {})", "by simp"], ["proof (state)\nthis:\n  P (Sup {})\n\ngoal (2 subgoals):\n 1. ccpo.admissible Sup (\\<le>) P\n 2. \\<And>x. P x \\<Longrightarrow> P (f x)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. ccpo.admissible Sup (\\<le>) P\n 2. \\<And>x. P x \\<Longrightarrow> P (f x)", "show \"ccpo.admissible Sup (\\<le>) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible Sup (\\<le>) P", "by (auto simp add: chain ccpo.admissible_def Complete_Partial_Order.chain_def)"], ["proof (state)\nthis:\n  ccpo.admissible Sup (\\<le>) P\n\ngoal (1 subgoal):\n 1. \\<And>x. P x \\<Longrightarrow> P (f x)", "qed fact"], ["", "subsubsection \\<open>Preservation of transitivity, asymmetry, irreflexivity by suprema\\<close>"], ["", "lemma trans_Sup_of_chain:\n  assumes \"set_chain C\" and trans: \"\\<And>R. R \\<in> C \\<Longrightarrow> trans R\"\n  shows \"trans (Sup C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans (\\<Union> C)", "proof (intro transI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> \\<Union> C; (y, z) \\<in> \\<Union> C\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> \\<Union> C", "fix x y z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> \\<Union> C; (y, z) \\<in> \\<Union> C\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> \\<Union> C", "assume \"(x,y) \\<in> Sup C\" and \"(y,z) \\<in> Sup C\""], ["proof (state)\nthis:\n  (x, y) \\<in> \\<Union> C\n  (y, z) \\<in> \\<Union> C\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> \\<Union> C; (y, z) \\<in> \\<Union> C\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> \\<Union> C", "from \\<open>(x,y) \\<in> Sup C\\<close>"], ["proof (chain)\npicking this:\n  (x, y) \\<in> \\<Union> C", "obtain R where \"R \\<in> C\" and \"(x,y) \\<in> R\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> \\<Union> C\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>R \\<in> C; (x, y) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  R \\<in> C\n  (x, y) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> \\<Union> C; (y, z) \\<in> \\<Union> C\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> \\<Union> C", "from \\<open>(y,z) \\<in> Sup C\\<close>"], ["proof (chain)\npicking this:\n  (y, z) \\<in> \\<Union> C", "obtain S where \"S \\<in> C\" and \"(y,z) \\<in> S\""], ["proof (prove)\nusing this:\n  (y, z) \\<in> \\<Union> C\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>S \\<in> C; (y, z) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  S \\<in> C\n  (y, z) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> \\<Union> C; (y, z) \\<in> \\<Union> C\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> \\<Union> C", "from \\<open>R \\<in> C\\<close> and \\<open>S \\<in> C\\<close> and \\<open>set_chain C\\<close>"], ["proof (chain)\npicking this:\n  R \\<in> C\n  S \\<in> C\n  set_chain C", "have \"R \\<union> S = R \\<or> R \\<union> S = S\""], ["proof (prove)\nusing this:\n  R \\<in> C\n  S \\<in> C\n  set_chain C\n\ngoal (1 subgoal):\n 1. R \\<union> S = R \\<or> R \\<union> S = S", "by blast"], ["proof (state)\nthis:\n  R \\<union> S = R \\<or> R \\<union> S = S\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> \\<Union> C; (y, z) \\<in> \\<Union> C\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> \\<Union> C", "with \\<open>R \\<in> C\\<close> and \\<open>S \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  R \\<in> C\n  S \\<in> C\n  R \\<union> S = R \\<or> R \\<union> S = S", "have \"R \\<union> S \\<in> C\""], ["proof (prove)\nusing this:\n  R \\<in> C\n  S \\<in> C\n  R \\<union> S = R \\<or> R \\<union> S = S\n\ngoal (1 subgoal):\n 1. R \\<union> S \\<in> C", "by fastforce"], ["proof (state)\nthis:\n  R \\<union> S \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> \\<Union> C; (y, z) \\<in> \\<Union> C\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> \\<Union> C", "with \\<open>(x,y) \\<in> R\\<close> and \\<open>(y,z) \\<in> S\\<close> and trans[of \"R \\<union> S\"]"], ["proof (chain)\npicking this:\n  (x, y) \\<in> R\n  (y, z) \\<in> S\n  R \\<union> S \\<in> C \\<Longrightarrow> trans (R \\<union> S)\n  R \\<union> S \\<in> C", "have \"(x,z) \\<in> R \\<union> S\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> R\n  (y, z) \\<in> S\n  R \\<union> S \\<in> C \\<Longrightarrow> trans (R \\<union> S)\n  R \\<union> S \\<in> C\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> R \\<union> S", "unfolding trans_def"], ["proof (prove)\nusing this:\n  (x, y) \\<in> R\n  (y, z) \\<in> S\n  R \\<union> S \\<in> C \\<Longrightarrow>\n  \\<forall>x y z.\n     (x, y) \\<in> R \\<union> S \\<longrightarrow>\n     (y, z) \\<in> R \\<union> S \\<longrightarrow> (x, z) \\<in> R \\<union> S\n  R \\<union> S \\<in> C\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> R \\<union> S", "by blast"], ["proof (state)\nthis:\n  (x, z) \\<in> R \\<union> S\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> \\<Union> C; (y, z) \\<in> \\<Union> C\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> \\<Union> C", "with \\<open>R \\<union> S \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  R \\<union> S \\<in> C\n  (x, z) \\<in> R \\<union> S", "show \"(x,z) \\<in> \\<Union>C\""], ["proof (prove)\nusing this:\n  R \\<union> S \\<in> C\n  (x, z) \\<in> R \\<union> S\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> \\<Union> C", "by blast"], ["proof (state)\nthis:\n  (x, z) \\<in> \\<Union> C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma asym_Sup_of_chain:\n  assumes \"set_chain C\" and asym: \"\\<And> R. R \\<in> C \\<Longrightarrow> asym R\"\n  shows \"asym (Sup C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. asym (\\<Union> C)", "proof (intro asymI2 notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> \\<Union> C; (b, a) \\<in> \\<Union> C\\<rbrakk>\n       \\<Longrightarrow> False", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> \\<Union> C; (b, a) \\<in> \\<Union> C\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"(a,b) \\<in> Sup C\""], ["proof (state)\nthis:\n  (a, b) \\<in> \\<Union> C\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> \\<Union> C; (b, a) \\<in> \\<Union> C\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (a, b) \\<in> \\<Union> C", "obtain \"R\" where \"R \\<in> C\" and \"(a,b) \\<in> R\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> \\<Union> C\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>R \\<in> C; (a, b) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  R \\<in> C\n  (a, b) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> \\<Union> C; (b, a) \\<in> \\<Union> C\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"(b,a) \\<in> Sup C\""], ["proof (state)\nthis:\n  (b, a) \\<in> \\<Union> C\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> \\<Union> C; (b, a) \\<in> \\<Union> C\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (b, a) \\<in> \\<Union> C", "obtain \"S\" where \"S \\<in> C\" and \"(b,a) \\<in> S\""], ["proof (prove)\nusing this:\n  (b, a) \\<in> \\<Union> C\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>S \\<in> C; (b, a) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  S \\<in> C\n  (b, a) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> \\<Union> C; (b, a) \\<in> \\<Union> C\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>R \\<in> C\\<close> and \\<open>S \\<in> C\\<close> and \\<open>set_chain C\\<close>"], ["proof (chain)\npicking this:\n  R \\<in> C\n  S \\<in> C\n  set_chain C", "have \"R \\<union> S = R \\<or> R \\<union> S = S\""], ["proof (prove)\nusing this:\n  R \\<in> C\n  S \\<in> C\n  set_chain C\n\ngoal (1 subgoal):\n 1. R \\<union> S = R \\<or> R \\<union> S = S", "by blast"], ["proof (state)\nthis:\n  R \\<union> S = R \\<or> R \\<union> S = S\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> \\<Union> C; (b, a) \\<in> \\<Union> C\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>R \\<in> C\\<close> and \\<open>S \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  R \\<in> C\n  S \\<in> C\n  R \\<union> S = R \\<or> R \\<union> S = S", "have \"R \\<union> S \\<in> C\""], ["proof (prove)\nusing this:\n  R \\<in> C\n  S \\<in> C\n  R \\<union> S = R \\<or> R \\<union> S = S\n\ngoal (1 subgoal):\n 1. R \\<union> S \\<in> C", "by fastforce"], ["proof (state)\nthis:\n  R \\<union> S \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> \\<Union> C; (b, a) \\<in> \\<Union> C\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>(a,b) \\<in> R\\<close> and \\<open>(b,a) \\<in> S\\<close> and asym"], ["proof (chain)\npicking this:\n  (a, b) \\<in> R\n  (b, a) \\<in> S\n  ?R \\<in> C \\<Longrightarrow> asym ?R\n  R \\<union> S \\<in> C", "show \"False\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> R\n  (b, a) \\<in> S\n  ?R \\<in> C \\<Longrightarrow> asym ?R\n  R \\<union> S \\<in> C\n\ngoal (1 subgoal):\n 1. False", "unfolding asym.simps"], ["proof (prove)\nusing this:\n  (a, b) \\<in> R\n  (b, a) \\<in> S\n  ?R \\<in> C \\<Longrightarrow>\n  \\<exists>R.\n     ?R = R \\<and>\n     (\\<forall>x xa. (x, xa) \\<in> R \\<longrightarrow> (xa, x) \\<notin> R)\n  R \\<union> S \\<in> C\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strict_order_lfp:\n  assumes \"mono f\" and \"\\<And>R. strict_order R \\<Longrightarrow> strict_order (f R)\"\n  shows \"strict_order (lfp f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_order (lfp f)", "proof (intro lfp_chain_induct[of f strict_order])"], ["proof (state)\ngoal (3 subgoals):\n 1. mono f\n 2. \\<And>x. strict_order x \\<Longrightarrow> strict_order (f x)\n 3. \\<And>C.\n       \\<lbrakk>set_chain C; \\<forall>x\\<in>C. strict_order x\\<rbrakk>\n       \\<Longrightarrow> strict_order (\\<Union> C)", "fix C :: \"('b \\<times> 'b) set set\""], ["proof (state)\ngoal (3 subgoals):\n 1. mono f\n 2. \\<And>x. strict_order x \\<Longrightarrow> strict_order (f x)\n 3. \\<And>C.\n       \\<lbrakk>set_chain C; \\<forall>x\\<in>C. strict_order x\\<rbrakk>\n       \\<Longrightarrow> strict_order (\\<Union> C)", "assume \"set_chain C\" and \"\\<forall>R \\<in> C. strict_order R\""], ["proof (state)\nthis:\n  set_chain C\n  \\<forall>R\\<in>C. strict_order R\n\ngoal (3 subgoals):\n 1. mono f\n 2. \\<And>x. strict_order x \\<Longrightarrow> strict_order (f x)\n 3. \\<And>C.\n       \\<lbrakk>set_chain C; \\<forall>x\\<in>C. strict_order x\\<rbrakk>\n       \\<Longrightarrow> strict_order (\\<Union> C)", "from this"], ["proof (chain)\npicking this:\n  set_chain C\n  \\<forall>R\\<in>C. strict_order R", "show \"strict_order (Sup C)\""], ["proof (prove)\nusing this:\n  set_chain C\n  \\<forall>R\\<in>C. strict_order R\n\ngoal (1 subgoal):\n 1. strict_order (\\<Union> C)", "by (metis asym_Sup_of_chain trans_Sup_of_chain order_asym)"], ["proof (state)\nthis:\n  strict_order (\\<Union> C)\n\ngoal (2 subgoals):\n 1. mono f\n 2. \\<And>x. strict_order x \\<Longrightarrow> strict_order (f x)", "qed fact+"], ["", "lemma trans_lfp:\n  assumes \"mono f\" and \"\\<And>R. trans R \\<Longrightarrow> trans (f R)\"\n  shows \"trans (lfp f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans (lfp f)", "by (metis lfp_chain_induct[of f trans] assms trans_Sup_of_chain)"], ["", "end"], ["", "(* complete_lattice *)"], ["", "subsection \\<open>Multiset extension\\<close>"], ["", "lemma mulex_iff_mult: \"mulex r M N \\<longleftrightarrow> (M,N) \\<in> mult {(M,N) . r M N}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mulex r M N = ((M, N) \\<in> mult {(M, N). r M N})", "by (auto simp add: mulex_on_def restrict_to_def mult_def mulex1_def tranclp_unfold)"], ["", "lemma multI:\n  assumes \"trans r\" \"M = I + K\" \"N = I + J\" \"J \\<noteq> {#}\" \"\\<forall>k \\<in> set_mset K. \\<exists>j \\<in> set_mset J. (k,j) \\<in> r\"\n  shows \"(M,N) \\<in> mult r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M, N) \\<in> mult r", "using assms one_step_implies_mult"], ["proof (prove)\nusing this:\n  trans r\n  M = I + K\n  N = I + J\n  J \\<noteq> {#}\n  \\<forall>k\\<in>#K. \\<exists>j\\<in>#J. (k, j) \\<in> r\n  \\<lbrakk>?J \\<noteq> {#};\n   \\<forall>k\\<in>#?K. \\<exists>j\\<in>#?J. (k, j) \\<in> ?r\\<rbrakk>\n  \\<Longrightarrow> (?I + ?K, ?I + ?J) \\<in> mult ?r\n\ngoal (1 subgoal):\n 1. (M, N) \\<in> mult r", "by blast"], ["", "lemma multE:\n  assumes \"trans r\" and \"(M,N) \\<in> mult r\"\n  obtains I J K where \"M = I + K\" \"N = I + J\" \"J \\<noteq> {#}\" \"\\<forall>k \\<in> set_mset K. \\<exists>j \\<in> set_mset J. (k,j) \\<in> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>I K J.\n        \\<lbrakk>M = I + K; N = I + J; J \\<noteq> {#};\n         \\<forall>k\\<in>#K. \\<exists>j\\<in>#J. (k, j) \\<in> r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using mult_implies_one_step[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>I J K.\n     N = I + J \\<and>\n     M = I + K \\<and>\n     J \\<noteq> {#} \\<and>\n     (\\<forall>k\\<in>#K. \\<exists>j\\<in>#J. (k, j) \\<in> r)\n\ngoal (1 subgoal):\n 1. (\\<And>I K J.\n        \\<lbrakk>M = I + K; N = I + J; J \\<noteq> {#};\n         \\<forall>k\\<in>#K. \\<exists>j\\<in>#J. (k, j) \\<in> r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "lemma mult_on_union: \"(M,N) \\<in> mult r \\<Longrightarrow> (K + M, K + N) \\<in> mult r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M, N) \\<in> mult r \\<Longrightarrow> (K + M, K + N) \\<in> mult r", "using mulex_on_union[of \"\\<lambda>x y. (x,y) \\<in> r\" UNIV]"], ["proof (prove)\nusing this:\n  \\<lbrakk>mulex (\\<lambda>x y. (x, y) \\<in> r) ?M ?N;\n   ?K \\<in> multisets UNIV\\<rbrakk>\n  \\<Longrightarrow> mulex (\\<lambda>x y. (x, y) \\<in> r) (?K + ?M) (?K + ?N)\n\ngoal (1 subgoal):\n 1. (M, N) \\<in> mult r \\<Longrightarrow> (K + M, K + N) \\<in> mult r", "by (auto simp: mulex_iff_mult)"], ["", "lemma mult_on_union': \"(M,N) \\<in> mult r \\<Longrightarrow> (M + K, N + K) \\<in> mult r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M, N) \\<in> mult r \\<Longrightarrow> (M + K, N + K) \\<in> mult r", "using mulex_on_union'[of \"\\<lambda>x y. (x,y) \\<in> r\" UNIV]"], ["proof (prove)\nusing this:\n  \\<lbrakk>mulex (\\<lambda>x y. (x, y) \\<in> r) ?M ?N;\n   ?K \\<in> multisets UNIV\\<rbrakk>\n  \\<Longrightarrow> mulex (\\<lambda>x y. (x, y) \\<in> r) (?M + ?K) (?N + ?K)\n\ngoal (1 subgoal):\n 1. (M, N) \\<in> mult r \\<Longrightarrow> (M + K, N + K) \\<in> mult r", "by (auto simp: mulex_iff_mult)"], ["", "lemma mult_on_add_mset: \"(M,N) \\<in> mult r \\<Longrightarrow> (add_mset k M, add_mset k N) \\<in> mult r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M, N) \\<in> mult r \\<Longrightarrow>\n    (add_mset k M, add_mset k N) \\<in> mult r", "unfolding add_mset_add_single[of k M] add_mset_add_single[of k N]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (M, N) \\<in> mult r \\<Longrightarrow>\n    (M + {#k#}, N + {#k#}) \\<in> mult r", "by (rule mult_on_union')"], ["", "lemma mult_empty[simp]: \"(M,{#}) \\<notin> mult R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M, {#}) \\<notin> mult R", "by (metis mult_def not_less_empty trancl.cases)"], ["", "lemma mult_singleton[simp]: \"(x, y) \\<in> r \\<Longrightarrow> (add_mset x M, add_mset y M) \\<in> mult r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> r \\<Longrightarrow>\n    (add_mset x M, add_mset y M) \\<in> mult r", "unfolding add_mset_add_single[of x M] add_mset_add_single[of y M]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> r \\<Longrightarrow> (M + {#x#}, M + {#y#}) \\<in> mult r", "apply (rule mult_on_union)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> r \\<Longrightarrow> ({#x#}, {#y#}) \\<in> mult r", "using mult1_singleton[of x y r]"], ["proof (prove)\nusing this:\n  (({#x#}, {#y#}) \\<in> mult1 r) = ((x, y) \\<in> r)\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> r \\<Longrightarrow> ({#x#}, {#y#}) \\<in> mult r", "by (auto simp add: mult_def mult_on_union)"], ["", "lemma empty_mult[simp]: \"({#},N) \\<in> mult R \\<longleftrightarrow> N \\<noteq> {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (({#}, N) \\<in> mult R) = (N \\<noteq> {#})", "using empty_mulex_on[of N UNIV \"\\<lambda>M N. (M,N) \\<in> R\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>N \\<noteq> {#}; N \\<in> multisets UNIV\\<rbrakk>\n  \\<Longrightarrow> mulex (\\<lambda>M N. (M, N) \\<in> R) {#} N\n\ngoal (1 subgoal):\n 1. (({#}, N) \\<in> mult R) = (N \\<noteq> {#})", "by (auto simp add: mulex_iff_mult)"], ["", "lemma trans_mult: \"trans (mult R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans (mult R)", "unfolding mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. trans ((mult1 R)\\<^sup>+)", "by simp"], ["", "lemma strict_order_mult:\n  assumes \"irrefl R\" and \"trans R\"\n  shows \"irrefl (mult R)\" and \"trans (mult R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irrefl (mult R) &&& trans (mult R)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. irrefl (mult R)\n 2. trans (mult R)", "show \"irrefl (mult R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irrefl (mult R)", "unfolding irrefl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. (a, a) \\<notin> mult R", "proof (intro allI notI, elim multE[OF \\<open>trans R\\<close>])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a I J K.\n       \\<lbrakk>a = I + K; a = I + J; J \\<noteq> {#};\n        \\<forall>k\\<in>#K. \\<exists>j\\<in>#J. (k, j) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> False", "fix M I J K"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a I J K.\n       \\<lbrakk>a = I + K; a = I + J; J \\<noteq> {#};\n        \\<forall>k\\<in>#K. \\<exists>j\\<in>#J. (k, j) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"M = I + J\" \"M = I + K\" \"J \\<noteq> {#}\" and *: \"\\<forall>k \\<in> set_mset K. \\<exists>j \\<in> set_mset J. (k, j) \\<in> R\""], ["proof (state)\nthis:\n  M = I + J\n  M = I + K\n  J \\<noteq> {#}\n  \\<forall>k\\<in>#K. \\<exists>j\\<in>#J. (k, j) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>a I J K.\n       \\<lbrakk>a = I + K; a = I + J; J \\<noteq> {#};\n        \\<forall>k\\<in>#K. \\<exists>j\\<in>#J. (k, j) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>M = I + J\\<close> and \\<open>M = I + K\\<close>"], ["proof (chain)\npicking this:\n  M = I + J\n  M = I + K", "have \"J = K\""], ["proof (prove)\nusing this:\n  M = I + J\n  M = I + K\n\ngoal (1 subgoal):\n 1. J = K", "by simp"], ["proof (state)\nthis:\n  J = K\n\ngoal (1 subgoal):\n 1. \\<And>a I J K.\n       \\<lbrakk>a = I + K; a = I + J; J \\<noteq> {#};\n        \\<forall>k\\<in>#K. \\<exists>j\\<in>#J. (k, j) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> False", "have \"finite (set_mset J)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_mset J)", "by simp"], ["proof (state)\nthis:\n  finite (set_mset J)\n\ngoal (1 subgoal):\n 1. \\<And>a I J K.\n       \\<lbrakk>a = I + K; a = I + J; J \\<noteq> {#};\n        \\<forall>k\\<in>#K. \\<exists>j\\<in>#J. (k, j) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  finite (set_mset J)", "have \"set_mset J = {}\""], ["proof (prove)\nusing this:\n  finite (set_mset J)\n\ngoal (1 subgoal):\n 1. set_mset J = {}", "using *"], ["proof (prove)\nusing this:\n  finite (set_mset J)\n  \\<forall>k\\<in>#K. \\<exists>j\\<in>#J. (k, j) \\<in> R\n\ngoal (1 subgoal):\n 1. set_mset J = {}", "unfolding \\<open>J = K\\<close>"], ["proof (prove)\nusing this:\n  finite (set_mset K)\n  \\<forall>k\\<in>#K. \\<exists>j\\<in>#K. (k, j) \\<in> R\n\ngoal (1 subgoal):\n 1. set_mset K = {}", "by (induct rule: finite_induct)\n         (simp, metis assms insert_absorb insert_iff insert_not_empty irrefl_def transD)"], ["proof (state)\nthis:\n  set_mset J = {}\n\ngoal (1 subgoal):\n 1. \\<And>a I J K.\n       \\<lbrakk>a = I + K; a = I + J; J \\<noteq> {#};\n        \\<forall>k\\<in>#K. \\<exists>j\\<in>#J. (k, j) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  set_mset J = {}", "show \"False\""], ["proof (prove)\nusing this:\n  set_mset J = {}\n\ngoal (1 subgoal):\n 1. False", "using \\<open>J \\<noteq> {#}\\<close>"], ["proof (prove)\nusing this:\n  set_mset J = {}\n  J \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  irrefl (mult R)\n\ngoal (1 subgoal):\n 1. trans (mult R)", "qed (simp add: trans_mult)"], ["", "lemma mult_of_image_mset:\n  assumes \"trans R\" and \"trans R'\"\n  and \"\\<And>x y. x \\<in> set_mset N \\<Longrightarrow> y \\<in> set_mset M \\<Longrightarrow> (x,y) \\<in> R \\<Longrightarrow> (f x, f y) \\<in> R'\"\n  and \"(N, M) \\<in> mult R\"\n  shows \"(image_mset f N, image_mset f M) \\<in> mult R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (image_mset f N, image_mset f M) \\<in> mult R'", "proof (insert assms(4), elim multE[OF assms(1)])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I J K.\n       \\<lbrakk>N = I + K; M = I + J; J \\<noteq> {#};\n        \\<forall>k\\<in>#K. \\<exists>j\\<in>#J. (k, j) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (image_mset f N, image_mset f M) \\<in> mult R'", "fix I J K"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I J K.\n       \\<lbrakk>N = I + K; M = I + J; J \\<noteq> {#};\n        \\<forall>k\\<in>#K. \\<exists>j\\<in>#J. (k, j) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (image_mset f N, image_mset f M) \\<in> mult R'", "assume \"N = I + K\" \"M = I + J\" \"J \\<noteq> {#}\" \"\\<forall>k \\<in> set_mset K. \\<exists>j \\<in> set_mset J. (k, j) \\<in> R\""], ["proof (state)\nthis:\n  N = I + K\n  M = I + J\n  J \\<noteq> {#}\n  \\<forall>k\\<in>#K. \\<exists>j\\<in>#J. (k, j) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>I J K.\n       \\<lbrakk>N = I + K; M = I + J; J \\<noteq> {#};\n        \\<forall>k\\<in>#K. \\<exists>j\\<in>#J. (k, j) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (image_mset f N, image_mset f M) \\<in> mult R'", "thus \"(image_mset f N, image_mset f M) \\<in> mult R'\""], ["proof (prove)\nusing this:\n  N = I + K\n  M = I + J\n  J \\<noteq> {#}\n  \\<forall>k\\<in>#K. \\<exists>j\\<in>#J. (k, j) \\<in> R\n\ngoal (1 subgoal):\n 1. (image_mset f N, image_mset f M) \\<in> mult R'", "using assms(2,3)"], ["proof (prove)\nusing this:\n  N = I + K\n  M = I + J\n  J \\<noteq> {#}\n  \\<forall>k\\<in>#K. \\<exists>j\\<in>#J. (k, j) \\<in> R\n  trans R'\n  \\<lbrakk>?x \\<in># N; ?y \\<in># M; (?x, ?y) \\<in> R\\<rbrakk>\n  \\<Longrightarrow> (f ?x, f ?y) \\<in> R'\n\ngoal (1 subgoal):\n 1. (image_mset f N, image_mset f M) \\<in> mult R'", "by (intro multI) (auto, blast)"], ["proof (state)\nthis:\n  (image_mset f N, image_mset f M) \\<in> mult R'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Incrementality of @{term mult1} and @{term mult}\\<close>"], ["", "lemma mono_mult1: \"mono mult1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono mult1", "unfolding mono_def mult1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<subseteq> y \\<longrightarrow>\n       {(N, M).\n        \\<exists>a M0 K.\n           M = add_mset a M0 \\<and>\n           N = M0 + K \\<and>\n           (\\<forall>b. b \\<in># K \\<longrightarrow> (b, a) \\<in> x)}\n       \\<subseteq> {(N, M).\n                    \\<exists>a M0 K.\n                       M = add_mset a M0 \\<and>\n                       N = M0 + K \\<and>\n                       (\\<forall>b.\n                           b \\<in># K \\<longrightarrow> (b, a) \\<in> y)}", "by blast"], ["", "lemma mono_mult: \"mono mult\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono mult", "unfolding mono_def mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<subseteq> y \\<longrightarrow>\n       (mult1 x)\\<^sup>+ \\<subseteq> (mult1 y)\\<^sup>+", "proof (intro allI impI subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x \\<subseteq> y; xa \\<in> (mult1 x)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> (mult1 y)\\<^sup>+", "fix R S :: \"'a rel\" and x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x \\<subseteq> y; xa \\<in> (mult1 x)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> (mult1 y)\\<^sup>+", "assume \"R \\<subseteq> S\" and \"x \\<in> (mult1 R)\\<^sup>+\""], ["proof (state)\nthis:\n  R \\<subseteq> S\n  x \\<in> (mult1 R)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x \\<subseteq> y; xa \\<in> (mult1 x)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> (mult1 y)\\<^sup>+", "then"], ["proof (chain)\npicking this:\n  R \\<subseteq> S\n  x \\<in> (mult1 R)\\<^sup>+", "show \"x \\<in> (mult1 S)\\<^sup>+\""], ["proof (prove)\nusing this:\n  R \\<subseteq> S\n  x \\<in> (mult1 R)\\<^sup>+\n\ngoal (1 subgoal):\n 1. x \\<in> (mult1 S)\\<^sup>+", "using mono_mult1[unfolded mono_def] trancl_mono[of x \"mult1 R\" \"mult1 S\"]"], ["proof (prove)\nusing this:\n  R \\<subseteq> S\n  x \\<in> (mult1 R)\\<^sup>+\n  \\<forall>x y.\n     x \\<subseteq> y \\<longrightarrow> mult1 x \\<subseteq> mult1 y\n  \\<lbrakk>x \\<in> (mult1 R)\\<^sup>+; mult1 R \\<subseteq> mult1 S\\<rbrakk>\n  \\<Longrightarrow> x \\<in> (mult1 S)\\<^sup>+\n\ngoal (1 subgoal):\n 1. x \\<in> (mult1 S)\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  x \\<in> (mult1 S)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Well-orders and well-quasi-orders\\<close>"], ["", "lemma wf_iff_wfp_on:\n  \"wf p \\<longleftrightarrow> wfp_on (\\<lambda>a b. (a, b) \\<in> p) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf p = wfp_on (\\<lambda>a b. (a, b) \\<in> p) UNIV", "unfolding wfp_on_iff_inductive_on wf_def inductive_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>P.\n        (\\<forall>x.\n            (\\<forall>y.\n                (y, x) \\<in> p \\<longrightarrow> P y) \\<longrightarrow>\n            P x) \\<longrightarrow>\n        All P) =\n    (\\<forall>Q.\n        (\\<forall>y\\<in>UNIV.\n            (\\<forall>x\\<in>UNIV.\n                (x, y) \\<in> p \\<longrightarrow> Q x) \\<longrightarrow>\n            Q y) \\<longrightarrow>\n        Ball UNIV Q)", "by force"], ["", "lemma well_order_implies_wqo:\n  assumes \"well_order r\"\n  shows \"wqo_on (\\<lambda>a b. (a, b) \\<in> r) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wqo_on (\\<lambda>a b. (a, b) \\<in> r) UNIV", "proof (intro wqo_onI almost_full_onI)"], ["proof (state)\ngoal (2 subgoals):\n 1. transp_on (\\<lambda>a b. (a, b) \\<in> r) UNIV\n 2. \\<And>f.\n       \\<forall>i. f i \\<in> UNIV \\<Longrightarrow>\n       good (\\<lambda>a b. (a, b) \\<in> r) f", "show \"transp_on (\\<lambda>a b. (a, b) \\<in> r) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transp_on (\\<lambda>a b. (a, b) \\<in> r) UNIV", "using assms"], ["proof (prove)\nusing this:\n  well_order r\n\ngoal (1 subgoal):\n 1. transp_on (\\<lambda>a b. (a, b) \\<in> r) UNIV", "by (auto simp only: well_order_on_def linear_order_on_def partial_order_on_def preorder_on_def\n    trans_def transp_on_def)"], ["proof (state)\nthis:\n  transp_on (\\<lambda>a b. (a, b) \\<in> r) UNIV\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> UNIV \\<Longrightarrow>\n       good (\\<lambda>a b. (a, b) \\<in> r) f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> UNIV \\<Longrightarrow>\n       good (\\<lambda>a b. (a, b) \\<in> r) f", "fix f :: \"nat \\<Rightarrow> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> UNIV \\<Longrightarrow>\n       good (\\<lambda>a b. (a, b) \\<in> r) f", "show \"good (\\<lambda>a b. (a, b) \\<in> r) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. good (\\<lambda>a b. (a, b) \\<in> r) f", "using assms"], ["proof (prove)\nusing this:\n  well_order r\n\ngoal (1 subgoal):\n 1. good (\\<lambda>a b. (a, b) \\<in> r) f", "unfolding well_order_on_def wf_iff_wfp_on wfp_on_def not_ex not_all de_Morgan_conj"], ["proof (prove)\nusing this:\n  linear_order r \\<and>\n  (\\<forall>x.\n      \\<exists>xa.\n         x xa \\<notin> UNIV \\<or> (x (Suc xa), x xa) \\<notin> r - Id)\n\ngoal (1 subgoal):\n 1. good (\\<lambda>a b. (a, b) \\<in> r) f", "proof (elim conjE allE exE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>linear_order r;\n        ?x2 x \\<notin> UNIV \\<or>\n        (?x2 (Suc x), ?x2 x) \\<notin> r - Id\\<rbrakk>\n       \\<Longrightarrow> good (\\<lambda>a b. (a, b) \\<in> r) f", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>linear_order r;\n        ?x2 x \\<notin> UNIV \\<or>\n        (?x2 (Suc x), ?x2 x) \\<notin> r - Id\\<rbrakk>\n       \\<Longrightarrow> good (\\<lambda>a b. (a, b) \\<in> r) f", "assume \"linear_order r\" and \"f x \\<notin> UNIV \\<or> (f (Suc x), f x) \\<notin> r - Id\""], ["proof (state)\nthis:\n  linear_order r\n  f x \\<notin> UNIV \\<or> (f (Suc x), f x) \\<notin> r - Id\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>linear_order r;\n        ?x2 x \\<notin> UNIV \\<or>\n        (?x2 (Suc x), ?x2 x) \\<notin> r - Id\\<rbrakk>\n       \\<Longrightarrow> good (\\<lambda>a b. (a, b) \\<in> r) f", "then"], ["proof (chain)\npicking this:\n  linear_order r\n  f x \\<notin> UNIV \\<or> (f (Suc x), f x) \\<notin> r - Id", "have \"(f x, f (Suc x)) \\<in> r\""], ["proof (prove)\nusing this:\n  linear_order r\n  f x \\<notin> UNIV \\<or> (f (Suc x), f x) \\<notin> r - Id\n\ngoal (1 subgoal):\n 1. (f x, f (Suc x)) \\<in> r", "using \\<open>linear_order r\\<close>"], ["proof (prove)\nusing this:\n  linear_order r\n  f x \\<notin> UNIV \\<or> (f (Suc x), f x) \\<notin> r - Id\n  linear_order r\n\ngoal (1 subgoal):\n 1. (f x, f (Suc x)) \\<in> r", "by (force simp: linear_order_on_def Relation.total_on_def partial_order_on_def preorder_on_def\n      refl_on_def)"], ["proof (state)\nthis:\n  (f x, f (Suc x)) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>linear_order r;\n        ?x2 x \\<notin> UNIV \\<or>\n        (?x2 (Suc x), ?x2 x) \\<notin> r - Id\\<rbrakk>\n       \\<Longrightarrow> good (\\<lambda>a b. (a, b) \\<in> r) f", "then"], ["proof (chain)\npicking this:\n  (f x, f (Suc x)) \\<in> r", "show \"good (\\<lambda>a b. (a, b) \\<in> r) f\""], ["proof (prove)\nusing this:\n  (f x, f (Suc x)) \\<in> r\n\ngoal (1 subgoal):\n 1. good (\\<lambda>a b. (a, b) \\<in> r) f", "by (auto simp: good_def)"], ["proof (state)\nthis:\n  good (\\<lambda>a b. (a, b) \\<in> r) f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  good (\\<lambda>a b. (a, b) \\<in> r) f\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Splitting lists into prefix, element, and suffix\\<close>"], ["", "fun list_splits :: \"'a list \\<Rightarrow> ('a list \\<times> 'a \\<times> 'a list) list\" where\n  \"list_splits [] = []\"\n| \"list_splits (x # xs) = ([], x, xs) # map (\\<lambda>(xs, x', xs'). (x # xs, x', xs')) (list_splits xs)\""], ["", "lemma list_splits_empty[simp]:\n  \"list_splits xs = [] \\<longleftrightarrow> xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_splits xs = []) = (xs = [])", "by (cases xs) simp_all"], ["", "lemma elem_list_splits_append:\n  assumes \"(ys, y, zs) \\<in> set (list_splits xs)\"\n  shows \"ys @ [y] @ zs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys @ [y] @ zs = xs", "using assms"], ["proof (prove)\nusing this:\n  (ys, y, zs) \\<in> set (list_splits xs)\n\ngoal (1 subgoal):\n 1. ys @ [y] @ zs = xs", "by (induct xs arbitrary: ys) auto"], ["", "lemma elem_list_splits_length:\n  assumes \"(ys, y, zs) \\<in> set (list_splits xs)\"\n  shows \"length ys < length xs\" and \"length zs < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ys < length xs &&& length zs < length xs", "using elem_list_splits_append[OF assms]"], ["proof (prove)\nusing this:\n  ys @ [y] @ zs = xs\n\ngoal (1 subgoal):\n 1. length ys < length xs &&& length zs < length xs", "by auto"], ["", "lemma elem_list_splits_elem:\n  assumes \"(xs, y, ys) \\<in> set (list_splits zs)\"\n  shows \"y \\<in> set zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> set zs", "using elem_list_splits_append[OF assms]"], ["proof (prove)\nusing this:\n  xs @ [y] @ ys = zs\n\ngoal (1 subgoal):\n 1. y \\<in> set zs", "by force"], ["", "lemma list_splits_append:\n  \"list_splits (xs @ ys) = map (\\<lambda>(xs', x', ys'). (xs', x', ys' @ ys)) (list_splits xs) @\n                           map (\\<lambda>(xs', x', ys'). (xs @ xs', x', ys')) (list_splits ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_splits (xs @ ys) =\n    map (\\<lambda>(xs', x', ys'). (xs', x', ys' @ ys)) (list_splits xs) @\n    map (\\<lambda>(xs', x', ys'). (xs @ xs', x', ys')) (list_splits ys)", "by (induct xs) auto"], ["", "lemma list_splits_rev:\n  \"list_splits (rev xs) = map (\\<lambda>(xs, x, ys). (rev ys, x, rev xs)) (rev (list_splits xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_splits (rev xs) =\n    map (\\<lambda>(xs, x, ys). (rev ys, x, rev xs)) (rev (list_splits xs))", "by (induct xs) (auto simp add: list_splits_append comp_def prod.case_distrib rev_map)"], ["", "lemma list_splits_map:\n  \"list_splits (map f xs) = map (\\<lambda>(xs, x, ys). (map f xs, f x, map f ys)) (list_splits xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_splits (map f xs) =\n    map (\\<lambda>(xs, x, ys). (map f xs, f x, map f ys)) (list_splits xs)", "by (induct xs) auto"], ["", "end"], ["", "(* Decreasing_Diagrams_II_Aux *)"]]}