{"file_name": "/home/qj213/afp-2021-10-22/thys/Decreasing-Diagrams-II/Decreasing_Diagrams_II.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Decreasing-Diagrams-II", "problem_names": ["lemma UNIV_accent: \"UNIV = { Acute, Grave, Macron }\"", "lemma finite_accent: \"finite (UNIV :: accent set)\"", "lemma mono_letter_less: \"mono letter_less\"", "lemma adj_msog_adj_msog[simp]:\n  \"adj_msog xs zs (adj_msog xs' zs' y) = adj_msog (xs @ xs') (zs' @ zs) y\"", "lemma compose_adj_msog[simp]: \"adj_msog xs zs \\<circ> adj_msog xs' zs' = adj_msog (xs @ xs') (zs' @ zs)\"", "lemma adj_msog_single:\n  \"adj_msog xs zs (x,[]) = (x, (case fst x of Grave \\<Rightarrow> xs | Acute \\<Rightarrow> zs | Macron \\<Rightarrow> []))\"", "lemma ms_of_greek_elem:\n  assumes \"(x,xs) \\<in> set_mset (ms_of_greek ys)\"\n  shows \"x \\<in> set ys\"", "lemma ms_of_greek_shorter:\n  assumes \"(x, t) \\<in># ms_of_greek s\"\n  shows \"length s > length t\"", "lemma msog_append: \"ms_of_greek (xs @ ys) = image_mset (adj_msog [] ys) (ms_of_greek xs) +\n  image_mset (adj_msog xs []) (ms_of_greek ys)\"", "lemma mono_nest: \"mono (nest r)\"", "lemma nest_mono[mono_set]: \"x \\<subseteq> y \\<Longrightarrow> (a,b) \\<in> nest r x \\<longrightarrow> (a,b) \\<in> nest r y\"", "lemma greek_less_unfold:\n  \"greek_less r = nest r (greek_less r)\"", "lemma strict_order_letter_less:\n  assumes \"strict_order r\"\n  shows \"strict_order (letter_less r)\"", "lemma strict_order_nest:\n  assumes r: \"strict_order r\" and R: \"strict_order R\"\n  shows \"strict_order (nest r R)\"", "lemma strict_order_greek_less:\n  assumes \"strict_order r\"\n  shows \"strict_order (greek_less r)\"", "lemma trans_letter_less:\n  assumes \"trans r\"\n  shows \"trans (letter_less r)\"", "lemma trans_order_nest: \"trans (nest r R)\"", "lemma trans_greek_less[simp]: \"trans (greek_less r)\"", "lemma mono_greek_less: \"mono greek_less\"", "lemma inv_letter_pair[simp]:\n  \"inv_letter (a, x) = (case a of Grave \\<Rightarrow> Acute | Acute \\<Rightarrow> Grave | Macron \\<Rightarrow> Macron, x)\"", "lemma snd_inv_letter[simp]:\n  \"snd (inv_letter x) = snd x\"", "lemma inv_letter_invol[simp]:\n  \"inv_letter (inv_letter x) = x\"", "lemma inv_letter_mono[simp]:\n  assumes \"(x, y) \\<in> letter_less r\"\n  shows \"(inv_letter x, inv_letter y) \\<in> letter_less r\"", "lemma inv_greek_invol[simp]:\n  \"inv_greek (inv_greek s) = s\"", "lemma inv_greek_append:\n  \"inv_greek (s @ t) = inv_greek t @ inv_greek s\"", "lemma inv_msog_invol[simp]:\n  \"inv_msog (inv_msog M) = M\"", "lemma ms_of_greek_inv_greek:\n  \"ms_of_greek (inv_greek M) = inv_msog (ms_of_greek M)\"", "lemma inv_greek_mono:\n  assumes \"trans r\" and \"(s, t) \\<in> greek_less r\"\n  shows \"(inv_greek s, inv_greek t) \\<in> greek_less r\"", "lemma greek_less_rempty[simp]:\n  \"(a,[]) \\<in> greek_less r \\<longleftrightarrow> False\"", "lemma greek_less_nonempty:\n  assumes \"b \\<noteq> []\"\n  shows \"(a,b) \\<in> greek_less r \\<longleftrightarrow> (a,b) \\<in> nest r (greek_less r)\"", "lemma greek_less_lempty[simp]:\n  \"([],b) \\<in> greek_less r \\<longleftrightarrow> b \\<noteq> []\"", "lemma greek_less_singleton:\n  \"(a, b) \\<in> letter_less r \\<Longrightarrow> ([a], [b]) \\<in> greek_less r\"", "lemma ms_of_greek_cons:\n  \"ms_of_greek (x # s) = {# adj_msog [] s (x,[]) #} + image_mset (adj_msog [x] []) (ms_of_greek s)\"", "lemma greek_less_cons_mono:\n  assumes \"trans r\"\n  shows \"(s, t) \\<in> greek_less r \\<Longrightarrow> (x # s, x # t) \\<in> greek_less r\"", "lemma greek_less_app_mono2:\n  assumes \"trans r\" and \"(s, t) \\<in> greek_less r\"\n  shows \"(p @ s, p @ t) \\<in> greek_less r\"", "lemma greek_less_app_mono1:\n  assumes \"trans r\" and \"(s, t) \\<in> greek_less r\"\n  shows \"(s @ p, t @ p) \\<in> greek_less r\"", "lemma greek_embed:\n  assumes \"trans r\"\n  shows \"list_emb (\\<lambda>a b. (a, b): reflcl (letter_less r)) a b \\<Longrightarrow> (a, b) \\<in> reflcl (greek_less r)\"", "lemma wqo_letter_less:\n  assumes t: \"trans r\" and w: \"wqo_on (\\<lambda>a b. (a, b) \\<in> r\\<^sup>=) UNIV\"\n  shows \"wqo_on (\\<lambda>a b. (a, b) \\<in> (letter_less r)\\<^sup>=) UNIV\"", "lemma wf_greek_less:\n  assumes \"wf r\" and \"trans r\"\n  shows \"wf (greek_less r)\"", "lemma pairwise_imp_mult:\n  assumes \"N \\<noteq> {#}\" and \"\\<forall>x \\<in> set_mset M. \\<exists>y \\<in> set_mset N. (x, y) \\<in> r\"\n  shows \"(M, N) \\<in> mult r\"", "lemma singleton_greek_less:\n  assumes as: \"snd ` set as \\<subseteq> under r b\"\n  shows \"(as, [(a,b)]) \\<in> greek_less r\"", "lemma peak_greek_less:\n  assumes as: \"snd ` set as \\<subseteq> under r a\" and b': \"b' \\<in> {[(Grave,b)],[]}\"\n  and cs: \"snd ` set cs \\<subseteq> under r a \\<union> under r b\" and a': \"a' \\<in> {[(Acute,a)],[]}\"\n  and bs: \"snd ` set bs \\<subseteq> under r b\"\n  shows \"(as @ b' @ cs @ a' @ bs, [(Acute,a),(Grave,b)]) \\<in> greek_less r\"", "lemma rcliff_greek_less1:\n  assumes \"trans r\" (* unused assumption kept for symmetry with lcliff_greek_less1 *)\n  and as: \"snd ` set as \\<subseteq> under r a \\<inter> under r b\" and b': \"b' \\<in> {[(Grave,b)],[]}\"\n  and cs: \"snd ` set cs \\<subseteq> under r b\" and a': \"a' = [(Macron,a)]\"\n  and bs: \"snd ` set bs \\<subseteq> under r b\"\n  shows \"(as @ b' @ cs @ a' @ bs, [(Macron,a),(Grave,b)]) \\<in> greek_less r\"", "lemma rcliff_greek_less2:\n  assumes \"trans r\" (* unused assumption kept for symmetry with lcliff_greek_less2 *)\n  and as: \"snd ` set as \\<subseteq> under r a\" and b': \"b' \\<in> {[(Grave,b)],[]}\"\n  and cs: \"snd ` set cs \\<subseteq> under r a \\<union> under r b\"\n  shows \"(as @ b' @ cs, [(Macron,a),(Grave,b)]) \\<in> greek_less r\"", "lemma snd_inv_greek [simp]: \"snd ` set (inv_greek as) = snd ` set as\"", "lemma lcliff_greek_less1:\n  assumes \"trans r\"\n  and as: \"snd ` set as \\<subseteq> under r a\" and b': \"b' = [(Macron,b)]\"\n  and cs: \"snd ` set cs \\<subseteq> under r a\" and a': \"a' \\<in> {[(Acute,a)],[]}\"\n  and bs: \"snd ` set bs \\<subseteq> under r a \\<inter> under r b\"\n  shows \"(as @ b' @ cs @ a' @ bs, [(Acute,a),(Macron,b)]) \\<in> greek_less r\"", "lemma lcliff_greek_less2:\n  assumes \"trans r\"\n  and cs: \"snd ` set cs \\<subseteq> under r a \\<union> under r b\" and a': \"a' \\<in> {[(Acute,a)],[]}\"\n  and bs: \"snd ` set bs \\<subseteq> under r b\"\n  shows \"(cs @ a' @ bs, [(Acute,a),(Macron,b)]) \\<in> greek_less r\"", "lemma lconv_append[simp]:\n  \"lconv (xs @ ys) = lconv xs O lconv ys\"", "lemma conversion_join_or_peak_or_cliff:\n  obtains (join) as bs cs where \"set as \\<subseteq> {Grave}\" and \"set bs \\<subseteq> {Macron}\" and \"set cs \\<subseteq> {Acute}\"\n    and \"ds = as @ bs @ cs\"\n  | (peak) as bs where \"ds = as @ ([Acute] @ [Grave]) @ bs\"\n  | (lcliff) as bs where \"ds = as @ ([Acute] @ [Macron]) @ bs\"\n  | (rcliff) as bs where \"ds = as @ ([Macron] @ [Grave]) @ bs\"", "lemma map_eq_append_split:\n  assumes \"map f xs = ys1 @ ys2\"\n  obtains xs1 xs2 where \"ys1 = map f xs1\" \"ys2 = map f xs2\" \"xs = xs1 @ xs2\"", "lemmas map_eq_append_splits = map_eq_append_split map_eq_append_split[OF sym]", "lemma conversion_to_lconv:\n  assumes \"(u, v) \\<in> conversion' M\"\n  obtains xs where \"snd ` set xs \\<subseteq> M\" and \"(u, v) \\<in> lconv xs\"", "lemma dd_commute_modulo_conv[case_names wf trans peak lcliff rcliff]:\n  assumes \"wf r\" and \"trans r\"\n  and pk: \"\\<And>a b s t u. (s, t) \\<in> L a \\<Longrightarrow> (s, u) \\<in> R b \\<Longrightarrow> \\<exists>xs. lpeak r a b xs \\<and> (t, u) \\<in> lconv xs\"\n  and lc: \"\\<And>a b s t u. (s, t) \\<in> L a \\<Longrightarrow> (s, u) \\<in> E b \\<Longrightarrow> \\<exists>xs. lcliff r a b xs \\<and> (t, u) \\<in> lconv xs\"\n  and rc: \"\\<And>a b s t u. (s, t) \\<in> (E a)\\<inverse> \\<Longrightarrow> (s, u) \\<in> R b \\<Longrightarrow> \\<exists>xs. rcliff r a b xs \\<and> (t, u) \\<in> lconv xs\"\n  shows \"conversion' UNIV \\<subseteq> valley' UNIV\"", "lemma dd_commute_modulo[case_names wf trans peak lcliff rcliff]:\n  assumes \"wf r\" and \"trans r\"\n  and pk: \"\\<And>a b s t u. (s, t) \\<in> L a \\<Longrightarrow> (s, u) \\<in> R b \\<Longrightarrow>\n    (t, u) \\<in> conversion' (under r a) O (R b)\\<^sup>= O conversion' (under r a \\<union> under r b) O\n      ((L a)\\<inverse>)\\<^sup>= O conversion' (under r b)\"\n  and lc: \"\\<And>a b s t u. (s, t) \\<in> L a \\<Longrightarrow> (s, u) \\<in> E b \\<Longrightarrow>\n    (t, u) \\<in> conversion' (under r a) O E b O conversion' (under r a) O\n      ((L a)\\<inverse>)\\<^sup>= O conversion' (under r a \\<inter> under r b) \\<or>\n    (t, u) \\<in> conversion' (under r a \\<union> under r b) O ((L a )\\<inverse>)\\<^sup>= O conversion' (under r b)\"\n  and rc: \"\\<And>a b s t u. (s, t) \\<in> (E a)\\<inverse> \\<Longrightarrow> (s, u) \\<in> R b \\<Longrightarrow>\n    (t, u) \\<in> conversion' (under r a \\<inter> under r b) O (R b)\\<^sup>= O conversion' (under r b) O\n      E a O conversion' (under r b) \\<or>\n    (t, u) \\<in> conversion' (under r a) O (R b)\\<^sup>= O conversion' (under r a \\<union> under r b)\"\n  shows \"conversion' UNIV \\<subseteq> valley' UNIV\"", "lemma dd_cr_modulo[case_names wf trans symE peak cliff]:\n  assumes \"wf r\" and \"trans r\" and E: \"\\<And>i. sym (E i)\"\n  and pk: \"\\<And>a b s t u. (s, t) \\<in> L a \\<Longrightarrow> (s, u) \\<in> L b \\<Longrightarrow>\n    (t, u) \\<in> conversion' L L E (under r a) O (L b)\\<^sup>= O conversion' L L E (under r a \\<union> under r b) O\n      ((L a)\\<inverse>)\\<^sup>= O conversion' L L E (under r b)\"\n  and cl: \"\\<And>a b s t u. (s, t) \\<in> L a \\<Longrightarrow> (s, u) \\<in> E b \\<Longrightarrow>\n    (t, u) \\<in> conversion' L L E (under r a) O E b O conversion' L L E (under r a) O\n      ((L a)\\<inverse>)\\<^sup>= O conversion' L L E (under r a \\<inter> under r b) \\<or>\n    (t, u) \\<in> conversion' L L E (under r a \\<union> under r b) O ((L a )\\<inverse>)\\<^sup>= O conversion' L L E (under r b)\"\n  shows \"conversion' L L E UNIV \\<subseteq> valley' L L E UNIV\"", "lemma dd_commute[case_names wf trans peak]:\n  assumes \"wf r\" and \"trans r\"\n  and pk: \"\\<And>a b s t u. (s, t) \\<in> L a \\<Longrightarrow> (s, u) \\<in> R b \\<Longrightarrow>\n    (t, u) \\<in> conversion'' L R (under r a) O (R b)\\<^sup>= O conversion'' L R (under r a \\<union> under r b) O\n      ((L a)\\<inverse>)\\<^sup>= O conversion'' L R (under r b)\"\n  shows \"commute (\\<Union>i. L i) (\\<Union>i. R i)\"", "lemmas dd_cr[case_names wf trans peak] =\n  dd_commute[of _ L L for L, unfolded CR_iff_self_commute[symmetric]]", "lemma Union_down: \"(\\<Union>i. down L i) = (\\<Union>i. L i)\"", "lemma edd_commute[case_names wf transr transq reflq compat peak]:\n  assumes pk: \"\\<And>a b s t u. (s, t) \\<in> L a \\<Longrightarrow> (s, u) \\<in> R b \\<Longrightarrow>\n    (t, u) \\<in> conversion'' L R (under r a) O (down R b)\\<^sup>= O conversion'' L R (under r a \\<union> under r b) O\n      ((down L a)\\<inverse>)\\<^sup>= O conversion'' L R (under r b)\"\n  shows \"commute (\\<Union>i. L i) (\\<Union>i. R i)\"", "lemmas edd_cr[case_names wf transr transq reflq compat peak] =\n  edd_commute[of L L for L, unfolded CR_iff_self_commute[symmetric]]"], "translations": [["", "lemma UNIV_accent: \"UNIV = { Acute, Grave, Macron }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = {Acute, Grave, Macron}", "using accent.nchotomy"], ["proof (prove)\nusing this:\n  \\<forall>accent. accent = Acute \\<or> accent = Grave \\<or> accent = Macron\n\ngoal (1 subgoal):\n 1. UNIV = {Acute, Grave, Macron}", "by blast"], ["", "lemma finite_accent: \"finite (UNIV :: accent set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV", "by (simp add: UNIV_accent)"], ["", "type_synonym 'a letter = \"accent \\<times> 'a\""], ["", "definition letter_less :: \"('a \\<times> 'a) set \\<Rightarrow> ('a letter \\<times> 'a letter) set\" where\n  [simp]: \"letter_less R = {(a,b). (snd a, snd b) \\<in> R}\""], ["", "lemma mono_letter_less: \"mono letter_less\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono letter_less", "by (auto simp add: mono_def)"], ["", "subsection \\<open>Comparing Greek strings\\<close>"], ["", "type_synonym 'a greek = \"'a letter list\""], ["", "definition adj_msog :: \"'a greek \\<Rightarrow> 'a greek \\<Rightarrow> ('a letter \\<times> 'a greek) \\<Rightarrow> ('a letter \\<times> 'a greek)\"\nwhere\n  \"adj_msog xs zs l \\<equiv>\n    case l of (y,ys) \\<Rightarrow> (y, case fst y of Acute \\<Rightarrow> ys @ zs | Grave \\<Rightarrow> xs @ ys | Macron \\<Rightarrow> ys)\""], ["", "definition ms_of_greek :: \"'a greek \\<Rightarrow> ('a letter \\<times> 'a greek) multiset\" where\n  \"ms_of_greek as = mset\n    (map (\\<lambda>(xs, y, zs) \\<Rightarrow> adj_msog xs zs (y, [])) (list_splits as))\""], ["", "lemma adj_msog_adj_msog[simp]:\n  \"adj_msog xs zs (adj_msog xs' zs' y) = adj_msog (xs @ xs') (zs' @ zs) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adj_msog xs zs (adj_msog xs' zs' y) = adj_msog (xs @ xs') (zs' @ zs) y", "by (auto simp: adj_msog_def split: accent.splits prod.splits)"], ["", "lemma compose_adj_msog[simp]: \"adj_msog xs zs \\<circ> adj_msog xs' zs' = adj_msog (xs @ xs') (zs' @ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adj_msog xs zs \\<circ> adj_msog xs' zs' = adj_msog (xs @ xs') (zs' @ zs)", "by (simp add: comp_def)"], ["", "lemma adj_msog_single:\n  \"adj_msog xs zs (x,[]) = (x, (case fst x of Grave \\<Rightarrow> xs | Acute \\<Rightarrow> zs | Macron \\<Rightarrow> []))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adj_msog xs zs (x, []) =\n    (x, case fst x of Acute \\<Rightarrow> zs | Grave \\<Rightarrow> xs\n        | Macron \\<Rightarrow> [])", "by (simp add: adj_msog_def split: accent.splits)"], ["", "lemma ms_of_greek_elem:\n  assumes \"(x,xs) \\<in> set_mset (ms_of_greek ys)\"\n  shows \"x \\<in> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set ys", "using assms"], ["proof (prove)\nusing this:\n  (x, xs) \\<in># ms_of_greek ys\n\ngoal (1 subgoal):\n 1. x \\<in> set ys", "by (auto dest: elem_list_splits_elem simp: adj_msog_def ms_of_greek_def)"], ["", "lemma ms_of_greek_shorter:\n  assumes \"(x, t) \\<in># ms_of_greek s\"\n  shows \"length s > length t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length t < length s", "using assms[unfolded ms_of_greek_def in_multiset_in_set]"], ["proof (prove)\nusing this:\n  (x, t)\n  \\<in> set (map (\\<lambda>(xs, y, zs). adj_msog xs zs (y, []))\n              (list_splits s))\n\ngoal (1 subgoal):\n 1. length t < length s", "by (auto simp: elem_list_splits_length adj_msog_def split: accent.splits)"], ["", "lemma msog_append: \"ms_of_greek (xs @ ys) = image_mset (adj_msog [] ys) (ms_of_greek xs) +\n  image_mset (adj_msog xs []) (ms_of_greek ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ms_of_greek (xs @ ys) =\n    image_mset (adj_msog [] ys) (ms_of_greek xs) +\n    image_mset (adj_msog xs []) (ms_of_greek ys)", "by (auto simp: ms_of_greek_def list_splits_append multiset.map_comp comp_def prod.case_distrib)"], ["", "definition nest :: \"('a \\<times> 'a) set \\<Rightarrow> ('a greek \\<times> 'a greek) set \\<Rightarrow> ('a greek \\<times> 'a greek) set\" where\n  [simp]: \"nest r s = {(a,b). (ms_of_greek a, ms_of_greek b) \\<in> mult (letter_less r <*lex*> s)}\""], ["", "lemma mono_nest: \"mono (nest r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (nest r)", "unfolding mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<subseteq> y \\<longrightarrow> nest r x \\<subseteq> nest r y", "proof (intro allI impI subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x \\<subseteq> y; xa \\<in> nest r x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> nest r y", "fix R S x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x \\<subseteq> y; xa \\<in> nest r x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> nest r y", "assume 1: \"R \\<subseteq> S\" and 2: \"x \\<in> nest r R\""], ["proof (state)\nthis:\n  R \\<subseteq> S\n  x \\<in> nest r R\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x \\<subseteq> y; xa \\<in> nest r x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> nest r y", "from 1"], ["proof (chain)\npicking this:\n  R \\<subseteq> S", "have \"mult (letter_less r <*lex*> R) \\<subseteq> mult (letter_less r <*lex*> S)\""], ["proof (prove)\nusing this:\n  R \\<subseteq> S\n\ngoal (1 subgoal):\n 1. mult (letter_less r <*lex*> R)\n    \\<subseteq> mult (letter_less r <*lex*> S)", "using mono_mult mono_lex2[of \"letter_less r\"]"], ["proof (prove)\nusing this:\n  R \\<subseteq> S\n  mono mult\n  mono ((<*lex*>) (letter_less r))\n\ngoal (1 subgoal):\n 1. mult (letter_less r <*lex*> R)\n    \\<subseteq> mult (letter_less r <*lex*> S)", "unfolding mono_def"], ["proof (prove)\nusing this:\n  R \\<subseteq> S\n  \\<forall>x y. x \\<subseteq> y \\<longrightarrow> mult x \\<subseteq> mult y\n  \\<forall>x y.\n     x \\<subseteq> y \\<longrightarrow>\n     letter_less r <*lex*> x \\<subseteq> letter_less r <*lex*> y\n\ngoal (1 subgoal):\n 1. mult (letter_less r <*lex*> R)\n    \\<subseteq> mult (letter_less r <*lex*> S)", "by blast"], ["proof (state)\nthis:\n  mult (letter_less r <*lex*> R) \\<subseteq> mult (letter_less r <*lex*> S)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x \\<subseteq> y; xa \\<in> nest r x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> nest r y", "with 2"], ["proof (chain)\npicking this:\n  x \\<in> nest r R\n  mult (letter_less r <*lex*> R) \\<subseteq> mult (letter_less r <*lex*> S)", "show \"x \\<in> nest r S\""], ["proof (prove)\nusing this:\n  x \\<in> nest r R\n  mult (letter_less r <*lex*> R) \\<subseteq> mult (letter_less r <*lex*> S)\n\ngoal (1 subgoal):\n 1. x \\<in> nest r S", "by auto"], ["proof (state)\nthis:\n  x \\<in> nest r S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nest_mono[mono_set]: \"x \\<subseteq> y \\<Longrightarrow> (a,b) \\<in> nest r x \\<longrightarrow> (a,b) \\<in> nest r y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<subseteq> y \\<Longrightarrow>\n    (a, b) \\<in> nest r x \\<longrightarrow> (a, b) \\<in> nest r y", "using mono_nest[unfolded mono_def, rule_format, of x y r]"], ["proof (prove)\nusing this:\n  x \\<subseteq> y \\<Longrightarrow> nest r x \\<subseteq> nest r y\n\ngoal (1 subgoal):\n 1. x \\<subseteq> y \\<Longrightarrow>\n    (a, b) \\<in> nest r x \\<longrightarrow> (a, b) \\<in> nest r y", "by blast"], ["", "definition greek_less :: \"('a \\<times> 'a) set \\<Rightarrow> ('a greek \\<times> 'a greek) set\" where\n  \"greek_less r = lfp (nest r)\""], ["", "lemma greek_less_unfold:\n  \"greek_less r = nest r (greek_less r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. greek_less r = nest r (greek_less r)", "using mono_nest[of r] lfp_unfold[of \"nest r\"]"], ["proof (prove)\nusing this:\n  mono (nest r)\n  mono (nest r) \\<Longrightarrow> lfp (nest r) = nest r (lfp (nest r))\n\ngoal (1 subgoal):\n 1. greek_less r = nest r (greek_less r)", "by (simp add: greek_less_def)"], ["", "subsection \\<open>Preservation of strict partial orders\\<close>"], ["", "lemma strict_order_letter_less:\n  assumes \"strict_order r\"\n  shows \"strict_order (letter_less r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_order (letter_less r)", "using assms"], ["proof (prove)\nusing this:\n  strict_order r\n\ngoal (1 subgoal):\n 1. strict_order (letter_less r)", "unfolding irrefl_def trans_def letter_less_def"], ["proof (prove)\nusing this:\n  (\\<forall>a. (a, a) \\<notin> r) \\<and>\n  (\\<forall>x y z.\n      (x, y) \\<in> r \\<longrightarrow>\n      (y, z) \\<in> r \\<longrightarrow> (x, z) \\<in> r)\n\ngoal (1 subgoal):\n 1. (\\<forall>a. (a, a) \\<notin> {(a, b). (snd a, snd b) \\<in> r}) \\<and>\n    (\\<forall>x y z.\n        (x, y) \\<in> {(a, b). (snd a, snd b) \\<in> r} \\<longrightarrow>\n        (y, z) \\<in> {(a, b). (snd a, snd b) \\<in> r} \\<longrightarrow>\n        (x, z) \\<in> {(a, b). (snd a, snd b) \\<in> r})", "by fast"], ["", "lemma strict_order_nest:\n  assumes r: \"strict_order r\" and R: \"strict_order R\"\n  shows \"strict_order (nest r R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_order (nest r R)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. strict_order (nest r R)", "have \"strict_order (mult (letter_less r <*lex*> R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_order (mult (letter_less r <*lex*> R))", "using strict_order_letter_less[of r] irrefl_lex_prod[of \"letter_less r\" R]\n    trans_lex_prod[of \"letter_less r\" R] strict_order_mult[of \"letter_less r <*lex*> R\"] assms"], ["proof (prove)\nusing this:\n  strict_order r \\<Longrightarrow> strict_order (letter_less r)\n  \\<lbrakk>irrefl (letter_less r); irrefl R\\<rbrakk>\n  \\<Longrightarrow> irrefl (letter_less r <*lex*> R)\n  \\<lbrakk>trans (letter_less r); trans R\\<rbrakk>\n  \\<Longrightarrow> trans (letter_less r <*lex*> R)\n  \\<lbrakk>irrefl (letter_less r <*lex*> R);\n   trans (letter_less r <*lex*> R)\\<rbrakk>\n  \\<Longrightarrow> irrefl (mult (letter_less r <*lex*> R))\n  \\<lbrakk>irrefl (letter_less r <*lex*> R);\n   trans (letter_less r <*lex*> R)\\<rbrakk>\n  \\<Longrightarrow> trans (mult (letter_less r <*lex*> R))\n  strict_order r\n  strict_order R\n\ngoal (1 subgoal):\n 1. strict_order (mult (letter_less r <*lex*> R))", "by fast"], ["proof (state)\nthis:\n  strict_order (mult (letter_less r <*lex*> R))\n\ngoal (1 subgoal):\n 1. strict_order (nest r R)", "from this"], ["proof (chain)\npicking this:\n  strict_order (mult (letter_less r <*lex*> R))", "show \"strict_order (nest r R)\""], ["proof (prove)\nusing this:\n  strict_order (mult (letter_less r <*lex*> R))\n\ngoal (1 subgoal):\n 1. strict_order (nest r R)", "unfolding nest_def trans_def irrefl_def"], ["proof (prove)\nusing this:\n  (\\<forall>a. (a, a) \\<notin> mult (letter_less r <*lex*> R)) \\<and>\n  (\\<forall>x y z.\n      (x, y) \\<in> mult (letter_less r <*lex*> R) \\<longrightarrow>\n      (y, z) \\<in> mult (letter_less r <*lex*> R) \\<longrightarrow>\n      (x, z) \\<in> mult (letter_less r <*lex*> R))\n\ngoal (1 subgoal):\n 1. (\\<forall>a.\n        (a, a)\n        \\<notin> {(a, b).\n                  (ms_of_greek a, ms_of_greek b)\n                  \\<in> mult (letter_less r <*lex*> R)}) \\<and>\n    (\\<forall>x y z.\n        (x, y)\n        \\<in> {(a, b).\n               (ms_of_greek a, ms_of_greek b)\n               \\<in> mult (letter_less r <*lex*> R)} \\<longrightarrow>\n        (y, z)\n        \\<in> {(a, b).\n               (ms_of_greek a, ms_of_greek b)\n               \\<in> mult (letter_less r <*lex*> R)} \\<longrightarrow>\n        (x, z)\n        \\<in> {(a, b).\n               (ms_of_greek a, ms_of_greek b)\n               \\<in> mult (letter_less r <*lex*> R)})", "by fast"], ["proof (state)\nthis:\n  strict_order (nest r R)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strict_order_greek_less:\n  assumes \"strict_order r\"\n  shows \"strict_order (greek_less r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_order (greek_less r)", "by (simp add: greek_less_def strict_order_lfp[OF mono_nest strict_order_nest[OF assms]])"], ["", "lemma trans_letter_less:\n  assumes \"trans r\"\n  shows \"trans (letter_less r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans (letter_less r)", "using assms"], ["proof (prove)\nusing this:\n  trans r\n\ngoal (1 subgoal):\n 1. trans (letter_less r)", "unfolding trans_def letter_less_def"], ["proof (prove)\nusing this:\n  \\<forall>x y z.\n     (x, y) \\<in> r \\<longrightarrow>\n     (y, z) \\<in> r \\<longrightarrow> (x, z) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       (x, y) \\<in> {(a, b). (snd a, snd b) \\<in> r} \\<longrightarrow>\n       (y, z) \\<in> {(a, b). (snd a, snd b) \\<in> r} \\<longrightarrow>\n       (x, z) \\<in> {(a, b). (snd a, snd b) \\<in> r}", "by fast"], ["", "lemma trans_order_nest: \"trans (nest r R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans (nest r R)", "using trans_mult"], ["proof (prove)\nusing this:\n  trans (mult ?R)\n\ngoal (1 subgoal):\n 1. trans (nest r R)", "unfolding nest_def trans_def"], ["proof (prove)\nusing this:\n  \\<forall>x y z.\n     (x, y) \\<in> mult ?R \\<longrightarrow>\n     (y, z) \\<in> mult ?R \\<longrightarrow> (x, z) \\<in> mult ?R\n\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       (x, y)\n       \\<in> {(a, b).\n              (ms_of_greek a, ms_of_greek b)\n              \\<in> mult (letter_less r <*lex*> R)} \\<longrightarrow>\n       (y, z)\n       \\<in> {(a, b).\n              (ms_of_greek a, ms_of_greek b)\n              \\<in> mult (letter_less r <*lex*> R)} \\<longrightarrow>\n       (x, z)\n       \\<in> {(a, b).\n              (ms_of_greek a, ms_of_greek b)\n              \\<in> mult (letter_less r <*lex*> R)}", "by fast"], ["", "lemma trans_greek_less[simp]: \"trans (greek_less r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans (greek_less r)", "by (subst greek_less_unfold) (rule trans_order_nest)"], ["", "lemma mono_greek_less: \"mono greek_less\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono greek_less", "unfolding greek_less_def mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<subseteq> y \\<longrightarrow>\n       lfp (nest x) \\<subseteq> lfp (nest y)", "proof (intro allI impI lfp_mono)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y Z.\n       x \\<subseteq> y \\<Longrightarrow> nest x Z \\<subseteq> nest y Z", "fix r s :: \"('a \\<times> 'a) set\" and R :: \"('a greek \\<times> 'a greek) set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y Z.\n       x \\<subseteq> y \\<Longrightarrow> nest x Z \\<subseteq> nest y Z", "assume \"r \\<subseteq> s\""], ["proof (state)\nthis:\n  r \\<subseteq> s\n\ngoal (1 subgoal):\n 1. \\<And>x y Z.\n       x \\<subseteq> y \\<Longrightarrow> nest x Z \\<subseteq> nest y Z", "then"], ["proof (chain)\npicking this:\n  r \\<subseteq> s", "have \"letter_less r <*lex*> R \\<subseteq> letter_less s <*lex*> R\""], ["proof (prove)\nusing this:\n  r \\<subseteq> s\n\ngoal (1 subgoal):\n 1. letter_less r <*lex*> R \\<subseteq> letter_less s <*lex*> R", "using mono_letter_less mono_lex1"], ["proof (prove)\nusing this:\n  r \\<subseteq> s\n  mono letter_less\n  mono (\\<lambda>r. r <*lex*> ?s)\n\ngoal (1 subgoal):\n 1. letter_less r <*lex*> R \\<subseteq> letter_less s <*lex*> R", "unfolding mono_def"], ["proof (prove)\nusing this:\n  r \\<subseteq> s\n  \\<forall>x y.\n     x \\<subseteq> y \\<longrightarrow>\n     letter_less x \\<subseteq> letter_less y\n  \\<forall>x y.\n     x \\<subseteq> y \\<longrightarrow> x <*lex*> ?s \\<subseteq> y <*lex*> ?s\n\ngoal (1 subgoal):\n 1. letter_less r <*lex*> R \\<subseteq> letter_less s <*lex*> R", "by metis"], ["proof (state)\nthis:\n  letter_less r <*lex*> R \\<subseteq> letter_less s <*lex*> R\n\ngoal (1 subgoal):\n 1. \\<And>x y Z.\n       x \\<subseteq> y \\<Longrightarrow> nest x Z \\<subseteq> nest y Z", "then"], ["proof (chain)\npicking this:\n  letter_less r <*lex*> R \\<subseteq> letter_less s <*lex*> R", "show \"nest r R \\<subseteq> nest s R\""], ["proof (prove)\nusing this:\n  letter_less r <*lex*> R \\<subseteq> letter_less s <*lex*> R\n\ngoal (1 subgoal):\n 1. nest r R \\<subseteq> nest s R", "using mono_mult"], ["proof (prove)\nusing this:\n  letter_less r <*lex*> R \\<subseteq> letter_less s <*lex*> R\n  mono mult\n\ngoal (1 subgoal):\n 1. nest r R \\<subseteq> nest s R", "unfolding nest_def mono_def"], ["proof (prove)\nusing this:\n  letter_less r <*lex*> R \\<subseteq> letter_less s <*lex*> R\n  \\<forall>x y. x \\<subseteq> y \\<longrightarrow> mult x \\<subseteq> mult y\n\ngoal (1 subgoal):\n 1. {(a, b).\n     (ms_of_greek a, ms_of_greek b) \\<in> mult (letter_less r <*lex*> R)}\n    \\<subseteq> {(a, b).\n                 (ms_of_greek a, ms_of_greek b)\n                 \\<in> mult (letter_less s <*lex*> R)}", "by blast"], ["proof (state)\nthis:\n  nest r R \\<subseteq> nest s R\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Involution\\<close>"], ["", "definition inv_letter :: \"'a letter \\<Rightarrow> 'a letter\" where\n  \"inv_letter l \\<equiv>\n    case l of (a, x) \\<Rightarrow> (case a of Grave \\<Rightarrow> Acute | Acute \\<Rightarrow> Grave | Macron \\<Rightarrow> Macron, x)\""], ["", "lemma inv_letter_pair[simp]:\n  \"inv_letter (a, x) = (case a of Grave \\<Rightarrow> Acute | Acute \\<Rightarrow> Grave | Macron \\<Rightarrow> Macron, x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_letter (a, x) =\n    (case a of Acute \\<Rightarrow> Grave | Grave \\<Rightarrow> Acute\n     | Macron \\<Rightarrow> Macron,\n     x)", "by (simp add: inv_letter_def)"], ["", "lemma snd_inv_letter[simp]:\n  \"snd (inv_letter x) = snd x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (inv_letter x) = snd x", "by (simp add: inv_letter_def split: prod.splits)"], ["", "lemma inv_letter_invol[simp]:\n  \"inv_letter (inv_letter x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_letter (inv_letter x) = x", "by (simp add: inv_letter_def split: prod.splits accent.splits)"], ["", "lemma inv_letter_mono[simp]:\n  assumes \"(x, y) \\<in> letter_less r\"\n  shows \"(inv_letter x, inv_letter y) \\<in> letter_less r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inv_letter x, inv_letter y) \\<in> letter_less r", "using assms"], ["proof (prove)\nusing this:\n  (x, y) \\<in> letter_less r\n\ngoal (1 subgoal):\n 1. (inv_letter x, inv_letter y) \\<in> letter_less r", "by simp"], ["", "definition inv_greek :: \"'a greek \\<Rightarrow> 'a greek\" where\n  \"inv_greek s = rev (map inv_letter s)\""], ["", "lemma inv_greek_invol[simp]:\n  \"inv_greek (inv_greek s) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_greek (inv_greek s) = s", "by (simp add: inv_greek_def rev_map comp_def)"], ["", "lemma inv_greek_append:\n  \"inv_greek (s @ t) = inv_greek t @ inv_greek s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_greek (s @ t) = inv_greek t @ inv_greek s", "by (simp add: inv_greek_def)"], ["", "definition inv_msog :: \"('a letter \\<times> 'a greek) multiset \\<Rightarrow> ('a letter \\<times> 'a greek) multiset\" where\n  \"inv_msog M = image_mset (\\<lambda>(x, t). (inv_letter x, inv_greek t)) M\""], ["", "lemma inv_msog_invol[simp]:\n  \"inv_msog (inv_msog M) = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_msog (inv_msog M) = M", "by (simp add: inv_msog_def multiset.map_comp comp_def prod.case_distrib)"], ["", "lemma ms_of_greek_inv_greek:\n  \"ms_of_greek (inv_greek M) = inv_msog (ms_of_greek M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ms_of_greek (inv_greek M) = inv_msog (ms_of_greek M)", "unfolding inv_msog_def inv_greek_def ms_of_greek_def list_splits_rev list_splits_map mset_map\n  multiset.map_comp mset_rev inv_letter_def adj_msog_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset\n     ((\\<lambda>(xs, y, zs).\n          case (y, []) of\n          (y, ys) \\<Rightarrow>\n            (y, case fst y of Acute \\<Rightarrow> ys @ zs\n                | Grave \\<Rightarrow> xs @ ys\n                | Macron \\<Rightarrow> ys)) \\<circ>\n      ((\\<lambda>(xs, x, ys). (rev ys, x, rev xs)) \\<circ>\n       (\\<lambda>(xs, x, ys).\n           (map (\\<lambda>l.\n                    case l of\n                    (a, x) \\<Rightarrow>\n                      (case a of Acute \\<Rightarrow> Grave\n                       | Grave \\<Rightarrow> Acute\n                       | Macron \\<Rightarrow> Macron,\n                       x))\n             xs,\n            case x of\n            (a, x) \\<Rightarrow>\n              (case a of Acute \\<Rightarrow> Grave\n               | Grave \\<Rightarrow> Acute | Macron \\<Rightarrow> Macron,\n               x),\n            map (\\<lambda>l.\n                    case l of\n                    (a, x) \\<Rightarrow>\n                      (case a of Acute \\<Rightarrow> Grave\n                       | Grave \\<Rightarrow> Acute\n                       | Macron \\<Rightarrow> Macron,\n                       x))\n             ys))))\n     (mset (list_splits M)) =\n    image_mset\n     ((\\<lambda>(x, t).\n          (case x of\n           (a, x) \\<Rightarrow>\n             (case a of Acute \\<Rightarrow> Grave\n              | Grave \\<Rightarrow> Acute | Macron \\<Rightarrow> Macron,\n              x),\n           rev (map (\\<lambda>l.\n                        case l of\n                        (a, x) \\<Rightarrow>\n                          (case a of Acute \\<Rightarrow> Grave\n                           | Grave \\<Rightarrow> Acute\n                           | Macron \\<Rightarrow> Macron,\n                           x))\n                 t))) \\<circ>\n      (\\<lambda>(xs, y, zs).\n          case (y, []) of\n          (y, ys) \\<Rightarrow>\n            (y, case fst y of Acute \\<Rightarrow> ys @ zs\n                | Grave \\<Rightarrow> xs @ ys | Macron \\<Rightarrow> ys)))\n     (mset (list_splits M))", "by (rule cong[OF cong[OF refl[of \"image_mset\"]] refl]) (auto split: accent.splits)"], ["", "lemma inv_greek_mono:\n  assumes \"trans r\" and \"(s, t) \\<in> greek_less r\"\n  shows \"(inv_greek s, inv_greek t) \\<in> greek_less r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inv_greek s, inv_greek t) \\<in> greek_less r", "using assms(2)"], ["proof (prove)\nusing this:\n  (s, t) \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. (inv_greek s, inv_greek t) \\<in> greek_less r", "proof (induct \"length s + length t\" arbitrary: s t rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<And>sa ta.\n                   \\<lbrakk>length sa + length ta < length s + length t;\n                    (sa, ta) \\<in> greek_less r\\<rbrakk>\n                   \\<Longrightarrow> (inv_greek sa, inv_greek ta)\n                                     \\<in> greek_less r;\n        (s, t) \\<in> greek_less r\\<rbrakk>\n       \\<Longrightarrow> (inv_greek s, inv_greek t) \\<in> greek_less r", "note * = trans_lex_prod[OF trans_letter_less[OF \\<open>trans r\\<close>] trans_greek_less[of r]]"], ["proof (state)\nthis:\n  trans (letter_less r <*lex*> greek_less r)\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<And>sa ta.\n                   \\<lbrakk>length sa + length ta < length s + length t;\n                    (sa, ta) \\<in> greek_less r\\<rbrakk>\n                   \\<Longrightarrow> (inv_greek sa, inv_greek ta)\n                                     \\<in> greek_less r;\n        (s, t) \\<in> greek_less r\\<rbrakk>\n       \\<Longrightarrow> (inv_greek s, inv_greek t) \\<in> greek_less r", "case (less s t)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?s + length ?t < length s + length t;\n   (?s, ?t) \\<in> greek_less r\\<rbrakk>\n  \\<Longrightarrow> (inv_greek ?s, inv_greek ?t) \\<in> greek_less r\n  (s, t) \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<And>sa ta.\n                   \\<lbrakk>length sa + length ta < length s + length t;\n                    (sa, ta) \\<in> greek_less r\\<rbrakk>\n                   \\<Longrightarrow> (inv_greek sa, inv_greek ta)\n                                     \\<in> greek_less r;\n        (s, t) \\<in> greek_less r\\<rbrakk>\n       \\<Longrightarrow> (inv_greek s, inv_greek t) \\<in> greek_less r", "have \"(inv_msog (ms_of_greek s), inv_msog (ms_of_greek t)) \\<in> mult (letter_less r <*lex*> greek_less r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inv_msog (ms_of_greek s), inv_msog (ms_of_greek t))\n    \\<in> mult (letter_less r <*lex*> greek_less r)", "unfolding inv_msog_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({#(inv_letter x, inv_greek t). (x, t) \\<in># ms_of_greek s#},\n     {#(inv_letter x, inv_greek t). (x, t) \\<in># ms_of_greek t#})\n    \\<in> mult (letter_less r <*lex*> greek_less r)", "proof (induct rule: mult_of_image_mset[OF * *])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in># ms_of_greek s; y \\<in># ms_of_greek t;\n        (x, y) \\<in> letter_less r <*lex*> greek_less r\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (x, t) \\<Rightarrow> (inv_letter x, inv_greek t),\n                          case y of\n                          (x, t) \\<Rightarrow> (inv_letter x, inv_greek t))\n                         \\<in> letter_less r <*lex*> greek_less r\n 2. (ms_of_greek s, ms_of_greek t)\n    \\<in> mult (letter_less r <*lex*> greek_less r)", "case (1 x y)"], ["proof (state)\nthis:\n  x \\<in># ms_of_greek s\n  y \\<in># ms_of_greek t\n  (x, y) \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in># ms_of_greek s; y \\<in># ms_of_greek t;\n        (x, y) \\<in> letter_less r <*lex*> greek_less r\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (x, t) \\<Rightarrow> (inv_letter x, inv_greek t),\n                          case y of\n                          (x, t) \\<Rightarrow> (inv_letter x, inv_greek t))\n                         \\<in> letter_less r <*lex*> greek_less r\n 2. (ms_of_greek s, ms_of_greek t)\n    \\<in> mult (letter_less r <*lex*> greek_less r)", "thus ?case"], ["proof (prove)\nusing this:\n  x \\<in># ms_of_greek s\n  y \\<in># ms_of_greek t\n  (x, y) \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. (case x of (x, t) \\<Rightarrow> (inv_letter x, inv_greek t),\n     case y of (x, t) \\<Rightarrow> (inv_letter x, inv_greek t))\n    \\<in> letter_less r <*lex*> greek_less r", "by (auto intro: less(1) split: prod.splits dest!: ms_of_greek_shorter)"], ["proof (state)\nthis:\n  (case x of (x, t) \\<Rightarrow> (inv_letter x, inv_greek t),\n   case y of (x, t) \\<Rightarrow> (inv_letter x, inv_greek t))\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. (ms_of_greek s, ms_of_greek t)\n    \\<in> mult (letter_less r <*lex*> greek_less r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (ms_of_greek s, ms_of_greek t)\n    \\<in> mult (letter_less r <*lex*> greek_less r)", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. (ms_of_greek s, ms_of_greek t)\n    \\<in> mult (letter_less r <*lex*> greek_less r)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ms_of_greek s, ms_of_greek t)\n    \\<in> mult (letter_less r <*lex*> greek_less r)", "using less(2)"], ["proof (prove)\nusing this:\n  (s, t) \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. (ms_of_greek s, ms_of_greek t)\n    \\<in> mult (letter_less r <*lex*> greek_less r)", "by (subst(asm) greek_less_unfold) simp"], ["proof (state)\nthis:\n  (ms_of_greek s, ms_of_greek t)\n  \\<in> mult (letter_less r <*lex*> greek_less r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (inv_msog (ms_of_greek s), inv_msog (ms_of_greek t))\n  \\<in> mult (letter_less r <*lex*> greek_less r)\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<And>sa ta.\n                   \\<lbrakk>length sa + length ta < length s + length t;\n                    (sa, ta) \\<in> greek_less r\\<rbrakk>\n                   \\<Longrightarrow> (inv_greek sa, inv_greek ta)\n                                     \\<in> greek_less r;\n        (s, t) \\<in> greek_less r\\<rbrakk>\n       \\<Longrightarrow> (inv_greek s, inv_greek t) \\<in> greek_less r", "thus ?case"], ["proof (prove)\nusing this:\n  (inv_msog (ms_of_greek s), inv_msog (ms_of_greek t))\n  \\<in> mult (letter_less r <*lex*> greek_less r)\n\ngoal (1 subgoal):\n 1. (inv_greek s, inv_greek t) \\<in> greek_less r", "by (subst greek_less_unfold) (auto simp: ms_of_greek_inv_greek)"], ["proof (state)\nthis:\n  (inv_greek s, inv_greek t) \\<in> greek_less r\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Monotonicity of @{term \"greek_less r\"}\\<close>"], ["", "lemma greek_less_rempty[simp]:\n  \"(a,[]) \\<in> greek_less r \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a, []) \\<in> greek_less r) = False", "by (subst greek_less_unfold) (auto simp: ms_of_greek_def)"], ["", "lemma greek_less_nonempty:\n  assumes \"b \\<noteq> []\"\n  shows \"(a,b) \\<in> greek_less r \\<longleftrightarrow> (a,b) \\<in> nest r (greek_less r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a, b) \\<in> greek_less r) = ((a, b) \\<in> nest r (greek_less r))", "by (subst greek_less_unfold) simp"], ["", "lemma greek_less_lempty[simp]:\n  \"([],b) \\<in> greek_less r \\<longleftrightarrow> b \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (([], b) \\<in> greek_less r) = (b \\<noteq> [])", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ([], b) \\<in> greek_less r \\<Longrightarrow> b \\<noteq> []\n 2. b \\<noteq> [] \\<Longrightarrow> ([], b) \\<in> greek_less r", "assume \"([],b) \\<in> greek_less r\""], ["proof (state)\nthis:\n  ([], b) \\<in> greek_less r\n\ngoal (2 subgoals):\n 1. ([], b) \\<in> greek_less r \\<Longrightarrow> b \\<noteq> []\n 2. b \\<noteq> [] \\<Longrightarrow> ([], b) \\<in> greek_less r", "then"], ["proof (chain)\npicking this:\n  ([], b) \\<in> greek_less r", "show \"b \\<noteq> []\""], ["proof (prove)\nusing this:\n  ([], b) \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. b \\<noteq> []", "using greek_less_rempty"], ["proof (prove)\nusing this:\n  ([], b) \\<in> greek_less r\n  ((?a, []) \\<in> greek_less ?r) = False\n\ngoal (1 subgoal):\n 1. b \\<noteq> []", "by fast"], ["proof (state)\nthis:\n  b \\<noteq> []\n\ngoal (1 subgoal):\n 1. b \\<noteq> [] \\<Longrightarrow> ([], b) \\<in> greek_less r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> [] \\<Longrightarrow> ([], b) \\<in> greek_less r", "assume \"b \\<noteq> []\""], ["proof (state)\nthis:\n  b \\<noteq> []\n\ngoal (1 subgoal):\n 1. b \\<noteq> [] \\<Longrightarrow> ([], b) \\<in> greek_less r", "then"], ["proof (chain)\npicking this:\n  b \\<noteq> []", "show \"([],b) \\<in> greek_less r\""], ["proof (prove)\nusing this:\n  b \\<noteq> []\n\ngoal (1 subgoal):\n 1. ([], b) \\<in> greek_less r", "unfolding greek_less_nonempty[OF \\<open>b \\<noteq> []\\<close>]"], ["proof (prove)\nusing this:\n  b \\<noteq> []\n\ngoal (1 subgoal):\n 1. ([], b) \\<in> nest r (greek_less r)", "by (simp add: ms_of_greek_def)"], ["proof (state)\nthis:\n  ([], b) \\<in> greek_less r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma greek_less_singleton:\n  \"(a, b) \\<in> letter_less r \\<Longrightarrow> ([a], [b]) \\<in> greek_less r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> letter_less r \\<Longrightarrow>\n    ([a], [b]) \\<in> greek_less r", "by (subst greek_less_unfold) (auto split: accent.splits simp: adj_msog_def ms_of_greek_def)"], ["", "lemma ms_of_greek_cons:\n  \"ms_of_greek (x # s) = {# adj_msog [] s (x,[]) #} + image_mset (adj_msog [x] []) (ms_of_greek s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ms_of_greek (x # s) =\n    {#adj_msog [] s (x, [])#} + image_mset (adj_msog [x] []) (ms_of_greek s)", "using msog_append[of \"[x]\" s]"], ["proof (prove)\nusing this:\n  ms_of_greek ([x] @ s) =\n  image_mset (adj_msog [] s) (ms_of_greek [x]) +\n  image_mset (adj_msog [x] []) (ms_of_greek s)\n\ngoal (1 subgoal):\n 1. ms_of_greek (x # s) =\n    {#adj_msog [] s (x, [])#} + image_mset (adj_msog [x] []) (ms_of_greek s)", "by (auto simp add: adj_msog_def ms_of_greek_def accent.splits)"], ["", "lemma greek_less_cons_mono:\n  assumes \"trans r\"\n  shows \"(s, t) \\<in> greek_less r \\<Longrightarrow> (x # s, x # t) \\<in> greek_less r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, t) \\<in> greek_less r \\<Longrightarrow>\n    (x # s, x # t) \\<in> greek_less r", "proof (induct \"length s + length t\" arbitrary: s t rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<And>sa ta.\n                   \\<lbrakk>length sa + length ta < length s + length t;\n                    (sa, ta) \\<in> greek_less r\\<rbrakk>\n                   \\<Longrightarrow> (x # sa, x # ta) \\<in> greek_less r;\n        (s, t) \\<in> greek_less r\\<rbrakk>\n       \\<Longrightarrow> (x # s, x # t) \\<in> greek_less r", "note * = trans_lex_prod[OF trans_letter_less[OF \\<open>trans r\\<close>] trans_greek_less[of r]]"], ["proof (state)\nthis:\n  trans (letter_less r <*lex*> greek_less r)\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<And>sa ta.\n                   \\<lbrakk>length sa + length ta < length s + length t;\n                    (sa, ta) \\<in> greek_less r\\<rbrakk>\n                   \\<Longrightarrow> (x # sa, x # ta) \\<in> greek_less r;\n        (s, t) \\<in> greek_less r\\<rbrakk>\n       \\<Longrightarrow> (x # s, x # t) \\<in> greek_less r", "case (less s t)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?s + length ?t < length s + length t;\n   (?s, ?t) \\<in> greek_less r\\<rbrakk>\n  \\<Longrightarrow> (x # ?s, x # ?t) \\<in> greek_less r\n  (s, t) \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<And>sa ta.\n                   \\<lbrakk>length sa + length ta < length s + length t;\n                    (sa, ta) \\<in> greek_less r\\<rbrakk>\n                   \\<Longrightarrow> (x # sa, x # ta) \\<in> greek_less r;\n        (s, t) \\<in> greek_less r\\<rbrakk>\n       \\<Longrightarrow> (x # s, x # t) \\<in> greek_less r", "{"], ["proof (state)\nthis:\n  \\<lbrakk>length ?s + length ?t < length s + length t;\n   (?s, ?t) \\<in> greek_less r\\<rbrakk>\n  \\<Longrightarrow> (x # ?s, x # ?t) \\<in> greek_less r\n  (s, t) \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<And>sa ta.\n                   \\<lbrakk>length sa + length ta < length s + length t;\n                    (sa, ta) \\<in> greek_less r\\<rbrakk>\n                   \\<Longrightarrow> (x # sa, x # ta) \\<in> greek_less r;\n        (s, t) \\<in> greek_less r\\<rbrakk>\n       \\<Longrightarrow> (x # s, x # t) \\<in> greek_less r", "fix M"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<And>sa ta.\n                   \\<lbrakk>length sa + length ta < length s + length t;\n                    (sa, ta) \\<in> greek_less r\\<rbrakk>\n                   \\<Longrightarrow> (x # sa, x # ta) \\<in> greek_less r;\n        (s, t) \\<in> greek_less r\\<rbrakk>\n       \\<Longrightarrow> (x # s, x # t) \\<in> greek_less r", "have \"(M + image_mset (adj_msog [x] []) (ms_of_greek s),\n      M + image_mset (adj_msog [x] []) (ms_of_greek t)) \\<in> mult (letter_less r <*lex*> greek_less r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M + image_mset (adj_msog [x] []) (ms_of_greek s),\n     M + image_mset (adj_msog [x] []) (ms_of_greek t))\n    \\<in> mult (letter_less r <*lex*> greek_less r)", "proof (rule mult_on_union, induct rule: mult_of_image_mset[OF * *])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in># ms_of_greek s; y \\<in># ms_of_greek t;\n        (xa, y) \\<in> letter_less r <*lex*> greek_less r\\<rbrakk>\n       \\<Longrightarrow> (adj_msog [x] [] xa, adj_msog [x] [] y)\n                         \\<in> letter_less r <*lex*> greek_less r\n 2. (ms_of_greek s, ms_of_greek t)\n    \\<in> mult (letter_less r <*lex*> greek_less r)", "case (1 x y)"], ["proof (state)\nthis:\n  x \\<in># ms_of_greek s\n  y \\<in># ms_of_greek t\n  (x, y) \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in># ms_of_greek s; y \\<in># ms_of_greek t;\n        (xa, y) \\<in> letter_less r <*lex*> greek_less r\\<rbrakk>\n       \\<Longrightarrow> (adj_msog [x] [] xa, adj_msog [x] [] y)\n                         \\<in> letter_less r <*lex*> greek_less r\n 2. (ms_of_greek s, ms_of_greek t)\n    \\<in> mult (letter_less r <*lex*> greek_less r)", "thus ?case"], ["proof (prove)\nusing this:\n  x \\<in># ms_of_greek s\n  y \\<in># ms_of_greek t\n  (x, y) \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. (adj_msog [x] [] x, adj_msog [x] [] y)\n    \\<in> letter_less r <*lex*> greek_less r", "unfolding adj_msog_def"], ["proof (prove)\nusing this:\n  x \\<in># ms_of_greek s\n  y \\<in># ms_of_greek t\n  (x, y) \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. (case x of\n     (y, ys) \\<Rightarrow>\n       (y, case fst y of Acute \\<Rightarrow> ys @ []\n           | Grave \\<Rightarrow> [x] @ ys | Macron \\<Rightarrow> ys),\n     case y of\n     (y, ys) \\<Rightarrow>\n       (y, case fst y of Acute \\<Rightarrow> ys @ []\n           | Grave \\<Rightarrow> [x] @ ys | Macron \\<Rightarrow> ys))\n    \\<in> letter_less r <*lex*> greek_less r", "by (auto intro: less(1) split: prod.splits accent.splits dest!: ms_of_greek_shorter)"], ["proof (state)\nthis:\n  (adj_msog [x] [] x, adj_msog [x] [] y)\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. (ms_of_greek s, ms_of_greek t)\n    \\<in> mult (letter_less r <*lex*> greek_less r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (ms_of_greek s, ms_of_greek t)\n    \\<in> mult (letter_less r <*lex*> greek_less r)", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. (ms_of_greek s, ms_of_greek t)\n    \\<in> mult (letter_less r <*lex*> greek_less r)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ms_of_greek s, ms_of_greek t)\n    \\<in> mult (letter_less r <*lex*> greek_less r)", "using less(2)"], ["proof (prove)\nusing this:\n  (s, t) \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. (ms_of_greek s, ms_of_greek t)\n    \\<in> mult (letter_less r <*lex*> greek_less r)", "by (subst(asm) greek_less_unfold) simp"], ["proof (state)\nthis:\n  (ms_of_greek s, ms_of_greek t)\n  \\<in> mult (letter_less r <*lex*> greek_less r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (M + image_mset (adj_msog [x] []) (ms_of_greek s),\n   M + image_mset (adj_msog [x] []) (ms_of_greek t))\n  \\<in> mult (letter_less r <*lex*> greek_less r)\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<And>sa ta.\n                   \\<lbrakk>length sa + length ta < length s + length t;\n                    (sa, ta) \\<in> greek_less r\\<rbrakk>\n                   \\<Longrightarrow> (x # sa, x # ta) \\<in> greek_less r;\n        (s, t) \\<in> greek_less r\\<rbrakk>\n       \\<Longrightarrow> (x # s, x # t) \\<in> greek_less r", "}"], ["proof (state)\nthis:\n  (?M2 + image_mset (adj_msog [x] []) (ms_of_greek s),\n   ?M2 + image_mset (adj_msog [x] []) (ms_of_greek t))\n  \\<in> mult (letter_less r <*lex*> greek_less r)\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<And>sa ta.\n                   \\<lbrakk>length sa + length ta < length s + length t;\n                    (sa, ta) \\<in> greek_less r\\<rbrakk>\n                   \\<Longrightarrow> (x # sa, x # ta) \\<in> greek_less r;\n        (s, t) \\<in> greek_less r\\<rbrakk>\n       \\<Longrightarrow> (x # s, x # t) \\<in> greek_less r", "moreover"], ["proof (state)\nthis:\n  (?M2 + image_mset (adj_msog [x] []) (ms_of_greek s),\n   ?M2 + image_mset (adj_msog [x] []) (ms_of_greek t))\n  \\<in> mult (letter_less r <*lex*> greek_less r)\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<And>sa ta.\n                   \\<lbrakk>length sa + length ta < length s + length t;\n                    (sa, ta) \\<in> greek_less r\\<rbrakk>\n                   \\<Longrightarrow> (x # sa, x # ta) \\<in> greek_less r;\n        (s, t) \\<in> greek_less r\\<rbrakk>\n       \\<Longrightarrow> (x # s, x # t) \\<in> greek_less r", "{"], ["proof (state)\nthis:\n  (?M2 + image_mset (adj_msog [x] []) (ms_of_greek s),\n   ?M2 + image_mset (adj_msog [x] []) (ms_of_greek t))\n  \\<in> mult (letter_less r <*lex*> greek_less r)\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<And>sa ta.\n                   \\<lbrakk>length sa + length ta < length s + length t;\n                    (sa, ta) \\<in> greek_less r\\<rbrakk>\n                   \\<Longrightarrow> (x # sa, x # ta) \\<in> greek_less r;\n        (s, t) \\<in> greek_less r\\<rbrakk>\n       \\<Longrightarrow> (x # s, x # t) \\<in> greek_less r", "fix N"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<And>sa ta.\n                   \\<lbrakk>length sa + length ta < length s + length t;\n                    (sa, ta) \\<in> greek_less r\\<rbrakk>\n                   \\<Longrightarrow> (x # sa, x # ta) \\<in> greek_less r;\n        (s, t) \\<in> greek_less r\\<rbrakk>\n       \\<Longrightarrow> (x # s, x # t) \\<in> greek_less r", "have \"({# adj_msog [] s (x,[]) #} + N,{# adj_msog [] t (x,[]) #} + N) \\<in>\n      (mult (letter_less r <*lex*> greek_less r))\\<^sup>=\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({#adj_msog [] s (x, [])#} + N, {#adj_msog [] t (x, [])#} + N)\n    \\<in> (mult (letter_less r <*lex*> greek_less r))\\<^sup>=", "by (auto simp: adj_msog_def less split: accent.splits)"], ["proof (state)\nthis:\n  ({#adj_msog [] s (x, [])#} + N, {#adj_msog [] t (x, [])#} + N)\n  \\<in> (mult (letter_less r <*lex*> greek_less r))\\<^sup>=\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<And>sa ta.\n                   \\<lbrakk>length sa + length ta < length s + length t;\n                    (sa, ta) \\<in> greek_less r\\<rbrakk>\n                   \\<Longrightarrow> (x # sa, x # ta) \\<in> greek_less r;\n        (s, t) \\<in> greek_less r\\<rbrakk>\n       \\<Longrightarrow> (x # s, x # t) \\<in> greek_less r", "}"], ["proof (state)\nthis:\n  ({#adj_msog [] s (x, [])#} + ?N2, {#adj_msog [] t (x, [])#} + ?N2)\n  \\<in> (mult (letter_less r <*lex*> greek_less r))\\<^sup>=\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<And>sa ta.\n                   \\<lbrakk>length sa + length ta < length s + length t;\n                    (sa, ta) \\<in> greek_less r\\<rbrakk>\n                   \\<Longrightarrow> (x # sa, x # ta) \\<in> greek_less r;\n        (s, t) \\<in> greek_less r\\<rbrakk>\n       \\<Longrightarrow> (x # s, x # t) \\<in> greek_less r", "ultimately"], ["proof (chain)\npicking this:\n  (?M2 + image_mset (adj_msog [x] []) (ms_of_greek s),\n   ?M2 + image_mset (adj_msog [x] []) (ms_of_greek t))\n  \\<in> mult (letter_less r <*lex*> greek_less r)\n  ({#adj_msog [] s (x, [])#} + ?N2, {#adj_msog [] t (x, [])#} + ?N2)\n  \\<in> (mult (letter_less r <*lex*> greek_less r))\\<^sup>=", "show ?case"], ["proof (prove)\nusing this:\n  (?M2 + image_mset (adj_msog [x] []) (ms_of_greek s),\n   ?M2 + image_mset (adj_msog [x] []) (ms_of_greek t))\n  \\<in> mult (letter_less r <*lex*> greek_less r)\n  ({#adj_msog [] s (x, [])#} + ?N2, {#adj_msog [] t (x, [])#} + ?N2)\n  \\<in> (mult (letter_less r <*lex*> greek_less r))\\<^sup>=\n\ngoal (1 subgoal):\n 1. (x # s, x # t) \\<in> greek_less r", "using transD[OF trans_mult]"], ["proof (prove)\nusing this:\n  (?M2 + image_mset (adj_msog [x] []) (ms_of_greek s),\n   ?M2 + image_mset (adj_msog [x] []) (ms_of_greek t))\n  \\<in> mult (letter_less r <*lex*> greek_less r)\n  ({#adj_msog [] s (x, [])#} + ?N2, {#adj_msog [] t (x, [])#} + ?N2)\n  \\<in> (mult (letter_less r <*lex*> greek_less r))\\<^sup>=\n  \\<lbrakk>(?x, ?y) \\<in> mult ?R1; (?y, ?z) \\<in> mult ?R1\\<rbrakk>\n  \\<Longrightarrow> (?x, ?z) \\<in> mult ?R1\n\ngoal (1 subgoal):\n 1. (x # s, x # t) \\<in> greek_less r", "by (subst greek_less_unfold) (fastforce simp: ms_of_greek_cons)"], ["proof (state)\nthis:\n  (x # s, x # t) \\<in> greek_less r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma greek_less_app_mono2:\n  assumes \"trans r\" and \"(s, t) \\<in> greek_less r\"\n  shows \"(p @ s, p @ t) \\<in> greek_less r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p @ s, p @ t) \\<in> greek_less r", "using assms"], ["proof (prove)\nusing this:\n  trans r\n  (s, t) \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. (p @ s, p @ t) \\<in> greek_less r", "by (induct p) (auto simp add: greek_less_cons_mono)"], ["", "lemma greek_less_app_mono1:\n  assumes \"trans r\" and \"(s, t) \\<in> greek_less r\"\n  shows \"(s @ p, t @ p) \\<in> greek_less r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s @ p, t @ p) \\<in> greek_less r", "using inv_greek_mono[of r \"inv_greek p @ inv_greek s\" \"inv_greek p @ inv_greek t\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>trans r;\n   (inv_greek p @ inv_greek s, inv_greek p @ inv_greek t)\n   \\<in> greek_less r\\<rbrakk>\n  \\<Longrightarrow> (inv_greek (inv_greek p @ inv_greek s),\n                     inv_greek (inv_greek p @ inv_greek t))\n                    \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. (s @ p, t @ p) \\<in> greek_less r", "by (simp add: assms inv_greek_append inv_greek_mono greek_less_app_mono2)"], ["", "subsection \\<open>Well-founded-ness of @{term \"greek_less r\"}\\<close>"], ["", "lemma greek_embed:\n  assumes \"trans r\"\n  shows \"list_emb (\\<lambda>a b. (a, b): reflcl (letter_less r)) a b \\<Longrightarrow> (a, b) \\<in> reflcl (greek_less r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less r)\\<^sup>=) a\n     b \\<Longrightarrow>\n    (a, b) \\<in> (greek_less r)\\<^sup>=", "proof (induct rule: list_emb.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys. ([], ys) \\<in> (greek_less r)\\<^sup>=\n 2. \\<And>xs ys y.\n       \\<lbrakk>list_emb\n                 (\\<lambda>a b. (a, b) \\<in> (letter_less r)\\<^sup>=) xs ys;\n        (xs, ys) \\<in> (greek_less r)\\<^sup>=\\<rbrakk>\n       \\<Longrightarrow> (xs, y # ys) \\<in> (greek_less r)\\<^sup>=\n 3. \\<And>x y xs ys.\n       \\<lbrakk>(x, y) \\<in> (letter_less r)\\<^sup>=;\n        list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less r)\\<^sup>=) xs ys;\n        (xs, ys) \\<in> (greek_less r)\\<^sup>=\\<rbrakk>\n       \\<Longrightarrow> (x # xs, y # ys) \\<in> (greek_less r)\\<^sup>=", "case (list_emb_Cons a b y)"], ["proof (state)\nthis:\n  list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less r)\\<^sup>=) a b\n  (a, b) \\<in> (greek_less r)\\<^sup>=\n\ngoal (3 subgoals):\n 1. \\<And>ys. ([], ys) \\<in> (greek_less r)\\<^sup>=\n 2. \\<And>xs ys y.\n       \\<lbrakk>list_emb\n                 (\\<lambda>a b. (a, b) \\<in> (letter_less r)\\<^sup>=) xs ys;\n        (xs, ys) \\<in> (greek_less r)\\<^sup>=\\<rbrakk>\n       \\<Longrightarrow> (xs, y # ys) \\<in> (greek_less r)\\<^sup>=\n 3. \\<And>x y xs ys.\n       \\<lbrakk>(x, y) \\<in> (letter_less r)\\<^sup>=;\n        list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less r)\\<^sup>=) xs ys;\n        (xs, ys) \\<in> (greek_less r)\\<^sup>=\\<rbrakk>\n       \\<Longrightarrow> (x # xs, y # ys) \\<in> (greek_less r)\\<^sup>=", "thus ?case"], ["proof (prove)\nusing this:\n  list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less r)\\<^sup>=) a b\n  (a, b) \\<in> (greek_less r)\\<^sup>=\n\ngoal (1 subgoal):\n 1. (a, y # b) \\<in> (greek_less r)\\<^sup>=", "using trans_greek_less[unfolded trans_def] \\<open>trans r\\<close>\n    greek_less_app_mono1[of r \"[]\" \"[y]\" a] greek_less_app_mono2[of r a b \"[y]\"]"], ["proof (prove)\nusing this:\n  list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less r)\\<^sup>=) a b\n  (a, b) \\<in> (greek_less r)\\<^sup>=\n  \\<forall>x y z.\n     (x, y) \\<in> greek_less ?r \\<longrightarrow>\n     (y, z) \\<in> greek_less ?r \\<longrightarrow> (x, z) \\<in> greek_less ?r\n  trans r\n  \\<lbrakk>trans r; ([], [y]) \\<in> greek_less r\\<rbrakk>\n  \\<Longrightarrow> ([] @ a, [y] @ a) \\<in> greek_less r\n  \\<lbrakk>trans r; (a, b) \\<in> greek_less r\\<rbrakk>\n  \\<Longrightarrow> ([y] @ a, [y] @ b) \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. (a, y # b) \\<in> (greek_less r)\\<^sup>=", "by auto"], ["proof (state)\nthis:\n  (a, y # b) \\<in> (greek_less r)\\<^sup>=\n\ngoal (2 subgoals):\n 1. \\<And>ys. ([], ys) \\<in> (greek_less r)\\<^sup>=\n 2. \\<And>x y xs ys.\n       \\<lbrakk>(x, y) \\<in> (letter_less r)\\<^sup>=;\n        list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less r)\\<^sup>=) xs ys;\n        (xs, ys) \\<in> (greek_less r)\\<^sup>=\\<rbrakk>\n       \\<Longrightarrow> (x # xs, y # ys) \\<in> (greek_less r)\\<^sup>=", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys. ([], ys) \\<in> (greek_less r)\\<^sup>=\n 2. \\<And>x y xs ys.\n       \\<lbrakk>(x, y) \\<in> (letter_less r)\\<^sup>=;\n        list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less r)\\<^sup>=) xs ys;\n        (xs, ys) \\<in> (greek_less r)\\<^sup>=\\<rbrakk>\n       \\<Longrightarrow> (x # xs, y # ys) \\<in> (greek_less r)\\<^sup>=", "case (list_emb_Cons2 x y a b)"], ["proof (state)\nthis:\n  (x, y) \\<in> (letter_less r)\\<^sup>=\n  list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less r)\\<^sup>=) a b\n  (a, b) \\<in> (greek_less r)\\<^sup>=\n\ngoal (2 subgoals):\n 1. \\<And>ys. ([], ys) \\<in> (greek_less r)\\<^sup>=\n 2. \\<And>x y xs ys.\n       \\<lbrakk>(x, y) \\<in> (letter_less r)\\<^sup>=;\n        list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less r)\\<^sup>=) xs ys;\n        (xs, ys) \\<in> (greek_less r)\\<^sup>=\\<rbrakk>\n       \\<Longrightarrow> (x # xs, y # ys) \\<in> (greek_less r)\\<^sup>=", "thus ?case"], ["proof (prove)\nusing this:\n  (x, y) \\<in> (letter_less r)\\<^sup>=\n  list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less r)\\<^sup>=) a b\n  (a, b) \\<in> (greek_less r)\\<^sup>=\n\ngoal (1 subgoal):\n 1. (x # a, y # b) \\<in> (greek_less r)\\<^sup>=", "using trans_greek_less[unfolded trans_def] \\<open>trans r\\<close> greek_less_singleton[of x y r]\n    greek_less_app_mono1[of r \"[x]\" \"[y]\" a] greek_less_app_mono2[of r a b \"[y]\"]"], ["proof (prove)\nusing this:\n  (x, y) \\<in> (letter_less r)\\<^sup>=\n  list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less r)\\<^sup>=) a b\n  (a, b) \\<in> (greek_less r)\\<^sup>=\n  \\<forall>x y z.\n     (x, y) \\<in> greek_less ?r \\<longrightarrow>\n     (y, z) \\<in> greek_less ?r \\<longrightarrow> (x, z) \\<in> greek_less ?r\n  trans r\n  (x, y) \\<in> letter_less r \\<Longrightarrow> ([x], [y]) \\<in> greek_less r\n  \\<lbrakk>trans r; ([x], [y]) \\<in> greek_less r\\<rbrakk>\n  \\<Longrightarrow> ([x] @ a, [y] @ a) \\<in> greek_less r\n  \\<lbrakk>trans r; (a, b) \\<in> greek_less r\\<rbrakk>\n  \\<Longrightarrow> ([y] @ a, [y] @ b) \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. (x # a, y # b) \\<in> (greek_less r)\\<^sup>=", "by auto"], ["proof (state)\nthis:\n  (x # a, y # b) \\<in> (greek_less r)\\<^sup>=\n\ngoal (1 subgoal):\n 1. \\<And>ys. ([], ys) \\<in> (greek_less r)\\<^sup>=", "qed simp"], ["", "lemma wqo_letter_less:\n  assumes t: \"trans r\" and w: \"wqo_on (\\<lambda>a b. (a, b) \\<in> r\\<^sup>=) UNIV\"\n  shows \"wqo_on (\\<lambda>a b. (a, b) \\<in> (letter_less r)\\<^sup>=) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wqo_on (\\<lambda>a b. (a, b) \\<in> (letter_less r)\\<^sup>=) UNIV", "proof (rule wqo_on_hom[of _ id _ \"prod_le (=) (\\<lambda>a b. (a, b) \\<in> r\\<^sup>=)\", unfolded image_id id_apply])"], ["proof (state)\ngoal (3 subgoals):\n 1. transp_on (\\<lambda>a b. (a, b) \\<in> (letter_less r)\\<^sup>=) UNIV\n 2. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          prod_le (=) (\\<lambda>a b. (a, b) \\<in> r\\<^sup>=) x\n           y \\<longrightarrow>\n          (x, y) \\<in> (letter_less r)\\<^sup>=\n 3. wqo_on (prod_le (=) (\\<lambda>a b. (a, b) \\<in> r\\<^sup>=)) UNIV", "show \"wqo_on (prod_le ((=) :: accent \\<Rightarrow> accent \\<Rightarrow> bool) (\\<lambda>a b. (a, b) \\<in> r\\<^sup>=)) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wqo_on (prod_le (=) (\\<lambda>a b. (a, b) \\<in> r\\<^sup>=)) UNIV", "by (rule dickson[OF finite_eq_wqo_on[OF finite_accent] w, unfolded UNIV_Times_UNIV])"], ["proof (state)\nthis:\n  wqo_on (prod_le (=) (\\<lambda>a b. (a, b) \\<in> r\\<^sup>=)) UNIV\n\ngoal (2 subgoals):\n 1. transp_on (\\<lambda>a b. (a, b) \\<in> (letter_less r)\\<^sup>=) UNIV\n 2. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          prod_le (=) (\\<lambda>a b. (a, b) \\<in> r\\<^sup>=) x\n           y \\<longrightarrow>\n          (x, y) \\<in> (letter_less r)\\<^sup>=", "qed (insert t, auto simp: transp_on_def trans_def prod_le_def)"], ["", "lemma wf_greek_less:\n  assumes \"wf r\" and \"trans r\"\n  shows \"wf (greek_less r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (greek_less r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf (greek_less r)", "obtain q where \"r \\<subseteq> q\" and \"well_order q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>r \\<subseteq> q; well_order q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis total_well_order_extension \\<open>wf r\\<close>)"], ["proof (state)\nthis:\n  r \\<subseteq> q\n  well_order q\n\ngoal (1 subgoal):\n 1. wf (greek_less r)", "define q' where \"q' = q - Id\""], ["proof (state)\nthis:\n  q' = q - Id\n\ngoal (1 subgoal):\n 1. wf (greek_less r)", "from \\<open>well_order q\\<close>"], ["proof (chain)\npicking this:\n  well_order q", "have \"reflcl q' = q\""], ["proof (prove)\nusing this:\n  well_order q\n\ngoal (1 subgoal):\n 1. q'\\<^sup>= = q", "by (auto simp add: well_order_on_def linear_order_on_def partial_order_on_def preorder_on_def\n      refl_on_def q'_def)"], ["proof (state)\nthis:\n  q'\\<^sup>= = q\n\ngoal (1 subgoal):\n 1. wf (greek_less r)", "from \\<open>well_order q\\<close>"], ["proof (chain)\npicking this:\n  well_order q", "have \"trans q'\" and \"irrefl q'\""], ["proof (prove)\nusing this:\n  well_order q\n\ngoal (1 subgoal):\n 1. trans q' &&& irrefl q'", "unfolding well_order_on_def linear_order_on_def partial_order_on_def preorder_on_def antisym_def\n    trans_def irrefl_def q'_def"], ["proof (prove)\nusing this:\n  (((refl q \\<and>\n     (\\<forall>x y z.\n         (x, y) \\<in> q \\<longrightarrow>\n         (y, z) \\<in> q \\<longrightarrow> (x, z) \\<in> q)) \\<and>\n    (\\<forall>x y.\n        (x, y) \\<in> q \\<longrightarrow>\n        (y, x) \\<in> q \\<longrightarrow> x = y)) \\<and>\n   total q) \\<and>\n  wf (q - Id)\n\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       (x, y) \\<in> q - Id \\<longrightarrow>\n       (y, z) \\<in> q - Id \\<longrightarrow> (x, z) \\<in> q - Id &&&\n    \\<forall>a. (a, a) \\<notin> q - Id", "by blast+"], ["proof (state)\nthis:\n  trans q'\n  irrefl q'\n\ngoal (1 subgoal):\n 1. wf (greek_less r)", "from \\<open>r \\<subseteq> q\\<close> \\<open>wf r\\<close>"], ["proof (chain)\npicking this:\n  r \\<subseteq> q\n  wf r", "have \"r \\<subseteq> q'\""], ["proof (prove)\nusing this:\n  r \\<subseteq> q\n  wf r\n\ngoal (1 subgoal):\n 1. r \\<subseteq> q'", "by (auto simp add: q'_def)"], ["proof (state)\nthis:\n  r \\<subseteq> q'\n\ngoal (1 subgoal):\n 1. wf (greek_less r)", "have \"wqo_on (\\<lambda>a b. (a,b) \\<in> (greek_less q')\\<^sup>=) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wqo_on (\\<lambda>a b. (a, b) \\<in> (greek_less q')\\<^sup>=) UNIV", "proof (intro wqo_on_hom[of \"(\\<lambda>a b. (a, b) \\<in> (greek_less q')\\<^sup>=)\" \"id\" UNIV\n         \"list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less q')\\<^sup>=)\", unfolded surj_id])"], ["proof (state)\ngoal (3 subgoals):\n 1. transp_on (\\<lambda>a b. (a, b) \\<in> (greek_less q')\\<^sup>=) UNIV\n 2. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less q')\\<^sup>=) x\n           y \\<longrightarrow>\n          (id x, id y) \\<in> (greek_less q')\\<^sup>=\n 3. wqo_on (list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less q')\\<^sup>=))\n     UNIV", "show \"transp_on (\\<lambda>a b. (a, b) \\<in> (greek_less q')\\<^sup>=) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transp_on (\\<lambda>a b. (a, b) \\<in> (greek_less q')\\<^sup>=) UNIV", "using trans_greek_less[of q']"], ["proof (prove)\nusing this:\n  trans (greek_less q')\n\ngoal (1 subgoal):\n 1. transp_on (\\<lambda>a b. (a, b) \\<in> (greek_less q')\\<^sup>=) UNIV", "unfolding trans_def transp_on_def"], ["proof (prove)\nusing this:\n  \\<forall>x y z.\n     (x, y) \\<in> greek_less q' \\<longrightarrow>\n     (y, z) \\<in> greek_less q' \\<longrightarrow> (x, z) \\<in> greek_less q'\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          \\<forall>z\\<in>UNIV.\n             (x, y) \\<in> (greek_less q')\\<^sup>= \\<and>\n             (y, z) \\<in> (greek_less q')\\<^sup>= \\<longrightarrow>\n             (x, z) \\<in> (greek_less q')\\<^sup>=", "by blast"], ["proof (state)\nthis:\n  transp_on (\\<lambda>a b. (a, b) \\<in> (greek_less q')\\<^sup>=) UNIV\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less q')\\<^sup>=) x\n           y \\<longrightarrow>\n          (id x, id y) \\<in> (greek_less q')\\<^sup>=\n 2. wqo_on (list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less q')\\<^sup>=))\n     UNIV", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less q')\\<^sup>=) x\n           y \\<longrightarrow>\n          (id x, id y) \\<in> (greek_less q')\\<^sup>=\n 2. wqo_on (list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less q')\\<^sup>=))\n     UNIV", "show \"\\<forall>x\\<in>UNIV. \\<forall>y\\<in>UNIV. list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less q')\\<^sup>=) x y \\<longrightarrow>\n          (id x, id y) \\<in> (greek_less q')\\<^sup>=\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less q')\\<^sup>=) x\n           y \\<longrightarrow>\n          (id x, id y) \\<in> (greek_less q')\\<^sup>=", "using greek_embed[OF \\<open>trans q'\\<close>]"], ["proof (prove)\nusing this:\n  list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less q')\\<^sup>=) ?a\n   ?b \\<Longrightarrow>\n  (?a, ?b) \\<in> (greek_less q')\\<^sup>=\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less q')\\<^sup>=) x\n           y \\<longrightarrow>\n          (id x, id y) \\<in> (greek_less q')\\<^sup>=", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>UNIV.\n     \\<forall>y\\<in>UNIV.\n        list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less q')\\<^sup>=) x\n         y \\<longrightarrow>\n        (id x, id y) \\<in> (greek_less q')\\<^sup>=\n\ngoal (1 subgoal):\n 1. wqo_on (list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less q')\\<^sup>=))\n     UNIV", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. wqo_on (list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less q')\\<^sup>=))\n     UNIV", "show \"wqo_on (list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less q')\\<^sup>=)) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wqo_on (list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less q')\\<^sup>=))\n     UNIV", "using higman[OF wqo_letter_less[OF \\<open>trans q'\\<close>]] \\<open>well_order q\\<close> \\<open>reflcl q' = q\\<close>"], ["proof (prove)\nusing this:\n  wqo_on (\\<lambda>a b. (a, b) \\<in> q'\\<^sup>=) UNIV \\<Longrightarrow>\n  wqo_on (list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less q')\\<^sup>=))\n   (lists UNIV)\n  well_order q\n  q'\\<^sup>= = q\n\ngoal (1 subgoal):\n 1. wqo_on (list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less q')\\<^sup>=))\n     UNIV", "by (auto simp: well_order_implies_wqo)"], ["proof (state)\nthis:\n  wqo_on (list_emb (\\<lambda>a b. (a, b) \\<in> (letter_less q')\\<^sup>=))\n   UNIV\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wqo_on (\\<lambda>a b. (a, b) \\<in> (greek_less q')\\<^sup>=) UNIV\n\ngoal (1 subgoal):\n 1. wf (greek_less r)", "with wqo_on_imp_wfp_on[OF this] strict_order_strict[OF strict_order_greek_less]\n    \\<open>irrefl q'\\<close> \\<open>trans q'\\<close>"], ["proof (chain)\npicking this:\n  wfp_on\n   (\\<lambda>x y.\n       (x, y) \\<in> (greek_less q')\\<^sup>= \\<and>\n       (y, x) \\<notin> (greek_less q')\\<^sup>=)\n   UNIV\n  strict_order ?r1 \\<Longrightarrow>\n  (\\<lambda>x y.\n      (x, y) \\<in> (greek_less ?r1)\\<^sup>= \\<and>\n      (y, x) \\<notin> (greek_less ?r1)\\<^sup>=) =\n  (\\<lambda>a b. (a, b) \\<in> greek_less ?r1)\n  irrefl q'\n  trans q'\n  wqo_on (\\<lambda>a b. (a, b) \\<in> (greek_less q')\\<^sup>=) UNIV", "have \"wfp_on (\\<lambda>a b. (a, b) \\<in> greek_less q') UNIV\""], ["proof (prove)\nusing this:\n  wfp_on\n   (\\<lambda>x y.\n       (x, y) \\<in> (greek_less q')\\<^sup>= \\<and>\n       (y, x) \\<notin> (greek_less q')\\<^sup>=)\n   UNIV\n  strict_order ?r1 \\<Longrightarrow>\n  (\\<lambda>x y.\n      (x, y) \\<in> (greek_less ?r1)\\<^sup>= \\<and>\n      (y, x) \\<notin> (greek_less ?r1)\\<^sup>=) =\n  (\\<lambda>a b. (a, b) \\<in> greek_less ?r1)\n  irrefl q'\n  trans q'\n  wqo_on (\\<lambda>a b. (a, b) \\<in> (greek_less q')\\<^sup>=) UNIV\n\ngoal (1 subgoal):\n 1. wfp_on (\\<lambda>a b. (a, b) \\<in> greek_less q') UNIV", "by force"], ["proof (state)\nthis:\n  wfp_on (\\<lambda>a b. (a, b) \\<in> greek_less q') UNIV\n\ngoal (1 subgoal):\n 1. wf (greek_less r)", "then"], ["proof (chain)\npicking this:\n  wfp_on (\\<lambda>a b. (a, b) \\<in> greek_less q') UNIV", "show ?thesis"], ["proof (prove)\nusing this:\n  wfp_on (\\<lambda>a b. (a, b) \\<in> greek_less q') UNIV\n\ngoal (1 subgoal):\n 1. wf (greek_less r)", "using mono_greek_less \\<open>r \\<subseteq> q'\\<close> wf_subset"], ["proof (prove)\nusing this:\n  wfp_on (\\<lambda>a b. (a, b) \\<in> greek_less q') UNIV\n  mono greek_less\n  r \\<subseteq> q'\n  \\<lbrakk>wf ?r; ?p \\<subseteq> ?r\\<rbrakk> \\<Longrightarrow> wf ?p\n\ngoal (1 subgoal):\n 1. wf (greek_less r)", "unfolding wf_iff_wfp_on[symmetric] mono_def"], ["proof (prove)\nusing this:\n  wf (greek_less q')\n  \\<forall>x y.\n     x \\<subseteq> y \\<longrightarrow> greek_less x \\<subseteq> greek_less y\n  r \\<subseteq> q'\n  \\<lbrakk>wf ?r; ?p \\<subseteq> ?r\\<rbrakk> \\<Longrightarrow> wf ?p\n\ngoal (1 subgoal):\n 1. wf (greek_less r)", "by metis"], ["proof (state)\nthis:\n  wf (greek_less r)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Basic Comparisons\\<close>"], ["", "lemma pairwise_imp_mult:\n  assumes \"N \\<noteq> {#}\" and \"\\<forall>x \\<in> set_mset M. \\<exists>y \\<in> set_mset N. (x, y) \\<in> r\"\n  shows \"(M, N) \\<in> mult r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M, N) \\<in> mult r", "using assms one_step_implies_mult[of _ _ _ \"{#}\"]"], ["proof (prove)\nusing this:\n  N \\<noteq> {#}\n  \\<forall>x\\<in>#M. \\<exists>y\\<in>#N. (x, y) \\<in> r\n  \\<lbrakk>?J \\<noteq> {#};\n   \\<forall>k\\<in>#?K. \\<exists>j\\<in>#?J. (k, j) \\<in> ?r\\<rbrakk>\n  \\<Longrightarrow> ({#} + ?K, {#} + ?J) \\<in> mult ?r\n\ngoal (1 subgoal):\n 1. (M, N) \\<in> mult r", "by auto"], ["", "lemma singleton_greek_less:\n  assumes as: \"snd ` set as \\<subseteq> under r b\"\n  shows \"(as, [(a,b)]) \\<in> greek_less r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (as, [(a, b)]) \\<in> greek_less r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (as, [(a, b)]) \\<in> greek_less r", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (as, [(a, b)]) \\<in> greek_less r", "fix e"], ["proof (state)\ngoal (1 subgoal):\n 1. (as, [(a, b)]) \\<in> greek_less r", "assume \"e \\<in> set_mset (ms_of_greek as)\""], ["proof (state)\nthis:\n  e \\<in># ms_of_greek as\n\ngoal (1 subgoal):\n 1. (as, [(a, b)]) \\<in> greek_less r", "with as ms_of_greek_elem[of _ _ as]"], ["proof (chain)\npicking this:\n  snd ` set as \\<subseteq> under r b\n  (?x, ?xs) \\<in># ms_of_greek as \\<Longrightarrow> ?x \\<in> set as\n  e \\<in># ms_of_greek as", "have \"(e, ((a,b),[])) \\<in> letter_less r <*lex*> greek_less r\""], ["proof (prove)\nusing this:\n  snd ` set as \\<subseteq> under r b\n  (?x, ?xs) \\<in># ms_of_greek as \\<Longrightarrow> ?x \\<in> set as\n  e \\<in># ms_of_greek as\n\ngoal (1 subgoal):\n 1. (e, (a, b), []) \\<in> letter_less r <*lex*> greek_less r", "by (cases e) (fastforce simp: adj_msog_def under_def)"], ["proof (state)\nthis:\n  (e, (a, b), []) \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. (as, [(a, b)]) \\<in> greek_less r", "}"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek as \\<Longrightarrow>\n  (?e2, (a, b), []) \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. (as, [(a, b)]) \\<in> greek_less r", "moreover"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek as \\<Longrightarrow>\n  (?e2, (a, b), []) \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. (as, [(a, b)]) \\<in> greek_less r", "have \"ms_of_greek [(a,b)] = {# ((a,b),[]) #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ms_of_greek [(a, b)] = {#((a, b), [])#}", "by (auto simp: ms_of_greek_def adj_msog_def split: accent.splits)"], ["proof (state)\nthis:\n  ms_of_greek [(a, b)] = {#((a, b), [])#}\n\ngoal (1 subgoal):\n 1. (as, [(a, b)]) \\<in> greek_less r", "ultimately"], ["proof (chain)\npicking this:\n  ?e2 \\<in># ms_of_greek as \\<Longrightarrow>\n  (?e2, (a, b), []) \\<in> letter_less r <*lex*> greek_less r\n  ms_of_greek [(a, b)] = {#((a, b), [])#}", "show ?thesis"], ["proof (prove)\nusing this:\n  ?e2 \\<in># ms_of_greek as \\<Longrightarrow>\n  (?e2, (a, b), []) \\<in> letter_less r <*lex*> greek_less r\n  ms_of_greek [(a, b)] = {#((a, b), [])#}\n\ngoal (1 subgoal):\n 1. (as, [(a, b)]) \\<in> greek_less r", "by (subst greek_less_unfold) (auto intro!: pairwise_imp_mult)"], ["proof (state)\nthis:\n  (as, [(a, b)]) \\<in> greek_less r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma peak_greek_less:\n  assumes as: \"snd ` set as \\<subseteq> under r a\" and b': \"b' \\<in> {[(Grave,b)],[]}\"\n  and cs: \"snd ` set cs \\<subseteq> under r a \\<union> under r b\" and a': \"a' \\<in> {[(Acute,a)],[]}\"\n  and bs: \"snd ` set bs \\<subseteq> under r b\"\n  shows \"(as @ b' @ cs @ a' @ bs, [(Acute,a),(Grave,b)]) \\<in> greek_less r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Acute, a), (Grave, b)]) \\<in> greek_less r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Acute, a), (Grave, b)]) \\<in> greek_less r", "let ?A = \"(Acute,a)\" and ?B = \"(Grave,b)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Acute, a), (Grave, b)]) \\<in> greek_less r", "have \"(ms_of_greek (as @ b' @ cs @ a' @ bs), ms_of_greek [?A,?B]) \\<in> mult (letter_less r <*lex*> greek_less r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ms_of_greek (as @ b' @ cs @ a' @ bs),\n     ms_of_greek [(Acute, a), (Grave, b)])\n    \\<in> mult (letter_less r <*lex*> greek_less r)", "proof (intro pairwise_imp_mult)"], ["proof (state)\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "(* we distinguish 5 cases depending on where in xs an element e originates *)"], ["proof (state)\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "fix e"], ["proof (state)\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "assume \"e \\<in> set_mset (ms_of_greek as)\""], ["proof (state)\nthis:\n  e \\<in># ms_of_greek as\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "with as ms_of_greek_elem[of _ _ as]"], ["proof (chain)\npicking this:\n  snd ` set as \\<subseteq> under r a\n  (?x, ?xs) \\<in># ms_of_greek as \\<Longrightarrow> ?x \\<in> set as\n  e \\<in># ms_of_greek as", "have \"(adj_msog [] (b' @ cs @ a' @ bs) e, (?A,[?B])) \\<in> letter_less r <*lex*> greek_less r\""], ["proof (prove)\nusing this:\n  snd ` set as \\<subseteq> under r a\n  (?x, ?xs) \\<in># ms_of_greek as \\<Longrightarrow> ?x \\<in> set as\n  e \\<in># ms_of_greek as\n\ngoal (1 subgoal):\n 1. (adj_msog [] (b' @ cs @ a' @ bs) e, (Acute, a), [(Grave, b)])\n    \\<in> letter_less r <*lex*> greek_less r", "by (cases e) (fastforce simp: adj_msog_def under_def)"], ["proof (state)\nthis:\n  (adj_msog [] (b' @ cs @ a' @ bs) e, (Acute, a), [(Grave, b)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "}"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek as \\<Longrightarrow>\n  (adj_msog [] (b' @ cs @ a' @ bs) ?e2, (Acute, a), [(Grave, b)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "moreover"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek as \\<Longrightarrow>\n  (adj_msog [] (b' @ cs @ a' @ bs) ?e2, (Acute, a), [(Grave, b)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "{"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek as \\<Longrightarrow>\n  (adj_msog [] (b' @ cs @ a' @ bs) ?e2, (Acute, a), [(Grave, b)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "fix e"], ["proof (state)\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "assume \"e \\<in> set_mset (ms_of_greek b')\""], ["proof (state)\nthis:\n  e \\<in># ms_of_greek b'\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "with b' singleton_greek_less[OF as] ms_of_greek_elem[of _ _ b']"], ["proof (chain)\npicking this:\n  b' \\<in> {[(Grave, b)], []}\n  (as, [(?a, a)]) \\<in> greek_less r\n  (?x, ?xs) \\<in># ms_of_greek b' \\<Longrightarrow> ?x \\<in> set b'\n  e \\<in># ms_of_greek b'", "have \"(adj_msog as (cs @ a' @ bs) e, (?B,[?A])) \\<in> letter_less r <*lex*> greek_less r\""], ["proof (prove)\nusing this:\n  b' \\<in> {[(Grave, b)], []}\n  (as, [(?a, a)]) \\<in> greek_less r\n  (?x, ?xs) \\<in># ms_of_greek b' \\<Longrightarrow> ?x \\<in> set b'\n  e \\<in># ms_of_greek b'\n\ngoal (1 subgoal):\n 1. (adj_msog as (cs @ a' @ bs) e, (Grave, b), [(Acute, a)])\n    \\<in> letter_less r <*lex*> greek_less r", "by (cases e) (fastforce simp: adj_msog_def ms_of_greek_def)"], ["proof (state)\nthis:\n  (adj_msog as (cs @ a' @ bs) e, (Grave, b), [(Acute, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "}"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek b' \\<Longrightarrow>\n  (adj_msog as (cs @ a' @ bs) ?e2, (Grave, b), [(Acute, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "moreover"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek b' \\<Longrightarrow>\n  (adj_msog as (cs @ a' @ bs) ?e2, (Grave, b), [(Acute, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "{"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek b' \\<Longrightarrow>\n  (adj_msog as (cs @ a' @ bs) ?e2, (Grave, b), [(Acute, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "fix e"], ["proof (state)\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "assume \"e \\<in> set_mset (ms_of_greek cs)\""], ["proof (state)\nthis:\n  e \\<in># ms_of_greek cs\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "with cs ms_of_greek_elem[of _ _ cs]"], ["proof (chain)\npicking this:\n  snd ` set cs \\<subseteq> under r a \\<union> under r b\n  (?x, ?xs) \\<in># ms_of_greek cs \\<Longrightarrow> ?x \\<in> set cs\n  e \\<in># ms_of_greek cs", "have \"(adj_msog (as @ b') (a' @ bs) e, (?A,[?B])) \\<in> letter_less r <*lex*> greek_less r \\<or>\n            (adj_msog (as @ b') (a' @ bs) e, (?B,[?A])) \\<in> letter_less r <*lex*> greek_less r\""], ["proof (prove)\nusing this:\n  snd ` set cs \\<subseteq> under r a \\<union> under r b\n  (?x, ?xs) \\<in># ms_of_greek cs \\<Longrightarrow> ?x \\<in> set cs\n  e \\<in># ms_of_greek cs\n\ngoal (1 subgoal):\n 1. (adj_msog (as @ b') (a' @ bs) e, (Acute, a), [(Grave, b)])\n    \\<in> letter_less r <*lex*> greek_less r \\<or>\n    (adj_msog (as @ b') (a' @ bs) e, (Grave, b), [(Acute, a)])\n    \\<in> letter_less r <*lex*> greek_less r", "by (cases e) (fastforce simp: adj_msog_def under_def)"], ["proof (state)\nthis:\n  (adj_msog (as @ b') (a' @ bs) e, (Acute, a), [(Grave, b)])\n  \\<in> letter_less r <*lex*> greek_less r \\<or>\n  (adj_msog (as @ b') (a' @ bs) e, (Grave, b), [(Acute, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "}"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek cs \\<Longrightarrow>\n  (adj_msog (as @ b') (a' @ bs) ?e2, (Acute, a), [(Grave, b)])\n  \\<in> letter_less r <*lex*> greek_less r \\<or>\n  (adj_msog (as @ b') (a' @ bs) ?e2, (Grave, b), [(Acute, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "moreover"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek cs \\<Longrightarrow>\n  (adj_msog (as @ b') (a' @ bs) ?e2, (Acute, a), [(Grave, b)])\n  \\<in> letter_less r <*lex*> greek_less r \\<or>\n  (adj_msog (as @ b') (a' @ bs) ?e2, (Grave, b), [(Acute, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "{"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek cs \\<Longrightarrow>\n  (adj_msog (as @ b') (a' @ bs) ?e2, (Acute, a), [(Grave, b)])\n  \\<in> letter_less r <*lex*> greek_less r \\<or>\n  (adj_msog (as @ b') (a' @ bs) ?e2, (Grave, b), [(Acute, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "fix e"], ["proof (state)\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "assume \"e \\<in> set_mset (ms_of_greek a')\""], ["proof (state)\nthis:\n  e \\<in># ms_of_greek a'\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "with a' singleton_greek_less[OF bs] ms_of_greek_elem[of _ _ a']"], ["proof (chain)\npicking this:\n  a' \\<in> {[(Acute, a)], []}\n  (bs, [(?a, b)]) \\<in> greek_less r\n  (?x, ?xs) \\<in># ms_of_greek a' \\<Longrightarrow> ?x \\<in> set a'\n  e \\<in># ms_of_greek a'", "have \"(adj_msog (as @ b' @ cs) bs e, (?A,[?B])) \\<in> letter_less r <*lex*> greek_less r\""], ["proof (prove)\nusing this:\n  a' \\<in> {[(Acute, a)], []}\n  (bs, [(?a, b)]) \\<in> greek_less r\n  (?x, ?xs) \\<in># ms_of_greek a' \\<Longrightarrow> ?x \\<in> set a'\n  e \\<in># ms_of_greek a'\n\ngoal (1 subgoal):\n 1. (adj_msog (as @ b' @ cs) bs e, (Acute, a), [(Grave, b)])\n    \\<in> letter_less r <*lex*> greek_less r", "by (cases e) (fastforce simp: adj_msog_def ms_of_greek_def)"], ["proof (state)\nthis:\n  (adj_msog (as @ b' @ cs) bs e, (Acute, a), [(Grave, b)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "}"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek a' \\<Longrightarrow>\n  (adj_msog (as @ b' @ cs) bs ?e2, (Acute, a), [(Grave, b)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "moreover"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek a' \\<Longrightarrow>\n  (adj_msog (as @ b' @ cs) bs ?e2, (Acute, a), [(Grave, b)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "{"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek a' \\<Longrightarrow>\n  (adj_msog (as @ b' @ cs) bs ?e2, (Acute, a), [(Grave, b)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "fix e"], ["proof (state)\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "assume \"e \\<in> set_mset (ms_of_greek bs)\""], ["proof (state)\nthis:\n  e \\<in># ms_of_greek bs\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "with bs ms_of_greek_elem[of _ _ bs]"], ["proof (chain)\npicking this:\n  snd ` set bs \\<subseteq> under r b\n  (?x, ?xs) \\<in># ms_of_greek bs \\<Longrightarrow> ?x \\<in> set bs\n  e \\<in># ms_of_greek bs", "have \"(adj_msog (as @ b' @ cs @ a') [] e, (?B,[?A])) \\<in> letter_less r <*lex*> greek_less r\""], ["proof (prove)\nusing this:\n  snd ` set bs \\<subseteq> under r b\n  (?x, ?xs) \\<in># ms_of_greek bs \\<Longrightarrow> ?x \\<in> set bs\n  e \\<in># ms_of_greek bs\n\ngoal (1 subgoal):\n 1. (adj_msog (as @ b' @ cs @ a') [] e, (Grave, b), [(Acute, a)])\n    \\<in> letter_less r <*lex*> greek_less r", "by (cases e) (fastforce simp: adj_msog_def under_def)"], ["proof (state)\nthis:\n  (adj_msog (as @ b' @ cs @ a') [] e, (Grave, b), [(Acute, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "}"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek bs \\<Longrightarrow>\n  (adj_msog (as @ b' @ cs @ a') [] ?e2, (Grave, b), [(Acute, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "moreover"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek bs \\<Longrightarrow>\n  (adj_msog (as @ b' @ cs @ a') [] ?e2, (Grave, b), [(Acute, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "have \"ms_of_greek [?A,?B] = {# (?B,[?A]), (?A,[?B]) #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ms_of_greek [(Acute, a), (Grave, b)] =\n    {#((Grave, b), [(Acute, a)]), ((Acute, a), [(Grave, b)])#}", "by (simp add: adj_msog_def ms_of_greek_def)"], ["proof (state)\nthis:\n  ms_of_greek [(Acute, a), (Grave, b)] =\n  {#((Grave, b), [(Acute, a)]), ((Acute, a), [(Grave, b)])#}\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "ultimately"], ["proof (chain)\npicking this:\n  ?e2 \\<in># ms_of_greek as \\<Longrightarrow>\n  (adj_msog [] (b' @ cs @ a' @ bs) ?e2, (Acute, a), [(Grave, b)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ?e2 \\<in># ms_of_greek b' \\<Longrightarrow>\n  (adj_msog as (cs @ a' @ bs) ?e2, (Grave, b), [(Acute, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ?e2 \\<in># ms_of_greek cs \\<Longrightarrow>\n  (adj_msog (as @ b') (a' @ bs) ?e2, (Acute, a), [(Grave, b)])\n  \\<in> letter_less r <*lex*> greek_less r \\<or>\n  (adj_msog (as @ b') (a' @ bs) ?e2, (Grave, b), [(Acute, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ?e2 \\<in># ms_of_greek a' \\<Longrightarrow>\n  (adj_msog (as @ b' @ cs) bs ?e2, (Acute, a), [(Grave, b)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ?e2 \\<in># ms_of_greek bs \\<Longrightarrow>\n  (adj_msog (as @ b' @ cs @ a') [] ?e2, (Grave, b), [(Acute, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ms_of_greek [(Acute, a), (Grave, b)] =\n  {#((Grave, b), [(Acute, a)]), ((Acute, a), [(Grave, b)])#}", "show \"\\<forall>x\\<in>set_mset (ms_of_greek (as @ b' @ cs @ a' @ bs)).\n      \\<exists>y\\<in>set_mset (ms_of_greek [?A,?B]). (x, y) \\<in> letter_less r <*lex*> greek_less r\""], ["proof (prove)\nusing this:\n  ?e2 \\<in># ms_of_greek as \\<Longrightarrow>\n  (adj_msog [] (b' @ cs @ a' @ bs) ?e2, (Acute, a), [(Grave, b)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ?e2 \\<in># ms_of_greek b' \\<Longrightarrow>\n  (adj_msog as (cs @ a' @ bs) ?e2, (Grave, b), [(Acute, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ?e2 \\<in># ms_of_greek cs \\<Longrightarrow>\n  (adj_msog (as @ b') (a' @ bs) ?e2, (Acute, a), [(Grave, b)])\n  \\<in> letter_less r <*lex*> greek_less r \\<or>\n  (adj_msog (as @ b') (a' @ bs) ?e2, (Grave, b), [(Acute, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ?e2 \\<in># ms_of_greek a' \\<Longrightarrow>\n  (adj_msog (as @ b' @ cs) bs ?e2, (Acute, a), [(Grave, b)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ?e2 \\<in># ms_of_greek bs \\<Longrightarrow>\n  (adj_msog (as @ b' @ cs @ a') [] ?e2, (Grave, b), [(Acute, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ms_of_greek [(Acute, a), (Grave, b)] =\n  {#((Grave, b), [(Acute, a)]), ((Acute, a), [(Grave, b)])#}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n       \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "by (auto simp: msog_append) blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs).\n     \\<exists>y\\<in>#ms_of_greek [(Acute, a), (Grave, b)].\n        (x, y) \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. ms_of_greek [(Acute, a), (Grave, b)] \\<noteq> {#}", "qed (auto simp: ms_of_greek_def)"], ["proof (state)\nthis:\n  (ms_of_greek (as @ b' @ cs @ a' @ bs),\n   ms_of_greek [(Acute, a), (Grave, b)])\n  \\<in> mult (letter_less r <*lex*> greek_less r)\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Acute, a), (Grave, b)]) \\<in> greek_less r", "then"], ["proof (chain)\npicking this:\n  (ms_of_greek (as @ b' @ cs @ a' @ bs),\n   ms_of_greek [(Acute, a), (Grave, b)])\n  \\<in> mult (letter_less r <*lex*> greek_less r)", "show ?thesis"], ["proof (prove)\nusing this:\n  (ms_of_greek (as @ b' @ cs @ a' @ bs),\n   ms_of_greek [(Acute, a), (Grave, b)])\n  \\<in> mult (letter_less r <*lex*> greek_less r)\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Acute, a), (Grave, b)]) \\<in> greek_less r", "by (subst greek_less_unfold) auto"], ["proof (state)\nthis:\n  (as @ b' @ cs @ a' @ bs, [(Acute, a), (Grave, b)]) \\<in> greek_less r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rcliff_greek_less1:\n  assumes \"trans r\" (* unused assumption kept for symmetry with lcliff_greek_less1 *)\n  and as: \"snd ` set as \\<subseteq> under r a \\<inter> under r b\" and b': \"b' \\<in> {[(Grave,b)],[]}\"\n  and cs: \"snd ` set cs \\<subseteq> under r b\" and a': \"a' = [(Macron,a)]\"\n  and bs: \"snd ` set bs \\<subseteq> under r b\"\n  shows \"(as @ b' @ cs @ a' @ bs, [(Macron,a),(Grave,b)]) \\<in> greek_less r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "let ?A = \"(Macron,a)\" and ?B = \"(Grave,b)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "have *: \"ms_of_greek [?A,?B] = {#(?B,[?A]), (?A,[])#}\" \"ms_of_greek [?A] = {#(?A,[])#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ms_of_greek [(Macron, a), (Grave, b)] =\n    {#((Grave, b), [(Macron, a)]), ((Macron, a), [])#} &&&\n    ms_of_greek [(Macron, a)] = {#((Macron, a), [])#}", "by (simp_all add: ms_of_greek_def adj_msog_def)"], ["proof (state)\nthis:\n  ms_of_greek [(Macron, a), (Grave, b)] =\n  {#((Grave, b), [(Macron, a)]), ((Macron, a), [])#}\n  ms_of_greek [(Macron, a)] = {#((Macron, a), [])#}\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "then"], ["proof (chain)\npicking this:\n  ms_of_greek [(Macron, a), (Grave, b)] =\n  {#((Grave, b), [(Macron, a)]), ((Macron, a), [])#}\n  ms_of_greek [(Macron, a)] = {#((Macron, a), [])#}", "have **: \"ms_of_greek [(Macron, a), (Grave, b)] - {#((Macron, a), [])#} \\<noteq> {#}\""], ["proof (prove)\nusing this:\n  ms_of_greek [(Macron, a), (Grave, b)] =\n  {#((Grave, b), [(Macron, a)]), ((Macron, a), [])#}\n  ms_of_greek [(Macron, a)] = {#((Macron, a), [])#}\n\ngoal (1 subgoal):\n 1. ms_of_greek [(Macron, a), (Grave, b)] - {#((Macron, a), [])#} \\<noteq>\n    {#}", "by (auto)"], ["proof (state)\nthis:\n  ms_of_greek [(Macron, a), (Grave, b)] - {#((Macron, a), [])#} \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "(* we distinguish 5 cases depending on where in xs an element e originates *)"], ["proof (state)\nthis:\n  ms_of_greek [(Macron, a), (Grave, b)] - {#((Macron, a), [])#} \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "{"], ["proof (state)\nthis:\n  ms_of_greek [(Macron, a), (Grave, b)] - {#((Macron, a), [])#} \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "fix e"], ["proof (state)\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "assume \"e \\<in> set_mset (ms_of_greek as)\""], ["proof (state)\nthis:\n  e \\<in># ms_of_greek as\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "with as ms_of_greek_elem[of _ _ as]"], ["proof (chain)\npicking this:\n  snd ` set as \\<subseteq> under r a \\<inter> under r b\n  (?x, ?xs) \\<in># ms_of_greek as \\<Longrightarrow> ?x \\<in> set as\n  e \\<in># ms_of_greek as", "have \"(adj_msog [] (b' @ cs @ a' @ bs) e, (?B,[?A])) \\<in> letter_less r <*lex*> greek_less r\""], ["proof (prove)\nusing this:\n  snd ` set as \\<subseteq> under r a \\<inter> under r b\n  (?x, ?xs) \\<in># ms_of_greek as \\<Longrightarrow> ?x \\<in> set as\n  e \\<in># ms_of_greek as\n\ngoal (1 subgoal):\n 1. (adj_msog [] (b' @ cs @ a' @ bs) e, (Grave, b), [(Macron, a)])\n    \\<in> letter_less r <*lex*> greek_less r", "by (cases e) (force simp: adj_msog_def under_def)"], ["proof (state)\nthis:\n  (adj_msog [] (b' @ cs @ a' @ bs) e, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "}"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek as \\<Longrightarrow>\n  (adj_msog [] (b' @ cs @ a' @ bs) ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "moreover"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek as \\<Longrightarrow>\n  (adj_msog [] (b' @ cs @ a' @ bs) ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "{"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek as \\<Longrightarrow>\n  (adj_msog [] (b' @ cs @ a' @ bs) ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "fix e"], ["proof (state)\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "assume \"e \\<in> set_mset (ms_of_greek b')\""], ["proof (state)\nthis:\n  e \\<in># ms_of_greek b'\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "with b' singleton_greek_less as ms_of_greek_elem[of _ _ b']"], ["proof (chain)\npicking this:\n  b' \\<in> {[(Grave, b)], []}\n  snd ` set ?as \\<subseteq> under ?r ?b \\<Longrightarrow>\n  (?as, [(?a, ?b)]) \\<in> greek_less ?r\n  snd ` set as \\<subseteq> under r a \\<inter> under r b\n  (?x, ?xs) \\<in># ms_of_greek b' \\<Longrightarrow> ?x \\<in> set b'\n  e \\<in># ms_of_greek b'", "have \"(adj_msog as (cs @ a' @ bs) e, (?B,[?A])) \\<in> letter_less r <*lex*> greek_less r\""], ["proof (prove)\nusing this:\n  b' \\<in> {[(Grave, b)], []}\n  snd ` set ?as \\<subseteq> under ?r ?b \\<Longrightarrow>\n  (?as, [(?a, ?b)]) \\<in> greek_less ?r\n  snd ` set as \\<subseteq> under r a \\<inter> under r b\n  (?x, ?xs) \\<in># ms_of_greek b' \\<Longrightarrow> ?x \\<in> set b'\n  e \\<in># ms_of_greek b'\n\ngoal (1 subgoal):\n 1. (adj_msog as (cs @ a' @ bs) e, (Grave, b), [(Macron, a)])\n    \\<in> letter_less r <*lex*> greek_less r", "by (cases e) (fastforce simp: adj_msog_def ms_of_greek_def)"], ["proof (state)\nthis:\n  (adj_msog as (cs @ a' @ bs) e, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "}"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek b' \\<Longrightarrow>\n  (adj_msog as (cs @ a' @ bs) ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "moreover"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek b' \\<Longrightarrow>\n  (adj_msog as (cs @ a' @ bs) ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "{"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek b' \\<Longrightarrow>\n  (adj_msog as (cs @ a' @ bs) ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "fix e"], ["proof (state)\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "assume \"e \\<in> set_mset (ms_of_greek cs)\""], ["proof (state)\nthis:\n  e \\<in># ms_of_greek cs\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "with cs ms_of_greek_elem[of _ _ cs]"], ["proof (chain)\npicking this:\n  snd ` set cs \\<subseteq> under r b\n  (?x, ?xs) \\<in># ms_of_greek cs \\<Longrightarrow> ?x \\<in> set cs\n  e \\<in># ms_of_greek cs", "have \"(adj_msog (as @ b') (a' @ bs) e, (?B,[?A])) \\<in> letter_less r <*lex*> greek_less r\""], ["proof (prove)\nusing this:\n  snd ` set cs \\<subseteq> under r b\n  (?x, ?xs) \\<in># ms_of_greek cs \\<Longrightarrow> ?x \\<in> set cs\n  e \\<in># ms_of_greek cs\n\ngoal (1 subgoal):\n 1. (adj_msog (as @ b') (a' @ bs) e, (Grave, b), [(Macron, a)])\n    \\<in> letter_less r <*lex*> greek_less r", "by (cases e) (fastforce simp: adj_msog_def under_def)"], ["proof (state)\nthis:\n  (adj_msog (as @ b') (a' @ bs) e, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "}"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek cs \\<Longrightarrow>\n  (adj_msog (as @ b') (a' @ bs) ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "moreover"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek cs \\<Longrightarrow>\n  (adj_msog (as @ b') (a' @ bs) ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "{"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek cs \\<Longrightarrow>\n  (adj_msog (as @ b') (a' @ bs) ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "fix e"], ["proof (state)\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "assume \"e \\<in> set_mset (ms_of_greek bs)\""], ["proof (state)\nthis:\n  e \\<in># ms_of_greek bs\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "with bs ms_of_greek_elem[of _ _ bs]"], ["proof (chain)\npicking this:\n  snd ` set bs \\<subseteq> under r b\n  (?x, ?xs) \\<in># ms_of_greek bs \\<Longrightarrow> ?x \\<in> set bs\n  e \\<in># ms_of_greek bs", "have \"(adj_msog (as @ b' @ cs @ a') [] e, (?B,[?A])) \\<in> letter_less r <*lex*> greek_less r\""], ["proof (prove)\nusing this:\n  snd ` set bs \\<subseteq> under r b\n  (?x, ?xs) \\<in># ms_of_greek bs \\<Longrightarrow> ?x \\<in> set bs\n  e \\<in># ms_of_greek bs\n\ngoal (1 subgoal):\n 1. (adj_msog (as @ b' @ cs @ a') [] e, (Grave, b), [(Macron, a)])\n    \\<in> letter_less r <*lex*> greek_less r", "by (cases e) (fastforce simp: adj_msog_def under_def)"], ["proof (state)\nthis:\n  (adj_msog (as @ b' @ cs @ a') [] e, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "}"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek bs \\<Longrightarrow>\n  (adj_msog (as @ b' @ cs @ a') [] ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "moreover"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek bs \\<Longrightarrow>\n  (adj_msog (as @ b' @ cs @ a') [] ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "have \"ms_of_greek [?A,?B] = {# (?B,[?A]), (?A,[]) #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ms_of_greek [(Macron, a), (Grave, b)] =\n    {#((Grave, b), [(Macron, a)]), ((Macron, a), [])#}", "by (simp add: adj_msog_def ms_of_greek_def)"], ["proof (state)\nthis:\n  ms_of_greek [(Macron, a), (Grave, b)] =\n  {#((Grave, b), [(Macron, a)]), ((Macron, a), [])#}\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "ultimately"], ["proof (chain)\npicking this:\n  ?e2 \\<in># ms_of_greek as \\<Longrightarrow>\n  (adj_msog [] (b' @ cs @ a' @ bs) ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ?e2 \\<in># ms_of_greek b' \\<Longrightarrow>\n  (adj_msog as (cs @ a' @ bs) ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ?e2 \\<in># ms_of_greek cs \\<Longrightarrow>\n  (adj_msog (as @ b') (a' @ bs) ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ?e2 \\<in># ms_of_greek bs \\<Longrightarrow>\n  (adj_msog (as @ b' @ cs @ a') [] ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ms_of_greek [(Macron, a), (Grave, b)] =\n  {#((Grave, b), [(Macron, a)]), ((Macron, a), [])#}", "have \"\\<forall>x\\<in>set_mset (ms_of_greek (as @ b' @ cs @ a' @ bs) - {#(?A,[])#}).\n    \\<exists>y\\<in>set_mset (ms_of_greek [?A,?B] - {#(?A,[])#}). (x, y) \\<in> letter_less r <*lex*> greek_less r\""], ["proof (prove)\nusing this:\n  ?e2 \\<in># ms_of_greek as \\<Longrightarrow>\n  (adj_msog [] (b' @ cs @ a' @ bs) ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ?e2 \\<in># ms_of_greek b' \\<Longrightarrow>\n  (adj_msog as (cs @ a' @ bs) ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ?e2 \\<in># ms_of_greek cs \\<Longrightarrow>\n  (adj_msog (as @ b') (a' @ bs) ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ?e2 \\<in># ms_of_greek bs \\<Longrightarrow>\n  (adj_msog (as @ b' @ cs @ a') [] ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ms_of_greek [(Macron, a), (Grave, b)] =\n  {#((Grave, b), [(Macron, a)]), ((Macron, a), [])#}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs) -\n                    {#((Macron, a), [])#}.\n       \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)] -\n                       {#((Macron, a), [])#}.\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "unfolding msog_append"], ["proof (prove)\nusing this:\n  ?e2 \\<in># ms_of_greek as \\<Longrightarrow>\n  (adj_msog [] (b' @ cs @ a' @ bs) ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ?e2 \\<in># ms_of_greek b' \\<Longrightarrow>\n  (adj_msog as (cs @ a' @ bs) ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ?e2 \\<in># ms_of_greek cs \\<Longrightarrow>\n  (adj_msog (as @ b') (a' @ bs) ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ?e2 \\<in># ms_of_greek bs \\<Longrightarrow>\n  (adj_msog (as @ b' @ cs @ a') [] ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ms_of_greek [(Macron, a), (Grave, b)] =\n  {#((Grave, b), [(Macron, a)]), ((Macron, a), [])#}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>#image_mset (adj_msog [] (b' @ cs @ a' @ bs))\n                     (ms_of_greek as) +\n                    image_mset (adj_msog as [])\n                     (image_mset (adj_msog [] (cs @ a' @ bs))\n                       (ms_of_greek b') +\n                      image_mset (adj_msog b' [])\n                       (image_mset (adj_msog [] (a' @ bs))\n                         (ms_of_greek cs) +\n                        image_mset (adj_msog cs [])\n                         (image_mset (adj_msog [] bs) (ms_of_greek a') +\n                          image_mset (adj_msog a' []) (ms_of_greek bs)))) -\n                    {#((Macron, a), [])#}.\n       \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)] -\n                       {#((Macron, a), [])#}.\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "by (auto simp: a' msog_append ac_simps * adj_msog_single)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs @ a' @ bs) -\n                  {#((Macron, a), [])#}.\n     \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)] -\n                     {#((Macron, a), [])#}.\n        (x, y) \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "from one_step_implies_mult[OF ** this,of \"{#(?A,[])#}\"]"], ["proof (chain)\npicking this:\n  ({#((Macron, a), [])#} +\n   (ms_of_greek (as @ b' @ cs @ a' @ bs) - {#((Macron, a), [])#}),\n   {#((Macron, a), [])#} +\n   (ms_of_greek [(Macron, a), (Grave, b)] - {#((Macron, a), [])#}))\n  \\<in> mult (letter_less r <*lex*> greek_less r)", "have \"(ms_of_greek (as @ b' @ cs @ a' @ bs), ms_of_greek [?A,?B]) \\<in> mult (letter_less r <*lex*> greek_less r)\""], ["proof (prove)\nusing this:\n  ({#((Macron, a), [])#} +\n   (ms_of_greek (as @ b' @ cs @ a' @ bs) - {#((Macron, a), [])#}),\n   {#((Macron, a), [])#} +\n   (ms_of_greek [(Macron, a), (Grave, b)] - {#((Macron, a), [])#}))\n  \\<in> mult (letter_less r <*lex*> greek_less r)\n\ngoal (1 subgoal):\n 1. (ms_of_greek (as @ b' @ cs @ a' @ bs),\n     ms_of_greek [(Macron, a), (Grave, b)])\n    \\<in> mult (letter_less r <*lex*> greek_less r)", "unfolding a' msog_append"], ["proof (prove)\nusing this:\n  ({#((Macron, a), [])#} +\n   (image_mset (adj_msog [] (b' @ cs @ [(Macron, a)] @ bs))\n     (ms_of_greek as) +\n    image_mset (adj_msog as [])\n     (image_mset (adj_msog [] (cs @ [(Macron, a)] @ bs)) (ms_of_greek b') +\n      image_mset (adj_msog b' [])\n       (image_mset (adj_msog [] ([(Macron, a)] @ bs)) (ms_of_greek cs) +\n        image_mset (adj_msog cs [])\n         (image_mset (adj_msog [] bs) (ms_of_greek [(Macron, a)]) +\n          image_mset (adj_msog [(Macron, a)] []) (ms_of_greek bs)))) -\n    {#((Macron, a), [])#}),\n   {#((Macron, a), [])#} +\n   (ms_of_greek [(Macron, a), (Grave, b)] - {#((Macron, a), [])#}))\n  \\<in> mult (letter_less r <*lex*> greek_less r)\n\ngoal (1 subgoal):\n 1. (image_mset (adj_msog [] (b' @ cs @ [(Macron, a)] @ bs))\n      (ms_of_greek as) +\n     image_mset (adj_msog as [])\n      (image_mset (adj_msog [] (cs @ [(Macron, a)] @ bs)) (ms_of_greek b') +\n       image_mset (adj_msog b' [])\n        (image_mset (adj_msog [] ([(Macron, a)] @ bs)) (ms_of_greek cs) +\n         image_mset (adj_msog cs [])\n          (image_mset (adj_msog [] bs) (ms_of_greek [(Macron, a)]) +\n           image_mset (adj_msog [(Macron, a)] []) (ms_of_greek bs)))),\n     ms_of_greek [(Macron, a), (Grave, b)])\n    \\<in> mult (letter_less r <*lex*> greek_less r)", "by (auto simp: a' ac_simps * adj_msog_single)"], ["proof (state)\nthis:\n  (ms_of_greek (as @ b' @ cs @ a' @ bs),\n   ms_of_greek [(Macron, a), (Grave, b)])\n  \\<in> mult (letter_less r <*lex*> greek_less r)\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "then"], ["proof (chain)\npicking this:\n  (ms_of_greek (as @ b' @ cs @ a' @ bs),\n   ms_of_greek [(Macron, a), (Grave, b)])\n  \\<in> mult (letter_less r <*lex*> greek_less r)", "show ?thesis"], ["proof (prove)\nusing this:\n  (ms_of_greek (as @ b' @ cs @ a' @ bs),\n   ms_of_greek [(Macron, a), (Grave, b)])\n  \\<in> mult (letter_less r <*lex*> greek_less r)\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "by (subst greek_less_unfold) auto"], ["proof (state)\nthis:\n  (as @ b' @ cs @ a' @ bs, [(Macron, a), (Grave, b)]) \\<in> greek_less r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rcliff_greek_less2:\n  assumes \"trans r\" (* unused assumption kept for symmetry with lcliff_greek_less2 *)\n  and as: \"snd ` set as \\<subseteq> under r a\" and b': \"b' \\<in> {[(Grave,b)],[]}\"\n  and cs: \"snd ` set cs \\<subseteq> under r a \\<union> under r b\"\n  shows \"(as @ b' @ cs, [(Macron,a),(Grave,b)]) \\<in> greek_less r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (as @ b' @ cs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (as @ b' @ cs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "let ?A = \"(Macron,a)\" and ?B = \"(Grave,b)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (as @ b' @ cs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "have \"(ms_of_greek (as @ b' @ cs), ms_of_greek [?A,?B]) \\<in> mult (letter_less r <*lex*> greek_less r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ms_of_greek (as @ b' @ cs), ms_of_greek [(Macron, a), (Grave, b)])\n    \\<in> mult (letter_less r <*lex*> greek_less r)", "proof (intro pairwise_imp_mult)"], ["proof (state)\ngoal (2 subgoals):\n 1. ms_of_greek [(Macron, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs).\n       \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "(* we distinguish 3 cases depending on where in xs an element e originates *)"], ["proof (state)\ngoal (2 subgoals):\n 1. ms_of_greek [(Macron, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs).\n       \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. ms_of_greek [(Macron, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs).\n       \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "fix e"], ["proof (state)\ngoal (2 subgoals):\n 1. ms_of_greek [(Macron, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs).\n       \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "assume \"e \\<in> set_mset (ms_of_greek as)\""], ["proof (state)\nthis:\n  e \\<in># ms_of_greek as\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Macron, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs).\n       \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "with as ms_of_greek_elem[of _ _ as]"], ["proof (chain)\npicking this:\n  snd ` set as \\<subseteq> under r a\n  (?x, ?xs) \\<in># ms_of_greek as \\<Longrightarrow> ?x \\<in> set as\n  e \\<in># ms_of_greek as", "have \"(adj_msog [] (b' @ cs) e, (?A,[])) \\<in> letter_less r <*lex*> greek_less r\""], ["proof (prove)\nusing this:\n  snd ` set as \\<subseteq> under r a\n  (?x, ?xs) \\<in># ms_of_greek as \\<Longrightarrow> ?x \\<in> set as\n  e \\<in># ms_of_greek as\n\ngoal (1 subgoal):\n 1. (adj_msog [] (b' @ cs) e, (Macron, a), [])\n    \\<in> letter_less r <*lex*> greek_less r", "by (cases e) (fastforce simp: adj_msog_def under_def)"], ["proof (state)\nthis:\n  (adj_msog [] (b' @ cs) e, (Macron, a), [])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Macron, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs).\n       \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "}"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek as \\<Longrightarrow>\n  (adj_msog [] (b' @ cs) ?e2, (Macron, a), [])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Macron, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs).\n       \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "moreover"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek as \\<Longrightarrow>\n  (adj_msog [] (b' @ cs) ?e2, (Macron, a), [])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Macron, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs).\n       \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "{"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek as \\<Longrightarrow>\n  (adj_msog [] (b' @ cs) ?e2, (Macron, a), [])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Macron, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs).\n       \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "fix e"], ["proof (state)\ngoal (2 subgoals):\n 1. ms_of_greek [(Macron, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs).\n       \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "assume \"e \\<in> set_mset (ms_of_greek b')\""], ["proof (state)\nthis:\n  e \\<in># ms_of_greek b'\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Macron, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs).\n       \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "with b' singleton_greek_less[OF as] ms_of_greek_elem[of _ _ b']"], ["proof (chain)\npicking this:\n  b' \\<in> {[(Grave, b)], []}\n  (as, [(?a, a)]) \\<in> greek_less r\n  (?x, ?xs) \\<in># ms_of_greek b' \\<Longrightarrow> ?x \\<in> set b'\n  e \\<in># ms_of_greek b'", "have \"(adj_msog as (cs) e, (?B,[?A])) \\<in> letter_less r <*lex*> greek_less r\""], ["proof (prove)\nusing this:\n  b' \\<in> {[(Grave, b)], []}\n  (as, [(?a, a)]) \\<in> greek_less r\n  (?x, ?xs) \\<in># ms_of_greek b' \\<Longrightarrow> ?x \\<in> set b'\n  e \\<in># ms_of_greek b'\n\ngoal (1 subgoal):\n 1. (adj_msog as cs e, (Grave, b), [(Macron, a)])\n    \\<in> letter_less r <*lex*> greek_less r", "by (cases e) (fastforce simp: adj_msog_def ms_of_greek_def)"], ["proof (state)\nthis:\n  (adj_msog as cs e, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Macron, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs).\n       \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "}"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek b' \\<Longrightarrow>\n  (adj_msog as cs ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Macron, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs).\n       \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "moreover"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek b' \\<Longrightarrow>\n  (adj_msog as cs ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Macron, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs).\n       \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "{"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek b' \\<Longrightarrow>\n  (adj_msog as cs ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Macron, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs).\n       \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "fix e"], ["proof (state)\ngoal (2 subgoals):\n 1. ms_of_greek [(Macron, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs).\n       \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "assume \"e \\<in> set_mset (ms_of_greek cs)\""], ["proof (state)\nthis:\n  e \\<in># ms_of_greek cs\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Macron, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs).\n       \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "with cs ms_of_greek_elem[of _ _ cs]"], ["proof (chain)\npicking this:\n  snd ` set cs \\<subseteq> under r a \\<union> under r b\n  (?x, ?xs) \\<in># ms_of_greek cs \\<Longrightarrow> ?x \\<in> set cs\n  e \\<in># ms_of_greek cs", "have \"(adj_msog (as @ b') [] e, (?A,[])) \\<in> letter_less r <*lex*> greek_less r \\<or>\n            (adj_msog (as @ b') [] e, (?B,[?A])) \\<in> letter_less r <*lex*> greek_less r\""], ["proof (prove)\nusing this:\n  snd ` set cs \\<subseteq> under r a \\<union> under r b\n  (?x, ?xs) \\<in># ms_of_greek cs \\<Longrightarrow> ?x \\<in> set cs\n  e \\<in># ms_of_greek cs\n\ngoal (1 subgoal):\n 1. (adj_msog (as @ b') [] e, (Macron, a), [])\n    \\<in> letter_less r <*lex*> greek_less r \\<or>\n    (adj_msog (as @ b') [] e, (Grave, b), [(Macron, a)])\n    \\<in> letter_less r <*lex*> greek_less r", "by (cases e) (fastforce simp: adj_msog_def under_def)"], ["proof (state)\nthis:\n  (adj_msog (as @ b') [] e, (Macron, a), [])\n  \\<in> letter_less r <*lex*> greek_less r \\<or>\n  (adj_msog (as @ b') [] e, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Macron, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs).\n       \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "}"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek cs \\<Longrightarrow>\n  (adj_msog (as @ b') [] ?e2, (Macron, a), [])\n  \\<in> letter_less r <*lex*> greek_less r \\<or>\n  (adj_msog (as @ b') [] ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Macron, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs).\n       \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "moreover"], ["proof (state)\nthis:\n  ?e2 \\<in># ms_of_greek cs \\<Longrightarrow>\n  (adj_msog (as @ b') [] ?e2, (Macron, a), [])\n  \\<in> letter_less r <*lex*> greek_less r \\<or>\n  (adj_msog (as @ b') [] ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Macron, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs).\n       \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "have *: \"ms_of_greek [?A,?B] = {# (?B,[?A]), (?A,[]) #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ms_of_greek [(Macron, a), (Grave, b)] =\n    {#((Grave, b), [(Macron, a)]), ((Macron, a), [])#}", "by (simp add: adj_msog_def ms_of_greek_def)"], ["proof (state)\nthis:\n  ms_of_greek [(Macron, a), (Grave, b)] =\n  {#((Grave, b), [(Macron, a)]), ((Macron, a), [])#}\n\ngoal (2 subgoals):\n 1. ms_of_greek [(Macron, a), (Grave, b)] \\<noteq> {#}\n 2. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs).\n       \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "ultimately"], ["proof (chain)\npicking this:\n  ?e2 \\<in># ms_of_greek as \\<Longrightarrow>\n  (adj_msog [] (b' @ cs) ?e2, (Macron, a), [])\n  \\<in> letter_less r <*lex*> greek_less r\n  ?e2 \\<in># ms_of_greek b' \\<Longrightarrow>\n  (adj_msog as cs ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ?e2 \\<in># ms_of_greek cs \\<Longrightarrow>\n  (adj_msog (as @ b') [] ?e2, (Macron, a), [])\n  \\<in> letter_less r <*lex*> greek_less r \\<or>\n  (adj_msog (as @ b') [] ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ms_of_greek [(Macron, a), (Grave, b)] =\n  {#((Grave, b), [(Macron, a)]), ((Macron, a), [])#}", "show \"\\<forall>x\\<in>set_mset (ms_of_greek (as @ b' @ cs)).\n      \\<exists>y\\<in>set_mset (ms_of_greek [?A,?B]). (x, y) \\<in> letter_less r <*lex*> greek_less r\""], ["proof (prove)\nusing this:\n  ?e2 \\<in># ms_of_greek as \\<Longrightarrow>\n  (adj_msog [] (b' @ cs) ?e2, (Macron, a), [])\n  \\<in> letter_less r <*lex*> greek_less r\n  ?e2 \\<in># ms_of_greek b' \\<Longrightarrow>\n  (adj_msog as cs ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ?e2 \\<in># ms_of_greek cs \\<Longrightarrow>\n  (adj_msog (as @ b') [] ?e2, (Macron, a), [])\n  \\<in> letter_less r <*lex*> greek_less r \\<or>\n  (adj_msog (as @ b') [] ?e2, (Grave, b), [(Macron, a)])\n  \\<in> letter_less r <*lex*> greek_less r\n  ms_of_greek [(Macron, a), (Grave, b)] =\n  {#((Grave, b), [(Macron, a)]), ((Macron, a), [])#}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs).\n       \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)].\n          (x, y) \\<in> letter_less r <*lex*> greek_less r", "by (auto simp: msog_append adj_msog_single ac_simps *) blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>#ms_of_greek (as @ b' @ cs).\n     \\<exists>y\\<in>#ms_of_greek [(Macron, a), (Grave, b)].\n        (x, y) \\<in> letter_less r <*lex*> greek_less r\n\ngoal (1 subgoal):\n 1. ms_of_greek [(Macron, a), (Grave, b)] \\<noteq> {#}", "qed (auto simp: ms_of_greek_def)"], ["proof (state)\nthis:\n  (ms_of_greek (as @ b' @ cs), ms_of_greek [(Macron, a), (Grave, b)])\n  \\<in> mult (letter_less r <*lex*> greek_less r)\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "then"], ["proof (chain)\npicking this:\n  (ms_of_greek (as @ b' @ cs), ms_of_greek [(Macron, a), (Grave, b)])\n  \\<in> mult (letter_less r <*lex*> greek_less r)", "show ?thesis"], ["proof (prove)\nusing this:\n  (ms_of_greek (as @ b' @ cs), ms_of_greek [(Macron, a), (Grave, b)])\n  \\<in> mult (letter_less r <*lex*> greek_less r)\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "by (subst greek_less_unfold) auto"], ["proof (state)\nthis:\n  (as @ b' @ cs, [(Macron, a), (Grave, b)]) \\<in> greek_less r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma snd_inv_greek [simp]: \"snd ` set (inv_greek as) = snd ` set as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` set (inv_greek as) = snd ` set as", "by (force simp: inv_greek_def)"], ["", "lemma lcliff_greek_less1:\n  assumes \"trans r\"\n  and as: \"snd ` set as \\<subseteq> under r a\" and b': \"b' = [(Macron,b)]\"\n  and cs: \"snd ` set cs \\<subseteq> under r a\" and a': \"a' \\<in> {[(Acute,a)],[]}\"\n  and bs: \"snd ` set bs \\<subseteq> under r a \\<inter> under r b\"\n  shows \"(as @ b' @ cs @ a' @ bs, [(Acute,a),(Macron,b)]) \\<in> greek_less r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Acute, a), (Macron, b)]) \\<in> greek_less r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Acute, a), (Macron, b)]) \\<in> greek_less r", "have *: \"inv_greek [(Acute,a),(Macron,b)] = [(Macron,b),(Grave,a)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_greek [(Acute, a), (Macron, b)] = [(Macron, b), (Grave, a)]", "by (simp add: inv_greek_def)"], ["proof (state)\nthis:\n  inv_greek [(Acute, a), (Macron, b)] = [(Macron, b), (Grave, a)]\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Acute, a), (Macron, b)]) \\<in> greek_less r", "have \"(inv_greek (inv_greek (as @ b' @ cs @ a' @ bs)),\n   inv_greek (inv_greek ([(Acute,a),(Macron,b)]))) \\<in> greek_less r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inv_greek (inv_greek (as @ b' @ cs @ a' @ bs)),\n     inv_greek (inv_greek [(Acute, a), (Macron, b)]))\n    \\<in> greek_less r", "apply (rule inv_greek_mono[OF \\<open>trans r\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (inv_greek (as @ b' @ cs @ a' @ bs),\n     inv_greek [(Acute, a), (Macron, b)])\n    \\<in> greek_less r", "apply (unfold inv_greek_append append_assoc *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (inv_greek bs @\n     inv_greek a' @ inv_greek cs @ inv_greek b' @ inv_greek as,\n     [(Macron, b), (Grave, a)])\n    \\<in> greek_less r", "apply (insert assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trans r; snd ` set as \\<subseteq> under r a;\n     b' = [(Macron, b)]; snd ` set cs \\<subseteq> under r a;\n     a' \\<in> {[(Acute, a)], []};\n     snd ` set bs \\<subseteq> under r a \\<inter> under r b\\<rbrakk>\n    \\<Longrightarrow> (inv_greek bs @\n                       inv_greek a' @\n                       inv_greek cs @ inv_greek b' @ inv_greek as,\n                       [(Macron, b), (Grave, a)])\n                      \\<in> greek_less r", "apply (rule rcliff_greek_less1, auto simp: inv_greek_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (inv_greek (inv_greek (as @ b' @ cs @ a' @ bs)),\n   inv_greek (inv_greek [(Acute, a), (Macron, b)]))\n  \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Acute, a), (Macron, b)]) \\<in> greek_less r", "then"], ["proof (chain)\npicking this:\n  (inv_greek (inv_greek (as @ b' @ cs @ a' @ bs)),\n   inv_greek (inv_greek [(Acute, a), (Macron, b)]))\n  \\<in> greek_less r", "show ?thesis"], ["proof (prove)\nusing this:\n  (inv_greek (inv_greek (as @ b' @ cs @ a' @ bs)),\n   inv_greek (inv_greek [(Acute, a), (Macron, b)]))\n  \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. (as @ b' @ cs @ a' @ bs, [(Acute, a), (Macron, b)]) \\<in> greek_less r", "by simp"], ["proof (state)\nthis:\n  (as @ b' @ cs @ a' @ bs, [(Acute, a), (Macron, b)]) \\<in> greek_less r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lcliff_greek_less2:\n  assumes \"trans r\"\n  and cs: \"snd ` set cs \\<subseteq> under r a \\<union> under r b\" and a': \"a' \\<in> {[(Acute,a)],[]}\"\n  and bs: \"snd ` set bs \\<subseteq> under r b\"\n  shows \"(cs @ a' @ bs, [(Acute,a),(Macron,b)]) \\<in> greek_less r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cs @ a' @ bs, [(Acute, a), (Macron, b)]) \\<in> greek_less r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (cs @ a' @ bs, [(Acute, a), (Macron, b)]) \\<in> greek_less r", "have *: \"inv_greek [(Acute,a),(Macron,b)] = [(Macron,b),(Grave,a)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_greek [(Acute, a), (Macron, b)] = [(Macron, b), (Grave, a)]", "by (simp add: inv_greek_def)"], ["proof (state)\nthis:\n  inv_greek [(Acute, a), (Macron, b)] = [(Macron, b), (Grave, a)]\n\ngoal (1 subgoal):\n 1. (cs @ a' @ bs, [(Acute, a), (Macron, b)]) \\<in> greek_less r", "have \"(inv_greek (inv_greek (cs @ a' @ bs)),\n    inv_greek (inv_greek ([(Acute,a),(Macron,b)]))) \\<in> greek_less r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inv_greek (inv_greek (cs @ a' @ bs)),\n     inv_greek (inv_greek [(Acute, a), (Macron, b)]))\n    \\<in> greek_less r", "apply (rule inv_greek_mono[OF \\<open>trans r\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (inv_greek (cs @ a' @ bs), inv_greek [(Acute, a), (Macron, b)])\n    \\<in> greek_less r", "apply (unfold inv_greek_append append_assoc *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (inv_greek bs @ inv_greek a' @ inv_greek cs, [(Macron, b), (Grave, a)])\n    \\<in> greek_less r", "apply (insert assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trans r; snd ` set cs \\<subseteq> under r a \\<union> under r b;\n     a' \\<in> {[(Acute, a)], []};\n     snd ` set bs \\<subseteq> under r b\\<rbrakk>\n    \\<Longrightarrow> (inv_greek bs @ inv_greek a' @ inv_greek cs,\n                       [(Macron, b), (Grave, a)])\n                      \\<in> greek_less r", "apply (rule rcliff_greek_less2, auto simp: inv_greek_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (inv_greek (inv_greek (cs @ a' @ bs)),\n   inv_greek (inv_greek [(Acute, a), (Macron, b)]))\n  \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. (cs @ a' @ bs, [(Acute, a), (Macron, b)]) \\<in> greek_less r", "then"], ["proof (chain)\npicking this:\n  (inv_greek (inv_greek (cs @ a' @ bs)),\n   inv_greek (inv_greek [(Acute, a), (Macron, b)]))\n  \\<in> greek_less r", "show ?thesis"], ["proof (prove)\nusing this:\n  (inv_greek (inv_greek (cs @ a' @ bs)),\n   inv_greek (inv_greek [(Acute, a), (Macron, b)]))\n  \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. (cs @ a' @ bs, [(Acute, a), (Macron, b)]) \\<in> greek_less r", "by simp"], ["proof (state)\nthis:\n  (cs @ a' @ bs, [(Acute, a), (Macron, b)]) \\<in> greek_less r\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Labeled abstract rewriting\\<close>"], ["", "context\n  fixes L R E :: \"'b \\<Rightarrow> 'a rel\"\nbegin"], ["", "definition lstep :: \"'b letter \\<Rightarrow> 'a rel\" where\n  [simp]: \"lstep x = (case x of (a, i) \\<Rightarrow> (case a of Acute \\<Rightarrow> (L i)\\<inverse> | Grave \\<Rightarrow> R i | Macron \\<Rightarrow> E i))\""], ["", "fun lconv :: \"'b greek \\<Rightarrow> 'a rel\" where\n  \"lconv [] = Id\"\n| \"lconv (x # xs) = lstep x O lconv xs\""], ["", "lemma lconv_append[simp]:\n  \"lconv (xs @ ys) = lconv xs O lconv ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.lconv (xs @ ys) = local.lconv xs O local.lconv ys", "by (induct xs) auto"], ["", "lemma conversion_join_or_peak_or_cliff:\n  obtains (join) as bs cs where \"set as \\<subseteq> {Grave}\" and \"set bs \\<subseteq> {Macron}\" and \"set cs \\<subseteq> {Acute}\"\n    and \"ds = as @ bs @ cs\"\n  | (peak) as bs where \"ds = as @ ([Acute] @ [Grave]) @ bs\"\n  | (lcliff) as bs where \"ds = as @ ([Acute] @ [Macron]) @ bs\"\n  | (rcliff) as bs where \"ds = as @ ([Macron] @ [Grave]) @ bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>as bs cs.\n                \\<lbrakk>set as \\<subseteq> {Grave};\n                 set bs \\<subseteq> {Macron}; set cs \\<subseteq> {Acute};\n                 ds = as @ bs @ cs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>as bs.\n        ds = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow> thesis;\n     \\<And>as bs.\n        ds = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow> thesis;\n     \\<And>as bs.\n        ds = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n        thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof (induct ds arbitrary: thesis)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<And>as bs cs.\n                   \\<lbrakk>set as \\<subseteq> {Grave};\n                    set bs \\<subseteq> {Macron}; set cs \\<subseteq> {Acute};\n                    [] = as @ bs @ cs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>as bs.\n           [] = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow> thesis;\n        \\<And>as bs.\n           [] = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow> thesis;\n        \\<And>as bs.\n           [] = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a ds thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>as bs cs.\n                               \\<lbrakk>set as \\<subseteq> {Grave};\n                                set bs \\<subseteq> {Macron};\n                                set cs \\<subseteq> {Acute};\n                                ds = as @ bs @ cs\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    \\<And>as bs.\n                       ds = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow>\n                       thesis;\n                    \\<And>as bs.\n                       ds = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n                       thesis;\n                    \\<And>as bs.\n                       ds = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n                       thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>as bs cs.\n           \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n            set cs \\<subseteq> {Acute}; a # ds = as @ bs @ cs\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>as bs.\n           a # ds = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow> thesis;\n        \\<And>as bs.\n           a # ds = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow> thesis;\n        \\<And>as bs.\n           a # ds = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Cons d ds thesis)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>as bs cs.\n              \\<lbrakk>set as \\<subseteq> {Grave};\n               set bs \\<subseteq> {Macron}; set cs \\<subseteq> {Acute};\n               ds = as @ bs @ cs\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>as bs.\n      ds = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow> ?thesis;\n   \\<And>as bs.\n      ds = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow> ?thesis;\n   \\<And>as bs.\n      ds = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>set ?as \\<subseteq> {Grave}; set ?bs \\<subseteq> {Macron};\n   set ?cs \\<subseteq> {Acute}; d # ds = ?as @ ?bs @ ?cs\\<rbrakk>\n  \\<Longrightarrow> thesis\n  d # ds = ?as @ ([Acute] @ [Grave]) @ ?bs \\<Longrightarrow> thesis\n  d # ds = ?as @ ([Acute] @ [Macron]) @ ?bs \\<Longrightarrow> thesis\n  d # ds = ?as @ ([Macron] @ [Grave]) @ ?bs \\<Longrightarrow> thesis\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<And>as bs cs.\n                   \\<lbrakk>set as \\<subseteq> {Grave};\n                    set bs \\<subseteq> {Macron}; set cs \\<subseteq> {Acute};\n                    [] = as @ bs @ cs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>as bs.\n           [] = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow> thesis;\n        \\<And>as bs.\n           [] = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow> thesis;\n        \\<And>as bs.\n           [] = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a ds thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>as bs cs.\n                               \\<lbrakk>set as \\<subseteq> {Grave};\n                                set bs \\<subseteq> {Macron};\n                                set cs \\<subseteq> {Acute};\n                                ds = as @ bs @ cs\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    \\<And>as bs.\n                       ds = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow>\n                       thesis;\n                    \\<And>as bs.\n                       ds = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n                       thesis;\n                    \\<And>as bs.\n                       ds = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n                       thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>as bs cs.\n           \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n            set cs \\<subseteq> {Acute}; a # ds = as @ bs @ cs\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>as bs.\n           a # ds = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow> thesis;\n        \\<And>as bs.\n           a # ds = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow> thesis;\n        \\<And>as bs.\n           a # ds = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "note IH = this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>as bs cs.\n              \\<lbrakk>set as \\<subseteq> {Grave};\n               set bs \\<subseteq> {Macron}; set cs \\<subseteq> {Acute};\n               ds = as @ bs @ cs\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>as bs.\n      ds = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow> ?thesis;\n   \\<And>as bs.\n      ds = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow> ?thesis;\n   \\<And>as bs.\n      ds = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>set ?as \\<subseteq> {Grave}; set ?bs \\<subseteq> {Macron};\n   set ?cs \\<subseteq> {Acute}; d # ds = ?as @ ?bs @ ?cs\\<rbrakk>\n  \\<Longrightarrow> thesis\n  d # ds = ?as @ ([Acute] @ [Grave]) @ ?bs \\<Longrightarrow> thesis\n  d # ds = ?as @ ([Acute] @ [Macron]) @ ?bs \\<Longrightarrow> thesis\n  d # ds = ?as @ ([Macron] @ [Grave]) @ ?bs \\<Longrightarrow> thesis\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<And>as bs cs.\n                   \\<lbrakk>set as \\<subseteq> {Grave};\n                    set bs \\<subseteq> {Macron}; set cs \\<subseteq> {Acute};\n                    [] = as @ bs @ cs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>as bs.\n           [] = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow> thesis;\n        \\<And>as bs.\n           [] = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow> thesis;\n        \\<And>as bs.\n           [] = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a ds thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>as bs cs.\n                               \\<lbrakk>set as \\<subseteq> {Grave};\n                                set bs \\<subseteq> {Macron};\n                                set cs \\<subseteq> {Acute};\n                                ds = as @ bs @ cs\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    \\<And>as bs.\n                       ds = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow>\n                       thesis;\n                    \\<And>as bs.\n                       ds = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n                       thesis;\n                    \\<And>as bs.\n                       ds = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n                       thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>as bs cs.\n           \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n            set cs \\<subseteq> {Acute}; a # ds = as @ bs @ cs\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>as bs.\n           a # ds = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow> thesis;\n        \\<And>as bs.\n           a # ds = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow> thesis;\n        \\<And>as bs.\n           a # ds = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule IH(1))"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>as bs cs.\n       \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n        set cs \\<subseteq> {Acute}; ds = as @ bs @ cs\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>as bs. ds = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow> thesis\n 3. \\<And>as bs.\n       ds = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow> thesis\n 4. \\<And>as bs.\n       ds = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow> thesis", "fix as bs"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>as bs cs.\n       \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n        set cs \\<subseteq> {Acute}; ds = as @ bs @ cs\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>as bs. ds = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow> thesis\n 3. \\<And>as bs.\n       ds = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow> thesis\n 4. \\<And>as bs.\n       ds = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow> thesis", "assume \"ds = as @ ([Acute] @ [Grave]) @ bs\""], ["proof (state)\nthis:\n  ds = as @ ([Acute] @ [Grave]) @ bs\n\ngoal (4 subgoals):\n 1. \\<And>as bs cs.\n       \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n        set cs \\<subseteq> {Acute}; ds = as @ bs @ cs\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>as bs. ds = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow> thesis\n 3. \\<And>as bs.\n       ds = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow> thesis\n 4. \\<And>as bs.\n       ds = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  ds = as @ ([Acute] @ [Grave]) @ bs", "show ?case"], ["proof (prove)\nusing this:\n  ds = as @ ([Acute] @ [Grave]) @ bs\n\ngoal (1 subgoal):\n 1. thesis", "using IH(3)[of \"d # as\" bs]"], ["proof (prove)\nusing this:\n  ds = as @ ([Acute] @ [Grave]) @ bs\n  d # ds = (d # as) @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (3 subgoals):\n 1. \\<And>as bs cs.\n       \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n        set cs \\<subseteq> {Acute}; ds = as @ bs @ cs\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>as bs.\n       ds = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow> thesis\n 3. \\<And>as bs.\n       ds = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>as bs cs.\n       \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n        set cs \\<subseteq> {Acute}; ds = as @ bs @ cs\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>as bs.\n       ds = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow> thesis\n 3. \\<And>as bs.\n       ds = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow> thesis", "fix as bs"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>as bs cs.\n       \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n        set cs \\<subseteq> {Acute}; ds = as @ bs @ cs\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>as bs.\n       ds = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow> thesis\n 3. \\<And>as bs.\n       ds = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow> thesis", "assume \"ds = as @ ([Acute] @ [Macron]) @ bs\""], ["proof (state)\nthis:\n  ds = as @ ([Acute] @ [Macron]) @ bs\n\ngoal (3 subgoals):\n 1. \\<And>as bs cs.\n       \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n        set cs \\<subseteq> {Acute}; ds = as @ bs @ cs\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>as bs.\n       ds = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow> thesis\n 3. \\<And>as bs.\n       ds = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  ds = as @ ([Acute] @ [Macron]) @ bs", "show ?case"], ["proof (prove)\nusing this:\n  ds = as @ ([Acute] @ [Macron]) @ bs\n\ngoal (1 subgoal):\n 1. thesis", "using IH(4)[of \"d # as\" bs]"], ["proof (prove)\nusing this:\n  ds = as @ ([Acute] @ [Macron]) @ bs\n  d # ds = (d # as) @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<And>as bs cs.\n       \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n        set cs \\<subseteq> {Acute}; ds = as @ bs @ cs\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>as bs.\n       ds = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as bs cs.\n       \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n        set cs \\<subseteq> {Acute}; ds = as @ bs @ cs\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>as bs.\n       ds = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow> thesis", "fix as bs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as bs cs.\n       \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n        set cs \\<subseteq> {Acute}; ds = as @ bs @ cs\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>as bs.\n       ds = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow> thesis", "assume \"ds = as @ ([Macron] @ [Grave]) @ bs\""], ["proof (state)\nthis:\n  ds = as @ ([Macron] @ [Grave]) @ bs\n\ngoal (2 subgoals):\n 1. \\<And>as bs cs.\n       \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n        set cs \\<subseteq> {Acute}; ds = as @ bs @ cs\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>as bs.\n       ds = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  ds = as @ ([Macron] @ [Grave]) @ bs", "show ?case"], ["proof (prove)\nusing this:\n  ds = as @ ([Macron] @ [Grave]) @ bs\n\ngoal (1 subgoal):\n 1. thesis", "using IH(5)[of \"d # as\" bs]"], ["proof (prove)\nusing this:\n  ds = as @ ([Macron] @ [Grave]) @ bs\n  d # ds = (d # as) @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>as bs cs.\n       \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n        set cs \\<subseteq> {Acute}; ds = as @ bs @ cs\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as bs cs.\n       \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n        set cs \\<subseteq> {Acute}; ds = as @ bs @ cs\\<rbrakk>\n       \\<Longrightarrow> thesis", "fix as bs cs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as bs cs.\n       \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n        set cs \\<subseteq> {Acute}; ds = as @ bs @ cs\\<rbrakk>\n       \\<Longrightarrow> thesis", "assume *: \"set as \\<subseteq> {Grave}\" \"set bs \\<subseteq> {Macron}\" \"set cs \\<subseteq> {Acute}\" \"ds = as @ bs @ cs\""], ["proof (state)\nthis:\n  set as \\<subseteq> {Grave}\n  set bs \\<subseteq> {Macron}\n  set cs \\<subseteq> {Acute}\n  ds = as @ bs @ cs\n\ngoal (1 subgoal):\n 1. \\<And>as bs cs.\n       \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n        set cs \\<subseteq> {Acute}; ds = as @ bs @ cs\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases d)"], ["proof (state)\ngoal (3 subgoals):\n 1. d = Acute \\<Longrightarrow> thesis\n 2. d = Grave \\<Longrightarrow> thesis\n 3. d = Macron \\<Longrightarrow> thesis", "case Grave"], ["proof (state)\nthis:\n  d = Grave\n\ngoal (3 subgoals):\n 1. d = Acute \\<Longrightarrow> thesis\n 2. d = Grave \\<Longrightarrow> thesis\n 3. d = Macron \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  d = Grave\n\ngoal (1 subgoal):\n 1. thesis", "using * IH(2)[of \"d # as\" bs cs]"], ["proof (prove)\nusing this:\n  d = Grave\n  set as \\<subseteq> {Grave}\n  set bs \\<subseteq> {Macron}\n  set cs \\<subseteq> {Acute}\n  ds = as @ bs @ cs\n  \\<lbrakk>set (d # as) \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n   set cs \\<subseteq> {Acute}; d # ds = (d # as) @ bs @ cs\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. d = Acute \\<Longrightarrow> thesis\n 2. d = Macron \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. d = Acute \\<Longrightarrow> thesis\n 2. d = Macron \\<Longrightarrow> thesis", "case Macron"], ["proof (state)\nthis:\n  d = Macron\n\ngoal (2 subgoals):\n 1. d = Acute \\<Longrightarrow> thesis\n 2. d = Macron \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases as)"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> thesis\n 2. \\<And>a list. as = a # list \\<Longrightarrow> thesis", "case Nil"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> thesis\n 2. \\<And>a list. as = a # list \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  as = []\n\ngoal (1 subgoal):\n 1. thesis", "using * Macron IH(2)[of as \"d # bs\" cs]"], ["proof (prove)\nusing this:\n  as = []\n  set as \\<subseteq> {Grave}\n  set bs \\<subseteq> {Macron}\n  set cs \\<subseteq> {Acute}\n  ds = as @ bs @ cs\n  d = Macron\n  \\<lbrakk>set as \\<subseteq> {Grave}; set (d # bs) \\<subseteq> {Macron};\n   set cs \\<subseteq> {Acute}; d # ds = as @ (d # bs) @ cs\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>a list. as = a # list \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. as = a # list \\<Longrightarrow> thesis", "case (Cons a as)"], ["proof (state)\nthis:\n  as__ = a # as\n\ngoal (1 subgoal):\n 1. \\<And>a list. as__ = a # list \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  as__ = a # as\n\ngoal (1 subgoal):\n 1. thesis", "using * Macron IH(5)[of \"[]\" \"as @ bs @ cs\"]"], ["proof (prove)\nusing this:\n  as__ = a # as\n  set as__ \\<subseteq> {Grave}\n  set bs \\<subseteq> {Macron}\n  set cs \\<subseteq> {Acute}\n  ds = as__ @ bs @ cs\n  d = Macron\n  d # ds = [] @ ([Macron] @ [Grave]) @ as @ bs @ cs \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. d = Acute \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d = Acute \\<Longrightarrow> thesis", "case Acute"], ["proof (state)\nthis:\n  d = Acute\n\ngoal (1 subgoal):\n 1. d = Acute \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases as)"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> thesis\n 2. \\<And>a list. as = a # list \\<Longrightarrow> thesis", "case Nil"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> thesis\n 2. \\<And>a list. as = a # list \\<Longrightarrow> thesis", "note as = this"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> thesis\n 2. \\<And>a list. as = a # list \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases bs)"], ["proof (state)\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow> thesis\n 2. \\<And>a list. bs = a # list \\<Longrightarrow> thesis", "case Nil"], ["proof (state)\nthis:\n  bs = []\n\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow> thesis\n 2. \\<And>a list. bs = a # list \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  bs = []\n\ngoal (1 subgoal):\n 1. thesis", "using * as Acute IH(2)[of \"[]\" \"[]\" \"d # cs\"]"], ["proof (prove)\nusing this:\n  bs = []\n  set as \\<subseteq> {Grave}\n  set bs \\<subseteq> {Macron}\n  set cs \\<subseteq> {Acute}\n  ds = as @ bs @ cs\n  as = []\n  d = Acute\n  \\<lbrakk>set [] \\<subseteq> {Grave}; set [] \\<subseteq> {Macron};\n   set (d # cs) \\<subseteq> {Acute}; d # ds = [] @ [] @ d # cs\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>a list. bs = a # list \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. bs = a # list \\<Longrightarrow> thesis", "case (Cons b bs)"], ["proof (state)\nthis:\n  bs__ = b # bs\n\ngoal (1 subgoal):\n 1. \\<And>a list. bs__ = a # list \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  bs__ = b # bs\n\ngoal (1 subgoal):\n 1. thesis", "using * as Acute IH(4)[of \"[]\" \"bs @ cs\"]"], ["proof (prove)\nusing this:\n  bs__ = b # bs\n  set as \\<subseteq> {Grave}\n  set bs__ \\<subseteq> {Macron}\n  set cs \\<subseteq> {Acute}\n  ds = as @ bs__ @ cs\n  as = []\n  d = Acute\n  d # ds = [] @ ([Acute] @ [Macron]) @ bs @ cs \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>a list. as = a # list \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. as = a # list \\<Longrightarrow> thesis", "case (Cons a as)"], ["proof (state)\nthis:\n  as__ = a # as\n\ngoal (1 subgoal):\n 1. \\<And>a list. as__ = a # list \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  as__ = a # as\n\ngoal (1 subgoal):\n 1. thesis", "using * Acute IH(3)[of \"[]\" \"as @ bs @ cs\"]"], ["proof (prove)\nusing this:\n  as__ = a # as\n  set as__ \\<subseteq> {Grave}\n  set bs \\<subseteq> {Macron}\n  set cs \\<subseteq> {Acute}\n  ds = as__ @ bs @ cs\n  d = Acute\n  d # ds = [] @ ([Acute] @ [Grave]) @ as @ bs @ cs \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<And>as bs cs.\n                   \\<lbrakk>set as \\<subseteq> {Grave};\n                    set bs \\<subseteq> {Macron}; set cs \\<subseteq> {Acute};\n                    [] = as @ bs @ cs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>as bs.\n           [] = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow> thesis;\n        \\<And>as bs.\n           [] = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow> thesis;\n        \\<And>as bs.\n           [] = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed auto"], ["", "lemma map_eq_append_split:\n  assumes \"map f xs = ys1 @ ys2\"\n  obtains xs1 xs2 where \"ys1 = map f xs1\" \"ys2 = map f xs2\" \"xs = xs1 @ xs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs1 xs2.\n        \\<lbrakk>ys1 = map f xs1; ys2 = map f xs2; xs = xs1 @ xs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (insert assms, induct ys1 arbitrary: xs thesis)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs thesis.\n       \\<lbrakk>\\<And>xs1 xs2.\n                   \\<lbrakk>[] = map f xs1; ys2 = map f xs2;\n                    xs = xs1 @ xs2\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        map f xs = [] @ ys2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a ys1 xs thesis.\n       \\<lbrakk>\\<And>xs thesis.\n                   \\<lbrakk>\\<And>xs1 xs2.\n                               \\<lbrakk>ys1 = map f xs1; ys2 = map f xs2;\n                                xs = xs1 @ xs2\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    map f xs = ys1 @ ys2\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>xs1 xs2.\n           \\<lbrakk>a # ys1 = map f xs1; ys2 = map f xs2;\n            xs = xs1 @ xs2\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        map f xs = (a # ys1) @ ys2\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Cons y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>xs1 xs2.\n              \\<lbrakk>ys = map f xs1; ys2 = map f xs2;\n               ?xs = xs1 @ xs2\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   map f ?xs = ys @ ys2\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>y # ys = map f ?xs1.0; ys2 = map f ?xs2.0;\n   xs = ?xs1.0 @ ?xs2.0\\<rbrakk>\n  \\<Longrightarrow> thesis\n  map f xs = (y # ys) @ ys2\n\ngoal (2 subgoals):\n 1. \\<And>xs thesis.\n       \\<lbrakk>\\<And>xs1 xs2.\n                   \\<lbrakk>[] = map f xs1; ys2 = map f xs2;\n                    xs = xs1 @ xs2\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        map f xs = [] @ ys2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a ys1 xs thesis.\n       \\<lbrakk>\\<And>xs thesis.\n                   \\<lbrakk>\\<And>xs1 xs2.\n                               \\<lbrakk>ys1 = map f xs1; ys2 = map f xs2;\n                                xs = xs1 @ xs2\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    map f xs = ys1 @ ys2\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>xs1 xs2.\n           \\<lbrakk>a # ys1 = map f xs1; ys2 = map f xs2;\n            xs = xs1 @ xs2\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        map f xs = (a # ys1) @ ys2\\<rbrakk>\n       \\<Longrightarrow> thesis", "note IH = this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>xs1 xs2.\n              \\<lbrakk>ys = map f xs1; ys2 = map f xs2;\n               ?xs = xs1 @ xs2\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   map f ?xs = ys @ ys2\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>y # ys = map f ?xs1.0; ys2 = map f ?xs2.0;\n   xs = ?xs1.0 @ ?xs2.0\\<rbrakk>\n  \\<Longrightarrow> thesis\n  map f xs = (y # ys) @ ys2\n\ngoal (2 subgoals):\n 1. \\<And>xs thesis.\n       \\<lbrakk>\\<And>xs1 xs2.\n                   \\<lbrakk>[] = map f xs1; ys2 = map f xs2;\n                    xs = xs1 @ xs2\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        map f xs = [] @ ys2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a ys1 xs thesis.\n       \\<lbrakk>\\<And>xs thesis.\n                   \\<lbrakk>\\<And>xs1 xs2.\n                               \\<lbrakk>ys1 = map f xs1; ys2 = map f xs2;\n                                xs = xs1 @ xs2\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    map f xs = ys1 @ ys2\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>xs1 xs2.\n           \\<lbrakk>a # ys1 = map f xs1; ys2 = map f xs2;\n            xs = xs1 @ xs2\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        map f xs = (a # ys1) @ ys2\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> thesis\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> thesis", "case (Cons x xs')"], ["proof (state)\nthis:\n  xs = x # xs'\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> thesis\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule IH(1))"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs1 xs2.\n       \\<lbrakk>ys = map f xs1; ys2 = map f xs2; ?xs = xs1 @ xs2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. map f ?xs = ys @ ys2", "fix xs1 xs2"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs1 xs2.\n       \\<lbrakk>ys = map f xs1; ys2 = map f xs2; ?xs = xs1 @ xs2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. map f ?xs = ys @ ys2", "assume \"ys = map f xs1\" \"ys2 = map f xs2\" \"xs' = xs1 @ xs2\""], ["proof (state)\nthis:\n  ys = map f xs1\n  ys2 = map f xs2\n  xs' = xs1 @ xs2\n\ngoal (2 subgoals):\n 1. \\<And>xs1 xs2.\n       \\<lbrakk>ys = map f xs1; ys2 = map f xs2; ?xs = xs1 @ xs2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. map f ?xs = ys @ ys2", "thus ?thesis"], ["proof (prove)\nusing this:\n  ys = map f xs1\n  ys2 = map f xs2\n  xs' = xs1 @ xs2\n\ngoal (1 subgoal):\n 1. thesis", "using Cons IH(2)[of \"x # xs1\" xs2] IH(3)"], ["proof (prove)\nusing this:\n  ys = map f xs1\n  ys2 = map f xs2\n  xs' = xs1 @ xs2\n  xs = x # xs'\n  \\<lbrakk>y # ys = map f (x # xs1); ys2 = map f xs2;\n   xs = (x # xs1) @ xs2\\<rbrakk>\n  \\<Longrightarrow> thesis\n  map f xs = (y # ys) @ ys2\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. map f xs' = ys @ ys2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. map f xs' = ys @ ys2", "show \"map f xs' = ys @ ys2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f xs' = ys @ ys2", "using Cons IH(3)"], ["proof (prove)\nusing this:\n  xs = x # xs'\n  map f xs = (y # ys) @ ys2\n\ngoal (1 subgoal):\n 1. map f xs' = ys @ ys2", "by simp"], ["proof (state)\nthis:\n  map f xs' = ys @ ys2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow> thesis", "qed (insert Cons, simp)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>xs thesis.\n       \\<lbrakk>\\<And>xs1 xs2.\n                   \\<lbrakk>[] = map f xs1; ys2 = map f xs2;\n                    xs = xs1 @ xs2\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        map f xs = [] @ ys2\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed auto"], ["", "lemmas map_eq_append_splits = map_eq_append_split map_eq_append_split[OF sym]"], ["", "abbreviation \"conversion' M \\<equiv> ((\\<Union>i \\<in> M. R i) \\<union> (\\<Union>i \\<in> M. E i) \\<union> (\\<Union>i \\<in> M. L i)\\<inverse>)\\<^sup>*\""], ["", "abbreviation \"valley' M \\<equiv>  (\\<Union>i \\<in> M. R i)\\<^sup>* O (\\<Union>i \\<in> M. E i)\\<^sup>* O ((\\<Union>i \\<in> M. L i)\\<inverse>)\\<^sup>*\""], ["", "lemma conversion_to_lconv:\n  assumes \"(u, v) \\<in> conversion' M\"\n  obtains xs where \"snd ` set xs \\<subseteq> M\" and \"(u, v) \\<in> lconv xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>snd ` set xs \\<subseteq> M;\n         (u, v) \\<in> local.lconv xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  (u, v) \\<in> local.conversion' M\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>snd ` set xs \\<subseteq> M;\n         (u, v) \\<in> local.lconv xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induct arbitrary: thesis rule: converse_rtrancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       (\\<And>xs.\n           \\<lbrakk>snd ` set xs \\<subseteq> M;\n            (v, v) \\<in> local.lconv xs\\<rbrakk>\n           \\<Longrightarrow> thesis) \\<Longrightarrow>\n       thesis\n 2. \\<And>y z thesis.\n       \\<lbrakk>(y, z)\n                \\<in> \\<Union> (R ` M) \\<union> \\<Union> (E ` M) \\<union>\n                      (\\<Union> (L ` M))\\<inverse>;\n        (z, v) \\<in> local.conversion' M;\n        \\<And>thesis.\n           (\\<And>xs.\n               \\<lbrakk>snd ` set xs \\<subseteq> M;\n                (z, v) \\<in> local.lconv xs\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>xs.\n           \\<lbrakk>snd ` set xs \\<subseteq> M;\n            (y, v) \\<in> local.lconv xs\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case base"], ["proof (state)\nthis:\n  \\<lbrakk>snd ` set ?xs \\<subseteq> M;\n   (v, v) \\<in> local.lconv ?xs\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       (\\<And>xs.\n           \\<lbrakk>snd ` set xs \\<subseteq> M;\n            (v, v) \\<in> local.lconv xs\\<rbrakk>\n           \\<Longrightarrow> thesis) \\<Longrightarrow>\n       thesis\n 2. \\<And>y z thesis.\n       \\<lbrakk>(y, z)\n                \\<in> \\<Union> (R ` M) \\<union> \\<Union> (E ` M) \\<union>\n                      (\\<Union> (L ` M))\\<inverse>;\n        (z, v) \\<in> local.conversion' M;\n        \\<And>thesis.\n           (\\<And>xs.\n               \\<lbrakk>snd ` set xs \\<subseteq> M;\n                (z, v) \\<in> local.lconv xs\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>xs.\n           \\<lbrakk>snd ` set xs \\<subseteq> M;\n            (y, v) \\<in> local.lconv xs\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using base[of \"[]\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>snd ` set [] \\<subseteq> M; (v, v) \\<in> local.lconv []\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>y z thesis.\n       \\<lbrakk>(y, z)\n                \\<in> \\<Union> (R ` M) \\<union> \\<Union> (E ` M) \\<union>\n                      (\\<Union> (L ` M))\\<inverse>;\n        (z, v) \\<in> local.conversion' M;\n        \\<And>thesis.\n           (\\<And>xs.\n               \\<lbrakk>snd ` set xs \\<subseteq> M;\n                (z, v) \\<in> local.lconv xs\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>xs.\n           \\<lbrakk>snd ` set xs \\<subseteq> M;\n            (y, v) \\<in> local.lconv xs\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z thesis.\n       \\<lbrakk>(y, z)\n                \\<in> \\<Union> (R ` M) \\<union> \\<Union> (E ` M) \\<union>\n                      (\\<Union> (L ` M))\\<inverse>;\n        (z, v) \\<in> local.conversion' M;\n        \\<And>thesis.\n           (\\<And>xs.\n               \\<lbrakk>snd ` set xs \\<subseteq> M;\n                (z, v) \\<in> local.lconv xs\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>xs.\n           \\<lbrakk>snd ` set xs \\<subseteq> M;\n            (y, v) \\<in> local.lconv xs\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (step u' x)"], ["proof (state)\nthis:\n  (u', x)\n  \\<in> \\<Union> (R ` M) \\<union> \\<Union> (E ` M) \\<union>\n        (\\<Union> (L ` M))\\<inverse>\n  (x, v) \\<in> local.conversion' M\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> M;\n       (x, v) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  \\<lbrakk>snd ` set ?xs \\<subseteq> M;\n   (u', v) \\<in> local.lconv ?xs\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<And>y z thesis.\n       \\<lbrakk>(y, z)\n                \\<in> \\<Union> (R ` M) \\<union> \\<Union> (E ` M) \\<union>\n                      (\\<Union> (L ` M))\\<inverse>;\n        (z, v) \\<in> local.conversion' M;\n        \\<And>thesis.\n           (\\<And>xs.\n               \\<lbrakk>snd ` set xs \\<subseteq> M;\n                (z, v) \\<in> local.lconv xs\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>xs.\n           \\<lbrakk>snd ` set xs \\<subseteq> M;\n            (y, v) \\<in> local.lconv xs\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "from step(1)"], ["proof (chain)\npicking this:\n  (u', x)\n  \\<in> \\<Union> (R ` M) \\<union> \\<Union> (E ` M) \\<union>\n        (\\<Union> (L ` M))\\<inverse>", "obtain p where \"snd p \\<in> M\" and \"(u', x) \\<in> lstep p\""], ["proof (prove)\nusing this:\n  (u', x)\n  \\<in> \\<Union> (R ` M) \\<union> \\<Union> (E ` M) \\<union>\n        (\\<Union> (L ` M))\\<inverse>\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>snd p \\<in> M; (u', x) \\<in> local.lstep p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (force split: accent.splits)"], ["proof (state)\nthis:\n  snd p \\<in> M\n  (u', x) \\<in> local.lstep p\n\ngoal (1 subgoal):\n 1. \\<And>y z thesis.\n       \\<lbrakk>(y, z)\n                \\<in> \\<Union> (R ` M) \\<union> \\<Union> (E ` M) \\<union>\n                      (\\<Union> (L ` M))\\<inverse>;\n        (z, v) \\<in> local.conversion' M;\n        \\<And>thesis.\n           (\\<And>xs.\n               \\<lbrakk>snd ` set xs \\<subseteq> M;\n                (z, v) \\<in> local.lconv xs\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>xs.\n           \\<lbrakk>snd ` set xs \\<subseteq> M;\n            (y, v) \\<in> local.lconv xs\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  snd p \\<in> M\n  (u', x) \\<in> local.lstep p\n\ngoal (1 subgoal):\n 1. \\<And>y z thesis.\n       \\<lbrakk>(y, z)\n                \\<in> \\<Union> (R ` M) \\<union> \\<Union> (E ` M) \\<union>\n                      (\\<Union> (L ` M))\\<inverse>;\n        (z, v) \\<in> local.conversion' M;\n        \\<And>thesis.\n           (\\<And>xs.\n               \\<lbrakk>snd ` set xs \\<subseteq> M;\n                (z, v) \\<in> local.lconv xs\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>xs.\n           \\<lbrakk>snd ` set xs \\<subseteq> M;\n            (y, v) \\<in> local.lconv xs\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain xs where \"snd ` set xs \\<subseteq> M\" \"(x, v) \\<in> lconv xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>snd ` set xs \\<subseteq> M;\n         (x, v) \\<in> local.lconv xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule step(3))"], ["proof (state)\nthis:\n  snd ` set xs \\<subseteq> M\n  (x, v) \\<in> local.lconv xs\n\ngoal (1 subgoal):\n 1. \\<And>y z thesis.\n       \\<lbrakk>(y, z)\n                \\<in> \\<Union> (R ` M) \\<union> \\<Union> (E ` M) \\<union>\n                      (\\<Union> (L ` M))\\<inverse>;\n        (z, v) \\<in> local.conversion' M;\n        \\<And>thesis.\n           (\\<And>xs.\n               \\<lbrakk>snd ` set xs \\<subseteq> M;\n                (z, v) \\<in> local.lconv xs\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>xs.\n           \\<lbrakk>snd ` set xs \\<subseteq> M;\n            (y, v) \\<in> local.lconv xs\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  snd p \\<in> M\n  (u', x) \\<in> local.lstep p\n  snd ` set xs \\<subseteq> M\n  (x, v) \\<in> local.lconv xs", "show ?case"], ["proof (prove)\nusing this:\n  snd p \\<in> M\n  (u', x) \\<in> local.lstep p\n  snd ` set xs \\<subseteq> M\n  (x, v) \\<in> local.lconv xs\n\ngoal (1 subgoal):\n 1. thesis", "using step(4)[of \"p # xs\"]"], ["proof (prove)\nusing this:\n  snd p \\<in> M\n  (u', x) \\<in> local.lstep p\n  snd ` set xs \\<subseteq> M\n  (x, v) \\<in> local.lconv xs\n  \\<lbrakk>snd ` set (p # xs) \\<subseteq> M;\n   (u', v) \\<in> local.lconv (p # xs)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "definition lpeak :: \"'b rel \\<Rightarrow> 'b \\<Rightarrow> 'b \\<Rightarrow> 'b greek \\<Rightarrow> bool\" where\n  \"lpeak r a b xs \\<longleftrightarrow> (\\<exists>as b' cs a' bs. snd ` set as \\<subseteq> under r a \\<and> b' \\<in> {[(Grave,b)],[]} \\<and>\n    snd ` set cs \\<subseteq> under r a \\<union> under r b \\<and> a' \\<in> {[(Acute,a)],[]} \\<and>\n    snd ` set bs \\<subseteq> under r b \\<and> xs = as @ b' @ cs @ a' @ bs)\""], ["", "definition lcliff :: \"'b rel \\<Rightarrow> 'b \\<Rightarrow> 'b \\<Rightarrow> 'b greek \\<Rightarrow> bool\" where\n  \"lcliff r a b xs \\<longleftrightarrow> (\\<exists>as b' cs a' bs. snd ` set as \\<subseteq> under r a \\<and> b' = [(Macron,b)] \\<and>\n    snd ` set cs \\<subseteq> under r a \\<and> a' \\<in> {[(Acute,a)],[]} \\<and>\n    snd ` set bs \\<subseteq> under r a \\<inter> under r b \\<and> xs = as @ b' @ cs @ a' @ bs) \\<or>\n    (\\<exists>cs a' bs. snd ` set cs \\<subseteq> under r a \\<union> under r b \\<and> a' \\<in> {[(Acute,a)],[]} \\<and>\n    snd ` set bs \\<subseteq> under r b \\<and> xs = cs @ a' @ bs)\""], ["", "definition rcliff :: \"'b rel \\<Rightarrow> 'b \\<Rightarrow> 'b \\<Rightarrow> 'b greek \\<Rightarrow> bool\" where\n  \"rcliff r a b xs \\<longleftrightarrow> (\\<exists>as b' cs a' bs. snd ` set as \\<subseteq> under r a \\<inter> under r b \\<and> b' \\<in> {[(Grave,b)],[]} \\<and>\n    snd ` set cs \\<subseteq> under r b \\<and> a' = [(Macron,a)] \\<and>\n    snd ` set bs \\<subseteq> under r b \\<and> xs = as @ b' @ cs @ a' @ bs) \\<or>\n    (\\<exists>as b' cs. snd ` set as \\<subseteq> under r a \\<and> b' \\<in> {[(Grave,b)],[]} \\<and>\n    snd ` set cs \\<subseteq> under r a \\<union> under r b \\<and> xs = as @ b' @ cs)\""], ["", "lemma dd_commute_modulo_conv[case_names wf trans peak lcliff rcliff]:\n  assumes \"wf r\" and \"trans r\"\n  and pk: \"\\<And>a b s t u. (s, t) \\<in> L a \\<Longrightarrow> (s, u) \\<in> R b \\<Longrightarrow> \\<exists>xs. lpeak r a b xs \\<and> (t, u) \\<in> lconv xs\"\n  and lc: \"\\<And>a b s t u. (s, t) \\<in> L a \\<Longrightarrow> (s, u) \\<in> E b \\<Longrightarrow> \\<exists>xs. lcliff r a b xs \\<and> (t, u) \\<in> lconv xs\"\n  and rc: \"\\<And>a b s t u. (s, t) \\<in> (E a)\\<inverse> \\<Longrightarrow> (s, u) \\<in> R b \\<Longrightarrow> \\<exists>xs. rcliff r a b xs \\<and> (t, u) \\<in> lconv xs\"\n  shows \"conversion' UNIV \\<subseteq> valley' UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union> (range R) \\<union> \\<Union> (range E) \\<union>\n     (\\<Union> (range L))\\<inverse>)\\<^sup>*\n    \\<subseteq> (\\<Union> (range R))\\<^sup>* O\n                (\\<Union> (range E))\\<^sup>* O\n                ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "proof (intro subrelI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y)\n       \\<in> (\\<Union> (range R) \\<union> \\<Union> (range E) \\<union>\n              (\\<Union> (range L))\\<inverse>)\\<^sup>* \\<Longrightarrow>\n       (x, y)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "fix u v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y)\n       \\<in> (\\<Union> (range R) \\<union> \\<Union> (range E) \\<union>\n              (\\<Union> (range L))\\<inverse>)\\<^sup>* \\<Longrightarrow>\n       (x, y)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "assume \"(u,v) \\<in> conversion' UNIV\""], ["proof (state)\nthis:\n  (u, v)\n  \\<in> (\\<Union> (range R) \\<union> \\<Union> (range E) \\<union>\n         (\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y)\n       \\<in> (\\<Union> (range R) \\<union> \\<Union> (range E) \\<union>\n              (\\<Union> (range L))\\<inverse>)\\<^sup>* \\<Longrightarrow>\n       (x, y)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  (u, v)\n  \\<in> (\\<Union> (range R) \\<union> \\<Union> (range E) \\<union>\n         (\\<Union> (range L))\\<inverse>)\\<^sup>*", "obtain xs where \"(u, v) \\<in> lconv xs\""], ["proof (prove)\nusing this:\n  (u, v)\n  \\<in> (\\<Union> (range R) \\<union> \\<Union> (range E) \\<union>\n         (\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        (u, v) \\<in> local.lconv xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: conversion_to_lconv[of u v])"], ["proof (state)\nthis:\n  (u, v) \\<in> local.lconv xs\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y)\n       \\<in> (\\<Union> (range R) \\<union> \\<Union> (range E) \\<union>\n              (\\<Union> (range L))\\<inverse>)\\<^sup>* \\<Longrightarrow>\n       (x, y)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  (u, v) \\<in> local.lconv xs", "show \"(u, v) \\<in> valley' UNIV\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> local.lconv xs\n\ngoal (1 subgoal):\n 1. (u, v)\n    \\<in> (\\<Union> (range R))\\<^sup>* O\n          (\\<Union> (range E))\\<^sup>* O\n          ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "proof (induct xs rule: wf_induct[of \"greek_less r\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. wf (greek_less r)\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> greek_less r \\<longrightarrow>\n                   (u, v) \\<in> local.lconv y \\<longrightarrow>\n                   (u, v)\n                   \\<in> (\\<Union> (range R))\\<^sup>* O\n                         (\\<Union> (range E))\\<^sup>* O\n                         ((\\<Union> (range L))\\<inverse>)\\<^sup>*;\n        (u, v) \\<in> local.lconv x\\<rbrakk>\n       \\<Longrightarrow> (u, v)\n                         \\<in> (\\<Union> (range R))\\<^sup>* O\n                               (\\<Union> (range E))\\<^sup>* O\n                               ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. wf (greek_less r)\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> greek_less r \\<longrightarrow>\n                   (u, v) \\<in> local.lconv y \\<longrightarrow>\n                   (u, v)\n                   \\<in> (\\<Union> (range R))\\<^sup>* O\n                         (\\<Union> (range E))\\<^sup>* O\n                         ((\\<Union> (range L))\\<inverse>)\\<^sup>*;\n        (u, v) \\<in> local.lconv x\\<rbrakk>\n       \\<Longrightarrow> (u, v)\n                         \\<in> (\\<Union> (range R))\\<^sup>* O\n                               (\\<Union> (range E))\\<^sup>* O\n                               ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (greek_less r)", "using wf_greek_less[OF \\<open>wf r\\<close> \\<open>trans r\\<close>]"], ["proof (prove)\nusing this:\n  wf (greek_less r)\n\ngoal (1 subgoal):\n 1. wf (greek_less r)", "."], ["proof (state)\nthis:\n  wf (greek_less r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> greek_less r \\<longrightarrow>\n                   (u, v) \\<in> local.lconv y \\<longrightarrow>\n                   (u, v)\n                   \\<in> (\\<Union> (range R))\\<^sup>* O\n                         (\\<Union> (range E))\\<^sup>* O\n                         ((\\<Union> (range L))\\<inverse>)\\<^sup>*;\n        (u, v) \\<in> local.lconv x\\<rbrakk>\n       \\<Longrightarrow> (u, v)\n                         \\<in> (\\<Union> (range R))\\<^sup>* O\n                               (\\<Union> (range E))\\<^sup>* O\n                               ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> greek_less r \\<longrightarrow>\n                   (u, v) \\<in> local.lconv y \\<longrightarrow>\n                   (u, v)\n                   \\<in> (\\<Union> (range R))\\<^sup>* O\n                         (\\<Union> (range E))\\<^sup>* O\n                         ((\\<Union> (range L))\\<inverse>)\\<^sup>*;\n        (u, v) \\<in> local.lconv x\\<rbrakk>\n       \\<Longrightarrow> (u, v)\n                         \\<in> (\\<Union> (range R))\\<^sup>* O\n                               (\\<Union> (range E))\\<^sup>* O\n                               ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "case (2 xs)"], ["proof (state)\nthis:\n  \\<forall>y.\n     (y, xs) \\<in> greek_less r \\<longrightarrow>\n     (u, v) \\<in> local.lconv y \\<longrightarrow>\n     (u, v)\n     \\<in> (\\<Union> (range R))\\<^sup>* O\n           (\\<Union> (range E))\\<^sup>* O\n           ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n  (u, v) \\<in> local.lconv xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> greek_less r \\<longrightarrow>\n                   (u, v) \\<in> local.lconv y \\<longrightarrow>\n                   (u, v)\n                   \\<in> (\\<Union> (range R))\\<^sup>* O\n                         (\\<Union> (range E))\\<^sup>* O\n                         ((\\<Union> (range L))\\<inverse>)\\<^sup>*;\n        (u, v) \\<in> local.lconv x\\<rbrakk>\n       \\<Longrightarrow> (u, v)\n                         \\<in> (\\<Union> (range R))\\<^sup>* O\n                               (\\<Union> (range E))\\<^sup>* O\n                               ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v)\n    \\<in> (\\<Union> (range R))\\<^sup>* O\n          (\\<Union> (range E))\\<^sup>* O\n          ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "proof (rule conversion_join_or_peak_or_cliff[of \"map fst xs\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>as bs cs.\n       \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n        set cs \\<subseteq> {Acute}; map fst xs = as @ bs @ cs\\<rbrakk>\n       \\<Longrightarrow> (u, v)\n                         \\<in> (\\<Union> (range R))\\<^sup>* O\n                               (\\<Union> (range E))\\<^sup>* O\n                               ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 3. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 4. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "fix as bs cs"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>as bs cs.\n       \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n        set cs \\<subseteq> {Acute}; map fst xs = as @ bs @ cs\\<rbrakk>\n       \\<Longrightarrow> (u, v)\n                         \\<in> (\\<Union> (range R))\\<^sup>* O\n                               (\\<Union> (range E))\\<^sup>* O\n                               ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 3. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 4. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "assume *: \"set as \\<subseteq> {Grave}\" \"set bs \\<subseteq> {Macron}\" \"set cs \\<subseteq> {Acute}\" \"map fst xs = as @ bs @ cs\""], ["proof (state)\nthis:\n  set as \\<subseteq> {Grave}\n  set bs \\<subseteq> {Macron}\n  set cs \\<subseteq> {Acute}\n  map fst xs = as @ bs @ cs\n\ngoal (4 subgoals):\n 1. \\<And>as bs cs.\n       \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n        set cs \\<subseteq> {Acute}; map fst xs = as @ bs @ cs\\<rbrakk>\n       \\<Longrightarrow> (u, v)\n                         \\<in> (\\<Union> (range R))\\<^sup>* O\n                               (\\<Union> (range E))\\<^sup>* O\n                               ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 3. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 4. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  set as \\<subseteq> {Grave}\n  set bs \\<subseteq> {Macron}\n  set cs \\<subseteq> {Acute}\n  map fst xs = as @ bs @ cs", "show \"(u, v) \\<in> valley' UNIV\""], ["proof (prove)\nusing this:\n  set as \\<subseteq> {Grave}\n  set bs \\<subseteq> {Macron}\n  set cs \\<subseteq> {Acute}\n  map fst xs = as @ bs @ cs\n\ngoal (1 subgoal):\n 1. (u, v)\n    \\<in> (\\<Union> (range R))\\<^sup>* O\n          (\\<Union> (range E))\\<^sup>* O\n          ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "proof (elim map_eq_append_splits)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs1 xs2 xs1a xs2a.\n       \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n        set cs \\<subseteq> {Acute}; as = map fst xs1; xs = xs1 @ xs2;\n        bs = map fst xs1a; cs = map fst xs2a; xs2 = xs1a @ xs2a\\<rbrakk>\n       \\<Longrightarrow> (u, v)\n                         \\<in> (\\<Union> (range R))\\<^sup>* O\n                               (\\<Union> (range E))\\<^sup>* O\n                               ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "fix as' bs' cs' bcs'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs1 xs2 xs1a xs2a.\n       \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n        set cs \\<subseteq> {Acute}; as = map fst xs1; xs = xs1 @ xs2;\n        bs = map fst xs1a; cs = map fst xs2a; xs2 = xs1a @ xs2a\\<rbrakk>\n       \\<Longrightarrow> (u, v)\n                         \\<in> (\\<Union> (range R))\\<^sup>* O\n                               (\\<Union> (range E))\\<^sup>* O\n                               ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "assume as: \"set as \\<subseteq> {Grave}\" \"as = map fst as'\" and\n          bs: \"set bs \\<subseteq> {Macron}\" \"bs = map fst bs'\" and\n          cs: \"set cs \\<subseteq> {Acute}\" \"cs = map fst cs'\" and\n          xs: \"xs = as' @ bcs'\" \"bcs' = bs' @ cs'\""], ["proof (state)\nthis:\n  set as \\<subseteq> {Grave}\n  as = map fst as'\n  set bs \\<subseteq> {Macron}\n  bs = map fst bs'\n  set cs \\<subseteq> {Acute}\n  cs = map fst cs'\n  xs = as' @ bcs'\n  bcs' = bs' @ cs'\n\ngoal (1 subgoal):\n 1. \\<And>xs1 xs2 xs1a xs2a.\n       \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n        set cs \\<subseteq> {Acute}; as = map fst xs1; xs = xs1 @ xs2;\n        bs = map fst xs1a; cs = map fst xs2a; xs2 = xs1a @ xs2a\\<rbrakk>\n       \\<Longrightarrow> (u, v)\n                         \\<in> (\\<Union> (range R))\\<^sup>* O\n                               (\\<Union> (range E))\\<^sup>* O\n                               ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "from as(1)[unfolded as(2)]"], ["proof (chain)\npicking this:\n  set (map fst as') \\<subseteq> {Grave}", "have as': \"\\<And>x y. (x,y) \\<in> lconv as' \\<Longrightarrow> (x,y) \\<in> (\\<Union>a. R a)\\<^sup>*\""], ["proof (prove)\nusing this:\n  set (map fst as') \\<subseteq> {Grave}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y) \\<in> local.lconv as' \\<Longrightarrow>\n       (x, y) \\<in> (\\<Union> (range R))\\<^sup>*", "proof (induct as')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> local.lconv [];\n        set (map fst []) \\<subseteq> {Grave}\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (\\<Union> (range R))\\<^sup>*\n 2. \\<And>a as' x y.\n       \\<lbrakk>\\<And>x y.\n                   \\<lbrakk>(x, y) \\<in> local.lconv as';\n                    set (map fst as') \\<subseteq> {Grave}\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (\\<Union> (range R))\\<^sup>*;\n        (x, y) \\<in> local.lconv (a # as');\n        set (map fst (a # as')) \\<subseteq> {Grave}\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (\\<Union> (range R))\\<^sup>*", "case (Cons x' xs)"], ["proof (state)\nthis:\n  \\<lbrakk>(?x, ?y) \\<in> local.lconv xs;\n   set (map fst xs) \\<subseteq> {Grave}\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> (\\<Union> (range R))\\<^sup>*\n  (x, y) \\<in> local.lconv (x' # xs)\n  set (map fst (x' # xs)) \\<subseteq> {Grave}\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> local.lconv [];\n        set (map fst []) \\<subseteq> {Grave}\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (\\<Union> (range R))\\<^sup>*\n 2. \\<And>a as' x y.\n       \\<lbrakk>\\<And>x y.\n                   \\<lbrakk>(x, y) \\<in> local.lconv as';\n                    set (map fst as') \\<subseteq> {Grave}\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (\\<Union> (range R))\\<^sup>*;\n        (x, y) \\<in> local.lconv (a # as');\n        set (map fst (a # as')) \\<subseteq> {Grave}\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (\\<Union> (range R))\\<^sup>*", "have \"\\<And>x y z i. (x,y) \\<in> R i \\<Longrightarrow> (y,z) \\<in> (\\<Union>a. R a)\\<^sup>* \\<Longrightarrow> (x,z) \\<in> (\\<Union>a. R a)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z i.\n       \\<lbrakk>(x, y) \\<in> R i;\n        (y, z) \\<in> (\\<Union> (range R))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> (\\<Union> (range R))\\<^sup>*", "by (rule rtrancl_trans) auto"], ["proof (state)\nthis:\n  \\<lbrakk>(?x, ?y) \\<in> R ?i;\n   (?y, ?z) \\<in> (\\<Union> (range R))\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> (?x, ?z) \\<in> (\\<Union> (range R))\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> local.lconv [];\n        set (map fst []) \\<subseteq> {Grave}\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (\\<Union> (range R))\\<^sup>*\n 2. \\<And>a as' x y.\n       \\<lbrakk>\\<And>x y.\n                   \\<lbrakk>(x, y) \\<in> local.lconv as';\n                    set (map fst as') \\<subseteq> {Grave}\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (\\<Union> (range R))\\<^sup>*;\n        (x, y) \\<in> local.lconv (a # as');\n        set (map fst (a # as')) \\<subseteq> {Grave}\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (\\<Union> (range R))\\<^sup>*", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?x, ?y) \\<in> local.lconv xs;\n   set (map fst xs) \\<subseteq> {Grave}\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> (\\<Union> (range R))\\<^sup>*\n  (x, y) \\<in> local.lconv (x' # xs)\n  set (map fst (x' # xs)) \\<subseteq> {Grave}\n  \\<lbrakk>(?x, ?y) \\<in> R ?i;\n   (?y, ?z) \\<in> (\\<Union> (range R))\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> (?x, ?z) \\<in> (\\<Union> (range R))\\<^sup>*", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x, ?y) \\<in> local.lconv xs;\n   set (map fst xs) \\<subseteq> {Grave}\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> (\\<Union> (range R))\\<^sup>*\n  (x, y) \\<in> local.lconv (x' # xs)\n  set (map fst (x' # xs)) \\<subseteq> {Grave}\n  \\<lbrakk>(?x, ?y) \\<in> R ?i;\n   (?y, ?z) \\<in> (\\<Union> (range R))\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> (?x, ?z) \\<in> (\\<Union> (range R))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (\\<Union> (range R))\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (x, y) \\<in> (\\<Union> (range R))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> local.lconv [];\n        set (map fst []) \\<subseteq> {Grave}\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (\\<Union> (range R))\\<^sup>*", "qed simp"], ["proof (state)\nthis:\n  (?x, ?y) \\<in> local.lconv as' \\<Longrightarrow>\n  (?x, ?y) \\<in> (\\<Union> (range R))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>xs1 xs2 xs1a xs2a.\n       \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n        set cs \\<subseteq> {Acute}; as = map fst xs1; xs = xs1 @ xs2;\n        bs = map fst xs1a; cs = map fst xs2a; xs2 = xs1a @ xs2a\\<rbrakk>\n       \\<Longrightarrow> (u, v)\n                         \\<in> (\\<Union> (range R))\\<^sup>* O\n                               (\\<Union> (range E))\\<^sup>* O\n                               ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "from bs(1)[unfolded bs(2)]"], ["proof (chain)\npicking this:\n  set (map fst bs') \\<subseteq> {Macron}", "have bs': \"\\<And>x y. (x,y) \\<in> lconv bs' \\<Longrightarrow> (x,y) \\<in> (\\<Union>a. E a)\\<^sup>*\""], ["proof (prove)\nusing this:\n  set (map fst bs') \\<subseteq> {Macron}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y) \\<in> local.lconv bs' \\<Longrightarrow>\n       (x, y) \\<in> (\\<Union> (range E))\\<^sup>*", "proof (induct bs')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> local.lconv [];\n        set (map fst []) \\<subseteq> {Macron}\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (\\<Union> (range E))\\<^sup>*\n 2. \\<And>a bs' x y.\n       \\<lbrakk>\\<And>x y.\n                   \\<lbrakk>(x, y) \\<in> local.lconv bs';\n                    set (map fst bs') \\<subseteq> {Macron}\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (\\<Union> (range E))\\<^sup>*;\n        (x, y) \\<in> local.lconv (a # bs');\n        set (map fst (a # bs')) \\<subseteq> {Macron}\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (\\<Union> (range E))\\<^sup>*", "case (Cons x' xs)"], ["proof (state)\nthis:\n  \\<lbrakk>(?x, ?y) \\<in> local.lconv xs;\n   set (map fst xs) \\<subseteq> {Macron}\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> (\\<Union> (range E))\\<^sup>*\n  (x, y) \\<in> local.lconv (x' # xs)\n  set (map fst (x' # xs)) \\<subseteq> {Macron}\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> local.lconv [];\n        set (map fst []) \\<subseteq> {Macron}\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (\\<Union> (range E))\\<^sup>*\n 2. \\<And>a bs' x y.\n       \\<lbrakk>\\<And>x y.\n                   \\<lbrakk>(x, y) \\<in> local.lconv bs';\n                    set (map fst bs') \\<subseteq> {Macron}\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (\\<Union> (range E))\\<^sup>*;\n        (x, y) \\<in> local.lconv (a # bs');\n        set (map fst (a # bs')) \\<subseteq> {Macron}\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (\\<Union> (range E))\\<^sup>*", "have \"\\<And>x y z i. (x,y) \\<in> E i \\<Longrightarrow> (y,z) \\<in> (\\<Union>a. E a)\\<^sup>* \\<Longrightarrow> (x,z) \\<in> (\\<Union>a. E a)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z i.\n       \\<lbrakk>(x, y) \\<in> E i;\n        (y, z) \\<in> (\\<Union> (range E))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> (\\<Union> (range E))\\<^sup>*", "by (rule rtrancl_trans) auto"], ["proof (state)\nthis:\n  \\<lbrakk>(?x, ?y) \\<in> E ?i;\n   (?y, ?z) \\<in> (\\<Union> (range E))\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> (?x, ?z) \\<in> (\\<Union> (range E))\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> local.lconv [];\n        set (map fst []) \\<subseteq> {Macron}\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (\\<Union> (range E))\\<^sup>*\n 2. \\<And>a bs' x y.\n       \\<lbrakk>\\<And>x y.\n                   \\<lbrakk>(x, y) \\<in> local.lconv bs';\n                    set (map fst bs') \\<subseteq> {Macron}\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> (\\<Union> (range E))\\<^sup>*;\n        (x, y) \\<in> local.lconv (a # bs');\n        set (map fst (a # bs')) \\<subseteq> {Macron}\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (\\<Union> (range E))\\<^sup>*", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?x, ?y) \\<in> local.lconv xs;\n   set (map fst xs) \\<subseteq> {Macron}\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> (\\<Union> (range E))\\<^sup>*\n  (x, y) \\<in> local.lconv (x' # xs)\n  set (map fst (x' # xs)) \\<subseteq> {Macron}\n  \\<lbrakk>(?x, ?y) \\<in> E ?i;\n   (?y, ?z) \\<in> (\\<Union> (range E))\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> (?x, ?z) \\<in> (\\<Union> (range E))\\<^sup>*", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x, ?y) \\<in> local.lconv xs;\n   set (map fst xs) \\<subseteq> {Macron}\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> (\\<Union> (range E))\\<^sup>*\n  (x, y) \\<in> local.lconv (x' # xs)\n  set (map fst (x' # xs)) \\<subseteq> {Macron}\n  \\<lbrakk>(?x, ?y) \\<in> E ?i;\n   (?y, ?z) \\<in> (\\<Union> (range E))\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> (?x, ?z) \\<in> (\\<Union> (range E))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (\\<Union> (range E))\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (x, y) \\<in> (\\<Union> (range E))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> local.lconv [];\n        set (map fst []) \\<subseteq> {Macron}\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> (\\<Union> (range E))\\<^sup>*", "qed simp"], ["proof (state)\nthis:\n  (?x, ?y) \\<in> local.lconv bs' \\<Longrightarrow>\n  (?x, ?y) \\<in> (\\<Union> (range E))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>xs1 xs2 xs1a xs2a.\n       \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n        set cs \\<subseteq> {Acute}; as = map fst xs1; xs = xs1 @ xs2;\n        bs = map fst xs1a; cs = map fst xs2a; xs2 = xs1a @ xs2a\\<rbrakk>\n       \\<Longrightarrow> (u, v)\n                         \\<in> (\\<Union> (range R))\\<^sup>* O\n                               (\\<Union> (range E))\\<^sup>* O\n                               ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "from cs(1)[unfolded cs(2)]"], ["proof (chain)\npicking this:\n  set (map fst cs') \\<subseteq> {Acute}", "have cs': \"\\<And>x y. (x,y) \\<in> lconv cs' \\<Longrightarrow> (x,y) \\<in> ((\\<Union>a. L a)\\<inverse>)\\<^sup>*\""], ["proof (prove)\nusing this:\n  set (map fst cs') \\<subseteq> {Acute}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y) \\<in> local.lconv cs' \\<Longrightarrow>\n       (x, y) \\<in> ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "proof (induct cs')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> local.lconv [];\n        set (map fst []) \\<subseteq> {Acute}\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>a cs' x y.\n       \\<lbrakk>\\<And>x y.\n                   \\<lbrakk>(x, y) \\<in> local.lconv cs';\n                    set (map fst cs') \\<subseteq> {Acute}\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> ((\\<Union>\n        (range L))\\<inverse>)\\<^sup>*;\n        (x, y) \\<in> local.lconv (a # cs');\n        set (map fst (a # cs')) \\<subseteq> {Acute}\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "case (Cons x' xs)"], ["proof (state)\nthis:\n  \\<lbrakk>(?x, ?y) \\<in> local.lconv xs;\n   set (map fst xs) \\<subseteq> {Acute}\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n  (x, y) \\<in> local.lconv (x' # xs)\n  set (map fst (x' # xs)) \\<subseteq> {Acute}\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> local.lconv [];\n        set (map fst []) \\<subseteq> {Acute}\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>a cs' x y.\n       \\<lbrakk>\\<And>x y.\n                   \\<lbrakk>(x, y) \\<in> local.lconv cs';\n                    set (map fst cs') \\<subseteq> {Acute}\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> ((\\<Union>\n        (range L))\\<inverse>)\\<^sup>*;\n        (x, y) \\<in> local.lconv (a # cs');\n        set (map fst (a # cs')) \\<subseteq> {Acute}\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "have \"\\<And>x y z i. (x,y) \\<in> (L i)\\<inverse> \\<Longrightarrow> (y,z) \\<in> ((\\<Union>a. L a)\\<inverse>)\\<^sup>* \\<Longrightarrow> (x,z) \\<in> ((\\<Union>a. L a)\\<inverse>)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z i.\n       \\<lbrakk>(x, y) \\<in> (L i)\\<inverse>;\n        (y, z) \\<in> ((\\<Union> (range L))\\<inverse>)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (x, z)\n                         \\<in> ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "by (rule rtrancl_trans) auto"], ["proof (state)\nthis:\n  \\<lbrakk>(?x, ?y) \\<in> (L ?i)\\<inverse>;\n   (?y, ?z) \\<in> ((\\<Union> (range L))\\<inverse>)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> (?x, ?z) \\<in> ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> local.lconv [];\n        set (map fst []) \\<subseteq> {Acute}\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>a cs' x y.\n       \\<lbrakk>\\<And>x y.\n                   \\<lbrakk>(x, y) \\<in> local.lconv cs';\n                    set (map fst cs') \\<subseteq> {Acute}\\<rbrakk>\n                   \\<Longrightarrow> (x, y)\n                                     \\<in> ((\\<Union>\n        (range L))\\<inverse>)\\<^sup>*;\n        (x, y) \\<in> local.lconv (a # cs');\n        set (map fst (a # cs')) \\<subseteq> {Acute}\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?x, ?y) \\<in> local.lconv xs;\n   set (map fst xs) \\<subseteq> {Acute}\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n  (x, y) \\<in> local.lconv (x' # xs)\n  set (map fst (x' # xs)) \\<subseteq> {Acute}\n  \\<lbrakk>(?x, ?y) \\<in> (L ?i)\\<inverse>;\n   (?y, ?z) \\<in> ((\\<Union> (range L))\\<inverse>)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> (?x, ?z) \\<in> ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x, ?y) \\<in> local.lconv xs;\n   set (map fst xs) \\<subseteq> {Acute}\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n  (x, y) \\<in> local.lconv (x' # xs)\n  set (map fst (x' # xs)) \\<subseteq> {Acute}\n  \\<lbrakk>(?x, ?y) \\<in> (L ?i)\\<inverse>;\n   (?y, ?z) \\<in> ((\\<Union> (range L))\\<inverse>)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> (?x, ?z) \\<in> ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (x, y) \\<in> ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> local.lconv [];\n        set (map fst []) \\<subseteq> {Acute}\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "qed simp"], ["proof (state)\nthis:\n  (?x, ?y) \\<in> local.lconv cs' \\<Longrightarrow>\n  (?x, ?y) \\<in> ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>xs1 xs2 xs1a xs2a.\n       \\<lbrakk>set as \\<subseteq> {Grave}; set bs \\<subseteq> {Macron};\n        set cs \\<subseteq> {Acute}; as = map fst xs1; xs = xs1 @ xs2;\n        bs = map fst xs1a; cs = map fst xs2a; xs2 = xs1a @ xs2a\\<rbrakk>\n       \\<Longrightarrow> (u, v)\n                         \\<in> (\\<Union> (range R))\\<^sup>* O\n                               (\\<Union> (range E))\\<^sup>* O\n                               ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "from 2(2) as' bs' cs'"], ["proof (chain)\npicking this:\n  (u, v) \\<in> local.lconv xs\n  (?x, ?y) \\<in> local.lconv as' \\<Longrightarrow>\n  (?x, ?y) \\<in> (\\<Union> (range R))\\<^sup>*\n  (?x, ?y) \\<in> local.lconv bs' \\<Longrightarrow>\n  (?x, ?y) \\<in> (\\<Union> (range E))\\<^sup>*\n  (?x, ?y) \\<in> local.lconv cs' \\<Longrightarrow>\n  (?x, ?y) \\<in> ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "show \"(u, v) \\<in> valley' UNIV\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> local.lconv xs\n  (?x, ?y) \\<in> local.lconv as' \\<Longrightarrow>\n  (?x, ?y) \\<in> (\\<Union> (range R))\\<^sup>*\n  (?x, ?y) \\<in> local.lconv bs' \\<Longrightarrow>\n  (?x, ?y) \\<in> (\\<Union> (range E))\\<^sup>*\n  (?x, ?y) \\<in> local.lconv cs' \\<Longrightarrow>\n  (?x, ?y) \\<in> ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (u, v)\n    \\<in> (\\<Union> (range R))\\<^sup>* O\n          (\\<Union> (range E))\\<^sup>* O\n          ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "unfolding xs lconv_append"], ["proof (prove)\nusing this:\n  (u, v) \\<in> local.lconv as' O local.lconv bs' O local.lconv cs'\n  (?x, ?y) \\<in> local.lconv as' \\<Longrightarrow>\n  (?x, ?y) \\<in> (\\<Union> (range R))\\<^sup>*\n  (?x, ?y) \\<in> local.lconv bs' \\<Longrightarrow>\n  (?x, ?y) \\<in> (\\<Union> (range E))\\<^sup>*\n  (?x, ?y) \\<in> local.lconv cs' \\<Longrightarrow>\n  (?x, ?y) \\<in> ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (u, v)\n    \\<in> (\\<Union> (range R))\\<^sup>* O\n          (\\<Union> (range E))\\<^sup>* O\n          ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "by auto (meson relcomp.simps)"], ["proof (state)\nthis:\n  (u, v)\n  \\<in> (\\<Union> (range R))\\<^sup>* O\n        (\\<Union> (range E))\\<^sup>* O\n        ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (u, v)\n  \\<in> (\\<Union> (range R))\\<^sup>* O\n        (\\<Union> (range E))\\<^sup>* O\n        ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (3 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 3. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 3. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "fix as bs"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 3. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "assume *: \"map fst xs = as @ ([Acute] @ [Grave]) @ bs\""], ["proof (state)\nthis:\n  map fst xs = as @ ([Acute] @ [Grave]) @ bs\n\ngoal (3 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 3. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "{"], ["proof (state)\nthis:\n  map fst xs = as @ ([Acute] @ [Grave]) @ bs\n\ngoal (3 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 3. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "fix p a b q t' s' u'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 3. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "assume xs: \"xs = p @ [(Acute,a),(Grave,b)] @ q\" and p: \"(u,t') \\<in> lconv p\"\n          and a: \"(s',t') \\<in> L a\" and b: \"(s',u') \\<in> R b\" and q: \"(u',v) \\<in> lconv q\""], ["proof (state)\nthis:\n  xs = p @ [(Acute, a), (Grave, b)] @ q\n  (u, t') \\<in> local.lconv p\n  (s', t') \\<in> L a\n  (s', u') \\<in> R b\n  (u', v) \\<in> local.lconv q\n\ngoal (3 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 3. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "obtain js where lp: \"lpeak r a b js\" and js: \"(t',u') \\<in> lconv js\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>js.\n        \\<lbrakk>local.lpeak r a b js;\n         (t', u') \\<in> local.lconv js\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using pk[OF a b]"], ["proof (prove)\nusing this:\n  \\<exists>xs. local.lpeak r a b xs \\<and> (t', u') \\<in> local.lconv xs\n\ngoal (1 subgoal):\n 1. (\\<And>js.\n        \\<lbrakk>local.lpeak r a b js;\n         (t', u') \\<in> local.lconv js\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  local.lpeak r a b js\n  (t', u') \\<in> local.lconv js\n\ngoal (3 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 3. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "from lp"], ["proof (chain)\npicking this:\n  local.lpeak r a b js", "have \"(js, [(Acute,a),(Grave,b)]) \\<in> greek_less r\""], ["proof (prove)\nusing this:\n  local.lpeak r a b js\n\ngoal (1 subgoal):\n 1. (js, [(Acute, a), (Grave, b)]) \\<in> greek_less r", "unfolding lpeak_def"], ["proof (prove)\nusing this:\n  \\<exists>as b' cs a' bs.\n     snd ` set as \\<subseteq> under r a \\<and>\n     b' \\<in> {[(Grave, b)], []} \\<and>\n     snd ` set cs \\<subseteq> under r a \\<union> under r b \\<and>\n     a' \\<in> {[(Acute, a)], []} \\<and>\n     snd ` set bs \\<subseteq> under r b \\<and> js = as @ b' @ cs @ a' @ bs\n\ngoal (1 subgoal):\n 1. (js, [(Acute, a), (Grave, b)]) \\<in> greek_less r", "using peak_greek_less[of _ r a _ b]"], ["proof (prove)\nusing this:\n  \\<exists>as b' cs a' bs.\n     snd ` set as \\<subseteq> under r a \\<and>\n     b' \\<in> {[(Grave, b)], []} \\<and>\n     snd ` set cs \\<subseteq> under r a \\<union> under r b \\<and>\n     a' \\<in> {[(Acute, a)], []} \\<and>\n     snd ` set bs \\<subseteq> under r b \\<and> js = as @ b' @ cs @ a' @ bs\n  \\<lbrakk>snd ` set ?as \\<subseteq> under r a;\n   ?b' \\<in> {[(Grave, b)], []};\n   snd ` set ?cs \\<subseteq> under r a \\<union> under r b;\n   ?a' \\<in> {[(Acute, a)], []};\n   snd ` set ?bs \\<subseteq> under r b\\<rbrakk>\n  \\<Longrightarrow> (?as @ ?b' @ ?cs @ ?a' @ ?bs, [(Acute, a), (Grave, b)])\n                    \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. (js, [(Acute, a), (Grave, b)]) \\<in> greek_less r", "by fastforce"], ["proof (state)\nthis:\n  (js, [(Acute, a), (Grave, b)]) \\<in> greek_less r\n\ngoal (3 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 3. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  (js, [(Acute, a), (Grave, b)]) \\<in> greek_less r", "have \"(p @ js @ q, xs) \\<in> greek_less r\""], ["proof (prove)\nusing this:\n  (js, [(Acute, a), (Grave, b)]) \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. (p @ js @ q, xs) \\<in> greek_less r", "unfolding xs"], ["proof (prove)\nusing this:\n  (js, [(Acute, a), (Grave, b)]) \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. (p @ js @ q, p @ [(Acute, a), (Grave, b)] @ q) \\<in> greek_less r", "by (intro greek_less_app_mono1 greek_less_app_mono2 \\<open>trans r\\<close>) auto"], ["proof (state)\nthis:\n  (p @ js @ q, xs) \\<in> greek_less r\n\ngoal (3 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 3. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "moreover"], ["proof (state)\nthis:\n  (p @ js @ q, xs) \\<in> greek_less r\n\ngoal (3 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 3. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "have \"(u, v) \\<in> lconv (p @ js @ q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> local.lconv (p @ js @ q)", "using p q js"], ["proof (prove)\nusing this:\n  (u, t') \\<in> local.lconv p\n  (u', v) \\<in> local.lconv q\n  (t', u') \\<in> local.lconv js\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> local.lconv (p @ js @ q)", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<in> local.lconv (p @ js @ q)\n\ngoal (3 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 3. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "ultimately"], ["proof (chain)\npicking this:\n  (p @ js @ q, xs) \\<in> greek_less r\n  (u, v) \\<in> local.lconv (p @ js @ q)", "have \"(u, v) \\<in> valley' UNIV\""], ["proof (prove)\nusing this:\n  (p @ js @ q, xs) \\<in> greek_less r\n  (u, v) \\<in> local.lconv (p @ js @ q)\n\ngoal (1 subgoal):\n 1. (u, v)\n    \\<in> (\\<Union> (range R))\\<^sup>* O\n          (\\<Union> (range E))\\<^sup>* O\n          ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "using 2(1)"], ["proof (prove)\nusing this:\n  (p @ js @ q, xs) \\<in> greek_less r\n  (u, v) \\<in> local.lconv (p @ js @ q)\n  \\<forall>y.\n     (y, xs) \\<in> greek_less r \\<longrightarrow>\n     (u, v) \\<in> local.lconv y \\<longrightarrow>\n     (u, v)\n     \\<in> (\\<Union> (range R))\\<^sup>* O\n           (\\<Union> (range E))\\<^sup>* O\n           ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (u, v)\n    \\<in> (\\<Union> (range R))\\<^sup>* O\n          (\\<Union> (range E))\\<^sup>* O\n          ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "by blast"], ["proof (state)\nthis:\n  (u, v)\n  \\<in> (\\<Union> (range R))\\<^sup>* O\n        (\\<Union> (range E))\\<^sup>* O\n        ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (3 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 3. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "}"], ["proof (state)\nthis:\n  \\<lbrakk>xs = ?p2 @ [(Acute, ?a2), (Grave, ?b2)] @ ?q2;\n   (u, ?t'2) \\<in> local.lconv ?p2; (?s'2, ?t'2) \\<in> L ?a2;\n   (?s'2, ?u'2) \\<in> R ?b2; (?u'2, v) \\<in> local.lconv ?q2\\<rbrakk>\n  \\<Longrightarrow> (u, v)\n                    \\<in> (\\<Union> (range R))\\<^sup>* O\n                          (\\<Union> (range E))\\<^sup>* O\n                          ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (3 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 3. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "with *"], ["proof (chain)\npicking this:\n  map fst xs = as @ ([Acute] @ [Grave]) @ bs\n  \\<lbrakk>xs = ?p2 @ [(Acute, ?a2), (Grave, ?b2)] @ ?q2;\n   (u, ?t'2) \\<in> local.lconv ?p2; (?s'2, ?t'2) \\<in> L ?a2;\n   (?s'2, ?u'2) \\<in> R ?b2; (?u'2, v) \\<in> local.lconv ?q2\\<rbrakk>\n  \\<Longrightarrow> (u, v)\n                    \\<in> (\\<Union> (range R))\\<^sup>* O\n                          (\\<Union> (range E))\\<^sup>* O\n                          ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "show \"(u, v) \\<in> valley' UNIV\""], ["proof (prove)\nusing this:\n  map fst xs = as @ ([Acute] @ [Grave]) @ bs\n  \\<lbrakk>xs = ?p2 @ [(Acute, ?a2), (Grave, ?b2)] @ ?q2;\n   (u, ?t'2) \\<in> local.lconv ?p2; (?s'2, ?t'2) \\<in> L ?a2;\n   (?s'2, ?u'2) \\<in> R ?b2; (?u'2, v) \\<in> local.lconv ?q2\\<rbrakk>\n  \\<Longrightarrow> (u, v)\n                    \\<in> (\\<Union> (range R))\\<^sup>* O\n                          (\\<Union> (range E))\\<^sup>* O\n                          ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (u, v)\n    \\<in> (\\<Union> (range R))\\<^sup>* O\n          (\\<Union> (range E))\\<^sup>* O\n          ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "using 2(2)"], ["proof (prove)\nusing this:\n  map fst xs = as @ ([Acute] @ [Grave]) @ bs\n  \\<lbrakk>xs = ?p2 @ [(Acute, ?a2), (Grave, ?b2)] @ ?q2;\n   (u, ?t'2) \\<in> local.lconv ?p2; (?s'2, ?t'2) \\<in> L ?a2;\n   (?s'2, ?u'2) \\<in> R ?b2; (?u'2, v) \\<in> local.lconv ?q2\\<rbrakk>\n  \\<Longrightarrow> (u, v)\n                    \\<in> (\\<Union> (range R))\\<^sup>* O\n                          (\\<Union> (range E))\\<^sup>* O\n                          ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n  (u, v) \\<in> local.lconv xs\n\ngoal (1 subgoal):\n 1. (u, v)\n    \\<in> (\\<Union> (range R))\\<^sup>* O\n          (\\<Union> (range E))\\<^sup>* O\n          ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "by (auto elim!: map_eq_append_splits relcompEpair simp del: append.simps) simp"], ["proof (state)\nthis:\n  (u, v)\n  \\<in> (\\<Union> (range R))\\<^sup>* O\n        (\\<Union> (range E))\\<^sup>* O\n        ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "fix as bs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "assume *: \"map fst xs = as @ ([Acute] @ [Macron]) @ bs\""], ["proof (state)\nthis:\n  map fst xs = as @ ([Acute] @ [Macron]) @ bs\n\ngoal (2 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "{"], ["proof (state)\nthis:\n  map fst xs = as @ ([Acute] @ [Macron]) @ bs\n\ngoal (2 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "fix p a b q t' s' u'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "assume xs: \"xs = p @ [(Acute,a),(Macron,b)] @ q\" and p: \"(u,t') \\<in> lconv p\"\n          and a: \"(s',t') \\<in> L a\" and b: \"(s',u') \\<in> E b\" and q: \"(u',v) \\<in> lconv q\""], ["proof (state)\nthis:\n  xs = p @ [(Acute, a), (Macron, b)] @ q\n  (u, t') \\<in> local.lconv p\n  (s', t') \\<in> L a\n  (s', u') \\<in> E b\n  (u', v) \\<in> local.lconv q\n\ngoal (2 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "obtain js where lp: \"lcliff r a b js\" and js: \"(t',u') \\<in> lconv js\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>js.\n        \\<lbrakk>local.lcliff r a b js;\n         (t', u') \\<in> local.lconv js\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using lc[OF a b]"], ["proof (prove)\nusing this:\n  \\<exists>xs. local.lcliff r a b xs \\<and> (t', u') \\<in> local.lconv xs\n\ngoal (1 subgoal):\n 1. (\\<And>js.\n        \\<lbrakk>local.lcliff r a b js;\n         (t', u') \\<in> local.lconv js\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  local.lcliff r a b js\n  (t', u') \\<in> local.lconv js\n\ngoal (2 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "from lp"], ["proof (chain)\npicking this:\n  local.lcliff r a b js", "have \"(js, [(Acute,a),(Macron,b)]) \\<in> greek_less r\""], ["proof (prove)\nusing this:\n  local.lcliff r a b js\n\ngoal (1 subgoal):\n 1. (js, [(Acute, a), (Macron, b)]) \\<in> greek_less r", "unfolding lcliff_def"], ["proof (prove)\nusing this:\n  (\\<exists>as b' cs a' bs.\n      snd ` set as \\<subseteq> under r a \\<and>\n      b' = [(Macron, b)] \\<and>\n      snd ` set cs \\<subseteq> under r a \\<and>\n      a' \\<in> {[(Acute, a)], []} \\<and>\n      snd ` set bs \\<subseteq> under r a \\<inter> under r b \\<and>\n      js = as @ b' @ cs @ a' @ bs) \\<or>\n  (\\<exists>cs a' bs.\n      snd ` set cs \\<subseteq> under r a \\<union> under r b \\<and>\n      a' \\<in> {[(Acute, a)], []} \\<and>\n      snd ` set bs \\<subseteq> under r b \\<and> js = cs @ a' @ bs)\n\ngoal (1 subgoal):\n 1. (js, [(Acute, a), (Macron, b)]) \\<in> greek_less r", "using lcliff_greek_less1[OF \\<open>trans r\\<close>, of _ a _ b] lcliff_greek_less2[OF \\<open>trans r\\<close>, of _ a b]"], ["proof (prove)\nusing this:\n  (\\<exists>as b' cs a' bs.\n      snd ` set as \\<subseteq> under r a \\<and>\n      b' = [(Macron, b)] \\<and>\n      snd ` set cs \\<subseteq> under r a \\<and>\n      a' \\<in> {[(Acute, a)], []} \\<and>\n      snd ` set bs \\<subseteq> under r a \\<inter> under r b \\<and>\n      js = as @ b' @ cs @ a' @ bs) \\<or>\n  (\\<exists>cs a' bs.\n      snd ` set cs \\<subseteq> under r a \\<union> under r b \\<and>\n      a' \\<in> {[(Acute, a)], []} \\<and>\n      snd ` set bs \\<subseteq> under r b \\<and> js = cs @ a' @ bs)\n  \\<lbrakk>snd ` set ?as \\<subseteq> under r a; ?b' = [(Macron, b)];\n   snd ` set ?cs \\<subseteq> under r a; ?a' \\<in> {[(Acute, a)], []};\n   snd ` set ?bs \\<subseteq> under r a \\<inter> under r b\\<rbrakk>\n  \\<Longrightarrow> (?as @ ?b' @ ?cs @ ?a' @ ?bs, [(Acute, a), (Macron, b)])\n                    \\<in> greek_less r\n  \\<lbrakk>snd ` set ?cs \\<subseteq> under r a \\<union> under r b;\n   ?a' \\<in> {[(Acute, a)], []};\n   snd ` set ?bs \\<subseteq> under r b\\<rbrakk>\n  \\<Longrightarrow> (?cs @ ?a' @ ?bs, [(Acute, a), (Macron, b)])\n                    \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. (js, [(Acute, a), (Macron, b)]) \\<in> greek_less r", "by fastforce"], ["proof (state)\nthis:\n  (js, [(Acute, a), (Macron, b)]) \\<in> greek_less r\n\ngoal (2 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  (js, [(Acute, a), (Macron, b)]) \\<in> greek_less r", "have \"(p @ js @ q, xs) \\<in> greek_less r\""], ["proof (prove)\nusing this:\n  (js, [(Acute, a), (Macron, b)]) \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. (p @ js @ q, xs) \\<in> greek_less r", "unfolding xs"], ["proof (prove)\nusing this:\n  (js, [(Acute, a), (Macron, b)]) \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. (p @ js @ q, p @ [(Acute, a), (Macron, b)] @ q) \\<in> greek_less r", "by (intro greek_less_app_mono1 greek_less_app_mono2 \\<open>trans r\\<close>) auto"], ["proof (state)\nthis:\n  (p @ js @ q, xs) \\<in> greek_less r\n\ngoal (2 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "moreover"], ["proof (state)\nthis:\n  (p @ js @ q, xs) \\<in> greek_less r\n\ngoal (2 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "have \"(u, v) \\<in> lconv (p @ js @ q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> local.lconv (p @ js @ q)", "using p q js"], ["proof (prove)\nusing this:\n  (u, t') \\<in> local.lconv p\n  (u', v) \\<in> local.lconv q\n  (t', u') \\<in> local.lconv js\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> local.lconv (p @ js @ q)", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<in> local.lconv (p @ js @ q)\n\ngoal (2 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "ultimately"], ["proof (chain)\npicking this:\n  (p @ js @ q, xs) \\<in> greek_less r\n  (u, v) \\<in> local.lconv (p @ js @ q)", "have \"(u, v) \\<in> valley' UNIV\""], ["proof (prove)\nusing this:\n  (p @ js @ q, xs) \\<in> greek_less r\n  (u, v) \\<in> local.lconv (p @ js @ q)\n\ngoal (1 subgoal):\n 1. (u, v)\n    \\<in> (\\<Union> (range R))\\<^sup>* O\n          (\\<Union> (range E))\\<^sup>* O\n          ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "using 2(1)"], ["proof (prove)\nusing this:\n  (p @ js @ q, xs) \\<in> greek_less r\n  (u, v) \\<in> local.lconv (p @ js @ q)\n  \\<forall>y.\n     (y, xs) \\<in> greek_less r \\<longrightarrow>\n     (u, v) \\<in> local.lconv y \\<longrightarrow>\n     (u, v)\n     \\<in> (\\<Union> (range R))\\<^sup>* O\n           (\\<Union> (range E))\\<^sup>* O\n           ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (u, v)\n    \\<in> (\\<Union> (range R))\\<^sup>* O\n          (\\<Union> (range E))\\<^sup>* O\n          ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "by blast"], ["proof (state)\nthis:\n  (u, v)\n  \\<in> (\\<Union> (range R))\\<^sup>* O\n        (\\<Union> (range E))\\<^sup>* O\n        ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "}"], ["proof (state)\nthis:\n  \\<lbrakk>xs = ?p2 @ [(Acute, ?a2), (Macron, ?b2)] @ ?q2;\n   (u, ?t'2) \\<in> local.lconv ?p2; (?s'2, ?t'2) \\<in> L ?a2;\n   (?s'2, ?u'2) \\<in> E ?b2; (?u'2, v) \\<in> local.lconv ?q2\\<rbrakk>\n  \\<Longrightarrow> (u, v)\n                    \\<in> (\\<Union> (range R))\\<^sup>* O\n                          (\\<Union> (range E))\\<^sup>* O\n                          ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Acute] @ [Macron]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n 2. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "with *"], ["proof (chain)\npicking this:\n  map fst xs = as @ ([Acute] @ [Macron]) @ bs\n  \\<lbrakk>xs = ?p2 @ [(Acute, ?a2), (Macron, ?b2)] @ ?q2;\n   (u, ?t'2) \\<in> local.lconv ?p2; (?s'2, ?t'2) \\<in> L ?a2;\n   (?s'2, ?u'2) \\<in> E ?b2; (?u'2, v) \\<in> local.lconv ?q2\\<rbrakk>\n  \\<Longrightarrow> (u, v)\n                    \\<in> (\\<Union> (range R))\\<^sup>* O\n                          (\\<Union> (range E))\\<^sup>* O\n                          ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "show \"(u, v) \\<in> valley' UNIV\""], ["proof (prove)\nusing this:\n  map fst xs = as @ ([Acute] @ [Macron]) @ bs\n  \\<lbrakk>xs = ?p2 @ [(Acute, ?a2), (Macron, ?b2)] @ ?q2;\n   (u, ?t'2) \\<in> local.lconv ?p2; (?s'2, ?t'2) \\<in> L ?a2;\n   (?s'2, ?u'2) \\<in> E ?b2; (?u'2, v) \\<in> local.lconv ?q2\\<rbrakk>\n  \\<Longrightarrow> (u, v)\n                    \\<in> (\\<Union> (range R))\\<^sup>* O\n                          (\\<Union> (range E))\\<^sup>* O\n                          ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (u, v)\n    \\<in> (\\<Union> (range R))\\<^sup>* O\n          (\\<Union> (range E))\\<^sup>* O\n          ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "using 2(2)"], ["proof (prove)\nusing this:\n  map fst xs = as @ ([Acute] @ [Macron]) @ bs\n  \\<lbrakk>xs = ?p2 @ [(Acute, ?a2), (Macron, ?b2)] @ ?q2;\n   (u, ?t'2) \\<in> local.lconv ?p2; (?s'2, ?t'2) \\<in> L ?a2;\n   (?s'2, ?u'2) \\<in> E ?b2; (?u'2, v) \\<in> local.lconv ?q2\\<rbrakk>\n  \\<Longrightarrow> (u, v)\n                    \\<in> (\\<Union> (range R))\\<^sup>* O\n                          (\\<Union> (range E))\\<^sup>* O\n                          ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n  (u, v) \\<in> local.lconv xs\n\ngoal (1 subgoal):\n 1. (u, v)\n    \\<in> (\\<Union> (range R))\\<^sup>* O\n          (\\<Union> (range E))\\<^sup>* O\n          ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "by (auto elim!: map_eq_append_splits relcompEpair simp del: append.simps) simp"], ["proof (state)\nthis:\n  (u, v)\n  \\<in> (\\<Union> (range R))\\<^sup>* O\n        (\\<Union> (range E))\\<^sup>* O\n        ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "fix as bs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "assume *: \"map fst xs = as @ ([Macron] @ [Grave]) @ bs\""], ["proof (state)\nthis:\n  map fst xs = as @ ([Macron] @ [Grave]) @ bs\n\ngoal (1 subgoal):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "{"], ["proof (state)\nthis:\n  map fst xs = as @ ([Macron] @ [Grave]) @ bs\n\ngoal (1 subgoal):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "fix p a b q t' s' u'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "assume xs: \"xs = p @ [(Macron,a),(Grave,b)] @ q\" and p: \"(u,t') \\<in> lconv p\"\n          and a: \"(s',t') \\<in> (E a)\\<inverse>\" and b: \"(s',u') \\<in> R b\" and q: \"(u',v) \\<in> lconv q\""], ["proof (state)\nthis:\n  xs = p @ [(Macron, a), (Grave, b)] @ q\n  (u, t') \\<in> local.lconv p\n  (s', t') \\<in> (E a)\\<inverse>\n  (s', u') \\<in> R b\n  (u', v) \\<in> local.lconv q\n\ngoal (1 subgoal):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "obtain js where lp: \"rcliff r a b js\" and js: \"(t',u') \\<in> lconv js\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>js.\n        \\<lbrakk>local.rcliff r a b js;\n         (t', u') \\<in> local.lconv js\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rc[OF a b]"], ["proof (prove)\nusing this:\n  \\<exists>xs. local.rcliff r a b xs \\<and> (t', u') \\<in> local.lconv xs\n\ngoal (1 subgoal):\n 1. (\\<And>js.\n        \\<lbrakk>local.rcliff r a b js;\n         (t', u') \\<in> local.lconv js\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  local.rcliff r a b js\n  (t', u') \\<in> local.lconv js\n\ngoal (1 subgoal):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "from lp"], ["proof (chain)\npicking this:\n  local.rcliff r a b js", "have \"(js, [(Macron,a),(Grave,b)]) \\<in> greek_less r\""], ["proof (prove)\nusing this:\n  local.rcliff r a b js\n\ngoal (1 subgoal):\n 1. (js, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "unfolding rcliff_def"], ["proof (prove)\nusing this:\n  (\\<exists>as b' cs a' bs.\n      snd ` set as \\<subseteq> under r a \\<inter> under r b \\<and>\n      b' \\<in> {[(Grave, b)], []} \\<and>\n      snd ` set cs \\<subseteq> under r b \\<and>\n      a' = [(Macron, a)] \\<and>\n      snd ` set bs \\<subseteq> under r b \\<and>\n      js = as @ b' @ cs @ a' @ bs) \\<or>\n  (\\<exists>as b' cs.\n      snd ` set as \\<subseteq> under r a \\<and>\n      b' \\<in> {[(Grave, b)], []} \\<and>\n      snd ` set cs \\<subseteq> under r a \\<union> under r b \\<and>\n      js = as @ b' @ cs)\n\ngoal (1 subgoal):\n 1. (js, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "using rcliff_greek_less1[OF \\<open>trans r\\<close>, of _ a b] rcliff_greek_less2[OF \\<open>trans r\\<close>, of _ a _ b]"], ["proof (prove)\nusing this:\n  (\\<exists>as b' cs a' bs.\n      snd ` set as \\<subseteq> under r a \\<inter> under r b \\<and>\n      b' \\<in> {[(Grave, b)], []} \\<and>\n      snd ` set cs \\<subseteq> under r b \\<and>\n      a' = [(Macron, a)] \\<and>\n      snd ` set bs \\<subseteq> under r b \\<and>\n      js = as @ b' @ cs @ a' @ bs) \\<or>\n  (\\<exists>as b' cs.\n      snd ` set as \\<subseteq> under r a \\<and>\n      b' \\<in> {[(Grave, b)], []} \\<and>\n      snd ` set cs \\<subseteq> under r a \\<union> under r b \\<and>\n      js = as @ b' @ cs)\n  \\<lbrakk>snd ` set ?as \\<subseteq> under r a \\<inter> under r b;\n   ?b' \\<in> {[(Grave, b)], []}; snd ` set ?cs \\<subseteq> under r b;\n   ?a' = [(Macron, a)]; snd ` set ?bs \\<subseteq> under r b\\<rbrakk>\n  \\<Longrightarrow> (?as @ ?b' @ ?cs @ ?a' @ ?bs, [(Macron, a), (Grave, b)])\n                    \\<in> greek_less r\n  \\<lbrakk>snd ` set ?as \\<subseteq> under r a;\n   ?b' \\<in> {[(Grave, b)], []};\n   snd ` set ?cs \\<subseteq> under r a \\<union> under r b\\<rbrakk>\n  \\<Longrightarrow> (?as @ ?b' @ ?cs, [(Macron, a), (Grave, b)])\n                    \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. (js, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "by fastforce"], ["proof (state)\nthis:\n  (js, [(Macron, a), (Grave, b)]) \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  (js, [(Macron, a), (Grave, b)]) \\<in> greek_less r", "have \"(p @ js @ q, xs) \\<in> greek_less r\""], ["proof (prove)\nusing this:\n  (js, [(Macron, a), (Grave, b)]) \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. (p @ js @ q, xs) \\<in> greek_less r", "unfolding xs"], ["proof (prove)\nusing this:\n  (js, [(Macron, a), (Grave, b)]) \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. (p @ js @ q, p @ [(Macron, a), (Grave, b)] @ q) \\<in> greek_less r", "by (intro greek_less_app_mono1 greek_less_app_mono2 \\<open>trans r\\<close>) auto"], ["proof (state)\nthis:\n  (p @ js @ q, xs) \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "moreover"], ["proof (state)\nthis:\n  (p @ js @ q, xs) \\<in> greek_less r\n\ngoal (1 subgoal):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "have \"(u, v) \\<in> lconv (p @ js @ q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> local.lconv (p @ js @ q)", "using p q js"], ["proof (prove)\nusing this:\n  (u, t') \\<in> local.lconv p\n  (u', v) \\<in> local.lconv q\n  (t', u') \\<in> local.lconv js\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> local.lconv (p @ js @ q)", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<in> local.lconv (p @ js @ q)\n\ngoal (1 subgoal):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "ultimately"], ["proof (chain)\npicking this:\n  (p @ js @ q, xs) \\<in> greek_less r\n  (u, v) \\<in> local.lconv (p @ js @ q)", "have \"(u, v) \\<in> valley' UNIV\""], ["proof (prove)\nusing this:\n  (p @ js @ q, xs) \\<in> greek_less r\n  (u, v) \\<in> local.lconv (p @ js @ q)\n\ngoal (1 subgoal):\n 1. (u, v)\n    \\<in> (\\<Union> (range R))\\<^sup>* O\n          (\\<Union> (range E))\\<^sup>* O\n          ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "using 2(1)"], ["proof (prove)\nusing this:\n  (p @ js @ q, xs) \\<in> greek_less r\n  (u, v) \\<in> local.lconv (p @ js @ q)\n  \\<forall>y.\n     (y, xs) \\<in> greek_less r \\<longrightarrow>\n     (u, v) \\<in> local.lconv y \\<longrightarrow>\n     (u, v)\n     \\<in> (\\<Union> (range R))\\<^sup>* O\n           (\\<Union> (range E))\\<^sup>* O\n           ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (u, v)\n    \\<in> (\\<Union> (range R))\\<^sup>* O\n          (\\<Union> (range E))\\<^sup>* O\n          ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "by blast"], ["proof (state)\nthis:\n  (u, v)\n  \\<in> (\\<Union> (range R))\\<^sup>* O\n        (\\<Union> (range E))\\<^sup>* O\n        ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "}"], ["proof (state)\nthis:\n  \\<lbrakk>xs = ?p2 @ [(Macron, ?a2), (Grave, ?b2)] @ ?q2;\n   (u, ?t'2) \\<in> local.lconv ?p2; (?s'2, ?t'2) \\<in> (E ?a2)\\<inverse>;\n   (?s'2, ?u'2) \\<in> R ?b2; (?u'2, v) \\<in> local.lconv ?q2\\<rbrakk>\n  \\<Longrightarrow> (u, v)\n                    \\<in> (\\<Union> (range R))\\<^sup>* O\n                          (\\<Union> (range E))\\<^sup>* O\n                          ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>as bs.\n       map fst xs = as @ ([Macron] @ [Grave]) @ bs \\<Longrightarrow>\n       (u, v)\n       \\<in> (\\<Union> (range R))\\<^sup>* O\n             (\\<Union> (range E))\\<^sup>* O\n             ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "with *"], ["proof (chain)\npicking this:\n  map fst xs = as @ ([Macron] @ [Grave]) @ bs\n  \\<lbrakk>xs = ?p2 @ [(Macron, ?a2), (Grave, ?b2)] @ ?q2;\n   (u, ?t'2) \\<in> local.lconv ?p2; (?s'2, ?t'2) \\<in> (E ?a2)\\<inverse>;\n   (?s'2, ?u'2) \\<in> R ?b2; (?u'2, v) \\<in> local.lconv ?q2\\<rbrakk>\n  \\<Longrightarrow> (u, v)\n                    \\<in> (\\<Union> (range R))\\<^sup>* O\n                          (\\<Union> (range E))\\<^sup>* O\n                          ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "show \"(u, v) \\<in> valley' UNIV\""], ["proof (prove)\nusing this:\n  map fst xs = as @ ([Macron] @ [Grave]) @ bs\n  \\<lbrakk>xs = ?p2 @ [(Macron, ?a2), (Grave, ?b2)] @ ?q2;\n   (u, ?t'2) \\<in> local.lconv ?p2; (?s'2, ?t'2) \\<in> (E ?a2)\\<inverse>;\n   (?s'2, ?u'2) \\<in> R ?b2; (?u'2, v) \\<in> local.lconv ?q2\\<rbrakk>\n  \\<Longrightarrow> (u, v)\n                    \\<in> (\\<Union> (range R))\\<^sup>* O\n                          (\\<Union> (range E))\\<^sup>* O\n                          ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (u, v)\n    \\<in> (\\<Union> (range R))\\<^sup>* O\n          (\\<Union> (range E))\\<^sup>* O\n          ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "using 2(2)"], ["proof (prove)\nusing this:\n  map fst xs = as @ ([Macron] @ [Grave]) @ bs\n  \\<lbrakk>xs = ?p2 @ [(Macron, ?a2), (Grave, ?b2)] @ ?q2;\n   (u, ?t'2) \\<in> local.lconv ?p2; (?s'2, ?t'2) \\<in> (E ?a2)\\<inverse>;\n   (?s'2, ?u'2) \\<in> R ?b2; (?u'2, v) \\<in> local.lconv ?q2\\<rbrakk>\n  \\<Longrightarrow> (u, v)\n                    \\<in> (\\<Union> (range R))\\<^sup>* O\n                          (\\<Union> (range E))\\<^sup>* O\n                          ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n  (u, v) \\<in> local.lconv xs\n\ngoal (1 subgoal):\n 1. (u, v)\n    \\<in> (\\<Union> (range R))\\<^sup>* O\n          (\\<Union> (range E))\\<^sup>* O\n          ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "by (auto elim!: map_eq_append_splits relcompEpair simp del: append.simps) simp"], ["proof (state)\nthis:\n  (u, v)\n  \\<in> (\\<Union> (range R))\\<^sup>* O\n        (\\<Union> (range E))\\<^sup>* O\n        ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (u, v)\n  \\<in> (\\<Union> (range R))\\<^sup>* O\n        (\\<Union> (range E))\\<^sup>* O\n        ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (u, v)\n  \\<in> (\\<Union> (range R))\\<^sup>* O\n        (\\<Union> (range E))\\<^sup>* O\n        ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Results\\<close>"], ["", "subsection \\<open>Church-Rosser modulo\\<close>"], ["", "text \\<open>Decreasing diagrams for Church-Rosser modulo, commutation version.\\<close>"], ["", "lemma dd_commute_modulo[case_names wf trans peak lcliff rcliff]:\n  assumes \"wf r\" and \"trans r\"\n  and pk: \"\\<And>a b s t u. (s, t) \\<in> L a \\<Longrightarrow> (s, u) \\<in> R b \\<Longrightarrow>\n    (t, u) \\<in> conversion' (under r a) O (R b)\\<^sup>= O conversion' (under r a \\<union> under r b) O\n      ((L a)\\<inverse>)\\<^sup>= O conversion' (under r b)\"\n  and lc: \"\\<And>a b s t u. (s, t) \\<in> L a \\<Longrightarrow> (s, u) \\<in> E b \\<Longrightarrow>\n    (t, u) \\<in> conversion' (under r a) O E b O conversion' (under r a) O\n      ((L a)\\<inverse>)\\<^sup>= O conversion' (under r a \\<inter> under r b) \\<or>\n    (t, u) \\<in> conversion' (under r a \\<union> under r b) O ((L a )\\<inverse>)\\<^sup>= O conversion' (under r b)\"\n  and rc: \"\\<And>a b s t u. (s, t) \\<in> (E a)\\<inverse> \\<Longrightarrow> (s, u) \\<in> R b \\<Longrightarrow>\n    (t, u) \\<in> conversion' (under r a \\<inter> under r b) O (R b)\\<^sup>= O conversion' (under r b) O\n      E a O conversion' (under r b) \\<or>\n    (t, u) \\<in> conversion' (under r a) O (R b)\\<^sup>= O conversion' (under r a \\<union> under r b)\"\n  shows \"conversion' UNIV \\<subseteq> valley' UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union> (range R) \\<union> \\<Union> (range E) \\<union>\n     (\\<Union> (range L))\\<inverse>)\\<^sup>*\n    \\<subseteq> (\\<Union> (range R))\\<^sup>* O\n                (\\<Union> (range E))\\<^sup>* O\n                ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "proof (cases rule: dd_commute_modulo_conv[of r])"], ["proof (state)\ngoal (5 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lpeak r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 5. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "case (peak a b s t u)"], ["proof (state)\nthis:\n  (s, t) \\<in> L a\n  (s, u) \\<in> R b\n\ngoal (5 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lpeak r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 5. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "{"], ["proof (state)\nthis:\n  (s, t) \\<in> L a\n  (s, u) \\<in> R b\n\ngoal (5 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lpeak r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 5. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "fix w x y z"], ["proof (state)\ngoal (5 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lpeak r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 5. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "assume \"(t, w) \\<in> conversion' (under r a)\""], ["proof (state)\nthis:\n  (t, w) \\<in> local.conversion' (under r a)\n\ngoal (5 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lpeak r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 5. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "from conversion_to_lconv[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r a;\n       (t, w) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain as where \"snd ` set as \\<subseteq> under r a\" \"(t, w) \\<in> lconv as\""], ["proof (prove)\nusing this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r a;\n       (t, w) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>snd ` set as \\<subseteq> under r a;\n         (t, w) \\<in> local.lconv as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  snd ` set as \\<subseteq> under r a\n  (t, w) \\<in> local.lconv as\n\ngoal (5 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lpeak r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 5. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "moreover"], ["proof (state)\nthis:\n  snd ` set as \\<subseteq> under r a\n  (t, w) \\<in> local.lconv as\n\ngoal (5 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lpeak r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 5. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "assume \"(w, x) \\<in> (R b)\\<^sup>=\""], ["proof (state)\nthis:\n  (w, x) \\<in> (R b)\\<^sup>=\n\ngoal (5 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lpeak r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 5. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "then"], ["proof (chain)\npicking this:\n  (w, x) \\<in> (R b)\\<^sup>=", "obtain b' where \"b' \\<in> {[(Grave,b)],[]}\" \"(w, x) \\<in> lconv b'\""], ["proof (prove)\nusing this:\n  (w, x) \\<in> (R b)\\<^sup>=\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>b' \\<in> {[(Grave, b)], []};\n         (w, x) \\<in> local.lconv b'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  b' \\<in> {[(Grave, b)], []}\n  (w, x) \\<in> local.lconv b'\n\ngoal (5 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lpeak r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 5. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "moreover"], ["proof (state)\nthis:\n  b' \\<in> {[(Grave, b)], []}\n  (w, x) \\<in> local.lconv b'\n\ngoal (5 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lpeak r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 5. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "assume \"(x, y) \\<in> conversion' (under r a \\<union> under r b)\""], ["proof (state)\nthis:\n  (x, y) \\<in> local.conversion' (under r a \\<union> under r b)\n\ngoal (5 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lpeak r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 5. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "from conversion_to_lconv[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r a \\<union> under r b;\n       (x, y) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain cs where \"snd ` set cs \\<subseteq> under r a \\<union> under r b\" \"(x, y) \\<in> lconv cs\""], ["proof (prove)\nusing this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r a \\<union> under r b;\n       (x, y) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>snd ` set cs \\<subseteq> under r a \\<union> under r b;\n         (x, y) \\<in> local.lconv cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  snd ` set cs \\<subseteq> under r a \\<union> under r b\n  (x, y) \\<in> local.lconv cs\n\ngoal (5 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lpeak r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 5. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "moreover"], ["proof (state)\nthis:\n  snd ` set cs \\<subseteq> under r a \\<union> under r b\n  (x, y) \\<in> local.lconv cs\n\ngoal (5 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lpeak r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 5. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "assume \"(y, z) \\<in> ((L a)\\<inverse>)\\<^sup>=\""], ["proof (state)\nthis:\n  (y, z) \\<in> ((L a)\\<inverse>)\\<^sup>=\n\ngoal (5 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lpeak r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 5. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "then"], ["proof (chain)\npicking this:\n  (y, z) \\<in> ((L a)\\<inverse>)\\<^sup>=", "obtain a' where \"a' \\<in> {[(Acute,a)],[]}\" \"(y, z) \\<in> lconv a'\""], ["proof (prove)\nusing this:\n  (y, z) \\<in> ((L a)\\<inverse>)\\<^sup>=\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a' \\<in> {[(Acute, a)], []};\n         (y, z) \\<in> local.lconv a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a' \\<in> {[(Acute, a)], []}\n  (y, z) \\<in> local.lconv a'\n\ngoal (5 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lpeak r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 5. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "moreover"], ["proof (state)\nthis:\n  a' \\<in> {[(Acute, a)], []}\n  (y, z) \\<in> local.lconv a'\n\ngoal (5 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lpeak r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 5. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "assume \"(z, u) \\<in> conversion' (under r b)\""], ["proof (state)\nthis:\n  (z, u) \\<in> local.conversion' (under r b)\n\ngoal (5 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lpeak r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 5. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "from conversion_to_lconv[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r b;\n       (z, u) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain bs where \"snd ` set bs \\<subseteq> under r b\" \"(z, u) \\<in> lconv bs\""], ["proof (prove)\nusing this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r b;\n       (z, u) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        \\<lbrakk>snd ` set bs \\<subseteq> under r b;\n         (z, u) \\<in> local.lconv bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  snd ` set bs \\<subseteq> under r b\n  (z, u) \\<in> local.lconv bs\n\ngoal (5 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lpeak r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 5. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "ultimately"], ["proof (chain)\npicking this:\n  snd ` set as \\<subseteq> under r a\n  (t, w) \\<in> local.lconv as\n  b' \\<in> {[(Grave, b)], []}\n  (w, x) \\<in> local.lconv b'\n  snd ` set cs \\<subseteq> under r a \\<union> under r b\n  (x, y) \\<in> local.lconv cs\n  a' \\<in> {[(Acute, a)], []}\n  (y, z) \\<in> local.lconv a'\n  snd ` set bs \\<subseteq> under r b\n  (z, u) \\<in> local.lconv bs", "have \"\\<exists>xs. lpeak r a b xs \\<and> (t, u) \\<in> lconv xs\""], ["proof (prove)\nusing this:\n  snd ` set as \\<subseteq> under r a\n  (t, w) \\<in> local.lconv as\n  b' \\<in> {[(Grave, b)], []}\n  (w, x) \\<in> local.lconv b'\n  snd ` set cs \\<subseteq> under r a \\<union> under r b\n  (x, y) \\<in> local.lconv cs\n  a' \\<in> {[(Acute, a)], []}\n  (y, z) \\<in> local.lconv a'\n  snd ` set bs \\<subseteq> under r b\n  (z, u) \\<in> local.lconv bs\n\ngoal (1 subgoal):\n 1. \\<exists>xs. local.lpeak r a b xs \\<and> (t, u) \\<in> local.lconv xs", "by (intro exI[of _ \"as @ b' @ cs @ a' @ bs\"], unfold lconv_append lpeak_def) blast"], ["proof (state)\nthis:\n  \\<exists>xs. local.lpeak r a b xs \\<and> (t, u) \\<in> local.lconv xs\n\ngoal (5 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lpeak r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 5. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(t, ?w2) \\<in> local.conversion' (under r a);\n   (?w2, ?x2) \\<in> (R b)\\<^sup>=;\n   (?x2, ?y2) \\<in> local.conversion' (under r a \\<union> under r b);\n   (?y2, ?z2) \\<in> ((L a)\\<inverse>)\\<^sup>=;\n   (?z2, u) \\<in> local.conversion' (under r b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       local.lpeak r a b xs \\<and>\n                       (t, u) \\<in> local.lconv xs\n\ngoal (5 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lpeak r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 5. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(t, ?w2) \\<in> local.conversion' (under r a);\n   (?w2, ?x2) \\<in> (R b)\\<^sup>=;\n   (?x2, ?y2) \\<in> local.conversion' (under r a \\<union> under r b);\n   (?y2, ?z2) \\<in> ((L a)\\<inverse>)\\<^sup>=;\n   (?z2, u) \\<in> local.conversion' (under r b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       local.lpeak r a b xs \\<and>\n                       (t, u) \\<in> local.lconv xs", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>(t, ?w2) \\<in> local.conversion' (under r a);\n   (?w2, ?x2) \\<in> (R b)\\<^sup>=;\n   (?x2, ?y2) \\<in> local.conversion' (under r a \\<union> under r b);\n   (?y2, ?z2) \\<in> ((L a)\\<inverse>)\\<^sup>=;\n   (?z2, u) \\<in> local.conversion' (under r b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       local.lpeak r a b xs \\<and>\n                       (t, u) \\<in> local.lconv xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs. local.lpeak r a b xs \\<and> (t, u) \\<in> local.lconv xs", "using pk[OF peak]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(t, ?w2) \\<in> local.conversion' (under r a);\n   (?w2, ?x2) \\<in> (R b)\\<^sup>=;\n   (?x2, ?y2) \\<in> local.conversion' (under r a \\<union> under r b);\n   (?y2, ?z2) \\<in> ((L a)\\<inverse>)\\<^sup>=;\n   (?z2, u) \\<in> local.conversion' (under r b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       local.lpeak r a b xs \\<and>\n                       (t, u) \\<in> local.lconv xs\n  (t, u)\n  \\<in> local.conversion' (under r a) O\n        (R b)\\<^sup>= O\n        local.conversion' (under r a \\<union> under r b) O\n        ((L a)\\<inverse>)\\<^sup>= O local.conversion' (under r b)\n\ngoal (1 subgoal):\n 1. \\<exists>xs. local.lpeak r a b xs \\<and> (t, u) \\<in> local.lconv xs", "by blast"], ["proof (state)\nthis:\n  \\<exists>xs. local.lpeak r a b xs \\<and> (t, u) \\<in> local.lconv xs\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "case (lcliff a b s t u)"], ["proof (state)\nthis:\n  (s, t) \\<in> L a\n  (s, u) \\<in> E b\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "{"], ["proof (state)\nthis:\n  (s, t) \\<in> L a\n  (s, u) \\<in> E b\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "fix w x y z"], ["proof (state)\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "assume \"(t, w) \\<in> conversion' (under r a)\""], ["proof (state)\nthis:\n  (t, w) \\<in> local.conversion' (under r a)\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "from conversion_to_lconv[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r a;\n       (t, w) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain as where \"snd ` set as \\<subseteq> under r a\" \"(t, w) \\<in> lconv as\""], ["proof (prove)\nusing this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r a;\n       (t, w) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>snd ` set as \\<subseteq> under r a;\n         (t, w) \\<in> local.lconv as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  snd ` set as \\<subseteq> under r a\n  (t, w) \\<in> local.lconv as\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "moreover"], ["proof (state)\nthis:\n  snd ` set as \\<subseteq> under r a\n  (t, w) \\<in> local.lconv as\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "assume \"(w, x) \\<in> E b\""], ["proof (state)\nthis:\n  (w, x) \\<in> E b\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "then"], ["proof (chain)\npicking this:\n  (w, x) \\<in> E b", "obtain b' where \"b' = [(Macron,b)]\" \"(w, x) \\<in> lconv b'\""], ["proof (prove)\nusing this:\n  (w, x) \\<in> E b\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>b' = [(Macron, b)]; (w, x) \\<in> local.lconv b'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  b' = [(Macron, b)]\n  (w, x) \\<in> local.lconv b'\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "moreover"], ["proof (state)\nthis:\n  b' = [(Macron, b)]\n  (w, x) \\<in> local.lconv b'\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "assume \"(x, y) \\<in> conversion' (under r a)\""], ["proof (state)\nthis:\n  (x, y) \\<in> local.conversion' (under r a)\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "from conversion_to_lconv[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r a;\n       (x, y) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain cs where \"snd ` set cs \\<subseteq> under r a\" \"(x, y) \\<in> lconv cs\""], ["proof (prove)\nusing this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r a;\n       (x, y) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>snd ` set cs \\<subseteq> under r a;\n         (x, y) \\<in> local.lconv cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  snd ` set cs \\<subseteq> under r a\n  (x, y) \\<in> local.lconv cs\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "moreover"], ["proof (state)\nthis:\n  snd ` set cs \\<subseteq> under r a\n  (x, y) \\<in> local.lconv cs\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "assume \"(y, z) \\<in> ((L a)\\<inverse>)\\<^sup>=\""], ["proof (state)\nthis:\n  (y, z) \\<in> ((L a)\\<inverse>)\\<^sup>=\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "then"], ["proof (chain)\npicking this:\n  (y, z) \\<in> ((L a)\\<inverse>)\\<^sup>=", "obtain a' where \"a' \\<in> {[(Acute,a)],[]}\" \"(y, z) \\<in> lconv a'\""], ["proof (prove)\nusing this:\n  (y, z) \\<in> ((L a)\\<inverse>)\\<^sup>=\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a' \\<in> {[(Acute, a)], []};\n         (y, z) \\<in> local.lconv a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a' \\<in> {[(Acute, a)], []}\n  (y, z) \\<in> local.lconv a'\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "moreover"], ["proof (state)\nthis:\n  a' \\<in> {[(Acute, a)], []}\n  (y, z) \\<in> local.lconv a'\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "assume \"(z, u) \\<in> conversion' (under r a \\<inter> under r b)\""], ["proof (state)\nthis:\n  (z, u) \\<in> local.conversion' (under r a \\<inter> under r b)\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "from conversion_to_lconv[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r a \\<inter> under r b;\n       (z, u) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain bs where \"snd ` set bs \\<subseteq> under r a \\<inter> under r b\" \"(z, u) \\<in> lconv bs\""], ["proof (prove)\nusing this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r a \\<inter> under r b;\n       (z, u) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        \\<lbrakk>snd ` set bs \\<subseteq> under r a \\<inter> under r b;\n         (z, u) \\<in> local.lconv bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  snd ` set bs \\<subseteq> under r a \\<inter> under r b\n  (z, u) \\<in> local.lconv bs\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "ultimately"], ["proof (chain)\npicking this:\n  snd ` set as \\<subseteq> under r a\n  (t, w) \\<in> local.lconv as\n  b' = [(Macron, b)]\n  (w, x) \\<in> local.lconv b'\n  snd ` set cs \\<subseteq> under r a\n  (x, y) \\<in> local.lconv cs\n  a' \\<in> {[(Acute, a)], []}\n  (y, z) \\<in> local.lconv a'\n  snd ` set bs \\<subseteq> under r a \\<inter> under r b\n  (z, u) \\<in> local.lconv bs", "have \"\\<exists>xs. lcliff r a b xs \\<and> (t, u) \\<in> lconv xs\""], ["proof (prove)\nusing this:\n  snd ` set as \\<subseteq> under r a\n  (t, w) \\<in> local.lconv as\n  b' = [(Macron, b)]\n  (w, x) \\<in> local.lconv b'\n  snd ` set cs \\<subseteq> under r a\n  (x, y) \\<in> local.lconv cs\n  a' \\<in> {[(Acute, a)], []}\n  (y, z) \\<in> local.lconv a'\n  snd ` set bs \\<subseteq> under r a \\<inter> under r b\n  (z, u) \\<in> local.lconv bs\n\ngoal (1 subgoal):\n 1. \\<exists>xs. local.lcliff r a b xs \\<and> (t, u) \\<in> local.lconv xs", "by (intro exI[of _ \"as @ b' @ cs @ a' @ bs\"], unfold lconv_append lcliff_def) blast"], ["proof (state)\nthis:\n  \\<exists>xs. local.lcliff r a b xs \\<and> (t, u) \\<in> local.lconv xs\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(t, ?w2) \\<in> local.conversion' (under r a);\n   (?w2, ?x2) \\<in> E b; (?x2, ?y2) \\<in> local.conversion' (under r a);\n   (?y2, ?z2) \\<in> ((L a)\\<inverse>)\\<^sup>=;\n   (?z2, u) \\<in> local.conversion' (under r a \\<inter> under r b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       local.lcliff r a b xs \\<and>\n                       (t, u) \\<in> local.lconv xs\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>(t, ?w2) \\<in> local.conversion' (under r a);\n   (?w2, ?x2) \\<in> E b; (?x2, ?y2) \\<in> local.conversion' (under r a);\n   (?y2, ?z2) \\<in> ((L a)\\<inverse>)\\<^sup>=;\n   (?z2, u) \\<in> local.conversion' (under r a \\<inter> under r b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       local.lcliff r a b xs \\<and>\n                       (t, u) \\<in> local.lconv xs\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(t, ?w2) \\<in> local.conversion' (under r a);\n   (?w2, ?x2) \\<in> E b; (?x2, ?y2) \\<in> local.conversion' (under r a);\n   (?y2, ?z2) \\<in> ((L a)\\<inverse>)\\<^sup>=;\n   (?z2, u) \\<in> local.conversion' (under r a \\<inter> under r b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       local.lcliff r a b xs \\<and>\n                       (t, u) \\<in> local.lconv xs\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "fix w x"], ["proof (state)\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "assume \"(t, w) \\<in> conversion' (under r a \\<union> under r b)\""], ["proof (state)\nthis:\n  (t, w) \\<in> local.conversion' (under r a \\<union> under r b)\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "from conversion_to_lconv[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r a \\<union> under r b;\n       (t, w) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain cs where \"snd ` set cs \\<subseteq> under r a \\<union> under r b\" \"(t, w) \\<in> lconv cs\""], ["proof (prove)\nusing this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r a \\<union> under r b;\n       (t, w) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>snd ` set cs \\<subseteq> under r a \\<union> under r b;\n         (t, w) \\<in> local.lconv cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  snd ` set cs \\<subseteq> under r a \\<union> under r b\n  (t, w) \\<in> local.lconv cs\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "moreover"], ["proof (state)\nthis:\n  snd ` set cs \\<subseteq> under r a \\<union> under r b\n  (t, w) \\<in> local.lconv cs\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "assume \"(w, x) \\<in> ((L a)\\<inverse>)\\<^sup>=\""], ["proof (state)\nthis:\n  (w, x) \\<in> ((L a)\\<inverse>)\\<^sup>=\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "then"], ["proof (chain)\npicking this:\n  (w, x) \\<in> ((L a)\\<inverse>)\\<^sup>=", "obtain a' where \"a' \\<in> {[(Acute,a)],[]}\" \"(w, x) \\<in> lconv a'\""], ["proof (prove)\nusing this:\n  (w, x) \\<in> ((L a)\\<inverse>)\\<^sup>=\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a' \\<in> {[(Acute, a)], []};\n         (w, x) \\<in> local.lconv a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a' \\<in> {[(Acute, a)], []}\n  (w, x) \\<in> local.lconv a'\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "moreover"], ["proof (state)\nthis:\n  a' \\<in> {[(Acute, a)], []}\n  (w, x) \\<in> local.lconv a'\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "assume \"(x, u) \\<in> conversion' (under r b)\""], ["proof (state)\nthis:\n  (x, u) \\<in> local.conversion' (under r b)\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "from conversion_to_lconv[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r b;\n       (x, u) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain bs where \"snd ` set bs \\<subseteq> under r b\" \"(x, u) \\<in> lconv bs\""], ["proof (prove)\nusing this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r b;\n       (x, u) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        \\<lbrakk>snd ` set bs \\<subseteq> under r b;\n         (x, u) \\<in> local.lconv bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  snd ` set bs \\<subseteq> under r b\n  (x, u) \\<in> local.lconv bs\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "ultimately"], ["proof (chain)\npicking this:\n  snd ` set cs \\<subseteq> under r a \\<union> under r b\n  (t, w) \\<in> local.lconv cs\n  a' \\<in> {[(Acute, a)], []}\n  (w, x) \\<in> local.lconv a'\n  snd ` set bs \\<subseteq> under r b\n  (x, u) \\<in> local.lconv bs", "have \"\\<exists>xs. lcliff r a b xs \\<and> (t, u) \\<in> lconv xs\""], ["proof (prove)\nusing this:\n  snd ` set cs \\<subseteq> under r a \\<union> under r b\n  (t, w) \\<in> local.lconv cs\n  a' \\<in> {[(Acute, a)], []}\n  (w, x) \\<in> local.lconv a'\n  snd ` set bs \\<subseteq> under r b\n  (x, u) \\<in> local.lconv bs\n\ngoal (1 subgoal):\n 1. \\<exists>xs. local.lcliff r a b xs \\<and> (t, u) \\<in> local.lconv xs", "by (intro exI[of _ \"cs @ a' @ bs\"], unfold lconv_append lcliff_def) blast"], ["proof (state)\nthis:\n  \\<exists>xs. local.lcliff r a b xs \\<and> (t, u) \\<in> local.lconv xs\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(t, ?w2) \\<in> local.conversion' (under r a \\<union> under r b);\n   (?w2, ?x2) \\<in> ((L a)\\<inverse>)\\<^sup>=;\n   (?x2, u) \\<in> local.conversion' (under r b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       local.lcliff r a b xs \\<and>\n                       (t, u) \\<in> local.lconv xs\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.lcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>(t, ?w2) \\<in> local.conversion' (under r a);\n   (?w2, ?x2) \\<in> E b; (?x2, ?y2) \\<in> local.conversion' (under r a);\n   (?y2, ?z2) \\<in> ((L a)\\<inverse>)\\<^sup>=;\n   (?z2, u) \\<in> local.conversion' (under r a \\<inter> under r b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       local.lcliff r a b xs \\<and>\n                       (t, u) \\<in> local.lconv xs\n  \\<lbrakk>(t, ?w2) \\<in> local.conversion' (under r a \\<union> under r b);\n   (?w2, ?x2) \\<in> ((L a)\\<inverse>)\\<^sup>=;\n   (?x2, u) \\<in> local.conversion' (under r b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       local.lcliff r a b xs \\<and>\n                       (t, u) \\<in> local.lconv xs", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>(t, ?w2) \\<in> local.conversion' (under r a);\n   (?w2, ?x2) \\<in> E b; (?x2, ?y2) \\<in> local.conversion' (under r a);\n   (?y2, ?z2) \\<in> ((L a)\\<inverse>)\\<^sup>=;\n   (?z2, u) \\<in> local.conversion' (under r a \\<inter> under r b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       local.lcliff r a b xs \\<and>\n                       (t, u) \\<in> local.lconv xs\n  \\<lbrakk>(t, ?w2) \\<in> local.conversion' (under r a \\<union> under r b);\n   (?w2, ?x2) \\<in> ((L a)\\<inverse>)\\<^sup>=;\n   (?x2, u) \\<in> local.conversion' (under r b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       local.lcliff r a b xs \\<and>\n                       (t, u) \\<in> local.lconv xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs. local.lcliff r a b xs \\<and> (t, u) \\<in> local.lconv xs", "using lc[OF lcliff]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(t, ?w2) \\<in> local.conversion' (under r a);\n   (?w2, ?x2) \\<in> E b; (?x2, ?y2) \\<in> local.conversion' (under r a);\n   (?y2, ?z2) \\<in> ((L a)\\<inverse>)\\<^sup>=;\n   (?z2, u) \\<in> local.conversion' (under r a \\<inter> under r b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       local.lcliff r a b xs \\<and>\n                       (t, u) \\<in> local.lconv xs\n  \\<lbrakk>(t, ?w2) \\<in> local.conversion' (under r a \\<union> under r b);\n   (?w2, ?x2) \\<in> ((L a)\\<inverse>)\\<^sup>=;\n   (?x2, u) \\<in> local.conversion' (under r b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       local.lcliff r a b xs \\<and>\n                       (t, u) \\<in> local.lconv xs\n  (t, u)\n  \\<in> local.conversion' (under r a) O\n        E b O\n        local.conversion' (under r a) O\n        ((L a)\\<inverse>)\\<^sup>= O\n        local.conversion' (under r a \\<inter> under r b) \\<or>\n  (t, u)\n  \\<in> local.conversion' (under r a \\<union> under r b) O\n        ((L a)\\<inverse>)\\<^sup>= O local.conversion' (under r b)\n\ngoal (1 subgoal):\n 1. \\<exists>xs. local.lcliff r a b xs \\<and> (t, u) \\<in> local.lconv xs", "by blast"], ["proof (state)\nthis:\n  \\<exists>xs. local.lcliff r a b xs \\<and> (t, u) \\<in> local.lconv xs\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "case (rcliff a b s t u)"], ["proof (state)\nthis:\n  (s, t) \\<in> (E a)\\<inverse>\n  (s, u) \\<in> R b\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "{"], ["proof (state)\nthis:\n  (s, t) \\<in> (E a)\\<inverse>\n  (s, u) \\<in> R b\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "fix w x y z"], ["proof (state)\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "assume \"(t, w) \\<in> conversion' (under r a \\<inter> under r b)\""], ["proof (state)\nthis:\n  (t, w) \\<in> local.conversion' (under r a \\<inter> under r b)\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "from conversion_to_lconv[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r a \\<inter> under r b;\n       (t, w) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain as where \"snd ` set as \\<subseteq> under r a \\<inter> under r b\" \"(t, w) \\<in> lconv as\""], ["proof (prove)\nusing this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r a \\<inter> under r b;\n       (t, w) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>snd ` set as \\<subseteq> under r a \\<inter> under r b;\n         (t, w) \\<in> local.lconv as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  snd ` set as \\<subseteq> under r a \\<inter> under r b\n  (t, w) \\<in> local.lconv as\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "moreover"], ["proof (state)\nthis:\n  snd ` set as \\<subseteq> under r a \\<inter> under r b\n  (t, w) \\<in> local.lconv as\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "assume \"(w, x) \\<in> (R b)\\<^sup>=\""], ["proof (state)\nthis:\n  (w, x) \\<in> (R b)\\<^sup>=\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "then"], ["proof (chain)\npicking this:\n  (w, x) \\<in> (R b)\\<^sup>=", "obtain b' where \"b' \\<in> {[(Grave,b)],[]}\" \"(w, x) \\<in> lconv b'\""], ["proof (prove)\nusing this:\n  (w, x) \\<in> (R b)\\<^sup>=\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>b' \\<in> {[(Grave, b)], []};\n         (w, x) \\<in> local.lconv b'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  b' \\<in> {[(Grave, b)], []}\n  (w, x) \\<in> local.lconv b'\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "moreover"], ["proof (state)\nthis:\n  b' \\<in> {[(Grave, b)], []}\n  (w, x) \\<in> local.lconv b'\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "assume \"(x, y) \\<in> conversion' (under r b)\""], ["proof (state)\nthis:\n  (x, y) \\<in> local.conversion' (under r b)\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "from conversion_to_lconv[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r b;\n       (x, y) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain cs where \"snd ` set cs \\<subseteq> under r b\" \"(x, y) \\<in> lconv cs\""], ["proof (prove)\nusing this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r b;\n       (x, y) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>snd ` set cs \\<subseteq> under r b;\n         (x, y) \\<in> local.lconv cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  snd ` set cs \\<subseteq> under r b\n  (x, y) \\<in> local.lconv cs\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "moreover"], ["proof (state)\nthis:\n  snd ` set cs \\<subseteq> under r b\n  (x, y) \\<in> local.lconv cs\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "assume \"(y, z) \\<in> E a\""], ["proof (state)\nthis:\n  (y, z) \\<in> E a\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "then"], ["proof (chain)\npicking this:\n  (y, z) \\<in> E a", "obtain a' where \"a' = [(Macron,a)]\" \"(y, z) \\<in> lconv a'\""], ["proof (prove)\nusing this:\n  (y, z) \\<in> E a\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a' = [(Macron, a)]; (y, z) \\<in> local.lconv a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a' = [(Macron, a)]\n  (y, z) \\<in> local.lconv a'\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "moreover"], ["proof (state)\nthis:\n  a' = [(Macron, a)]\n  (y, z) \\<in> local.lconv a'\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "assume \"(z, u) \\<in> conversion' (under r b)\""], ["proof (state)\nthis:\n  (z, u) \\<in> local.conversion' (under r b)\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "from conversion_to_lconv[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r b;\n       (z, u) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain bs where \"snd ` set bs \\<subseteq> under r b\" \"(z, u) \\<in> lconv bs\""], ["proof (prove)\nusing this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r b;\n       (z, u) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        \\<lbrakk>snd ` set bs \\<subseteq> under r b;\n         (z, u) \\<in> local.lconv bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  snd ` set bs \\<subseteq> under r b\n  (z, u) \\<in> local.lconv bs\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "ultimately"], ["proof (chain)\npicking this:\n  snd ` set as \\<subseteq> under r a \\<inter> under r b\n  (t, w) \\<in> local.lconv as\n  b' \\<in> {[(Grave, b)], []}\n  (w, x) \\<in> local.lconv b'\n  snd ` set cs \\<subseteq> under r b\n  (x, y) \\<in> local.lconv cs\n  a' = [(Macron, a)]\n  (y, z) \\<in> local.lconv a'\n  snd ` set bs \\<subseteq> under r b\n  (z, u) \\<in> local.lconv bs", "have \"\\<exists>xs. rcliff r a b xs \\<and> (t, u) \\<in> lconv xs\""], ["proof (prove)\nusing this:\n  snd ` set as \\<subseteq> under r a \\<inter> under r b\n  (t, w) \\<in> local.lconv as\n  b' \\<in> {[(Grave, b)], []}\n  (w, x) \\<in> local.lconv b'\n  snd ` set cs \\<subseteq> under r b\n  (x, y) \\<in> local.lconv cs\n  a' = [(Macron, a)]\n  (y, z) \\<in> local.lconv a'\n  snd ` set bs \\<subseteq> under r b\n  (z, u) \\<in> local.lconv bs\n\ngoal (1 subgoal):\n 1. \\<exists>xs. local.rcliff r a b xs \\<and> (t, u) \\<in> local.lconv xs", "by (intro exI[of _ \"as @ b' @ cs @ a' @ bs\"], unfold lconv_append rcliff_def) blast"], ["proof (state)\nthis:\n  \\<exists>xs. local.rcliff r a b xs \\<and> (t, u) \\<in> local.lconv xs\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(t, ?w2) \\<in> local.conversion' (under r a \\<inter> under r b);\n   (?w2, ?x2) \\<in> (R b)\\<^sup>=;\n   (?x2, ?y2) \\<in> local.conversion' (under r b); (?y2, ?z2) \\<in> E a;\n   (?z2, u) \\<in> local.conversion' (under r b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       local.rcliff r a b xs \\<and>\n                       (t, u) \\<in> local.lconv xs\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>(t, ?w2) \\<in> local.conversion' (under r a \\<inter> under r b);\n   (?w2, ?x2) \\<in> (R b)\\<^sup>=;\n   (?x2, ?y2) \\<in> local.conversion' (under r b); (?y2, ?z2) \\<in> E a;\n   (?z2, u) \\<in> local.conversion' (under r b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       local.rcliff r a b xs \\<and>\n                       (t, u) \\<in> local.lconv xs\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(t, ?w2) \\<in> local.conversion' (under r a \\<inter> under r b);\n   (?w2, ?x2) \\<in> (R b)\\<^sup>=;\n   (?x2, ?y2) \\<in> local.conversion' (under r b); (?y2, ?z2) \\<in> E a;\n   (?z2, u) \\<in> local.conversion' (under r b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       local.rcliff r a b xs \\<and>\n                       (t, u) \\<in> local.lconv xs\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "fix w x"], ["proof (state)\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "assume \"(t, w) \\<in> conversion' (under r a)\""], ["proof (state)\nthis:\n  (t, w) \\<in> local.conversion' (under r a)\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "from conversion_to_lconv[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r a;\n       (t, w) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain as where \"snd ` set as \\<subseteq> under r a\" \"(t, w) \\<in> lconv as\""], ["proof (prove)\nusing this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r a;\n       (t, w) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>snd ` set as \\<subseteq> under r a;\n         (t, w) \\<in> local.lconv as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  snd ` set as \\<subseteq> under r a\n  (t, w) \\<in> local.lconv as\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "moreover"], ["proof (state)\nthis:\n  snd ` set as \\<subseteq> under r a\n  (t, w) \\<in> local.lconv as\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "assume \"(w, x) \\<in> (R b)\\<^sup>=\""], ["proof (state)\nthis:\n  (w, x) \\<in> (R b)\\<^sup>=\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "then"], ["proof (chain)\npicking this:\n  (w, x) \\<in> (R b)\\<^sup>=", "obtain b' where \"b' \\<in> {[(Grave,b)],[]}\" \"(w, x) \\<in> lconv b'\""], ["proof (prove)\nusing this:\n  (w, x) \\<in> (R b)\\<^sup>=\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>b' \\<in> {[(Grave, b)], []};\n         (w, x) \\<in> local.lconv b'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  b' \\<in> {[(Grave, b)], []}\n  (w, x) \\<in> local.lconv b'\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "moreover"], ["proof (state)\nthis:\n  b' \\<in> {[(Grave, b)], []}\n  (w, x) \\<in> local.lconv b'\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "assume \"(x, u) \\<in> conversion' (under r a \\<union> under r b)\""], ["proof (state)\nthis:\n  (x, u) \\<in> local.conversion' (under r a \\<union> under r b)\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "from conversion_to_lconv[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r a \\<union> under r b;\n       (x, u) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain cs where \"snd ` set cs \\<subseteq> under r a \\<union> under r b\" \"(x, u) \\<in> lconv cs\""], ["proof (prove)\nusing this:\n  (\\<And>xs.\n      \\<lbrakk>snd ` set xs \\<subseteq> under r a \\<union> under r b;\n       (x, u) \\<in> local.lconv xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>snd ` set cs \\<subseteq> under r a \\<union> under r b;\n         (x, u) \\<in> local.lconv cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  snd ` set cs \\<subseteq> under r a \\<union> under r b\n  (x, u) \\<in> local.lconv cs\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "ultimately"], ["proof (chain)\npicking this:\n  snd ` set as \\<subseteq> under r a\n  (t, w) \\<in> local.lconv as\n  b' \\<in> {[(Grave, b)], []}\n  (w, x) \\<in> local.lconv b'\n  snd ` set cs \\<subseteq> under r a \\<union> under r b\n  (x, u) \\<in> local.lconv cs", "have \"\\<exists>xs. rcliff r a b xs \\<and> (t, u) \\<in> lconv xs\""], ["proof (prove)\nusing this:\n  snd ` set as \\<subseteq> under r a\n  (t, w) \\<in> local.lconv as\n  b' \\<in> {[(Grave, b)], []}\n  (w, x) \\<in> local.lconv b'\n  snd ` set cs \\<subseteq> under r a \\<union> under r b\n  (x, u) \\<in> local.lconv cs\n\ngoal (1 subgoal):\n 1. \\<exists>xs. local.rcliff r a b xs \\<and> (t, u) \\<in> local.lconv xs", "by (intro exI[of _ \"as @ b' @ cs\"], unfold lconv_append rcliff_def) blast"], ["proof (state)\nthis:\n  \\<exists>xs. local.rcliff r a b xs \\<and> (t, u) \\<in> local.lconv xs\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(t, ?w2) \\<in> local.conversion' (under r a);\n   (?w2, ?x2) \\<in> (R b)\\<^sup>=;\n   (?x2, u) \\<in> local.conversion' (under r a \\<union> under r b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       local.rcliff r a b xs \\<and>\n                       (t, u) \\<in> local.lconv xs\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            local.rcliff r a b xs \\<and>\n                            (t, u) \\<in> local.lconv xs", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>(t, ?w2) \\<in> local.conversion' (under r a \\<inter> under r b);\n   (?w2, ?x2) \\<in> (R b)\\<^sup>=;\n   (?x2, ?y2) \\<in> local.conversion' (under r b); (?y2, ?z2) \\<in> E a;\n   (?z2, u) \\<in> local.conversion' (under r b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       local.rcliff r a b xs \\<and>\n                       (t, u) \\<in> local.lconv xs\n  \\<lbrakk>(t, ?w2) \\<in> local.conversion' (under r a);\n   (?w2, ?x2) \\<in> (R b)\\<^sup>=;\n   (?x2, u) \\<in> local.conversion' (under r a \\<union> under r b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       local.rcliff r a b xs \\<and>\n                       (t, u) \\<in> local.lconv xs", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>(t, ?w2) \\<in> local.conversion' (under r a \\<inter> under r b);\n   (?w2, ?x2) \\<in> (R b)\\<^sup>=;\n   (?x2, ?y2) \\<in> local.conversion' (under r b); (?y2, ?z2) \\<in> E a;\n   (?z2, u) \\<in> local.conversion' (under r b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       local.rcliff r a b xs \\<and>\n                       (t, u) \\<in> local.lconv xs\n  \\<lbrakk>(t, ?w2) \\<in> local.conversion' (under r a);\n   (?w2, ?x2) \\<in> (R b)\\<^sup>=;\n   (?x2, u) \\<in> local.conversion' (under r a \\<union> under r b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       local.rcliff r a b xs \\<and>\n                       (t, u) \\<in> local.lconv xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs. local.rcliff r a b xs \\<and> (t, u) \\<in> local.lconv xs", "using rc[OF rcliff]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(t, ?w2) \\<in> local.conversion' (under r a \\<inter> under r b);\n   (?w2, ?x2) \\<in> (R b)\\<^sup>=;\n   (?x2, ?y2) \\<in> local.conversion' (under r b); (?y2, ?z2) \\<in> E a;\n   (?z2, u) \\<in> local.conversion' (under r b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       local.rcliff r a b xs \\<and>\n                       (t, u) \\<in> local.lconv xs\n  \\<lbrakk>(t, ?w2) \\<in> local.conversion' (under r a);\n   (?w2, ?x2) \\<in> (R b)\\<^sup>=;\n   (?x2, u) \\<in> local.conversion' (under r a \\<union> under r b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       local.rcliff r a b xs \\<and>\n                       (t, u) \\<in> local.lconv xs\n  (t, u)\n  \\<in> local.conversion' (under r a \\<inter> under r b) O\n        (R b)\\<^sup>= O\n        local.conversion' (under r b) O\n        E a O local.conversion' (under r b) \\<or>\n  (t, u)\n  \\<in> local.conversion' (under r a) O\n        (R b)\\<^sup>= O local.conversion' (under r a \\<union> under r b)\n\ngoal (1 subgoal):\n 1. \\<exists>xs. local.rcliff r a b xs \\<and> (t, u) \\<in> local.lconv xs", "by blast"], ["proof (state)\nthis:\n  \\<exists>xs. local.rcliff r a b xs \\<and> (t, u) \\<in> local.lconv xs\n\ngoal (2 subgoals):\n 1. wf r\n 2. trans r", "qed fact+"], ["", "end"], ["", "(* context *)"], ["", "text \\<open>Decreasing diagrams for Church-Rosser modulo.\\<close>"], ["", "lemma dd_cr_modulo[case_names wf trans symE peak cliff]:\n  assumes \"wf r\" and \"trans r\" and E: \"\\<And>i. sym (E i)\"\n  and pk: \"\\<And>a b s t u. (s, t) \\<in> L a \\<Longrightarrow> (s, u) \\<in> L b \\<Longrightarrow>\n    (t, u) \\<in> conversion' L L E (under r a) O (L b)\\<^sup>= O conversion' L L E (under r a \\<union> under r b) O\n      ((L a)\\<inverse>)\\<^sup>= O conversion' L L E (under r b)\"\n  and cl: \"\\<And>a b s t u. (s, t) \\<in> L a \\<Longrightarrow> (s, u) \\<in> E b \\<Longrightarrow>\n    (t, u) \\<in> conversion' L L E (under r a) O E b O conversion' L L E (under r a) O\n      ((L a)\\<inverse>)\\<^sup>= O conversion' L L E (under r a \\<inter> under r b) \\<or>\n    (t, u) \\<in> conversion' L L E (under r a \\<union> under r b) O ((L a )\\<inverse>)\\<^sup>= O conversion' L L E (under r b)\"\n  shows \"conversion' L L E UNIV \\<subseteq> valley' L L E UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union> (range L) \\<union> \\<Union> (range E) \\<union>\n     (\\<Union> (range L))\\<inverse>)\\<^sup>*\n    \\<subseteq> (\\<Union> (range L))\\<^sup>* O\n                (\\<Union> (range E))\\<^sup>* O\n                ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "proof (induct rule: dd_commute_modulo[of r])"], ["proof (state)\ngoal (5 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> L b\\<rbrakk>\n       \\<Longrightarrow> (t, u)\n                         \\<in> conversion' L L E (under r a) O\n                               (L b)\\<^sup>= O\n                               conversion' L L E\n                                (under r a \\<union> under r b) O\n                               ((L a)\\<inverse>)\\<^sup>= O\n                               conversion' L L E (under r b)\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> (t, u)\n                         \\<in> conversion' L L E (under r a) O\n                               E b O\n                               conversion' L L E (under r a) O\n                               ((L a)\\<inverse>)\\<^sup>= O\n                               conversion' L L E\n                                (under r a \\<inter> under r b) \\<or>\n                         (t, u)\n                         \\<in> conversion' L L E\n                                (under r a \\<union> under r b) O\n                               ((L a)\\<inverse>)\\<^sup>= O\n                               conversion' L L E (under r b)\n 5. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> L b\\<rbrakk>\n       \\<Longrightarrow> (t, u)\n                         \\<in> conversion' L L E\n                                (under r a \\<inter> under r b) O\n                               (L b)\\<^sup>= O\n                               conversion' L L E (under r b) O\n                               E a O conversion' L L E (under r b) \\<or>\n                         (t, u)\n                         \\<in> conversion' L L E (under r a) O\n                               (L b)\\<^sup>= O\n                               conversion' L L E\n                                (under r a \\<union> under r b)", "note E' = E[unfolded sym_conv_converse_eq]"], ["proof (state)\nthis:\n  (E ?i)\\<inverse> = E ?i\n\ngoal (5 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> L b\\<rbrakk>\n       \\<Longrightarrow> (t, u)\n                         \\<in> conversion' L L E (under r a) O\n                               (L b)\\<^sup>= O\n                               conversion' L L E\n                                (under r a \\<union> under r b) O\n                               ((L a)\\<inverse>)\\<^sup>= O\n                               conversion' L L E (under r b)\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> (t, u)\n                         \\<in> conversion' L L E (under r a) O\n                               E b O\n                               conversion' L L E (under r a) O\n                               ((L a)\\<inverse>)\\<^sup>= O\n                               conversion' L L E\n                                (under r a \\<inter> under r b) \\<or>\n                         (t, u)\n                         \\<in> conversion' L L E\n                                (under r a \\<union> under r b) O\n                               ((L a)\\<inverse>)\\<^sup>= O\n                               conversion' L L E (under r b)\n 5. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> L b\\<rbrakk>\n       \\<Longrightarrow> (t, u)\n                         \\<in> conversion' L L E\n                                (under r a \\<inter> under r b) O\n                               (L b)\\<^sup>= O\n                               conversion' L L E (under r b) O\n                               E a O conversion' L L E (under r b) \\<or>\n                         (t, u)\n                         \\<in> conversion' L L E (under r a) O\n                               (L b)\\<^sup>= O\n                               conversion' L L E\n                                (under r a \\<union> under r b)", "case (rcliff a b s t u)"], ["proof (state)\nthis:\n  (s, t) \\<in> (E a)\\<inverse>\n  (s, u) \\<in> L b\n\ngoal (5 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> L b\\<rbrakk>\n       \\<Longrightarrow> (t, u)\n                         \\<in> conversion' L L E (under r a) O\n                               (L b)\\<^sup>= O\n                               conversion' L L E\n                                (under r a \\<union> under r b) O\n                               ((L a)\\<inverse>)\\<^sup>= O\n                               conversion' L L E (under r b)\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> (t, u)\n                         \\<in> conversion' L L E (under r a) O\n                               E b O\n                               conversion' L L E (under r a) O\n                               ((L a)\\<inverse>)\\<^sup>= O\n                               conversion' L L E\n                                (under r a \\<inter> under r b) \\<or>\n                         (t, u)\n                         \\<in> conversion' L L E\n                                (under r a \\<union> under r b) O\n                               ((L a)\\<inverse>)\\<^sup>= O\n                               conversion' L L E (under r b)\n 5. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> (E a)\\<inverse>; (s, u) \\<in> L b\\<rbrakk>\n       \\<Longrightarrow> (t, u)\n                         \\<in> conversion' L L E\n                                (under r a \\<inter> under r b) O\n                               (L b)\\<^sup>= O\n                               conversion' L L E (under r b) O\n                               E a O conversion' L L E (under r b) \\<or>\n                         (t, u)\n                         \\<in> conversion' L L E (under r a) O\n                               (L b)\\<^sup>= O\n                               conversion' L L E\n                                (under r a \\<union> under r b)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (t, u)\n    \\<in> conversion' L L E (under r a \\<inter> under r b) O\n          (L b)\\<^sup>= O\n          conversion' L L E (under r b) O\n          E a O conversion' L L E (under r b) \\<or>\n    (t, u)\n    \\<in> conversion' L L E (under r a) O\n          (L b)\\<^sup>= O conversion' L L E (under r a \\<union> under r b)", "using cl[OF rcliff(2) rcliff(1)[unfolded E'], unfolded converse_iff[of t u,symmetric]]"], ["proof (prove)\nusing this:\n  (t, u)\n  \\<in> (conversion' L L E (under r b) O\n         E a O\n         conversion' L L E (under r b) O\n         ((L b)\\<inverse>)\\<^sup>= O\n         conversion' L L E (under r b \\<inter> under r a))\\<inverse> \\<or>\n  (t, u)\n  \\<in> (conversion' L L E (under r b \\<union> under r a) O\n         ((L b)\\<inverse>)\\<^sup>= O\n         conversion' L L E (under r a))\\<inverse>\n\ngoal (1 subgoal):\n 1. (t, u)\n    \\<in> conversion' L L E (under r a \\<inter> under r b) O\n          (L b)\\<^sup>= O\n          conversion' L L E (under r b) O\n          E a O conversion' L L E (under r b) \\<or>\n    (t, u)\n    \\<in> conversion' L L E (under r a) O\n          (L b)\\<^sup>= O conversion' L L E (under r a \\<union> under r b)", "by (auto simp only: E' converse_inward) (auto simp only: ac_simps)"], ["proof (state)\nthis:\n  (t, u)\n  \\<in> conversion' L L E (under r a \\<inter> under r b) O\n        (L b)\\<^sup>= O\n        conversion' L L E (under r b) O\n        E a O conversion' L L E (under r b) \\<or>\n  (t, u)\n  \\<in> conversion' L L E (under r a) O\n        (L b)\\<^sup>= O conversion' L L E (under r a \\<union> under r b)\n\ngoal (4 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> L b\\<rbrakk>\n       \\<Longrightarrow> (t, u)\n                         \\<in> conversion' L L E (under r a) O\n                               (L b)\\<^sup>= O\n                               conversion' L L E\n                                (under r a \\<union> under r b) O\n                               ((L a)\\<inverse>)\\<^sup>= O\n                               conversion' L L E (under r b)\n 4. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> E b\\<rbrakk>\n       \\<Longrightarrow> (t, u)\n                         \\<in> conversion' L L E (under r a) O\n                               E b O\n                               conversion' L L E (under r a) O\n                               ((L a)\\<inverse>)\\<^sup>= O\n                               conversion' L L E\n                                (under r a \\<inter> under r b) \\<or>\n                         (t, u)\n                         \\<in> conversion' L L E\n                                (under r a \\<union> under r b) O\n                               ((L a)\\<inverse>)\\<^sup>= O\n                               conversion' L L E (under r b)", "qed fact+"], ["", "subsection \\<open>Commutation and confluence\\<close>"], ["", "abbreviation \"conversion'' L R M \\<equiv> ((\\<Union>i \\<in> M. R i) \\<union> (\\<Union>i \\<in> M. L i)\\<inverse>)\\<^sup>*\""], ["", "abbreviation \"valley'' L R M \\<equiv> (\\<Union>i \\<in> M. R i)\\<^sup>* O ((\\<Union>i \\<in> M. L i)\\<inverse>)\\<^sup>*\""], ["", "text \\<open>Decreasing diagrams for commutation.\\<close>"], ["", "lemma dd_commute[case_names wf trans peak]:\n  assumes \"wf r\" and \"trans r\"\n  and pk: \"\\<And>a b s t u. (s, t) \\<in> L a \\<Longrightarrow> (s, u) \\<in> R b \\<Longrightarrow>\n    (t, u) \\<in> conversion'' L R (under r a) O (R b)\\<^sup>= O conversion'' L R (under r a \\<union> under r b) O\n      ((L a)\\<inverse>)\\<^sup>= O conversion'' L R (under r b)\"\n  shows \"commute (\\<Union>i. L i) (\\<Union>i. R i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. commute (\\<Union> (range L)) (\\<Union> (range R))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. commute (\\<Union> (range L)) (\\<Union> (range R))", "have \"((\\<Union>i. L i)\\<inverse>)\\<^sup>* O (\\<Union>i. R i)\\<^sup>* \\<subseteq> conversion'' L R UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Union> (range L))\\<inverse>)\\<^sup>* O (\\<Union> (range R))\\<^sup>*\n    \\<subseteq> (\\<Union> (range R) \\<union>\n                 (\\<Union> (range L))\\<inverse>)\\<^sup>*", "by regexp"], ["proof (state)\nthis:\n  ((\\<Union> (range L))\\<inverse>)\\<^sup>* O (\\<Union> (range R))\\<^sup>*\n  \\<subseteq> (\\<Union> (range R) \\<union>\n               (\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (1 subgoal):\n 1. commute (\\<Union> (range L)) (\\<Union> (range R))", "also"], ["proof (state)\nthis:\n  ((\\<Union> (range L))\\<inverse>)\\<^sup>* O (\\<Union> (range R))\\<^sup>*\n  \\<subseteq> (\\<Union> (range R) \\<union>\n               (\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (1 subgoal):\n 1. commute (\\<Union> (range L)) (\\<Union> (range R))", "have \"\\<dots> \\<subseteq> valley'' L R UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union> (range R) \\<union> (\\<Union> (range L))\\<inverse>)\\<^sup>*\n    \\<subseteq> (\\<Union> (range R))\\<^sup>* O\n                ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "using dd_commute_modulo[OF assms(1,2), of L R \"\\<lambda>_. {}\"] pk"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>a b s t u.\n              \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> R b\\<rbrakk>\n              \\<Longrightarrow> (t, u)\n                                \\<in> conversion' L R (\\<lambda>i. {})\n (under r a) O\n(R b)\\<^sup>= O\nconversion' L R (\\<lambda>i. {}) (under r a \\<union> under r b) O\n((L a)\\<inverse>)\\<^sup>= O conversion' L R (\\<lambda>i. {}) (under r b);\n   \\<And>a b s t u.\n      \\<lbrakk>(s, t) \\<in> L a; (s, u) \\<in> {}\\<rbrakk>\n      \\<Longrightarrow> (t, u)\n                        \\<in> conversion' L R (\\<lambda>i. {}) (under r a) O\n                              {} O\n                              conversion' L R (\\<lambda>i. {}) (under r a) O\n                              ((L a)\\<inverse>)\\<^sup>= O\n                              conversion' L R (\\<lambda>i. {})\n                               (under r a \\<inter> under r b) \\<or>\n                        (t, u)\n                        \\<in> conversion' L R (\\<lambda>i. {})\n                               (under r a \\<union> under r b) O\n                              ((L a)\\<inverse>)\\<^sup>= O\n                              conversion' L R (\\<lambda>i. {}) (under r b);\n   \\<And>a b s t u.\n      \\<lbrakk>(s, t) \\<in> {}\\<inverse>; (s, u) \\<in> R b\\<rbrakk>\n      \\<Longrightarrow> (t, u)\n                        \\<in> conversion' L R (\\<lambda>i. {})\n                               (under r a \\<inter> under r b) O\n                              (R b)\\<^sup>= O\n                              conversion' L R (\\<lambda>i. {}) (under r b) O\n                              {} O\n                              conversion' L R (\\<lambda>i. {})\n                               (under r b) \\<or>\n                        (t, u)\n                        \\<in> conversion' L R (\\<lambda>i. {}) (under r a) O\n                              (R b)\\<^sup>= O\n                              conversion' L R (\\<lambda>i. {})\n                               (under r a \\<union> under r b)\\<rbrakk>\n  \\<Longrightarrow> (\\<Union> (range R) \\<union> (\\<Union>i. {}) \\<union>\n                     (\\<Union> (range L))\\<inverse>)\\<^sup>*\n                    \\<subseteq> (\\<Union> (range R))\\<^sup>* O\n                                (\\<Union>i. {})\\<^sup>* O\n                                ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n  \\<lbrakk>(?s, ?t) \\<in> L ?a; (?s, ?u) \\<in> R ?b\\<rbrakk>\n  \\<Longrightarrow> (?t, ?u)\n                    \\<in> conversion'' L R (under r ?a) O\n                          (R ?b)\\<^sup>= O\n                          conversion'' L R\n                           (under r ?a \\<union> under r ?b) O\n                          ((L ?a)\\<inverse>)\\<^sup>= O\n                          conversion'' L R (under r ?b)\n\ngoal (1 subgoal):\n 1. (\\<Union> (range R) \\<union> (\\<Union> (range L))\\<inverse>)\\<^sup>*\n    \\<subseteq> (\\<Union> (range R))\\<^sup>* O\n                ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (\\<Union> (range R) \\<union> (\\<Union> (range L))\\<inverse>)\\<^sup>*\n  \\<subseteq> (\\<Union> (range R))\\<^sup>* O\n              ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (1 subgoal):\n 1. commute (\\<Union> (range L)) (\\<Union> (range R))", "finally"], ["proof (chain)\npicking this:\n  ((\\<Union> (range L))\\<inverse>)\\<^sup>* O (\\<Union> (range R))\\<^sup>*\n  \\<subseteq> (\\<Union> (range R))\\<^sup>* O\n              ((\\<Union> (range L))\\<inverse>)\\<^sup>*", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<Union> (range L))\\<inverse>)\\<^sup>* O (\\<Union> (range R))\\<^sup>*\n  \\<subseteq> (\\<Union> (range R))\\<^sup>* O\n              ((\\<Union> (range L))\\<inverse>)\\<^sup>*\n\ngoal (1 subgoal):\n 1. commute (\\<Union> (range L)) (\\<Union> (range R))", "by (simp only: commute_def)"], ["proof (state)\nthis:\n  commute (\\<Union> (range L)) (\\<Union> (range R))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Decreasing diagrams for confluence.\\<close>"], ["", "lemmas dd_cr[case_names wf trans peak] =\n  dd_commute[of _ L L for L, unfolded CR_iff_self_commute[symmetric]]"], ["", "subsection \\<open>Extended decreasing diagrams\\<close>"], ["", "context\n  fixes r q :: \"'b rel\"\n  assumes \"wf r\" and \"trans r\" and \"trans q\" and \"refl q\" and compat: \"r O q \\<subseteq> r\"\nbegin"], ["", "private"], ["", "abbreviation (input) down :: \"('b \\<Rightarrow> 'a rel) \\<Rightarrow> ('b \\<Rightarrow> 'a rel)\" where\n  \"down L \\<equiv> \\<lambda>i. \\<Union>j \\<in> under q i. L j\""], ["", "private"], ["", "lemma Union_down: \"(\\<Union>i. down L i) = (\\<Union>i. L i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>i. \\<Union> (L ` under q i)) = \\<Union> (range L)", "using \\<open>refl q\\<close>"], ["proof (prove)\nusing this:\n  refl q\n\ngoal (1 subgoal):\n 1. (\\<Union>i. \\<Union> (L ` under q i)) = \\<Union> (range L)", "by (auto simp: refl_on_def under_def)"], ["", "text \\<open>Extended decreasing diagrams for commutation.\\<close>"], ["", "lemma edd_commute[case_names wf transr transq reflq compat peak]:\n  assumes pk: \"\\<And>a b s t u. (s, t) \\<in> L a \\<Longrightarrow> (s, u) \\<in> R b \\<Longrightarrow>\n    (t, u) \\<in> conversion'' L R (under r a) O (down R b)\\<^sup>= O conversion'' L R (under r a \\<union> under r b) O\n      ((down L a)\\<inverse>)\\<^sup>= O conversion'' L R (under r b)\"\n  shows \"commute (\\<Union>i. L i) (\\<Union>i. R i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. commute (\\<Union> (range L)) (\\<Union> (range R))", "unfolding Union_down[of L, symmetric] Union_down[of R, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. commute (\\<Union>i. \\<Union> (L ` under q i))\n     (\\<Union>i. \\<Union> (R ` under q i))", "proof (induct rule: dd_commute[of r \"down L\" \"down R\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> \\<Union> (L ` under q a);\n        (s, u) \\<in> \\<Union> (R ` under q b)\\<rbrakk>\n       \\<Longrightarrow> (t, u)\n                         \\<in> conversion''\n                                (\\<lambda>i. \\<Union> (L ` under q i))\n                                (\\<lambda>i. \\<Union> (R ` under q i))\n                                (under r a) O\n                               (\\<Union> (R ` under q b))\\<^sup>= O\n                               conversion''\n                                (\\<lambda>i. \\<Union> (L ` under q i))\n                                (\\<lambda>i. \\<Union> (R ` under q i))\n                                (under r a \\<union> under r b) O\n                               ((\\<Union>\n                                  (L ` under q a))\\<inverse>)\\<^sup>= O\n                               conversion''\n                                (\\<lambda>i. \\<Union> (L ` under q i))\n                                (\\<lambda>i. \\<Union> (R ` under q i))\n                                (under r b)", "case (peak a b s t u)"], ["proof (state)\nthis:\n  (s, t) \\<in> \\<Union> (L ` under q a)\n  (s, u) \\<in> \\<Union> (R ` under q b)\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> \\<Union> (L ` under q a);\n        (s, u) \\<in> \\<Union> (R ` under q b)\\<rbrakk>\n       \\<Longrightarrow> (t, u)\n                         \\<in> conversion''\n                                (\\<lambda>i. \\<Union> (L ` under q i))\n                                (\\<lambda>i. \\<Union> (R ` under q i))\n                                (under r a) O\n                               (\\<Union> (R ` under q b))\\<^sup>= O\n                               conversion''\n                                (\\<lambda>i. \\<Union> (L ` under q i))\n                                (\\<lambda>i. \\<Union> (R ` under q i))\n                                (under r a \\<union> under r b) O\n                               ((\\<Union>\n                                  (L ` under q a))\\<inverse>)\\<^sup>= O\n                               conversion''\n                                (\\<lambda>i. \\<Union> (L ` under q i))\n                                (\\<lambda>i. \\<Union> (R ` under q i))\n                                (under r b)", "then"], ["proof (chain)\npicking this:\n  (s, t) \\<in> \\<Union> (L ` under q a)\n  (s, u) \\<in> \\<Union> (R ` under q b)", "obtain a' b' where a': \"(a', a) \\<in> q\" \"(s, t) \\<in> L a'\" and b': \"(b', b) \\<in> q\" \"(s, u) \\<in> R b'\""], ["proof (prove)\nusing this:\n  (s, t) \\<in> \\<Union> (L ` under q a)\n  (s, u) \\<in> \\<Union> (R ` under q b)\n\ngoal (1 subgoal):\n 1. (\\<And>a' b'.\n        \\<lbrakk>(a', a) \\<in> q; (s, t) \\<in> L a'; (b', b) \\<in> q;\n         (s, u) \\<in> R b'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: under_def)"], ["proof (state)\nthis:\n  (a', a) \\<in> q\n  (s, t) \\<in> L a'\n  (b', b) \\<in> q\n  (s, u) \\<in> R b'\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> \\<Union> (L ` under q a);\n        (s, u) \\<in> \\<Union> (R ` under q b)\\<rbrakk>\n       \\<Longrightarrow> (t, u)\n                         \\<in> conversion''\n                                (\\<lambda>i. \\<Union> (L ` under q i))\n                                (\\<lambda>i. \\<Union> (R ` under q i))\n                                (under r a) O\n                               (\\<Union> (R ` under q b))\\<^sup>= O\n                               conversion''\n                                (\\<lambda>i. \\<Union> (L ` under q i))\n                                (\\<lambda>i. \\<Union> (R ` under q i))\n                                (under r a \\<union> under r b) O\n                               ((\\<Union>\n                                  (L ` under q a))\\<inverse>)\\<^sup>= O\n                               conversion''\n                                (\\<lambda>i. \\<Union> (L ` under q i))\n                                (\\<lambda>i. \\<Union> (R ` under q i))\n                                (under r b)", "have \"\\<And>a' a. (a',a) \\<in> q \\<Longrightarrow> under r a' \\<subseteq> under r a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a' a.\n       (a', a) \\<in> q \\<Longrightarrow> under r a' \\<subseteq> under r a", "using compat"], ["proof (prove)\nusing this:\n  r O q \\<subseteq> r\n\ngoal (1 subgoal):\n 1. \\<And>a' a.\n       (a', a) \\<in> q \\<Longrightarrow> under r a' \\<subseteq> under r a", "by (auto simp: under_def)"], ["proof (state)\nthis:\n  (?a'1, ?a1) \\<in> q \\<Longrightarrow> under r ?a'1 \\<subseteq> under r ?a1\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> \\<Union> (L ` under q a);\n        (s, u) \\<in> \\<Union> (R ` under q b)\\<rbrakk>\n       \\<Longrightarrow> (t, u)\n                         \\<in> conversion''\n                                (\\<lambda>i. \\<Union> (L ` under q i))\n                                (\\<lambda>i. \\<Union> (R ` under q i))\n                                (under r a) O\n                               (\\<Union> (R ` under q b))\\<^sup>= O\n                               conversion''\n                                (\\<lambda>i. \\<Union> (L ` under q i))\n                                (\\<lambda>i. \\<Union> (R ` under q i))\n                                (under r a \\<union> under r b) O\n                               ((\\<Union>\n                                  (L ` under q a))\\<inverse>)\\<^sup>= O\n                               conversion''\n                                (\\<lambda>i. \\<Union> (L ` under q i))\n                                (\\<lambda>i. \\<Union> (R ` under q i))\n                                (under r b)", "then"], ["proof (chain)\npicking this:\n  (?a'1, ?a1) \\<in> q \\<Longrightarrow> under r ?a'1 \\<subseteq> under r ?a1", "have aux1: \"\\<And>a' a L. (a',a) \\<in> q \\<Longrightarrow> (\\<Union>i \\<in> under r a'. L i) \\<subseteq> (\\<Union>i \\<in> under r a. L i)\""], ["proof (prove)\nusing this:\n  (?a'1, ?a1) \\<in> q \\<Longrightarrow> under r ?a'1 \\<subseteq> under r ?a1\n\ngoal (1 subgoal):\n 1. \\<And>a' a L.\n       (a', a) \\<in> q \\<Longrightarrow>\n       \\<Union> (L ` under r a') \\<subseteq> \\<Union> (L ` under r a)", "by auto"], ["proof (state)\nthis:\n  (?a'1, ?a1) \\<in> q \\<Longrightarrow>\n  \\<Union> (?L1 ` under r ?a'1) \\<subseteq> \\<Union> (?L1 ` under r ?a1)\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> \\<Union> (L ` under q a);\n        (s, u) \\<in> \\<Union> (R ` under q b)\\<rbrakk>\n       \\<Longrightarrow> (t, u)\n                         \\<in> conversion''\n                                (\\<lambda>i. \\<Union> (L ` under q i))\n                                (\\<lambda>i. \\<Union> (R ` under q i))\n                                (under r a) O\n                               (\\<Union> (R ` under q b))\\<^sup>= O\n                               conversion''\n                                (\\<lambda>i. \\<Union> (L ` under q i))\n                                (\\<lambda>i. \\<Union> (R ` under q i))\n                                (under r a \\<union> under r b) O\n                               ((\\<Union>\n                                  (L ` under q a))\\<inverse>)\\<^sup>= O\n                               conversion''\n                                (\\<lambda>i. \\<Union> (L ` under q i))\n                                (\\<lambda>i. \\<Union> (R ` under q i))\n                                (under r b)", "have aux2: \"\\<And>a' a L. (a',a) \\<in> q \\<Longrightarrow> down L a' \\<subseteq> down L a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a' a L.\n       (a', a) \\<in> q \\<Longrightarrow>\n       \\<Union> (L ` under q a') \\<subseteq> \\<Union> (L ` under q a)", "using \\<open>trans q\\<close>"], ["proof (prove)\nusing this:\n  trans q\n\ngoal (1 subgoal):\n 1. \\<And>a' a L.\n       (a', a) \\<in> q \\<Longrightarrow>\n       \\<Union> (L ` under q a') \\<subseteq> \\<Union> (L ` under q a)", "by (auto simp: under_def trans_def)"], ["proof (state)\nthis:\n  (?a'2, ?a2) \\<in> q \\<Longrightarrow>\n  \\<Union> (?L2 ` under q ?a'2) \\<subseteq> \\<Union> (?L2 ` under q ?a2)\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> \\<Union> (L ` under q a);\n        (s, u) \\<in> \\<Union> (R ` under q b)\\<rbrakk>\n       \\<Longrightarrow> (t, u)\n                         \\<in> conversion''\n                                (\\<lambda>i. \\<Union> (L ` under q i))\n                                (\\<lambda>i. \\<Union> (R ` under q i))\n                                (under r a) O\n                               (\\<Union> (R ` under q b))\\<^sup>= O\n                               conversion''\n                                (\\<lambda>i. \\<Union> (L ` under q i))\n                                (\\<lambda>i. \\<Union> (R ` under q i))\n                                (under r a \\<union> under r b) O\n                               ((\\<Union>\n                                  (L ` under q a))\\<inverse>)\\<^sup>= O\n                               conversion''\n                                (\\<lambda>i. \\<Union> (L ` under q i))\n                                (\\<lambda>i. \\<Union> (R ` under q i))\n                                (under r b)", "have aux3: \"\\<And>a L. (\\<Union>i \\<in> under r a. L i) \\<subseteq> (\\<Union>i \\<in> under r a. down L i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<Union> (L ` under r a)\n       \\<subseteq> (\\<Union>i\\<in>under r a. \\<Union> (L ` under q i))", "using \\<open>refl q\\<close>"], ["proof (prove)\nusing this:\n  refl q\n\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<Union> (L ` under r a)\n       \\<subseteq> (\\<Union>i\\<in>under r a. \\<Union> (L ` under q i))", "by (auto simp: under_def refl_on_def)"], ["proof (state)\nthis:\n  \\<Union> (?L3 ` under r ?a3)\n  \\<subseteq> (\\<Union>i\\<in>under r ?a3. \\<Union> (?L3 ` under q i))\n\ngoal (3 subgoals):\n 1. wf r\n 2. trans r\n 3. \\<And>a b s t u.\n       \\<lbrakk>(s, t) \\<in> \\<Union> (L ` under q a);\n        (s, u) \\<in> \\<Union> (R ` under q b)\\<rbrakk>\n       \\<Longrightarrow> (t, u)\n                         \\<in> conversion''\n                                (\\<lambda>i. \\<Union> (L ` under q i))\n                                (\\<lambda>i. \\<Union> (R ` under q i))\n                                (under r a) O\n                               (\\<Union> (R ` under q b))\\<^sup>= O\n                               conversion''\n                                (\\<lambda>i. \\<Union> (L ` under q i))\n                                (\\<lambda>i. \\<Union> (R ` under q i))\n                                (under r a \\<union> under r b) O\n                               ((\\<Union>\n                                  (L ` under q a))\\<inverse>)\\<^sup>= O\n                               conversion''\n                                (\\<lambda>i. \\<Union> (L ` under q i))\n                                (\\<lambda>i. \\<Union> (R ` under q i))\n                                (under r b)", "from aux1[OF a'(1), of L] aux1[OF a'(1), of R] aux2[OF a'(1), of L]\n       aux1[OF b'(1), of L] aux1[OF b'(1), of R] aux2[OF b'(1), of R]\n       aux3[of L] aux3[of R]"], ["proof (chain)\npicking this:\n  \\<Union> (L ` under r a') \\<subseteq> \\<Union> (L ` under r a)\n  \\<Union> (R ` under r a') \\<subseteq> \\<Union> (R ` under r a)\n  \\<Union> (L ` under q a') \\<subseteq> \\<Union> (L ` under q a)\n  \\<Union> (L ` under r b') \\<subseteq> \\<Union> (L ` under r b)\n  \\<Union> (R ` under r b') \\<subseteq> \\<Union> (R ` under r b)\n  \\<Union> (R ` under q b') \\<subseteq> \\<Union> (R ` under q b)\n  \\<Union> (L ` under r ?a3)\n  \\<subseteq> (\\<Union>i\\<in>under r ?a3. \\<Union> (L ` under q i))\n  \\<Union> (R ` under r ?a3)\n  \\<subseteq> (\\<Union>i\\<in>under r ?a3. \\<Union> (R ` under q i))", "show ?case"], ["proof (prove)\nusing this:\n  \\<Union> (L ` under r a') \\<subseteq> \\<Union> (L ` under r a)\n  \\<Union> (R ` under r a') \\<subseteq> \\<Union> (R ` under r a)\n  \\<Union> (L ` under q a') \\<subseteq> \\<Union> (L ` under q a)\n  \\<Union> (L ` under r b') \\<subseteq> \\<Union> (L ` under r b)\n  \\<Union> (R ` under r b') \\<subseteq> \\<Union> (R ` under r b)\n  \\<Union> (R ` under q b') \\<subseteq> \\<Union> (R ` under q b)\n  \\<Union> (L ` under r ?a3)\n  \\<subseteq> (\\<Union>i\\<in>under r ?a3. \\<Union> (L ` under q i))\n  \\<Union> (R ` under r ?a3)\n  \\<subseteq> (\\<Union>i\\<in>under r ?a3. \\<Union> (R ` under q i))\n\ngoal (1 subgoal):\n 1. (t, u)\n    \\<in> conversion'' (\\<lambda>i. \\<Union> (L ` under q i))\n           (\\<lambda>i. \\<Union> (R ` under q i)) (under r a) O\n          (\\<Union> (R ` under q b))\\<^sup>= O\n          conversion'' (\\<lambda>i. \\<Union> (L ` under q i))\n           (\\<lambda>i. \\<Union> (R ` under q i))\n           (under r a \\<union> under r b) O\n          ((\\<Union> (L ` under q a))\\<inverse>)\\<^sup>= O\n          conversion'' (\\<lambda>i. \\<Union> (L ` under q i))\n           (\\<lambda>i. \\<Union> (R ` under q i)) (under r b)", "by (intro subsetD[OF _ pk[OF \\<open>(s, t) \\<in> L a'\\<close> \\<open>(s, u) \\<in> R b'\\<close>]], unfold UN_Un)\n     (intro relcomp_mono rtrancl_mono Un_mono iffD2[OF converse_mono]; fast)"], ["proof (state)\nthis:\n  (t, u)\n  \\<in> conversion'' (\\<lambda>i. \\<Union> (L ` under q i))\n         (\\<lambda>i. \\<Union> (R ` under q i)) (under r a) O\n        (\\<Union> (R ` under q b))\\<^sup>= O\n        conversion'' (\\<lambda>i. \\<Union> (L ` under q i))\n         (\\<lambda>i. \\<Union> (R ` under q i))\n         (under r a \\<union> under r b) O\n        ((\\<Union> (L ` under q a))\\<inverse>)\\<^sup>= O\n        conversion'' (\\<lambda>i. \\<Union> (L ` under q i))\n         (\\<lambda>i. \\<Union> (R ` under q i)) (under r b)\n\ngoal (2 subgoals):\n 1. wf r\n 2. trans r", "qed fact+"], ["", "text \\<open>Extended decreasing diagrams for confluence.\\<close>"], ["", "lemmas edd_cr[case_names wf transr transq reflq compat peak] =\n  edd_commute[of L L for L, unfolded CR_iff_self_commute[symmetric]]"], ["", "end"], ["", "(* context *)"], ["", "end"], ["", "(* Decreasing_Diagrams_II *)"]]}