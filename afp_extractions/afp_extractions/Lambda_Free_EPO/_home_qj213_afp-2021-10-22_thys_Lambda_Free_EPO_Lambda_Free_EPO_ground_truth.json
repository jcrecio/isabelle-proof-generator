{"file_name": "/home/qj213/afp-2021-10-22/thys/Lambda_Free_EPO/Lambda_Free_EPO.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Lambda_Free_EPO", "problem_names": ["lemma extf_ext_trans: \"ext_trans (extf f)\"", "lemma extf_ext: \"ext (extf f)\"", "lemmas extf_mono_strong = ext.mono_strong[OF extf_ext]", "lemmas extf_mono = ext.mono[OF extf_ext, mono]", "lemmas extf_map = ext.map[OF extf_ext]", "lemmas extf_trans = ext_trans.trans[OF extf_ext_trans]", "lemmas extf_irrefl_from_trans =\n  ext_trans_before_irrefl.irrefl_from_trans[OF extf_ext_trans_before_irrefl]", "lemmas extf_compat_list = ext_compat_list.compat_list[OF extf_ext_compat_list]", "lemmas extf_snoc = ext_snoc.snoc[OF extf_ext_snoc]", "lemmas extf_compat_append_right = ext_compat_snoc.compat_append_right[OF extf_ext_compat_snoc]", "lemmas extf_compat_append_left = ext_compat_cons.compat_append_left[OF extf_ext_compat_cons]", "lemma extf_ext_insert_arg: \"extf f gt (xs @ z # ys) (xs @ ys)\"", "lemma chkchop_mono[mono]: \"gt \\<le> gt' \\<Longrightarrow> chkchop gt \\<le> chkchop gt'\"", "lemma chkchop_same_mono[mono]: \"gt \\<le> gt' \\<Longrightarrow> chkchop_same gt \\<le> chkchop_same gt'\"", "lemma gt_iff_chop_diff_same: \"t >\\<^sub>t s \\<longleftrightarrow> gt_chop t s \\<or> gt_diff t s \\<or> gt_same t s\"", "lemma t_gt_chop_t: \"is_App t \\<Longrightarrow> t >\\<^sub>t chop t\"", "lemma gt_imp_vars: \"t >\\<^sub>t s \\<Longrightarrow> vars t \\<supseteq> vars s\"", "lemma gt_trans: \"u >\\<^sub>t t \\<Longrightarrow> t >\\<^sub>t s \\<Longrightarrow> u >\\<^sub>t s\"", "theorem gt_irrefl: \"\\<not> s >\\<^sub>t s\"", "lemma gt_antisym: \"t >\\<^sub>t s \\<Longrightarrow> \\<not> s >\\<^sub>t t\"", "lemma nth_drop_lemma:\n  assumes \"length xs = length ys\"\nand \"k \\<le> length xs\"\nand \"\\<And>i. i < length xs \\<longrightarrow> i \\<ge> k \\<longrightarrow> xs ! i = ys ! i\"\nshows \"drop k xs = drop k ys\"", "lemma gt_embedding_step_property:\n  assumes \"t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\"\n  shows \"t >\\<^sub>t s\"", "lemma gt_embedding_property:\n  assumes \"t \\<unrhd>\\<^sub>e\\<^sub>m\\<^sub>b s\" \"t \\<noteq> s\"\n  shows \"t >\\<^sub>t s\"", "theorem gt_proper_sub: \"proper_sub s t \\<Longrightarrow> t >\\<^sub>t s\"", "lemma\n  gt_emb_fun: \"App s t >\\<^sub>t s\" and\n  gt_emb_arg: \"App s t >\\<^sub>t t\"", "lemma gt_fun_imp: \"fun t >\\<^sub>t s \\<Longrightarrow> t >\\<^sub>t s\"", "lemma gt_arg_imp: \"arg t >\\<^sub>t s \\<Longrightarrow> t >\\<^sub>t s\"", "lemma gt_compat_fun:\n  assumes \"t' >\\<^sub>t t\"\n  shows \"App s t' >\\<^sub>t App s t\"", "theorem gt_compat_arg:\n  shows \"s' >\\<^sub>t s \\<Longrightarrow> t' \\<ge>\\<^sub>t t \\<Longrightarrow> App s' t' >\\<^sub>t App s t\"", "theorem gt_compat_fun_strong:\n  assumes t'_gt_t: \"t' >\\<^sub>t t\"\n  shows \"apps s (t' # us) >\\<^sub>t apps s (t # us)\"", "theorem gt_or_eq_compat_App: \"s' \\<ge>\\<^sub>t s \\<Longrightarrow> t' \\<ge>\\<^sub>t t \\<Longrightarrow> App s' t' \\<ge>\\<^sub>t App s t\"", "theorem gt_compat_App:\n  shows \"s' \\<ge>\\<^sub>t s \\<Longrightarrow> t' >\\<^sub>t t \\<Longrightarrow> App s' t' >\\<^sub>t App s t\"", "lemma extf_map2:\n  assumes\n    \"\\<forall>y\\<in>set ys \\<union> set xs. \\<forall>x\\<in>set ys \\<union> set xs. y >\\<^sub>t x \\<longrightarrow> (h y) >\\<^sub>t (h x)\"\n    \"extf f (>\\<^sub>t) ys xs\"\n  shows\n    \"extf f (>\\<^sub>t) (map h ys) (map h xs)\"", "theorem gt_sus: \n  assumes \\<rho>_wary: \"wary_subst \\<rho>\"\n  assumes ghd: \"\\<And>x. ground_heads (Var x) = UNIV\" (* This condition is only needed for gt_same, not for gt_diff ! *)\n  shows \"t >\\<^sub>t s \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\"", "theorem gt_total_ground:\n  assumes extf_total: \"\\<And>f. ext_total (extf f)\"\n  shows \"ground t \\<Longrightarrow> ground s \\<Longrightarrow> t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\"", "theorem gt_wf:\n  assumes ghd_UNIV: \"\\<And>x. ground_heads_var x = UNIV\"\n  assumes extf_wf: \"\\<And>f. ext_wf (extf f)\"\n  shows \"wfP (\\<lambda>s t. t >\\<^sub>t s)\""], "translations": [["", "lemma extf_ext_trans: \"ext_trans (extf f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ext_trans (extf f)", "by (rule ext_trans_before_irrefl.axioms(1)[OF extf_ext_trans_before_irrefl])"], ["", "lemma extf_ext: \"ext (extf f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ext (extf f)", "by (rule ext_trans.axioms(1)[OF extf_ext_trans])"], ["", "lemmas extf_mono_strong = ext.mono_strong[OF extf_ext]"], ["", "lemmas extf_mono = ext.mono[OF extf_ext, mono]"], ["", "lemmas extf_map = ext.map[OF extf_ext]"], ["", "lemmas extf_trans = ext_trans.trans[OF extf_ext_trans]"], ["", "lemmas extf_irrefl_from_trans =\n  ext_trans_before_irrefl.irrefl_from_trans[OF extf_ext_trans_before_irrefl]"], ["", "lemmas extf_compat_list = ext_compat_list.compat_list[OF extf_ext_compat_list]"], ["", "lemmas extf_snoc = ext_snoc.snoc[OF extf_ext_snoc]"], ["", "lemmas extf_compat_append_right = ext_compat_snoc.compat_append_right[OF extf_ext_compat_snoc]"], ["", "lemmas extf_compat_append_left = ext_compat_cons.compat_append_left[OF extf_ext_compat_cons]"], ["", "lemma extf_ext_insert_arg: \"extf f gt (xs @ z # ys) (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extf f gt (xs @ z # ys) (xs @ ys)", "using extf_compat_append_left extf_compat_append_right extf_snoc[of f gt Nil z]"], ["proof (prove)\nusing this:\n  extf ?f ?gt ?ys ?xs \\<Longrightarrow> extf ?f ?gt (?zs @ ?ys) (?zs @ ?xs)\n  extf ?f ?gt ?ys ?xs \\<Longrightarrow> extf ?f ?gt (?ys @ ?zs) (?xs @ ?zs)\n  extf f gt ([] @ [z]) []\n\ngoal (1 subgoal):\n 1. extf f gt (xs @ z # ys) (xs @ ys)", "by fastforce"], ["", "subsection \\<open>Inductive Definitions\\<close>"], ["", "definition\n  chkchop :: \"(('s, 'v) tm \\<Rightarrow> ('s, 'v) tm \\<Rightarrow> bool) \\<Rightarrow> ('s, 'v) tm \\<Rightarrow> ('s, 'v) tm \\<Rightarrow> bool\"\nwhere\n  [simp]: \"chkchop gt t s \\<longleftrightarrow> is_Hd s \\<or> gt t (chop s)\""], ["", "definition\n  chkchop_same :: \"(('s, 'v) tm \\<Rightarrow> ('s, 'v) tm \\<Rightarrow> bool) \\<Rightarrow> ('s, 'v) tm \\<Rightarrow> ('s, 'v) tm \\<Rightarrow> bool\"\nwhere\n  [simp]: \"chkchop_same gt t s \\<longleftrightarrow> \n            (if is_Var (head t) \n            then is_Hd t \\<or> chkchop gt (chop t) s \n            else chkchop gt t s)\""], ["", "lemma chkchop_mono[mono]: \"gt \\<le> gt' \\<Longrightarrow> chkchop gt \\<le> chkchop gt'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gt \\<le> gt' \\<Longrightarrow> chkchop gt \\<le> chkchop gt'", "using chkchop_def"], ["proof (prove)\nusing this:\n  chkchop ?gt ?t ?s = (is_Hd ?s \\<or> ?gt ?t (chop ?s))\n\ngoal (1 subgoal):\n 1. gt \\<le> gt' \\<Longrightarrow> chkchop gt \\<le> chkchop gt'", "by blast"], ["", "lemma chkchop_same_mono[mono]: \"gt \\<le> gt' \\<Longrightarrow> chkchop_same gt \\<le> chkchop_same gt'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gt \\<le> gt' \\<Longrightarrow> chkchop_same gt \\<le> chkchop_same gt'", "using chkchop_same_def"], ["proof (prove)\nusing this:\n  chkchop_same ?gt ?t ?s =\n  (if is_Var (head ?t) then is_Hd ?t \\<or> chkchop ?gt (chop ?t) ?s\n   else chkchop ?gt ?t ?s)\n\ngoal (1 subgoal):\n 1. gt \\<le> gt' \\<Longrightarrow> chkchop_same gt \\<le> chkchop_same gt'", "by fastforce"], ["", "inductive gt :: \"('s, 'v) tm \\<Rightarrow> ('s, 'v) tm \\<Rightarrow> bool\" (infix \">\\<^sub>t\" 50) where\n  gt_chop: \"is_App t \\<Longrightarrow> chop t >\\<^sub>t s \\<or> chop t = s \\<Longrightarrow> t >\\<^sub>t s\"\n| gt_diff: \"head t >\\<^sub>h\\<^sub>d head s \\<Longrightarrow> is_Sym (head s) \\<Longrightarrow> chkchop (>\\<^sub>t) t s \\<Longrightarrow> t >\\<^sub>t s\"\n| gt_same: \"head t = head s \\<Longrightarrow> chkchop_same (>\\<^sub>t) t s \\<Longrightarrow>\n    (\\<forall>f \\<in> ground_heads (head t). extf f (>\\<^sub>t) (args t) (args s)) \\<Longrightarrow> t >\\<^sub>t s\""], ["", "abbreviation ge :: \"('s, 'v) tm \\<Rightarrow> ('s, 'v) tm \\<Rightarrow> bool\" (infix \"\\<ge>\\<^sub>t\" 50) where\n  \"t \\<ge>\\<^sub>t s \\<equiv> t >\\<^sub>t s \\<or> t = s\""], ["", "inductive gt_chop :: \"('s, 'v) tm \\<Rightarrow> ('s, 'v) tm \\<Rightarrow> bool\" where\n  gt_chopI: \"is_App t \\<Longrightarrow> chop t \\<ge>\\<^sub>t s \\<Longrightarrow> gt_chop t s\""], ["", "inductive gt_diff :: \"('s, 'v) tm \\<Rightarrow> ('s, 'v) tm \\<Rightarrow> bool\" where\n  gt_diffI: \"head t >\\<^sub>h\\<^sub>d head s \\<Longrightarrow> is_Sym (head s) \\<Longrightarrow> chkchop (>\\<^sub>t) t s \\<Longrightarrow> gt_diff t s\""], ["", "inductive gt_same :: \"('s, 'v) tm \\<Rightarrow> ('s, 'v) tm \\<Rightarrow> bool\" where\n  gt_sameI: \"head t = head s \\<Longrightarrow> chkchop_same (>\\<^sub>t) t s \\<Longrightarrow>\n    (\\<forall>f \\<in> ground_heads (head t). extf f (>\\<^sub>t) (args t) (args s)) \\<Longrightarrow> gt_same t s\""], ["", "lemma gt_iff_chop_diff_same: \"t >\\<^sub>t s \\<longleftrightarrow> gt_chop t s \\<or> gt_diff t s \\<or> gt_same t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t >\\<^sub>t s) = (gt_chop t s \\<or> gt_diff t s \\<or> gt_same t s)", "by (subst gt.simps) (auto simp: gt_chop.simps gt_diff.simps gt_same.simps)"], ["", "subsection \\<open>Transitivity\\<close>"], ["", "lemma t_gt_chop_t: \"is_App t \\<Longrightarrow> t >\\<^sub>t chop t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_App t \\<Longrightarrow> t >\\<^sub>t chop t", "by (simp add: gt_chop)"], ["", "lemma gt_imp_vars: \"t >\\<^sub>t s \\<Longrightarrow> vars t \\<supseteq> vars s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t >\\<^sub>t s \\<Longrightarrow> vars s \\<subseteq> vars t", "proof (simp only: atomize_imp,\n    rule measure_induct_rule[of \"\\<lambda>(t, s). hsize t + hsize s\"\n      \"\\<lambda>(t, s). t >\\<^sub>t s \\<longrightarrow> vars t \\<supseteq> vars s\" \"(t, s)\", simplified prod.case],\n    simp only: split_paired_all prod.case atomize_imp[symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>hsize aa + hsize ba < hsize a + hsize b;\n                    aa >\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> vars ba \\<subseteq> vars aa;\n        a >\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> vars b \\<subseteq> vars a", "fix t s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>hsize aa + hsize ba < hsize a + hsize b;\n                    aa >\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> vars ba \\<subseteq> vars aa;\n        a >\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> vars b \\<subseteq> vars a", "assume\n    ih: \"\\<And>ta sa. hsize ta + hsize sa < hsize t + hsize s \\<Longrightarrow> ta >\\<^sub>t sa \\<Longrightarrow> vars ta \\<supseteq> vars sa\" and\n    t_gt_s: \"t >\\<^sub>t s\""], ["proof (state)\nthis:\n  \\<lbrakk>hsize ?ta + hsize ?sa < hsize t + hsize s;\n   ?ta >\\<^sub>t ?sa\\<rbrakk>\n  \\<Longrightarrow> vars ?sa \\<subseteq> vars ?ta\n  t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>hsize aa + hsize ba < hsize a + hsize b;\n                    aa >\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> vars ba \\<subseteq> vars aa;\n        a >\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> vars b \\<subseteq> vars a", "show \"vars t \\<supseteq> vars s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars s \\<subseteq> vars t", "using t_gt_s"], ["proof (prove)\nusing this:\n  t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. vars s \\<subseteq> vars t", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_App t; chop t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> vars s \\<subseteq> vars t\n 2. \\<lbrakk>head t >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) t s\\<rbrakk>\n    \\<Longrightarrow> vars s \\<subseteq> vars t\n 3. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> vars s \\<subseteq> vars t", "case (gt_chop)"], ["proof (state)\nthis:\n  is_App t\n  chop t \\<ge>\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>is_App t; chop t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> vars s \\<subseteq> vars t\n 2. \\<lbrakk>head t >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) t s\\<rbrakk>\n    \\<Longrightarrow> vars s \\<subseteq> vars t\n 3. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> vars s \\<subseteq> vars t", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_App t\n  chop t \\<ge>\\<^sub>t s\n\ngoal (1 subgoal):\n 1. vars s \\<subseteq> vars t", "using ih"], ["proof (prove)\nusing this:\n  is_App t\n  chop t \\<ge>\\<^sub>t s\n  \\<lbrakk>hsize ?ta + hsize ?sa < hsize t + hsize s;\n   ?ta >\\<^sub>t ?sa\\<rbrakk>\n  \\<Longrightarrow> vars ?sa \\<subseteq> vars ?ta\n\ngoal (1 subgoal):\n 1. vars s \\<subseteq> vars t", "by (metis add_mono_thms_linordered_field(1) le_supI1 order_refl hsize_chop_lt vars_chop)"], ["proof (state)\nthis:\n  vars s \\<subseteq> vars t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>head t >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) t s\\<rbrakk>\n    \\<Longrightarrow> vars s \\<subseteq> vars t\n 2. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> vars s \\<subseteq> vars t", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>head t >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) t s\\<rbrakk>\n    \\<Longrightarrow> vars s \\<subseteq> vars t\n 2. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> vars s \\<subseteq> vars t", "case gt_diff"], ["proof (state)\nthis:\n  head t >\\<^sub>h\\<^sub>d head s\n  is_Sym (head s)\n  chkchop (>\\<^sub>t) t s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>head t >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) t s\\<rbrakk>\n    \\<Longrightarrow> vars s \\<subseteq> vars t\n 2. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> vars s \\<subseteq> vars t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars s \\<subseteq> vars t", "proof (cases s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1. s = Hd x1 \\<Longrightarrow> vars s \\<subseteq> vars t\n 2. \\<And>x21 x22.\n       s = App x21 x22 \\<Longrightarrow> vars s \\<subseteq> vars t", "case Hd"], ["proof (state)\nthis:\n  s = Hd x1_\n\ngoal (2 subgoals):\n 1. \\<And>x1. s = Hd x1 \\<Longrightarrow> vars s \\<subseteq> vars t\n 2. \\<And>x21 x22.\n       s = App x21 x22 \\<Longrightarrow> vars s \\<subseteq> vars t", "thus ?thesis"], ["proof (prove)\nusing this:\n  s = Hd x1_\n\ngoal (1 subgoal):\n 1. vars s \\<subseteq> vars t", "using gt_diff(2)"], ["proof (prove)\nusing this:\n  s = Hd x1_\n  is_Sym (head s)\n\ngoal (1 subgoal):\n 1. vars s \\<subseteq> vars t", "by (metis empty_iff hd.collapse(2) hd.simps(18) subsetI tm.sel(1) tm.simps(17))"], ["proof (state)\nthis:\n  vars s \\<subseteq> vars t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = App x21 x22 \\<Longrightarrow> vars s \\<subseteq> vars t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = App x21 x22 \\<Longrightarrow> vars s \\<subseteq> vars t", "case (App s1 s2)"], ["proof (state)\nthis:\n  s = App s1 s2\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = App x21 x22 \\<Longrightarrow> vars s \\<subseteq> vars t", "have \"vars (chop s) \\<subseteq> vars t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (chop s) \\<subseteq> vars t", "using ih"], ["proof (prove)\nusing this:\n  \\<lbrakk>hsize ?ta + hsize ?sa < hsize t + hsize s;\n   ?ta >\\<^sub>t ?sa\\<rbrakk>\n  \\<Longrightarrow> vars ?sa \\<subseteq> vars ?ta\n\ngoal (1 subgoal):\n 1. vars (chop s) \\<subseteq> vars t", "using App chkchop_def local.gt_diff(3) nat_add_left_cancel_less hsize_chop_lt tm.disc(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>hsize ?ta + hsize ?sa < hsize t + hsize s;\n   ?ta >\\<^sub>t ?sa\\<rbrakk>\n  \\<Longrightarrow> vars ?sa \\<subseteq> vars ?ta\n  s = App s1 s2\n  chkchop ?gt ?t ?s = (is_Hd ?s \\<or> ?gt ?t (chop ?s))\n  chkchop (>\\<^sub>t) t s\n  (?k + ?m < ?k + ?n) = (?m < ?n)\n  is_App ?t \\<Longrightarrow> hsize (chop ?t) < hsize ?t\n  is_App (App ?x21.0 ?x22.0)\n\ngoal (1 subgoal):\n 1. vars (chop s) \\<subseteq> vars t", "by blast"], ["proof (state)\nthis:\n  vars (chop s) \\<subseteq> vars t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = App x21 x22 \\<Longrightarrow> vars s \\<subseteq> vars t", "thus ?thesis"], ["proof (prove)\nusing this:\n  vars (chop s) \\<subseteq> vars t\n\ngoal (1 subgoal):\n 1. vars s \\<subseteq> vars t", "using  App  le_sup_iff local.gt_diff(2) tm.disc(2) vars_chop"], ["proof (prove)\nusing this:\n  vars (chop s) \\<subseteq> vars t\n  s = App s1 s2\n  (sup ?x ?y \\<le> ?z) = (?x \\<le> ?z \\<and> ?y \\<le> ?z)\n  is_Sym (head s)\n  is_App (App ?x21.0 ?x22.0)\n  is_App ?t \\<Longrightarrow>\n  vars (chop ?t) \\<union> vars_hd (head ?t) = vars ?t\n\ngoal (1 subgoal):\n 1. vars s \\<subseteq> vars t", "by (metis empty_iff hd.collapse(2) hd.simps(18) subsetI)"], ["proof (state)\nthis:\n  vars s \\<subseteq> vars t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vars s \\<subseteq> vars t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> vars s \\<subseteq> vars t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> vars s \\<subseteq> vars t", "case gt_same"], ["proof (state)\nthis:\n  head t = head s\n  chkchop_same (>\\<^sub>t) t s\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> vars s \\<subseteq> vars t", "thus ?thesis"], ["proof (prove)\nusing this:\n  head t = head s\n  chkchop_same (>\\<^sub>t) t s\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n\ngoal (1 subgoal):\n 1. vars s \\<subseteq> vars t", "proof (cases \"head t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n        \\<forall>f\\<in>local.ground_heads (head t).\n           extf f (>\\<^sub>t) (args t) (args s);\n        head t = Var x1\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t\n 2. \\<And>x2.\n       \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n        \\<forall>f\\<in>local.ground_heads (head t).\n           extf f (>\\<^sub>t) (args t) (args s);\n        head t = Sym x2\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t", "case (Var x)"], ["proof (state)\nthis:\n  head t = Var x\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n        \\<forall>f\\<in>local.ground_heads (head t).\n           extf f (>\\<^sub>t) (args t) (args s);\n        head t = Var x1\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t\n 2. \\<And>x2.\n       \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n        \\<forall>f\\<in>local.ground_heads (head t).\n           extf f (>\\<^sub>t) (args t) (args s);\n        head t = Sym x2\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t", "then"], ["proof (chain)\npicking this:\n  head t = Var x", "show ?thesis"], ["proof (prove)\nusing this:\n  head t = Var x\n\ngoal (1 subgoal):\n 1. vars s \\<subseteq> vars t", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>head t = Var x; t = Hd x1\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t\n 2. \\<And>x21 x22.\n       \\<lbrakk>head t = Var x; t = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t", "case (Hd _)"], ["proof (state)\nthis:\n  t = Hd x1_\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>head t = Var x; t = Hd x1\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t\n 2. \\<And>x21 x22.\n       \\<lbrakk>head t = Var x; t = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t", "then"], ["proof (chain)\npicking this:\n  t = Hd x1_", "show ?thesis"], ["proof (prove)\nusing this:\n  t = Hd x1_\n\ngoal (1 subgoal):\n 1. vars s \\<subseteq> vars t", "using gt_same extf_min_empty[of _ \"(>\\<^sub>t)\" \"args s\"]"], ["proof (prove)\nusing this:\n  t = Hd x1_\n  head t = head s\n  chkchop_same (>\\<^sub>t) t s\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n  \\<not> extf ?f (>\\<^sub>t) [] (args s)\n\ngoal (1 subgoal):\n 1. vars s \\<subseteq> vars t", "by simp"], ["proof (state)\nthis:\n  vars s \\<subseteq> vars t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>head t = Var x; t = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>head t = Var x; t = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t", "case (App t1 t2)"], ["proof (state)\nthis:\n  t = App t1 t2\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>head t = Var x; t = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t", "then"], ["proof (chain)\npicking this:\n  t = App t1 t2", "show ?thesis"], ["proof (prove)\nusing this:\n  t = App t1 t2\n\ngoal (1 subgoal):\n 1. vars s \\<subseteq> vars t", "proof (cases s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>t = App t1 t2; s = Hd x1\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t\n 2. \\<And>x21 x22.\n       \\<lbrakk>t = App t1 t2; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t", "case (Hd _)"], ["proof (state)\nthis:\n  s = Hd x1_\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>t = App t1 t2; s = Hd x1\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t\n 2. \\<And>x21 x22.\n       \\<lbrakk>t = App t1 t2; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t", "then"], ["proof (chain)\npicking this:\n  s = Hd x1_", "show ?thesis"], ["proof (prove)\nusing this:\n  s = Hd x1_\n\ngoal (1 subgoal):\n 1. vars s \\<subseteq> vars t", "using local.gt_same(1) vars_head_subseteq"], ["proof (prove)\nusing this:\n  s = Hd x1_\n  head t = head s\n  vars_hd (head ?s) \\<subseteq> vars ?s\n\ngoal (1 subgoal):\n 1. vars s \\<subseteq> vars t", "by fastforce"], ["proof (state)\nthis:\n  vars s \\<subseteq> vars t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>t = App t1 t2; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>t = App t1 t2; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t", "case (App s1 s2)"], ["proof (state)\nthis:\n  s = App s1 s2\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>t = App t1 t2; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t", "then"], ["proof (chain)\npicking this:\n  s = App s1 s2", "have \"chop t >\\<^sub>t chop s\""], ["proof (prove)\nusing this:\n  s = App s1 s2\n\ngoal (1 subgoal):\n 1. chop t >\\<^sub>t chop s", "by (metis Var args.simps(1) chkchop_def chkchop_same_def epo.extf_min_empty \n                epo_axioms gt_hd_def gt_hd_irrefl hd.disc(1) local.gt_same(2) local.gt_same(3) tm.collapse(1) tm.disc(2))"], ["proof (state)\nthis:\n  chop t >\\<^sub>t chop s\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>t = App t1 t2; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t", "then"], ["proof (chain)\npicking this:\n  chop t >\\<^sub>t chop s", "have \"vars (chop s) \\<subseteq> vars (chop t)\""], ["proof (prove)\nusing this:\n  chop t >\\<^sub>t chop s\n\ngoal (1 subgoal):\n 1. vars (chop s) \\<subseteq> vars (chop t)", "using ih[OF _ \\<open>chop t >\\<^sub>t chop s\\<close>]"], ["proof (prove)\nusing this:\n  chop t >\\<^sub>t chop s\n  hsize (chop t) + hsize (chop s) < hsize t + hsize s \\<Longrightarrow>\n  vars (chop s) \\<subseteq> vars (chop t)\n\ngoal (1 subgoal):\n 1. vars (chop s) \\<subseteq> vars (chop t)", "by (metis App add_mono_thms_linordered_field(5) args_Nil_iff_is_Hd extf_min_empty gt_hd_def gt_hd_irrefl local.gt_same(3) hsize_chop_lt tm.disc(2))"], ["proof (state)\nthis:\n  vars (chop s) \\<subseteq> vars (chop t)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>t = App t1 t2; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t", "then"], ["proof (chain)\npicking this:\n  vars (chop s) \\<subseteq> vars (chop t)", "show ?thesis"], ["proof (prove)\nusing this:\n  vars (chop s) \\<subseteq> vars (chop t)\n\ngoal (1 subgoal):\n 1. vars s \\<subseteq> vars t", "using  gt_same(1) vars_chop[of t] vars_chop[of s]"], ["proof (prove)\nusing this:\n  vars (chop s) \\<subseteq> vars (chop t)\n  head t = head s\n  is_App t \\<Longrightarrow>\n  vars (chop t) \\<union> vars_hd (head t) = vars t\n  is_App s \\<Longrightarrow>\n  vars (chop s) \\<union> vars_hd (head s) = vars s\n\ngoal (1 subgoal):\n 1. vars s \\<subseteq> vars t", "by (metis App args_Nil_iff_is_Hd extf_min_empty gt_hd_def gt_hd_irrefl le_sup_iff local.gt_same(3) order_refl sup.coboundedI1 tm.disc(2))"], ["proof (state)\nthis:\n  vars s \\<subseteq> vars t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vars s \\<subseteq> vars t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vars s \\<subseteq> vars t\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n        \\<forall>f\\<in>local.ground_heads (head t).\n           extf f (>\\<^sub>t) (args t) (args s);\n        head t = Sym x2\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n        \\<forall>f\\<in>local.ground_heads (head t).\n           extf f (>\\<^sub>t) (args t) (args s);\n        head t = Sym x2\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t", "case (Sym f)"], ["proof (state)\nthis:\n  head t = Sym f\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n        \\<forall>f\\<in>local.ground_heads (head t).\n           extf f (>\\<^sub>t) (args t) (args s);\n        head t = Sym x2\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t", "then"], ["proof (chain)\npicking this:\n  head t = Sym f", "have \"chkchop (>\\<^sub>t) t s\""], ["proof (prove)\nusing this:\n  head t = Sym f\n\ngoal (1 subgoal):\n 1. chkchop (>\\<^sub>t) t s", "using gt_same chkchop_same_def"], ["proof (prove)\nusing this:\n  head t = Sym f\n  head t = head s\n  chkchop_same (>\\<^sub>t) t s\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n  chkchop_same ?gt ?t ?s =\n  (if is_Var (head ?t) then is_Hd ?t \\<or> chkchop ?gt (chop ?t) ?s\n   else chkchop ?gt ?t ?s)\n\ngoal (1 subgoal):\n 1. chkchop (>\\<^sub>t) t s", "by auto"], ["proof (state)\nthis:\n  chkchop (>\\<^sub>t) t s\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n        \\<forall>f\\<in>local.ground_heads (head t).\n           extf f (>\\<^sub>t) (args t) (args s);\n        head t = Sym x2\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t", "then"], ["proof (chain)\npicking this:\n  chkchop (>\\<^sub>t) t s", "show ?thesis"], ["proof (prove)\nusing this:\n  chkchop (>\\<^sub>t) t s\n\ngoal (1 subgoal):\n 1. vars s \\<subseteq> vars t", "proof (cases s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>chkchop (>\\<^sub>t) t s; s = Hd x1\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t\n 2. \\<And>x21 x22.\n       \\<lbrakk>chkchop (>\\<^sub>t) t s; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t", "case (Hd _)"], ["proof (state)\nthis:\n  s = Hd x1_\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>chkchop (>\\<^sub>t) t s; s = Hd x1\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t\n 2. \\<And>x21 x22.\n       \\<lbrakk>chkchop (>\\<^sub>t) t s; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t", "then"], ["proof (chain)\npicking this:\n  s = Hd x1_", "show ?thesis"], ["proof (prove)\nusing this:\n  s = Hd x1_\n\ngoal (1 subgoal):\n 1. vars s \\<subseteq> vars t", "using local.gt_same(1) vars_head_subseteq"], ["proof (prove)\nusing this:\n  s = Hd x1_\n  head t = head s\n  vars_hd (head ?s) \\<subseteq> vars ?s\n\ngoal (1 subgoal):\n 1. vars s \\<subseteq> vars t", "by force"], ["proof (state)\nthis:\n  vars s \\<subseteq> vars t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>chkchop (>\\<^sub>t) t s; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>chkchop (>\\<^sub>t) t s; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t", "case (App s1 s2)"], ["proof (state)\nthis:\n  s = App s1 s2\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>chkchop (>\\<^sub>t) t s; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> vars s \\<subseteq> vars t", "then"], ["proof (chain)\npicking this:\n  s = App s1 s2", "show ?thesis"], ["proof (prove)\nusing this:\n  s = App s1 s2\n\ngoal (1 subgoal):\n 1. vars s \\<subseteq> vars t", "unfolding chkchop_def"], ["proof (prove)\nusing this:\n  s = App s1 s2\n\ngoal (1 subgoal):\n 1. vars s \\<subseteq> vars t", "using vars_chop ih[of t \"chop s\"]"], ["proof (prove)\nusing this:\n  s = App s1 s2\n  is_App ?t \\<Longrightarrow>\n  vars (chop ?t) \\<union> vars_hd (head ?t) = vars ?t\n  \\<lbrakk>hsize t + hsize (chop s) < hsize t + hsize s;\n   t >\\<^sub>t chop s\\<rbrakk>\n  \\<Longrightarrow> vars (chop s) \\<subseteq> vars t\n\ngoal (1 subgoal):\n 1. vars s \\<subseteq> vars t", "by (metis \\<open>chkchop (>\\<^sub>t) t s\\<close> chkchop_def le_sup_iff local.gt_same(1) \n              nat_add_left_cancel_less hsize_chop_lt tm.disc(2) vars_head_subseteq)"], ["proof (state)\nthis:\n  vars s \\<subseteq> vars t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vars s \\<subseteq> vars t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vars s \\<subseteq> vars t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vars s \\<subseteq> vars t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gt_trans: \"u >\\<^sub>t t \\<Longrightarrow> t >\\<^sub>t s \\<Longrightarrow> u >\\<^sub>t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u >\\<^sub>t t; t >\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "proof (simp only: atomize_imp,\n    rule measure_induct_rule[of \"\\<lambda>(u, t, s). {#hsize u, hsize t, hsize s#}\"\n        \"\\<lambda>(u, t, s). u >\\<^sub>t t \\<longrightarrow> t >\\<^sub>t s \\<longrightarrow> u >\\<^sub>t s\" \"(u, t, s)\",\n      simplified prod.case],\n    simp only: split_paired_all prod.case atomize_imp[symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>ab ac ba.\n                   \\<lbrakk>{#hsize ab, hsize ac, hsize ba#}\n                            < {#hsize a, hsize aa, hsize b#};\n                    ab >\\<^sub>t ac; ac >\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> ab >\\<^sub>t ba;\n        a >\\<^sub>t aa; aa >\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b", "fix u t s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>ab ac ba.\n                   \\<lbrakk>{#hsize ab, hsize ac, hsize ba#}\n                            < {#hsize a, hsize aa, hsize b#};\n                    ab >\\<^sub>t ac; ac >\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> ab >\\<^sub>t ba;\n        a >\\<^sub>t aa; aa >\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b", "assume\n    ih: \"\\<And>ua ta sa. {#hsize ua, hsize ta, hsize sa#} < {#hsize u, hsize t, hsize s#} \\<Longrightarrow>\n      ua >\\<^sub>t ta \\<Longrightarrow> ta >\\<^sub>t sa \\<Longrightarrow> ua >\\<^sub>t sa\" and\n    u_gt_t: \"u >\\<^sub>t t\" and t_gt_s: \"t >\\<^sub>t s\""], ["proof (state)\nthis:\n  \\<lbrakk>{#hsize ?ua, hsize ?ta, hsize ?sa#}\n           < {#hsize u, hsize t, hsize s#};\n   ?ua >\\<^sub>t ?ta; ?ta >\\<^sub>t ?sa\\<rbrakk>\n  \\<Longrightarrow> ?ua >\\<^sub>t ?sa\n  u >\\<^sub>t t\n  t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>ab ac ba.\n                   \\<lbrakk>{#hsize ab, hsize ac, hsize ba#}\n                            < {#hsize a, hsize aa, hsize b#};\n                    ab >\\<^sub>t ac; ac >\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> ab >\\<^sub>t ba;\n        a >\\<^sub>t aa; aa >\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b", "have u_gt_s_if_ui: \"chop u \\<ge>\\<^sub>t t \\<Longrightarrow> u >\\<^sub>t s\" if ui_in: \"is_App u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chop u \\<ge>\\<^sub>t t \\<Longrightarrow> u >\\<^sub>t s", "using ih[of \"chop u\" t s, simplified] t_gt_s gt_chop hsize_chop_lt ui_in"], ["proof (prove)\nusing this:\n  \\<lbrakk>hsize (chop u) < hsize u; chop u >\\<^sub>t t;\n   t >\\<^sub>t s\\<rbrakk>\n  \\<Longrightarrow> chop u >\\<^sub>t s\n  t >\\<^sub>t s\n  \\<lbrakk>is_App ?t; chop ?t \\<ge>\\<^sub>t ?s\\<rbrakk>\n  \\<Longrightarrow> ?t >\\<^sub>t ?s\n  is_App ?t \\<Longrightarrow> hsize (chop ?t) < hsize ?t\n  is_App u\n\ngoal (1 subgoal):\n 1. chop u \\<ge>\\<^sub>t t \\<Longrightarrow> u >\\<^sub>t s", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>is_App u; chop u \\<ge>\\<^sub>t t\\<rbrakk>\n  \\<Longrightarrow> u >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>ab ac ba.\n                   \\<lbrakk>{#hsize ab, hsize ac, hsize ba#}\n                            < {#hsize a, hsize aa, hsize b#};\n                    ab >\\<^sub>t ac; ac >\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> ab >\\<^sub>t ba;\n        a >\\<^sub>t aa; aa >\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b", "show \"u >\\<^sub>t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "using t_gt_s"], ["proof (prove)\nusing this:\n  t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_App t; chop t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>head t >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) t s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "case gt_chop"], ["proof (state)\nthis:\n  is_App t\n  chop t \\<ge>\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>is_App t; chop t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>head t >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) t s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have u_gt_s_if_chk_u_t: ?thesis if chk_u_t: \"chkchop (>\\<^sub>t) u t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "using ih[of u \"chop u\" s] gt_chop chk_u_t"], ["proof (prove)\nusing this:\n  \\<lbrakk>{#hsize u, hsize (chop u), hsize s#}\n           < {#hsize u, hsize t, hsize s#};\n   u >\\<^sub>t chop u; chop u >\\<^sub>t s\\<rbrakk>\n  \\<Longrightarrow> u >\\<^sub>t s\n  is_App t\n  chop t \\<ge>\\<^sub>t s\n  chkchop (>\\<^sub>t) u t\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by (metis add_mset_lt_left_lt add_mset_lt_right_lt chkchop_def ih hsize_chop_lt)"], ["proof (state)\nthis:\n  chkchop (>\\<^sub>t) u t \\<Longrightarrow> u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>is_App t; chop t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>head t >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) t s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by (metis args_Nil_iff_is_Hd chkchop_def chkchop_same_def \n          epo.extf_min_empty epo_axioms gt.simps gt_hd_def gt_hd_irrefl\n          u_gt_s_if_chk_u_t u_gt_s_if_ui u_gt_t)"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>head t >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) t s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>head t >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) t s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "case gt_diff_t_s: gt_diff"], ["proof (state)\nthis:\n  head t >\\<^sub>h\\<^sub>d head s\n  is_Sym (head s)\n  chkchop (>\\<^sub>t) t s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>head t >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) t s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "using u_gt_t"], ["proof (prove)\nusing this:\n  u >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_App u; chop u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>head u >\\<^sub>h\\<^sub>d head t; is_Sym (head t);\n     chkchop (>\\<^sub>t) u t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>head u = head t; chkchop_same (>\\<^sub>t) u t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "case gt_chop"], ["proof (state)\nthis:\n  is_App u\n  chop u \\<ge>\\<^sub>t t\n\ngoal (3 subgoals):\n 1. \\<lbrakk>is_App u; chop u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>head u >\\<^sub>h\\<^sub>d head t; is_Sym (head t);\n     chkchop (>\\<^sub>t) u t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>head u = head t; chkchop_same (>\\<^sub>t) u t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "then"], ["proof (chain)\npicking this:\n  is_App u\n  chop u \\<ge>\\<^sub>t t", "show ?thesis"], ["proof (prove)\nusing this:\n  is_App u\n  chop u \\<ge>\\<^sub>t t\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "using u_gt_s_if_ui"], ["proof (prove)\nusing this:\n  is_App u\n  chop u \\<ge>\\<^sub>t t\n  \\<lbrakk>is_App u; chop u \\<ge>\\<^sub>t t\\<rbrakk>\n  \\<Longrightarrow> u >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by blast"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>head u >\\<^sub>h\\<^sub>d head t; is_Sym (head t);\n     chkchop (>\\<^sub>t) u t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>head u = head t; chkchop_same (>\\<^sub>t) u t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>head u >\\<^sub>h\\<^sub>d head t; is_Sym (head t);\n     chkchop (>\\<^sub>t) u t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>head u = head t; chkchop_same (>\\<^sub>t) u t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "case gt_diff_u_t: gt_diff"], ["proof (state)\nthis:\n  head u >\\<^sub>h\\<^sub>d head t\n  is_Sym (head t)\n  chkchop (>\\<^sub>t) u t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>head u >\\<^sub>h\\<^sub>d head t; is_Sym (head t);\n     chkchop (>\\<^sub>t) u t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>head u = head t; chkchop_same (>\\<^sub>t) u t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have \"head u >\\<^sub>h\\<^sub>d head s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head u >\\<^sub>h\\<^sub>d head s", "using gt_diff_u_t(1) gt_diff_t_s(1)"], ["proof (prove)\nusing this:\n  head u >\\<^sub>h\\<^sub>d head t\n  head t >\\<^sub>h\\<^sub>d head s\n\ngoal (1 subgoal):\n 1. head u >\\<^sub>h\\<^sub>d head s", "by (auto intro: gt_hd_trans)"], ["proof (state)\nthis:\n  head u >\\<^sub>h\\<^sub>d head s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>head u >\\<^sub>h\\<^sub>d head t; is_Sym (head t);\n     chkchop (>\\<^sub>t) u t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>head u = head t; chkchop_same (>\\<^sub>t) u t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "thus ?thesis"], ["proof (prove)\nusing this:\n  head u >\\<^sub>h\\<^sub>d head s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "using add_mset_lt_left_lt add_mset_lt_right_lt chkchop_def  gt_diff gt_diff_t_s(3) ih hsize_chop_lt u_gt_t"], ["proof (prove)\nusing this:\n  head u >\\<^sub>h\\<^sub>d head s\n  ?a < ?b \\<Longrightarrow> add_mset ?a ?A < add_mset ?b ?A\n  ?A < ?B \\<Longrightarrow> add_mset ?a ?A < add_mset ?a ?B\n  chkchop ?gt ?t ?s = (is_Hd ?s \\<or> ?gt ?t (chop ?s))\n  \\<lbrakk>head ?t >\\<^sub>h\\<^sub>d head ?s; is_Sym (head ?s);\n   chkchop (>\\<^sub>t) ?t ?s\\<rbrakk>\n  \\<Longrightarrow> ?t >\\<^sub>t ?s\n  chkchop (>\\<^sub>t) t s\n  \\<lbrakk>{#hsize ?ua, hsize ?ta, hsize ?sa#}\n           < {#hsize u, hsize t, hsize s#};\n   ?ua >\\<^sub>t ?ta; ?ta >\\<^sub>t ?sa\\<rbrakk>\n  \\<Longrightarrow> ?ua >\\<^sub>t ?sa\n  is_App ?t \\<Longrightarrow> hsize (chop ?t) < hsize ?t\n  u >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by (metis gt_diff_t_s(2))"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head u = head t; chkchop_same (>\\<^sub>t) u t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>head u = head t; chkchop_same (>\\<^sub>t) u t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "case gt_same_u_t: gt_same"], ["proof (state)\nthis:\n  head u = head t\n  chkchop_same (>\\<^sub>t) u t\n  \\<forall>f\\<in>local.ground_heads (head u).\n     extf f (>\\<^sub>t) (args u) (args t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head u = head t; chkchop_same (>\\<^sub>t) u t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have \"head u >\\<^sub>h\\<^sub>d head s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head u >\\<^sub>h\\<^sub>d head s", "using gt_diff_t_s(1) gt_same_u_t(1)"], ["proof (prove)\nusing this:\n  head t >\\<^sub>h\\<^sub>d head s\n  head u = head t\n\ngoal (1 subgoal):\n 1. head u >\\<^sub>h\\<^sub>d head s", "by auto"], ["proof (state)\nthis:\n  head u >\\<^sub>h\\<^sub>d head s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head u = head t; chkchop_same (>\\<^sub>t) u t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "thus ?thesis"], ["proof (prove)\nusing this:\n  head u >\\<^sub>h\\<^sub>d head s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "using add_mset_lt_left_lt add_mset_lt_right_lt chkchop_def gt_diff gt_diff_t_s(3) ih hsize_chop_lt u_gt_t"], ["proof (prove)\nusing this:\n  head u >\\<^sub>h\\<^sub>d head s\n  ?a < ?b \\<Longrightarrow> add_mset ?a ?A < add_mset ?b ?A\n  ?A < ?B \\<Longrightarrow> add_mset ?a ?A < add_mset ?a ?B\n  chkchop ?gt ?t ?s = (is_Hd ?s \\<or> ?gt ?t (chop ?s))\n  \\<lbrakk>head ?t >\\<^sub>h\\<^sub>d head ?s; is_Sym (head ?s);\n   chkchop (>\\<^sub>t) ?t ?s\\<rbrakk>\n  \\<Longrightarrow> ?t >\\<^sub>t ?s\n  chkchop (>\\<^sub>t) t s\n  \\<lbrakk>{#hsize ?ua, hsize ?ta, hsize ?sa#}\n           < {#hsize u, hsize t, hsize s#};\n   ?ua >\\<^sub>t ?ta; ?ta >\\<^sub>t ?sa\\<rbrakk>\n  \\<Longrightarrow> ?ua >\\<^sub>t ?sa\n  is_App ?t \\<Longrightarrow> hsize (chop ?t) < hsize ?t\n  u >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by (metis gt_diff_t_s(2))"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "case gt_same_t_s: gt_same"], ["proof (state)\nthis:\n  head t = head s\n  chkchop_same (>\\<^sub>t) t s\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "using u_gt_t"], ["proof (prove)\nusing this:\n  u >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_App u; chop u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>head u >\\<^sub>h\\<^sub>d head t; is_Sym (head t);\n     chkchop (>\\<^sub>t) u t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>head u = head t; chkchop_same (>\\<^sub>t) u t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "case gt_chop"], ["proof (state)\nthis:\n  is_App u\n  chop u \\<ge>\\<^sub>t t\n\ngoal (3 subgoals):\n 1. \\<lbrakk>is_App u; chop u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>head u >\\<^sub>h\\<^sub>d head t; is_Sym (head t);\n     chkchop (>\\<^sub>t) u t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>head u = head t; chkchop_same (>\\<^sub>t) u t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "then"], ["proof (chain)\npicking this:\n  is_App u\n  chop u \\<ge>\\<^sub>t t", "show ?thesis"], ["proof (prove)\nusing this:\n  is_App u\n  chop u \\<ge>\\<^sub>t t\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "using u_gt_s_if_ui"], ["proof (prove)\nusing this:\n  is_App u\n  chop u \\<ge>\\<^sub>t t\n  \\<lbrakk>is_App u; chop u \\<ge>\\<^sub>t t\\<rbrakk>\n  \\<Longrightarrow> u >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by linarith"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>head u >\\<^sub>h\\<^sub>d head t; is_Sym (head t);\n     chkchop (>\\<^sub>t) u t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>head u = head t; chkchop_same (>\\<^sub>t) u t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>head u >\\<^sub>h\\<^sub>d head t; is_Sym (head t);\n     chkchop (>\\<^sub>t) u t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>head u = head t; chkchop_same (>\\<^sub>t) u t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "case gt_diff_u_t: gt_diff"], ["proof (state)\nthis:\n  head u >\\<^sub>h\\<^sub>d head t\n  is_Sym (head t)\n  chkchop (>\\<^sub>t) u t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>head u >\\<^sub>h\\<^sub>d head t; is_Sym (head t);\n     chkchop (>\\<^sub>t) u t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>head u = head t; chkchop_same (>\\<^sub>t) u t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have \"head u >\\<^sub>h\\<^sub>d head s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head u >\\<^sub>h\\<^sub>d head s", "using gt_diff_u_t(1) gt_same_t_s(1)"], ["proof (prove)\nusing this:\n  head u >\\<^sub>h\\<^sub>d head t\n  head t = head s\n\ngoal (1 subgoal):\n 1. head u >\\<^sub>h\\<^sub>d head s", "by simp"], ["proof (state)\nthis:\n  head u >\\<^sub>h\\<^sub>d head s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>head u >\\<^sub>h\\<^sub>d head t; is_Sym (head t);\n     chkchop (>\\<^sub>t) u t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>head u = head t; chkchop_same (>\\<^sub>t) u t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "thus ?thesis"], ["proof (prove)\nusing this:\n  head u >\\<^sub>h\\<^sub>d head s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "using add_mset_lt_left_lt add_mset_lt_right_lt chkchop_def gt_diff gt_same_t_s ih hsize_chop_lt u_gt_t"], ["proof (prove)\nusing this:\n  head u >\\<^sub>h\\<^sub>d head s\n  ?a < ?b \\<Longrightarrow> add_mset ?a ?A < add_mset ?b ?A\n  ?A < ?B \\<Longrightarrow> add_mset ?a ?A < add_mset ?a ?B\n  chkchop ?gt ?t ?s = (is_Hd ?s \\<or> ?gt ?t (chop ?s))\n  \\<lbrakk>head ?t >\\<^sub>h\\<^sub>d head ?s; is_Sym (head ?s);\n   chkchop (>\\<^sub>t) ?t ?s\\<rbrakk>\n  \\<Longrightarrow> ?t >\\<^sub>t ?s\n  head t = head s\n  chkchop_same (>\\<^sub>t) t s\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n  \\<lbrakk>{#hsize ?ua, hsize ?ta, hsize ?sa#}\n           < {#hsize u, hsize t, hsize s#};\n   ?ua >\\<^sub>t ?ta; ?ta >\\<^sub>t ?sa\\<rbrakk>\n  \\<Longrightarrow> ?ua >\\<^sub>t ?sa\n  is_App ?t \\<Longrightarrow> hsize (chop ?t) < hsize ?t\n  u >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by (metis chkchop_same_def gt_diff_u_t(2))"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head u = head t; chkchop_same (>\\<^sub>t) u t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>head u = head t; chkchop_same (>\\<^sub>t) u t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "case gt_same_u_t: gt_same"], ["proof (state)\nthis:\n  head u = head t\n  chkchop_same (>\\<^sub>t) u t\n  \\<forall>f\\<in>local.ground_heads (head u).\n     extf f (>\\<^sub>t) (args u) (args t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head u = head t; chkchop_same (>\\<^sub>t) u t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have hd_u_s: \"head u = head s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head u = head s", "using gt_same_u_t(1) gt_same_t_s(1)"], ["proof (prove)\nusing this:\n  head u = head t\n  head t = head s\n\ngoal (1 subgoal):\n 1. head u = head s", "by simp"], ["proof (state)\nthis:\n  head u = head s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head u = head t; chkchop_same (>\\<^sub>t) u t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "let ?S = \"set (args u) \\<union> set (args t) \\<union> set (args s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>head u = head t; chkchop_same (>\\<^sub>t) u t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have gt_trans_args: \"\\<forall>ua \\<in> ?S. \\<forall>ta \\<in> ?S. \\<forall>sa \\<in> ?S. ua >\\<^sub>t ta \\<longrightarrow> ta >\\<^sub>t sa \\<longrightarrow> ua >\\<^sub>t sa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>uaa\\<in>set (args u) \\<union> set (args t) \\<union>\n                     set (args s).\n       \\<forall>taa\\<in>set (args u) \\<union> set (args t) \\<union>\n                        set (args s).\n          \\<forall>sa\\<in>set (args u) \\<union> set (args t) \\<union>\n                          set (args s).\n             uaa >\\<^sub>t taa \\<longrightarrow>\n             taa >\\<^sub>t sa \\<longrightarrow> uaa >\\<^sub>t sa", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>uaa taa saa.\n       \\<lbrakk>uaa\n                \\<in> set (args u) \\<union> set (args t) \\<union>\n                      set (args s);\n        taa \\<in> set (args u) \\<union> set (args t) \\<union> set (args s);\n        saa \\<in> set (args u) \\<union> set (args t) \\<union> set (args s);\n        uaa >\\<^sub>t taa; taa >\\<^sub>t saa\\<rbrakk>\n       \\<Longrightarrow> uaa >\\<^sub>t saa", "fix sa ta ua"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>uaa taa saa.\n       \\<lbrakk>uaa\n                \\<in> set (args u) \\<union> set (args t) \\<union>\n                      set (args s);\n        taa \\<in> set (args u) \\<union> set (args t) \\<union> set (args s);\n        saa \\<in> set (args u) \\<union> set (args t) \\<union> set (args s);\n        uaa >\\<^sub>t taa; taa >\\<^sub>t saa\\<rbrakk>\n       \\<Longrightarrow> uaa >\\<^sub>t saa", "assume\n          ua_in: \"ua \\<in> ?S\" and ta_in: \"ta \\<in> ?S\" and sa_in: \"sa \\<in> ?S\" and\n          ua_gt_ta: \"ua >\\<^sub>t ta\" and ta_gt_sa: \"ta >\\<^sub>t sa\""], ["proof (state)\nthis:\n  ua \\<in> set (args u) \\<union> set (args t) \\<union> set (args s)\n  ta \\<in> set (args u) \\<union> set (args t) \\<union> set (args s)\n  sa \\<in> set (args u) \\<union> set (args t) \\<union> set (args s)\n  ua >\\<^sub>t ta\n  ta >\\<^sub>t sa\n\ngoal (1 subgoal):\n 1. \\<And>uaa taa saa.\n       \\<lbrakk>uaa\n                \\<in> set (args u) \\<union> set (args t) \\<union>\n                      set (args s);\n        taa \\<in> set (args u) \\<union> set (args t) \\<union> set (args s);\n        saa \\<in> set (args u) \\<union> set (args t) \\<union> set (args s);\n        uaa >\\<^sub>t taa; taa >\\<^sub>t saa\\<rbrakk>\n       \\<Longrightarrow> uaa >\\<^sub>t saa", "show \"ua >\\<^sub>t sa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ua >\\<^sub>t sa", "by (auto intro!: ih[OF Max_lt_imp_lt_mset ua_gt_ta ta_gt_sa])\n            (meson ua_in ta_in sa_in Un_iff max.strict_coboundedI1 max.strict_coboundedI2\n               hsize_in_args)+"], ["proof (state)\nthis:\n  ua >\\<^sub>t sa\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>uaa\\<in>set (args u) \\<union> set (args t) \\<union> set (args s).\n     \\<forall>taa\\<in>set (args u) \\<union> set (args t) \\<union>\n                      set (args s).\n        \\<forall>sa\\<in>set (args u) \\<union> set (args t) \\<union>\n                        set (args s).\n           uaa >\\<^sub>t taa \\<longrightarrow>\n           taa >\\<^sub>t sa \\<longrightarrow> uaa >\\<^sub>t sa\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head u = head t; chkchop_same (>\\<^sub>t) u t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have \"\\<forall>f \\<in> ground_heads (head u). extf f (>\\<^sub>t) (args u) (args s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head u).\n       extf f (>\\<^sub>t) (args u) (args s)", "proof (clarify, rule extf_trans[OF _ _ _ gt_trans_args])"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>f.\n       f \\<in> local.ground_heads (head u) \\<Longrightarrow>\n       args u\n       \\<in> lists\n              (set (args u) \\<union> set (args t) \\<union> set (args s))\n 2. \\<And>f.\n       f \\<in> local.ground_heads (head u) \\<Longrightarrow>\n       ?ys1 f\n       \\<in> lists\n              (set (args u) \\<union> set (args t) \\<union> set (args s))\n 3. \\<And>f.\n       f \\<in> local.ground_heads (head u) \\<Longrightarrow>\n       args s\n       \\<in> lists\n              (set (args u) \\<union> set (args t) \\<union> set (args s))\n 4. \\<And>f.\n       f \\<in> local.ground_heads (head u) \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args u) (?ys1 f)\n 5. \\<And>f.\n       f \\<in> local.ground_heads (head u) \\<Longrightarrow>\n       extf f (>\\<^sub>t) (?ys1 f) (args s)", "fix f"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>f.\n       f \\<in> local.ground_heads (head u) \\<Longrightarrow>\n       args u\n       \\<in> lists\n              (set (args u) \\<union> set (args t) \\<union> set (args s))\n 2. \\<And>f.\n       f \\<in> local.ground_heads (head u) \\<Longrightarrow>\n       ?ys1 f\n       \\<in> lists\n              (set (args u) \\<union> set (args t) \\<union> set (args s))\n 3. \\<And>f.\n       f \\<in> local.ground_heads (head u) \\<Longrightarrow>\n       args s\n       \\<in> lists\n              (set (args u) \\<union> set (args t) \\<union> set (args s))\n 4. \\<And>f.\n       f \\<in> local.ground_heads (head u) \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args u) (?ys1 f)\n 5. \\<And>f.\n       f \\<in> local.ground_heads (head u) \\<Longrightarrow>\n       extf f (>\\<^sub>t) (?ys1 f) (args s)", "assume f_in_grounds: \"f \\<in> ground_heads (head u)\""], ["proof (state)\nthis:\n  f \\<in> local.ground_heads (head u)\n\ngoal (5 subgoals):\n 1. \\<And>f.\n       f \\<in> local.ground_heads (head u) \\<Longrightarrow>\n       args u\n       \\<in> lists\n              (set (args u) \\<union> set (args t) \\<union> set (args s))\n 2. \\<And>f.\n       f \\<in> local.ground_heads (head u) \\<Longrightarrow>\n       ?ys1 f\n       \\<in> lists\n              (set (args u) \\<union> set (args t) \\<union> set (args s))\n 3. \\<And>f.\n       f \\<in> local.ground_heads (head u) \\<Longrightarrow>\n       args s\n       \\<in> lists\n              (set (args u) \\<union> set (args t) \\<union> set (args s))\n 4. \\<And>f.\n       f \\<in> local.ground_heads (head u) \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args u) (?ys1 f)\n 5. \\<And>f.\n       f \\<in> local.ground_heads (head u) \\<Longrightarrow>\n       extf f (>\\<^sub>t) (?ys1 f) (args s)", "show \"extf f (>\\<^sub>t) (args u) (args t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args u) (args t)", "using f_in_grounds gt_same_u_t(3)"], ["proof (prove)\nusing this:\n  f \\<in> local.ground_heads (head u)\n  \\<forall>f\\<in>local.ground_heads (head u).\n     extf f (>\\<^sub>t) (args u) (args t)\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args u) (args t)", "by blast"], ["proof (state)\nthis:\n  extf f (>\\<^sub>t) (args u) (args t)\n\ngoal (4 subgoals):\n 1. \\<And>f.\n       f \\<in> local.ground_heads (head u) \\<Longrightarrow>\n       args u\n       \\<in> lists\n              (set (args u) \\<union> set (args t) \\<union> set (args s))\n 2. \\<And>f.\n       f \\<in> local.ground_heads (head u) \\<Longrightarrow>\n       args t\n       \\<in> lists\n              (set (args u) \\<union> set (args t) \\<union> set (args s))\n 3. \\<And>f.\n       f \\<in> local.ground_heads (head u) \\<Longrightarrow>\n       args s\n       \\<in> lists\n              (set (args u) \\<union> set (args t) \\<union> set (args s))\n 4. \\<And>f.\n       f \\<in> local.ground_heads (head u) \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args t) (args s)", "show \"extf f (>\\<^sub>t) (args t) (args s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args t) (args s)", "using f_in_grounds gt_same_t_s(3)"], ["proof (prove)\nusing this:\n  f \\<in> local.ground_heads (head u)\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args t) (args s)", "unfolding gt_same_u_t(1)"], ["proof (prove)\nusing this:\n  f \\<in> local.ground_heads (head t)\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args t) (args s)", "by blast"], ["proof (state)\nthis:\n  extf f (>\\<^sub>t) (args t) (args s)\n\ngoal (3 subgoals):\n 1. \\<And>f.\n       f \\<in> local.ground_heads (head u) \\<Longrightarrow>\n       args u\n       \\<in> lists\n              (set (args u) \\<union> set (args t) \\<union> set (args s))\n 2. \\<And>f.\n       f \\<in> local.ground_heads (head u) \\<Longrightarrow>\n       args t\n       \\<in> lists\n              (set (args u) \\<union> set (args t) \\<union> set (args s))\n 3. \\<And>f.\n       f \\<in> local.ground_heads (head u) \\<Longrightarrow>\n       args s\n       \\<in> lists\n              (set (args u) \\<union> set (args t) \\<union> set (args s))", "qed auto"], ["proof (state)\nthis:\n  \\<forall>f\\<in>local.ground_heads (head u).\n     extf f (>\\<^sub>t) (args u) (args s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head u = head t; chkchop_same (>\\<^sub>t) u t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have \"chkchop_same (>\\<^sub>t) u s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) u s", "proof (cases \"head u\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1. head u = Var x1 \\<Longrightarrow> chkchop_same (>\\<^sub>t) u s\n 2. \\<And>x2. head u = Sym x2 \\<Longrightarrow> chkchop_same (>\\<^sub>t) u s", "case (Var x)"], ["proof (state)\nthis:\n  head u = Var x\n\ngoal (2 subgoals):\n 1. \\<And>x1. head u = Var x1 \\<Longrightarrow> chkchop_same (>\\<^sub>t) u s\n 2. \\<And>x2. head u = Sym x2 \\<Longrightarrow> chkchop_same (>\\<^sub>t) u s", "then"], ["proof (chain)\npicking this:\n  head u = Var x", "show ?thesis"], ["proof (prove)\nusing this:\n  head u = Var x\n\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) u s", "proof (cases u)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>head u = Var x; u = Hd x1\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) u s\n 2. \\<And>x21 x22.\n       \\<lbrakk>head u = Var x; u = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) u s", "case (Hd _)"], ["proof (state)\nthis:\n  u = Hd x1_\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>head u = Var x; u = Hd x1\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) u s\n 2. \\<And>x21 x22.\n       \\<lbrakk>head u = Var x; u = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) u s", "then"], ["proof (chain)\npicking this:\n  u = Hd x1_", "show ?thesis"], ["proof (prove)\nusing this:\n  u = Hd x1_\n\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) u s", "using Var"], ["proof (prove)\nusing this:\n  u = Hd x1_\n  head u = Var x\n\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) u s", "by auto"], ["proof (state)\nthis:\n  chkchop_same (>\\<^sub>t) u s\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>head u = Var x; u = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) u s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>head u = Var x; u = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) u s", "case (App u1 u2)"], ["proof (state)\nthis:\n  u = App u1 u2\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>head u = Var x; u = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) u s", "then"], ["proof (chain)\npicking this:\n  u = App u1 u2", "have \"chop u >\\<^sub>t chop t\""], ["proof (prove)\nusing this:\n  u = App u1 u2\n\ngoal (1 subgoal):\n 1. chop u >\\<^sub>t chop t", "by (metis Var args.simps(1) chkchop_def chkchop_same_def epo.extf_min_empty epo_axioms gt_hd_def gt_hd_irrefl gt_same_t_s(3) gt_same_u_t(2) hd.disc(1) tm.collapse(1) tm.disc(2))"], ["proof (state)\nthis:\n  chop u >\\<^sub>t chop t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>head u = Var x; u = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) u s", "then"], ["proof (chain)\npicking this:\n  chop u >\\<^sub>t chop t", "show ?thesis"], ["proof (prove)\nusing this:\n  chop u >\\<^sub>t chop t\n\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) u s", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>chop u >\\<^sub>t chop t; t = Hd x1\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) u s\n 2. \\<And>x21 x22.\n       \\<lbrakk>chop u >\\<^sub>t chop t; t = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) u s", "case (Hd _)"], ["proof (state)\nthis:\n  t = Hd x1_\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>chop u >\\<^sub>t chop t; t = Hd x1\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) u s\n 2. \\<And>x21 x22.\n       \\<lbrakk>chop u >\\<^sub>t chop t; t = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) u s", "then"], ["proof (chain)\npicking this:\n  t = Hd x1_", "show ?thesis"], ["proof (prove)\nusing this:\n  t = Hd x1_\n\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) u s", "using extf_min_empty gt_same_t_s(3)"], ["proof (prove)\nusing this:\n  t = Hd x1_\n  \\<not> extf ?f ?gt [] ?ss\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) u s", "by auto"], ["proof (state)\nthis:\n  chkchop_same (>\\<^sub>t) u s\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>chop u >\\<^sub>t chop t; t = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) u s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>chop u >\\<^sub>t chop t; t = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) u s", "case t_App: (App t1 t2)"], ["proof (state)\nthis:\n  t = App t1 t2\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>chop u >\\<^sub>t chop t; t = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) u s", "then"], ["proof (chain)\npicking this:\n  t = App t1 t2", "have \"is_App s \\<Longrightarrow> chop t >\\<^sub>t chop s\""], ["proof (prove)\nusing this:\n  t = App t1 t2\n\ngoal (1 subgoal):\n 1. is_App s \\<Longrightarrow> chop t >\\<^sub>t chop s", "using gt_same_t_s"], ["proof (prove)\nusing this:\n  t = App t1 t2\n  head t = head s\n  chkchop_same (>\\<^sub>t) t s\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n\ngoal (1 subgoal):\n 1. is_App s \\<Longrightarrow> chop t >\\<^sub>t chop s", "unfolding chkchop_same_def"], ["proof (prove)\nusing this:\n  t = App t1 t2\n  head t = head s\n  if is_Var (head t) then is_Hd t \\<or> chkchop (>\\<^sub>t) (chop t) s\n  else chkchop (>\\<^sub>t) t s\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n\ngoal (1 subgoal):\n 1. is_App s \\<Longrightarrow> chop t >\\<^sub>t chop s", "unfolding chkchop_def"], ["proof (prove)\nusing this:\n  t = App t1 t2\n  head t = head s\n  if is_Var (head t)\n  then is_Hd t \\<or> is_Hd s \\<or> chop t >\\<^sub>t chop s\n  else is_Hd s \\<or> t >\\<^sub>t chop s\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n\ngoal (1 subgoal):\n 1. is_App s \\<Longrightarrow> chop t >\\<^sub>t chop s", "using Var hd_u_s"], ["proof (prove)\nusing this:\n  t = App t1 t2\n  head t = head s\n  if is_Var (head t)\n  then is_Hd t \\<or> is_Hd s \\<or> chop t >\\<^sub>t chop s\n  else is_Hd s \\<or> t >\\<^sub>t chop s\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n  head u = Var x\n  head u = head s\n\ngoal (1 subgoal):\n 1. is_App s \\<Longrightarrow> chop t >\\<^sub>t chop s", "by auto"], ["proof (state)\nthis:\n  is_App s \\<Longrightarrow> chop t >\\<^sub>t chop s\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>chop u >\\<^sub>t chop t; t = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) u s", "then"], ["proof (chain)\npicking this:\n  is_App s \\<Longrightarrow> chop t >\\<^sub>t chop s", "have \"chkchop (>\\<^sub>t) (chop u) s\""], ["proof (prove)\nusing this:\n  is_App s \\<Longrightarrow> chop t >\\<^sub>t chop s\n\ngoal (1 subgoal):\n 1. chkchop (>\\<^sub>t) (chop u) s", "unfolding chkchop_def"], ["proof (prove)\nusing this:\n  is_App s \\<Longrightarrow> chop t >\\<^sub>t chop s\n\ngoal (1 subgoal):\n 1. is_Hd s \\<or> chop u >\\<^sub>t chop s", "using ih[of \"chop u\" \"chop t\" \"chop s\"]"], ["proof (prove)\nusing this:\n  is_App s \\<Longrightarrow> chop t >\\<^sub>t chop s\n  \\<lbrakk>{#hsize (chop u), hsize (chop t), hsize (chop s)#}\n           < {#hsize u, hsize t, hsize s#};\n   chop u >\\<^sub>t chop t; chop t >\\<^sub>t chop s\\<rbrakk>\n  \\<Longrightarrow> chop u >\\<^sub>t chop s\n\ngoal (1 subgoal):\n 1. is_Hd s \\<or> chop u >\\<^sub>t chop s", "by (metis App \\<open>chop u >\\<^sub>t chop t\\<close> t_App add_mset_lt_lt_le less_imp_le mset_lt_single_iff hsize_chop_lt tm.disc(2))"], ["proof (state)\nthis:\n  chkchop (>\\<^sub>t) (chop u) s\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>chop u >\\<^sub>t chop t; t = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) u s", "then"], ["proof (chain)\npicking this:\n  chkchop (>\\<^sub>t) (chop u) s", "show ?thesis"], ["proof (prove)\nusing this:\n  chkchop (>\\<^sub>t) (chop u) s\n\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) u s", "unfolding chkchop_same_def"], ["proof (prove)\nusing this:\n  chkchop (>\\<^sub>t) (chop u) s\n\ngoal (1 subgoal):\n 1. if is_Var (head u) then is_Hd u \\<or> chkchop (>\\<^sub>t) (chop u) s\n    else chkchop (>\\<^sub>t) u s", "using Var"], ["proof (prove)\nusing this:\n  chkchop (>\\<^sub>t) (chop u) s\n  head u = Var x\n\ngoal (1 subgoal):\n 1. if is_Var (head u) then is_Hd u \\<or> chkchop (>\\<^sub>t) (chop u) s\n    else chkchop (>\\<^sub>t) u s", "by auto"], ["proof (state)\nthis:\n  chkchop_same (>\\<^sub>t) u s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chkchop_same (>\\<^sub>t) u s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chkchop_same (>\\<^sub>t) u s\n\ngoal (1 subgoal):\n 1. \\<And>x2. head u = Sym x2 \\<Longrightarrow> chkchop_same (>\\<^sub>t) u s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2. head u = Sym x2 \\<Longrightarrow> chkchop_same (>\\<^sub>t) u s", "case (Sym f)"], ["proof (state)\nthis:\n  head u = Sym f\n\ngoal (1 subgoal):\n 1. \\<And>x2. head u = Sym x2 \\<Longrightarrow> chkchop_same (>\\<^sub>t) u s", "have \"chkchop (>\\<^sub>t) u s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chkchop (>\\<^sub>t) u s", "proof (cases s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1. s = Hd x1 \\<Longrightarrow> chkchop (>\\<^sub>t) u s\n 2. \\<And>x21 x22. s = App x21 x22 \\<Longrightarrow> chkchop (>\\<^sub>t) u s", "case (Hd _)"], ["proof (state)\nthis:\n  s = Hd x1_\n\ngoal (2 subgoals):\n 1. \\<And>x1. s = Hd x1 \\<Longrightarrow> chkchop (>\\<^sub>t) u s\n 2. \\<And>x21 x22. s = App x21 x22 \\<Longrightarrow> chkchop (>\\<^sub>t) u s", "then"], ["proof (chain)\npicking this:\n  s = Hd x1_", "show ?thesis"], ["proof (prove)\nusing this:\n  s = Hd x1_\n\ngoal (1 subgoal):\n 1. chkchop (>\\<^sub>t) u s", "by simp"], ["proof (state)\nthis:\n  chkchop (>\\<^sub>t) u s\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. s = App x21 x22 \\<Longrightarrow> chkchop (>\\<^sub>t) u s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22. s = App x21 x22 \\<Longrightarrow> chkchop (>\\<^sub>t) u s", "case (App s1 s2)"], ["proof (state)\nthis:\n  s = App s1 s2\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. s = App x21 x22 \\<Longrightarrow> chkchop (>\\<^sub>t) u s", "then"], ["proof (chain)\npicking this:\n  s = App s1 s2", "have \"t >\\<^sub>t chop s\""], ["proof (prove)\nusing this:\n  s = App s1 s2\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t chop s", "using Sym gt_same_t_s(1) gt_same_t_s(2) hd_u_s"], ["proof (prove)\nusing this:\n  s = App s1 s2\n  head u = Sym f\n  head t = head s\n  chkchop_same (>\\<^sub>t) t s\n  head u = head s\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t chop s", "by auto"], ["proof (state)\nthis:\n  t >\\<^sub>t chop s\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. s = App x21 x22 \\<Longrightarrow> chkchop (>\\<^sub>t) u s", "then"], ["proof (chain)\npicking this:\n  t >\\<^sub>t chop s", "have \"u >\\<^sub>t chop s\""], ["proof (prove)\nusing this:\n  t >\\<^sub>t chop s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t chop s", "using ih[of u t \"chop s\"]"], ["proof (prove)\nusing this:\n  t >\\<^sub>t chop s\n  \\<lbrakk>{#hsize u, hsize t, hsize (chop s)#}\n           < {#hsize u, hsize t, hsize s#};\n   u >\\<^sub>t t; t >\\<^sub>t chop s\\<rbrakk>\n  \\<Longrightarrow> u >\\<^sub>t chop s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t chop s", "by (metis App add_mset_lt_right_lt mset_lt_single_iff hsize_chop_lt tm.disc(2) u_gt_t)"], ["proof (state)\nthis:\n  u >\\<^sub>t chop s\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. s = App x21 x22 \\<Longrightarrow> chkchop (>\\<^sub>t) u s", "then"], ["proof (chain)\npicking this:\n  u >\\<^sub>t chop s", "show ?thesis"], ["proof (prove)\nusing this:\n  u >\\<^sub>t chop s\n\ngoal (1 subgoal):\n 1. chkchop (>\\<^sub>t) u s", "unfolding chkchop_def"], ["proof (prove)\nusing this:\n  u >\\<^sub>t chop s\n\ngoal (1 subgoal):\n 1. is_Hd s \\<or> u >\\<^sub>t chop s", "by blast"], ["proof (state)\nthis:\n  chkchop (>\\<^sub>t) u s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chkchop (>\\<^sub>t) u s\n\ngoal (1 subgoal):\n 1. \\<And>x2. head u = Sym x2 \\<Longrightarrow> chkchop_same (>\\<^sub>t) u s", "then"], ["proof (chain)\npicking this:\n  chkchop (>\\<^sub>t) u s", "show ?thesis"], ["proof (prove)\nusing this:\n  chkchop (>\\<^sub>t) u s\n\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) u s", "by (simp add: Sym)"], ["proof (state)\nthis:\n  chkchop_same (>\\<^sub>t) u s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chkchop_same (>\\<^sub>t) u s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head u = head t; chkchop_same (>\\<^sub>t) u t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "thus ?thesis"], ["proof (prove)\nusing this:\n  chkchop_same (>\\<^sub>t) u s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "using \\<open>\\<forall>f\\<in>local.ground_heads (head u). extf f (>\\<^sub>t) (args u) (args s)\\<close> gt_same hd_u_s"], ["proof (prove)\nusing this:\n  chkchop_same (>\\<^sub>t) u s\n  \\<forall>f\\<in>local.ground_heads (head u).\n     extf f (>\\<^sub>t) (args u) (args s)\n  \\<lbrakk>head ?t = head ?s; chkchop_same (>\\<^sub>t) ?t ?s;\n   \\<forall>f\\<in>local.ground_heads (head ?t).\n      extf f (>\\<^sub>t) (args ?t) (args ?s)\\<rbrakk>\n  \\<Longrightarrow> ?t >\\<^sub>t ?s\n  head u = head s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by blast"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Irreflexivity\\<close>"], ["", "theorem gt_irrefl: \"\\<not> s >\\<^sub>t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> s >\\<^sub>t s", "proof (standard, induct s rule: measure_induct_rule[of hsize])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>hsize y < hsize x; y >\\<^sub>t y\\<rbrakk>\n                   \\<Longrightarrow> False;\n        x >\\<^sub>t x\\<rbrakk>\n       \\<Longrightarrow> False", "case (less s)"], ["proof (state)\nthis:\n  \\<lbrakk>hsize ?y < hsize s; ?y >\\<^sub>t ?y\\<rbrakk>\n  \\<Longrightarrow> False\n  s >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>hsize y < hsize x; y >\\<^sub>t y\\<rbrakk>\n                   \\<Longrightarrow> False;\n        x >\\<^sub>t x\\<rbrakk>\n       \\<Longrightarrow> False", "note ih = this(1) and s_gt_s = this(2)"], ["proof (state)\nthis:\n  \\<lbrakk>hsize ?y < hsize s; ?y >\\<^sub>t ?y\\<rbrakk>\n  \\<Longrightarrow> False\n  s >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>hsize y < hsize x; y >\\<^sub>t y\\<rbrakk>\n                   \\<Longrightarrow> False;\n        x >\\<^sub>t x\\<rbrakk>\n       \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using s_gt_s"], ["proof (prove)\nusing this:\n  s >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_App s; chop s \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>head s >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) s s\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>head s = head s; chkchop_same (>\\<^sub>t) s s;\n     \\<forall>f\\<in>local.ground_heads (head s).\n        extf f (>\\<^sub>t) (args s) (args s)\\<rbrakk>\n    \\<Longrightarrow> False", "case gt_chop"], ["proof (state)\nthis:\n  is_App s\n  chop s \\<ge>\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>is_App s; chop s \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>head s >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) s s\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>head s = head s; chkchop_same (>\\<^sub>t) s s;\n     \\<forall>f\\<in>local.ground_heads (head s).\n        extf f (>\\<^sub>t) (args s) (args s)\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  is_App s\n  chop s \\<ge>\\<^sub>t s", "show False"], ["proof (prove)\nusing this:\n  is_App s\n  chop s \\<ge>\\<^sub>t s\n\ngoal (1 subgoal):\n 1. False", "using ih[of \"chop s\"]"], ["proof (prove)\nusing this:\n  is_App s\n  chop s \\<ge>\\<^sub>t s\n  \\<lbrakk>hsize (chop s) < hsize s; chop s >\\<^sub>t chop s\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by (metis gt.gt_chop gt_trans hsize_chop_lt)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>head s >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) s s\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>head s = head s; chkchop_same (>\\<^sub>t) s s;\n     \\<forall>f\\<in>local.ground_heads (head s).\n        extf f (>\\<^sub>t) (args s) (args s)\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>head s >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) s s\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>head s = head s; chkchop_same (>\\<^sub>t) s s;\n     \\<forall>f\\<in>local.ground_heads (head s).\n        extf f (>\\<^sub>t) (args s) (args s)\\<rbrakk>\n    \\<Longrightarrow> False", "case gt_diff"], ["proof (state)\nthis:\n  head s >\\<^sub>h\\<^sub>d head s\n  is_Sym (head s)\n  chkchop (>\\<^sub>t) s s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>head s >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) s s\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>head s = head s; chkchop_same (>\\<^sub>t) s s;\n     \\<forall>f\\<in>local.ground_heads (head s).\n        extf f (>\\<^sub>t) (args s) (args s)\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  head s >\\<^sub>h\\<^sub>d head s\n  is_Sym (head s)\n  chkchop (>\\<^sub>t) s s\n\ngoal (1 subgoal):\n 1. False", "by (cases \"head s\") (auto simp: gt_hd_irrefl)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head s = head s; chkchop_same (>\\<^sub>t) s s;\n     \\<forall>f\\<in>local.ground_heads (head s).\n        extf f (>\\<^sub>t) (args s) (args s)\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>head s = head s; chkchop_same (>\\<^sub>t) s s;\n     \\<forall>f\\<in>local.ground_heads (head s).\n        extf f (>\\<^sub>t) (args s) (args s)\\<rbrakk>\n    \\<Longrightarrow> False", "case gt_same"], ["proof (state)\nthis:\n  head s = head s\n  chkchop_same (>\\<^sub>t) s s\n  \\<forall>f\\<in>local.ground_heads (head s).\n     extf f (>\\<^sub>t) (args s) (args s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head s = head s; chkchop_same (>\\<^sub>t) s s;\n     \\<forall>f\\<in>local.ground_heads (head s).\n        extf f (>\\<^sub>t) (args s) (args s)\\<rbrakk>\n    \\<Longrightarrow> False", "note in_grounds = this(3)"], ["proof (state)\nthis:\n  \\<forall>f\\<in>local.ground_heads (head s).\n     extf f (>\\<^sub>t) (args s) (args s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head s = head s; chkchop_same (>\\<^sub>t) s s;\n     \\<forall>f\\<in>local.ground_heads (head s).\n        extf f (>\\<^sub>t) (args s) (args s)\\<rbrakk>\n    \\<Longrightarrow> False", "obtain si where si_in_args: \"si \\<in> set (args s)\" and si_gt_si: \"si >\\<^sub>t si\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>si.\n        \\<lbrakk>si \\<in> set (args s); si >\\<^sub>t si\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using in_grounds"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>local.ground_heads (head s).\n     extf f (>\\<^sub>t) (args s) (args s)\n\ngoal (1 subgoal):\n 1. (\\<And>si.\n        \\<lbrakk>si \\<in> set (args s); si >\\<^sub>t si\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (full_types) all_not_in_conv extf_irrefl_from_trans ground_heads_nonempty gt_trans)"], ["proof (state)\nthis:\n  si \\<in> set (args s)\n  si >\\<^sub>t si\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head s = head s; chkchop_same (>\\<^sub>t) s s;\n     \\<forall>f\\<in>local.ground_heads (head s).\n        extf f (>\\<^sub>t) (args s) (args s)\\<rbrakk>\n    \\<Longrightarrow> False", "have \"hsize si < hsize s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hsize si < hsize s", "by (rule hsize_in_args[OF si_in_args])"], ["proof (state)\nthis:\n  hsize si < hsize s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head s = head s; chkchop_same (>\\<^sub>t) s s;\n     \\<forall>f\\<in>local.ground_heads (head s).\n        extf f (>\\<^sub>t) (args s) (args s)\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  hsize si < hsize s\n\ngoal (1 subgoal):\n 1. False", "by (rule ih[OF _ si_gt_si])"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gt_antisym: \"t >\\<^sub>t s \\<Longrightarrow> \\<not> s >\\<^sub>t t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t >\\<^sub>t s \\<Longrightarrow> \\<not> s >\\<^sub>t t", "using gt_irrefl gt_trans"], ["proof (prove)\nusing this:\n  \\<not> ?s >\\<^sub>t ?s\n  \\<lbrakk>?u >\\<^sub>t ?t; ?t >\\<^sub>t ?s\\<rbrakk>\n  \\<Longrightarrow> ?u >\\<^sub>t ?s\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s \\<Longrightarrow> \\<not> s >\\<^sub>t t", "by blast"], ["", "subsection \"Compatibility with Embedding Relation\""], ["", "(* TODO: move? *)"], ["", "lemma nth_drop_lemma:\n  assumes \"length xs = length ys\"\nand \"k \\<le> length xs\"\nand \"\\<And>i. i < length xs \\<longrightarrow> i \\<ge> k \\<longrightarrow> xs ! i = ys ! i\"\nshows \"drop k xs = drop k ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop k xs = drop k ys", "using assms"], ["proof (prove)\nusing this:\n  length xs = length ys\n  k \\<le> length xs\n  ?i < length xs \\<longrightarrow>\n  k \\<le> ?i \\<longrightarrow> xs ! ?i = ys ! ?i\n\ngoal (1 subgoal):\n 1. drop k xs = drop k ys", "proof (induct arbitrary:k rule:list_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> length [];\n        \\<And>i.\n           i < length [] \\<longrightarrow>\n           k \\<le> i \\<longrightarrow> [] ! i = [] ! i\\<rbrakk>\n       \\<Longrightarrow> drop k [] = drop k []\n 2. \\<And>x xs y ys k.\n       \\<lbrakk>length xs = length ys;\n        \\<And>k.\n           \\<lbrakk>k \\<le> length xs;\n            \\<And>i.\n               i < length xs \\<longrightarrow>\n               k \\<le> i \\<longrightarrow> xs ! i = ys ! i\\<rbrakk>\n           \\<Longrightarrow> drop k xs = drop k ys;\n        k \\<le> length (x # xs);\n        \\<And>i.\n           i < length (x # xs) \\<longrightarrow>\n           k \\<le> i \\<longrightarrow> (x # xs) ! i = (y # ys) ! i\\<rbrakk>\n       \\<Longrightarrow> drop k (x # xs) = drop k (y # ys)", "case Nil"], ["proof (state)\nthis:\n  k \\<le> length []\n  ?i < length [] \\<longrightarrow>\n  k \\<le> ?i \\<longrightarrow> [] ! ?i = [] ! ?i\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> length [];\n        \\<And>i.\n           i < length [] \\<longrightarrow>\n           k \\<le> i \\<longrightarrow> [] ! i = [] ! i\\<rbrakk>\n       \\<Longrightarrow> drop k [] = drop k []\n 2. \\<And>x xs y ys k.\n       \\<lbrakk>length xs = length ys;\n        \\<And>k.\n           \\<lbrakk>k \\<le> length xs;\n            \\<And>i.\n               i < length xs \\<longrightarrow>\n               k \\<le> i \\<longrightarrow> xs ! i = ys ! i\\<rbrakk>\n           \\<Longrightarrow> drop k xs = drop k ys;\n        k \\<le> length (x # xs);\n        \\<And>i.\n           i < length (x # xs) \\<longrightarrow>\n           k \\<le> i \\<longrightarrow> (x # xs) ! i = (y # ys) ! i\\<rbrakk>\n       \\<Longrightarrow> drop k (x # xs) = drop k (y # ys)", "then"], ["proof (chain)\npicking this:\n  k \\<le> length []\n  ?i < length [] \\<longrightarrow>\n  k \\<le> ?i \\<longrightarrow> [] ! ?i = [] ! ?i", "show ?case"], ["proof (prove)\nusing this:\n  k \\<le> length []\n  ?i < length [] \\<longrightarrow>\n  k \\<le> ?i \\<longrightarrow> [] ! ?i = [] ! ?i\n\ngoal (1 subgoal):\n 1. drop k [] = drop k []", "by simp"], ["proof (state)\nthis:\n  drop k [] = drop k []\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys k.\n       \\<lbrakk>length xs = length ys;\n        \\<And>k.\n           \\<lbrakk>k \\<le> length xs;\n            \\<And>i.\n               i < length xs \\<longrightarrow>\n               k \\<le> i \\<longrightarrow> xs ! i = ys ! i\\<rbrakk>\n           \\<Longrightarrow> drop k xs = drop k ys;\n        k \\<le> length (x # xs);\n        \\<And>i.\n           i < length (x # xs) \\<longrightarrow>\n           k \\<le> i \\<longrightarrow> (x # xs) ! i = (y # ys) ! i\\<rbrakk>\n       \\<Longrightarrow> drop k (x # xs) = drop k (y # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys k.\n       \\<lbrakk>length xs = length ys;\n        \\<And>k.\n           \\<lbrakk>k \\<le> length xs;\n            \\<And>i.\n               i < length xs \\<longrightarrow>\n               k \\<le> i \\<longrightarrow> xs ! i = ys ! i\\<rbrakk>\n           \\<Longrightarrow> drop k xs = drop k ys;\n        k \\<le> length (x # xs);\n        \\<And>i.\n           i < length (x # xs) \\<longrightarrow>\n           k \\<le> i \\<longrightarrow> (x # xs) ! i = (y # ys) ! i\\<rbrakk>\n       \\<Longrightarrow> drop k (x # xs) = drop k (y # ys)", "case (Cons x xs y ys)"], ["proof (state)\nthis:\n  length xs = length ys\n  \\<lbrakk>?k \\<le> length xs;\n   \\<And>i.\n      i < length xs \\<longrightarrow>\n      ?k \\<le> i \\<longrightarrow> xs ! i = ys ! i\\<rbrakk>\n  \\<Longrightarrow> drop ?k xs = drop ?k ys\n  k \\<le> length (x # xs)\n  ?i < length (x # xs) \\<longrightarrow>\n  k \\<le> ?i \\<longrightarrow> (x # xs) ! ?i = (y # ys) ! ?i\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys k.\n       \\<lbrakk>length xs = length ys;\n        \\<And>k.\n           \\<lbrakk>k \\<le> length xs;\n            \\<And>i.\n               i < length xs \\<longrightarrow>\n               k \\<le> i \\<longrightarrow> xs ! i = ys ! i\\<rbrakk>\n           \\<Longrightarrow> drop k xs = drop k ys;\n        k \\<le> length (x # xs);\n        \\<And>i.\n           i < length (x # xs) \\<longrightarrow>\n           k \\<le> i \\<longrightarrow> (x # xs) ! i = (y # ys) ! i\\<rbrakk>\n       \\<Longrightarrow> drop k (x # xs) = drop k (y # ys)", "then"], ["proof (chain)\npicking this:\n  length xs = length ys\n  \\<lbrakk>?k \\<le> length xs;\n   \\<And>i.\n      i < length xs \\<longrightarrow>\n      ?k \\<le> i \\<longrightarrow> xs ! i = ys ! i\\<rbrakk>\n  \\<Longrightarrow> drop ?k xs = drop ?k ys\n  k \\<le> length (x # xs)\n  ?i < length (x # xs) \\<longrightarrow>\n  k \\<le> ?i \\<longrightarrow> (x # xs) ! ?i = (y # ys) ! ?i", "show ?case"], ["proof (prove)\nusing this:\n  length xs = length ys\n  \\<lbrakk>?k \\<le> length xs;\n   \\<And>i.\n      i < length xs \\<longrightarrow>\n      ?k \\<le> i \\<longrightarrow> xs ! i = ys ! i\\<rbrakk>\n  \\<Longrightarrow> drop ?k xs = drop ?k ys\n  k \\<le> length (x # xs)\n  ?i < length (x # xs) \\<longrightarrow>\n  k \\<le> ?i \\<longrightarrow> (x # xs) ! ?i = (y # ys) ! ?i\n\ngoal (1 subgoal):\n 1. drop k (x # xs) = drop k (y # ys)", "proof (cases k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>length xs = length ys;\n     \\<And>k.\n        \\<lbrakk>k \\<le> length xs;\n         \\<And>i.\n            i < length xs \\<longrightarrow>\n            k \\<le> i \\<longrightarrow> xs ! i = ys ! i\\<rbrakk>\n        \\<Longrightarrow> drop k xs = drop k ys;\n     k \\<le> length (x # xs);\n     \\<And>i.\n        i < length (x # xs) \\<longrightarrow>\n        k \\<le> i \\<longrightarrow> (x # xs) ! i = (y # ys) ! i;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> drop k (x # xs) = drop k (y # ys)\n 2. \\<And>nat.\n       \\<lbrakk>length xs = length ys;\n        \\<And>k.\n           \\<lbrakk>k \\<le> length xs;\n            \\<And>i.\n               i < length xs \\<longrightarrow>\n               k \\<le> i \\<longrightarrow> xs ! i = ys ! i\\<rbrakk>\n           \\<Longrightarrow> drop k xs = drop k ys;\n        k \\<le> length (x # xs);\n        \\<And>i.\n           i < length (x # xs) \\<longrightarrow>\n           k \\<le> i \\<longrightarrow> (x # xs) ! i = (y # ys) ! i;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> drop k (x # xs) = drop k (y # ys)", "case 0"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length xs = length ys;\n     \\<And>k.\n        \\<lbrakk>k \\<le> length xs;\n         \\<And>i.\n            i < length xs \\<longrightarrow>\n            k \\<le> i \\<longrightarrow> xs ! i = ys ! i\\<rbrakk>\n        \\<Longrightarrow> drop k xs = drop k ys;\n     k \\<le> length (x # xs);\n     \\<And>i.\n        i < length (x # xs) \\<longrightarrow>\n        k \\<le> i \\<longrightarrow> (x # xs) ! i = (y # ys) ! i;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> drop k (x # xs) = drop k (y # ys)\n 2. \\<And>nat.\n       \\<lbrakk>length xs = length ys;\n        \\<And>k.\n           \\<lbrakk>k \\<le> length xs;\n            \\<And>i.\n               i < length xs \\<longrightarrow>\n               k \\<le> i \\<longrightarrow> xs ! i = ys ! i\\<rbrakk>\n           \\<Longrightarrow> drop k xs = drop k ys;\n        k \\<le> length (x # xs);\n        \\<And>i.\n           i < length (x # xs) \\<longrightarrow>\n           k \\<le> i \\<longrightarrow> (x # xs) ! i = (y # ys) ! i;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> drop k (x # xs) = drop k (y # ys)", "then"], ["proof (chain)\npicking this:\n  k = 0", "have \"x # xs =  y # ys\""], ["proof (prove)\nusing this:\n  k = 0\n\ngoal (1 subgoal):\n 1. x # xs = y # ys", "by (metis Cons.hyps(1) Cons.prems(2) leI length_Cons not_less_zero nth_equalityI)"], ["proof (state)\nthis:\n  x # xs = y # ys\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length xs = length ys;\n     \\<And>k.\n        \\<lbrakk>k \\<le> length xs;\n         \\<And>i.\n            i < length xs \\<longrightarrow>\n            k \\<le> i \\<longrightarrow> xs ! i = ys ! i\\<rbrakk>\n        \\<Longrightarrow> drop k xs = drop k ys;\n     k \\<le> length (x # xs);\n     \\<And>i.\n        i < length (x # xs) \\<longrightarrow>\n        k \\<le> i \\<longrightarrow> (x # xs) ! i = (y # ys) ! i;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> drop k (x # xs) = drop k (y # ys)\n 2. \\<And>nat.\n       \\<lbrakk>length xs = length ys;\n        \\<And>k.\n           \\<lbrakk>k \\<le> length xs;\n            \\<And>i.\n               i < length xs \\<longrightarrow>\n               k \\<le> i \\<longrightarrow> xs ! i = ys ! i\\<rbrakk>\n           \\<Longrightarrow> drop k xs = drop k ys;\n        k \\<le> length (x # xs);\n        \\<And>i.\n           i < length (x # xs) \\<longrightarrow>\n           k \\<le> i \\<longrightarrow> (x # xs) ! i = (y # ys) ! i;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> drop k (x # xs) = drop k (y # ys)", "then"], ["proof (chain)\npicking this:\n  x # xs = y # ys", "show ?thesis"], ["proof (prove)\nusing this:\n  x # xs = y # ys\n\ngoal (1 subgoal):\n 1. drop k (x # xs) = drop k (y # ys)", "by blast"], ["proof (state)\nthis:\n  drop k (x # xs) = drop k (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>length xs = length ys;\n        \\<And>k.\n           \\<lbrakk>k \\<le> length xs;\n            \\<And>i.\n               i < length xs \\<longrightarrow>\n               k \\<le> i \\<longrightarrow> xs ! i = ys ! i\\<rbrakk>\n           \\<Longrightarrow> drop k xs = drop k ys;\n        k \\<le> length (x # xs);\n        \\<And>i.\n           i < length (x # xs) \\<longrightarrow>\n           k \\<le> i \\<longrightarrow> (x # xs) ! i = (y # ys) ! i;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> drop k (x # xs) = drop k (y # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>length xs = length ys;\n        \\<And>k.\n           \\<lbrakk>k \\<le> length xs;\n            \\<And>i.\n               i < length xs \\<longrightarrow>\n               k \\<le> i \\<longrightarrow> xs ! i = ys ! i\\<rbrakk>\n           \\<Longrightarrow> drop k xs = drop k ys;\n        k \\<le> length (x # xs);\n        \\<And>i.\n           i < length (x # xs) \\<longrightarrow>\n           k \\<le> i \\<longrightarrow> (x # xs) ! i = (y # ys) ! i;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> drop k (x # xs) = drop k (y # ys)", "case (Suc m)"], ["proof (state)\nthis:\n  k = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>length xs = length ys;\n        \\<And>k.\n           \\<lbrakk>k \\<le> length xs;\n            \\<And>i.\n               i < length xs \\<longrightarrow>\n               k \\<le> i \\<longrightarrow> xs ! i = ys ! i\\<rbrakk>\n           \\<Longrightarrow> drop k xs = drop k ys;\n        k \\<le> length (x # xs);\n        \\<And>i.\n           i < length (x # xs) \\<longrightarrow>\n           k \\<le> i \\<longrightarrow> (x # xs) ! i = (y # ys) ! i;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> drop k (x # xs) = drop k (y # ys)", "then"], ["proof (chain)\npicking this:\n  k = Suc m", "have \"drop m xs = drop m ys\""], ["proof (prove)\nusing this:\n  k = Suc m\n\ngoal (1 subgoal):\n 1. drop m xs = drop m ys", "by (metis Cons.hyps(2) Cons.prems(1) Cons.prems(2) Suc_le_mono Suc_mono length_Cons nth_Cons_Suc)"], ["proof (state)\nthis:\n  drop m xs = drop m ys\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>length xs = length ys;\n        \\<And>k.\n           \\<lbrakk>k \\<le> length xs;\n            \\<And>i.\n               i < length xs \\<longrightarrow>\n               k \\<le> i \\<longrightarrow> xs ! i = ys ! i\\<rbrakk>\n           \\<Longrightarrow> drop k xs = drop k ys;\n        k \\<le> length (x # xs);\n        \\<And>i.\n           i < length (x # xs) \\<longrightarrow>\n           k \\<le> i \\<longrightarrow> (x # xs) ! i = (y # ys) ! i;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> drop k (x # xs) = drop k (y # ys)", "then"], ["proof (chain)\npicking this:\n  drop m xs = drop m ys", "show ?thesis"], ["proof (prove)\nusing this:\n  drop m xs = drop m ys\n\ngoal (1 subgoal):\n 1. drop k (x # xs) = drop k (y # ys)", "by (simp add: Suc)"], ["proof (state)\nthis:\n  drop k (x # xs) = drop k (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  drop k (x # xs) = drop k (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gt_embedding_step_property:\n  assumes \"t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\"\n  shows \"t >\\<^sub>t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t >\\<^sub>t s", "using assms"], ["proof (prove)\nusing this:\n  t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s", "apply(simp only: atomize_imp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s \\<longrightarrow>\n    t >\\<^sub>t s", "apply (rule measure_induct_rule[of \"\\<lambda>(t, s). hsize t + hsize s\"\n      \"\\<lambda>(t, s). t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s \\<longrightarrow> t >\\<^sub>t s\" \"(t, s)\", simplified prod.case])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (case y of (t, s) \\<Rightarrow> hsize t + hsize s)\n           < (case x of\n              (t, s) \\<Rightarrow> hsize t + hsize s) \\<Longrightarrow>\n           case y of\n           (t, s) \\<Rightarrow>\n             t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s \\<longrightarrow>\n             t >\\<^sub>t s) \\<Longrightarrow>\n       case x of\n       (t, s) \\<Rightarrow>\n         t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s \\<longrightarrow>\n         t >\\<^sub>t s", "proof(simp only: split_paired_all prod.case atomize_imp[symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>hsize aa + hsize ba < hsize a + hsize b;\n                    aa \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba;\n        a \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b", "fix s t :: \"('s,'v) tm\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>hsize aa + hsize ba < hsize a + hsize b;\n                    aa \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba;\n        a \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b", "assume \"t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\" \n    and ih: \"\\<And>tt ss. hsize tt + hsize ss < hsize t + hsize s \\<Longrightarrow> tt \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b ss \\<Longrightarrow> tt >\\<^sub>t ss\""], ["proof (state)\nthis:\n  t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\n  \\<lbrakk>hsize ?tt + hsize ?ss < hsize t + hsize s;\n   ?tt \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b ?ss\\<rbrakk>\n  \\<Longrightarrow> ?tt >\\<^sub>t ?ss\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>hsize aa + hsize ba < hsize a + hsize b;\n                    aa \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba;\n        a \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b", "have \"is_App t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_App t", "by (metis \\<open>t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\\<close> emb_step_at_is_App emb_step_equiv)"], ["proof (state)\nthis:\n  is_App t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>hsize aa + hsize ba < hsize a + hsize b;\n                    aa \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba;\n        a \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b", "obtain p d where \"emb_step_at p d t = s\" \"position_of t (p @ [d])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p d.\n        \\<lbrakk>emb_step_at p d t = s; position_of t (p @ [d])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\\<close> emb_step_equiv"], ["proof (prove)\nusing this:\n  t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\n  (?t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b ?s) =\n  ((\\<exists>p d. emb_step_at p d ?t = ?s) \\<and> ?t \\<noteq> ?s)\n\ngoal (1 subgoal):\n 1. (\\<And>p d.\n        \\<lbrakk>emb_step_at p d t = s; position_of t (p @ [d])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis position_if_emb_step_at)"], ["proof (state)\nthis:\n  emb_step_at p d t = s\n  position_of t (p @ [d])\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>hsize aa + hsize ba < hsize a + hsize b;\n                    aa \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba;\n        a \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b", "define q where q_rep_t: \"q = replicate (num_args (fun t)) Left\""], ["proof (state)\nthis:\n  q = replicate (num_args (fun t)) dir.Left\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>hsize aa + hsize ba < hsize a + hsize b;\n                    aa \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba;\n        a \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b", "show \"t >\\<^sub>t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t >\\<^sub>t s", "proof (cases \"list_all (\\<lambda>x. x = Left) p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. list_all (\\<lambda>x. x = dir.Left) p \\<Longrightarrow> t >\\<^sub>t s\n 2. \\<not> list_all (\\<lambda>x. x = dir.Left) p \\<Longrightarrow>\n    t >\\<^sub>t s", "case True"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. x = dir.Left) p\n\ngoal (2 subgoals):\n 1. list_all (\\<lambda>x. x = dir.Left) p \\<Longrightarrow> t >\\<^sub>t s\n 2. \\<not> list_all (\\<lambda>x. x = dir.Left) p \\<Longrightarrow>\n    t >\\<^sub>t s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. t >\\<^sub>t s", "proof (cases d)"], ["proof (state)\ngoal (2 subgoals):\n 1. d = dir.Left \\<Longrightarrow> t >\\<^sub>t s\n 2. d = dir.Right \\<Longrightarrow> t >\\<^sub>t s", "text \\<open>Embedding removes an argument i\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. d = dir.Left \\<Longrightarrow> t >\\<^sub>t s\n 2. d = dir.Right \\<Longrightarrow> t >\\<^sub>t s", "case Left"], ["proof (state)\nthis:\n  d = dir.Left\n\ngoal (2 subgoals):\n 1. d = dir.Left \\<Longrightarrow> t >\\<^sub>t s\n 2. d = dir.Right \\<Longrightarrow> t >\\<^sub>t s", "define i where \"i = num_args t - Suc (length p)\""], ["proof (state)\nthis:\n  i = num_args t - Suc (length p)\n\ngoal (2 subgoals):\n 1. d = dir.Left \\<Longrightarrow> t >\\<^sub>t s\n 2. d = dir.Right \\<Longrightarrow> t >\\<^sub>t s", "then"], ["proof (chain)\npicking this:\n  i = num_args t - Suc (length p)", "have \" head t = head s\" \"i < num_args t\" \"args s = take i (args t) @ drop (Suc i) (args t)\""], ["proof (prove)\nusing this:\n  i = num_args t - Suc (length p)\n\ngoal (1 subgoal):\n 1. head t = head s &&&\n    i < num_args t &&& args s = take i (args t) @ drop (Suc i) (args t)", "using emb_step_at_remove_arg Left True \\<open>emb_step_at p d t = s\\<close> \\<open>position_of t (p @ [d])\\<close>"], ["proof (prove)\nusing this:\n  i = num_args t - Suc (length p)\n  \\<lbrakk>emb_step_at ?p dir.Left ?t = ?s;\n   position_of ?t (?p @ [dir.Left]);\n   list_all (\\<lambda>x. x = dir.Left) ?p\\<rbrakk>\n  \\<Longrightarrow> let i = num_args ?t - Suc (length ?p)\n                    in head ?t = head ?s \\<and>\n                       i < num_args ?t \\<and>\n                       args ?s = take i (args ?t) @ drop (Suc i) (args ?t)\n  d = dir.Left\n  list_all (\\<lambda>x. x = dir.Left) p\n  emb_step_at p d t = s\n  position_of t (p @ [d])\n\ngoal (1 subgoal):\n 1. head t = head s &&&\n    i < num_args t &&& args s = take i (args t) @ drop (Suc i) (args t)", "by metis+"], ["proof (state)\nthis:\n  head t = head s\n  i < num_args t\n  args s = take i (args t) @ drop (Suc i) (args t)\n\ngoal (2 subgoals):\n 1. d = dir.Left \\<Longrightarrow> t >\\<^sub>t s\n 2. d = dir.Right \\<Longrightarrow> t >\\<^sub>t s", "have \"is_App s \\<Longrightarrow> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_App s \\<Longrightarrow>\n    chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "proof (cases \"p = q\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_App s; p = q\\<rbrakk>\n    \\<Longrightarrow> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\n 2. \\<lbrakk>is_App s; p \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "case True"], ["proof (state)\nthis:\n  p = q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_App s; p = q\\<rbrakk>\n    \\<Longrightarrow> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\n 2. \\<lbrakk>is_App s; p \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "assume \"is_App s\""], ["proof (state)\nthis:\n  is_App s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_App s; p = q\\<rbrakk>\n    \\<Longrightarrow> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\n 2. \\<lbrakk>is_App s; p \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "have \"Suc (num_args (fun s)) = num_args (fun t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (num_args (fun s)) = num_args (fun t)", "by (metis One_nat_def Suc_num_args True \\<open>args s = take i (args t) @ drop (Suc i) (args t)\\<close> \\<open>is_App s\\<close> \\<open>is_App t\\<close> append_self_conv2 cancel_comm_monoid_add_class.diff_cancel diff_Suc_1 i_def length_drop length_replicate q_rep_t take_eq_Nil)"], ["proof (state)\nthis:\n  Suc (num_args (fun s)) = num_args (fun t)\n\ngoal (1 subgoal):\n 1. chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "have \"emb_step_at (replicate (num_args (fun s)) Left) Right (chop t) =\n                emb_step_at (replicate (num_args (fun s)) Left) Right t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right (chop t) =\n    emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right t", "using merge_emb_step_at[of \"replicate (num_args (fun s)) Left\" Right Nil Right t, unfolded append_Nil2 opp_simps(1) replicate_append_same]"], ["proof (prove)\nusing this:\n  emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right\n   (emb_step_at (dir.Left # replicate (num_args (fun s)) dir.Left) dir.Right\n     t) =\n  emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right t\n\ngoal (1 subgoal):\n 1. emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right (chop t) =\n    emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right t", "by (metis \\<open>Suc (num_args (fun s)) = num_args (fun t)\\<close> \\<open>is_App t\\<close> chop_emb_step_at replicate_Suc)"], ["proof (state)\nthis:\n  emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right (chop t) =\n  emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right t\n\ngoal (1 subgoal):\n 1. chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "then"], ["proof (chain)\npicking this:\n  emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right (chop t) =\n  emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right t", "have \"emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right (chop t) = chop s\""], ["proof (prove)\nusing this:\n  emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right (chop t) =\n  emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right t\n\ngoal (1 subgoal):\n 1. emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right (chop t) =\n    chop s", "unfolding chop_emb_step_at[OF \\<open>is_App s\\<close>]"], ["proof (prove)\nusing this:\n  emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right (chop t) =\n  emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right t\n\ngoal (1 subgoal):\n 1. emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right (chop t) =\n    emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right s", "using merge_emb_step_at[of \"replicate (num_args (fun s)) Left\" Right Nil Left t, unfolded append_Nil2 opp_simps(1) replicate_append_same]"], ["proof (prove)\nusing this:\n  emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right (chop t) =\n  emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right t\n  emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right\n   (emb_step_at (dir.Left # replicate (num_args (fun s)) dir.Left) dir.Left\n     t) =\n  emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right t\n\ngoal (1 subgoal):\n 1. emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right (chop t) =\n    emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right s", "by (metis Left True \\<open>Suc (num_args (fun s)) = num_args (fun t)\\<close> \\<open>emb_step_at p d t = s\\<close> q_rep_t replicate_Suc)"], ["proof (state)\nthis:\n  emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right (chop t) =\n  chop s\n\ngoal (1 subgoal):\n 1. chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "then"], ["proof (chain)\npicking this:\n  emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right (chop t) =\n  chop s", "show \"chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\""], ["proof (prove)\nusing this:\n  emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right (chop t) =\n  chop s\n\ngoal (1 subgoal):\n 1. chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "by (metis \\<open>is_App s\\<close> \\<open>is_App t\\<close> \\<open>t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\\<close> emb_step_equiv emb_step_hsize nat_neq_iff hsize_chop)"], ["proof (state)\nthis:\n  chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_App s; p \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_App s; p \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "case False"], ["proof (state)\nthis:\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_App s; p \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "assume \"is_App s\""], ["proof (state)\nthis:\n  is_App s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_App s; p \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "have p_rep: \"p = replicate (length p) Left\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = replicate (length p) dir.Left", "by (metis (full_types) \\<open>list_all (\\<lambda>x. x = Left) p\\<close> list_all_iff replicate_length_same)"], ["proof (state)\nthis:\n  p = replicate (length p) dir.Left\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_App s; p \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "have length_p:\"length p < num_args t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length p < num_args t", "using no_position_replicate_num_args \\<open>position_of t (p @ [d])\\<close> \n            replicate_add[of \"num_args t\" \"length p - num_args t\" Left]  p_rep q_rep_t"], ["proof (prove)\nusing this:\n  \\<not> position_of ?t (replicate (num_args ?t) dir.Left @ [?d])\n  position_of t (p @ [d])\n  replicate (num_args t + (length p - num_args t)) dir.Left =\n  replicate (num_args t) dir.Left @\n  replicate (length p - num_args t) dir.Left\n  p = replicate (length p) dir.Left\n  q = replicate (num_args (fun t)) dir.Left\n\ngoal (1 subgoal):\n 1. length p < num_args t", "by (metis Left add_diff_inverse_nat replicate_app_Cons_same replicate_append_same shallower_pos)"], ["proof (state)\nthis:\n  length p < num_args t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_App s; p \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "then"], ["proof (chain)\npicking this:\n  length p < num_args t", "have \"length p \\<le> length q\""], ["proof (prove)\nusing this:\n  length p < num_args t\n\ngoal (1 subgoal):\n 1. length p \\<le> length q", "using Suc_num_args \\<open>is_App t\\<close> q_rep_t"], ["proof (prove)\nusing this:\n  length p < num_args t\n  is_App ?t \\<Longrightarrow> Suc (num_args (fun ?t)) = num_args ?t\n  is_App t\n  q = replicate (num_args (fun t)) dir.Left\n\ngoal (1 subgoal):\n 1. length p \\<le> length q", "by fastforce"], ["proof (state)\nthis:\n  length p \\<le> length q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_App s; p \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "then"], ["proof (chain)\npicking this:\n  length p \\<le> length q", "have \"length p < length q\""], ["proof (prove)\nusing this:\n  length p \\<le> length q\n\ngoal (1 subgoal):\n 1. length p < length q", "using False le_neq_implies_less p_rep q_rep_t"], ["proof (prove)\nusing this:\n  length p \\<le> length q\n  p \\<noteq> q\n  \\<lbrakk>?m \\<le> ?n; ?m \\<noteq> ?n\\<rbrakk> \\<Longrightarrow> ?m < ?n\n  p = replicate (length p) dir.Left\n  q = replicate (num_args (fun t)) dir.Left\n\ngoal (1 subgoal):\n 1. length p < length q", "by fastforce"], ["proof (state)\nthis:\n  length p < length q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_App s; p \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "then"], ["proof (chain)\npicking this:\n  length p < length q", "have \"take (Suc (length p)) q = p @ [Left]\""], ["proof (prove)\nusing this:\n  length p < length q\n\ngoal (1 subgoal):\n 1. take (Suc (length p)) q = p @ [dir.Left]", "by (metis (no_types, lifting) \\<open>length p \\<le> length q\\<close> length_replicate min.orderE nth_replicate p_rep q_rep_t take_Suc_conv_app_nth take_replicate)"], ["proof (state)\nthis:\n  take (Suc (length p)) q = p @ [dir.Left]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_App s; p \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "then"], ["proof (chain)\npicking this:\n  take (Suc (length p)) q = p @ [dir.Left]", "obtain q' where \"q = p @ [Left] @ q'\""], ["proof (prove)\nusing this:\n  take (Suc (length p)) q = p @ [dir.Left]\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        q = p @ [dir.Left] @ q' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis append.assoc append_take_drop_id)"], ["proof (state)\nthis:\n  q = p @ [dir.Left] @ q'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_App s; p \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "have \"Suc (num_args (fun s)) = num_args (fun t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (num_args (fun s)) = num_args (fun t)", "by (metis (no_types, lifting) Cons_nth_drop_Suc Suc_num_args \\<open>args s = take i (args t) @ drop (Suc i) (args t)\\<close> \\<open>i < num_args t\\<close> \\<open>is_App s\\<close> \\<open>is_App t\\<close> add_Suc_right append_take_drop_id diff_Suc_1 length_Cons length_append)"], ["proof (state)\nthis:\n  Suc (num_args (fun s)) = num_args (fun t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_App s; p \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "then"], ["proof (chain)\npicking this:\n  Suc (num_args (fun s)) = num_args (fun t)", "have \"chop s = emb_step_at p dir.Left (chop t)\""], ["proof (prove)\nusing this:\n  Suc (num_args (fun s)) = num_args (fun t)\n\ngoal (1 subgoal):\n 1. chop s = emb_step_at p dir.Left (chop t)", "using swap_nested_emb_step_at[of p q' Right Left t] chop_emb_step_at[OF \\<open>is_App s\\<close>]\n            chop_emb_step_at[OF \\<open>is_App t\\<close>]"], ["proof (prove)\nusing this:\n  Suc (num_args (fun s)) = num_args (fun t)\n  emb_step_at (p @ q') dir.Right (emb_step_at p dir.Left t) =\n  emb_step_at p dir.Left (emb_step_at (p @ [dir.Left] @ q') dir.Right t)\n  chop s = emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right s\n  chop t = emb_step_at (replicate (num_args (fun t)) dir.Left) dir.Right t\n\ngoal (1 subgoal):\n 1. chop s = emb_step_at p dir.Left (chop t)", "by (metis (no_types, lifting) Cons_replicate_eq Left \\<open>emb_step_at p d t = s\\<close> \\<open>q = p @ [dir.Left] @ q'\\<close> append.assoc append_Cons diff_Suc_1 p_rep q_rep_t replicate_append_same)"], ["proof (state)\nthis:\n  chop s = emb_step_at p dir.Left (chop t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_App s; p \\<noteq> q\\<rbrakk>\n    \\<Longrightarrow> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "then"], ["proof (chain)\npicking this:\n  chop s = emb_step_at p dir.Left (chop t)", "show \"chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\""], ["proof (prove)\nusing this:\n  chop s = emb_step_at p dir.Left (chop t)\n\ngoal (1 subgoal):\n 1. chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "by (metis Left \\<open>is_App t\\<close> \\<open>position_of t (p @ [d])\\<close> \\<open>q = p @ [dir.Left] @ q'\\<close> chop_emb_step_at emb_step_at_if_position pos_emb_step_at_nested q_rep_t)"], ["proof (state)\nthis:\n  chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_App s \\<Longrightarrow>\n  chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\n\ngoal (2 subgoals):\n 1. d = dir.Left \\<Longrightarrow> t >\\<^sub>t s\n 2. d = dir.Right \\<Longrightarrow> t >\\<^sub>t s", "then"], ["proof (chain)\npicking this:\n  is_App s \\<Longrightarrow>\n  chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "have \"chkchop_same (>\\<^sub>t) t s\""], ["proof (prove)\nusing this:\n  is_App s \\<Longrightarrow>\n  chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\n\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) t s", "proof (cases \"is_Var (head t)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_App s \\<Longrightarrow>\n             chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s;\n     is_Var (head t)\\<rbrakk>\n    \\<Longrightarrow> chkchop_same (>\\<^sub>t) t s\n 2. \\<lbrakk>is_App s \\<Longrightarrow>\n             chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s;\n     is_Sym (head t)\\<rbrakk>\n    \\<Longrightarrow> chkchop_same (>\\<^sub>t) t s", "case True"], ["proof (state)\nthis:\n  is_Var (head t)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_App s \\<Longrightarrow>\n             chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s;\n     is_Var (head t)\\<rbrakk>\n    \\<Longrightarrow> chkchop_same (>\\<^sub>t) t s\n 2. \\<lbrakk>is_App s \\<Longrightarrow>\n             chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s;\n     is_Sym (head t)\\<rbrakk>\n    \\<Longrightarrow> chkchop_same (>\\<^sub>t) t s", "then"], ["proof (chain)\npicking this:\n  is_Var (head t)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_Var (head t)\n\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) t s", "unfolding chkchop_same_def chkchop_def"], ["proof (prove)\nusing this:\n  is_Var (head t)\n\ngoal (1 subgoal):\n 1. if is_Var (head t)\n    then is_Hd t \\<or> is_Hd s \\<or> chop t >\\<^sub>t chop s\n    else is_Hd s \\<or> t >\\<^sub>t chop s", "using ih[of \"chop t\" \"chop s\"] \n           add_less_mono hsize_chop_lt \\<open>is_App s \\<Longrightarrow> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\\<close>"], ["proof (prove)\nusing this:\n  is_Var (head t)\n  \\<lbrakk>hsize (chop t) + hsize (chop s) < hsize t + hsize s;\n   chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\\<rbrakk>\n  \\<Longrightarrow> chop t >\\<^sub>t chop s\n  \\<lbrakk>?i < ?j; ?k < ?l\\<rbrakk> \\<Longrightarrow> ?i + ?k < ?j + ?l\n  is_App ?t \\<Longrightarrow> hsize (chop ?t) < hsize ?t\n  is_App s \\<Longrightarrow>\n  chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\n\ngoal (1 subgoal):\n 1. if is_Var (head t)\n    then is_Hd t \\<or> is_Hd s \\<or> chop t >\\<^sub>t chop s\n    else is_Hd s \\<or> t >\\<^sub>t chop s", "by metis"], ["proof (state)\nthis:\n  chkchop_same (>\\<^sub>t) t s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_App s \\<Longrightarrow>\n             chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s;\n     is_Sym (head t)\\<rbrakk>\n    \\<Longrightarrow> chkchop_same (>\\<^sub>t) t s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_App s \\<Longrightarrow>\n             chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s;\n     is_Sym (head t)\\<rbrakk>\n    \\<Longrightarrow> chkchop_same (>\\<^sub>t) t s", "case False"], ["proof (state)\nthis:\n  is_Sym (head t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_App s \\<Longrightarrow>\n             chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s;\n     is_Sym (head t)\\<rbrakk>\n    \\<Longrightarrow> chkchop_same (>\\<^sub>t) t s", "then"], ["proof (chain)\npicking this:\n  is_Sym (head t)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_Sym (head t)\n\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) t s", "unfolding chkchop_same_def chkchop_def"], ["proof (prove)\nusing this:\n  is_Sym (head t)\n\ngoal (1 subgoal):\n 1. if is_Var (head t)\n    then is_Hd t \\<or> is_Hd s \\<or> chop t >\\<^sub>t chop s\n    else is_Hd s \\<or> t >\\<^sub>t chop s", "using \\<open>is_App t\\<close> add_less_mono gt_chop ih hsize_chop_lt \n        \\<open>is_App s \\<Longrightarrow> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\\<close>"], ["proof (prove)\nusing this:\n  is_Sym (head t)\n  is_App t\n  \\<lbrakk>?i < ?j; ?k < ?l\\<rbrakk> \\<Longrightarrow> ?i + ?k < ?j + ?l\n  \\<lbrakk>is_App ?t; chop ?t \\<ge>\\<^sub>t ?s\\<rbrakk>\n  \\<Longrightarrow> ?t >\\<^sub>t ?s\n  \\<lbrakk>hsize ?tt + hsize ?ss < hsize t + hsize s;\n   ?tt \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b ?ss\\<rbrakk>\n  \\<Longrightarrow> ?tt >\\<^sub>t ?ss\n  is_App ?t \\<Longrightarrow> hsize (chop ?t) < hsize ?t\n  is_App s \\<Longrightarrow>\n  chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\n\ngoal (1 subgoal):\n 1. if is_Var (head t)\n    then is_Hd t \\<or> is_Hd s \\<or> chop t >\\<^sub>t chop s\n    else is_Hd s \\<or> t >\\<^sub>t chop s", "by metis"], ["proof (state)\nthis:\n  chkchop_same (>\\<^sub>t) t s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chkchop_same (>\\<^sub>t) t s\n\ngoal (2 subgoals):\n 1. d = dir.Left \\<Longrightarrow> t >\\<^sub>t s\n 2. d = dir.Right \\<Longrightarrow> t >\\<^sub>t s", "have \"\\<forall>f\\<in>local.ground_heads (head t). extf f (>\\<^sub>t) (args t) (args s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head t).\n       extf f (>\\<^sub>t) (args t) (args s)", "using extf_ext_insert_arg[of _ _ \"take i (args t)\" \"args t ! i\" \"drop (Suc i) (args t)\"]"], ["proof (prove)\nusing this:\n  extf ?f ?gt (take i (args t) @ args t ! i # drop (Suc i) (args t))\n   (take i (args t) @ drop (Suc i) (args t))\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head t).\n       extf f (>\\<^sub>t) (args t) (args s)", "using \\<open>args s = take i (args t) @ drop (Suc i) (args t)\\<close> \\<open>i < num_args t\\<close> id_take_nth_drop"], ["proof (prove)\nusing this:\n  extf ?f ?gt (take i (args t) @ args t ! i # drop (Suc i) (args t))\n   (take i (args t) @ drop (Suc i) (args t))\n  args s = take i (args t) @ drop (Suc i) (args t)\n  i < num_args t\n  ?i < length ?xs \\<Longrightarrow>\n  ?xs = take ?i ?xs @ ?xs ! ?i # drop (Suc ?i) ?xs\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head t).\n       extf f (>\\<^sub>t) (args t) (args s)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n\ngoal (2 subgoals):\n 1. d = dir.Left \\<Longrightarrow> t >\\<^sub>t s\n 2. d = dir.Right \\<Longrightarrow> t >\\<^sub>t s", "then"], ["proof (chain)\npicking this:\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s", "using gt_same \\<open>head t = head s\\<close> \\<open>chkchop_same (>\\<^sub>t) t s\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n  \\<lbrakk>head ?t = head ?s; chkchop_same (>\\<^sub>t) ?t ?s;\n   \\<forall>f\\<in>local.ground_heads (head ?t).\n      extf f (>\\<^sub>t) (args ?t) (args ?s)\\<rbrakk>\n  \\<Longrightarrow> ?t >\\<^sub>t ?s\n  head t = head s\n  chkchop_same (>\\<^sub>t) t s\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s", "by blast"], ["proof (state)\nthis:\n  t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. d = dir.Right \\<Longrightarrow> t >\\<^sub>t s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d = dir.Right \\<Longrightarrow> t >\\<^sub>t s", "text \\<open>Embedding chops and might remove arguments from the left\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. d = dir.Right \\<Longrightarrow> t >\\<^sub>t s", "case Right"], ["proof (state)\nthis:\n  d = dir.Right\n\ngoal (1 subgoal):\n 1. d = dir.Right \\<Longrightarrow> t >\\<^sub>t s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. t >\\<^sub>t s", "using emb_step_at_chop"], ["proof (prove)\nusing this:\n  \\<lbrakk>emb_step_at ?p dir.Right ?t = ?s;\n   position_of ?t (?p @ [dir.Right]);\n   list_all (\\<lambda>x. x = dir.Left) ?p\\<rbrakk>\n  \\<Longrightarrow> chop ?t = ?s \\<or>\n                    chop ?t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b ?s\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s", "by (metis Right True \\<open>emb_step_at p d t = s\\<close> \\<open>is_App t\\<close> \\<open>position_of t (p @ [d])\\<close> add_Suc gt_chop ih less_Suc_eq hsize_chop)"], ["proof (state)\nthis:\n  t >\\<^sub>t s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<not> list_all (\\<lambda>x. x = dir.Left) p \\<Longrightarrow>\n    t >\\<^sub>t s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> list_all (\\<lambda>x. x = dir.Left) p \\<Longrightarrow>\n    t >\\<^sub>t s", "text \\<open>Embedding operates under one of the arguments\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> list_all (\\<lambda>x. x = dir.Left) p \\<Longrightarrow>\n    t >\\<^sub>t s", "case False"], ["proof (state)\nthis:\n  \\<not> list_all (\\<lambda>x. x = dir.Left) p\n\ngoal (1 subgoal):\n 1. \\<not> list_all (\\<lambda>x. x = dir.Left) p \\<Longrightarrow>\n    t >\\<^sub>t s", "have \"num_args t = num_args s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_args t = num_args s", "using emb_step_under_args_num_args[OF False]"], ["proof (prove)\nusing this:\n  num_args (emb_step_at p ?d ?t) = num_args ?t\n\ngoal (1 subgoal):\n 1. num_args t = num_args s", "by (metis (no_types) \\<open>\\<And>t d. num_args (emb_step_at p d t) = num_args t\\<close> \\<open>emb_step_at p d t = s\\<close>)"], ["proof (state)\nthis:\n  num_args t = num_args s\n\ngoal (1 subgoal):\n 1. \\<not> list_all (\\<lambda>x. x = dir.Left) p \\<Longrightarrow>\n    t >\\<^sub>t s", "then"], ["proof (chain)\npicking this:\n  num_args t = num_args s", "have \"is_App s\""], ["proof (prove)\nusing this:\n  num_args t = num_args s\n\ngoal (1 subgoal):\n 1. is_App s", "using \\<open>num_args t = num_args s\\<close>"], ["proof (prove)\nusing this:\n  num_args t = num_args s\n  num_args t = num_args s\n\ngoal (1 subgoal):\n 1. is_App s", "by (metis args_Nil_iff_is_Hd length_0_conv \\<open>is_App t\\<close>)"], ["proof (state)\nthis:\n  is_App s\n\ngoal (1 subgoal):\n 1. \\<not> list_all (\\<lambda>x. x = dir.Left) p \\<Longrightarrow>\n    t >\\<^sub>t s", "have q_rep_s: \"q = replicate (num_args (fun s)) Left\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = replicate (num_args (fun s)) dir.Left", "by (metis  q_rep_t \\<open>is_App s\\<close> \\<open>is_App t\\<close> \\<open>num_args t = num_args s\\<close> args.simps(2) butlast_snoc length_butlast tm.collapse(2))"], ["proof (state)\nthis:\n  q = replicate (num_args (fun s)) dir.Left\n\ngoal (1 subgoal):\n 1. \\<not> list_all (\\<lambda>x. x = dir.Left) p \\<Longrightarrow>\n    t >\\<^sub>t s", "have \"chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "proof (cases \"take (num_args (fun t)) p = q\")"], ["proof (state)\ngoal (2 subgoals):\n 1. take (num_args (fun t)) p = q \\<Longrightarrow>\n    chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\n 2. take (num_args (fun t)) p \\<noteq> q \\<Longrightarrow>\n    chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "case True"], ["proof (state)\nthis:\n  take (num_args (fun t)) p = q\n\ngoal (2 subgoals):\n 1. take (num_args (fun t)) p = q \\<Longrightarrow>\n    chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\n 2. take (num_args (fun t)) p \\<noteq> q \\<Longrightarrow>\n    chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "have  \"num_args (fun t) < length p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_args (fun t) < length p", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> num_args (fun t) < length p \\<Longrightarrow> False", "assume \"\\<not> num_args (fun t) < length p\""], ["proof (state)\nthis:\n  \\<not> num_args (fun t) < length p\n\ngoal (1 subgoal):\n 1. \\<not> num_args (fun t) < length p \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> num_args (fun t) < length p", "have \"num_args (fun t) = length p\"  \"q = p\""], ["proof (prove)\nusing this:\n  \\<not> num_args (fun t) < length p\n\ngoal (1 subgoal):\n 1. num_args (fun t) = length p &&& q = p", "using True q_rep_t"], ["proof (prove)\nusing this:\n  \\<not> num_args (fun t) < length p\n  take (num_args (fun t)) p = q\n  q = replicate (num_args (fun t)) dir.Left\n\ngoal (1 subgoal):\n 1. num_args (fun t) = length p &&& q = p", "by auto"], ["proof (state)\nthis:\n  num_args (fun t) = length p\n  q = p\n\ngoal (1 subgoal):\n 1. \\<not> num_args (fun t) < length p \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  num_args (fun t) = length p\n  q = p", "show False"], ["proof (prove)\nusing this:\n  num_args (fun t) = length p\n  q = p\n\ngoal (1 subgoal):\n 1. False", "using False"], ["proof (prove)\nusing this:\n  num_args (fun t) = length p\n  q = p\n  \\<not> list_all (\\<lambda>x. x = dir.Left) p\n\ngoal (1 subgoal):\n 1. False", "using list_all_length q_rep_t"], ["proof (prove)\nusing this:\n  num_args (fun t) = length p\n  q = p\n  \\<not> list_all (\\<lambda>x. x = dir.Left) p\n  list_all ?P ?xs = (\\<forall>n<length ?xs. ?P (?xs ! n))\n  q = replicate (num_args (fun t)) dir.Left\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  num_args (fun t) < length p\n\ngoal (2 subgoals):\n 1. take (num_args (fun t)) p = q \\<Longrightarrow>\n    chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\n 2. take (num_args (fun t)) p \\<noteq> q \\<Longrightarrow>\n    chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "have \"p ! (num_args (fun t)) = Right\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ! num_args (fun t) = dir.Right", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. p ! num_args (fun t) \\<noteq> dir.Right \\<Longrightarrow> False", "assume \"p ! num_args (fun t) \\<noteq> Right\""], ["proof (state)\nthis:\n  p ! num_args (fun t) \\<noteq> dir.Right\n\ngoal (1 subgoal):\n 1. p ! num_args (fun t) \\<noteq> dir.Right \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p ! num_args (fun t) \\<noteq> dir.Right", "have \"p ! num_args (fun t) = Left\""], ["proof (prove)\nusing this:\n  p ! num_args (fun t) \\<noteq> dir.Right\n\ngoal (1 subgoal):\n 1. p ! num_args (fun t) = dir.Left", "using dir.exhaust"], ["proof (prove)\nusing this:\n  p ! num_args (fun t) \\<noteq> dir.Right\n  \\<lbrakk>?y = dir.Left \\<Longrightarrow> ?P;\n   ?y = dir.Right \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. p ! num_args (fun t) = dir.Left", "by blast"], ["proof (state)\nthis:\n  p ! num_args (fun t) = dir.Left\n\ngoal (1 subgoal):\n 1. p ! num_args (fun t) \\<noteq> dir.Right \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p ! num_args (fun t) = dir.Left", "have \"take (num_args t) p = replicate (num_args t) Left\""], ["proof (prove)\nusing this:\n  p ! num_args (fun t) = dir.Left\n\ngoal (1 subgoal):\n 1. take (num_args t) p = replicate (num_args t) dir.Left", "using True Suc_num_args[OF \\<open>is_App t\\<close>] q_rep_t\n            take_Suc_conv_app_nth[of \"num_args (fun t)\" p]"], ["proof (prove)\nusing this:\n  p ! num_args (fun t) = dir.Left\n  take (num_args (fun t)) p = q\n  Suc (num_args (fun t)) = num_args t\n  q = replicate (num_args (fun t)) dir.Left\n  num_args (fun t) < length p \\<Longrightarrow>\n  take (Suc (num_args (fun t))) p =\n  take (num_args (fun t)) p @ [p ! num_args (fun t)]\n\ngoal (1 subgoal):\n 1. take (num_args t) p = replicate (num_args t) dir.Left", "by (metis \\<open>num_args (fun t) < length p\\<close> replicate_Suc replicate_append_same)"], ["proof (state)\nthis:\n  take (num_args t) p = replicate (num_args t) dir.Left\n\ngoal (1 subgoal):\n 1. p ! num_args (fun t) \\<noteq> dir.Right \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  take (num_args t) p = replicate (num_args t) dir.Left", "show False"], ["proof (prove)\nusing this:\n  take (num_args t) p = replicate (num_args t) dir.Left\n\ngoal (1 subgoal):\n 1. False", "by (metis \\<open>num_args t = num_args s\\<close> \\<open>num_args t = num_args s\\<close> \\<open>position_of t (p @ [d])\\<close> \n              append.assoc append_eq_Cons_conv append_take_drop_id no_position_replicate_num_args shallower_pos)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p ! num_args (fun t) = dir.Right\n\ngoal (2 subgoals):\n 1. take (num_args (fun t)) p = q \\<Longrightarrow>\n    chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\n 2. take (num_args (fun t)) p \\<noteq> q \\<Longrightarrow>\n    chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "then"], ["proof (chain)\npicking this:\n  p ! num_args (fun t) = dir.Right", "obtain q' where \"p = q @ [Right] @ q'\""], ["proof (prove)\nusing this:\n  p ! num_args (fun t) = dir.Right\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        p = q @ [dir.Right] @ q' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Cons_nth_drop_Suc True \\<open>num_args (fun t) < length p\\<close> append_Cons append_Nil append_eq_conv_conj length_replicate q_rep_t)"], ["proof (state)\nthis:\n  p = q @ [dir.Right] @ q'\n\ngoal (2 subgoals):\n 1. take (num_args (fun t)) p = q \\<Longrightarrow>\n    chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\n 2. take (num_args (fun t)) p \\<noteq> q \\<Longrightarrow>\n    chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "have \"emb_step_at (q @ q') d (chop t) = chop s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emb_step_at (q @ q') d (chop t) = chop s", "unfolding chop_emb_step_at[OF \\<open>is_App t\\<close>] chop_emb_step_at[OF \\<open>is_App s\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. emb_step_at (q @ q') d\n     (emb_step_at (replicate (num_args (fun t)) dir.Left) dir.Right t) =\n    emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right s", "using swap_nested_emb_step_at[of q q' d Right t, unfolded] \\<open>emb_step_at p d t = s\\<close> \\<open>p = q @ [Right] @ q'\\<close> \n        q_rep_t q_rep_s"], ["proof (prove)\nusing this:\n  emb_step_at (q @ q') d (emb_step_at q dir.Right t) =\n  emb_step_at q dir.Right (emb_step_at (q @ [dir.Right] @ q') d t)\n  emb_step_at p d t = s\n  p = q @ [dir.Right] @ q'\n  q = replicate (num_args (fun t)) dir.Left\n  q = replicate (num_args (fun s)) dir.Left\n\ngoal (1 subgoal):\n 1. emb_step_at (q @ q') d\n     (emb_step_at (replicate (num_args (fun t)) dir.Left) dir.Right t) =\n    emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right s", "by auto"], ["proof (state)\nthis:\n  emb_step_at (q @ q') d (chop t) = chop s\n\ngoal (2 subgoals):\n 1. take (num_args (fun t)) p = q \\<Longrightarrow>\n    chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\n 2. take (num_args (fun t)) p \\<noteq> q \\<Longrightarrow>\n    chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "moreover"], ["proof (state)\nthis:\n  emb_step_at (q @ q') d (chop t) = chop s\n\ngoal (2 subgoals):\n 1. take (num_args (fun t)) p = q \\<Longrightarrow>\n    chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\n 2. take (num_args (fun t)) p \\<noteq> q \\<Longrightarrow>\n    chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "have \"chop t \\<noteq> chop s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chop t \\<noteq> chop s", "by (metis \\<open>is_App s\\<close> \\<open>is_App t\\<close> \\<open>t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\\<close> emb_step_hsize nat_less_le hsize_chop)"], ["proof (state)\nthis:\n  chop t \\<noteq> chop s\n\ngoal (2 subgoals):\n 1. take (num_args (fun t)) p = q \\<Longrightarrow>\n    chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\n 2. take (num_args (fun t)) p \\<noteq> q \\<Longrightarrow>\n    chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "ultimately"], ["proof (chain)\npicking this:\n  emb_step_at (q @ q') d (chop t) = chop s\n  chop t \\<noteq> chop s", "show \"chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\""], ["proof (prove)\nusing this:\n  emb_step_at (q @ q') d (chop t) = chop s\n  chop t \\<noteq> chop s\n\ngoal (1 subgoal):\n 1. chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "using emb_step_equiv"], ["proof (prove)\nusing this:\n  emb_step_at (q @ q') d (chop t) = chop s\n  chop t \\<noteq> chop s\n  (?t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b ?s) =\n  ((\\<exists>p d. emb_step_at p d ?t = ?s) \\<and> ?t \\<noteq> ?s)\n\ngoal (1 subgoal):\n 1. chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "by blast"], ["proof (state)\nthis:\n  chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\n\ngoal (1 subgoal):\n 1. take (num_args (fun t)) p \\<noteq> q \\<Longrightarrow>\n    chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. take (num_args (fun t)) p \\<noteq> q \\<Longrightarrow>\n    chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "case False"], ["proof (state)\nthis:\n  take (num_args (fun t)) p \\<noteq> q\n\ngoal (1 subgoal):\n 1. take (num_args (fun t)) p \\<noteq> q \\<Longrightarrow>\n    chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "then"], ["proof (chain)\npicking this:\n  take (num_args (fun t)) p \\<noteq> q", "have takepq: \"take (length q) p \\<noteq> q\""], ["proof (prove)\nusing this:\n  take (num_args (fun t)) p \\<noteq> q\n\ngoal (1 subgoal):\n 1. take (length q) p \\<noteq> q", "using q_rep_t"], ["proof (prove)\nusing this:\n  take (num_args (fun t)) p \\<noteq> q\n  q = replicate (num_args (fun t)) dir.Left\n\ngoal (1 subgoal):\n 1. take (length q) p \\<noteq> q", "by auto"], ["proof (state)\nthis:\n  take (length q) p \\<noteq> q\n\ngoal (1 subgoal):\n 1. take (num_args (fun t)) p \\<noteq> q \\<Longrightarrow>\n    chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "have takeqp: \"length p \\<le> length q \\<Longrightarrow> take (length p) q \\<noteq> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length p \\<le> length q \\<Longrightarrow> take (length p) q \\<noteq> p", "using \\<open>\\<not> list_all (\\<lambda>x. x = Left) p\\<close>[unfolded list_all_length]"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>n<length p. p ! n = dir.Left)\n\ngoal (1 subgoal):\n 1. length p \\<le> length q \\<Longrightarrow> take (length p) q \\<noteq> p", "using diff_diff_cancel take_replicate length_replicate  nth_replicate q_rep_s"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>n<length p. p ! n = dir.Left)\n  ?i \\<le> ?n \\<Longrightarrow> ?n - (?n - ?i) = ?i\n  take ?i (replicate ?k ?x) = replicate (min ?i ?k) ?x\n  length (replicate ?n ?x) = ?n\n  ?i < ?n \\<Longrightarrow> replicate ?n ?x ! ?i = ?x\n  q = replicate (num_args (fun s)) dir.Left\n\ngoal (1 subgoal):\n 1. length p \\<le> length q \\<Longrightarrow> take (length p) q \\<noteq> p", "by metis"], ["proof (state)\nthis:\n  length p \\<le> length q \\<Longrightarrow> take (length p) q \\<noteq> p\n\ngoal (1 subgoal):\n 1. take (num_args (fun t)) p \\<noteq> q \\<Longrightarrow>\n    chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "have \"chop s = emb_step_at p d (chop t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chop s = emb_step_at p d (chop t)", "using swap_disjunct_emb_step_at[of p q Right d t, OF takeqp takepq, unfolded \\<open>emb_step_at p d t = s\\<close>]"], ["proof (prove)\nusing this:\n  (length p \\<le> length q \\<Longrightarrow>\n   length p \\<le> length q) \\<Longrightarrow>\n  emb_step_at q dir.Right s = emb_step_at p d (emb_step_at q dir.Right t)\n\ngoal (1 subgoal):\n 1. chop s = emb_step_at p d (chop t)", "using \\<open>is_App s\\<close> \\<open>is_App t\\<close> chop_emb_step_at q_rep_s q_rep_t"], ["proof (prove)\nusing this:\n  (length p \\<le> length q \\<Longrightarrow>\n   length p \\<le> length q) \\<Longrightarrow>\n  emb_step_at q dir.Right s = emb_step_at p d (emb_step_at q dir.Right t)\n  is_App s\n  is_App t\n  is_App ?t \\<Longrightarrow>\n  chop ?t =\n  emb_step_at (replicate (num_args (fun ?t)) dir.Left) dir.Right ?t\n  q = replicate (num_args (fun s)) dir.Left\n  q = replicate (num_args (fun t)) dir.Left\n\ngoal (1 subgoal):\n 1. chop s = emb_step_at p d (chop t)", "by (simp add: chop_emb_step_at)"], ["proof (state)\nthis:\n  chop s = emb_step_at p d (chop t)\n\ngoal (1 subgoal):\n 1. take (num_args (fun t)) p \\<noteq> q \\<Longrightarrow>\n    chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "then"], ["proof (chain)\npicking this:\n  chop s = emb_step_at p d (chop t)", "show ?thesis"], ["proof (prove)\nusing this:\n  chop s = emb_step_at p d (chop t)\n\ngoal (1 subgoal):\n 1. chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "by (metis False \\<open>is_App t\\<close> \\<open>position_of t (p @ [d])\\<close> chop_emb_step_at emb_step_at_if_position length_replicate nat_le_linear pos_emb_step_at_disjunct q_rep_t take_all takeqp)"], ["proof (state)\nthis:\n  chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\n\ngoal (1 subgoal):\n 1. \\<not> list_all (\\<lambda>x. x = dir.Left) p \\<Longrightarrow>\n    t >\\<^sub>t s", "then"], ["proof (chain)\npicking this:\n  chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s", "have gt1:\"chkchop_same (>\\<^sub>t) t s\""], ["proof (prove)\nusing this:\n  chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\n\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) t s", "proof (cases \"head t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s;\n        head t = Var x1\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) t s\n 2. \\<And>x2.\n       \\<lbrakk>chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s;\n        head t = Sym x2\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) t s", "case (Var _)"], ["proof (state)\nthis:\n  head t = Var x1_\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s;\n        head t = Var x1\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) t s\n 2. \\<And>x2.\n       \\<lbrakk>chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s;\n        head t = Sym x2\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) t s", "then"], ["proof (chain)\npicking this:\n  head t = Var x1_", "have \"chop t >\\<^sub>t chop s\""], ["proof (prove)\nusing this:\n  head t = Var x1_\n\ngoal (1 subgoal):\n 1. chop t >\\<^sub>t chop s", "using ih[of \"chop t\" \"chop s\"]"], ["proof (prove)\nusing this:\n  head t = Var x1_\n  \\<lbrakk>hsize (chop t) + hsize (chop s) < hsize t + hsize s;\n   chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\\<rbrakk>\n  \\<Longrightarrow> chop t >\\<^sub>t chop s\n\ngoal (1 subgoal):\n 1. chop t >\\<^sub>t chop s", "by (meson \\<open>chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\\<close> \\<open>is_App s\\<close> \\<open>is_App t\\<close> add_strict_mono hsize_chop_lt)"], ["proof (state)\nthis:\n  chop t >\\<^sub>t chop s\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s;\n        head t = Var x1\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) t s\n 2. \\<And>x2.\n       \\<lbrakk>chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s;\n        head t = Sym x2\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) t s", "then"], ["proof (chain)\npicking this:\n  chop t >\\<^sub>t chop s", "show ?thesis"], ["proof (prove)\nusing this:\n  chop t >\\<^sub>t chop s\n\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) t s", "unfolding chkchop_same_def"], ["proof (prove)\nusing this:\n  chop t >\\<^sub>t chop s\n\ngoal (1 subgoal):\n 1. if is_Var (head t) then is_Hd t \\<or> chkchop (>\\<^sub>t) (chop t) s\n    else chkchop (>\\<^sub>t) t s", "by (simp add: Var)"], ["proof (state)\nthis:\n  chkchop_same (>\\<^sub>t) t s\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s;\n        head t = Sym x2\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) t s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s;\n        head t = Sym x2\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) t s", "case (Sym _)"], ["proof (state)\nthis:\n  head t = Sym x2_\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s;\n        head t = Sym x2\\<rbrakk>\n       \\<Longrightarrow> chkchop_same (>\\<^sub>t) t s", "then"], ["proof (chain)\npicking this:\n  head t = Sym x2_", "show ?thesis"], ["proof (prove)\nusing this:\n  head t = Sym x2_\n\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) t s", "unfolding chkchop_same_def"], ["proof (prove)\nusing this:\n  head t = Sym x2_\n\ngoal (1 subgoal):\n 1. if is_Var (head t) then is_Hd t \\<or> chkchop (>\\<^sub>t) (chop t) s\n    else chkchop (>\\<^sub>t) t s", "using \\<open>chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\\<close> \n         \\<open>is_App t\\<close> add_Suc add_Suc_shift chkchop_def gt_trans ih \n         less_Suc_eq hsize_chop t_gt_chop_t"], ["proof (prove)\nusing this:\n  head t = Sym x2_\n  chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop s\n  is_App t\n  Suc ?m + ?n = Suc (?m + ?n)\n  Suc ?m + ?n = ?m + Suc ?n\n  chkchop ?gt ?t ?s = (is_Hd ?s \\<or> ?gt ?t (chop ?s))\n  \\<lbrakk>?u >\\<^sub>t ?t; ?t >\\<^sub>t ?s\\<rbrakk>\n  \\<Longrightarrow> ?u >\\<^sub>t ?s\n  \\<lbrakk>hsize ?tt + hsize ?ss < hsize t + hsize s;\n   ?tt \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b ?ss\\<rbrakk>\n  \\<Longrightarrow> ?tt >\\<^sub>t ?ss\n  (?m < Suc ?n) = (?m < ?n \\<or> ?m = ?n)\n  is_App ?t \\<Longrightarrow> Suc (hsize (chop ?t)) = hsize ?t\n  is_App ?t \\<Longrightarrow> ?t >\\<^sub>t chop ?t\n\ngoal (1 subgoal):\n 1. if is_Var (head t) then is_Hd t \\<or> chkchop (>\\<^sub>t) (chop t) s\n    else chkchop (>\\<^sub>t) t s", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  chkchop_same (>\\<^sub>t) t s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chkchop_same (>\\<^sub>t) t s\n\ngoal (1 subgoal):\n 1. \\<not> list_all (\\<lambda>x. x = dir.Left) p \\<Longrightarrow>\n    t >\\<^sub>t s", "have gt2:\"head t = head s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head t = head s", "by (metis emb_step_under_args_head False \\<open>emb_step_at p d t = s\\<close>)"], ["proof (state)\nthis:\n  head t = head s\n\ngoal (1 subgoal):\n 1. \\<not> list_all (\\<lambda>x. x = dir.Left) p \\<Longrightarrow>\n    t >\\<^sub>t s", "have gt3:\"\\<forall>f\\<in>local.ground_heads (head t). extf f (>\\<^sub>t) (args t) (args s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head t).\n       extf f (>\\<^sub>t) (args t) (args s)", "proof (rule ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> local.ground_heads (head t) \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args t) (args s)", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> local.ground_heads (head t) \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args t) (args s)", "assume \"f\\<in>local.ground_heads (head t)\""], ["proof (state)\nthis:\n  f \\<in> local.ground_heads (head t)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> local.ground_heads (head t) \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args t) (args s)", "obtain i where i_def:\n        \"i < num_args t\"\n        \"args t ! i \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b args (emb_step_at p d t) ! i\"\n        \"\\<And>j. j < num_args t \\<Longrightarrow> i \\<noteq> j \\<Longrightarrow> args t ! j = args (emb_step_at p d t) ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < num_args t;\n         args t ! i \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b\n         args (emb_step_at p d t) ! i;\n         \\<And>j.\n            \\<lbrakk>j < num_args t; i \\<noteq> j\\<rbrakk>\n            \\<Longrightarrow> args t ! j =\n                              args (emb_step_at p d t) ! j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using emb_step_under_args_emb_step[of p t d]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> list_all (\\<lambda>x. x = dir.Left) p;\n   position_of t (p @ [d]);\n   \\<And>i.\n      \\<lbrakk>i < num_args t;\n       args t ! i \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b\n       args (emb_step_at p d t) ! i;\n       \\<And>j.\n          \\<lbrakk>j < num_args t; i \\<noteq> j\\<rbrakk>\n          \\<Longrightarrow> args t ! j =\n                            args (emb_step_at p d t) ! j\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < num_args t;\n         args t ! i \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b\n         args (emb_step_at p d t) ! i;\n         \\<And>j.\n            \\<lbrakk>j < num_args t; i \\<noteq> j\\<rbrakk>\n            \\<Longrightarrow> args t ! j =\n                              args (emb_step_at p d t) ! j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using False \\<open>position_of t (p @ [d])\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> list_all (\\<lambda>x. x = dir.Left) p;\n   position_of t (p @ [d]);\n   \\<And>i.\n      \\<lbrakk>i < num_args t;\n       args t ! i \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b\n       args (emb_step_at p d t) ! i;\n       \\<And>j.\n          \\<lbrakk>j < num_args t; i \\<noteq> j\\<rbrakk>\n          \\<Longrightarrow> args t ! j =\n                            args (emb_step_at p d t) ! j\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<not> list_all (\\<lambda>x. x = dir.Left) p\n  position_of t (p @ [d])\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < num_args t;\n         args t ! i \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b\n         args (emb_step_at p d t) ! i;\n         \\<And>j.\n            \\<lbrakk>j < num_args t; i \\<noteq> j\\<rbrakk>\n            \\<Longrightarrow> args t ! j =\n                              args (emb_step_at p d t) ! j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i < num_args t\n  args t ! i \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b\n  args (emb_step_at p d t) ! i\n  \\<lbrakk>?j < num_args t; i \\<noteq> ?j\\<rbrakk>\n  \\<Longrightarrow> args t ! ?j = args (emb_step_at p d t) ! ?j\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> local.ground_heads (head t) \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args t) (args s)", "have compat_list1: \"args t ! i >\\<^sub>t args s ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. args t ! i >\\<^sub>t args s ! i", "by (metis \\<open>num_args t = num_args s\\<close> \\<open>emb_step_at p d t = s\\<close>  add_less_mono i_def(1) i_def(2) ih nth_mem hsize_in_args)"], ["proof (state)\nthis:\n  args t ! i >\\<^sub>t args s ! i\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> local.ground_heads (head t) \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args t) (args s)", "have compat_list2: \"args t ! i \\<noteq> args s ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. args t ! i \\<noteq> args s ! i", "using emb_step_equiv i_def(2) \\<open>emb_step_at p d t = s\\<close>"], ["proof (prove)\nusing this:\n  (?t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b ?s) =\n  ((\\<exists>p d. emb_step_at p d ?t = ?s) \\<and> ?t \\<noteq> ?s)\n  args t ! i \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b\n  args (emb_step_at p d t) ! i\n  emb_step_at p d t = s\n\ngoal (1 subgoal):\n 1. args t ! i \\<noteq> args s ! i", "by blast"], ["proof (state)\nthis:\n  args t ! i \\<noteq> args s ! i\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> local.ground_heads (head t) \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args t) (args s)", "have argst:\"args t = take i (args t) @ args t ! i # drop (Suc i) (args t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. args t = take i (args t) @ args t ! i # drop (Suc i) (args t)", "by (simp add: Cons_nth_drop_Suc i_def(1))"], ["proof (state)\nthis:\n  args t = take i (args t) @ args t ! i # drop (Suc i) (args t)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> local.ground_heads (head t) \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args t) (args s)", "have argss:\"args s = take i (args t) @ args (emb_step_at p d t) ! i # drop (Suc i) (args t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. args s =\n    take i (args t) @ args (emb_step_at p d t) ! i # drop (Suc i) (args t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. args s =\n    take i (args t) @ args (emb_step_at p d t) ! i # drop (Suc i) (args t)", "have \"take i (args t) = take i (args s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take i (args t) = take i (args s)", "apply (rule nth_take_lemma)"], ["proof (prove)\ngoal (3 subgoals):\n 1. i \\<le> num_args t\n 2. i \\<le> num_args s\n 3. \\<And>ia. ia < i \\<longrightarrow> args t ! ia = args s ! ia", "using \\<open>num_args t = num_args s\\<close> i_def(1) i_def(3)[unfolded \\<open>emb_step_at p d t = s\\<close>]"], ["proof (prove)\nusing this:\n  num_args t = num_args s\n  i < num_args t\n  \\<lbrakk>?j < num_args t; i \\<noteq> ?j\\<rbrakk>\n  \\<Longrightarrow> args t ! ?j = args s ! ?j\n\ngoal (3 subgoals):\n 1. i \\<le> num_args t\n 2. i \\<le> num_args s\n 3. \\<And>ia. ia < i \\<longrightarrow> args t ! ia = args s ! ia", "by auto"], ["proof (state)\nthis:\n  take i (args t) = take i (args s)\n\ngoal (1 subgoal):\n 1. args s =\n    take i (args t) @ args (emb_step_at p d t) ! i # drop (Suc i) (args t)", "moreover"], ["proof (state)\nthis:\n  take i (args t) = take i (args s)\n\ngoal (1 subgoal):\n 1. args s =\n    take i (args t) @ args (emb_step_at p d t) ! i # drop (Suc i) (args t)", "have \"drop (Suc i) (args t) = drop (Suc i) (args s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (Suc i) (args t) = drop (Suc i) (args s)", "apply (rule nth_drop_lemma)"], ["proof (prove)\ngoal (3 subgoals):\n 1. num_args t = num_args s\n 2. Suc i \\<le> num_args t\n 3. \\<And>ia.\n       ia < num_args t \\<longrightarrow>\n       Suc i \\<le> ia \\<longrightarrow> args t ! ia = args s ! ia", "apply (simp add: \\<open>num_args t = num_args s\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Suc i \\<le> num_args t\n 2. \\<And>ia.\n       ia < num_args t \\<longrightarrow>\n       Suc i \\<le> ia \\<longrightarrow> args t ! ia = args s ! ia", "apply (simp add: Suc_le_eq i_def(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < num_args t \\<longrightarrow>\n       Suc i \\<le> ia \\<longrightarrow> args t ! ia = args s ! ia", "using Suc_n_not_le_n \\<open>emb_step_at p d t = s\\<close> i_def(3)"], ["proof (prove)\nusing this:\n  \\<not> Suc ?n \\<le> ?n\n  emb_step_at p d t = s\n  \\<lbrakk>?j < num_args t; i \\<noteq> ?j\\<rbrakk>\n  \\<Longrightarrow> args t ! ?j = args (emb_step_at p d t) ! ?j\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < num_args t \\<longrightarrow>\n       Suc i \\<le> ia \\<longrightarrow> args t ! ia = args s ! ia", "by blast"], ["proof (state)\nthis:\n  drop (Suc i) (args t) = drop (Suc i) (args s)\n\ngoal (1 subgoal):\n 1. args s =\n    take i (args t) @ args (emb_step_at p d t) ! i # drop (Suc i) (args t)", "ultimately"], ["proof (chain)\npicking this:\n  take i (args t) = take i (args s)\n  drop (Suc i) (args t) = drop (Suc i) (args s)", "show ?thesis"], ["proof (prove)\nusing this:\n  take i (args t) = take i (args s)\n  drop (Suc i) (args t) = drop (Suc i) (args s)\n\ngoal (1 subgoal):\n 1. args s =\n    take i (args t) @ args (emb_step_at p d t) ! i # drop (Suc i) (args t)", "using \\<open>emb_step_at p d t = s\\<close> \\<open>num_args t = num_args s\\<close> i_def(1) id_take_nth_drop"], ["proof (prove)\nusing this:\n  take i (args t) = take i (args s)\n  drop (Suc i) (args t) = drop (Suc i) (args s)\n  emb_step_at p d t = s\n  num_args t = num_args s\n  i < num_args t\n  ?i < length ?xs \\<Longrightarrow>\n  ?xs = take ?i ?xs @ ?xs ! ?i # drop (Suc ?i) ?xs\n\ngoal (1 subgoal):\n 1. args s =\n    take i (args t) @ args (emb_step_at p d t) ! i # drop (Suc i) (args t)", "by auto"], ["proof (state)\nthis:\n  args s =\n  take i (args t) @ args (emb_step_at p d t) ! i # drop (Suc i) (args t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  args s =\n  take i (args t) @ args (emb_step_at p d t) ! i # drop (Suc i) (args t)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> local.ground_heads (head t) \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args t) (args s)", "show \"extf f (>\\<^sub>t) (args t) (args s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args t) (args s)", "using  extf_compat_list[of \"args t ! i\" \"args (emb_step_at p d t) ! i\" gt f \"take i (args t)\"  \"drop (Suc i) (args t)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>args t ! i \\<noteq> args (emb_step_at p d t) ! i;\n   args t ! i >\\<^sub>t args (emb_step_at p d t) ! i\\<rbrakk>\n  \\<Longrightarrow> extf f (>\\<^sub>t)\n                     (take i (args t) @ args t ! i # drop (Suc i) (args t))\n                     (take i (args t) @\n                      args (emb_step_at p d t) ! i # drop (Suc i) (args t))\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args t) (args s)", "using \\<open>emb_step_at p d t = s\\<close> argss argst compat_list1 compat_list2"], ["proof (prove)\nusing this:\n  \\<lbrakk>args t ! i \\<noteq> args (emb_step_at p d t) ! i;\n   args t ! i >\\<^sub>t args (emb_step_at p d t) ! i\\<rbrakk>\n  \\<Longrightarrow> extf f (>\\<^sub>t)\n                     (take i (args t) @ args t ! i # drop (Suc i) (args t))\n                     (take i (args t) @\n                      args (emb_step_at p d t) ! i # drop (Suc i) (args t))\n  emb_step_at p d t = s\n  args s =\n  take i (args t) @ args (emb_step_at p d t) ! i # drop (Suc i) (args t)\n  args t = take i (args t) @ args t ! i # drop (Suc i) (args t)\n  args t ! i >\\<^sub>t args s ! i\n  args t ! i \\<noteq> args s ! i\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args t) (args s)", "by force"], ["proof (state)\nthis:\n  extf f (>\\<^sub>t) (args t) (args s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n\ngoal (1 subgoal):\n 1. \\<not> list_all (\\<lambda>x. x = dir.Left) p \\<Longrightarrow>\n    t >\\<^sub>t s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. t >\\<^sub>t s", "using gt_same"], ["proof (prove)\nusing this:\n  \\<lbrakk>head ?t = head ?s; chkchop_same (>\\<^sub>t) ?t ?s;\n   \\<forall>f\\<in>local.ground_heads (head ?t).\n      extf f (>\\<^sub>t) (args ?t) (args ?s)\\<rbrakk>\n  \\<Longrightarrow> ?t >\\<^sub>t ?s\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s", "using gt1 gt2 gt3"], ["proof (prove)\nusing this:\n  \\<lbrakk>head ?t = head ?s; chkchop_same (>\\<^sub>t) ?t ?s;\n   \\<forall>f\\<in>local.ground_heads (head ?t).\n      extf f (>\\<^sub>t) (args ?t) (args ?s)\\<rbrakk>\n  \\<Longrightarrow> ?t >\\<^sub>t ?s\n  chkchop_same (>\\<^sub>t) t s\n  head t = head s\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s", "by blast"], ["proof (state)\nthis:\n  t >\\<^sub>t s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t >\\<^sub>t s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gt_embedding_property:\n  assumes \"t \\<unrhd>\\<^sub>e\\<^sub>m\\<^sub>b s\" \"t \\<noteq> s\"\n  shows \"t >\\<^sub>t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t >\\<^sub>t s", "using assms"], ["proof (prove)\nusing this:\n  t \\<unrhd>\\<^sub>e\\<^sub>m\\<^sub>b s\n  t \\<noteq> s\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s", "proof (induction)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t. t \\<noteq> t \\<Longrightarrow> t >\\<^sub>t t\n 2. \\<And>t u s.\n       \\<lbrakk>t \\<unrhd>\\<^sub>e\\<^sub>m\\<^sub>b u;\n        t \\<noteq> u \\<Longrightarrow> t >\\<^sub>t u;\n        u \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s; t \\<noteq> s\\<rbrakk>\n       \\<Longrightarrow> t >\\<^sub>t s", "case (refl t)"], ["proof (state)\nthis:\n  t \\<noteq> t\n\ngoal (2 subgoals):\n 1. \\<And>t. t \\<noteq> t \\<Longrightarrow> t >\\<^sub>t t\n 2. \\<And>t u s.\n       \\<lbrakk>t \\<unrhd>\\<^sub>e\\<^sub>m\\<^sub>b u;\n        t \\<noteq> u \\<Longrightarrow> t >\\<^sub>t u;\n        u \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s; t \\<noteq> s\\<rbrakk>\n       \\<Longrightarrow> t >\\<^sub>t s", "then"], ["proof (chain)\npicking this:\n  t \\<noteq> t", "show ?case"], ["proof (prove)\nusing this:\n  t \\<noteq> t\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t t", "by simp"], ["proof (state)\nthis:\n  t >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>t u s.\n       \\<lbrakk>t \\<unrhd>\\<^sub>e\\<^sub>m\\<^sub>b u;\n        t \\<noteq> u \\<Longrightarrow> t >\\<^sub>t u;\n        u \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s; t \\<noteq> s\\<rbrakk>\n       \\<Longrightarrow> t >\\<^sub>t s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t u s.\n       \\<lbrakk>t \\<unrhd>\\<^sub>e\\<^sub>m\\<^sub>b u;\n        t \\<noteq> u \\<Longrightarrow> t >\\<^sub>t u;\n        u \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s; t \\<noteq> s\\<rbrakk>\n       \\<Longrightarrow> t >\\<^sub>t s", "case (step t u s)"], ["proof (state)\nthis:\n  t \\<unrhd>\\<^sub>e\\<^sub>m\\<^sub>b u\n  u \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\n  t \\<noteq> u \\<Longrightarrow> t >\\<^sub>t u\n  t \\<noteq> s\n\ngoal (1 subgoal):\n 1. \\<And>t u s.\n       \\<lbrakk>t \\<unrhd>\\<^sub>e\\<^sub>m\\<^sub>b u;\n        t \\<noteq> u \\<Longrightarrow> t >\\<^sub>t u;\n        u \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s; t \\<noteq> s\\<rbrakk>\n       \\<Longrightarrow> t >\\<^sub>t s", "then"], ["proof (chain)\npicking this:\n  t \\<unrhd>\\<^sub>e\\<^sub>m\\<^sub>b u\n  u \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\n  t \\<noteq> u \\<Longrightarrow> t >\\<^sub>t u\n  t \\<noteq> s", "show ?case"], ["proof (prove)\nusing this:\n  t \\<unrhd>\\<^sub>e\\<^sub>m\\<^sub>b u\n  u \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\n  t \\<noteq> u \\<Longrightarrow> t >\\<^sub>t u\n  t \\<noteq> s\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s", "using gt_embedding_step_property gt_trans"], ["proof (prove)\nusing this:\n  t \\<unrhd>\\<^sub>e\\<^sub>m\\<^sub>b u\n  u \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\n  t \\<noteq> u \\<Longrightarrow> t >\\<^sub>t u\n  t \\<noteq> s\n  ?t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b ?s \\<Longrightarrow>\n  ?t >\\<^sub>t ?s\n  \\<lbrakk>?u >\\<^sub>t ?t; ?t >\\<^sub>t ?s\\<rbrakk>\n  \\<Longrightarrow> ?u >\\<^sub>t ?s\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s", "by blast"], ["proof (state)\nthis:\n  t >\\<^sub>t s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Subterm Property\\<close>"], ["", "theorem gt_proper_sub: \"proper_sub s t \\<Longrightarrow> t >\\<^sub>t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_sub s t \\<Longrightarrow> t >\\<^sub>t s", "using gt_embedding_property sub_emb"], ["proof (prove)\nusing this:\n  \\<lbrakk>?t \\<unrhd>\\<^sub>e\\<^sub>m\\<^sub>b ?s; ?t \\<noteq> ?s\\<rbrakk>\n  \\<Longrightarrow> ?t >\\<^sub>t ?s\n  sub ?s ?t \\<Longrightarrow> ?t \\<unrhd>\\<^sub>e\\<^sub>m\\<^sub>b ?s\n\ngoal (1 subgoal):\n 1. proper_sub s t \\<Longrightarrow> t >\\<^sub>t s", "by blast"], ["", "lemma\n  gt_emb_fun: \"App s t >\\<^sub>t s\" and\n  gt_emb_arg: \"App s t >\\<^sub>t t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. App s t >\\<^sub>t s &&& App s t >\\<^sub>t t", "by (simp_all add: gt_embedding_step_property left right)"], ["", "subsection \\<open>Compatibility with Contexts\\<close>"], ["", "lemma gt_fun_imp: \"fun t >\\<^sub>t s \\<Longrightarrow> t >\\<^sub>t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun t >\\<^sub>t s \\<Longrightarrow> t >\\<^sub>t s", "by (metis emb_step_fun gt_embedding_step_property gt_trans tm.disc(2) tm.exhaust_sel tm.sel(3))"], ["", "lemma gt_arg_imp: \"arg t >\\<^sub>t s \\<Longrightarrow> t >\\<^sub>t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg t >\\<^sub>t s \\<Longrightarrow> t >\\<^sub>t s", "by (metis emb_step_arg gt_embedding_step_property gt_trans tm.disc(2) tm.exhaust_sel tm.sel(5))"], ["", "lemma gt_compat_fun:\n  assumes \"t' >\\<^sub>t t\"\n  shows \"App s t' >\\<^sub>t App s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. App s t' >\\<^sub>t App s t", "using assms"], ["proof (prove)\nusing this:\n  t' >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. App s t' >\\<^sub>t App s t", "apply (simp only:atomize_imp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. t' >\\<^sub>t t \\<longrightarrow> App s t' >\\<^sub>t App s t", "proof (induction rule:measure_induct_rule[of \"\\<lambda>(t, s). hsize t + hsize s\" \"\\<lambda>(t, s). t' >\\<^sub>t t \\<longrightarrow> App s t' >\\<^sub>t App s t\" \"(t,s)\", \n  simplified prod.case],\n  simp only: split_paired_all prod.case atomize_imp[symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>hsize aa + hsize ba < hsize a + hsize b;\n                    t' >\\<^sub>t aa\\<rbrakk>\n                   \\<Longrightarrow> App ba t' >\\<^sub>t App ba aa;\n        t' >\\<^sub>t a\\<rbrakk>\n       \\<Longrightarrow> App b t' >\\<^sub>t App b a", "fix t s ::\"('s, 'v) tm\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>hsize aa + hsize ba < hsize a + hsize b;\n                    t' >\\<^sub>t aa\\<rbrakk>\n                   \\<Longrightarrow> App ba t' >\\<^sub>t App ba aa;\n        t' >\\<^sub>t a\\<rbrakk>\n       \\<Longrightarrow> App b t' >\\<^sub>t App b a", "assume ih:\"\\<And>ta sa. hsize ta + hsize sa < hsize t + hsize s \\<Longrightarrow> t' >\\<^sub>t ta \\<Longrightarrow> App sa t' >\\<^sub>t App sa ta\"\n  and t'_gt_t:\"t' >\\<^sub>t t\""], ["proof (state)\nthis:\n  \\<lbrakk>hsize ?ta + hsize ?sa < hsize t + hsize s;\n   t' >\\<^sub>t ?ta\\<rbrakk>\n  \\<Longrightarrow> App ?sa t' >\\<^sub>t App ?sa ?ta\n  t' >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>hsize aa + hsize ba < hsize a + hsize b;\n                    t' >\\<^sub>t aa\\<rbrakk>\n                   \\<Longrightarrow> App ba t' >\\<^sub>t App ba aa;\n        t' >\\<^sub>t a\\<rbrakk>\n       \\<Longrightarrow> App b t' >\\<^sub>t App b a", "have t'_ne_t: \"t' \\<noteq> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t' \\<noteq> t", "using gt_antisym t'_gt_t"], ["proof (prove)\nusing this:\n  ?t >\\<^sub>t ?s \\<Longrightarrow> \\<not> ?s >\\<^sub>t ?t\n  t' >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. t' \\<noteq> t", "by blast"], ["proof (state)\nthis:\n  t' \\<noteq> t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>hsize aa + hsize ba < hsize a + hsize b;\n                    t' >\\<^sub>t aa\\<rbrakk>\n                   \\<Longrightarrow> App ba t' >\\<^sub>t App ba aa;\n        t' >\\<^sub>t a\\<rbrakk>\n       \\<Longrightarrow> App b t' >\\<^sub>t App b a", "have extf_args_single: \"\\<forall>f \\<in> ground_heads (head s). extf f (>\\<^sub>t) (args s @ [t']) (args s @ [t])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head s).\n       extf f (>\\<^sub>t) (args s @ [t']) (args s @ [t])", "by (simp add: extf_compat_list t'_gt_t t'_ne_t)"], ["proof (state)\nthis:\n  \\<forall>f\\<in>local.ground_heads (head s).\n     extf f (>\\<^sub>t) (args s @ [t']) (args s @ [t])\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>hsize aa + hsize ba < hsize a + hsize b;\n                    t' >\\<^sub>t aa\\<rbrakk>\n                   \\<Longrightarrow> App ba t' >\\<^sub>t App ba aa;\n        t' >\\<^sub>t a\\<rbrakk>\n       \\<Longrightarrow> App b t' >\\<^sub>t App b a", "show  \"App s t' >\\<^sub>t App s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. App s t' >\\<^sub>t App s t", "proof (rule gt_same)"], ["proof (state)\ngoal (3 subgoals):\n 1. head (App s t') = head (App s t)\n 2. chkchop_same (>\\<^sub>t) (App s t') (App s t)\n 3. \\<forall>f\\<in>local.ground_heads (head (App s t')).\n       extf f (>\\<^sub>t) (args (App s t')) (args (App s t))", "show \"head (App s t') = head (App s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head (App s t') = head (App s t)", "by simp"], ["proof (state)\nthis:\n  head (App s t') = head (App s t)\n\ngoal (2 subgoals):\n 1. chkchop_same (>\\<^sub>t) (App s t') (App s t)\n 2. \\<forall>f\\<in>local.ground_heads (head (App s t')).\n       extf f (>\\<^sub>t) (args (App s t')) (args (App s t))", "show \"\\<forall>f\\<in>local.ground_heads (head (App s t')). extf f (>\\<^sub>t) (args (App s t')) (args (App s t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head (App s t')).\n       extf f (>\\<^sub>t) (args (App s t')) (args (App s t))", "by (simp add: extf_args_single)"], ["proof (state)\nthis:\n  \\<forall>f\\<in>local.ground_heads (head (App s t')).\n     extf f (>\\<^sub>t) (args (App s t')) (args (App s t))\n\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) (App s t') (App s t)", "have 0: \"chop (App s t') >\\<^sub>t chop (App s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chop (App s t') >\\<^sub>t chop (App s t)", "proof (cases s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       s = Hd x1 \\<Longrightarrow> chop (App s t') >\\<^sub>t chop (App s t)\n 2. \\<And>x21 x22.\n       s = App x21 x22 \\<Longrightarrow>\n       chop (App s t') >\\<^sub>t chop (App s t)", "case (Hd _)"], ["proof (state)\nthis:\n  s = Hd x1_\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       s = Hd x1 \\<Longrightarrow> chop (App s t') >\\<^sub>t chop (App s t)\n 2. \\<And>x21 x22.\n       s = App x21 x22 \\<Longrightarrow>\n       chop (App s t') >\\<^sub>t chop (App s t)", "then"], ["proof (chain)\npicking this:\n  s = Hd x1_", "show ?thesis"], ["proof (prove)\nusing this:\n  s = Hd x1_\n\ngoal (1 subgoal):\n 1. chop (App s t') >\\<^sub>t chop (App s t)", "using chop_App_Hd"], ["proof (prove)\nusing this:\n  s = Hd x1_\n  is_Hd ?s \\<Longrightarrow> chop (App ?s ?t) = ?t\n\ngoal (1 subgoal):\n 1. chop (App s t') >\\<^sub>t chop (App s t)", "by (simp add: chop_App_Hd t'_gt_t)"], ["proof (state)\nthis:\n  chop (App s t') >\\<^sub>t chop (App s t)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = App x21 x22 \\<Longrightarrow>\n       chop (App s t') >\\<^sub>t chop (App s t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = App x21 x22 \\<Longrightarrow>\n       chop (App s t') >\\<^sub>t chop (App s t)", "case (App s1 s2)"], ["proof (state)\nthis:\n  s = App s1 s2\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = App x21 x22 \\<Longrightarrow>\n       chop (App s t') >\\<^sub>t chop (App s t)", "then"], ["proof (chain)\npicking this:\n  s = App s1 s2", "show ?thesis"], ["proof (prove)\nusing this:\n  s = App s1 s2\n\ngoal (1 subgoal):\n 1. chop (App s t') >\\<^sub>t chop (App s t)", "using ih[of t \"chop s\"] chop_fun"], ["proof (prove)\nusing this:\n  s = App s1 s2\n  \\<lbrakk>hsize t + hsize (chop s) < hsize t + hsize s;\n   t' >\\<^sub>t t\\<rbrakk>\n  \\<Longrightarrow> App (chop s) t' >\\<^sub>t App (chop s) t\n  \\<lbrakk>is_App ?t; is_App (fun ?t)\\<rbrakk>\n  \\<Longrightarrow> App (chop (fun ?t)) (arg ?t) = chop ?t\n\ngoal (1 subgoal):\n 1. chop (App s t') >\\<^sub>t chop (App s t)", "by (metis nat_add_left_cancel_less hsize_chop_lt t'_gt_t tm.disc(2) tm.sel(4) tm.sel(6))"], ["proof (state)\nthis:\n  chop (App s t') >\\<^sub>t chop (App s t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chop (App s t') >\\<^sub>t chop (App s t)\n\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) (App s t') (App s t)", "show \"chkchop_same (>\\<^sub>t) (App s t') (App s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) (App s t') (App s t)", "proof (cases \"is_Var (head (App s t'))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_Var (head (App s t')) \\<Longrightarrow>\n    chkchop_same (>\\<^sub>t) (App s t') (App s t)\n 2. is_Sym (head (App s t')) \\<Longrightarrow>\n    chkchop_same (>\\<^sub>t) (App s t') (App s t)", "case True"], ["proof (state)\nthis:\n  is_Var (head (App s t'))\n\ngoal (2 subgoals):\n 1. is_Var (head (App s t')) \\<Longrightarrow>\n    chkchop_same (>\\<^sub>t) (App s t') (App s t)\n 2. is_Sym (head (App s t')) \\<Longrightarrow>\n    chkchop_same (>\\<^sub>t) (App s t') (App s t)", "then"], ["proof (chain)\npicking this:\n  is_Var (head (App s t'))", "show ?thesis"], ["proof (prove)\nusing this:\n  is_Var (head (App s t'))\n\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) (App s t') (App s t)", "unfolding chkchop_same_def chkchop_def"], ["proof (prove)\nusing this:\n  is_Var (head (App s t'))\n\ngoal (1 subgoal):\n 1. if is_Var (head (App s t'))\n    then is_Hd (App s t') \\<or>\n         is_Hd (App s t) \\<or> chop (App s t') >\\<^sub>t chop (App s t)\n    else is_Hd (App s t) \\<or> App s t' >\\<^sub>t chop (App s t)", "using True 0"], ["proof (prove)\nusing this:\n  is_Var (head (App s t'))\n  is_Var (head (App s t'))\n  chop (App s t') >\\<^sub>t chop (App s t)\n\ngoal (1 subgoal):\n 1. if is_Var (head (App s t'))\n    then is_Hd (App s t') \\<or>\n         is_Hd (App s t) \\<or> chop (App s t') >\\<^sub>t chop (App s t)\n    else is_Hd (App s t) \\<or> App s t' >\\<^sub>t chop (App s t)", "by auto"], ["proof (state)\nthis:\n  chkchop_same (>\\<^sub>t) (App s t') (App s t)\n\ngoal (1 subgoal):\n 1. is_Sym (head (App s t')) \\<Longrightarrow>\n    chkchop_same (>\\<^sub>t) (App s t') (App s t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. is_Sym (head (App s t')) \\<Longrightarrow>\n    chkchop_same (>\\<^sub>t) (App s t') (App s t)", "case False"], ["proof (state)\nthis:\n  is_Sym (head (App s t'))\n\ngoal (1 subgoal):\n 1. is_Sym (head (App s t')) \\<Longrightarrow>\n    chkchop_same (>\\<^sub>t) (App s t') (App s t)", "have \"App s t' >\\<^sub>t chop (App s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. App s t' >\\<^sub>t chop (App s t)", "using 0"], ["proof (prove)\nusing this:\n  chop (App s t') >\\<^sub>t chop (App s t)\n\ngoal (1 subgoal):\n 1. App s t' >\\<^sub>t chop (App s t)", "by (simp add: gt_chop)"], ["proof (state)\nthis:\n  App s t' >\\<^sub>t chop (App s t)\n\ngoal (1 subgoal):\n 1. is_Sym (head (App s t')) \\<Longrightarrow>\n    chkchop_same (>\\<^sub>t) (App s t') (App s t)", "then"], ["proof (chain)\npicking this:\n  App s t' >\\<^sub>t chop (App s t)", "show ?thesis"], ["proof (prove)\nusing this:\n  App s t' >\\<^sub>t chop (App s t)\n\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) (App s t') (App s t)", "unfolding chkchop_same_def chkchop_def"], ["proof (prove)\nusing this:\n  App s t' >\\<^sub>t chop (App s t)\n\ngoal (1 subgoal):\n 1. if is_Var (head (App s t'))\n    then is_Hd (App s t') \\<or>\n         is_Hd (App s t) \\<or> chop (App s t') >\\<^sub>t chop (App s t)\n    else is_Hd (App s t) \\<or> App s t' >\\<^sub>t chop (App s t)", "using False"], ["proof (prove)\nusing this:\n  App s t' >\\<^sub>t chop (App s t)\n  is_Sym (head (App s t'))\n\ngoal (1 subgoal):\n 1. if is_Var (head (App s t'))\n    then is_Hd (App s t') \\<or>\n         is_Hd (App s t) \\<or> chop (App s t') >\\<^sub>t chop (App s t)\n    else is_Hd (App s t) \\<or> App s t' >\\<^sub>t chop (App s t)", "by auto"], ["proof (state)\nthis:\n  chkchop_same (>\\<^sub>t) (App s t') (App s t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chkchop_same (>\\<^sub>t) (App s t') (App s t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  App s t' >\\<^sub>t App s t\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem gt_compat_arg:\n  shows \"s' >\\<^sub>t s \\<Longrightarrow> t' \\<ge>\\<^sub>t t \\<Longrightarrow> App s' t' >\\<^sub>t App s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s' >\\<^sub>t s; t' \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "proof (simp only:atomize_imp,induction rule:measure_induct[of \"\\<lambda>(s',s,t). hsize s' + hsize s + hsize t\" \"\\<lambda>(s',s,t). s' >\\<^sub>t s \\<longrightarrow> t' \\<ge>\\<^sub>t t \\<longrightarrow> App s' t' >\\<^sub>t App s t\" \"(s',s,t)\", simplified prod.case],\n    simp only: split_paired_all prod.case atomize_imp[symmetric] atomize_all[symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>ab ac ba.\n                   \\<lbrakk>hsize ab + hsize ac + hsize ba\n                            < hsize a + hsize aa + hsize b;\n                    ab >\\<^sub>t ac; t' \\<ge>\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> App ab t' >\\<^sub>t App ac ba;\n        a >\\<^sub>t aa; t' \\<ge>\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> App a t' >\\<^sub>t App aa b", "fix s' s t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>ab ac ba.\n                   \\<lbrakk>hsize ab + hsize ac + hsize ba\n                            < hsize a + hsize aa + hsize b;\n                    ab >\\<^sub>t ac; t' \\<ge>\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> App ab t' >\\<^sub>t App ac ba;\n        a >\\<^sub>t aa; t' \\<ge>\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> App a t' >\\<^sub>t App aa b", "assume ih:\"\\<And>ab ac ba. hsize ab + hsize ac + hsize ba < hsize s' + hsize s + hsize t \\<Longrightarrow> ab >\\<^sub>t ac \\<Longrightarrow> t' \\<ge>\\<^sub>t ba \\<Longrightarrow> App ab t' >\\<^sub>t App ac ba\" \n    and \"s' >\\<^sub>t s\" and \"t' \\<ge>\\<^sub>t t\""], ["proof (state)\nthis:\n  \\<lbrakk>hsize ?ab + hsize ?ac + hsize ?ba < hsize s' + hsize s + hsize t;\n   ?ab >\\<^sub>t ?ac; t' \\<ge>\\<^sub>t ?ba\\<rbrakk>\n  \\<Longrightarrow> App ?ab t' >\\<^sub>t App ?ac ?ba\n  s' >\\<^sub>t s\n  t' \\<ge>\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>ab ac ba.\n                   \\<lbrakk>hsize ab + hsize ac + hsize ba\n                            < hsize a + hsize aa + hsize b;\n                    ab >\\<^sub>t ac; t' \\<ge>\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> App ab t' >\\<^sub>t App ac ba;\n        a >\\<^sub>t aa; t' \\<ge>\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> App a t' >\\<^sub>t App aa b", "{"], ["proof (state)\nthis:\n  \\<lbrakk>hsize ?ab + hsize ?ac + hsize ?ba < hsize s' + hsize s + hsize t;\n   ?ab >\\<^sub>t ?ac; t' \\<ge>\\<^sub>t ?ba\\<rbrakk>\n  \\<Longrightarrow> App ?ab t' >\\<^sub>t App ?ac ?ba\n  s' >\\<^sub>t s\n  t' \\<ge>\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>ab ac ba.\n                   \\<lbrakk>hsize ab + hsize ac + hsize ba\n                            < hsize a + hsize aa + hsize b;\n                    ab >\\<^sub>t ac; t' \\<ge>\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> App ab t' >\\<^sub>t App ac ba;\n        a >\\<^sub>t aa; t' \\<ge>\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> App a t' >\\<^sub>t App aa b", "fix s''::\"('s,'v) tm\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>ab ac ba.\n                   \\<lbrakk>hsize ab + hsize ac + hsize ba\n                            < hsize a + hsize aa + hsize b;\n                    ab >\\<^sub>t ac; t' \\<ge>\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> App ab t' >\\<^sub>t App ac ba;\n        a >\\<^sub>t aa; t' \\<ge>\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> App a t' >\\<^sub>t App aa b", "assume hsize_s'':\"hsize s'' \\<le> hsize s'\""], ["proof (state)\nthis:\n  hsize s'' \\<le> hsize s'\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>ab ac ba.\n                   \\<lbrakk>hsize ab + hsize ac + hsize ba\n                            < hsize a + hsize aa + hsize b;\n                    ab >\\<^sub>t ac; t' \\<ge>\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> App ab t' >\\<^sub>t App ac ba;\n        a >\\<^sub>t aa; t' \\<ge>\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> App a t' >\\<^sub>t App aa b", "assume chkchop_s'_s: \"chkchop (>\\<^sub>t) s'' s\""], ["proof (state)\nthis:\n  chkchop (>\\<^sub>t) s'' s\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>ab ac ba.\n                   \\<lbrakk>hsize ab + hsize ac + hsize ba\n                            < hsize a + hsize aa + hsize b;\n                    ab >\\<^sub>t ac; t' \\<ge>\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> App ab t' >\\<^sub>t App ac ba;\n        a >\\<^sub>t aa; t' \\<ge>\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> App a t' >\\<^sub>t App aa b", "then"], ["proof (chain)\npicking this:\n  chkchop (>\\<^sub>t) s'' s", "have \"chkchop (>\\<^sub>t) (App s'' t') (App s t)\""], ["proof (prove)\nusing this:\n  chkchop (>\\<^sub>t) s'' s\n\ngoal (1 subgoal):\n 1. chkchop (>\\<^sub>t) (App s'' t') (App s t)", "proof (cases \"is_Hd s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>chkchop (>\\<^sub>t) s'' s; is_Hd s\\<rbrakk>\n    \\<Longrightarrow> chkchop (>\\<^sub>t) (App s'' t') (App s t)\n 2. \\<lbrakk>chkchop (>\\<^sub>t) s'' s; is_App s\\<rbrakk>\n    \\<Longrightarrow> chkchop (>\\<^sub>t) (App s'' t') (App s t)", "case True"], ["proof (state)\nthis:\n  is_Hd s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>chkchop (>\\<^sub>t) s'' s; is_Hd s\\<rbrakk>\n    \\<Longrightarrow> chkchop (>\\<^sub>t) (App s'' t') (App s t)\n 2. \\<lbrakk>chkchop (>\\<^sub>t) s'' s; is_App s\\<rbrakk>\n    \\<Longrightarrow> chkchop (>\\<^sub>t) (App s'' t') (App s t)", "then"], ["proof (chain)\npicking this:\n  is_Hd s", "show ?thesis"], ["proof (prove)\nusing this:\n  is_Hd s\n\ngoal (1 subgoal):\n 1. chkchop (>\\<^sub>t) (App s'' t') (App s t)", "using chkchop_s'_s"], ["proof (prove)\nusing this:\n  is_Hd s\n  chkchop (>\\<^sub>t) s'' s\n\ngoal (1 subgoal):\n 1. chkchop (>\\<^sub>t) (App s'' t') (App s t)", "unfolding chkchop_def"], ["proof (prove)\nusing this:\n  is_Hd s\n  is_Hd s \\<or> s'' >\\<^sub>t chop s\n\ngoal (1 subgoal):\n 1. is_Hd (App s t) \\<or> App s'' t' >\\<^sub>t chop (App s t)", "by (metis \\<open>t' \\<ge>\\<^sub>t t\\<close> chop_App_Hd gt_arg_imp gt_emb_arg tm.sel(6))"], ["proof (state)\nthis:\n  chkchop (>\\<^sub>t) (App s'' t') (App s t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>chkchop (>\\<^sub>t) s'' s; is_App s\\<rbrakk>\n    \\<Longrightarrow> chkchop (>\\<^sub>t) (App s'' t') (App s t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>chkchop (>\\<^sub>t) s'' s; is_App s\\<rbrakk>\n    \\<Longrightarrow> chkchop (>\\<^sub>t) (App s'' t') (App s t)", "case False"], ["proof (state)\nthis:\n  is_App s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>chkchop (>\\<^sub>t) s'' s; is_App s\\<rbrakk>\n    \\<Longrightarrow> chkchop (>\\<^sub>t) (App s'' t') (App s t)", "then"], ["proof (chain)\npicking this:\n  is_App s", "show ?thesis"], ["proof (prove)\nusing this:\n  is_App s\n\ngoal (1 subgoal):\n 1. chkchop (>\\<^sub>t) (App s'' t') (App s t)", "using chkchop_s'_s"], ["proof (prove)\nusing this:\n  is_App s\n  chkchop (>\\<^sub>t) s'' s\n\ngoal (1 subgoal):\n 1. chkchop (>\\<^sub>t) (App s'' t') (App s t)", "unfolding chkchop_def"], ["proof (prove)\nusing this:\n  is_App s\n  is_Hd s \\<or> s'' >\\<^sub>t chop s\n\ngoal (1 subgoal):\n 1. is_Hd (App s t) \\<or> App s'' t' >\\<^sub>t chop (App s t)", "using ih[of s'' \"chop s\" t] hsize_s''"], ["proof (prove)\nusing this:\n  is_App s\n  is_Hd s \\<or> s'' >\\<^sub>t chop s\n  \\<lbrakk>hsize s'' + hsize (chop s) + hsize t\n           < hsize s' + hsize s + hsize t;\n   s'' >\\<^sub>t chop s; t' \\<ge>\\<^sub>t t\\<rbrakk>\n  \\<Longrightarrow> App s'' t' >\\<^sub>t App (chop s) t\n  hsize s'' \\<le> hsize s'\n\ngoal (1 subgoal):\n 1. is_Hd (App s t) \\<or> App s'' t' >\\<^sub>t chop (App s t)", "by (metis \\<open>t' \\<ge>\\<^sub>t t\\<close> add_less_mono add_mono_thms_linordered_field(1) chop_fun le_eq_less_or_eq nat_add_left_cancel_less hsize_chop_lt tm.sel(4) tm.sel(6))"], ["proof (state)\nthis:\n  chkchop (>\\<^sub>t) (App s'' t') (App s t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chkchop (>\\<^sub>t) (App s'' t') (App s t)\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>ab ac ba.\n                   \\<lbrakk>hsize ab + hsize ac + hsize ba\n                            < hsize a + hsize aa + hsize b;\n                    ab >\\<^sub>t ac; t' \\<ge>\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> App ab t' >\\<^sub>t App ac ba;\n        a >\\<^sub>t aa; t' \\<ge>\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> App a t' >\\<^sub>t App aa b", "}"], ["proof (state)\nthis:\n  \\<lbrakk>hsize ?s''2 \\<le> hsize s'; chkchop (>\\<^sub>t) ?s''2 s\\<rbrakk>\n  \\<Longrightarrow> chkchop (>\\<^sub>t) (App ?s''2 t') (App s t)\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>ab ac ba.\n                   \\<lbrakk>hsize ab + hsize ac + hsize ba\n                            < hsize a + hsize aa + hsize b;\n                    ab >\\<^sub>t ac; t' \\<ge>\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> App ab t' >\\<^sub>t App ac ba;\n        a >\\<^sub>t aa; t' \\<ge>\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> App a t' >\\<^sub>t App aa b", "note chkchop_compat_arg = this"], ["proof (state)\nthis:\n  \\<lbrakk>hsize ?s''2 \\<le> hsize s'; chkchop (>\\<^sub>t) ?s''2 s\\<rbrakk>\n  \\<Longrightarrow> chkchop (>\\<^sub>t) (App ?s''2 t') (App s t)\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>ab ac ba.\n                   \\<lbrakk>hsize ab + hsize ac + hsize ba\n                            < hsize a + hsize aa + hsize b;\n                    ab >\\<^sub>t ac; t' \\<ge>\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> App ab t' >\\<^sub>t App ac ba;\n        a >\\<^sub>t aa; t' \\<ge>\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> App a t' >\\<^sub>t App aa b", "show \"App s' t' >\\<^sub>t App s t \""], ["proof (prove)\ngoal (1 subgoal):\n 1. App s' t' >\\<^sub>t App s t", "using \\<open>s' >\\<^sub>t s\\<close>"], ["proof (prove)\nusing this:\n  s' >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. App s' t' >\\<^sub>t App s t", "proof (cases rule:gt.cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_App s'; chop s' \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t\n 2. \\<lbrakk>head s' >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) s' s\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t\n 3. \\<lbrakk>head s' = head s; chkchop_same (>\\<^sub>t) s' s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "case gt_chop"], ["proof (state)\nthis:\n  is_App s'\n  chop s' \\<ge>\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>is_App s'; chop s' \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t\n 2. \\<lbrakk>head s' >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) s' s\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t\n 3. \\<lbrakk>head s' = head s; chkchop_same (>\\<^sub>t) s' s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "then"], ["proof (chain)\npicking this:\n  is_App s'\n  chop s' \\<ge>\\<^sub>t s", "show ?thesis"], ["proof (prove)\nusing this:\n  is_App s'\n  chop s' \\<ge>\\<^sub>t s\n\ngoal (1 subgoal):\n 1. App s' t' >\\<^sub>t App s t", "proof (cases \"t = t'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_App s'; chop s' \\<ge>\\<^sub>t s; t = t'\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t\n 2. \\<lbrakk>is_App s'; chop s' \\<ge>\\<^sub>t s; t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "case True"], ["proof (state)\nthis:\n  t = t'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_App s'; chop s' \\<ge>\\<^sub>t s; t = t'\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t\n 2. \\<lbrakk>is_App s'; chop s' \\<ge>\\<^sub>t s; t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. App s' t' >\\<^sub>t App s t", "using True gt.gt_chop[of \"App s' t'\" \"App s t\"] gt_chop chkchop_compat_arg[of \"chop s'\"]"], ["proof (prove)\nusing this:\n  t = t'\n  \\<lbrakk>is_App (App s' t');\n   chop (App s' t') \\<ge>\\<^sub>t App s t\\<rbrakk>\n  \\<Longrightarrow> App s' t' >\\<^sub>t App s t\n  is_App s'\n  chop s' \\<ge>\\<^sub>t s\n  \\<lbrakk>hsize (chop s') \\<le> hsize s';\n   chkchop (>\\<^sub>t) (chop s') s\\<rbrakk>\n  \\<Longrightarrow> chkchop (>\\<^sub>t) (App (chop s') t') (App s t)\n\ngoal (1 subgoal):\n 1. App s' t' >\\<^sub>t App s t", "by (metis add_strict_right_mono chop_fun ih hsize_chop_lt tm.disc(2) tm.sel(4) tm.sel(6))"], ["proof (state)\nthis:\n  App s' t' >\\<^sub>t App s t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_App s'; chop s' \\<ge>\\<^sub>t s; t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_App s'; chop s' \\<ge>\\<^sub>t s; t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "case False"], ["proof (state)\nthis:\n  t \\<noteq> t'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_App s'; chop s' \\<ge>\\<^sub>t s; t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "then"], ["proof (chain)\npicking this:\n  t \\<noteq> t'", "have \"t' >\\<^sub>t t\""], ["proof (prove)\nusing this:\n  t \\<noteq> t'\n\ngoal (1 subgoal):\n 1. t' >\\<^sub>t t", "using \\<open>t' \\<ge>\\<^sub>t t\\<close>"], ["proof (prove)\nusing this:\n  t \\<noteq> t'\n  t' \\<ge>\\<^sub>t t\n\ngoal (1 subgoal):\n 1. t' >\\<^sub>t t", "by blast"], ["proof (state)\nthis:\n  t' >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_App s'; chop s' \\<ge>\\<^sub>t s; t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "have \"App s' t' >\\<^sub>t App (chop s') t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. App s' t' >\\<^sub>t App (chop s') t'", "by (simp add: context_left emb_step_chop gt_embedding_step_property local.gt_chop(1))"], ["proof (state)\nthis:\n  App s' t' >\\<^sub>t App (chop s') t'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_App s'; chop s' \\<ge>\\<^sub>t s; t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "moreover"], ["proof (state)\nthis:\n  App s' t' >\\<^sub>t App (chop s') t'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_App s'; chop s' \\<ge>\\<^sub>t s; t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "have \"... >\\<^sub>t App s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. App (chop s') t' >\\<^sub>t App s t", "using ih[of \"chop s'\" s t]"], ["proof (prove)\nusing this:\n  \\<lbrakk>hsize (chop s') + hsize s + hsize t\n           < hsize s' + hsize s + hsize t;\n   chop s' >\\<^sub>t s; t' \\<ge>\\<^sub>t t\\<rbrakk>\n  \\<Longrightarrow> App (chop s') t' >\\<^sub>t App s t\n\ngoal (1 subgoal):\n 1. App (chop s') t' >\\<^sub>t App s t", "using \\<open>t' >\\<^sub>t t\\<close> gt_compat_fun local.gt_chop(1) local.gt_chop(2) hsize_chop_lt"], ["proof (prove)\nusing this:\n  \\<lbrakk>hsize (chop s') + hsize s + hsize t\n           < hsize s' + hsize s + hsize t;\n   chop s' >\\<^sub>t s; t' \\<ge>\\<^sub>t t\\<rbrakk>\n  \\<Longrightarrow> App (chop s') t' >\\<^sub>t App s t\n  t' >\\<^sub>t t\n  ?t' >\\<^sub>t ?t \\<Longrightarrow> App ?s ?t' >\\<^sub>t App ?s ?t\n  is_App s'\n  chop s' \\<ge>\\<^sub>t s\n  is_App ?t \\<Longrightarrow> hsize (chop ?t) < hsize ?t\n\ngoal (1 subgoal):\n 1. App (chop s') t' >\\<^sub>t App s t", "by fastforce"], ["proof (state)\nthis:\n  App (chop s') t' >\\<^sub>t App s t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_App s'; chop s' \\<ge>\\<^sub>t s; t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "ultimately"], ["proof (chain)\npicking this:\n  App s' t' >\\<^sub>t App (chop s') t'\n  App (chop s') t' >\\<^sub>t App s t", "show ?thesis"], ["proof (prove)\nusing this:\n  App s' t' >\\<^sub>t App (chop s') t'\n  App (chop s') t' >\\<^sub>t App s t\n\ngoal (1 subgoal):\n 1. App s' t' >\\<^sub>t App s t", "using gt_trans"], ["proof (prove)\nusing this:\n  App s' t' >\\<^sub>t App (chop s') t'\n  App (chop s') t' >\\<^sub>t App s t\n  \\<lbrakk>?u >\\<^sub>t ?t; ?t >\\<^sub>t ?s\\<rbrakk>\n  \\<Longrightarrow> ?u >\\<^sub>t ?s\n\ngoal (1 subgoal):\n 1. App s' t' >\\<^sub>t App s t", "by blast"], ["proof (state)\nthis:\n  App s' t' >\\<^sub>t App s t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  App s' t' >\\<^sub>t App s t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>head s' >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) s' s\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t\n 2. \\<lbrakk>head s' = head s; chkchop_same (>\\<^sub>t) s' s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>head s' >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) s' s\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t\n 2. \\<lbrakk>head s' = head s; chkchop_same (>\\<^sub>t) s' s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "case gt_diff"], ["proof (state)\nthis:\n  head s' >\\<^sub>h\\<^sub>d head s\n  is_Sym (head s)\n  chkchop (>\\<^sub>t) s' s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>head s' >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) s' s\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t\n 2. \\<lbrakk>head s' = head s; chkchop_same (>\\<^sub>t) s' s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "then"], ["proof (chain)\npicking this:\n  head s' >\\<^sub>h\\<^sub>d head s\n  is_Sym (head s)\n  chkchop (>\\<^sub>t) s' s", "show ?thesis"], ["proof (prove)\nusing this:\n  head s' >\\<^sub>h\\<^sub>d head s\n  is_Sym (head s)\n  chkchop (>\\<^sub>t) s' s\n\ngoal (1 subgoal):\n 1. App s' t' >\\<^sub>t App s t", "using chkchop_compat_arg gt.gt_diff"], ["proof (prove)\nusing this:\n  head s' >\\<^sub>h\\<^sub>d head s\n  is_Sym (head s)\n  chkchop (>\\<^sub>t) s' s\n  \\<lbrakk>hsize ?s''2 \\<le> hsize s'; chkchop (>\\<^sub>t) ?s''2 s\\<rbrakk>\n  \\<Longrightarrow> chkchop (>\\<^sub>t) (App ?s''2 t') (App s t)\n  \\<lbrakk>head ?t >\\<^sub>h\\<^sub>d head ?s; is_Sym (head ?s);\n   chkchop (>\\<^sub>t) ?t ?s\\<rbrakk>\n  \\<Longrightarrow> ?t >\\<^sub>t ?s\n\ngoal (1 subgoal):\n 1. App s' t' >\\<^sub>t App s t", "by auto"], ["proof (state)\nthis:\n  App s' t' >\\<^sub>t App s t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head s' = head s; chkchop_same (>\\<^sub>t) s' s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>head s' = head s; chkchop_same (>\\<^sub>t) s' s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "case gt_same"], ["proof (state)\nthis:\n  head s' = head s\n  chkchop_same (>\\<^sub>t) s' s\n  \\<forall>f\\<in>local.ground_heads (head s').\n     extf f (>\\<^sub>t) (args s') (args s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head s' = head s; chkchop_same (>\\<^sub>t) s' s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "have hd_s'_eq_s: \"head s' = head s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head s' = head s", "by (simp add: local.gt_same(1))"], ["proof (state)\nthis:\n  head s' = head s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head s' = head s; chkchop_same (>\\<^sub>t) s' s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "{"], ["proof (state)\nthis:\n  head s' = head s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head s' = head s; chkchop_same (>\\<^sub>t) s' s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>head s' = head s; chkchop_same (>\\<^sub>t) s' s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "assume f_gh: \"f \\<in> ground_heads (head s)\""], ["proof (state)\nthis:\n  f \\<in> local.ground_heads (head s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head s' = head s; chkchop_same (>\\<^sub>t) s' s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "have f_s_args: \n        \"extf f (>\\<^sub>t) (args s') (args s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args s') (args s)", "using local.gt_same(3) f_gh"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>local.ground_heads (head s').\n     extf f (>\\<^sub>t) (args s') (args s)\n  f \\<in> local.ground_heads (head s)\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args s') (args s)", "by (simp add: hd_s'_eq_s)"], ["proof (state)\nthis:\n  extf f (>\\<^sub>t) (args s') (args s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head s' = head s; chkchop_same (>\\<^sub>t) s' s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "have f_compat_snoc: \n        \"\\<And>xs ys x. extf f (>\\<^sub>t) ys xs \\<Longrightarrow> extf f (>\\<^sub>t) (ys @ [x]) (xs @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys x.\n       extf f (>\\<^sub>t) ys xs \\<Longrightarrow>\n       extf f (>\\<^sub>t) (ys @ [x]) (xs @ [x])", "by (simp add: extf_compat_append_right)"], ["proof (state)\nthis:\n  extf f (>\\<^sub>t) ?ys ?xs \\<Longrightarrow>\n  extf f (>\\<^sub>t) (?ys @ [?x]) (?xs @ [?x])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head s' = head s; chkchop_same (>\\<^sub>t) s' s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "have f_st_args2:\n        \"extf f (>\\<^sub>t) (args (App s' t)) (args (App s t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args (App s' t)) (args (App s t))", "by (simp add: f_compat_snoc f_s_args)"], ["proof (state)\nthis:\n  extf f (>\\<^sub>t) (args (App s' t)) (args (App s t))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head s' = head s; chkchop_same (>\\<^sub>t) s' s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "have 0:\"\\<forall>z\\<in>UNIV. \\<forall>y\\<in>UNIV. \\<forall>x\\<in>UNIV. z >\\<^sub>t y \\<longrightarrow> y >\\<^sub>t x \\<longrightarrow> z >\\<^sub>t x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          \\<forall>x\\<in>UNIV.\n             z >\\<^sub>t y \\<longrightarrow>\n             y >\\<^sub>t x \\<longrightarrow> z >\\<^sub>t x", "using gt_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u >\\<^sub>t ?t; ?t >\\<^sub>t ?s\\<rbrakk>\n  \\<Longrightarrow> ?u >\\<^sub>t ?s\n\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          \\<forall>x\\<in>UNIV.\n             z >\\<^sub>t y \\<longrightarrow>\n             y >\\<^sub>t x \\<longrightarrow> z >\\<^sub>t x", "by blast"], ["proof (state)\nthis:\n  \\<forall>z\\<in>UNIV.\n     \\<forall>y\\<in>UNIV.\n        \\<forall>x\\<in>UNIV.\n           z >\\<^sub>t y \\<longrightarrow>\n           y >\\<^sub>t x \\<longrightarrow> z >\\<^sub>t x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head s' = head s; chkchop_same (>\\<^sub>t) s' s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "then"], ["proof (chain)\npicking this:\n  \\<forall>z\\<in>UNIV.\n     \\<forall>y\\<in>UNIV.\n        \\<forall>x\\<in>UNIV.\n           z >\\<^sub>t y \\<longrightarrow>\n           y >\\<^sub>t x \\<longrightarrow> z >\\<^sub>t x", "have f_trans:\"\\<And>xs ys zs. extf f (>\\<^sub>t) zs ys \\<Longrightarrow> extf f (>\\<^sub>t) ys xs \\<Longrightarrow> extf f (>\\<^sub>t) zs xs\""], ["proof (prove)\nusing this:\n  \\<forall>z\\<in>UNIV.\n     \\<forall>y\\<in>UNIV.\n        \\<forall>x\\<in>UNIV.\n           z >\\<^sub>t y \\<longrightarrow>\n           y >\\<^sub>t x \\<longrightarrow> z >\\<^sub>t x\n\ngoal (1 subgoal):\n 1. \\<And>xs ys zs.\n       \\<lbrakk>extf f (>\\<^sub>t) zs ys; extf f (>\\<^sub>t) ys xs\\<rbrakk>\n       \\<Longrightarrow> extf f (>\\<^sub>t) zs xs", "using  extf_trans[of _ UNIV, unfolded lists_UNIV, OF UNIV_I UNIV_I UNIV_I 0]"], ["proof (prove)\nusing this:\n  \\<forall>z\\<in>UNIV.\n     \\<forall>y\\<in>UNIV.\n        \\<forall>x\\<in>UNIV.\n           z >\\<^sub>t y \\<longrightarrow>\n           y >\\<^sub>t x \\<longrightarrow> z >\\<^sub>t x\n  \\<lbrakk>extf ?f (>\\<^sub>t) ?zs ?ys; extf ?f (>\\<^sub>t) ?ys ?xs\\<rbrakk>\n  \\<Longrightarrow> extf ?f (>\\<^sub>t) ?zs ?xs\n\ngoal (1 subgoal):\n 1. \\<And>xs ys zs.\n       \\<lbrakk>extf f (>\\<^sub>t) zs ys; extf f (>\\<^sub>t) ys xs\\<rbrakk>\n       \\<Longrightarrow> extf f (>\\<^sub>t) zs xs", "by metis"], ["proof (state)\nthis:\n  \\<lbrakk>extf f (>\\<^sub>t) ?zs ?ys; extf f (>\\<^sub>t) ?ys ?xs\\<rbrakk>\n  \\<Longrightarrow> extf f (>\\<^sub>t) ?zs ?xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head s' = head s; chkchop_same (>\\<^sub>t) s' s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "have \"extf f (>\\<^sub>t) (args (App s' t')) (args (App s t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args (App s' t')) (args (App s t))", "proof (cases \"t' = t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t' = t \\<Longrightarrow>\n    extf f (>\\<^sub>t) (args (App s' t')) (args (App s t))\n 2. t' \\<noteq> t \\<Longrightarrow>\n    extf f (>\\<^sub>t) (args (App s' t')) (args (App s t))", "case True"], ["proof (state)\nthis:\n  t' = t\n\ngoal (2 subgoals):\n 1. t' = t \\<Longrightarrow>\n    extf f (>\\<^sub>t) (args (App s' t')) (args (App s t))\n 2. t' \\<noteq> t \\<Longrightarrow>\n    extf f (>\\<^sub>t) (args (App s' t')) (args (App s t))", "then"], ["proof (chain)\npicking this:\n  t' = t", "show ?thesis"], ["proof (prove)\nusing this:\n  t' = t\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args (App s' t')) (args (App s t))", "using f_st_args2"], ["proof (prove)\nusing this:\n  t' = t\n  extf f (>\\<^sub>t) (args (App s' t)) (args (App s t))\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args (App s' t')) (args (App s t))", "by metis"], ["proof (state)\nthis:\n  extf f (>\\<^sub>t) (args (App s' t')) (args (App s t))\n\ngoal (1 subgoal):\n 1. t' \\<noteq> t \\<Longrightarrow>\n    extf f (>\\<^sub>t) (args (App s' t')) (args (App s t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t' \\<noteq> t \\<Longrightarrow>\n    extf f (>\\<^sub>t) (args (App s' t')) (args (App s t))", "case False"], ["proof (state)\nthis:\n  t' \\<noteq> t\n\ngoal (1 subgoal):\n 1. t' \\<noteq> t \\<Longrightarrow>\n    extf f (>\\<^sub>t) (args (App s' t')) (args (App s t))", "have f_st_args1: \n          \"extf f (>\\<^sub>t) (args (App s' t')) (args (App s' t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args (App s' t')) (args (App s' t))", "using extf_compat_list \\<open>t' \\<ge>\\<^sub>t t\\<close> False"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<noteq> ?x; ?gt ?y ?x\\<rbrakk>\n  \\<Longrightarrow> extf ?f ?gt (?xs @ ?y # ?xs') (?xs @ ?x # ?xs')\n  t' \\<ge>\\<^sub>t t\n  t' \\<noteq> t\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args (App s' t')) (args (App s' t))", "by simp"], ["proof (state)\nthis:\n  extf f (>\\<^sub>t) (args (App s' t')) (args (App s' t))\n\ngoal (1 subgoal):\n 1. t' \\<noteq> t \\<Longrightarrow>\n    extf f (>\\<^sub>t) (args (App s' t')) (args (App s t))", "then"], ["proof (chain)\npicking this:\n  extf f (>\\<^sub>t) (args (App s' t')) (args (App s' t))", "show ?thesis"], ["proof (prove)\nusing this:\n  extf f (>\\<^sub>t) (args (App s' t')) (args (App s' t))\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args (App s' t')) (args (App s t))", "using f_trans f_st_args1 f_st_args2"], ["proof (prove)\nusing this:\n  extf f (>\\<^sub>t) (args (App s' t')) (args (App s' t))\n  \\<lbrakk>extf f (>\\<^sub>t) ?zs ?ys; extf f (>\\<^sub>t) ?ys ?xs\\<rbrakk>\n  \\<Longrightarrow> extf f (>\\<^sub>t) ?zs ?xs\n  extf f (>\\<^sub>t) (args (App s' t')) (args (App s' t))\n  extf f (>\\<^sub>t) (args (App s' t)) (args (App s t))\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args (App s' t')) (args (App s t))", "by metis"], ["proof (state)\nthis:\n  extf f (>\\<^sub>t) (args (App s' t')) (args (App s t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  extf f (>\\<^sub>t) (args (App s' t')) (args (App s t))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head s' = head s; chkchop_same (>\\<^sub>t) s' s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "}"], ["proof (state)\nthis:\n  ?f2 \\<in> local.ground_heads (head s) \\<Longrightarrow>\n  extf ?f2 (>\\<^sub>t) (args (App s' t')) (args (App s t))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head s' = head s; chkchop_same (>\\<^sub>t) s' s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "note extf_cond = this"], ["proof (state)\nthis:\n  ?f2 \\<in> local.ground_heads (head s) \\<Longrightarrow>\n  extf ?f2 (>\\<^sub>t) (args (App s' t')) (args (App s t))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head s' = head s; chkchop_same (>\\<^sub>t) s' s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "have \"chkchop_same (>\\<^sub>t) (App s' t') (App s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) (App s' t') (App s t)", "unfolding chkchop_same_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. if is_Var (head (App s' t'))\n    then is_Hd (App s' t') \\<or>\n         chkchop (>\\<^sub>t) (chop (App s' t')) (App s t)\n    else chkchop (>\\<^sub>t) (App s' t') (App s t)", "using args.simps(1) chop_fun chkchop_compat_arg[of \"chop s'\", unfolded le_eq_less_or_eq] \n      chkchop_compat_arg[of s'] chkchop_def chkchop_same_def \n      hsize_chop_lt   epo.extf_min_empty[OF epo_axioms] gt.gt_same gt_antisym hd_s'_eq_s head_App \n      leI less_irrefl_nat local.gt_same(2) local.gt_same(3) tm.collapse(1) tm.sel(4) tm.sel(6)"], ["proof (prove)\nusing this:\n  args (Hd ?uu) = []\n  \\<lbrakk>is_App ?t; is_App (fun ?t)\\<rbrakk>\n  \\<Longrightarrow> App (chop (fun ?t)) (arg ?t) = chop ?t\n  \\<lbrakk>hsize (chop s') < hsize s' \\<or> hsize (chop s') = hsize s';\n   chkchop (>\\<^sub>t) (chop s') s\\<rbrakk>\n  \\<Longrightarrow> chkchop (>\\<^sub>t) (App (chop s') t') (App s t)\n  \\<lbrakk>hsize s' \\<le> hsize s'; chkchop (>\\<^sub>t) s' s\\<rbrakk>\n  \\<Longrightarrow> chkchop (>\\<^sub>t) (App s' t') (App s t)\n  chkchop ?gt ?t ?s = (is_Hd ?s \\<or> ?gt ?t (chop ?s))\n  chkchop_same ?gt ?t ?s =\n  (if is_Var (head ?t) then is_Hd ?t \\<or> chkchop ?gt (chop ?t) ?s\n   else chkchop ?gt ?t ?s)\n  is_App ?t \\<Longrightarrow> hsize (chop ?t) < hsize ?t\n  \\<not> extf ?f ?gt [] ?ss\n  \\<lbrakk>head ?t = head ?s; chkchop_same (>\\<^sub>t) ?t ?s;\n   \\<forall>f\\<in>local.ground_heads (head ?t).\n      extf f (>\\<^sub>t) (args ?t) (args ?s)\\<rbrakk>\n  \\<Longrightarrow> ?t >\\<^sub>t ?s\n  ?t >\\<^sub>t ?s \\<Longrightarrow> \\<not> ?s >\\<^sub>t ?t\n  head s' = head s\n  head (App ?s ?t) = head ?s\n  \\<not> ?x < ?y \\<Longrightarrow> ?y \\<le> ?x\n  ?n < ?n \\<Longrightarrow> ?R\n  chkchop_same (>\\<^sub>t) s' s\n  \\<forall>f\\<in>local.ground_heads (head s').\n     extf f (>\\<^sub>t) (args s') (args s)\n  is_Hd ?tm \\<Longrightarrow> Hd (head ?tm) = ?tm\n  fun (App ?x21.0 ?x22.0) = ?x21.0\n  arg (App ?x21.0 ?x22.0) = ?x22.0\n\ngoal (1 subgoal):\n 1. if is_Var (head (App s' t'))\n    then is_Hd (App s' t') \\<or>\n         chkchop (>\\<^sub>t) (chop (App s' t')) (App s t)\n    else chkchop (>\\<^sub>t) (App s' t') (App s t)", "by metis"], ["proof (state)\nthis:\n  chkchop_same (>\\<^sub>t) (App s' t') (App s t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head s' = head s; chkchop_same (>\\<^sub>t) s' s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "then"], ["proof (chain)\npicking this:\n  chkchop_same (>\\<^sub>t) (App s' t') (App s t)", "show ?thesis"], ["proof (prove)\nusing this:\n  chkchop_same (>\\<^sub>t) (App s' t') (App s t)\n\ngoal (1 subgoal):\n 1. App s' t' >\\<^sub>t App s t", "using extf_cond gt.gt_same hd_s'_eq_s"], ["proof (prove)\nusing this:\n  chkchop_same (>\\<^sub>t) (App s' t') (App s t)\n  ?f2 \\<in> local.ground_heads (head s) \\<Longrightarrow>\n  extf ?f2 (>\\<^sub>t) (args (App s' t')) (args (App s t))\n  \\<lbrakk>head ?t = head ?s; chkchop_same (>\\<^sub>t) ?t ?s;\n   \\<forall>f\\<in>local.ground_heads (head ?t).\n      extf f (>\\<^sub>t) (args ?t) (args ?s)\\<rbrakk>\n  \\<Longrightarrow> ?t >\\<^sub>t ?s\n  head s' = head s\n\ngoal (1 subgoal):\n 1. App s' t' >\\<^sub>t App s t", "by auto"], ["proof (state)\nthis:\n  App s' t' >\\<^sub>t App s t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  App s' t' >\\<^sub>t App s t\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem gt_compat_fun_strong:\n  assumes t'_gt_t: \"t' >\\<^sub>t t\"\n  shows \"apps s (t' # us) >\\<^sub>t apps s (t # us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apps s (t' # us) >\\<^sub>t apps s (t # us)", "proof (induct us rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. apps s [t'] >\\<^sub>t apps s [t]\n 2. \\<And>x xs.\n       apps s (t' # xs) >\\<^sub>t apps s (t # xs) \\<Longrightarrow>\n       apps s (t' # xs @ [x]) >\\<^sub>t apps s (t # xs @ [x])", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. apps s [t'] >\\<^sub>t apps s [t]\n 2. \\<And>x xs.\n       apps s (t' # xs) >\\<^sub>t apps s (t # xs) \\<Longrightarrow>\n       apps s (t' # xs @ [x]) >\\<^sub>t apps s (t # xs @ [x])", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. apps s [t'] >\\<^sub>t apps s [t]", "by (simp add: gt_compat_fun t'_gt_t)"], ["proof (state)\nthis:\n  apps s [t'] >\\<^sub>t apps s [t]\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       apps s (t' # xs) >\\<^sub>t apps s (t # xs) \\<Longrightarrow>\n       apps s (t' # xs @ [x]) >\\<^sub>t apps s (t # xs @ [x])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       apps s (t' # xs) >\\<^sub>t apps s (t # xs) \\<Longrightarrow>\n       apps s (t' # xs @ [x]) >\\<^sub>t apps s (t # xs @ [x])", "case (snoc x xs)"], ["proof (state)\nthis:\n  apps s (t' # xs) >\\<^sub>t apps s (t # xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       apps s (t' # xs) >\\<^sub>t apps s (t # xs) \\<Longrightarrow>\n       apps s (t' # xs @ [x]) >\\<^sub>t apps s (t # xs @ [x])", "then"], ["proof (chain)\npicking this:\n  apps s (t' # xs) >\\<^sub>t apps s (t # xs)", "show ?case"], ["proof (prove)\nusing this:\n  apps s (t' # xs) >\\<^sub>t apps s (t # xs)\n\ngoal (1 subgoal):\n 1. apps s (t' # xs @ [x]) >\\<^sub>t apps s (t # xs @ [x])", "unfolding App_apps[symmetric] append_Cons[symmetric]"], ["proof (prove)\nusing this:\n  apps s (t' # xs) >\\<^sub>t apps s (t # xs)\n\ngoal (1 subgoal):\n 1. App (apps s (t' # xs)) x >\\<^sub>t App (apps s (t # xs)) x", "using gt_compat_arg"], ["proof (prove)\nusing this:\n  apps s (t' # xs) >\\<^sub>t apps s (t # xs)\n  \\<lbrakk>?s' >\\<^sub>t ?s; ?t' \\<ge>\\<^sub>t ?t\\<rbrakk>\n  \\<Longrightarrow> App ?s' ?t' >\\<^sub>t App ?s ?t\n\ngoal (1 subgoal):\n 1. App (apps s (t' # xs)) x >\\<^sub>t App (apps s (t # xs)) x", "by blast"], ["proof (state)\nthis:\n  apps s (t' # xs @ [x]) >\\<^sub>t apps s (t # xs @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem gt_or_eq_compat_App: \"s' \\<ge>\\<^sub>t s \\<Longrightarrow> t' \\<ge>\\<^sub>t t \\<Longrightarrow> App s' t' \\<ge>\\<^sub>t App s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s' \\<ge>\\<^sub>t s; t' \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> App s' t' \\<ge>\\<^sub>t App s t", "using gt_compat_fun gt_compat_arg"], ["proof (prove)\nusing this:\n  ?t' >\\<^sub>t ?t \\<Longrightarrow> App ?s ?t' >\\<^sub>t App ?s ?t\n  \\<lbrakk>?s' >\\<^sub>t ?s; ?t' \\<ge>\\<^sub>t ?t\\<rbrakk>\n  \\<Longrightarrow> App ?s' ?t' >\\<^sub>t App ?s ?t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s' \\<ge>\\<^sub>t s; t' \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> App s' t' \\<ge>\\<^sub>t App s t", "by blast"], ["", "theorem gt_compat_App:\n  shows \"s' \\<ge>\\<^sub>t s \\<Longrightarrow> t' >\\<^sub>t t \\<Longrightarrow> App s' t' >\\<^sub>t App s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s' \\<ge>\\<^sub>t s; t' >\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "using gt_compat_fun gt_compat_arg"], ["proof (prove)\nusing this:\n  ?t' >\\<^sub>t ?t \\<Longrightarrow> App ?s ?t' >\\<^sub>t App ?s ?t\n  \\<lbrakk>?s' >\\<^sub>t ?s; ?t' \\<ge>\\<^sub>t ?t\\<rbrakk>\n  \\<Longrightarrow> App ?s' ?t' >\\<^sub>t App ?s ?t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s' \\<ge>\\<^sub>t s; t' >\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> App s' t' >\\<^sub>t App s t", "by blast"], ["", "subsection \"Stability under Substitutions\""], ["", "(* TODO: move *)"], ["", "lemma extf_map2:\n  assumes\n    \"\\<forall>y\\<in>set ys \\<union> set xs. \\<forall>x\\<in>set ys \\<union> set xs. y >\\<^sub>t x \\<longrightarrow> (h y) >\\<^sub>t (h x)\"\n    \"extf f (>\\<^sub>t) ys xs\"\n  shows\n    \"extf f (>\\<^sub>t) (map h ys) (map h xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (map h ys) (map h xs)", "apply (rule extf_map[of \"set ys \\<union> set xs\" ys xs \"(>\\<^sub>t)\" h f])"], ["proof (prove)\ngoal (7 subgoals):\n 1. finite (set ys \\<union> set xs)\n 2. ys \\<in> lists (set ys \\<union> set xs)\n 3. xs \\<in> lists (set ys \\<union> set xs)\n 4. \\<forall>x\\<in>set ys \\<union> set xs. \\<not> h x >\\<^sub>t h x\n 5. \\<forall>z\\<in>set ys \\<union> set xs.\n       \\<forall>y\\<in>set ys \\<union> set xs.\n          \\<forall>x\\<in>set ys \\<union> set xs.\n             h z >\\<^sub>t h y \\<longrightarrow>\n             h y >\\<^sub>t h x \\<longrightarrow> h z >\\<^sub>t h x\n 6. \\<forall>y\\<in>set ys \\<union> set xs.\n       \\<forall>x\\<in>set ys \\<union> set xs.\n          y >\\<^sub>t x \\<longrightarrow> h y >\\<^sub>t h x\n 7. extf f (>\\<^sub>t) ys xs", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. ys \\<in> lists (set ys \\<union> set xs)\n 2. xs \\<in> lists (set ys \\<union> set xs)\n 3. \\<forall>x\\<in>set ys \\<union> set xs. \\<not> h x >\\<^sub>t h x\n 4. \\<forall>z\\<in>set ys \\<union> set xs.\n       \\<forall>y\\<in>set ys \\<union> set xs.\n          \\<forall>x\\<in>set ys \\<union> set xs.\n             h z >\\<^sub>t h y \\<longrightarrow>\n             h y >\\<^sub>t h x \\<longrightarrow> h z >\\<^sub>t h x\n 5. \\<forall>y\\<in>set ys \\<union> set xs.\n       \\<forall>x\\<in>set ys \\<union> set xs.\n          y >\\<^sub>t x \\<longrightarrow> h y >\\<^sub>t h x\n 6. extf f (>\\<^sub>t) ys xs", "apply (simp add: in_listsI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. xs \\<in> lists (set ys \\<union> set xs)\n 2. \\<forall>x\\<in>set ys \\<union> set xs. \\<not> h x >\\<^sub>t h x\n 3. \\<forall>z\\<in>set ys \\<union> set xs.\n       \\<forall>y\\<in>set ys \\<union> set xs.\n          \\<forall>x\\<in>set ys \\<union> set xs.\n             h z >\\<^sub>t h y \\<longrightarrow>\n             h y >\\<^sub>t h x \\<longrightarrow> h z >\\<^sub>t h x\n 4. \\<forall>y\\<in>set ys \\<union> set xs.\n       \\<forall>x\\<in>set ys \\<union> set xs.\n          y >\\<^sub>t x \\<longrightarrow> h y >\\<^sub>t h x\n 5. extf f (>\\<^sub>t) ys xs", "apply (simp add: in_listsI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>x\\<in>set ys \\<union> set xs. \\<not> h x >\\<^sub>t h x\n 2. \\<forall>z\\<in>set ys \\<union> set xs.\n       \\<forall>y\\<in>set ys \\<union> set xs.\n          \\<forall>x\\<in>set ys \\<union> set xs.\n             h z >\\<^sub>t h y \\<longrightarrow>\n             h y >\\<^sub>t h x \\<longrightarrow> h z >\\<^sub>t h x\n 3. \\<forall>y\\<in>set ys \\<union> set xs.\n       \\<forall>x\\<in>set ys \\<union> set xs.\n          y >\\<^sub>t x \\<longrightarrow> h y >\\<^sub>t h x\n 4. extf f (>\\<^sub>t) ys xs", "using gt_antisym"], ["proof (prove)\nusing this:\n  ?t >\\<^sub>t ?s \\<Longrightarrow> \\<not> ?s >\\<^sub>t ?t\n\ngoal (4 subgoals):\n 1. \\<forall>x\\<in>set ys \\<union> set xs. \\<not> h x >\\<^sub>t h x\n 2. \\<forall>z\\<in>set ys \\<union> set xs.\n       \\<forall>y\\<in>set ys \\<union> set xs.\n          \\<forall>x\\<in>set ys \\<union> set xs.\n             h z >\\<^sub>t h y \\<longrightarrow>\n             h y >\\<^sub>t h x \\<longrightarrow> h z >\\<^sub>t h x\n 3. \\<forall>y\\<in>set ys \\<union> set xs.\n       \\<forall>x\\<in>set ys \\<union> set xs.\n          y >\\<^sub>t x \\<longrightarrow> h y >\\<^sub>t h x\n 4. extf f (>\\<^sub>t) ys xs", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>z\\<in>set ys \\<union> set xs.\n       \\<forall>y\\<in>set ys \\<union> set xs.\n          \\<forall>x\\<in>set ys \\<union> set xs.\n             h z >\\<^sub>t h y \\<longrightarrow>\n             h y >\\<^sub>t h x \\<longrightarrow> h z >\\<^sub>t h x\n 2. \\<forall>y\\<in>set ys \\<union> set xs.\n       \\<forall>x\\<in>set ys \\<union> set xs.\n          y >\\<^sub>t x \\<longrightarrow> h y >\\<^sub>t h x\n 3. extf f (>\\<^sub>t) ys xs", "using gt_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u >\\<^sub>t ?t; ?t >\\<^sub>t ?s\\<rbrakk>\n  \\<Longrightarrow> ?u >\\<^sub>t ?s\n\ngoal (3 subgoals):\n 1. \\<forall>z\\<in>set ys \\<union> set xs.\n       \\<forall>y\\<in>set ys \\<union> set xs.\n          \\<forall>x\\<in>set ys \\<union> set xs.\n             h z >\\<^sub>t h y \\<longrightarrow>\n             h y >\\<^sub>t h x \\<longrightarrow> h z >\\<^sub>t h x\n 2. \\<forall>y\\<in>set ys \\<union> set xs.\n       \\<forall>x\\<in>set ys \\<union> set xs.\n          y >\\<^sub>t x \\<longrightarrow> h y >\\<^sub>t h x\n 3. extf f (>\\<^sub>t) ys xs", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>y\\<in>set ys \\<union> set xs.\n       \\<forall>x\\<in>set ys \\<union> set xs.\n          y >\\<^sub>t x \\<longrightarrow> h y >\\<^sub>t h x\n 2. extf f (>\\<^sub>t) ys xs", "by (simp add: assms)+"], ["", "theorem gt_sus: \n  assumes \\<rho>_wary: \"wary_subst \\<rho>\"\n  assumes ghd: \"\\<And>x. ground_heads (Var x) = UNIV\" (* This condition is only needed for gt_same, not for gt_diff ! *)\n  shows \"t >\\<^sub>t s \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t >\\<^sub>t s \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "proof (simp only:atomize_imp,induction rule:measure_induct[of \"\\<lambda>(t,s). {# hsize t, hsize s #}\" \"\\<lambda>(t,s). t >\\<^sub>t s \\<longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\" \"(t,s)\", simplified prod.case],\n    simp only: split_paired_all prod.case atomize_imp[symmetric] atomize_all[symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    aa >\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> subst \\<rho> aa >\\<^sub>t\n                                     subst \\<rho> ba;\n        a >\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> subst \\<rho> a >\\<^sub>t subst \\<rho> b", "fix t s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    aa >\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> subst \\<rho> aa >\\<^sub>t\n                                     subst \\<rho> ba;\n        a >\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> subst \\<rho> a >\\<^sub>t subst \\<rho> b", "assume ih:\"\\<And>tt ss.\n               {# hsize tt, hsize ss #} < {# hsize t, hsize s #} \\<Longrightarrow>\n               tt >\\<^sub>t ss \\<Longrightarrow> subst \\<rho> tt >\\<^sub>t subst \\<rho> ss\" \n    and \"t >\\<^sub>t s\""], ["proof (state)\nthis:\n  \\<lbrakk>{#hsize ?tt, hsize ?ss#} < {#hsize t, hsize s#};\n   ?tt >\\<^sub>t ?ss\\<rbrakk>\n  \\<Longrightarrow> subst \\<rho> ?tt >\\<^sub>t subst \\<rho> ?ss\n  t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    aa >\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> subst \\<rho> aa >\\<^sub>t\n                                     subst \\<rho> ba;\n        a >\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> subst \\<rho> a >\\<^sub>t subst \\<rho> b", "show \"subst \\<rho> t >\\<^sub>t subst \\<rho> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<rho> t >\\<^sub>t subst \\<rho> s", "using \\<open>t >\\<^sub>t s\\<close>"], ["proof (prove)\nusing this:\n  t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. subst \\<rho> t >\\<^sub>t subst \\<rho> s", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_App t; chop t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<lbrakk>head t >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) t s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 3. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "case t_gt_s_chop: gt_chop"], ["proof (state)\nthis:\n  is_App t\n  chop t \\<ge>\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>is_App t; chop t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<lbrakk>head t >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) t s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 3. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "then"], ["proof (chain)\npicking this:\n  is_App t\n  chop t \\<ge>\\<^sub>t s", "show ?thesis"], ["proof (prove)\nusing this:\n  is_App t\n  chop t \\<ge>\\<^sub>t s\n\ngoal (1 subgoal):\n 1. subst \\<rho> t >\\<^sub>t subst \\<rho> s", "using emb_step_subst emb_step_chop[OF t_gt_s_chop(1)] gt_embedding_step_property \n       emb_step_hsize gt_trans ih[of \"chop t\" s]"], ["proof (prove)\nusing this:\n  is_App t\n  chop t \\<ge>\\<^sub>t s\n  ?t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b ?s \\<Longrightarrow>\n  subst ?\\<rho> ?t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b subst ?\\<rho> ?s\n  t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t\n  ?t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b ?s \\<Longrightarrow>\n  ?t >\\<^sub>t ?s\n  ?t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b ?s \\<Longrightarrow>\n  hsize ?s < hsize ?t\n  \\<lbrakk>?u >\\<^sub>t ?t; ?t >\\<^sub>t ?s\\<rbrakk>\n  \\<Longrightarrow> ?u >\\<^sub>t ?s\n  \\<lbrakk>{#hsize (chop t), hsize s#} < {#hsize t, hsize s#};\n   chop t >\\<^sub>t s\\<rbrakk>\n  \\<Longrightarrow> subst \\<rho> (chop t) >\\<^sub>t subst \\<rho> s\n\ngoal (1 subgoal):\n 1. subst \\<rho> t >\\<^sub>t subst \\<rho> s", "by (metis add_mset_lt_left_lt)"], ["proof (state)\nthis:\n  subst \\<rho> t >\\<^sub>t subst \\<rho> s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>head t >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) t s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>head t >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) t s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "case t_gt_s_diff: gt_diff"], ["proof (state)\nthis:\n  head t >\\<^sub>h\\<^sub>d head s\n  is_Sym (head s)\n  chkchop (>\\<^sub>t) t s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>head t >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) t s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "have gt_diff1: \"head (subst \\<rho> t) >\\<^sub>h\\<^sub>d head (subst \\<rho> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head (subst \\<rho> t) >\\<^sub>h\\<^sub>d head (subst \\<rho> s)", "by (meson assms gt_hd_def subsetCE t_gt_s_diff(1) wary_subst_ground_heads)"], ["proof (state)\nthis:\n  head (subst \\<rho> t) >\\<^sub>h\\<^sub>d head (subst \\<rho> s)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>head t >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) t s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "have gt_diff2: \"is_Sym (head (subst \\<rho> s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Sym (head (subst \\<rho> s))", "by (metis ground_imp_subst_iden hd.collapse(2) hd.simps(18) head_subst t_gt_s_diff(2) tm.sel(1) tm.simps(17))"], ["proof (state)\nthis:\n  is_Sym (head (subst \\<rho> s))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>head t >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) t s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "have gt_diff3: \"chkchop (>\\<^sub>t) (subst \\<rho> t) (subst \\<rho> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chkchop (>\\<^sub>t) (subst \\<rho> t) (subst \\<rho> s)", "proof (cases s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       s = Hd x1 \\<Longrightarrow>\n       chkchop (>\\<^sub>t) (subst \\<rho> t) (subst \\<rho> s)\n 2. \\<And>x21 x22.\n       s = App x21 x22 \\<Longrightarrow>\n       chkchop (>\\<^sub>t) (subst \\<rho> t) (subst \\<rho> s)", "case (Hd _)"], ["proof (state)\nthis:\n  s = Hd x1_\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       s = Hd x1 \\<Longrightarrow>\n       chkchop (>\\<^sub>t) (subst \\<rho> t) (subst \\<rho> s)\n 2. \\<And>x21 x22.\n       s = App x21 x22 \\<Longrightarrow>\n       chkchop (>\\<^sub>t) (subst \\<rho> t) (subst \\<rho> s)", "then"], ["proof (chain)\npicking this:\n  s = Hd x1_", "show ?thesis"], ["proof (prove)\nusing this:\n  s = Hd x1_\n\ngoal (1 subgoal):\n 1. chkchop (>\\<^sub>t) (subst \\<rho> t) (subst \\<rho> s)", "using t_gt_s_diff"], ["proof (prove)\nusing this:\n  s = Hd x1_\n  head t >\\<^sub>h\\<^sub>d head s\n  is_Sym (head s)\n  chkchop (>\\<^sub>t) t s\n\ngoal (1 subgoal):\n 1. chkchop (>\\<^sub>t) (subst \\<rho> t) (subst \\<rho> s)", "unfolding chkchop_def"], ["proof (prove)\nusing this:\n  s = Hd x1_\n  head t >\\<^sub>h\\<^sub>d head s\n  is_Sym (head s)\n  is_Hd s \\<or> t >\\<^sub>t chop s\n\ngoal (1 subgoal):\n 1. is_Hd (subst \\<rho> s) \\<or>\n    subst \\<rho> t >\\<^sub>t chop (subst \\<rho> s)", "by (metis ground_imp_subst_iden hd.collapse(2) hd.simps(18) tm.disc(1) tm.sel(1) tm.simps(17))"], ["proof (state)\nthis:\n  chkchop (>\\<^sub>t) (subst \\<rho> t) (subst \\<rho> s)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = App x21 x22 \\<Longrightarrow>\n       chkchop (>\\<^sub>t) (subst \\<rho> t) (subst \\<rho> s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = App x21 x22 \\<Longrightarrow>\n       chkchop (>\\<^sub>t) (subst \\<rho> t) (subst \\<rho> s)", "case s_App: (App s1 s2)"], ["proof (state)\nthis:\n  s = App s1 s2\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = App x21 x22 \\<Longrightarrow>\n       chkchop (>\\<^sub>t) (subst \\<rho> t) (subst \\<rho> s)", "then"], ["proof (chain)\npicking this:\n  s = App s1 s2", "show ?thesis"], ["proof (prove)\nusing this:\n  s = App s1 s2\n\ngoal (1 subgoal):\n 1. chkchop (>\\<^sub>t) (subst \\<rho> t) (subst \\<rho> s)", "using t_gt_s_diff"], ["proof (prove)\nusing this:\n  s = App s1 s2\n  head t >\\<^sub>h\\<^sub>d head s\n  is_Sym (head s)\n  chkchop (>\\<^sub>t) t s\n\ngoal (1 subgoal):\n 1. chkchop (>\\<^sub>t) (subst \\<rho> t) (subst \\<rho> s)", "unfolding chkchop_def"], ["proof (prove)\nusing this:\n  s = App s1 s2\n  head t >\\<^sub>h\\<^sub>d head s\n  is_Sym (head s)\n  is_Hd s \\<or> t >\\<^sub>t chop s\n\ngoal (1 subgoal):\n 1. is_Hd (subst \\<rho> s) \\<or>\n    subst \\<rho> t >\\<^sub>t chop (subst \\<rho> s)", "using ih[of t \"chop s\"] chop_subst_Sym hsize_chop_lt tm.disc(2)"], ["proof (prove)\nusing this:\n  s = App s1 s2\n  head t >\\<^sub>h\\<^sub>d head s\n  is_Sym (head s)\n  is_Hd s \\<or> t >\\<^sub>t chop s\n  \\<lbrakk>{#hsize t, hsize (chop s)#} < {#hsize t, hsize s#};\n   t >\\<^sub>t chop s\\<rbrakk>\n  \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> (chop s)\n  \\<lbrakk>is_App ?s; is_Sym (head ?s)\\<rbrakk>\n  \\<Longrightarrow> chop (subst ?\\<rho> ?s) = subst ?\\<rho> (chop ?s)\n  is_App ?t \\<Longrightarrow> hsize (chop ?t) < hsize ?t\n  is_App (App ?x21.0 ?x22.0)\n\ngoal (1 subgoal):\n 1. is_Hd (subst \\<rho> s) \\<or>\n    subst \\<rho> t >\\<^sub>t chop (subst \\<rho> s)", "by (metis add_mset_lt_left_lt add_mset_lt_right_lt)"], ["proof (state)\nthis:\n  chkchop (>\\<^sub>t) (subst \\<rho> t) (subst \\<rho> s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chkchop (>\\<^sub>t) (subst \\<rho> t) (subst \\<rho> s)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>head t >\\<^sub>h\\<^sub>d head s; is_Sym (head s);\n     chkchop (>\\<^sub>t) t s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<rho> t >\\<^sub>t subst \\<rho> s", "using gt_diff gt_diff1 gt_diff2 gt_diff3"], ["proof (prove)\nusing this:\n  \\<lbrakk>head ?t >\\<^sub>h\\<^sub>d head ?s; is_Sym (head ?s);\n   chkchop (>\\<^sub>t) ?t ?s\\<rbrakk>\n  \\<Longrightarrow> ?t >\\<^sub>t ?s\n  head (subst \\<rho> t) >\\<^sub>h\\<^sub>d head (subst \\<rho> s)\n  is_Sym (head (subst \\<rho> s))\n  chkchop (>\\<^sub>t) (subst \\<rho> t) (subst \\<rho> s)\n\ngoal (1 subgoal):\n 1. subst \\<rho> t >\\<^sub>t subst \\<rho> s", "by blast"], ["proof (state)\nthis:\n  subst \\<rho> t >\\<^sub>t subst \\<rho> s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "case t_gt_s_same: gt_same"], ["proof (state)\nthis:\n  head t = head s\n  chkchop_same (>\\<^sub>t) t s\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "have gt_same1: \"head (subst \\<rho> t) = head (subst \\<rho> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head (subst \\<rho> t) = head (subst \\<rho> s)", "by (simp add: t_gt_s_same(1))"], ["proof (state)\nthis:\n  head (subst \\<rho> t) = head (subst \\<rho> s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "have extf_map_ts:\"\\<forall>f\\<in>ground_heads (head t). extf f (>\\<^sub>t) (map (subst \\<rho>) (args t)) (map (subst \\<rho>) (args s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head t).\n       extf f (>\\<^sub>t) (map (subst \\<rho>) (args t))\n        (map (subst \\<rho>) (args s))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head t).\n       extf f (>\\<^sub>t) (map (subst \\<rho>) (args t))\n        (map (subst \\<rho>) (args s))", "have ih_args: \"\\<forall>y\\<in>set (args t) \\<union> set (args s). \\<forall>x\\<in>set (args t) \\<union> set (args s). y >\\<^sub>t x \\<longrightarrow> subst \\<rho> y >\\<^sub>t subst \\<rho> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set (args t) \\<union> set (args s).\n       \\<forall>x\\<in>set (args t) \\<union> set (args s).\n          y >\\<^sub>t x \\<longrightarrow>\n          subst \\<rho> y >\\<^sub>t subst \\<rho> x", "by (metis Un_iff less_multiset_doubletons hsize_in_args ih)"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set (args t) \\<union> set (args s).\n     \\<forall>x\\<in>set (args t) \\<union> set (args s).\n        y >\\<^sub>t x \\<longrightarrow>\n        subst \\<rho> y >\\<^sub>t subst \\<rho> x\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head t).\n       extf f (>\\<^sub>t) (map (subst \\<rho>) (args t))\n        (map (subst \\<rho>) (args s))", "have \"\\<forall>f\\<in>ground_heads (head t). extf f (>\\<^sub>t) (args t) (args s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head t).\n       extf f (>\\<^sub>t) (args t) (args s)", "using ghd t_gt_s_same(3)"], ["proof (prove)\nusing this:\n  local.ground_heads (Var ?x) = UNIV\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head t).\n       extf f (>\\<^sub>t) (args t) (args s)", "by metis"], ["proof (state)\nthis:\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head t).\n       extf f (>\\<^sub>t) (map (subst \\<rho>) (args t))\n        (map (subst \\<rho>) (args s))", "then"], ["proof (chain)\npicking this:\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head t).\n       extf f (>\\<^sub>t) (map (subst \\<rho>) (args t))\n        (map (subst \\<rho>) (args s))", "using extf_map[of \"set (args t) \\<union> set (args s)\" \"args t\" \"args s\" gt \"subst \\<rho>\"]"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n  \\<lbrakk>finite (set (args t) \\<union> set (args s));\n   args t \\<in> lists (set (args t) \\<union> set (args s));\n   args s \\<in> lists (set (args t) \\<union> set (args s));\n   \\<forall>x\\<in>set (args t) \\<union> set (args s).\n      \\<not> subst \\<rho> x >\\<^sub>t subst \\<rho> x;\n   \\<forall>z\\<in>set (args t) \\<union> set (args s).\n      \\<forall>y\\<in>set (args t) \\<union> set (args s).\n         \\<forall>x\\<in>set (args t) \\<union> set (args s).\n            subst \\<rho> z >\\<^sub>t subst \\<rho> y \\<longrightarrow>\n            subst \\<rho> y >\\<^sub>t subst \\<rho> x \\<longrightarrow>\n            subst \\<rho> z >\\<^sub>t subst \\<rho> x;\n   \\<forall>y\\<in>set (args t) \\<union> set (args s).\n      \\<forall>x\\<in>set (args t) \\<union> set (args s).\n         y >\\<^sub>t x \\<longrightarrow>\n         subst \\<rho> y >\\<^sub>t subst \\<rho> x;\n   extf ?fa (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n  \\<Longrightarrow> extf ?fa (>\\<^sub>t) (map (subst \\<rho>) (args t))\n                     (map (subst \\<rho>) (args s))\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head t).\n       extf f (>\\<^sub>t) (map (subst \\<rho>) (args t))\n        (map (subst \\<rho>) (args s))", "using gt_irrefl gt_trans ih_args"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n  \\<lbrakk>finite (set (args t) \\<union> set (args s));\n   args t \\<in> lists (set (args t) \\<union> set (args s));\n   args s \\<in> lists (set (args t) \\<union> set (args s));\n   \\<forall>x\\<in>set (args t) \\<union> set (args s).\n      \\<not> subst \\<rho> x >\\<^sub>t subst \\<rho> x;\n   \\<forall>z\\<in>set (args t) \\<union> set (args s).\n      \\<forall>y\\<in>set (args t) \\<union> set (args s).\n         \\<forall>x\\<in>set (args t) \\<union> set (args s).\n            subst \\<rho> z >\\<^sub>t subst \\<rho> y \\<longrightarrow>\n            subst \\<rho> y >\\<^sub>t subst \\<rho> x \\<longrightarrow>\n            subst \\<rho> z >\\<^sub>t subst \\<rho> x;\n   \\<forall>y\\<in>set (args t) \\<union> set (args s).\n      \\<forall>x\\<in>set (args t) \\<union> set (args s).\n         y >\\<^sub>t x \\<longrightarrow>\n         subst \\<rho> y >\\<^sub>t subst \\<rho> x;\n   extf ?fa (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n  \\<Longrightarrow> extf ?fa (>\\<^sub>t) (map (subst \\<rho>) (args t))\n                     (map (subst \\<rho>) (args s))\n  \\<not> ?s >\\<^sub>t ?s\n  \\<lbrakk>?u >\\<^sub>t ?t; ?t >\\<^sub>t ?s\\<rbrakk>\n  \\<Longrightarrow> ?u >\\<^sub>t ?s\n  \\<forall>y\\<in>set (args t) \\<union> set (args s).\n     \\<forall>x\\<in>set (args t) \\<union> set (args s).\n        y >\\<^sub>t x \\<longrightarrow>\n        subst \\<rho> y >\\<^sub>t subst \\<rho> x\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head t).\n       extf f (>\\<^sub>t) (map (subst \\<rho>) (args t))\n        (map (subst \\<rho>) (args s))", "by blast"], ["proof (state)\nthis:\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (map (subst \\<rho>) (args t))\n      (map (subst \\<rho>) (args s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (map (subst \\<rho>) (args t))\n      (map (subst \\<rho>) (args s))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>head t = head s; chkchop_same (>\\<^sub>t) t s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<rho> t >\\<^sub>t subst \\<rho> s", "proof (cases \"head t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       head t = Var x1 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<And>x2.\n       head t = Sym x2 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s", "case (Var x1)"], ["proof (state)\nthis:\n  head t = Var x1\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       head t = Var x1 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<And>x2.\n       head t = Sym x2 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s", "then"], ["proof (chain)\npicking this:\n  head t = Var x1", "have \"is_Var (head t)\""], ["proof (prove)\nusing this:\n  head t = Var x1\n\ngoal (1 subgoal):\n 1. is_Var (head t)", "by simp"], ["proof (state)\nthis:\n  is_Var (head t)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       head t = Var x1 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<And>x2.\n       head t = Sym x2 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s", "{"], ["proof (state)\nthis:\n  is_Var (head t)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       head t = Var x1 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<And>x2.\n       head t = Sym x2 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s", "fix u :: \"('s, 'v) tm\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       head t = Var x1 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<And>x2.\n       head t = Sym x2 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s", "assume \"ground_heads (head u) \\<subseteq> ground_heads (head t)\" \"hsize u \\<le> hsize (subst \\<rho> (Hd (head t)))\""], ["proof (state)\nthis:\n  local.ground_heads (head u) \\<subseteq> local.ground_heads (head t)\n  hsize u \\<le> hsize (subst \\<rho> (Hd (head t)))\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       head t = Var x1 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<And>x2.\n       head t = Sym x2 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s", "then"], ["proof (chain)\npicking this:\n  local.ground_heads (head u) \\<subseteq> local.ground_heads (head t)\n  hsize u \\<le> hsize (subst \\<rho> (Hd (head t)))", "have \"apps u (map (subst \\<rho>) (args t)) >\\<^sub>t apps u (map (subst \\<rho>) (args s))\""], ["proof (prove)\nusing this:\n  local.ground_heads (head u) \\<subseteq> local.ground_heads (head t)\n  hsize u \\<le> hsize (subst \\<rho> (Hd (head t)))\n\ngoal (1 subgoal):\n 1. apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n    apps u (map (subst \\<rho>) (args s))", "proof (induct \"hsize u\" arbitrary:u rule:less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>\\<And>ua.\n                   \\<lbrakk>hsize ua < hsize u;\n                    local.ground_heads (head ua)\n                    \\<subseteq> local.ground_heads (head t);\n                    hsize ua\n                    \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n                   \\<Longrightarrow> apps ua\n(map (subst \\<rho>) (args t)) >\\<^sub>t\n                                     apps ua (map (subst \\<rho>) (args s));\n        local.ground_heads (head u) \\<subseteq> local.ground_heads (head t);\n        hsize u \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "case less"], ["proof (state)\nthis:\n  \\<lbrakk>hsize ?u < hsize u;\n   local.ground_heads (head ?u) \\<subseteq> local.ground_heads (head t);\n   hsize ?u \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n  \\<Longrightarrow> apps ?u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                    apps ?u (map (subst \\<rho>) (args s))\n  local.ground_heads (head u) \\<subseteq> local.ground_heads (head t)\n  hsize u \\<le> hsize (subst \\<rho> (Hd (head t)))\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>\\<And>ua.\n                   \\<lbrakk>hsize ua < hsize u;\n                    local.ground_heads (head ua)\n                    \\<subseteq> local.ground_heads (head t);\n                    hsize ua\n                    \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n                   \\<Longrightarrow> apps ua\n(map (subst \\<rho>) (args t)) >\\<^sub>t\n                                     apps ua (map (subst \\<rho>) (args s));\n        local.ground_heads (head u) \\<subseteq> local.ground_heads (head t);\n        hsize u \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>hsize ?u < hsize u;\n   local.ground_heads (head ?u) \\<subseteq> local.ground_heads (head t);\n   hsize ?u \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n  \\<Longrightarrow> apps ?u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                    apps ?u (map (subst \\<rho>) (args s))\n  local.ground_heads (head u) \\<subseteq> local.ground_heads (head t)\n  hsize u \\<le> hsize (subst \\<rho> (Hd (head t)))", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>hsize ?u < hsize u;\n   local.ground_heads (head ?u) \\<subseteq> local.ground_heads (head t);\n   hsize ?u \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n  \\<Longrightarrow> apps ?u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                    apps ?u (map (subst \\<rho>) (args s))\n  local.ground_heads (head u) \\<subseteq> local.ground_heads (head t)\n  hsize u \\<le> hsize (subst \\<rho> (Hd (head t)))\n\ngoal (1 subgoal):\n 1. apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n    apps u (map (subst \\<rho>) (args s))", "proof (cases u)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>hsize u < hsize u;\n                    local.ground_heads (head u)\n                    \\<subseteq> local.ground_heads (head t);\n                    hsize u\n                    \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n                   \\<Longrightarrow> apps u\n(map (subst \\<rho>) (args t)) >\\<^sub>t\n                                     apps u (map (subst \\<rho>) (args s));\n        local.ground_heads (head u) \\<subseteq> local.ground_heads (head t);\n        hsize u \\<le> hsize (subst \\<rho> (Hd (head t))); u = Hd x1\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>hsize u < hsize u;\n                    local.ground_heads (head u)\n                    \\<subseteq> local.ground_heads (head t);\n                    hsize u\n                    \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n                   \\<Longrightarrow> apps u\n(map (subst \\<rho>) (args t)) >\\<^sub>t\n                                     apps u (map (subst \\<rho>) (args s));\n        local.ground_heads (head u) \\<subseteq> local.ground_heads (head t);\n        hsize u \\<le> hsize (subst \\<rho> (Hd (head t)));\n        u = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "case u_Hd: (Hd _)"], ["proof (state)\nthis:\n  u = Hd x1_\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>hsize u < hsize u;\n                    local.ground_heads (head u)\n                    \\<subseteq> local.ground_heads (head t);\n                    hsize u\n                    \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n                   \\<Longrightarrow> apps u\n(map (subst \\<rho>) (args t)) >\\<^sub>t\n                                     apps u (map (subst \\<rho>) (args s));\n        local.ground_heads (head u) \\<subseteq> local.ground_heads (head t);\n        hsize u \\<le> hsize (subst \\<rho> (Hd (head t))); u = Hd x1\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>hsize u < hsize u;\n                    local.ground_heads (head u)\n                    \\<subseteq> local.ground_heads (head t);\n                    hsize u\n                    \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n                   \\<Longrightarrow> apps u\n(map (subst \\<rho>) (args t)) >\\<^sub>t\n                                     apps u (map (subst \\<rho>) (args s));\n        local.ground_heads (head u) \\<subseteq> local.ground_heads (head t);\n        hsize u \\<le> hsize (subst \\<rho> (Hd (head t)));\n        u = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "then"], ["proof (chain)\npicking this:\n  u = Hd x1_", "have \"args u = []\""], ["proof (prove)\nusing this:\n  u = Hd x1_\n\ngoal (1 subgoal):\n 1. args u = []", "by simp"], ["proof (state)\nthis:\n  args u = []\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>hsize u < hsize u;\n                    local.ground_heads (head u)\n                    \\<subseteq> local.ground_heads (head t);\n                    hsize u\n                    \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n                   \\<Longrightarrow> apps u\n(map (subst \\<rho>) (args t)) >\\<^sub>t\n                                     apps u (map (subst \\<rho>) (args s));\n        local.ground_heads (head u) \\<subseteq> local.ground_heads (head t);\n        hsize u \\<le> hsize (subst \\<rho> (Hd (head t))); u = Hd x1\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>hsize u < hsize u;\n                    local.ground_heads (head u)\n                    \\<subseteq> local.ground_heads (head t);\n                    hsize u\n                    \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n                   \\<Longrightarrow> apps u\n(map (subst \\<rho>) (args t)) >\\<^sub>t\n                                     apps u (map (subst \\<rho>) (args s));\n        local.ground_heads (head u) \\<subseteq> local.ground_heads (head t);\n        hsize u \\<le> hsize (subst \\<rho> (Hd (head t)));\n        u = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "then"], ["proof (chain)\npicking this:\n  args u = []", "show ?thesis"], ["proof (prove)\nusing this:\n  args u = []\n\ngoal (1 subgoal):\n 1. apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n    apps u (map (subst \\<rho>) (args s))", "proof (cases s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>args u = []; s = Hd x1\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))\n 2. \\<And>x21 x22.\n       \\<lbrakk>args u = []; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "case s_Hd: (Hd _)"], ["proof (state)\nthis:\n  s = Hd x1_\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>args u = []; s = Hd x1\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))\n 2. \\<And>x21 x22.\n       \\<lbrakk>args u = []; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n    apps u (map (subst \\<rho>) (args s))", "apply (rule gt_same)"], ["proof (prove)\ngoal (3 subgoals):\n 1. head (apps u (map (subst \\<rho>) (args t))) =\n    head (apps u (map (subst \\<rho>) (args s)))\n 2. chkchop_same (>\\<^sub>t) (apps u (map (subst \\<rho>) (args t)))\n     (apps u (map (subst \\<rho>) (args s)))\n 3. \\<forall>f\\<in>local.ground_heads\n                    (head (apps u (map (subst \\<rho>) (args t)))).\n       extf f (>\\<^sub>t) (args (apps u (map (subst \\<rho>) (args t))))\n        (args (apps u (map (subst \\<rho>) (args s))))", "using extf_map_ts  args_Nil_iff_is_Hd s_Hd u_Hd \\<open>args u = []\\<close> less"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (map (subst \\<rho>) (args t))\n      (map (subst \\<rho>) (args s))\n  (args ?s = []) = is_Hd ?s\n  s = Hd x1_\n  u = Hd x1a___\n  args u = []\n  \\<lbrakk>hsize ?u < hsize u;\n   local.ground_heads (head ?u) \\<subseteq> local.ground_heads (head t);\n   hsize ?u \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n  \\<Longrightarrow> apps ?u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                    apps ?u (map (subst \\<rho>) (args s))\n  local.ground_heads (head u) \\<subseteq> local.ground_heads (head t)\n  hsize u \\<le> hsize (subst \\<rho> (Hd (head t)))\n\ngoal (3 subgoals):\n 1. head (apps u (map (subst \\<rho>) (args t))) =\n    head (apps u (map (subst \\<rho>) (args s)))\n 2. chkchop_same (>\\<^sub>t) (apps u (map (subst \\<rho>) (args t)))\n     (apps u (map (subst \\<rho>) (args s)))\n 3. \\<forall>f\\<in>local.ground_heads\n                    (head (apps u (map (subst \\<rho>) (args t)))).\n       extf f (>\\<^sub>t) (args (apps u (map (subst \\<rho>) (args t))))\n        (args (apps u (map (subst \\<rho>) (args s))))", "by fastforce+"], ["proof (state)\nthis:\n  apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n  apps u (map (subst \\<rho>) (args s))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>args u = []; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>args u = []; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "case s_App: (App _ _)"], ["proof (state)\nthis:\n  s = App x21_ x22_\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>args u = []; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "then"], ["proof (chain)\npicking this:\n  s = App x21_ x22_", "have \"is_App t\""], ["proof (prove)\nusing this:\n  s = App x21_ x22_\n\ngoal (1 subgoal):\n 1. is_App t", "by (metis args_Nil_iff_is_Hd extf_min_empty gt_hd_def gt_hd_irrefl t_gt_s_same(3))"], ["proof (state)\nthis:\n  is_App t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>args u = []; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "have \"chop t >\\<^sub>t chop s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chop t >\\<^sub>t chop s", "using \\<open>is_App t\\<close> \\<open>is_Var (head t)\\<close> s_App t_gt_s_same(2)"], ["proof (prove)\nusing this:\n  is_App t\n  is_Var (head t)\n  s = App x21_ x22_\n  chkchop_same (>\\<^sub>t) t s\n\ngoal (1 subgoal):\n 1. chop t >\\<^sub>t chop s", "by auto"], ["proof (state)\nthis:\n  chop t >\\<^sub>t chop s\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>args u = []; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "then"], ["proof (chain)\npicking this:\n  chop t >\\<^sub>t chop s", "have \"subst \\<rho> (chop t) >\\<^sub>t subst \\<rho> (chop s)\""], ["proof (prove)\nusing this:\n  chop t >\\<^sub>t chop s\n\ngoal (1 subgoal):\n 1. subst \\<rho> (chop t) >\\<^sub>t subst \\<rho> (chop s)", "using ih"], ["proof (prove)\nusing this:\n  chop t >\\<^sub>t chop s\n  \\<lbrakk>{#hsize ?tt, hsize ?ss#} < {#hsize t, hsize s#};\n   ?tt >\\<^sub>t ?ss\\<rbrakk>\n  \\<Longrightarrow> subst \\<rho> ?tt >\\<^sub>t subst \\<rho> ?ss\n\ngoal (1 subgoal):\n 1. subst \\<rho> (chop t) >\\<^sub>t subst \\<rho> (chop s)", "by (metis \\<open>is_App t\\<close> less_multiset_doubletons s_App hsize_chop_lt tm.disc(2))"], ["proof (state)\nthis:\n  subst \\<rho> (chop t) >\\<^sub>t subst \\<rho> (chop s)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>args u = []; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "define ut where \"ut = apps u (map (subst \\<rho>) (args t))\""], ["proof (state)\nthis:\n  ut = apps u (map (subst \\<rho>) (args t))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>args u = []; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "define us where \"us = apps u (map (subst \\<rho>) (args s))\""], ["proof (state)\nthis:\n  us = apps u (map (subst \\<rho>) (args s))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>args u = []; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "have 0:\"\\<And>ss. args (apps u ss) = ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ss. args (apps u ss) = ss", "using  \\<open>args u = []\\<close>"], ["proof (prove)\nusing this:\n  args u = []\n\ngoal (1 subgoal):\n 1. \\<And>ss. args (apps u ss) = ss", "by simp"], ["proof (state)\nthis:\n  args (apps u ?ss) = ?ss\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>args u = []; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "have chop_us: \"chop us = subst \\<rho> (chop s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chop us = subst \\<rho> (chop s)", "unfolding chop_def subst_apps us_def 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. apps (hd (map (subst \\<rho>) (args s)))\n     (tl (map (subst \\<rho>) (args s))) =\n    apps (subst \\<rho> (hd (args s))) (map (subst \\<rho>) (tl (args s)))", "using hd_map"], ["proof (prove)\nusing this:\n  ?xs \\<noteq> [] \\<Longrightarrow> hd (map ?f ?xs) = ?f (hd ?xs)\n\ngoal (1 subgoal):\n 1. apps (hd (map (subst \\<rho>) (args s)))\n     (tl (map (subst \\<rho>) (args s))) =\n    apps (subst \\<rho> (hd (args s))) (map (subst \\<rho>) (tl (args s)))", "by (metis (no_types, lifting) args_Nil_iff_is_Hd map_tl s_App tm.disc(2))"], ["proof (state)\nthis:\n  chop us = subst \\<rho> (chop s)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>args u = []; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "have chop_ut: \"chop ut = subst \\<rho> (chop t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chop ut = subst \\<rho> (chop t)", "unfolding chop_def subst_apps ut_def 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. apps (hd (map (subst \\<rho>) (args t)))\n     (tl (map (subst \\<rho>) (args t))) =\n    apps (subst \\<rho> (hd (args t))) (map (subst \\<rho>) (tl (args t)))", "using \\<open>is_App t\\<close>"], ["proof (prove)\nusing this:\n  is_App t\n\ngoal (1 subgoal):\n 1. apps (hd (map (subst \\<rho>) (args t)))\n     (tl (map (subst \\<rho>) (args t))) =\n    apps (subst \\<rho> (hd (args t))) (map (subst \\<rho>) (tl (args t)))", "by (simp add: args_Nil_iff_is_Hd hd_map map_tl)"], ["proof (state)\nthis:\n  chop ut = subst \\<rho> (chop t)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>args u = []; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "have \"head ut = head us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head ut = head us", "by (simp add: us_def ut_def)"], ["proof (state)\nthis:\n  head ut = head us\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>args u = []; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "moreover"], ["proof (state)\nthis:\n  head ut = head us\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>args u = []; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "have \"chkchop_same (>\\<^sub>t) ut us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) ut us", "unfolding chkchop_def chkchop_same_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. if is_Var (head ut)\n    then is_Hd ut \\<or> is_Hd us \\<or> chop ut >\\<^sub>t chop us\n    else is_Hd us \\<or> ut >\\<^sub>t chop us", "by (metis \"0\" UNIV_witness \\<open>is_Var (head t)\\<close> \\<open>subst \\<rho> (chop t) >\\<^sub>t subst \\<rho> (chop s)\\<close> \n                    args.simps(1) chop_us chop_ut extf_map_ts extf_min_empty \n                    ghd gt_chop is_Var_def tm.collapse(1) ut_def)"], ["proof (state)\nthis:\n  chkchop_same (>\\<^sub>t) ut us\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>args u = []; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "moreover"], ["proof (state)\nthis:\n  chkchop_same (>\\<^sub>t) ut us\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>args u = []; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "have \"\\<forall>f\\<in>local.ground_heads (head ut). extf f (>\\<^sub>t) (args ut) (args us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head ut).\n       extf f (>\\<^sub>t) (args ut) (args us)", "using extf_map_ts less us_def ut_def"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (map (subst \\<rho>) (args t))\n      (map (subst \\<rho>) (args s))\n  \\<lbrakk>hsize ?u < hsize u;\n   local.ground_heads (head ?u) \\<subseteq> local.ground_heads (head t);\n   hsize ?u \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n  \\<Longrightarrow> apps ?u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                    apps ?u (map (subst \\<rho>) (args s))\n  local.ground_heads (head u) \\<subseteq> local.ground_heads (head t)\n  hsize u \\<le> hsize (subst \\<rho> (Hd (head t)))\n  us = apps u (map (subst \\<rho>) (args s))\n  ut = apps u (map (subst \\<rho>) (args t))\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head ut).\n       extf f (>\\<^sub>t) (args ut) (args us)", "using \"0\""], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (map (subst \\<rho>) (args t))\n      (map (subst \\<rho>) (args s))\n  \\<lbrakk>hsize ?u < hsize u;\n   local.ground_heads (head ?u) \\<subseteq> local.ground_heads (head t);\n   hsize ?u \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n  \\<Longrightarrow> apps ?u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                    apps ?u (map (subst \\<rho>) (args s))\n  local.ground_heads (head u) \\<subseteq> local.ground_heads (head t)\n  hsize u \\<le> hsize (subst \\<rho> (Hd (head t)))\n  us = apps u (map (subst \\<rho>) (args s))\n  ut = apps u (map (subst \\<rho>) (args t))\n  args (apps u ?ss) = ?ss\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head ut).\n       extf f (>\\<^sub>t) (args ut) (args us)", "by auto"], ["proof (state)\nthis:\n  \\<forall>f\\<in>local.ground_heads (head ut).\n     extf f (>\\<^sub>t) (args ut) (args us)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>args u = []; s = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "ultimately"], ["proof (chain)\npicking this:\n  head ut = head us\n  chkchop_same (>\\<^sub>t) ut us\n  \\<forall>f\\<in>local.ground_heads (head ut).\n     extf f (>\\<^sub>t) (args ut) (args us)", "show \"ut >\\<^sub>t us\""], ["proof (prove)\nusing this:\n  head ut = head us\n  chkchop_same (>\\<^sub>t) ut us\n  \\<forall>f\\<in>local.ground_heads (head ut).\n     extf f (>\\<^sub>t) (args ut) (args us)\n\ngoal (1 subgoal):\n 1. ut >\\<^sub>t us", "using gt_same"], ["proof (prove)\nusing this:\n  head ut = head us\n  chkchop_same (>\\<^sub>t) ut us\n  \\<forall>f\\<in>local.ground_heads (head ut).\n     extf f (>\\<^sub>t) (args ut) (args us)\n  \\<lbrakk>head ?t = head ?s; chkchop_same (>\\<^sub>t) ?t ?s;\n   \\<forall>f\\<in>local.ground_heads (head ?t).\n      extf f (>\\<^sub>t) (args ?t) (args ?s)\\<rbrakk>\n  \\<Longrightarrow> ?t >\\<^sub>t ?s\n\ngoal (1 subgoal):\n 1. ut >\\<^sub>t us", "by blast"], ["proof (state)\nthis:\n  ut >\\<^sub>t us\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n  apps u (map (subst \\<rho>) (args s))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>hsize u < hsize u;\n                    local.ground_heads (head u)\n                    \\<subseteq> local.ground_heads (head t);\n                    hsize u\n                    \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n                   \\<Longrightarrow> apps u\n(map (subst \\<rho>) (args t)) >\\<^sub>t\n                                     apps u (map (subst \\<rho>) (args s));\n        local.ground_heads (head u) \\<subseteq> local.ground_heads (head t);\n        hsize u \\<le> hsize (subst \\<rho> (Hd (head t)));\n        u = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>hsize u < hsize u;\n                    local.ground_heads (head u)\n                    \\<subseteq> local.ground_heads (head t);\n                    hsize u\n                    \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n                   \\<Longrightarrow> apps u\n(map (subst \\<rho>) (args t)) >\\<^sub>t\n                                     apps u (map (subst \\<rho>) (args s));\n        local.ground_heads (head u) \\<subseteq> local.ground_heads (head t);\n        hsize u \\<le> hsize (subst \\<rho> (Hd (head t)));\n        u = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "case u_app: (App _ _)"], ["proof (state)\nthis:\n  u = App x21_ x22_\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>hsize u < hsize u;\n                    local.ground_heads (head u)\n                    \\<subseteq> local.ground_heads (head t);\n                    hsize u\n                    \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n                   \\<Longrightarrow> apps u\n(map (subst \\<rho>) (args t)) >\\<^sub>t\n                                     apps u (map (subst \\<rho>) (args s));\n        local.ground_heads (head u) \\<subseteq> local.ground_heads (head t);\n        hsize u \\<le> hsize (subst \\<rho> (Hd (head t)));\n        u = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "let ?ut = \"apps u (map (subst \\<rho>) (args t))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>hsize u < hsize u;\n                    local.ground_heads (head u)\n                    \\<subseteq> local.ground_heads (head t);\n                    hsize u\n                    \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n                   \\<Longrightarrow> apps u\n(map (subst \\<rho>) (args t)) >\\<^sub>t\n                                     apps u (map (subst \\<rho>) (args s));\n        local.ground_heads (head u) \\<subseteq> local.ground_heads (head t);\n        hsize u \\<le> hsize (subst \\<rho> (Hd (head t)));\n        u = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "let ?us = \"apps u (map (subst \\<rho>) (args s))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>hsize u < hsize u;\n                    local.ground_heads (head u)\n                    \\<subseteq> local.ground_heads (head t);\n                    hsize u\n                    \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n                   \\<Longrightarrow> apps u\n(map (subst \\<rho>) (args t)) >\\<^sub>t\n                                     apps u (map (subst \\<rho>) (args s));\n        local.ground_heads (head u) \\<subseteq> local.ground_heads (head t);\n        hsize u \\<le> hsize (subst \\<rho> (Hd (head t)));\n        u = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "have 1:\"head ?ut = head ?ut\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head (apps u (map (subst \\<rho>) (args t))) =\n    head (apps u (map (subst \\<rho>) (args t)))", "by simp"], ["proof (state)\nthis:\n  head (apps u (map (subst \\<rho>) (args t))) =\n  head (apps u (map (subst \\<rho>) (args t)))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>hsize u < hsize u;\n                    local.ground_heads (head u)\n                    \\<subseteq> local.ground_heads (head t);\n                    hsize u\n                    \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n                   \\<Longrightarrow> apps u\n(map (subst \\<rho>) (args t)) >\\<^sub>t\n                                     apps u (map (subst \\<rho>) (args s));\n        local.ground_heads (head u) \\<subseteq> local.ground_heads (head t);\n        hsize u \\<le> hsize (subst \\<rho> (Hd (head t)));\n        u = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "have \"apps (chop u) (map (subst \\<rho>) (args t)) >\\<^sub>t apps (chop u) (map (subst \\<rho>) (args s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apps (chop u) (map (subst \\<rho>) (args t)) >\\<^sub>t\n    apps (chop u) (map (subst \\<rho>) (args s))", "using less.hyps[of \"chop u\"] hsize_chop_lt"], ["proof (prove)\nusing this:\n  \\<lbrakk>hsize (chop u) < hsize u;\n   local.ground_heads (head (chop u))\n   \\<subseteq> local.ground_heads (head t);\n   hsize (chop u) \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n  \\<Longrightarrow> apps (chop u) (map (subst \\<rho>) (args t)) >\\<^sub>t\n                    apps (chop u) (map (subst \\<rho>) (args s))\n  is_App ?t \\<Longrightarrow> hsize (chop ?t) < hsize ?t\n\ngoal (1 subgoal):\n 1. apps (chop u) (map (subst \\<rho>) (args t)) >\\<^sub>t\n    apps (chop u) (map (subst \\<rho>) (args s))", "by (metis Var dual_order.trans ghd less.prems(2) less_or_eq_imp_le subset_UNIV tm.disc(2) u_app)"], ["proof (state)\nthis:\n  apps (chop u) (map (subst \\<rho>) (args t)) >\\<^sub>t\n  apps (chop u) (map (subst \\<rho>) (args s))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>hsize u < hsize u;\n                    local.ground_heads (head u)\n                    \\<subseteq> local.ground_heads (head t);\n                    hsize u\n                    \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n                   \\<Longrightarrow> apps u\n(map (subst \\<rho>) (args t)) >\\<^sub>t\n                                     apps u (map (subst \\<rho>) (args s));\n        local.ground_heads (head u) \\<subseteq> local.ground_heads (head t);\n        hsize u \\<le> hsize (subst \\<rho> (Hd (head t)));\n        u = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "then"], ["proof (chain)\npicking this:\n  apps (chop u) (map (subst \\<rho>) (args t)) >\\<^sub>t\n  apps (chop u) (map (subst \\<rho>) (args s))", "have \"chop ?ut >\\<^sub>t chop ?us\""], ["proof (prove)\nusing this:\n  apps (chop u) (map (subst \\<rho>) (args t)) >\\<^sub>t\n  apps (chop u) (map (subst \\<rho>) (args s))\n\ngoal (1 subgoal):\n 1. chop (apps u (map (subst \\<rho>) (args t))) >\\<^sub>t\n    chop (apps u (map (subst \\<rho>) (args s)))", "by (simp add: chop_apps u_app)"], ["proof (state)\nthis:\n  chop (apps u (map (subst \\<rho>) (args t))) >\\<^sub>t\n  chop (apps u (map (subst \\<rho>) (args s)))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>hsize u < hsize u;\n                    local.ground_heads (head u)\n                    \\<subseteq> local.ground_heads (head t);\n                    hsize u\n                    \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n                   \\<Longrightarrow> apps u\n(map (subst \\<rho>) (args t)) >\\<^sub>t\n                                     apps u (map (subst \\<rho>) (args s));\n        local.ground_heads (head u) \\<subseteq> local.ground_heads (head t);\n        hsize u \\<le> hsize (subst \\<rho> (Hd (head t)));\n        u = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "then"], ["proof (chain)\npicking this:\n  chop (apps u (map (subst \\<rho>) (args t))) >\\<^sub>t\n  chop (apps u (map (subst \\<rho>) (args s)))", "have 2:\"chkchop_same (>\\<^sub>t) ?ut ?us\""], ["proof (prove)\nusing this:\n  chop (apps u (map (subst \\<rho>) (args t))) >\\<^sub>t\n  chop (apps u (map (subst \\<rho>) (args s)))\n\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) (apps u (map (subst \\<rho>) (args t)))\n     (apps u (map (subst \\<rho>) (args s)))", "unfolding chkchop_same_def chkchop_def"], ["proof (prove)\nusing this:\n  chop (apps u (map (subst \\<rho>) (args t))) >\\<^sub>t\n  chop (apps u (map (subst \\<rho>) (args s)))\n\ngoal (1 subgoal):\n 1. if is_Var (head (apps u (map (subst \\<rho>) (args t))))\n    then is_Hd (apps u (map (subst \\<rho>) (args t))) \\<or>\n         is_Hd (apps u (map (subst \\<rho>) (args s))) \\<or>\n         chop (apps u (map (subst \\<rho>) (args t))) >\\<^sub>t\n         chop (apps u (map (subst \\<rho>) (args s)))\n    else is_Hd (apps u (map (subst \\<rho>) (args s))) \\<or>\n         apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n         chop (apps u (map (subst \\<rho>) (args s)))", "by (metis UNIV_I \\<open>is_Var (head t)\\<close> args_Nil_iff_is_Hd args_apps extf_compat_append_left \n                  extf_map_ts extf_min_empty ghd gt_chop is_Var_def)"], ["proof (state)\nthis:\n  chkchop_same (>\\<^sub>t) (apps u (map (subst \\<rho>) (args t)))\n   (apps u (map (subst \\<rho>) (args s)))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>hsize u < hsize u;\n                    local.ground_heads (head u)\n                    \\<subseteq> local.ground_heads (head t);\n                    hsize u\n                    \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n                   \\<Longrightarrow> apps u\n(map (subst \\<rho>) (args t)) >\\<^sub>t\n                                     apps u (map (subst \\<rho>) (args s));\n        local.ground_heads (head u) \\<subseteq> local.ground_heads (head t);\n        hsize u \\<le> hsize (subst \\<rho> (Hd (head t)));\n        u = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "have 3:\"\\<forall>f\\<in>local.ground_heads (head ?ut). extf f (>\\<^sub>t) (args ?ut) (args ?us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads\n                    (head (apps u (map (subst \\<rho>) (args t)))).\n       extf f (>\\<^sub>t) (args (apps u (map (subst \\<rho>) (args t))))\n        (args (apps u (map (subst \\<rho>) (args s))))", "using extf_compat_append_left extf_map_ts less.prems(1)"], ["proof (prove)\nusing this:\n  extf ?f ?gt ?ys ?xs \\<Longrightarrow> extf ?f ?gt (?zs @ ?ys) (?zs @ ?xs)\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (map (subst \\<rho>) (args t))\n      (map (subst \\<rho>) (args s))\n  local.ground_heads (head u) \\<subseteq> local.ground_heads (head t)\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads\n                    (head (apps u (map (subst \\<rho>) (args t)))).\n       extf f (>\\<^sub>t) (args (apps u (map (subst \\<rho>) (args t))))\n        (args (apps u (map (subst \\<rho>) (args s))))", "by auto"], ["proof (state)\nthis:\n  \\<forall>f\\<in>local.ground_heads\n                  (head (apps u (map (subst \\<rho>) (args t)))).\n     extf f (>\\<^sub>t) (args (apps u (map (subst \\<rho>) (args t))))\n      (args (apps u (map (subst \\<rho>) (args s))))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>hsize u < hsize u;\n                    local.ground_heads (head u)\n                    \\<subseteq> local.ground_heads (head t);\n                    hsize u\n                    \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n                   \\<Longrightarrow> apps u\n(map (subst \\<rho>) (args t)) >\\<^sub>t\n                                     apps u (map (subst \\<rho>) (args s));\n        local.ground_heads (head u) \\<subseteq> local.ground_heads (head t);\n        hsize u \\<le> hsize (subst \\<rho> (Hd (head t)));\n        u = App x21 x22\\<rbrakk>\n       \\<Longrightarrow> apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n                         apps u (map (subst \\<rho>) (args s))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n    apps u (map (subst \\<rho>) (args s))", "using gt_same 1 2 3"], ["proof (prove)\nusing this:\n  \\<lbrakk>head ?t = head ?s; chkchop_same (>\\<^sub>t) ?t ?s;\n   \\<forall>f\\<in>local.ground_heads (head ?t).\n      extf f (>\\<^sub>t) (args ?t) (args ?s)\\<rbrakk>\n  \\<Longrightarrow> ?t >\\<^sub>t ?s\n  head (apps u (map (subst \\<rho>) (args t))) =\n  head (apps u (map (subst \\<rho>) (args t)))\n  chkchop_same (>\\<^sub>t) (apps u (map (subst \\<rho>) (args t)))\n   (apps u (map (subst \\<rho>) (args s)))\n  \\<forall>f\\<in>local.ground_heads\n                  (head (apps u (map (subst \\<rho>) (args t)))).\n     extf f (>\\<^sub>t) (args (apps u (map (subst \\<rho>) (args t))))\n      (args (apps u (map (subst \\<rho>) (args s))))\n\ngoal (1 subgoal):\n 1. apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n    apps u (map (subst \\<rho>) (args s))", "by simp"], ["proof (state)\nthis:\n  apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n  apps u (map (subst \\<rho>) (args s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n  apps u (map (subst \\<rho>) (args s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  apps u (map (subst \\<rho>) (args t)) >\\<^sub>t\n  apps u (map (subst \\<rho>) (args s))\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       head t = Var x1 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<And>x2.\n       head t = Sym x2 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s", "}"], ["proof (state)\nthis:\n  \\<lbrakk>local.ground_heads (head ?u2)\n           \\<subseteq> local.ground_heads (head t);\n   hsize ?u2 \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n  \\<Longrightarrow> apps ?u2 (map (subst \\<rho>) (args t)) >\\<^sub>t\n                    apps ?u2 (map (subst \\<rho>) (args s))\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       head t = Var x1 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<And>x2.\n       head t = Sym x2 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s", "note inner_induction = this"], ["proof (state)\nthis:\n  \\<lbrakk>local.ground_heads (head ?u2)\n           \\<subseteq> local.ground_heads (head t);\n   hsize ?u2 \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n  \\<Longrightarrow> apps ?u2 (map (subst \\<rho>) (args t)) >\\<^sub>t\n                    apps ?u2 (map (subst \\<rho>) (args s))\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       head t = Var x1 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<And>x2.\n       head t = Sym x2 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<rho> t >\\<^sub>t subst \\<rho> s", "using inner_induction[of \"subst \\<rho> (Hd (head t))\", unfolded subst_apps[symmetric]]"], ["proof (prove)\nusing this:\n  \\<lbrakk>local.ground_heads (head (subst \\<rho> (Hd (head t))))\n           \\<subseteq> local.ground_heads (head t);\n   hsize (subst \\<rho> (Hd (head t)))\n   \\<le> hsize (subst \\<rho> (Hd (head t)))\\<rbrakk>\n  \\<Longrightarrow> subst \\<rho> (apps (Hd (head t)) (args t)) >\\<^sub>t\n                    subst \\<rho> (apps (Hd (head t)) (args s))\n\ngoal (1 subgoal):\n 1. subst \\<rho> t >\\<^sub>t subst \\<rho> s", "by (metis Var ghd order_refl subset_UNIV t_gt_s_same(1) tm_collapse_apps)"], ["proof (state)\nthis:\n  subst \\<rho> t >\\<^sub>t subst \\<rho> s\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       head t = Sym x2 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       head t = Sym x2 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s", "case (Sym _)"], ["proof (state)\nthis:\n  head t = Sym x2_\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       head t = Sym x2 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s", "then"], ["proof (chain)\npicking this:\n  head t = Sym x2_", "have \"is_Sym (head (subst \\<rho> t))\" \"head (subst \\<rho> t) = head t\""], ["proof (prove)\nusing this:\n  head t = Sym x2_\n\ngoal (1 subgoal):\n 1. is_Sym (head (subst \\<rho> t)) &&& head (subst \\<rho> t) = head t", "by simp_all"], ["proof (state)\nthis:\n  is_Sym (head (subst \\<rho> t))\n  head (subst \\<rho> t) = head t\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       head t = Sym x2 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s", "then"], ["proof (chain)\npicking this:\n  is_Sym (head (subst \\<rho> t))\n  head (subst \\<rho> t) = head t", "have \"chkchop_same (>\\<^sub>t) t s\""], ["proof (prove)\nusing this:\n  is_Sym (head (subst \\<rho> t))\n  head (subst \\<rho> t) = head t\n\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) t s", "using t_gt_s_same"], ["proof (prove)\nusing this:\n  is_Sym (head (subst \\<rho> t))\n  head (subst \\<rho> t) = head t\n  head t = head s\n  chkchop_same (>\\<^sub>t) t s\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) t s", "unfolding chkchop_same_def chkchop_def"], ["proof (prove)\nusing this:\n  is_Sym (head (subst \\<rho> t))\n  head (subst \\<rho> t) = head t\n  head t = head s\n  if is_Var (head t)\n  then is_Hd t \\<or> is_Hd s \\<or> chop t >\\<^sub>t chop s\n  else is_Hd s \\<or> t >\\<^sub>t chop s\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n\ngoal (1 subgoal):\n 1. if is_Var (head t)\n    then is_Hd t \\<or> is_Hd s \\<or> chop t >\\<^sub>t chop s\n    else is_Hd s \\<or> t >\\<^sub>t chop s", "using Sym"], ["proof (prove)\nusing this:\n  is_Sym (head (subst \\<rho> t))\n  head (subst \\<rho> t) = head t\n  head t = head s\n  if is_Var (head t)\n  then is_Hd t \\<or> is_Hd s \\<or> chop t >\\<^sub>t chop s\n  else is_Hd s \\<or> t >\\<^sub>t chop s\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n  head t = Sym x2_\n\ngoal (1 subgoal):\n 1. if is_Var (head t)\n    then is_Hd t \\<or> is_Hd s \\<or> chop t >\\<^sub>t chop s\n    else is_Hd s \\<or> t >\\<^sub>t chop s", "by metis"], ["proof (state)\nthis:\n  chkchop_same (>\\<^sub>t) t s\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       head t = Sym x2 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s", "then"], ["proof (chain)\npicking this:\n  chkchop_same (>\\<^sub>t) t s", "have gt_same2: \"chkchop_same (>\\<^sub>t) (subst \\<rho> t) (subst \\<rho> s)\""], ["proof (prove)\nusing this:\n  chkchop_same (>\\<^sub>t) t s\n\ngoal (1 subgoal):\n 1. chkchop_same (>\\<^sub>t) (subst \\<rho> t) (subst \\<rho> s)", "unfolding chkchop_same_def chkchop_def"], ["proof (prove)\nusing this:\n  if is_Var (head t)\n  then is_Hd t \\<or> is_Hd s \\<or> chop t >\\<^sub>t chop s\n  else is_Hd s \\<or> t >\\<^sub>t chop s\n\ngoal (1 subgoal):\n 1. if is_Var (head (subst \\<rho> t))\n    then is_Hd (subst \\<rho> t) \\<or>\n         is_Hd (subst \\<rho> s) \\<or>\n         chop (subst \\<rho> t) >\\<^sub>t chop (subst \\<rho> s)\n    else is_Hd (subst \\<rho> s) \\<or>\n         subst \\<rho> t >\\<^sub>t chop (subst \\<rho> s)", "using ih[of t \"chop s\"]"], ["proof (prove)\nusing this:\n  if is_Var (head t)\n  then is_Hd t \\<or> is_Hd s \\<or> chop t >\\<^sub>t chop s\n  else is_Hd s \\<or> t >\\<^sub>t chop s\n  \\<lbrakk>{#hsize t, hsize (chop s)#} < {#hsize t, hsize s#};\n   t >\\<^sub>t chop s\\<rbrakk>\n  \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> (chop s)\n\ngoal (1 subgoal):\n 1. if is_Var (head (subst \\<rho> t))\n    then is_Hd (subst \\<rho> t) \\<or>\n         is_Hd (subst \\<rho> s) \\<or>\n         chop (subst \\<rho> t) >\\<^sub>t chop (subst \\<rho> s)\n    else is_Hd (subst \\<rho> s) \\<or>\n         subst \\<rho> t >\\<^sub>t chop (subst \\<rho> s)", "by (metis (no_types, lifting) Sym \\<open>head (subst \\<rho> t) = head t\\<close> \\<open>is_Sym (head (subst \\<rho> t))\\<close> \n             add_mset_commute add_mset_lt_left_lt chop_subst_Sym ground_imp_subst_iden hd.simps(18) \n             hsize_chop_lt t_gt_s_same(1) tm.collapse(1) tm.simps(17))"], ["proof (state)\nthis:\n  chkchop_same (>\\<^sub>t) (subst \\<rho> t) (subst \\<rho> s)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       head t = Sym x2 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s", "have gt_same3: \"\\<forall>f\\<in>local.ground_heads (head (subst \\<rho> t)). extf f (>\\<^sub>t) (args (subst \\<rho> t)) (args (subst \\<rho> s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head (subst \\<rho> t)).\n       extf f (>\\<^sub>t) (args (subst \\<rho> t)) (args (subst \\<rho> s))", "using \\<open>head (subst \\<rho> t) = head t\\<close> extf_compat_append_left extf_map_ts t_gt_s_same(1)"], ["proof (prove)\nusing this:\n  head (subst \\<rho> t) = head t\n  extf ?f ?gt ?ys ?xs \\<Longrightarrow> extf ?f ?gt (?zs @ ?ys) (?zs @ ?xs)\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (map (subst \\<rho>) (args t))\n      (map (subst \\<rho>) (args s))\n  head t = head s\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head (subst \\<rho> t)).\n       extf f (>\\<^sub>t) (args (subst \\<rho> t)) (args (subst \\<rho> s))", "by auto"], ["proof (state)\nthis:\n  \\<forall>f\\<in>local.ground_heads (head (subst \\<rho> t)).\n     extf f (>\\<^sub>t) (args (subst \\<rho> t)) (args (subst \\<rho> s))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       head t = Sym x2 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<rho> t >\\<^sub>t subst \\<rho> s", "using gt_same gt_same1 gt_same2 gt_same3"], ["proof (prove)\nusing this:\n  \\<lbrakk>head ?t = head ?s; chkchop_same (>\\<^sub>t) ?t ?s;\n   \\<forall>f\\<in>local.ground_heads (head ?t).\n      extf f (>\\<^sub>t) (args ?t) (args ?s)\\<rbrakk>\n  \\<Longrightarrow> ?t >\\<^sub>t ?s\n  head (subst \\<rho> t) = head (subst \\<rho> s)\n  chkchop_same (>\\<^sub>t) (subst \\<rho> t) (subst \\<rho> s)\n  \\<forall>f\\<in>local.ground_heads (head (subst \\<rho> t)).\n     extf f (>\\<^sub>t) (args (subst \\<rho> t)) (args (subst \\<rho> s))\n\ngoal (1 subgoal):\n 1. subst \\<rho> t >\\<^sub>t subst \\<rho> s", "by blast"], ["proof (state)\nthis:\n  subst \\<rho> t >\\<^sub>t subst \\<rho> s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst \\<rho> t >\\<^sub>t subst \\<rho> s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst \\<rho> t >\\<^sub>t subst \\<rho> s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Totality on Ground Terms\\<close>"], ["", "theorem gt_total_ground:\n  assumes extf_total: \"\\<And>f. ext_total (extf f)\"\n  shows \"ground t \\<Longrightarrow> ground s \\<Longrightarrow> t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ground t; ground s\\<rbrakk>\n    \\<Longrightarrow> t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "proof (simp only: atomize_imp,\n    rule measure_induct_rule[of \"\\<lambda>(t, s). {# hsize t, hsize s #}\"\n      \"\\<lambda>(t, s). ground t \\<longrightarrow> ground s \\<longrightarrow> t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\" \"(t, s)\", simplified prod.case],\n    simp only: split_paired_all prod.case atomize_imp[symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "fix t s :: \"('s, 'v) tm\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "assume\n    ih: \"\\<And>ta sa. {# hsize ta, hsize sa #} < {# hsize t, hsize s #} \\<Longrightarrow> ground ta \\<Longrightarrow> ground sa \\<Longrightarrow>\n      ta >\\<^sub>t sa \\<or> sa >\\<^sub>t ta \\<or> ta = sa\" and\n    gr_t: \"ground t\" and gr_s: \"ground s\""], ["proof (state)\nthis:\n  \\<lbrakk>{#hsize ?ta, hsize ?sa#} < {#hsize t, hsize s#}; ground ?ta;\n   ground ?sa\\<rbrakk>\n  \\<Longrightarrow> ?ta >\\<^sub>t ?sa \\<or>\n                    ?sa >\\<^sub>t ?ta \\<or> ?ta = ?sa\n  ground t\n  ground s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "let ?case = \"t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "have \"chkchop (>\\<^sub>t) t s \\<or> s >\\<^sub>t t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chkchop (>\\<^sub>t) t s \\<or> s >\\<^sub>t t", "unfolding chkchop_def tm.case_eq_if"], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_Hd s \\<or> t >\\<^sub>t chop s) \\<or> s >\\<^sub>t t", "using ih[of t \"chop s\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>{#hsize t, hsize (chop s)#} < {#hsize t, hsize s#}; ground t;\n   ground (chop s)\\<rbrakk>\n  \\<Longrightarrow> t >\\<^sub>t chop s \\<or>\n                    chop s >\\<^sub>t t \\<or> t = chop s\n\ngoal (1 subgoal):\n 1. (is_Hd s \\<or> t >\\<^sub>t chop s) \\<or> s >\\<^sub>t t", "by (metis (no_types, lifting) add_mset_commute add_mset_lt_left_lt gr_s gr_t ground_chop gt_chop hsize_chop_lt)"], ["proof (state)\nthis:\n  chkchop (>\\<^sub>t) t s \\<or> s >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "moreover"], ["proof (state)\nthis:\n  chkchop (>\\<^sub>t) t s \\<or> s >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "have \"chkchop (>\\<^sub>t) s t \\<or> t >\\<^sub>t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chkchop (>\\<^sub>t) s t \\<or> t >\\<^sub>t s", "unfolding chkchop_def tm.case_eq_if"], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_Hd t \\<or> s >\\<^sub>t chop t) \\<or> t >\\<^sub>t s", "using ih[of \"chop t\" s]"], ["proof (prove)\nusing this:\n  \\<lbrakk>{#hsize (chop t), hsize s#} < {#hsize t, hsize s#};\n   ground (chop t); ground s\\<rbrakk>\n  \\<Longrightarrow> chop t >\\<^sub>t s \\<or>\n                    s >\\<^sub>t chop t \\<or> chop t = s\n\ngoal (1 subgoal):\n 1. (is_Hd t \\<or> s >\\<^sub>t chop t) \\<or> t >\\<^sub>t s", "by (metis add_mset_lt_left_lt gr_s gr_t ground_chop gt_chop.intros gt_iff_chop_diff_same hsize_chop_lt)"], ["proof (state)\nthis:\n  chkchop (>\\<^sub>t) s t \\<or> t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "moreover"], ["proof (state)\nthis:\n  chkchop (>\\<^sub>t) s t \\<or> t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "{"], ["proof (state)\nthis:\n  chkchop (>\\<^sub>t) s t \\<or> t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "assume\n      chkembs_t_s: \"chkchop (>\\<^sub>t) t s\" and\n      chkembs_s_t: \"chkchop (>\\<^sub>t) s t\""], ["proof (state)\nthis:\n  chkchop (>\\<^sub>t) t s\n  chkchop (>\\<^sub>t) s t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "obtain g where g: \"head t = Sym g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g. head t = Sym g \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using gr_t"], ["proof (prove)\nusing this:\n  ground t\n\ngoal (1 subgoal):\n 1. (\\<And>g. head t = Sym g \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis ground_head hd.collapse(2))"], ["proof (state)\nthis:\n  head t = Sym g\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "obtain f where f: \"head s = Sym f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f. head s = Sym f \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using gr_s"], ["proof (prove)\nusing this:\n  ground s\n\ngoal (1 subgoal):\n 1. (\\<And>f. head s = Sym f \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis ground_head hd.collapse(2))"], ["proof (state)\nthis:\n  head s = Sym f\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "{"], ["proof (state)\nthis:\n  head s = Sym f\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "assume g_gt_f: \"g >\\<^sub>s f\""], ["proof (state)\nthis:\n  g >\\<^sub>s f\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "have \"t >\\<^sub>t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t >\\<^sub>t s", "using chkembs_t_s f g g_gt_f gt_diff gt_sym_imp_hd"], ["proof (prove)\nusing this:\n  chkchop (>\\<^sub>t) t s\n  head s = Sym f\n  head t = Sym g\n  g >\\<^sub>s f\n  \\<lbrakk>head ?t >\\<^sub>h\\<^sub>d head ?s; is_Sym (head ?s);\n   chkchop (>\\<^sub>t) ?t ?s\\<rbrakk>\n  \\<Longrightarrow> ?t >\\<^sub>t ?s\n  ?g >\\<^sub>s ?f \\<Longrightarrow> Sym ?g >\\<^sub>h\\<^sub>d Sym ?f\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s", "by auto"], ["proof (state)\nthis:\n  t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "}"], ["proof (state)\nthis:\n  g >\\<^sub>s f \\<Longrightarrow> t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "moreover"], ["proof (state)\nthis:\n  g >\\<^sub>s f \\<Longrightarrow> t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "{"], ["proof (state)\nthis:\n  g >\\<^sub>s f \\<Longrightarrow> t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "assume f_gt_g: \"f >\\<^sub>s g\""], ["proof (state)\nthis:\n  f >\\<^sub>s g\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "have \"s >\\<^sub>t t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s >\\<^sub>t t", "using chkembs_s_t f f_gt_g g gt_diff gt_sym_imp_hd"], ["proof (prove)\nusing this:\n  chkchop (>\\<^sub>t) s t\n  head s = Sym f\n  f >\\<^sub>s g\n  head t = Sym g\n  \\<lbrakk>head ?t >\\<^sub>h\\<^sub>d head ?s; is_Sym (head ?s);\n   chkchop (>\\<^sub>t) ?t ?s\\<rbrakk>\n  \\<Longrightarrow> ?t >\\<^sub>t ?s\n  ?g >\\<^sub>s ?f \\<Longrightarrow> Sym ?g >\\<^sub>h\\<^sub>d Sym ?f\n\ngoal (1 subgoal):\n 1. s >\\<^sub>t t", "by auto"], ["proof (state)\nthis:\n  s >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "}"], ["proof (state)\nthis:\n  f >\\<^sub>s g \\<Longrightarrow> s >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "moreover"], ["proof (state)\nthis:\n  f >\\<^sub>s g \\<Longrightarrow> s >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "{"], ["proof (state)\nthis:\n  f >\\<^sub>s g \\<Longrightarrow> s >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "assume g_eq_f: \"g = f\""], ["proof (state)\nthis:\n  g = f\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "hence hd_t: \"head t = head s\""], ["proof (prove)\nusing this:\n  g = f\n\ngoal (1 subgoal):\n 1. head t = head s", "using g f"], ["proof (prove)\nusing this:\n  g = f\n  head t = Sym g\n  head s = Sym f\n\ngoal (1 subgoal):\n 1. head t = head s", "by auto"], ["proof (state)\nthis:\n  head t = head s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "let ?ts = \"args t\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "let ?ss = \"args s\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "have gr_ts: \"\\<forall>ta \\<in> set ?ts. ground ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ta\\<in>set (args t). ground ta", "using ground_args[OF _ gr_t]"], ["proof (prove)\nusing this:\n  ?t \\<in> set (args t) \\<Longrightarrow> ground ?t\n\ngoal (1 subgoal):\n 1. \\<forall>ta\\<in>set (args t). ground ta", "by blast"], ["proof (state)\nthis:\n  \\<forall>ta\\<in>set (args t). ground ta\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "have gr_ss: \"\\<forall>sa \\<in> set ?ss. ground sa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>sa\\<in>set (args s). ground sa", "using ground_args[OF _ gr_s]"], ["proof (prove)\nusing this:\n  ?t \\<in> set (args s) \\<Longrightarrow> ground ?t\n\ngoal (1 subgoal):\n 1. \\<forall>sa\\<in>set (args s). ground sa", "by blast"], ["proof (state)\nthis:\n  \\<forall>sa\\<in>set (args s). ground sa\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "{"], ["proof (state)\nthis:\n  \\<forall>sa\\<in>set (args s). ground sa\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "assume ts_eq_ss: \"?ts = ?ss\""], ["proof (state)\nthis:\n  args t = args s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "have \"t = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = s", "using hd_t ts_eq_ss"], ["proof (prove)\nusing this:\n  head t = head s\n  args t = args s\n\ngoal (1 subgoal):\n 1. t = s", "by (rule tm_expand_apps)"], ["proof (state)\nthis:\n  t = s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "}"], ["proof (state)\nthis:\n  args t = args s \\<Longrightarrow> t = s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "moreover"], ["proof (state)\nthis:\n  args t = args s \\<Longrightarrow> t = s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "{"], ["proof (state)\nthis:\n  args t = args s \\<Longrightarrow> t = s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "assume ts_gt_ss: \"extf g (>\\<^sub>t) ?ts ?ss\""], ["proof (state)\nthis:\n  extf g (>\\<^sub>t) (args t) (args s)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "have \"t >\\<^sub>t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t >\\<^sub>t s", "using chkembs_t_s g gt_same hd_t ts_gt_ss"], ["proof (prove)\nusing this:\n  chkchop (>\\<^sub>t) t s\n  head t = Sym g\n  \\<lbrakk>head ?t = head ?s; chkchop_same (>\\<^sub>t) ?t ?s;\n   \\<forall>f\\<in>local.ground_heads (head ?t).\n      extf f (>\\<^sub>t) (args ?t) (args ?s)\\<rbrakk>\n  \\<Longrightarrow> ?t >\\<^sub>t ?s\n  head t = head s\n  extf g (>\\<^sub>t) (args t) (args s)\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s", "by auto"], ["proof (state)\nthis:\n  t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "}"], ["proof (state)\nthis:\n  extf g (>\\<^sub>t) (args t) (args s) \\<Longrightarrow> t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "moreover"], ["proof (state)\nthis:\n  extf g (>\\<^sub>t) (args t) (args s) \\<Longrightarrow> t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "{"], ["proof (state)\nthis:\n  extf g (>\\<^sub>t) (args t) (args s) \\<Longrightarrow> t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "assume ss_gt_ts: \"extf g (>\\<^sub>t) ?ss ?ts\""], ["proof (state)\nthis:\n  extf g (>\\<^sub>t) (args s) (args t)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "have \"s >\\<^sub>t t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s >\\<^sub>t t", "using chkembs_s_t f g_eq_f gt_same hd_t ss_gt_ts"], ["proof (prove)\nusing this:\n  chkchop (>\\<^sub>t) s t\n  head s = Sym f\n  g = f\n  \\<lbrakk>head ?t = head ?s; chkchop_same (>\\<^sub>t) ?t ?s;\n   \\<forall>f\\<in>local.ground_heads (head ?t).\n      extf f (>\\<^sub>t) (args ?t) (args ?s)\\<rbrakk>\n  \\<Longrightarrow> ?t >\\<^sub>t ?s\n  head t = head s\n  extf g (>\\<^sub>t) (args s) (args t)\n\ngoal (1 subgoal):\n 1. s >\\<^sub>t t", "by auto"], ["proof (state)\nthis:\n  s >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "}"], ["proof (state)\nthis:\n  extf g (>\\<^sub>t) (args s) (args t) \\<Longrightarrow> s >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "ultimately"], ["proof (chain)\npicking this:\n  args t = args s \\<Longrightarrow> t = s\n  extf g (>\\<^sub>t) (args t) (args s) \\<Longrightarrow> t >\\<^sub>t s\n  extf g (>\\<^sub>t) (args s) (args t) \\<Longrightarrow> s >\\<^sub>t t", "have ?case"], ["proof (prove)\nusing this:\n  args t = args s \\<Longrightarrow> t = s\n  extf g (>\\<^sub>t) (args t) (args s) \\<Longrightarrow> t >\\<^sub>t s\n  extf g (>\\<^sub>t) (args s) (args t) \\<Longrightarrow> s >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "using ih gr_ss gr_ts\n          ext_total.total[OF extf_total, rule_format, of \"set ?ts \\<union> set ?ss\" \"(>\\<^sub>t)\" ?ts ?ss g]"], ["proof (prove)\nusing this:\n  args t = args s \\<Longrightarrow> t = s\n  extf g (>\\<^sub>t) (args t) (args s) \\<Longrightarrow> t >\\<^sub>t s\n  extf g (>\\<^sub>t) (args s) (args t) \\<Longrightarrow> s >\\<^sub>t t\n  \\<lbrakk>{#hsize ?ta, hsize ?sa#} < {#hsize t, hsize s#}; ground ?ta;\n   ground ?sa\\<rbrakk>\n  \\<Longrightarrow> ?ta >\\<^sub>t ?sa \\<or>\n                    ?sa >\\<^sub>t ?ta \\<or> ?ta = ?sa\n  \\<forall>sa\\<in>set (args s). ground sa\n  \\<forall>ta\\<in>set (args t). ground ta\n  \\<lbrakk>\\<And>y x.\n              \\<lbrakk>y \\<in> set (args t) \\<union> set (args s);\n               x \\<in> set (args t) \\<union> set (args s)\\<rbrakk>\n              \\<Longrightarrow> y >\\<^sub>t x \\<or>\n                                x >\\<^sub>t y \\<or> y = x;\n   args t \\<in> lists (set (args t) \\<union> set (args s));\n   args s \\<in> lists (set (args t) \\<union> set (args s))\\<rbrakk>\n  \\<Longrightarrow> extf g (>\\<^sub>t) (args t) (args s) \\<or>\n                    extf g (>\\<^sub>t) (args s) (args t) \\<or>\n                    args t = args s\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "using less_multiset_doubletons epo_axioms hsize_in_args in_listsI"], ["proof (prove)\nusing this:\n  args t = args s \\<Longrightarrow> t = s\n  extf g (>\\<^sub>t) (args t) (args s) \\<Longrightarrow> t >\\<^sub>t s\n  extf g (>\\<^sub>t) (args s) (args t) \\<Longrightarrow> s >\\<^sub>t t\n  \\<lbrakk>{#hsize ?ta, hsize ?sa#} < {#hsize t, hsize s#}; ground ?ta;\n   ground ?sa\\<rbrakk>\n  \\<Longrightarrow> ?ta >\\<^sub>t ?sa \\<or>\n                    ?sa >\\<^sub>t ?ta \\<or> ?ta = ?sa\n  \\<forall>sa\\<in>set (args s). ground sa\n  \\<forall>ta\\<in>set (args t). ground ta\n  \\<lbrakk>\\<And>y x.\n              \\<lbrakk>y \\<in> set (args t) \\<union> set (args s);\n               x \\<in> set (args t) \\<union> set (args s)\\<rbrakk>\n              \\<Longrightarrow> y >\\<^sub>t x \\<or>\n                                x >\\<^sub>t y \\<or> y = x;\n   args t \\<in> lists (set (args t) \\<union> set (args s));\n   args s \\<in> lists (set (args t) \\<union> set (args s))\\<rbrakk>\n  \\<Longrightarrow> extf g (>\\<^sub>t) (args t) (args s) \\<or>\n                    extf g (>\\<^sub>t) (args s) (args t) \\<or>\n                    args t = args s\n  \\<lbrakk>?y < ?t \\<or> ?y < ?s; ?x < ?t \\<or> ?x < ?s\\<rbrakk>\n  \\<Longrightarrow> {#?y, ?x#} < {#?t, ?s#}\n  epo ground_heads_var (>\\<^sub>s) arity_sym arity_var extf\n  ?s \\<in> set (args ?t) \\<Longrightarrow> hsize ?s < hsize ?t\n  \\<forall>x\\<in>set ?xs. x \\<in> ?A \\<Longrightarrow> ?xs \\<in> lists ?A\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "by (metis Un_iff)"], ["proof (state)\nthis:\n  t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "}"], ["proof (state)\nthis:\n  g = f \\<Longrightarrow> t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "ultimately"], ["proof (chain)\npicking this:\n  g >\\<^sub>s f \\<Longrightarrow> t >\\<^sub>t s\n  f >\\<^sub>s g \\<Longrightarrow> s >\\<^sub>t t\n  g = f \\<Longrightarrow> t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "have ?case"], ["proof (prove)\nusing this:\n  g >\\<^sub>s f \\<Longrightarrow> t >\\<^sub>t s\n  f >\\<^sub>s g \\<Longrightarrow> s >\\<^sub>t t\n  g = f \\<Longrightarrow> t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "using gt_sym_total"], ["proof (prove)\nusing this:\n  g >\\<^sub>s f \\<Longrightarrow> t >\\<^sub>t s\n  f >\\<^sub>s g \\<Longrightarrow> s >\\<^sub>t t\n  g = f \\<Longrightarrow> t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\n  ?f >\\<^sub>s ?g \\<or> ?g >\\<^sub>s ?f \\<or> ?g = ?f\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "by blast"], ["proof (state)\nthis:\n  t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "}"], ["proof (state)\nthis:\n  \\<lbrakk>chkchop (>\\<^sub>t) t s; chkchop (>\\<^sub>t) s t\\<rbrakk>\n  \\<Longrightarrow> t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#hsize aa, hsize ba#} < {#hsize a, hsize b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "ultimately"], ["proof (chain)\npicking this:\n  chkchop (>\\<^sub>t) t s \\<or> s >\\<^sub>t t\n  chkchop (>\\<^sub>t) s t \\<or> t >\\<^sub>t s\n  \\<lbrakk>chkchop (>\\<^sub>t) t s; chkchop (>\\<^sub>t) s t\\<rbrakk>\n  \\<Longrightarrow> t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "show ?case"], ["proof (prove)\nusing this:\n  chkchop (>\\<^sub>t) t s \\<or> s >\\<^sub>t t\n  chkchop (>\\<^sub>t) s t \\<or> t >\\<^sub>t s\n  \\<lbrakk>chkchop (>\\<^sub>t) t s; chkchop (>\\<^sub>t) s t\\<rbrakk>\n  \\<Longrightarrow> t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "by fast"], ["proof (state)\nthis:\n  t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Well-foundedness\\<close>"], ["", "abbreviation gtg :: \"('s, 'v) tm \\<Rightarrow> ('s, 'v) tm \\<Rightarrow> bool\" (infix \">\\<^sub>t\\<^sub>g\" 50) where\n  \"(>\\<^sub>t\\<^sub>g) \\<equiv> \\<lambda>t s. ground t \\<and> t >\\<^sub>t s\""], ["", "theorem gt_wf:\n  assumes ghd_UNIV: \"\\<And>x. ground_heads_var x = UNIV\"\n  assumes extf_wf: \"\\<And>f. ext_wf (extf f)\"\n  shows \"wfP (\\<lambda>s t. t >\\<^sub>t s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP (\\<lambda>s t. t >\\<^sub>t s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wfP (\\<lambda>s t. t >\\<^sub>t s)", "have ground_wfP: \"wfP (\\<lambda>s t. t >\\<^sub>t\\<^sub>g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP (\\<lambda>s t. ground t \\<and> t >\\<^sub>t s)", "unfolding wfP_iff_no_inf_chain"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Ex (inf_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "assume \"\\<exists>f. inf_chain (>\\<^sub>t\\<^sub>g) f\""], ["proof (state)\nthis:\n  \\<exists>f. inf_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s) f\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>f. inf_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s) f", "obtain t where t_bad: \"bad (>\\<^sub>t\\<^sub>g) t\""], ["proof (prove)\nusing this:\n  \\<exists>f. inf_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s) f\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n         t \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding inf_chain_def bad_def"], ["proof (prove)\nusing this:\n  \\<exists>f. \\<forall>i. ground (f i) \\<and> f i >\\<^sub>t f (Suc i)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<exists>f.\n           (\\<forall>i. ground (f i) \\<and> f i >\\<^sub>t f (Suc i)) \\<and>\n           f 0 = t \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s) t\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "let ?ff = \"worst_chain (>\\<^sub>t\\<^sub>g) (\\<lambda>t s. hsize t > hsize s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "let ?U_of = \"\\<lambda>i. {u. (?ff i) \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b u}\""], ["proof (state)\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "note wf_sz = wf_app[OF wellorder_class.wf, of hsize, simplified]"], ["proof (state)\nthis:\n  wf {(x, y). hsize x < hsize y}\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "define U where \"U = (\\<Union>i. ?U_of i)\""], ["proof (state)\nthis:\n  U =\n  (\\<Union>i.\n      {u. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n           (\\<lambda>t s. hsize s < hsize t)\n           i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\n          u})\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "have gr: \"\\<And>i. ground (?ff i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       ground\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) i)", "using worst_chain_bad[OF wf_sz t_bad, unfolded inf_chain_def]"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     ground\n      (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n        (\\<lambda>y x. hsize x < hsize y) i) \\<and>\n     worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n      (\\<lambda>y x. hsize x < hsize y) i >\\<^sub>t\n     worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n      (\\<lambda>y x. hsize x < hsize y) (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       ground\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) i)", "by fast"], ["proof (state)\nthis:\n  ground\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) ?i)\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "have gr_u: \"\\<And>u. u \\<in> U \\<Longrightarrow> ground u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> U \\<Longrightarrow> ground u", "unfolding U_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> (\\<Union>i.\n                   {u. worst_chain\n                        (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                        (\\<lambda>t s. hsize s < hsize t)\n                        i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\n                       u}) \\<Longrightarrow>\n       ground u", "using gr ground_emb"], ["proof (prove)\nusing this:\n  ground\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) ?i)\n  \\<lbrakk>?t \\<unrhd>\\<^sub>e\\<^sub>m\\<^sub>b ?s; ground ?t\\<rbrakk>\n  \\<Longrightarrow> ground ?s\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> (\\<Union>i.\n                   {u. worst_chain\n                        (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                        (\\<lambda>t s. hsize s < hsize t)\n                        i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\n                       u}) \\<Longrightarrow>\n       ground u", "by fastforce"], ["proof (state)\nthis:\n  ?u \\<in> U \\<Longrightarrow> ground ?u\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "have \"\\<not> bad (>\\<^sub>t\\<^sub>g) u\" if u_in: \"u \\<in> ?U_of i\" for u i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s) u", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s) u \\<Longrightarrow>\n    False", "let ?ti = \"?ff i\""], ["proof (state)\ngoal (1 subgoal):\n 1. bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s) u \\<Longrightarrow>\n    False", "assume u_bad: \"bad (>\\<^sub>t\\<^sub>g) u\""], ["proof (state)\nthis:\n  bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s) u\n\ngoal (1 subgoal):\n 1. bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s) u \\<Longrightarrow>\n    False", "have sz_u: \"hsize u < hsize ?ti\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hsize u\n    < hsize\n       (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n         (\\<lambda>t s. hsize s < hsize t) i)", "using emb_hsize_neq u_in"], ["proof (prove)\nusing this:\n  \\<lbrakk>?t \\<unrhd>\\<^sub>e\\<^sub>m\\<^sub>b ?s; ?t \\<noteq> ?s\\<rbrakk>\n  \\<Longrightarrow> hsize ?s < hsize ?t\n  u \\<in> {u. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n               (\\<lambda>t s. hsize s < hsize t)\n               i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\n              u}\n\ngoal (1 subgoal):\n 1. hsize u\n    < hsize\n       (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n         (\\<lambda>t s. hsize s < hsize t) i)", "by blast"], ["proof (state)\nthis:\n  hsize u\n  < hsize\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i)\n\ngoal (1 subgoal):\n 1. bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s) u \\<Longrightarrow>\n    False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> False\n 2. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> False\n 2. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. False", "using sz_u min_worst_chain_0[OF wf_sz u_bad]"], ["proof (prove)\nusing this:\n  i = 0\n  hsize u\n  < hsize\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i)\n  \\<not> hsize u\n         < hsize\n            (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n              (\\<lambda>y x. hsize x < hsize y) 0)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "case Suc"], ["proof (state)\nthis:\n  i = Suc nat_\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "hence \"?ff (i - 1) >\\<^sub>t ?ff i\""], ["proof (prove)\nusing this:\n  i = Suc nat_\n\ngoal (1 subgoal):\n 1. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) (i - 1) >\\<^sub>t\n    worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) i", "using worst_chain_pred[OF wf_sz t_bad]"], ["proof (prove)\nusing this:\n  i = Suc nat_\n  ground\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>y x. hsize x < hsize y) ?i) \\<and>\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>y x. hsize x < hsize y) ?i >\\<^sub>t\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>y x. hsize x < hsize y) (Suc ?i)\n\ngoal (1 subgoal):\n 1. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) (i - 1) >\\<^sub>t\n    worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) i", "by simp"], ["proof (state)\nthis:\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>t s. hsize s < hsize t) (i - 1) >\\<^sub>t\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>t s. hsize s < hsize t) i\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>t s. hsize s < hsize t) (i - 1) >\\<^sub>t\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>t s. hsize s < hsize t) i\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "have \"?ff i >\\<^sub>t u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) i >\\<^sub>t\n    u", "using gt_embedding_property u_in"], ["proof (prove)\nusing this:\n  \\<lbrakk>?t \\<unrhd>\\<^sub>e\\<^sub>m\\<^sub>b ?s; ?t \\<noteq> ?s\\<rbrakk>\n  \\<Longrightarrow> ?t >\\<^sub>t ?s\n  u \\<in> {u. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n               (\\<lambda>t s. hsize s < hsize t)\n               i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\n              u}\n\ngoal (1 subgoal):\n 1. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) i >\\<^sub>t\n    u", "by blast"], ["proof (state)\nthis:\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>t s. hsize s < hsize t) i >\\<^sub>t\n  u\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>t s. hsize s < hsize t) (i - 1) >\\<^sub>t\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>t s. hsize s < hsize t) i\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>t s. hsize s < hsize t) i >\\<^sub>t\n  u", "have \"?ff (i - 1) >\\<^sub>t u\""], ["proof (prove)\nusing this:\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>t s. hsize s < hsize t) (i - 1) >\\<^sub>t\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>t s. hsize s < hsize t) i\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>t s. hsize s < hsize t) i >\\<^sub>t\n  u\n\ngoal (1 subgoal):\n 1. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) (i - 1) >\\<^sub>t\n    u", "by (rule gt_trans)"], ["proof (state)\nthis:\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>t s. hsize s < hsize t) (i - 1) >\\<^sub>t\n  u\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>t s. hsize s < hsize t) (i - 1) >\\<^sub>t\n  u\n\ngoal (1 subgoal):\n 1. False", "using Suc sz_u min_worst_chain_Suc[OF wf_sz u_bad] gr"], ["proof (prove)\nusing this:\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>t s. hsize s < hsize t) (i - 1) >\\<^sub>t\n  u\n  i = Suc nat_\n  hsize u\n  < hsize\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i)\n  ground\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>y x. hsize x < hsize y) ?i) \\<and>\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>y x. hsize x < hsize y) ?i >\\<^sub>t\n  u \\<Longrightarrow>\n  \\<not> hsize u\n         < hsize\n            (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n              (\\<lambda>y x. hsize x < hsize y) (Suc ?i))\n  ground\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) ?i)\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?u \\<in> {u. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                (\\<lambda>t s. hsize s < hsize t)\n                ?i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\n               u} \\<Longrightarrow>\n  \\<not> bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s) ?u\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "hence u_good: \"\\<And>u. u \\<in> U \\<Longrightarrow> \\<not> bad (>\\<^sub>t\\<^sub>g) u\""], ["proof (prove)\nusing this:\n  ?u \\<in> {u. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                (\\<lambda>t s. hsize s < hsize t)\n                ?i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\n               u} \\<Longrightarrow>\n  \\<not> bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s) ?u\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> U \\<Longrightarrow>\n       \\<not> bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s) u", "unfolding U_def"], ["proof (prove)\nusing this:\n  ?u \\<in> {u. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                (\\<lambda>t s. hsize s < hsize t)\n                ?i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\n               u} \\<Longrightarrow>\n  \\<not> bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s) ?u\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> (\\<Union>i.\n                   {u. worst_chain\n                        (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                        (\\<lambda>t s. hsize s < hsize t)\n                        i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\n                       u}) \\<Longrightarrow>\n       \\<not> bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s) u", "by blast"], ["proof (state)\nthis:\n  ?u \\<in> U \\<Longrightarrow>\n  \\<not> bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s) ?u\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "have bad_diff_same: \"inf_chain (\\<lambda>t s. ground t \\<and> (gt_diff t s \\<or> gt_same t s)) ?ff\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_chain\n     (\\<lambda>t s. ground t \\<and> (gt_diff t s \\<or> gt_same t s))\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t))", "unfolding inf_chain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       ground\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) i) \\<and>\n       (gt_diff\n         (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n           (\\<lambda>t s. hsize s < hsize t) i)\n         (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n           (\\<lambda>t s. hsize s < hsize t) (Suc i)) \\<or>\n        gt_same\n         (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n           (\\<lambda>t s. hsize s < hsize t) i)\n         (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n           (\\<lambda>t s. hsize s < hsize t) (Suc i)))", "proof (intro allI conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       ground\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) i)\n 2. \\<And>i.\n       gt_diff\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) i)\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (Suc i)) \\<or>\n       gt_same\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) i)\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (Suc i))", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       ground\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) i)\n 2. \\<And>i.\n       gt_diff\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) i)\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (Suc i)) \\<or>\n       gt_same\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) i)\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (Suc i))", "show \"ground (?ff i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ground\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i)", "by (rule gr)"], ["proof (state)\nthis:\n  ground\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       gt_diff\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) i)\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (Suc i)) \\<or>\n       gt_same\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) i)\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (Suc i))", "have gt: \"?ff i >\\<^sub>t ?ff (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) i >\\<^sub>t\n    worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) (Suc i)", "using worst_chain_pred[OF wf_sz t_bad]"], ["proof (prove)\nusing this:\n  ground\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>y x. hsize x < hsize y) ?i) \\<and>\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>y x. hsize x < hsize y) ?i >\\<^sub>t\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>y x. hsize x < hsize y) (Suc ?i)\n\ngoal (1 subgoal):\n 1. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) i >\\<^sub>t\n    worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) (Suc i)", "by blast"], ["proof (state)\nthis:\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>t s. hsize s < hsize t) i >\\<^sub>t\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>t s. hsize s < hsize t) (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       gt_diff\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) i)\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (Suc i)) \\<or>\n       gt_same\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) i)\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (Suc i))", "have \"\\<not> gt_chop (?ff i) (?ff (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> gt_chop\n            (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n              (\\<lambda>t s. hsize s < hsize t) i)\n            (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n              (\\<lambda>t s. hsize s < hsize t) (Suc i))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. gt_chop\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i)\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (Suc i)) \\<Longrightarrow>\n    False", "assume a: \"gt_chop (?ff i) (?ff (Suc i))\""], ["proof (state)\nthis:\n  gt_chop\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) i)\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) (Suc i))\n\ngoal (1 subgoal):\n 1. gt_chop\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i)\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (Suc i)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  gt_chop\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) i)\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) (Suc i))", "have \"chop (?ff i) \\<in> ?U_of i\""], ["proof (prove)\nusing this:\n  gt_chop\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) i)\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) (Suc i))\n\ngoal (1 subgoal):\n 1. chop\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i)\n    \\<in> {u. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n               (\\<lambda>t s. hsize s < hsize t)\n               i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\n              u}", "by (metis (mono_tags, lifting) emb_step_chop emb_step_is_emb gt_chop gt_chop.cases gt_irrefl mem_Collect_eq)"], ["proof (state)\nthis:\n  chop\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) i)\n  \\<in> {u. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n             (\\<lambda>t s. hsize s < hsize t)\n             i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\n            u}\n\ngoal (1 subgoal):\n 1. gt_chop\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i)\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (Suc i)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  chop\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) i)\n  \\<in> {u. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n             (\\<lambda>t s. hsize s < hsize t)\n             i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\n            u}", "have  uij_in:\"chop (?ff i) \\<in> U\""], ["proof (prove)\nusing this:\n  chop\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) i)\n  \\<in> {u. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n             (\\<lambda>t s. hsize s < hsize t)\n             i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\n            u}\n\ngoal (1 subgoal):\n 1. chop\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i)\n    \\<in> U", "unfolding U_def"], ["proof (prove)\nusing this:\n  chop\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) i)\n  \\<in> {u. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n             (\\<lambda>t s. hsize s < hsize t)\n             i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\n            u}\n\ngoal (1 subgoal):\n 1. chop\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i)\n    \\<in> (\\<Union>i.\n              {u. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                   (\\<lambda>t s. hsize s < hsize t)\n                   i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\n                  u})", "by fast"], ["proof (state)\nthis:\n  chop\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) i)\n  \\<in> U\n\ngoal (1 subgoal):\n 1. gt_chop\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i)\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (Suc i)) \\<Longrightarrow>\n    False", "have \"\\<And>n. ?ff n >\\<^sub>t ?ff (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n        (\\<lambda>t s. hsize s < hsize t) n >\\<^sub>t\n       worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n        (\\<lambda>t s. hsize s < hsize t) (Suc n)", "by (rule worst_chain_pred[OF wf_sz t_bad, THEN conjunct2])"], ["proof (state)\nthis:\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>t s. hsize s < hsize t) ?n >\\<^sub>t\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>t s. hsize s < hsize t) (Suc ?n)\n\ngoal (1 subgoal):\n 1. gt_chop\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i)\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (Suc i)) \\<Longrightarrow>\n    False", "hence uij_gt_i_plus_3: \"chop (?ff i) >\\<^sub>t ?ff (Suc (Suc i))\""], ["proof (prove)\nusing this:\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>t s. hsize s < hsize t) ?n >\\<^sub>t\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>t s. hsize s < hsize t) (Suc ?n)\n\ngoal (1 subgoal):\n 1. chop\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i) >\\<^sub>t\n    worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) (Suc (Suc i))", "using gt_trans"], ["proof (prove)\nusing this:\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>t s. hsize s < hsize t) ?n >\\<^sub>t\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>t s. hsize s < hsize t) (Suc ?n)\n  \\<lbrakk>?u >\\<^sub>t ?t; ?t >\\<^sub>t ?s\\<rbrakk>\n  \\<Longrightarrow> ?u >\\<^sub>t ?s\n\ngoal (1 subgoal):\n 1. chop\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i) >\\<^sub>t\n    worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) (Suc (Suc i))", "by (metis (mono_tags, lifting) a gt_chop.cases)"], ["proof (state)\nthis:\n  chop\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) i) >\\<^sub>t\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>t s. hsize s < hsize t) (Suc (Suc i))\n\ngoal (1 subgoal):\n 1. gt_chop\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i)\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (Suc i)) \\<Longrightarrow>\n    False", "have \"inf_chain (>\\<^sub>t\\<^sub>g) (\\<lambda>j. if j = 0 then chop (?ff i) else ?ff (Suc (i + j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>j.\n         if j = 0\n         then chop\n               (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                 (\\<lambda>t s. hsize s < hsize t) i)\n         else worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n               (\\<lambda>t s. hsize s < hsize t) (Suc (i + j)))", "unfolding inf_chain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ia.\n       ground\n        (if ia = 0\n         then chop\n               (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                 (\\<lambda>t s. hsize s < hsize t) i)\n         else worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n               (\\<lambda>t s. hsize s < hsize t) (Suc (i + ia))) \\<and>\n       (if ia = 0\n        then chop\n              (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                (\\<lambda>t s. hsize s < hsize t) i)\n        else worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n              (\\<lambda>t s. hsize s < hsize t) (Suc (i + ia))) >\\<^sub>t\n       (if Suc ia = 0\n        then chop\n              (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                (\\<lambda>t s. hsize s < hsize t) i)\n        else worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n              (\\<lambda>t s. hsize s < hsize t) (Suc (i + Suc ia)))", "by (auto intro!: gr gr_u[OF uij_in] uij_gt_i_plus_3 worst_chain_pred[OF wf_sz t_bad])"], ["proof (state)\nthis:\n  inf_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>j.\n       if j = 0\n       then chop\n             (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n               (\\<lambda>t s. hsize s < hsize t) i)\n       else worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n             (\\<lambda>t s. hsize s < hsize t) (Suc (i + j)))\n\ngoal (1 subgoal):\n 1. gt_chop\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i)\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (Suc i)) \\<Longrightarrow>\n    False", "hence \"bad (>\\<^sub>t\\<^sub>g) (chop (?ff i))\""], ["proof (prove)\nusing this:\n  inf_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>j.\n       if j = 0\n       then chop\n             (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n               (\\<lambda>t s. hsize s < hsize t) i)\n       else worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n             (\\<lambda>t s. hsize s < hsize t) (Suc (i + j)))\n\ngoal (1 subgoal):\n 1. bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (chop\n       (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n         (\\<lambda>t s. hsize s < hsize t) i))", "unfolding bad_def"], ["proof (prove)\nusing this:\n  inf_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>j.\n       if j = 0\n       then chop\n             (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n               (\\<lambda>t s. hsize s < hsize t) i)\n       else worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n             (\\<lambda>t s. hsize s < hsize t) (Suc (i + j)))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       inf_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s) f \\<and>\n       f 0 =\n       chop\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) i)", "by fastforce"], ["proof (state)\nthis:\n  bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (chop\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i))\n\ngoal (1 subgoal):\n 1. gt_chop\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i)\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (Suc i)) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (chop\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i))\n\ngoal (1 subgoal):\n 1. False", "using u_good[OF uij_in]"], ["proof (prove)\nusing this:\n  bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (chop\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i))\n  \\<not> bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (chop\n            (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n              (\\<lambda>t s. hsize s < hsize t) i))\n\ngoal (1 subgoal):\n 1. False", "by sat"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> gt_chop\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n            (\\<lambda>t s. hsize s < hsize t) i)\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n            (\\<lambda>t s. hsize s < hsize t) (Suc i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       gt_diff\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) i)\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (Suc i)) \\<or>\n       gt_same\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) i)\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (Suc i))", "thus \"gt_diff (?ff i) (?ff (Suc i)) \\<or> gt_same (?ff i) (?ff (Suc i))\""], ["proof (prove)\nusing this:\n  \\<not> gt_chop\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n            (\\<lambda>t s. hsize s < hsize t) i)\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n            (\\<lambda>t s. hsize s < hsize t) (Suc i))\n\ngoal (1 subgoal):\n 1. gt_diff\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i)\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (Suc i)) \\<or>\n    gt_same\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i)\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (Suc i))", "using gt"], ["proof (prove)\nusing this:\n  \\<not> gt_chop\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n            (\\<lambda>t s. hsize s < hsize t) i)\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n            (\\<lambda>t s. hsize s < hsize t) (Suc i))\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>t s. hsize s < hsize t) i >\\<^sub>t\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (\\<lambda>t s. hsize s < hsize t) (Suc i)\n\ngoal (1 subgoal):\n 1. gt_diff\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i)\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (Suc i)) \\<or>\n    gt_same\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i)\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (Suc i))", "unfolding gt_iff_chop_diff_same"], ["proof (prove)\nusing this:\n  \\<not> gt_chop\n          (worst_chain\n            (\\<lambda>t s.\n                ground t \\<and>\n                (gt_chop t s \\<or> gt_diff t s \\<or> gt_same t s))\n            (\\<lambda>t s. hsize s < hsize t) i)\n          (worst_chain\n            (\\<lambda>t s.\n                ground t \\<and>\n                (gt_chop t s \\<or> gt_diff t s \\<or> gt_same t s))\n            (\\<lambda>t s. hsize s < hsize t) (Suc i))\n  gt_chop\n   (worst_chain\n     (\\<lambda>t s.\n         ground t \\<and> (gt_chop t s \\<or> gt_diff t s \\<or> gt_same t s))\n     (\\<lambda>t s. hsize s < hsize t) i)\n   (worst_chain\n     (\\<lambda>t s.\n         ground t \\<and> (gt_chop t s \\<or> gt_diff t s \\<or> gt_same t s))\n     (\\<lambda>t s. hsize s < hsize t) (Suc i)) \\<or>\n  gt_diff\n   (worst_chain\n     (\\<lambda>t s.\n         ground t \\<and> (gt_chop t s \\<or> gt_diff t s \\<or> gt_same t s))\n     (\\<lambda>t s. hsize s < hsize t) i)\n   (worst_chain\n     (\\<lambda>t s.\n         ground t \\<and> (gt_chop t s \\<or> gt_diff t s \\<or> gt_same t s))\n     (\\<lambda>t s. hsize s < hsize t) (Suc i)) \\<or>\n  gt_same\n   (worst_chain\n     (\\<lambda>t s.\n         ground t \\<and> (gt_chop t s \\<or> gt_diff t s \\<or> gt_same t s))\n     (\\<lambda>t s. hsize s < hsize t) i)\n   (worst_chain\n     (\\<lambda>t s.\n         ground t \\<and> (gt_chop t s \\<or> gt_diff t s \\<or> gt_same t s))\n     (\\<lambda>t s. hsize s < hsize t) (Suc i))\n\ngoal (1 subgoal):\n 1. gt_diff\n     (worst_chain\n       (\\<lambda>t s.\n           ground t \\<and>\n           (gt_chop t s \\<or> gt_diff t s \\<or> gt_same t s))\n       (\\<lambda>t s. hsize s < hsize t) i)\n     (worst_chain\n       (\\<lambda>t s.\n           ground t \\<and>\n           (gt_chop t s \\<or> gt_diff t s \\<or> gt_same t s))\n       (\\<lambda>t s. hsize s < hsize t) (Suc i)) \\<or>\n    gt_same\n     (worst_chain\n       (\\<lambda>t s.\n           ground t \\<and>\n           (gt_chop t s \\<or> gt_diff t s \\<or> gt_same t s))\n       (\\<lambda>t s. hsize s < hsize t) i)\n     (worst_chain\n       (\\<lambda>t s.\n           ground t \\<and>\n           (gt_chop t s \\<or> gt_diff t s \\<or> gt_same t s))\n       (\\<lambda>t s. hsize s < hsize t) (Suc i))", "by sat"], ["proof (state)\nthis:\n  gt_diff\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) i)\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) (Suc i)) \\<or>\n  gt_same\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) i)\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) (Suc i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inf_chain (\\<lambda>t s. ground t \\<and> (gt_diff t s \\<or> gt_same t s))\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t))\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "have \"wf {(s, t). ground s \\<and> ground t \\<and> sym (head t) >\\<^sub>s sym (head s)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(s, t).\n        ground s \\<and>\n        ground t \\<and> hd.sym (head t) >\\<^sub>s hd.sym (head s)}", "using gt_sym_wf"], ["proof (prove)\nusing this:\n  wfP (\\<lambda>f g. g >\\<^sub>s f)\n\ngoal (1 subgoal):\n 1. wf {(s, t).\n        ground s \\<and>\n        ground t \\<and> hd.sym (head t) >\\<^sub>s hd.sym (head s)}", "unfolding wfP_def wf_iff_no_infinite_down_chain"], ["proof (prove)\nusing this:\n  \\<nexists>f. \\<forall>i. (f (Suc i), f i) \\<in> {(f, g). g >\\<^sub>s f}\n\ngoal (1 subgoal):\n 1. \\<nexists>f.\n       \\<forall>i.\n          (f (Suc i), f i)\n          \\<in> {(s, t).\n                 ground s \\<and>\n                 ground t \\<and> hd.sym (head t) >\\<^sub>s hd.sym (head s)}", "by fast"], ["proof (state)\nthis:\n  wf {(s, t).\n      ground s \\<and>\n      ground t \\<and> hd.sym (head t) >\\<^sub>s hd.sym (head s)}\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  wf {(s, t).\n      ground s \\<and>\n      ground t \\<and> hd.sym (head t) >\\<^sub>s hd.sym (head s)}\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "have \"{(s, t). ground t \\<and> gt_diff t s}\n      \\<subseteq> {(s, t). ground s \\<and> ground t \\<and> sym (head t) >\\<^sub>s sym (head s)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(s, t). ground t \\<and> gt_diff t s}\n    \\<subseteq> {(s, t).\n                 ground s \\<and>\n                 ground t \\<and> hd.sym (head t) >\\<^sub>s hd.sym (head s)}", "proof (clarsimp, intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>ground b; gt_diff b a\\<rbrakk> \\<Longrightarrow> ground a\n 2. \\<And>a b.\n       \\<lbrakk>ground b; gt_diff b a\\<rbrakk>\n       \\<Longrightarrow> hd.sym (head b) >\\<^sub>s hd.sym (head a)", "fix s t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>ground b; gt_diff b a\\<rbrakk> \\<Longrightarrow> ground a\n 2. \\<And>a b.\n       \\<lbrakk>ground b; gt_diff b a\\<rbrakk>\n       \\<Longrightarrow> hd.sym (head b) >\\<^sub>s hd.sym (head a)", "assume gr_t: \"ground t\" and gt_diff_t_s: \"gt_diff t s\""], ["proof (state)\nthis:\n  ground t\n  gt_diff t s\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>ground b; gt_diff b a\\<rbrakk> \\<Longrightarrow> ground a\n 2. \\<And>a b.\n       \\<lbrakk>ground b; gt_diff b a\\<rbrakk>\n       \\<Longrightarrow> hd.sym (head b) >\\<^sub>s hd.sym (head a)", "thus gr_s: \"ground s\""], ["proof (prove)\nusing this:\n  ground t\n  gt_diff t s\n\ngoal (1 subgoal):\n 1. ground s", "using gt_iff_chop_diff_same gt_imp_vars"], ["proof (prove)\nusing this:\n  ground t\n  gt_diff t s\n  (?t >\\<^sub>t ?s) =\n  (gt_chop ?t ?s \\<or> gt_diff ?t ?s \\<or> gt_same ?t ?s)\n  ?t >\\<^sub>t ?s \\<Longrightarrow> vars ?s \\<subseteq> vars ?t\n\ngoal (1 subgoal):\n 1. ground s", "by fastforce"], ["proof (state)\nthis:\n  ground s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ground b; gt_diff b a\\<rbrakk>\n       \\<Longrightarrow> hd.sym (head b) >\\<^sub>s hd.sym (head a)", "show \"sym (head t) >\\<^sub>s sym (head s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd.sym (head t) >\\<^sub>s hd.sym (head s)", "using gt_diff_t_s ground_head[OF gr_s] ground_head[OF gr_t]"], ["proof (prove)\nusing this:\n  gt_diff t s\n  is_Sym (head s)\n  is_Sym (head t)\n\ngoal (1 subgoal):\n 1. hd.sym (head t) >\\<^sub>s hd.sym (head s)", "by (cases; cases \"head s\"; cases \"head t\") (auto simp: gt_hd_def)"], ["proof (state)\nthis:\n  hd.sym (head t) >\\<^sub>s hd.sym (head s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {(s, t). ground t \\<and> gt_diff t s}\n  \\<subseteq> {(s, t).\n               ground s \\<and>\n               ground t \\<and> hd.sym (head t) >\\<^sub>s hd.sym (head s)}\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  wf {(s, t).\n      ground s \\<and>\n      ground t \\<and> hd.sym (head t) >\\<^sub>s hd.sym (head s)}\n  {(s, t). ground t \\<and> gt_diff t s}\n  \\<subseteq> {(s, t).\n               ground s \\<and>\n               ground t \\<and> hd.sym (head t) >\\<^sub>s hd.sym (head s)}", "have wf_diff: \"wf {(s, t). ground t \\<and> gt_diff t s}\""], ["proof (prove)\nusing this:\n  wf {(s, t).\n      ground s \\<and>\n      ground t \\<and> hd.sym (head t) >\\<^sub>s hd.sym (head s)}\n  {(s, t). ground t \\<and> gt_diff t s}\n  \\<subseteq> {(s, t).\n               ground s \\<and>\n               ground t \\<and> hd.sym (head t) >\\<^sub>s hd.sym (head s)}\n\ngoal (1 subgoal):\n 1. wf {(s, t). ground t \\<and> gt_diff t s}", "by (rule wf_subset)"], ["proof (state)\nthis:\n  wf {(s, t). ground t \\<and> gt_diff t s}\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "have diff_O_same: \"{(s, t). ground t \\<and> gt_diff t s} O {(s, t). ground t \\<and> gt_same t s}\n      \\<subseteq> {(s, t). ground t \\<and> gt_diff t s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(s, t). ground t \\<and> gt_diff t s} O\n    {(s, t). ground t \\<and> gt_same t s}\n    \\<subseteq> {(s, t). ground t \\<and> gt_diff t s}", "unfolding gt_diff.simps gt_same.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(s, t).\n     ground t \\<and>\n     (\\<exists>ta sa.\n         t = ta \\<and>\n         s = sa \\<and>\n         head ta >\\<^sub>h\\<^sub>d head sa \\<and>\n         is_Sym (head sa) \\<and> chkchop (>\\<^sub>t) ta sa)} O\n    {(s, t).\n     ground t \\<and>\n     (\\<exists>ta sa.\n         t = ta \\<and>\n         s = sa \\<and>\n         head ta = head sa \\<and>\n         chkchop_same (>\\<^sub>t) ta sa \\<and>\n         (\\<forall>f\\<in>local.ground_heads (head ta).\n             extf f (>\\<^sub>t) (args ta) (args sa)))}\n    \\<subseteq> {(s, t).\n                 ground t \\<and>\n                 (\\<exists>ta sa.\n                     t = ta \\<and>\n                     s = sa \\<and>\n                     head ta >\\<^sub>h\\<^sub>d head sa \\<and>\n                     is_Sym (head sa) \\<and> chkchop (>\\<^sub>t) ta sa)}", "by clarsimp (metis chkchop_def chkchop_same_def gt_same gt_trans)"], ["proof (state)\nthis:\n  {(s, t). ground t \\<and> gt_diff t s} O\n  {(s, t). ground t \\<and> gt_same t s}\n  \\<subseteq> {(s, t). ground t \\<and> gt_diff t s}\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "have diff_same_as_union: \"{(s, t). ground t \\<and> (gt_diff t s \\<or> gt_same t s)} =\n      {(s, t). ground t \\<and> gt_diff t s} \\<union> {(s, t). ground t \\<and> gt_same t s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(s, t). ground t \\<and> (gt_diff t s \\<or> gt_same t s)} =\n    {(s, t). ground t \\<and> gt_diff t s} \\<union>\n    {(s, t). ground t \\<and> gt_same t s}", "by auto"], ["proof (state)\nthis:\n  {(s, t). ground t \\<and> (gt_diff t s \\<or> gt_same t s)} =\n  {(s, t). ground t \\<and> gt_diff t s} \\<union>\n  {(s, t). ground t \\<and> gt_same t s}\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "obtain k where bad_same: \"inf_chain (\\<lambda>t s. ground t \\<and> gt_same t s) (\\<lambda>i. ?ff (i + k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        inf_chain (\\<lambda>t s. ground t \\<and> gt_same t s)\n         (\\<lambda>i.\n             worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n              (\\<lambda>t s. hsize s < hsize t) (i + k)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using wf_infinite_down_chain_compatible[OF wf_diff _ diff_O_same, of ?ff] bad_diff_same"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (Suc i),\n      worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i)\n     \\<in> {(s, t). ground t \\<and> gt_diff t s} \\<union>\n           {(s, t). ground t \\<and> gt_same t s} \\<Longrightarrow>\n  \\<exists>k.\n     \\<forall>i.\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (Suc (i + k)),\n         worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (i + k))\n        \\<in> {(s, t). ground t \\<and> gt_same t s}\n  inf_chain (\\<lambda>t s. ground t \\<and> (gt_diff t s \\<or> gt_same t s))\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t))\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        inf_chain (\\<lambda>t s. ground t \\<and> gt_same t s)\n         (\\<lambda>i.\n             worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n              (\\<lambda>t s. hsize s < hsize t) (i + k)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding inf_chain_def diff_same_as_union[symmetric]"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (Suc i),\n      worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) i)\n     \\<in> {(s, t).\n            ground t \\<and>\n            (gt_diff t s \\<or> gt_same t s)} \\<Longrightarrow>\n  \\<exists>k.\n     \\<forall>i.\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (Suc (i + k)),\n         worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (i + k))\n        \\<in> {(s, t). ground t \\<and> gt_same t s}\n  \\<forall>i.\n     ground\n      (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n        (\\<lambda>t s. hsize s < hsize t) i) \\<and>\n     (gt_diff\n       (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n         (\\<lambda>t s. hsize s < hsize t) i)\n       (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n         (\\<lambda>t s. hsize s < hsize t) (Suc i)) \\<or>\n      gt_same\n       (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n         (\\<lambda>t s. hsize s < hsize t) i)\n       (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n         (\\<lambda>t s. hsize s < hsize t) (Suc i)))\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<forall>i.\n           ground\n            (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n              (\\<lambda>t s. hsize s < hsize t) (i + k)) \\<and>\n           gt_same\n            (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n              (\\<lambda>t s. hsize s < hsize t) (i + k))\n            (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n              (\\<lambda>t s. hsize s < hsize t)\n              (Suc i + k)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  inf_chain (\\<lambda>t s. ground t \\<and> gt_same t s)\n   (\\<lambda>i.\n       worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n        (\\<lambda>t s. hsize s < hsize t) (i + k))\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "hence hd_sym: \"\\<And>i. is_Sym (head (?ff (i + k)))\""], ["proof (prove)\nusing this:\n  inf_chain (\\<lambda>t s. ground t \\<and> gt_same t s)\n   (\\<lambda>i.\n       worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n        (\\<lambda>t s. hsize s < hsize t) (i + k))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       is_Sym\n        (head\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n            (\\<lambda>t s. hsize s < hsize t) (i + k)))", "unfolding inf_chain_def"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     ground\n      (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n        (\\<lambda>t s. hsize s < hsize t) (i + k)) \\<and>\n     gt_same\n      (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n        (\\<lambda>t s. hsize s < hsize t) (i + k))\n      (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n        (\\<lambda>t s. hsize s < hsize t) (Suc i + k))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       is_Sym\n        (head\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n            (\\<lambda>t s. hsize s < hsize t) (i + k)))", "by (simp add: ground_head)"], ["proof (state)\nthis:\n  is_Sym\n   (head\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (?i1 + k)))\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "define f where \"f = sym (head (?ff k))\""], ["proof (state)\nthis:\n  f =\n  hd.sym\n   (head\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) k))\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "have hd_eq_f: \"head (?ff (i + k)) = Sym f\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. head\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (i + k)) =\n    Sym f", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. head\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (0 + k)) =\n    Sym f\n 2. \\<And>i.\n       head\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (i + k)) =\n       Sym f \\<Longrightarrow>\n       head\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (Suc i + k)) =\n       Sym f", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. head\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (0 + k)) =\n    Sym f\n 2. \\<And>i.\n       head\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (i + k)) =\n       Sym f \\<Longrightarrow>\n       head\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (Suc i + k)) =\n       Sym f", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. head\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (0 + k)) =\n    Sym f", "by (auto simp: f_def hd.collapse(2)[OF hd_sym, of 0, simplified])"], ["proof (state)\nthis:\n  head\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) (0 + k)) =\n  Sym f\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       head\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (i + k)) =\n       Sym f \\<Longrightarrow>\n       head\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (Suc i + k)) =\n       Sym f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       head\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (i + k)) =\n       Sym f \\<Longrightarrow>\n       head\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (Suc i + k)) =\n       Sym f", "case (Suc ia)"], ["proof (state)\nthis:\n  head\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) (ia + k)) =\n  Sym f\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       head\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (i + k)) =\n       Sym f \\<Longrightarrow>\n       head\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (Suc i + k)) =\n       Sym f", "thus ?case"], ["proof (prove)\nusing this:\n  head\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) (ia + k)) =\n  Sym f\n\ngoal (1 subgoal):\n 1. head\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (Suc ia + k)) =\n    Sym f", "using bad_same"], ["proof (prove)\nusing this:\n  head\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) (ia + k)) =\n  Sym f\n  inf_chain (\\<lambda>t s. ground t \\<and> gt_same t s)\n   (\\<lambda>i.\n       worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n        (\\<lambda>t s. hsize s < hsize t) (i + k))\n\ngoal (1 subgoal):\n 1. head\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (Suc ia + k)) =\n    Sym f", "unfolding inf_chain_def gt_same.simps"], ["proof (prove)\nusing this:\n  head\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) (ia + k)) =\n  Sym f\n  \\<forall>i.\n     ground\n      (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n        (\\<lambda>t s. hsize s < hsize t) (i + k)) \\<and>\n     (\\<exists>t s.\n         worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (i + k) =\n         t \\<and>\n         worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (Suc i + k) =\n         s \\<and>\n         head t = head s \\<and>\n         chkchop_same (>\\<^sub>t) t s \\<and>\n         (\\<forall>f\\<in>local.ground_heads (head t).\n             extf f (>\\<^sub>t) (args t) (args s)))\n\ngoal (1 subgoal):\n 1. head\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (Suc ia + k)) =\n    Sym f", "by simp"], ["proof (state)\nthis:\n  head\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) (Suc ia + k)) =\n  Sym f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  head\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) (?i1 + k)) =\n  Sym f\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "let ?gtu = \"\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s\""], ["proof (state)\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "thm UnionI CollectI"], ["proof (state)\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "have \"t \\<in> set (args (?ff i)) \\<Longrightarrow> t \\<in> U\" for t i"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> set (args\n                  (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                    (\\<lambda>t s. hsize s < hsize t) i)) \\<Longrightarrow>\n    t \\<in> U", "unfolding U_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> set (args\n                  (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                    (\\<lambda>t s. hsize s < hsize t) i)) \\<Longrightarrow>\n    t \\<in> (\\<Union>i.\n                {u. worst_chain\n                     (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                     (\\<lambda>t s. hsize s < hsize t)\n                     i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\n                    u})", "apply (rule UnionI[of \"?U_of i\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. t \\<in> set (args\n                  (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                    (\\<lambda>t s. hsize s < hsize t) i)) \\<Longrightarrow>\n    {u. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n         (\\<lambda>t s. hsize s < hsize t) i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\n        u}\n    \\<in> range\n           (\\<lambda>i.\n               {u. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                    (\\<lambda>t s. hsize s < hsize t)\n                    i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\n                   u})\n 2. t \\<in> set (args\n                  (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                    (\\<lambda>t s. hsize s < hsize t) i)) \\<Longrightarrow>\n    t \\<in> {u. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                 (\\<lambda>t s. hsize s < hsize t)\n                 i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\n                u}", "using arg_emb CollectI arg_emb hsize_in_args"], ["proof (prove)\nusing this:\n  ?s \\<in> set (args ?t) \\<Longrightarrow>\n  ?t \\<unrhd>\\<^sub>e\\<^sub>m\\<^sub>b ?s\n  ?P ?a \\<Longrightarrow> ?a \\<in> {x. ?P x}\n  ?s \\<in> set (args ?t) \\<Longrightarrow>\n  ?t \\<unrhd>\\<^sub>e\\<^sub>m\\<^sub>b ?s\n  ?s \\<in> set (args ?t) \\<Longrightarrow> hsize ?s < hsize ?t\n\ngoal (2 subgoals):\n 1. t \\<in> set (args\n                  (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                    (\\<lambda>t s. hsize s < hsize t) i)) \\<Longrightarrow>\n    {u. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n         (\\<lambda>t s. hsize s < hsize t) i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\n        u}\n    \\<in> range\n           (\\<lambda>i.\n               {u. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                    (\\<lambda>t s. hsize s < hsize t)\n                    i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\n                   u})\n 2. t \\<in> set (args\n                  (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                    (\\<lambda>t s. hsize s < hsize t) i)) \\<Longrightarrow>\n    t \\<in> {u. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                 (\\<lambda>t s. hsize s < hsize t)\n                 i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\n                u}", "by fast+"], ["proof (state)\nthis:\n  ?t1\n  \\<in> set (args\n              (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                (\\<lambda>t s. hsize s < hsize t) ?i1)) \\<Longrightarrow>\n  ?t1 \\<in> U\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  ?t1\n  \\<in> set (args\n              (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                (\\<lambda>t s. hsize s < hsize t) ?i1)) \\<Longrightarrow>\n  ?t1 \\<in> U\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "have \"\\<And>i. extf f (>\\<^sub>t\\<^sub>g) (args (?ff (i + k))) (args (?ff (Suc i + k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       extf f (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n            (\\<lambda>t s. hsize s < hsize t) (i + k)))\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n            (\\<lambda>t s. hsize s < hsize t) (Suc i + k)))", "using bad_same hd_eq_f"], ["proof (prove)\nusing this:\n  inf_chain (\\<lambda>t s. ground t \\<and> gt_same t s)\n   (\\<lambda>i.\n       worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n        (\\<lambda>t s. hsize s < hsize t) (i + k))\n  head\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) (?i1 + k)) =\n  Sym f\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       extf f (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n            (\\<lambda>t s. hsize s < hsize t) (i + k)))\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n            (\\<lambda>t s. hsize s < hsize t) (Suc i + k)))", "unfolding  inf_chain_def gt_same.simps f_def hd.collapse(2)[OF ground_head, OF gr]"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     ground\n      (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n        (\\<lambda>t s. hsize s < hsize t) (i + k)) \\<and>\n     (\\<exists>t s.\n         worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (i + k) =\n         t \\<and>\n         worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (Suc i + k) =\n         s \\<and>\n         head t = head s \\<and>\n         chkchop_same (>\\<^sub>t) t s \\<and>\n         (\\<forall>f\\<in>local.ground_heads (head t).\n             extf f (>\\<^sub>t) (args t) (args s)))\n  head\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) (?i1 + k)) =\n  head\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) k)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       extf\n        (hd.sym\n          (head\n            (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n              (\\<lambda>t s. hsize s < hsize t) k)))\n        (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n            (\\<lambda>t s. hsize s < hsize t) (i + k)))\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n            (\\<lambda>t s. hsize s < hsize t) (Suc i + k)))", "using extf_mono_strong[of _ _ \"(>\\<^sub>t)\" \"(\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\" ] ground_hd_in_ground_heads"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     ground\n      (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n        (\\<lambda>t s. hsize s < hsize t) (i + k)) \\<and>\n     (\\<exists>t s.\n         worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (i + k) =\n         t \\<and>\n         worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (Suc i + k) =\n         s \\<and>\n         head t = head s \\<and>\n         chkchop_same (>\\<^sub>t) t s \\<and>\n         (\\<forall>f\\<in>local.ground_heads (head t).\n             extf f (>\\<^sub>t) (args t) (args s)))\n  head\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) (?i1 + k)) =\n  head\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n     (\\<lambda>t s. hsize s < hsize t) k)\n  \\<lbrakk>\\<forall>y\\<in>set ?ys.\n              \\<forall>x\\<in>set ?xs.\n                 y >\\<^sub>t x \\<longrightarrow>\n                 ground y \\<and> y >\\<^sub>t x;\n   extf ?f (>\\<^sub>t) ?ys ?xs\\<rbrakk>\n  \\<Longrightarrow> extf ?f (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                     ?ys ?xs\n  ground ?s \\<Longrightarrow>\n  hd.sym (head ?s) \\<in> local.ground_heads (head ?s)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       extf\n        (hd.sym\n          (head\n            (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n              (\\<lambda>t s. hsize s < hsize t) k)))\n        (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n            (\\<lambda>t s. hsize s < hsize t) (i + k)))\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n            (\\<lambda>t s. hsize s < hsize t) (Suc i + k)))", "by (metis (no_types, lifting) ground_args)"], ["proof (state)\nthis:\n  extf f (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (?i1 + k)))\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (Suc ?i1 + k)))\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  ?t1\n  \\<in> set (args\n              (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                (\\<lambda>t s. hsize s < hsize t) ?i1)) \\<Longrightarrow>\n  ?t1 \\<in> U\n  extf f (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (?i1 + k)))\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (Suc ?i1 + k)))", "have \"\\<And>i. extf f ?gtu (args (?ff (i + k))) (args (?ff (Suc i + k)))\""], ["proof (prove)\nusing this:\n  ?t1\n  \\<in> set (args\n              (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                (\\<lambda>t s. hsize s < hsize t) ?i1)) \\<Longrightarrow>\n  ?t1 \\<in> U\n  extf f (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (?i1 + k)))\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (Suc ?i1 + k)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s)\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n            (\\<lambda>t s. hsize s < hsize t) (i + k)))\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n            (\\<lambda>t s. hsize s < hsize t) (Suc i + k)))", "using extf_mono_strong[of _ _ \"(\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\" \"\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s\"]"], ["proof (prove)\nusing this:\n  ?t1\n  \\<in> set (args\n              (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                (\\<lambda>t s. hsize s < hsize t) ?i1)) \\<Longrightarrow>\n  ?t1 \\<in> U\n  extf f (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (?i1 + k)))\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (Suc ?i1 + k)))\n  \\<lbrakk>\\<forall>y\\<in>set ?ys.\n              \\<forall>x\\<in>set ?xs.\n                 ground y \\<and> y >\\<^sub>t x \\<longrightarrow>\n                 y \\<in> U \\<and> y >\\<^sub>t x;\n   extf ?f (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s) ?ys ?xs\\<rbrakk>\n  \\<Longrightarrow> extf ?f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s)\n                     ?ys ?xs\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s)\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n            (\\<lambda>t s. hsize s < hsize t) (i + k)))\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n            (\\<lambda>t s. hsize s < hsize t) (Suc i + k)))", "unfolding U_def"], ["proof (prove)\nusing this:\n  ?t1\n  \\<in> set (args\n              (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                (\\<lambda>t s. hsize s < hsize t) ?i1)) \\<Longrightarrow>\n  ?t1\n  \\<in> (\\<Union>i.\n            {u. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                 (\\<lambda>t s. hsize s < hsize t)\n                 i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\n                u})\n  extf f (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (?i1 + k)))\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (Suc ?i1 + k)))\n  \\<lbrakk>\\<forall>y\\<in>set ?ys.\n              \\<forall>x\\<in>set ?xs.\n                 ground y \\<and> y >\\<^sub>t x \\<longrightarrow>\n                 y \\<in> (\\<Union>i.\n                             {u. worst_chain\n                                  (\\<lambda>t s.\nground t \\<and> t >\\<^sub>t s)\n                                  (\\<lambda>t s. hsize s < hsize t)\n                                  i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\n                                 u}) \\<and>\n                 y >\\<^sub>t x;\n   extf ?f (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s) ?ys ?xs\\<rbrakk>\n  \\<Longrightarrow> extf ?f\n                     (\\<lambda>t s.\n                         t \\<in> (\\<Union>i.\n                                     {u.\nworst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n (\\<lambda>t s. hsize s < hsize t) i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\nu}) \\<and>\n                         t >\\<^sub>t s)\n                     ?ys ?xs\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       extf f\n        (\\<lambda>t s.\n            t \\<in> (\\<Union>i.\n                        {u. worst_chain\n                             (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n                             (\\<lambda>t s. hsize s < hsize t)\n                             i \\<rhd>\\<^sub>e\\<^sub>m\\<^sub>b\n                            u}) \\<and>\n            t >\\<^sub>t s)\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n            (\\<lambda>t s. hsize s < hsize t) (i + k)))\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n            (\\<lambda>t s. hsize s < hsize t) (Suc i + k)))", "by blast"], ["proof (state)\nthis:\n  extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s)\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (?i1 + k)))\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (Suc ?i1 + k)))\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "hence \"inf_chain (extf f ?gtu) (\\<lambda>i. args (?ff (i + k)))\""], ["proof (prove)\nusing this:\n  extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s)\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (?i1 + k)))\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (Suc ?i1 + k)))\n\ngoal (1 subgoal):\n 1. inf_chain (extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s))\n     (\\<lambda>i.\n         args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n            (\\<lambda>t s. hsize s < hsize t) (i + k)))", "unfolding inf_chain_def"], ["proof (prove)\nusing this:\n  extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s)\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (?i1 + k)))\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n       (\\<lambda>t s. hsize s < hsize t) (Suc ?i1 + k)))\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s)\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n            (\\<lambda>t s. hsize s < hsize t) (i + k)))\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n            (\\<lambda>t s. hsize s < hsize t) (Suc i + k)))", "by blast"], ["proof (state)\nthis:\n  inf_chain (extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s))\n   (\\<lambda>i.\n       args\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (i + k)))\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "hence nwf_ext: \"\\<not> wfP (\\<lambda>xs ys. extf f ?gtu ys xs)\""], ["proof (prove)\nusing this:\n  inf_chain (extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s))\n   (\\<lambda>i.\n       args\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (i + k)))\n\ngoal (1 subgoal):\n 1. \\<not> wfP (\\<lambda>xs ys.\n                   extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s) ys\n                    xs)", "unfolding wfP_iff_no_inf_chain"], ["proof (prove)\nusing this:\n  inf_chain (extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s))\n   (\\<lambda>i.\n       args\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n          (\\<lambda>t s. hsize s < hsize t) (i + k)))\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> Ex (inf_chain\n                       (extf f\n                         (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s)))", "by fast"], ["proof (state)\nthis:\n  \\<not> wfP (\\<lambda>xs ys.\n                 extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s) ys\n                  xs)\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "have gtu_le_gtg: \"?gtu \\<le> (>\\<^sub>t\\<^sub>g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s)\n    \\<le> (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)", "by (auto intro!: gr_u)"], ["proof (state)\nthis:\n  (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s)\n  \\<le> (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "have \"wfP (\\<lambda>s t. ?gtu t s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP (\\<lambda>s t. t \\<in> U \\<and> t >\\<^sub>t s)", "unfolding wfP_iff_no_inf_chain"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Ex (inf_chain (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s))", "proof (intro notI, elim exE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       inf_chain (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s)\n        x \\<Longrightarrow>\n       False", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       inf_chain (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s)\n        x \\<Longrightarrow>\n       False", "assume bad_f: \"inf_chain ?gtu f\""], ["proof (state)\nthis:\n  inf_chain (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s) f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       inf_chain (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s)\n        x \\<Longrightarrow>\n       False", "hence bad_f0: \"bad ?gtu (f 0)\""], ["proof (prove)\nusing this:\n  inf_chain (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s) f\n\ngoal (1 subgoal):\n 1. bad (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s) (f 0)", "by (rule inf_chain_bad)"], ["proof (state)\nthis:\n  bad (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s) (f 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       inf_chain (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s)\n        x \\<Longrightarrow>\n       False", "have \"f 0 \\<in> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f 0 \\<in> U", "using bad_f"], ["proof (prove)\nusing this:\n  inf_chain (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s) f\n\ngoal (1 subgoal):\n 1. f 0 \\<in> U", "unfolding inf_chain_def"], ["proof (prove)\nusing this:\n  \\<forall>i. f i \\<in> U \\<and> f i >\\<^sub>t f (Suc i)\n\ngoal (1 subgoal):\n 1. f 0 \\<in> U", "by blast"], ["proof (state)\nthis:\n  f 0 \\<in> U\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       inf_chain (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s)\n        x \\<Longrightarrow>\n       False", "hence good_f0: \"\\<not> bad ?gtu (f 0)\""], ["proof (prove)\nusing this:\n  f 0 \\<in> U\n\ngoal (1 subgoal):\n 1. \\<not> bad (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s) (f 0)", "using u_good bad_f inf_chain_bad inf_chain_subset[OF _ gtu_le_gtg]"], ["proof (prove)\nusing this:\n  f 0 \\<in> U\n  ?u \\<in> U \\<Longrightarrow>\n  \\<not> bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s) ?u\n  inf_chain (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s) f\n  inf_chain ?p ?f \\<Longrightarrow> bad ?p (?f ?i)\n  inf_chain (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s)\n   ?f \\<Longrightarrow>\n  inf_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s) ?f\n\ngoal (1 subgoal):\n 1. \\<not> bad (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s) (f 0)", "by blast"], ["proof (state)\nthis:\n  \\<not> bad (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s) (f 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       inf_chain (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s)\n        x \\<Longrightarrow>\n       False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using bad_f0 good_f0"], ["proof (prove)\nusing this:\n  bad (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s) (f 0)\n  \\<not> bad (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s) (f 0)\n\ngoal (1 subgoal):\n 1. False", "by sat"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wfP (\\<lambda>s t. t \\<in> U \\<and> t >\\<^sub>t s)\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "hence wf_ext: \"wfP (\\<lambda>xs ys. extf f ?gtu ys xs)\""], ["proof (prove)\nusing this:\n  wfP (\\<lambda>s t. t \\<in> U \\<and> t >\\<^sub>t s)\n\ngoal (1 subgoal):\n 1. wfP (\\<lambda>xs ys.\n            extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s) ys xs)", "by (rule ext_wf.wf[OF extf_wf, rule_format])"], ["proof (state)\nthis:\n  wfP (\\<lambda>xs ys.\n          extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s) ys xs)\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s. ground t \\<and> t >\\<^sub>t s)) \\<Longrightarrow>\n    False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using nwf_ext wf_ext"], ["proof (prove)\nusing this:\n  \\<not> wfP (\\<lambda>xs ys.\n                 extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s) ys\n                  xs)\n  wfP (\\<lambda>xs ys.\n          extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t s) ys xs)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wfP (\\<lambda>s t. ground t \\<and> t >\\<^sub>t s)\n\ngoal (1 subgoal):\n 1. wfP (\\<lambda>s t. t >\\<^sub>t s)", "let ?subst = \"subst grounding_\\<rho>\""], ["proof (state)\ngoal (1 subgoal):\n 1. wfP (\\<lambda>s t. t >\\<^sub>t s)", "have \"wfP (\\<lambda>s t. ?subst t >\\<^sub>t\\<^sub>g ?subst s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP (\\<lambda>s t.\n            ground (subst grounding_\\<rho> t) \\<and>\n            subst grounding_\\<rho> t >\\<^sub>t subst grounding_\\<rho> s)", "by (rule wfP_app[OF ground_wfP])"], ["proof (state)\nthis:\n  wfP (\\<lambda>s t.\n          ground (subst grounding_\\<rho> t) \\<and>\n          subst grounding_\\<rho> t >\\<^sub>t subst grounding_\\<rho> s)\n\ngoal (1 subgoal):\n 1. wfP (\\<lambda>s t. t >\\<^sub>t s)", "hence \"wfP (\\<lambda>s t. ?subst t >\\<^sub>t ?subst s)\""], ["proof (prove)\nusing this:\n  wfP (\\<lambda>s t.\n          ground (subst grounding_\\<rho> t) \\<and>\n          subst grounding_\\<rho> t >\\<^sub>t subst grounding_\\<rho> s)\n\ngoal (1 subgoal):\n 1. wfP (\\<lambda>s t.\n            subst grounding_\\<rho> t >\\<^sub>t subst grounding_\\<rho> s)", "by (simp add: ground_grounding_\\<rho>)"], ["proof (state)\nthis:\n  wfP (\\<lambda>s t.\n          subst grounding_\\<rho> t >\\<^sub>t subst grounding_\\<rho> s)\n\ngoal (1 subgoal):\n 1. wfP (\\<lambda>s t. t >\\<^sub>t s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  wfP (\\<lambda>s t.\n          subst grounding_\\<rho> t >\\<^sub>t subst grounding_\\<rho> s)\n\ngoal (1 subgoal):\n 1. wfP (\\<lambda>s t. t >\\<^sub>t s)", "using gt_sus ghd_UNIV ground_heads.simps(1) wary_grounding_\\<rho> wfP_eq_minimal"], ["proof (prove)\nusing this:\n  wfP (\\<lambda>s t.\n          subst grounding_\\<rho> t >\\<^sub>t subst grounding_\\<rho> s)\n  \\<lbrakk>wary_subst ?\\<rho>; \\<And>x. local.ground_heads (Var x) = UNIV;\n   ?t >\\<^sub>t ?s\\<rbrakk>\n  \\<Longrightarrow> subst ?\\<rho> ?t >\\<^sub>t subst ?\\<rho> ?s\n  ground_heads_var ?x = UNIV\n  local.ground_heads (Var ?x) = ground_heads_var ?x\n  wary_subst grounding_\\<rho>\n  wfP ?r =\n  (\\<forall>Q x.\n      x \\<in> Q \\<longrightarrow>\n      (\\<exists>z\\<in>Q. \\<forall>y. ?r y z \\<longrightarrow> y \\<notin> Q))\n\ngoal (1 subgoal):\n 1. wfP (\\<lambda>s t. t >\\<^sub>t s)", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  wfP (\\<lambda>s t. t >\\<^sub>t s)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}