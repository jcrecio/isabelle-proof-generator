{"file_name": "/home/qj213/afp-2021-10-22/thys/Lambda_Free_EPO/Chop.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Lambda_Free_EPO", "problem_names": ["lemma chop_App_Hd: \"is_Hd s \\<Longrightarrow> chop (App s t) = t\"", "lemma chop_apps: \"is_App t \\<Longrightarrow> chop (apps t ts) = apps (chop t) ts\"", "lemma vars_chop: \"is_App t \\<Longrightarrow> vars (chop t) \\<union> vars_hd (head t) = vars t\"", "lemma ground_chop: \"is_App t \\<Longrightarrow> ground t \\<Longrightarrow> ground (chop t)\"", "lemma hsize_chop: \"is_App t \\<Longrightarrow> (Suc (hsize (chop t))) = hsize t\"", "lemma hsize_chop_lt: \"is_App t \\<Longrightarrow> hsize (chop t) < hsize t\"", "lemma chop_fun:\n  assumes \"is_App t\" \"is_App (fun t)\" \n  shows \"App (chop (fun t)) (arg t) = chop t\"", "lemma emb_step_chop: \"is_App t \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t\"", "lemma chop_emb_step_at:\n  assumes \"is_App t\"\n  shows \"chop t = emb_step_at (replicate (num_args (fun t)) Left) Right t\"", "lemma emb_step_at_chop:\n  assumes emb_step_at: \"emb_step_at p Right t = s\"\n    and pos:\"position_of t (p @ [Right])\"\n    and all_Left: \"list_all (\\<lambda>x. x = Left) p\"\n  shows \"chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\"", "lemma emb_step_at_remove_arg:\n  assumes emb_step_at: \"emb_step_at p Left t = s\"\n    and pos:\"position_of t (p @ [Left])\"\n    and all_Left: \"list_all (\\<lambda>x. x = Left) p\"\n  shows \"let i = num_args t - Suc (length p) in \n  head t = head s \\<and> i < num_args t \\<and> args s = take i (args t) @ drop (Suc i) (args t)\"", "lemma emb_step_cases [consumes 1, case_names chop extended_chop remove_arg under_arg]:\n  assumes emb:\"t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\"\n    and chop:\"chop t = s \\<Longrightarrow> P\"\n    and extended_chop:\"chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s \\<Longrightarrow> P\"\n    and remove_arg:\"\\<And>i. head t = head s \\<Longrightarrow> i<num_args t \\<Longrightarrow> args s = take i (args t) @ drop (Suc i) (args t) \\<Longrightarrow> P\"\n    and under_arg:\"\\<And>i. head t = head s \\<Longrightarrow> num_args t = num_args s \\<Longrightarrow> args t ! i \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b args s ! i \\<Longrightarrow>\n         (\\<And>j. j<num_args t \\<Longrightarrow> i \\<noteq> j \\<Longrightarrow> args t ! j = args s ! j) \\<Longrightarrow> P\"\n  shows P", "lemma chop_position_of:\n  assumes \"is_App s\"\n  shows \"position_of s (replicate (num_args (fun s)) dir.Left @ [Right])\"", "lemma Suc_num_args: \"is_App t \\<Longrightarrow> Suc (num_args (fun t)) = num_args t\"", "lemma fun_subst: \"is_App s \\<Longrightarrow> subst \\<rho> (fun s) = fun (subst \\<rho> s)\"", "lemma args_subst_Hd:\n  assumes \"is_Hd (subst \\<rho> (Hd (head s)))\"\n  shows  \"args (subst \\<rho> s) = map (subst \\<rho>) (args s)\"", "lemma chop_subst_emb0:\n  assumes \"is_App s\"\n  assumes \"chop (subst \\<rho> s) \\<noteq> subst \\<rho> (chop s)\"\n  shows \"emb_step_at (replicate (num_args (fun s)) Left) Right (chop (subst \\<rho> s)) = subst \\<rho> (chop s)\"", "lemma chop_subst_emb:\n  assumes \"is_App s\"\n  shows \"chop (subst \\<rho> s) \\<unrhd>\\<^sub>e\\<^sub>m\\<^sub>b subst \\<rho> (chop s)\"", "lemma chop_subst_Hd:\n  assumes \"is_App s\"\n  assumes \"is_Hd (subst \\<rho> (Hd (head s)))\"\n  shows \"chop (subst \\<rho> s) = subst \\<rho> (chop s)\"", "lemma chop_subst_Sym:\n  assumes \"is_App s\"\n  assumes \"is_Sym (head s)\"\n  shows \"chop (subst \\<rho> s) = subst \\<rho> (chop s)\""], "translations": [["", "lemma chop_App_Hd: \"is_Hd s \\<Longrightarrow> chop (App s t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Hd s \\<Longrightarrow> chop (App s t) = t", "unfolding chop_def args.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Hd s \\<Longrightarrow>\n    apps (hd (args s @ [t])) (tl (args s @ [t])) = t", "using args_Nil_iff_is_Hd"], ["proof (prove)\nusing this:\n  (args ?s = []) = is_Hd ?s\n\ngoal (1 subgoal):\n 1. is_Hd s \\<Longrightarrow>\n    apps (hd (args s @ [t])) (tl (args s @ [t])) = t", "by force"], ["", "lemma chop_apps: \"is_App t \\<Longrightarrow> chop (apps t ts) = apps (chop t) ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_App t \\<Longrightarrow> chop (apps t ts) = apps (chop t) ts", "unfolding chop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_App t \\<Longrightarrow>\n    apps (hd (args (apps t ts))) (tl (args (apps t ts))) =\n    apps (apps (hd (args t)) (tl (args t))) ts", "by (simp add: args_Nil_iff_is_Hd)"], ["", "lemma vars_chop: \"is_App t \\<Longrightarrow> vars (chop t) \\<union> vars_hd (head t) = vars t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_App t \\<Longrightarrow>\n    vars (chop t) \\<union> vars_hd (head t) = vars t", "by (induct rule:tm_induct_apps; metis (no_types, lifting) chop_def UN_insert Un_commute list.exhaust_sel list.simps(15)\n      args_Nil_iff_is_Hd tm.simps(17) tm_exhaust_apps_sel vars_apps)"], ["", "lemma ground_chop: \"is_App t \\<Longrightarrow> ground t \\<Longrightarrow> ground (chop t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_App t; ground t\\<rbrakk> \\<Longrightarrow> ground (chop t)", "using vars_chop"], ["proof (prove)\nusing this:\n  is_App ?t \\<Longrightarrow>\n  vars (chop ?t) \\<union> vars_hd (head ?t) = vars ?t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_App t; ground t\\<rbrakk> \\<Longrightarrow> ground (chop t)", "by auto"], ["", "lemma hsize_chop: \"is_App t \\<Longrightarrow> (Suc (hsize (chop t))) = hsize t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_App t \\<Longrightarrow> Suc (hsize (chop t)) = hsize t", "unfolding hsize_args[of t, symmetric] chop_def hsize_apps"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_App t \\<Longrightarrow>\n    Suc (hsize (hd (args t)) + sum_list (map hsize (tl (args t)))) =\n    1 + sum_list (map hsize (args t))", "by (metis Nil_is_map_conv args_Nil_iff_is_Hd list.exhaust_sel list.map_sel(1) map_tl plus_1_eq_Suc sum_list.Cons)"], ["", "lemma hsize_chop_lt: \"is_App t \\<Longrightarrow> hsize (chop t) < hsize t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_App t \\<Longrightarrow> hsize (chop t) < hsize t", "by (simp add: Suc_le_lessD less_or_eq_imp_le hsize_chop)"], ["", "lemma chop_fun:\n  assumes \"is_App t\" \"is_App (fun t)\" \n  shows \"App (chop (fun t)) (arg t) = chop t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. App (chop (fun t)) (arg t) = chop t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. App (chop (fun t)) (arg t) = chop t", "have \"args (fun t) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. args (fun t) \\<noteq> []", "using assms(2) args_Nil_iff_is_Hd"], ["proof (prove)\nusing this:\n  is_App (fun t)\n  (args ?s = []) = is_Hd ?s\n\ngoal (1 subgoal):\n 1. args (fun t) \\<noteq> []", "by blast"], ["proof (state)\nthis:\n  args (fun t) \\<noteq> []\n\ngoal (1 subgoal):\n 1. App (chop (fun t)) (arg t) = chop t", "then"], ["proof (chain)\npicking this:\n  args (fun t) \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  args (fun t) \\<noteq> []\n\ngoal (1 subgoal):\n 1. App (chop (fun t)) (arg t) = chop t", "unfolding chop_def"], ["proof (prove)\nusing this:\n  args (fun t) \\<noteq> []\n\ngoal (1 subgoal):\n 1. App (apps (hd (args (fun t))) (tl (args (fun t)))) (arg t) =\n    apps (hd (args t)) (tl (args t))", "using assms(1)"], ["proof (prove)\nusing this:\n  args (fun t) \\<noteq> []\n  is_App t\n\ngoal (1 subgoal):\n 1. App (apps (hd (args (fun t))) (tl (args (fun t)))) (arg t) =\n    apps (hd (args t)) (tl (args t))", "by (metis (no_types) App_apps args.simps(2) hd_append2 tl_append2 tm.collapse(2))"], ["proof (state)\nthis:\n  App (chop (fun t)) (arg t) = chop t\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Chop and the Embedding Relation\\<close>"], ["", "lemma emb_step_chop: \"is_App t \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_App t \\<Longrightarrow>\n    t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t", "proof (induct \"num_args t - 1\" arbitrary:t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 = num_args t - 1; is_App t\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t\n 2. \\<And>x t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>x = num_args t - 1; is_App t\\<rbrakk>\n                   \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b\n                                     chop t;\n        Suc x = num_args t - 1; is_App t\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t", "case 0"], ["proof (state)\nthis:\n  0 = num_args t - 1\n  is_App t\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 = num_args t - 1; is_App t\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t\n 2. \\<And>x t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>x = num_args t - 1; is_App t\\<rbrakk>\n                   \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b\n                                     chop t;\n        Suc x = num_args t - 1; is_App t\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t", "have nil: \"num_args t = 0 \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_args t = 0 \\<Longrightarrow>\n    t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t", "unfolding chop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. num_args t = 0 \\<Longrightarrow>\n    t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b apps (hd (args t)) (tl (args t))", "using 0 args_Nil_iff_is_Hd"], ["proof (prove)\nusing this:\n  0 = num_args t - 1\n  is_App t\n  (args ?s = []) = is_Hd ?s\n\ngoal (1 subgoal):\n 1. num_args t = 0 \\<Longrightarrow>\n    t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b apps (hd (args t)) (tl (args t))", "by force"], ["proof (state)\nthis:\n  num_args t = 0 \\<Longrightarrow>\n  t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 = num_args t - 1; is_App t\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t\n 2. \\<And>x t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>x = num_args t - 1; is_App t\\<rbrakk>\n                   \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b\n                                     chop t;\n        Suc x = num_args t - 1; is_App t\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t", "have single: \"\\<And>a. args t = [a] \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       args t = [a] \\<Longrightarrow>\n       t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t", "unfolding chop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       args t = [a] \\<Longrightarrow>\n       t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b\n       apps (hd (args t)) (tl (args t))", "by (metis \"0.prems\" apps.simps(1) args.elims args_Nil_iff_is_Hd emb_step_arg last.simps last_snoc list.sel(1) list.sel(3) tm.sel(6))"], ["proof (state)\nthis:\n  args t = [?a] \\<Longrightarrow>\n  t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 = num_args t - 1; is_App t\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t\n 2. \\<And>x t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>x = num_args t - 1; is_App t\\<rbrakk>\n                   \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b\n                                     chop t;\n        Suc x = num_args t - 1; is_App t\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t", "then"], ["proof (chain)\npicking this:\n  args t = [?a] \\<Longrightarrow>\n  t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t", "show ?case"], ["proof (prove)\nusing this:\n  args t = [?a] \\<Longrightarrow>\n  t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t", "using nil single"], ["proof (prove)\nusing this:\n  args t = [?a] \\<Longrightarrow>\n  t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t\n  num_args t = 0 \\<Longrightarrow>\n  t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t\n  args t = [?a] \\<Longrightarrow>\n  t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t", "by (metis \"0.hyps\" length_0_conv length_tl list.exhaust_sel)"], ["proof (state)\nthis:\n  t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t\n\ngoal (1 subgoal):\n 1. \\<And>x t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>x = num_args t - 1; is_App t\\<rbrakk>\n                   \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b\n                                     chop t;\n        Suc x = num_args t - 1; is_App t\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>x = num_args t - 1; is_App t\\<rbrakk>\n                   \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b\n                                     chop t;\n        Suc x = num_args t - 1; is_App t\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t", "case (Suc x)"], ["proof (state)\nthis:\n  \\<lbrakk>x = num_args ?t - 1; is_App ?t\\<rbrakk>\n  \\<Longrightarrow> ?t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop ?t\n  Suc x = num_args t - 1\n  is_App t\n\ngoal (1 subgoal):\n 1. \\<And>x t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>x = num_args t - 1; is_App t\\<rbrakk>\n                   \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b\n                                     chop t;\n        Suc x = num_args t - 1; is_App t\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t", "have 1:\"apps (Hd (head t)) (butlast (args t)) \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop (apps (Hd (head t)) (butlast (args t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apps (Hd (head t))\n     (butlast (args t)) \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b\n    chop (apps (Hd (head t)) (butlast (args t)))", "using Suc(1)[of \"apps (Hd (head t)) (butlast (args t))\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>x = num_args (apps (Hd (head t)) (butlast (args t))) - 1;\n   is_App (apps (Hd (head t)) (butlast (args t)))\\<rbrakk>\n  \\<Longrightarrow> apps (Hd (head t))\n                     (butlast\n                       (args t)) \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b\n                    chop (apps (Hd (head t)) (butlast (args t)))\n\ngoal (1 subgoal):\n 1. apps (Hd (head t))\n     (butlast (args t)) \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b\n    chop (apps (Hd (head t)) (butlast (args t)))", "by (metis Suc.hyps(2) Suc_eq_plus1 add_diff_cancel_right' args_Nil_iff_is_Hd length_butlast list.size(3) nat.distinct(1) tm_exhaust_apps_sel tm_inject_apps)"], ["proof (state)\nthis:\n  apps (Hd (head t))\n   (butlast (args t)) \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b\n  chop (apps (Hd (head t)) (butlast (args t)))\n\ngoal (1 subgoal):\n 1. \\<And>x t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>x = num_args t - 1; is_App t\\<rbrakk>\n                   \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b\n                                     chop t;\n        Suc x = num_args t - 1; is_App t\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t", "have 2:\"App (apps (Hd (head t)) (butlast (args t))) (last (args t)) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. App (apps (Hd (head t)) (butlast (args t))) (last (args t)) = t", "by (simp add: App_apps Suc.prems args_Nil_iff_is_Hd)"], ["proof (state)\nthis:\n  App (apps (Hd (head t)) (butlast (args t))) (last (args t)) = t\n\ngoal (1 subgoal):\n 1. \\<And>x t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>x = num_args t - 1; is_App t\\<rbrakk>\n                   \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b\n                                     chop t;\n        Suc x = num_args t - 1; is_App t\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t", "have 3:\"App (chop (apps (Hd (head t)) (butlast (args t)))) (last (args t)) = chop t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. App (chop (apps (Hd (head t)) (butlast (args t)))) (last (args t)) =\n    chop t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. App (chop (apps (Hd (head t)) (butlast (args t)))) (last (args t)) =\n    chop t", "have f1: \"hd (args t) = hd (butlast (args t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (args t) = hd (butlast (args t))", "by (metis Suc.hyps(2) Suc.prems append_butlast_last_id args_Nil_iff_is_Hd hd_append2 length_0_conv length_butlast nat.simps(3))"], ["proof (state)\nthis:\n  hd (args t) = hd (butlast (args t))\n\ngoal (1 subgoal):\n 1. App (chop (apps (Hd (head t)) (butlast (args t)))) (last (args t)) =\n    chop t", "have \"tl (args t) = tl (butlast (args t)) @ [last (args t)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (args t) = tl (butlast (args t)) @ [last (args t)]", "by (metis (no_types) Suc.hyps(2) Suc.prems append_butlast_last_id args_Nil_iff_is_Hd length_0_conv length_butlast nat.simps(3) tl_append2)"], ["proof (state)\nthis:\n  tl (args t) = tl (butlast (args t)) @ [last (args t)]\n\ngoal (1 subgoal):\n 1. App (chop (apps (Hd (head t)) (butlast (args t)))) (last (args t)) =\n    chop t", "then"], ["proof (chain)\npicking this:\n  tl (args t) = tl (butlast (args t)) @ [last (args t)]", "show ?thesis"], ["proof (prove)\nusing this:\n  tl (args t) = tl (butlast (args t)) @ [last (args t)]\n\ngoal (1 subgoal):\n 1. App (chop (apps (Hd (head t)) (butlast (args t)))) (last (args t)) =\n    chop t", "using f1 chop_def"], ["proof (prove)\nusing this:\n  tl (args t) = tl (butlast (args t)) @ [last (args t)]\n  hd (args t) = hd (butlast (args t))\n  chop ?t = apps (hd (args ?t)) (tl (args ?t))\n\ngoal (1 subgoal):\n 1. App (chop (apps (Hd (head t)) (butlast (args t)))) (last (args t)) =\n    chop t", "by (metis App_apps append_Nil args.simps(1) args_apps)"], ["proof (state)\nthis:\n  App (chop (apps (Hd (head t)) (butlast (args t)))) (last (args t)) =\n  chop t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  App (chop (apps (Hd (head t)) (butlast (args t)))) (last (args t)) =\n  chop t\n\ngoal (1 subgoal):\n 1. \\<And>x t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>x = num_args t - 1; is_App t\\<rbrakk>\n                   \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b\n                                     chop t;\n        Suc x = num_args t - 1; is_App t\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t", "then"], ["proof (chain)\npicking this:\n  App (chop (apps (Hd (head t)) (butlast (args t)))) (last (args t)) =\n  chop t", "show ?case"], ["proof (prove)\nusing this:\n  App (chop (apps (Hd (head t)) (butlast (args t)))) (last (args t)) =\n  chop t\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t", "using 1 2 3"], ["proof (prove)\nusing this:\n  App (chop (apps (Hd (head t)) (butlast (args t)))) (last (args t)) =\n  chop t\n  apps (Hd (head t))\n   (butlast (args t)) \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b\n  chop (apps (Hd (head t)) (butlast (args t)))\n  App (apps (Hd (head t)) (butlast (args t))) (last (args t)) = t\n  App (chop (apps (Hd (head t)) (butlast (args t)))) (last (args t)) =\n  chop t\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t", "by (metis context_left)"], ["proof (state)\nthis:\n  t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b chop t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chop_emb_step_at:\n  assumes \"is_App t\"\n  shows \"chop t = emb_step_at (replicate (num_args (fun t)) Left) Right t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chop t = emb_step_at (replicate (num_args (fun t)) dir.Left) dir.Right t", "using assms"], ["proof (prove)\nusing this:\n  is_App t\n\ngoal (1 subgoal):\n 1. chop t = emb_step_at (replicate (num_args (fun t)) dir.Left) dir.Right t", "proof (induct \"num_args (fun t)\" arbitrary: t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 = num_args (fun t); is_App t\\<rbrakk>\n       \\<Longrightarrow> chop t =\n                         emb_step_at (replicate (num_args (fun t)) dir.Left)\n                          dir.Right t\n 2. \\<And>x t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>x = num_args (fun t); is_App t\\<rbrakk>\n                   \\<Longrightarrow> chop t =\n                                     emb_step_at\n(replicate (num_args (fun t)) dir.Left) dir.Right t;\n        Suc x = num_args (fun t); is_App t\\<rbrakk>\n       \\<Longrightarrow> chop t =\n                         emb_step_at (replicate (num_args (fun t)) dir.Left)\n                          dir.Right t", "case 0"], ["proof (state)\nthis:\n  0 = num_args (fun t)\n  is_App t\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 = num_args (fun t); is_App t\\<rbrakk>\n       \\<Longrightarrow> chop t =\n                         emb_step_at (replicate (num_args (fun t)) dir.Left)\n                          dir.Right t\n 2. \\<And>x t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>x = num_args (fun t); is_App t\\<rbrakk>\n                   \\<Longrightarrow> chop t =\n                                     emb_step_at\n(replicate (num_args (fun t)) dir.Left) dir.Right t;\n        Suc x = num_args (fun t); is_App t\\<rbrakk>\n       \\<Longrightarrow> chop t =\n                         emb_step_at (replicate (num_args (fun t)) dir.Left)\n                          dir.Right t", "then"], ["proof (chain)\npicking this:\n  0 = num_args (fun t)\n  is_App t", "have rep_Nil:\"replicate (num_args (fun t)) dir.Left = []\""], ["proof (prove)\nusing this:\n  0 = num_args (fun t)\n  is_App t\n\ngoal (1 subgoal):\n 1. replicate (num_args (fun t)) dir.Left = []", "by simp"], ["proof (state)\nthis:\n  replicate (num_args (fun t)) dir.Left = []\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 = num_args (fun t); is_App t\\<rbrakk>\n       \\<Longrightarrow> chop t =\n                         emb_step_at (replicate (num_args (fun t)) dir.Left)\n                          dir.Right t\n 2. \\<And>x t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>x = num_args (fun t); is_App t\\<rbrakk>\n                   \\<Longrightarrow> chop t =\n                                     emb_step_at\n(replicate (num_args (fun t)) dir.Left) dir.Right t;\n        Suc x = num_args (fun t); is_App t\\<rbrakk>\n       \\<Longrightarrow> chop t =\n                         emb_step_at (replicate (num_args (fun t)) dir.Left)\n                          dir.Right t", "then"], ["proof (chain)\npicking this:\n  replicate (num_args (fun t)) dir.Left = []", "show ?case"], ["proof (prove)\nusing this:\n  replicate (num_args (fun t)) dir.Left = []\n\ngoal (1 subgoal):\n 1. chop t = emb_step_at (replicate (num_args (fun t)) dir.Left) dir.Right t", "unfolding rep_Nil"], ["proof (prove)\nusing this:\n  [] = []\n\ngoal (1 subgoal):\n 1. chop t = emb_step_at [] dir.Right t", "by (metis \"0.hyps\" \"0.prems\" emb_step_at_right append_Nil apps.simps(1) args.simps(2) chop_def length_0_conv list.sel(1) list.sel(3) tm.collapse(2))"], ["proof (state)\nthis:\n  chop t = emb_step_at (replicate (num_args (fun t)) dir.Left) dir.Right t\n\ngoal (1 subgoal):\n 1. \\<And>x t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>x = num_args (fun t); is_App t\\<rbrakk>\n                   \\<Longrightarrow> chop t =\n                                     emb_step_at\n(replicate (num_args (fun t)) dir.Left) dir.Right t;\n        Suc x = num_args (fun t); is_App t\\<rbrakk>\n       \\<Longrightarrow> chop t =\n                         emb_step_at (replicate (num_args (fun t)) dir.Left)\n                          dir.Right t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>x = num_args (fun t); is_App t\\<rbrakk>\n                   \\<Longrightarrow> chop t =\n                                     emb_step_at\n(replicate (num_args (fun t)) dir.Left) dir.Right t;\n        Suc x = num_args (fun t); is_App t\\<rbrakk>\n       \\<Longrightarrow> chop t =\n                         emb_step_at (replicate (num_args (fun t)) dir.Left)\n                          dir.Right t", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>n = num_args (fun ?t); is_App ?t\\<rbrakk>\n  \\<Longrightarrow> chop ?t =\n                    emb_step_at (replicate (num_args (fun ?t)) dir.Left)\n                     dir.Right ?t\n  Suc n = num_args (fun t)\n  is_App t\n\ngoal (1 subgoal):\n 1. \\<And>x t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>x = num_args (fun t); is_App t\\<rbrakk>\n                   \\<Longrightarrow> chop t =\n                                     emb_step_at\n(replicate (num_args (fun t)) dir.Left) dir.Right t;\n        Suc x = num_args (fun t); is_App t\\<rbrakk>\n       \\<Longrightarrow> chop t =\n                         emb_step_at (replicate (num_args (fun t)) dir.Left)\n                          dir.Right t", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>n = num_args (fun ?t); is_App ?t\\<rbrakk>\n  \\<Longrightarrow> chop ?t =\n                    emb_step_at (replicate (num_args (fun ?t)) dir.Left)\n                     dir.Right ?t\n  Suc n = num_args (fun t)\n  is_App t", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>n = num_args (fun ?t); is_App ?t\\<rbrakk>\n  \\<Longrightarrow> chop ?t =\n                    emb_step_at (replicate (num_args (fun ?t)) dir.Left)\n                     dir.Right ?t\n  Suc n = num_args (fun t)\n  is_App t\n\ngoal (1 subgoal):\n 1. chop t = emb_step_at (replicate (num_args (fun t)) dir.Left) dir.Right t", "using Suc.hyps(1)[of \"fun t\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>n = num_args (fun ?t); is_App ?t\\<rbrakk>\n  \\<Longrightarrow> chop ?t =\n                    emb_step_at (replicate (num_args (fun ?t)) dir.Left)\n                     dir.Right ?t\n  Suc n = num_args (fun t)\n  is_App t\n  \\<lbrakk>n = num_args (fun (fun t)); is_App (fun t)\\<rbrakk>\n  \\<Longrightarrow> chop (fun t) =\n                    emb_step_at\n                     (replicate (num_args (fun (fun t))) dir.Left) dir.Right\n                     (fun t)\n\ngoal (1 subgoal):\n 1. chop t = emb_step_at (replicate (num_args (fun t)) dir.Left) dir.Right t", "using emb_step_at_left_context args.elims args_Nil_iff_is_Hd chop_fun butlast_snoc diff_Suc_1 length_0_conv length_butlast nat.distinct(1) replicate_Suc tm.collapse(2) tm.sel(4)"], ["proof (prove)\nusing this:\n  \\<lbrakk>n = num_args (fun ?t); is_App ?t\\<rbrakk>\n  \\<Longrightarrow> chop ?t =\n                    emb_step_at (replicate (num_args (fun ?t)) dir.Left)\n                     dir.Right ?t\n  Suc n = num_args (fun t)\n  is_App t\n  \\<lbrakk>n = num_args (fun (fun t)); is_App (fun t)\\<rbrakk>\n  \\<Longrightarrow> chop (fun t) =\n                    emb_step_at\n                     (replicate (num_args (fun (fun t))) dir.Left) dir.Right\n                     (fun t)\n  emb_step_at (dir.Left # ?p) ?dir (App ?t ?s) =\n  App (emb_step_at ?p ?dir ?t) ?s\n  \\<lbrakk>args ?x = ?y;\n   \\<And>uu_. \\<lbrakk>?x = Hd uu_; ?y = []\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>s t.\n      \\<lbrakk>?x = App s t; ?y = args s @ [t]\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  (args ?s = []) = is_Hd ?s\n  \\<lbrakk>is_App ?t; is_App (fun ?t)\\<rbrakk>\n  \\<Longrightarrow> App (chop (fun ?t)) (arg ?t) = chop ?t\n  butlast (?xs @ [?x]) = ?xs\n  Suc ?n - 1 = ?n\n  (length ?xs = 0) = (?xs = [])\n  length (butlast ?xs) = length ?xs - 1\n  0 \\<noteq> Suc ?x2.0\n  replicate (Suc ?n) ?x = ?x # replicate ?n ?x\n  is_App ?tm \\<Longrightarrow> App (fun ?tm) (arg ?tm) = ?tm\n  fun (App ?x21.0 ?x22.0) = ?x21.0\n\ngoal (1 subgoal):\n 1. chop t = emb_step_at (replicate (num_args (fun t)) dir.Left) dir.Right t", "by metis"], ["proof (state)\nthis:\n  chop t = emb_step_at (replicate (num_args (fun t)) dir.Left) dir.Right t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma emb_step_at_chop:\n  assumes emb_step_at: \"emb_step_at p Right t = s\"\n    and pos:\"position_of t (p @ [Right])\"\n    and all_Left: \"list_all (\\<lambda>x. x = Left) p\"\n  shows \"chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s", "have \"is_App t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_App t", "by (metis emb_step_at_if_position emb_step_at_is_App emb_step_equiv pos)"], ["proof (state)\nthis:\n  is_App t\n\ngoal (1 subgoal):\n 1. chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s", "have p_replicate: \"replicate (length p) Left = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate (length p) dir.Left = p", "using replicate_length_same[of p Left]"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set p. y = dir.Left \\<Longrightarrow>\n  replicate (length p) dir.Left = p\n\ngoal (1 subgoal):\n 1. replicate (length p) dir.Left = p", "by (simp add: Ball_set all_Left)"], ["proof (state)\nthis:\n  replicate (length p) dir.Left = p\n\ngoal (1 subgoal):\n 1. chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s", "proof (cases \"Suc (length p) = num_args t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc (length p) = num_args t \\<Longrightarrow>\n    chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\n 2. Suc (length p) \\<noteq> num_args t \\<Longrightarrow>\n    chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s", "case True"], ["proof (state)\nthis:\n  Suc (length p) = num_args t\n\ngoal (2 subgoals):\n 1. Suc (length p) = num_args t \\<Longrightarrow>\n    chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\n 2. Suc (length p) \\<noteq> num_args t \\<Longrightarrow>\n    chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s", "then"], ["proof (chain)\npicking this:\n  Suc (length p) = num_args t", "have \"p = replicate (num_args (fun t)) Left\""], ["proof (prove)\nusing this:\n  Suc (length p) = num_args t\n\ngoal (1 subgoal):\n 1. p = replicate (num_args (fun t)) dir.Left", "using p_replicate"], ["proof (prove)\nusing this:\n  Suc (length p) = num_args t\n  replicate (length p) dir.Left = p\n\ngoal (1 subgoal):\n 1. p = replicate (num_args (fun t)) dir.Left", "by (metis Suc_inject \\<open>is_App t\\<close> args.elims args_Nil_iff_is_Hd length_append_singleton tm.sel(4))"], ["proof (state)\nthis:\n  p = replicate (num_args (fun t)) dir.Left\n\ngoal (2 subgoals):\n 1. Suc (length p) = num_args t \\<Longrightarrow>\n    chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\n 2. Suc (length p) \\<noteq> num_args t \\<Longrightarrow>\n    chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s", "then"], ["proof (chain)\npicking this:\n  p = replicate (num_args (fun t)) dir.Left", "have \"chop t = s\""], ["proof (prove)\nusing this:\n  p = replicate (num_args (fun t)) dir.Left\n\ngoal (1 subgoal):\n 1. chop t = s", "unfolding chop_emb_step_at[OF \\<open>is_App t\\<close>]"], ["proof (prove)\nusing this:\n  p = replicate (num_args (fun t)) dir.Left\n\ngoal (1 subgoal):\n 1. emb_step_at (replicate (num_args (fun t)) dir.Left) dir.Right t = s", "using pos emb_step_at"], ["proof (prove)\nusing this:\n  p = replicate (num_args (fun t)) dir.Left\n  position_of t (p @ [dir.Right])\n  emb_step_at p dir.Right t = s\n\ngoal (1 subgoal):\n 1. emb_step_at (replicate (num_args (fun t)) dir.Left) dir.Right t = s", "by blast"], ["proof (state)\nthis:\n  chop t = s\n\ngoal (2 subgoals):\n 1. Suc (length p) = num_args t \\<Longrightarrow>\n    chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\n 2. Suc (length p) \\<noteq> num_args t \\<Longrightarrow>\n    chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s", "then"], ["proof (chain)\npicking this:\n  chop t = s", "show ?thesis"], ["proof (prove)\nusing this:\n  chop t = s\n\ngoal (1 subgoal):\n 1. chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s", "by blast"], ["proof (state)\nthis:\n  chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\n\ngoal (1 subgoal):\n 1. Suc (length p) \\<noteq> num_args t \\<Longrightarrow>\n    chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc (length p) \\<noteq> num_args t \\<Longrightarrow>\n    chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s", "case False"], ["proof (state)\nthis:\n  Suc (length p) \\<noteq> num_args t\n\ngoal (1 subgoal):\n 1. Suc (length p) \\<noteq> num_args t \\<Longrightarrow>\n    chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s", "then"], ["proof (chain)\npicking this:\n  Suc (length p) \\<noteq> num_args t", "have \"Suc (length p) < num_args t\""], ["proof (prove)\nusing this:\n  Suc (length p) \\<noteq> num_args t\n\ngoal (1 subgoal):\n 1. Suc (length p) < num_args t", "using pos emb_step_at \\<open>is_App t\\<close> \\<open>list_all (\\<lambda>x. x = dir.Left) p\\<close>"], ["proof (prove)\nusing this:\n  Suc (length p) \\<noteq> num_args t\n  position_of t (p @ [dir.Right])\n  emb_step_at p dir.Right t = s\n  is_App t\n  list_all (\\<lambda>x. x = dir.Left) p\n\ngoal (1 subgoal):\n 1. Suc (length p) < num_args t", "proof (induct p arbitrary:t s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t s.\n       \\<lbrakk>Suc (length []) \\<noteq> num_args t;\n        position_of t ([] @ [dir.Right]); emb_step_at [] dir.Right t = s;\n        is_App t; list_all (\\<lambda>x. x = dir.Left) []\\<rbrakk>\n       \\<Longrightarrow> Suc (length []) < num_args t\n 2. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>Suc (length p) \\<noteq> num_args t;\n                    position_of t (p @ [dir.Right]);\n                    emb_step_at p dir.Right t = s; is_App t;\n                    list_all (\\<lambda>x. x = dir.Left) p\\<rbrakk>\n                   \\<Longrightarrow> Suc (length p) < num_args t;\n        Suc (length (a # p)) \\<noteq> num_args t;\n        position_of t ((a # p) @ [dir.Right]);\n        emb_step_at (a # p) dir.Right t = s; is_App t;\n        list_all (\\<lambda>x. x = dir.Left) (a # p)\\<rbrakk>\n       \\<Longrightarrow> Suc (length (a # p)) < num_args t", "case Nil"], ["proof (state)\nthis:\n  Suc (length []) \\<noteq> num_args t\n  position_of t ([] @ [dir.Right])\n  emb_step_at [] dir.Right t = s\n  is_App t\n  list_all (\\<lambda>x. x = dir.Left) []\n\ngoal (2 subgoals):\n 1. \\<And>t s.\n       \\<lbrakk>Suc (length []) \\<noteq> num_args t;\n        position_of t ([] @ [dir.Right]); emb_step_at [] dir.Right t = s;\n        is_App t; list_all (\\<lambda>x. x = dir.Left) []\\<rbrakk>\n       \\<Longrightarrow> Suc (length []) < num_args t\n 2. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>Suc (length p) \\<noteq> num_args t;\n                    position_of t (p @ [dir.Right]);\n                    emb_step_at p dir.Right t = s; is_App t;\n                    list_all (\\<lambda>x. x = dir.Left) p\\<rbrakk>\n                   \\<Longrightarrow> Suc (length p) < num_args t;\n        Suc (length (a # p)) \\<noteq> num_args t;\n        position_of t ((a # p) @ [dir.Right]);\n        emb_step_at (a # p) dir.Right t = s; is_App t;\n        list_all (\\<lambda>x. x = dir.Left) (a # p)\\<rbrakk>\n       \\<Longrightarrow> Suc (length (a # p)) < num_args t", "then"], ["proof (chain)\npicking this:\n  Suc (length []) \\<noteq> num_args t\n  position_of t ([] @ [dir.Right])\n  emb_step_at [] dir.Right t = s\n  is_App t\n  list_all (\\<lambda>x. x = dir.Left) []", "show ?case"], ["proof (prove)\nusing this:\n  Suc (length []) \\<noteq> num_args t\n  position_of t ([] @ [dir.Right])\n  emb_step_at [] dir.Right t = s\n  is_App t\n  list_all (\\<lambda>x. x = dir.Left) []\n\ngoal (1 subgoal):\n 1. Suc (length []) < num_args t", "by (metis Suc_lessI args_Nil_iff_is_Hd length_greater_0_conv list.size(3))"], ["proof (state)\nthis:\n  Suc (length []) < num_args t\n\ngoal (1 subgoal):\n 1. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>Suc (length p) \\<noteq> num_args t;\n                    position_of t (p @ [dir.Right]);\n                    emb_step_at p dir.Right t = s; is_App t;\n                    list_all (\\<lambda>x. x = dir.Left) p\\<rbrakk>\n                   \\<Longrightarrow> Suc (length p) < num_args t;\n        Suc (length (a # p)) \\<noteq> num_args t;\n        position_of t ((a # p) @ [dir.Right]);\n        emb_step_at (a # p) dir.Right t = s; is_App t;\n        list_all (\\<lambda>x. x = dir.Left) (a # p)\\<rbrakk>\n       \\<Longrightarrow> Suc (length (a # p)) < num_args t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>Suc (length p) \\<noteq> num_args t;\n                    position_of t (p @ [dir.Right]);\n                    emb_step_at p dir.Right t = s; is_App t;\n                    list_all (\\<lambda>x. x = dir.Left) p\\<rbrakk>\n                   \\<Longrightarrow> Suc (length p) < num_args t;\n        Suc (length (a # p)) \\<noteq> num_args t;\n        position_of t ((a # p) @ [dir.Right]);\n        emb_step_at (a # p) dir.Right t = s; is_App t;\n        list_all (\\<lambda>x. x = dir.Left) (a # p)\\<rbrakk>\n       \\<Longrightarrow> Suc (length (a # p)) < num_args t", "case (Cons a p)"], ["proof (state)\nthis:\n  \\<lbrakk>Suc (length p) \\<noteq> num_args ?t;\n   position_of ?t (p @ [dir.Right]); emb_step_at p dir.Right ?t = ?s;\n   is_App ?t; list_all (\\<lambda>x. x = dir.Left) p\\<rbrakk>\n  \\<Longrightarrow> Suc (length p) < num_args ?t\n  Suc (length (a # p)) \\<noteq> num_args t\n  position_of t ((a # p) @ [dir.Right])\n  emb_step_at (a # p) dir.Right t = s\n  is_App t\n  list_all (\\<lambda>x. x = dir.Left) (a # p)\n\ngoal (1 subgoal):\n 1. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>Suc (length p) \\<noteq> num_args t;\n                    position_of t (p @ [dir.Right]);\n                    emb_step_at p dir.Right t = s; is_App t;\n                    list_all (\\<lambda>x. x = dir.Left) p\\<rbrakk>\n                   \\<Longrightarrow> Suc (length p) < num_args t;\n        Suc (length (a # p)) \\<noteq> num_args t;\n        position_of t ((a # p) @ [dir.Right]);\n        emb_step_at (a # p) dir.Right t = s; is_App t;\n        list_all (\\<lambda>x. x = dir.Left) (a # p)\\<rbrakk>\n       \\<Longrightarrow> Suc (length (a # p)) < num_args t", "have \"a = Left\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = dir.Left", "using Cons.prems(5)"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. x = dir.Left) (a # p)\n\ngoal (1 subgoal):\n 1. a = dir.Left", "by auto"], ["proof (state)\nthis:\n  a = dir.Left\n\ngoal (1 subgoal):\n 1. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>Suc (length p) \\<noteq> num_args t;\n                    position_of t (p @ [dir.Right]);\n                    emb_step_at p dir.Right t = s; is_App t;\n                    list_all (\\<lambda>x. x = dir.Left) p\\<rbrakk>\n                   \\<Longrightarrow> Suc (length p) < num_args t;\n        Suc (length (a # p)) \\<noteq> num_args t;\n        position_of t ((a # p) @ [dir.Right]);\n        emb_step_at (a # p) dir.Right t = s; is_App t;\n        list_all (\\<lambda>x. x = dir.Left) (a # p)\\<rbrakk>\n       \\<Longrightarrow> Suc (length (a # p)) < num_args t", "have 1:\"Suc (length p) \\<noteq> num_args (fun t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (length p) \\<noteq> num_args (fun t)", "by (metis (no_types, lifting) Cons.prems(1) Cons.prems(4) args.elims args_Nil_iff_is_Hd length_Cons length_append_singleton tm.sel(4))"], ["proof (state)\nthis:\n  Suc (length p) \\<noteq> num_args (fun t)\n\ngoal (1 subgoal):\n 1. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>Suc (length p) \\<noteq> num_args t;\n                    position_of t (p @ [dir.Right]);\n                    emb_step_at p dir.Right t = s; is_App t;\n                    list_all (\\<lambda>x. x = dir.Left) p\\<rbrakk>\n                   \\<Longrightarrow> Suc (length p) < num_args t;\n        Suc (length (a # p)) \\<noteq> num_args t;\n        position_of t ((a # p) @ [dir.Right]);\n        emb_step_at (a # p) dir.Right t = s; is_App t;\n        list_all (\\<lambda>x. x = dir.Left) (a # p)\\<rbrakk>\n       \\<Longrightarrow> Suc (length (a # p)) < num_args t", "have 2:\"position_of (fun t) (p @ [Right])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. position_of (fun t) (p @ [dir.Right])", "using \\<open>position_of t ((a # p) @ [Right])\\<close> \\<open>is_App t\\<close>"], ["proof (prove)\nusing this:\n  position_of t ((a # p) @ [dir.Right])\n  is_App t\n\ngoal (1 subgoal):\n 1. position_of (fun t) (p @ [dir.Right])", "by (metis (full_types) Cons.prems(5) position_of_left append_Cons list_all_simps(1) tm.collapse(2))"], ["proof (state)\nthis:\n  position_of (fun t) (p @ [dir.Right])\n\ngoal (1 subgoal):\n 1. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>Suc (length p) \\<noteq> num_args t;\n                    position_of t (p @ [dir.Right]);\n                    emb_step_at p dir.Right t = s; is_App t;\n                    list_all (\\<lambda>x. x = dir.Left) p\\<rbrakk>\n                   \\<Longrightarrow> Suc (length p) < num_args t;\n        Suc (length (a # p)) \\<noteq> num_args t;\n        position_of t ((a # p) @ [dir.Right]);\n        emb_step_at (a # p) dir.Right t = s; is_App t;\n        list_all (\\<lambda>x. x = dir.Left) (a # p)\\<rbrakk>\n       \\<Longrightarrow> Suc (length (a # p)) < num_args t", "have 3: \"emb_step_at p dir.Right (fun t) = emb_step_at p dir.Right (fun t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emb_step_at p dir.Right (fun t) = emb_step_at p dir.Right (fun t)", "using emb_step_at_left_context[of p Right \"fun t\" \"arg t\"]"], ["proof (prove)\nusing this:\n  emb_step_at (dir.Left # p) dir.Right (App (fun t) (arg t)) =\n  App (emb_step_at p dir.Right (fun t)) (arg t)\n\ngoal (1 subgoal):\n 1. emb_step_at p dir.Right (fun t) = emb_step_at p dir.Right (fun t)", "by blast"], ["proof (state)\nthis:\n  emb_step_at p dir.Right (fun t) = emb_step_at p dir.Right (fun t)\n\ngoal (1 subgoal):\n 1. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>Suc (length p) \\<noteq> num_args t;\n                    position_of t (p @ [dir.Right]);\n                    emb_step_at p dir.Right t = s; is_App t;\n                    list_all (\\<lambda>x. x = dir.Left) p\\<rbrakk>\n                   \\<Longrightarrow> Suc (length p) < num_args t;\n        Suc (length (a # p)) \\<noteq> num_args t;\n        position_of t ((a # p) @ [dir.Right]);\n        emb_step_at (a # p) dir.Right t = s; is_App t;\n        list_all (\\<lambda>x. x = dir.Left) (a # p)\\<rbrakk>\n       \\<Longrightarrow> Suc (length (a # p)) < num_args t", "have \"Suc (length p) < num_args (fun t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (length p) < num_args (fun t)", "using Cons.hyps[OF 1 2 3]"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_App (fun t); list_all (\\<lambda>x. x = dir.Left) p\\<rbrakk>\n  \\<Longrightarrow> Suc (length p) < num_args (fun t)\n\ngoal (1 subgoal):\n 1. Suc (length p) < num_args (fun t)", "by (metis \"2\" Cons.prems(5) Nil_is_append_conv list_all_simps(1) not_Cons_self2 position_of.elims(2) tm.discI(2))"], ["proof (state)\nthis:\n  Suc (length p) < num_args (fun t)\n\ngoal (1 subgoal):\n 1. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>Suc (length p) \\<noteq> num_args t;\n                    position_of t (p @ [dir.Right]);\n                    emb_step_at p dir.Right t = s; is_App t;\n                    list_all (\\<lambda>x. x = dir.Left) p\\<rbrakk>\n                   \\<Longrightarrow> Suc (length p) < num_args t;\n        Suc (length (a # p)) \\<noteq> num_args t;\n        position_of t ((a # p) @ [dir.Right]);\n        emb_step_at (a # p) dir.Right t = s; is_App t;\n        list_all (\\<lambda>x. x = dir.Left) (a # p)\\<rbrakk>\n       \\<Longrightarrow> Suc (length (a # p)) < num_args t", "then"], ["proof (chain)\npicking this:\n  Suc (length p) < num_args (fun t)", "show ?case"], ["proof (prove)\nusing this:\n  Suc (length p) < num_args (fun t)\n\ngoal (1 subgoal):\n 1. Suc (length (a # p)) < num_args t", "by (metis Cons.prems(4) Suc_less_eq2 args.simps(2) length_Cons length_append_singleton tm.collapse(2))"], ["proof (state)\nthis:\n  Suc (length (a # p)) < num_args t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Suc (length p) < num_args t\n\ngoal (1 subgoal):\n 1. Suc (length p) \\<noteq> num_args t \\<Longrightarrow>\n    chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s", "define q where \"q = replicate (num_args (fun t) - Suc (length p)) dir.Left\""], ["proof (state)\nthis:\n  q = replicate (num_args (fun t) - Suc (length p)) dir.Left\n\ngoal (1 subgoal):\n 1. Suc (length p) \\<noteq> num_args t \\<Longrightarrow>\n    chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s", "have \"chop t = emb_step_at (p @ [Left] @ q) dir.Right t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chop t = emb_step_at (p @ [dir.Left] @ q) dir.Right t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. chop t = emb_step_at (p @ [dir.Left] @ q) dir.Right t", "have \"length p + (num_args (fun t) - length p) = num_args (fun t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length p + (num_args (fun t) - length p) = num_args (fun t)", "using \\<open>Suc (length p) < num_args t\\<close>"], ["proof (prove)\nusing this:\n  Suc (length p) < num_args t\n\ngoal (1 subgoal):\n 1. length p + (num_args (fun t) - length p) = num_args (fun t)", "by (metis Suc_less_eq2 \\<open>is_App t\\<close> args.simps(2) diff_Suc_1 leD length_butlast nat_le_linear \n            ordered_cancel_comm_monoid_diff_class.add_diff_inverse snoc_eq_iff_butlast tm.collapse(2))"], ["proof (state)\nthis:\n  length p + (num_args (fun t) - length p) = num_args (fun t)\n\ngoal (1 subgoal):\n 1. chop t = emb_step_at (p @ [dir.Left] @ q) dir.Right t", "then"], ["proof (chain)\npicking this:\n  length p + (num_args (fun t) - length p) = num_args (fun t)", "have 1:\"replicate (num_args (fun t)) dir.Left = p @ replicate (num_args (fun t) - length p) dir.Left\""], ["proof (prove)\nusing this:\n  length p + (num_args (fun t) - length p) = num_args (fun t)\n\ngoal (1 subgoal):\n 1. replicate (num_args (fun t)) dir.Left =\n    p @ replicate (num_args (fun t) - length p) dir.Left", "by (metis p_replicate replicate_add)"], ["proof (state)\nthis:\n  replicate (num_args (fun t)) dir.Left =\n  p @ replicate (num_args (fun t) - length p) dir.Left\n\ngoal (1 subgoal):\n 1. chop t = emb_step_at (p @ [dir.Left] @ q) dir.Right t", "have \"0 < num_args (fun t) - length p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < num_args (fun t) - length p", "by (metis (no_types) False \\<open>is_App t\\<close> \\<open>length p + (num_args (fun t) - length p) = num_args (fun t)\\<close> args.simps(2) length_append_singleton less_Suc_eq less_add_Suc1 tm.collapse(2) zero_less_diff)"], ["proof (state)\nthis:\n  0 < num_args (fun t) - length p\n\ngoal (1 subgoal):\n 1. chop t = emb_step_at (p @ [dir.Left] @ q) dir.Right t", "then"], ["proof (chain)\npicking this:\n  0 < num_args (fun t) - length p", "have \"replicate (num_args (fun t) - length p) dir.Left = [Left] @ q\""], ["proof (prove)\nusing this:\n  0 < num_args (fun t) - length p\n\ngoal (1 subgoal):\n 1. replicate (num_args (fun t) - length p) dir.Left = [dir.Left] @ q", "unfolding q_def"], ["proof (prove)\nusing this:\n  0 < num_args (fun t) - length p\n\ngoal (1 subgoal):\n 1. replicate (num_args (fun t) - length p) dir.Left =\n    [dir.Left] @ replicate (num_args (fun t) - Suc (length p)) dir.Left", "by (metis (no_types) Cons_replicate_eq Nat.diff_cancel Suc_eq_plus1 \\<open>length p + (num_args (fun t) - length p) = num_args (fun t)\\<close> append_Cons self_append_conv2)"], ["proof (state)\nthis:\n  replicate (num_args (fun t) - length p) dir.Left = [dir.Left] @ q\n\ngoal (1 subgoal):\n 1. chop t = emb_step_at (p @ [dir.Left] @ q) dir.Right t", "then"], ["proof (chain)\npicking this:\n  replicate (num_args (fun t) - length p) dir.Left = [dir.Left] @ q", "show ?thesis"], ["proof (prove)\nusing this:\n  replicate (num_args (fun t) - length p) dir.Left = [dir.Left] @ q\n\ngoal (1 subgoal):\n 1. chop t = emb_step_at (p @ [dir.Left] @ q) dir.Right t", "using chop_emb_step_at"], ["proof (prove)\nusing this:\n  replicate (num_args (fun t) - length p) dir.Left = [dir.Left] @ q\n  is_App ?t \\<Longrightarrow>\n  chop ?t =\n  emb_step_at (replicate (num_args (fun ?t)) dir.Left) dir.Right ?t\n\ngoal (1 subgoal):\n 1. chop t = emb_step_at (p @ [dir.Left] @ q) dir.Right t", "using \\<open>is_App t\\<close> 1"], ["proof (prove)\nusing this:\n  replicate (num_args (fun t) - length p) dir.Left = [dir.Left] @ q\n  is_App ?t \\<Longrightarrow>\n  chop ?t =\n  emb_step_at (replicate (num_args (fun ?t)) dir.Left) dir.Right ?t\n  is_App t\n  replicate (num_args (fun t)) dir.Left =\n  p @ replicate (num_args (fun t) - length p) dir.Left\n\ngoal (1 subgoal):\n 1. chop t = emb_step_at (p @ [dir.Left] @ q) dir.Right t", "by (simp add: chop_emb_step_at)"], ["proof (state)\nthis:\n  chop t = emb_step_at (p @ [dir.Left] @ q) dir.Right t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chop t = emb_step_at (p @ [dir.Left] @ q) dir.Right t\n\ngoal (1 subgoal):\n 1. Suc (length p) \\<noteq> num_args t \\<Longrightarrow>\n    chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s", "then"], ["proof (chain)\npicking this:\n  chop t = emb_step_at (p @ [dir.Left] @ q) dir.Right t", "have \"chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\""], ["proof (prove)\nusing this:\n  chop t = emb_step_at (p @ [dir.Left] @ q) dir.Right t\n\ngoal (1 subgoal):\n 1. chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s", "using pos merge_emb_step_at[of p Right q Right t]"], ["proof (prove)\nusing this:\n  chop t = emb_step_at (p @ [dir.Left] @ q) dir.Right t\n  position_of t (p @ [dir.Right])\n  emb_step_at p dir.Right\n   (emb_step_at (p @ [opp dir.Right] @ q) dir.Right t) =\n  emb_step_at p dir.Right t\n\ngoal (1 subgoal):\n 1. chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s", "by (metis emb_step_at_if_position opp_simps(1) emb_step_at pos_emb_step_at_opp)"], ["proof (state)\nthis:\n  chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\n\ngoal (1 subgoal):\n 1. Suc (length p) \\<noteq> num_args t \\<Longrightarrow>\n    chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s", "then"], ["proof (chain)\npicking this:\n  chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s", "show ?thesis"], ["proof (prove)\nusing this:\n  chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\n\ngoal (1 subgoal):\n 1. chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s", "by blast"], ["proof (state)\nthis:\n  chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chop t = s \\<or> chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma emb_step_at_remove_arg:\n  assumes emb_step_at: \"emb_step_at p Left t = s\"\n    and pos:\"position_of t (p @ [Left])\"\n    and all_Left: \"list_all (\\<lambda>x. x = Left) p\"\n  shows \"let i = num_args t - Suc (length p) in \n  head t = head s \\<and> i < num_args t \\<and> args s = take i (args t) @ drop (Suc i) (args t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let i = num_args t - Suc (length p)\n    in head t = head s \\<and>\n       i < num_args t \\<and>\n       args s = take i (args t) @ drop (Suc i) (args t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. let i = num_args t - Suc (length p)\n    in head t = head s \\<and>\n       i < num_args t \\<and>\n       args s = take i (args t) @ drop (Suc i) (args t)", "have \"is_App t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_App t", "by (metis emb_step_at_if_position emb_step_at_is_App emb_step_equiv pos)"], ["proof (state)\nthis:\n  is_App t\n\ngoal (1 subgoal):\n 1. let i = num_args t - Suc (length p)\n    in head t = head s \\<and>\n       i < num_args t \\<and>\n       args s = take i (args t) @ drop (Suc i) (args t)", "have C1: \"head t = head s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head t = head s", "using all_Left emb_step_at pos"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. x = dir.Left) p\n  emb_step_at p dir.Left t = s\n  position_of t (p @ [dir.Left])\n\ngoal (1 subgoal):\n 1. head t = head s", "proof (induct p arbitrary:s t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) [];\n        emb_step_at [] dir.Left t = s;\n        position_of t ([] @ [dir.Left])\\<rbrakk>\n       \\<Longrightarrow> head t = head s\n 2. \\<And>a p s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n                    emb_step_at p dir.Left t = s;\n                    position_of t (p @ [dir.Left])\\<rbrakk>\n                   \\<Longrightarrow> head t = head s;\n        list_all (\\<lambda>x. x = dir.Left) (a # p);\n        emb_step_at (a # p) dir.Left t = s;\n        position_of t ((a # p) @ [dir.Left])\\<rbrakk>\n       \\<Longrightarrow> head t = head s", "case Nil"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. x = dir.Left) []\n  emb_step_at [] dir.Left t = s\n  position_of t ([] @ [dir.Left])\n\ngoal (2 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) [];\n        emb_step_at [] dir.Left t = s;\n        position_of t ([] @ [dir.Left])\\<rbrakk>\n       \\<Longrightarrow> head t = head s\n 2. \\<And>a p s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n                    emb_step_at p dir.Left t = s;\n                    position_of t (p @ [dir.Left])\\<rbrakk>\n                   \\<Longrightarrow> head t = head s;\n        list_all (\\<lambda>x. x = dir.Left) (a # p);\n        emb_step_at (a # p) dir.Left t = s;\n        position_of t ((a # p) @ [dir.Left])\\<rbrakk>\n       \\<Longrightarrow> head t = head s", "then"], ["proof (chain)\npicking this:\n  list_all (\\<lambda>x. x = dir.Left) []\n  emb_step_at [] dir.Left t = s\n  position_of t ([] @ [dir.Left])", "have \"s = emb_step_at [] dir.Left (App (fun t) (arg t))\""], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. x = dir.Left) []\n  emb_step_at [] dir.Left t = s\n  position_of t ([] @ [dir.Left])\n\ngoal (1 subgoal):\n 1. s = emb_step_at [] dir.Left (App (fun t) (arg t))", "by (metis position_of.elims(2) snoc_eq_iff_butlast tm.collapse(2) tm.discI(2))"], ["proof (state)\nthis:\n  s = emb_step_at [] dir.Left (App (fun t) (arg t))\n\ngoal (2 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) [];\n        emb_step_at [] dir.Left t = s;\n        position_of t ([] @ [dir.Left])\\<rbrakk>\n       \\<Longrightarrow> head t = head s\n 2. \\<And>a p s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n                    emb_step_at p dir.Left t = s;\n                    position_of t (p @ [dir.Left])\\<rbrakk>\n                   \\<Longrightarrow> head t = head s;\n        list_all (\\<lambda>x. x = dir.Left) (a # p);\n        emb_step_at (a # p) dir.Left t = s;\n        position_of t ((a # p) @ [dir.Left])\\<rbrakk>\n       \\<Longrightarrow> head t = head s", "then"], ["proof (chain)\npicking this:\n  s = emb_step_at [] dir.Left (App (fun t) (arg t))", "have \"s = fun t\""], ["proof (prove)\nusing this:\n  s = emb_step_at [] dir.Left (App (fun t) (arg t))\n\ngoal (1 subgoal):\n 1. s = fun t", "by simp"], ["proof (state)\nthis:\n  s = fun t\n\ngoal (2 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) [];\n        emb_step_at [] dir.Left t = s;\n        position_of t ([] @ [dir.Left])\\<rbrakk>\n       \\<Longrightarrow> head t = head s\n 2. \\<And>a p s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n                    emb_step_at p dir.Left t = s;\n                    position_of t (p @ [dir.Left])\\<rbrakk>\n                   \\<Longrightarrow> head t = head s;\n        list_all (\\<lambda>x. x = dir.Left) (a # p);\n        emb_step_at (a # p) dir.Left t = s;\n        position_of t ((a # p) @ [dir.Left])\\<rbrakk>\n       \\<Longrightarrow> head t = head s", "then"], ["proof (chain)\npicking this:\n  s = fun t", "show ?case"], ["proof (prove)\nusing this:\n  s = fun t\n\ngoal (1 subgoal):\n 1. head t = head s", "by simp"], ["proof (state)\nthis:\n  head t = head s\n\ngoal (1 subgoal):\n 1. \\<And>a p s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n                    emb_step_at p dir.Left t = s;\n                    position_of t (p @ [dir.Left])\\<rbrakk>\n                   \\<Longrightarrow> head t = head s;\n        list_all (\\<lambda>x. x = dir.Left) (a # p);\n        emb_step_at (a # p) dir.Left t = s;\n        position_of t ((a # p) @ [dir.Left])\\<rbrakk>\n       \\<Longrightarrow> head t = head s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n                    emb_step_at p dir.Left t = s;\n                    position_of t (p @ [dir.Left])\\<rbrakk>\n                   \\<Longrightarrow> head t = head s;\n        list_all (\\<lambda>x. x = dir.Left) (a # p);\n        emb_step_at (a # p) dir.Left t = s;\n        position_of t ((a # p) @ [dir.Left])\\<rbrakk>\n       \\<Longrightarrow> head t = head s", "case (Cons a p)"], ["proof (state)\nthis:\n  \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n   emb_step_at p dir.Left ?t = ?s; position_of ?t (p @ [dir.Left])\\<rbrakk>\n  \\<Longrightarrow> head ?t = head ?s\n  list_all (\\<lambda>x. x = dir.Left) (a # p)\n  emb_step_at (a # p) dir.Left t = s\n  position_of t ((a # p) @ [dir.Left])\n\ngoal (1 subgoal):\n 1. \\<And>a p s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n                    emb_step_at p dir.Left t = s;\n                    position_of t (p @ [dir.Left])\\<rbrakk>\n                   \\<Longrightarrow> head t = head s;\n        list_all (\\<lambda>x. x = dir.Left) (a # p);\n        emb_step_at (a # p) dir.Left t = s;\n        position_of t ((a # p) @ [dir.Left])\\<rbrakk>\n       \\<Longrightarrow> head t = head s", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n   emb_step_at p dir.Left ?t = ?s; position_of ?t (p @ [dir.Left])\\<rbrakk>\n  \\<Longrightarrow> head ?t = head ?s\n  list_all (\\<lambda>x. x = dir.Left) (a # p)\n  emb_step_at (a # p) dir.Left t = s\n  position_of t ((a # p) @ [dir.Left])", "have \"a = Left\""], ["proof (prove)\nusing this:\n  \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n   emb_step_at p dir.Left ?t = ?s; position_of ?t (p @ [dir.Left])\\<rbrakk>\n  \\<Longrightarrow> head ?t = head ?s\n  list_all (\\<lambda>x. x = dir.Left) (a # p)\n  emb_step_at (a # p) dir.Left t = s\n  position_of t ((a # p) @ [dir.Left])\n\ngoal (1 subgoal):\n 1. a = dir.Left", "by simp"], ["proof (state)\nthis:\n  a = dir.Left\n\ngoal (1 subgoal):\n 1. \\<And>a p s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n                    emb_step_at p dir.Left t = s;\n                    position_of t (p @ [dir.Left])\\<rbrakk>\n                   \\<Longrightarrow> head t = head s;\n        list_all (\\<lambda>x. x = dir.Left) (a # p);\n        emb_step_at (a # p) dir.Left t = s;\n        position_of t ((a # p) @ [dir.Left])\\<rbrakk>\n       \\<Longrightarrow> head t = head s", "then"], ["proof (chain)\npicking this:\n  a = dir.Left", "have \"head (emb_step_at p Left (fun t)) = head t\""], ["proof (prove)\nusing this:\n  a = dir.Left\n\ngoal (1 subgoal):\n 1. head (emb_step_at p dir.Left (fun t)) = head t", "by (metis Cons.hyps Cons.prems(1) head_fun list.pred_inject(2) position_if_emb_step_at)"], ["proof (state)\nthis:\n  head (emb_step_at p dir.Left (fun t)) = head t\n\ngoal (1 subgoal):\n 1. \\<And>a p s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n                    emb_step_at p dir.Left t = s;\n                    position_of t (p @ [dir.Left])\\<rbrakk>\n                   \\<Longrightarrow> head t = head s;\n        list_all (\\<lambda>x. x = dir.Left) (a # p);\n        emb_step_at (a # p) dir.Left t = s;\n        position_of t ((a # p) @ [dir.Left])\\<rbrakk>\n       \\<Longrightarrow> head t = head s", "then"], ["proof (chain)\npicking this:\n  head (emb_step_at p dir.Left (fun t)) = head t", "show ?case"], ["proof (prove)\nusing this:\n  head (emb_step_at p dir.Left (fun t)) = head t\n\ngoal (1 subgoal):\n 1. head t = head s", "using emb_step_at_left_context[of p a \"fun t\" \"arg t\"]"], ["proof (prove)\nusing this:\n  head (emb_step_at p dir.Left (fun t)) = head t\n  emb_step_at (dir.Left # p) a (App (fun t) (arg t)) =\n  App (emb_step_at p a (fun t)) (arg t)\n\ngoal (1 subgoal):\n 1. head t = head s", "by (metis Cons.prems(2) \\<open>a = Left\\<close> emb_step_at_is_App head_App tm.collapse(2))"], ["proof (state)\nthis:\n  head t = head s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  head t = head s\n\ngoal (1 subgoal):\n 1. let i = num_args t - Suc (length p)\n    in head t = head s \\<and>\n       i < num_args t \\<and>\n       args s = take i (args t) @ drop (Suc i) (args t)", "let ?i = \"num_args t - Suc (length p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. let i = num_args t - Suc (length p)\n    in head t = head s \\<and>\n       i < num_args t \\<and>\n       args s = take i (args t) @ drop (Suc i) (args t)", "have C2:\"?i < num_args t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_args t - Suc (length p) < num_args t", "by (simp add: \\<open>is_App t\\<close> args_Nil_iff_is_Hd)"], ["proof (state)\nthis:\n  num_args t - Suc (length p) < num_args t\n\ngoal (1 subgoal):\n 1. let i = num_args t - Suc (length p)\n    in head t = head s \\<and>\n       i < num_args t \\<and>\n       args s = take i (args t) @ drop (Suc i) (args t)", "have C3:\"args s = take ?i (args t) @ drop (Suc ?i) (args t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. args s =\n    take (num_args t - Suc (length p)) (args t) @\n    drop (Suc (num_args t - Suc (length p))) (args t)", "using all_Left pos emb_step_at \\<open>is_App t\\<close>"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. x = dir.Left) p\n  position_of t (p @ [dir.Left])\n  emb_step_at p dir.Left t = s\n  is_App t\n\ngoal (1 subgoal):\n 1. args s =\n    take (num_args t - Suc (length p)) (args t) @\n    drop (Suc (num_args t - Suc (length p))) (args t)", "proof (induct p arbitrary:s t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) [];\n        position_of t ([] @ [dir.Left]); emb_step_at [] dir.Left t = s;\n        is_App t\\<rbrakk>\n       \\<Longrightarrow> args s =\n                         take (num_args t - Suc (length [])) (args t) @\n                         drop (Suc (num_args t - Suc (length []))) (args t)\n 2. \\<And>a p s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n                    position_of t (p @ [dir.Left]);\n                    emb_step_at p dir.Left t = s; is_App t\\<rbrakk>\n                   \\<Longrightarrow> args s =\n                                     take (num_args t - Suc (length p))\n(args t) @\n                                     drop\n(Suc (num_args t - Suc (length p))) (args t);\n        list_all (\\<lambda>x. x = dir.Left) (a # p);\n        position_of t ((a # p) @ [dir.Left]);\n        emb_step_at (a # p) dir.Left t = s; is_App t\\<rbrakk>\n       \\<Longrightarrow> args s =\n                         take (num_args t - Suc (length (a # p))) (args t) @\n                         drop (Suc (num_args t - Suc (length (a # p))))\n                          (args t)", "case Nil"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. x = dir.Left) []\n  position_of t ([] @ [dir.Left])\n  emb_step_at [] dir.Left t = s\n  is_App t\n\ngoal (2 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) [];\n        position_of t ([] @ [dir.Left]); emb_step_at [] dir.Left t = s;\n        is_App t\\<rbrakk>\n       \\<Longrightarrow> args s =\n                         take (num_args t - Suc (length [])) (args t) @\n                         drop (Suc (num_args t - Suc (length []))) (args t)\n 2. \\<And>a p s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n                    position_of t (p @ [dir.Left]);\n                    emb_step_at p dir.Left t = s; is_App t\\<rbrakk>\n                   \\<Longrightarrow> args s =\n                                     take (num_args t - Suc (length p))\n(args t) @\n                                     drop\n(Suc (num_args t - Suc (length p))) (args t);\n        list_all (\\<lambda>x. x = dir.Left) (a # p);\n        position_of t ((a # p) @ [dir.Left]);\n        emb_step_at (a # p) dir.Left t = s; is_App t\\<rbrakk>\n       \\<Longrightarrow> args s =\n                         take (num_args t - Suc (length (a # p))) (args t) @\n                         drop (Suc (num_args t - Suc (length (a # p))))\n                          (args t)", "then"], ["proof (chain)\npicking this:\n  list_all (\\<lambda>x. x = dir.Left) []\n  position_of t ([] @ [dir.Left])\n  emb_step_at [] dir.Left t = s\n  is_App t", "show ?case"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. x = dir.Left) []\n  position_of t ([] @ [dir.Left])\n  emb_step_at [] dir.Left t = s\n  is_App t\n\ngoal (1 subgoal):\n 1. args s =\n    take (num_args t - Suc (length [])) (args t) @\n    drop (Suc (num_args t - Suc (length []))) (args t)", "using emb_step_at_left[of \"fun t\" \"arg t\"]"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. x = dir.Left) []\n  position_of t ([] @ [dir.Left])\n  emb_step_at [] dir.Left t = s\n  is_App t\n  emb_step_at [] dir.Left (App (fun t) (arg t)) = fun t\n\ngoal (1 subgoal):\n 1. args s =\n    take (num_args t - Suc (length [])) (args t) @\n    drop (Suc (num_args t - Suc (length []))) (args t)", "by (simp, metis One_nat_def args.simps(2) butlast_conv_take butlast_snoc tm.collapse(2))"], ["proof (state)\nthis:\n  args s =\n  take (num_args t - Suc (length [])) (args t) @\n  drop (Suc (num_args t - Suc (length []))) (args t)\n\ngoal (1 subgoal):\n 1. \\<And>a p s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n                    position_of t (p @ [dir.Left]);\n                    emb_step_at p dir.Left t = s; is_App t\\<rbrakk>\n                   \\<Longrightarrow> args s =\n                                     take (num_args t - Suc (length p))\n(args t) @\n                                     drop\n(Suc (num_args t - Suc (length p))) (args t);\n        list_all (\\<lambda>x. x = dir.Left) (a # p);\n        position_of t ((a # p) @ [dir.Left]);\n        emb_step_at (a # p) dir.Left t = s; is_App t\\<rbrakk>\n       \\<Longrightarrow> args s =\n                         take (num_args t - Suc (length (a # p))) (args t) @\n                         drop (Suc (num_args t - Suc (length (a # p))))\n                          (args t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n                    position_of t (p @ [dir.Left]);\n                    emb_step_at p dir.Left t = s; is_App t\\<rbrakk>\n                   \\<Longrightarrow> args s =\n                                     take (num_args t - Suc (length p))\n(args t) @\n                                     drop\n(Suc (num_args t - Suc (length p))) (args t);\n        list_all (\\<lambda>x. x = dir.Left) (a # p);\n        position_of t ((a # p) @ [dir.Left]);\n        emb_step_at (a # p) dir.Left t = s; is_App t\\<rbrakk>\n       \\<Longrightarrow> args s =\n                         take (num_args t - Suc (length (a # p))) (args t) @\n                         drop (Suc (num_args t - Suc (length (a # p))))\n                          (args t)", "case (Cons a p)"], ["proof (state)\nthis:\n  \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n   position_of ?t (p @ [dir.Left]); emb_step_at p dir.Left ?t = ?s;\n   is_App ?t\\<rbrakk>\n  \\<Longrightarrow> args ?s =\n                    take (num_args ?t - Suc (length p)) (args ?t) @\n                    drop (Suc (num_args ?t - Suc (length p))) (args ?t)\n  list_all (\\<lambda>x. x = dir.Left) (a # p)\n  position_of t ((a # p) @ [dir.Left])\n  emb_step_at (a # p) dir.Left t = s\n  is_App t\n\ngoal (1 subgoal):\n 1. \\<And>a p s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n                    position_of t (p @ [dir.Left]);\n                    emb_step_at p dir.Left t = s; is_App t\\<rbrakk>\n                   \\<Longrightarrow> args s =\n                                     take (num_args t - Suc (length p))\n(args t) @\n                                     drop\n(Suc (num_args t - Suc (length p))) (args t);\n        list_all (\\<lambda>x. x = dir.Left) (a # p);\n        position_of t ((a # p) @ [dir.Left]);\n        emb_step_at (a # p) dir.Left t = s; is_App t\\<rbrakk>\n       \\<Longrightarrow> args s =\n                         take (num_args t - Suc (length (a # p))) (args t) @\n                         drop (Suc (num_args t - Suc (length (a # p))))\n                          (args t)", "have \"position_of (fun t) (p @ [Left])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. position_of (fun t) (p @ [dir.Left])", "by (metis (full_types) Cons.prems(1) Cons.prems(2) Cons.prems(4) position_of_left \n          append_Cons list.pred_inject(2) tm.collapse(2))"], ["proof (state)\nthis:\n  position_of (fun t) (p @ [dir.Left])\n\ngoal (1 subgoal):\n 1. \\<And>a p s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n                    position_of t (p @ [dir.Left]);\n                    emb_step_at p dir.Left t = s; is_App t\\<rbrakk>\n                   \\<Longrightarrow> args s =\n                                     take (num_args t - Suc (length p))\n(args t) @\n                                     drop\n(Suc (num_args t - Suc (length p))) (args t);\n        list_all (\\<lambda>x. x = dir.Left) (a # p);\n        position_of t ((a # p) @ [dir.Left]);\n        emb_step_at (a # p) dir.Left t = s; is_App t\\<rbrakk>\n       \\<Longrightarrow> args s =\n                         take (num_args t - Suc (length (a # p))) (args t) @\n                         drop (Suc (num_args t - Suc (length (a # p))))\n                          (args t)", "then"], ["proof (chain)\npicking this:\n  position_of (fun t) (p @ [dir.Left])", "have 0:\"args (emb_step_at p Left (fun t))\n                   = take (num_args (fun t) - Suc (length p)) (args (fun t)) \n                   @ drop (Suc (num_args (fun t) - Suc (length p))) (args (fun t))\""], ["proof (prove)\nusing this:\n  position_of (fun t) (p @ [dir.Left])\n\ngoal (1 subgoal):\n 1. args (emb_step_at p dir.Left (fun t)) =\n    take (num_args (fun t) - Suc (length p)) (args (fun t)) @\n    drop (Suc (num_args (fun t) - Suc (length p))) (args (fun t))", "using Cons.hyps[of \"fun t\"]"], ["proof (prove)\nusing this:\n  position_of (fun t) (p @ [dir.Left])\n  \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n   position_of (fun t) (p @ [dir.Left]);\n   emb_step_at p dir.Left (fun t) = ?s; is_App (fun t)\\<rbrakk>\n  \\<Longrightarrow> args ?s =\n                    take (num_args (fun t) - Suc (length p))\n                     (args (fun t)) @\n                    drop (Suc (num_args (fun t) - Suc (length p)))\n                     (args (fun t))\n\ngoal (1 subgoal):\n 1. args (emb_step_at p dir.Left (fun t)) =\n    take (num_args (fun t) - Suc (length p)) (args (fun t)) @\n    drop (Suc (num_args (fun t) - Suc (length p))) (args (fun t))", "by (metis Cons.prems(1) append_Nil args_Nil_iff_is_Hd drop_Nil \n          emb_step_at_is_App list.size(3) list_all_simps(1) take_0 zero_diff)"], ["proof (state)\nthis:\n  args (emb_step_at p dir.Left (fun t)) =\n  take (num_args (fun t) - Suc (length p)) (args (fun t)) @\n  drop (Suc (num_args (fun t) - Suc (length p))) (args (fun t))\n\ngoal (1 subgoal):\n 1. \\<And>a p s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n                    position_of t (p @ [dir.Left]);\n                    emb_step_at p dir.Left t = s; is_App t\\<rbrakk>\n                   \\<Longrightarrow> args s =\n                                     take (num_args t - Suc (length p))\n(args t) @\n                                     drop\n(Suc (num_args t - Suc (length p))) (args t);\n        list_all (\\<lambda>x. x = dir.Left) (a # p);\n        position_of t ((a # p) @ [dir.Left]);\n        emb_step_at (a # p) dir.Left t = s; is_App t\\<rbrakk>\n       \\<Longrightarrow> args s =\n                         take (num_args t - Suc (length (a # p))) (args t) @\n                         drop (Suc (num_args t - Suc (length (a # p))))\n                          (args t)", "have 1:\"s = App (emb_step_at p Left (fun t)) (arg t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = App (emb_step_at p dir.Left (fun t)) (arg t)", "using emb_step_at_left_context[of p Left \"fun t\" \"arg t\"]"], ["proof (prove)\nusing this:\n  emb_step_at (dir.Left # p) dir.Left (App (fun t) (arg t)) =\n  App (emb_step_at p dir.Left (fun t)) (arg t)\n\ngoal (1 subgoal):\n 1. s = App (emb_step_at p dir.Left (fun t)) (arg t)", "using Cons.prems"], ["proof (prove)\nusing this:\n  emb_step_at (dir.Left # p) dir.Left (App (fun t) (arg t)) =\n  App (emb_step_at p dir.Left (fun t)) (arg t)\n  list_all (\\<lambda>x. x = dir.Left) (a # p)\n  position_of t ((a # p) @ [dir.Left])\n  emb_step_at (a # p) dir.Left t = s\n  is_App t\n\ngoal (1 subgoal):\n 1. s = App (emb_step_at p dir.Left (fun t)) (arg t)", "by auto"], ["proof (state)\nthis:\n  s = App (emb_step_at p dir.Left (fun t)) (arg t)\n\ngoal (1 subgoal):\n 1. \\<And>a p s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n                    position_of t (p @ [dir.Left]);\n                    emb_step_at p dir.Left t = s; is_App t\\<rbrakk>\n                   \\<Longrightarrow> args s =\n                                     take (num_args t - Suc (length p))\n(args t) @\n                                     drop\n(Suc (num_args t - Suc (length p))) (args t);\n        list_all (\\<lambda>x. x = dir.Left) (a # p);\n        position_of t ((a # p) @ [dir.Left]);\n        emb_step_at (a # p) dir.Left t = s; is_App t\\<rbrakk>\n       \\<Longrightarrow> args s =\n                         take (num_args t - Suc (length (a # p))) (args t) @\n                         drop (Suc (num_args t - Suc (length (a # p))))\n                          (args t)", "define k where k_def:\"k = (num_args (fun t) - Suc (length p))\""], ["proof (state)\nthis:\n  k = num_args (fun t) - Suc (length p)\n\ngoal (1 subgoal):\n 1. \\<And>a p s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n                    position_of t (p @ [dir.Left]);\n                    emb_step_at p dir.Left t = s; is_App t\\<rbrakk>\n                   \\<Longrightarrow> args s =\n                                     take (num_args t - Suc (length p))\n(args t) @\n                                     drop\n(Suc (num_args t - Suc (length p))) (args t);\n        list_all (\\<lambda>x. x = dir.Left) (a # p);\n        position_of t ((a # p) @ [dir.Left]);\n        emb_step_at (a # p) dir.Left t = s; is_App t\\<rbrakk>\n       \\<Longrightarrow> args s =\n                         take (num_args t - Suc (length (a # p))) (args t) @\n                         drop (Suc (num_args t - Suc (length (a # p))))\n                          (args t)", "have 2:\"take k (args (fun t)) = take (num_args t - Suc (length (a # p))) (args t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take k (args (fun t)) =\n    take (num_args t - Suc (length (a # p))) (args t)", "by (smt k_def Cons.prems(4) args.elims args_Nil_iff_is_Hd butlast_snoc diff_Suc_eq_diff_pred \n          diff_Suc_less length_Cons length_butlast length_greater_0_conv take_butlast tm.sel(4))"], ["proof (state)\nthis:\n  take k (args (fun t)) = take (num_args t - Suc (length (a # p))) (args t)\n\ngoal (1 subgoal):\n 1. \\<And>a p s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n                    position_of t (p @ [dir.Left]);\n                    emb_step_at p dir.Left t = s; is_App t\\<rbrakk>\n                   \\<Longrightarrow> args s =\n                                     take (num_args t - Suc (length p))\n(args t) @\n                                     drop\n(Suc (num_args t - Suc (length p))) (args t);\n        list_all (\\<lambda>x. x = dir.Left) (a # p);\n        position_of t ((a # p) @ [dir.Left]);\n        emb_step_at (a # p) dir.Left t = s; is_App t\\<rbrakk>\n       \\<Longrightarrow> args s =\n                         take (num_args t - Suc (length (a # p))) (args t) @\n                         drop (Suc (num_args t - Suc (length (a # p))))\n                          (args t)", "have k_def': \"k = num_args t - Suc (Suc (length p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k = num_args t - Suc (Suc (length p))", "using k_def"], ["proof (prove)\nusing this:\n  k = num_args (fun t) - Suc (length p)\n\ngoal (1 subgoal):\n 1. k = num_args t - Suc (Suc (length p))", "by (metis args.simps(2) diff_Suc_Suc length_append_singleton local.Cons(5) tm.collapse(2))"], ["proof (state)\nthis:\n  k = num_args t - Suc (Suc (length p))\n\ngoal (1 subgoal):\n 1. \\<And>a p s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n                    position_of t (p @ [dir.Left]);\n                    emb_step_at p dir.Left t = s; is_App t\\<rbrakk>\n                   \\<Longrightarrow> args s =\n                                     take (num_args t - Suc (length p))\n(args t) @\n                                     drop\n(Suc (num_args t - Suc (length p))) (args t);\n        list_all (\\<lambda>x. x = dir.Left) (a # p);\n        position_of t ((a # p) @ [dir.Left]);\n        emb_step_at (a # p) dir.Left t = s; is_App t\\<rbrakk>\n       \\<Longrightarrow> args s =\n                         take (num_args t - Suc (length (a # p))) (args t) @\n                         drop (Suc (num_args t - Suc (length (a # p))))\n                          (args t)", "have 3:\"args (fun t) @ [arg t] = args t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. args (fun t) @ [arg t] = args t", "by (metis Cons.prems(4) args.simps(2) tm.collapse(2))"], ["proof (state)\nthis:\n  args (fun t) @ [arg t] = args t\n\ngoal (1 subgoal):\n 1. \\<And>a p s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n                    position_of t (p @ [dir.Left]);\n                    emb_step_at p dir.Left t = s; is_App t\\<rbrakk>\n                   \\<Longrightarrow> args s =\n                                     take (num_args t - Suc (length p))\n(args t) @\n                                     drop\n(Suc (num_args t - Suc (length p))) (args t);\n        list_all (\\<lambda>x. x = dir.Left) (a # p);\n        position_of t ((a # p) @ [dir.Left]);\n        emb_step_at (a # p) dir.Left t = s; is_App t\\<rbrakk>\n       \\<Longrightarrow> args s =\n                         take (num_args t - Suc (length (a # p))) (args t) @\n                         drop (Suc (num_args t - Suc (length (a # p))))\n                          (args t)", "have \"num_args t > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < num_args t", "using \\<open>position_of t ((a # p) @ [Left])\\<close>"], ["proof (prove)\nusing this:\n  position_of t ((a # p) @ [dir.Left])\n\ngoal (1 subgoal):\n 1. 1 < num_args t", "by (metis \"3\" \\<open>position_of (fun t) (p @ [dir.Left])\\<close> args_Nil_iff_is_Hd butlast_snoc emb_step.simps emb_step_at_if_position length_butlast length_greater_0_conv tm.discI(2) zero_less_diff)"], ["proof (state)\nthis:\n  1 < num_args t\n\ngoal (1 subgoal):\n 1. \\<And>a p s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n                    position_of t (p @ [dir.Left]);\n                    emb_step_at p dir.Left t = s; is_App t\\<rbrakk>\n                   \\<Longrightarrow> args s =\n                                     take (num_args t - Suc (length p))\n(args t) @\n                                     drop\n(Suc (num_args t - Suc (length p))) (args t);\n        list_all (\\<lambda>x. x = dir.Left) (a # p);\n        position_of t ((a # p) @ [dir.Left]);\n        emb_step_at (a # p) dir.Left t = s; is_App t\\<rbrakk>\n       \\<Longrightarrow> args s =\n                         take (num_args t - Suc (length (a # p))) (args t) @\n                         drop (Suc (num_args t - Suc (length (a # p))))\n                          (args t)", "then"], ["proof (chain)\npicking this:\n  1 < num_args t", "have \"Suc k<num_args t\""], ["proof (prove)\nusing this:\n  1 < num_args t\n\ngoal (1 subgoal):\n 1. Suc k < num_args t", "unfolding k_def'"], ["proof (prove)\nusing this:\n  1 < num_args t\n\ngoal (1 subgoal):\n 1. Suc (num_args t - Suc (Suc (length p))) < num_args t", "using \\<open>1 < num_args t\\<close>"], ["proof (prove)\nusing this:\n  1 < num_args t\n  1 < num_args t\n\ngoal (1 subgoal):\n 1. Suc (num_args t - Suc (Suc (length p))) < num_args t", "by linarith"], ["proof (state)\nthis:\n  Suc k < num_args t\n\ngoal (1 subgoal):\n 1. \\<And>a p s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n                    position_of t (p @ [dir.Left]);\n                    emb_step_at p dir.Left t = s; is_App t\\<rbrakk>\n                   \\<Longrightarrow> args s =\n                                     take (num_args t - Suc (length p))\n(args t) @\n                                     drop\n(Suc (num_args t - Suc (length p))) (args t);\n        list_all (\\<lambda>x. x = dir.Left) (a # p);\n        position_of t ((a # p) @ [dir.Left]);\n        emb_step_at (a # p) dir.Left t = s; is_App t\\<rbrakk>\n       \\<Longrightarrow> args s =\n                         take (num_args t - Suc (length (a # p))) (args t) @\n                         drop (Suc (num_args t - Suc (length (a # p))))\n                          (args t)", "have \"\\<forall>k< num_args t. drop k (args (fun t)) @ [arg t] = drop k (args t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k<num_args t. drop k (args (fun t)) @ [arg t] = drop k (args t)", "by (metis (no_types, lifting) \\<open>args (fun t) @ [arg t] = args t\\<close> drop_butlast drop_eq_Nil last_drop leD snoc_eq_iff_butlast)"], ["proof (state)\nthis:\n  \\<forall>k<num_args t. drop k (args (fun t)) @ [arg t] = drop k (args t)\n\ngoal (1 subgoal):\n 1. \\<And>a p s t.\n       \\<lbrakk>\\<And>s t.\n                   \\<lbrakk>list_all (\\<lambda>x. x = dir.Left) p;\n                    position_of t (p @ [dir.Left]);\n                    emb_step_at p dir.Left t = s; is_App t\\<rbrakk>\n                   \\<Longrightarrow> args s =\n                                     take (num_args t - Suc (length p))\n(args t) @\n                                     drop\n(Suc (num_args t - Suc (length p))) (args t);\n        list_all (\\<lambda>x. x = dir.Left) (a # p);\n        position_of t ((a # p) @ [dir.Left]);\n        emb_step_at (a # p) dir.Left t = s; is_App t\\<rbrakk>\n       \\<Longrightarrow> args s =\n                         take (num_args t - Suc (length (a # p))) (args t) @\n                         drop (Suc (num_args t - Suc (length (a # p))))\n                          (args t)", "then"], ["proof (chain)\npicking this:\n  \\<forall>k<num_args t. drop k (args (fun t)) @ [arg t] = drop k (args t)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>k<num_args t. drop k (args (fun t)) @ [arg t] = drop k (args t)\n\ngoal (1 subgoal):\n 1. args s =\n    take (num_args t - Suc (length (a # p))) (args t) @\n    drop (Suc (num_args t - Suc (length (a # p)))) (args t)", "using 0 1 2 3 k_def'"], ["proof (prove)\nusing this:\n  \\<forall>k<num_args t. drop k (args (fun t)) @ [arg t] = drop k (args t)\n  args (emb_step_at p dir.Left (fun t)) =\n  take (num_args (fun t) - Suc (length p)) (args (fun t)) @\n  drop (Suc (num_args (fun t) - Suc (length p))) (args (fun t))\n  s = App (emb_step_at p dir.Left (fun t)) (arg t)\n  take k (args (fun t)) = take (num_args t - Suc (length (a # p))) (args t)\n  args (fun t) @ [arg t] = args t\n  k = num_args t - Suc (Suc (length p))\n\ngoal (1 subgoal):\n 1. args s =\n    take (num_args t - Suc (length (a # p))) (args t) @\n    drop (Suc (num_args t - Suc (length (a # p)))) (args t)", "using \\<open>Suc k < num_args t\\<close> k_def"], ["proof (prove)\nusing this:\n  \\<forall>k<num_args t. drop k (args (fun t)) @ [arg t] = drop k (args t)\n  args (emb_step_at p dir.Left (fun t)) =\n  take (num_args (fun t) - Suc (length p)) (args (fun t)) @\n  drop (Suc (num_args (fun t) - Suc (length p))) (args (fun t))\n  s = App (emb_step_at p dir.Left (fun t)) (arg t)\n  take k (args (fun t)) = take (num_args t - Suc (length (a # p))) (args t)\n  args (fun t) @ [arg t] = args t\n  k = num_args t - Suc (Suc (length p))\n  Suc k < num_args t\n  k = num_args (fun t) - Suc (length p)\n\ngoal (1 subgoal):\n 1. args s =\n    take (num_args t - Suc (length (a # p))) (args t) @\n    drop (Suc (num_args t - Suc (length (a # p)))) (args t)", "by auto"], ["proof (state)\nthis:\n  args s =\n  take (num_args t - Suc (length (a # p))) (args t) @\n  drop (Suc (num_args t - Suc (length (a # p)))) (args t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  args s =\n  take (num_args t - Suc (length p)) (args t) @\n  drop (Suc (num_args t - Suc (length p))) (args t)\n\ngoal (1 subgoal):\n 1. let i = num_args t - Suc (length p)\n    in head t = head s \\<and>\n       i < num_args t \\<and>\n       args s = take i (args t) @ drop (Suc i) (args t)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. let i = num_args t - Suc (length p)\n    in head t = head s \\<and>\n       i < num_args t \\<and>\n       args s = take i (args t) @ drop (Suc i) (args t)", "using C1 C2 C3"], ["proof (prove)\nusing this:\n  head t = head s\n  num_args t - Suc (length p) < num_args t\n  args s =\n  take (num_args t - Suc (length p)) (args t) @\n  drop (Suc (num_args t - Suc (length p))) (args t)\n\ngoal (1 subgoal):\n 1. let i = num_args t - Suc (length p)\n    in head t = head s \\<and>\n       i < num_args t \\<and>\n       args s = take i (args t) @ drop (Suc i) (args t)", "by simp"], ["proof (state)\nthis:\n  let i = num_args t - Suc (length p)\n  in head t = head s \\<and>\n     i < num_args t \\<and> args s = take i (args t) @ drop (Suc i) (args t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma emb_step_cases [consumes 1, case_names chop extended_chop remove_arg under_arg]:\n  assumes emb:\"t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\"\n    and chop:\"chop t = s \\<Longrightarrow> P\"\n    and extended_chop:\"chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s \\<Longrightarrow> P\"\n    and remove_arg:\"\\<And>i. head t = head s \\<Longrightarrow> i<num_args t \\<Longrightarrow> args s = take i (args t) @ drop (Suc i) (args t) \\<Longrightarrow> P\"\n    and under_arg:\"\\<And>i. head t = head s \\<Longrightarrow> num_args t = num_args s \\<Longrightarrow> args t ! i \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b args s ! i \\<Longrightarrow>\n         (\\<And>j. j<num_args t \\<Longrightarrow> i \\<noteq> j \\<Longrightarrow> args t ! j = args s ! j) \\<Longrightarrow> P\"\n  shows P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "obtain p d where pd_def:\"emb_step_at p d t = s\" \"position_of t (p @ [d])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p d.\n        \\<lbrakk>emb_step_at p d t = s; position_of t (p @ [d])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using emb emb_step_equiv' position_if_emb_step_at"], ["proof (prove)\nusing this:\n  t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s\n  (?t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b ?s) =\n  ((\\<exists>p. p \\<noteq> [] \\<and> emb_step_at' p ?t = ?s) \\<and>\n   ?t \\<noteq> ?s)\n  \\<lbrakk>emb_step_at ?p ?d ?t = ?u; ?t \\<noteq> ?u\\<rbrakk>\n  \\<Longrightarrow> position_of ?t (?p @ [?d])\n\ngoal (1 subgoal):\n 1. (\\<And>p d.\n        \\<lbrakk>emb_step_at p d t = s; position_of t (p @ [d])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  emb_step_at p d t = s\n  position_of t (p @ [d])\n\ngoal (1 subgoal):\n 1. P", "have \"is_App t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_App t", "by (metis emb emb_step_at_is_App emb_step_equiv)"], ["proof (state)\nthis:\n  is_App t\n\ngoal (1 subgoal):\n 1. P", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof (cases \"list_all (\\<lambda>x. x = Left) p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. list_all (\\<lambda>x. x = dir.Left) p \\<Longrightarrow> P\n 2. \\<not> list_all (\\<lambda>x. x = dir.Left) p \\<Longrightarrow> P", "case True"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. x = dir.Left) p\n\ngoal (2 subgoals):\n 1. list_all (\\<lambda>x. x = dir.Left) p \\<Longrightarrow> P\n 2. \\<not> list_all (\\<lambda>x. x = dir.Left) p \\<Longrightarrow> P", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof (cases d)"], ["proof (state)\ngoal (2 subgoals):\n 1. d = dir.Left \\<Longrightarrow> P\n 2. d = dir.Right \\<Longrightarrow> P", "case Left"], ["proof (state)\nthis:\n  d = dir.Left\n\ngoal (2 subgoals):\n 1. d = dir.Left \\<Longrightarrow> P\n 2. d = dir.Right \\<Longrightarrow> P", "then"], ["proof (chain)\npicking this:\n  d = dir.Left", "show P"], ["proof (prove)\nusing this:\n  d = dir.Left\n\ngoal (1 subgoal):\n 1. P", "using emb_step_at_remove_arg"], ["proof (prove)\nusing this:\n  d = dir.Left\n  \\<lbrakk>emb_step_at ?p dir.Left ?t = ?s;\n   position_of ?t (?p @ [dir.Left]);\n   list_all (\\<lambda>x. x = dir.Left) ?p\\<rbrakk>\n  \\<Longrightarrow> let i = num_args ?t - Suc (length ?p)\n                    in head ?t = head ?s \\<and>\n                       i < num_args ?t \\<and>\n                       args ?s = take i (args ?t) @ drop (Suc i) (args ?t)\n\ngoal (1 subgoal):\n 1. P", "by (metis True pd_def(1) pd_def(2) remove_arg)"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. d = dir.Right \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d = dir.Right \\<Longrightarrow> P", "case Right"], ["proof (state)\nthis:\n  d = dir.Right\n\ngoal (1 subgoal):\n 1. d = dir.Right \\<Longrightarrow> P", "then"], ["proof (chain)\npicking this:\n  d = dir.Right", "show P"], ["proof (prove)\nusing this:\n  d = dir.Right\n\ngoal (1 subgoal):\n 1. P", "using True chop emb_step_at_chop extended_chop pd_def(1) pd_def(2)"], ["proof (prove)\nusing this:\n  d = dir.Right\n  list_all (\\<lambda>x. x = dir.Left) p\n  chop t = s \\<Longrightarrow> P\n  \\<lbrakk>emb_step_at ?p dir.Right ?t = ?s;\n   position_of ?t (?p @ [dir.Right]);\n   list_all (\\<lambda>x. x = dir.Left) ?p\\<rbrakk>\n  \\<Longrightarrow> chop ?t = ?s \\<or>\n                    chop ?t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b ?s\n  chop t \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b s \\<Longrightarrow> P\n  emb_step_at p d t = s\n  position_of t (p @ [d])\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<not> list_all (\\<lambda>x. x = dir.Left) p \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> list_all (\\<lambda>x. x = dir.Left) p \\<Longrightarrow> P", "case False"], ["proof (state)\nthis:\n  \\<not> list_all (\\<lambda>x. x = dir.Left) p\n\ngoal (1 subgoal):\n 1. \\<not> list_all (\\<lambda>x. x = dir.Left) p \\<Longrightarrow> P", "have 1:\"num_args t = num_args s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_args t = num_args s", "using emb_step_under_args_num_args"], ["proof (prove)\nusing this:\n  \\<not> list_all (\\<lambda>x. x = dir.Left) ?p \\<Longrightarrow>\n  num_args (emb_step_at ?p ?d ?t) = num_args ?t\n\ngoal (1 subgoal):\n 1. num_args t = num_args s", "by (metis False pd_def(1))"], ["proof (state)\nthis:\n  num_args t = num_args s\n\ngoal (1 subgoal):\n 1. \\<not> list_all (\\<lambda>x. x = dir.Left) p \\<Longrightarrow> P", "have 2:\"head t = head s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head t = head s", "using emb_step_under_args_head"], ["proof (prove)\nusing this:\n  \\<not> list_all (\\<lambda>x. x = dir.Left) ?p \\<Longrightarrow>\n  head (emb_step_at ?p ?d ?t) = head ?t\n\ngoal (1 subgoal):\n 1. head t = head s", "by (metis False pd_def(1))"], ["proof (state)\nthis:\n  head t = head s\n\ngoal (1 subgoal):\n 1. \\<not> list_all (\\<lambda>x. x = dir.Left) p \\<Longrightarrow> P", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using 1 2 under_arg emb_step_under_args_emb_step"], ["proof (prove)\nusing this:\n  num_args t = num_args s\n  head t = head s\n  \\<lbrakk>head t = head s; num_args t = num_args s;\n   args t ! ?i \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b args s ! ?i;\n   \\<And>j.\n      \\<lbrakk>j < num_args t; ?i \\<noteq> j\\<rbrakk>\n      \\<Longrightarrow> args t ! j = args s ! j\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>\\<not> list_all (\\<lambda>x. x = dir.Left) ?p;\n   position_of ?t (?p @ [?d]);\n   \\<And>i.\n      \\<lbrakk>i < num_args ?t;\n       args ?t ! i \\<rightarrow>\\<^sub>e\\<^sub>m\\<^sub>b\n       args (emb_step_at ?p ?d ?t) ! i;\n       \\<And>j.\n          \\<lbrakk>j < num_args ?t; i \\<noteq> j\\<rbrakk>\n          \\<Longrightarrow> args ?t ! j =\n                            args (emb_step_at ?p ?d ?t) ! j\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. P", "by (metis False pd_def(1) pd_def(2))"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chop_position_of:\n  assumes \"is_App s\"\n  shows \"position_of s (replicate (num_args (fun s)) dir.Left @ [Right])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. position_of s (replicate (num_args (fun s)) dir.Left @ [dir.Right])", "by (metis Suc_n_not_le_n assms chop_emb_step_at lessI less_imp_le_nat position_if_emb_step_at hsize_chop)"], ["", "subsection \\<open>Chop and Substitutions\\<close>"], ["", "(* TODO: move *)"], ["", "lemma Suc_num_args: \"is_App t \\<Longrightarrow> Suc (num_args (fun t)) = num_args t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_App t \\<Longrightarrow> Suc (num_args (fun t)) = num_args t", "by (metis args.simps(2) length_append_singleton tm.collapse(2))"], ["", "(* TODO: move *)"], ["", "lemma fun_subst: \"is_App s \\<Longrightarrow> subst \\<rho> (fun s) = fun (subst \\<rho> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_App s \\<Longrightarrow> subst \\<rho> (fun s) = fun (subst \\<rho> s)", "by (metis subst.simps(2) tm.collapse(2) tm.sel(4))"], ["", "(* TODO: move *)"], ["", "lemma args_subst_Hd:\n  assumes \"is_Hd (subst \\<rho> (Hd (head s)))\"\n  shows  \"args (subst \\<rho> s) = map (subst \\<rho>) (args s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. args (subst \\<rho> s) = map (subst \\<rho>) (args s)", "using assms"], ["proof (prove)\nusing this:\n  is_Hd (subst \\<rho> (Hd (head s)))\n\ngoal (1 subgoal):\n 1. args (subst \\<rho> s) = map (subst \\<rho>) (args s)", "by (metis append_Nil args_Nil_iff_is_Hd args_apps subst_apps tm_exhaust_apps_sel)"], ["", "lemma chop_subst_emb0:\n  assumes \"is_App s\"\n  assumes \"chop (subst \\<rho> s) \\<noteq> subst \\<rho> (chop s)\"\n  shows \"emb_step_at (replicate (num_args (fun s)) Left) Right (chop (subst \\<rho> s)) = subst \\<rho> (chop s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right\n     (chop (subst \\<rho> s)) =\n    subst \\<rho> (chop s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right\n     (chop (subst \\<rho> s)) =\n    subst \\<rho> (chop s)", "have \"is_App (subst \\<rho> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_App (subst \\<rho> s)", "by (metis assms(1) subst.simps(2) tm.collapse(2) tm.disc(2))"], ["proof (state)\nthis:\n  is_App (subst \\<rho> s)\n\ngoal (1 subgoal):\n 1. emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right\n     (chop (subst \\<rho> s)) =\n    subst \\<rho> (chop s)", "have 1:\"subst \\<rho> (chop s) = emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right (subst \\<rho>  s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<rho> (chop s) =\n    emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right\n     (subst \\<rho> s)", "using chop_emb_step_at[OF assms(1)]"], ["proof (prove)\nusing this:\n  chop s = emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right s\n\ngoal (1 subgoal):\n 1. subst \\<rho> (chop s) =\n    emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right\n     (subst \\<rho> s)", "using emb_step_at_subst chop_position_of[OF \\<open>is_App s\\<close>]"], ["proof (prove)\nusing this:\n  chop s = emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right s\n  position_of ?t (?p @ [?d]) \\<Longrightarrow>\n  emb_step_at ?p ?d (subst ?\\<rho> ?t) =\n  subst ?\\<rho> (emb_step_at ?p ?d ?t)\n  position_of s (replicate (num_args (fun s)) dir.Left @ [dir.Right])\n\ngoal (1 subgoal):\n 1. subst \\<rho> (chop s) =\n    emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right\n     (subst \\<rho> s)", "by (metis)"], ["proof (state)\nthis:\n  subst \\<rho> (chop s) =\n  emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right\n   (subst \\<rho> s)\n\ngoal (1 subgoal):\n 1. emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right\n     (chop (subst \\<rho> s)) =\n    subst \\<rho> (chop s)", "have \"num_args (fun s) \\<le> num_args (fun (subst \\<rho> s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_args (fun s) \\<le> num_args (fun (subst \\<rho> s))", "using fun_subst[OF \\<open>is_App s\\<close>]"], ["proof (prove)\nusing this:\n  subst ?\\<rho> (fun s) = fun (subst ?\\<rho> s)\n\ngoal (1 subgoal):\n 1. num_args (fun s) \\<le> num_args (fun (subst \\<rho> s))", "by (metis args_subst leI length_append length_map not_add_less2)"], ["proof (state)\nthis:\n  num_args (fun s) \\<le> num_args (fun (subst \\<rho> s))\n\ngoal (1 subgoal):\n 1. emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right\n     (chop (subst \\<rho> s)) =\n    subst \\<rho> (chop s)", "then"], ["proof (chain)\npicking this:\n  num_args (fun s) \\<le> num_args (fun (subst \\<rho> s))", "have \"num_args (fun s) < num_args (fun (subst \\<rho> s))\""], ["proof (prove)\nusing this:\n  num_args (fun s) \\<le> num_args (fun (subst \\<rho> s))\n\ngoal (1 subgoal):\n 1. num_args (fun s) < num_args (fun (subst \\<rho> s))", "using assms(2) \"1\" \\<open>is_App (subst \\<rho> s)\\<close> chop_emb_step_at le_imp_less_or_eq"], ["proof (prove)\nusing this:\n  num_args (fun s) \\<le> num_args (fun (subst \\<rho> s))\n  chop (subst \\<rho> s) \\<noteq> subst \\<rho> (chop s)\n  subst \\<rho> (chop s) =\n  emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right\n   (subst \\<rho> s)\n  is_App (subst \\<rho> s)\n  is_App ?t \\<Longrightarrow>\n  chop ?t =\n  emb_step_at (replicate (num_args (fun ?t)) dir.Left) dir.Right ?t\n  ?x \\<le> ?y \\<Longrightarrow> ?x < ?y \\<or> ?x = ?y\n\ngoal (1 subgoal):\n 1. num_args (fun s) < num_args (fun (subst \\<rho> s))", "by fastforce"], ["proof (state)\nthis:\n  num_args (fun s) < num_args (fun (subst \\<rho> s))\n\ngoal (1 subgoal):\n 1. emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right\n     (chop (subst \\<rho> s)) =\n    subst \\<rho> (chop s)", "then"], ["proof (chain)\npicking this:\n  num_args (fun s) < num_args (fun (subst \\<rho> s))", "have \"num_args s \\<le> num_args (fun (subst \\<rho> s))\""], ["proof (prove)\nusing this:\n  num_args (fun s) < num_args (fun (subst \\<rho> s))\n\ngoal (1 subgoal):\n 1. num_args s \\<le> num_args (fun (subst \\<rho> s))", "using Suc_num_args[OF \\<open>is_App s\\<close>]"], ["proof (prove)\nusing this:\n  num_args (fun s) < num_args (fun (subst \\<rho> s))\n  Suc (num_args (fun s)) = num_args s\n\ngoal (1 subgoal):\n 1. num_args s \\<le> num_args (fun (subst \\<rho> s))", "by linarith"], ["proof (state)\nthis:\n  num_args s \\<le> num_args (fun (subst \\<rho> s))\n\ngoal (1 subgoal):\n 1. emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right\n     (chop (subst \\<rho> s)) =\n    subst \\<rho> (chop s)", "then"], ["proof (chain)\npicking this:\n  num_args s \\<le> num_args (fun (subst \\<rho> s))", "have  \"replicate (num_args (fun s)) dir.Left @\n        [opp dir.Right] @ replicate (num_args (fun (subst \\<rho> s)) - num_args s) dir.Left =\n        replicate (num_args (fun (subst \\<rho> s))) dir.Left\""], ["proof (prove)\nusing this:\n  num_args s \\<le> num_args (fun (subst \\<rho> s))\n\ngoal (1 subgoal):\n 1. replicate (num_args (fun s)) dir.Left @\n    [opp dir.Right] @\n    replicate (num_args (fun (subst \\<rho> s)) - num_args s) dir.Left =\n    replicate (num_args (fun (subst \\<rho> s))) dir.Left", "unfolding append.simps opp_simps replicate_Suc[symmetric] replicate_add[symmetric]"], ["proof (prove)\nusing this:\n  num_args s \\<le> num_args (fun (subst \\<rho> s))\n\ngoal (1 subgoal):\n 1. replicate\n     (num_args (fun s) + Suc (num_args (fun (subst \\<rho> s)) - num_args s))\n     dir.Left =\n    replicate (num_args (fun (subst \\<rho> s))) dir.Left", "using Suc_num_args[OF \\<open>is_App s\\<close>]"], ["proof (prove)\nusing this:\n  num_args s \\<le> num_args (fun (subst \\<rho> s))\n  Suc (num_args (fun s)) = num_args s\n\ngoal (1 subgoal):\n 1. replicate\n     (num_args (fun s) + Suc (num_args (fun (subst \\<rho> s)) - num_args s))\n     dir.Left =\n    replicate (num_args (fun (subst \\<rho> s))) dir.Left", "by (metis add_Suc_shift ordered_cancel_comm_monoid_diff_class.add_diff_inverse)"], ["proof (state)\nthis:\n  replicate (num_args (fun s)) dir.Left @\n  [opp dir.Right] @\n  replicate (num_args (fun (subst \\<rho> s)) - num_args s) dir.Left =\n  replicate (num_args (fun (subst \\<rho> s))) dir.Left\n\ngoal (1 subgoal):\n 1. emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right\n     (chop (subst \\<rho> s)) =\n    subst \\<rho> (chop s)", "then"], ["proof (chain)\npicking this:\n  replicate (num_args (fun s)) dir.Left @\n  [opp dir.Right] @\n  replicate (num_args (fun (subst \\<rho> s)) - num_args s) dir.Left =\n  replicate (num_args (fun (subst \\<rho> s))) dir.Left", "show ?thesis"], ["proof (prove)\nusing this:\n  replicate (num_args (fun s)) dir.Left @\n  [opp dir.Right] @\n  replicate (num_args (fun (subst \\<rho> s)) - num_args s) dir.Left =\n  replicate (num_args (fun (subst \\<rho> s))) dir.Left\n\ngoal (1 subgoal):\n 1. emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right\n     (chop (subst \\<rho> s)) =\n    subst \\<rho> (chop s)", "unfolding 1"], ["proof (prove)\nusing this:\n  replicate (num_args (fun s)) dir.Left @\n  [opp dir.Right] @\n  replicate (num_args (fun (subst \\<rho> s)) - num_args s) dir.Left =\n  replicate (num_args (fun (subst \\<rho> s))) dir.Left\n\ngoal (1 subgoal):\n 1. emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right\n     (chop (subst \\<rho> s)) =\n    emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right\n     (subst \\<rho> s)", "unfolding  chop_emb_step_at[OF \\<open>is_App (subst \\<rho> s)\\<close>]"], ["proof (prove)\nusing this:\n  replicate (num_args (fun s)) dir.Left @\n  [opp dir.Right] @\n  replicate (num_args (fun (subst \\<rho> s)) - num_args s) dir.Left =\n  replicate (num_args (fun (subst \\<rho> s))) dir.Left\n\ngoal (1 subgoal):\n 1. emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right\n     (emb_step_at (replicate (num_args (fun (subst \\<rho> s))) dir.Left)\n       dir.Right (subst \\<rho> s)) =\n    emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right\n     (subst \\<rho> s)", "by (metis merge_emb_step_at)"], ["proof (state)\nthis:\n  emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right\n   (chop (subst \\<rho> s)) =\n  subst \\<rho> (chop s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chop_subst_emb:\n  assumes \"is_App s\"\n  shows \"chop (subst \\<rho> s) \\<unrhd>\\<^sub>e\\<^sub>m\\<^sub>b subst \\<rho> (chop s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chop (subst \\<rho> s) \\<unrhd>\\<^sub>e\\<^sub>m\\<^sub>b\n    subst \\<rho> (chop s)", "using chop_subst_emb0"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_App ?s;\n   chop (subst ?\\<rho> ?s) \\<noteq> subst ?\\<rho> (chop ?s)\\<rbrakk>\n  \\<Longrightarrow> emb_step_at (replicate (num_args (fun ?s)) dir.Left)\n                     dir.Right (chop (subst ?\\<rho> ?s)) =\n                    subst ?\\<rho> (chop ?s)\n\ngoal (1 subgoal):\n 1. chop (subst \\<rho> s) \\<unrhd>\\<^sub>e\\<^sub>m\\<^sub>b\n    subst \\<rho> (chop s)", "by (metis assms emb.refl emb_step_equiv emb_step_is_emb)"], ["", "lemma chop_subst_Hd:\n  assumes \"is_App s\"\n  assumes \"is_Hd (subst \\<rho> (Hd (head s)))\"\n  shows \"chop (subst \\<rho> s) = subst \\<rho> (chop s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chop (subst \\<rho> s) = subst \\<rho> (chop s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. chop (subst \\<rho> s) = subst \\<rho> (chop s)", "have \"is_App (subst \\<rho> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_App (subst \\<rho> s)", "by (metis assms(1) subst.simps(2) tm.collapse(2) tm.disc(2))"], ["proof (state)\nthis:\n  is_App (subst \\<rho> s)\n\ngoal (1 subgoal):\n 1. chop (subst \\<rho> s) = subst \\<rho> (chop s)", "have \"num_args (fun s) = num_args (fun (subst \\<rho> s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_args (fun s) = num_args (fun (subst \\<rho> s))", "unfolding fun_subst[OF \\<open>is_App s\\<close>,symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. num_args (fun s) = num_args (subst \\<rho> (fun s))", "using args_subst_Hd"], ["proof (prove)\nusing this:\n  is_Hd (subst ?\\<rho> (Hd (head ?s))) \\<Longrightarrow>\n  args (subst ?\\<rho> ?s) = map (subst ?\\<rho>) (args ?s)\n\ngoal (1 subgoal):\n 1. num_args (fun s) = num_args (subst \\<rho> (fun s))", "using assms(2)"], ["proof (prove)\nusing this:\n  is_Hd (subst ?\\<rho> (Hd (head ?s))) \\<Longrightarrow>\n  args (subst ?\\<rho> ?s) = map (subst ?\\<rho>) (args ?s)\n  is_Hd (subst \\<rho> (Hd (head s)))\n\ngoal (1 subgoal):\n 1. num_args (fun s) = num_args (subst \\<rho> (fun s))", "by auto"], ["proof (state)\nthis:\n  num_args (fun s) = num_args (fun (subst \\<rho> s))\n\ngoal (1 subgoal):\n 1. chop (subst \\<rho> s) = subst \\<rho> (chop s)", "then"], ["proof (chain)\npicking this:\n  num_args (fun s) = num_args (fun (subst \\<rho> s))", "show ?thesis"], ["proof (prove)\nusing this:\n  num_args (fun s) = num_args (fun (subst \\<rho> s))\n\ngoal (1 subgoal):\n 1. chop (subst \\<rho> s) = subst \\<rho> (chop s)", "unfolding chop_emb_step_at[OF assms(1)] chop_emb_step_at[OF \\<open>is_App (subst \\<rho> s)\\<close>]"], ["proof (prove)\nusing this:\n  num_args (fun s) = num_args (fun (subst \\<rho> s))\n\ngoal (1 subgoal):\n 1. emb_step_at (replicate (num_args (fun (subst \\<rho> s))) dir.Left)\n     dir.Right (subst \\<rho> s) =\n    subst \\<rho>\n     (emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right s)", "using emb_step_at_subst[OF chop_position_of[OF \\<open>is_App s\\<close>]]"], ["proof (prove)\nusing this:\n  num_args (fun s) = num_args (fun (subst \\<rho> s))\n  emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right\n   (subst ?\\<rho> s) =\n  subst ?\\<rho>\n   (emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right s)\n\ngoal (1 subgoal):\n 1. emb_step_at (replicate (num_args (fun (subst \\<rho> s))) dir.Left)\n     dir.Right (subst \\<rho> s) =\n    subst \\<rho>\n     (emb_step_at (replicate (num_args (fun s)) dir.Left) dir.Right s)", "by simp"], ["proof (state)\nthis:\n  chop (subst \\<rho> s) = subst \\<rho> (chop s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chop_subst_Sym:\n  assumes \"is_App s\"\n  assumes \"is_Sym (head s)\"\n  shows \"chop (subst \\<rho> s) = subst \\<rho> (chop s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chop (subst \\<rho> s) = subst \\<rho> (chop s)", "by (metis assms(1) assms(2) chop_subst_Hd ground_imp_subst_iden hd.collapse(2) hd.simps(18) tm.disc(1) tm.simps(17))"], ["", "end"]]}