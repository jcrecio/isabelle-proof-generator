{"file_name": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus/Matrix_Record_Based.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus", "problem_names": ["lemma right_total_mat_rel: \"right_total R \\<Longrightarrow> right_total (mat_rel R)\"", "lemma left_unique_mat_rel: \"left_unique R \\<Longrightarrow> left_unique (mat_rel R)\"", "lemma right_unique_mat_rel: \"right_unique R \\<Longrightarrow> right_unique (mat_rel R)\"", "lemma bi_unique_mat_rel: \"bi_unique R \\<Longrightarrow> bi_unique (mat_rel R)\"", "lemma mat_rel_eq: \"((R ===> R ===> (=))) (=) (=) \\<Longrightarrow> \n  ((mat_rel R ===> mat_rel R ===> (=))) (=) (=)\"", "lemma right_total_vec_rel: \"right_total R \\<Longrightarrow> right_total (vec_rel R)\"", "lemma left_unique_vec_rel: \"left_unique R \\<Longrightarrow> left_unique (vec_rel R)\"", "lemma right_unique_vec_rel: \"right_unique R \\<Longrightarrow> right_unique (vec_rel R)\"", "lemma bi_unique_vec_rel: \"bi_unique R \\<Longrightarrow> bi_unique (vec_rel R)\"", "lemma vec_rel_eq: \"((R ===> R ===> (=))) (=) (=) \\<Longrightarrow> \n  ((vec_rel R ===> vec_rel R ===> (=))) (=) (=)\"", "lemma multrow_transfer[transfer_rule]: \"((R ===> R ===> R) ===> (=) ===> R\n  ===> mat_rel R ===> mat_rel R) mat_multrow_gen mat_multrow_gen\"", "lemma swap_rows_transfer: \"mat_rel R A B \\<Longrightarrow> i < dim_row B \\<Longrightarrow> j < dim_row B \\<Longrightarrow> \n  mat_rel R (mat_swaprows i j A) (mat_swaprows i j B)\"", "lemma pivot_positions_gen_transfer: assumes [transfer_rule]: \"(R ===> R ===> (=)) (=) (=)\" \n  shows \n  \"(R ===> mat_rel R ===> (=)) pivot_positions_gen pivot_positions_gen\"", "lemma set_pivot_positions_main_gen: \n  \"set (pivot_positions_main_gen ze A nr nc i j) \\<subseteq> {0 ..< nr} \\<times> {0 ..< nc}\"", "lemma find_base_vectors_transfer: assumes [transfer_rule]: \"(R ===> R ===> (=)) (=) (=)\"\n  shows \"((R ===> R) ===> R ===> R ===> mat_rel R \n  ===> list_all2 (vec_rel R)) find_base_vectors_gen find_base_vectors_gen\"", "lemma eliminate_entries_gen_transfer: assumes *[transfer_rule]: \"(R ===> R ===> R) ad ad'\"\n  \"(R ===> R ===> R) mul mul'\"\n  and vs: \"\\<And> j. j < dim_row B' \\<Longrightarrow> R (vs j) (vs' j)\" \n  and i: \"i < dim_row B'\"  \n  and B: \"mat_rel R B B'\"\n  shows \"mat_rel R \n   (eliminate_entries_gen ad mul vs B i j) \n   (eliminate_entries_gen ad' mul' vs' B' i j)\"", "lemma dim_eliminate_entries_gen_zero[simp]:\n  \"dim_row (eliminate_entries_gen_zero mm tt z v B i as) = dim_row B\"\n  \"dim_col (eliminate_entries_gen_zero mm tt z v B i as) = dim_col B\"", "lemma right_total_poly_rel[transfer_rule]: \"right_total (mat_rel R)\"", "lemma bi_unique_poly_rel[transfer_rule]: \"bi_unique (mat_rel R)\"", "lemma eq_mat_rel[transfer_rule]: \"(mat_rel R ===> mat_rel R ===> (=)) (=) (=)\"", "lemma multrow_i[transfer_rule]: \"((=) ===> R ===> mat_rel R ===> mat_rel R)\n  (multrow_i ops) multrow\"", "lemma eliminate_entries_gen_zero[simp]:\n  assumes \"mat_rel R A A'\" \"I < dim_row A'\" shows\n  \"eliminate_entries_gen_zero minus times zero v A I J = eliminate_entries_gen minus times (v o integer_of_nat) A I J\"", "lemma eliminate_entries_i: assumes  \n  vs: \"\\<And> j. j < dim_row B' \\<Longrightarrow> R (vs (integer_of_nat j)) (vs' j)\" \n  and i: \"i < dim_row B'\"  \n  and B: \"mat_rel R B B'\"  \n  shows \"mat_rel R (eliminate_entries_i ops vs B i j) \n    (eliminate_entries vs' B' i j)\"", "lemma gauss_jordan_main_i:  \n  \"nr = dim_row A' \\<Longrightarrow> nc = dim_col A' \\<Longrightarrow> mat_rel R A A' \\<Longrightarrow> i \\<le> nr \\<Longrightarrow> j \\<le> nc \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j) (fst (gauss_jordan_main A' B' i j))\"", "lemma gauss_jordan_i[transfer_rule]:  \n  \"(mat_rel R ===> mat_rel R) (gauss_jordan_single_i ops) gauss_jordan_single\"", "lemma find_base_vectors_i[transfer_rule]:  \n  \"(mat_rel R ===> list_all2 (vec_rel R)) (find_base_vectors_i ops) find_base_vectors\"", "lemma list_of_vec_transfer[transfer_rule]: \"(vec_rel A ===> list_all2 A) list_of_vec list_of_vec\"", "lemma IArray_sub'[simp]: \"i < IArray.length a \\<Longrightarrow> IArray.sub' (a, integer_of_nat i) = IArray.sub a i\"", "lemma eliminate_entries_gen_zero [simp]:\n  assumes \"i<(dim_row A)\" \"j<(dim_col A)\" shows\n  \"eliminate_entries_gen_zero mminus ttimes z v A I J $$ (i, j) =\n   (if v (integer_of_nat i) = z \\<or> i = I then A $$ (i,j) else mminus (A $$ (i,j)) (ttimes (v (integer_of_nat i)) (A $$ (I,j))))\"", "lemma eliminate_entries_gen [simp]:\n  assumes \"i<(dim_row A)\" \"j<(dim_col A)\" shows\n  \"eliminate_entries_gen mminus ttimes v A I J $$ (i, j) =\n   (if i = I then A $$ (i,j) else mminus (A $$ (i,j)) (ttimes (v i) (A $$ (I,j))))\"", "lemma dim_mat_impl [simp]:\n  \"dim_row (mat_impl x) = dim_row_impl x\"\n  \"dim_col (mat_impl x) = dim_col_impl x\"", "lemma dim_eliminate_entries_i2 [simp]:\n  \"dim_row_impl (eliminate_entries_i2 z mm tt v m i) = dim_row_impl m\"\n  \"dim_col_impl (eliminate_entries_i2 z mm tt v m i) = dim_col_impl m\"", "lemma tabulate_nth: \"i < n \\<Longrightarrow> IArray.tabulate (integer_of_nat n, f) !! i = f (integer_of_nat i)\"", "lemma eliminate_entries_i2[code]:\"eliminate_entries_gen_zero mm tt z v (mat_impl m) i j\n   = (if i < dim_row_impl m \n     then mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i))\n     else (Code.abort (STR ''index out of range in eliminate_entries'') \n       (\\<lambda> _. eliminate_entries_gen_zero mm tt z v (mat_impl m) i j)))\""], "translations": [["", "lemma right_total_mat_rel: \"right_total R \\<Longrightarrow> right_total (mat_rel R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_total R \\<Longrightarrow> right_total (mat_rel R)", "unfolding right_total_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. R x y \\<Longrightarrow>\n    \\<forall>y. \\<exists>x. mat_rel R x y", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<forall>y. \\<exists>x. R x y \\<Longrightarrow>\n       \\<exists>x. mat_rel R x y", "fix B"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<forall>y. \\<exists>x. R x y \\<Longrightarrow>\n       \\<exists>x. mat_rel R x y", "assume \"\\<forall> y. \\<exists> x. R x y\""], ["proof (state)\nthis:\n  \\<forall>y. \\<exists>x. R x y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<forall>y. \\<exists>x. R x y \\<Longrightarrow>\n       \\<exists>x. mat_rel R x y", "from choice[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>f. \\<forall>x. R (f x) x", "obtain f where f: \"\\<And> x. R (f x) x\""], ["proof (prove)\nusing this:\n  \\<exists>f. \\<forall>x. R (f x) x\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        (\\<And>x. R (f x) x) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  R (f ?x) ?x\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<forall>y. \\<exists>x. R x y \\<Longrightarrow>\n       \\<exists>x. mat_rel R x y", "show \"\\<exists> A. mat_rel R A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A. mat_rel R A B", "by (rule exI[of _ \"map_mat f B\"], unfold mat_rel_def, auto simp: f)"], ["proof (state)\nthis:\n  \\<exists>A. mat_rel R A B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma left_unique_mat_rel: \"left_unique R \\<Longrightarrow> left_unique (mat_rel R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_unique R \\<Longrightarrow> left_unique (mat_rel R)", "unfolding left_unique_def mat_rel_def mat_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       R x z \\<longrightarrow>\n       R y z \\<longrightarrow> x = y \\<Longrightarrow>\n    \\<forall>x y z.\n       dim_row x = dim_row z \\<and>\n       dim_col x = dim_col z \\<and>\n       (\\<forall>i j.\n           i < dim_row z \\<longrightarrow>\n           j < dim_col z \\<longrightarrow>\n           R (x $$ (i, j)) (z $$ (i, j))) \\<longrightarrow>\n       dim_row y = dim_row z \\<and>\n       dim_col y = dim_col z \\<and>\n       (\\<forall>i j.\n           i < dim_row z \\<longrightarrow>\n           j < dim_col z \\<longrightarrow>\n           R (y $$ (i, j)) (z $$ (i, j))) \\<longrightarrow>\n       dim_row x = dim_row y \\<and>\n       dim_col x = dim_col y \\<and>\n       (\\<forall>i j.\n           i < dim_row y \\<longrightarrow>\n           j < dim_col y \\<longrightarrow> x $$ (i, j) = y $$ (i, j))", "by (auto, blast)"], ["", "lemma right_unique_mat_rel: \"right_unique R \\<Longrightarrow> right_unique (mat_rel R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_unique R \\<Longrightarrow> right_unique (mat_rel R)", "unfolding right_unique_def mat_rel_def mat_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       R x y \\<longrightarrow>\n       R x z \\<longrightarrow> y = z \\<Longrightarrow>\n    \\<forall>x y z.\n       dim_row x = dim_row y \\<and>\n       dim_col x = dim_col y \\<and>\n       (\\<forall>i j.\n           i < dim_row y \\<longrightarrow>\n           j < dim_col y \\<longrightarrow>\n           R (x $$ (i, j)) (y $$ (i, j))) \\<longrightarrow>\n       dim_row x = dim_row z \\<and>\n       dim_col x = dim_col z \\<and>\n       (\\<forall>i j.\n           i < dim_row z \\<longrightarrow>\n           j < dim_col z \\<longrightarrow>\n           R (x $$ (i, j)) (z $$ (i, j))) \\<longrightarrow>\n       dim_row y = dim_row z \\<and>\n       dim_col y = dim_col z \\<and>\n       (\\<forall>i j.\n           i < dim_row z \\<longrightarrow>\n           j < dim_col z \\<longrightarrow> y $$ (i, j) = z $$ (i, j))", "by (auto, blast)"], ["", "lemma bi_unique_mat_rel: \"bi_unique R \\<Longrightarrow> bi_unique (mat_rel R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique R \\<Longrightarrow> bi_unique (mat_rel R)", "using left_unique_mat_rel[of R] right_unique_mat_rel[of R]"], ["proof (prove)\nusing this:\n  left_unique R \\<Longrightarrow> left_unique (mat_rel R)\n  right_unique R \\<Longrightarrow> right_unique (mat_rel R)\n\ngoal (1 subgoal):\n 1. bi_unique R \\<Longrightarrow> bi_unique (mat_rel R)", "unfolding bi_unique_def left_unique_def right_unique_def"], ["proof (prove)\nusing this:\n  \\<forall>x y z.\n     R x z \\<longrightarrow> R y z \\<longrightarrow> x = y \\<Longrightarrow>\n  \\<forall>x y z.\n     mat_rel R x z \\<longrightarrow> mat_rel R y z \\<longrightarrow> x = y\n  \\<forall>x y z.\n     R x y \\<longrightarrow> R x z \\<longrightarrow> y = z \\<Longrightarrow>\n  \\<forall>x y z.\n     mat_rel R x y \\<longrightarrow> mat_rel R x z \\<longrightarrow> y = z\n\ngoal (1 subgoal):\n 1. (\\<forall>x y z.\n        R x y \\<longrightarrow> R x z \\<longrightarrow> y = z) \\<and>\n    (\\<forall>x y z.\n        R x z \\<longrightarrow>\n        R y z \\<longrightarrow> x = y) \\<Longrightarrow>\n    (\\<forall>x y z.\n        mat_rel R x y \\<longrightarrow>\n        mat_rel R x z \\<longrightarrow> y = z) \\<and>\n    (\\<forall>x y z.\n        mat_rel R x z \\<longrightarrow>\n        mat_rel R y z \\<longrightarrow> x = y)", "by blast"], ["", "lemma mat_rel_eq: \"((R ===> R ===> (=))) (=) (=) \\<Longrightarrow> \n  ((mat_rel R ===> mat_rel R ===> (=))) (=) (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (R ===> R ===> (=)) (=) (=) \\<Longrightarrow>\n    (mat_rel R ===> mat_rel R ===> (=)) (=) (=)", "unfolding mat_rel_def rel_fun_def mat_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       R x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           R xa ya \\<longrightarrow> (x = xa) = (y = ya)) \\<Longrightarrow>\n    \\<forall>x y.\n       dim_row x = dim_row y \\<and>\n       dim_col x = dim_col y \\<and>\n       (\\<forall>i j.\n           i < dim_row y \\<longrightarrow>\n           j < dim_col y \\<longrightarrow>\n           R (x $$ (i, j)) (y $$ (i, j))) \\<longrightarrow>\n       (\\<forall>xa ya.\n           dim_row xa = dim_row ya \\<and>\n           dim_col xa = dim_col ya \\<and>\n           (\\<forall>i j.\n               i < dim_row ya \\<longrightarrow>\n               j < dim_col ya \\<longrightarrow>\n               R (xa $$ (i, j)) (ya $$ (i, j))) \\<longrightarrow>\n           (dim_row x = dim_row xa \\<and>\n            dim_col x = dim_col xa \\<and>\n            (\\<forall>i j.\n                i < dim_row xa \\<longrightarrow>\n                j < dim_col xa \\<longrightarrow>\n                x $$ (i, j) = xa $$ (i, j))) =\n           (dim_row y = dim_row ya \\<and>\n            dim_col y = dim_col ya \\<and>\n            (\\<forall>i j.\n                i < dim_row ya \\<longrightarrow>\n                j < dim_col ya \\<longrightarrow>\n                y $$ (i, j) = ya $$ (i, j))))", "by (auto, blast+)"], ["", "definition vec_rel :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> 'a vec \\<Rightarrow> 'b vec \\<Rightarrow> bool\" where\n  \"vec_rel R A B \\<equiv> dim_vec A = dim_vec B \\<and> (\\<forall> i. i < dim_vec B \\<longrightarrow> R (A $ i) (B $ i))\""], ["", "lemma right_total_vec_rel: \"right_total R \\<Longrightarrow> right_total (vec_rel R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_total R \\<Longrightarrow> right_total (vec_rel R)", "unfolding right_total_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. R x y \\<Longrightarrow>\n    \\<forall>y. \\<exists>x. vec_rel R x y", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<forall>y. \\<exists>x. R x y \\<Longrightarrow>\n       \\<exists>x. vec_rel R x y", "fix B"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<forall>y. \\<exists>x. R x y \\<Longrightarrow>\n       \\<exists>x. vec_rel R x y", "assume \"\\<forall> y. \\<exists> x. R x y\""], ["proof (state)\nthis:\n  \\<forall>y. \\<exists>x. R x y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<forall>y. \\<exists>x. R x y \\<Longrightarrow>\n       \\<exists>x. vec_rel R x y", "from choice[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>f. \\<forall>x. R (f x) x", "obtain f where f: \"\\<And> x. R (f x) x\""], ["proof (prove)\nusing this:\n  \\<exists>f. \\<forall>x. R (f x) x\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        (\\<And>x. R (f x) x) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  R (f ?x) ?x\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<forall>y. \\<exists>x. R x y \\<Longrightarrow>\n       \\<exists>x. vec_rel R x y", "show \"\\<exists> A. vec_rel R A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A. vec_rel R A B", "by (rule exI[of _ \"map_vec f B\"], unfold vec_rel_def, auto simp: f)"], ["proof (state)\nthis:\n  \\<exists>A. vec_rel R A B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma left_unique_vec_rel: \"left_unique R \\<Longrightarrow> left_unique (vec_rel R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_unique R \\<Longrightarrow> left_unique (vec_rel R)", "unfolding left_unique_def vec_rel_def vec_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       R x z \\<longrightarrow>\n       R y z \\<longrightarrow> x = y \\<Longrightarrow>\n    \\<forall>x y z.\n       dim_vec x = dim_vec z \\<and>\n       (\\<forall>i<dim_vec z. R (x $ i) (z $ i)) \\<longrightarrow>\n       dim_vec y = dim_vec z \\<and>\n       (\\<forall>i<dim_vec z. R (y $ i) (z $ i)) \\<longrightarrow>\n       dim_vec x = dim_vec y \\<and> (\\<forall>i<dim_vec y. x $ i = y $ i)", "by auto"], ["", "lemma right_unique_vec_rel: \"right_unique R \\<Longrightarrow> right_unique (vec_rel R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_unique R \\<Longrightarrow> right_unique (vec_rel R)", "unfolding right_unique_def vec_rel_def vec_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       R x y \\<longrightarrow>\n       R x z \\<longrightarrow> y = z \\<Longrightarrow>\n    \\<forall>x y z.\n       dim_vec x = dim_vec y \\<and>\n       (\\<forall>i<dim_vec y. R (x $ i) (y $ i)) \\<longrightarrow>\n       dim_vec x = dim_vec z \\<and>\n       (\\<forall>i<dim_vec z. R (x $ i) (z $ i)) \\<longrightarrow>\n       dim_vec y = dim_vec z \\<and> (\\<forall>i<dim_vec z. y $ i = z $ i)", "by auto"], ["", "lemma bi_unique_vec_rel: \"bi_unique R \\<Longrightarrow> bi_unique (vec_rel R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique R \\<Longrightarrow> bi_unique (vec_rel R)", "using left_unique_vec_rel[of R] right_unique_vec_rel[of R]"], ["proof (prove)\nusing this:\n  left_unique R \\<Longrightarrow> left_unique (vec_rel R)\n  right_unique R \\<Longrightarrow> right_unique (vec_rel R)\n\ngoal (1 subgoal):\n 1. bi_unique R \\<Longrightarrow> bi_unique (vec_rel R)", "unfolding bi_unique_def left_unique_def right_unique_def"], ["proof (prove)\nusing this:\n  \\<forall>x y z.\n     R x z \\<longrightarrow> R y z \\<longrightarrow> x = y \\<Longrightarrow>\n  \\<forall>x y z.\n     vec_rel R x z \\<longrightarrow> vec_rel R y z \\<longrightarrow> x = y\n  \\<forall>x y z.\n     R x y \\<longrightarrow> R x z \\<longrightarrow> y = z \\<Longrightarrow>\n  \\<forall>x y z.\n     vec_rel R x y \\<longrightarrow> vec_rel R x z \\<longrightarrow> y = z\n\ngoal (1 subgoal):\n 1. (\\<forall>x y z.\n        R x y \\<longrightarrow> R x z \\<longrightarrow> y = z) \\<and>\n    (\\<forall>x y z.\n        R x z \\<longrightarrow>\n        R y z \\<longrightarrow> x = y) \\<Longrightarrow>\n    (\\<forall>x y z.\n        vec_rel R x y \\<longrightarrow>\n        vec_rel R x z \\<longrightarrow> y = z) \\<and>\n    (\\<forall>x y z.\n        vec_rel R x z \\<longrightarrow>\n        vec_rel R y z \\<longrightarrow> x = y)", "by blast"], ["", "lemma vec_rel_eq: \"((R ===> R ===> (=))) (=) (=) \\<Longrightarrow> \n  ((vec_rel R ===> vec_rel R ===> (=))) (=) (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (R ===> R ===> (=)) (=) (=) \\<Longrightarrow>\n    (vec_rel R ===> vec_rel R ===> (=)) (=) (=)", "unfolding vec_rel_def rel_fun_def vec_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       R x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           R xa ya \\<longrightarrow> (x = xa) = (y = ya)) \\<Longrightarrow>\n    \\<forall>x y.\n       dim_vec x = dim_vec y \\<and>\n       (\\<forall>i<dim_vec y. R (x $ i) (y $ i)) \\<longrightarrow>\n       (\\<forall>xa ya.\n           dim_vec xa = dim_vec ya \\<and>\n           (\\<forall>i<dim_vec ya. R (xa $ i) (ya $ i)) \\<longrightarrow>\n           (dim_vec x = dim_vec xa \\<and>\n            (\\<forall>i<dim_vec xa. x $ i = xa $ i)) =\n           (dim_vec y = dim_vec ya \\<and>\n            (\\<forall>i<dim_vec ya. y $ i = ya $ i)))", "by (auto, blast+)"], ["", "lemma multrow_transfer[transfer_rule]: \"((R ===> R ===> R) ===> (=) ===> R\n  ===> mat_rel R ===> mat_rel R) mat_multrow_gen mat_multrow_gen\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((R ===> R ===> R) ===> (=) ===> R ===> mat_rel R ===> mat_rel R)\n     mat_multrow_gen mat_multrow_gen", "unfolding mat_rel_def[abs_def] mat_multrow_gen_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((R ===> R ===> R) ===>\n     (=) ===>\n     R ===>\n     (\\<lambda>A B.\n         dim_row A = dim_row B \\<and>\n         dim_col A = dim_col B \\<and>\n         (\\<forall>i j.\n             i < dim_row B \\<longrightarrow>\n             j < dim_col B \\<longrightarrow>\n             R (A $$ (i, j)) (B $$ (i, j)))) ===>\n     (\\<lambda>A B.\n         dim_row A = dim_row B \\<and>\n         dim_col A = dim_col B \\<and>\n         (\\<forall>i j.\n             i < dim_row B \\<longrightarrow>\n             j < dim_col B \\<longrightarrow>\n             R (A $$ (i, j)) (B $$ (i, j)))))\n     (\\<lambda>mul k a A.\n         mat (dim_row A) (dim_col A)\n          (\\<lambda>(i, j).\n              if k = i then mul a (A $$ (i, j)) else A $$ (i, j)))\n     (\\<lambda>mul k a A.\n         mat (dim_row A) (dim_col A)\n          (\\<lambda>(i, j).\n              if k = i then mul a (A $$ (i, j)) else A $$ (i, j)))", "by (intro rel_funI conjI allI impI eq_matI, auto simp: rel_fun_def)"], ["", "(* we need index restrictions, TODO: can this be incorporated into transfer rule? *)"], ["", "lemma swap_rows_transfer: \"mat_rel R A B \\<Longrightarrow> i < dim_row B \\<Longrightarrow> j < dim_row B \\<Longrightarrow> \n  mat_rel R (mat_swaprows i j A) (mat_swaprows i j B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mat_rel R A B; i < dim_row B; j < dim_row B\\<rbrakk>\n    \\<Longrightarrow> mat_rel R (swaprows i j A) (swaprows i j B)", "unfolding mat_rel_def mat_swaprows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dim_row A = dim_row B \\<and>\n             dim_col A = dim_col B \\<and>\n             (\\<forall>i j.\n                 i < dim_row B \\<longrightarrow>\n                 j < dim_col B \\<longrightarrow>\n                 R (A $$ (i, j)) (B $$ (i, j)));\n     i < dim_row B; j < dim_row B\\<rbrakk>\n    \\<Longrightarrow> dim_row\n                       (mat (dim_row A) (dim_col A)\n                         (\\<lambda>(ia, ja).\n                             if i = ia then A $$ (j, ja)\n                             else if j = ia then A $$ (i, ja)\n                                  else A $$ (ia, ja))) =\n                      dim_row\n                       (mat (dim_row B) (dim_col B)\n                         (\\<lambda>(ia, ja).\n                             if i = ia then B $$ (j, ja)\n                             else if j = ia then B $$ (i, ja)\n                                  else B $$ (ia, ja))) \\<and>\n                      dim_col\n                       (mat (dim_row A) (dim_col A)\n                         (\\<lambda>(ia, ja).\n                             if i = ia then A $$ (j, ja)\n                             else if j = ia then A $$ (i, ja)\n                                  else A $$ (ia, ja))) =\n                      dim_col\n                       (mat (dim_row B) (dim_col B)\n                         (\\<lambda>(ia, ja).\n                             if i = ia then B $$ (j, ja)\n                             else if j = ia then B $$ (i, ja)\n                                  else B $$ (ia, ja))) \\<and>\n                      (\\<forall>ia ja.\n                          ia < dim_row\n                                (mat (dim_row B) (dim_col B)\n                                  (\\<lambda>(ia, ja).\nif i = ia then B $$ (j, ja)\nelse if j = ia then B $$ (i, ja) else B $$ (ia, ja))) \\<longrightarrow>\n                          ja < dim_col\n                                (mat (dim_row B) (dim_col B)\n                                  (\\<lambda>(ia, ja).\nif i = ia then B $$ (j, ja)\nelse if j = ia then B $$ (i, ja) else B $$ (ia, ja))) \\<longrightarrow>\n                          R (mat (dim_row A) (dim_col A)\n                              (\\<lambda>(ia, ja).\n                                  if i = ia then A $$ (j, ja)\n                                  else if j = ia then A $$ (i, ja)\n else A $$ (ia, ja)) $$\n                             (ia, ja))\n                           (mat (dim_row B) (dim_col B)\n                             (\\<lambda>(ia, ja).\n                                 if i = ia then B $$ (j, ja)\n                                 else if j = ia then B $$ (i, ja)\nelse B $$ (ia, ja)) $$\n                            (ia, ja)))", "by (intro rel_funI conjI allI impI eq_matI, auto)"], ["", "lemma pivot_positions_gen_transfer: assumes [transfer_rule]: \"(R ===> R ===> (=)) (=) (=)\" \n  shows \n  \"(R ===> mat_rel R ===> (=)) pivot_positions_gen pivot_positions_gen\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (R ===> mat_rel R ===> (=)) pivot_positions_gen pivot_positions_gen", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>R x y; mat_rel R xa ya\\<rbrakk>\n       \\<Longrightarrow> pivot_positions_gen x xa = pivot_positions_gen y ya", "case (1 ze ze' A A')"], ["proof (state)\nthis:\n  R ze ze'\n  mat_rel R A A'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>R x y; mat_rel R xa ya\\<rbrakk>\n       \\<Longrightarrow> pivot_positions_gen x xa = pivot_positions_gen y ya", "note trans[transfer_rule] = 1"], ["proof (state)\nthis:\n  R ze ze'\n  mat_rel R A A'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>R x y; mat_rel R xa ya\\<rbrakk>\n       \\<Longrightarrow> pivot_positions_gen x xa = pivot_positions_gen y ya", "from 1"], ["proof (chain)\npicking this:\n  R ze ze'\n  mat_rel R A A'", "have dim: \"dim_row A = dim_row A'\" \"dim_col A = dim_col A'\""], ["proof (prove)\nusing this:\n  R ze ze'\n  mat_rel R A A'\n\ngoal (1 subgoal):\n 1. dim_row A = dim_row A' &&& dim_col A = dim_col A'", "unfolding mat_rel_def"], ["proof (prove)\nusing this:\n  R ze ze'\n  dim_row A = dim_row A' \\<and>\n  dim_col A = dim_col A' \\<and>\n  (\\<forall>i j.\n      i < dim_row A' \\<longrightarrow>\n      j < dim_col A' \\<longrightarrow> R (A $$ (i, j)) (A' $$ (i, j)))\n\ngoal (1 subgoal):\n 1. dim_row A = dim_row A' &&& dim_col A = dim_col A'", "by auto"], ["proof (state)\nthis:\n  dim_row A = dim_row A'\n  dim_col A = dim_col A'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>R x y; mat_rel R xa ya\\<rbrakk>\n       \\<Longrightarrow> pivot_positions_gen x xa = pivot_positions_gen y ya", "obtain i j where id: \"i = 0\" \"j = 0\" and ij: \"i \\<le> dim_row A'\" \"j \\<le> dim_col A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i = 0; j = 0; i \\<le> dim_row A';\n         j \\<le> dim_col A'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i = 0\n  j = 0\n  i \\<le> dim_row A'\n  j \\<le> dim_col A'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>R x y; mat_rel R xa ya\\<rbrakk>\n       \\<Longrightarrow> pivot_positions_gen x xa = pivot_positions_gen y ya", "have \"pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "using ij"], ["proof (prove)\nusing this:\n  i \\<le> dim_row A'\n  j \\<le> dim_col A'\n\ngoal (1 subgoal):\n 1. pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "proof (induct i j rule: pivot_positions_main_gen.induct[of \"dim_row A'\" \"dim_col A'\" A' ze'])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < dim_row A'; j < dim_col A'; A' $$ (i, j) = ze';\n                 i \\<le> dim_row A'; Suc j \\<le> dim_col A'\\<rbrakk>\n                \\<Longrightarrow> pivot_positions_main_gen ze A (dim_row A)\n                                   (dim_col A) i (Suc j) =\n                                  pivot_positions_main_gen ze' A'\n                                   (dim_row A') (dim_col A') i (Suc j);\n        \\<lbrakk>i < dim_row A'; j < dim_col A'; A' $$ (i, j) \\<noteq> ze';\n         Suc i \\<le> dim_row A'; Suc j \\<le> dim_col A'\\<rbrakk>\n        \\<Longrightarrow> pivot_positions_main_gen ze A (dim_row A)\n                           (dim_col A) (Suc i) (Suc j) =\n                          pivot_positions_main_gen ze' A' (dim_row A')\n                           (dim_col A') (Suc i) (Suc j);\n        i \\<le> dim_row A'; j \\<le> dim_col A'\\<rbrakk>\n       \\<Longrightarrow> pivot_positions_main_gen ze A (dim_row A)\n                          (dim_col A) i j =\n                         pivot_positions_main_gen ze' A' (dim_row A')\n                          (dim_col A') i j", "case (1 i j)"], ["proof (state)\nthis:\n  \\<lbrakk>i < dim_row A'; j < dim_col A'; A' $$ (i, j) = ze';\n   i \\<le> dim_row A'; Suc j \\<le> dim_col A'\\<rbrakk>\n  \\<Longrightarrow> pivot_positions_main_gen ze A (dim_row A) (dim_col A) i\n                     (Suc j) =\n                    pivot_positions_main_gen ze' A' (dim_row A')\n                     (dim_col A') i (Suc j)\n  \\<lbrakk>i < dim_row A'; j < dim_col A'; A' $$ (i, j) \\<noteq> ze';\n   Suc i \\<le> dim_row A'; Suc j \\<le> dim_col A'\\<rbrakk>\n  \\<Longrightarrow> pivot_positions_main_gen ze A (dim_row A) (dim_col A)\n                     (Suc i) (Suc j) =\n                    pivot_positions_main_gen ze' A' (dim_row A')\n                     (dim_col A') (Suc i) (Suc j)\n  i \\<le> dim_row A'\n  j \\<le> dim_col A'\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < dim_row A'; j < dim_col A'; A' $$ (i, j) = ze';\n                 i \\<le> dim_row A'; Suc j \\<le> dim_col A'\\<rbrakk>\n                \\<Longrightarrow> pivot_positions_main_gen ze A (dim_row A)\n                                   (dim_col A) i (Suc j) =\n                                  pivot_positions_main_gen ze' A'\n                                   (dim_row A') (dim_col A') i (Suc j);\n        \\<lbrakk>i < dim_row A'; j < dim_col A'; A' $$ (i, j) \\<noteq> ze';\n         Suc i \\<le> dim_row A'; Suc j \\<le> dim_col A'\\<rbrakk>\n        \\<Longrightarrow> pivot_positions_main_gen ze A (dim_row A)\n                           (dim_col A) (Suc i) (Suc j) =\n                          pivot_positions_main_gen ze' A' (dim_row A')\n                           (dim_col A') (Suc i) (Suc j);\n        i \\<le> dim_row A'; j \\<le> dim_col A'\\<rbrakk>\n       \\<Longrightarrow> pivot_positions_main_gen ze A (dim_row A)\n                          (dim_col A) i j =\n                         pivot_positions_main_gen ze' A' (dim_row A')\n                          (dim_col A') i j", "note simps[simp] = pivot_positions_main_gen.simps[of _ _ _ _ i j]"], ["proof (state)\nthis:\n  pivot_positions_main_gen ?zero ?A ?nr ?nc i j =\n  (if i < ?nr\n   then if j < ?nc\n        then if ?A $$ (i, j) = ?zero\n             then pivot_positions_main_gen ?zero ?A ?nr ?nc i (Suc j)\n             else (i, j) #\n                  pivot_positions_main_gen ?zero ?A ?nr ?nc (Suc i) (Suc j)\n        else []\n   else [])\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < dim_row A'; j < dim_col A'; A' $$ (i, j) = ze';\n                 i \\<le> dim_row A'; Suc j \\<le> dim_col A'\\<rbrakk>\n                \\<Longrightarrow> pivot_positions_main_gen ze A (dim_row A)\n                                   (dim_col A) i (Suc j) =\n                                  pivot_positions_main_gen ze' A'\n                                   (dim_row A') (dim_col A') i (Suc j);\n        \\<lbrakk>i < dim_row A'; j < dim_col A'; A' $$ (i, j) \\<noteq> ze';\n         Suc i \\<le> dim_row A'; Suc j \\<le> dim_col A'\\<rbrakk>\n        \\<Longrightarrow> pivot_positions_main_gen ze A (dim_row A)\n                           (dim_col A) (Suc i) (Suc j) =\n                          pivot_positions_main_gen ze' A' (dim_row A')\n                           (dim_col A') (Suc i) (Suc j);\n        i \\<le> dim_row A'; j \\<le> dim_col A'\\<rbrakk>\n       \\<Longrightarrow> pivot_positions_main_gen ze A (dim_row A)\n                          (dim_col A) i j =\n                         pivot_positions_main_gen ze' A' (dim_row A')\n                          (dim_col A') i j", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "proof (cases \"i < dim_row A' \\<and> j < dim_col A'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < dim_row A' \\<and> j < dim_col A' \\<Longrightarrow>\n    pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j\n 2. \\<not> (i < dim_row A' \\<and> j < dim_col A') \\<Longrightarrow>\n    pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "case False"], ["proof (state)\nthis:\n  \\<not> (i < dim_row A' \\<and> j < dim_col A')\n\ngoal (2 subgoals):\n 1. i < dim_row A' \\<and> j < dim_col A' \\<Longrightarrow>\n    pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j\n 2. \\<not> (i < dim_row A' \\<and> j < dim_col A') \\<Longrightarrow>\n    pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "with dim"], ["proof (chain)\npicking this:\n  dim_row A = dim_row A'\n  dim_col A = dim_col A'\n  \\<not> (i < dim_row A' \\<and> j < dim_col A')", "show ?thesis"], ["proof (prove)\nusing this:\n  dim_row A = dim_row A'\n  dim_col A = dim_col A'\n  \\<not> (i < dim_row A' \\<and> j < dim_col A')\n\ngoal (1 subgoal):\n 1. pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "by auto"], ["proof (state)\nthis:\n  pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n  pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j\n\ngoal (1 subgoal):\n 1. i < dim_row A' \\<and> j < dim_col A' \\<Longrightarrow>\n    pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < dim_row A' \\<and> j < dim_col A' \\<Longrightarrow>\n    pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "case True"], ["proof (state)\nthis:\n  i < dim_row A' \\<and> j < dim_col A'\n\ngoal (1 subgoal):\n 1. i < dim_row A' \\<and> j < dim_col A' \\<Longrightarrow>\n    pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "hence ij: \"i < dim_row A'\" \"j < dim_col A'\" and j: \"Suc j \\<le> dim_col A'\""], ["proof (prove)\nusing this:\n  i < dim_row A' \\<and> j < dim_col A'\n\ngoal (1 subgoal):\n 1. (i < dim_row A' &&& j < dim_col A') &&& Suc j \\<le> dim_col A'", "by auto"], ["proof (state)\nthis:\n  i < dim_row A'\n  j < dim_col A'\n  Suc j \\<le> dim_col A'\n\ngoal (1 subgoal):\n 1. i < dim_row A' \\<and> j < dim_col A' \\<Longrightarrow>\n    pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "note IH = 1(1-2)[OF ij _ _ j]"], ["proof (state)\nthis:\n  \\<lbrakk>A' $$ (i, j) = ze'; i \\<le> dim_row A'\\<rbrakk>\n  \\<Longrightarrow> pivot_positions_main_gen ze A (dim_row A) (dim_col A) i\n                     (Suc j) =\n                    pivot_positions_main_gen ze' A' (dim_row A')\n                     (dim_col A') i (Suc j)\n  \\<lbrakk>A' $$ (i, j) \\<noteq> ze'; Suc i \\<le> dim_row A'\\<rbrakk>\n  \\<Longrightarrow> pivot_positions_main_gen ze A (dim_row A) (dim_col A)\n                     (Suc i) (Suc j) =\n                    pivot_positions_main_gen ze' A' (dim_row A')\n                     (dim_col A') (Suc i) (Suc j)\n\ngoal (1 subgoal):\n 1. i < dim_row A' \\<and> j < dim_col A' \\<Longrightarrow>\n    pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "from ij True trans"], ["proof (chain)\npicking this:\n  i < dim_row A'\n  j < dim_col A'\n  i < dim_row A' \\<and> j < dim_col A'\n  R ze ze'\n  mat_rel R A A'", "have [transfer_rule]:\"R (A $$ (i,j)) (A' $$ (i,j))\""], ["proof (prove)\nusing this:\n  i < dim_row A'\n  j < dim_col A'\n  i < dim_row A' \\<and> j < dim_col A'\n  R ze ze'\n  mat_rel R A A'\n\ngoal (1 subgoal):\n 1. R (A $$ (i, j)) (A' $$ (i, j))", "unfolding mat_rel_def"], ["proof (prove)\nusing this:\n  i < dim_row A'\n  j < dim_col A'\n  i < dim_row A' \\<and> j < dim_col A'\n  R ze ze'\n  dim_row A = dim_row A' \\<and>\n  dim_col A = dim_col A' \\<and>\n  (\\<forall>i j.\n      i < dim_row A' \\<longrightarrow>\n      j < dim_col A' \\<longrightarrow> R (A $$ (i, j)) (A' $$ (i, j)))\n\ngoal (1 subgoal):\n 1. R (A $$ (i, j)) (A' $$ (i, j))", "by auto"], ["proof (state)\nthis:\n  R (A $$ (i, j)) (A' $$ (i, j))\n\ngoal (1 subgoal):\n 1. i < dim_row A' \\<and> j < dim_col A' \\<Longrightarrow>\n    pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "have eq: \"(A $$ (i,j) = ze) = (A' $$ (i,j) = ze')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A $$ (i, j) = ze) = (A' $$ (i, j) = ze')", "by transfer_prover"], ["proof (state)\nthis:\n  (A $$ (i, j) = ze) = (A' $$ (i, j) = ze')\n\ngoal (1 subgoal):\n 1. i < dim_row A' \\<and> j < dim_col A' \\<Longrightarrow>\n    pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "proof (cases \"A' $$ (i,j) = ze'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A' $$ (i, j) = ze' \\<Longrightarrow>\n    pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j\n 2. A' $$ (i, j) \\<noteq> ze' \\<Longrightarrow>\n    pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "case True"], ["proof (state)\nthis:\n  A' $$ (i, j) = ze'\n\ngoal (2 subgoals):\n 1. A' $$ (i, j) = ze' \\<Longrightarrow>\n    pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j\n 2. A' $$ (i, j) \\<noteq> ze' \\<Longrightarrow>\n    pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "from ij"], ["proof (chain)\npicking this:\n  i < dim_row A'\n  j < dim_col A'", "have \"i \\<le> dim_row A'\""], ["proof (prove)\nusing this:\n  i < dim_row A'\n  j < dim_col A'\n\ngoal (1 subgoal):\n 1. i \\<le> dim_row A'", "by auto"], ["proof (state)\nthis:\n  i \\<le> dim_row A'\n\ngoal (2 subgoals):\n 1. A' $$ (i, j) = ze' \\<Longrightarrow>\n    pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j\n 2. A' $$ (i, j) \\<noteq> ze' \\<Longrightarrow>\n    pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "note IH = IH(1)[OF True this]"], ["proof (state)\nthis:\n  pivot_positions_main_gen ze A (dim_row A) (dim_col A) i (Suc j) =\n  pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i (Suc j)\n\ngoal (2 subgoals):\n 1. A' $$ (i, j) = ze' \\<Longrightarrow>\n    pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j\n 2. A' $$ (i, j) \\<noteq> ze' \\<Longrightarrow>\n    pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "thus ?thesis"], ["proof (prove)\nusing this:\n  pivot_positions_main_gen ze A (dim_row A) (dim_col A) i (Suc j) =\n  pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i (Suc j)\n\ngoal (1 subgoal):\n 1. pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "using True ij dim eq"], ["proof (prove)\nusing this:\n  pivot_positions_main_gen ze A (dim_row A) (dim_col A) i (Suc j) =\n  pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i (Suc j)\n  A' $$ (i, j) = ze'\n  i < dim_row A'\n  j < dim_col A'\n  dim_row A = dim_row A'\n  dim_col A = dim_col A'\n  (A $$ (i, j) = ze) = (A' $$ (i, j) = ze')\n\ngoal (1 subgoal):\n 1. pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "by simp"], ["proof (state)\nthis:\n  pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n  pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j\n\ngoal (1 subgoal):\n 1. A' $$ (i, j) \\<noteq> ze' \\<Longrightarrow>\n    pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A' $$ (i, j) \\<noteq> ze' \\<Longrightarrow>\n    pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "case False"], ["proof (state)\nthis:\n  A' $$ (i, j) \\<noteq> ze'\n\ngoal (1 subgoal):\n 1. A' $$ (i, j) \\<noteq> ze' \\<Longrightarrow>\n    pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "from ij"], ["proof (chain)\npicking this:\n  i < dim_row A'\n  j < dim_col A'", "have \"Suc i \\<le> dim_row A'\""], ["proof (prove)\nusing this:\n  i < dim_row A'\n  j < dim_col A'\n\ngoal (1 subgoal):\n 1. Suc i \\<le> dim_row A'", "by auto"], ["proof (state)\nthis:\n  Suc i \\<le> dim_row A'\n\ngoal (1 subgoal):\n 1. A' $$ (i, j) \\<noteq> ze' \\<Longrightarrow>\n    pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "note IH = IH(2)[OF False this]"], ["proof (state)\nthis:\n  pivot_positions_main_gen ze A (dim_row A) (dim_col A) (Suc i) (Suc j) =\n  pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') (Suc i) (Suc j)\n\ngoal (1 subgoal):\n 1. A' $$ (i, j) \\<noteq> ze' \\<Longrightarrow>\n    pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "thus ?thesis"], ["proof (prove)\nusing this:\n  pivot_positions_main_gen ze A (dim_row A) (dim_col A) (Suc i) (Suc j) =\n  pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') (Suc i) (Suc j)\n\ngoal (1 subgoal):\n 1. pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "using False ij dim eq"], ["proof (prove)\nusing this:\n  pivot_positions_main_gen ze A (dim_row A) (dim_col A) (Suc i) (Suc j) =\n  pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') (Suc i) (Suc j)\n  A' $$ (i, j) \\<noteq> ze'\n  i < dim_row A'\n  j < dim_col A'\n  dim_row A = dim_row A'\n  dim_col A = dim_col A'\n  (A $$ (i, j) = ze) = (A' $$ (i, j) = ze')\n\ngoal (1 subgoal):\n 1. pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j", "by simp"], ["proof (state)\nthis:\n  pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n  pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n  pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n  pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n  pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>R x y; mat_rel R xa ya\\<rbrakk>\n       \\<Longrightarrow> pivot_positions_gen x xa = pivot_positions_gen y ya", "thus \"pivot_positions_gen ze A = pivot_positions_gen ze' A'\""], ["proof (prove)\nusing this:\n  pivot_positions_main_gen ze A (dim_row A) (dim_col A) i j =\n  pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') i j\n\ngoal (1 subgoal):\n 1. pivot_positions_gen ze A = pivot_positions_gen ze' A'", "unfolding pivot_positions_gen_def id"], ["proof (prove)\nusing this:\n  pivot_positions_main_gen ze A (dim_row A) (dim_col A) 0 0 =\n  pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') 0 0\n\ngoal (1 subgoal):\n 1. pivot_positions_main_gen ze A (dim_row A) (dim_col A) 0 0 =\n    pivot_positions_main_gen ze' A' (dim_row A') (dim_col A') 0 0", "."], ["proof (state)\nthis:\n  pivot_positions_gen ze A = pivot_positions_gen ze' A'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_pivot_positions_main_gen: \n  \"set (pivot_positions_main_gen ze A nr nc i j) \\<subseteq> {0 ..< nr} \\<times> {0 ..< nc}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (pivot_positions_main_gen ze A nr nc i j)\n    \\<subseteq> {0..<nr} \\<times> {0..<nc}", "proof (induct i j rule: pivot_positions_main_gen.induct[of nr nc A ze])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < nr; j < nc; A $$ (i, j) = ze\\<rbrakk>\n                \\<Longrightarrow> set (pivot_positions_main_gen ze A nr nc i\n  (Suc j))\n                                  \\<subseteq> {0..<nr} \\<times> {0..<nc};\n        \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> ze\\<rbrakk>\n        \\<Longrightarrow> set (pivot_positions_main_gen ze A nr nc (Suc i)\n                                (Suc j))\n                          \\<subseteq> {0..<nr} \\<times> {0..<nc}\\<rbrakk>\n       \\<Longrightarrow> set (pivot_positions_main_gen ze A nr nc i j)\n                         \\<subseteq> {0..<nr} \\<times> {0..<nc}", "case (1 i j)"], ["proof (state)\nthis:\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) = ze\\<rbrakk>\n  \\<Longrightarrow> set (pivot_positions_main_gen ze A nr nc i (Suc j))\n                    \\<subseteq> {0..<nr} \\<times> {0..<nc}\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> ze\\<rbrakk>\n  \\<Longrightarrow> set (pivot_positions_main_gen ze A nr nc (Suc i)\n                          (Suc j))\n                    \\<subseteq> {0..<nr} \\<times> {0..<nc}\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < nr; j < nc; A $$ (i, j) = ze\\<rbrakk>\n                \\<Longrightarrow> set (pivot_positions_main_gen ze A nr nc i\n  (Suc j))\n                                  \\<subseteq> {0..<nr} \\<times> {0..<nc};\n        \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> ze\\<rbrakk>\n        \\<Longrightarrow> set (pivot_positions_main_gen ze A nr nc (Suc i)\n                                (Suc j))\n                          \\<subseteq> {0..<nr} \\<times> {0..<nc}\\<rbrakk>\n       \\<Longrightarrow> set (pivot_positions_main_gen ze A nr nc i j)\n                         \\<subseteq> {0..<nr} \\<times> {0..<nc}", "note [simp] = pivot_positions_main_gen.simps[of _ _ _ _ i j]"], ["proof (state)\nthis:\n  pivot_positions_main_gen ?zero ?A ?nr ?nc i j =\n  (if i < ?nr\n   then if j < ?nc\n        then if ?A $$ (i, j) = ?zero\n             then pivot_positions_main_gen ?zero ?A ?nr ?nc i (Suc j)\n             else (i, j) #\n                  pivot_positions_main_gen ?zero ?A ?nr ?nc (Suc i) (Suc j)\n        else []\n   else [])\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < nr; j < nc; A $$ (i, j) = ze\\<rbrakk>\n                \\<Longrightarrow> set (pivot_positions_main_gen ze A nr nc i\n  (Suc j))\n                                  \\<subseteq> {0..<nr} \\<times> {0..<nc};\n        \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> ze\\<rbrakk>\n        \\<Longrightarrow> set (pivot_positions_main_gen ze A nr nc (Suc i)\n                                (Suc j))\n                          \\<subseteq> {0..<nr} \\<times> {0..<nc}\\<rbrakk>\n       \\<Longrightarrow> set (pivot_positions_main_gen ze A nr nc i j)\n                         \\<subseteq> {0..<nr} \\<times> {0..<nc}", "from 1"], ["proof (chain)\npicking this:\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) = ze\\<rbrakk>\n  \\<Longrightarrow> set (pivot_positions_main_gen ze A nr nc i (Suc j))\n                    \\<subseteq> {0..<nr} \\<times> {0..<nc}\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> ze\\<rbrakk>\n  \\<Longrightarrow> set (pivot_positions_main_gen ze A nr nc (Suc i)\n                          (Suc j))\n                    \\<subseteq> {0..<nr} \\<times> {0..<nc}", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) = ze\\<rbrakk>\n  \\<Longrightarrow> set (pivot_positions_main_gen ze A nr nc i (Suc j))\n                    \\<subseteq> {0..<nr} \\<times> {0..<nc}\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> ze\\<rbrakk>\n  \\<Longrightarrow> set (pivot_positions_main_gen ze A nr nc (Suc i)\n                          (Suc j))\n                    \\<subseteq> {0..<nr} \\<times> {0..<nc}\n\ngoal (1 subgoal):\n 1. set (pivot_positions_main_gen ze A nr nc i j)\n    \\<subseteq> {0..<nr} \\<times> {0..<nc}", "by (cases \"i < nr \\<and> j < nc\", auto)"], ["proof (state)\nthis:\n  set (pivot_positions_main_gen ze A nr nc i j)\n  \\<subseteq> {0..<nr} \\<times> {0..<nc}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_base_vectors_transfer: assumes [transfer_rule]: \"(R ===> R ===> (=)) (=) (=)\"\n  shows \"((R ===> R) ===> R ===> R ===> mat_rel R \n  ===> list_all2 (vec_rel R)) find_base_vectors_gen find_base_vectors_gen\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((R ===> R) ===> R ===> R ===> mat_rel R ===> list_all2 (vec_rel R))\n     find_base_vectors_gen find_base_vectors_gen", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>(R ===> R) x y; R xa ya; R xb yb; mat_rel R xc yc\\<rbrakk>\n       \\<Longrightarrow> list_all2 (vec_rel R)\n                          (find_base_vectors_gen x xa xb xc)\n                          (find_base_vectors_gen y ya yb yc)", "case (1 um um' ze ze' on on' A A')"], ["proof (state)\nthis:\n  (R ===> R) um um'\n  R ze ze'\n  R on on'\n  mat_rel R A A'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>(R ===> R) x y; R xa ya; R xb yb; mat_rel R xc yc\\<rbrakk>\n       \\<Longrightarrow> list_all2 (vec_rel R)\n                          (find_base_vectors_gen x xa xb xc)\n                          (find_base_vectors_gen y ya yb yc)", "note trans[transfer_rule] = 1 pivot_positions_gen_transfer[OF assms]"], ["proof (state)\nthis:\n  (R ===> R) um um'\n  R ze ze'\n  R on on'\n  mat_rel R A A'\n  (R ===> mat_rel R ===> (=)) pivot_positions_gen pivot_positions_gen\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>(R ===> R) x y; R xa ya; R xb yb; mat_rel R xc yc\\<rbrakk>\n       \\<Longrightarrow> list_all2 (vec_rel R)\n                          (find_base_vectors_gen x xa xb xc)\n                          (find_base_vectors_gen y ya yb yc)", "from 1(4)"], ["proof (chain)\npicking this:\n  mat_rel R A A'", "have dim: \"dim_row A = dim_row A'\" \"dim_col A = dim_col A'\""], ["proof (prove)\nusing this:\n  mat_rel R A A'\n\ngoal (1 subgoal):\n 1. dim_row A = dim_row A' &&& dim_col A = dim_col A'", "unfolding mat_rel_def"], ["proof (prove)\nusing this:\n  dim_row A = dim_row A' \\<and>\n  dim_col A = dim_col A' \\<and>\n  (\\<forall>i j.\n      i < dim_row A' \\<longrightarrow>\n      j < dim_col A' \\<longrightarrow> R (A $$ (i, j)) (A' $$ (i, j)))\n\ngoal (1 subgoal):\n 1. dim_row A = dim_row A' &&& dim_col A = dim_col A'", "by auto"], ["proof (state)\nthis:\n  dim_row A = dim_row A'\n  dim_col A = dim_col A'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>(R ===> R) x y; R xa ya; R xb yb; mat_rel R xc yc\\<rbrakk>\n       \\<Longrightarrow> list_all2 (vec_rel R)\n                          (find_base_vectors_gen x xa xb xc)\n                          (find_base_vectors_gen y ya yb yc)", "have id: \"pivot_positions_gen ze A = pivot_positions_gen ze' A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_positions_gen ze A = pivot_positions_gen ze' A'", "by transfer_prover"], ["proof (state)\nthis:\n  pivot_positions_gen ze A = pivot_positions_gen ze' A'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>(R ===> R) x y; R xa ya; R xb yb; mat_rel R xc yc\\<rbrakk>\n       \\<Longrightarrow> list_all2 (vec_rel R)\n                          (find_base_vectors_gen x xa xb xc)\n                          (find_base_vectors_gen y ya yb yc)", "obtain xs where xs: \"map snd (pivot_positions_gen ze' A') = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        map snd (pivot_positions_gen ze' A') = xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  map snd (pivot_positions_gen ze' A') = xs\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>(R ===> R) x y; R xa ya; R xb yb; mat_rel R xc yc\\<rbrakk>\n       \\<Longrightarrow> list_all2 (vec_rel R)\n                          (find_base_vectors_gen x xa xb xc)\n                          (find_base_vectors_gen y ya yb yc)", "obtain ys where ys: \"[j\\<leftarrow>[0..<dim_col A'] . j \\<notin> set xs] = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        filter (\\<lambda>j. j \\<notin> set xs) [0..<dim_col A'] =\n        ys \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  filter (\\<lambda>j. j \\<notin> set xs) [0..<dim_col A'] = ys\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>(R ===> R) x y; R xa ya; R xb yb; mat_rel R xc yc\\<rbrakk>\n       \\<Longrightarrow> list_all2 (vec_rel R)\n                          (find_base_vectors_gen x xa xb xc)\n                          (find_base_vectors_gen y ya yb yc)", "show \"list_all2 (vec_rel R) (find_base_vectors_gen um ze on A) \n    (find_base_vectors_gen um' ze' on' A')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (vec_rel R) (find_base_vectors_gen um ze on A)\n     (find_base_vectors_gen um' ze' on' A')", "unfolding find_base_vectors_gen_def Let_def id xs list_all2_conv_all_nth length_map ys dim"], ["proof (prove)\ngoal (1 subgoal):\n 1. length ys = length ys \\<and>\n    (\\<forall>i<length ys.\n        vec_rel R\n         (map (non_pivot_base_gen um ze on A (pivot_positions_gen ze' A'))\n           ys !\n          i)\n         (map (non_pivot_base_gen um' ze' on' A'\n                (pivot_positions_gen ze' A'))\n           ys !\n          i))", "proof (intro conjI[OF refl] allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length ys \\<Longrightarrow>\n       vec_rel R\n        (map (non_pivot_base_gen um ze on A (pivot_positions_gen ze' A'))\n          ys !\n         i)\n        (map (non_pivot_base_gen um' ze' on' A'\n               (pivot_positions_gen ze' A'))\n          ys !\n         i)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length ys \\<Longrightarrow>\n       vec_rel R\n        (map (non_pivot_base_gen um ze on A (pivot_positions_gen ze' A'))\n          ys !\n         i)\n        (map (non_pivot_base_gen um' ze' on' A'\n               (pivot_positions_gen ze' A'))\n          ys !\n         i)", "assume i: \"i < length ys\""], ["proof (state)\nthis:\n  i < length ys\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length ys \\<Longrightarrow>\n       vec_rel R\n        (map (non_pivot_base_gen um ze on A (pivot_positions_gen ze' A'))\n          ys !\n         i)\n        (map (non_pivot_base_gen um' ze' on' A'\n               (pivot_positions_gen ze' A'))\n          ys !\n         i)", "define y where \"y = ys ! i\""], ["proof (state)\nthis:\n  y = ys ! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length ys \\<Longrightarrow>\n       vec_rel R\n        (map (non_pivot_base_gen um ze on A (pivot_positions_gen ze' A'))\n          ys !\n         i)\n        (map (non_pivot_base_gen um' ze' on' A'\n               (pivot_positions_gen ze' A'))\n          ys !\n         i)", "from i"], ["proof (chain)\npicking this:\n  i < length ys", "have y: \"y < dim_col A'\""], ["proof (prove)\nusing this:\n  i < length ys\n\ngoal (1 subgoal):\n 1. y < dim_col A'", "unfolding y_def ys[symmetric]"], ["proof (prove)\nusing this:\n  i < length (filter (\\<lambda>j. j \\<notin> set xs) [0..<dim_col A'])\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>j. j \\<notin> set xs) [0..<dim_col A'] ! i < dim_col A'", "using nth_mem"], ["proof (prove)\nusing this:\n  i < length (filter (\\<lambda>j. j \\<notin> set xs) [0..<dim_col A'])\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>j. j \\<notin> set xs) [0..<dim_col A'] ! i < dim_col A'", "by fastforce"], ["proof (state)\nthis:\n  y < dim_col A'\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length ys \\<Longrightarrow>\n       vec_rel R\n        (map (non_pivot_base_gen um ze on A (pivot_positions_gen ze' A'))\n          ys !\n         i)\n        (map (non_pivot_base_gen um' ze' on' A'\n               (pivot_positions_gen ze' A'))\n          ys !\n         i)", "let ?map = \"map_of (map prod.swap (pivot_positions_gen ze' A'))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length ys \\<Longrightarrow>\n       vec_rel R\n        (map (non_pivot_base_gen um ze on A (pivot_positions_gen ze' A'))\n          ys !\n         i)\n        (map (non_pivot_base_gen um' ze' on' A'\n               (pivot_positions_gen ze' A'))\n          ys !\n         i)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length ys \\<Longrightarrow>\n       vec_rel R\n        (map (non_pivot_base_gen um ze on A (pivot_positions_gen ze' A'))\n          ys !\n         i)\n        (map (non_pivot_base_gen um' ze' on' A'\n               (pivot_positions_gen ze' A'))\n          ys !\n         i)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length ys \\<Longrightarrow>\n       vec_rel R\n        (map (non_pivot_base_gen um ze on A (pivot_positions_gen ze' A'))\n          ys !\n         i)\n        (map (non_pivot_base_gen um' ze' on' A'\n               (pivot_positions_gen ze' A'))\n          ys !\n         i)", "assume i: \"i < dim_col A'\"\n      and neq: \"i \\<noteq> y\""], ["proof (state)\nthis:\n  i < dim_col A'\n  i \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length ys \\<Longrightarrow>\n       vec_rel R\n        (map (non_pivot_base_gen um ze on A (pivot_positions_gen ze' A'))\n          ys !\n         i)\n        (map (non_pivot_base_gen um' ze' on' A'\n               (pivot_positions_gen ze' A'))\n          ys !\n         i)", "have \"R (case ?map i of None \\<Rightarrow> ze | Some j \\<Rightarrow> um (A $$ (j, y)))\n          (case ?map i of None \\<Rightarrow> ze' | Some j \\<Rightarrow> um' (A' $$ (j, y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n       None \\<Rightarrow> ze | Some j \\<Rightarrow> um (A $$ (j, y)))\n     (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n      None \\<Rightarrow> ze' | Some j \\<Rightarrow> um' (A' $$ (j, y)))", "proof (cases \"?map i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. map_of (map prod.swap (pivot_positions_gen ze' A')) i =\n    None \\<Longrightarrow>\n    R (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n       None \\<Rightarrow> ze | Some j \\<Rightarrow> um (A $$ (j, y)))\n     (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n      None \\<Rightarrow> ze' | Some j \\<Rightarrow> um' (A' $$ (j, y)))\n 2. \\<And>a.\n       map_of (map prod.swap (pivot_positions_gen ze' A')) i =\n       Some a \\<Longrightarrow>\n       R (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n          None \\<Rightarrow> ze | Some j \\<Rightarrow> um (A $$ (j, y)))\n        (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n         None \\<Rightarrow> ze' | Some j \\<Rightarrow> um' (A' $$ (j, y)))", "case None"], ["proof (state)\nthis:\n  map_of (map prod.swap (pivot_positions_gen ze' A')) i = None\n\ngoal (2 subgoals):\n 1. map_of (map prod.swap (pivot_positions_gen ze' A')) i =\n    None \\<Longrightarrow>\n    R (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n       None \\<Rightarrow> ze | Some j \\<Rightarrow> um (A $$ (j, y)))\n     (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n      None \\<Rightarrow> ze' | Some j \\<Rightarrow> um' (A' $$ (j, y)))\n 2. \\<And>a.\n       map_of (map prod.swap (pivot_positions_gen ze' A')) i =\n       Some a \\<Longrightarrow>\n       R (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n          None \\<Rightarrow> ze | Some j \\<Rightarrow> um (A $$ (j, y)))\n        (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n         None \\<Rightarrow> ze' | Some j \\<Rightarrow> um' (A' $$ (j, y)))", "with trans(2)"], ["proof (chain)\npicking this:\n  R ze ze'\n  map_of (map prod.swap (pivot_positions_gen ze' A')) i = None", "show ?thesis"], ["proof (prove)\nusing this:\n  R ze ze'\n  map_of (map prod.swap (pivot_positions_gen ze' A')) i = None\n\ngoal (1 subgoal):\n 1. R (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n       None \\<Rightarrow> ze | Some j \\<Rightarrow> um (A $$ (j, y)))\n     (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n      None \\<Rightarrow> ze' | Some j \\<Rightarrow> um' (A' $$ (j, y)))", "by auto"], ["proof (state)\nthis:\n  R (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n     None \\<Rightarrow> ze | Some j \\<Rightarrow> um (A $$ (j, y)))\n   (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n    None \\<Rightarrow> ze' | Some j \\<Rightarrow> um' (A' $$ (j, y)))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of (map prod.swap (pivot_positions_gen ze' A')) i =\n       Some a \\<Longrightarrow>\n       R (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n          None \\<Rightarrow> ze | Some j \\<Rightarrow> um (A $$ (j, y)))\n        (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n         None \\<Rightarrow> ze' | Some j \\<Rightarrow> um' (A' $$ (j, y)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of (map prod.swap (pivot_positions_gen ze' A')) i =\n       Some a \\<Longrightarrow>\n       R (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n          None \\<Rightarrow> ze | Some j \\<Rightarrow> um (A $$ (j, y)))\n        (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n         None \\<Rightarrow> ze' | Some j \\<Rightarrow> um' (A' $$ (j, y)))", "case (Some j)"], ["proof (state)\nthis:\n  map_of (map prod.swap (pivot_positions_gen ze' A')) i = Some j\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of (map prod.swap (pivot_positions_gen ze' A')) i =\n       Some a \\<Longrightarrow>\n       R (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n          None \\<Rightarrow> ze | Some j \\<Rightarrow> um (A $$ (j, y)))\n        (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n         None \\<Rightarrow> ze' | Some j \\<Rightarrow> um' (A' $$ (j, y)))", "from map_of_SomeD[OF this]"], ["proof (chain)\npicking this:\n  (i, j) \\<in> set (map prod.swap (pivot_positions_gen ze' A'))", "have \"(j,i) \\<in> set (pivot_positions_gen ze' A')\""], ["proof (prove)\nusing this:\n  (i, j) \\<in> set (map prod.swap (pivot_positions_gen ze' A'))\n\ngoal (1 subgoal):\n 1. (j, i) \\<in> set (pivot_positions_gen ze' A')", "by auto"], ["proof (state)\nthis:\n  (j, i) \\<in> set (pivot_positions_gen ze' A')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of (map prod.swap (pivot_positions_gen ze' A')) i =\n       Some a \\<Longrightarrow>\n       R (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n          None \\<Rightarrow> ze | Some j \\<Rightarrow> um (A $$ (j, y)))\n        (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n         None \\<Rightarrow> ze' | Some j \\<Rightarrow> um' (A' $$ (j, y)))", "from subsetD[OF set_pivot_positions_main_gen this[unfolded pivot_positions_gen_def]]"], ["proof (chain)\npicking this:\n  (j, i) \\<in> {0..<dim_row A'} \\<times> {0..<dim_col A'}", "have j: \"j < dim_row A'\""], ["proof (prove)\nusing this:\n  (j, i) \\<in> {0..<dim_row A'} \\<times> {0..<dim_col A'}\n\ngoal (1 subgoal):\n 1. j < dim_row A'", "by auto"], ["proof (state)\nthis:\n  j < dim_row A'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of (map prod.swap (pivot_positions_gen ze' A')) i =\n       Some a \\<Longrightarrow>\n       R (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n          None \\<Rightarrow> ze | Some j \\<Rightarrow> um (A $$ (j, y)))\n        (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n         None \\<Rightarrow> ze' | Some j \\<Rightarrow> um' (A' $$ (j, y)))", "with trans(4) y"], ["proof (chain)\npicking this:\n  mat_rel R A A'\n  y < dim_col A'\n  j < dim_row A'", "have [transfer_rule]: \"R (A $$ (j,y)) (A' $$ (j,y))\""], ["proof (prove)\nusing this:\n  mat_rel R A A'\n  y < dim_col A'\n  j < dim_row A'\n\ngoal (1 subgoal):\n 1. R (A $$ (j, y)) (A' $$ (j, y))", "unfolding mat_rel_def"], ["proof (prove)\nusing this:\n  dim_row A = dim_row A' \\<and>\n  dim_col A = dim_col A' \\<and>\n  (\\<forall>i j.\n      i < dim_row A' \\<longrightarrow>\n      j < dim_col A' \\<longrightarrow> R (A $$ (i, j)) (A' $$ (i, j)))\n  y < dim_col A'\n  j < dim_row A'\n\ngoal (1 subgoal):\n 1. R (A $$ (j, y)) (A' $$ (j, y))", "by auto"], ["proof (state)\nthis:\n  R (A $$ (j, y)) (A' $$ (j, y))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of (map prod.swap (pivot_positions_gen ze' A')) i =\n       Some a \\<Longrightarrow>\n       R (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n          None \\<Rightarrow> ze | Some j \\<Rightarrow> um (A $$ (j, y)))\n        (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n         None \\<Rightarrow> ze' | Some j \\<Rightarrow> um' (A' $$ (j, y)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n       None \\<Rightarrow> ze | Some j \\<Rightarrow> um (A $$ (j, y)))\n     (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n      None \\<Rightarrow> ze' | Some j \\<Rightarrow> um' (A' $$ (j, y)))", "unfolding Some"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (case Some j of None \\<Rightarrow> ze\n       | Some j \\<Rightarrow> um (A $$ (j, y)))\n     (case Some j of None \\<Rightarrow> ze'\n      | Some j \\<Rightarrow> um' (A' $$ (j, y)))", "by (simp, transfer_prover)"], ["proof (state)\nthis:\n  R (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n     None \\<Rightarrow> ze | Some j \\<Rightarrow> um (A $$ (j, y)))\n   (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n    None \\<Rightarrow> ze' | Some j \\<Rightarrow> um' (A' $$ (j, y)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n     None \\<Rightarrow> ze | Some j \\<Rightarrow> um (A $$ (j, y)))\n   (case map_of (map prod.swap (pivot_positions_gen ze' A')) i of\n    None \\<Rightarrow> ze' | Some j \\<Rightarrow> um' (A' $$ (j, y)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length ys \\<Longrightarrow>\n       vec_rel R\n        (map (non_pivot_base_gen um ze on A (pivot_positions_gen ze' A'))\n          ys !\n         i)\n        (map (non_pivot_base_gen um' ze' on' A'\n               (pivot_positions_gen ze' A'))\n          ys !\n         i)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ia2 < dim_col A'; ?ia2 \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> R (case map_of\n                             (map prod.swap (pivot_positions_gen ze' A'))\n                             ?ia2 of\n                       None \\<Rightarrow> ze\n                       | Some j \\<Rightarrow> um (A $$ (j, y)))\n                     (case map_of\n                            (map prod.swap (pivot_positions_gen ze' A'))\n                            ?ia2 of\n                      None \\<Rightarrow> ze'\n                      | Some j \\<Rightarrow> um' (A' $$ (j, y)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length ys \\<Longrightarrow>\n       vec_rel R\n        (map (non_pivot_base_gen um ze on A (pivot_positions_gen ze' A'))\n          ys !\n         i)\n        (map (non_pivot_base_gen um' ze' on' A'\n               (pivot_positions_gen ze' A'))\n          ys !\n         i)", "note main = this"], ["proof (state)\nthis:\n  \\<lbrakk>?ia2 < dim_col A'; ?ia2 \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> R (case map_of\n                             (map prod.swap (pivot_positions_gen ze' A'))\n                             ?ia2 of\n                       None \\<Rightarrow> ze\n                       | Some j \\<Rightarrow> um (A $$ (j, y)))\n                     (case map_of\n                            (map prod.swap (pivot_positions_gen ze' A'))\n                            ?ia2 of\n                      None \\<Rightarrow> ze'\n                      | Some j \\<Rightarrow> um' (A' $$ (j, y)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length ys \\<Longrightarrow>\n       vec_rel R\n        (map (non_pivot_base_gen um ze on A (pivot_positions_gen ze' A'))\n          ys !\n         i)\n        (map (non_pivot_base_gen um' ze' on' A'\n               (pivot_positions_gen ze' A'))\n          ys !\n         i)", "show \"vec_rel R (map (non_pivot_base_gen um ze on A (pivot_positions_gen ze' A')) ys ! i)\n          (map (non_pivot_base_gen um' ze' on' A' (pivot_positions_gen ze' A')) ys ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_rel R\n     (map (non_pivot_base_gen um ze on A (pivot_positions_gen ze' A')) ys !\n      i)\n     (map (non_pivot_base_gen um' ze' on' A' (pivot_positions_gen ze' A'))\n       ys !\n      i)", "unfolding y_def[symmetric] nth_map[OF i]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_rel R (non_pivot_base_gen um ze on A (pivot_positions_gen ze' A') y)\n     (non_pivot_base_gen um' ze' on' A' (pivot_positions_gen ze' A') y)", "unfolding non_pivot_base_gen_def Let_def dim vec_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (vec (dim_col A')\n       (\\<lambda>i.\n           if i = y then on\n           else case map_of (map prod.swap (pivot_positions_gen ze' A'))\n                      i of\n                None \\<Rightarrow> ze\n                | Some j \\<Rightarrow> um (A $$ (j, y)))) =\n    dim_vec\n     (vec (dim_col A')\n       (\\<lambda>i.\n           if i = y then on'\n           else case map_of (map prod.swap (pivot_positions_gen ze' A'))\n                      i of\n                None \\<Rightarrow> ze'\n                | Some j \\<Rightarrow> um' (A' $$ (j, y)))) \\<and>\n    (\\<forall>i<dim_vec\n                 (vec (dim_col A')\n                   (\\<lambda>i.\n                       if i = y then on'\n                       else case map_of\n                                  (map prod.swap\n                                    (pivot_positions_gen ze' A'))\n                                  i of\n                            None \\<Rightarrow> ze'\n                            | Some j \\<Rightarrow> um' (A' $$ (j, y)))).\n        R (vec (dim_col A')\n            (\\<lambda>i.\n                if i = y then on\n                else case map_of\n                           (map prod.swap (pivot_positions_gen ze' A')) i of\n                     None \\<Rightarrow> ze\n                     | Some j \\<Rightarrow> um (A $$ (j, y))) $\n           i)\n         (vec (dim_col A')\n           (\\<lambda>i.\n               if i = y then on'\n               else case map_of (map prod.swap (pivot_positions_gen ze' A'))\n                          i of\n                    None \\<Rightarrow> ze'\n                    | Some j \\<Rightarrow> um' (A' $$ (j, y))) $\n          i))", "by (intro conjI allI impI, force, insert main, auto simp: trans(3))"], ["proof (state)\nthis:\n  vec_rel R\n   (map (non_pivot_base_gen um ze on A (pivot_positions_gen ze' A')) ys ! i)\n   (map (non_pivot_base_gen um' ze' on' A' (pivot_positions_gen ze' A'))\n     ys !\n    i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all2 (vec_rel R) (find_base_vectors_gen um ze on A)\n   (find_base_vectors_gen um' ze' on' A')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eliminate_entries_gen_transfer: assumes *[transfer_rule]: \"(R ===> R ===> R) ad ad'\"\n  \"(R ===> R ===> R) mul mul'\"\n  and vs: \"\\<And> j. j < dim_row B' \\<Longrightarrow> R (vs j) (vs' j)\" \n  and i: \"i < dim_row B'\"  \n  and B: \"mat_rel R B B'\"\n  shows \"mat_rel R \n   (eliminate_entries_gen ad mul vs B i j) \n   (eliminate_entries_gen ad' mul' vs' B' i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R (eliminate_entries_gen ad mul vs B i j)\n     (eliminate_entries_gen ad' mul' vs' B' i j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_rel R (eliminate_entries_gen ad mul vs B i j)\n     (eliminate_entries_gen ad' mul' vs' B' i j)", "note BB = B[unfolded mat_rel_def]"], ["proof (state)\nthis:\n  dim_row B = dim_row B' \\<and>\n  dim_col B = dim_col B' \\<and>\n  (\\<forall>i j.\n      i < dim_row B' \\<longrightarrow>\n      j < dim_col B' \\<longrightarrow> R (B $$ (i, j)) (B' $$ (i, j)))\n\ngoal (1 subgoal):\n 1. mat_rel R (eliminate_entries_gen ad mul vs B i j)\n     (eliminate_entries_gen ad' mul' vs' B' i j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R (eliminate_entries_gen ad mul vs B i j)\n     (eliminate_entries_gen ad' mul' vs' B' i j)", "unfolding mat_rel_def dim_eliminate_entries_gen"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row B = dim_row B' \\<and>\n    dim_col B = dim_col B' \\<and>\n    (\\<forall>ia ja.\n        ia < dim_row B' \\<longrightarrow>\n        ja < dim_col B' \\<longrightarrow>\n        R (eliminate_entries_gen ad mul vs B i j $$ (ia, ja))\n         (eliminate_entries_gen ad' mul' vs' B' i j $$ (ia, ja)))", "proof (intro conjI impI allI)"], ["proof (state)\ngoal (3 subgoals):\n 1. dim_row B = dim_row B'\n 2. dim_col B = dim_col B'\n 3. \\<And>ia ja.\n       \\<lbrakk>ia < dim_row B'; ja < dim_col B'\\<rbrakk>\n       \\<Longrightarrow> R (eliminate_entries_gen ad mul vs B i j $$\n                            (ia, ja))\n                          (eliminate_entries_gen ad' mul' vs' B' i j $$\n                           (ia, ja))", "fix i' j'"], ["proof (state)\ngoal (3 subgoals):\n 1. dim_row B = dim_row B'\n 2. dim_col B = dim_col B'\n 3. \\<And>ia ja.\n       \\<lbrakk>ia < dim_row B'; ja < dim_col B'\\<rbrakk>\n       \\<Longrightarrow> R (eliminate_entries_gen ad mul vs B i j $$\n                            (ia, ja))\n                          (eliminate_entries_gen ad' mul' vs' B' i j $$\n                           (ia, ja))", "assume ij': \"i' < dim_row B'\" \"j' < dim_col B'\""], ["proof (state)\nthis:\n  i' < dim_row B'\n  j' < dim_col B'\n\ngoal (3 subgoals):\n 1. dim_row B = dim_row B'\n 2. dim_col B = dim_col B'\n 3. \\<And>ia ja.\n       \\<lbrakk>ia < dim_row B'; ja < dim_col B'\\<rbrakk>\n       \\<Longrightarrow> R (eliminate_entries_gen ad mul vs B i j $$\n                            (ia, ja))\n                          (eliminate_entries_gen ad' mul' vs' B' i j $$\n                           (ia, ja))", "with BB"], ["proof (chain)\npicking this:\n  dim_row B = dim_row B' \\<and>\n  dim_col B = dim_col B' \\<and>\n  (\\<forall>i j.\n      i < dim_row B' \\<longrightarrow>\n      j < dim_col B' \\<longrightarrow> R (B $$ (i, j)) (B' $$ (i, j)))\n  i' < dim_row B'\n  j' < dim_col B'", "have ij: \"i'< dim_row B\" \"j' < dim_col B\""], ["proof (prove)\nusing this:\n  dim_row B = dim_row B' \\<and>\n  dim_col B = dim_col B' \\<and>\n  (\\<forall>i j.\n      i < dim_row B' \\<longrightarrow>\n      j < dim_col B' \\<longrightarrow> R (B $$ (i, j)) (B' $$ (i, j)))\n  i' < dim_row B'\n  j' < dim_col B'\n\ngoal (1 subgoal):\n 1. i' < dim_row B &&& j' < dim_col B", "by auto"], ["proof (state)\nthis:\n  i' < dim_row B\n  j' < dim_col B\n\ngoal (3 subgoals):\n 1. dim_row B = dim_row B'\n 2. dim_col B = dim_col B'\n 3. \\<And>ia ja.\n       \\<lbrakk>ia < dim_row B'; ja < dim_col B'\\<rbrakk>\n       \\<Longrightarrow> R (eliminate_entries_gen ad mul vs B i j $$\n                            (ia, ja))\n                          (eliminate_entries_gen ad' mul' vs' B' i j $$\n                           (ia, ja))", "have [transfer_rule]: \"R (B $$ (i', j')) (B' $$ (i', j'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (B $$ (i', j')) (B' $$ (i', j'))", "using BB ij'"], ["proof (prove)\nusing this:\n  dim_row B = dim_row B' \\<and>\n  dim_col B = dim_col B' \\<and>\n  (\\<forall>i j.\n      i < dim_row B' \\<longrightarrow>\n      j < dim_col B' \\<longrightarrow> R (B $$ (i, j)) (B' $$ (i, j)))\n  i' < dim_row B'\n  j' < dim_col B'\n\ngoal (1 subgoal):\n 1. R (B $$ (i', j')) (B' $$ (i', j'))", "by auto"], ["proof (state)\nthis:\n  R (B $$ (i', j')) (B' $$ (i', j'))\n\ngoal (3 subgoals):\n 1. dim_row B = dim_row B'\n 2. dim_col B = dim_col B'\n 3. \\<And>ia ja.\n       \\<lbrakk>ia < dim_row B'; ja < dim_col B'\\<rbrakk>\n       \\<Longrightarrow> R (eliminate_entries_gen ad mul vs B i j $$\n                            (ia, ja))\n                          (eliminate_entries_gen ad' mul' vs' B' i j $$\n                           (ia, ja))", "have [transfer_rule]: \"R (B $$ (i, j')) (B' $$ (i, j'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (B $$ (i, j')) (B' $$ (i, j'))", "using BB ij' i"], ["proof (prove)\nusing this:\n  dim_row B = dim_row B' \\<and>\n  dim_col B = dim_col B' \\<and>\n  (\\<forall>i j.\n      i < dim_row B' \\<longrightarrow>\n      j < dim_col B' \\<longrightarrow> R (B $$ (i, j)) (B' $$ (i, j)))\n  i' < dim_row B'\n  j' < dim_col B'\n  i < dim_row B'\n\ngoal (1 subgoal):\n 1. R (B $$ (i, j')) (B' $$ (i, j'))", "by auto"], ["proof (state)\nthis:\n  R (B $$ (i, j')) (B' $$ (i, j'))\n\ngoal (3 subgoals):\n 1. dim_row B = dim_row B'\n 2. dim_col B = dim_col B'\n 3. \\<And>ia ja.\n       \\<lbrakk>ia < dim_row B'; ja < dim_col B'\\<rbrakk>\n       \\<Longrightarrow> R (eliminate_entries_gen ad mul vs B i j $$\n                            (ia, ja))\n                          (eliminate_entries_gen ad' mul' vs' B' i j $$\n                           (ia, ja))", "have [transfer_rule]: \"R (vs i') (vs' i')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (vs i') (vs' i')", "using ij' vs[of i']"], ["proof (prove)\nusing this:\n  i' < dim_row B'\n  j' < dim_col B'\n  i' < dim_row B' \\<Longrightarrow> R (vs i') (vs' i')\n\ngoal (1 subgoal):\n 1. R (vs i') (vs' i')", "by auto"], ["proof (state)\nthis:\n  R (vs i') (vs' i')\n\ngoal (3 subgoals):\n 1. dim_row B = dim_row B'\n 2. dim_col B = dim_col B'\n 3. \\<And>ia ja.\n       \\<lbrakk>ia < dim_row B'; ja < dim_col B'\\<rbrakk>\n       \\<Longrightarrow> R (eliminate_entries_gen ad mul vs B i j $$\n                            (ia, ja))\n                          (eliminate_entries_gen ad' mul' vs' B' i j $$\n                           (ia, ja))", "show \"R (eliminate_entries_gen ad mul vs B i j $$ (i', j'))\n        (eliminate_entries_gen ad' mul' vs' B' i j $$ (i', j'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (eliminate_entries_gen ad mul vs B i j $$ (i', j'))\n     (eliminate_entries_gen ad' mul' vs' B' i j $$ (i', j'))", "unfolding eliminate_entries_gen_def index_mat(1)[OF ij] index_mat(1)[OF ij'] split"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (if i' \\<noteq> i then ad (B $$ (i', j')) (mul (vs i') (B $$ (i, j')))\n       else B $$ (i', j'))\n     (if i' \\<noteq> i\n      then ad' (B' $$ (i', j')) (mul' (vs' i') (B' $$ (i, j')))\n      else B' $$ (i', j'))", "by transfer_prover"], ["proof (state)\nthis:\n  R (eliminate_entries_gen ad mul vs B i j $$ (i', j'))\n   (eliminate_entries_gen ad' mul' vs' B' i j $$ (i', j'))\n\ngoal (2 subgoals):\n 1. dim_row B = dim_row B'\n 2. dim_col B = dim_col B'", "qed (insert BB, auto)"], ["proof (state)\nthis:\n  mat_rel R (eliminate_entries_gen ad mul vs B i j)\n   (eliminate_entries_gen ad' mul' vs' B' i j)\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  fixes ops :: \"'i arith_ops_record\" (structure)\nbegin"], ["", "private"], ["", "abbreviation (input) zero where \"zero \\<equiv> arith_ops_record.zero ops\""], ["", "private"], ["", "abbreviation (input) one where \"one \\<equiv> arith_ops_record.one ops\""], ["", "private"], ["", "abbreviation (input) plus where \"plus \\<equiv> arith_ops_record.plus ops\""], ["", "private"], ["", "abbreviation (input) times where \"times \\<equiv> arith_ops_record.times ops\""], ["", "private"], ["", "abbreviation (input) minus where \"minus \\<equiv> arith_ops_record.minus ops\""], ["", "private"], ["", "abbreviation (input) uminus where \"uminus \\<equiv> arith_ops_record.uminus ops\""], ["", "private"], ["", "abbreviation (input) divide where \"divide \\<equiv> arith_ops_record.divide ops\""], ["", "private"], ["", "abbreviation (input) inverse where \"inverse \\<equiv> arith_ops_record.inverse ops\""], ["", "private"], ["", "abbreviation (input) modulo where \"modulo \\<equiv> arith_ops_record.modulo ops\""], ["", "private"], ["", "abbreviation (input) normalize where \"normalize \\<equiv> arith_ops_record.normalize ops\""], ["", "definition eliminate_entries_gen_zero :: \"('a \\<Rightarrow> 'a \\<Rightarrow> 'a) \\<Rightarrow> ('a \\<Rightarrow> 'a \\<Rightarrow> 'a) \\<Rightarrow> 'a \\<Rightarrow> (integer \\<Rightarrow> 'a) \\<Rightarrow> 'a mat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a mat\" where\n  \"eliminate_entries_gen_zero minu time z v A I J = mat (dim_row A) (dim_col A) (\\<lambda> (i, j).\n     if v (integer_of_nat i) \\<noteq> z \\<and> i \\<noteq> I then minu (A $$ (i,j)) (time (v (integer_of_nat i)) (A $$ (I,j))) else A $$ (i,j))\""], ["", "definition eliminate_entries_i where \"eliminate_entries_i \\<equiv> eliminate_entries_gen_zero minus times zero\""], ["", "definition multrow_i where \"multrow_i \\<equiv> mat_multrow_gen times\""], ["", "lemma dim_eliminate_entries_gen_zero[simp]:\n  \"dim_row (eliminate_entries_gen_zero mm tt z v B i as) = dim_row B\"\n  \"dim_col (eliminate_entries_gen_zero mm tt z v B i as) = dim_col B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (eliminate_entries_gen_zero mm tt z v B i as) = dim_row B &&&\n    dim_col (eliminate_entries_gen_zero mm tt z v B i as) = dim_col B", "unfolding eliminate_entries_gen_zero_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row\n     (mat (dim_row B) (dim_col B)\n       (\\<lambda>(ia, j).\n           if v (integer_of_nat ia) \\<noteq> z \\<and> ia \\<noteq> i\n           then mm (B $$ (ia, j)) (tt (v (integer_of_nat ia)) (B $$ (i, j)))\n           else B $$ (ia, j))) =\n    dim_row B &&&\n    dim_col\n     (mat (dim_row B) (dim_col B)\n       (\\<lambda>(ia, j).\n           if v (integer_of_nat ia) \\<noteq> z \\<and> ia \\<noteq> i\n           then mm (B $$ (ia, j)) (tt (v (integer_of_nat ia)) (B $$ (i, j)))\n           else B $$ (ia, j))) =\n    dim_col B", "by auto"], ["", "partial_function (tailrec) gauss_jordan_main_i :: \"nat \\<Rightarrow> nat \\<Rightarrow> 'i mat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'i mat\" where\n  [code]: \"gauss_jordan_main_i nr nc A i j = (\n    if i < nr \\<and> j < nc then let aij = A $$ (i,j) in if aij = zero then\n      (case [ i' . i' <- [Suc i ..< nr],  A $$ (i',j) \\<noteq> zero] \n        of [] \\<Rightarrow> gauss_jordan_main_i nr nc A i (Suc j)\n         | (i' # _) \\<Rightarrow> gauss_jordan_main_i nr nc (swaprows i i' A) i j)\n      else if aij = one then let \n        v = (\\<lambda> i. A $$ (nat_of_integer i,j)) in\n        gauss_jordan_main_i nr nc\n        (eliminate_entries_i v A i j) (Suc i) (Suc j)\n      else let iaij = inverse aij; A' = multrow_i i iaij A;\n        v = (\\<lambda> i. A' $$ (nat_of_integer i,j))\n        in gauss_jordan_main_i nr nc (eliminate_entries_i v A' i j) (Suc i) (Suc j)\n    else A)\""], ["", "definition gauss_jordan_single_i :: \"'i mat \\<Rightarrow> 'i mat\" where\n  \"gauss_jordan_single_i A \\<equiv> gauss_jordan_main_i (dim_row A) (dim_col A) A 0 0\""], ["", "definition find_base_vectors_i :: \"'i mat \\<Rightarrow> 'i vec list\" where\n  \"find_base_vectors_i A \\<equiv> find_base_vectors_gen uminus zero one A\""], ["", "end"], ["", "(* **************************************************************************** *)\n(* subsection \\<open>Proofs\\<close> *)"], ["", "context field_ops\nbegin"], ["", "lemma right_total_poly_rel[transfer_rule]: \"right_total (mat_rel R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_total (mat_rel R)", "using right_total_mat_rel[of R] right_total"], ["proof (prove)\nusing this:\n  right_total R \\<Longrightarrow> right_total (mat_rel R)\n  right_total R\n\ngoal (1 subgoal):\n 1. right_total (mat_rel R)", "."], ["", "lemma bi_unique_poly_rel[transfer_rule]: \"bi_unique (mat_rel R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique (mat_rel R)", "using bi_unique_mat_rel[of R] bi_unique"], ["proof (prove)\nusing this:\n  bi_unique R \\<Longrightarrow> bi_unique (mat_rel R)\n  bi_unique R\n\ngoal (1 subgoal):\n 1. bi_unique (mat_rel R)", "."], ["", "lemma eq_mat_rel[transfer_rule]: \"(mat_rel R ===> mat_rel R ===> (=)) (=) (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat_rel R ===> mat_rel R ===> (=)) (=) (=)", "by (rule mat_rel_eq[OF eq])"], ["", "lemma multrow_i[transfer_rule]: \"((=) ===> R ===> mat_rel R ===> mat_rel R)\n  (multrow_i ops) multrow\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> R ===> mat_rel R ===> mat_rel R) (multrow_i ops) multrow", "using multrow_transfer[of R] times"], ["proof (prove)\nusing this:\n  ((R ===> R ===> R) ===> (=) ===> R ===> mat_rel R ===> mat_rel R)\n   mat_multrow_gen mat_multrow_gen\n  (R ===> R ===> R) (arith_ops_record.times ops) (*)\n\ngoal (1 subgoal):\n 1. ((=) ===> R ===> mat_rel R ===> mat_rel R) (multrow_i ops) multrow", "unfolding multrow_i_def rel_fun_def"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     (\\<forall>xa ya.\n         R xa ya \\<longrightarrow>\n         (\\<forall>xb yb.\n             R xb yb \\<longrightarrow>\n             R (x xa xb) (y ya yb))) \\<longrightarrow>\n     (\\<forall>xa ya.\n         xa = ya \\<longrightarrow>\n         (\\<forall>xb yb.\n             R xb yb \\<longrightarrow>\n             (\\<forall>xc yc.\n                 mat_rel R xc yc \\<longrightarrow>\n                 mat_rel R (mat_multrow_gen x xa xb xc)\n                  (mat_multrow_gen y ya yb yc))))\n  \\<forall>x y.\n     R x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         R xa ya \\<longrightarrow>\n         R (arith_ops_record.times ops x xa) (y * ya))\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x = y \\<longrightarrow>\n       (\\<forall>xa ya.\n           R xa ya \\<longrightarrow>\n           (\\<forall>xb yb.\n               mat_rel R xb yb \\<longrightarrow>\n               mat_rel R\n                (mat_multrow_gen (arith_ops_record.times ops) x xa xb)\n                (multrow y ya yb)))", "by blast"], ["", "lemma eliminate_entries_gen_zero[simp]:\n  assumes \"mat_rel R A A'\" \"I < dim_row A'\" shows\n  \"eliminate_entries_gen_zero minus times zero v A I J = eliminate_entries_gen minus times (v o integer_of_nat) A I J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eliminate_entries_gen_zero (arith_ops_record.minus ops)\n     (arith_ops_record.times ops) (arith_ops_record.zero ops) v A I J =\n    eliminate_entries_gen (arith_ops_record.minus ops)\n     (arith_ops_record.times ops) (v \\<circ> integer_of_nat) A I J", "unfolding eliminate_entries_gen_def eliminate_entries_gen_zero_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_row A) (dim_col A)\n     (\\<lambda>(i, j).\n         if v (integer_of_nat i) \\<noteq> arith_ops_record.zero ops \\<and>\n            i \\<noteq> I\n         then arith_ops_record.minus ops (A $$ (i, j))\n               (arith_ops_record.times ops (v (integer_of_nat i))\n                 (A $$ (I, j)))\n         else A $$ (i, j)) =\n    mat (dim_row A) (dim_col A)\n     (\\<lambda>(i, j).\n         if i \\<noteq> I\n         then arith_ops_record.minus ops (A $$ (i, j))\n               (arith_ops_record.times ops ((v \\<circ> integer_of_nat) i)\n                 (A $$ (I, j)))\n         else A $$ (i, j))", "proof(standard,goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat (dim_row A) (dim_col A)\n                       (\\<lambda>(i, j).\n                           if i \\<noteq> I\n                           then arith_ops_record.minus ops (A $$ (i, j))\n                                 (arith_ops_record.times ops\n                                   ((v \\<circ> integer_of_nat) i)\n                                   (A $$ (I, j)))\n                           else A $$ (i, j)));\n        j < dim_col\n             (mat (dim_row A) (dim_col A)\n               (\\<lambda>(i, j).\n                   if i \\<noteq> I\n                   then arith_ops_record.minus ops (A $$ (i, j))\n                         (arith_ops_record.times ops\n                           ((v \\<circ> integer_of_nat) i) (A $$ (I, j)))\n                   else A $$ (i, j)))\\<rbrakk>\n       \\<Longrightarrow> mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, j).\n                              if v (integer_of_nat i) \\<noteq>\n                                 arith_ops_record.zero ops \\<and>\n                                 i \\<noteq> I\n                              then arith_ops_record.minus ops (A $$ (i, j))\n                                    (arith_ops_record.times ops\n(v (integer_of_nat i)) (A $$ (I, j)))\n                              else A $$ (i, j)) $$\n                         (i, j) =\n                         mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, j).\n                              if i \\<noteq> I\n                              then arith_ops_record.minus ops (A $$ (i, j))\n                                    (arith_ops_record.times ops\n((v \\<circ> integer_of_nat) i) (A $$ (I, j)))\n                              else A $$ (i, j)) $$\n                         (i, j)\n 2. dim_row\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if v (integer_of_nat i) \\<noteq> arith_ops_record.zero ops \\<and>\n              i \\<noteq> I\n           then arith_ops_record.minus ops (A $$ (i, j))\n                 (arith_ops_record.times ops (v (integer_of_nat i))\n                   (A $$ (I, j)))\n           else A $$ (i, j))) =\n    dim_row\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if i \\<noteq> I\n           then arith_ops_record.minus ops (A $$ (i, j))\n                 (arith_ops_record.times ops ((v \\<circ> integer_of_nat) i)\n                   (A $$ (I, j)))\n           else A $$ (i, j)))\n 3. dim_col\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if v (integer_of_nat i) \\<noteq> arith_ops_record.zero ops \\<and>\n              i \\<noteq> I\n           then arith_ops_record.minus ops (A $$ (i, j))\n                 (arith_ops_record.times ops (v (integer_of_nat i))\n                   (A $$ (I, j)))\n           else A $$ (i, j))) =\n    dim_col\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if i \\<noteq> I\n           then arith_ops_record.minus ops (A $$ (i, j))\n                 (arith_ops_record.times ops ((v \\<circ> integer_of_nat) i)\n                   (A $$ (I, j)))\n           else A $$ (i, j)))", "case (1 i j)"], ["proof (state)\nthis:\n  i < dim_row\n       (mat (dim_row A) (dim_col A)\n         (\\<lambda>(i, j).\n             if i \\<noteq> I\n             then arith_ops_record.minus ops (A $$ (i, j))\n                   (arith_ops_record.times ops\n                     ((v \\<circ> integer_of_nat) i) (A $$ (I, j)))\n             else A $$ (i, j)))\n  j < dim_col\n       (mat (dim_row A) (dim_col A)\n         (\\<lambda>(i, j).\n             if i \\<noteq> I\n             then arith_ops_record.minus ops (A $$ (i, j))\n                   (arith_ops_record.times ops\n                     ((v \\<circ> integer_of_nat) i) (A $$ (I, j)))\n             else A $$ (i, j)))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat (dim_row A) (dim_col A)\n                       (\\<lambda>(i, j).\n                           if i \\<noteq> I\n                           then arith_ops_record.minus ops (A $$ (i, j))\n                                 (arith_ops_record.times ops\n                                   ((v \\<circ> integer_of_nat) i)\n                                   (A $$ (I, j)))\n                           else A $$ (i, j)));\n        j < dim_col\n             (mat (dim_row A) (dim_col A)\n               (\\<lambda>(i, j).\n                   if i \\<noteq> I\n                   then arith_ops_record.minus ops (A $$ (i, j))\n                         (arith_ops_record.times ops\n                           ((v \\<circ> integer_of_nat) i) (A $$ (I, j)))\n                   else A $$ (i, j)))\\<rbrakk>\n       \\<Longrightarrow> mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, j).\n                              if v (integer_of_nat i) \\<noteq>\n                                 arith_ops_record.zero ops \\<and>\n                                 i \\<noteq> I\n                              then arith_ops_record.minus ops (A $$ (i, j))\n                                    (arith_ops_record.times ops\n(v (integer_of_nat i)) (A $$ (I, j)))\n                              else A $$ (i, j)) $$\n                         (i, j) =\n                         mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, j).\n                              if i \\<noteq> I\n                              then arith_ops_record.minus ops (A $$ (i, j))\n                                    (arith_ops_record.times ops\n((v \\<circ> integer_of_nat) i) (A $$ (I, j)))\n                              else A $$ (i, j)) $$\n                         (i, j)\n 2. dim_row\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if v (integer_of_nat i) \\<noteq> arith_ops_record.zero ops \\<and>\n              i \\<noteq> I\n           then arith_ops_record.minus ops (A $$ (i, j))\n                 (arith_ops_record.times ops (v (integer_of_nat i))\n                   (A $$ (I, j)))\n           else A $$ (i, j))) =\n    dim_row\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if i \\<noteq> I\n           then arith_ops_record.minus ops (A $$ (i, j))\n                 (arith_ops_record.times ops ((v \\<circ> integer_of_nat) i)\n                   (A $$ (I, j)))\n           else A $$ (i, j)))\n 3. dim_col\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if v (integer_of_nat i) \\<noteq> arith_ops_record.zero ops \\<and>\n              i \\<noteq> I\n           then arith_ops_record.minus ops (A $$ (i, j))\n                 (arith_ops_record.times ops (v (integer_of_nat i))\n                   (A $$ (I, j)))\n           else A $$ (i, j))) =\n    dim_col\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if i \\<noteq> I\n           then arith_ops_record.minus ops (A $$ (i, j))\n                 (arith_ops_record.times ops ((v \\<circ> integer_of_nat) i)\n                   (A $$ (I, j)))\n           else A $$ (i, j)))", "have d1:\"DP (A $$ (I, j))\" and d2:\"DP (A $$ (i, j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_ops_record.DP ops (A $$ (I, j)) &&&\n    arith_ops_record.DP ops (A $$ (i, j))", "using assms DPR 1"], ["proof (prove)\nusing this:\n  mat_rel R A A'\n  I < dim_row A'\n  Domainp R = arith_ops_record.DP ops\n  i < dim_row\n       (mat (dim_row A) (dim_col A)\n         (\\<lambda>(i, j).\n             if i \\<noteq> I\n             then arith_ops_record.minus ops (A $$ (i, j))\n                   (arith_ops_record.times ops\n                     ((v \\<circ> integer_of_nat) i) (A $$ (I, j)))\n             else A $$ (i, j)))\n  j < dim_col\n       (mat (dim_row A) (dim_col A)\n         (\\<lambda>(i, j).\n             if i \\<noteq> I\n             then arith_ops_record.minus ops (A $$ (i, j))\n                   (arith_ops_record.times ops\n                     ((v \\<circ> integer_of_nat) i) (A $$ (I, j)))\n             else A $$ (i, j)))\n\ngoal (1 subgoal):\n 1. arith_ops_record.DP ops (A $$ (I, j)) &&&\n    arith_ops_record.DP ops (A $$ (i, j))", "unfolding mat_rel_def dim_col_mat dim_row_mat"], ["proof (prove)\nusing this:\n  dim_row A = dim_row A' \\<and>\n  dim_col A = dim_col A' \\<and>\n  (\\<forall>i j.\n      i < dim_row A' \\<longrightarrow>\n      j < dim_col A' \\<longrightarrow> R (A $$ (i, j)) (A' $$ (i, j)))\n  I < dim_row A'\n  Domainp R = arith_ops_record.DP ops\n  i < dim_row A\n  j < dim_col A\n\ngoal (1 subgoal):\n 1. arith_ops_record.DP ops (A $$ (I, j)) &&&\n    arith_ops_record.DP ops (A $$ (i, j))", "by (metis Domainp.DomainI)+"], ["proof (state)\nthis:\n  arith_ops_record.DP ops (A $$ (I, j))\n  arith_ops_record.DP ops (A $$ (i, j))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat (dim_row A) (dim_col A)\n                       (\\<lambda>(i, j).\n                           if i \\<noteq> I\n                           then arith_ops_record.minus ops (A $$ (i, j))\n                                 (arith_ops_record.times ops\n                                   ((v \\<circ> integer_of_nat) i)\n                                   (A $$ (I, j)))\n                           else A $$ (i, j)));\n        j < dim_col\n             (mat (dim_row A) (dim_col A)\n               (\\<lambda>(i, j).\n                   if i \\<noteq> I\n                   then arith_ops_record.minus ops (A $$ (i, j))\n                         (arith_ops_record.times ops\n                           ((v \\<circ> integer_of_nat) i) (A $$ (I, j)))\n                   else A $$ (i, j)))\\<rbrakk>\n       \\<Longrightarrow> mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, j).\n                              if v (integer_of_nat i) \\<noteq>\n                                 arith_ops_record.zero ops \\<and>\n                                 i \\<noteq> I\n                              then arith_ops_record.minus ops (A $$ (i, j))\n                                    (arith_ops_record.times ops\n(v (integer_of_nat i)) (A $$ (I, j)))\n                              else A $$ (i, j)) $$\n                         (i, j) =\n                         mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, j).\n                              if i \\<noteq> I\n                              then arith_ops_record.minus ops (A $$ (i, j))\n                                    (arith_ops_record.times ops\n((v \\<circ> integer_of_nat) i) (A $$ (I, j)))\n                              else A $$ (i, j)) $$\n                         (i, j)\n 2. dim_row\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if v (integer_of_nat i) \\<noteq> arith_ops_record.zero ops \\<and>\n              i \\<noteq> I\n           then arith_ops_record.minus ops (A $$ (i, j))\n                 (arith_ops_record.times ops (v (integer_of_nat i))\n                   (A $$ (I, j)))\n           else A $$ (i, j))) =\n    dim_row\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if i \\<noteq> I\n           then arith_ops_record.minus ops (A $$ (i, j))\n                 (arith_ops_record.times ops ((v \\<circ> integer_of_nat) i)\n                   (A $$ (I, j)))\n           else A $$ (i, j)))\n 3. dim_col\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if v (integer_of_nat i) \\<noteq> arith_ops_record.zero ops \\<and>\n              i \\<noteq> I\n           then arith_ops_record.minus ops (A $$ (i, j))\n                 (arith_ops_record.times ops (v (integer_of_nat i))\n                   (A $$ (I, j)))\n           else A $$ (i, j))) =\n    dim_col\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if i \\<noteq> I\n           then arith_ops_record.minus ops (A $$ (i, j))\n                 (arith_ops_record.times ops ((v \\<circ> integer_of_nat) i)\n                   (A $$ (I, j)))\n           else A $$ (i, j)))", "have e1:\"\\<And> x. (0::'a) * x = 0\" and e2:\"\\<And> x. x - (0::'a) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. (0::'a) * x = (0::'a)) &&& (\\<And>x. x - (0::'a) = x)", "by auto"], ["proof (state)\nthis:\n  (0::'a) * ?x = (0::'a)\n  ?x - (0::'a) = ?x\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat (dim_row A) (dim_col A)\n                       (\\<lambda>(i, j).\n                           if i \\<noteq> I\n                           then arith_ops_record.minus ops (A $$ (i, j))\n                                 (arith_ops_record.times ops\n                                   ((v \\<circ> integer_of_nat) i)\n                                   (A $$ (I, j)))\n                           else A $$ (i, j)));\n        j < dim_col\n             (mat (dim_row A) (dim_col A)\n               (\\<lambda>(i, j).\n                   if i \\<noteq> I\n                   then arith_ops_record.minus ops (A $$ (i, j))\n                         (arith_ops_record.times ops\n                           ((v \\<circ> integer_of_nat) i) (A $$ (I, j)))\n                   else A $$ (i, j)))\\<rbrakk>\n       \\<Longrightarrow> mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, j).\n                              if v (integer_of_nat i) \\<noteq>\n                                 arith_ops_record.zero ops \\<and>\n                                 i \\<noteq> I\n                              then arith_ops_record.minus ops (A $$ (i, j))\n                                    (arith_ops_record.times ops\n(v (integer_of_nat i)) (A $$ (I, j)))\n                              else A $$ (i, j)) $$\n                         (i, j) =\n                         mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, j).\n                              if i \\<noteq> I\n                              then arith_ops_record.minus ops (A $$ (i, j))\n                                    (arith_ops_record.times ops\n((v \\<circ> integer_of_nat) i) (A $$ (I, j)))\n                              else A $$ (i, j)) $$\n                         (i, j)\n 2. dim_row\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if v (integer_of_nat i) \\<noteq> arith_ops_record.zero ops \\<and>\n              i \\<noteq> I\n           then arith_ops_record.minus ops (A $$ (i, j))\n                 (arith_ops_record.times ops (v (integer_of_nat i))\n                   (A $$ (I, j)))\n           else A $$ (i, j))) =\n    dim_row\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if i \\<noteq> I\n           then arith_ops_record.minus ops (A $$ (i, j))\n                 (arith_ops_record.times ops ((v \\<circ> integer_of_nat) i)\n                   (A $$ (I, j)))\n           else A $$ (i, j)))\n 3. dim_col\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if v (integer_of_nat i) \\<noteq> arith_ops_record.zero ops \\<and>\n              i \\<noteq> I\n           then arith_ops_record.minus ops (A $$ (i, j))\n                 (arith_ops_record.times ops (v (integer_of_nat i))\n                   (A $$ (I, j)))\n           else A $$ (i, j))) =\n    dim_col\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if i \\<noteq> I\n           then arith_ops_record.minus ops (A $$ (i, j))\n                 (arith_ops_record.times ops ((v \\<circ> integer_of_nat) i)\n                   (A $$ (I, j)))\n           else A $$ (i, j)))", "from e1[untransferred,OF d1] e2[untransferred,OF d2] 1"], ["proof (chain)\npicking this:\n  arith_ops_record.times ops (arith_ops_record.zero ops) (A $$ (I, j)) =\n  arith_ops_record.zero ops\n  arith_ops_record.minus ops (A $$ (i, j)) (arith_ops_record.zero ops) =\n  A $$ (i, j)\n  i < dim_row\n       (mat (dim_row A) (dim_col A)\n         (\\<lambda>(i, j).\n             if i \\<noteq> I\n             then arith_ops_record.minus ops (A $$ (i, j))\n                   (arith_ops_record.times ops\n                     ((v \\<circ> integer_of_nat) i) (A $$ (I, j)))\n             else A $$ (i, j)))\n  j < dim_col\n       (mat (dim_row A) (dim_col A)\n         (\\<lambda>(i, j).\n             if i \\<noteq> I\n             then arith_ops_record.minus ops (A $$ (i, j))\n                   (arith_ops_record.times ops\n                     ((v \\<circ> integer_of_nat) i) (A $$ (I, j)))\n             else A $$ (i, j)))", "show ?case"], ["proof (prove)\nusing this:\n  arith_ops_record.times ops (arith_ops_record.zero ops) (A $$ (I, j)) =\n  arith_ops_record.zero ops\n  arith_ops_record.minus ops (A $$ (i, j)) (arith_ops_record.zero ops) =\n  A $$ (i, j)\n  i < dim_row\n       (mat (dim_row A) (dim_col A)\n         (\\<lambda>(i, j).\n             if i \\<noteq> I\n             then arith_ops_record.minus ops (A $$ (i, j))\n                   (arith_ops_record.times ops\n                     ((v \\<circ> integer_of_nat) i) (A $$ (I, j)))\n             else A $$ (i, j)))\n  j < dim_col\n       (mat (dim_row A) (dim_col A)\n         (\\<lambda>(i, j).\n             if i \\<noteq> I\n             then arith_ops_record.minus ops (A $$ (i, j))\n                   (arith_ops_record.times ops\n                     ((v \\<circ> integer_of_nat) i) (A $$ (I, j)))\n             else A $$ (i, j)))\n\ngoal (1 subgoal):\n 1. mat (dim_row A) (dim_col A)\n     (\\<lambda>(i, j).\n         if v (integer_of_nat i) \\<noteq> arith_ops_record.zero ops \\<and>\n            i \\<noteq> I\n         then arith_ops_record.minus ops (A $$ (i, j))\n               (arith_ops_record.times ops (v (integer_of_nat i))\n                 (A $$ (I, j)))\n         else A $$ (i, j)) $$\n    (i, j) =\n    mat (dim_row A) (dim_col A)\n     (\\<lambda>(i, j).\n         if i \\<noteq> I\n         then arith_ops_record.minus ops (A $$ (i, j))\n               (arith_ops_record.times ops ((v \\<circ> integer_of_nat) i)\n                 (A $$ (I, j)))\n         else A $$ (i, j)) $$\n    (i, j)", "by auto"], ["proof (state)\nthis:\n  mat (dim_row A) (dim_col A)\n   (\\<lambda>(i, j).\n       if v (integer_of_nat i) \\<noteq> arith_ops_record.zero ops \\<and>\n          i \\<noteq> I\n       then arith_ops_record.minus ops (A $$ (i, j))\n             (arith_ops_record.times ops (v (integer_of_nat i))\n               (A $$ (I, j)))\n       else A $$ (i, j)) $$\n  (i, j) =\n  mat (dim_row A) (dim_col A)\n   (\\<lambda>(i, j).\n       if i \\<noteq> I\n       then arith_ops_record.minus ops (A $$ (i, j))\n             (arith_ops_record.times ops ((v \\<circ> integer_of_nat) i)\n               (A $$ (I, j)))\n       else A $$ (i, j)) $$\n  (i, j)\n\ngoal (2 subgoals):\n 1. dim_row\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if v (integer_of_nat i) \\<noteq> arith_ops_record.zero ops \\<and>\n              i \\<noteq> I\n           then arith_ops_record.minus ops (A $$ (i, j))\n                 (arith_ops_record.times ops (v (integer_of_nat i))\n                   (A $$ (I, j)))\n           else A $$ (i, j))) =\n    dim_row\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if i \\<noteq> I\n           then arith_ops_record.minus ops (A $$ (i, j))\n                 (arith_ops_record.times ops ((v \\<circ> integer_of_nat) i)\n                   (A $$ (I, j)))\n           else A $$ (i, j)))\n 2. dim_col\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if v (integer_of_nat i) \\<noteq> arith_ops_record.zero ops \\<and>\n              i \\<noteq> I\n           then arith_ops_record.minus ops (A $$ (i, j))\n                 (arith_ops_record.times ops (v (integer_of_nat i))\n                   (A $$ (I, j)))\n           else A $$ (i, j))) =\n    dim_col\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if i \\<noteq> I\n           then arith_ops_record.minus ops (A $$ (i, j))\n                 (arith_ops_record.times ops ((v \\<circ> integer_of_nat) i)\n                   (A $$ (I, j)))\n           else A $$ (i, j)))", "qed auto"], ["", "lemma eliminate_entries_i: assumes  \n  vs: \"\\<And> j. j < dim_row B' \\<Longrightarrow> R (vs (integer_of_nat j)) (vs' j)\" \n  and i: \"i < dim_row B'\"  \n  and B: \"mat_rel R B B'\"  \n  shows \"mat_rel R (eliminate_entries_i ops vs B i j) \n    (eliminate_entries vs' B' i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R (eliminate_entries_i ops vs B i j)\n     (eliminate_entries vs' B' i j)", "unfolding eliminate_entries_i_def eliminate_entries_gen_zero[OF B i]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R\n     (eliminate_entries_gen (arith_ops_record.minus ops)\n       (arith_ops_record.times ops) (vs \\<circ> integer_of_nat) B i j)\n     (eliminate_entries vs' B' i j)", "by (rule eliminate_entries_gen_transfer, insert assms, auto simp: plus times minus)"], ["", "lemma gauss_jordan_main_i:  \n  \"nr = dim_row A' \\<Longrightarrow> nc = dim_col A' \\<Longrightarrow> mat_rel R A A' \\<Longrightarrow> i \\<le> nr \\<Longrightarrow> j \\<le> nc \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j) (fst (gauss_jordan_main A' B' i j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nr = dim_row A'; nc = dim_col A'; mat_rel R A A'; i \\<le> nr;\n     j \\<le> nc\\<rbrakk>\n    \\<Longrightarrow> mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n                       (fst (gauss_jordan_main A' B' i j))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>nr = dim_row A'; nc = dim_col A'; mat_rel R A A'; i \\<le> nr;\n     j \\<le> nc\\<rbrakk>\n    \\<Longrightarrow> mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n                       (fst (gauss_jordan_main A' B' i j))", "obtain P where P: \"P = (A',i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P. P = (A', i, j) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P = (A', i, j)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nr = dim_row A'; nc = dim_col A'; mat_rel R A A'; i \\<le> nr;\n     j \\<le> nc\\<rbrakk>\n    \\<Longrightarrow> mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n                       (fst (gauss_jordan_main A' B' i j))", "let ?Rel = \"measures [\\<lambda> (A' :: 'a mat,i,j). nc - j, \\<lambda> (A',i,j). if A' $$ (i,j) = 0 then 1 else 0]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>nr = dim_row A'; nc = dim_col A'; mat_rel R A A'; i \\<le> nr;\n     j \\<le> nc\\<rbrakk>\n    \\<Longrightarrow> mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n                       (fst (gauss_jordan_main A' B' i j))", "have wf: \"wf ?Rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measures\n         [\\<lambda>(A', i, j). nc - j,\n          \\<lambda>(A', i, j). if A' $$ (i, j) = (0::'a) then 1 else 0])", "by simp"], ["proof (state)\nthis:\n  wf (measures\n       [\\<lambda>(A', i, j). nc - j,\n        \\<lambda>(A', i, j). if A' $$ (i, j) = (0::'a) then 1 else 0])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nr = dim_row A'; nc = dim_col A'; mat_rel R A A'; i \\<le> nr;\n     j \\<le> nc\\<rbrakk>\n    \\<Longrightarrow> mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n                       (fst (gauss_jordan_main A' B' i j))", "show \"nr = dim_row A' \\<Longrightarrow> nc = dim_col A' \\<Longrightarrow> mat_rel R A A' \\<Longrightarrow> i \\<le> nr \\<Longrightarrow> j \\<le> nc \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j) (fst (gauss_jordan_main A' B' i j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nr = dim_row A'; nc = dim_col A'; mat_rel R A A'; i \\<le> nr;\n     j \\<le> nc\\<rbrakk>\n    \\<Longrightarrow> mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n                       (fst (gauss_jordan_main A' B' i j))", "using P"], ["proof (prove)\nusing this:\n  P = (A', i, j)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nr = dim_row A'; nc = dim_col A'; mat_rel R A A'; i \\<le> nr;\n     j \\<le> nc\\<rbrakk>\n    \\<Longrightarrow> mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n                       (fst (gauss_jordan_main A' B' i j))", "proof (induct P arbitrary: A' B' A i j rule: wf_induct[OF wf])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x A' B' A i j.\n       \\<lbrakk>\\<forall>y.\n                   (y, x)\n                   \\<in> measures\n                          [\\<lambda>(A', i, j). nc - j,\n                           \\<lambda>(A', i, j).\n                              if A' $$ (i, j) = (0::'a) then 1\n                              else 0] \\<longrightarrow>\n                   (\\<forall>x.\n                       nr = dim_row x \\<longrightarrow>\n                       nc = dim_col x \\<longrightarrow>\n                       (\\<forall>xa xb.\n                           mat_rel R xb x \\<longrightarrow>\n                           (\\<forall>xc\\<le>nr.\n                               \\<forall>xd\\<le>nc.\n                                  y = (x, xc, xd) \\<longrightarrow>\n                                  mat_rel R\n                                   (gauss_jordan_main_i ops nr nc xb xc xd)\n                                   (fst (gauss_jordan_main x xa xc xd)))));\n        nr = dim_row A'; nc = dim_col A'; mat_rel R A A'; i \\<le> nr;\n        j \\<le> nc; x = (A', i, j)\\<rbrakk>\n       \\<Longrightarrow> mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n                          (fst (gauss_jordan_main A' B' i j))", "case (1 P A' B' A i j)"], ["proof (state)\nthis:\n  \\<forall>y.\n     (y, P)\n     \\<in> measures\n            [\\<lambda>(A', i, j). nc - j,\n             \\<lambda>(A', i, j).\n                if A' $$ (i, j) = (0::'a) then 1 else 0] \\<longrightarrow>\n     (\\<forall>x.\n         nr = dim_row x \\<longrightarrow>\n         nc = dim_col x \\<longrightarrow>\n         (\\<forall>xa xb.\n             mat_rel R xb x \\<longrightarrow>\n             (\\<forall>xc\\<le>nr.\n                 \\<forall>xd\\<le>nc.\n                    y = (x, xc, xd) \\<longrightarrow>\n                    mat_rel R (gauss_jordan_main_i ops nr nc xb xc xd)\n                     (fst (gauss_jordan_main x xa xc xd)))))\n  nr = dim_row A'\n  nc = dim_col A'\n  mat_rel R A A'\n  i \\<le> nr\n  j \\<le> nc\n  P = (A', i, j)\n\ngoal (1 subgoal):\n 1. \\<And>x A' B' A i j.\n       \\<lbrakk>\\<forall>y.\n                   (y, x)\n                   \\<in> measures\n                          [\\<lambda>(A', i, j). nc - j,\n                           \\<lambda>(A', i, j).\n                              if A' $$ (i, j) = (0::'a) then 1\n                              else 0] \\<longrightarrow>\n                   (\\<forall>x.\n                       nr = dim_row x \\<longrightarrow>\n                       nc = dim_col x \\<longrightarrow>\n                       (\\<forall>xa xb.\n                           mat_rel R xb x \\<longrightarrow>\n                           (\\<forall>xc\\<le>nr.\n                               \\<forall>xd\\<le>nc.\n                                  y = (x, xc, xd) \\<longrightarrow>\n                                  mat_rel R\n                                   (gauss_jordan_main_i ops nr nc xb xc xd)\n                                   (fst (gauss_jordan_main x xa xc xd)))));\n        nr = dim_row A'; nc = dim_col A'; mat_rel R A A'; i \\<le> nr;\n        j \\<le> nc; x = (A', i, j)\\<rbrakk>\n       \\<Longrightarrow> mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n                          (fst (gauss_jordan_main A' B' i j))", "note prems = 1(2-6)"], ["proof (state)\nthis:\n  nr = dim_row A'\n  nc = dim_col A'\n  mat_rel R A A'\n  i \\<le> nr\n  j \\<le> nc\n\ngoal (1 subgoal):\n 1. \\<And>x A' B' A i j.\n       \\<lbrakk>\\<forall>y.\n                   (y, x)\n                   \\<in> measures\n                          [\\<lambda>(A', i, j). nc - j,\n                           \\<lambda>(A', i, j).\n                              if A' $$ (i, j) = (0::'a) then 1\n                              else 0] \\<longrightarrow>\n                   (\\<forall>x.\n                       nr = dim_row x \\<longrightarrow>\n                       nc = dim_col x \\<longrightarrow>\n                       (\\<forall>xa xb.\n                           mat_rel R xb x \\<longrightarrow>\n                           (\\<forall>xc\\<le>nr.\n                               \\<forall>xd\\<le>nc.\n                                  y = (x, xc, xd) \\<longrightarrow>\n                                  mat_rel R\n                                   (gauss_jordan_main_i ops nr nc xb xc xd)\n                                   (fst (gauss_jordan_main x xa xc xd)))));\n        nr = dim_row A'; nc = dim_col A'; mat_rel R A A'; i \\<le> nr;\n        j \\<le> nc; x = (A', i, j)\\<rbrakk>\n       \\<Longrightarrow> mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n                          (fst (gauss_jordan_main A' B' i j))", "note P = 1(7)"], ["proof (state)\nthis:\n  P = (A', i, j)\n\ngoal (1 subgoal):\n 1. \\<And>x A' B' A i j.\n       \\<lbrakk>\\<forall>y.\n                   (y, x)\n                   \\<in> measures\n                          [\\<lambda>(A', i, j). nc - j,\n                           \\<lambda>(A', i, j).\n                              if A' $$ (i, j) = (0::'a) then 1\n                              else 0] \\<longrightarrow>\n                   (\\<forall>x.\n                       nr = dim_row x \\<longrightarrow>\n                       nc = dim_col x \\<longrightarrow>\n                       (\\<forall>xa xb.\n                           mat_rel R xb x \\<longrightarrow>\n                           (\\<forall>xc\\<le>nr.\n                               \\<forall>xd\\<le>nc.\n                                  y = (x, xc, xd) \\<longrightarrow>\n                                  mat_rel R\n                                   (gauss_jordan_main_i ops nr nc xb xc xd)\n                                   (fst (gauss_jordan_main x xa xc xd)))));\n        nr = dim_row A'; nc = dim_col A'; mat_rel R A A'; i \\<le> nr;\n        j \\<le> nc; x = (A', i, j)\\<rbrakk>\n       \\<Longrightarrow> mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n                          (fst (gauss_jordan_main A' B' i j))", "note A[transfer_rule] = prems(3)"], ["proof (state)\nthis:\n  mat_rel R A A'\n\ngoal (1 subgoal):\n 1. \\<And>x A' B' A i j.\n       \\<lbrakk>\\<forall>y.\n                   (y, x)\n                   \\<in> measures\n                          [\\<lambda>(A', i, j). nc - j,\n                           \\<lambda>(A', i, j).\n                              if A' $$ (i, j) = (0::'a) then 1\n                              else 0] \\<longrightarrow>\n                   (\\<forall>x.\n                       nr = dim_row x \\<longrightarrow>\n                       nc = dim_col x \\<longrightarrow>\n                       (\\<forall>xa xb.\n                           mat_rel R xb x \\<longrightarrow>\n                           (\\<forall>xc\\<le>nr.\n                               \\<forall>xd\\<le>nc.\n                                  y = (x, xc, xd) \\<longrightarrow>\n                                  mat_rel R\n                                   (gauss_jordan_main_i ops nr nc xb xc xd)\n                                   (fst (gauss_jordan_main x xa xc xd)))));\n        nr = dim_row A'; nc = dim_col A'; mat_rel R A A'; i \\<le> nr;\n        j \\<le> nc; x = (A', i, j)\\<rbrakk>\n       \\<Longrightarrow> mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n                          (fst (gauss_jordan_main A' B' i j))", "note IH = 1(1)[rule_format, OF _ _ _ _ _ _ refl]"], ["proof (state)\nthis:\n  \\<lbrakk>((?x, ?xc, ?xd), P)\n           \\<in> measures\n                  [\\<lambda>(A', i, y). nc - y,\n                   \\<lambda>(A', i, j).\n                      if A' $$ (i, j) = (0::'a) then 1 else 0];\n   nr = dim_row ?x; nc = dim_col ?x; mat_rel R ?xb ?x; ?xc \\<le> nr;\n   ?xd \\<le> nc\\<rbrakk>\n  \\<Longrightarrow> mat_rel R (gauss_jordan_main_i ops nr nc ?xb ?xc ?xd)\n                     (fst (gauss_jordan_main ?x ?xa ?xc ?xd))\n\ngoal (1 subgoal):\n 1. \\<And>x A' B' A i j.\n       \\<lbrakk>\\<forall>y.\n                   (y, x)\n                   \\<in> measures\n                          [\\<lambda>(A', i, j). nc - j,\n                           \\<lambda>(A', i, j).\n                              if A' $$ (i, j) = (0::'a) then 1\n                              else 0] \\<longrightarrow>\n                   (\\<forall>x.\n                       nr = dim_row x \\<longrightarrow>\n                       nc = dim_col x \\<longrightarrow>\n                       (\\<forall>xa xb.\n                           mat_rel R xb x \\<longrightarrow>\n                           (\\<forall>xc\\<le>nr.\n                               \\<forall>xd\\<le>nc.\n                                  y = (x, xc, xd) \\<longrightarrow>\n                                  mat_rel R\n                                   (gauss_jordan_main_i ops nr nc xb xc xd)\n                                   (fst (gauss_jordan_main x xa xc xd)))));\n        nr = dim_row A'; nc = dim_col A'; mat_rel R A A'; i \\<le> nr;\n        j \\<le> nc; x = (A', i, j)\\<rbrakk>\n       \\<Longrightarrow> mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n                          (fst (gauss_jordan_main A' B' i j))", "note simps = gauss_jordan_main_code[of A' B' i j, unfolded Let_def, folded prems(1-2)] \n      gauss_jordan_main_i.simps[of ops nr nc A i j] Let_def if_True if_False"], ["proof (state)\nthis:\n  gauss_jordan_main A' B' i j =\n  (if i < nr \\<and> j < nc\n   then if A' $$ (i, j) = (0::'a)\n        then case concat\n                   (map (\\<lambda>i'.\n                            if A' $$ (i', j) \\<noteq> (0::'a) then [i']\n                            else [])\n                     [Suc i..<nr]) of\n             [] \\<Rightarrow> gauss_jordan_main A' B' i (Suc j)\n             | i' # x \\<Rightarrow>\n                 gauss_jordan_main (swaprows i i' A') (swaprows i i' B') i j\n        else if A' $$ (i, j) = (1::'a)\n             then gauss_jordan_main\n                   (eliminate_entries (\\<lambda>i. A' $$ (i, j)) A' i j)\n                   (eliminate_entries (\\<lambda>i. A' $$ (i, j)) B' i j)\n                   (Suc i) (Suc j)\n             else gauss_jordan_main\n                   (eliminate_entries\n                     (\\<lambda>i.\n                         multrow i (inverse_class.inverse (A' $$ (i, j)))\n                          A' $$\n                         (i, j))\n                     (multrow i (inverse_class.inverse (A' $$ (i, j))) A') i\n                     j)\n                   (eliminate_entries\n                     (\\<lambda>i.\n                         multrow i (inverse_class.inverse (A' $$ (i, j)))\n                          A' $$\n                         (i, j))\n                     (multrow i (inverse_class.inverse (A' $$ (i, j))) B') i\n                     j)\n                   (Suc i) (Suc j)\n   else (A', B'))\n  gauss_jordan_main_i ops nr nc A i j =\n  (if i < nr \\<and> j < nc\n   then let aij = A $$ (i, j)\n        in if aij = arith_ops_record.zero ops\n           then case concat\n                      (map (\\<lambda>i'.\n                               if A $$ (i', j) \\<noteq>\n                                  arith_ops_record.zero ops\n                               then [i'] else [])\n                        [Suc i..<nr]) of\n                [] \\<Rightarrow> gauss_jordan_main_i ops nr nc A i (Suc j)\n                | i' # x \\<Rightarrow>\n                    gauss_jordan_main_i ops nr nc (swaprows i i' A) i j\n           else if aij = arith_ops_record.one ops\n                then let v = \\<lambda>i. A $$ (nat_of_integer i, j)\n                     in gauss_jordan_main_i ops nr nc\n                         (eliminate_entries_i ops v A i j) (Suc i) (Suc j)\n                else let iaij = arith_ops_record.inverse ops aij;\n                         A' = multrow_i ops i iaij A;\n                         v = \\<lambda>i. A' $$ (nat_of_integer i, j)\n                     in gauss_jordan_main_i ops nr nc\n                         (eliminate_entries_i ops v A' i j) (Suc i) (Suc j)\n   else A)\n  Let ?s ?f \\<equiv> ?f ?s\n  (if True then ?x else ?y) = ?x\n  (if False then ?x else ?y) = ?y\n\ngoal (1 subgoal):\n 1. \\<And>x A' B' A i j.\n       \\<lbrakk>\\<forall>y.\n                   (y, x)\n                   \\<in> measures\n                          [\\<lambda>(A', i, j). nc - j,\n                           \\<lambda>(A', i, j).\n                              if A' $$ (i, j) = (0::'a) then 1\n                              else 0] \\<longrightarrow>\n                   (\\<forall>x.\n                       nr = dim_row x \\<longrightarrow>\n                       nc = dim_col x \\<longrightarrow>\n                       (\\<forall>xa xb.\n                           mat_rel R xb x \\<longrightarrow>\n                           (\\<forall>xc\\<le>nr.\n                               \\<forall>xd\\<le>nc.\n                                  y = (x, xc, xd) \\<longrightarrow>\n                                  mat_rel R\n                                   (gauss_jordan_main_i ops nr nc xb xc xd)\n                                   (fst (gauss_jordan_main x xa xc xd)))));\n        nr = dim_row A'; nc = dim_col A'; mat_rel R A A'; i \\<le> nr;\n        j \\<le> nc; x = (A', i, j)\\<rbrakk>\n       \\<Longrightarrow> mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n                          (fst (gauss_jordan_main A' B' i j))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "proof (cases \"i < nr \\<and> j < nc\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))\n 2. \\<not> (i < nr \\<and> j < nc) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "case False"], ["proof (state)\nthis:\n  \\<not> (i < nr \\<and> j < nc)\n\ngoal (2 subgoals):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))\n 2. \\<not> (i < nr \\<and> j < nc) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "hence id: \"(i < nr \\<and> j < nc) = False\""], ["proof (prove)\nusing this:\n  \\<not> (i < nr \\<and> j < nc)\n\ngoal (1 subgoal):\n 1. (i < nr \\<and> j < nc) = False", "by simp"], ["proof (state)\nthis:\n  (i < nr \\<and> j < nc) = False\n\ngoal (2 subgoals):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))\n 2. \\<not> (i < nr \\<and> j < nc) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "unfolding simps id"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R A (fst (A', B'))", "by simp transfer_prover"], ["proof (state)\nthis:\n  mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n   (fst (gauss_jordan_main A' B' i j))\n\ngoal (1 subgoal):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "case True"], ["proof (state)\nthis:\n  i < nr \\<and> j < nc\n\ngoal (1 subgoal):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "note ij' = this"], ["proof (state)\nthis:\n  i < nr \\<and> j < nc\n\ngoal (1 subgoal):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "hence id: \"(i < nr \\<and> j < nc) = True\" \"\\<And> x y z. (if x = x then y else z) = y\""], ["proof (prove)\nusing this:\n  i < nr \\<and> j < nc\n\ngoal (1 subgoal):\n 1. (i < nr \\<and> j < nc) = True &&&\n    (\\<And>x y z. (if x = x then y else z) = y)", "by auto"], ["proof (state)\nthis:\n  (i < nr \\<and> j < nc) = True\n  (if ?x = ?x then ?y else ?z) = ?y\n\ngoal (1 subgoal):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "from True prems"], ["proof (chain)\npicking this:\n  i < nr \\<and> j < nc\n  nr = dim_row A'\n  nc = dim_col A'\n  mat_rel R A A'\n  i \\<le> nr\n  j \\<le> nc", "have ij [transfer_rule]:\"R (A $$ (i,j)) (A' $$ (i,j))\""], ["proof (prove)\nusing this:\n  i < nr \\<and> j < nc\n  nr = dim_row A'\n  nc = dim_col A'\n  mat_rel R A A'\n  i \\<le> nr\n  j \\<le> nc\n\ngoal (1 subgoal):\n 1. R (A $$ (i, j)) (A' $$ (i, j))", "unfolding mat_rel_def"], ["proof (prove)\nusing this:\n  i < nr \\<and> j < nc\n  nr = dim_row A'\n  nc = dim_col A'\n  dim_row A = dim_row A' \\<and>\n  dim_col A = dim_col A' \\<and>\n  (\\<forall>i j.\n      i < dim_row A' \\<longrightarrow>\n      j < dim_col A' \\<longrightarrow> R (A $$ (i, j)) (A' $$ (i, j)))\n  i \\<le> nr\n  j \\<le> nc\n\ngoal (1 subgoal):\n 1. R (A $$ (i, j)) (A' $$ (i, j))", "by auto"], ["proof (state)\nthis:\n  R (A $$ (i, j)) (A' $$ (i, j))\n\ngoal (1 subgoal):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "from True prems"], ["proof (chain)\npicking this:\n  i < nr \\<and> j < nc\n  nr = dim_row A'\n  nc = dim_col A'\n  mat_rel R A A'\n  i \\<le> nr\n  j \\<le> nc", "have i: \"i < dim_row A'\" \"j < dim_col A'\" and i': \"i < nr\" \"j < nc\""], ["proof (prove)\nusing this:\n  i < nr \\<and> j < nc\n  nr = dim_row A'\n  nc = dim_col A'\n  mat_rel R A A'\n  i \\<le> nr\n  j \\<le> nc\n\ngoal (1 subgoal):\n 1. (i < dim_row A' &&& j < dim_col A') &&& i < nr &&& j < nc", "by auto"], ["proof (state)\nthis:\n  i < dim_row A'\n  j < dim_col A'\n  i < nr\n  j < nc\n\ngoal (1 subgoal):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "{"], ["proof (state)\nthis:\n  i < dim_row A'\n  j < dim_col A'\n  i < nr\n  j < nc\n\ngoal (1 subgoal):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. ia__ < nr \\<and> j < nc \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A ia__ j)\n     (fst (gauss_jordan_main A' B' ia__ j))", "assume \"i < dim_row A'\""], ["proof (state)\nthis:\n  i < dim_row A'\n\ngoal (1 subgoal):\n 1. ia__ < nr \\<and> j < nc \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A ia__ j)\n     (fst (gauss_jordan_main A' B' ia__ j))", "with i True prems"], ["proof (chain)\npicking this:\n  ia__ < dim_row A'\n  j < dim_col A'\n  ia__ < nr \\<and> j < nc\n  nr = dim_row A'\n  nc = dim_col A'\n  mat_rel R A A'\n  ia__ \\<le> nr\n  j \\<le> nc\n  i < dim_row A'", "have R[transfer_rule]:\"R (A $$ (i,j)) (A' $$ (i,j))\""], ["proof (prove)\nusing this:\n  ia__ < dim_row A'\n  j < dim_col A'\n  ia__ < nr \\<and> j < nc\n  nr = dim_row A'\n  nc = dim_col A'\n  mat_rel R A A'\n  ia__ \\<le> nr\n  j \\<le> nc\n  i < dim_row A'\n\ngoal (1 subgoal):\n 1. R (A $$ (i, j)) (A' $$ (i, j))", "unfolding mat_rel_def"], ["proof (prove)\nusing this:\n  ia__ < dim_row A'\n  j < dim_col A'\n  ia__ < nr \\<and> j < nc\n  nr = dim_row A'\n  nc = dim_col A'\n  dim_row A = dim_row A' \\<and>\n  dim_col A = dim_col A' \\<and>\n  (\\<forall>i j.\n      i < dim_row A' \\<longrightarrow>\n      j < dim_col A' \\<longrightarrow> R (A $$ (i, j)) (A' $$ (i, j)))\n  ia__ \\<le> nr\n  j \\<le> nc\n  i < dim_row A'\n\ngoal (1 subgoal):\n 1. R (A $$ (i, j)) (A' $$ (i, j))", "by auto"], ["proof (state)\nthis:\n  R (A $$ (i, j)) (A' $$ (i, j))\n\ngoal (1 subgoal):\n 1. ia__ < nr \\<and> j < nc \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A ia__ j)\n     (fst (gauss_jordan_main A' B' ia__ j))", "have \"(A $$ (i,j) = zero) = (A' $$ (i,j) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A $$ (i, j) = arith_ops_record.zero ops) = (A' $$ (i, j) = (0::'a))", "by transfer_prover"], ["proof (state)\nthis:\n  (A $$ (i, j) = arith_ops_record.zero ops) = (A' $$ (i, j) = (0::'a))\n\ngoal (1 subgoal):\n 1. ia__ < nr \\<and> j < nc \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A ia__ j)\n     (fst (gauss_jordan_main A' B' ia__ j))", "note this R"], ["proof (state)\nthis:\n  (A $$ (i, j) = arith_ops_record.zero ops) = (A' $$ (i, j) = (0::'a))\n  R (A $$ (i, j)) (A' $$ (i, j))\n\ngoal (1 subgoal):\n 1. ia__ < nr \\<and> j < nc \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A ia__ j)\n     (fst (gauss_jordan_main A' B' ia__ j))", "}"], ["proof (state)\nthis:\n  ?ib3 < dim_row A' \\<Longrightarrow>\n  (A $$ (?ib3, j) = arith_ops_record.zero ops) = (A' $$ (?ib3, j) = (0::'a))\n  ?ib3 < dim_row A' \\<Longrightarrow> R (A $$ (?ib3, j)) (A' $$ (?ib3, j))\n\ngoal (1 subgoal):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "note eq_gen = this"], ["proof (state)\nthis:\n  ?ib3 < dim_row A' \\<Longrightarrow>\n  (A $$ (?ib3, j) = arith_ops_record.zero ops) = (A' $$ (?ib3, j) = (0::'a))\n  ?ib3 < dim_row A' \\<Longrightarrow> R (A $$ (?ib3, j)) (A' $$ (?ib3, j))\n\ngoal (1 subgoal):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "have eq: \"(A $$ (i,j) = zero) = (A' $$ (i,j) = 0)\"\n        \"(A $$ (i,j) = one) = (A' $$ (i,j) = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A $$ (i, j) = arith_ops_record.zero ops) = (A' $$ (i, j) = (0::'a)) &&&\n    (A $$ (i, j) = arith_ops_record.one ops) = (A' $$ (i, j) = (1::'a))", "by transfer_prover+"], ["proof (state)\nthis:\n  (A $$ (i, j) = arith_ops_record.zero ops) = (A' $$ (i, j) = (0::'a))\n  (A $$ (i, j) = arith_ops_record.one ops) = (A' $$ (i, j) = (1::'a))\n\ngoal (1 subgoal):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "proof (cases \"A' $$ (i, j) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A' $$ (i, j) = (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))\n 2. A' $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "case True"], ["proof (state)\nthis:\n  A' $$ (i, j) = (0::'a)\n\ngoal (2 subgoals):\n 1. A' $$ (i, j) = (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))\n 2. A' $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "hence eq: \"A $$ (i,j) = zero\""], ["proof (prove)\nusing this:\n  A' $$ (i, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = arith_ops_record.zero ops", "using eq"], ["proof (prove)\nusing this:\n  A' $$ (i, j) = (0::'a)\n  (A $$ (i, j) = arith_ops_record.zero ops) = (A' $$ (i, j) = (0::'a))\n  (A $$ (i, j) = arith_ops_record.one ops) = (A' $$ (i, j) = (1::'a))\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = arith_ops_record.zero ops", "by auto"], ["proof (state)\nthis:\n  A $$ (i, j) = arith_ops_record.zero ops\n\ngoal (2 subgoals):\n 1. A' $$ (i, j) = (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))\n 2. A' $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "let ?is = \"[ i' . i' <- [Suc i ..< nr],  A $$ (i',j) \\<noteq> zero]\""], ["proof (state)\ngoal (2 subgoals):\n 1. A' $$ (i, j) = (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))\n 2. A' $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "let ?is' = \"[ i' . i' <- [Suc i ..< nr],  A' $$ (i',j) \\<noteq> 0]\""], ["proof (state)\ngoal (2 subgoals):\n 1. A' $$ (i, j) = (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))\n 2. A' $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "define xs where \"xs = [Suc i..<nr]\""], ["proof (state)\nthis:\n  xs = [Suc i..<nr]\n\ngoal (2 subgoals):\n 1. A' $$ (i, j) = (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))\n 2. A' $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "have xs: \"set xs \\<subseteq> {0 ..< dim_row A'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> {0..<dim_row A'}", "unfolding xs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set [Suc i..<nr] \\<subseteq> {0..<dim_row A'}", "using prems"], ["proof (prove)\nusing this:\n  nr = dim_row A'\n  nc = dim_col A'\n  mat_rel R A A'\n  i \\<le> nr\n  j \\<le> nc\n\ngoal (1 subgoal):\n 1. set [Suc i..<nr] \\<subseteq> {0..<dim_row A'}", "by auto"], ["proof (state)\nthis:\n  set xs \\<subseteq> {0..<dim_row A'}\n\ngoal (2 subgoals):\n 1. A' $$ (i, j) = (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))\n 2. A' $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "hence id': \"?is = ?is'\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> {0..<dim_row A'}\n\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>i'.\n              if A $$ (i', j) \\<noteq> arith_ops_record.zero ops then [i']\n              else [])\n       [Suc i..<nr]) =\n    concat\n     (map (\\<lambda>i'. if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n       [Suc i..<nr])", "unfolding xs_def[symmetric]"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> {0..<dim_row A'}\n\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>i'.\n              if A $$ (i', j) \\<noteq> arith_ops_record.zero ops then [i']\n              else [])\n       xs) =\n    concat\n     (map (\\<lambda>i'. if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n       xs)", "by (induct xs, insert eq_gen, auto)"], ["proof (state)\nthis:\n  concat\n   (map (\\<lambda>i'.\n            if A $$ (i', j) \\<noteq> arith_ops_record.zero ops then [i']\n            else [])\n     [Suc i..<nr]) =\n  concat\n   (map (\\<lambda>i'. if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n     [Suc i..<nr])\n\ngoal (2 subgoals):\n 1. A' $$ (i, j) = (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))\n 2. A' $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "proof (cases ?is')"], ["proof (state)\ngoal (2 subgoals):\n 1. concat\n     (map (\\<lambda>i'. if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n       [Suc i..<nr]) =\n    [] \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))\n 2. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n        (fst (gauss_jordan_main A' B' i j))", "case Nil"], ["proof (state)\nthis:\n  concat\n   (map (\\<lambda>i'. if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n     [Suc i..<nr]) =\n  []\n\ngoal (2 subgoals):\n 1. concat\n     (map (\\<lambda>i'. if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n       [Suc i..<nr]) =\n    [] \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))\n 2. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n        (fst (gauss_jordan_main A' B' i j))", "have \"?thesis = (mat_rel R (gauss_jordan_main_i ops nr nc A i (Suc j)) \n            (fst (gauss_jordan_main A' B' i (Suc j))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j)) =\n    mat_rel R (gauss_jordan_main_i ops nr nc A i (Suc j))\n     (fst (gauss_jordan_main A' B' i (Suc j)))", "unfolding True simps id eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R\n     (case concat\n            (map (\\<lambda>i'.\n                     if A $$ (i', j) \\<noteq> arith_ops_record.zero ops\n                     then [i'] else [])\n              [Suc i..<nr]) of\n      [] \\<Rightarrow> gauss_jordan_main_i ops nr nc A i (Suc j)\n      | i' # x \\<Rightarrow>\n          gauss_jordan_main_i ops nr nc (swaprows i i' A) i j)\n     (fst (case concat\n                 (map (\\<lambda>i'.\n                          if A' $$ (i', j) \\<noteq> (0::'a) then [i']\n                          else [])\n                   [Suc i..<nr]) of\n           [] \\<Rightarrow> gauss_jordan_main A' B' i (Suc j)\n           | i' # x \\<Rightarrow>\n               gauss_jordan_main (swaprows i i' A') (swaprows i i' B') i\n                j)) =\n    mat_rel R (gauss_jordan_main_i ops nr nc A i (Suc j))\n     (fst (gauss_jordan_main A' B' i (Suc j)))", "unfolding Nil id'[unfolded Nil]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R\n     (case [] of [] \\<Rightarrow> gauss_jordan_main_i ops nr nc A i (Suc j)\n      | i' # x \\<Rightarrow>\n          gauss_jordan_main_i ops nr nc (swaprows i i' A) i j)\n     (fst (case [] of [] \\<Rightarrow> gauss_jordan_main A' B' i (Suc j)\n           | i' # x \\<Rightarrow>\n               gauss_jordan_main (swaprows i i' A') (swaprows i i' B') i\n                j)) =\n    mat_rel R (gauss_jordan_main_i ops nr nc A i (Suc j))\n     (fst (gauss_jordan_main A' B' i (Suc j)))", "by simp"], ["proof (state)\nthis:\n  mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n   (fst (gauss_jordan_main A' B' i j)) =\n  mat_rel R (gauss_jordan_main_i ops nr nc A i (Suc j))\n   (fst (gauss_jordan_main A' B' i (Suc j)))\n\ngoal (2 subgoals):\n 1. concat\n     (map (\\<lambda>i'. if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n       [Suc i..<nr]) =\n    [] \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))\n 2. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n        (fst (gauss_jordan_main A' B' i j))", "also"], ["proof (state)\nthis:\n  mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n   (fst (gauss_jordan_main A' B' i j)) =\n  mat_rel R (gauss_jordan_main_i ops nr nc A i (Suc j))\n   (fst (gauss_jordan_main A' B' i (Suc j)))\n\ngoal (2 subgoals):\n 1. concat\n     (map (\\<lambda>i'. if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n       [Suc i..<nr]) =\n    [] \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))\n 2. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n        (fst (gauss_jordan_main A' B' i j))", "have \"\\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R (gauss_jordan_main_i ops nr nc A i (Suc j))\n     (fst (gauss_jordan_main A' B' i (Suc j)))", "by (rule IH, insert i prems P, auto)"], ["proof (state)\nthis:\n  mat_rel R (gauss_jordan_main_i ops nr nc A i (Suc j))\n   (fst (gauss_jordan_main A' B' i (Suc j)))\n\ngoal (2 subgoals):\n 1. concat\n     (map (\\<lambda>i'. if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n       [Suc i..<nr]) =\n    [] \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))\n 2. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n        (fst (gauss_jordan_main A' B' i j))", "finally"], ["proof (chain)\npicking this:\n  mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n   (fst (gauss_jordan_main A' B' i j))", "show ?thesis"], ["proof (prove)\nusing this:\n  mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n   (fst (gauss_jordan_main A' B' i j))\n\ngoal (1 subgoal):\n 1. mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "."], ["proof (state)\nthis:\n  mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n   (fst (gauss_jordan_main A' B' i j))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n        (fst (gauss_jordan_main A' B' i j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n        (fst (gauss_jordan_main A' B' i j))", "case (Cons i' idx')"], ["proof (state)\nthis:\n  concat\n   (map (\\<lambda>i'. if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n     [Suc i..<nr]) =\n  i' # idx'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n        (fst (gauss_jordan_main A' B' i j))", "from arg_cong[OF this, of set] i"], ["proof (chain)\npicking this:\n  set (concat\n        (map (\\<lambda>i'.\n                 if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr])) =\n  set (i' # idx')\n  i < dim_row A'\n  j < dim_col A'", "have i': \"i' < nr\" \"A' $$ (i', j) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  set (concat\n        (map (\\<lambda>i'.\n                 if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr])) =\n  set (i' # idx')\n  i < dim_row A'\n  j < dim_col A'\n\ngoal (1 subgoal):\n 1. i' < nr &&& A' $$ (i', j) \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  i' < nr\n  A' $$ (i', j) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n        (fst (gauss_jordan_main A' B' i j))", "with ij' prems(1-2)"], ["proof (chain)\npicking this:\n  i < nr \\<and> j < nc\n  nr = dim_row A'\n  nc = dim_col A'\n  i' < nr\n  A' $$ (i', j) \\<noteq> (0::'a)", "have *: \"i' < dim_row A'\" \"i < dim_row A'\" \"j < dim_col A'\""], ["proof (prove)\nusing this:\n  i < nr \\<and> j < nc\n  nr = dim_row A'\n  nc = dim_col A'\n  i' < nr\n  A' $$ (i', j) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. i' < dim_row A' &&& i < dim_row A' &&& j < dim_col A'", "by auto"], ["proof (state)\nthis:\n  i' < dim_row A'\n  i < dim_row A'\n  j < dim_col A'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n        (fst (gauss_jordan_main A' B' i j))", "have rel: \"((swaprows i i' A', i, j), P) \\<in> ?Rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((swaprows i i' A', i, j), P)\n    \\<in> measures\n           [\\<lambda>(A', i, j). nc - j,\n            \\<lambda>(A', i, j). if A' $$ (i, j) = (0::'a) then 1 else 0]", "by (simp add: P True * i')"], ["proof (state)\nthis:\n  ((swaprows i i' A', i, j), P)\n  \\<in> measures\n         [\\<lambda>(A', i, j). nc - j,\n          \\<lambda>(A', i, j). if A' $$ (i, j) = (0::'a) then 1 else 0]\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n        (fst (gauss_jordan_main A' B' i j))", "have \"?thesis = (mat_rel R (gauss_jordan_main_i ops nr nc (swaprows i i' A) i j)\n            (fst (gauss_jordan_main (swaprows i i' A') (swaprows i i' B') i j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j)) =\n    mat_rel R (gauss_jordan_main_i ops nr nc (swaprows i i' A) i j)\n     (fst (gauss_jordan_main (swaprows i i' A') (swaprows i i' B') i j))", "unfolding True simps id eq Cons id'[unfolded Cons]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R\n     (case i' # idx' of\n      [] \\<Rightarrow> gauss_jordan_main_i ops nr nc A i (Suc j)\n      | i' # x \\<Rightarrow>\n          gauss_jordan_main_i ops nr nc (swaprows i i' A) i j)\n     (fst (case i' # idx' of\n           [] \\<Rightarrow> gauss_jordan_main A' B' i (Suc j)\n           | i' # x \\<Rightarrow>\n               gauss_jordan_main (swaprows i i' A') (swaprows i i' B') i\n                j)) =\n    mat_rel R (gauss_jordan_main_i ops nr nc (swaprows i i' A) i j)\n     (fst (gauss_jordan_main (swaprows i i' A') (swaprows i i' B') i j))", "by simp"], ["proof (state)\nthis:\n  mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n   (fst (gauss_jordan_main A' B' i j)) =\n  mat_rel R (gauss_jordan_main_i ops nr nc (swaprows i i' A) i j)\n   (fst (gauss_jordan_main (swaprows i i' A') (swaprows i i' B') i j))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n        (fst (gauss_jordan_main A' B' i j))", "also"], ["proof (state)\nthis:\n  mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n   (fst (gauss_jordan_main A' B' i j)) =\n  mat_rel R (gauss_jordan_main_i ops nr nc (swaprows i i' A) i j)\n   (fst (gauss_jordan_main (swaprows i i' A') (swaprows i i' B') i j))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n        (fst (gauss_jordan_main A' B' i j))", "have \"\\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R (gauss_jordan_main_i ops nr nc (swaprows i i' A) i j)\n     (fst (gauss_jordan_main (swaprows i i' A') (swaprows i i' B') i j))", "by (rule IH[OF rel _ _ swap_rows_transfer], insert i i' prems P True, auto)"], ["proof (state)\nthis:\n  mat_rel R (gauss_jordan_main_i ops nr nc (swaprows i i' A) i j)\n   (fst (gauss_jordan_main (swaprows i i' A') (swaprows i i' B') i j))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A' $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n        (fst (gauss_jordan_main A' B' i j))", "finally"], ["proof (chain)\npicking this:\n  mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n   (fst (gauss_jordan_main A' B' i j))", "show ?thesis"], ["proof (prove)\nusing this:\n  mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n   (fst (gauss_jordan_main A' B' i j))\n\ngoal (1 subgoal):\n 1. mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "."], ["proof (state)\nthis:\n  mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n   (fst (gauss_jordan_main A' B' i j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n   (fst (gauss_jordan_main A' B' i j))\n\ngoal (1 subgoal):\n 1. A' $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A' $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "case False"], ["proof (state)\nthis:\n  A' $$ (i, j) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A' $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "from False eq"], ["proof (chain)\npicking this:\n  A' $$ (i, j) \\<noteq> (0::'a)\n  (A $$ (i, j) = arith_ops_record.zero ops) = (A' $$ (i, j) = (0::'a))\n  (A $$ (i, j) = arith_ops_record.one ops) = (A' $$ (i, j) = (1::'a))", "have neq: \"(A $$ (i, j) = zero) = False\" \"(A' $$ (i, j) = 0) = False\""], ["proof (prove)\nusing this:\n  A' $$ (i, j) \\<noteq> (0::'a)\n  (A $$ (i, j) = arith_ops_record.zero ops) = (A' $$ (i, j) = (0::'a))\n  (A $$ (i, j) = arith_ops_record.one ops) = (A' $$ (i, j) = (1::'a))\n\ngoal (1 subgoal):\n 1. (A $$ (i, j) = arith_ops_record.zero ops) = False &&&\n    (A' $$ (i, j) = (0::'a)) = False", "by auto"], ["proof (state)\nthis:\n  (A $$ (i, j) = arith_ops_record.zero ops) = False\n  (A' $$ (i, j) = (0::'a)) = False\n\ngoal (1 subgoal):\n 1. A' $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "{"], ["proof (state)\nthis:\n  (A $$ (i, j) = arith_ops_record.zero ops) = False\n  (A' $$ (i, j) = (0::'a)) = False\n\ngoal (1 subgoal):\n 1. A' $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "fix B B' i"], ["proof (state)\ngoal (1 subgoal):\n 1. A' $$ (ia__, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A ia__ j)\n     (fst (gauss_jordan_main A' B'a__ ia__ j))", "assume B[transfer_rule]: \"mat_rel R B B'\" and dim: \"dim_col B' = nc\" and i: \"i < dim_row B'\""], ["proof (state)\nthis:\n  mat_rel R B B'\n  dim_col B' = nc\n  i < dim_row B'\n\ngoal (1 subgoal):\n 1. A' $$ (ia__, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A ia__ j)\n     (fst (gauss_jordan_main A' B'a__ ia__ j))", "from dim i True"], ["proof (chain)\npicking this:\n  dim_col B' = nc\n  i < dim_row B'\n  ia__ < nr \\<and> j < nc", "have \"j < dim_col B'\""], ["proof (prove)\nusing this:\n  dim_col B' = nc\n  i < dim_row B'\n  ia__ < nr \\<and> j < nc\n\ngoal (1 subgoal):\n 1. j < dim_col B'", "by simp"], ["proof (state)\nthis:\n  j < dim_col B'\n\ngoal (1 subgoal):\n 1. A' $$ (ia__, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A ia__ j)\n     (fst (gauss_jordan_main A' B'a__ ia__ j))", "with B i"], ["proof (chain)\npicking this:\n  mat_rel R B B'\n  i < dim_row B'\n  j < dim_col B'", "have \"R (B $$ (i,j)) (B' $$ (i,j))\""], ["proof (prove)\nusing this:\n  mat_rel R B B'\n  i < dim_row B'\n  j < dim_col B'\n\ngoal (1 subgoal):\n 1. R (B $$ (i, j)) (B' $$ (i, j))", "by (simp add: mat_rel_def)"], ["proof (state)\nthis:\n  R (B $$ (i, j)) (B' $$ (i, j))\n\ngoal (1 subgoal):\n 1. A' $$ (ia__, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A ia__ j)\n     (fst (gauss_jordan_main A' B'a__ ia__ j))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>mat_rel R ?B3 ?B'b3; dim_col ?B'b3 = nc;\n   ?ib3 < dim_row ?B'b3\\<rbrakk>\n  \\<Longrightarrow> R (?B3 $$ (?ib3, j)) (?B'b3 $$ (?ib3, j))\n\ngoal (1 subgoal):\n 1. A' $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "note vec_rel = this"], ["proof (state)\nthis:\n  \\<lbrakk>mat_rel R ?B3 ?B'b3; dim_col ?B'b3 = nc;\n   ?ib3 < dim_row ?B'b3\\<rbrakk>\n  \\<Longrightarrow> R (?B3 $$ (?ib3, j)) (?B'b3 $$ (?ib3, j))\n\ngoal (1 subgoal):\n 1. A' $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "from prems"], ["proof (chain)\npicking this:\n  nr = dim_row A'\n  nc = dim_col A'\n  mat_rel R A A'\n  i \\<le> nr\n  j \\<le> nc", "have dim: \"dim_row A = dim_row A'\""], ["proof (prove)\nusing this:\n  nr = dim_row A'\n  nc = dim_col A'\n  mat_rel R A A'\n  i \\<le> nr\n  j \\<le> nc\n\ngoal (1 subgoal):\n 1. dim_row A = dim_row A'", "unfolding mat_rel_def"], ["proof (prove)\nusing this:\n  nr = dim_row A'\n  nc = dim_col A'\n  dim_row A = dim_row A' \\<and>\n  dim_col A = dim_col A' \\<and>\n  (\\<forall>i j.\n      i < dim_row A' \\<longrightarrow>\n      j < dim_col A' \\<longrightarrow> R (A $$ (i, j)) (A' $$ (i, j)))\n  i \\<le> nr\n  j \\<le> nc\n\ngoal (1 subgoal):\n 1. dim_row A = dim_row A'", "by auto"], ["proof (state)\nthis:\n  dim_row A = dim_row A'\n\ngoal (1 subgoal):\n 1. A' $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "proof (cases \"A' $$ (i, j) = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A' $$ (i, j) = (1::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))\n 2. A' $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "case True"], ["proof (state)\nthis:\n  A' $$ (i, j) = (1::'a)\n\ngoal (2 subgoals):\n 1. A' $$ (i, j) = (1::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))\n 2. A' $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "from True eq"], ["proof (chain)\npicking this:\n  A' $$ (i, j) = (1::'a)\n  (A $$ (i, j) = arith_ops_record.zero ops) = (A' $$ (i, j) = (0::'a))\n  (A $$ (i, j) = arith_ops_record.one ops) = (A' $$ (i, j) = (1::'a))", "have eq: \"(A $$ (i,j) = one) = True\" \"(A' $$ (i,j) = 1) = True\""], ["proof (prove)\nusing this:\n  A' $$ (i, j) = (1::'a)\n  (A $$ (i, j) = arith_ops_record.zero ops) = (A' $$ (i, j) = (0::'a))\n  (A $$ (i, j) = arith_ops_record.one ops) = (A' $$ (i, j) = (1::'a))\n\ngoal (1 subgoal):\n 1. (A $$ (i, j) = arith_ops_record.one ops) = True &&&\n    (A' $$ (i, j) = (1::'a)) = True", "by auto"], ["proof (state)\nthis:\n  (A $$ (i, j) = arith_ops_record.one ops) = True\n  (A' $$ (i, j) = (1::'a)) = True\n\ngoal (2 subgoals):\n 1. A' $$ (i, j) = (1::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))\n 2. A' $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "note rel = vec_rel[OF A]"], ["proof (state)\nthis:\n  \\<lbrakk>dim_col A' = nc; ?ib3 < dim_row A'\\<rbrakk>\n  \\<Longrightarrow> R (A $$ (?ib3, j)) (A' $$ (?ib3, j))\n\ngoal (2 subgoals):\n 1. A' $$ (i, j) = (1::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))\n 2. A' $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "unfolding simps id neq eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R\n     (gauss_jordan_main_i ops nr nc\n       (eliminate_entries_i ops (\\<lambda>i. A $$ (nat_of_integer i, j)) A i\n         j)\n       (Suc i) (Suc j))\n     (fst (gauss_jordan_main\n            (eliminate_entries (\\<lambda>i. A' $$ (i, j)) A' i j)\n            (eliminate_entries (\\<lambda>i. A' $$ (i, j)) B' i j) (Suc i)\n            (Suc j)))", "by (rule IH[OF _ _ _ eliminate_entries_i], insert rel prems ij i P dim, auto)"], ["proof (state)\nthis:\n  mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n   (fst (gauss_jordan_main A' B' i j))\n\ngoal (1 subgoal):\n 1. A' $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A' $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "case False"], ["proof (state)\nthis:\n  A' $$ (i, j) \\<noteq> (1::'a)\n\ngoal (1 subgoal):\n 1. A' $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "from False eq"], ["proof (chain)\npicking this:\n  A' $$ (i, j) \\<noteq> (1::'a)\n  (A $$ (i, j) = arith_ops_record.zero ops) = (A' $$ (i, j) = (0::'a))\n  (A $$ (i, j) = arith_ops_record.one ops) = (A' $$ (i, j) = (1::'a))", "have eq: \"(A $$ (i,j) = one) = False\" \"(A' $$ (i,j) = 1) = False\""], ["proof (prove)\nusing this:\n  A' $$ (i, j) \\<noteq> (1::'a)\n  (A $$ (i, j) = arith_ops_record.zero ops) = (A' $$ (i, j) = (0::'a))\n  (A $$ (i, j) = arith_ops_record.one ops) = (A' $$ (i, j) = (1::'a))\n\ngoal (1 subgoal):\n 1. (A $$ (i, j) = arith_ops_record.one ops) = False &&&\n    (A' $$ (i, j) = (1::'a)) = False", "by auto"], ["proof (state)\nthis:\n  (A $$ (i, j) = arith_ops_record.one ops) = False\n  (A' $$ (i, j) = (1::'a)) = False\n\ngoal (1 subgoal):\n 1. A' $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n     (fst (gauss_jordan_main A' B' i j))", "unfolding simps id neq eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R\n     (gauss_jordan_main_i ops nr nc\n       (eliminate_entries_i ops\n         (\\<lambda>i.\n             multrow_i ops i (arith_ops_record.inverse ops (A $$ (i, j)))\n              A $$\n             (nat_of_integer i, j))\n         (multrow_i ops i (arith_ops_record.inverse ops (A $$ (i, j))) A) i\n         j)\n       (Suc i) (Suc j))\n     (fst (gauss_jordan_main\n            (eliminate_entries\n              (\\<lambda>i.\n                  multrow i (inverse_class.inverse (A' $$ (i, j))) A' $$\n                  (i, j))\n              (multrow i (inverse_class.inverse (A' $$ (i, j))) A') i j)\n            (eliminate_entries\n              (\\<lambda>i.\n                  multrow i (inverse_class.inverse (A' $$ (i, j))) A' $$\n                  (i, j))\n              (multrow i (inverse_class.inverse (A' $$ (i, j))) B') i j)\n            (Suc i) (Suc j)))", "proof (rule IH, goal_cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. ((eliminate_entries\n       (\\<lambda>i.\n           multrow i (inverse_class.inverse (A' $$ (i, j))) A' $$ (i, j))\n       (multrow i (inverse_class.inverse (A' $$ (i, j))) A') i j,\n      Suc i, Suc j),\n     P)\n    \\<in> measures\n           [\\<lambda>(A', i, y). nc - y,\n            \\<lambda>(A', i, j). if A' $$ (i, j) = (0::'a) then 1 else 0]\n 2. nr =\n    dim_row\n     (eliminate_entries\n       (\\<lambda>i.\n           multrow i (inverse_class.inverse (A' $$ (i, j))) A' $$ (i, j))\n       (multrow i (inverse_class.inverse (A' $$ (i, j))) A') i j)\n 3. nc =\n    dim_col\n     (eliminate_entries\n       (\\<lambda>i.\n           multrow i (inverse_class.inverse (A' $$ (i, j))) A' $$ (i, j))\n       (multrow i (inverse_class.inverse (A' $$ (i, j))) A') i j)\n 4. mat_rel R\n     (eliminate_entries_i ops\n       (\\<lambda>i.\n           multrow_i ops i (arith_ops_record.inverse ops (A $$ (i, j))) A $$\n           (nat_of_integer i, j))\n       (multrow_i ops i (arith_ops_record.inverse ops (A $$ (i, j))) A) i j)\n     (eliminate_entries\n       (\\<lambda>i.\n           multrow i (inverse_class.inverse (A' $$ (i, j))) A' $$ (i, j))\n       (multrow i (inverse_class.inverse (A' $$ (i, j))) A') i j)\n 5. Suc i \\<le> nr\n 6. Suc j \\<le> nc", "case 4"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. ((eliminate_entries\n       (\\<lambda>i.\n           multrow i (inverse_class.inverse (A' $$ (i, j))) A' $$ (i, j))\n       (multrow i (inverse_class.inverse (A' $$ (i, j))) A') i j,\n      Suc i, Suc j),\n     P)\n    \\<in> measures\n           [\\<lambda>(A', i, y). nc - y,\n            \\<lambda>(A', i, j). if A' $$ (i, j) = (0::'a) then 1 else 0]\n 2. nr =\n    dim_row\n     (eliminate_entries\n       (\\<lambda>i.\n           multrow i (inverse_class.inverse (A' $$ (i, j))) A' $$ (i, j))\n       (multrow i (inverse_class.inverse (A' $$ (i, j))) A') i j)\n 3. nc =\n    dim_col\n     (eliminate_entries\n       (\\<lambda>i.\n           multrow i (inverse_class.inverse (A' $$ (i, j))) A' $$ (i, j))\n       (multrow i (inverse_class.inverse (A' $$ (i, j))) A') i j)\n 4. mat_rel R\n     (eliminate_entries_i ops\n       (\\<lambda>i.\n           multrow_i ops i (arith_ops_record.inverse ops (A $$ (i, j))) A $$\n           (nat_of_integer i, j))\n       (multrow_i ops i (arith_ops_record.inverse ops (A $$ (i, j))) A) i j)\n     (eliminate_entries\n       (\\<lambda>i.\n           multrow i (inverse_class.inverse (A' $$ (i, j))) A' $$ (i, j))\n       (multrow i (inverse_class.inverse (A' $$ (i, j))) A') i j)\n 5. Suc i \\<le> nr\n 6. Suc j \\<le> nc", "have A': \"mat_rel R (multrow_i ops i (inverse (A $$ (i, j))) A)\n              (multrow i (inverse_class.inverse (A' $$ (i, j))) A')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R\n     (multrow_i ops i (arith_ops_record.inverse ops (A $$ (i, j))) A)\n     (multrow i (inverse_class.inverse (A' $$ (i, j))) A')", "by transfer_prover"], ["proof (state)\nthis:\n  mat_rel R (multrow_i ops i (arith_ops_record.inverse ops (A $$ (i, j))) A)\n   (multrow i (inverse_class.inverse (A' $$ (i, j))) A')\n\ngoal (6 subgoals):\n 1. ((eliminate_entries\n       (\\<lambda>i.\n           multrow i (inverse_class.inverse (A' $$ (i, j))) A' $$ (i, j))\n       (multrow i (inverse_class.inverse (A' $$ (i, j))) A') i j,\n      Suc i, Suc j),\n     P)\n    \\<in> measures\n           [\\<lambda>(A', i, y). nc - y,\n            \\<lambda>(A', i, j). if A' $$ (i, j) = (0::'a) then 1 else 0]\n 2. nr =\n    dim_row\n     (eliminate_entries\n       (\\<lambda>i.\n           multrow i (inverse_class.inverse (A' $$ (i, j))) A' $$ (i, j))\n       (multrow i (inverse_class.inverse (A' $$ (i, j))) A') i j)\n 3. nc =\n    dim_col\n     (eliminate_entries\n       (\\<lambda>i.\n           multrow i (inverse_class.inverse (A' $$ (i, j))) A' $$ (i, j))\n       (multrow i (inverse_class.inverse (A' $$ (i, j))) A') i j)\n 4. mat_rel R\n     (eliminate_entries_i ops\n       (\\<lambda>i.\n           multrow_i ops i (arith_ops_record.inverse ops (A $$ (i, j))) A $$\n           (nat_of_integer i, j))\n       (multrow_i ops i (arith_ops_record.inverse ops (A $$ (i, j))) A) i j)\n     (eliminate_entries\n       (\\<lambda>i.\n           multrow i (inverse_class.inverse (A' $$ (i, j))) A' $$ (i, j))\n       (multrow i (inverse_class.inverse (A' $$ (i, j))) A') i j)\n 5. Suc i \\<le> nr\n 6. Suc j \\<le> nc", "note rel = vec_rel[OF A']"], ["proof (state)\nthis:\n  \\<lbrakk>dim_col (multrow i (inverse_class.inverse (A' $$ (i, j))) A') =\n           nc;\n   ?ib3\n   < dim_row (multrow i (inverse_class.inverse (A' $$ (i, j))) A')\\<rbrakk>\n  \\<Longrightarrow> R (multrow_i ops i\n                        (arith_ops_record.inverse ops (A $$ (i, j))) A $$\n                       (?ib3, j))\n                     (multrow i (inverse_class.inverse (A' $$ (i, j))) A' $$\n                      (?ib3, j))\n\ngoal (6 subgoals):\n 1. ((eliminate_entries\n       (\\<lambda>i.\n           multrow i (inverse_class.inverse (A' $$ (i, j))) A' $$ (i, j))\n       (multrow i (inverse_class.inverse (A' $$ (i, j))) A') i j,\n      Suc i, Suc j),\n     P)\n    \\<in> measures\n           [\\<lambda>(A', i, y). nc - y,\n            \\<lambda>(A', i, j). if A' $$ (i, j) = (0::'a) then 1 else 0]\n 2. nr =\n    dim_row\n     (eliminate_entries\n       (\\<lambda>i.\n           multrow i (inverse_class.inverse (A' $$ (i, j))) A' $$ (i, j))\n       (multrow i (inverse_class.inverse (A' $$ (i, j))) A') i j)\n 3. nc =\n    dim_col\n     (eliminate_entries\n       (\\<lambda>i.\n           multrow i (inverse_class.inverse (A' $$ (i, j))) A' $$ (i, j))\n       (multrow i (inverse_class.inverse (A' $$ (i, j))) A') i j)\n 4. mat_rel R\n     (eliminate_entries_i ops\n       (\\<lambda>i.\n           multrow_i ops i (arith_ops_record.inverse ops (A $$ (i, j))) A $$\n           (nat_of_integer i, j))\n       (multrow_i ops i (arith_ops_record.inverse ops (A $$ (i, j))) A) i j)\n     (eliminate_entries\n       (\\<lambda>i.\n           multrow i (inverse_class.inverse (A' $$ (i, j))) A' $$ (i, j))\n       (multrow i (inverse_class.inverse (A' $$ (i, j))) A') i j)\n 5. Suc i \\<le> nr\n 6. Suc j \\<le> nc", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R\n     (eliminate_entries_i ops\n       (\\<lambda>i.\n           multrow_i ops i (arith_ops_record.inverse ops (A $$ (i, j))) A $$\n           (nat_of_integer i, j))\n       (multrow_i ops i (arith_ops_record.inverse ops (A $$ (i, j))) A) i j)\n     (eliminate_entries\n       (\\<lambda>i.\n           multrow i (inverse_class.inverse (A' $$ (i, j))) A' $$ (i, j))\n       (multrow i (inverse_class.inverse (A' $$ (i, j))) A') i j)", "by (rule eliminate_entries_i[OF _ _ A'], insert rel prems i dim, auto)"], ["proof (state)\nthis:\n  mat_rel R\n   (eliminate_entries_i ops\n     (\\<lambda>i.\n         multrow_i ops i (arith_ops_record.inverse ops (A $$ (i, j))) A $$\n         (nat_of_integer i, j))\n     (multrow_i ops i (arith_ops_record.inverse ops (A $$ (i, j))) A) i j)\n   (eliminate_entries\n     (\\<lambda>i.\n         multrow i (inverse_class.inverse (A' $$ (i, j))) A' $$ (i, j))\n     (multrow i (inverse_class.inverse (A' $$ (i, j))) A') i j)\n\ngoal (5 subgoals):\n 1. ((eliminate_entries\n       (\\<lambda>i.\n           multrow i (inverse_class.inverse (A' $$ (i, j))) A' $$ (i, j))\n       (multrow i (inverse_class.inverse (A' $$ (i, j))) A') i j,\n      Suc i, Suc j),\n     P)\n    \\<in> measures\n           [\\<lambda>(A', i, y). nc - y,\n            \\<lambda>(A', i, j). if A' $$ (i, j) = (0::'a) then 1 else 0]\n 2. nr =\n    dim_row\n     (eliminate_entries\n       (\\<lambda>i.\n           multrow i (inverse_class.inverse (A' $$ (i, j))) A' $$ (i, j))\n       (multrow i (inverse_class.inverse (A' $$ (i, j))) A') i j)\n 3. nc =\n    dim_col\n     (eliminate_entries\n       (\\<lambda>i.\n           multrow i (inverse_class.inverse (A' $$ (i, j))) A' $$ (i, j))\n       (multrow i (inverse_class.inverse (A' $$ (i, j))) A') i j)\n 4. Suc i \\<le> nr\n 5. Suc j \\<le> nc", "qed (insert prems i P, auto)"], ["proof (state)\nthis:\n  mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n   (fst (gauss_jordan_main A' B' i j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n   (fst (gauss_jordan_main A' B' i j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n   (fst (gauss_jordan_main A' B' i j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n   (fst (gauss_jordan_main A' B' i j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>nr = dim_row A'; nc = dim_col A'; mat_rel R A A'; i \\<le> nr;\n   j \\<le> nc\\<rbrakk>\n  \\<Longrightarrow> mat_rel R (gauss_jordan_main_i ops nr nc A i j)\n                     (fst (gauss_jordan_main A' B' i j))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gauss_jordan_i[transfer_rule]:  \n  \"(mat_rel R ===> mat_rel R) (gauss_jordan_single_i ops) gauss_jordan_single\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat_rel R ===> mat_rel R) (gauss_jordan_single_i ops)\n     gauss_jordan_single", "proof (intro rel_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       mat_rel R x y \\<Longrightarrow>\n       mat_rel R (gauss_jordan_single_i ops x) (gauss_jordan_single y)", "fix A A'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       mat_rel R x y \\<Longrightarrow>\n       mat_rel R (gauss_jordan_single_i ops x) (gauss_jordan_single y)", "assume A: \"mat_rel R A A'\""], ["proof (state)\nthis:\n  mat_rel R A A'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       mat_rel R x y \\<Longrightarrow>\n       mat_rel R (gauss_jordan_single_i ops x) (gauss_jordan_single y)", "show \"mat_rel R (gauss_jordan_single_i ops A) (gauss_jordan_single A')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R (gauss_jordan_single_i ops A) (gauss_jordan_single A')", "unfolding gauss_jordan_single_def gauss_jordan_single_i_def gauss_jordan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R (gauss_jordan_main_i ops (dim_row A) (dim_col A) A 0 0)\n     (fst (gauss_jordan_main A' (0\\<^sub>m (dim_row A') 0) 0 0))", "by (rule gauss_jordan_main_i[OF _ _ A], insert A, auto simp: mat_rel_def)"], ["proof (state)\nthis:\n  mat_rel R (gauss_jordan_single_i ops A) (gauss_jordan_single A')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_base_vectors_i[transfer_rule]:  \n  \"(mat_rel R ===> list_all2 (vec_rel R)) (find_base_vectors_i ops) find_base_vectors\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat_rel R ===> list_all2 (vec_rel R)) (find_base_vectors_i ops)\n     find_base_vectors", "unfolding find_base_vectors_i_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat_rel R ===> list_all2 (vec_rel R))\n     (find_base_vectors_gen (arith_ops_record.uminus ops)\n       (arith_ops_record.zero ops) (arith_ops_record.one ops))\n     find_base_vectors", "using find_base_vectors_transfer[OF eq] uminus zero one"], ["proof (prove)\nusing this:\n  ((R ===> R) ===> R ===> R ===> mat_rel R ===> list_all2 (vec_rel R))\n   find_base_vectors_gen find_base_vectors_gen\n  (R ===> R) (arith_ops_record.uminus ops) uminus_class.uminus\n  R (arith_ops_record.zero ops) (0::'a)\n  R (arith_ops_record.one ops) (1::'a)\n\ngoal (1 subgoal):\n 1. (mat_rel R ===> list_all2 (vec_rel R))\n     (find_base_vectors_gen (arith_ops_record.uminus ops)\n       (arith_ops_record.zero ops) (arith_ops_record.one ops))\n     find_base_vectors", "unfolding rel_fun_def"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     (\\<forall>xa ya.\n         R xa ya \\<longrightarrow> R (x xa) (y ya)) \\<longrightarrow>\n     (\\<forall>xa ya.\n         R xa ya \\<longrightarrow>\n         (\\<forall>xb yb.\n             R xb yb \\<longrightarrow>\n             (\\<forall>xc yc.\n                 mat_rel R xc yc \\<longrightarrow>\n                 list_all2 (vec_rel R) (find_base_vectors_gen x xa xb xc)\n                  (find_base_vectors_gen y ya yb yc))))\n  \\<forall>x y.\n     R x y \\<longrightarrow> R (arith_ops_record.uminus ops x) (- y)\n  R (arith_ops_record.zero ops) (0::'a)\n  R (arith_ops_record.one ops) (1::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       mat_rel R x y \\<longrightarrow>\n       list_all2 (vec_rel R)\n        (find_base_vectors_gen (arith_ops_record.uminus ops)\n          (arith_ops_record.zero ops) (arith_ops_record.one ops) x)\n        (find_base_vectors y)", "by blast"], ["", "end"], ["", "lemma list_of_vec_transfer[transfer_rule]: \"(vec_rel A ===> list_all2 A) list_of_vec list_of_vec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (vec_rel A ===> list_all2 A) list_of_vec list_of_vec", "unfolding rel_fun_def vec_rel_def vec_eq_iff list_all2_conv_all_nth"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       dim_vec x = dim_vec y \\<and>\n       (\\<forall>i<dim_vec y. A (x $ i) (y $ i)) \\<longrightarrow>\n       length (list_of_vec x) = length (list_of_vec y) \\<and>\n       (\\<forall>i<length (list_of_vec x).\n           A (list_of_vec x ! i) (list_of_vec y ! i))", "by auto"], ["", "lemma IArray_sub'[simp]: \"i < IArray.length a \\<Longrightarrow> IArray.sub' (a, integer_of_nat i) = IArray.sub a i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < IArray.length a \\<Longrightarrow>\n    IArray.sub' (a, integer_of_nat i) = a !! i", "by auto"], ["", "lift_definition eliminate_entries_i2 ::\n  \"'a \\<Rightarrow> ('a \\<Rightarrow> 'a \\<Rightarrow> 'a) \\<Rightarrow> ('a \\<Rightarrow> 'a \\<Rightarrow> 'a) \\<Rightarrow> (integer \\<Rightarrow> 'a) \\<Rightarrow> 'a mat_impl \\<Rightarrow> integer \\<Rightarrow> 'a mat_impl\" is\n  \"\\<lambda> z mminus ttimes v (nr, nc, a) i'.\n   (nr,nc,let ai' = IArray.sub' (a, i') in (IArray.tabulate (integer_of_nat nr, \\<lambda> i. let ai = IArray.sub' (a, i) in\n     if i = i' then ai else \n     let vi'j = v i \n     in if vi'j = z then ai\n        else \n             IArray.tabulate (integer_of_nat nc, \\<lambda> j. mminus (IArray.sub' (ai, j)) (ttimes vi'j \n               (IArray.sub' (ai', j))))\n       )))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a fun1 fun2 fun3 prod integer.\n       prod\n       \\<in> {(nr, nc, m).\n              IArray.length m = nr \\<and>\n              IArray.all (\\<lambda>r. IArray.length r = nc)\n               m} \\<Longrightarrow>\n       (case prod of\n        (nr, nc, aa) \\<Rightarrow>\n          \\<lambda>i'.\n             (nr, nc,\n              let ai' = IArray.sub' (aa, i')\n              in IArray.tabulate\n                  (integer_of_nat nr,\n                   \\<lambda>i.\n                      let ai = IArray.sub' (aa, i)\n                      in if i = i' then ai\n                         else let vi'j = fun3 i\n                              in if vi'j = a then ai\n                                 else IArray.tabulate\n (integer_of_nat nc,\n  \\<lambda>j.\n     fun1 (IArray.sub' (ai, j)) (fun2 vi'j (IArray.sub' (ai', j)))))))\n        integer\n       \\<in> {(nr, nc, m).\n              IArray.length m = nr \\<and>\n              IArray.all (\\<lambda>r. IArray.length r = nc) m}", "proof(goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a fun1 fun2 fun3 prod integer.\n       prod\n       \\<in> {(nr, nc, m).\n              IArray.length m = nr \\<and>\n              IArray.all (\\<lambda>r. IArray.length r = nc)\n               m} \\<Longrightarrow>\n       (case prod of\n        (nr, nc, aa) \\<Rightarrow>\n          \\<lambda>i'.\n             (nr, nc,\n              let ai' = IArray.sub' (aa, i')\n              in IArray.tabulate\n                  (integer_of_nat nr,\n                   \\<lambda>i.\n                      let ai = IArray.sub' (aa, i)\n                      in if i = i' then ai\n                         else let vi'j = fun3 i\n                              in if vi'j = a then ai\n                                 else IArray.tabulate\n (integer_of_nat nc,\n  \\<lambda>j.\n     fun1 (IArray.sub' (ai, j)) (fun2 vi'j (IArray.sub' (ai', j)))))))\n        integer\n       \\<in> {(nr, nc, m).\n              IArray.length m = nr \\<and>\n              IArray.all (\\<lambda>r. IArray.length r = nc) m}", "case (1 z mm tt  vec prod nat2)"], ["proof (state)\nthis:\n  prod\n  \\<in> {(nr, nc, m).\n         IArray.length m = nr \\<and>\n         IArray.all (\\<lambda>r. IArray.length r = nc) m}\n\ngoal (1 subgoal):\n 1. \\<And>a fun1 fun2 fun3 prod integer.\n       prod\n       \\<in> {(nr, nc, m).\n              IArray.length m = nr \\<and>\n              IArray.all (\\<lambda>r. IArray.length r = nc)\n               m} \\<Longrightarrow>\n       (case prod of\n        (nr, nc, aa) \\<Rightarrow>\n          \\<lambda>i'.\n             (nr, nc,\n              let ai' = IArray.sub' (aa, i')\n              in IArray.tabulate\n                  (integer_of_nat nr,\n                   \\<lambda>i.\n                      let ai = IArray.sub' (aa, i)\n                      in if i = i' then ai\n                         else let vi'j = fun3 i\n                              in if vi'j = a then ai\n                                 else IArray.tabulate\n (integer_of_nat nc,\n  \\<lambda>j.\n     fun1 (IArray.sub' (ai, j)) (fun2 vi'j (IArray.sub' (ai', j)))))))\n        integer\n       \\<in> {(nr, nc, m).\n              IArray.length m = nr \\<and>\n              IArray.all (\\<lambda>r. IArray.length r = nc) m}", "thus ?case"], ["proof (prove)\nusing this:\n  prod\n  \\<in> {(nr, nc, m).\n         IArray.length m = nr \\<and>\n         IArray.all (\\<lambda>r. IArray.length r = nc) m}\n\ngoal (1 subgoal):\n 1. (case prod of\n     (nr, nc, a) \\<Rightarrow>\n       \\<lambda>i'.\n          (nr, nc,\n           let ai' = IArray.sub' (a, i')\n           in IArray.tabulate\n               (integer_of_nat nr,\n                \\<lambda>i.\n                   let ai = IArray.sub' (a, i)\n                   in if i = i' then ai\n                      else let vi'j = vec i\n                           in if vi'j = z then ai\n                              else IArray.tabulate\n                                    (integer_of_nat nc,\n                                     \\<lambda>j.\n  mm (IArray.sub' (ai, j)) (tt vi'j (IArray.sub' (ai', j)))))))\n     nat2\n    \\<in> {(nr, nc, m).\n           IArray.length m = nr \\<and>\n           IArray.all (\\<lambda>r. IArray.length r = nc) m}", "by(cases prod;cases \"snd (snd prod)\";auto simp:Let_def)"], ["proof (state)\nthis:\n  (case prod of\n   (nr, nc, a) \\<Rightarrow>\n     \\<lambda>i'.\n        (nr, nc,\n         let ai' = IArray.sub' (a, i')\n         in IArray.tabulate\n             (integer_of_nat nr,\n              \\<lambda>i.\n                 let ai = IArray.sub' (a, i)\n                 in if i = i' then ai\n                    else let vi'j = vec i\n                         in if vi'j = z then ai\n                            else IArray.tabulate\n                                  (integer_of_nat nc,\n                                   \\<lambda>j.\nmm (IArray.sub' (ai, j)) (tt vi'j (IArray.sub' (ai', j)))))))\n   nat2\n  \\<in> {(nr, nc, m).\n         IArray.length m = nr \\<and>\n         IArray.all (\\<lambda>r. IArray.length r = nc) m}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eliminate_entries_gen_zero [simp]:\n  assumes \"i<(dim_row A)\" \"j<(dim_col A)\" shows\n  \"eliminate_entries_gen_zero mminus ttimes z v A I J $$ (i, j) =\n   (if v (integer_of_nat i) = z \\<or> i = I then A $$ (i,j) else mminus (A $$ (i,j)) (ttimes (v (integer_of_nat i)) (A $$ (I,j))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eliminate_entries_gen_zero mminus ttimes z v A I J $$ (i, j) =\n    (if v (integer_of_nat i) = z \\<or> i = I then A $$ (i, j)\n     else mminus (A $$ (i, j))\n           (ttimes (v (integer_of_nat i)) (A $$ (I, j))))", "using assms"], ["proof (prove)\nusing this:\n  i < dim_row A\n  j < dim_col A\n\ngoal (1 subgoal):\n 1. eliminate_entries_gen_zero mminus ttimes z v A I J $$ (i, j) =\n    (if v (integer_of_nat i) = z \\<or> i = I then A $$ (i, j)\n     else mminus (A $$ (i, j))\n           (ttimes (v (integer_of_nat i)) (A $$ (I, j))))", "unfolding eliminate_entries_gen_zero_def"], ["proof (prove)\nusing this:\n  i < dim_row A\n  j < dim_col A\n\ngoal (1 subgoal):\n 1. mat (dim_row A) (dim_col A)\n     (\\<lambda>(i, j).\n         if v (integer_of_nat i) \\<noteq> z \\<and> i \\<noteq> I\n         then mminus (A $$ (i, j))\n               (ttimes (v (integer_of_nat i)) (A $$ (I, j)))\n         else A $$ (i, j)) $$\n    (i, j) =\n    (if v (integer_of_nat i) = z \\<or> i = I then A $$ (i, j)\n     else mminus (A $$ (i, j))\n           (ttimes (v (integer_of_nat i)) (A $$ (I, j))))", "by auto"], ["", "lemma eliminate_entries_gen [simp]:\n  assumes \"i<(dim_row A)\" \"j<(dim_col A)\" shows\n  \"eliminate_entries_gen mminus ttimes v A I J $$ (i, j) =\n   (if i = I then A $$ (i,j) else mminus (A $$ (i,j)) (ttimes (v i) (A $$ (I,j))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eliminate_entries_gen mminus ttimes v A I J $$ (i, j) =\n    (if i = I then A $$ (i, j)\n     else mminus (A $$ (i, j)) (ttimes (v i) (A $$ (I, j))))", "using assms"], ["proof (prove)\nusing this:\n  i < dim_row A\n  j < dim_col A\n\ngoal (1 subgoal):\n 1. eliminate_entries_gen mminus ttimes v A I J $$ (i, j) =\n    (if i = I then A $$ (i, j)\n     else mminus (A $$ (i, j)) (ttimes (v i) (A $$ (I, j))))", "unfolding eliminate_entries_gen_def"], ["proof (prove)\nusing this:\n  i < dim_row A\n  j < dim_col A\n\ngoal (1 subgoal):\n 1. mat (dim_row A) (dim_col A)\n     (\\<lambda>(i, j).\n         if i \\<noteq> I\n         then mminus (A $$ (i, j)) (ttimes (v i) (A $$ (I, j)))\n         else A $$ (i, j)) $$\n    (i, j) =\n    (if i = I then A $$ (i, j)\n     else mminus (A $$ (i, j)) (ttimes (v i) (A $$ (I, j))))", "by auto"], ["", "lemma dim_mat_impl [simp]:\n  \"dim_row (mat_impl x) = dim_row_impl x\"\n  \"dim_col (mat_impl x) = dim_col_impl x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (mat_impl x) = dim_row_impl x &&&\n    dim_col (mat_impl x) = dim_col_impl x", "by (cases \"Rep_mat_impl x\";auto simp:mat_impl.rep_eq dim_row_def dim_col_def dim_row_impl.rep_eq dim_col_impl.rep_eq)+"], ["", "lemma dim_eliminate_entries_i2 [simp]:\n  \"dim_row_impl (eliminate_entries_i2 z mm tt v m i) = dim_row_impl m\"\n  \"dim_col_impl (eliminate_entries_i2 z mm tt v m i) = dim_col_impl m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row_impl (eliminate_entries_i2 z mm tt v m i) = dim_row_impl m &&&\n    dim_col_impl (eliminate_entries_i2 z mm tt v m i) = dim_col_impl m", "by (transfer, auto)+"], ["", "lemma tabulate_nth: \"i < n \\<Longrightarrow> IArray.tabulate (integer_of_nat n, f) !! i = f (integer_of_nat i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow>\n    IArray.tabulate (integer_of_nat n, f) !! i = f (integer_of_nat i)", "using of_fun_nth[of i n]"], ["proof (prove)\nusing this:\n  i < n \\<Longrightarrow> IArray.of_fun ?f n !! i = ?f i\n\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow>\n    IArray.tabulate (integer_of_nat n, f) !! i = f (integer_of_nat i)", "by auto"], ["", "lemma eliminate_entries_i2[code]:\"eliminate_entries_gen_zero mm tt z v (mat_impl m) i j\n   = (if i < dim_row_impl m \n     then mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i))\n     else (Code.abort (STR ''index out of range in eliminate_entries'') \n       (\\<lambda> _. eliminate_entries_gen_zero mm tt z v (mat_impl m) i j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eliminate_entries_gen_zero mm tt z v (mat_impl m) i j =\n    (if i < dim_row_impl m\n     then mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i))\n     else Code.abort STR ''index out of range in eliminate_entries''\n           (\\<lambda>_.\n               eliminate_entries_gen_zero mm tt z v (mat_impl m) i j))", "proof (cases \"i < dim_row_impl m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < dim_row_impl m \\<Longrightarrow>\n    eliminate_entries_gen_zero mm tt z v (mat_impl m) i j =\n    (if i < dim_row_impl m\n     then mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i))\n     else Code.abort STR ''index out of range in eliminate_entries''\n           (\\<lambda>_.\n               eliminate_entries_gen_zero mm tt z v (mat_impl m) i j))\n 2. \\<not> i < dim_row_impl m \\<Longrightarrow>\n    eliminate_entries_gen_zero mm tt z v (mat_impl m) i j =\n    (if i < dim_row_impl m\n     then mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i))\n     else Code.abort STR ''index out of range in eliminate_entries''\n           (\\<lambda>_.\n               eliminate_entries_gen_zero mm tt z v (mat_impl m) i j))", "case True"], ["proof (state)\nthis:\n  i < dim_row_impl m\n\ngoal (2 subgoals):\n 1. i < dim_row_impl m \\<Longrightarrow>\n    eliminate_entries_gen_zero mm tt z v (mat_impl m) i j =\n    (if i < dim_row_impl m\n     then mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i))\n     else Code.abort STR ''index out of range in eliminate_entries''\n           (\\<lambda>_.\n               eliminate_entries_gen_zero mm tt z v (mat_impl m) i j))\n 2. \\<not> i < dim_row_impl m \\<Longrightarrow>\n    eliminate_entries_gen_zero mm tt z v (mat_impl m) i j =\n    (if i < dim_row_impl m\n     then mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i))\n     else Code.abort STR ''index out of range in eliminate_entries''\n           (\\<lambda>_.\n               eliminate_entries_gen_zero mm tt z v (mat_impl m) i j))", "hence id: \"(i < dim_row_impl m) = True\""], ["proof (prove)\nusing this:\n  i < dim_row_impl m\n\ngoal (1 subgoal):\n 1. (i < dim_row_impl m) = True", "by simp"], ["proof (state)\nthis:\n  (i < dim_row_impl m) = True\n\ngoal (2 subgoals):\n 1. i < dim_row_impl m \\<Longrightarrow>\n    eliminate_entries_gen_zero mm tt z v (mat_impl m) i j =\n    (if i < dim_row_impl m\n     then mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i))\n     else Code.abort STR ''index out of range in eliminate_entries''\n           (\\<lambda>_.\n               eliminate_entries_gen_zero mm tt z v (mat_impl m) i j))\n 2. \\<not> i < dim_row_impl m \\<Longrightarrow>\n    eliminate_entries_gen_zero mm tt z v (mat_impl m) i j =\n    (if i < dim_row_impl m\n     then mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i))\n     else Code.abort STR ''index out of range in eliminate_entries''\n           (\\<lambda>_.\n               eliminate_entries_gen_zero mm tt z v (mat_impl m) i j))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eliminate_entries_gen_zero mm tt z v (mat_impl m) i j =\n    (if i < dim_row_impl m\n     then mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i))\n     else Code.abort STR ''index out of range in eliminate_entries''\n           (\\<lambda>_.\n               eliminate_entries_gen_zero mm tt z v (mat_impl m) i j))", "unfolding id if_True"], ["proof (prove)\ngoal (1 subgoal):\n 1. eliminate_entries_gen_zero mm tt z v (mat_impl m) i j =\n    mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i))", "proof (standard;goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ia ja.\n       \\<lbrakk>ia < dim_row\n                      (mat_impl\n                        (eliminate_entries_i2 z mm tt v m\n                          (integer_of_nat i)));\n        ja < dim_col\n              (mat_impl\n                (eliminate_entries_i2 z mm tt v m\n                  (integer_of_nat i)))\\<rbrakk>\n       \\<Longrightarrow> eliminate_entries_gen_zero mm tt z v (mat_impl m) i\n                          j $$\n                         (ia, ja) =\n                         mat_impl\n                          (eliminate_entries_i2 z mm tt v m\n                            (integer_of_nat i)) $$\n                         (ia, ja)\n 2. dim_row (eliminate_entries_gen_zero mm tt z v (mat_impl m) i j) =\n    dim_row (mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i)))\n 3. dim_col (eliminate_entries_gen_zero mm tt z v (mat_impl m) i j) =\n    dim_col (mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i)))", "case (1 i j)"], ["proof (state)\nthis:\n  i < dim_row\n       (mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i)))\n  j < dim_col\n       (mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i)))\n\ngoal (3 subgoals):\n 1. \\<And>ia ja.\n       \\<lbrakk>ia < dim_row\n                      (mat_impl\n                        (eliminate_entries_i2 z mm tt v m\n                          (integer_of_nat i)));\n        ja < dim_col\n              (mat_impl\n                (eliminate_entries_i2 z mm tt v m\n                  (integer_of_nat i)))\\<rbrakk>\n       \\<Longrightarrow> eliminate_entries_gen_zero mm tt z v (mat_impl m) i\n                          j $$\n                         (ia, ja) =\n                         mat_impl\n                          (eliminate_entries_i2 z mm tt v m\n                            (integer_of_nat i)) $$\n                         (ia, ja)\n 2. dim_row (eliminate_entries_gen_zero mm tt z v (mat_impl m) i j) =\n    dim_row (mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i)))\n 3. dim_col (eliminate_entries_gen_zero mm tt z v (mat_impl m) i j) =\n    dim_col (mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i)))", "have dims: \"i < dim_row (mat_impl m)\" \"j < dim_col (mat_impl m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < dim_row (mat_impl m) &&& j < dim_col (mat_impl m)", "using 1"], ["proof (prove)\nusing this:\n  i < dim_row\n       (mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i)))\n  j < dim_col\n       (mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i)))\n\ngoal (1 subgoal):\n 1. i < dim_row (mat_impl m) &&& j < dim_col (mat_impl m)", "by (auto simp:eliminate_entries_i2.rep_eq)"], ["proof (state)\nthis:\n  i < dim_row (mat_impl m)\n  j < dim_col (mat_impl m)\n\ngoal (3 subgoals):\n 1. \\<And>ia ja.\n       \\<lbrakk>ia < dim_row\n                      (mat_impl\n                        (eliminate_entries_i2 z mm tt v m\n                          (integer_of_nat i)));\n        ja < dim_col\n              (mat_impl\n                (eliminate_entries_i2 z mm tt v m\n                  (integer_of_nat i)))\\<rbrakk>\n       \\<Longrightarrow> eliminate_entries_gen_zero mm tt z v (mat_impl m) i\n                          j $$\n                         (ia, ja) =\n                         mat_impl\n                          (eliminate_entries_i2 z mm tt v m\n                            (integer_of_nat i)) $$\n                         (ia, ja)\n 2. dim_row (eliminate_entries_gen_zero mm tt z v (mat_impl m) i j) =\n    dim_row (mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i)))\n 3. dim_col (eliminate_entries_gen_zero mm tt z v (mat_impl m) i j) =\n    dim_col (mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i)))", "then"], ["proof (chain)\npicking this:\n  i < dim_row (mat_impl m)\n  j < dim_col (mat_impl m)", "show ?case"], ["proof (prove)\nusing this:\n  i < dim_row (mat_impl m)\n  j < dim_col (mat_impl m)\n\ngoal (1 subgoal):\n 1. eliminate_entries_gen_zero mm tt z v (mat_impl m) i j $$ (i, j) =\n    mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i)) $$ (i, j)", "unfolding eliminate_entries_gen_zero[OF dims]"], ["proof (prove)\nusing this:\n  i < dim_row (mat_impl m)\n  j < dim_col (mat_impl m)\n\ngoal (1 subgoal):\n 1. (if v (integer_of_nat i) = z \\<or> i = i then mat_impl m $$ (i, j)\n     else mm (mat_impl m $$ (i, j))\n           (tt (v (integer_of_nat i)) (mat_impl m $$ (i, j)))) =\n    mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i)) $$ (i, j)", "using True"], ["proof (prove)\nusing this:\n  i < dim_row (mat_impl m)\n  j < dim_col (mat_impl m)\n  i < dim_row_impl m\n\ngoal (1 subgoal):\n 1. (if v (integer_of_nat i) = z \\<or> i = i then mat_impl m $$ (i, j)\n     else mm (mat_impl m $$ (i, j))\n           (tt (v (integer_of_nat i)) (mat_impl m $$ (i, j)))) =\n    mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i)) $$ (i, j)", "proof(transfer, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i m j ia v z mm tt.\n       \\<lbrakk>m \\<in> {(nr, nc, m).\n                         IArray.length m = nr \\<and>\n                         IArray.all (\\<lambda>r. IArray.length r = nc) m};\n        i < fst (case m of\n                 (nr, nc, m) \\<Rightarrow>\n                   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        j < (fst \\<circ> snd)\n             (case m of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        ia < fst m\\<rbrakk>\n       \\<Longrightarrow> (if v (integer_of_nat i) = z \\<or> i = ia\n                          then (snd \\<circ> snd)\n                                (case m of\n                                 (nr, nc, m) \\<Rightarrow>\n                                   (nr, nc,\n                                    mk_mat nr nc\n                                     (\\<lambda>(i, y). m !! i !! y)))\n                                (i, j)\n                          else mm ((snd \\<circ> snd)\n                                    (case m of\n                                     (nr, nc, m) \\<Rightarrow>\n (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                                    (i, j))\n                                (tt (v (integer_of_nat i))\n                                  ((snd \\<circ> snd)\n                                    (case m of\n                                     (nr, nc, m) \\<Rightarrow>\n (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                                    (ia, j)))) =\n                         (snd \\<circ> snd)\n                          (case (case m of\n                                 (nr, nc, a) \\<Rightarrow>\n                                   \\<lambda>i'.\n(nr, nc,\n let ai' = IArray.sub' (a, i')\n in IArray.tabulate\n     (integer_of_nat nr,\n      \\<lambda>i.\n         let ai = IArray.sub' (a, i)\n         in if i = i' then ai\n            else let vi'j = v i\n                 in if vi'j = z then ai\n                    else IArray.tabulate\n                          (integer_of_nat nc,\n                           \\<lambda>j.\n                              mm (IArray.sub' (ai, j))\n                               (tt vi'j (IArray.sub' (ai', j)))))))\n                                 (integer_of_nat ia) of\n                           (nr, nc, m) \\<Rightarrow>\n                             (nr, nc,\n                              mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                          (i, j)", "case (1 i m j ia v z mm tt)"], ["proof (state)\nthis:\n  m \\<in> {(nr, nc, m).\n           IArray.length m = nr \\<and>\n           IArray.all (\\<lambda>r. IArray.length r = nc) m}\n  i < fst (case m of\n           (nr, nc, m) \\<Rightarrow>\n             (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  j < (fst \\<circ> snd)\n       (case m of\n        (nr, nc, m) \\<Rightarrow>\n          (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  ia < fst m\n\ngoal (1 subgoal):\n 1. \\<And>i m j ia v z mm tt.\n       \\<lbrakk>m \\<in> {(nr, nc, m).\n                         IArray.length m = nr \\<and>\n                         IArray.all (\\<lambda>r. IArray.length r = nc) m};\n        i < fst (case m of\n                 (nr, nc, m) \\<Rightarrow>\n                   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        j < (fst \\<circ> snd)\n             (case m of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        ia < fst m\\<rbrakk>\n       \\<Longrightarrow> (if v (integer_of_nat i) = z \\<or> i = ia\n                          then (snd \\<circ> snd)\n                                (case m of\n                                 (nr, nc, m) \\<Rightarrow>\n                                   (nr, nc,\n                                    mk_mat nr nc\n                                     (\\<lambda>(i, y). m !! i !! y)))\n                                (i, j)\n                          else mm ((snd \\<circ> snd)\n                                    (case m of\n                                     (nr, nc, m) \\<Rightarrow>\n (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                                    (i, j))\n                                (tt (v (integer_of_nat i))\n                                  ((snd \\<circ> snd)\n                                    (case m of\n                                     (nr, nc, m) \\<Rightarrow>\n (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                                    (ia, j)))) =\n                         (snd \\<circ> snd)\n                          (case (case m of\n                                 (nr, nc, a) \\<Rightarrow>\n                                   \\<lambda>i'.\n(nr, nc,\n let ai' = IArray.sub' (a, i')\n in IArray.tabulate\n     (integer_of_nat nr,\n      \\<lambda>i.\n         let ai = IArray.sub' (a, i)\n         in if i = i' then ai\n            else let vi'j = v i\n                 in if vi'j = z then ai\n                    else IArray.tabulate\n                          (integer_of_nat nc,\n                           \\<lambda>j.\n                              mm (IArray.sub' (ai, j))\n                               (tt vi'j (IArray.sub' (ai', j)))))))\n                                 (integer_of_nat ia) of\n                           (nr, nc, m) \\<Rightarrow>\n                             (nr, nc,\n                              mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                          (i, j)", "obtain nr nc M where m: \"m = (nr,nc,M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>nr nc M.\n        m = (nr, nc, M) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases m)"], ["proof (state)\nthis:\n  m = (nr, nc, M)\n\ngoal (1 subgoal):\n 1. \\<And>i m j ia v z mm tt.\n       \\<lbrakk>m \\<in> {(nr, nc, m).\n                         IArray.length m = nr \\<and>\n                         IArray.all (\\<lambda>r. IArray.length r = nc) m};\n        i < fst (case m of\n                 (nr, nc, m) \\<Rightarrow>\n                   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        j < (fst \\<circ> snd)\n             (case m of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        ia < fst m\\<rbrakk>\n       \\<Longrightarrow> (if v (integer_of_nat i) = z \\<or> i = ia\n                          then (snd \\<circ> snd)\n                                (case m of\n                                 (nr, nc, m) \\<Rightarrow>\n                                   (nr, nc,\n                                    mk_mat nr nc\n                                     (\\<lambda>(i, y). m !! i !! y)))\n                                (i, j)\n                          else mm ((snd \\<circ> snd)\n                                    (case m of\n                                     (nr, nc, m) \\<Rightarrow>\n (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                                    (i, j))\n                                (tt (v (integer_of_nat i))\n                                  ((snd \\<circ> snd)\n                                    (case m of\n                                     (nr, nc, m) \\<Rightarrow>\n (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                                    (ia, j)))) =\n                         (snd \\<circ> snd)\n                          (case (case m of\n                                 (nr, nc, a) \\<Rightarrow>\n                                   \\<lambda>i'.\n(nr, nc,\n let ai' = IArray.sub' (a, i')\n in IArray.tabulate\n     (integer_of_nat nr,\n      \\<lambda>i.\n         let ai = IArray.sub' (a, i)\n         in if i = i' then ai\n            else let vi'j = v i\n                 in if vi'j = z then ai\n                    else IArray.tabulate\n                          (integer_of_nat nc,\n                           \\<lambda>j.\n                              mm (IArray.sub' (ai, j))\n                               (tt vi'j (IArray.sub' (ai', j)))))))\n                                 (integer_of_nat ia) of\n                           (nr, nc, m) \\<Rightarrow>\n                             (nr, nc,\n                              mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                          (i, j)", "note 1 = 1[unfolded m, simplified]"], ["proof (state)\nthis:\n  length (IArray.list_of M) = nr \\<and>\n  (\\<forall>a\\<in>set (IArray.list_of M). length (IArray.list_of a) = nc)\n  i < nr\n  j < nc\n  ia < nr\n\ngoal (1 subgoal):\n 1. \\<And>i m j ia v z mm tt.\n       \\<lbrakk>m \\<in> {(nr, nc, m).\n                         IArray.length m = nr \\<and>\n                         IArray.all (\\<lambda>r. IArray.length r = nc) m};\n        i < fst (case m of\n                 (nr, nc, m) \\<Rightarrow>\n                   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        j < (fst \\<circ> snd)\n             (case m of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        ia < fst m\\<rbrakk>\n       \\<Longrightarrow> (if v (integer_of_nat i) = z \\<or> i = ia\n                          then (snd \\<circ> snd)\n                                (case m of\n                                 (nr, nc, m) \\<Rightarrow>\n                                   (nr, nc,\n                                    mk_mat nr nc\n                                     (\\<lambda>(i, y). m !! i !! y)))\n                                (i, j)\n                          else mm ((snd \\<circ> snd)\n                                    (case m of\n                                     (nr, nc, m) \\<Rightarrow>\n (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                                    (i, j))\n                                (tt (v (integer_of_nat i))\n                                  ((snd \\<circ> snd)\n                                    (case m of\n                                     (nr, nc, m) \\<Rightarrow>\n (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                                    (ia, j)))) =\n                         (snd \\<circ> snd)\n                          (case (case m of\n                                 (nr, nc, a) \\<Rightarrow>\n                                   \\<lambda>i'.\n(nr, nc,\n let ai' = IArray.sub' (a, i')\n in IArray.tabulate\n     (integer_of_nat nr,\n      \\<lambda>i.\n         let ai = IArray.sub' (a, i)\n         in if i = i' then ai\n            else let vi'j = v i\n                 in if vi'j = z then ai\n                    else IArray.tabulate\n                          (integer_of_nat nc,\n                           \\<lambda>j.\n                              mm (IArray.sub' (ai, j))\n                               (tt vi'j (IArray.sub' (ai', j)))))))\n                                 (integer_of_nat ia) of\n                           (nr, nc, m) \\<Rightarrow>\n                             (nr, nc,\n                              mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                          (i, j)", "have mk: \"\\<And> f. mk_mat nr nc f (i,j) = f (i,j)\" \n         \"\\<And> f. mk_mat nr nc f (ia,j) = f (ia,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f. mk_mat nr nc f (i, j) = f (i, j)) &&&\n    (\\<And>f. mk_mat nr nc f (ia, j) = f (ia, j))", "using 1"], ["proof (prove)\nusing this:\n  length (IArray.list_of M) = nr \\<and>\n  (\\<forall>a\\<in>set (IArray.list_of M). length (IArray.list_of a) = nc)\n  i < nr\n  j < nc\n  ia < nr\n\ngoal (1 subgoal):\n 1. (\\<And>f. mk_mat nr nc f (i, j) = f (i, j)) &&&\n    (\\<And>f. mk_mat nr nc f (ia, j) = f (ia, j))", "unfolding mk_mat_def mk_vec_def"], ["proof (prove)\nusing this:\n  length (IArray.list_of M) = nr \\<and>\n  (\\<forall>a\\<in>set (IArray.list_of M). length (IArray.list_of a) = nc)\n  i < nr\n  j < nc\n  ia < nr\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        (case (i, j) of\n         (i, j) \\<Rightarrow>\n           if i < nr \\<and> j < nc then f (i, j)\n           else undef_mat nr nc f (i, j)) =\n        f (i, j)) &&&\n    (\\<And>f.\n        (case (ia, j) of\n         (i, j) \\<Rightarrow>\n           if i < nr \\<and> j < nc then f (i, j)\n           else undef_mat nr nc f (i, j)) =\n        f (ia, j))", "by auto"], ["proof (state)\nthis:\n  mk_mat nr nc ?f (i, j) = ?f (i, j)\n  mk_mat nr nc ?f (ia, j) = ?f (ia, j)\n\ngoal (1 subgoal):\n 1. \\<And>i m j ia v z mm tt.\n       \\<lbrakk>m \\<in> {(nr, nc, m).\n                         IArray.length m = nr \\<and>\n                         IArray.all (\\<lambda>r. IArray.length r = nc) m};\n        i < fst (case m of\n                 (nr, nc, m) \\<Rightarrow>\n                   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        j < (fst \\<circ> snd)\n             (case m of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        ia < fst m\\<rbrakk>\n       \\<Longrightarrow> (if v (integer_of_nat i) = z \\<or> i = ia\n                          then (snd \\<circ> snd)\n                                (case m of\n                                 (nr, nc, m) \\<Rightarrow>\n                                   (nr, nc,\n                                    mk_mat nr nc\n                                     (\\<lambda>(i, y). m !! i !! y)))\n                                (i, j)\n                          else mm ((snd \\<circ> snd)\n                                    (case m of\n                                     (nr, nc, m) \\<Rightarrow>\n (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                                    (i, j))\n                                (tt (v (integer_of_nat i))\n                                  ((snd \\<circ> snd)\n                                    (case m of\n                                     (nr, nc, m) \\<Rightarrow>\n (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                                    (ia, j)))) =\n                         (snd \\<circ> snd)\n                          (case (case m of\n                                 (nr, nc, a) \\<Rightarrow>\n                                   \\<lambda>i'.\n(nr, nc,\n let ai' = IArray.sub' (a, i')\n in IArray.tabulate\n     (integer_of_nat nr,\n      \\<lambda>i.\n         let ai = IArray.sub' (a, i)\n         in if i = i' then ai\n            else let vi'j = v i\n                 in if vi'j = z then ai\n                    else IArray.tabulate\n                          (integer_of_nat nc,\n                           \\<lambda>j.\n                              mm (IArray.sub' (ai, j))\n                               (tt vi'j (IArray.sub' (ai', j)))))))\n                                 (integer_of_nat ia) of\n                           (nr, nc, m) \\<Rightarrow>\n                             (nr, nc,\n                              mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                          (i, j)", "note of_fun = of_fun_nth[OF 1(2)] of_fun_nth[OF 1(3)] tabulate_nth[OF 1(2)] tabulate_nth[OF 1(3)]"], ["proof (state)\nthis:\n  IArray.of_fun ?f nr !! i = ?f i\n  IArray.of_fun ?f nc !! j = ?f j\n  IArray.tabulate (integer_of_nat nr, ?f) !! i = ?f (integer_of_nat i)\n  IArray.tabulate (integer_of_nat nc, ?f) !! j = ?f (integer_of_nat j)\n\ngoal (1 subgoal):\n 1. \\<And>i m j ia v z mm tt.\n       \\<lbrakk>m \\<in> {(nr, nc, m).\n                         IArray.length m = nr \\<and>\n                         IArray.all (\\<lambda>r. IArray.length r = nc) m};\n        i < fst (case m of\n                 (nr, nc, m) \\<Rightarrow>\n                   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        j < (fst \\<circ> snd)\n             (case m of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        ia < fst m\\<rbrakk>\n       \\<Longrightarrow> (if v (integer_of_nat i) = z \\<or> i = ia\n                          then (snd \\<circ> snd)\n                                (case m of\n                                 (nr, nc, m) \\<Rightarrow>\n                                   (nr, nc,\n                                    mk_mat nr nc\n                                     (\\<lambda>(i, y). m !! i !! y)))\n                                (i, j)\n                          else mm ((snd \\<circ> snd)\n                                    (case m of\n                                     (nr, nc, m) \\<Rightarrow>\n (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                                    (i, j))\n                                (tt (v (integer_of_nat i))\n                                  ((snd \\<circ> snd)\n                                    (case m of\n                                     (nr, nc, m) \\<Rightarrow>\n (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                                    (ia, j)))) =\n                         (snd \\<circ> snd)\n                          (case (case m of\n                                 (nr, nc, a) \\<Rightarrow>\n                                   \\<lambda>i'.\n(nr, nc,\n let ai' = IArray.sub' (a, i')\n in IArray.tabulate\n     (integer_of_nat nr,\n      \\<lambda>i.\n         let ai = IArray.sub' (a, i)\n         in if i = i' then ai\n            else let vi'j = v i\n                 in if vi'j = z then ai\n                    else IArray.tabulate\n                          (integer_of_nat nc,\n                           \\<lambda>j.\n                              mm (IArray.sub' (ai, j))\n                               (tt vi'j (IArray.sub' (ai', j)))))))\n                                 (integer_of_nat ia) of\n                           (nr, nc, m) \\<Rightarrow>\n                             (nr, nc,\n                              mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                          (i, j)", "let ?c1 = \"v (integer_of_nat i) = z\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i m j ia v z mm tt.\n       \\<lbrakk>m \\<in> {(nr, nc, m).\n                         IArray.length m = nr \\<and>\n                         IArray.all (\\<lambda>r. IArray.length r = nc) m};\n        i < fst (case m of\n                 (nr, nc, m) \\<Rightarrow>\n                   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        j < (fst \\<circ> snd)\n             (case m of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        ia < fst m\\<rbrakk>\n       \\<Longrightarrow> (if v (integer_of_nat i) = z \\<or> i = ia\n                          then (snd \\<circ> snd)\n                                (case m of\n                                 (nr, nc, m) \\<Rightarrow>\n                                   (nr, nc,\n                                    mk_mat nr nc\n                                     (\\<lambda>(i, y). m !! i !! y)))\n                                (i, j)\n                          else mm ((snd \\<circ> snd)\n                                    (case m of\n                                     (nr, nc, m) \\<Rightarrow>\n (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                                    (i, j))\n                                (tt (v (integer_of_nat i))\n                                  ((snd \\<circ> snd)\n                                    (case m of\n                                     (nr, nc, m) \\<Rightarrow>\n (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                                    (ia, j)))) =\n                         (snd \\<circ> snd)\n                          (case (case m of\n                                 (nr, nc, a) \\<Rightarrow>\n                                   \\<lambda>i'.\n(nr, nc,\n let ai' = IArray.sub' (a, i')\n in IArray.tabulate\n     (integer_of_nat nr,\n      \\<lambda>i.\n         let ai = IArray.sub' (a, i)\n         in if i = i' then ai\n            else let vi'j = v i\n                 in if vi'j = z then ai\n                    else IArray.tabulate\n                          (integer_of_nat nc,\n                           \\<lambda>j.\n                              mm (IArray.sub' (ai, j))\n                               (tt vi'j (IArray.sub' (ai', j)))))))\n                                 (integer_of_nat ia) of\n                           (nr, nc, m) \\<Rightarrow>\n                             (nr, nc,\n                              mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                          (i, j)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if v (integer_of_nat i) = z \\<or> i = ia\n     then (snd \\<circ> snd)\n           (case m of\n            (nr, nc, m) \\<Rightarrow>\n              (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n           (i, j)\n     else mm ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (i, j))\n           (tt (v (integer_of_nat i))\n             ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (ia, j)))) =\n    (snd \\<circ> snd)\n     (case (case m of\n            (nr, nc, a) \\<Rightarrow>\n              \\<lambda>i'.\n                 (nr, nc,\n                  let ai' = IArray.sub' (a, i')\n                  in IArray.tabulate\n                      (integer_of_nat nr,\n                       \\<lambda>i.\n                          let ai = IArray.sub' (a, i)\n                          in if i = i' then ai\n                             else let vi'j = v i\n                                  in if vi'j = z then ai\n                                     else IArray.tabulate\n     (integer_of_nat nc,\n      \\<lambda>j.\n         mm (IArray.sub' (ai, j)) (tt vi'j (IArray.sub' (ai', j)))))))\n            (integer_of_nat ia) of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j)", "proof (cases \"?c1 \\<or> i = ia\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v (integer_of_nat i) = z \\<or> i = ia \\<Longrightarrow>\n    (if v (integer_of_nat i) = z \\<or> i = ia\n     then (snd \\<circ> snd)\n           (case m of\n            (nr, nc, m) \\<Rightarrow>\n              (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n           (i, j)\n     else mm ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (i, j))\n           (tt (v (integer_of_nat i))\n             ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (ia, j)))) =\n    (snd \\<circ> snd)\n     (case (case m of\n            (nr, nc, a) \\<Rightarrow>\n              \\<lambda>i'.\n                 (nr, nc,\n                  let ai' = IArray.sub' (a, i')\n                  in IArray.tabulate\n                      (integer_of_nat nr,\n                       \\<lambda>i.\n                          let ai = IArray.sub' (a, i)\n                          in if i = i' then ai\n                             else let vi'j = v i\n                                  in if vi'j = z then ai\n                                     else IArray.tabulate\n     (integer_of_nat nc,\n      \\<lambda>j.\n         mm (IArray.sub' (ai, j)) (tt vi'j (IArray.sub' (ai', j)))))))\n            (integer_of_nat ia) of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j)\n 2. \\<not> (v (integer_of_nat i) = z \\<or> i = ia) \\<Longrightarrow>\n    (if v (integer_of_nat i) = z \\<or> i = ia\n     then (snd \\<circ> snd)\n           (case m of\n            (nr, nc, m) \\<Rightarrow>\n              (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n           (i, j)\n     else mm ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (i, j))\n           (tt (v (integer_of_nat i))\n             ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (ia, j)))) =\n    (snd \\<circ> snd)\n     (case (case m of\n            (nr, nc, a) \\<Rightarrow>\n              \\<lambda>i'.\n                 (nr, nc,\n                  let ai' = IArray.sub' (a, i')\n                  in IArray.tabulate\n                      (integer_of_nat nr,\n                       \\<lambda>i.\n                          let ai = IArray.sub' (a, i)\n                          in if i = i' then ai\n                             else let vi'j = v i\n                                  in if vi'j = z then ai\n                                     else IArray.tabulate\n     (integer_of_nat nc,\n      \\<lambda>j.\n         mm (IArray.sub' (ai, j)) (tt vi'j (IArray.sub' (ai', j)))))))\n            (integer_of_nat ia) of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j)", "case True"], ["proof (state)\nthis:\n  v (integer_of_nat i) = z \\<or> i = ia\n\ngoal (2 subgoals):\n 1. v (integer_of_nat i) = z \\<or> i = ia \\<Longrightarrow>\n    (if v (integer_of_nat i) = z \\<or> i = ia\n     then (snd \\<circ> snd)\n           (case m of\n            (nr, nc, m) \\<Rightarrow>\n              (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n           (i, j)\n     else mm ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (i, j))\n           (tt (v (integer_of_nat i))\n             ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (ia, j)))) =\n    (snd \\<circ> snd)\n     (case (case m of\n            (nr, nc, a) \\<Rightarrow>\n              \\<lambda>i'.\n                 (nr, nc,\n                  let ai' = IArray.sub' (a, i')\n                  in IArray.tabulate\n                      (integer_of_nat nr,\n                       \\<lambda>i.\n                          let ai = IArray.sub' (a, i)\n                          in if i = i' then ai\n                             else let vi'j = v i\n                                  in if vi'j = z then ai\n                                     else IArray.tabulate\n     (integer_of_nat nc,\n      \\<lambda>j.\n         mm (IArray.sub' (ai, j)) (tt vi'j (IArray.sub' (ai', j)))))))\n            (integer_of_nat ia) of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j)\n 2. \\<not> (v (integer_of_nat i) = z \\<or> i = ia) \\<Longrightarrow>\n    (if v (integer_of_nat i) = z \\<or> i = ia\n     then (snd \\<circ> snd)\n           (case m of\n            (nr, nc, m) \\<Rightarrow>\n              (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n           (i, j)\n     else mm ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (i, j))\n           (tt (v (integer_of_nat i))\n             ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (ia, j)))) =\n    (snd \\<circ> snd)\n     (case (case m of\n            (nr, nc, a) \\<Rightarrow>\n              \\<lambda>i'.\n                 (nr, nc,\n                  let ai' = IArray.sub' (a, i')\n                  in IArray.tabulate\n                      (integer_of_nat nr,\n                       \\<lambda>i.\n                          let ai = IArray.sub' (a, i)\n                          in if i = i' then ai\n                             else let vi'j = v i\n                                  in if vi'j = z then ai\n                                     else IArray.tabulate\n     (integer_of_nat nc,\n      \\<lambda>j.\n         mm (IArray.sub' (ai, j)) (tt vi'j (IArray.sub' (ai', j)))))))\n            (integer_of_nat ia) of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j)", "hence id: \"(if ?c1 \\<or> i = ia then x else y) = x\" \n          \"(if integer_of_nat i = integer_of_nat ia then x else if ?c1 then x else y) = x\" for x y"], ["proof (prove)\nusing this:\n  v (integer_of_nat i) = z \\<or> i = ia\n\ngoal (1 subgoal):\n 1. (if v (integer_of_nat i) = z \\<or> i = ia then x else y) = x &&&\n    (if integer_of_nat i = integer_of_nat ia then x\n     else if v (integer_of_nat i) = z then x else y) =\n    x", "by auto"], ["proof (state)\nthis:\n  (if v (integer_of_nat i) = z \\<or> i = ia then ?x2 else ?y2) = ?x2\n  (if integer_of_nat i = integer_of_nat ia then ?x2\n   else if v (integer_of_nat i) = z then ?x2 else ?y2) =\n  ?x2\n\ngoal (2 subgoals):\n 1. v (integer_of_nat i) = z \\<or> i = ia \\<Longrightarrow>\n    (if v (integer_of_nat i) = z \\<or> i = ia\n     then (snd \\<circ> snd)\n           (case m of\n            (nr, nc, m) \\<Rightarrow>\n              (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n           (i, j)\n     else mm ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (i, j))\n           (tt (v (integer_of_nat i))\n             ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (ia, j)))) =\n    (snd \\<circ> snd)\n     (case (case m of\n            (nr, nc, a) \\<Rightarrow>\n              \\<lambda>i'.\n                 (nr, nc,\n                  let ai' = IArray.sub' (a, i')\n                  in IArray.tabulate\n                      (integer_of_nat nr,\n                       \\<lambda>i.\n                          let ai = IArray.sub' (a, i)\n                          in if i = i' then ai\n                             else let vi'j = v i\n                                  in if vi'j = z then ai\n                                     else IArray.tabulate\n     (integer_of_nat nc,\n      \\<lambda>j.\n         mm (IArray.sub' (ai, j)) (tt vi'j (IArray.sub' (ai', j)))))))\n            (integer_of_nat ia) of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j)\n 2. \\<not> (v (integer_of_nat i) = z \\<or> i = ia) \\<Longrightarrow>\n    (if v (integer_of_nat i) = z \\<or> i = ia\n     then (snd \\<circ> snd)\n           (case m of\n            (nr, nc, m) \\<Rightarrow>\n              (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n           (i, j)\n     else mm ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (i, j))\n           (tt (v (integer_of_nat i))\n             ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (ia, j)))) =\n    (snd \\<circ> snd)\n     (case (case m of\n            (nr, nc, a) \\<Rightarrow>\n              \\<lambda>i'.\n                 (nr, nc,\n                  let ai' = IArray.sub' (a, i')\n                  in IArray.tabulate\n                      (integer_of_nat nr,\n                       \\<lambda>i.\n                          let ai = IArray.sub' (a, i)\n                          in if i = i' then ai\n                             else let vi'j = v i\n                                  in if vi'j = z then ai\n                                     else IArray.tabulate\n     (integer_of_nat nc,\n      \\<lambda>j.\n         mm (IArray.sub' (ai, j)) (tt vi'j (IArray.sub' (ai', j)))))))\n            (integer_of_nat ia) of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if v (integer_of_nat i) = z \\<or> i = ia\n     then (snd \\<circ> snd)\n           (case m of\n            (nr, nc, m) \\<Rightarrow>\n              (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n           (i, j)\n     else mm ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (i, j))\n           (tt (v (integer_of_nat i))\n             ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (ia, j)))) =\n    (snd \\<circ> snd)\n     (case (case m of\n            (nr, nc, a) \\<Rightarrow>\n              \\<lambda>i'.\n                 (nr, nc,\n                  let ai' = IArray.sub' (a, i')\n                  in IArray.tabulate\n                      (integer_of_nat nr,\n                       \\<lambda>i.\n                          let ai = IArray.sub' (a, i)\n                          in if i = i' then ai\n                             else let vi'j = v i\n                                  in if vi'j = z then ai\n                                     else IArray.tabulate\n     (integer_of_nat nc,\n      \\<lambda>j.\n         mm (IArray.sub' (ai, j)) (tt vi'j (IArray.sub' (ai', j)))))))\n            (integer_of_nat ia) of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j)", "unfolding id m o_def Let_def split snd_conv mk of_fun"], ["proof (prove)\ngoal (1 subgoal):\n 1. M !! i !! j = IArray.sub' (M, integer_of_nat i) !! j", "by (auto simp: 1)"], ["proof (state)\nthis:\n  (if v (integer_of_nat i) = z \\<or> i = ia\n   then (snd \\<circ> snd)\n         (case m of\n          (nr, nc, m) \\<Rightarrow>\n            (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n         (i, j)\n   else mm ((snd \\<circ> snd)\n             (case m of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n             (i, j))\n         (tt (v (integer_of_nat i))\n           ((snd \\<circ> snd)\n             (case m of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n             (ia, j)))) =\n  (snd \\<circ> snd)\n   (case (case m of\n          (nr, nc, a) \\<Rightarrow>\n            \\<lambda>i'.\n               (nr, nc,\n                let ai' = IArray.sub' (a, i')\n                in IArray.tabulate\n                    (integer_of_nat nr,\n                     \\<lambda>i.\n                        let ai = IArray.sub' (a, i)\n                        in if i = i' then ai\n                           else let vi'j = v i\n                                in if vi'j = z then ai\n                                   else IArray.tabulate\n   (integer_of_nat nc,\n    \\<lambda>j.\n       mm (IArray.sub' (ai, j)) (tt vi'j (IArray.sub' (ai', j)))))))\n          (integer_of_nat ia) of\n    (nr, nc, m) \\<Rightarrow>\n      (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n   (i, j)\n\ngoal (1 subgoal):\n 1. \\<not> (v (integer_of_nat i) = z \\<or> i = ia) \\<Longrightarrow>\n    (if v (integer_of_nat i) = z \\<or> i = ia\n     then (snd \\<circ> snd)\n           (case m of\n            (nr, nc, m) \\<Rightarrow>\n              (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n           (i, j)\n     else mm ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (i, j))\n           (tt (v (integer_of_nat i))\n             ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (ia, j)))) =\n    (snd \\<circ> snd)\n     (case (case m of\n            (nr, nc, a) \\<Rightarrow>\n              \\<lambda>i'.\n                 (nr, nc,\n                  let ai' = IArray.sub' (a, i')\n                  in IArray.tabulate\n                      (integer_of_nat nr,\n                       \\<lambda>i.\n                          let ai = IArray.sub' (a, i)\n                          in if i = i' then ai\n                             else let vi'j = v i\n                                  in if vi'j = z then ai\n                                     else IArray.tabulate\n     (integer_of_nat nc,\n      \\<lambda>j.\n         mm (IArray.sub' (ai, j)) (tt vi'j (IArray.sub' (ai', j)))))))\n            (integer_of_nat ia) of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (v (integer_of_nat i) = z \\<or> i = ia) \\<Longrightarrow>\n    (if v (integer_of_nat i) = z \\<or> i = ia\n     then (snd \\<circ> snd)\n           (case m of\n            (nr, nc, m) \\<Rightarrow>\n              (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n           (i, j)\n     else mm ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (i, j))\n           (tt (v (integer_of_nat i))\n             ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (ia, j)))) =\n    (snd \\<circ> snd)\n     (case (case m of\n            (nr, nc, a) \\<Rightarrow>\n              \\<lambda>i'.\n                 (nr, nc,\n                  let ai' = IArray.sub' (a, i')\n                  in IArray.tabulate\n                      (integer_of_nat nr,\n                       \\<lambda>i.\n                          let ai = IArray.sub' (a, i)\n                          in if i = i' then ai\n                             else let vi'j = v i\n                                  in if vi'j = z then ai\n                                     else IArray.tabulate\n     (integer_of_nat nc,\n      \\<lambda>j.\n         mm (IArray.sub' (ai, j)) (tt vi'j (IArray.sub' (ai', j)))))))\n            (integer_of_nat ia) of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j)", "case False"], ["proof (state)\nthis:\n  \\<not> (v (integer_of_nat i) = z \\<or> i = ia)\n\ngoal (1 subgoal):\n 1. \\<not> (v (integer_of_nat i) = z \\<or> i = ia) \\<Longrightarrow>\n    (if v (integer_of_nat i) = z \\<or> i = ia\n     then (snd \\<circ> snd)\n           (case m of\n            (nr, nc, m) \\<Rightarrow>\n              (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n           (i, j)\n     else mm ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (i, j))\n           (tt (v (integer_of_nat i))\n             ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (ia, j)))) =\n    (snd \\<circ> snd)\n     (case (case m of\n            (nr, nc, a) \\<Rightarrow>\n              \\<lambda>i'.\n                 (nr, nc,\n                  let ai' = IArray.sub' (a, i')\n                  in IArray.tabulate\n                      (integer_of_nat nr,\n                       \\<lambda>i.\n                          let ai = IArray.sub' (a, i)\n                          in if i = i' then ai\n                             else let vi'j = v i\n                                  in if vi'j = z then ai\n                                     else IArray.tabulate\n     (integer_of_nat nc,\n      \\<lambda>j.\n         mm (IArray.sub' (ai, j)) (tt vi'j (IArray.sub' (ai', j)))))))\n            (integer_of_nat ia) of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j)", "hence id: \"?c1 = False \" \"(integer_of_nat i = integer_of_nat ia) = False\" \"(False \\<or> i = ia) = False\""], ["proof (prove)\nusing this:\n  \\<not> (v (integer_of_nat i) = z \\<or> i = ia)\n\ngoal (1 subgoal):\n 1. (v (integer_of_nat i) = z) = False &&&\n    (integer_of_nat i = integer_of_nat ia) = False &&&\n    (False \\<or> i = ia) = False", "by (auto simp add: integer_of_nat_eq_of_nat)"], ["proof (state)\nthis:\n  (v (integer_of_nat i) = z) = False\n  (integer_of_nat i = integer_of_nat ia) = False\n  (False \\<or> i = ia) = False\n\ngoal (1 subgoal):\n 1. \\<not> (v (integer_of_nat i) = z \\<or> i = ia) \\<Longrightarrow>\n    (if v (integer_of_nat i) = z \\<or> i = ia\n     then (snd \\<circ> snd)\n           (case m of\n            (nr, nc, m) \\<Rightarrow>\n              (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n           (i, j)\n     else mm ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (i, j))\n           (tt (v (integer_of_nat i))\n             ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (ia, j)))) =\n    (snd \\<circ> snd)\n     (case (case m of\n            (nr, nc, a) \\<Rightarrow>\n              \\<lambda>i'.\n                 (nr, nc,\n                  let ai' = IArray.sub' (a, i')\n                  in IArray.tabulate\n                      (integer_of_nat nr,\n                       \\<lambda>i.\n                          let ai = IArray.sub' (a, i)\n                          in if i = i' then ai\n                             else let vi'j = v i\n                                  in if vi'j = z then ai\n                                     else IArray.tabulate\n     (integer_of_nat nc,\n      \\<lambda>j.\n         mm (IArray.sub' (ai, j)) (tt vi'j (IArray.sub' (ai', j)))))))\n            (integer_of_nat ia) of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if v (integer_of_nat i) = z \\<or> i = ia\n     then (snd \\<circ> snd)\n           (case m of\n            (nr, nc, m) \\<Rightarrow>\n              (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n           (i, j)\n     else mm ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (i, j))\n           (tt (v (integer_of_nat i))\n             ((snd \\<circ> snd)\n               (case m of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (ia, j)))) =\n    (snd \\<circ> snd)\n     (case (case m of\n            (nr, nc, a) \\<Rightarrow>\n              \\<lambda>i'.\n                 (nr, nc,\n                  let ai' = IArray.sub' (a, i')\n                  in IArray.tabulate\n                      (integer_of_nat nr,\n                       \\<lambda>i.\n                          let ai = IArray.sub' (a, i)\n                          in if i = i' then ai\n                             else let vi'j = v i\n                                  in if vi'j = z then ai\n                                     else IArray.tabulate\n     (integer_of_nat nc,\n      \\<lambda>j.\n         mm (IArray.sub' (ai, j)) (tt vi'j (IArray.sub' (ai', j)))))))\n            (integer_of_nat ia) of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j)", "unfolding m o_def Let_def split snd_conv mk of_fun id if_False"], ["proof (prove)\ngoal (1 subgoal):\n 1. mm (M !! i !! j) (tt (v (integer_of_nat i)) (M !! ia !! j)) =\n    mm (IArray.sub' (IArray.sub' (M, integer_of_nat i), integer_of_nat j))\n     (tt (v (integer_of_nat i))\n       (IArray.sub' (IArray.sub' (M, integer_of_nat ia), integer_of_nat j)))", "by (auto simp: 1)"], ["proof (state)\nthis:\n  (if v (integer_of_nat i) = z \\<or> i = ia\n   then (snd \\<circ> snd)\n         (case m of\n          (nr, nc, m) \\<Rightarrow>\n            (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n         (i, j)\n   else mm ((snd \\<circ> snd)\n             (case m of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n             (i, j))\n         (tt (v (integer_of_nat i))\n           ((snd \\<circ> snd)\n             (case m of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n             (ia, j)))) =\n  (snd \\<circ> snd)\n   (case (case m of\n          (nr, nc, a) \\<Rightarrow>\n            \\<lambda>i'.\n               (nr, nc,\n                let ai' = IArray.sub' (a, i')\n                in IArray.tabulate\n                    (integer_of_nat nr,\n                     \\<lambda>i.\n                        let ai = IArray.sub' (a, i)\n                        in if i = i' then ai\n                           else let vi'j = v i\n                                in if vi'j = z then ai\n                                   else IArray.tabulate\n   (integer_of_nat nc,\n    \\<lambda>j.\n       mm (IArray.sub' (ai, j)) (tt vi'j (IArray.sub' (ai', j)))))))\n          (integer_of_nat ia) of\n    (nr, nc, m) \\<Rightarrow>\n      (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n   (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if v (integer_of_nat i) = z \\<or> i = ia\n   then (snd \\<circ> snd)\n         (case m of\n          (nr, nc, m) \\<Rightarrow>\n            (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n         (i, j)\n   else mm ((snd \\<circ> snd)\n             (case m of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n             (i, j))\n         (tt (v (integer_of_nat i))\n           ((snd \\<circ> snd)\n             (case m of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n             (ia, j)))) =\n  (snd \\<circ> snd)\n   (case (case m of\n          (nr, nc, a) \\<Rightarrow>\n            \\<lambda>i'.\n               (nr, nc,\n                let ai' = IArray.sub' (a, i')\n                in IArray.tabulate\n                    (integer_of_nat nr,\n                     \\<lambda>i.\n                        let ai = IArray.sub' (a, i)\n                        in if i = i' then ai\n                           else let vi'j = v i\n                                in if vi'j = z then ai\n                                   else IArray.tabulate\n   (integer_of_nat nc,\n    \\<lambda>j.\n       mm (IArray.sub' (ai, j)) (tt vi'j (IArray.sub' (ai', j)))))))\n          (integer_of_nat ia) of\n    (nr, nc, m) \\<Rightarrow>\n      (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n   (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eliminate_entries_gen_zero mm tt z v (mat_impl m) i j $$ (i, j) =\n  mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i)) $$ (i, j)\n\ngoal (2 subgoals):\n 1. dim_row (eliminate_entries_gen_zero mm tt z v (mat_impl m) i j) =\n    dim_row (mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i)))\n 2. dim_col (eliminate_entries_gen_zero mm tt z v (mat_impl m) i j) =\n    dim_col (mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i)))", "qed (auto simp:eliminate_entries_i2.rep_eq)"], ["proof (state)\nthis:\n  eliminate_entries_gen_zero mm tt z v (mat_impl m) i j =\n  (if i < dim_row_impl m\n   then mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i))\n   else Code.abort STR ''index out of range in eliminate_entries''\n         (\\<lambda>_.\n             eliminate_entries_gen_zero mm tt z v (mat_impl m) i j))\n\ngoal (1 subgoal):\n 1. \\<not> i < dim_row_impl m \\<Longrightarrow>\n    eliminate_entries_gen_zero mm tt z v (mat_impl m) i j =\n    (if i < dim_row_impl m\n     then mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i))\n     else Code.abort STR ''index out of range in eliminate_entries''\n           (\\<lambda>_.\n               eliminate_entries_gen_zero mm tt z v (mat_impl m) i j))", "qed auto"], ["", "end"]]}