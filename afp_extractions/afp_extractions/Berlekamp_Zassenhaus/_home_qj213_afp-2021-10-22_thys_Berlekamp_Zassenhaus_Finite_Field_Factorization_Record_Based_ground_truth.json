{"file_name": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus/Finite_Field_Factorization_Record_Based.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus", "problem_names": ["lemma (in poly_mod_prime_type) finite_field_factorization_modulo_ring:\n  assumes g: \"(g :: 'a mod_ring poly) = of_int_poly f\"\n  and sf: \"square_free_m f\"\n  and fact: \"finite_field_factorization g = (d,gs)\"\n  and c: \"c = to_int_mod_ring d\"\n  and fs: \"fs = map to_int_poly gs\"\n  shows \"unique_factorization_m f (c, mset fs)\"", "lemma length_power_polys_i[simp]: \"length (power_polys_i x y z n) = n\"", "lemma power_polys_i: assumes i: \"i < n\" and [transfer_rule]: \"poly_rel f f'\" \"poly_rel g g'\" \n  and h: \"poly_rel h h'\"\n  shows \"poly_rel (power_polys_i ff_ops g f h n ! i) (power_polys g' f' h' n ! i)\"", "lemma power_poly_f_mod_i: assumes m: \"(poly_rel ===> poly_rel) m (\\<lambda> x'. x' mod m')\"\n  shows \"poly_rel f f' \\<Longrightarrow> poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)\"", "lemma berlekamp_mat_i[transfer_rule]: \"(poly_rel ===> mat_rel R) \n  (berlekamp_mat_i p ff_ops) berlekamp_mat\"", "lemma berlekamp_resulting_mat_i[transfer_rule]: \"(poly_rel ===> mat_rel R) \n  (berlekamp_resulting_mat_i p ff_ops) berlekamp_resulting_mat\"", "lemma berlekamp_basis_i[transfer_rule]: \"(poly_rel ===> list_all2 poly_rel) \n  (berlekamp_basis_i p ff_ops) berlekamp_basis\"", "lemma berlekamp_factorization_main_i[transfer_rule]: \n  \"((=) ===> list_all2 poly_rel ===> list_all2 poly_rel ===> (=) ===> list_all2 poly_rel) \n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops) \n       (arith_ops_record.one ff_ops)) \n     berlekamp_factorization_main\"", "lemma berlekamp_monic_factorization_i[transfer_rule]: \n  \"((=) ===> poly_rel ===> list_all2 poly_rel) \n     (berlekamp_monic_factorization_i p ff_ops) berlekamp_monic_factorization\"", "lemma dist_degree_factorize_main_i: \n  \"poly_rel F f \\<Longrightarrow> poly_rel G g \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel) Res res \n   \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel) \n      (dist_degree_factorize_main_i p ff_ops \n         (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) (degree_i F) F G d Res)\n      (dist_degree_factorize_main f g d res)\"", "lemma distinct_degree_factorization_i[transfer_rule]: \"(poly_rel ===> list_all2 (rel_prod (=) poly_rel)) \n  (distinct_degree_factorization_i p ff_ops) distinct_degree_factorization\"", "lemma finite_field_factorization_i[transfer_rule]: \n  \"(poly_rel ===> rel_prod R (list_all2 poly_rel))\n     (finite_field_factorization_i p ff_ops) finite_field_factorization\"", "lemma finite_field_i_sound: \n  assumes f': \"f' = of_int_poly_i ff_ops (Mp f)\" \n  and berl_i: \"finite_field_factorization_i p ff_ops f' = (c',fs')\"\n  and sq: \"square_free_m f\" \n  and fs: \"fs = map (to_int_poly_i ff_ops) fs'\"\n  and c: \"c = arith_ops_record.to_int ff_ops c'\" \n  shows \"unique_factorization_m f (c, mset fs)\n    \\<and> c \\<in> {0 ..< p} \n    \\<and> (\\<forall> fi \\<in> set fs. set (coeffs fi) \\<subseteq> {0 ..< p})\"", "lemma(in prime_field_gen) finite_field_factorization_main: \n  assumes res: \"finite_field_factorization_main p ff_ops f = (c,fs)\"\n  and sq: \"square_free_m f\" \n  shows \"unique_factorization_m f (c, mset fs)\n    \\<and> c \\<in> {0 ..< p} \n    \\<and> (\\<forall> fi \\<in> set fs. set (coeffs fi) \\<subseteq> {0 ..< p})\"", "lemmas finite_field_factorization_main_integer = prime_field_gen.finite_field_factorization_main\n  [OF prime_field.prime_field_finite_field_ops_integer, unfolded prime_field_def mod_ring_locale_def,\n  unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]", "lemmas finite_field_factorization_main_uint32 = prime_field_gen.finite_field_factorization_main\n  [OF prime_field.prime_field_finite_field_ops32, unfolded prime_field_def mod_ring_locale_def,\n  unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]", "lemmas finite_field_factorization_main_uint64 = prime_field_gen.finite_field_factorization_main\n  [OF prime_field.prime_field_finite_field_ops64, unfolded prime_field_def mod_ring_locale_def,\n  unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]", "lemma finite_field_factorization_int:\n  assumes sq: \"poly_mod.square_free_m p f\" \n  and result: \"finite_field_factorization_int p f = (c,fs)\"\n  shows \"poly_mod.unique_factorization_m p f (c, mset fs)\n    \\<and> c \\<in> {0 ..< p} \n    \\<and> (\\<forall> fi \\<in> set fs. set (coeffs fi) \\<subseteq> {0 ..< p})\""], "translations": [["", "lemma (in poly_mod_prime_type) finite_field_factorization_modulo_ring:\n  assumes g: \"(g :: 'a mod_ring poly) = of_int_poly f\"\n  and sf: \"square_free_m f\"\n  and fact: \"finite_field_factorization g = (d,gs)\"\n  and c: \"c = to_int_mod_ring d\"\n  and fs: \"fs = map to_int_poly gs\"\n  shows \"unique_factorization_m f (c, mset fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs)", "have [transfer_rule]: \"MP_Rel f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel f g", "unfolding g MP_Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp f = to_int_poly (of_int_poly f)", "by (simp add: Mp_f_representative)"], ["proof (state)\nthis:\n  MP_Rel f g\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs)", "have sg: \"square_free g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free g", "by (transfer, rule sf)"], ["proof (state)\nthis:\n  square_free g\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs)", "have [transfer_rule]: \"M_Rel c d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_Rel c d", "unfolding M_Rel_def c"], ["proof (prove)\ngoal (1 subgoal):\n 1. M (to_int_mod_ring d) = to_int_mod_ring d", "by (rule M_to_int_mod_ring)"], ["proof (state)\nthis:\n  M_Rel c d\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs)", "have fs_gs[transfer_rule]: \"list_all2 MP_Rel fs gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 MP_Rel fs gs", "unfolding fs list_all2_map1 MP_Rel_def[abs_def] Mp_to_int_poly"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>x f'. to_int_poly x = to_int_poly f') gs gs", "by (simp add: list.rel_refl)"], ["proof (state)\nthis:\n  list_all2 MP_Rel fs gs\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs)", "have [transfer_rule]: \"rel_mset MP_Rel (mset fs) (mset gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_mset MP_Rel (mset fs) (mset gs)", "using fs_gs"], ["proof (prove)\nusing this:\n  list_all2 MP_Rel fs gs\n\ngoal (1 subgoal):\n 1. rel_mset MP_Rel (mset fs) (mset gs)", "using rel_mset_def"], ["proof (prove)\nusing this:\n  list_all2 MP_Rel fs gs\n  rel_mset ?R ?X ?Y =\n  (\\<exists>xs ys.\n      mset xs = ?X \\<and> mset ys = ?Y \\<and> list_all2 ?R xs ys)\n\ngoal (1 subgoal):\n 1. rel_mset MP_Rel (mset fs) (mset gs)", "by blast"], ["proof (state)\nthis:\n  rel_mset MP_Rel (mset fs) (mset gs)\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs)", "have [transfer_rule]: \"MF_Rel (c,mset fs) (d,mset gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MF_Rel (c, mset fs) (d, mset gs)", "unfolding MF_Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod M_Rel (rel_mset MP_Rel) (c, mset fs) (d, mset gs)", "by transfer_prover"], ["proof (state)\nthis:\n  MF_Rel (c, mset fs) (d, mset gs)\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs)", "from finite_field_factorization[OF sg fact]"], ["proof (chain)\npicking this:\n  unique_factorization Irr_Mon g (d, mset gs)", "have uf: \"unique_factorization Irr_Mon g (d,mset gs)\""], ["proof (prove)\nusing this:\n  unique_factorization Irr_Mon g (d, mset gs)\n\ngoal (1 subgoal):\n 1. unique_factorization Irr_Mon g (d, mset gs)", "by auto"], ["proof (state)\nthis:\n  unique_factorization Irr_Mon g (d, mset gs)\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs)", "from uf[untransferred]"], ["proof (chain)\npicking this:\n  unique_factorization_m f (c, mset fs)", "show \"unique_factorization_m f (c, mset fs)\""], ["proof (prove)\nusing this:\n  unique_factorization_m f (c, mset fs)\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs)", "."], ["proof (state)\nthis:\n  unique_factorization_m f (c, mset fs)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We now have to implement @{const finite_field_factorization}.\\<close>"], ["", "context\n  fixes p :: int\n  and ff_ops :: \"'i arith_ops_record\"  (* finite-fields *)\nbegin"], ["", "fun power_poly_f_mod_i :: \"('i list \\<Rightarrow> 'i list) \\<Rightarrow> 'i list \\<Rightarrow> nat \\<Rightarrow> 'i list\" where\n  \"power_poly_f_mod_i modulus a n = (if n = 0 then modulus (one_poly_i ff_ops)\n    else let (d,r) = Divides.divmod_nat n 2; \n       rec = power_poly_f_mod_i modulus (modulus (times_poly_i ff_ops a a)) d in \n    if r = 0 then rec else modulus (times_poly_i ff_ops rec a))\""], ["", "declare power_poly_f_mod_i.simps[simp del]"], ["", "fun power_polys_i :: \"'i list \\<Rightarrow> 'i list \\<Rightarrow> 'i list \\<Rightarrow> nat \\<Rightarrow> 'i list list\" where\n  \"power_polys_i mul_p u curr_p (Suc i) = curr_p # \n      power_polys_i mul_p u (mod_field_poly_i ff_ops (times_poly_i ff_ops curr_p mul_p) u) i\"\n| \"power_polys_i mul_p u curr_p 0 = []\""], ["", "lemma length_power_polys_i[simp]: \"length (power_polys_i x y z n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (local.power_polys_i x y z n) = n", "by (induct n arbitrary: x y z, auto)"], ["", "definition berlekamp_mat_i :: \"'i list \\<Rightarrow> 'i mat\" where\n  \"berlekamp_mat_i u = (let n = degree_i u; \n    ze = arith_ops_record.zero ff_ops; on = arith_ops_record.one ff_ops;\n    mul_p = power_poly_f_mod_i (\\<lambda> v. mod_field_poly_i ff_ops v u) \n      [ze, on] (nat p);\n    xks = power_polys_i mul_p u [on] n\n   in mat_of_rows_list n (map (\\<lambda> cs. cs @ replicate (n - length cs) ze) xks))\""], ["", "definition berlekamp_resulting_mat_i :: \"'i list \\<Rightarrow> 'i mat\" where\n\"berlekamp_resulting_mat_i u = (let Q = berlekamp_mat_i u;\n    n = dim_row Q;\n    QI = mat n n (\\<lambda> (i,j). if i = j then arith_ops_record.minus ff_ops (Q $$ (i,j)) (arith_ops_record.one ff_ops) else Q $$ (i,j))\n    in (gauss_jordan_single_i ff_ops (transpose_mat QI)))\""], ["", "definition berlekamp_basis_i :: \"'i list \\<Rightarrow> 'i list list\" where\n  \"berlekamp_basis_i u = (map (poly_of_list_i ff_ops o list_of_vec) \n    (find_base_vectors_i ff_ops (berlekamp_resulting_mat_i u)))\""], ["", "primrec berlekamp_factorization_main_i :: \"'i \\<Rightarrow> 'i \\<Rightarrow> nat \\<Rightarrow> 'i list list \\<Rightarrow> 'i list list \\<Rightarrow> nat \\<Rightarrow> 'i list list\" where\n  \"berlekamp_factorization_main_i ze on d divs (v # vs) n = (\n    if v = [on] then berlekamp_factorization_main_i ze on d divs vs n else\n    if length divs = n then divs else\n    let of_int = arith_ops_record.of_int ff_ops;\n        facts = filter (\\<lambda> w. w \\<noteq> [on]) \n          [ gcd_poly_i ff_ops u (minus_poly_i ff_ops v (if s = 0 then [] else [of_int (int s)])) . \n            u \\<leftarrow> divs, s \\<leftarrow> [0 ..< nat p]];\n      (lin,nonlin) = List.partition (\\<lambda> q. degree_i q = d) facts \n      in lin @ berlekamp_factorization_main_i ze on d nonlin vs (n - length lin))\"\n| \"berlekamp_factorization_main_i ze on d divs [] n = divs\""], ["", "definition berlekamp_monic_factorization_i :: \"nat \\<Rightarrow> 'i list \\<Rightarrow> 'i list list\" where\n  \"berlekamp_monic_factorization_i d f = (let\n     vs = berlekamp_basis_i f\n    in berlekamp_factorization_main_i (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d [f] vs (length vs))\""], ["", "partial_function (tailrec) dist_degree_factorize_main_i :: \n  \"'i \\<Rightarrow> 'i \\<Rightarrow> nat \\<Rightarrow> 'i list \\<Rightarrow> 'i list \\<Rightarrow> nat \\<Rightarrow> (nat \\<times> 'i list) list \n  \\<Rightarrow> (nat \\<times> 'i list) list\" where\n  [code]: \"dist_degree_factorize_main_i ze on dv v w d res = (if v = [on] then res else if d + d > dv \n    then (dv, v) # res else let\n      w = power_poly_f_mod_i (\\<lambda> f. mod_field_poly_i ff_ops f v) w (nat p);\n      d = Suc d;\n      gd = gcd_poly_i ff_ops (minus_poly_i ff_ops w [ze,on]) v\n      in if gd = [on] then dist_degree_factorize_main_i ze on dv v w d res else \n      let v' = div_field_poly_i ff_ops v gd\n      in dist_degree_factorize_main_i ze on (degree_i v') v' (mod_field_poly_i ff_ops w v') d ((d,gd) # res))\""], ["", "definition distinct_degree_factorization_i\n  :: \"'i list \\<Rightarrow> (nat \\<times> 'i list) list\" where\n  \"distinct_degree_factorization_i f = (let ze = arith_ops_record.zero ff_ops;\n     on = arith_ops_record.one ff_ops in if degree_i f = 1 then [(1,f)] else \n     dist_degree_factorize_main_i ze on (degree_i f) f [ze,on] 0 [])\""], ["", "definition finite_field_factorization_i :: \"'i list \\<Rightarrow> 'i \\<times> 'i list list\" where\n  \"finite_field_factorization_i f = (if degree_i f = 0 then (lead_coeff_i ff_ops f,[]) else let\n     a = lead_coeff_i ff_ops f;\n     u = smult_i ff_ops (arith_ops_record.inverse ff_ops a) f;\n     gs = (if use_distinct_degree_factorization then distinct_degree_factorization_i u else [(1,u)]);\n     (irr,hs) = List.partition (\\<lambda> (i,f). degree_i f = i) gs\n     in (a,map snd irr @ concat (map (\\<lambda> (i,g). berlekamp_monic_factorization_i i g) hs)))\""], ["", "end"], ["", "context prime_field_gen\nbegin"], ["", "lemma power_polys_i: assumes i: \"i < n\" and [transfer_rule]: \"poly_rel f f'\" \"poly_rel g g'\" \n  and h: \"poly_rel h h'\"\n  shows \"poly_rel (power_polys_i ff_ops g f h n ! i) (power_polys g' f' h' n ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (power_polys_i ff_ops g f h n ! i) (power_polys g' f' h' n ! i)", "using i h"], ["proof (prove)\nusing this:\n  i < n\n  poly_rel h h'\n\ngoal (1 subgoal):\n 1. poly_rel (power_polys_i ff_ops g f h n ! i) (power_polys g' f' h' n ! i)", "proof (induct n arbitrary: h h' i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h h' i.\n       \\<lbrakk>i < 0; poly_rel h h'\\<rbrakk>\n       \\<Longrightarrow> poly_rel (power_polys_i ff_ops g f h 0 ! i)\n                          (power_polys g' f' h' 0 ! i)\n 2. \\<And>n h h' i.\n       \\<lbrakk>\\<And>h h' i.\n                   \\<lbrakk>i < n; poly_rel h h'\\<rbrakk>\n                   \\<Longrightarrow> poly_rel\n(power_polys_i ff_ops g f h n ! i) (power_polys g' f' h' n ! i);\n        i < Suc n; poly_rel h h'\\<rbrakk>\n       \\<Longrightarrow> poly_rel (power_polys_i ff_ops g f h (Suc n) ! i)\n                          (power_polys g' f' h' (Suc n) ! i)", "case (Suc n h h' i)"], ["proof (state)\nthis:\n  \\<lbrakk>?i < n; poly_rel ?h ?h'\\<rbrakk>\n  \\<Longrightarrow> poly_rel (power_polys_i ff_ops g f ?h n ! ?i)\n                     (power_polys g' f' ?h' n ! ?i)\n  i < Suc n\n  poly_rel h h'\n\ngoal (2 subgoals):\n 1. \\<And>h h' i.\n       \\<lbrakk>i < 0; poly_rel h h'\\<rbrakk>\n       \\<Longrightarrow> poly_rel (power_polys_i ff_ops g f h 0 ! i)\n                          (power_polys g' f' h' 0 ! i)\n 2. \\<And>n h h' i.\n       \\<lbrakk>\\<And>h h' i.\n                   \\<lbrakk>i < n; poly_rel h h'\\<rbrakk>\n                   \\<Longrightarrow> poly_rel\n(power_polys_i ff_ops g f h n ! i) (power_polys g' f' h' n ! i);\n        i < Suc n; poly_rel h h'\\<rbrakk>\n       \\<Longrightarrow> poly_rel (power_polys_i ff_ops g f h (Suc n) ! i)\n                          (power_polys g' f' h' (Suc n) ! i)", "note * = this"], ["proof (state)\nthis:\n  \\<lbrakk>?i < n; poly_rel ?h ?h'\\<rbrakk>\n  \\<Longrightarrow> poly_rel (power_polys_i ff_ops g f ?h n ! ?i)\n                     (power_polys g' f' ?h' n ! ?i)\n  i < Suc n\n  poly_rel h h'\n\ngoal (2 subgoals):\n 1. \\<And>h h' i.\n       \\<lbrakk>i < 0; poly_rel h h'\\<rbrakk>\n       \\<Longrightarrow> poly_rel (power_polys_i ff_ops g f h 0 ! i)\n                          (power_polys g' f' h' 0 ! i)\n 2. \\<And>n h h' i.\n       \\<lbrakk>\\<And>h h' i.\n                   \\<lbrakk>i < n; poly_rel h h'\\<rbrakk>\n                   \\<Longrightarrow> poly_rel\n(power_polys_i ff_ops g f h n ! i) (power_polys g' f' h' n ! i);\n        i < Suc n; poly_rel h h'\\<rbrakk>\n       \\<Longrightarrow> poly_rel (power_polys_i ff_ops g f h (Suc n) ! i)\n                          (power_polys g' f' h' (Suc n) ! i)", "note [transfer_rule] = *(3)"], ["proof (state)\nthis:\n  poly_rel h h'\n\ngoal (2 subgoals):\n 1. \\<And>h h' i.\n       \\<lbrakk>i < 0; poly_rel h h'\\<rbrakk>\n       \\<Longrightarrow> poly_rel (power_polys_i ff_ops g f h 0 ! i)\n                          (power_polys g' f' h' 0 ! i)\n 2. \\<And>n h h' i.\n       \\<lbrakk>\\<And>h h' i.\n                   \\<lbrakk>i < n; poly_rel h h'\\<rbrakk>\n                   \\<Longrightarrow> poly_rel\n(power_polys_i ff_ops g f h n ! i) (power_polys g' f' h' n ! i);\n        i < Suc n; poly_rel h h'\\<rbrakk>\n       \\<Longrightarrow> poly_rel (power_polys_i ff_ops g f h (Suc n) ! i)\n                          (power_polys g' f' h' (Suc n) ! i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (power_polys_i ff_ops g f h (Suc n) ! i)\n     (power_polys g' f' h' (Suc n) ! i)", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    poly_rel (power_polys_i ff_ops g f h (Suc n) ! i)\n     (power_polys g' f' h' (Suc n) ! i)\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       poly_rel (power_polys_i ff_ops g f h (Suc n) ! i)\n        (power_polys g' f' h' (Suc n) ! i)", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    poly_rel (power_polys_i ff_ops g f h (Suc n) ! i)\n     (power_polys g' f' h' (Suc n) ! i)\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       poly_rel (power_polys_i ff_ops g f h (Suc n) ! i)\n        (power_polys g' f' h' (Suc n) ! i)", "with Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < n; poly_rel ?h ?h'\\<rbrakk>\n  \\<Longrightarrow> poly_rel (power_polys_i ff_ops g f ?h n ! ?i)\n                     (power_polys g' f' ?h' n ! ?i)\n  i < Suc n\n  poly_rel h h'\n  i = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < n; poly_rel ?h ?h'\\<rbrakk>\n  \\<Longrightarrow> poly_rel (power_polys_i ff_ops g f ?h n ! ?i)\n                     (power_polys g' f' ?h' n ! ?i)\n  i < Suc n\n  poly_rel h h'\n  i = 0\n\ngoal (1 subgoal):\n 1. poly_rel (power_polys_i ff_ops g f h (Suc n) ! i)\n     (power_polys g' f' h' (Suc n) ! i)", "by auto"], ["proof (state)\nthis:\n  poly_rel (power_polys_i ff_ops g f h (Suc n) ! i)\n   (power_polys g' f' h' (Suc n) ! i)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       poly_rel (power_polys_i ff_ops g f h (Suc n) ! i)\n        (power_polys g' f' h' (Suc n) ! i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       poly_rel (power_polys_i ff_ops g f h (Suc n) ! i)\n        (power_polys g' f' h' (Suc n) ! i)", "case (Suc j)"], ["proof (state)\nthis:\n  i = Suc j\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       poly_rel (power_polys_i ff_ops g f h (Suc n) ! i)\n        (power_polys g' f' h' (Suc n) ! i)", "with *(2-)"], ["proof (chain)\npicking this:\n  i < Suc n\n  poly_rel h h'\n  i = Suc j", "have \"j < n\""], ["proof (prove)\nusing this:\n  i < Suc n\n  poly_rel h h'\n  i = Suc j\n\ngoal (1 subgoal):\n 1. j < n", "by auto"], ["proof (state)\nthis:\n  j < n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       poly_rel (power_polys_i ff_ops g f h (Suc n) ! i)\n        (power_polys g' f' h' (Suc n) ! i)", "note IH = *(1)[OF this]"], ["proof (state)\nthis:\n  poly_rel ?h ?h' \\<Longrightarrow>\n  poly_rel (power_polys_i ff_ops g f ?h n ! j) (power_polys g' f' ?h' n ! j)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       poly_rel (power_polys_i ff_ops g f h (Suc n) ! i)\n        (power_polys g' f' h' (Suc n) ! i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (power_polys_i ff_ops g f h (Suc n) ! i)\n     (power_polys g' f' h' (Suc n) ! i)", "unfolding Suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (power_polys_i ff_ops g f h (Suc n) ! Suc j)\n     (power_polys g' f' h' (Suc n) ! Suc j)", "by (simp, rule IH, transfer_prover)"], ["proof (state)\nthis:\n  poly_rel (power_polys_i ff_ops g f h (Suc n) ! i)\n   (power_polys g' f' h' (Suc n) ! i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_rel (power_polys_i ff_ops g f h (Suc n) ! i)\n   (power_polys g' f' h' (Suc n) ! i)\n\ngoal (1 subgoal):\n 1. \\<And>h h' i.\n       \\<lbrakk>i < 0; poly_rel h h'\\<rbrakk>\n       \\<Longrightarrow> poly_rel (power_polys_i ff_ops g f h 0 ! i)\n                          (power_polys g' f' h' 0 ! i)", "qed simp"], ["", "lemma power_poly_f_mod_i: assumes m: \"(poly_rel ===> poly_rel) m (\\<lambda> x'. x' mod m')\"\n  shows \"poly_rel f f' \\<Longrightarrow> poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel f f' \\<Longrightarrow>\n    poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_rel f f' \\<Longrightarrow>\n    poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)", "from m"], ["proof (chain)\npicking this:\n  (poly_rel ===> poly_rel) m (\\<lambda>x'. x' mod m')", "have m: \"\\<And> x x'. poly_rel x x' \\<Longrightarrow> poly_rel (m x) (x' mod m')\""], ["proof (prove)\nusing this:\n  (poly_rel ===> poly_rel) m (\\<lambda>x'. x' mod m')\n\ngoal (1 subgoal):\n 1. \\<And>x x'. poly_rel x x' \\<Longrightarrow> poly_rel (m x) (x' mod m')", "unfolding rel_fun_def"], ["proof (prove)\nusing this:\n  \\<forall>x y. poly_rel x y \\<longrightarrow> poly_rel (m x) (y mod m')\n\ngoal (1 subgoal):\n 1. \\<And>x x'. poly_rel x x' \\<Longrightarrow> poly_rel (m x) (x' mod m')", "by auto"], ["proof (state)\nthis:\n  poly_rel ?x ?x' \\<Longrightarrow> poly_rel (m ?x) (?x' mod m')\n\ngoal (1 subgoal):\n 1. poly_rel f f' \\<Longrightarrow>\n    poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)", "show \"poly_rel f f' \\<Longrightarrow> poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel f f' \\<Longrightarrow>\n    poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)", "proof (induct n arbitrary: f f' rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x f f'.\n       \\<lbrakk>\\<And>y f f'.\n                   \\<lbrakk>y < x; poly_rel f f'\\<rbrakk>\n                   \\<Longrightarrow> poly_rel\n(power_poly_f_mod_i ff_ops m f y) (power_poly_f_mod m' f' y);\n        poly_rel f f'\\<rbrakk>\n       \\<Longrightarrow> poly_rel (power_poly_f_mod_i ff_ops m f x)\n                          (power_poly_f_mod m' f' x)", "case (less n f f')"], ["proof (state)\nthis:\n  \\<lbrakk>?y < n; poly_rel ?f ?f'\\<rbrakk>\n  \\<Longrightarrow> poly_rel (power_poly_f_mod_i ff_ops m ?f ?y)\n                     (power_poly_f_mod m' ?f' ?y)\n  poly_rel f f'\n\ngoal (1 subgoal):\n 1. \\<And>x f f'.\n       \\<lbrakk>\\<And>y f f'.\n                   \\<lbrakk>y < x; poly_rel f f'\\<rbrakk>\n                   \\<Longrightarrow> poly_rel\n(power_poly_f_mod_i ff_ops m f y) (power_poly_f_mod m' f' y);\n        poly_rel f f'\\<rbrakk>\n       \\<Longrightarrow> poly_rel (power_poly_f_mod_i ff_ops m f x)\n                          (power_poly_f_mod m' f' x)", "note f[transfer_rule] = less(2)"], ["proof (state)\nthis:\n  poly_rel f f'\n\ngoal (1 subgoal):\n 1. \\<And>x f f'.\n       \\<lbrakk>\\<And>y f f'.\n                   \\<lbrakk>y < x; poly_rel f f'\\<rbrakk>\n                   \\<Longrightarrow> poly_rel\n(power_poly_f_mod_i ff_ops m f y) (power_poly_f_mod m' f' y);\n        poly_rel f f'\\<rbrakk>\n       \\<Longrightarrow> poly_rel (power_poly_f_mod_i ff_ops m f x)\n                          (power_poly_f_mod m' f' x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)", "by (simp add: True power_poly_f_mod_i.simps power_poly_f_mod_binary, \n          rule m[OF poly_rel_one])"], ["proof (state)\nthis:\n  poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)", "hence n: \"(n = 0) = False\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (n = 0) = False", "by simp"], ["proof (state)\nthis:\n  (n = 0) = False\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)", "obtain q r where div: \"Divides.divmod_nat n 2 = (q,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        divmod_nat n 2 = (q, r) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  divmod_nat n 2 = (q, r)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)", "from this[unfolded divmod_nat_def] n"], ["proof (chain)\npicking this:\n  (n div 2, n mod 2) = (q, r)\n  (n = 0) = False", "have \"q < n\""], ["proof (prove)\nusing this:\n  (n div 2, n mod 2) = (q, r)\n  (n = 0) = False\n\ngoal (1 subgoal):\n 1. q < n", "by auto"], ["proof (state)\nthis:\n  q < n\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)", "note IH = less(1)[OF this]"], ["proof (state)\nthis:\n  poly_rel ?f ?f' \\<Longrightarrow>\n  poly_rel (power_poly_f_mod_i ff_ops m ?f q) (power_poly_f_mod m' ?f' q)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)", "have rec: \"poly_rel (power_poly_f_mod_i ff_ops m (m (times_poly_i ff_ops f f)) q) \n        (power_poly_f_mod m' (f' * f' mod m') q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (power_poly_f_mod_i ff_ops m (m (times_poly_i ff_ops f f)) q)\n     (power_poly_f_mod m' (f' * f' mod m') q)", "by (rule IH, rule m, transfer_prover)"], ["proof (state)\nthis:\n  poly_rel (power_poly_f_mod_i ff_ops m (m (times_poly_i ff_ops f f)) q)\n   (power_poly_f_mod m' (f' * f' mod m') q)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)", "have other: \"poly_rel \n        (m (times_poly_i ff_ops (power_poly_f_mod_i ff_ops m (m (times_poly_i ff_ops f f)) q) f))\n        (power_poly_f_mod m' (f' * f' mod m') q * f' mod m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel\n     (m (times_poly_i ff_ops\n          (power_poly_f_mod_i ff_ops m (m (times_poly_i ff_ops f f)) q) f))\n     (power_poly_f_mod m' (f' * f' mod m') q * f' mod m')", "by (rule m, rule poly_rel_times[unfolded rel_fun_def, rule_format, OF rec f])"], ["proof (state)\nthis:\n  poly_rel\n   (m (times_poly_i ff_ops\n        (power_poly_f_mod_i ff_ops m (m (times_poly_i ff_ops f f)) q) f))\n   (power_poly_f_mod m' (f' * f' mod m') q * f' mod m')\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)", "unfolding power_poly_f_mod_i.simps[of _ _ _ n] Let_def \n        power_poly_f_mod_binary[of _ _ n] div split n if_False"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel\n     (if r = 0\n      then power_poly_f_mod_i ff_ops m (m (times_poly_i ff_ops f f)) q\n      else m (times_poly_i ff_ops\n               (power_poly_f_mod_i ff_ops m (m (times_poly_i ff_ops f f)) q)\n               f))\n     (if r = 0 then power_poly_f_mod m' (f' * f' mod m') q\n      else power_poly_f_mod m' (f' * f' mod m') q * f' mod m')", "using rec other"], ["proof (prove)\nusing this:\n  poly_rel (power_poly_f_mod_i ff_ops m (m (times_poly_i ff_ops f f)) q)\n   (power_poly_f_mod m' (f' * f' mod m') q)\n  poly_rel\n   (m (times_poly_i ff_ops\n        (power_poly_f_mod_i ff_ops m (m (times_poly_i ff_ops f f)) q) f))\n   (power_poly_f_mod m' (f' * f' mod m') q * f' mod m')\n\ngoal (1 subgoal):\n 1. poly_rel\n     (if r = 0\n      then power_poly_f_mod_i ff_ops m (m (times_poly_i ff_ops f f)) q\n      else m (times_poly_i ff_ops\n               (power_poly_f_mod_i ff_ops m (m (times_poly_i ff_ops f f)) q)\n               f))\n     (if r = 0 then power_poly_f_mod m' (f' * f' mod m') q\n      else power_poly_f_mod m' (f' * f' mod m') q * f' mod m')", "by auto"], ["proof (state)\nthis:\n  poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_rel f f' \\<Longrightarrow>\n  poly_rel (power_poly_f_mod_i ff_ops m f n) (power_poly_f_mod m' f' n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma berlekamp_mat_i[transfer_rule]: \"(poly_rel ===> mat_rel R) \n  (berlekamp_mat_i p ff_ops) berlekamp_mat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> mat_rel R) (berlekamp_mat_i p ff_ops) berlekamp_mat", "proof (intro rel_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       mat_rel R (berlekamp_mat_i p ff_ops x) (berlekamp_mat y)", "fix f f'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       mat_rel R (berlekamp_mat_i p ff_ops x) (berlekamp_mat y)", "let ?ze = \"arith_ops_record.zero ff_ops\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       mat_rel R (berlekamp_mat_i p ff_ops x) (berlekamp_mat y)", "let ?on = \"arith_ops_record.one ff_ops\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       mat_rel R (berlekamp_mat_i p ff_ops x) (berlekamp_mat y)", "assume f[transfer_rule]: \"poly_rel f f'\""], ["proof (state)\nthis:\n  poly_rel f f'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       mat_rel R (berlekamp_mat_i p ff_ops x) (berlekamp_mat y)", "have deg: \"degree_i f = degree f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_i f = degree f'", "by transfer_prover"], ["proof (state)\nthis:\n  degree_i f = degree f'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       mat_rel R (berlekamp_mat_i p ff_ops x) (berlekamp_mat y)", "{"], ["proof (state)\nthis:\n  degree_i f = degree f'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       mat_rel R (berlekamp_mat_i p ff_ops x) (berlekamp_mat y)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       mat_rel R (berlekamp_mat_i p ff_ops x) (berlekamp_mat y)", "assume i: \"i < degree f'\" and j: \"j < degree f'\""], ["proof (state)\nthis:\n  i < degree f'\n  j < degree f'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       mat_rel R (berlekamp_mat_i p ff_ops x) (berlekamp_mat y)", "define cs where \"cs = (\\<lambda>cs :: 'i list. cs @ replicate (degree f' - length cs) ?ze)\""], ["proof (state)\nthis:\n  cs =\n  (\\<lambda>cs.\n      cs @ replicate (degree f' - length cs) (arith_ops_record.zero ff_ops))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       mat_rel R (berlekamp_mat_i p ff_ops x) (berlekamp_mat y)", "define cs' where \"cs' = (\\<lambda>cs :: 'a mod_ring poly. coeffs cs @ replicate (degree f' - length (coeffs cs)) 0)\""], ["proof (state)\nthis:\n  cs' =\n  (\\<lambda>cs. coeffs cs @ replicate (degree f' - length (coeffs cs)) 0)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       mat_rel R (berlekamp_mat_i p ff_ops x) (berlekamp_mat y)", "define poly where \"poly = power_polys_i ff_ops\n         (power_poly_f_mod_i ff_ops (\\<lambda>v. mod_field_poly_i ff_ops v f) [?ze, ?on] (nat p)) f [?on]\n         (degree f')\""], ["proof (state)\nthis:\n  poly =\n  power_polys_i ff_ops\n   (power_poly_f_mod_i ff_ops (\\<lambda>v. mod_field_poly_i ff_ops v f)\n     [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops] (nat p))\n   f [arith_ops_record.one ff_ops] (degree f')\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       mat_rel R (berlekamp_mat_i p ff_ops x) (berlekamp_mat y)", "define poly' where \"poly' = (power_polys (power_poly_f_mod f' [:0, 1:] (nat p)) f' 1 (degree f'))\""], ["proof (state)\nthis:\n  poly' =\n  power_polys (power_poly_f_mod f' [:0, 1:] (nat p)) f' 1 (degree f')\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       mat_rel R (berlekamp_mat_i p ff_ops x) (berlekamp_mat y)", "have *: \"poly_rel (power_poly_f_mod_i ff_ops (\\<lambda>v. mod_field_poly_i ff_ops v f) [?ze, ?on] (nat p))\n      (power_poly_f_mod f' [:0, 1:] (nat p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel\n     (power_poly_f_mod_i ff_ops (\\<lambda>v. mod_field_poly_i ff_ops v f)\n       [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops] (nat p))\n     (power_poly_f_mod f' [:0, 1:] (nat p))", "by (rule power_poly_f_mod_i, transfer_prover, simp add: poly_rel_def one zero)"], ["proof (state)\nthis:\n  poly_rel\n   (power_poly_f_mod_i ff_ops (\\<lambda>v. mod_field_poly_i ff_ops v f)\n     [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops] (nat p))\n   (power_poly_f_mod f' [:0, 1:] (nat p))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       mat_rel R (berlekamp_mat_i p ff_ops x) (berlekamp_mat y)", "have [transfer_rule]: \"poly_rel (poly ! i) (poly' ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (poly ! i) (poly' ! i)", "unfolding poly_def poly'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel\n     (power_polys_i ff_ops\n       (power_poly_f_mod_i ff_ops (\\<lambda>v. mod_field_poly_i ff_ops v f)\n         [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops]\n         (nat p))\n       f [arith_ops_record.one ff_ops] (degree f') !\n      i)\n     (power_polys (power_poly_f_mod f' [:0, 1:] (nat p)) f' 1 (degree f') !\n      i)", "by (rule power_polys_i[OF i f *], simp add: poly_rel_def one)"], ["proof (state)\nthis:\n  poly_rel (poly ! i) (poly' ! i)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       mat_rel R (berlekamp_mat_i p ff_ops x) (berlekamp_mat y)", "have *: \"list_all2 R (cs (poly ! i)) (cs' (poly' ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R (cs (poly ! i)) (cs' (poly' ! i))", "unfolding cs_def cs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R\n     (poly ! i @\n      replicate (degree f' - length (poly ! i))\n       (arith_ops_record.zero ff_ops))\n     (coeffs (poly' ! i) @\n      replicate (degree f' - length (coeffs (poly' ! i))) 0)", "by transfer_prover"], ["proof (state)\nthis:\n  list_all2 R (cs (poly ! i)) (cs' (poly' ! i))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       mat_rel R (berlekamp_mat_i p ff_ops x) (berlekamp_mat y)", "from list_all2_nthD[OF *[unfolded poly_rel_def], of j] j"], ["proof (chain)\npicking this:\n  j < length (cs (poly ! i)) \\<Longrightarrow>\n  R (cs (poly ! i) ! j) (cs' (poly' ! i) ! j)\n  j < degree f'", "have \"R (cs (poly ! i) ! j) (cs' (poly' ! i) ! j)\""], ["proof (prove)\nusing this:\n  j < length (cs (poly ! i)) \\<Longrightarrow>\n  R (cs (poly ! i) ! j) (cs' (poly' ! i) ! j)\n  j < degree f'\n\ngoal (1 subgoal):\n 1. R (cs (poly ! i) ! j) (cs' (poly' ! i) ! j)", "unfolding cs_def"], ["proof (prove)\nusing this:\n  j < length\n       (poly ! i @\n        replicate (degree f' - length (poly ! i))\n         (arith_ops_record.zero ff_ops)) \\<Longrightarrow>\n  R ((poly ! i @\n      replicate (degree f' - length (poly ! i))\n       (arith_ops_record.zero ff_ops)) !\n     j)\n   (cs' (poly' ! i) ! j)\n  j < degree f'\n\ngoal (1 subgoal):\n 1. R ((poly ! i @\n        replicate (degree f' - length (poly ! i))\n         (arith_ops_record.zero ff_ops)) !\n       j)\n     (cs' (poly' ! i) ! j)", "by auto"], ["proof (state)\nthis:\n  R (cs (poly ! i) ! j) (cs' (poly' ! i) ! j)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       mat_rel R (berlekamp_mat_i p ff_ops x) (berlekamp_mat y)", "hence \"R\n            (mat_of_rows_list (degree f')\n              (map (\\<lambda>cs. cs @ replicate (degree f' - length cs) ?ze)\n                (power_polys_i ff_ops\n                  (power_poly_f_mod_i ff_ops (\\<lambda>v. mod_field_poly_i ff_ops v f) [?ze, ?on] (nat p)) f [?on]\n                  (degree f'))) $$\n             (i, j))\n            (mat_of_rows_list (degree f')\n              (map (\\<lambda>cs. coeffs cs @ replicate (degree f' - length (coeffs cs)) 0)\n                (power_polys (power_poly_f_mod f' [:0, 1:] (nat p)) f' 1 (degree f'))) $$\n             (i, j))\""], ["proof (prove)\nusing this:\n  R (cs (poly ! i) ! j) (cs' (poly' ! i) ! j)\n\ngoal (1 subgoal):\n 1. R (mat_of_rows_list (degree f')\n        (map (\\<lambda>cs.\n                 cs @\n                 replicate (degree f' - length cs)\n                  (arith_ops_record.zero ff_ops))\n          (power_polys_i ff_ops\n            (power_poly_f_mod_i ff_ops\n              (\\<lambda>v. mod_field_poly_i ff_ops v f)\n              [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops]\n              (nat p))\n            f [arith_ops_record.one ff_ops] (degree f'))) $$\n       (i, j))\n     (mat_of_rows_list (degree f')\n       (map (\\<lambda>cs.\n                coeffs cs @ replicate (degree f' - length (coeffs cs)) 0)\n         (power_polys (power_poly_f_mod f' [:0, 1:] (nat p)) f' 1\n           (degree f'))) $$\n      (i, j))", "unfolding mat_of_rows_list_def length_map length_power_polys_i power_polys_works\n          length_power_polys index_mat[OF i j] split"], ["proof (prove)\nusing this:\n  R (cs (poly ! i) ! j) (cs' (poly' ! i) ! j)\n\ngoal (1 subgoal):\n 1. R (map (\\<lambda>cs.\n               cs @\n               replicate (degree f' - length cs)\n                (arith_ops_record.zero ff_ops))\n        (power_polys_i ff_ops\n          (power_poly_f_mod_i ff_ops\n            (\\<lambda>v. mod_field_poly_i ff_ops v f)\n            [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops]\n            (nat p))\n          f [arith_ops_record.one ff_ops] (degree f')) !\n       i !\n       j)\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree f' - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod f' [:0, 1:] (nat p)) f' 1\n         (degree f')) !\n      i !\n      j)", "unfolding poly_def cs_def poly'_def cs'_def"], ["proof (prove)\nusing this:\n  R ((power_polys_i ff_ops\n       (power_poly_f_mod_i ff_ops (\\<lambda>v. mod_field_poly_i ff_ops v f)\n         [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops]\n         (nat p))\n       f [arith_ops_record.one ff_ops] (degree f') !\n      i @\n      replicate\n       (degree f' -\n        length\n         (power_polys_i ff_ops\n           (power_poly_f_mod_i ff_ops\n             (\\<lambda>v. mod_field_poly_i ff_ops v f)\n             [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops]\n             (nat p))\n           f [arith_ops_record.one ff_ops] (degree f') !\n          i))\n       (arith_ops_record.zero ff_ops)) !\n     j)\n   ((coeffs\n      (power_polys (power_poly_f_mod f' [:0, 1:] (nat p)) f' 1 (degree f') !\n       i) @\n     replicate\n      (degree f' -\n       length\n        (coeffs\n          (power_polys (power_poly_f_mod f' [:0, 1:] (nat p)) f' 1\n            (degree f') !\n           i)))\n      0) !\n    j)\n\ngoal (1 subgoal):\n 1. R (map (\\<lambda>cs.\n               cs @\n               replicate (degree f' - length cs)\n                (arith_ops_record.zero ff_ops))\n        (power_polys_i ff_ops\n          (power_poly_f_mod_i ff_ops\n            (\\<lambda>v. mod_field_poly_i ff_ops v f)\n            [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops]\n            (nat p))\n          f [arith_ops_record.one ff_ops] (degree f')) !\n       i !\n       j)\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree f' - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod f' [:0, 1:] (nat p)) f' 1\n         (degree f')) !\n      i !\n      j)", "using i"], ["proof (prove)\nusing this:\n  R ((power_polys_i ff_ops\n       (power_poly_f_mod_i ff_ops (\\<lambda>v. mod_field_poly_i ff_ops v f)\n         [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops]\n         (nat p))\n       f [arith_ops_record.one ff_ops] (degree f') !\n      i @\n      replicate\n       (degree f' -\n        length\n         (power_polys_i ff_ops\n           (power_poly_f_mod_i ff_ops\n             (\\<lambda>v. mod_field_poly_i ff_ops v f)\n             [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops]\n             (nat p))\n           f [arith_ops_record.one ff_ops] (degree f') !\n          i))\n       (arith_ops_record.zero ff_ops)) !\n     j)\n   ((coeffs\n      (power_polys (power_poly_f_mod f' [:0, 1:] (nat p)) f' 1 (degree f') !\n       i) @\n     replicate\n      (degree f' -\n       length\n        (coeffs\n          (power_polys (power_poly_f_mod f' [:0, 1:] (nat p)) f' 1\n            (degree f') !\n           i)))\n      0) !\n    j)\n  i < degree f'\n\ngoal (1 subgoal):\n 1. R (map (\\<lambda>cs.\n               cs @\n               replicate (degree f' - length cs)\n                (arith_ops_record.zero ff_ops))\n        (power_polys_i ff_ops\n          (power_poly_f_mod_i ff_ops\n            (\\<lambda>v. mod_field_poly_i ff_ops v f)\n            [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops]\n            (nat p))\n          f [arith_ops_record.one ff_ops] (degree f')) !\n       i !\n       j)\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree f' - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod f' [:0, 1:] (nat p)) f' 1\n         (degree f')) !\n      i !\n      j)", "by auto"], ["proof (state)\nthis:\n  R (mat_of_rows_list (degree f')\n      (map (\\<lambda>cs.\n               cs @\n               replicate (degree f' - length cs)\n                (arith_ops_record.zero ff_ops))\n        (power_polys_i ff_ops\n          (power_poly_f_mod_i ff_ops\n            (\\<lambda>v. mod_field_poly_i ff_ops v f)\n            [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops]\n            (nat p))\n          f [arith_ops_record.one ff_ops] (degree f'))) $$\n     (i, j))\n   (mat_of_rows_list (degree f')\n     (map (\\<lambda>cs.\n              coeffs cs @ replicate (degree f' - length (coeffs cs)) 0)\n       (power_polys (power_poly_f_mod f' [:0, 1:] (nat p)) f' 1\n         (degree f'))) $$\n    (i, j))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       mat_rel R (berlekamp_mat_i p ff_ops x) (berlekamp_mat y)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < degree f'; ?j2 < degree f'\\<rbrakk>\n  \\<Longrightarrow> R (mat_of_rows_list (degree f')\n                        (map (\\<lambda>cs.\n                                 cs @\n                                 replicate (degree f' - length cs)\n                                  (arith_ops_record.zero ff_ops))\n                          (power_polys_i ff_ops\n                            (power_poly_f_mod_i ff_ops\n                              (\\<lambda>v. mod_field_poly_i ff_ops v f)\n                              [arith_ops_record.zero ff_ops,\n                               arith_ops_record.one ff_ops]\n                              (nat p))\n                            f [arith_ops_record.one ff_ops] (degree f'))) $$\n                       (?i2, ?j2))\n                     (mat_of_rows_list (degree f')\n                       (map (\\<lambda>cs.\n                                coeffs cs @\n                                replicate (degree f' - length (coeffs cs))\n                                 0)\n                         (power_polys (power_poly_f_mod f' [:0, 1:] (nat p))\n                           f' 1 (degree f'))) $$\n                      (?i2, ?j2))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       mat_rel R (berlekamp_mat_i p ff_ops x) (berlekamp_mat y)", "note main = this"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < degree f'; ?j2 < degree f'\\<rbrakk>\n  \\<Longrightarrow> R (mat_of_rows_list (degree f')\n                        (map (\\<lambda>cs.\n                                 cs @\n                                 replicate (degree f' - length cs)\n                                  (arith_ops_record.zero ff_ops))\n                          (power_polys_i ff_ops\n                            (power_poly_f_mod_i ff_ops\n                              (\\<lambda>v. mod_field_poly_i ff_ops v f)\n                              [arith_ops_record.zero ff_ops,\n                               arith_ops_record.one ff_ops]\n                              (nat p))\n                            f [arith_ops_record.one ff_ops] (degree f'))) $$\n                       (?i2, ?j2))\n                     (mat_of_rows_list (degree f')\n                       (map (\\<lambda>cs.\n                                coeffs cs @\n                                replicate (degree f' - length (coeffs cs))\n                                 0)\n                         (power_polys (power_poly_f_mod f' [:0, 1:] (nat p))\n                           f' 1 (degree f'))) $$\n                      (?i2, ?j2))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       mat_rel R (berlekamp_mat_i p ff_ops x) (berlekamp_mat y)", "show \"mat_rel R (berlekamp_mat_i p ff_ops f) (berlekamp_mat f')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R (berlekamp_mat_i p ff_ops f) (berlekamp_mat f')", "unfolding berlekamp_mat_i_def berlekamp_mat_def Let_def nat_p[symmetric] deg"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R\n     (mat_of_rows_list (degree f')\n       (map (\\<lambda>cs.\n                cs @\n                replicate (degree f' - length cs)\n                 (arith_ops_record.zero ff_ops))\n         (power_polys_i ff_ops\n           (power_poly_f_mod_i ff_ops\n             (\\<lambda>v. mod_field_poly_i ff_ops v f)\n             [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops]\n             (nat p))\n           f [arith_ops_record.one ff_ops] (degree f'))))\n     (mat_of_rows_list (degree f')\n       (map (\\<lambda>cs.\n                coeffs cs @ replicate (degree f' - length (coeffs cs)) 0)\n         (power_polys (power_poly_f_mod f' [:0, 1:] (nat p)) f' 1\n           (degree f'))))", "unfolding mat_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row\n     (mat_of_rows_list (degree f')\n       (map (\\<lambda>cs.\n                cs @\n                replicate (degree f' - length cs)\n                 (arith_ops_record.zero ff_ops))\n         (power_polys_i ff_ops\n           (power_poly_f_mod_i ff_ops\n             (\\<lambda>v. mod_field_poly_i ff_ops v f)\n             [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops]\n             (nat p))\n           f [arith_ops_record.one ff_ops] (degree f')))) =\n    dim_row\n     (mat_of_rows_list (degree f')\n       (map (\\<lambda>cs.\n                coeffs cs @ replicate (degree f' - length (coeffs cs)) 0)\n         (power_polys (power_poly_f_mod f' [:0, 1:] (nat p)) f' 1\n           (degree f')))) \\<and>\n    dim_col\n     (mat_of_rows_list (degree f')\n       (map (\\<lambda>cs.\n                cs @\n                replicate (degree f' - length cs)\n                 (arith_ops_record.zero ff_ops))\n         (power_polys_i ff_ops\n           (power_poly_f_mod_i ff_ops\n             (\\<lambda>v. mod_field_poly_i ff_ops v f)\n             [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops]\n             (nat p))\n           f [arith_ops_record.one ff_ops] (degree f')))) =\n    dim_col\n     (mat_of_rows_list (degree f')\n       (map (\\<lambda>cs.\n                coeffs cs @ replicate (degree f' - length (coeffs cs)) 0)\n         (power_polys (power_poly_f_mod f' [:0, 1:] (nat p)) f' 1\n           (degree f')))) \\<and>\n    (\\<forall>i j.\n        i < dim_row\n             (mat_of_rows_list (degree f')\n               (map (\\<lambda>cs.\n                        coeffs cs @\n                        replicate (degree f' - length (coeffs cs)) 0)\n                 (power_polys (power_poly_f_mod f' [:0, 1:] (nat p)) f' 1\n                   (degree f')))) \\<longrightarrow>\n        j < dim_col\n             (mat_of_rows_list (degree f')\n               (map (\\<lambda>cs.\n                        coeffs cs @\n                        replicate (degree f' - length (coeffs cs)) 0)\n                 (power_polys (power_poly_f_mod f' [:0, 1:] (nat p)) f' 1\n                   (degree f')))) \\<longrightarrow>\n        R (mat_of_rows_list (degree f')\n            (map (\\<lambda>cs.\n                     cs @\n                     replicate (degree f' - length cs)\n                      (arith_ops_record.zero ff_ops))\n              (power_polys_i ff_ops\n                (power_poly_f_mod_i ff_ops\n                  (\\<lambda>v. mod_field_poly_i ff_ops v f)\n                  [arith_ops_record.zero ff_ops,\n                   arith_ops_record.one ff_ops]\n                  (nat p))\n                f [arith_ops_record.one ff_ops] (degree f'))) $$\n           (i, j))\n         (mat_of_rows_list (degree f')\n           (map (\\<lambda>cs.\n                    coeffs cs @\n                    replicate (degree f' - length (coeffs cs)) 0)\n             (power_polys (power_poly_f_mod f' [:0, 1:] (nat p)) f' 1\n               (degree f'))) $$\n          (i, j)))", "by (intro conjI allI impI, insert main, auto)"], ["proof (state)\nthis:\n  mat_rel R (berlekamp_mat_i p ff_ops f) (berlekamp_mat f')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma berlekamp_resulting_mat_i[transfer_rule]: \"(poly_rel ===> mat_rel R) \n  (berlekamp_resulting_mat_i p ff_ops) berlekamp_resulting_mat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> mat_rel R) (berlekamp_resulting_mat_i p ff_ops)\n     berlekamp_resulting_mat", "proof (intro rel_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       mat_rel R (berlekamp_resulting_mat_i p ff_ops x)\n        (berlekamp_resulting_mat y)", "fix f f'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       mat_rel R (berlekamp_resulting_mat_i p ff_ops x)\n        (berlekamp_resulting_mat y)", "assume \"poly_rel f f'\""], ["proof (state)\nthis:\n  poly_rel f f'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       mat_rel R (berlekamp_resulting_mat_i p ff_ops x)\n        (berlekamp_resulting_mat y)", "from berlekamp_mat_i[unfolded rel_fun_def, rule_format, OF this]"], ["proof (chain)\npicking this:\n  mat_rel R (berlekamp_mat_i p ff_ops f) (berlekamp_mat f')", "have bmi: \"mat_rel R (berlekamp_mat_i p ff_ops f) (berlekamp_mat f')\""], ["proof (prove)\nusing this:\n  mat_rel R (berlekamp_mat_i p ff_ops f) (berlekamp_mat f')\n\ngoal (1 subgoal):\n 1. mat_rel R (berlekamp_mat_i p ff_ops f) (berlekamp_mat f')", "."], ["proof (state)\nthis:\n  mat_rel R (berlekamp_mat_i p ff_ops f) (berlekamp_mat f')\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       mat_rel R (berlekamp_resulting_mat_i p ff_ops x)\n        (berlekamp_resulting_mat y)", "show \"mat_rel R (berlekamp_resulting_mat_i p ff_ops f) (berlekamp_resulting_mat f')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R (berlekamp_resulting_mat_i p ff_ops f)\n     (berlekamp_resulting_mat f')", "unfolding berlekamp_resulting_mat_def Let_def berlekamp_resulting_mat_i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_rel R\n     (gauss_jordan_single_i ff_ops\n       (mat (dim_row (berlekamp_mat_i p ff_ops f))\n         (dim_row (berlekamp_mat_i p ff_ops f))\n         (\\<lambda>(i, j).\n             if i = j\n             then arith_ops_record.minus ff_ops\n                   (berlekamp_mat_i p ff_ops f $$ (i, j))\n                   (arith_ops_record.one ff_ops)\n             else berlekamp_mat_i p ff_ops f $$ (i, j)))\\<^sup>T)\n     (gauss_jordan_single\n       (mat (dim_row (berlekamp_mat f')) (dim_row (berlekamp_mat f'))\n         (\\<lambda>(i, j).\n             if i = j then berlekamp_mat f' $$ (i, j) - 1\n             else berlekamp_mat f' $$ (i, j)))\\<^sup>T)", "by (rule gauss_jordan_i[unfolded rel_fun_def, rule_format],\n    insert bmi, auto simp: mat_rel_def one intro!: minus[unfolded rel_fun_def, rule_format])"], ["proof (state)\nthis:\n  mat_rel R (berlekamp_resulting_mat_i p ff_ops f)\n   (berlekamp_resulting_mat f')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma berlekamp_basis_i[transfer_rule]: \"(poly_rel ===> list_all2 poly_rel) \n  (berlekamp_basis_i p ff_ops) berlekamp_basis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> list_all2 poly_rel) (berlekamp_basis_i p ff_ops)\n     berlekamp_basis", "unfolding berlekamp_basis_i_def[abs_def] berlekamp_basis_code[abs_def] o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> list_all2 poly_rel)\n     (\\<lambda>u.\n         map (\\<lambda>x. poly_of_list_i ff_ops (list_of_vec x))\n          (find_base_vectors_i ff_ops\n            (berlekamp_resulting_mat_i p ff_ops u)))\n     (\\<lambda>u.\n         map (\\<lambda>x. poly_of_list (list_of_vec x))\n          (find_base_vectors (berlekamp_resulting_mat u)))", "by transfer_prover"], ["", "lemma berlekamp_factorization_main_i[transfer_rule]: \n  \"((=) ===> list_all2 poly_rel ===> list_all2 poly_rel ===> (=) ===> list_all2 poly_rel) \n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops) \n       (arith_ops_record.one ff_ops)) \n     berlekamp_factorization_main\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===>\n     list_all2 poly_rel ===>\n     list_all2 poly_rel ===> (=) ===> list_all2 poly_rel)\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops))\n     berlekamp_factorization_main", "proof (intro rel_funI, clarify, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>list_all2 poly_rel xa ya; list_all2 poly_rel xb yb\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (berlekamp_factorization_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) y xa xb yc)\n                          (berlekamp_factorization_main y ya yb yc)", "case (1 _ d xs xs' ys ys' _ n)"], ["proof (state)\nthis:\n  list_all2 poly_rel xs xs'\n  list_all2 poly_rel ys ys'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>list_all2 poly_rel xa ya; list_all2 poly_rel xb yb\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (berlekamp_factorization_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) y xa xb yc)\n                          (berlekamp_factorization_main y ya yb yc)", "let ?ze = \"arith_ops_record.zero ff_ops\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>list_all2 poly_rel xa ya; list_all2 poly_rel xb yb\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (berlekamp_factorization_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) y xa xb yc)\n                          (berlekamp_factorization_main y ya yb yc)", "let ?on = \"arith_ops_record.one ff_ops\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>list_all2 poly_rel xa ya; list_all2 poly_rel xb yb\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (berlekamp_factorization_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) y xa xb yc)\n                          (berlekamp_factorization_main y ya yb yc)", "let ?of_int = \"arith_ops_record.of_int ff_ops\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>list_all2 poly_rel xa ya; list_all2 poly_rel xb yb\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (berlekamp_factorization_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) y xa xb yc)\n                          (berlekamp_factorization_main y ya yb yc)", "from 1(2) 1(1)"], ["proof (chain)\npicking this:\n  list_all2 poly_rel ys ys'\n  list_all2 poly_rel xs xs'", "show ?case"], ["proof (prove)\nusing this:\n  list_all2 poly_rel ys ys'\n  list_all2 poly_rel xs xs'\n\ngoal (1 subgoal):\n 1. list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs ys n)\n     (berlekamp_factorization_main d xs' ys' n)", "proof (induct ys ys' arbitrary: xs xs' n rule: list_all2_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs xs' n.\n       list_all2 poly_rel xs xs' \\<Longrightarrow>\n       list_all2 poly_rel\n        (berlekamp_factorization_main_i p ff_ops\n          (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d xs\n          [] n)\n        (berlekamp_factorization_main d xs' [] n)\n 2. \\<And>x xs y ys xsa xs' n.\n       \\<lbrakk>poly_rel x y; list_all2 poly_rel xs ys;\n        \\<And>xsa xs' n.\n           list_all2 poly_rel xsa xs' \\<Longrightarrow>\n           list_all2 poly_rel\n            (berlekamp_factorization_main_i p ff_ops\n              (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d\n              xsa xs n)\n            (berlekamp_factorization_main d xs' ys n);\n        list_all2 poly_rel xsa xs'\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (berlekamp_factorization_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) d xsa (x # xs) n)\n                          (berlekamp_factorization_main d xs' (y # ys) n)", "case (Cons y ys y' ys' xs xs' n)"], ["proof (state)\nthis:\n  poly_rel y y'\n  list_all2 poly_rel ys ys'\n  list_all2 poly_rel ?xs ?xs' \\<Longrightarrow>\n  list_all2 poly_rel\n   (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n     (arith_ops_record.one ff_ops) d ?xs ys ?n)\n   (berlekamp_factorization_main d ?xs' ys' ?n)\n  list_all2 poly_rel xs xs'\n\ngoal (2 subgoals):\n 1. \\<And>xs xs' n.\n       list_all2 poly_rel xs xs' \\<Longrightarrow>\n       list_all2 poly_rel\n        (berlekamp_factorization_main_i p ff_ops\n          (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d xs\n          [] n)\n        (berlekamp_factorization_main d xs' [] n)\n 2. \\<And>x xs y ys xsa xs' n.\n       \\<lbrakk>poly_rel x y; list_all2 poly_rel xs ys;\n        \\<And>xsa xs' n.\n           list_all2 poly_rel xsa xs' \\<Longrightarrow>\n           list_all2 poly_rel\n            (berlekamp_factorization_main_i p ff_ops\n              (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d\n              xsa xs n)\n            (berlekamp_factorization_main d xs' ys n);\n        list_all2 poly_rel xsa xs'\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (berlekamp_factorization_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) d xsa (x # xs) n)\n                          (berlekamp_factorization_main d xs' (y # ys) n)", "note trans[transfer_rule] = Cons(1,2,4)"], ["proof (state)\nthis:\n  poly_rel y y'\n  list_all2 poly_rel ys ys'\n  list_all2 poly_rel xs xs'\n\ngoal (2 subgoals):\n 1. \\<And>xs xs' n.\n       list_all2 poly_rel xs xs' \\<Longrightarrow>\n       list_all2 poly_rel\n        (berlekamp_factorization_main_i p ff_ops\n          (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d xs\n          [] n)\n        (berlekamp_factorization_main d xs' [] n)\n 2. \\<And>x xs y ys xsa xs' n.\n       \\<lbrakk>poly_rel x y; list_all2 poly_rel xs ys;\n        \\<And>xsa xs' n.\n           list_all2 poly_rel xsa xs' \\<Longrightarrow>\n           list_all2 poly_rel\n            (berlekamp_factorization_main_i p ff_ops\n              (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d\n              xsa xs n)\n            (berlekamp_factorization_main d xs' ys n);\n        list_all2 poly_rel xsa xs'\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (berlekamp_factorization_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) d xsa (x # xs) n)\n                          (berlekamp_factorization_main d xs' (y # ys) n)", "obtain clar0 clar1 clar2 where clarify: \"\\<And> s u. gcd_poly_i ff_ops u\n                         (minus_poly_i ff_ops y\n                        (if s = 0 then [] else [?of_int (int s)])) = clar0 s u\" \n        \"[0..<nat p] = clar1\"\n        \"[?on] = clar2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>clar0 clar1 clar2.\n        \\<lbrakk>\\<And>s u.\n                    gcd_poly_i ff_ops u\n                     (minus_poly_i ff_ops y\n                       (if s = 0 then []\n                        else [arith_ops_record.of_int ff_ops (int s)])) =\n                    clar0 s u;\n         [0..<nat p] = clar1; [arith_ops_record.one ff_ops] = clar2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  gcd_poly_i ff_ops ?u\n   (minus_poly_i ff_ops y\n     (if ?s = 0 then [] else [arith_ops_record.of_int ff_ops (int ?s)])) =\n  clar0 ?s ?u\n  [0..<nat p] = clar1\n  [arith_ops_record.one ff_ops] = clar2\n\ngoal (2 subgoals):\n 1. \\<And>xs xs' n.\n       list_all2 poly_rel xs xs' \\<Longrightarrow>\n       list_all2 poly_rel\n        (berlekamp_factorization_main_i p ff_ops\n          (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d xs\n          [] n)\n        (berlekamp_factorization_main d xs' [] n)\n 2. \\<And>x xs y ys xsa xs' n.\n       \\<lbrakk>poly_rel x y; list_all2 poly_rel xs ys;\n        \\<And>xsa xs' n.\n           list_all2 poly_rel xsa xs' \\<Longrightarrow>\n           list_all2 poly_rel\n            (berlekamp_factorization_main_i p ff_ops\n              (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d\n              xsa xs n)\n            (berlekamp_factorization_main d xs' ys n);\n        list_all2 poly_rel xsa xs'\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (berlekamp_factorization_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) d xsa (x # xs) n)\n                          (berlekamp_factorization_main d xs' (y # ys) n)", "define facts where \"facts = concat (map (\\<lambda>u. concat\n                        (map (\\<lambda>s. if gcd_poly_i ff_ops u\n                                      (minus_poly_i ff_ops y (if s = 0 then [] else [?of_int (int s)])) \\<noteq>\n                                     [?on]\n                                  then [gcd_poly_i ff_ops u\n                                         (minus_poly_i ff_ops y (if s = 0 then [] else [?of_int (int s)]))]\n                                  else [])\n                          [0..<nat p])) xs)\""], ["proof (state)\nthis:\n  facts =\n  concat\n   (map (\\<lambda>u.\n            concat\n             (map (\\<lambda>s.\n                      if gcd_poly_i ff_ops u\n                          (minus_poly_i ff_ops y\n                            (if s = 0 then []\n                             else [arith_ops_record.of_int ff_ops\n                                    (int s)])) \\<noteq>\n                         [arith_ops_record.one ff_ops]\n                      then [gcd_poly_i ff_ops u\n                             (minus_poly_i ff_ops y\n                               (if s = 0 then []\n                                else [arith_ops_record.of_int ff_ops\n (int s)]))]\n                      else [])\n               [0..<nat p]))\n     xs)\n\ngoal (2 subgoals):\n 1. \\<And>xs xs' n.\n       list_all2 poly_rel xs xs' \\<Longrightarrow>\n       list_all2 poly_rel\n        (berlekamp_factorization_main_i p ff_ops\n          (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d xs\n          [] n)\n        (berlekamp_factorization_main d xs' [] n)\n 2. \\<And>x xs y ys xsa xs' n.\n       \\<lbrakk>poly_rel x y; list_all2 poly_rel xs ys;\n        \\<And>xsa xs' n.\n           list_all2 poly_rel xsa xs' \\<Longrightarrow>\n           list_all2 poly_rel\n            (berlekamp_factorization_main_i p ff_ops\n              (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d\n              xsa xs n)\n            (berlekamp_factorization_main d xs' ys n);\n        list_all2 poly_rel xsa xs'\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (berlekamp_factorization_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) d xsa (x # xs) n)\n                          (berlekamp_factorization_main d xs' (y # ys) n)", "define Facts where \"Facts = [w\\<leftarrow>concat\n                          (map (\\<lambda>u. map (\\<lambda>s. gcd_poly_i ff_ops u\n                                              (minus_poly_i ff_ops y\n                                                (if s = 0 then [] else [?of_int (int s)])))\n                                     [0..<nat p])\n                            xs) .  w \\<noteq> [?on]]\""], ["proof (state)\nthis:\n  Facts =\n  filter (\\<lambda>w. w \\<noteq> [arith_ops_record.one ff_ops])\n   (concat\n     (map (\\<lambda>u.\n              map (\\<lambda>s.\n                      gcd_poly_i ff_ops u\n                       (minus_poly_i ff_ops y\n                         (if s = 0 then []\n                          else [arith_ops_record.of_int ff_ops (int s)])))\n               [0..<nat p])\n       xs))\n\ngoal (2 subgoals):\n 1. \\<And>xs xs' n.\n       list_all2 poly_rel xs xs' \\<Longrightarrow>\n       list_all2 poly_rel\n        (berlekamp_factorization_main_i p ff_ops\n          (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d xs\n          [] n)\n        (berlekamp_factorization_main d xs' [] n)\n 2. \\<And>x xs y ys xsa xs' n.\n       \\<lbrakk>poly_rel x y; list_all2 poly_rel xs ys;\n        \\<And>xsa xs' n.\n           list_all2 poly_rel xsa xs' \\<Longrightarrow>\n           list_all2 poly_rel\n            (berlekamp_factorization_main_i p ff_ops\n              (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d\n              xsa xs n)\n            (berlekamp_factorization_main d xs' ys n);\n        list_all2 poly_rel xsa xs'\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (berlekamp_factorization_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) d xsa (x # xs) n)\n                          (berlekamp_factorization_main d xs' (y # ys) n)", "have Facts: \"Facts = facts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Facts = facts", "unfolding Facts_def facts_def clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>w. w \\<noteq> clar2)\n     (concat (map (\\<lambda>u. map (\\<lambda>s. clar0 s u) clar1) xs)) =\n    concat\n     (map (\\<lambda>u.\n              concat\n               (map (\\<lambda>s.\n                        if clar0 s u \\<noteq> clar2 then [clar0 s u]\n                        else [])\n                 clar1))\n       xs)", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. filter (\\<lambda>w. w \\<noteq> clar2)\n     (concat (map (\\<lambda>u. map (\\<lambda>s. clar0 s u) clar1) [])) =\n    concat\n     (map (\\<lambda>u.\n              concat\n               (map (\\<lambda>s.\n                        if clar0 s u \\<noteq> clar2 then [clar0 s u]\n                        else [])\n                 clar1))\n       [])\n 2. \\<And>a xs.\n       filter (\\<lambda>w. w \\<noteq> clar2)\n        (concat (map (\\<lambda>u. map (\\<lambda>s. clar0 s u) clar1) xs)) =\n       concat\n        (map (\\<lambda>u.\n                 concat\n                  (map (\\<lambda>s.\n                           if clar0 s u \\<noteq> clar2 then [clar0 s u]\n                           else [])\n                    clar1))\n          xs) \\<Longrightarrow>\n       filter (\\<lambda>w. w \\<noteq> clar2)\n        (concat\n          (map (\\<lambda>u. map (\\<lambda>s. clar0 s u) clar1) (a # xs))) =\n       concat\n        (map (\\<lambda>u.\n                 concat\n                  (map (\\<lambda>s.\n                           if clar0 s u \\<noteq> clar2 then [clar0 s u]\n                           else [])\n                    clar1))\n          (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  filter (\\<lambda>w. w \\<noteq> clar2)\n   (concat (map (\\<lambda>u. map (\\<lambda>s. clar0 s u) clar1) xs)) =\n  concat\n   (map (\\<lambda>u.\n            concat\n             (map (\\<lambda>s.\n                      if clar0 s u \\<noteq> clar2 then [clar0 s u] else [])\n               clar1))\n     xs)\n\ngoal (2 subgoals):\n 1. filter (\\<lambda>w. w \\<noteq> clar2)\n     (concat (map (\\<lambda>u. map (\\<lambda>s. clar0 s u) clar1) [])) =\n    concat\n     (map (\\<lambda>u.\n              concat\n               (map (\\<lambda>s.\n                        if clar0 s u \\<noteq> clar2 then [clar0 s u]\n                        else [])\n                 clar1))\n       [])\n 2. \\<And>a xs.\n       filter (\\<lambda>w. w \\<noteq> clar2)\n        (concat (map (\\<lambda>u. map (\\<lambda>s. clar0 s u) clar1) xs)) =\n       concat\n        (map (\\<lambda>u.\n                 concat\n                  (map (\\<lambda>s.\n                           if clar0 s u \\<noteq> clar2 then [clar0 s u]\n                           else [])\n                    clar1))\n          xs) \\<Longrightarrow>\n       filter (\\<lambda>w. w \\<noteq> clar2)\n        (concat\n          (map (\\<lambda>u. map (\\<lambda>s. clar0 s u) clar1) (a # xs))) =\n       concat\n        (map (\\<lambda>u.\n                 concat\n                  (map (\\<lambda>s.\n                           if clar0 s u \\<noteq> clar2 then [clar0 s u]\n                           else [])\n                    clar1))\n          (a # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>w. w \\<noteq> clar2)\n     (concat\n       (map (\\<lambda>u. map (\\<lambda>s. clar0 s u) clar1) (x # xs))) =\n    concat\n     (map (\\<lambda>u.\n              concat\n               (map (\\<lambda>s.\n                        if clar0 s u \\<noteq> clar2 then [clar0 s u]\n                        else [])\n                 clar1))\n       (x # xs))", "by (simp add: Cons, induct clar1, auto)"], ["proof (state)\nthis:\n  filter (\\<lambda>w. w \\<noteq> clar2)\n   (concat (map (\\<lambda>u. map (\\<lambda>s. clar0 s u) clar1) (x # xs))) =\n  concat\n   (map (\\<lambda>u.\n            concat\n             (map (\\<lambda>s.\n                      if clar0 s u \\<noteq> clar2 then [clar0 s u] else [])\n               clar1))\n     (x # xs))\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>w. w \\<noteq> clar2)\n     (concat (map (\\<lambda>u. map (\\<lambda>s. clar0 s u) clar1) [])) =\n    concat\n     (map (\\<lambda>u.\n              concat\n               (map (\\<lambda>s.\n                        if clar0 s u \\<noteq> clar2 then [clar0 s u]\n                        else [])\n                 clar1))\n       [])", "qed simp"], ["proof (state)\nthis:\n  Facts = facts\n\ngoal (2 subgoals):\n 1. \\<And>xs xs' n.\n       list_all2 poly_rel xs xs' \\<Longrightarrow>\n       list_all2 poly_rel\n        (berlekamp_factorization_main_i p ff_ops\n          (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d xs\n          [] n)\n        (berlekamp_factorization_main d xs' [] n)\n 2. \\<And>x xs y ys xsa xs' n.\n       \\<lbrakk>poly_rel x y; list_all2 poly_rel xs ys;\n        \\<And>xsa xs' n.\n           list_all2 poly_rel xsa xs' \\<Longrightarrow>\n           list_all2 poly_rel\n            (berlekamp_factorization_main_i p ff_ops\n              (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d\n              xsa xs n)\n            (berlekamp_factorization_main d xs' ys n);\n        list_all2 poly_rel xsa xs'\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (berlekamp_factorization_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) d xsa (x # xs) n)\n                          (berlekamp_factorization_main d xs' (y # ys) n)", "define facts' where \"facts' = concat\n             (map (\\<lambda>u. concat\n                        (map (\\<lambda>x. if gcd u (y' - [:of_nat x:]) \\<noteq> 1\n                                  then [gcd u (y' - [:of_int (int x):])] else [])\n                          [0..<nat p]))\n               xs')\""], ["proof (state)\nthis:\n  facts' =\n  concat\n   (map (\\<lambda>u.\n            concat\n             (map (\\<lambda>x.\n                      if gcd u (y' - [:of_nat x:]) \\<noteq> 1\n                      then [gcd u (y' - [:of_int (int x):])] else [])\n               [0..<nat p]))\n     xs')\n\ngoal (2 subgoals):\n 1. \\<And>xs xs' n.\n       list_all2 poly_rel xs xs' \\<Longrightarrow>\n       list_all2 poly_rel\n        (berlekamp_factorization_main_i p ff_ops\n          (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d xs\n          [] n)\n        (berlekamp_factorization_main d xs' [] n)\n 2. \\<And>x xs y ys xsa xs' n.\n       \\<lbrakk>poly_rel x y; list_all2 poly_rel xs ys;\n        \\<And>xsa xs' n.\n           list_all2 poly_rel xsa xs' \\<Longrightarrow>\n           list_all2 poly_rel\n            (berlekamp_factorization_main_i p ff_ops\n              (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d\n              xsa xs n)\n            (berlekamp_factorization_main d xs' ys n);\n        list_all2 poly_rel xsa xs'\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (berlekamp_factorization_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) d xsa (x # xs) n)\n                          (berlekamp_factorization_main d xs' (y # ys) n)", "have id: \"\\<And> x. of_int (int x) = of_nat x\" \"[?on] = one_poly_i ff_ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. of_int (int x) = of_nat x) &&&\n    [arith_ops_record.one ff_ops] = one_poly_i ff_ops", "by (auto simp: one_poly_i_def)"], ["proof (state)\nthis:\n  of_int (int ?x) = of_nat ?x\n  [arith_ops_record.one ff_ops] = one_poly_i ff_ops\n\ngoal (2 subgoals):\n 1. \\<And>xs xs' n.\n       list_all2 poly_rel xs xs' \\<Longrightarrow>\n       list_all2 poly_rel\n        (berlekamp_factorization_main_i p ff_ops\n          (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d xs\n          [] n)\n        (berlekamp_factorization_main d xs' [] n)\n 2. \\<And>x xs y ys xsa xs' n.\n       \\<lbrakk>poly_rel x y; list_all2 poly_rel xs ys;\n        \\<And>xsa xs' n.\n           list_all2 poly_rel xsa xs' \\<Longrightarrow>\n           list_all2 poly_rel\n            (berlekamp_factorization_main_i p ff_ops\n              (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d\n              xsa xs n)\n            (berlekamp_factorization_main d xs' ys n);\n        list_all2 poly_rel xsa xs'\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (berlekamp_factorization_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) d xsa (x # xs) n)\n                          (berlekamp_factorization_main d xs' (y # ys) n)", "have facts[transfer_rule]: \"list_all2 poly_rel facts facts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 poly_rel facts facts'", "unfolding facts_def facts'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 poly_rel\n     (concat\n       (map (\\<lambda>u.\n                concat\n                 (map (\\<lambda>s.\n                          if gcd_poly_i ff_ops u\n                              (minus_poly_i ff_ops y\n                                (if s = 0 then []\n                                 else [arith_ops_record.of_int ff_ops\n  (int s)])) \\<noteq>\n                             [arith_ops_record.one ff_ops]\n                          then [gcd_poly_i ff_ops u\n                                 (minus_poly_i ff_ops y\n                                   (if s = 0 then []\n                                    else [arith_ops_record.of_int ff_ops\n     (int s)]))]\n                          else [])\n                   [0..<nat p]))\n         xs))\n     (concat\n       (map (\\<lambda>u.\n                concat\n                 (map (\\<lambda>x.\n                          if gcd u (y' - [:of_nat x:]) \\<noteq> 1\n                          then [gcd u (y' - [:of_int (int x):])] else [])\n                   [0..<nat p]))\n         xs'))", "apply (rule concat_transfer[unfolded rel_fun_def, rule_format])"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (list_all2 poly_rel)\n     (map (\\<lambda>u.\n              concat\n               (map (\\<lambda>s.\n                        if gcd_poly_i ff_ops u\n                            (minus_poly_i ff_ops y\n                              (if s = 0 then []\n                               else [arith_ops_record.of_int ff_ops\n(int s)])) \\<noteq>\n                           [arith_ops_record.one ff_ops]\n                        then [gcd_poly_i ff_ops u\n                               (minus_poly_i ff_ops y\n                                 (if s = 0 then []\n                                  else [arith_ops_record.of_int ff_ops\n   (int s)]))]\n                        else [])\n                 [0..<nat p]))\n       xs)\n     (map (\\<lambda>u.\n              concat\n               (map (\\<lambda>x.\n                        if gcd u (y' - [:of_nat x:]) \\<noteq> 1\n                        then [gcd u (y' - [:of_int (int x):])] else [])\n                 [0..<nat p]))\n       xs')", "apply (rule list.map_transfer[unfolded rel_fun_def, rule_format, OF _ trans(3)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       poly_rel x ya \\<Longrightarrow>\n       list_all2 poly_rel\n        (concat\n          (map (\\<lambda>s.\n                   if gcd_poly_i ff_ops x\n                       (minus_poly_i ff_ops y\n                         (if s = 0 then []\n                          else [arith_ops_record.of_int ff_ops\n                                 (int s)])) \\<noteq>\n                      [arith_ops_record.one ff_ops]\n                   then [gcd_poly_i ff_ops x\n                          (minus_poly_i ff_ops y\n                            (if s = 0 then []\n                             else [arith_ops_record.of_int ff_ops\n                                    (int s)]))]\n                   else [])\n            [0..<nat p]))\n        (concat\n          (map (\\<lambda>x.\n                   if gcd ya (y' - [:of_nat x:]) \\<noteq> 1\n                   then [gcd ya (y' - [:of_int (int x):])] else [])\n            [0..<nat p]))", "apply (rule concat_transfer[unfolded rel_fun_def, rule_format])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       poly_rel x ya \\<Longrightarrow>\n       list_all2 (list_all2 poly_rel)\n        (map (\\<lambda>s.\n                 if gcd_poly_i ff_ops x\n                     (minus_poly_i ff_ops y\n                       (if s = 0 then []\n                        else [arith_ops_record.of_int ff_ops\n                               (int s)])) \\<noteq>\n                    [arith_ops_record.one ff_ops]\n                 then [gcd_poly_i ff_ops x\n                        (minus_poly_i ff_ops y\n                          (if s = 0 then []\n                           else [arith_ops_record.of_int ff_ops (int s)]))]\n                 else [])\n          [0..<nat p])\n        (map (\\<lambda>x.\n                 if gcd ya (y' - [:of_nat x:]) \\<noteq> 1\n                 then [gcd ya (y' - [:of_int (int x):])] else [])\n          [0..<nat p])", "apply (rule list_all2_map_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x ya xa.\n       \\<lbrakk>poly_rel x ya; xa \\<in> set [0..<nat p]\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (if gcd_poly_i ff_ops x\n                               (minus_poly_i ff_ops y\n                                 (if xa = 0 then []\n                                  else [arith_ops_record.of_int ff_ops\n   (int xa)])) \\<noteq>\n                              [arith_ops_record.one ff_ops]\n                           then [gcd_poly_i ff_ops x\n                                  (minus_poly_i ff_ops y\n                                    (if xa = 0 then []\n                                     else [arith_ops_record.of_int ff_ops\n      (int xa)]))]\n                           else [])\n                          (if gcd ya (y' - [:of_nat xa:]) \\<noteq> 1\n                           then [gcd ya (y' - [:of_int (int xa):])] else [])", "proof (unfold id)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ya xa.\n       \\<lbrakk>poly_rel x ya; xa \\<in> set [0..<nat p]\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (if gcd_poly_i ff_ops x\n                               (minus_poly_i ff_ops y\n                                 (if xa = 0 then []\n                                  else [arith_ops_record.of_int ff_ops\n   (int xa)])) \\<noteq>\n                              one_poly_i ff_ops\n                           then [gcd_poly_i ff_ops x\n                                  (minus_poly_i ff_ops y\n                                    (if xa = 0 then []\n                                     else [arith_ops_record.of_int ff_ops\n      (int xa)]))]\n                           else [])\n                          (if gcd ya (y' - [:of_nat xa:]) \\<noteq> 1\n                           then [gcd ya (y' - [:of_nat xa:])] else [])", "fix f f' x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ya xa.\n       \\<lbrakk>poly_rel x ya; xa \\<in> set [0..<nat p]\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (if gcd_poly_i ff_ops x\n                               (minus_poly_i ff_ops y\n                                 (if xa = 0 then []\n                                  else [arith_ops_record.of_int ff_ops\n   (int xa)])) \\<noteq>\n                              one_poly_i ff_ops\n                           then [gcd_poly_i ff_ops x\n                                  (minus_poly_i ff_ops y\n                                    (if xa = 0 then []\n                                     else [arith_ops_record.of_int ff_ops\n      (int xa)]))]\n                           else [])\n                          (if gcd ya (y' - [:of_nat xa:]) \\<noteq> 1\n                           then [gcd ya (y' - [:of_nat xa:])] else [])", "assume [transfer_rule]: \"poly_rel f f'\" and x: \"x \\<in> set [0..<nat p]\""], ["proof (state)\nthis:\n  poly_rel f f'\n  x \\<in> set [0..<nat p]\n\ngoal (1 subgoal):\n 1. \\<And>x ya xa.\n       \\<lbrakk>poly_rel x ya; xa \\<in> set [0..<nat p]\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (if gcd_poly_i ff_ops x\n                               (minus_poly_i ff_ops y\n                                 (if xa = 0 then []\n                                  else [arith_ops_record.of_int ff_ops\n   (int xa)])) \\<noteq>\n                              one_poly_i ff_ops\n                           then [gcd_poly_i ff_ops x\n                                  (minus_poly_i ff_ops y\n                                    (if xa = 0 then []\n                                     else [arith_ops_record.of_int ff_ops\n      (int xa)]))]\n                           else [])\n                          (if gcd ya (y' - [:of_nat xa:]) \\<noteq> 1\n                           then [gcd ya (y' - [:of_nat xa:])] else [])", "hence *: \"0 \\<le> int x\" \"int x < p\""], ["proof (prove)\nusing this:\n  poly_rel f f'\n  x \\<in> set [0..<nat p]\n\ngoal (1 subgoal):\n 1. 0 \\<le> int x &&& int x < p", "by auto"], ["proof (state)\nthis:\n  0 \\<le> int x\n  int x < p\n\ngoal (1 subgoal):\n 1. \\<And>x ya xa.\n       \\<lbrakk>poly_rel x ya; xa \\<in> set [0..<nat p]\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (if gcd_poly_i ff_ops x\n                               (minus_poly_i ff_ops y\n                                 (if xa = 0 then []\n                                  else [arith_ops_record.of_int ff_ops\n   (int xa)])) \\<noteq>\n                              one_poly_i ff_ops\n                           then [gcd_poly_i ff_ops x\n                                  (minus_poly_i ff_ops y\n                                    (if xa = 0 then []\n                                     else [arith_ops_record.of_int ff_ops\n      (int xa)]))]\n                           else [])\n                          (if gcd ya (y' - [:of_nat xa:]) \\<noteq> 1\n                           then [gcd ya (y' - [:of_nat xa:])] else [])", "from of_int[OF this]"], ["proof (chain)\npicking this:\n  R (arith_ops_record.of_int ff_ops (int x)) (of_int (int x))", "have rel[transfer_rule]: \"R (?of_int (int x)) (of_nat x)\""], ["proof (prove)\nusing this:\n  R (arith_ops_record.of_int ff_ops (int x)) (of_int (int x))\n\ngoal (1 subgoal):\n 1. R (arith_ops_record.of_int ff_ops (int x)) (of_nat x)", "by auto"], ["proof (state)\nthis:\n  R (arith_ops_record.of_int ff_ops (int x)) (of_nat x)\n\ngoal (1 subgoal):\n 1. \\<And>x ya xa.\n       \\<lbrakk>poly_rel x ya; xa \\<in> set [0..<nat p]\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (if gcd_poly_i ff_ops x\n                               (minus_poly_i ff_ops y\n                                 (if xa = 0 then []\n                                  else [arith_ops_record.of_int ff_ops\n   (int xa)])) \\<noteq>\n                              one_poly_i ff_ops\n                           then [gcd_poly_i ff_ops x\n                                  (minus_poly_i ff_ops y\n                                    (if xa = 0 then []\n                                     else [arith_ops_record.of_int ff_ops\n      (int xa)]))]\n                           else [])\n                          (if gcd ya (y' - [:of_nat xa:]) \\<noteq> 1\n                           then [gcd ya (y' - [:of_nat xa:])] else [])", "{"], ["proof (state)\nthis:\n  R (arith_ops_record.of_int ff_ops (int x)) (of_nat x)\n\ngoal (1 subgoal):\n 1. \\<And>x ya xa.\n       \\<lbrakk>poly_rel x ya; xa \\<in> set [0..<nat p]\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (if gcd_poly_i ff_ops x\n                               (minus_poly_i ff_ops y\n                                 (if xa = 0 then []\n                                  else [arith_ops_record.of_int ff_ops\n   (int xa)])) \\<noteq>\n                              one_poly_i ff_ops\n                           then [gcd_poly_i ff_ops x\n                                  (minus_poly_i ff_ops y\n                                    (if xa = 0 then []\n                                     else [arith_ops_record.of_int ff_ops\n      (int xa)]))]\n                           else [])\n                          (if gcd ya (y' - [:of_nat xa:]) \\<noteq> 1\n                           then [gcd ya (y' - [:of_nat xa:])] else [])", "assume \"0 < x\""], ["proof (state)\nthis:\n  0 < x\n\ngoal (1 subgoal):\n 1. \\<And>x ya xa.\n       \\<lbrakk>poly_rel x ya; xa \\<in> set [0..<nat p]\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (if gcd_poly_i ff_ops x\n                               (minus_poly_i ff_ops y\n                                 (if xa = 0 then []\n                                  else [arith_ops_record.of_int ff_ops\n   (int xa)])) \\<noteq>\n                              one_poly_i ff_ops\n                           then [gcd_poly_i ff_ops x\n                                  (minus_poly_i ff_ops y\n                                    (if xa = 0 then []\n                                     else [arith_ops_record.of_int ff_ops\n      (int xa)]))]\n                           else [])\n                          (if gcd ya (y' - [:of_nat xa:]) \\<noteq> 1\n                           then [gcd ya (y' - [:of_nat xa:])] else [])", "with *"], ["proof (chain)\npicking this:\n  0 \\<le> int x\n  int x < p\n  0 < x", "have *: \"0 < int x\" \"int x < p\""], ["proof (prove)\nusing this:\n  0 \\<le> int x\n  int x < p\n  0 < x\n\ngoal (1 subgoal):\n 1. 0 < int x &&& int x < p", "by auto"], ["proof (state)\nthis:\n  0 < int x\n  int x < p\n\ngoal (1 subgoal):\n 1. \\<And>x ya xa.\n       \\<lbrakk>poly_rel x ya; xa \\<in> set [0..<nat p]\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (if gcd_poly_i ff_ops x\n                               (minus_poly_i ff_ops y\n                                 (if xa = 0 then []\n                                  else [arith_ops_record.of_int ff_ops\n   (int xa)])) \\<noteq>\n                              one_poly_i ff_ops\n                           then [gcd_poly_i ff_ops x\n                                  (minus_poly_i ff_ops y\n                                    (if xa = 0 then []\n                                     else [arith_ops_record.of_int ff_ops\n      (int xa)]))]\n                           else [])\n                          (if gcd ya (y' - [:of_nat xa:]) \\<noteq> 1\n                           then [gcd ya (y' - [:of_nat xa:])] else [])", "have \"(of_nat x :: 'a mod_ring) = of_int (int x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat x = of_int (int x)", "by simp"], ["proof (state)\nthis:\n  of_nat x = of_int (int x)\n\ngoal (1 subgoal):\n 1. \\<And>x ya xa.\n       \\<lbrakk>poly_rel x ya; xa \\<in> set [0..<nat p]\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (if gcd_poly_i ff_ops x\n                               (minus_poly_i ff_ops y\n                                 (if xa = 0 then []\n                                  else [arith_ops_record.of_int ff_ops\n   (int xa)])) \\<noteq>\n                              one_poly_i ff_ops\n                           then [gcd_poly_i ff_ops x\n                                  (minus_poly_i ff_ops y\n                                    (if xa = 0 then []\n                                     else [arith_ops_record.of_int ff_ops\n      (int xa)]))]\n                           else [])\n                          (if gcd ya (y' - [:of_nat xa:]) \\<noteq> 1\n                           then [gcd ya (y' - [:of_nat xa:])] else [])", "also"], ["proof (state)\nthis:\n  of_nat x = of_int (int x)\n\ngoal (1 subgoal):\n 1. \\<And>x ya xa.\n       \\<lbrakk>poly_rel x ya; xa \\<in> set [0..<nat p]\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (if gcd_poly_i ff_ops x\n                               (minus_poly_i ff_ops y\n                                 (if xa = 0 then []\n                                  else [arith_ops_record.of_int ff_ops\n   (int xa)])) \\<noteq>\n                              one_poly_i ff_ops\n                           then [gcd_poly_i ff_ops x\n                                  (minus_poly_i ff_ops y\n                                    (if xa = 0 then []\n                                     else [arith_ops_record.of_int ff_ops\n      (int xa)]))]\n                           else [])\n                          (if gcd ya (y' - [:of_nat xa:]) \\<noteq> 1\n                           then [gcd ya (y' - [:of_nat xa:])] else [])", "have \"\\<dots> \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (int x) \\<noteq> 0", "unfolding of_int_of_int_mod_ring"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_mod_ring (int x) \\<noteq> 0", "using *"], ["proof (prove)\nusing this:\n  0 < int x\n  int x < p\n\ngoal (1 subgoal):\n 1. of_int_mod_ring (int x) \\<noteq> 0", "unfolding p"], ["proof (prove)\nusing this:\n  0 < int x\n  int x < int CARD('a)\n\ngoal (1 subgoal):\n 1. of_int_mod_ring (int x) \\<noteq> 0", "by (transfer', auto)"], ["proof (state)\nthis:\n  of_int (int x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x ya xa.\n       \\<lbrakk>poly_rel x ya; xa \\<in> set [0..<nat p]\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (if gcd_poly_i ff_ops x\n                               (minus_poly_i ff_ops y\n                                 (if xa = 0 then []\n                                  else [arith_ops_record.of_int ff_ops\n   (int xa)])) \\<noteq>\n                              one_poly_i ff_ops\n                           then [gcd_poly_i ff_ops x\n                                  (minus_poly_i ff_ops y\n                                    (if xa = 0 then []\n                                     else [arith_ops_record.of_int ff_ops\n      (int xa)]))]\n                           else [])\n                          (if gcd ya (y' - [:of_nat xa:]) \\<noteq> 1\n                           then [gcd ya (y' - [:of_nat xa:])] else [])", "}"], ["proof (state)\nthis:\n  0 < x \\<Longrightarrow> of_int (int x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x ya xa.\n       \\<lbrakk>poly_rel x ya; xa \\<in> set [0..<nat p]\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (if gcd_poly_i ff_ops x\n                               (minus_poly_i ff_ops y\n                                 (if xa = 0 then []\n                                  else [arith_ops_record.of_int ff_ops\n   (int xa)])) \\<noteq>\n                              one_poly_i ff_ops\n                           then [gcd_poly_i ff_ops x\n                                  (minus_poly_i ff_ops y\n                                    (if xa = 0 then []\n                                     else [arith_ops_record.of_int ff_ops\n      (int xa)]))]\n                           else [])\n                          (if gcd ya (y' - [:of_nat xa:]) \\<noteq> 1\n                           then [gcd ya (y' - [:of_nat xa:])] else [])", "with rel"], ["proof (chain)\npicking this:\n  R (arith_ops_record.of_int ff_ops (int x)) (of_nat x)\n  0 < x \\<Longrightarrow> of_int (int x) \\<noteq> 0", "have [transfer_rule]: \"poly_rel (if x = 0 then [] else [?of_int (int x)]) [:of_nat x:]\""], ["proof (prove)\nusing this:\n  R (arith_ops_record.of_int ff_ops (int x)) (of_nat x)\n  0 < x \\<Longrightarrow> of_int (int x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_rel\n     (if x = 0 then [] else [arith_ops_record.of_int ff_ops (int x)])\n     [:of_nat x:]", "unfolding poly_rel_def"], ["proof (prove)\nusing this:\n  R (arith_ops_record.of_int ff_ops (int x)) (of_nat x)\n  0 < x \\<Longrightarrow> of_int (int x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. list_all2 R\n     (if x = 0 then [] else [arith_ops_record.of_int ff_ops (int x)])\n     (coeffs [:of_nat x:])", "by (auto simp add: cCons_def p)"], ["proof (state)\nthis:\n  poly_rel (if x = 0 then [] else [arith_ops_record.of_int ff_ops (int x)])\n   [:of_nat x:]\n\ngoal (1 subgoal):\n 1. \\<And>x ya xa.\n       \\<lbrakk>poly_rel x ya; xa \\<in> set [0..<nat p]\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (if gcd_poly_i ff_ops x\n                               (minus_poly_i ff_ops y\n                                 (if xa = 0 then []\n                                  else [arith_ops_record.of_int ff_ops\n   (int xa)])) \\<noteq>\n                              one_poly_i ff_ops\n                           then [gcd_poly_i ff_ops x\n                                  (minus_poly_i ff_ops y\n                                    (if xa = 0 then []\n                                     else [arith_ops_record.of_int ff_ops\n      (int xa)]))]\n                           else [])\n                          (if gcd ya (y' - [:of_nat xa:]) \\<noteq> 1\n                           then [gcd ya (y' - [:of_nat xa:])] else [])", "show \"list_all2 poly_rel\n          (if gcd_poly_i ff_ops f (minus_poly_i ff_ops y (if x = 0 then [] else [?of_int (int x)])) \\<noteq> one_poly_i ff_ops\n           then [gcd_poly_i ff_ops f (minus_poly_i ff_ops y (if x = 0 then [] else [?of_int (int x)]))]\n           else [])\n          (if gcd f' (y' - [:of_nat x:]) \\<noteq> 1 then [gcd f' (y' - [:of_nat x:])] else [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 poly_rel\n     (if gcd_poly_i ff_ops f\n          (minus_poly_i ff_ops y\n            (if x = 0 then []\n             else [arith_ops_record.of_int ff_ops (int x)])) \\<noteq>\n         one_poly_i ff_ops\n      then [gcd_poly_i ff_ops f\n             (minus_poly_i ff_ops y\n               (if x = 0 then []\n                else [arith_ops_record.of_int ff_ops (int x)]))]\n      else [])\n     (if gcd f' (y' - [:of_nat x:]) \\<noteq> 1\n      then [gcd f' (y' - [:of_nat x:])] else [])", "by transfer_prover"], ["proof (state)\nthis:\n  list_all2 poly_rel\n   (if gcd_poly_i ff_ops f\n        (minus_poly_i ff_ops y\n          (if x = 0 then []\n           else [arith_ops_record.of_int ff_ops (int x)])) \\<noteq>\n       one_poly_i ff_ops\n    then [gcd_poly_i ff_ops f\n           (minus_poly_i ff_ops y\n             (if x = 0 then []\n              else [arith_ops_record.of_int ff_ops (int x)]))]\n    else [])\n   (if gcd f' (y' - [:of_nat x:]) \\<noteq> 1\n    then [gcd f' (y' - [:of_nat x:])] else [])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all2 poly_rel facts facts'\n\ngoal (2 subgoals):\n 1. \\<And>xs xs' n.\n       list_all2 poly_rel xs xs' \\<Longrightarrow>\n       list_all2 poly_rel\n        (berlekamp_factorization_main_i p ff_ops\n          (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d xs\n          [] n)\n        (berlekamp_factorization_main d xs' [] n)\n 2. \\<And>x xs y ys xsa xs' n.\n       \\<lbrakk>poly_rel x y; list_all2 poly_rel xs ys;\n        \\<And>xsa xs' n.\n           list_all2 poly_rel xsa xs' \\<Longrightarrow>\n           list_all2 poly_rel\n            (berlekamp_factorization_main_i p ff_ops\n              (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d\n              xsa xs n)\n            (berlekamp_factorization_main d xs' ys n);\n        list_all2 poly_rel xsa xs'\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (berlekamp_factorization_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) d xsa (x # xs) n)\n                          (berlekamp_factorization_main d xs' (y # ys) n)", "have id1: \"berlekamp_factorization_main_i p ff_ops ?ze ?on d xs (y # ys) n = (\n      if y = [?on] then berlekamp_factorization_main_i p ff_ops ?ze ?on d xs ys n else\n      if length xs = n then xs else\n      (let fac = facts;\n          (lin, nonlin) = List.partition (\\<lambda>q. degree_i q = d) fac\n             in lin @ berlekamp_factorization_main_i p ff_ops ?ze ?on d nonlin ys (n - length lin)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n     (arith_ops_record.one ff_ops) d xs (y # ys) n =\n    (if y = [arith_ops_record.one ff_ops]\n     then berlekamp_factorization_main_i p ff_ops\n           (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d xs\n           ys n\n     else if length xs = n then xs\n          else let fac = facts;\n                   (lin, nonlin) =\n                     List.partition (\\<lambda>q. degree_i q = d) fac\n               in lin @\n                  berlekamp_factorization_main_i p ff_ops\n                   (arith_ops_record.zero ff_ops)\n                   (arith_ops_record.one ff_ops) d nonlin ys\n                   (n - length lin))", "unfolding berlekamp_factorization_main_i.simps Facts[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if y = [arith_ops_record.one ff_ops]\n     then berlekamp_factorization_main_i p ff_ops\n           (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d xs\n           ys n\n     else if length xs = n then xs\n          else let of_int = arith_ops_record.of_int ff_ops;\n                   facts =\n                     filter\n                      (\\<lambda>w. w \\<noteq> [arith_ops_record.one ff_ops])\n                      (concat\n                        (map (\\<lambda>u.\n                                 map (\\<lambda>s.\n   gcd_poly_i ff_ops u\n    (minus_poly_i ff_ops y (if s = 0 then [] else [of_int (int s)])))\n                                  [0..<nat p])\n                          xs));\n                   (lin, nonlin) =\n                     List.partition (\\<lambda>q. degree_i q = d) facts\n               in lin @\n                  berlekamp_factorization_main_i p ff_ops\n                   (arith_ops_record.zero ff_ops)\n                   (arith_ops_record.one ff_ops) d nonlin ys\n                   (n - length lin)) =\n    (if y = [arith_ops_record.one ff_ops]\n     then berlekamp_factorization_main_i p ff_ops\n           (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d xs\n           ys n\n     else if length xs = n then xs\n          else let fac = Facts;\n                   (lin, nonlin) =\n                     List.partition (\\<lambda>q. degree_i q = d) fac\n               in lin @\n                  berlekamp_factorization_main_i p ff_ops\n                   (arith_ops_record.zero ff_ops)\n                   (arith_ops_record.one ff_ops) d nonlin ys\n                   (n - length lin))", "by (simp add: o_def Facts_def Let_def)"], ["proof (state)\nthis:\n  berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n   (arith_ops_record.one ff_ops) d xs (y # ys) n =\n  (if y = [arith_ops_record.one ff_ops]\n   then berlekamp_factorization_main_i p ff_ops\n         (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d xs\n         ys n\n   else if length xs = n then xs\n        else let fac = facts;\n                 (lin, nonlin) =\n                   List.partition (\\<lambda>q. degree_i q = d) fac\n             in lin @\n                berlekamp_factorization_main_i p ff_ops\n                 (arith_ops_record.zero ff_ops)\n                 (arith_ops_record.one ff_ops) d nonlin ys (n - length lin))\n\ngoal (2 subgoals):\n 1. \\<And>xs xs' n.\n       list_all2 poly_rel xs xs' \\<Longrightarrow>\n       list_all2 poly_rel\n        (berlekamp_factorization_main_i p ff_ops\n          (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d xs\n          [] n)\n        (berlekamp_factorization_main d xs' [] n)\n 2. \\<And>x xs y ys xsa xs' n.\n       \\<lbrakk>poly_rel x y; list_all2 poly_rel xs ys;\n        \\<And>xsa xs' n.\n           list_all2 poly_rel xsa xs' \\<Longrightarrow>\n           list_all2 poly_rel\n            (berlekamp_factorization_main_i p ff_ops\n              (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d\n              xsa xs n)\n            (berlekamp_factorization_main d xs' ys n);\n        list_all2 poly_rel xsa xs'\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (berlekamp_factorization_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) d xsa (x # xs) n)\n                          (berlekamp_factorization_main d xs' (y # ys) n)", "have id2: \"berlekamp_factorization_main d xs' (y' # ys') n = (\n      if y' = 1 then berlekamp_factorization_main d xs' ys' n\n      else if length xs' = n then xs' else\n      (let fac = facts';\n          (lin, nonlin) = List.partition (\\<lambda>q. degree q = d) fac\n              in lin @ berlekamp_factorization_main d nonlin ys' (n - length lin)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. berlekamp_factorization_main d xs' (y' # ys') n =\n    (if y' = 1 then berlekamp_factorization_main d xs' ys' n\n     else if length xs' = n then xs'\n          else let fac = facts';\n                   (lin, nonlin) =\n                     List.partition (\\<lambda>q. degree q = d) fac\n               in lin @\n                  berlekamp_factorization_main d nonlin ys'\n                   (n - length lin))", "by (simp add: o_def facts'_def nat_p)"], ["proof (state)\nthis:\n  berlekamp_factorization_main d xs' (y' # ys') n =\n  (if y' = 1 then berlekamp_factorization_main d xs' ys' n\n   else if length xs' = n then xs'\n        else let fac = facts';\n                 (lin, nonlin) =\n                   List.partition (\\<lambda>q. degree q = d) fac\n             in lin @\n                berlekamp_factorization_main d nonlin ys' (n - length lin))\n\ngoal (2 subgoals):\n 1. \\<And>xs xs' n.\n       list_all2 poly_rel xs xs' \\<Longrightarrow>\n       list_all2 poly_rel\n        (berlekamp_factorization_main_i p ff_ops\n          (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d xs\n          [] n)\n        (berlekamp_factorization_main d xs' [] n)\n 2. \\<And>x xs y ys xsa xs' n.\n       \\<lbrakk>poly_rel x y; list_all2 poly_rel xs ys;\n        \\<And>xsa xs' n.\n           list_all2 poly_rel xsa xs' \\<Longrightarrow>\n           list_all2 poly_rel\n            (berlekamp_factorization_main_i p ff_ops\n              (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d\n              xsa xs n)\n            (berlekamp_factorization_main d xs' ys n);\n        list_all2 poly_rel xsa xs'\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (berlekamp_factorization_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) d xsa (x # xs) n)\n                          (berlekamp_factorization_main d xs' (y # ys) n)", "have len: \"length xs = length xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length xs'", "by transfer_prover"], ["proof (state)\nthis:\n  length xs = length xs'\n\ngoal (2 subgoals):\n 1. \\<And>xs xs' n.\n       list_all2 poly_rel xs xs' \\<Longrightarrow>\n       list_all2 poly_rel\n        (berlekamp_factorization_main_i p ff_ops\n          (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d xs\n          [] n)\n        (berlekamp_factorization_main d xs' [] n)\n 2. \\<And>x xs y ys xsa xs' n.\n       \\<lbrakk>poly_rel x y; list_all2 poly_rel xs ys;\n        \\<And>xsa xs' n.\n           list_all2 poly_rel xsa xs' \\<Longrightarrow>\n           list_all2 poly_rel\n            (berlekamp_factorization_main_i p ff_ops\n              (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d\n              xsa xs n)\n            (berlekamp_factorization_main d xs' ys n);\n        list_all2 poly_rel xsa xs'\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (berlekamp_factorization_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) d xsa (x # xs) n)\n                          (berlekamp_factorization_main d xs' (y # ys) n)", "have id3: \"(y = [?on]) = (y' = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y = [arith_ops_record.one ff_ops]) = (y' = 1)", "by (transfer_prover_start, transfer_step+, simp add: one_poly_i_def finite_field_ops_int_def)"], ["proof (state)\nthis:\n  (y = [arith_ops_record.one ff_ops]) = (y' = 1)\n\ngoal (2 subgoals):\n 1. \\<And>xs xs' n.\n       list_all2 poly_rel xs xs' \\<Longrightarrow>\n       list_all2 poly_rel\n        (berlekamp_factorization_main_i p ff_ops\n          (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d xs\n          [] n)\n        (berlekamp_factorization_main d xs' [] n)\n 2. \\<And>x xs y ys xsa xs' n.\n       \\<lbrakk>poly_rel x y; list_all2 poly_rel xs ys;\n        \\<And>xsa xs' n.\n           list_all2 poly_rel xsa xs' \\<Longrightarrow>\n           list_all2 poly_rel\n            (berlekamp_factorization_main_i p ff_ops\n              (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d\n              xsa xs n)\n            (berlekamp_factorization_main d xs' ys n);\n        list_all2 poly_rel xsa xs'\\<rbrakk>\n       \\<Longrightarrow> list_all2 poly_rel\n                          (berlekamp_factorization_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) d xsa (x # xs) n)\n                          (berlekamp_factorization_main d xs' (y # ys) n)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)", "proof (cases \"y' = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y' = 1 \\<Longrightarrow>\n    list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)\n 2. y' \\<noteq> 1 \\<Longrightarrow>\n    list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)", "case True"], ["proof (state)\nthis:\n  y' = 1\n\ngoal (2 subgoals):\n 1. y' = 1 \\<Longrightarrow>\n    list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)\n 2. y' \\<noteq> 1 \\<Longrightarrow>\n    list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)", "hence id4: \"(y' = 1) = True\""], ["proof (prove)\nusing this:\n  y' = 1\n\ngoal (1 subgoal):\n 1. (y' = 1) = True", "by simp"], ["proof (state)\nthis:\n  (y' = 1) = True\n\ngoal (2 subgoals):\n 1. y' = 1 \\<Longrightarrow>\n    list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)\n 2. y' \\<noteq> 1 \\<Longrightarrow>\n    list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)", "unfolding id1 id2 id3 id4 if_True"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs ys n)\n     (berlekamp_factorization_main d xs' ys' n)", "by (rule Cons(3), transfer_prover)"], ["proof (state)\nthis:\n  list_all2 poly_rel\n   (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n     (arith_ops_record.one ff_ops) d xs (y # ys) n)\n   (berlekamp_factorization_main d xs' (y' # ys') n)\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 1 \\<Longrightarrow>\n    list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y' \\<noteq> 1 \\<Longrightarrow>\n    list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)", "case False"], ["proof (state)\nthis:\n  y' \\<noteq> 1\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 1 \\<Longrightarrow>\n    list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)", "hence id4: \"(y' = 1) = False\""], ["proof (prove)\nusing this:\n  y' \\<noteq> 1\n\ngoal (1 subgoal):\n 1. (y' = 1) = False", "by simp"], ["proof (state)\nthis:\n  (y' = 1) = False\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 1 \\<Longrightarrow>\n    list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)", "note id1 = id1[unfolded id3 id4 if_False]"], ["proof (state)\nthis:\n  berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n   (arith_ops_record.one ff_ops) d xs (y # ys) n =\n  (if length xs = n then xs\n   else let fac = facts;\n            (lin, nonlin) = List.partition (\\<lambda>q. degree_i q = d) fac\n        in lin @\n           berlekamp_factorization_main_i p ff_ops\n            (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d\n            nonlin ys (n - length lin))\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 1 \\<Longrightarrow>\n    list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)", "note id2 = id2[unfolded id4 if_False]"], ["proof (state)\nthis:\n  berlekamp_factorization_main d xs' (y' # ys') n =\n  (if length xs' = n then xs'\n   else let fac = facts';\n            (lin, nonlin) = List.partition (\\<lambda>q. degree q = d) fac\n        in lin @ berlekamp_factorization_main d nonlin ys' (n - length lin))\n\ngoal (1 subgoal):\n 1. y' \\<noteq> 1 \\<Longrightarrow>\n    list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)", "proof (cases \"length xs' = n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length xs' = n \\<Longrightarrow>\n    list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)\n 2. length xs' \\<noteq> n \\<Longrightarrow>\n    list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)", "case True"], ["proof (state)\nthis:\n  length xs' = n\n\ngoal (2 subgoals):\n 1. length xs' = n \\<Longrightarrow>\n    list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)\n 2. length xs' \\<noteq> n \\<Longrightarrow>\n    list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  length xs' = n\n\ngoal (1 subgoal):\n 1. list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)", "unfolding id1 id2 Let_def len"], ["proof (prove)\nusing this:\n  length xs' = n\n\ngoal (1 subgoal):\n 1. list_all2 poly_rel\n     (if length xs' = n then xs\n      else case List.partition (\\<lambda>q. degree_i q = d) facts of\n           (lin, nonlin) \\<Rightarrow>\n             lin @\n             berlekamp_factorization_main_i p ff_ops\n              (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d\n              nonlin ys (n - length lin))\n     (if length xs' = n then xs'\n      else case List.partition (\\<lambda>q. degree q = d) facts' of\n           (lin, nonlin) \\<Rightarrow>\n             lin @\n             berlekamp_factorization_main d nonlin ys' (n - length lin))", "using trans"], ["proof (prove)\nusing this:\n  length xs' = n\n  poly_rel y y'\n  list_all2 poly_rel ys ys'\n  list_all2 poly_rel xs xs'\n\ngoal (1 subgoal):\n 1. list_all2 poly_rel\n     (if length xs' = n then xs\n      else case List.partition (\\<lambda>q. degree_i q = d) facts of\n           (lin, nonlin) \\<Rightarrow>\n             lin @\n             berlekamp_factorization_main_i p ff_ops\n              (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d\n              nonlin ys (n - length lin))\n     (if length xs' = n then xs'\n      else case List.partition (\\<lambda>q. degree q = d) facts' of\n           (lin, nonlin) \\<Rightarrow>\n             lin @\n             berlekamp_factorization_main d nonlin ys' (n - length lin))", "by simp"], ["proof (state)\nthis:\n  list_all2 poly_rel\n   (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n     (arith_ops_record.one ff_ops) d xs (y # ys) n)\n   (berlekamp_factorization_main d xs' (y' # ys') n)\n\ngoal (1 subgoal):\n 1. length xs' \\<noteq> n \\<Longrightarrow>\n    list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length xs' \\<noteq> n \\<Longrightarrow>\n    list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)", "case False"], ["proof (state)\nthis:\n  length xs' \\<noteq> n\n\ngoal (1 subgoal):\n 1. length xs' \\<noteq> n \\<Longrightarrow>\n    list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)", "hence id: \"(length xs' = n) = False\""], ["proof (prove)\nusing this:\n  length xs' \\<noteq> n\n\ngoal (1 subgoal):\n 1. (length xs' = n) = False", "by simp"], ["proof (state)\nthis:\n  (length xs' = n) = False\n\ngoal (1 subgoal):\n 1. length xs' \\<noteq> n \\<Longrightarrow>\n    list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)", "have id': \"length [q\\<leftarrow>facts . degree_i q = d] = length [q\\<leftarrow>facts'. degree q = d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>q. degree_i q = d) facts) =\n    length (filter (\\<lambda>q. degree q = d) facts')", "by transfer_prover"], ["proof (state)\nthis:\n  length (filter (\\<lambda>q. degree_i q = d) facts) =\n  length (filter (\\<lambda>q. degree q = d) facts')\n\ngoal (1 subgoal):\n 1. length xs' \\<noteq> n \\<Longrightarrow>\n    list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)", "have [transfer_rule]: \"list_all2 poly_rel (berlekamp_factorization_main_i p ff_ops ?ze ?on d [x\\<leftarrow>facts . degree_i x \\<noteq> d] ys\n         (n - length [q\\<leftarrow>facts . degree_i q = d])) \n         (berlekamp_factorization_main d [x\\<leftarrow>facts' . degree x \\<noteq> d] ys'\n         (n - length [q\\<leftarrow>facts' . degree q = d]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d\n       (filter (\\<lambda>x. degree_i x \\<noteq> d) facts) ys\n       (n - length (filter (\\<lambda>q. degree_i q = d) facts)))\n     (berlekamp_factorization_main d\n       (filter (\\<lambda>x. degree x \\<noteq> d) facts') ys'\n       (n - length (filter (\\<lambda>q. degree q = d) facts')))", "unfolding id'"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d\n       (filter (\\<lambda>x. degree_i x \\<noteq> d) facts) ys\n       (n - length (filter (\\<lambda>q. degree q = d) facts')))\n     (berlekamp_factorization_main d\n       (filter (\\<lambda>x. degree x \\<noteq> d) facts') ys'\n       (n - length (filter (\\<lambda>q. degree q = d) facts')))", "by (rule Cons(3), transfer_prover)"], ["proof (state)\nthis:\n  list_all2 poly_rel\n   (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n     (arith_ops_record.one ff_ops) d\n     (filter (\\<lambda>x. degree_i x \\<noteq> d) facts) ys\n     (n - length (filter (\\<lambda>q. degree_i q = d) facts)))\n   (berlekamp_factorization_main d\n     (filter (\\<lambda>x. degree x \\<noteq> d) facts') ys'\n     (n - length (filter (\\<lambda>q. degree q = d) facts')))\n\ngoal (1 subgoal):\n 1. length xs' \\<noteq> n \\<Longrightarrow>\n    list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 poly_rel\n     (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d xs (y # ys) n)\n     (berlekamp_factorization_main d xs' (y' # ys') n)", "unfolding id1 id2 Let_def len id if_False"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 poly_rel\n     (case List.partition (\\<lambda>q. degree_i q = d) facts of\n      (lin, nonlin) \\<Rightarrow>\n        lin @\n        berlekamp_factorization_main_i p ff_ops\n         (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d\n         nonlin ys (n - length lin))\n     (case List.partition (\\<lambda>q. degree q = d) facts' of\n      (lin, nonlin) \\<Rightarrow>\n        lin @ berlekamp_factorization_main d nonlin ys' (n - length lin))", "unfolding partition_filter_conv o_def split"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 poly_rel\n     (filter (\\<lambda>q. degree_i q = d) facts @\n      berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) d\n       (filter (\\<lambda>x. degree_i x \\<noteq> d) facts) ys\n       (n - length (filter (\\<lambda>q. degree_i q = d) facts)))\n     (filter (\\<lambda>q. degree q = d) facts' @\n      berlekamp_factorization_main d\n       (filter (\\<lambda>x. degree x \\<noteq> d) facts') ys'\n       (n - length (filter (\\<lambda>q. degree q = d) facts')))", "by transfer_prover"], ["proof (state)\nthis:\n  list_all2 poly_rel\n   (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n     (arith_ops_record.one ff_ops) d xs (y # ys) n)\n   (berlekamp_factorization_main d xs' (y' # ys') n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all2 poly_rel\n   (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n     (arith_ops_record.one ff_ops) d xs (y # ys) n)\n   (berlekamp_factorization_main d xs' (y' # ys') n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all2 poly_rel\n   (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n     (arith_ops_record.one ff_ops) d xs (y # ys) n)\n   (berlekamp_factorization_main d xs' (y' # ys') n)\n\ngoal (1 subgoal):\n 1. \\<And>xs xs' n.\n       list_all2 poly_rel xs xs' \\<Longrightarrow>\n       list_all2 poly_rel\n        (berlekamp_factorization_main_i p ff_ops\n          (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d xs\n          [] n)\n        (berlekamp_factorization_main d xs' [] n)", "qed simp"], ["proof (state)\nthis:\n  list_all2 poly_rel\n   (berlekamp_factorization_main_i p ff_ops (arith_ops_record.zero ff_ops)\n     (arith_ops_record.one ff_ops) d xs ys n)\n   (berlekamp_factorization_main d xs' ys' n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma berlekamp_monic_factorization_i[transfer_rule]: \n  \"((=) ===> poly_rel ===> list_all2 poly_rel) \n     (berlekamp_monic_factorization_i p ff_ops) berlekamp_monic_factorization\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> poly_rel ===> list_all2 poly_rel)\n     (berlekamp_monic_factorization_i p ff_ops)\n     berlekamp_monic_factorization", "unfolding berlekamp_monic_factorization_i_def[abs_def] berlekamp_monic_factorization_def[abs_def] Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> poly_rel ===> list_all2 poly_rel)\n     (\\<lambda>d f.\n         berlekamp_factorization_main_i p ff_ops\n          (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) d [f]\n          (berlekamp_basis_i p ff_ops f)\n          (length (berlekamp_basis_i p ff_ops f)))\n     (\\<lambda>d f.\n         berlekamp_factorization_main d [f] (berlekamp_basis f)\n          (length (berlekamp_basis f)))", "by transfer_prover"], ["", "lemma dist_degree_factorize_main_i: \n  \"poly_rel F f \\<Longrightarrow> poly_rel G g \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel) Res res \n   \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel) \n      (dist_degree_factorize_main_i p ff_ops \n         (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops) (degree_i F) F G d Res)\n      (dist_degree_factorize_main f g d res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly_rel F f; poly_rel G g;\n     list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n    \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                       (dist_degree_factorize_main_i p ff_ops\n                         (arith_ops_record.zero ff_ops)\n                         (arith_ops_record.one ff_ops) (degree_i F) F G d\n                         Res)\n                       (dist_degree_factorize_main f g d res)", "proof (induct f g d res arbitrary: F G Res rule: dist_degree_factorize_main.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v w d res F G Res.\n       \\<lbrakk>\\<And>x xa xb F G Res.\n                   \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n                    x = w ^ CARD('a) mod v; xa = Suc d;\n                    xb = gcd (x - monom 1 1) v; xb = 1; poly_rel F v;\n                    poly_rel G x;\n                    list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n                   \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n(dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n  (arith_ops_record.one ff_ops) (degree_i F) F G xa Res)\n(dist_degree_factorize_main v x xa res);\n        \\<And>x xa xb xc F G Res.\n           \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n            x = w ^ CARD('a) mod v; xa = Suc d; xb = gcd (x - monom 1 1) v;\n            xb \\<noteq> 1; xc = v div xb; poly_rel F xc;\n            poly_rel G (x mod xc);\n            list_all2 (rel_prod (=) poly_rel) Res ((xa, xb) # res)\\<rbrakk>\n           \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                              (dist_degree_factorize_main_i p ff_ops\n                                (arith_ops_record.zero ff_ops)\n                                (arith_ops_record.one ff_ops) (degree_i F) F\n                                G xa Res)\n                              (dist_degree_factorize_main xc (x mod xc) xa\n                                ((xa, xb) # res));\n        poly_rel F v; poly_rel G w;\n        list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                          (dist_degree_factorize_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) (degree_i F) F G d\n                            Res)\n                          (dist_degree_factorize_main v w d res)", "case (1 v w d res V W Res)"], ["proof (state)\nthis:\n  \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d; ?x = w ^ CARD('a) mod v;\n   ?xa = Suc d; ?xb = gcd (?x - monom 1 1) v; ?xb = 1; poly_rel ?F v;\n   poly_rel ?G ?x; list_all2 (rel_prod (=) poly_rel) ?Res res\\<rbrakk>\n  \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                     (dist_degree_factorize_main_i p ff_ops\n                       (arith_ops_record.zero ff_ops)\n                       (arith_ops_record.one ff_ops) (degree_i ?F) ?F ?G ?xa\n                       ?Res)\n                     (dist_degree_factorize_main v ?x ?xa res)\n  \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d; ?x = w ^ CARD('a) mod v;\n   ?xa = Suc d; ?xb = gcd (?x - monom 1 1) v; ?xb \\<noteq> 1;\n   ?xc = v div ?xb; poly_rel ?F ?xc; poly_rel ?G (?x mod ?xc);\n   list_all2 (rel_prod (=) poly_rel) ?Res ((?xa, ?xb) # res)\\<rbrakk>\n  \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                     (dist_degree_factorize_main_i p ff_ops\n                       (arith_ops_record.zero ff_ops)\n                       (arith_ops_record.one ff_ops) (degree_i ?F) ?F ?G ?xa\n                       ?Res)\n                     (dist_degree_factorize_main ?xc (?x mod ?xc) ?xa\n                       ((?xa, ?xb) # res))\n  poly_rel V v\n  poly_rel W w\n  list_all2 (rel_prod (=) poly_rel) Res res\n\ngoal (1 subgoal):\n 1. \\<And>v w d res F G Res.\n       \\<lbrakk>\\<And>x xa xb F G Res.\n                   \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n                    x = w ^ CARD('a) mod v; xa = Suc d;\n                    xb = gcd (x - monom 1 1) v; xb = 1; poly_rel F v;\n                    poly_rel G x;\n                    list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n                   \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n(dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n  (arith_ops_record.one ff_ops) (degree_i F) F G xa Res)\n(dist_degree_factorize_main v x xa res);\n        \\<And>x xa xb xc F G Res.\n           \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n            x = w ^ CARD('a) mod v; xa = Suc d; xb = gcd (x - monom 1 1) v;\n            xb \\<noteq> 1; xc = v div xb; poly_rel F xc;\n            poly_rel G (x mod xc);\n            list_all2 (rel_prod (=) poly_rel) Res ((xa, xb) # res)\\<rbrakk>\n           \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                              (dist_degree_factorize_main_i p ff_ops\n                                (arith_ops_record.zero ff_ops)\n                                (arith_ops_record.one ff_ops) (degree_i F) F\n                                G xa Res)\n                              (dist_degree_factorize_main xc (x mod xc) xa\n                                ((xa, xb) # res));\n        poly_rel F v; poly_rel G w;\n        list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                          (dist_degree_factorize_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) (degree_i F) F G d\n                            Res)\n                          (dist_degree_factorize_main v w d res)", "let ?ze = \"arith_ops_record.zero ff_ops\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v w d res F G Res.\n       \\<lbrakk>\\<And>x xa xb F G Res.\n                   \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n                    x = w ^ CARD('a) mod v; xa = Suc d;\n                    xb = gcd (x - monom 1 1) v; xb = 1; poly_rel F v;\n                    poly_rel G x;\n                    list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n                   \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n(dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n  (arith_ops_record.one ff_ops) (degree_i F) F G xa Res)\n(dist_degree_factorize_main v x xa res);\n        \\<And>x xa xb xc F G Res.\n           \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n            x = w ^ CARD('a) mod v; xa = Suc d; xb = gcd (x - monom 1 1) v;\n            xb \\<noteq> 1; xc = v div xb; poly_rel F xc;\n            poly_rel G (x mod xc);\n            list_all2 (rel_prod (=) poly_rel) Res ((xa, xb) # res)\\<rbrakk>\n           \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                              (dist_degree_factorize_main_i p ff_ops\n                                (arith_ops_record.zero ff_ops)\n                                (arith_ops_record.one ff_ops) (degree_i F) F\n                                G xa Res)\n                              (dist_degree_factorize_main xc (x mod xc) xa\n                                ((xa, xb) # res));\n        poly_rel F v; poly_rel G w;\n        list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                          (dist_degree_factorize_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) (degree_i F) F G d\n                            Res)\n                          (dist_degree_factorize_main v w d res)", "let ?on = \"arith_ops_record.one ff_ops\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v w d res F G Res.\n       \\<lbrakk>\\<And>x xa xb F G Res.\n                   \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n                    x = w ^ CARD('a) mod v; xa = Suc d;\n                    xb = gcd (x - monom 1 1) v; xb = 1; poly_rel F v;\n                    poly_rel G x;\n                    list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n                   \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n(dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n  (arith_ops_record.one ff_ops) (degree_i F) F G xa Res)\n(dist_degree_factorize_main v x xa res);\n        \\<And>x xa xb xc F G Res.\n           \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n            x = w ^ CARD('a) mod v; xa = Suc d; xb = gcd (x - monom 1 1) v;\n            xb \\<noteq> 1; xc = v div xb; poly_rel F xc;\n            poly_rel G (x mod xc);\n            list_all2 (rel_prod (=) poly_rel) Res ((xa, xb) # res)\\<rbrakk>\n           \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                              (dist_degree_factorize_main_i p ff_ops\n                                (arith_ops_record.zero ff_ops)\n                                (arith_ops_record.one ff_ops) (degree_i F) F\n                                G xa Res)\n                              (dist_degree_factorize_main xc (x mod xc) xa\n                                ((xa, xb) # res));\n        poly_rel F v; poly_rel G w;\n        list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                          (dist_degree_factorize_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) (degree_i F) F G d\n                            Res)\n                          (dist_degree_factorize_main v w d res)", "note simp = dist_degree_factorize_main.simps[of v w d] \n    dist_degree_factorize_main_i.simps[of p ff_ops ?ze ?on \"degree_i V\" V W d]"], ["proof (state)\nthis:\n  dist_degree_factorize_main v w d ?res =\n  (if v = 1 then ?res\n   else if degree v < d + d then (degree v, v) # ?res\n        else let w = w ^ CARD('a) mod v; d = Suc d;\n                 gd = gcd (w - monom 1 1) v\n             in if gd = 1 then dist_degree_factorize_main v w d ?res\n                else let v' = v div gd\n                     in dist_degree_factorize_main v' (w mod v') d\n                         ((d, gd) # ?res))\n  dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n   (arith_ops_record.one ff_ops) (degree_i V) V W d ?res =\n  (if V = [arith_ops_record.one ff_ops] then ?res\n   else if degree_i V < d + d then (degree_i V, V) # ?res\n        else let w = power_poly_f_mod_i ff_ops\n                      (\\<lambda>f. mod_field_poly_i ff_ops f V) W (nat p);\n                 d = Suc d;\n                 gd = gcd_poly_i ff_ops\n                       (minus_poly_i ff_ops w\n                         [arith_ops_record.zero ff_ops,\n                          arith_ops_record.one ff_ops])\n                       V\n             in if gd = [arith_ops_record.one ff_ops]\n                then dist_degree_factorize_main_i p ff_ops\n                      (arith_ops_record.zero ff_ops)\n                      (arith_ops_record.one ff_ops) (degree_i V) V w d ?res\n                else let v' = div_field_poly_i ff_ops V gd\n                     in dist_degree_factorize_main_i p ff_ops\n                         (arith_ops_record.zero ff_ops)\n                         (arith_ops_record.one ff_ops) (degree_i v') v'\n                         (mod_field_poly_i ff_ops w v') d ((d, gd) # ?res))\n\ngoal (1 subgoal):\n 1. \\<And>v w d res F G Res.\n       \\<lbrakk>\\<And>x xa xb F G Res.\n                   \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n                    x = w ^ CARD('a) mod v; xa = Suc d;\n                    xb = gcd (x - monom 1 1) v; xb = 1; poly_rel F v;\n                    poly_rel G x;\n                    list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n                   \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n(dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n  (arith_ops_record.one ff_ops) (degree_i F) F G xa Res)\n(dist_degree_factorize_main v x xa res);\n        \\<And>x xa xb xc F G Res.\n           \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n            x = w ^ CARD('a) mod v; xa = Suc d; xb = gcd (x - monom 1 1) v;\n            xb \\<noteq> 1; xc = v div xb; poly_rel F xc;\n            poly_rel G (x mod xc);\n            list_all2 (rel_prod (=) poly_rel) Res ((xa, xb) # res)\\<rbrakk>\n           \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                              (dist_degree_factorize_main_i p ff_ops\n                                (arith_ops_record.zero ff_ops)\n                                (arith_ops_record.one ff_ops) (degree_i F) F\n                                G xa Res)\n                              (dist_degree_factorize_main xc (x mod xc) xa\n                                ((xa, xb) # res));\n        poly_rel F v; poly_rel G w;\n        list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                          (dist_degree_factorize_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) (degree_i F) F G d\n                            Res)\n                          (dist_degree_factorize_main v w d res)", "have v[transfer_rule]: \"poly_rel V v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel V v", "by (rule 1)"], ["proof (state)\nthis:\n  poly_rel V v\n\ngoal (1 subgoal):\n 1. \\<And>v w d res F G Res.\n       \\<lbrakk>\\<And>x xa xb F G Res.\n                   \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n                    x = w ^ CARD('a) mod v; xa = Suc d;\n                    xb = gcd (x - monom 1 1) v; xb = 1; poly_rel F v;\n                    poly_rel G x;\n                    list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n                   \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n(dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n  (arith_ops_record.one ff_ops) (degree_i F) F G xa Res)\n(dist_degree_factorize_main v x xa res);\n        \\<And>x xa xb xc F G Res.\n           \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n            x = w ^ CARD('a) mod v; xa = Suc d; xb = gcd (x - monom 1 1) v;\n            xb \\<noteq> 1; xc = v div xb; poly_rel F xc;\n            poly_rel G (x mod xc);\n            list_all2 (rel_prod (=) poly_rel) Res ((xa, xb) # res)\\<rbrakk>\n           \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                              (dist_degree_factorize_main_i p ff_ops\n                                (arith_ops_record.zero ff_ops)\n                                (arith_ops_record.one ff_ops) (degree_i F) F\n                                G xa Res)\n                              (dist_degree_factorize_main xc (x mod xc) xa\n                                ((xa, xb) # res));\n        poly_rel F v; poly_rel G w;\n        list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                          (dist_degree_factorize_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) (degree_i F) F G d\n                            Res)\n                          (dist_degree_factorize_main v w d res)", "have w[transfer_rule]: \"poly_rel W w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel W w", "by (rule 1)"], ["proof (state)\nthis:\n  poly_rel W w\n\ngoal (1 subgoal):\n 1. \\<And>v w d res F G Res.\n       \\<lbrakk>\\<And>x xa xb F G Res.\n                   \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n                    x = w ^ CARD('a) mod v; xa = Suc d;\n                    xb = gcd (x - monom 1 1) v; xb = 1; poly_rel F v;\n                    poly_rel G x;\n                    list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n                   \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n(dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n  (arith_ops_record.one ff_ops) (degree_i F) F G xa Res)\n(dist_degree_factorize_main v x xa res);\n        \\<And>x xa xb xc F G Res.\n           \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n            x = w ^ CARD('a) mod v; xa = Suc d; xb = gcd (x - monom 1 1) v;\n            xb \\<noteq> 1; xc = v div xb; poly_rel F xc;\n            poly_rel G (x mod xc);\n            list_all2 (rel_prod (=) poly_rel) Res ((xa, xb) # res)\\<rbrakk>\n           \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                              (dist_degree_factorize_main_i p ff_ops\n                                (arith_ops_record.zero ff_ops)\n                                (arith_ops_record.one ff_ops) (degree_i F) F\n                                G xa Res)\n                              (dist_degree_factorize_main xc (x mod xc) xa\n                                ((xa, xb) # res));\n        poly_rel F v; poly_rel G w;\n        list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                          (dist_degree_factorize_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) (degree_i F) F G d\n                            Res)\n                          (dist_degree_factorize_main v w d res)", "have res[transfer_rule]: \"list_all2 (rel_prod (=) poly_rel) Res res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (rel_prod (=) poly_rel) Res res", "by (rule 1)"], ["proof (state)\nthis:\n  list_all2 (rel_prod (=) poly_rel) Res res\n\ngoal (1 subgoal):\n 1. \\<And>v w d res F G Res.\n       \\<lbrakk>\\<And>x xa xb F G Res.\n                   \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n                    x = w ^ CARD('a) mod v; xa = Suc d;\n                    xb = gcd (x - monom 1 1) v; xb = 1; poly_rel F v;\n                    poly_rel G x;\n                    list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n                   \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n(dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n  (arith_ops_record.one ff_ops) (degree_i F) F G xa Res)\n(dist_degree_factorize_main v x xa res);\n        \\<And>x xa xb xc F G Res.\n           \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n            x = w ^ CARD('a) mod v; xa = Suc d; xb = gcd (x - monom 1 1) v;\n            xb \\<noteq> 1; xc = v div xb; poly_rel F xc;\n            poly_rel G (x mod xc);\n            list_all2 (rel_prod (=) poly_rel) Res ((xa, xb) # res)\\<rbrakk>\n           \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                              (dist_degree_factorize_main_i p ff_ops\n                                (arith_ops_record.zero ff_ops)\n                                (arith_ops_record.one ff_ops) (degree_i F) F\n                                G xa Res)\n                              (dist_degree_factorize_main xc (x mod xc) xa\n                                ((xa, xb) # res));\n        poly_rel F v; poly_rel G w;\n        list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                          (dist_degree_factorize_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) (degree_i F) F G d\n                            Res)\n                          (dist_degree_factorize_main v w d res)", "have [transfer_rule]: \"poly_rel [?on] 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel [arith_ops_record.one ff_ops] 1", "by (simp add: one poly_rel_def)"], ["proof (state)\nthis:\n  poly_rel [arith_ops_record.one ff_ops] 1\n\ngoal (1 subgoal):\n 1. \\<And>v w d res F G Res.\n       \\<lbrakk>\\<And>x xa xb F G Res.\n                   \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n                    x = w ^ CARD('a) mod v; xa = Suc d;\n                    xb = gcd (x - monom 1 1) v; xb = 1; poly_rel F v;\n                    poly_rel G x;\n                    list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n                   \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n(dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n  (arith_ops_record.one ff_ops) (degree_i F) F G xa Res)\n(dist_degree_factorize_main v x xa res);\n        \\<And>x xa xb xc F G Res.\n           \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n            x = w ^ CARD('a) mod v; xa = Suc d; xb = gcd (x - monom 1 1) v;\n            xb \\<noteq> 1; xc = v div xb; poly_rel F xc;\n            poly_rel G (x mod xc);\n            list_all2 (rel_prod (=) poly_rel) Res ((xa, xb) # res)\\<rbrakk>\n           \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                              (dist_degree_factorize_main_i p ff_ops\n                                (arith_ops_record.zero ff_ops)\n                                (arith_ops_record.one ff_ops) (degree_i F) F\n                                G xa Res)\n                              (dist_degree_factorize_main xc (x mod xc) xa\n                                ((xa, xb) # res));\n        poly_rel F v; poly_rel G w;\n        list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                          (dist_degree_factorize_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) (degree_i F) F G d\n                            Res)\n                          (dist_degree_factorize_main v w d res)", "have id1: \"(V = [?on]) = (v = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (V = [arith_ops_record.one ff_ops]) = (v = 1)", "unfolding finite_field_ops_int_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (V = [arith_ops_record.one ff_ops]) = (v = 1)", "by transfer_prover"], ["proof (state)\nthis:\n  (V = [arith_ops_record.one ff_ops]) = (v = 1)\n\ngoal (1 subgoal):\n 1. \\<And>v w d res F G Res.\n       \\<lbrakk>\\<And>x xa xb F G Res.\n                   \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n                    x = w ^ CARD('a) mod v; xa = Suc d;\n                    xb = gcd (x - monom 1 1) v; xb = 1; poly_rel F v;\n                    poly_rel G x;\n                    list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n                   \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n(dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n  (arith_ops_record.one ff_ops) (degree_i F) F G xa Res)\n(dist_degree_factorize_main v x xa res);\n        \\<And>x xa xb xc F G Res.\n           \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n            x = w ^ CARD('a) mod v; xa = Suc d; xb = gcd (x - monom 1 1) v;\n            xb \\<noteq> 1; xc = v div xb; poly_rel F xc;\n            poly_rel G (x mod xc);\n            list_all2 (rel_prod (=) poly_rel) Res ((xa, xb) # res)\\<rbrakk>\n           \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                              (dist_degree_factorize_main_i p ff_ops\n                                (arith_ops_record.zero ff_ops)\n                                (arith_ops_record.one ff_ops) (degree_i F) F\n                                G xa Res)\n                              (dist_degree_factorize_main xc (x mod xc) xa\n                                ((xa, xb) # res));\n        poly_rel F v; poly_rel G w;\n        list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                          (dist_degree_factorize_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) (degree_i F) F G d\n                            Res)\n                          (dist_degree_factorize_main v w d res)", "have id2: \"degree_i V = degree v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_i V = degree v", "by transfer_prover"], ["proof (state)\nthis:\n  degree_i V = degree v\n\ngoal (1 subgoal):\n 1. \\<And>v w d res F G Res.\n       \\<lbrakk>\\<And>x xa xb F G Res.\n                   \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n                    x = w ^ CARD('a) mod v; xa = Suc d;\n                    xb = gcd (x - monom 1 1) v; xb = 1; poly_rel F v;\n                    poly_rel G x;\n                    list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n                   \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n(dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n  (arith_ops_record.one ff_ops) (degree_i F) F G xa Res)\n(dist_degree_factorize_main v x xa res);\n        \\<And>x xa xb xc F G Res.\n           \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n            x = w ^ CARD('a) mod v; xa = Suc d; xb = gcd (x - monom 1 1) v;\n            xb \\<noteq> 1; xc = v div xb; poly_rel F xc;\n            poly_rel G (x mod xc);\n            list_all2 (rel_prod (=) poly_rel) Res ((xa, xb) # res)\\<rbrakk>\n           \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                              (dist_degree_factorize_main_i p ff_ops\n                                (arith_ops_record.zero ff_ops)\n                                (arith_ops_record.one ff_ops) (degree_i F) F\n                                G xa Res)\n                              (dist_degree_factorize_main xc (x mod xc) xa\n                                ((xa, xb) # res));\n        poly_rel F v; poly_rel G w;\n        list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                          (dist_degree_factorize_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) (degree_i F) F G d\n                            Res)\n                          (dist_degree_factorize_main v w d res)", "note simp = simp[unfolded id1 id2]"], ["proof (state)\nthis:\n  dist_degree_factorize_main v w d ?res =\n  (if v = 1 then ?res\n   else if degree v < d + d then (degree v, v) # ?res\n        else let w = w ^ CARD('a) mod v; d = Suc d;\n                 gd = gcd (w - monom 1 1) v\n             in if gd = 1 then dist_degree_factorize_main v w d ?res\n                else let v' = v div gd\n                     in dist_degree_factorize_main v' (w mod v') d\n                         ((d, gd) # ?res))\n  dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n   (arith_ops_record.one ff_ops) (degree v) V W d ?res =\n  (if v = 1 then ?res\n   else if degree v < d + d then (degree v, V) # ?res\n        else let w = power_poly_f_mod_i ff_ops\n                      (\\<lambda>f. mod_field_poly_i ff_ops f V) W (nat p);\n                 d = Suc d;\n                 gd = gcd_poly_i ff_ops\n                       (minus_poly_i ff_ops w\n                         [arith_ops_record.zero ff_ops,\n                          arith_ops_record.one ff_ops])\n                       V\n             in if gd = [arith_ops_record.one ff_ops]\n                then dist_degree_factorize_main_i p ff_ops\n                      (arith_ops_record.zero ff_ops)\n                      (arith_ops_record.one ff_ops) (degree v) V w d ?res\n                else let v' = div_field_poly_i ff_ops V gd\n                     in dist_degree_factorize_main_i p ff_ops\n                         (arith_ops_record.zero ff_ops)\n                         (arith_ops_record.one ff_ops) (degree_i v') v'\n                         (mod_field_poly_i ff_ops w v') d ((d, gd) # ?res))\n\ngoal (1 subgoal):\n 1. \\<And>v w d res F G Res.\n       \\<lbrakk>\\<And>x xa xb F G Res.\n                   \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n                    x = w ^ CARD('a) mod v; xa = Suc d;\n                    xb = gcd (x - monom 1 1) v; xb = 1; poly_rel F v;\n                    poly_rel G x;\n                    list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n                   \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n(dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n  (arith_ops_record.one ff_ops) (degree_i F) F G xa Res)\n(dist_degree_factorize_main v x xa res);\n        \\<And>x xa xb xc F G Res.\n           \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n            x = w ^ CARD('a) mod v; xa = Suc d; xb = gcd (x - monom 1 1) v;\n            xb \\<noteq> 1; xc = v div xb; poly_rel F xc;\n            poly_rel G (x mod xc);\n            list_all2 (rel_prod (=) poly_rel) Res ((xa, xb) # res)\\<rbrakk>\n           \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                              (dist_degree_factorize_main_i p ff_ops\n                                (arith_ops_record.zero ff_ops)\n                                (arith_ops_record.one ff_ops) (degree_i F) F\n                                G xa Res)\n                              (dist_degree_factorize_main xc (x mod xc) xa\n                                ((xa, xb) # res));\n        poly_rel F v; poly_rel G w;\n        list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                          (dist_degree_factorize_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) (degree_i F) F G d\n                            Res)\n                          (dist_degree_factorize_main v w d res)", "note IH = 1(1,2)"], ["proof (state)\nthis:\n  \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d; ?x = w ^ CARD('a) mod v;\n   ?xa = Suc d; ?xb = gcd (?x - monom 1 1) v; ?xb = 1; poly_rel ?F v;\n   poly_rel ?G ?x; list_all2 (rel_prod (=) poly_rel) ?Res res\\<rbrakk>\n  \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                     (dist_degree_factorize_main_i p ff_ops\n                       (arith_ops_record.zero ff_ops)\n                       (arith_ops_record.one ff_ops) (degree_i ?F) ?F ?G ?xa\n                       ?Res)\n                     (dist_degree_factorize_main v ?x ?xa res)\n  \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d; ?x = w ^ CARD('a) mod v;\n   ?xa = Suc d; ?xb = gcd (?x - monom 1 1) v; ?xb \\<noteq> 1;\n   ?xc = v div ?xb; poly_rel ?F ?xc; poly_rel ?G (?x mod ?xc);\n   list_all2 (rel_prod (=) poly_rel) ?Res ((?xa, ?xb) # res)\\<rbrakk>\n  \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                     (dist_degree_factorize_main_i p ff_ops\n                       (arith_ops_record.zero ff_ops)\n                       (arith_ops_record.one ff_ops) (degree_i ?F) ?F ?G ?xa\n                       ?Res)\n                     (dist_degree_factorize_main ?xc (?x mod ?xc) ?xa\n                       ((?xa, ?xb) # res))\n\ngoal (1 subgoal):\n 1. \\<And>v w d res F G Res.\n       \\<lbrakk>\\<And>x xa xb F G Res.\n                   \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n                    x = w ^ CARD('a) mod v; xa = Suc d;\n                    xb = gcd (x - monom 1 1) v; xb = 1; poly_rel F v;\n                    poly_rel G x;\n                    list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n                   \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n(dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n  (arith_ops_record.one ff_ops) (degree_i F) F G xa Res)\n(dist_degree_factorize_main v x xa res);\n        \\<And>x xa xb xc F G Res.\n           \\<lbrakk>v \\<noteq> 1; \\<not> degree v < d + d;\n            x = w ^ CARD('a) mod v; xa = Suc d; xb = gcd (x - monom 1 1) v;\n            xb \\<noteq> 1; xc = v div xb; poly_rel F xc;\n            poly_rel G (x mod xc);\n            list_all2 (rel_prod (=) poly_rel) Res ((xa, xb) # res)\\<rbrakk>\n           \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                              (dist_degree_factorize_main_i p ff_ops\n                                (arith_ops_record.zero ff_ops)\n                                (arith_ops_record.one ff_ops) (degree_i F) F\n                                G xa Res)\n                              (dist_degree_factorize_main xc (x mod xc) xa\n                                ((xa, xb) # res));\n        poly_rel F v; poly_rel G w;\n        list_all2 (rel_prod (=) poly_rel) Res res\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                          (dist_degree_factorize_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) (degree_i F) F G d\n                            Res)\n                          (dist_degree_factorize_main v w d res)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "proof (cases \"v = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "case True"], ["proof (state)\nthis:\n  v = 1\n\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)\n 2. v \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "with res"], ["proof (chain)\npicking this:\n  list_all2 (rel_prod (=) poly_rel) Res res\n  v = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  list_all2 (rel_prod (=) poly_rel) Res res\n  v = 1\n\ngoal (1 subgoal):\n 1. list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "unfolding id2 simp"], ["proof (prove)\nusing this:\n  list_all2 (rel_prod (=) poly_rel) Res res\n  v = 1\n\ngoal (1 subgoal):\n 1. list_all2 (rel_prod (=) poly_rel)\n     (if v = 1 then Res\n      else if degree v < d + d then (degree v, V) # Res\n           else let w = power_poly_f_mod_i ff_ops\n                         (\\<lambda>f. mod_field_poly_i ff_ops f V) W\n                         (nat p);\n                    d = Suc d;\n                    gd = gcd_poly_i ff_ops\n                          (minus_poly_i ff_ops w\n                            [arith_ops_record.zero ff_ops,\n                             arith_ops_record.one ff_ops])\n                          V\n                in if gd = [arith_ops_record.one ff_ops]\n                   then dist_degree_factorize_main_i p ff_ops\n                         (arith_ops_record.zero ff_ops)\n                         (arith_ops_record.one ff_ops) (degree v) V w d Res\n                   else let v' = div_field_poly_i ff_ops V gd\n                        in dist_degree_factorize_main_i p ff_ops\n                            (arith_ops_record.zero ff_ops)\n                            (arith_ops_record.one ff_ops) (degree_i v') v'\n                            (mod_field_poly_i ff_ops w v') d\n                            ((d, gd) # Res))\n     (if v = 1 then res\n      else if degree v < d + d then (degree v, v) # res\n           else let w = w ^ CARD('a) mod v; d = Suc d;\n                    gd = gcd (w - monom 1 1) v\n                in if gd = 1 then dist_degree_factorize_main v w d res\n                   else let v' = v div gd\n                        in dist_degree_factorize_main v' (w mod v') d\n                            ((d, gd) # res))", "by simp"], ["proof (state)\nthis:\n  list_all2 (rel_prod (=) poly_rel)\n   (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n     (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n   (dist_degree_factorize_main v w d res)\n\ngoal (1 subgoal):\n 1. v \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "case False"], ["proof (state)\nthis:\n  v \\<noteq> 1\n\ngoal (1 subgoal):\n 1. v \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "with id1"], ["proof (chain)\npicking this:\n  (V = [arith_ops_record.one ff_ops]) = (v = 1)\n  v \\<noteq> 1", "have \"(v = 1) = False\""], ["proof (prove)\nusing this:\n  (V = [arith_ops_record.one ff_ops]) = (v = 1)\n  v \\<noteq> 1\n\ngoal (1 subgoal):\n 1. (v = 1) = False", "by auto"], ["proof (state)\nthis:\n  (v = 1) = False\n\ngoal (1 subgoal):\n 1. v \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "note simp = simp[unfolded this if_False]"], ["proof (state)\nthis:\n  dist_degree_factorize_main v w d ?res =\n  (if degree v < d + d then (degree v, v) # ?res\n   else let w = w ^ CARD('a) mod v; d = Suc d; gd = gcd (w - monom 1 1) v\n        in if gd = 1 then dist_degree_factorize_main v w d ?res\n           else let v' = v div gd\n                in dist_degree_factorize_main v' (w mod v') d\n                    ((d, gd) # ?res))\n  dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n   (arith_ops_record.one ff_ops) (degree v) V W d ?res =\n  (if degree v < d + d then (degree v, V) # ?res\n   else let w = power_poly_f_mod_i ff_ops\n                 (\\<lambda>f. mod_field_poly_i ff_ops f V) W (nat p);\n            d = Suc d;\n            gd = gcd_poly_i ff_ops\n                  (minus_poly_i ff_ops w\n                    [arith_ops_record.zero ff_ops,\n                     arith_ops_record.one ff_ops])\n                  V\n        in if gd = [arith_ops_record.one ff_ops]\n           then dist_degree_factorize_main_i p ff_ops\n                 (arith_ops_record.zero ff_ops)\n                 (arith_ops_record.one ff_ops) (degree v) V w d ?res\n           else let v' = div_field_poly_i ff_ops V gd\n                in dist_degree_factorize_main_i p ff_ops\n                    (arith_ops_record.zero ff_ops)\n                    (arith_ops_record.one ff_ops) (degree_i v') v'\n                    (mod_field_poly_i ff_ops w v') d ((d, gd) # ?res))\n\ngoal (1 subgoal):\n 1. v \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "note IH = IH[OF False]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> degree v < d + d; ?x = w ^ CARD('a) mod v; ?xa = Suc d;\n   ?xb = gcd (?x - monom 1 1) v; ?xb = 1; poly_rel ?F v; poly_rel ?G ?x;\n   list_all2 (rel_prod (=) poly_rel) ?Res res\\<rbrakk>\n  \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                     (dist_degree_factorize_main_i p ff_ops\n                       (arith_ops_record.zero ff_ops)\n                       (arith_ops_record.one ff_ops) (degree_i ?F) ?F ?G ?xa\n                       ?Res)\n                     (dist_degree_factorize_main v ?x ?xa res)\n  \\<lbrakk>\\<not> degree v < d + d; ?x = w ^ CARD('a) mod v; ?xa = Suc d;\n   ?xb = gcd (?x - monom 1 1) v; ?xb \\<noteq> 1; ?xc = v div ?xb;\n   poly_rel ?F ?xc; poly_rel ?G (?x mod ?xc);\n   list_all2 (rel_prod (=) poly_rel) ?Res ((?xa, ?xb) # res)\\<rbrakk>\n  \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                     (dist_degree_factorize_main_i p ff_ops\n                       (arith_ops_record.zero ff_ops)\n                       (arith_ops_record.one ff_ops) (degree_i ?F) ?F ?G ?xa\n                       ?Res)\n                     (dist_degree_factorize_main ?xc (?x mod ?xc) ?xa\n                       ((?xa, ?xb) # res))\n\ngoal (1 subgoal):\n 1. v \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "proof (cases \"degree v < d + d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree v < d + d \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)\n 2. \\<not> degree v < d + d \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "case True"], ["proof (state)\nthis:\n  degree v < d + d\n\ngoal (2 subgoals):\n 1. degree v < d + d \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)\n 2. \\<not> degree v < d + d \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "thus ?thesis"], ["proof (prove)\nusing this:\n  degree v < d + d\n\ngoal (1 subgoal):\n 1. list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "unfolding id2 simp"], ["proof (prove)\nusing this:\n  degree v < d + d\n\ngoal (1 subgoal):\n 1. list_all2 (rel_prod (=) poly_rel)\n     (if degree v < d + d then (degree v, V) # Res\n      else let w = power_poly_f_mod_i ff_ops\n                    (\\<lambda>f. mod_field_poly_i ff_ops f V) W (nat p);\n               d = Suc d;\n               gd = gcd_poly_i ff_ops\n                     (minus_poly_i ff_ops w\n                       [arith_ops_record.zero ff_ops,\n                        arith_ops_record.one ff_ops])\n                     V\n           in if gd = [arith_ops_record.one ff_ops]\n              then dist_degree_factorize_main_i p ff_ops\n                    (arith_ops_record.zero ff_ops)\n                    (arith_ops_record.one ff_ops) (degree v) V w d Res\n              else let v' = div_field_poly_i ff_ops V gd\n                   in dist_degree_factorize_main_i p ff_ops\n                       (arith_ops_record.zero ff_ops)\n                       (arith_ops_record.one ff_ops) (degree_i v') v'\n                       (mod_field_poly_i ff_ops w v') d ((d, gd) # Res))\n     (if degree v < d + d then (degree v, v) # res\n      else let w = w ^ CARD('a) mod v; d = Suc d; gd = gcd (w - monom 1 1) v\n           in if gd = 1 then dist_degree_factorize_main v w d res\n              else let v' = v div gd\n                   in dist_degree_factorize_main v' (w mod v') d\n                       ((d, gd) # res))", "using res v"], ["proof (prove)\nusing this:\n  degree v < d + d\n  list_all2 (rel_prod (=) poly_rel) Res res\n  poly_rel V v\n\ngoal (1 subgoal):\n 1. list_all2 (rel_prod (=) poly_rel)\n     (if degree v < d + d then (degree v, V) # Res\n      else let w = power_poly_f_mod_i ff_ops\n                    (\\<lambda>f. mod_field_poly_i ff_ops f V) W (nat p);\n               d = Suc d;\n               gd = gcd_poly_i ff_ops\n                     (minus_poly_i ff_ops w\n                       [arith_ops_record.zero ff_ops,\n                        arith_ops_record.one ff_ops])\n                     V\n           in if gd = [arith_ops_record.one ff_ops]\n              then dist_degree_factorize_main_i p ff_ops\n                    (arith_ops_record.zero ff_ops)\n                    (arith_ops_record.one ff_ops) (degree v) V w d Res\n              else let v' = div_field_poly_i ff_ops V gd\n                   in dist_degree_factorize_main_i p ff_ops\n                       (arith_ops_record.zero ff_ops)\n                       (arith_ops_record.one ff_ops) (degree_i v') v'\n                       (mod_field_poly_i ff_ops w v') d ((d, gd) # Res))\n     (if degree v < d + d then (degree v, v) # res\n      else let w = w ^ CARD('a) mod v; d = Suc d; gd = gcd (w - monom 1 1) v\n           in if gd = 1 then dist_degree_factorize_main v w d res\n              else let v' = v div gd\n                   in dist_degree_factorize_main v' (w mod v') d\n                       ((d, gd) # res))", "by auto"], ["proof (state)\nthis:\n  list_all2 (rel_prod (=) poly_rel)\n   (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n     (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n   (dist_degree_factorize_main v w d res)\n\ngoal (1 subgoal):\n 1. \\<not> degree v < d + d \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> degree v < d + d \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "case False"], ["proof (state)\nthis:\n  \\<not> degree v < d + d\n\ngoal (1 subgoal):\n 1. \\<not> degree v < d + d \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "hence \"(degree v < d + d) = False\""], ["proof (prove)\nusing this:\n  \\<not> degree v < d + d\n\ngoal (1 subgoal):\n 1. (degree v < d + d) = False", "by auto"], ["proof (state)\nthis:\n  (degree v < d + d) = False\n\ngoal (1 subgoal):\n 1. \\<not> degree v < d + d \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "note simp = simp[unfolded this if_False]"], ["proof (state)\nthis:\n  dist_degree_factorize_main v w d ?res =\n  (let w = w ^ CARD('a) mod v; d = Suc d; gd = gcd (w - monom 1 1) v\n   in if gd = 1 then dist_degree_factorize_main v w d ?res\n      else let v' = v div gd\n           in dist_degree_factorize_main v' (w mod v') d ((d, gd) # ?res))\n  dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n   (arith_ops_record.one ff_ops) (degree v) V W d ?res =\n  (let w = power_poly_f_mod_i ff_ops\n            (\\<lambda>f. mod_field_poly_i ff_ops f V) W (nat p);\n       d = Suc d;\n       gd = gcd_poly_i ff_ops\n             (minus_poly_i ff_ops w\n               [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops])\n             V\n   in if gd = [arith_ops_record.one ff_ops]\n      then dist_degree_factorize_main_i p ff_ops\n            (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops)\n            (degree v) V w d ?res\n      else let v' = div_field_poly_i ff_ops V gd\n           in dist_degree_factorize_main_i p ff_ops\n               (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops)\n               (degree_i v') v' (mod_field_poly_i ff_ops w v') d\n               ((d, gd) # ?res))\n\ngoal (1 subgoal):\n 1. \\<not> degree v < d + d \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "let ?P = \"power_poly_f_mod_i ff_ops (\\<lambda>f. mod_field_poly_i ff_ops f V) W (nat p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> degree v < d + d \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "let ?G = \"gcd_poly_i ff_ops (minus_poly_i ff_ops ?P [?ze, ?on]) V\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> degree v < d + d \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "let ?g = \"gcd (w ^ CARD('a) mod v - monom 1 1) v\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> degree v < d + d \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "define G where \"G = ?G\""], ["proof (state)\nthis:\n  G =\n  gcd_poly_i ff_ops\n   (minus_poly_i ff_ops\n     (power_poly_f_mod_i ff_ops (\\<lambda>f. mod_field_poly_i ff_ops f V) W\n       (nat p))\n     [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops])\n   V\n\ngoal (1 subgoal):\n 1. \\<not> degree v < d + d \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "define g where \"g = ?g\""], ["proof (state)\nthis:\n  g = gcd (w ^ CARD('a) mod v - monom 1 1) v\n\ngoal (1 subgoal):\n 1. \\<not> degree v < d + d \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "note simp = simp[unfolded Let_def, folded G_def g_def]"], ["proof (state)\nthis:\n  dist_degree_factorize_main v w d ?res =\n  (if g = 1\n   then dist_degree_factorize_main v (w ^ CARD('a) mod v) (Suc d) ?res\n   else dist_degree_factorize_main (v div g)\n         (w ^ CARD('a) mod v mod (v div g)) (Suc d) ((Suc d, g) # ?res))\n  dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n   (arith_ops_record.one ff_ops) (degree v) V W d ?res =\n  (if G = [arith_ops_record.one ff_ops]\n   then dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n         (arith_ops_record.one ff_ops) (degree v) V\n         (power_poly_f_mod_i ff_ops\n           (\\<lambda>f. mod_field_poly_i ff_ops f V) W (nat p))\n         (Suc d) ?res\n   else dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n         (arith_ops_record.one ff_ops)\n         (degree_i (div_field_poly_i ff_ops V G))\n         (div_field_poly_i ff_ops V G)\n         (mod_field_poly_i ff_ops\n           (power_poly_f_mod_i ff_ops\n             (\\<lambda>f. mod_field_poly_i ff_ops f V) W (nat p))\n           (div_field_poly_i ff_ops V G))\n         (Suc d) ((Suc d, G) # ?res))\n\ngoal (1 subgoal):\n 1. \\<not> degree v < d + d \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "note IH = IH[OF False refl refl refl]"], ["proof (state)\nthis:\n  \\<lbrakk>gcd (w ^ CARD('a) mod v - monom 1 1) v = 1; poly_rel ?F v;\n   poly_rel ?G (w ^ CARD('a) mod v);\n   list_all2 (rel_prod (=) poly_rel) ?Res res\\<rbrakk>\n  \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                     (dist_degree_factorize_main_i p ff_ops\n                       (arith_ops_record.zero ff_ops)\n                       (arith_ops_record.one ff_ops) (degree_i ?F) ?F ?G\n                       (Suc d) ?Res)\n                     (dist_degree_factorize_main v (w ^ CARD('a) mod v)\n                       (Suc d) res)\n  \\<lbrakk>gcd (w ^ CARD('a) mod v - monom 1 1) v \\<noteq> 1;\n   ?xc = v div gcd (w ^ CARD('a) mod v - monom 1 1) v; poly_rel ?F ?xc;\n   poly_rel ?G (w ^ CARD('a) mod v mod ?xc);\n   list_all2 (rel_prod (=) poly_rel) ?Res\n    ((Suc d, gcd (w ^ CARD('a) mod v - monom 1 1) v) # res)\\<rbrakk>\n  \\<Longrightarrow> list_all2 (rel_prod (=) poly_rel)\n                     (dist_degree_factorize_main_i p ff_ops\n                       (arith_ops_record.zero ff_ops)\n                       (arith_ops_record.one ff_ops) (degree_i ?F) ?F ?G\n                       (Suc d) ?Res)\n                     (dist_degree_factorize_main ?xc\n                       (w ^ CARD('a) mod v mod ?xc) (Suc d)\n                       ((Suc d, gcd (w ^ CARD('a) mod v - monom 1 1) v) #\n                        res))\n\ngoal (1 subgoal):\n 1. \\<not> degree v < d + d \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "have [transfer_rule]: \"poly_rel [?ze,?on] (monom 1 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops]\n     (monom 1 1)", "unfolding poly_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops]\n     (coeffs (monom 1 1))", "by (auto simp: coeffs_monom one zero)"], ["proof (state)\nthis:\n  poly_rel [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops]\n   (monom 1 1)\n\ngoal (1 subgoal):\n 1. \\<not> degree v < d + d \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "have id: \"w ^ CARD('a) mod v = power_poly_f_mod v w (nat p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w ^ CARD('a) mod v = power_poly_f_mod v w (nat p)", "unfolding power_poly_f_mod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. w ^ CARD('a) mod v = w ^ nat p mod v", "by (simp add: p)"], ["proof (state)\nthis:\n  w ^ CARD('a) mod v = power_poly_f_mod v w (nat p)\n\ngoal (1 subgoal):\n 1. \\<not> degree v < d + d \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "have P[transfer_rule]: \"poly_rel ?P (w ^ CARD('a) mod v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel\n     (power_poly_f_mod_i ff_ops (\\<lambda>f. mod_field_poly_i ff_ops f V) W\n       (nat p))\n     (w ^ CARD('a) mod v)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel\n     (power_poly_f_mod_i ff_ops (\\<lambda>f. mod_field_poly_i ff_ops f V) W\n       (nat p))\n     (power_poly_f_mod v w (nat p))", "by (rule power_poly_f_mod_i[OF _ w], transfer_prover)"], ["proof (state)\nthis:\n  poly_rel\n   (power_poly_f_mod_i ff_ops (\\<lambda>f. mod_field_poly_i ff_ops f V) W\n     (nat p))\n   (w ^ CARD('a) mod v)\n\ngoal (1 subgoal):\n 1. \\<not> degree v < d + d \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "have g[transfer_rule]: \"poly_rel G g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel G g", "unfolding G_def g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel\n     (gcd_poly_i ff_ops\n       (minus_poly_i ff_ops\n         (power_poly_f_mod_i ff_ops\n           (\\<lambda>f. mod_field_poly_i ff_ops f V) W (nat p))\n         [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops])\n       V)\n     (gcd (w ^ CARD('a) mod v - monom 1 1) v)", "by transfer_prover"], ["proof (state)\nthis:\n  poly_rel G g\n\ngoal (1 subgoal):\n 1. \\<not> degree v < d + d \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "have id3: \"(G = [?on]) = (g = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G = [arith_ops_record.one ff_ops]) = (g = 1)", "by transfer_prover"], ["proof (state)\nthis:\n  (G = [arith_ops_record.one ff_ops]) = (g = 1)\n\ngoal (1 subgoal):\n 1. \\<not> degree v < d + d \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "note simp = simp[unfolded id3]"], ["proof (state)\nthis:\n  dist_degree_factorize_main v w d ?res =\n  (if g = 1\n   then dist_degree_factorize_main v (w ^ CARD('a) mod v) (Suc d) ?res\n   else dist_degree_factorize_main (v div g)\n         (w ^ CARD('a) mod v mod (v div g)) (Suc d) ((Suc d, g) # ?res))\n  dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n   (arith_ops_record.one ff_ops) (degree v) V W d ?res =\n  (if g = 1\n   then dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n         (arith_ops_record.one ff_ops) (degree v) V\n         (power_poly_f_mod_i ff_ops\n           (\\<lambda>f. mod_field_poly_i ff_ops f V) W (nat p))\n         (Suc d) ?res\n   else dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n         (arith_ops_record.one ff_ops)\n         (degree_i (div_field_poly_i ff_ops V G))\n         (div_field_poly_i ff_ops V G)\n         (mod_field_poly_i ff_ops\n           (power_poly_f_mod_i ff_ops\n             (\\<lambda>f. mod_field_poly_i ff_ops f V) W (nat p))\n           (div_field_poly_i ff_ops V G))\n         (Suc d) ((Suc d, G) # ?res))\n\ngoal (1 subgoal):\n 1. \\<not> degree v < d + d \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "proof (cases \"g = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. g = 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)\n 2. g \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "case True"], ["proof (state)\nthis:\n  g = 1\n\ngoal (2 subgoals):\n 1. g = 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)\n 2. g \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "from IH(1)[OF this[unfolded g_def] v P res] True"], ["proof (chain)\npicking this:\n  list_all2 (rel_prod (=) poly_rel)\n   (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n     (arith_ops_record.one ff_ops) (degree_i V) V\n     (power_poly_f_mod_i ff_ops (\\<lambda>f. mod_field_poly_i ff_ops f V) W\n       (nat p))\n     (Suc d) Res)\n   (dist_degree_factorize_main v (w ^ CARD('a) mod v) (Suc d) res)\n  g = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  list_all2 (rel_prod (=) poly_rel)\n   (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n     (arith_ops_record.one ff_ops) (degree_i V) V\n     (power_poly_f_mod_i ff_ops (\\<lambda>f. mod_field_poly_i ff_ops f V) W\n       (nat p))\n     (Suc d) Res)\n   (dist_degree_factorize_main v (w ^ CARD('a) mod v) (Suc d) res)\n  g = 1\n\ngoal (1 subgoal):\n 1. list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "unfolding id2 simp"], ["proof (prove)\nusing this:\n  list_all2 (rel_prod (=) poly_rel)\n   (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n     (arith_ops_record.one ff_ops) (degree v) V\n     (power_poly_f_mod_i ff_ops (\\<lambda>f. mod_field_poly_i ff_ops f V) W\n       (nat p))\n     (Suc d) Res)\n   (dist_degree_factorize_main v (w ^ CARD('a) mod v) (Suc d) res)\n  g = 1\n\ngoal (1 subgoal):\n 1. list_all2 (rel_prod (=) poly_rel)\n     (if g = 1\n      then dist_degree_factorize_main_i p ff_ops\n            (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops)\n            (degree v) V\n            (power_poly_f_mod_i ff_ops\n              (\\<lambda>f. mod_field_poly_i ff_ops f V) W (nat p))\n            (Suc d) Res\n      else dist_degree_factorize_main_i p ff_ops\n            (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops)\n            (degree_i (div_field_poly_i ff_ops V G))\n            (div_field_poly_i ff_ops V G)\n            (mod_field_poly_i ff_ops\n              (power_poly_f_mod_i ff_ops\n                (\\<lambda>f. mod_field_poly_i ff_ops f V) W (nat p))\n              (div_field_poly_i ff_ops V G))\n            (Suc d) ((Suc d, G) # Res))\n     (if g = 1\n      then dist_degree_factorize_main v (w ^ CARD('a) mod v) (Suc d) res\n      else dist_degree_factorize_main (v div g)\n            (w ^ CARD('a) mod v mod (v div g)) (Suc d) ((Suc d, g) # res))", "by simp"], ["proof (state)\nthis:\n  list_all2 (rel_prod (=) poly_rel)\n   (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n     (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n   (dist_degree_factorize_main v w d res)\n\ngoal (1 subgoal):\n 1. g \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. g \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "case False"], ["proof (state)\nthis:\n  g \\<noteq> 1\n\ngoal (1 subgoal):\n 1. g \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "have vg: \"poly_rel (div_field_poly_i ff_ops V G) (v div g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (div_field_poly_i ff_ops V G) (v div g)", "by transfer_prover"], ["proof (state)\nthis:\n  poly_rel (div_field_poly_i ff_ops V G) (v div g)\n\ngoal (1 subgoal):\n 1. g \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "have \"poly_rel (mod_field_poly_i ff_ops ?P\n          (div_field_poly_i ff_ops V G)) (w ^ CARD('a) mod v mod (v div g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel\n     (mod_field_poly_i ff_ops\n       (power_poly_f_mod_i ff_ops (\\<lambda>f. mod_field_poly_i ff_ops f V)\n         W (nat p))\n       (div_field_poly_i ff_ops V G))\n     (w ^ CARD('a) mod v mod (v div g))", "by transfer_prover"], ["proof (state)\nthis:\n  poly_rel\n   (mod_field_poly_i ff_ops\n     (power_poly_f_mod_i ff_ops (\\<lambda>f. mod_field_poly_i ff_ops f V) W\n       (nat p))\n     (div_field_poly_i ff_ops V G))\n   (w ^ CARD('a) mod v mod (v div g))\n\ngoal (1 subgoal):\n 1. g \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "note IH = IH(2)[OF False[unfolded g_def] refl vg[unfolded G_def g_def] this[unfolded G_def g_def],\n            folded g_def G_def]"], ["proof (state)\nthis:\n  list_all2 (rel_prod (=) poly_rel) ?Res\n   ((Suc d, g) # res) \\<Longrightarrow>\n  list_all2 (rel_prod (=) poly_rel)\n   (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n     (arith_ops_record.one ff_ops) (degree_i (div_field_poly_i ff_ops V G))\n     (div_field_poly_i ff_ops V G)\n     (mod_field_poly_i ff_ops\n       (power_poly_f_mod_i ff_ops (\\<lambda>f. mod_field_poly_i ff_ops f V)\n         W (nat p))\n       (div_field_poly_i ff_ops V G))\n     (Suc d) ?Res)\n   (dist_degree_factorize_main (v div g) (w ^ CARD('a) mod v mod (v div g))\n     (Suc d) ((Suc d, g) # res))\n\ngoal (1 subgoal):\n 1. g \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "have \"list_all2 (rel_prod (=) poly_rel) ((Suc d, G) # Res) ((Suc d, g) # res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (rel_prod (=) poly_rel) ((Suc d, G) # Res) ((Suc d, g) # res)", "using g res"], ["proof (prove)\nusing this:\n  poly_rel G g\n  list_all2 (rel_prod (=) poly_rel) Res res\n\ngoal (1 subgoal):\n 1. list_all2 (rel_prod (=) poly_rel) ((Suc d, G) # Res) ((Suc d, g) # res)", "by auto"], ["proof (state)\nthis:\n  list_all2 (rel_prod (=) poly_rel) ((Suc d, G) # Res) ((Suc d, g) # res)\n\ngoal (1 subgoal):\n 1. g \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "note IH = IH[OF this]"], ["proof (state)\nthis:\n  list_all2 (rel_prod (=) poly_rel)\n   (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n     (arith_ops_record.one ff_ops) (degree_i (div_field_poly_i ff_ops V G))\n     (div_field_poly_i ff_ops V G)\n     (mod_field_poly_i ff_ops\n       (power_poly_f_mod_i ff_ops (\\<lambda>f. mod_field_poly_i ff_ops f V)\n         W (nat p))\n       (div_field_poly_i ff_ops V G))\n     (Suc d) ((Suc d, G) # Res))\n   (dist_degree_factorize_main (v div g) (w ^ CARD('a) mod v mod (v div g))\n     (Suc d) ((Suc d, g) # res))\n\ngoal (1 subgoal):\n 1. g \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "from False"], ["proof (chain)\npicking this:\n  g \\<noteq> 1", "have \"(g = 1) = False\""], ["proof (prove)\nusing this:\n  g \\<noteq> 1\n\ngoal (1 subgoal):\n 1. (g = 1) = False", "by simp"], ["proof (state)\nthis:\n  (g = 1) = False\n\ngoal (1 subgoal):\n 1. g \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "note simp = simp[unfolded this if_False]"], ["proof (state)\nthis:\n  dist_degree_factorize_main v w d ?res =\n  dist_degree_factorize_main (v div g) (w ^ CARD('a) mod v mod (v div g))\n   (Suc d) ((Suc d, g) # ?res)\n  dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n   (arith_ops_record.one ff_ops) (degree v) V W d ?res =\n  dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n   (arith_ops_record.one ff_ops) (degree_i (div_field_poly_i ff_ops V G))\n   (div_field_poly_i ff_ops V G)\n   (mod_field_poly_i ff_ops\n     (power_poly_f_mod_i ff_ops (\\<lambda>f. mod_field_poly_i ff_ops f V) W\n       (nat p))\n     (div_field_poly_i ff_ops V G))\n   (Suc d) ((Suc d, G) # ?res)\n\ngoal (1 subgoal):\n 1. g \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n     (dist_degree_factorize_main v w d res)", "unfolding id2 simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops)\n       (degree_i (div_field_poly_i ff_ops V G))\n       (div_field_poly_i ff_ops V G)\n       (mod_field_poly_i ff_ops\n         (power_poly_f_mod_i ff_ops\n           (\\<lambda>f. mod_field_poly_i ff_ops f V) W (nat p))\n         (div_field_poly_i ff_ops V G))\n       (Suc d) ((Suc d, G) # Res))\n     (dist_degree_factorize_main (v div g)\n       (w ^ CARD('a) mod v mod (v div g)) (Suc d) ((Suc d, g) # res))", "using IH"], ["proof (prove)\nusing this:\n  list_all2 (rel_prod (=) poly_rel)\n   (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n     (arith_ops_record.one ff_ops) (degree_i (div_field_poly_i ff_ops V G))\n     (div_field_poly_i ff_ops V G)\n     (mod_field_poly_i ff_ops\n       (power_poly_f_mod_i ff_ops (\\<lambda>f. mod_field_poly_i ff_ops f V)\n         W (nat p))\n       (div_field_poly_i ff_ops V G))\n     (Suc d) ((Suc d, G) # Res))\n   (dist_degree_factorize_main (v div g) (w ^ CARD('a) mod v mod (v div g))\n     (Suc d) ((Suc d, g) # res))\n\ngoal (1 subgoal):\n 1. list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops)\n       (degree_i (div_field_poly_i ff_ops V G))\n       (div_field_poly_i ff_ops V G)\n       (mod_field_poly_i ff_ops\n         (power_poly_f_mod_i ff_ops\n           (\\<lambda>f. mod_field_poly_i ff_ops f V) W (nat p))\n         (div_field_poly_i ff_ops V G))\n       (Suc d) ((Suc d, G) # Res))\n     (dist_degree_factorize_main (v div g)\n       (w ^ CARD('a) mod v mod (v div g)) (Suc d) ((Suc d, g) # res))", "by simp"], ["proof (state)\nthis:\n  list_all2 (rel_prod (=) poly_rel)\n   (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n     (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n   (dist_degree_factorize_main v w d res)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all2 (rel_prod (=) poly_rel)\n   (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n     (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n   (dist_degree_factorize_main v w d res)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all2 (rel_prod (=) poly_rel)\n   (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n     (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n   (dist_degree_factorize_main v w d res)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all2 (rel_prod (=) poly_rel)\n   (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n     (arith_ops_record.one ff_ops) (degree_i V) V W d Res)\n   (dist_degree_factorize_main v w d res)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_degree_factorization_i[transfer_rule]: \"(poly_rel ===> list_all2 (rel_prod (=) poly_rel)) \n  (distinct_degree_factorization_i p ff_ops) distinct_degree_factorization\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> list_all2 (rel_prod (=) poly_rel))\n     (distinct_degree_factorization_i p ff_ops)\n     distinct_degree_factorization", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       list_all2 (rel_prod (=) poly_rel)\n        (distinct_degree_factorization_i p ff_ops x)\n        (distinct_degree_factorization y)", "fix F f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       list_all2 (rel_prod (=) poly_rel)\n        (distinct_degree_factorization_i p ff_ops x)\n        (distinct_degree_factorization y)", "assume f[transfer_rule]: \"poly_rel F f\""], ["proof (state)\nthis:\n  poly_rel F f\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       list_all2 (rel_prod (=) poly_rel)\n        (distinct_degree_factorization_i p ff_ops x)\n        (distinct_degree_factorization y)", "have id: \"(degree_i F = 1) = (degree f = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (degree_i F = 1) = (degree f = 1)", "by transfer_prover"], ["proof (state)\nthis:\n  (degree_i F = 1) = (degree f = 1)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       list_all2 (rel_prod (=) poly_rel)\n        (distinct_degree_factorization_i p ff_ops x)\n        (distinct_degree_factorization y)", "note d = distinct_degree_factorization_i_def distinct_degree_factorization_def"], ["proof (state)\nthis:\n  distinct_degree_factorization_i ?p ?ff_ops ?f =\n  (let ze = arith_ops_record.zero ?ff_ops; on = arith_ops_record.one ?ff_ops\n   in if degree_i ?f = 1 then [(1, ?f)]\n      else dist_degree_factorize_main_i ?p ?ff_ops ze on (degree_i ?f) ?f\n            [ze, on] 0 [])\n  distinct_degree_factorization ?f =\n  (if degree ?f = 1 then [(1, ?f)]\n   else dist_degree_factorize_main ?f (monom 1 1) 0 [])\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       list_all2 (rel_prod (=) poly_rel)\n        (distinct_degree_factorization_i p ff_ops x)\n        (distinct_degree_factorization y)", "let ?ze = \"arith_ops_record.zero ff_ops\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       list_all2 (rel_prod (=) poly_rel)\n        (distinct_degree_factorization_i p ff_ops x)\n        (distinct_degree_factorization y)", "let ?on = \"arith_ops_record.one ff_ops\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow>\n       list_all2 (rel_prod (=) poly_rel)\n        (distinct_degree_factorization_i p ff_ops x)\n        (distinct_degree_factorization y)", "show \"list_all2 (rel_prod (=) poly_rel) (distinct_degree_factorization_i p ff_ops F)\n            (distinct_degree_factorization f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (rel_prod (=) poly_rel)\n     (distinct_degree_factorization_i p ff_ops F)\n     (distinct_degree_factorization f)", "proof (cases \"degree f = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree f = 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (distinct_degree_factorization_i p ff_ops F)\n     (distinct_degree_factorization f)\n 2. degree f \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (distinct_degree_factorization_i p ff_ops F)\n     (distinct_degree_factorization f)", "case True"], ["proof (state)\nthis:\n  degree f = 1\n\ngoal (2 subgoals):\n 1. degree f = 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (distinct_degree_factorization_i p ff_ops F)\n     (distinct_degree_factorization f)\n 2. degree f \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (distinct_degree_factorization_i p ff_ops F)\n     (distinct_degree_factorization f)", "with id f"], ["proof (chain)\npicking this:\n  (degree_i F = 1) = (degree f = 1)\n  poly_rel F f\n  degree f = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  (degree_i F = 1) = (degree f = 1)\n  poly_rel F f\n  degree f = 1\n\ngoal (1 subgoal):\n 1. list_all2 (rel_prod (=) poly_rel)\n     (distinct_degree_factorization_i p ff_ops F)\n     (distinct_degree_factorization f)", "unfolding d"], ["proof (prove)\nusing this:\n  (degree_i F = 1) = (degree f = 1)\n  poly_rel F f\n  degree f = 1\n\ngoal (1 subgoal):\n 1. list_all2 (rel_prod (=) poly_rel)\n     (let ze = arith_ops_record.zero ff_ops;\n          on = arith_ops_record.one ff_ops\n      in if degree_i F = 1 then [(1, F)]\n         else dist_degree_factorize_main_i p ff_ops ze on (degree_i F) F\n               [ze, on] 0 [])\n     (if degree f = 1 then [(1, f)]\n      else dist_degree_factorize_main f (monom 1 1) 0 [])", "by auto"], ["proof (state)\nthis:\n  list_all2 (rel_prod (=) poly_rel)\n   (distinct_degree_factorization_i p ff_ops F)\n   (distinct_degree_factorization f)\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (distinct_degree_factorization_i p ff_ops F)\n     (distinct_degree_factorization f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree f \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (distinct_degree_factorization_i p ff_ops F)\n     (distinct_degree_factorization f)", "case False"], ["proof (state)\nthis:\n  degree f \\<noteq> 1\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (distinct_degree_factorization_i p ff_ops F)\n     (distinct_degree_factorization f)", "from False id"], ["proof (chain)\npicking this:\n  degree f \\<noteq> 1\n  (degree_i F = 1) = (degree f = 1)", "have \"?thesis = (list_all2 (rel_prod (=) poly_rel) \n      (dist_degree_factorize_main_i p ff_ops ?ze ?on (degree_i F) F [?ze, ?on] 0 [])\n      (dist_degree_factorize_main f (monom 1 1) 0 []))\""], ["proof (prove)\nusing this:\n  degree f \\<noteq> 1\n  (degree_i F = 1) = (degree f = 1)\n\ngoal (1 subgoal):\n 1. list_all2 (rel_prod (=) poly_rel)\n     (distinct_degree_factorization_i p ff_ops F)\n     (distinct_degree_factorization f) =\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i F) F\n       [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops] 0 [])\n     (dist_degree_factorize_main f (monom 1 1) 0 [])", "unfolding d Let_def"], ["proof (prove)\nusing this:\n  degree f \\<noteq> 1\n  (degree_i F = 1) = (degree f = 1)\n\ngoal (1 subgoal):\n 1. list_all2 (rel_prod (=) poly_rel)\n     (if degree_i F = 1 then [(1, F)]\n      else dist_degree_factorize_main_i p ff_ops\n            (arith_ops_record.zero ff_ops) (arith_ops_record.one ff_ops)\n            (degree_i F) F\n            [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops] 0\n            [])\n     (if degree f = 1 then [(1, f)]\n      else dist_degree_factorize_main f (monom 1 1) 0 []) =\n    list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i F) F\n       [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops] 0 [])\n     (dist_degree_factorize_main f (monom 1 1) 0 [])", "by simp"], ["proof (state)\nthis:\n  list_all2 (rel_prod (=) poly_rel)\n   (distinct_degree_factorization_i p ff_ops F)\n   (distinct_degree_factorization f) =\n  list_all2 (rel_prod (=) poly_rel)\n   (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n     (arith_ops_record.one ff_ops) (degree_i F) F\n     [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops] 0 [])\n   (dist_degree_factorize_main f (monom 1 1) 0 [])\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (distinct_degree_factorization_i p ff_ops F)\n     (distinct_degree_factorization f)", "also"], ["proof (state)\nthis:\n  list_all2 (rel_prod (=) poly_rel)\n   (distinct_degree_factorization_i p ff_ops F)\n   (distinct_degree_factorization f) =\n  list_all2 (rel_prod (=) poly_rel)\n   (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n     (arith_ops_record.one ff_ops) (degree_i F) F\n     [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops] 0 [])\n   (dist_degree_factorize_main f (monom 1 1) 0 [])\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (distinct_degree_factorization_i p ff_ops F)\n     (distinct_degree_factorization f)", "have \\<dots>"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (rel_prod (=) poly_rel)\n     (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n       (arith_ops_record.one ff_ops) (degree_i F) F\n       [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops] 0 [])\n     (dist_degree_factorize_main f (monom 1 1) 0 [])", "by (rule dist_degree_factorize_main_i[OF f], auto simp: poly_rel_def\n        coeffs_monom one zero)"], ["proof (state)\nthis:\n  list_all2 (rel_prod (=) poly_rel)\n   (dist_degree_factorize_main_i p ff_ops (arith_ops_record.zero ff_ops)\n     (arith_ops_record.one ff_ops) (degree_i F) F\n     [arith_ops_record.zero ff_ops, arith_ops_record.one ff_ops] 0 [])\n   (dist_degree_factorize_main f (monom 1 1) 0 [])\n\ngoal (1 subgoal):\n 1. degree f \\<noteq> 1 \\<Longrightarrow>\n    list_all2 (rel_prod (=) poly_rel)\n     (distinct_degree_factorization_i p ff_ops F)\n     (distinct_degree_factorization f)", "finally"], ["proof (chain)\npicking this:\n  list_all2 (rel_prod (=) poly_rel)\n   (distinct_degree_factorization_i p ff_ops F)\n   (distinct_degree_factorization f)", "show ?thesis"], ["proof (prove)\nusing this:\n  list_all2 (rel_prod (=) poly_rel)\n   (distinct_degree_factorization_i p ff_ops F)\n   (distinct_degree_factorization f)\n\ngoal (1 subgoal):\n 1. list_all2 (rel_prod (=) poly_rel)\n     (distinct_degree_factorization_i p ff_ops F)\n     (distinct_degree_factorization f)", "."], ["proof (state)\nthis:\n  list_all2 (rel_prod (=) poly_rel)\n   (distinct_degree_factorization_i p ff_ops F)\n   (distinct_degree_factorization f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all2 (rel_prod (=) poly_rel)\n   (distinct_degree_factorization_i p ff_ops F)\n   (distinct_degree_factorization f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_field_factorization_i[transfer_rule]: \n  \"(poly_rel ===> rel_prod R (list_all2 poly_rel))\n     (finite_field_factorization_i p ff_ops) finite_field_factorization\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> rel_prod R (list_all2 poly_rel))\n     (finite_field_factorization_i p ff_ops) finite_field_factorization", "unfolding finite_field_factorization_i_def finite_field_factorization_def Let_def lead_coeff_i_def'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> rel_prod R (list_all2 poly_rel))\n     (\\<lambda>f.\n         if degree_i f = 0 then (coeff_i ff_ops f (degree_i f), [])\n         else case List.partition (\\<lambda>(i, f). degree_i f = i)\n                    (if use_distinct_degree_factorization\n                     then distinct_degree_factorization_i p ff_ops\n                           (smult_i ff_ops\n                             (arith_ops_record.inverse ff_ops\n                               (coeff_i ff_ops f (degree_i f)))\n                             f)\n                     else [(1, smult_i ff_ops\n                                (arith_ops_record.inverse ff_ops\n                                  (coeff_i ff_ops f (degree_i f)))\n                                f)]) of\n              (irr, hs) \\<Rightarrow>\n                (coeff_i ff_ops f (degree_i f),\n                 map snd irr @\n                 concat\n                  (map (\\<lambda>(x, y).\n                           berlekamp_monic_factorization_i p ff_ops x y)\n                    hs)))\n     (\\<lambda>f.\n         if degree f = 0 then (lead_coeff f, [])\n         else case List.partition (\\<lambda>(i, f). degree f = i)\n                    (if use_distinct_degree_factorization\n                     then distinct_degree_factorization\n                           (Polynomial.smult\n                             (inverse_class.inverse (lead_coeff f)) f)\n                     else [(1, Polynomial.smult\n                                (inverse_class.inverse (lead_coeff f))\n                                f)]) of\n              (irr, hs) \\<Rightarrow>\n                (lead_coeff f,\n                 map snd irr @\n                 concat\n                  (map (\\<lambda>(x, y). berlekamp_monic_factorization x y)\n                    hs)))", "by transfer_prover"], ["", "text \\<open>Since the implementation is sound, we can now combine it with the soundness result\n  of the finite field factorization.\\<close>"], ["", "lemma finite_field_i_sound: \n  assumes f': \"f' = of_int_poly_i ff_ops (Mp f)\" \n  and berl_i: \"finite_field_factorization_i p ff_ops f' = (c',fs')\"\n  and sq: \"square_free_m f\" \n  and fs: \"fs = map (to_int_poly_i ff_ops) fs'\"\n  and c: \"c = arith_ops_record.to_int ff_ops c'\" \n  shows \"unique_factorization_m f (c, mset fs)\n    \\<and> c \\<in> {0 ..< p} \n    \\<and> (\\<forall> fi \\<in> set fs. set (coeffs fi) \\<subseteq> {0 ..< p})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "define f'' :: \"'a mod_ring poly\" where \"f'' = of_int_poly (Mp f)\""], ["proof (state)\nthis:\n  f'' = of_int_poly (Mp f)\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "have rel_f[transfer_rule]: \"poly_rel f' f''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel f' f''", "by (rule poly_rel_of_int_poly[OF f'], simp add: f''_def)"], ["proof (state)\nthis:\n  poly_rel f' f''\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "interpret pff: idom_ops \"poly_ops ff_ops\" poly_rel"], ["proof (prove)\ngoal (1 subgoal):\n 1. idom_ops (poly_ops ff_ops) poly_rel", "by (rule idom_ops_poly)"], ["proof (state)\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "obtain c'' fs'' where berl: \"finite_field_factorization f'' = (c'',fs'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c'' fs''.\n        finite_field_factorization f'' = (c'', fs'') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  finite_field_factorization f'' = (c'', fs'')\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "from rel_funD[OF finite_field_factorization_i rel_f, unfolded rel_prod_conv assms(2) split berl]"], ["proof (chain)\npicking this:\n  R c' c'' \\<and> list_all2 poly_rel fs' fs''", "have rel[transfer_rule]: \"R c' c''\" \"list_all2 poly_rel fs' fs''\""], ["proof (prove)\nusing this:\n  R c' c'' \\<and> list_all2 poly_rel fs' fs''\n\ngoal (1 subgoal):\n 1. R c' c'' &&& list_all2 poly_rel fs' fs''", "by auto"], ["proof (state)\nthis:\n  R c' c''\n  list_all2 poly_rel fs' fs''\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "from to_int[OF rel(1)]"], ["proof (chain)\npicking this:\n  arith_ops_record.to_int ff_ops c' = to_int_mod_ring c''", "have cc': \"c = to_int_mod_ring c''\""], ["proof (prove)\nusing this:\n  arith_ops_record.to_int ff_ops c' = to_int_mod_ring c''\n\ngoal (1 subgoal):\n 1. c = to_int_mod_ring c''", "unfolding c"], ["proof (prove)\nusing this:\n  arith_ops_record.to_int ff_ops c' = to_int_mod_ring c''\n\ngoal (1 subgoal):\n 1. arith_ops_record.to_int ff_ops c' = to_int_mod_ring c''", "by simp"], ["proof (state)\nthis:\n  c = to_int_mod_ring c''\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "have c: \"c \\<in> {0 ..< p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<in> {0..<p}", "unfolding cc'"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_mod_ring c'' \\<in> {0..<p}", "by (metis Divides.pos_mod_bound Divides.pos_mod_sign M_to_int_mod_ring atLeastLessThan_iff \n      gr_implies_not_zero nat_le_0 nat_p not_le poly_mod.M_def zero_less_card_finite)"], ["proof (state)\nthis:\n  c \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "{"], ["proof (state)\nthis:\n  c \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "assume \"f \\<in> set fs'\""], ["proof (state)\nthis:\n  f \\<in> set fs'\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "with rel(2)"], ["proof (chain)\npicking this:\n  list_all2 poly_rel fs' fs''\n  f \\<in> set fs'", "obtain f' where \"poly_rel f f'\""], ["proof (prove)\nusing this:\n  list_all2 poly_rel fs' fs''\n  f \\<in> set fs'\n\ngoal (1 subgoal):\n 1. (\\<And>f'. poly_rel f f' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding list_all2_conv_all_nth set_conv_nth"], ["proof (prove)\nusing this:\n  length fs' = length fs'' \\<and>\n  (\\<forall>i<length fs'. poly_rel (fs' ! i) (fs'' ! i))\n  f \\<in> {fs' ! i |i. i < length fs'}\n\ngoal (1 subgoal):\n 1. (\\<And>f'. poly_rel f f' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  poly_rel f f'\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "hence \"is_poly ff_ops f\""], ["proof (prove)\nusing this:\n  poly_rel f f'\n\ngoal (1 subgoal):\n 1. is_poly ff_ops f", "using fun_cong[OF Domainp_is_poly, of f]"], ["proof (prove)\nusing this:\n  poly_rel f f'\n  Domainp poly_rel f = is_poly ff_ops f\n\ngoal (1 subgoal):\n 1. is_poly ff_ops f", "unfolding Domainp_iff[abs_def]"], ["proof (prove)\nusing this:\n  poly_rel f f'\n  Ex (poly_rel f) = is_poly ff_ops f\n\ngoal (1 subgoal):\n 1. is_poly ff_ops f", "by auto"], ["proof (state)\nthis:\n  is_poly ff_ops f\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "}"], ["proof (state)\nthis:\n  ?fa2 \\<in> set fs' \\<Longrightarrow> is_poly ff_ops ?fa2\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "hence fs': \"Ball (set fs') (is_poly ff_ops)\""], ["proof (prove)\nusing this:\n  ?fa2 \\<in> set fs' \\<Longrightarrow> is_poly ff_ops ?fa2\n\ngoal (1 subgoal):\n 1. Ball (set fs') (is_poly ff_ops)", "by auto"], ["proof (state)\nthis:\n  Ball (set fs') (is_poly ff_ops)\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "define mon :: \"'a mod_ring poly \\<Rightarrow> bool\" where \"mon = monic\""], ["proof (state)\nthis:\n  mon = monic\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "have [transfer_rule]: \"(poly_rel ===> (=)) (monic_i ff_ops) mon\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> (=)) (monic_i ff_ops) mon", "unfolding mon_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> (=)) (monic_i ff_ops) monic", "by (rule poly_rel_monic)"], ["proof (state)\nthis:\n  (poly_rel ===> (=)) (monic_i ff_ops) mon\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "have len: \"length fs' = length fs''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length fs' = length fs''", "by transfer_prover"], ["proof (state)\nthis:\n  length fs' = length fs''\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "have fs': \"fs = map to_int_poly fs''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs = map to_int_poly fs''", "unfolding fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (to_int_poly_i ff_ops) fs' = map to_int_poly fs''", "proof (rule nth_map_conv[OF len], intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length fs' \\<Longrightarrow>\n       to_int_poly_i ff_ops (fs' ! i) = to_int_poly (fs'' ! i)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length fs' \\<Longrightarrow>\n       to_int_poly_i ff_ops (fs' ! i) = to_int_poly (fs'' ! i)", "assume i: \"i < length fs'\""], ["proof (state)\nthis:\n  i < length fs'\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length fs' \\<Longrightarrow>\n       to_int_poly_i ff_ops (fs' ! i) = to_int_poly (fs'' ! i)", "obtain f g where id: \"fs' ! i = f\" \"fs'' ! i = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>fs' ! i = f; fs'' ! i = g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  fs' ! i = f\n  fs'' ! i = g\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length fs' \\<Longrightarrow>\n       to_int_poly_i ff_ops (fs' ! i) = to_int_poly (fs'' ! i)", "from i rel(2)[unfolded list_all2_conv_all_nth[of _ fs' fs'']] id"], ["proof (chain)\npicking this:\n  i < length fs'\n  length fs' = length fs'' \\<and>\n  (\\<forall>i<length fs'. poly_rel (fs' ! i) (fs'' ! i))\n  fs' ! i = f\n  fs'' ! i = g", "have \"poly_rel f g\""], ["proof (prove)\nusing this:\n  i < length fs'\n  length fs' = length fs'' \\<and>\n  (\\<forall>i<length fs'. poly_rel (fs' ! i) (fs'' ! i))\n  fs' ! i = f\n  fs'' ! i = g\n\ngoal (1 subgoal):\n 1. poly_rel f g", "by auto"], ["proof (state)\nthis:\n  poly_rel f g\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length fs' \\<Longrightarrow>\n       to_int_poly_i ff_ops (fs' ! i) = to_int_poly (fs'' ! i)", "from to_int_poly_i[OF this]"], ["proof (chain)\npicking this:\n  to_int_poly_i ff_ops f = to_int_poly g", "have \"to_int_poly_i ff_ops f = to_int_poly g\""], ["proof (prove)\nusing this:\n  to_int_poly_i ff_ops f = to_int_poly g\n\ngoal (1 subgoal):\n 1. to_int_poly_i ff_ops f = to_int_poly g", "."], ["proof (state)\nthis:\n  to_int_poly_i ff_ops f = to_int_poly g\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length fs' \\<Longrightarrow>\n       to_int_poly_i ff_ops (fs' ! i) = to_int_poly (fs'' ! i)", "thus \"to_int_poly_i ff_ops (fs' ! i) = to_int_poly (fs'' ! i)\""], ["proof (prove)\nusing this:\n  to_int_poly_i ff_ops f = to_int_poly g\n\ngoal (1 subgoal):\n 1. to_int_poly_i ff_ops (fs' ! i) = to_int_poly (fs'' ! i)", "unfolding id"], ["proof (prove)\nusing this:\n  to_int_poly_i ff_ops f = to_int_poly g\n\ngoal (1 subgoal):\n 1. to_int_poly_i ff_ops f = to_int_poly g", "."], ["proof (state)\nthis:\n  to_int_poly_i ff_ops (fs' ! i) = to_int_poly (fs'' ! i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fs = map to_int_poly fs''\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "have f: \"f'' = of_int_poly f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f'' = of_int_poly f", "unfolding poly_eq_iff f''_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. coeff (of_int_poly (Mp f)) n = coeff (of_int_poly f) n", "by (simp add: to_int_mod_ring_hom.injectivity to_int_mod_ring_of_int_M Mp_coeff)"], ["proof (state)\nthis:\n  f'' = of_int_poly f\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "have *: \"unique_factorization_m f (c, mset fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs)", "using finite_field_factorization_modulo_ring[OF f sq berl cc' fs']"], ["proof (prove)\nusing this:\n  unique_factorization_m f (c, mset fs)\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs)", "by auto"], ["proof (state)\nthis:\n  unique_factorization_m f (c, mset fs)\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "have fs': \"(\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p}", "unfolding fs'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>fi\\<in>set (map to_int_poly fs'').\n       set (coeffs fi) \\<subseteq> {0..<p}", "using range_to_int_mod_ring[where 'a = 'a]"], ["proof (prove)\nusing this:\n  range to_int_mod_ring = {0..<int CARD('a)}\n\ngoal (1 subgoal):\n 1. \\<forall>fi\\<in>set (map to_int_poly fs'').\n       set (coeffs fi) \\<subseteq> {0..<p}", "by (auto simp: coeffs_to_int_poly p)"], ["proof (state)\nthis:\n  \\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p}\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "with c fs *"], ["proof (chain)\npicking this:\n  c \\<in> {0..<p}\n  fs = map (to_int_poly_i ff_ops) fs'\n  unique_factorization_m f (c, mset fs)\n  \\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p}", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<in> {0..<p}\n  fs = map (to_int_poly_i ff_ops) fs'\n  unique_factorization_m f (c, mset fs)\n  \\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p}\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "by blast"], ["proof (state)\nthis:\n  unique_factorization_m f (c, mset fs) \\<and>\n  c \\<in> {0..<p} \\<and>\n  (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "definition finite_field_factorization_main :: \"int \\<Rightarrow> 'i arith_ops_record \\<Rightarrow> int poly \\<Rightarrow> int \\<times> int poly list\" where\n  \"finite_field_factorization_main p f_ops f \\<equiv> \n    let (c',fs') = finite_field_factorization_i p f_ops (of_int_poly_i f_ops (poly_mod.Mp p f))\n      in (arith_ops_record.to_int f_ops c', map (to_int_poly_i f_ops) fs')\""], ["", "lemma(in prime_field_gen) finite_field_factorization_main: \n  assumes res: \"finite_field_factorization_main p ff_ops f = (c,fs)\"\n  and sq: \"square_free_m f\" \n  shows \"unique_factorization_m f (c, mset fs)\n    \\<and> c \\<in> {0 ..< p} \n    \\<and> (\\<forall> fi \\<in> set fs. set (coeffs fi) \\<subseteq> {0 ..< p})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "obtain c' fs' where \n    res': \"finite_field_factorization_i p ff_ops (of_int_poly_i ff_ops (Mp f)) = (c', fs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c' fs'.\n        finite_field_factorization_i p ff_ops\n         (of_int_poly_i ff_ops (Mp f)) =\n        (c', fs') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  finite_field_factorization_i p ff_ops (of_int_poly_i ff_ops (Mp f)) =\n  (c', fs')\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "by (rule finite_field_i_sound[OF refl res' sq], \n      insert res[unfolded finite_field_factorization_main_def res'], auto)"], ["proof (state)\nthis:\n  unique_factorization_m f (c, mset fs) \\<and>\n  c \\<in> {0..<p} \\<and>\n  (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})\n\ngoal:\nNo subgoals!", "qed"], ["", "definition finite_field_factorization_int :: \"int \\<Rightarrow> int poly \\<Rightarrow> int \\<times> int poly list\" where\n  \"finite_field_factorization_int p = (  \n    if p \\<le> 65535 \n    then finite_field_factorization_main p (finite_field_ops32 (uint32_of_int p))\n    else if p \\<le> 4294967295\n    then finite_field_factorization_main p (finite_field_ops64 (uint64_of_int p))\n    else finite_field_factorization_main p (finite_field_ops_integer (integer_of_int p)))\""], ["", "context poly_mod_prime begin"], ["", "lemmas finite_field_factorization_main_integer = prime_field_gen.finite_field_factorization_main\n  [OF prime_field.prime_field_finite_field_ops_integer, unfolded prime_field_def mod_ring_locale_def,\n  unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]"], ["", "lemmas finite_field_factorization_main_uint32 = prime_field_gen.finite_field_factorization_main\n  [OF prime_field.prime_field_finite_field_ops32, unfolded prime_field_def mod_ring_locale_def,\n  unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]"], ["", "lemmas finite_field_factorization_main_uint64 = prime_field_gen.finite_field_factorization_main\n  [OF prime_field.prime_field_finite_field_ops64, unfolded prime_field_def mod_ring_locale_def,\n  unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]"], ["", "lemma finite_field_factorization_int:\n  assumes sq: \"poly_mod.square_free_m p f\" \n  and result: \"finite_field_factorization_int p f = (c,fs)\"\n  shows \"poly_mod.unique_factorization_m p f (c, mset fs)\n    \\<and> c \\<in> {0 ..< p} \n    \\<and> (\\<forall> fi \\<in> set fs. set (coeffs fi) \\<subseteq> {0 ..< p})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "using finite_field_factorization_main_integer[OF  _ sq, of c fs]\n    finite_field_factorization_main_uint32[OF _ _ sq, of c fs]\n    finite_field_factorization_main_uint64[OF _ _ sq, of c fs]\n    result[unfolded finite_field_factorization_int_def]"], ["proof (prove)\nusing this:\n  finite_field_factorization_main p\n   (finite_field_ops_integer (integer_of_int p)) f =\n  (c, fs) \\<Longrightarrow>\n  unique_factorization_m f (c, mset fs) \\<and>\n  c \\<in> {0..<p} \\<and>\n  (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})\n  \\<lbrakk>p \\<le> 65535;\n   finite_field_factorization_main p (finite_field_ops32 (uint32_of_int p))\n    f =\n   (c, fs)\\<rbrakk>\n  \\<Longrightarrow> unique_factorization_m f (c, mset fs) \\<and>\n                    c \\<in> {0..<p} \\<and>\n                    (\\<forall>fi\\<in>set fs.\n                        set (coeffs fi) \\<subseteq> {0..<p})\n  \\<lbrakk>p \\<le> 4294967295;\n   finite_field_factorization_main p (finite_field_ops64 (uint64_of_int p))\n    f =\n   (c, fs)\\<rbrakk>\n  \\<Longrightarrow> unique_factorization_m f (c, mset fs) \\<and>\n                    c \\<in> {0..<p} \\<and>\n                    (\\<forall>fi\\<in>set fs.\n                        set (coeffs fi) \\<subseteq> {0..<p})\n  (if p \\<le> 65535\n   then finite_field_factorization_main p\n         (finite_field_ops32 (uint32_of_int p))\n   else if p \\<le> 4294967295\n        then finite_field_factorization_main p\n              (finite_field_ops64 (uint64_of_int p))\n        else finite_field_factorization_main p\n              (finite_field_ops_integer (integer_of_int p)))\n   f =\n  (c, fs)\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, mset fs) \\<and>\n    c \\<in> {0..<p} \\<and>\n    (\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})", "by (auto split: if_splits)"], ["", "end"], ["", "end"]]}