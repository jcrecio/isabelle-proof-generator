{"file_name": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus/Poly_Mod.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus", "problem_names": ["lemma M_0[simp]: \"M 0 = 0\"", "lemma M_M[simp]: \"M (M x) = M x\"", "lemma M_plus[simp]: \"M (M x + y) = M (x + y)\" \"M (x + M y) = M (x + y)\"", "lemma M_minus[simp]: \"M (M x - y) = M (x - y)\" \"M (x - M y) = M (x - y)\"", "lemma M_times[simp]: \"M (M x * y) = M (x * y)\" \"M (x * M y) = M (x * y)\"", "lemma M_sum: \"M (sum (\\<lambda> x. M (f x)) A) = M (sum f A)\"", "lemma M_inv_M_id[simp]: \"M (inv_M x) = M x\"", "lemma Mp_0[simp]: \"Mp 0 = 0\"", "lemma Mp_coeff: \"coeff (Mp f) i = M (coeff f i)\"", "lemma mult_Mp[simp]: \"Mp (Mp f * g) = Mp (f * g)\" \"Mp (f * Mp g) = Mp (f * g)\"", "lemma plus_Mp[simp]: \"Mp (Mp f + g) = Mp (f + g)\" \"Mp (f + Mp g) = Mp (f + g)\"", "lemma minus_Mp[simp]: \"Mp (Mp f - g) = Mp (f - g)\" \"Mp (f - Mp g) = Mp (f - g)\"", "lemma Mp_smult[simp]: \"Mp (smult (M a) f) = Mp (smult a f)\" \"Mp (smult a (Mp f)) = Mp (smult a f)\"", "lemma Mp_Mp[simp]: \"Mp (Mp f) = Mp f\"", "lemma Mp_smult_m_0[simp]: \"Mp (smult m f) = 0\"", "lemma dvdmE:\n  assumes fg: \"f dvdm g\"\n    and main: \"\\<And>h. g =m f * h \\<Longrightarrow> Mp h = h \\<Longrightarrow> thesis\"\n  shows \"thesis\"", "lemma Mp_dvdm[simp]: \"Mp f dvdm g \\<longleftrightarrow> f dvdm g\"\n  and dvdm_Mp[simp]: \"f dvdm Mp g \\<longleftrightarrow> f dvdm g\"", "lemma degree_m_le_degree [intro!]: \"degree_m f \\<le> degree f\"", "lemma irreducible\\<^sub>d_mI:\n  assumes f0: \"degree_m f > 0\"\n      and main: \"\\<And>g h. Mp g = g \\<Longrightarrow> Mp h = h \\<Longrightarrow> degree g > 0 \\<Longrightarrow> degree g < degree_m f \\<Longrightarrow> degree h > 0 \\<Longrightarrow> degree h < degree_m f \\<Longrightarrow> f =m g * h \\<Longrightarrow> False\"\n    shows \"irreducible\\<^sub>d_m f\"", "lemma irreducible\\<^sub>d_mE:\n  assumes \"irreducible\\<^sub>d_m f\"\n    and \"degree_m f > 0 \\<Longrightarrow> (\\<And>g h. degree_m g < degree_m f \\<Longrightarrow> degree_m h < degree_m f \\<Longrightarrow> \\<not> f =m g * h) \\<Longrightarrow> thesis\"\n  shows thesis", "lemma irreducible\\<^sub>d_mD:\n  assumes \"irreducible\\<^sub>d_m f\"\n  shows \"degree_m f > 0\" and \"\\<And>g h. degree_m g < degree_m f \\<Longrightarrow> degree_m h < degree_m f \\<Longrightarrow> \\<not> f =m g * h\"", "lemma Mp_square_free_m[simp]: \"square_free_m (Mp f) = square_free_m f\"", "lemma square_free_m_cong: \"square_free_m f \\<Longrightarrow> Mp f = Mp g \\<Longrightarrow> square_free_m g\"", "lemma Mp_prod_mset[simp]: \"Mp (prod_mset (image_mset Mp b)) = Mp (prod_mset b)\"", "lemma Mp_prod_list: \"Mp (prod_list (map Mp b)) = Mp (prod_list b)\"", "lemma M_poly_Mp[simp]: \"M_poly (Mp p) = M_poly p\"", "lemma Mp_lift_modulus: assumes \"f =m g\" \n  shows \"poly_mod.eq_m (m * k) (smult k f) (smult k g)\"", "lemma Mp_ident_product: \"n > 0 \\<Longrightarrow> Mp f = f \\<Longrightarrow> poly_mod.Mp (m * n) f = f\"", "lemma Mp_shrink_modulus: assumes \"poly_mod.eq_m (m * k) f g\" \"k \\<noteq> 0\" \n  shows \"f =m g\"", "lemma degree_m_le: \"degree_m f \\<le> degree f\"", "lemma degree_m_eq: \"coeff f (degree f) mod m \\<noteq> 0 \\<Longrightarrow> m > 1 \\<Longrightarrow> degree_m f = degree f\"", "lemma degree_m_mult_le:  \n  assumes eq: \"f =m g * h\" \n  shows \"degree_m f \\<le> degree_m g + degree_m h\"", "lemma degree_m_smult_le: \"degree_m (smult c f) \\<le> degree_m f\"", "lemma irreducible_m_Mp[simp]: \"irreducible_m (Mp f) \\<longleftrightarrow> irreducible_m f\"", "lemma eq_m_irreducible_m: \"f =m g \\<Longrightarrow> irreducible_m f \\<longleftrightarrow> irreducible_m g\"", "lemma irreducible_multD:\n  assumes l: \"irreducible (a*b)\"\n  shows \"a dvd 1 \\<and> irreducible b \\<or> b dvd 1 \\<and> irreducible a\"", "lemma irreducible_dvd_prod_mset:\n  fixes p :: \"'a :: field poly\"\n  assumes irr: \"irreducible p\" and dvd: \"p dvd prod_mset as\"\n  shows \"\\<exists> a \\<in># as. p dvd a\"", "lemma monic_factorization_unique_mset:\n  fixes P::\"'a::field poly multiset\"\n  assumes eq: \"prod_mset P = prod_mset Q\" \n    and P: \"set_mset P \\<subseteq> {q. irreducible q \\<and> monic q}\"\n    and Q: \"set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\"\n  shows \"P = Q\"", "lemma exactly_one_monic_factorization:\n  assumes mon: \"monic (f :: 'a :: field poly)\"\n  shows \"\\<exists>! fs. f = prod_mset fs \\<and> set_mset fs \\<subseteq> {q. irreducible q \\<and> monic q}\"", "lemma monic_prod_mset:\n  fixes as :: \"'a :: idom poly multiset\"\n  assumes \"\\<And> a. a \\<in> set_mset as \\<Longrightarrow> monic a\"\n  shows \"monic (prod_mset as)\"", "lemma exactly_one_factorization:\n  assumes f: \"f \\<noteq> (0 :: 'a :: field poly)\"\n  shows \"\\<exists>! cfs. factorization Irr_Mon f cfs\"", "lemma mod_ident_iff: \"m > 0 \\<Longrightarrow> (x :: int) mod m = x \\<longleftrightarrow> x \\<in> {0 ..< m}\"", "lemma mult_1_is_id[simp]: \"(*) (1 :: 'a :: ring_1) = id\"", "lemma degree_m_eq_monic: \"monic f \\<Longrightarrow> m > 1 \\<Longrightarrow> degree_m f = degree f\"", "lemma monic_degree_m_lift: assumes \"monic f\" \"k > 1\" \"m > 1\"\n  shows \"monic (poly_mod.Mp (m * k) f)\"", "lemma M_1[simp]: \"M 1 = 1\"", "lemma Mp_1[simp]: \"Mp 1 = 1\"", "lemma monic_degree_m[simp]: \"monic f \\<Longrightarrow> degree_m f = degree f\"", "lemma monic_Mp: \"monic f \\<Longrightarrow> monic (Mp f)\"", "lemma Mp_0_smult_sdiv_poly: assumes \"Mp f = 0\" \n  shows \"smult m (sdiv_poly f m) = f\"", "lemma Mp_product_modulus: \"m' = m * k \\<Longrightarrow> k > 0 \\<Longrightarrow> Mp (poly_mod.Mp m' f) = Mp f\"", "lemma inv_M_rev: assumes bnd: \"2 * abs c < m\" \n  shows \"inv_M (M c) = c\"", "lemma (in poly_mod) degree_m_eq_prime:\n  assumes f0: \"Mp f \\<noteq> 0\"\n  and deg: \"degree_m f = degree f\" \n  and eq: \"f =m g * h\" \n  and p: \"prime m\" \n  shows \"degree_m f = degree_m g + degree_m h\"", "lemma monic_smult_add_small: assumes \"f = 0 \\<or> degree f < degree g\" and mon: \"monic g\" \n  shows \"monic (g + smult q f)\"", "lemma Mf_Mf[simp]: \"Mf (Mf x) = Mf x\"", "lemma Mp_irreducible\\<^sub>d_m[simp]: \"irreducible\\<^sub>d_m (Mp f) = irreducible\\<^sub>d_m f\"", "lemma Mf_factorization_m[simp]: \"factorization_m f (Mf cfs) = factorization_m f cfs\"", "lemma unique_factorization_m_imp_factorization: assumes \"unique_factorization_m f cfs\" \n  shows \"factorization_m f cfs\"", "lemma unique_factorization_m_alt_def: \"unique_factorization_m f cfs = (factorization_m f cfs\n  \\<and> (\\<forall> dgs. factorization_m f dgs \\<longrightarrow> Mf dgs = Mf cfs))\"", "lemma factorization_m_lead_coeff: assumes \"factorization_m f (c,fs)\" \n  shows \"lead_coeff (Mp f) = M c\"", "lemma factorization_m_smult: assumes \"factorization_m f (c,fs)\" \n  shows \"factorization_m (smult d f) (c * d,fs)\"", "lemma factorization_m_prod: assumes \"factorization_m f (c,fs)\" \"factorization_m g (d,gs)\" \n  shows \"factorization_m (f * g) (c * d, fs + gs)\"", "lemma Mp_factorization_m[simp]: \"factorization_m (Mp f) cfs = factorization_m f cfs\"", "lemma Mp_unique_factorization_m[simp]: \n  \"unique_factorization_m (Mp f) cfs = unique_factorization_m f cfs\"", "lemma unique_factorization_m_cong: \"unique_factorization_m f cfs \\<Longrightarrow> Mp f = Mp g \n  \\<Longrightarrow> unique_factorization_m g cfs\"", "lemma unique_factorization_mI: assumes \"factorization_m f (c,fs)\" \n  and \"\\<And> d gs. factorization_m f (d,gs) \\<Longrightarrow> Mf (d,gs) = Mf (c,fs)\"\n  shows \"unique_factorization_m f (c,fs)\"", "lemma unique_factorization_m_smult: assumes uf: \"unique_factorization_m f (c,fs)\"\n  and d: \"M (di * d) = 1\"\n  shows \"unique_factorization_m (smult d f) (c * d,fs)\"", "lemma unique_factorization_m_smultD: assumes uf: \"unique_factorization_m (smult d f) (c,fs)\"\n  and d: \"M (di * d) = 1\"\n  shows \"unique_factorization_m f (c * di,fs)\"", "lemma degree_m_eq_lead_coeff: \"degree_m f = degree f \\<Longrightarrow> lead_coeff (Mp f) = M (lead_coeff f)\"", "lemma unique_factorization_m_zero: assumes \"unique_factorization_m f (c,fs)\" \n  shows \"M c \\<noteq> 0\"", "lemma dvdm_smult: assumes \"f dvdm g\" \n  shows \"f dvdm smult c g\"", "lemma dvdm_factor: assumes \"f dvdm g\" \n  shows \"f dvdm g * h\"", "lemma square_free_m_smultD: assumes \"square_free_m (smult c f)\" \n  shows \"square_free_m f\"", "lemma square_free_m_smultI: assumes sf: \"square_free_m f\" \n  and inv: \"M (ci * c) = 1\" \n  shows \"square_free_m (smult c f)\"", "lemma square_free_m_factor: assumes \"square_free_m (f * g)\" \n  shows \"square_free_m f\" \"square_free_m g\"", "lemma Mp_ident_iff: \"Mp f = f \\<longleftrightarrow> (\\<forall> n. coeff f n \\<in> {0 ..< m})\"", "lemma Mp_ident_iff': \"Mp f = f \\<longleftrightarrow> (set (coeffs f) \\<subseteq> {0 ..< m})\"", "lemma Mp_Mp_pow_is_Mp: \"n \\<noteq> 0 \\<Longrightarrow> p > 1 \\<Longrightarrow> poly_mod.Mp p (poly_mod.Mp (p^n) f) \n  = poly_mod.Mp p f\"", "lemma M_M_pow_is_M: \"n \\<noteq> 0 \\<Longrightarrow> p > 1 \\<Longrightarrow> poly_mod.M p (poly_mod.M (p^n) f) \n  = poly_mod.M p f\"", "lemma inverse_mod:\n  \"(inverse_mod x m * x) mod m = 1\"\n  if \"coprime x m\" \"m > 1\"", "lemma inverse_mod_pow:\n  \"(inverse_mod x (p ^ n) * x) mod (p ^ n) = 1\"\n  if \"coprime x p\" \"p > 1\" \"n \\<noteq> 0\"", "lemma (in poly_mod) inverse_mod_coprime:\n  assumes p: \"prime m\" \n  and cop: \"coprime x m\" shows \"M (inverse_mod x m * x) = 1\"", "lemma (in poly_mod) inverse_mod_coprime_exp:\n  assumes m: \"m = p^n\" and p: \"prime p\" \n  and n: \"n \\<noteq> 0\" and cop: \"coprime x p\"\n  shows \"M (inverse_mod x m * x) = 1\"", "lemma square_free_m_prod_imp_coprime_m: assumes sf: \"square_free_m (A * B)\" \n  shows \"coprime_m A B\"", "lemma coprime_exp_mod: \"coprime lu p \\<Longrightarrow> n \\<noteq> 0 \\<Longrightarrow> lu mod p ^ n \\<noteq> 0\"", "lemma Dp_Mp_eq: \"f = Mp f + smult m (Dp f)\"", "lemma dvd_imp_dvdm:\n  assumes \"a dvd b\" shows \"a dvdm b\"", "lemma dvdm_add:\n  assumes a: \"u dvdm a\"\n  and b: \"u dvdm b\"\n  shows \"u dvdm (a+b)\"", "lemma monic_dvdm_constant:\n  assumes uk: \"u dvdm [:k:]\"\n  and u1: \"monic u\" and u2: \"degree u > 0\" \n  shows \"k mod m = 0\"", "lemma div_mod_imp_dvdm:\n  assumes \"\\<exists>q r. b = q * a + Polynomial.smult m r\"\n  shows \"a dvdm b\"", "lemma lead_coeff_monic_mult:\n  fixes p :: \"'a :: {comm_semiring_1,semiring_no_zero_divisors} poly\"\n  assumes \"monic p\" shows \"lead_coeff (p * q) = lead_coeff q\"", "lemma degree_m_mult_eq:\n  assumes p: \"monic p\" and q: \"lead_coeff q mod m \\<noteq> 0\" and m1: \"m > 1\"\n  shows \"degree (Mp (p * q)) = degree p + degree q\"", "lemma dvdm_imp_degree_le:\n  assumes pq: \"p dvdm q\" and p: \"monic p\" and q0: \"Mp q \\<noteq> 0\" and m1: \"m > 1\"\n  shows \"degree p \\<le> degree q\"", "lemma dvdm_uminus [simp]:\n  \"p dvdm -q \\<longleftrightarrow> p dvdm q\"", "lemma Mp_const_poly: \"Mp [:a:] = [:a mod m:]\"", "lemma dvdm_imp_div_mod:\n  assumes \"u dvdm g\"\n  shows \"\\<exists>q r. g = q*u + smult m r\"", "lemma dvdmE':\n  assumes \"p dvdm q\" and \"\\<And>r. q =m p * Mp r \\<Longrightarrow> thesis\"\n  shows thesis", "lemma factorization_m_mem_dvdm: assumes fact: \"factorization_m f (c,fs)\" \n  and mem: \"Mp g \\<in># image_mset Mp fs\" \nshows \"g dvdm f\"", "lemma dvdm_degree: \"monic u \\<Longrightarrow> u dvdm f \\<Longrightarrow> Mp f \\<noteq> 0 \\<Longrightarrow> degree u \\<le> degree f\"", "lemma (in poly_mod_prime) pl_dvdm_imp_p_dvdm:\n  assumes l0: \"l \\<noteq> 0\" \n  and pl_dvdm: \"poly_mod.dvdm (p^l) a b\"\n  shows \"a dvdm b\""], "translations": [["", "lemma M_0[simp]: \"M 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M 0 = 0", "by (auto simp add: M_def)"], ["", "lemma M_M[simp]: \"M (M x) = M x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M (M x) = M x", "by (auto simp add: M_def)"], ["", "lemma M_plus[simp]: \"M (M x + y) = M (x + y)\" \"M (x + M y) = M (x + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M (M x + y) = M (x + y) &&& M (x + M y) = M (x + y)", "by (auto simp add: M_def mod_simps)"], ["", "lemma M_minus[simp]: \"M (M x - y) = M (x - y)\" \"M (x - M y) = M (x - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M (M x - y) = M (x - y) &&& M (x - M y) = M (x - y)", "by (auto simp add: M_def mod_simps)"], ["", "lemma M_times[simp]: \"M (M x * y) = M (x * y)\" \"M (x * M y) = M (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M (M x * y) = M (x * y) &&& M (x * M y) = M (x * y)", "by (auto simp add: M_def mod_simps)"], ["", "lemma M_sum: \"M (sum (\\<lambda> x. M (f x)) A) = M (sum f A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M (\\<Sum>x\\<in>A. M (f x)) = M (sum f A)", "proof (induct A rule: infinite_finite_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow> M (\\<Sum>x\\<in>A. M (f x)) = M (sum f A)\n 2. M (\\<Sum>x\\<in>{}. M (f x)) = M (sum f {})\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        M (\\<Sum>x\\<in>F. M (f x)) = M (sum f F)\\<rbrakk>\n       \\<Longrightarrow> M (\\<Sum>x\\<in>insert x F. M (f x)) =\n                         M (sum f (insert x F))", "case (insert x A)"], ["proof (state)\nthis:\n  finite A\n  x \\<notin> A\n  M (\\<Sum>x\\<in>A. M (f x)) = M (sum f A)\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow> M (\\<Sum>x\\<in>A. M (f x)) = M (sum f A)\n 2. M (\\<Sum>x\\<in>{}. M (f x)) = M (sum f {})\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        M (\\<Sum>x\\<in>F. M (f x)) = M (sum f F)\\<rbrakk>\n       \\<Longrightarrow> M (\\<Sum>x\\<in>insert x F. M (f x)) =\n                         M (sum f (insert x F))", "from insert(1-2)"], ["proof (chain)\npicking this:\n  finite A\n  x \\<notin> A", "have \"M (\\<Sum>x\\<in>insert x A. M (f x)) = M (f x + M ((\\<Sum>x\\<in>A. M (f x))))\""], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n\ngoal (1 subgoal):\n 1. M (\\<Sum>x\\<in>insert x A. M (f x)) =\n    M (f x + M (\\<Sum>x\\<in>A. M (f x)))", "by simp"], ["proof (state)\nthis:\n  M (\\<Sum>x\\<in>insert x A. M (f x)) = M (f x + M (\\<Sum>x\\<in>A. M (f x)))\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow> M (\\<Sum>x\\<in>A. M (f x)) = M (sum f A)\n 2. M (\\<Sum>x\\<in>{}. M (f x)) = M (sum f {})\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        M (\\<Sum>x\\<in>F. M (f x)) = M (sum f F)\\<rbrakk>\n       \\<Longrightarrow> M (\\<Sum>x\\<in>insert x F. M (f x)) =\n                         M (sum f (insert x F))", "also"], ["proof (state)\nthis:\n  M (\\<Sum>x\\<in>insert x A. M (f x)) = M (f x + M (\\<Sum>x\\<in>A. M (f x)))\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow> M (\\<Sum>x\\<in>A. M (f x)) = M (sum f A)\n 2. M (\\<Sum>x\\<in>{}. M (f x)) = M (sum f {})\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        M (\\<Sum>x\\<in>F. M (f x)) = M (sum f F)\\<rbrakk>\n       \\<Longrightarrow> M (\\<Sum>x\\<in>insert x F. M (f x)) =\n                         M (sum f (insert x F))", "have \"M ((\\<Sum>x\\<in>A. M (f x))) = M ((\\<Sum>x\\<in>A. f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M (\\<Sum>x\\<in>A. M (f x)) = M (sum f A)", "using insert"], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  M (\\<Sum>x\\<in>A. M (f x)) = M (sum f A)\n\ngoal (1 subgoal):\n 1. M (\\<Sum>x\\<in>A. M (f x)) = M (sum f A)", "by simp"], ["proof (state)\nthis:\n  M (\\<Sum>x\\<in>A. M (f x)) = M (sum f A)\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow> M (\\<Sum>x\\<in>A. M (f x)) = M (sum f A)\n 2. M (\\<Sum>x\\<in>{}. M (f x)) = M (sum f {})\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        M (\\<Sum>x\\<in>F. M (f x)) = M (sum f F)\\<rbrakk>\n       \\<Longrightarrow> M (\\<Sum>x\\<in>insert x F. M (f x)) =\n                         M (sum f (insert x F))", "finally"], ["proof (chain)\npicking this:\n  M (\\<Sum>x\\<in>insert x A. M (f x)) = M (f x + M (sum f A))", "show ?case"], ["proof (prove)\nusing this:\n  M (\\<Sum>x\\<in>insert x A. M (f x)) = M (f x + M (sum f A))\n\ngoal (1 subgoal):\n 1. M (\\<Sum>x\\<in>insert x A. M (f x)) = M (sum f (insert x A))", "using insert"], ["proof (prove)\nusing this:\n  M (\\<Sum>x\\<in>insert x A. M (f x)) = M (f x + M (sum f A))\n  finite A\n  x \\<notin> A\n  M (\\<Sum>x\\<in>A. M (f x)) = M (sum f A)\n\ngoal (1 subgoal):\n 1. M (\\<Sum>x\\<in>insert x A. M (f x)) = M (sum f (insert x A))", "by simp"], ["proof (state)\nthis:\n  M (\\<Sum>x\\<in>insert x A. M (f x)) = M (sum f (insert x A))\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow> M (\\<Sum>x\\<in>A. M (f x)) = M (sum f A)\n 2. M (\\<Sum>x\\<in>{}. M (f x)) = M (sum f {})", "qed auto"], ["", "definition inv_M :: \"int \\<Rightarrow> int\" where\n  \"inv_M = (\\<lambda> x. if x + x \\<le> m then x else x - m)\""], ["", "lemma M_inv_M_id[simp]: \"M (inv_M x) = M x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M (inv_M x) = M x", "unfolding inv_M_def M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x + x \\<le> m then x else x - m) mod m = x mod m", "by simp"], ["", "definition Mp :: \"int poly \\<Rightarrow> int poly\" where \"Mp = map_poly M\""], ["", "lemma Mp_0[simp]: \"Mp 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp 0 = 0", "unfolding Mp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly M 0 = 0", "by auto"], ["", "lemma Mp_coeff: \"coeff (Mp f) i = M (coeff f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (Mp f) i = M (coeff f i)", "unfolding Mp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (map_poly M f) i = M (coeff f i)", "by (simp add: M_def coeff_map_poly)"], ["", "abbreviation eq_m :: \"int poly \\<Rightarrow> int poly \\<Rightarrow> bool\" (infixl \"=m\" 50) where\n  \"f =m g \\<equiv> (Mp f = Mp g)\""], ["", "notation eq_m (infixl \"=m\" 50)"], ["", "abbreviation degree_m :: \"int poly \\<Rightarrow> nat\" where \n  \"degree_m f \\<equiv> degree (Mp f)\""], ["", "lemma mult_Mp[simp]: \"Mp (Mp f * g) = Mp (f * g)\" \"Mp (f * Mp g) = Mp (f * g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp f * g =m f * g &&& f * Mp g =m f * g", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. Mp f * g =m f * g\n 2. f * Mp g =m f * g", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. Mp f * g =m f * g\n 2. f * Mp g =m f * g", "fix f g"], ["proof (state)\ngoal (2 subgoals):\n 1. Mp f * g =m f * g\n 2. f * Mp g =m f * g", "have \"Mp (Mp f * g) = Mp (f * g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp f * g =m f * g", "unfolding poly_eq_iff Mp_coeff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. M (coeff (Mp f * g) n) = M (coeff (f * g) n)", "unfolding coeff_mult Mp_coeff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       M (\\<Sum>i\\<le>n. M (coeff f i) * coeff g (n - i)) =\n       M (\\<Sum>i\\<le>n. coeff f i * coeff g (n - i))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       M (\\<Sum>i\\<le>n. M (coeff f i) * coeff g (n - i)) =\n       M (\\<Sum>i\\<le>n. coeff f i * coeff g (n - i))", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       M (\\<Sum>i\\<le>n. M (coeff f i) * coeff g (n - i)) =\n       M (\\<Sum>i\\<le>n. coeff f i * coeff g (n - i))", "show \"M (\\<Sum>i\\<le>n. M (coeff f i) * coeff g (n - i)) = M (\\<Sum>i\\<le>n. coeff f i * coeff g (n - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M (\\<Sum>i\\<le>n. M (coeff f i) * coeff g (n - i)) =\n    M (\\<Sum>i\\<le>n. coeff f i * coeff g (n - i))", "by (subst M_sum[symmetric], rule sym, subst M_sum[symmetric], unfold M_times, simp)"], ["proof (state)\nthis:\n  M (\\<Sum>i\\<le>n. M (coeff f i) * coeff g (n - i)) =\n  M (\\<Sum>i\\<le>n. coeff f i * coeff g (n - i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Mp f * g =m f * g\n\ngoal (2 subgoals):\n 1. Mp f * g =m f * g\n 2. f * Mp g =m f * g", "}"], ["proof (state)\nthis:\n  Mp ?fa2 * ?ga2 =m ?fa2 * ?ga2\n\ngoal (2 subgoals):\n 1. Mp f * g =m f * g\n 2. f * Mp g =m f * g", "from this[of f g] this[of g f]"], ["proof (chain)\npicking this:\n  Mp f * g =m f * g\n  Mp g * f =m g * f", "show \"Mp (Mp f * g) = Mp (f * g)\" \"Mp (f * Mp g) = Mp (f * g)\""], ["proof (prove)\nusing this:\n  Mp f * g =m f * g\n  Mp g * f =m g * f\n\ngoal (1 subgoal):\n 1. Mp f * g =m f * g &&& f * Mp g =m f * g", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  Mp f * g =m f * g\n  f * Mp g =m f * g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma plus_Mp[simp]: \"Mp (Mp f + g) = Mp (f + g)\" \"Mp (f + Mp g) = Mp (f + g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp f + g =m f + g &&& f + Mp g =m f + g", "unfolding poly_eq_iff Mp_coeff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. M (coeff (Mp f + g) n) = M (coeff (f + g) n) &&&\n    \\<forall>n. M (coeff (f + Mp g) n) = M (coeff (f + g) n)", "unfolding coeff_mult Mp_coeff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. M (coeff (Mp f + g) n) = M (coeff (f + g) n) &&&\n    \\<forall>n. M (coeff (f + Mp g) n) = M (coeff (f + g) n)", "by (auto simp add: Mp_coeff)"], ["", "lemma minus_Mp[simp]: \"Mp (Mp f - g) = Mp (f - g)\" \"Mp (f - Mp g) = Mp (f - g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp f - g =m f - g &&& f - Mp g =m f - g", "unfolding poly_eq_iff Mp_coeff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. M (coeff (Mp f - g) n) = M (coeff (f - g) n) &&&\n    \\<forall>n. M (coeff (f - Mp g) n) = M (coeff (f - g) n)", "unfolding coeff_mult Mp_coeff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. M (coeff (Mp f - g) n) = M (coeff (f - g) n) &&&\n    \\<forall>n. M (coeff (f - Mp g) n) = M (coeff (f - g) n)", "by (auto simp add: Mp_coeff)"], ["", "lemma Mp_smult[simp]: \"Mp (smult (M a) f) = Mp (smult a f)\" \"Mp (smult a (Mp f)) = Mp (smult a f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (M a) f =m smult a f &&& smult a (Mp f) =m smult a f", "unfolding Mp_def smult_as_map_poly"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly M (map_poly ((*) (M a)) f) =\n    map_poly M (map_poly ((*) a) f) &&&\n    map_poly M (map_poly ((*) a) (map_poly M f)) =\n    map_poly M (map_poly ((*) a) f)", "by (rule poly_eqI, auto simp: coeff_map_poly)+"], ["", "lemma Mp_Mp[simp]: \"Mp (Mp f) = Mp f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp f =m f", "unfolding Mp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly M (map_poly M f) = map_poly M f", "by (intro poly_eqI, auto simp: coeff_map_poly)"], ["", "lemma Mp_smult_m_0[simp]: \"Mp (smult m f) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (smult m f) = 0", "by (intro poly_eqI, auto simp: Mp_coeff, auto simp: M_def)"], ["", "definition dvdm :: \"int poly \\<Rightarrow> int poly \\<Rightarrow> bool\" (infix \"dvdm\" 50) where\n  \"f dvdm g = (\\<exists> h. g =m f * h)\""], ["", "notation dvdm (infix \"dvdm\" 50)"], ["", "lemma dvdmE:\n  assumes fg: \"f dvdm g\"\n    and main: \"\\<And>h. g =m f * h \\<Longrightarrow> Mp h = h \\<Longrightarrow> thesis\"\n  shows \"thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. thesis", "from fg"], ["proof (chain)\npicking this:\n  f dvdm g", "obtain h where \"g =m f * h\""], ["proof (prove)\nusing this:\n  f dvdm g\n\ngoal (1 subgoal):\n 1. (\\<And>h. g =m f * h \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto simp: dvdm_def)"], ["proof (state)\nthis:\n  g =m f * h\n\ngoal (1 subgoal):\n 1. thesis", "then"], ["proof (chain)\npicking this:\n  g =m f * h", "have \"g =m f * Mp h\""], ["proof (prove)\nusing this:\n  g =m f * h\n\ngoal (1 subgoal):\n 1. g =m f * Mp h", "by auto"], ["proof (state)\nthis:\n  g =m f * Mp h\n\ngoal (1 subgoal):\n 1. thesis", "from main[OF this]"], ["proof (chain)\npicking this:\n  Mp h =m h \\<Longrightarrow> thesis", "show thesis"], ["proof (prove)\nusing this:\n  Mp h =m h \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Mp_dvdm[simp]: \"Mp f dvdm g \\<longleftrightarrow> f dvdm g\"\n  and dvdm_Mp[simp]: \"f dvdm Mp g \\<longleftrightarrow> f dvdm g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mp f dvdm g) = (f dvdm g) &&& (f dvdm Mp g) = (f dvdm g)", "by (auto simp: dvdm_def)"], ["", "definition irreducible_m\n  where \"irreducible_m f = (\\<not>f =m 0 \\<and> \\<not> f dvdm 1 \\<and> (\\<forall>a b. f =m a * b \\<longrightarrow> a dvdm 1 \\<or> b dvdm 1))\""], ["", "definition irreducible\\<^sub>d_m :: \"int poly \\<Rightarrow> bool\" where \"irreducible\\<^sub>d_m f \\<equiv>\n   degree_m f > 0 \\<and>\n   (\\<forall> g h. degree_m g < degree_m f \\<longrightarrow> degree_m h < degree_m f \\<longrightarrow> \\<not> f =m g * h)\""], ["", "definition prime_elem_m\n  where \"prime_elem_m f \\<equiv> \\<not> f =m 0 \\<and> \\<not> f dvdm 1 \\<and> (\\<forall>g h. f dvdm g * h \\<longrightarrow> f dvdm g \\<or> f dvdm h)\""], ["", "lemma degree_m_le_degree [intro!]: \"degree_m f \\<le> degree f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m f \\<le> degree f", "by (simp add: Mp_def degree_map_poly_le)"], ["", "lemma irreducible\\<^sub>d_mI:\n  assumes f0: \"degree_m f > 0\"\n      and main: \"\\<And>g h. Mp g = g \\<Longrightarrow> Mp h = h \\<Longrightarrow> degree g > 0 \\<Longrightarrow> degree g < degree_m f \\<Longrightarrow> degree h > 0 \\<Longrightarrow> degree h < degree_m f \\<Longrightarrow> f =m g * h \\<Longrightarrow> False\"\n    shows \"irreducible\\<^sub>d_m f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d_m f", "proof (unfold irreducible\\<^sub>d_m_def, intro conjI allI impI f0 notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g h.\n       \\<lbrakk>degree_m g < degree_m f; degree_m h < degree_m f;\n        f =m g * h\\<rbrakk>\n       \\<Longrightarrow> False", "fix g h"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g h.\n       \\<lbrakk>degree_m g < degree_m f; degree_m h < degree_m f;\n        f =m g * h\\<rbrakk>\n       \\<Longrightarrow> False", "assume deg: \"degree_m g < degree_m f\" \"degree_m h < degree_m f\" and \"f =m g * h\""], ["proof (state)\nthis:\n  degree_m g < degree_m f\n  degree_m h < degree_m f\n  f =m g * h\n\ngoal (1 subgoal):\n 1. \\<And>g h.\n       \\<lbrakk>degree_m g < degree_m f; degree_m h < degree_m f;\n        f =m g * h\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  degree_m g < degree_m f\n  degree_m h < degree_m f\n  f =m g * h", "have f: \"f =m Mp g * Mp h\""], ["proof (prove)\nusing this:\n  degree_m g < degree_m f\n  degree_m h < degree_m f\n  f =m g * h\n\ngoal (1 subgoal):\n 1. f =m Mp g * Mp h", "by simp"], ["proof (state)\nthis:\n  f =m Mp g * Mp h\n\ngoal (1 subgoal):\n 1. \\<And>g h.\n       \\<lbrakk>degree_m g < degree_m f; degree_m h < degree_m f;\n        f =m g * h\\<rbrakk>\n       \\<Longrightarrow> False", "have \"degree_m f \\<le> degree_m g + degree_m h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m f \\<le> degree_m g + degree_m h", "unfolding f"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m (Mp g * Mp h) \\<le> degree_m g + degree_m h", "using degree_mult_le order.trans"], ["proof (prove)\nusing this:\n  degree (?p * ?q) \\<le> degree ?p + degree ?q\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?c\\<rbrakk> \\<Longrightarrow> ?a \\<le> ?c\n\ngoal (1 subgoal):\n 1. degree_m (Mp g * Mp h) \\<le> degree_m g + degree_m h", "by blast"], ["proof (state)\nthis:\n  degree_m f \\<le> degree_m g + degree_m h\n\ngoal (1 subgoal):\n 1. \\<And>g h.\n       \\<lbrakk>degree_m g < degree_m f; degree_m h < degree_m f;\n        f =m g * h\\<rbrakk>\n       \\<Longrightarrow> False", "with main[of \"Mp g\" \"Mp h\"] deg f"], ["proof (chain)\npicking this:\n  \\<lbrakk>Mp g =m g; Mp h =m h; 0 < degree_m g; degree_m g < degree_m f;\n   0 < degree_m h; degree_m h < degree_m f; f =m Mp g * Mp h\\<rbrakk>\n  \\<Longrightarrow> False\n  degree_m g < degree_m f\n  degree_m h < degree_m f\n  f =m Mp g * Mp h\n  degree_m f \\<le> degree_m g + degree_m h", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>Mp g =m g; Mp h =m h; 0 < degree_m g; degree_m g < degree_m f;\n   0 < degree_m h; degree_m h < degree_m f; f =m Mp g * Mp h\\<rbrakk>\n  \\<Longrightarrow> False\n  degree_m g < degree_m f\n  degree_m h < degree_m f\n  f =m Mp g * Mp h\n  degree_m f \\<le> degree_m g + degree_m h\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma irreducible\\<^sub>d_mE:\n  assumes \"irreducible\\<^sub>d_m f\"\n    and \"degree_m f > 0 \\<Longrightarrow> (\\<And>g h. degree_m g < degree_m f \\<Longrightarrow> degree_m h < degree_m f \\<Longrightarrow> \\<not> f =m g * h) \\<Longrightarrow> thesis\"\n  shows thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using assms"], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d_m f\n  \\<lbrakk>0 < degree_m f;\n   \\<And>g h.\n      \\<lbrakk>degree_m g < degree_m f; degree_m h < degree_m f\\<rbrakk>\n      \\<Longrightarrow> Mp f \\<noteq> Mp (g * h)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (unfold irreducible\\<^sub>d_m_def, auto)"], ["", "lemma irreducible\\<^sub>d_mD:\n  assumes \"irreducible\\<^sub>d_m f\"\n  shows \"degree_m f > 0\" and \"\\<And>g h. degree_m g < degree_m f \\<Longrightarrow> degree_m h < degree_m f \\<Longrightarrow> \\<not> f =m g * h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree_m f &&&\n    (\\<And>g h.\n        \\<lbrakk>degree_m g < degree_m f; degree_m h < degree_m f\\<rbrakk>\n        \\<Longrightarrow> Mp f \\<noteq> Mp (g * h))", "using assms"], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d_m f\n\ngoal (1 subgoal):\n 1. 0 < degree_m f &&&\n    (\\<And>g h.\n        \\<lbrakk>degree_m g < degree_m f; degree_m h < degree_m f\\<rbrakk>\n        \\<Longrightarrow> Mp f \\<noteq> Mp (g * h))", "by (auto elim: irreducible\\<^sub>d_mE)"], ["", "definition square_free_m :: \"int poly \\<Rightarrow> bool\" where \n  \"square_free_m f = (\\<not> f =m 0 \\<and> (\\<forall> g. degree_m g \\<noteq> 0 \\<longrightarrow> \\<not> (g * g dvdm f)))\""], ["", "definition coprime_m :: \"int poly \\<Rightarrow> int poly \\<Rightarrow> bool\" where \n  \"coprime_m f g = (\\<forall> h. h dvdm f \\<longrightarrow> h dvdm g \\<longrightarrow> h dvdm 1)\""], ["", "lemma Mp_square_free_m[simp]: \"square_free_m (Mp f) = square_free_m f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free_m (Mp f) = square_free_m f", "unfolding square_free_m_def dvdm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mp (Mp f) \\<noteq> Mp 0 \\<and>\n     (\\<forall>g.\n         degree_m g \\<noteq> 0 \\<longrightarrow>\n         (\\<nexists>h. Mp f =m g * g * h))) =\n    (Mp f \\<noteq> Mp 0 \\<and>\n     (\\<forall>g.\n         degree_m g \\<noteq> 0 \\<longrightarrow>\n         (\\<nexists>h. f =m g * g * h)))", "by simp"], ["", "lemma square_free_m_cong: \"square_free_m f \\<Longrightarrow> Mp f = Mp g \\<Longrightarrow> square_free_m g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>square_free_m f; f =m g\\<rbrakk>\n    \\<Longrightarrow> square_free_m g", "unfolding square_free_m_def dvdm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Mp f \\<noteq> Mp 0 \\<and>\n             (\\<forall>g.\n                 degree_m g \\<noteq> 0 \\<longrightarrow>\n                 (\\<nexists>h. f =m g * g * h));\n     f =m g\\<rbrakk>\n    \\<Longrightarrow> Mp g \\<noteq> Mp 0 \\<and>\n                      (\\<forall>ga.\n                          degree_m ga \\<noteq> 0 \\<longrightarrow>\n                          (\\<nexists>h. g =m ga * ga * h))", "by simp"], ["", "lemma Mp_prod_mset[simp]: \"Mp (prod_mset (image_mset Mp b)) = Mp (prod_mset b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>\\<^sub># (image_mset Mp b) =m \\<Prod>\\<^sub># b", "proof (induct b)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Prod>\\<^sub># (image_mset Mp {#}) =m \\<Prod>\\<^sub># {#}\n 2. \\<And>x b.\n       \\<Prod>\\<^sub># (image_mset Mp b) =m\n       \\<Prod>\\<^sub># b \\<Longrightarrow>\n       \\<Prod>\\<^sub># (image_mset Mp (add_mset x b)) =m\n       \\<Prod>\\<^sub># (add_mset x b)", "case (add x b)"], ["proof (state)\nthis:\n  \\<Prod>\\<^sub># (image_mset Mp b) =m \\<Prod>\\<^sub># b\n\ngoal (2 subgoals):\n 1. \\<Prod>\\<^sub># (image_mset Mp {#}) =m \\<Prod>\\<^sub># {#}\n 2. \\<And>x b.\n       \\<Prod>\\<^sub># (image_mset Mp b) =m\n       \\<Prod>\\<^sub># b \\<Longrightarrow>\n       \\<Prod>\\<^sub># (image_mset Mp (add_mset x b)) =m\n       \\<Prod>\\<^sub># (add_mset x b)", "have \"Mp (prod_mset (image_mset Mp ({#x#}+b))) = Mp (Mp x * prod_mset (image_mset Mp b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>\\<^sub># (image_mset Mp ({#x#} + b)) =m\n    Mp x * \\<Prod>\\<^sub># (image_mset Mp b)", "by simp"], ["proof (state)\nthis:\n  \\<Prod>\\<^sub># (image_mset Mp ({#x#} + b)) =m\n  Mp x * \\<Prod>\\<^sub># (image_mset Mp b)\n\ngoal (2 subgoals):\n 1. \\<Prod>\\<^sub># (image_mset Mp {#}) =m \\<Prod>\\<^sub># {#}\n 2. \\<And>x b.\n       \\<Prod>\\<^sub># (image_mset Mp b) =m\n       \\<Prod>\\<^sub># b \\<Longrightarrow>\n       \\<Prod>\\<^sub># (image_mset Mp (add_mset x b)) =m\n       \\<Prod>\\<^sub># (add_mset x b)", "also"], ["proof (state)\nthis:\n  \\<Prod>\\<^sub># (image_mset Mp ({#x#} + b)) =m\n  Mp x * \\<Prod>\\<^sub># (image_mset Mp b)\n\ngoal (2 subgoals):\n 1. \\<Prod>\\<^sub># (image_mset Mp {#}) =m \\<Prod>\\<^sub># {#}\n 2. \\<And>x b.\n       \\<Prod>\\<^sub># (image_mset Mp b) =m\n       \\<Prod>\\<^sub># b \\<Longrightarrow>\n       \\<Prod>\\<^sub># (image_mset Mp (add_mset x b)) =m\n       \\<Prod>\\<^sub># (add_mset x b)", "have \"\\<dots> = Mp (Mp x * Mp (prod_mset (image_mset Mp b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp x * \\<Prod>\\<^sub># (image_mset Mp b) =m\n    Mp x * Mp (\\<Prod>\\<^sub># (image_mset Mp b))", "by simp"], ["proof (state)\nthis:\n  Mp x * \\<Prod>\\<^sub># (image_mset Mp b) =m\n  Mp x * Mp (\\<Prod>\\<^sub># (image_mset Mp b))\n\ngoal (2 subgoals):\n 1. \\<Prod>\\<^sub># (image_mset Mp {#}) =m \\<Prod>\\<^sub># {#}\n 2. \\<And>x b.\n       \\<Prod>\\<^sub># (image_mset Mp b) =m\n       \\<Prod>\\<^sub># b \\<Longrightarrow>\n       \\<Prod>\\<^sub># (image_mset Mp (add_mset x b)) =m\n       \\<Prod>\\<^sub># (add_mset x b)", "also"], ["proof (state)\nthis:\n  Mp x * \\<Prod>\\<^sub># (image_mset Mp b) =m\n  Mp x * Mp (\\<Prod>\\<^sub># (image_mset Mp b))\n\ngoal (2 subgoals):\n 1. \\<Prod>\\<^sub># (image_mset Mp {#}) =m \\<Prod>\\<^sub># {#}\n 2. \\<And>x b.\n       \\<Prod>\\<^sub># (image_mset Mp b) =m\n       \\<Prod>\\<^sub># b \\<Longrightarrow>\n       \\<Prod>\\<^sub># (image_mset Mp (add_mset x b)) =m\n       \\<Prod>\\<^sub># (add_mset x b)", "have \"\\<dots> = Mp ( Mp x * Mp (prod_mset b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp x * Mp (\\<Prod>\\<^sub># (image_mset Mp b)) =m\n    Mp x * Mp (\\<Prod>\\<^sub># b)", "unfolding add"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp x * Mp (\\<Prod>\\<^sub># b) =m Mp x * Mp (\\<Prod>\\<^sub># b)", "by simp"], ["proof (state)\nthis:\n  Mp x * Mp (\\<Prod>\\<^sub># (image_mset Mp b)) =m\n  Mp x * Mp (\\<Prod>\\<^sub># b)\n\ngoal (2 subgoals):\n 1. \\<Prod>\\<^sub># (image_mset Mp {#}) =m \\<Prod>\\<^sub># {#}\n 2. \\<And>x b.\n       \\<Prod>\\<^sub># (image_mset Mp b) =m\n       \\<Prod>\\<^sub># b \\<Longrightarrow>\n       \\<Prod>\\<^sub># (image_mset Mp (add_mset x b)) =m\n       \\<Prod>\\<^sub># (add_mset x b)", "finally"], ["proof (chain)\npicking this:\n  \\<Prod>\\<^sub># (image_mset Mp ({#x#} + b)) =m\n  Mp x * Mp (\\<Prod>\\<^sub># b)", "show ?case"], ["proof (prove)\nusing this:\n  \\<Prod>\\<^sub># (image_mset Mp ({#x#} + b)) =m\n  Mp x * Mp (\\<Prod>\\<^sub># b)\n\ngoal (1 subgoal):\n 1. \\<Prod>\\<^sub># (image_mset Mp (add_mset x b)) =m\n    \\<Prod>\\<^sub># (add_mset x b)", "by simp"], ["proof (state)\nthis:\n  \\<Prod>\\<^sub># (image_mset Mp (add_mset x b)) =m\n  \\<Prod>\\<^sub># (add_mset x b)\n\ngoal (1 subgoal):\n 1. \\<Prod>\\<^sub># (image_mset Mp {#}) =m \\<Prod>\\<^sub># {#}", "qed simp"], ["", "lemma Mp_prod_list: \"Mp (prod_list (map Mp b)) = Mp (prod_list b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map Mp b) =m prod_list b", "proof (induct b)"], ["proof (state)\ngoal (2 subgoals):\n 1. prod_list (map Mp []) =m prod_list []\n 2. \\<And>a b.\n       prod_list (map Mp b) =m prod_list b \\<Longrightarrow>\n       prod_list (map Mp (a # b)) =m prod_list (a # b)", "case (Cons b xs)"], ["proof (state)\nthis:\n  prod_list (map Mp xs) =m prod_list xs\n\ngoal (2 subgoals):\n 1. prod_list (map Mp []) =m prod_list []\n 2. \\<And>a b.\n       prod_list (map Mp b) =m prod_list b \\<Longrightarrow>\n       prod_list (map Mp (a # b)) =m prod_list (a # b)", "have \"Mp (prod_list (map Mp (b # xs))) = Mp (Mp b * prod_list (map Mp xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map Mp (b # xs)) =m Mp b * prod_list (map Mp xs)", "by simp"], ["proof (state)\nthis:\n  prod_list (map Mp (b # xs)) =m Mp b * prod_list (map Mp xs)\n\ngoal (2 subgoals):\n 1. prod_list (map Mp []) =m prod_list []\n 2. \\<And>a b.\n       prod_list (map Mp b) =m prod_list b \\<Longrightarrow>\n       prod_list (map Mp (a # b)) =m prod_list (a # b)", "also"], ["proof (state)\nthis:\n  prod_list (map Mp (b # xs)) =m Mp b * prod_list (map Mp xs)\n\ngoal (2 subgoals):\n 1. prod_list (map Mp []) =m prod_list []\n 2. \\<And>a b.\n       prod_list (map Mp b) =m prod_list b \\<Longrightarrow>\n       prod_list (map Mp (a # b)) =m prod_list (a # b)", "have \"\\<dots> = Mp (Mp b * Mp (prod_list (map Mp xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp b * prod_list (map Mp xs) =m Mp b * Mp (prod_list (map Mp xs))", "by simp"], ["proof (state)\nthis:\n  Mp b * prod_list (map Mp xs) =m Mp b * Mp (prod_list (map Mp xs))\n\ngoal (2 subgoals):\n 1. prod_list (map Mp []) =m prod_list []\n 2. \\<And>a b.\n       prod_list (map Mp b) =m prod_list b \\<Longrightarrow>\n       prod_list (map Mp (a # b)) =m prod_list (a # b)", "also"], ["proof (state)\nthis:\n  Mp b * prod_list (map Mp xs) =m Mp b * Mp (prod_list (map Mp xs))\n\ngoal (2 subgoals):\n 1. prod_list (map Mp []) =m prod_list []\n 2. \\<And>a b.\n       prod_list (map Mp b) =m prod_list b \\<Longrightarrow>\n       prod_list (map Mp (a # b)) =m prod_list (a # b)", "have \"\\<dots> = Mp (Mp b * Mp (prod_list xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp b * Mp (prod_list (map Mp xs)) =m Mp b * Mp (prod_list xs)", "unfolding Cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp b * Mp (prod_list xs) =m Mp b * Mp (prod_list xs)", "by simp"], ["proof (state)\nthis:\n  Mp b * Mp (prod_list (map Mp xs)) =m Mp b * Mp (prod_list xs)\n\ngoal (2 subgoals):\n 1. prod_list (map Mp []) =m prod_list []\n 2. \\<And>a b.\n       prod_list (map Mp b) =m prod_list b \\<Longrightarrow>\n       prod_list (map Mp (a # b)) =m prod_list (a # b)", "finally"], ["proof (chain)\npicking this:\n  prod_list (map Mp (b # xs)) =m Mp b * Mp (prod_list xs)", "show ?case"], ["proof (prove)\nusing this:\n  prod_list (map Mp (b # xs)) =m Mp b * Mp (prod_list xs)\n\ngoal (1 subgoal):\n 1. prod_list (map Mp (b # xs)) =m prod_list (b # xs)", "by simp"], ["proof (state)\nthis:\n  prod_list (map Mp (b # xs)) =m prod_list (b # xs)\n\ngoal (1 subgoal):\n 1. prod_list (map Mp []) =m prod_list []", "qed simp"], ["", "text \\<open>Polynomial evaluation modulo\\<close>"], ["", "definition \"M_poly p x \\<equiv> M (poly p x)\""], ["", "lemma M_poly_Mp[simp]: \"M_poly (Mp p) = M_poly p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_poly (Mp p) = M_poly p", "proof(intro ext, induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. M_poly (Mp 0) x = M_poly 0 x\n 2. \\<And>a p x.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        \\<And>x. M_poly (Mp p) x = M_poly p x\\<rbrakk>\n       \\<Longrightarrow> M_poly (Mp (pCons a p)) x = M_poly (pCons a p) x", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x. M_poly (Mp 0) x = M_poly 0 x\n 2. \\<And>a p x.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        \\<And>x. M_poly (Mp p) x = M_poly p x\\<rbrakk>\n       \\<Longrightarrow> M_poly (Mp (pCons a p)) x = M_poly (pCons a p) x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. M_poly (Mp 0) x = M_poly 0 x", "by auto"], ["proof (state)\nthis:\n  M_poly (Mp 0) x = M_poly 0 x\n\ngoal (1 subgoal):\n 1. \\<And>a p x.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        \\<And>x. M_poly (Mp p) x = M_poly p x\\<rbrakk>\n       \\<Longrightarrow> M_poly (Mp (pCons a p)) x = M_poly (pCons a p) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p x.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        \\<And>x. M_poly (Mp p) x = M_poly p x\\<rbrakk>\n       \\<Longrightarrow> M_poly (Mp (pCons a p)) x = M_poly (pCons a p) x", "case IH: (pCons a p)"], ["proof (state)\nthis:\n  a \\<noteq> 0 \\<or> p \\<noteq> 0\n  M_poly (Mp p) ?x = M_poly p ?x\n\ngoal (1 subgoal):\n 1. \\<And>a p x.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        \\<And>x. M_poly (Mp p) x = M_poly p x\\<rbrakk>\n       \\<Longrightarrow> M_poly (Mp (pCons a p)) x = M_poly (pCons a p) x", "from IH(1)"], ["proof (chain)\npicking this:\n  a \\<noteq> 0 \\<or> p \\<noteq> 0", "have \"M_poly (Mp (pCons a p)) x = M (a + M(x * M_poly (Mp p) x))\""], ["proof (prove)\nusing this:\n  a \\<noteq> 0 \\<or> p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. M_poly (Mp (pCons a p)) x = M (a + M (x * M_poly (Mp p) x))", "by (simp add: M_poly_def Mp_def)"], ["proof (state)\nthis:\n  M_poly (Mp (pCons a p)) x = M (a + M (x * M_poly (Mp p) x))\n\ngoal (1 subgoal):\n 1. \\<And>a p x.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        \\<And>x. M_poly (Mp p) x = M_poly p x\\<rbrakk>\n       \\<Longrightarrow> M_poly (Mp (pCons a p)) x = M_poly (pCons a p) x", "also"], ["proof (state)\nthis:\n  M_poly (Mp (pCons a p)) x = M (a + M (x * M_poly (Mp p) x))\n\ngoal (1 subgoal):\n 1. \\<And>a p x.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        \\<And>x. M_poly (Mp p) x = M_poly p x\\<rbrakk>\n       \\<Longrightarrow> M_poly (Mp (pCons a p)) x = M_poly (pCons a p) x", "note IH(2)[of x]"], ["proof (state)\nthis:\n  M_poly (Mp p) x = M_poly p x\n\ngoal (1 subgoal):\n 1. \\<And>a p x.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        \\<And>x. M_poly (Mp p) x = M_poly p x\\<rbrakk>\n       \\<Longrightarrow> M_poly (Mp (pCons a p)) x = M_poly (pCons a p) x", "finally"], ["proof (chain)\npicking this:\n  M_poly (Mp (pCons a p)) x = M (a + M (x * M_poly p x))", "show ?case"], ["proof (prove)\nusing this:\n  M_poly (Mp (pCons a p)) x = M (a + M (x * M_poly p x))\n\ngoal (1 subgoal):\n 1. M_poly (Mp (pCons a p)) x = M_poly (pCons a p) x", "by (simp add: M_poly_def)"], ["proof (state)\nthis:\n  M_poly (Mp (pCons a p)) x = M_poly (pCons a p) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Mp_lift_modulus: assumes \"f =m g\" \n  shows \"poly_mod.eq_m (m * k) (smult k f) (smult k g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.Mp (m * k) (smult k f) = poly_mod.Mp (m * k) (smult k g)", "using assms"], ["proof (prove)\nusing this:\n  f =m g\n\ngoal (1 subgoal):\n 1. poly_mod.Mp (m * k) (smult k f) = poly_mod.Mp (m * k) (smult k g)", "unfolding poly_eq_iff poly_mod.Mp_coeff coeff_smult"], ["proof (prove)\nusing this:\n  \\<forall>n. M (coeff f n) = M (coeff g n)\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       poly_mod.M (m * k) (k * coeff f n) =\n       poly_mod.M (m * k) (k * coeff g n)", "unfolding poly_mod.M_def"], ["proof (prove)\nusing this:\n  \\<forall>n. coeff f n mod m = coeff g n mod m\n\ngoal (1 subgoal):\n 1. \\<forall>n. k * coeff f n mod (m * k) = k * coeff g n mod (m * k)", "by simp"], ["", "lemma Mp_ident_product: \"n > 0 \\<Longrightarrow> Mp f = f \\<Longrightarrow> poly_mod.Mp (m * n) f = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; Mp f = f\\<rbrakk>\n    \\<Longrightarrow> poly_mod.Mp (m * n) f = f", "unfolding poly_eq_iff poly_mod.Mp_coeff poly_mod.M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; \\<forall>n. coeff f n mod m = coeff f n\\<rbrakk>\n    \\<Longrightarrow> \\<forall>na. coeff f na mod (m * n) = coeff f na", "by (auto simp add: zmod_zmult2_eq) (metis mod_div_trivial mod_0)"], ["", "lemma Mp_shrink_modulus: assumes \"poly_mod.eq_m (m * k) f g\" \"k \\<noteq> 0\" \n  shows \"f =m g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f =m g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f =m g", "from assms"], ["proof (chain)\npicking this:\n  poly_mod.Mp (m * k) f = poly_mod.Mp (m * k) g\n  k \\<noteq> 0", "have a: \"\\<And> n. coeff f n mod (m * k) = coeff g n mod (m * k)\""], ["proof (prove)\nusing this:\n  poly_mod.Mp (m * k) f = poly_mod.Mp (m * k) g\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>n. coeff f n mod (m * k) = coeff g n mod (m * k)", "unfolding poly_eq_iff poly_mod.Mp_coeff"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     poly_mod.M (m * k) (coeff f n) = poly_mod.M (m * k) (coeff g n)\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>n. coeff f n mod (m * k) = coeff g n mod (m * k)", "unfolding poly_mod.M_def"], ["proof (prove)\nusing this:\n  \\<forall>n. coeff f n mod (m * k) = coeff g n mod (m * k)\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>n. coeff f n mod (m * k) = coeff g n mod (m * k)", "by auto"], ["proof (state)\nthis:\n  coeff f ?n mod (m * k) = coeff g ?n mod (m * k)\n\ngoal (1 subgoal):\n 1. f =m g", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f =m g", "unfolding poly_eq_iff poly_mod.Mp_coeff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. M (coeff f n) = M (coeff g n)", "unfolding poly_mod.M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. coeff f n mod m = coeff g n mod m", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. coeff f n mod m = coeff g n mod m", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. coeff f n mod m = coeff g n mod m", "show \"coeff f n mod m = coeff g n mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff f n mod m = coeff g n mod m", "using a[of n] \\<open>k \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  coeff f n mod (m * k) = coeff g n mod (m * k)\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coeff f n mod m = coeff g n mod m", "by (metis mod_mult_right_eq mult.commute mult_cancel_left mult_mod_right)"], ["proof (state)\nthis:\n  coeff f n mod m = coeff g n mod m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f =m g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_m_le: \"degree_m f \\<le> degree f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m f \\<le> degree f", "unfolding Mp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (map_poly M f) \\<le> degree f", "by (rule degree_map_poly_le)"], ["", "lemma degree_m_eq: \"coeff f (degree f) mod m \\<noteq> 0 \\<Longrightarrow> m > 1 \\<Longrightarrow> degree_m f = degree f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lead_coeff f mod m \\<noteq> 0; 1 < m\\<rbrakk>\n    \\<Longrightarrow> degree_m f = degree f", "using degree_m_le[of f]"], ["proof (prove)\nusing this:\n  degree_m f \\<le> degree f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lead_coeff f mod m \\<noteq> 0; 1 < m\\<rbrakk>\n    \\<Longrightarrow> degree_m f = degree f", "unfolding Mp_def"], ["proof (prove)\nusing this:\n  degree (map_poly M f) \\<le> degree f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lead_coeff f mod m \\<noteq> 0; 1 < m\\<rbrakk>\n    \\<Longrightarrow> degree (map_poly M f) = degree f", "by (auto intro: degree_map_poly simp: Mp_def poly_mod.M_def)"], ["", "lemma degree_m_mult_le:  \n  assumes eq: \"f =m g * h\" \n  shows \"degree_m f \\<le> degree_m g + degree_m h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m f \\<le> degree_m g + degree_m h", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree_m f \\<le> degree_m g + degree_m h", "have \"degree_m f = degree_m (Mp g * Mp h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m f = degree_m (Mp g * Mp h)", "using eq"], ["proof (prove)\nusing this:\n  f =m g * h\n\ngoal (1 subgoal):\n 1. degree_m f = degree_m (Mp g * Mp h)", "by simp"], ["proof (state)\nthis:\n  degree_m f = degree_m (Mp g * Mp h)\n\ngoal (1 subgoal):\n 1. degree_m f \\<le> degree_m g + degree_m h", "also"], ["proof (state)\nthis:\n  degree_m f = degree_m (Mp g * Mp h)\n\ngoal (1 subgoal):\n 1. degree_m f \\<le> degree_m g + degree_m h", "have \"\\<dots> \\<le> degree (Mp g * Mp h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m (Mp g * Mp h) \\<le> degree (Mp g * Mp h)", "by (rule degree_m_le)"], ["proof (state)\nthis:\n  degree_m (Mp g * Mp h) \\<le> degree (Mp g * Mp h)\n\ngoal (1 subgoal):\n 1. degree_m f \\<le> degree_m g + degree_m h", "also"], ["proof (state)\nthis:\n  degree_m (Mp g * Mp h) \\<le> degree (Mp g * Mp h)\n\ngoal (1 subgoal):\n 1. degree_m f \\<le> degree_m g + degree_m h", "have \"\\<dots> \\<le> degree_m g + degree_m h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (Mp g * Mp h) \\<le> degree_m g + degree_m h", "by (rule degree_mult_le)"], ["proof (state)\nthis:\n  degree (Mp g * Mp h) \\<le> degree_m g + degree_m h\n\ngoal (1 subgoal):\n 1. degree_m f \\<le> degree_m g + degree_m h", "finally"], ["proof (chain)\npicking this:\n  degree_m f \\<le> degree_m g + degree_m h", "show ?thesis"], ["proof (prove)\nusing this:\n  degree_m f \\<le> degree_m g + degree_m h\n\ngoal (1 subgoal):\n 1. degree_m f \\<le> degree_m g + degree_m h", "by auto"], ["proof (state)\nthis:\n  degree_m f \\<le> degree_m g + degree_m h\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_m_smult_le: \"degree_m (smult c f) \\<le> degree_m f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m (smult c f) \\<le> degree_m f", "by (metis Mp_0 coeff_0 degree_le degree_m_le degree_smult_eq poly_mod.Mp_smult(2) smult_eq_0_iff)"], ["", "lemma irreducible_m_Mp[simp]: \"irreducible_m (Mp f) \\<longleftrightarrow> irreducible_m f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible_m (Mp f) = irreducible_m f", "by (simp add: irreducible_m_def)"], ["", "lemma eq_m_irreducible_m: \"f =m g \\<Longrightarrow> irreducible_m f \\<longleftrightarrow> irreducible_m g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f =m g \\<Longrightarrow> irreducible_m f = irreducible_m g", "using irreducible_m_Mp"], ["proof (prove)\nusing this:\n  irreducible_m (Mp ?f) = irreducible_m ?f\n\ngoal (1 subgoal):\n 1. f =m g \\<Longrightarrow> irreducible_m f = irreducible_m g", "by metis"], ["", "definition mset_factors_m where \"mset_factors_m F p \\<equiv>\n  F \\<noteq> {#} \\<and> (\\<forall>f. f \\<in># F \\<longrightarrow> irreducible_m f) \\<and> p =m prod_mset F\""], ["", "end"], ["", "declare poly_mod.M_def[code]"], ["", "declare poly_mod.Mp_def[code]"], ["", "declare poly_mod.inv_M_def[code]"], ["", "definition Irr_Mon :: \"'a :: comm_semiring_1 poly set\"\n  where \"Irr_Mon = {x. irreducible x \\<and> monic x}\""], ["", "definition factorization :: \"'a :: comm_semiring_1 poly set \\<Rightarrow> 'a poly \\<Rightarrow> ('a \\<times> 'a poly multiset) \\<Rightarrow> bool\" where\n  \"factorization Factors f cfs \\<equiv> (case cfs of (c,fs) \\<Rightarrow> f = (smult c (prod_mset fs)) \\<and> (set_mset fs \\<subseteq> Factors))\""], ["", "definition unique_factorization :: \"'a :: comm_semiring_1 poly set \\<Rightarrow> 'a poly \\<Rightarrow> ('a \\<times> 'a poly multiset) \\<Rightarrow> bool\" where\n  \"unique_factorization Factors f cfs = (Collect (factorization Factors f) = {cfs})\""], ["", "lemma irreducible_multD:\n  assumes l: \"irreducible (a*b)\"\n  shows \"a dvd 1 \\<and> irreducible b \\<or> b dvd 1 \\<and> irreducible a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "from l"], ["proof (chain)\npicking this:\n  irreducible (a * b)", "have \"a dvd 1 \\<or> b dvd 1\""], ["proof (prove)\nusing this:\n  irreducible (a * b)\n\ngoal (1 subgoal):\n 1. a dvd (1::'a) \\<or> b dvd (1::'a)", "by auto"], ["proof (state)\nthis:\n  a dvd (1::'a) \\<or> b dvd (1::'a)\n\ngoal (1 subgoal):\n 1. a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "then"], ["proof (chain)\npicking this:\n  a dvd (1::'a) \\<or> b dvd (1::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  a dvd (1::'a) \\<or> b dvd (1::'a)\n\ngoal (1 subgoal):\n 1. a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "proof(elim disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. a dvd (1::'a) \\<Longrightarrow>\n    a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a\n 2. b dvd (1::'a) \\<Longrightarrow>\n    a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "assume a: \"a dvd 1\""], ["proof (state)\nthis:\n  a dvd (1::'a)\n\ngoal (2 subgoals):\n 1. a dvd (1::'a) \\<Longrightarrow>\n    a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a\n 2. b dvd (1::'a) \\<Longrightarrow>\n    a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "with l"], ["proof (chain)\npicking this:\n  irreducible (a * b)\n  a dvd (1::'a)", "have \"irreducible b\""], ["proof (prove)\nusing this:\n  irreducible (a * b)\n  a dvd (1::'a)\n\ngoal (1 subgoal):\n 1. irreducible b", "unfolding irreducible_def"], ["proof (prove)\nusing this:\n  a * b \\<noteq> (0::'a) \\<and>\n  \\<not> a * b dvd (1::'a) \\<and>\n  (\\<forall>aa ba.\n      a * b = aa * ba \\<longrightarrow> aa dvd (1::'a) \\<or> ba dvd (1::'a))\n  a dvd (1::'a)\n\ngoal (1 subgoal):\n 1. b \\<noteq> (0::'a) \\<and>\n    \\<not> b dvd (1::'a) \\<and>\n    (\\<forall>a ba.\n        b = a * ba \\<longrightarrow> a dvd (1::'a) \\<or> ba dvd (1::'a))", "by (meson is_unit_mult_iff mult.left_commute mult_not_zero)"], ["proof (state)\nthis:\n  irreducible b\n\ngoal (2 subgoals):\n 1. a dvd (1::'a) \\<Longrightarrow>\n    a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a\n 2. b dvd (1::'a) \\<Longrightarrow>\n    a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "with a"], ["proof (chain)\npicking this:\n  a dvd (1::'a)\n  irreducible b", "show ?thesis"], ["proof (prove)\nusing this:\n  a dvd (1::'a)\n  irreducible b\n\ngoal (1 subgoal):\n 1. a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "by auto"], ["proof (state)\nthis:\n  a dvd (1::'a) \\<and> irreducible b \\<or>\n  b dvd (1::'a) \\<and> irreducible a\n\ngoal (1 subgoal):\n 1. b dvd (1::'a) \\<Longrightarrow>\n    a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b dvd (1::'a) \\<Longrightarrow>\n    a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "assume a: \"b dvd 1\""], ["proof (state)\nthis:\n  b dvd (1::'a)\n\ngoal (1 subgoal):\n 1. b dvd (1::'a) \\<Longrightarrow>\n    a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "with l"], ["proof (chain)\npicking this:\n  irreducible (a * b)\n  b dvd (1::'a)", "have \"irreducible a\""], ["proof (prove)\nusing this:\n  irreducible (a * b)\n  b dvd (1::'a)\n\ngoal (1 subgoal):\n 1. irreducible a", "unfolding irreducible_def"], ["proof (prove)\nusing this:\n  a * b \\<noteq> (0::'a) \\<and>\n  \\<not> a * b dvd (1::'a) \\<and>\n  (\\<forall>aa ba.\n      a * b = aa * ba \\<longrightarrow> aa dvd (1::'a) \\<or> ba dvd (1::'a))\n  b dvd (1::'a)\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<and>\n    \\<not> a dvd (1::'a) \\<and>\n    (\\<forall>aa b.\n        a = aa * b \\<longrightarrow> aa dvd (1::'a) \\<or> b dvd (1::'a))", "by (meson is_unit_mult_iff mult_not_zero semiring_normalization_rules(16))"], ["proof (state)\nthis:\n  irreducible a\n\ngoal (1 subgoal):\n 1. b dvd (1::'a) \\<Longrightarrow>\n    a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "with a"], ["proof (chain)\npicking this:\n  b dvd (1::'a)\n  irreducible a", "show ?thesis"], ["proof (prove)\nusing this:\n  b dvd (1::'a)\n  irreducible a\n\ngoal (1 subgoal):\n 1. a dvd (1::'a) \\<and> irreducible b \\<or>\n    b dvd (1::'a) \\<and> irreducible a", "by auto"], ["proof (state)\nthis:\n  a dvd (1::'a) \\<and> irreducible b \\<or>\n  b dvd (1::'a) \\<and> irreducible a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a dvd (1::'a) \\<and> irreducible b \\<or>\n  b dvd (1::'a) \\<and> irreducible a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma irreducible_dvd_prod_mset:\n  fixes p :: \"'a :: field poly\"\n  assumes irr: \"irreducible p\" and dvd: \"p dvd prod_mset as\"\n  shows \"\\<exists> a \\<in># as. p dvd a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>#as. p dvd a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>#as. p dvd a", "from irr[unfolded irreducible_def]"], ["proof (chain)\npicking this:\n  p \\<noteq> 0 \\<and>\n  \\<not> is_unit p \\<and>\n  (\\<forall>a b. p = a * b \\<longrightarrow> is_unit a \\<or> is_unit b)", "have deg: \"degree p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<and>\n  \\<not> is_unit p \\<and>\n  (\\<forall>a b. p = a * b \\<longrightarrow> is_unit a \\<or> is_unit b)\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>#as. p dvd a", "hence p1: \"\\<not> p dvd 1\""], ["proof (prove)\nusing this:\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> is_unit p", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<nexists>k. 1 = p * k", "by (metis degree_1 nonzero_mult_div_cancel_left div_poly_less linorder_neqE_nat mult_not_zero not_less0 zero_neq_one)"], ["proof (state)\nthis:\n  \\<not> is_unit p\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>#as. p dvd a", "from dvd"], ["proof (chain)\npicking this:\n  p dvd \\<Prod>\\<^sub># as", "show ?thesis"], ["proof (prove)\nusing this:\n  p dvd \\<Prod>\\<^sub># as\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>#as. p dvd a", "proof (induct as)"], ["proof (state)\ngoal (2 subgoals):\n 1. p dvd \\<Prod>\\<^sub># {#} \\<Longrightarrow> Multiset.Bex {#} ((dvd) p)\n 2. \\<And>x as.\n       \\<lbrakk>p dvd \\<Prod>\\<^sub># as \\<Longrightarrow>\n                Multiset.Bex as ((dvd) p);\n        p dvd \\<Prod>\\<^sub># (add_mset x as)\\<rbrakk>\n       \\<Longrightarrow> Multiset.Bex (add_mset x as) ((dvd) p)", "case (add a as)"], ["proof (state)\nthis:\n  p dvd \\<Prod>\\<^sub># as \\<Longrightarrow> \\<exists>a\\<in>#as. p dvd a\n  p dvd \\<Prod>\\<^sub># (add_mset a as)\n\ngoal (2 subgoals):\n 1. p dvd \\<Prod>\\<^sub># {#} \\<Longrightarrow> Multiset.Bex {#} ((dvd) p)\n 2. \\<And>x as.\n       \\<lbrakk>p dvd \\<Prod>\\<^sub># as \\<Longrightarrow>\n                Multiset.Bex as ((dvd) p);\n        p dvd \\<Prod>\\<^sub># (add_mset x as)\\<rbrakk>\n       \\<Longrightarrow> Multiset.Bex (add_mset x as) ((dvd) p)", "hence \"prod_mset (add_mset a as) = a * prod_mset as\""], ["proof (prove)\nusing this:\n  p dvd \\<Prod>\\<^sub># as \\<Longrightarrow> \\<exists>a\\<in>#as. p dvd a\n  p dvd \\<Prod>\\<^sub># (add_mset a as)\n\ngoal (1 subgoal):\n 1. \\<Prod>\\<^sub># (add_mset a as) = a * \\<Prod>\\<^sub># as", "by auto"], ["proof (state)\nthis:\n  \\<Prod>\\<^sub># (add_mset a as) = a * \\<Prod>\\<^sub># as\n\ngoal (2 subgoals):\n 1. p dvd \\<Prod>\\<^sub># {#} \\<Longrightarrow> Multiset.Bex {#} ((dvd) p)\n 2. \\<And>x as.\n       \\<lbrakk>p dvd \\<Prod>\\<^sub># as \\<Longrightarrow>\n                Multiset.Bex as ((dvd) p);\n        p dvd \\<Prod>\\<^sub># (add_mset x as)\\<rbrakk>\n       \\<Longrightarrow> Multiset.Bex (add_mset x as) ((dvd) p)", "from add(2)[unfolded this] add(1) irr"], ["proof (chain)\npicking this:\n  p dvd a * \\<Prod>\\<^sub># as\n  p dvd \\<Prod>\\<^sub># as \\<Longrightarrow> \\<exists>a\\<in>#as. p dvd a\n  irreducible p", "show ?case"], ["proof (prove)\nusing this:\n  p dvd a * \\<Prod>\\<^sub># as\n  p dvd \\<Prod>\\<^sub># as \\<Longrightarrow> \\<exists>a\\<in>#as. p dvd a\n  irreducible p\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>#add_mset a as. p dvd a", "by auto"], ["proof (state)\nthis:\n  \\<exists>a\\<in>#add_mset a as. p dvd a\n\ngoal (1 subgoal):\n 1. p dvd \\<Prod>\\<^sub># {#} \\<Longrightarrow> Multiset.Bex {#} ((dvd) p)", "qed (insert p1, auto)"], ["proof (state)\nthis:\n  \\<exists>a\\<in>#as. p dvd a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monic_factorization_unique_mset:\n  fixes P::\"'a::field poly multiset\"\n  assumes eq: \"prod_mset P = prod_mset Q\" \n    and P: \"set_mset P \\<subseteq> {q. irreducible q \\<and> monic q}\"\n    and Q: \"set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\"\n  shows \"P = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P = Q", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. P = Q", "fix P Q :: \"'a poly multiset\""], ["proof (state)\ngoal (1 subgoal):\n 1. P = Q", "assume id: \"prod_mset P = prod_mset Q\" \n    and P: \"set_mset P \\<subseteq> {q. irreducible q \\<and> monic q}\"\n    and Q: \"set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\""], ["proof (state)\nthis:\n  \\<Prod>\\<^sub># P = \\<Prod>\\<^sub># Q\n  set_mset P \\<subseteq> {q. irreducible q \\<and> monic q}\n  set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. P = Q", "hence \"P \\<subseteq># Q\""], ["proof (prove)\nusing this:\n  \\<Prod>\\<^sub># P = \\<Prod>\\<^sub># Q\n  set_mset P \\<subseteq> {q. irreducible q \\<and> monic q}\n  set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. P \\<subseteq># Q", "proof (induct P arbitrary: Q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q.\n       \\<lbrakk>\\<Prod>\\<^sub># {#} = \\<Prod>\\<^sub># Q;\n        set_mset {#} \\<subseteq> {q. irreducible q \\<and> monic q};\n        set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n       \\<Longrightarrow> {#} \\<subseteq># Q\n 2. \\<And>x P Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>\\<Prod>\\<^sub># P = \\<Prod>\\<^sub># Q;\n                    set_mset P\n                    \\<subseteq> {q. irreducible q \\<and> monic q};\n                    set_mset Q\n                    \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n                   \\<Longrightarrow> P \\<subseteq># Q;\n        \\<Prod>\\<^sub># (add_mset x P) = \\<Prod>\\<^sub># Q;\n        set_mset (add_mset x P)\n        \\<subseteq> {q. irreducible q \\<and> monic q};\n        set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n       \\<Longrightarrow> add_mset x P \\<subseteq># Q", "case (add x P Q')"], ["proof (state)\nthis:\n  \\<lbrakk>\\<Prod>\\<^sub># P = \\<Prod>\\<^sub># ?Q;\n   set_mset P \\<subseteq> {q. irreducible q \\<and> monic q};\n   set_mset ?Q \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n  \\<Longrightarrow> P \\<subseteq># ?Q\n  \\<Prod>\\<^sub># (add_mset x P) = \\<Prod>\\<^sub># Q'\n  set_mset (add_mset x P) \\<subseteq> {q. irreducible q \\<and> monic q}\n  set_mset Q' \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (2 subgoals):\n 1. \\<And>Q.\n       \\<lbrakk>\\<Prod>\\<^sub># {#} = \\<Prod>\\<^sub># Q;\n        set_mset {#} \\<subseteq> {q. irreducible q \\<and> monic q};\n        set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n       \\<Longrightarrow> {#} \\<subseteq># Q\n 2. \\<And>x P Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>\\<Prod>\\<^sub># P = \\<Prod>\\<^sub># Q;\n                    set_mset P\n                    \\<subseteq> {q. irreducible q \\<and> monic q};\n                    set_mset Q\n                    \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n                   \\<Longrightarrow> P \\<subseteq># Q;\n        \\<Prod>\\<^sub># (add_mset x P) = \\<Prod>\\<^sub># Q;\n        set_mset (add_mset x P)\n        \\<subseteq> {q. irreducible q \\<and> monic q};\n        set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n       \\<Longrightarrow> add_mset x P \\<subseteq># Q", "from add(3)"], ["proof (chain)\npicking this:\n  set_mset (add_mset x P) \\<subseteq> {q. irreducible q \\<and> monic q}", "have irr: \"irreducible x\" and mon: \"monic x\""], ["proof (prove)\nusing this:\n  set_mset (add_mset x P) \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. irreducible x &&& monic x", "by auto"], ["proof (state)\nthis:\n  irreducible x\n  monic x\n\ngoal (2 subgoals):\n 1. \\<And>Q.\n       \\<lbrakk>\\<Prod>\\<^sub># {#} = \\<Prod>\\<^sub># Q;\n        set_mset {#} \\<subseteq> {q. irreducible q \\<and> monic q};\n        set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n       \\<Longrightarrow> {#} \\<subseteq># Q\n 2. \\<And>x P Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>\\<Prod>\\<^sub># P = \\<Prod>\\<^sub># Q;\n                    set_mset P\n                    \\<subseteq> {q. irreducible q \\<and> monic q};\n                    set_mset Q\n                    \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n                   \\<Longrightarrow> P \\<subseteq># Q;\n        \\<Prod>\\<^sub># (add_mset x P) = \\<Prod>\\<^sub># Q;\n        set_mset (add_mset x P)\n        \\<subseteq> {q. irreducible q \\<and> monic q};\n        set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n       \\<Longrightarrow> add_mset x P \\<subseteq># Q", "have \"\\<exists> a \\<in># Q'. x dvd a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>#Q'. x dvd a", "proof (rule irreducible_dvd_prod_mset[OF irr])"], ["proof (state)\ngoal (1 subgoal):\n 1. x dvd \\<Prod>\\<^sub># Q'", "show \"x dvd prod_mset Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x dvd \\<Prod>\\<^sub># Q'", "unfolding add(2)[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. x dvd \\<Prod>\\<^sub># (add_mset x P)", "by simp"], ["proof (state)\nthis:\n  x dvd \\<Prod>\\<^sub># Q'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a\\<in>#Q'. x dvd a\n\ngoal (2 subgoals):\n 1. \\<And>Q.\n       \\<lbrakk>\\<Prod>\\<^sub># {#} = \\<Prod>\\<^sub># Q;\n        set_mset {#} \\<subseteq> {q. irreducible q \\<and> monic q};\n        set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n       \\<Longrightarrow> {#} \\<subseteq># Q\n 2. \\<And>x P Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>\\<Prod>\\<^sub># P = \\<Prod>\\<^sub># Q;\n                    set_mset P\n                    \\<subseteq> {q. irreducible q \\<and> monic q};\n                    set_mset Q\n                    \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n                   \\<Longrightarrow> P \\<subseteq># Q;\n        \\<Prod>\\<^sub># (add_mset x P) = \\<Prod>\\<^sub># Q;\n        set_mset (add_mset x P)\n        \\<subseteq> {q. irreducible q \\<and> monic q};\n        set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n       \\<Longrightarrow> add_mset x P \\<subseteq># Q", "then"], ["proof (chain)\npicking this:\n  \\<exists>a\\<in>#Q'. x dvd a", "obtain y Q where Q': \"Q' = add_mset y Q\" and xy: \"x dvd y\""], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>#Q'. x dvd a\n\ngoal (1 subgoal):\n 1. (\\<And>y Q.\n        \\<lbrakk>Q' = add_mset y Q; x dvd y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson mset_add)"], ["proof (state)\nthis:\n  Q' = add_mset y Q\n  x dvd y\n\ngoal (2 subgoals):\n 1. \\<And>Q.\n       \\<lbrakk>\\<Prod>\\<^sub># {#} = \\<Prod>\\<^sub># Q;\n        set_mset {#} \\<subseteq> {q. irreducible q \\<and> monic q};\n        set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n       \\<Longrightarrow> {#} \\<subseteq># Q\n 2. \\<And>x P Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>\\<Prod>\\<^sub># P = \\<Prod>\\<^sub># Q;\n                    set_mset P\n                    \\<subseteq> {q. irreducible q \\<and> monic q};\n                    set_mset Q\n                    \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n                   \\<Longrightarrow> P \\<subseteq># Q;\n        \\<Prod>\\<^sub># (add_mset x P) = \\<Prod>\\<^sub># Q;\n        set_mset (add_mset x P)\n        \\<subseteq> {q. irreducible q \\<and> monic q};\n        set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n       \\<Longrightarrow> add_mset x P \\<subseteq># Q", "from add(4) Q'"], ["proof (chain)\npicking this:\n  set_mset Q' \\<subseteq> {q. irreducible q \\<and> monic q}\n  Q' = add_mset y Q", "have irr': \"irreducible y\" and mon': \"monic y\""], ["proof (prove)\nusing this:\n  set_mset Q' \\<subseteq> {q. irreducible q \\<and> monic q}\n  Q' = add_mset y Q\n\ngoal (1 subgoal):\n 1. irreducible y &&& monic y", "by auto"], ["proof (state)\nthis:\n  irreducible y\n  monic y\n\ngoal (2 subgoals):\n 1. \\<And>Q.\n       \\<lbrakk>\\<Prod>\\<^sub># {#} = \\<Prod>\\<^sub># Q;\n        set_mset {#} \\<subseteq> {q. irreducible q \\<and> monic q};\n        set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n       \\<Longrightarrow> {#} \\<subseteq># Q\n 2. \\<And>x P Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>\\<Prod>\\<^sub># P = \\<Prod>\\<^sub># Q;\n                    set_mset P\n                    \\<subseteq> {q. irreducible q \\<and> monic q};\n                    set_mset Q\n                    \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n                   \\<Longrightarrow> P \\<subseteq># Q;\n        \\<Prod>\\<^sub># (add_mset x P) = \\<Prod>\\<^sub># Q;\n        set_mset (add_mset x P)\n        \\<subseteq> {q. irreducible q \\<and> monic q};\n        set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n       \\<Longrightarrow> add_mset x P \\<subseteq># Q", "have \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using irr irr' xy mon mon'"], ["proof (prove)\nusing this:\n  irreducible x\n  irreducible y\n  x dvd y\n  monic x\n  monic y\n\ngoal (1 subgoal):\n 1. x = y", "by (metis irreducibleD' irreducible_not_unit poly_dvd_antisym)"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. \\<And>Q.\n       \\<lbrakk>\\<Prod>\\<^sub># {#} = \\<Prod>\\<^sub># Q;\n        set_mset {#} \\<subseteq> {q. irreducible q \\<and> monic q};\n        set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n       \\<Longrightarrow> {#} \\<subseteq># Q\n 2. \\<And>x P Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>\\<Prod>\\<^sub># P = \\<Prod>\\<^sub># Q;\n                    set_mset P\n                    \\<subseteq> {q. irreducible q \\<and> monic q};\n                    set_mset Q\n                    \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n                   \\<Longrightarrow> P \\<subseteq># Q;\n        \\<Prod>\\<^sub># (add_mset x P) = \\<Prod>\\<^sub># Q;\n        set_mset (add_mset x P)\n        \\<subseteq> {q. irreducible q \\<and> monic q};\n        set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n       \\<Longrightarrow> add_mset x P \\<subseteq># Q", "hence Q': \"Q' = Q + {#x#}\""], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. Q' = Q + {#x#}", "using Q'"], ["proof (prove)\nusing this:\n  x = y\n  Q' = add_mset y Q\n\ngoal (1 subgoal):\n 1. Q' = Q + {#x#}", "by auto"], ["proof (state)\nthis:\n  Q' = Q + {#x#}\n\ngoal (2 subgoals):\n 1. \\<And>Q.\n       \\<lbrakk>\\<Prod>\\<^sub># {#} = \\<Prod>\\<^sub># Q;\n        set_mset {#} \\<subseteq> {q. irreducible q \\<and> monic q};\n        set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n       \\<Longrightarrow> {#} \\<subseteq># Q\n 2. \\<And>x P Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>\\<Prod>\\<^sub># P = \\<Prod>\\<^sub># Q;\n                    set_mset P\n                    \\<subseteq> {q. irreducible q \\<and> monic q};\n                    set_mset Q\n                    \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n                   \\<Longrightarrow> P \\<subseteq># Q;\n        \\<Prod>\\<^sub># (add_mset x P) = \\<Prod>\\<^sub># Q;\n        set_mset (add_mset x P)\n        \\<subseteq> {q. irreducible q \\<and> monic q};\n        set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n       \\<Longrightarrow> add_mset x P \\<subseteq># Q", "from mon"], ["proof (chain)\npicking this:\n  monic x", "have x0: \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  monic x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>Q.\n       \\<lbrakk>\\<Prod>\\<^sub># {#} = \\<Prod>\\<^sub># Q;\n        set_mset {#} \\<subseteq> {q. irreducible q \\<and> monic q};\n        set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n       \\<Longrightarrow> {#} \\<subseteq># Q\n 2. \\<And>x P Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>\\<Prod>\\<^sub># P = \\<Prod>\\<^sub># Q;\n                    set_mset P\n                    \\<subseteq> {q. irreducible q \\<and> monic q};\n                    set_mset Q\n                    \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n                   \\<Longrightarrow> P \\<subseteq># Q;\n        \\<Prod>\\<^sub># (add_mset x P) = \\<Prod>\\<^sub># Q;\n        set_mset (add_mset x P)\n        \\<subseteq> {q. irreducible q \\<and> monic q};\n        set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n       \\<Longrightarrow> add_mset x P \\<subseteq># Q", "from arg_cong[OF add(2)[unfolded Q'], of \"\\<lambda> z. z div x\"]"], ["proof (chain)\npicking this:\n  \\<Prod>\\<^sub># (add_mset x P) div x = \\<Prod>\\<^sub># (Q + {#x#}) div x", "have eq: \"prod_mset P = prod_mset Q\""], ["proof (prove)\nusing this:\n  \\<Prod>\\<^sub># (add_mset x P) div x = \\<Prod>\\<^sub># (Q + {#x#}) div x\n\ngoal (1 subgoal):\n 1. \\<Prod>\\<^sub># P = \\<Prod>\\<^sub># Q", "using x0"], ["proof (prove)\nusing this:\n  \\<Prod>\\<^sub># (add_mset x P) div x = \\<Prod>\\<^sub># (Q + {#x#}) div x\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<Prod>\\<^sub># P = \\<Prod>\\<^sub># Q", "by auto"], ["proof (state)\nthis:\n  \\<Prod>\\<^sub># P = \\<Prod>\\<^sub># Q\n\ngoal (2 subgoals):\n 1. \\<And>Q.\n       \\<lbrakk>\\<Prod>\\<^sub># {#} = \\<Prod>\\<^sub># Q;\n        set_mset {#} \\<subseteq> {q. irreducible q \\<and> monic q};\n        set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n       \\<Longrightarrow> {#} \\<subseteq># Q\n 2. \\<And>x P Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>\\<Prod>\\<^sub># P = \\<Prod>\\<^sub># Q;\n                    set_mset P\n                    \\<subseteq> {q. irreducible q \\<and> monic q};\n                    set_mset Q\n                    \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n                   \\<Longrightarrow> P \\<subseteq># Q;\n        \\<Prod>\\<^sub># (add_mset x P) = \\<Prod>\\<^sub># Q;\n        set_mset (add_mset x P)\n        \\<subseteq> {q. irreducible q \\<and> monic q};\n        set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n       \\<Longrightarrow> add_mset x P \\<subseteq># Q", "from add(3-4)[unfolded Q']"], ["proof (chain)\npicking this:\n  set_mset (add_mset x P) \\<subseteq> {q. irreducible q \\<and> monic q}\n  set_mset (Q + {#x#}) \\<subseteq> {q. irreducible q \\<and> monic q}", "have \"set_mset P \\<subseteq> {q. irreducible q \\<and> monic q}\" \"set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\""], ["proof (prove)\nusing this:\n  set_mset (add_mset x P) \\<subseteq> {q. irreducible q \\<and> monic q}\n  set_mset (Q + {#x#}) \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. set_mset P \\<subseteq> {q. irreducible q \\<and> monic q} &&&\n    set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}", "by auto"], ["proof (state)\nthis:\n  set_mset P \\<subseteq> {q. irreducible q \\<and> monic q}\n  set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (2 subgoals):\n 1. \\<And>Q.\n       \\<lbrakk>\\<Prod>\\<^sub># {#} = \\<Prod>\\<^sub># Q;\n        set_mset {#} \\<subseteq> {q. irreducible q \\<and> monic q};\n        set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n       \\<Longrightarrow> {#} \\<subseteq># Q\n 2. \\<And>x P Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>\\<Prod>\\<^sub># P = \\<Prod>\\<^sub># Q;\n                    set_mset P\n                    \\<subseteq> {q. irreducible q \\<and> monic q};\n                    set_mset Q\n                    \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n                   \\<Longrightarrow> P \\<subseteq># Q;\n        \\<Prod>\\<^sub># (add_mset x P) = \\<Prod>\\<^sub># Q;\n        set_mset (add_mset x P)\n        \\<subseteq> {q. irreducible q \\<and> monic q};\n        set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n       \\<Longrightarrow> add_mset x P \\<subseteq># Q", "from add(1)[OF eq this]"], ["proof (chain)\npicking this:\n  P \\<subseteq># Q", "show ?case"], ["proof (prove)\nusing this:\n  P \\<subseteq># Q\n\ngoal (1 subgoal):\n 1. add_mset x P \\<subseteq># Q'", "unfolding Q'"], ["proof (prove)\nusing this:\n  P \\<subseteq># Q\n\ngoal (1 subgoal):\n 1. add_mset x P \\<subseteq># Q + {#x#}", "by auto"], ["proof (state)\nthis:\n  add_mset x P \\<subseteq># Q'\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>\\<Prod>\\<^sub># {#} = \\<Prod>\\<^sub># Q;\n        set_mset {#} \\<subseteq> {q. irreducible q \\<and> monic q};\n        set_mset Q \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n       \\<Longrightarrow> {#} \\<subseteq># Q", "qed auto"], ["proof (state)\nthis:\n  P \\<subseteq># Q\n\ngoal (1 subgoal):\n 1. P = Q", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<Prod>\\<^sub># ?Pa2 = \\<Prod>\\<^sub># ?Qa2;\n   set_mset ?Pa2 \\<subseteq> {q. irreducible q \\<and> monic q};\n   set_mset ?Qa2 \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n  \\<Longrightarrow> ?Pa2 \\<subseteq># ?Qa2\n\ngoal (1 subgoal):\n 1. P = Q", "from this[OF eq P Q] this[OF eq[symmetric] Q P]"], ["proof (chain)\npicking this:\n  P \\<subseteq># Q\n  Q \\<subseteq># P", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<subseteq># Q\n  Q \\<subseteq># P\n\ngoal (1 subgoal):\n 1. P = Q", "by auto"], ["proof (state)\nthis:\n  P = Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exactly_one_monic_factorization:\n  assumes mon: \"monic (f :: 'a :: field poly)\"\n  shows \"\\<exists>! fs. f = prod_mset fs \\<and> set_mset fs \\<subseteq> {q. irreducible q \\<and> monic q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!fs.\n       f = \\<Prod>\\<^sub># fs \\<and>\n       set_mset fs \\<subseteq> {q. irreducible q \\<and> monic q}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!fs.\n       f = \\<Prod>\\<^sub># fs \\<and>\n       set_mset fs \\<subseteq> {q. irreducible q \\<and> monic q}", "from monic_irreducible_factorization[OF mon]"], ["proof (chain)\npicking this:\n  \\<exists>as fa.\n     finite as \\<and>\n     f = (\\<Prod>a\\<in>as. a ^ Suc (fa a)) \\<and>\n     as \\<subseteq> {q. irreducible q \\<and> monic q}", "obtain gs g where fin: \"finite gs\" and f: \"f = (\\<Prod>a\\<in>gs. a ^ Suc (g a))\" \n    and gs: \"gs \\<subseteq> {q. irreducible q \\<and> monic q}\""], ["proof (prove)\nusing this:\n  \\<exists>as fa.\n     finite as \\<and>\n     f = (\\<Prod>a\\<in>as. a ^ Suc (fa a)) \\<and>\n     as \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. (\\<And>gs g.\n        \\<lbrakk>finite gs; f = (\\<Prod>a\\<in>gs. a ^ Suc (g a));\n         gs \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  finite gs\n  f = (\\<Prod>a\\<in>gs. a ^ Suc (g a))\n  gs \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. \\<exists>!fs.\n       f = \\<Prod>\\<^sub># fs \\<and>\n       set_mset fs \\<subseteq> {q. irreducible q \\<and> monic q}", "from fin"], ["proof (chain)\npicking this:\n  finite gs", "have \"\\<exists> fs. set_mset fs \\<subseteq> gs \\<and> prod_mset fs = (\\<Prod>a\\<in>gs. a ^ Suc (g a))\""], ["proof (prove)\nusing this:\n  finite gs\n\ngoal (1 subgoal):\n 1. \\<exists>fs.\n       set_mset fs \\<subseteq> gs \\<and>\n       \\<Prod>\\<^sub># fs = (\\<Prod>a\\<in>gs. a ^ Suc (g a))", "proof (induct gs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>fs.\n       set_mset fs \\<subseteq> {} \\<and>\n       \\<Prod>\\<^sub># fs = (\\<Prod>a\\<in>{}. a ^ Suc (g a))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>fs.\n           set_mset fs \\<subseteq> F \\<and>\n           \\<Prod>\\<^sub># fs = (\\<Prod>a\\<in>F. a ^ Suc (g a))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            set_mset fs \\<subseteq> insert x F \\<and>\n                            \\<Prod>\\<^sub># fs =\n                            (\\<Prod>a\\<in>insert x F. a ^ Suc (g a))", "case (insert a gs)"], ["proof (state)\nthis:\n  finite gs\n  a \\<notin> gs\n  \\<exists>fs.\n     set_mset fs \\<subseteq> gs \\<and>\n     \\<Prod>\\<^sub># fs = (\\<Prod>a\\<in>gs. a ^ Suc (g a))\n\ngoal (2 subgoals):\n 1. \\<exists>fs.\n       set_mset fs \\<subseteq> {} \\<and>\n       \\<Prod>\\<^sub># fs = (\\<Prod>a\\<in>{}. a ^ Suc (g a))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>fs.\n           set_mset fs \\<subseteq> F \\<and>\n           \\<Prod>\\<^sub># fs = (\\<Prod>a\\<in>F. a ^ Suc (g a))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            set_mset fs \\<subseteq> insert x F \\<and>\n                            \\<Prod>\\<^sub># fs =\n                            (\\<Prod>a\\<in>insert x F. a ^ Suc (g a))", "from insert(3)"], ["proof (chain)\npicking this:\n  \\<exists>fs.\n     set_mset fs \\<subseteq> gs \\<and>\n     \\<Prod>\\<^sub># fs = (\\<Prod>a\\<in>gs. a ^ Suc (g a))", "obtain fs where *: \"set_mset fs \\<subseteq> gs\" \"prod_mset fs = (\\<Prod>a\\<in>gs. a ^ Suc (g a))\""], ["proof (prove)\nusing this:\n  \\<exists>fs.\n     set_mset fs \\<subseteq> gs \\<and>\n     \\<Prod>\\<^sub># fs = (\\<Prod>a\\<in>gs. a ^ Suc (g a))\n\ngoal (1 subgoal):\n 1. (\\<And>fs.\n        \\<lbrakk>set_mset fs \\<subseteq> gs;\n         \\<Prod>\\<^sub># fs = (\\<Prod>a\\<in>gs. a ^ Suc (g a))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  set_mset fs \\<subseteq> gs\n  \\<Prod>\\<^sub># fs = (\\<Prod>a\\<in>gs. a ^ Suc (g a))\n\ngoal (2 subgoals):\n 1. \\<exists>fs.\n       set_mset fs \\<subseteq> {} \\<and>\n       \\<Prod>\\<^sub># fs = (\\<Prod>a\\<in>{}. a ^ Suc (g a))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>fs.\n           set_mset fs \\<subseteq> F \\<and>\n           \\<Prod>\\<^sub># fs = (\\<Prod>a\\<in>F. a ^ Suc (g a))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            set_mset fs \\<subseteq> insert x F \\<and>\n                            \\<Prod>\\<^sub># fs =\n                            (\\<Prod>a\\<in>insert x F. a ^ Suc (g a))", "let ?fs = \"fs + replicate_mset (Suc (g a)) a\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>fs.\n       set_mset fs \\<subseteq> {} \\<and>\n       \\<Prod>\\<^sub># fs = (\\<Prod>a\\<in>{}. a ^ Suc (g a))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>fs.\n           set_mset fs \\<subseteq> F \\<and>\n           \\<Prod>\\<^sub># fs = (\\<Prod>a\\<in>F. a ^ Suc (g a))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            set_mset fs \\<subseteq> insert x F \\<and>\n                            \\<Prod>\\<^sub># fs =\n                            (\\<Prod>a\\<in>insert x F. a ^ Suc (g a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>fs.\n       set_mset fs \\<subseteq> insert a gs \\<and>\n       \\<Prod>\\<^sub># fs = (\\<Prod>a\\<in>insert a gs. a ^ Suc (g a))", "proof (rule exI[of _ \"fs + replicate_mset (Suc (g a)) a\"], intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. set_mset (fs + replicate_mset (Suc (g a)) a) \\<subseteq> insert a gs\n 2. \\<Prod>\\<^sub># (fs + replicate_mset (Suc (g a)) a) =\n    (\\<Prod>a\\<in>insert a gs. a ^ Suc (g a))", "show \"set_mset ?fs \\<subseteq> insert a gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset (fs + replicate_mset (Suc (g a)) a) \\<subseteq> insert a gs", "using *(1)"], ["proof (prove)\nusing this:\n  set_mset fs \\<subseteq> gs\n\ngoal (1 subgoal):\n 1. set_mset (fs + replicate_mset (Suc (g a)) a) \\<subseteq> insert a gs", "by auto"], ["proof (state)\nthis:\n  set_mset (fs + replicate_mset (Suc (g a)) a) \\<subseteq> insert a gs\n\ngoal (1 subgoal):\n 1. \\<Prod>\\<^sub># (fs + replicate_mset (Suc (g a)) a) =\n    (\\<Prod>a\\<in>insert a gs. a ^ Suc (g a))", "show \"prod_mset ?fs = (\\<Prod>a\\<in>insert a gs. a ^ Suc (g a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>\\<^sub># (fs + replicate_mset (Suc (g a)) a) =\n    (\\<Prod>a\\<in>insert a gs. a ^ Suc (g a))", "by (subst prod.insert[OF insert(1-2)], auto simp: *(2))"], ["proof (state)\nthis:\n  \\<Prod>\\<^sub># (fs + replicate_mset (Suc (g a)) a) =\n  (\\<Prod>a\\<in>insert a gs. a ^ Suc (g a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>fs.\n     set_mset fs \\<subseteq> insert a gs \\<and>\n     \\<Prod>\\<^sub># fs = (\\<Prod>a\\<in>insert a gs. a ^ Suc (g a))\n\ngoal (1 subgoal):\n 1. \\<exists>fs.\n       set_mset fs \\<subseteq> {} \\<and>\n       \\<Prod>\\<^sub># fs = (\\<Prod>a\\<in>{}. a ^ Suc (g a))", "qed simp"], ["proof (state)\nthis:\n  \\<exists>fs.\n     set_mset fs \\<subseteq> gs \\<and>\n     \\<Prod>\\<^sub># fs = (\\<Prod>a\\<in>gs. a ^ Suc (g a))\n\ngoal (1 subgoal):\n 1. \\<exists>!fs.\n       f = \\<Prod>\\<^sub># fs \\<and>\n       set_mset fs \\<subseteq> {q. irreducible q \\<and> monic q}", "then"], ["proof (chain)\npicking this:\n  \\<exists>fs.\n     set_mset fs \\<subseteq> gs \\<and>\n     \\<Prod>\\<^sub># fs = (\\<Prod>a\\<in>gs. a ^ Suc (g a))", "obtain fs where \"set_mset fs \\<subseteq> gs\" \"prod_mset fs = (\\<Prod>a\\<in>gs. a ^ Suc (g a))\""], ["proof (prove)\nusing this:\n  \\<exists>fs.\n     set_mset fs \\<subseteq> gs \\<and>\n     \\<Prod>\\<^sub># fs = (\\<Prod>a\\<in>gs. a ^ Suc (g a))\n\ngoal (1 subgoal):\n 1. (\\<And>fs.\n        \\<lbrakk>set_mset fs \\<subseteq> gs;\n         \\<Prod>\\<^sub># fs = (\\<Prod>a\\<in>gs. a ^ Suc (g a))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  set_mset fs \\<subseteq> gs\n  \\<Prod>\\<^sub># fs = (\\<Prod>a\\<in>gs. a ^ Suc (g a))\n\ngoal (1 subgoal):\n 1. \\<exists>!fs.\n       f = \\<Prod>\\<^sub># fs \\<and>\n       set_mset fs \\<subseteq> {q. irreducible q \\<and> monic q}", "with gs f"], ["proof (chain)\npicking this:\n  gs \\<subseteq> {q. irreducible q \\<and> monic q}\n  f = (\\<Prod>a\\<in>gs. a ^ Suc (g a))\n  set_mset fs \\<subseteq> gs\n  \\<Prod>\\<^sub># fs = (\\<Prod>a\\<in>gs. a ^ Suc (g a))", "have ex: \"\\<exists>fs. f = prod_mset fs \\<and> set_mset fs \\<subseteq> {q. irreducible q \\<and> monic q}\""], ["proof (prove)\nusing this:\n  gs \\<subseteq> {q. irreducible q \\<and> monic q}\n  f = (\\<Prod>a\\<in>gs. a ^ Suc (g a))\n  set_mset fs \\<subseteq> gs\n  \\<Prod>\\<^sub># fs = (\\<Prod>a\\<in>gs. a ^ Suc (g a))\n\ngoal (1 subgoal):\n 1. \\<exists>fs.\n       f = \\<Prod>\\<^sub># fs \\<and>\n       set_mset fs \\<subseteq> {q. irreducible q \\<and> monic q}", "by (intro exI[of _ fs], auto)"], ["proof (state)\nthis:\n  \\<exists>fs.\n     f = \\<Prod>\\<^sub># fs \\<and>\n     set_mset fs \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. \\<exists>!fs.\n       f = \\<Prod>\\<^sub># fs \\<and>\n       set_mset fs \\<subseteq> {q. irreducible q \\<and> monic q}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>fs.\n     f = \\<Prod>\\<^sub># fs \\<and>\n     set_mset fs \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal (1 subgoal):\n 1. \\<exists>!fs.\n       f = \\<Prod>\\<^sub># fs \\<and>\n       set_mset fs \\<subseteq> {q. irreducible q \\<and> monic q}", "using monic_factorization_unique_mset"], ["proof (prove)\nusing this:\n  \\<exists>fs.\n     f = \\<Prod>\\<^sub># fs \\<and>\n     set_mset fs \\<subseteq> {q. irreducible q \\<and> monic q}\n  \\<lbrakk>\\<Prod>\\<^sub># ?P = \\<Prod>\\<^sub># ?Q;\n   set_mset ?P \\<subseteq> {q. irreducible q \\<and> monic q};\n   set_mset ?Q \\<subseteq> {q. irreducible q \\<and> monic q}\\<rbrakk>\n  \\<Longrightarrow> ?P = ?Q\n\ngoal (1 subgoal):\n 1. \\<exists>!fs.\n       f = \\<Prod>\\<^sub># fs \\<and>\n       set_mset fs \\<subseteq> {q. irreducible q \\<and> monic q}", "by blast"], ["proof (state)\nthis:\n  \\<exists>!fs.\n     f = \\<Prod>\\<^sub># fs \\<and>\n     set_mset fs \\<subseteq> {q. irreducible q \\<and> monic q}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monic_prod_mset:\n  fixes as :: \"'a :: idom poly multiset\"\n  assumes \"\\<And> a. a \\<in> set_mset as \\<Longrightarrow> monic a\"\n  shows \"monic (prod_mset as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (\\<Prod>\\<^sub># as)", "using assms"], ["proof (prove)\nusing this:\n  ?a \\<in># as \\<Longrightarrow> monic ?a\n\ngoal (1 subgoal):\n 1. monic (\\<Prod>\\<^sub># as)", "by (induct as, auto intro: monic_mult)"], ["", "lemma exactly_one_factorization:\n  assumes f: \"f \\<noteq> (0 :: 'a :: field poly)\"\n  shows \"\\<exists>! cfs. factorization Irr_Mon f cfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!cfs. factorization Irr_Mon f cfs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!cfs. factorization Irr_Mon f cfs", "let ?a = \"coeff f (degree f)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!cfs. factorization Irr_Mon f cfs", "let ?b = \"inverse ?a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!cfs. factorization Irr_Mon f cfs", "let ?g = \"smult ?b f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!cfs. factorization Irr_Mon f cfs", "define g where \"g = ?g\""], ["proof (state)\nthis:\n  g = smult (inverse (lead_coeff f)) f\n\ngoal (1 subgoal):\n 1. \\<exists>!cfs. factorization Irr_Mon f cfs", "from f"], ["proof (chain)\npicking this:\n  f \\<noteq> 0", "have a: \"?a \\<noteq> 0\" \"?b \\<noteq> 0\""], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff f \\<noteq> (0::'a) &&&\n    inverse (lead_coeff f) \\<noteq> (0::'a)", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  lead_coeff f \\<noteq> (0::'a)\n  inverse (lead_coeff f) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>!cfs. factorization Irr_Mon f cfs", "hence \"monic g\""], ["proof (prove)\nusing this:\n  lead_coeff f \\<noteq> (0::'a)\n  inverse (lead_coeff f) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. monic g", "unfolding g_def"], ["proof (prove)\nusing this:\n  lead_coeff f \\<noteq> (0::'a)\n  inverse (lead_coeff f) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. monic (smult (inverse (lead_coeff f)) f)", "by simp"], ["proof (state)\nthis:\n  monic g\n\ngoal (1 subgoal):\n 1. \\<exists>!cfs. factorization Irr_Mon f cfs", "note ex1 = exactly_one_monic_factorization[OF this, folded Irr_Mon_def]"], ["proof (state)\nthis:\n  \\<exists>!fs.\n     g = \\<Prod>\\<^sub># fs \\<and> set_mset fs \\<subseteq> Irr_Mon\n\ngoal (1 subgoal):\n 1. \\<exists>!cfs. factorization Irr_Mon f cfs", "then"], ["proof (chain)\npicking this:\n  \\<exists>!fs.\n     g = \\<Prod>\\<^sub># fs \\<and> set_mset fs \\<subseteq> Irr_Mon", "obtain fs where g: \"g = prod_mset fs\" \"set_mset fs \\<subseteq> Irr_Mon\""], ["proof (prove)\nusing this:\n  \\<exists>!fs.\n     g = \\<Prod>\\<^sub># fs \\<and> set_mset fs \\<subseteq> Irr_Mon\n\ngoal (1 subgoal):\n 1. (\\<And>fs.\n        \\<lbrakk>g = \\<Prod>\\<^sub># fs;\n         set_mset fs \\<subseteq> Irr_Mon\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  g = \\<Prod>\\<^sub># fs\n  set_mset fs \\<subseteq> Irr_Mon\n\ngoal (1 subgoal):\n 1. \\<exists>!cfs. factorization Irr_Mon f cfs", "let ?cfs = \"(?a,fs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!cfs. factorization Irr_Mon f cfs", "have cfs: \"factorization Irr_Mon f ?cfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. factorization Irr_Mon f (lead_coeff f, fs)", "unfolding factorization_def split g(1)[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = smult (lead_coeff f) g \\<and> set_mset fs \\<subseteq> Irr_Mon", "using g(2)"], ["proof (prove)\nusing this:\n  set_mset fs \\<subseteq> Irr_Mon\n\ngoal (1 subgoal):\n 1. f = smult (lead_coeff f) g \\<and> set_mset fs \\<subseteq> Irr_Mon", "unfolding g_def"], ["proof (prove)\nusing this:\n  set_mset fs \\<subseteq> Irr_Mon\n\ngoal (1 subgoal):\n 1. f = smult (lead_coeff f) (smult (inverse (lead_coeff f)) f) \\<and>\n    set_mset fs \\<subseteq> Irr_Mon", "by (simp add: a field_simps)"], ["proof (state)\nthis:\n  factorization Irr_Mon f (lead_coeff f, fs)\n\ngoal (1 subgoal):\n 1. \\<exists>!cfs. factorization Irr_Mon f cfs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!cfs. factorization Irr_Mon f cfs", "proof (rule, rule cfs)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfs.\n       factorization Irr_Mon f cfs \\<Longrightarrow>\n       cfs = (lead_coeff f, fs)", "fix dgs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfs.\n       factorization Irr_Mon f cfs \\<Longrightarrow>\n       cfs = (lead_coeff f, fs)", "assume fact: \"factorization Irr_Mon f dgs\""], ["proof (state)\nthis:\n  factorization Irr_Mon f dgs\n\ngoal (1 subgoal):\n 1. \\<And>cfs.\n       factorization Irr_Mon f cfs \\<Longrightarrow>\n       cfs = (lead_coeff f, fs)", "obtain d gs where dgs: \"dgs = (d,gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d gs. dgs = (d, gs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  dgs = (d, gs)\n\ngoal (1 subgoal):\n 1. \\<And>cfs.\n       factorization Irr_Mon f cfs \\<Longrightarrow>\n       cfs = (lead_coeff f, fs)", "from fact[unfolded factorization_def dgs split]"], ["proof (chain)\npicking this:\n  f = smult d (\\<Prod>\\<^sub># gs) \\<and> set_mset gs \\<subseteq> Irr_Mon", "have fd: \"f = smult d (prod_mset gs)\" and gs: \"set_mset gs \\<subseteq> Irr_Mon\""], ["proof (prove)\nusing this:\n  f = smult d (\\<Prod>\\<^sub># gs) \\<and> set_mset gs \\<subseteq> Irr_Mon\n\ngoal (1 subgoal):\n 1. f = smult d (\\<Prod>\\<^sub># gs) &&& set_mset gs \\<subseteq> Irr_Mon", "by auto"], ["proof (state)\nthis:\n  f = smult d (\\<Prod>\\<^sub># gs)\n  set_mset gs \\<subseteq> Irr_Mon\n\ngoal (1 subgoal):\n 1. \\<And>cfs.\n       factorization Irr_Mon f cfs \\<Longrightarrow>\n       cfs = (lead_coeff f, fs)", "have \"monic (prod_mset gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (\\<Prod>\\<^sub># gs)", "by (rule monic_prod_mset, insert gs[unfolded Irr_Mon_def], auto)"], ["proof (state)\nthis:\n  monic (\\<Prod>\\<^sub># gs)\n\ngoal (1 subgoal):\n 1. \\<And>cfs.\n       factorization Irr_Mon f cfs \\<Longrightarrow>\n       cfs = (lead_coeff f, fs)", "hence d: \"d = ?a\""], ["proof (prove)\nusing this:\n  monic (\\<Prod>\\<^sub># gs)\n\ngoal (1 subgoal):\n 1. d = lead_coeff f", "unfolding fd"], ["proof (prove)\nusing this:\n  monic (\\<Prod>\\<^sub># gs)\n\ngoal (1 subgoal):\n 1. d = lead_coeff (smult d (\\<Prod>\\<^sub># gs))", "by auto"], ["proof (state)\nthis:\n  d = lead_coeff f\n\ngoal (1 subgoal):\n 1. \\<And>cfs.\n       factorization Irr_Mon f cfs \\<Longrightarrow>\n       cfs = (lead_coeff f, fs)", "from arg_cong[OF fd, of \"\\<lambda> x. smult ?b x\", unfolded d g_def[symmetric]]"], ["proof (chain)\npicking this:\n  g =\n  smult (inverse (lead_coeff f)) (smult (lead_coeff f) (\\<Prod>\\<^sub># gs))", "have \"g = prod_mset gs\""], ["proof (prove)\nusing this:\n  g =\n  smult (inverse (lead_coeff f)) (smult (lead_coeff f) (\\<Prod>\\<^sub># gs))\n\ngoal (1 subgoal):\n 1. g = \\<Prod>\\<^sub># gs", "using a"], ["proof (prove)\nusing this:\n  g =\n  smult (inverse (lead_coeff f)) (smult (lead_coeff f) (\\<Prod>\\<^sub># gs))\n  lead_coeff f \\<noteq> (0::'a)\n  inverse (lead_coeff f) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. g = \\<Prod>\\<^sub># gs", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  g = \\<Prod>\\<^sub># gs\n\ngoal (1 subgoal):\n 1. \\<And>cfs.\n       factorization Irr_Mon f cfs \\<Longrightarrow>\n       cfs = (lead_coeff f, fs)", "with ex1 g gs"], ["proof (chain)\npicking this:\n  \\<exists>!fs.\n     g = \\<Prod>\\<^sub># fs \\<and> set_mset fs \\<subseteq> Irr_Mon\n  g = \\<Prod>\\<^sub># fs\n  set_mset fs \\<subseteq> Irr_Mon\n  set_mset gs \\<subseteq> Irr_Mon\n  g = \\<Prod>\\<^sub># gs", "have \"gs = fs\""], ["proof (prove)\nusing this:\n  \\<exists>!fs.\n     g = \\<Prod>\\<^sub># fs \\<and> set_mset fs \\<subseteq> Irr_Mon\n  g = \\<Prod>\\<^sub># fs\n  set_mset fs \\<subseteq> Irr_Mon\n  set_mset gs \\<subseteq> Irr_Mon\n  g = \\<Prod>\\<^sub># gs\n\ngoal (1 subgoal):\n 1. gs = fs", "by auto"], ["proof (state)\nthis:\n  gs = fs\n\ngoal (1 subgoal):\n 1. \\<And>cfs.\n       factorization Irr_Mon f cfs \\<Longrightarrow>\n       cfs = (lead_coeff f, fs)", "thus \"dgs = ?cfs\""], ["proof (prove)\nusing this:\n  gs = fs\n\ngoal (1 subgoal):\n 1. dgs = (lead_coeff f, fs)", "unfolding dgs d"], ["proof (prove)\nusing this:\n  gs = fs\n\ngoal (1 subgoal):\n 1. (lead_coeff f, gs) = (lead_coeff f, fs)", "by auto"], ["proof (state)\nthis:\n  dgs = (lead_coeff f, fs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!cfs. factorization Irr_Mon f cfs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mod_ident_iff: \"m > 0 \\<Longrightarrow> (x :: int) mod m = x \\<longleftrightarrow> x \\<in> {0 ..< m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow> (x mod m = x) = (x \\<in> {0..<m})", "by (metis Divides.pos_mod_bound Divides.pos_mod_sign atLeastLessThan_iff mod_pos_pos_trivial)"], ["", "declare prod_mset_prod_list[simp]"], ["", "lemma mult_1_is_id[simp]: \"(*) (1 :: 'a :: ring_1) = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (*) (1::'a) = id", "by auto"], ["", "context poly_mod\nbegin"], ["", "lemma degree_m_eq_monic: \"monic f \\<Longrightarrow> m > 1 \\<Longrightarrow> degree_m f = degree f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>monic f; 1 < m\\<rbrakk> \\<Longrightarrow> degree_m f = degree f", "by (rule degree_m_eq) auto"], ["", "lemma monic_degree_m_lift: assumes \"monic f\" \"k > 1\" \"m > 1\"\n  shows \"monic (poly_mod.Mp (m * k) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (poly_mod.Mp (m * k) f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monic (poly_mod.Mp (m * k) f)", "have deg: \"degree (poly_mod.Mp (m * k) f) = degree f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (poly_mod.Mp (m * k) f) = degree f", "by (rule poly_mod.degree_m_eq_monic[of f \"m * k\"], insert assms, auto simp: less_1_mult)"], ["proof (state)\nthis:\n  degree (poly_mod.Mp (m * k) f) = degree f\n\ngoal (1 subgoal):\n 1. monic (poly_mod.Mp (m * k) f)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (poly_mod.Mp (m * k) f)", "unfolding poly_mod.Mp_coeff deg assms poly_mod.M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 mod (m * k) = 1", "using assms(2-)"], ["proof (prove)\nusing this:\n  1 < k\n  1 < m\n\ngoal (1 subgoal):\n 1. 1 mod (m * k) = 1", "by (simp add: less_1_mult)"], ["proof (state)\nthis:\n  monic (poly_mod.Mp (m * k) f)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale poly_mod_2 = poly_mod m for m +\n  assumes m1: \"m > 1\"\nbegin"], ["", "lemma M_1[simp]: \"M 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M 1 = 1", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 mod m = 1", "using m1"], ["proof (prove)\nusing this:\n  1 < m\n\ngoal (1 subgoal):\n 1. 1 mod m = 1", "by auto"], ["", "lemma Mp_1[simp]: \"Mp 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp 1 = 1", "unfolding Mp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly M 1 = 1", "by simp"], ["", "lemma monic_degree_m[simp]: \"monic f \\<Longrightarrow> degree_m f = degree f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic f \\<Longrightarrow> degree_m f = degree f", "using degree_m_eq_monic[of f]"], ["proof (prove)\nusing this:\n  \\<lbrakk>monic f; 1 < m\\<rbrakk> \\<Longrightarrow> degree_m f = degree f\n\ngoal (1 subgoal):\n 1. monic f \\<Longrightarrow> degree_m f = degree f", "using m1"], ["proof (prove)\nusing this:\n  \\<lbrakk>monic f; 1 < m\\<rbrakk> \\<Longrightarrow> degree_m f = degree f\n  1 < m\n\ngoal (1 subgoal):\n 1. monic f \\<Longrightarrow> degree_m f = degree f", "by auto"], ["", "lemma monic_Mp: \"monic f \\<Longrightarrow> monic (Mp f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic f \\<Longrightarrow> monic (Mp f)", "by (auto simp: Mp_coeff)"], ["", "lemma Mp_0_smult_sdiv_poly: assumes \"Mp f = 0\" \n  shows \"smult m (sdiv_poly f m) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult m (sdiv_poly f m) = f", "proof (intro poly_eqI, unfold Mp_coeff coeff_smult sdiv_poly_def, subst coeff_map_poly, force)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. m * (coeff f n div m) = coeff f n", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. m * (coeff f n div m) = coeff f n", "from assms"], ["proof (chain)\npicking this:\n  Mp f = 0", "have \"coeff (Mp f) n = 0\""], ["proof (prove)\nusing this:\n  Mp f = 0\n\ngoal (1 subgoal):\n 1. coeff (Mp f) n = 0", "by simp"], ["proof (state)\nthis:\n  coeff (Mp f) n = 0\n\ngoal (1 subgoal):\n 1. \\<And>n. m * (coeff f n div m) = coeff f n", "hence 0: \"coeff f n mod m = 0\""], ["proof (prove)\nusing this:\n  coeff (Mp f) n = 0\n\ngoal (1 subgoal):\n 1. coeff f n mod m = 0", "unfolding Mp_coeff M_def"], ["proof (prove)\nusing this:\n  coeff f n mod m = 0\n\ngoal (1 subgoal):\n 1. coeff f n mod m = 0", "."], ["proof (state)\nthis:\n  coeff f n mod m = 0\n\ngoal (1 subgoal):\n 1. \\<And>n. m * (coeff f n div m) = coeff f n", "thus \"m * (coeff f n div m) = coeff f n\""], ["proof (prove)\nusing this:\n  coeff f n mod m = 0\n\ngoal (1 subgoal):\n 1. m * (coeff f n div m) = coeff f n", "by auto"], ["proof (state)\nthis:\n  m * (coeff f n div m) = coeff f n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Mp_product_modulus: \"m' = m * k \\<Longrightarrow> k > 0 \\<Longrightarrow> Mp (poly_mod.Mp m' f) = Mp f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' = m * k; 0 < k\\<rbrakk>\n    \\<Longrightarrow> poly_mod.Mp m' f =m f", "by (intro poly_eqI, unfold poly_mod.Mp_coeff poly_mod.M_def, auto simp: mod_mod_cancel)"], ["", "lemma inv_M_rev: assumes bnd: \"2 * abs c < m\" \n  shows \"inv_M (M c) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_M (M c) = c", "proof (cases \"c \\<ge> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> c \\<Longrightarrow> inv_M (M c) = c\n 2. \\<not> 0 \\<le> c \\<Longrightarrow> inv_M (M c) = c", "case True"], ["proof (state)\nthis:\n  0 \\<le> c\n\ngoal (2 subgoals):\n 1. 0 \\<le> c \\<Longrightarrow> inv_M (M c) = c\n 2. \\<not> 0 \\<le> c \\<Longrightarrow> inv_M (M c) = c", "with bnd"], ["proof (chain)\npicking this:\n  2 * \\<bar>c\\<bar> < m\n  0 \\<le> c", "show ?thesis"], ["proof (prove)\nusing this:\n  2 * \\<bar>c\\<bar> < m\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. inv_M (M c) = c", "unfolding M_def inv_M_def"], ["proof (prove)\nusing this:\n  2 * \\<bar>c\\<bar> < m\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. (if c mod m + c mod m \\<le> m then c mod m else c mod m - m) = c", "by auto"], ["proof (state)\nthis:\n  inv_M (M c) = c\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> c \\<Longrightarrow> inv_M (M c) = c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> c \\<Longrightarrow> inv_M (M c) = c", "case False"], ["proof (state)\nthis:\n  \\<not> 0 \\<le> c\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> c \\<Longrightarrow> inv_M (M c) = c", "have 2: \"\\<And> v :: int. 2 * v = v + v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v. 2 * v = v + v", "by auto"], ["proof (state)\nthis:\n  2 * ?v = ?v + ?v\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> c \\<Longrightarrow> inv_M (M c) = c", "from False"], ["proof (chain)\npicking this:\n  \\<not> 0 \\<le> c", "have c: \"c < 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> c\n\ngoal (1 subgoal):\n 1. c < 0", "by auto"], ["proof (state)\nthis:\n  c < 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> c \\<Longrightarrow> inv_M (M c) = c", "from bnd c"], ["proof (chain)\npicking this:\n  2 * \\<bar>c\\<bar> < m\n  c < 0", "have \"c + m > 0\" \"c + m < m\""], ["proof (prove)\nusing this:\n  2 * \\<bar>c\\<bar> < m\n  c < 0\n\ngoal (1 subgoal):\n 1. 0 < c + m &&& c + m < m", "by auto"], ["proof (state)\nthis:\n  0 < c + m\n  c + m < m\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> c \\<Longrightarrow> inv_M (M c) = c", "with c"], ["proof (chain)\npicking this:\n  c < 0\n  0 < c + m\n  c + m < m", "have cm: \"c mod m = c + m\""], ["proof (prove)\nusing this:\n  c < 0\n  0 < c + m\n  c + m < m\n\ngoal (1 subgoal):\n 1. c mod m = c + m", "by (metis le_less mod_add_self2 mod_pos_pos_trivial)"], ["proof (state)\nthis:\n  c mod m = c + m\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> c \\<Longrightarrow> inv_M (M c) = c", "from c bnd"], ["proof (chain)\npicking this:\n  c < 0\n  2 * \\<bar>c\\<bar> < m", "have \"2 * (c mod m) > m\""], ["proof (prove)\nusing this:\n  c < 0\n  2 * \\<bar>c\\<bar> < m\n\ngoal (1 subgoal):\n 1. m < 2 * (c mod m)", "unfolding cm"], ["proof (prove)\nusing this:\n  c < 0\n  2 * \\<bar>c\\<bar> < m\n\ngoal (1 subgoal):\n 1. m < 2 * (c + m)", "by auto"], ["proof (state)\nthis:\n  m < 2 * (c mod m)\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> c \\<Longrightarrow> inv_M (M c) = c", "with bnd c"], ["proof (chain)\npicking this:\n  2 * \\<bar>c\\<bar> < m\n  c < 0\n  m < 2 * (c mod m)", "show ?thesis"], ["proof (prove)\nusing this:\n  2 * \\<bar>c\\<bar> < m\n  c < 0\n  m < 2 * (c mod m)\n\ngoal (1 subgoal):\n 1. inv_M (M c) = c", "unfolding M_def inv_M_def cm"], ["proof (prove)\nusing this:\n  2 * \\<bar>c\\<bar> < m\n  c < 0\n  m < 2 * (c + m)\n\ngoal (1 subgoal):\n 1. (if c + m + (c + m) \\<le> m then c + m else c + m - m) = c", "by auto"], ["proof (state)\nthis:\n  inv_M (M c) = c\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma (in poly_mod) degree_m_eq_prime:\n  assumes f0: \"Mp f \\<noteq> 0\"\n  and deg: \"degree_m f = degree f\" \n  and eq: \"f =m g * h\" \n  and p: \"prime m\" \n  shows \"degree_m f = degree_m g + degree_m h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m f = degree_m g + degree_m h", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree_m f = degree_m g + degree_m h", "interpret poly_mod_2 m"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_2 m", "using prime_ge_2_int[OF p]"], ["proof (prove)\nusing this:\n  2 \\<le> m\n\ngoal (1 subgoal):\n 1. poly_mod_2 m", "unfolding poly_mod_2_def"], ["proof (prove)\nusing this:\n  2 \\<le> m\n\ngoal (1 subgoal):\n 1. 1 < m", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. degree_m f = degree_m g + degree_m h", "from f0 eq"], ["proof (chain)\npicking this:\n  Mp f \\<noteq> 0\n  f =m g * h", "have \"Mp (Mp g * Mp h) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  Mp f \\<noteq> 0\n  f =m g * h\n\ngoal (1 subgoal):\n 1. Mp (Mp g * Mp h) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  Mp (Mp g * Mp h) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree_m f = degree_m g + degree_m h", "hence \"Mp g * Mp h \\<noteq> 0\""], ["proof (prove)\nusing this:\n  Mp (Mp g * Mp h) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Mp g * Mp h \\<noteq> 0", "using Mp_0"], ["proof (prove)\nusing this:\n  Mp (Mp g * Mp h) \\<noteq> 0\n  Mp 0 = 0\n\ngoal (1 subgoal):\n 1. Mp g * Mp h \\<noteq> 0", "by (cases \"Mp g * Mp h\", auto)"], ["proof (state)\nthis:\n  Mp g * Mp h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree_m f = degree_m g + degree_m h", "hence g0: \"Mp g \\<noteq> 0\" and h0: \"Mp h \\<noteq> 0\""], ["proof (prove)\nusing this:\n  Mp g * Mp h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Mp g \\<noteq> 0 &&& Mp h \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  Mp g \\<noteq> 0\n  Mp h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree_m f = degree_m g + degree_m h", "have \"degree (Mp (g * h)) = degree_m (Mp g * Mp h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m (g * h) = degree_m (Mp g * Mp h)", "by simp"], ["proof (state)\nthis:\n  degree_m (g * h) = degree_m (Mp g * Mp h)\n\ngoal (1 subgoal):\n 1. degree_m f = degree_m g + degree_m h", "also"], ["proof (state)\nthis:\n  degree_m (g * h) = degree_m (Mp g * Mp h)\n\ngoal (1 subgoal):\n 1. degree_m f = degree_m g + degree_m h", "have \"\\<dots> = degree (Mp g * Mp h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m (Mp g * Mp h) = degree (Mp g * Mp h)", "proof (rule degree_m_eq[OF _ m1], rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. lead_coeff (Mp g * Mp h) mod m = 0 \\<Longrightarrow> False", "have id: \"\\<And> g. coeff (Mp g) (degree (Mp g)) mod m = coeff (Mp g) (degree (Mp g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g. lead_coeff (Mp g) mod m = lead_coeff (Mp g)", "unfolding M_def[symmetric] Mp_coeff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g. M (M (coeff g (degree_m g))) = M (coeff g (degree_m g))", "by simp"], ["proof (state)\nthis:\n  lead_coeff (Mp ?g) mod m = lead_coeff (Mp ?g)\n\ngoal (1 subgoal):\n 1. lead_coeff (Mp g * Mp h) mod m = 0 \\<Longrightarrow> False", "from p"], ["proof (chain)\npicking this:\n  prime m", "have p': \"prime m\""], ["proof (prove)\nusing this:\n  prime m\n\ngoal (1 subgoal):\n 1. prime m", "unfolding prime_int_nat_transfer"], ["proof (prove)\nusing this:\n  0 \\<le> m \\<and> prime (nat m)\n\ngoal (1 subgoal):\n 1. 0 \\<le> m \\<and> prime (nat m)", "unfolding prime_nat_iff"], ["proof (prove)\nusing this:\n  0 \\<le> m \\<and>\n  1 < nat m \\<and>\n  (\\<forall>ma. ma dvd nat m \\<longrightarrow> ma = 1 \\<or> ma = nat m)\n\ngoal (1 subgoal):\n 1. 0 \\<le> m \\<and>\n    1 < nat m \\<and>\n    (\\<forall>ma. ma dvd nat m \\<longrightarrow> ma = 1 \\<or> ma = nat m)", "by auto"], ["proof (state)\nthis:\n  prime m\n\ngoal (1 subgoal):\n 1. lead_coeff (Mp g * Mp h) mod m = 0 \\<Longrightarrow> False", "assume \"coeff (Mp g * Mp h) (degree (Mp g * Mp h)) mod m = 0\""], ["proof (state)\nthis:\n  lead_coeff (Mp g * Mp h) mod m = 0\n\ngoal (1 subgoal):\n 1. lead_coeff (Mp g * Mp h) mod m = 0 \\<Longrightarrow> False", "from this[unfolded coeff_degree_mult]"], ["proof (chain)\npicking this:\n  lead_coeff (Mp h) * lead_coeff (Mp g) mod m = 0", "have \"coeff (Mp g) (degree (Mp g)) mod m = 0 \\<or> coeff (Mp h) (degree (Mp h)) mod m = 0\""], ["proof (prove)\nusing this:\n  lead_coeff (Mp h) * lead_coeff (Mp g) mod m = 0\n\ngoal (1 subgoal):\n 1. lead_coeff (Mp g) mod m = 0 \\<or> lead_coeff (Mp h) mod m = 0", "unfolding dvd_eq_mod_eq_0[symmetric]"], ["proof (prove)\nusing this:\n  m dvd lead_coeff (Mp h) * lead_coeff (Mp g)\n\ngoal (1 subgoal):\n 1. m dvd lead_coeff (Mp g) \\<or> m dvd lead_coeff (Mp h)", "using m1 prime_dvd_mult_int[OF p']"], ["proof (prove)\nusing this:\n  m dvd lead_coeff (Mp h) * lead_coeff (Mp g)\n  1 < m\n  (m dvd ?a * ?b) = (m dvd ?a \\<or> m dvd ?b)\n\ngoal (1 subgoal):\n 1. m dvd lead_coeff (Mp g) \\<or> m dvd lead_coeff (Mp h)", "by auto"], ["proof (state)\nthis:\n  lead_coeff (Mp g) mod m = 0 \\<or> lead_coeff (Mp h) mod m = 0\n\ngoal (1 subgoal):\n 1. lead_coeff (Mp g * Mp h) mod m = 0 \\<Longrightarrow> False", "with g0 h0"], ["proof (chain)\npicking this:\n  Mp g \\<noteq> 0\n  Mp h \\<noteq> 0\n  lead_coeff (Mp g) mod m = 0 \\<or> lead_coeff (Mp h) mod m = 0", "show False"], ["proof (prove)\nusing this:\n  Mp g \\<noteq> 0\n  Mp h \\<noteq> 0\n  lead_coeff (Mp g) mod m = 0 \\<or> lead_coeff (Mp h) mod m = 0\n\ngoal (1 subgoal):\n 1. False", "unfolding id"], ["proof (prove)\nusing this:\n  Mp g \\<noteq> 0\n  Mp h \\<noteq> 0\n  lead_coeff (Mp g) = 0 \\<or> lead_coeff (Mp h) = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree_m (Mp g * Mp h) = degree (Mp g * Mp h)\n\ngoal (1 subgoal):\n 1. degree_m f = degree_m g + degree_m h", "also"], ["proof (state)\nthis:\n  degree_m (Mp g * Mp h) = degree (Mp g * Mp h)\n\ngoal (1 subgoal):\n 1. degree_m f = degree_m g + degree_m h", "have \"\\<dots> = degree (Mp g) + degree (Mp h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (Mp g * Mp h) = degree_m g + degree_m h", "by (rule degree_mult_eq[OF g0 h0])"], ["proof (state)\nthis:\n  degree (Mp g * Mp h) = degree_m g + degree_m h\n\ngoal (1 subgoal):\n 1. degree_m f = degree_m g + degree_m h", "finally"], ["proof (chain)\npicking this:\n  degree_m (g * h) = degree_m g + degree_m h", "show ?thesis"], ["proof (prove)\nusing this:\n  degree_m (g * h) = degree_m g + degree_m h\n\ngoal (1 subgoal):\n 1. degree_m f = degree_m g + degree_m h", "using eq"], ["proof (prove)\nusing this:\n  degree_m (g * h) = degree_m g + degree_m h\n  f =m g * h\n\ngoal (1 subgoal):\n 1. degree_m f = degree_m g + degree_m h", "by simp"], ["proof (state)\nthis:\n  degree_m f = degree_m g + degree_m h\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monic_smult_add_small: assumes \"f = 0 \\<or> degree f < degree g\" and mon: \"monic g\" \n  shows \"monic (g + smult q f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (g + smult q f)", "proof (cases \"f = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f = 0 \\<Longrightarrow> monic (g + smult q f)\n 2. f \\<noteq> 0 \\<Longrightarrow> monic (g + smult q f)", "case True"], ["proof (state)\nthis:\n  f = 0\n\ngoal (2 subgoals):\n 1. f = 0 \\<Longrightarrow> monic (g + smult q f)\n 2. f \\<noteq> 0 \\<Longrightarrow> monic (g + smult q f)", "thus ?thesis"], ["proof (prove)\nusing this:\n  f = 0\n\ngoal (1 subgoal):\n 1. monic (g + smult q f)", "using mon"], ["proof (prove)\nusing this:\n  f = 0\n  monic g\n\ngoal (1 subgoal):\n 1. monic (g + smult q f)", "by auto"], ["proof (state)\nthis:\n  monic (g + smult q f)\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> monic (g + smult q f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> monic (g + smult q f)", "case False"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> monic (g + smult q f)", "with assms"], ["proof (chain)\npicking this:\n  f = 0 \\<or> degree f < degree g\n  monic g\n  f \\<noteq> 0", "have \"degree f < degree g\""], ["proof (prove)\nusing this:\n  f = 0 \\<or> degree f < degree g\n  monic g\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree f < degree g", "by auto"], ["proof (state)\nthis:\n  degree f < degree g\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> monic (g + smult q f)", "hence \"degree (smult q f) < degree g\""], ["proof (prove)\nusing this:\n  degree f < degree g\n\ngoal (1 subgoal):\n 1. degree (smult q f) < degree g", "by (meson degree_smult_le not_less order_trans)"], ["proof (state)\nthis:\n  degree (smult q f) < degree g\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> monic (g + smult q f)", "thus ?thesis"], ["proof (prove)\nusing this:\n  degree (smult q f) < degree g\n\ngoal (1 subgoal):\n 1. monic (g + smult q f)", "using mon"], ["proof (prove)\nusing this:\n  degree (smult q f) < degree g\n  monic g\n\ngoal (1 subgoal):\n 1. monic (g + smult q f)", "using coeff_eq_0 degree_add_eq_left"], ["proof (prove)\nusing this:\n  degree (smult q f) < degree g\n  monic g\n  degree ?p < ?n \\<Longrightarrow> coeff ?p ?n = (0::?'a)\n  degree ?q < degree ?p \\<Longrightarrow> degree (?p + ?q) = degree ?p\n\ngoal (1 subgoal):\n 1. monic (g + smult q f)", "by fastforce"], ["proof (state)\nthis:\n  monic (g + smult q f)\n\ngoal:\nNo subgoals!", "qed"], ["", "context poly_mod \nbegin"], ["", "definition factorization_m :: \"int poly \\<Rightarrow> (int \\<times> int poly multiset) \\<Rightarrow> bool\" where\n  \"factorization_m f cfs \\<equiv> (case cfs of (c,fs) \\<Rightarrow> f =m (smult c (prod_mset fs)) \\<and> \n    (\\<forall> f \\<in> set_mset fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f)))\""], ["", "definition Mf :: \"int \\<times> int poly multiset \\<Rightarrow> int \\<times> int poly multiset\" where\n  \"Mf cfs \\<equiv> case cfs of (c,fs) \\<Rightarrow> (M c, image_mset Mp fs)\""], ["", "lemma Mf_Mf[simp]: \"Mf (Mf x) = Mf x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mf (Mf x) = Mf x", "proof (cases x, auto simp: Mf_def, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       x = (a, b) \\<Longrightarrow>\n       image_mset Mp (image_mset Mp b) = image_mset Mp b", "case (1 c fs)"], ["proof (state)\nthis:\n  x = (c, fs)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       x = (a, b) \\<Longrightarrow>\n       image_mset Mp (image_mset Mp b) = image_mset Mp b", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset Mp (image_mset Mp fs) = image_mset Mp fs", "by (induct fs, auto)"], ["proof (state)\nthis:\n  image_mset Mp (image_mset Mp fs) = image_mset Mp fs\n\ngoal:\nNo subgoals!", "qed"], ["", "definition equivalent_fact_m :: \"int \\<times> int poly multiset \\<Rightarrow> int \\<times> int poly multiset \\<Rightarrow> bool\" where\n  \"equivalent_fact_m cfs dgs = (Mf cfs = Mf dgs)\""], ["", "definition unique_factorization_m :: \"int poly \\<Rightarrow> (int \\<times> int poly multiset) \\<Rightarrow> bool\" where\n  \"unique_factorization_m f cfs = (Mf ` Collect (factorization_m f) = {Mf cfs})\""], ["", "lemma Mp_irreducible\\<^sub>d_m[simp]: \"irreducible\\<^sub>d_m (Mp f) = irreducible\\<^sub>d_m f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d_m (Mp f) = irreducible\\<^sub>d_m f", "unfolding irreducible\\<^sub>d_m_def dvdm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < degree_m (Mp f) \\<and>\n     (\\<forall>g h.\n         degree_m g < degree_m (Mp f) \\<longrightarrow>\n         degree_m h < degree_m (Mp f) \\<longrightarrow>\n         Mp (Mp f) \\<noteq> Mp (g * h))) =\n    (0 < degree_m f \\<and>\n     (\\<forall>g h.\n         degree_m g < degree_m f \\<longrightarrow>\n         degree_m h < degree_m f \\<longrightarrow>\n         Mp f \\<noteq> Mp (g * h)))", "by simp"], ["", "lemma Mf_factorization_m[simp]: \"factorization_m f (Mf cfs) = factorization_m f cfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. factorization_m f (Mf cfs) = factorization_m f cfs", "unfolding factorization_m_def Mf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case case cfs of (c, fs) \\<Rightarrow> (M c, image_mset Mp fs) of\n     (c, fs) \\<Rightarrow>\n       f =m smult c (\\<Prod>\\<^sub># fs) \\<and>\n       (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))) =\n    (case cfs of\n     (c, fs) \\<Rightarrow>\n       f =m smult c (\\<Prod>\\<^sub># fs) \\<and>\n       (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f)))", "proof (cases cfs, simp, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       cfs = (a, b) \\<Longrightarrow>\n       (f =m smult a (\\<Prod>\\<^sub># (image_mset Mp b)) \\<and>\n        (\\<forall>f\\<in>#b. irreducible\\<^sub>d_m f \\<and> monic (Mp f))) =\n       (f =m smult a (\\<Prod>\\<^sub># b) \\<and>\n        (\\<forall>f\\<in>#b. irreducible\\<^sub>d_m f \\<and> monic (Mp f)))", "case (1 c fs)"], ["proof (state)\nthis:\n  cfs = (c, fs)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       cfs = (a, b) \\<Longrightarrow>\n       (f =m smult a (\\<Prod>\\<^sub># (image_mset Mp b)) \\<and>\n        (\\<forall>f\\<in>#b. irreducible\\<^sub>d_m f \\<and> monic (Mp f))) =\n       (f =m smult a (\\<Prod>\\<^sub># b) \\<and>\n        (\\<forall>f\\<in>#b. irreducible\\<^sub>d_m f \\<and> monic (Mp f)))", "have \"Mp (smult c (prod_mset fs)) = Mp (smult (M c) (Mp (prod_mset fs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult c (\\<Prod>\\<^sub># fs) =m smult (M c) (Mp (\\<Prod>\\<^sub># fs))", "by simp"], ["proof (state)\nthis:\n  smult c (\\<Prod>\\<^sub># fs) =m smult (M c) (Mp (\\<Prod>\\<^sub># fs))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       cfs = (a, b) \\<Longrightarrow>\n       (f =m smult a (\\<Prod>\\<^sub># (image_mset Mp b)) \\<and>\n        (\\<forall>f\\<in>#b. irreducible\\<^sub>d_m f \\<and> monic (Mp f))) =\n       (f =m smult a (\\<Prod>\\<^sub># b) \\<and>\n        (\\<forall>f\\<in>#b. irreducible\\<^sub>d_m f \\<and> monic (Mp f)))", "also"], ["proof (state)\nthis:\n  smult c (\\<Prod>\\<^sub># fs) =m smult (M c) (Mp (\\<Prod>\\<^sub># fs))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       cfs = (a, b) \\<Longrightarrow>\n       (f =m smult a (\\<Prod>\\<^sub># (image_mset Mp b)) \\<and>\n        (\\<forall>f\\<in>#b. irreducible\\<^sub>d_m f \\<and> monic (Mp f))) =\n       (f =m smult a (\\<Prod>\\<^sub># b) \\<and>\n        (\\<forall>f\\<in>#b. irreducible\\<^sub>d_m f \\<and> monic (Mp f)))", "have \"\\<dots> = Mp (smult (M c) (Mp (prod_mset (image_mset Mp fs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (M c) (Mp (\\<Prod>\\<^sub># fs)) =m\n    smult (M c) (Mp (\\<Prod>\\<^sub># (image_mset Mp fs)))", "unfolding Mp_prod_mset"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (M c) (Mp (\\<Prod>\\<^sub># fs)) =m\n    smult (M c) (Mp (\\<Prod>\\<^sub># fs))", "by simp"], ["proof (state)\nthis:\n  smult (M c) (Mp (\\<Prod>\\<^sub># fs)) =m\n  smult (M c) (Mp (\\<Prod>\\<^sub># (image_mset Mp fs)))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       cfs = (a, b) \\<Longrightarrow>\n       (f =m smult a (\\<Prod>\\<^sub># (image_mset Mp b)) \\<and>\n        (\\<forall>f\\<in>#b. irreducible\\<^sub>d_m f \\<and> monic (Mp f))) =\n       (f =m smult a (\\<Prod>\\<^sub># b) \\<and>\n        (\\<forall>f\\<in>#b. irreducible\\<^sub>d_m f \\<and> monic (Mp f)))", "also"], ["proof (state)\nthis:\n  smult (M c) (Mp (\\<Prod>\\<^sub># fs)) =m\n  smult (M c) (Mp (\\<Prod>\\<^sub># (image_mset Mp fs)))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       cfs = (a, b) \\<Longrightarrow>\n       (f =m smult a (\\<Prod>\\<^sub># (image_mset Mp b)) \\<and>\n        (\\<forall>f\\<in>#b. irreducible\\<^sub>d_m f \\<and> monic (Mp f))) =\n       (f =m smult a (\\<Prod>\\<^sub># b) \\<and>\n        (\\<forall>f\\<in>#b. irreducible\\<^sub>d_m f \\<and> monic (Mp f)))", "have \"\\<dots> = Mp (smult (M c) (prod_mset (image_mset Mp fs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (M c) (Mp (\\<Prod>\\<^sub># (image_mset Mp fs))) =m\n    smult (M c) (\\<Prod>\\<^sub># (image_mset Mp fs))", "unfolding Mp_smult"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult c (\\<Prod>\\<^sub># (image_mset Mp fs)) =m\n    smult c (\\<Prod>\\<^sub># (image_mset Mp fs))", ".."], ["proof (state)\nthis:\n  smult (M c) (Mp (\\<Prod>\\<^sub># (image_mset Mp fs))) =m\n  smult (M c) (\\<Prod>\\<^sub># (image_mset Mp fs))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       cfs = (a, b) \\<Longrightarrow>\n       (f =m smult a (\\<Prod>\\<^sub># (image_mset Mp b)) \\<and>\n        (\\<forall>f\\<in>#b. irreducible\\<^sub>d_m f \\<and> monic (Mp f))) =\n       (f =m smult a (\\<Prod>\\<^sub># b) \\<and>\n        (\\<forall>f\\<in>#b. irreducible\\<^sub>d_m f \\<and> monic (Mp f)))", "finally"], ["proof (chain)\npicking this:\n  smult c (\\<Prod>\\<^sub># fs) =m\n  smult (M c) (\\<Prod>\\<^sub># (image_mset Mp fs))", "show ?case"], ["proof (prove)\nusing this:\n  smult c (\\<Prod>\\<^sub># fs) =m\n  smult (M c) (\\<Prod>\\<^sub># (image_mset Mp fs))\n\ngoal (1 subgoal):\n 1. (f =m smult c (\\<Prod>\\<^sub># (image_mset Mp fs)) \\<and>\n     (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))) =\n    (f =m smult c (\\<Prod>\\<^sub># fs) \\<and>\n     (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f)))", "by auto"], ["proof (state)\nthis:\n  (f =m smult c (\\<Prod>\\<^sub># (image_mset Mp fs)) \\<and>\n   (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))) =\n  (f =m smult c (\\<Prod>\\<^sub># fs) \\<and>\n   (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unique_factorization_m_imp_factorization: assumes \"unique_factorization_m f cfs\" \n  shows \"factorization_m f cfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. factorization_m f cfs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. factorization_m f cfs", "from assms[unfolded unique_factorization_m_def]"], ["proof (chain)\npicking this:\n  Mf ` Collect (factorization_m f) = {Mf cfs}", "obtain dfs where\n     fact: \"factorization_m f dfs\" and id: \"Mf cfs = Mf dfs\""], ["proof (prove)\nusing this:\n  Mf ` Collect (factorization_m f) = {Mf cfs}\n\ngoal (1 subgoal):\n 1. (\\<And>dfs.\n        \\<lbrakk>factorization_m f dfs; Mf cfs = Mf dfs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  factorization_m f dfs\n  Mf cfs = Mf dfs\n\ngoal (1 subgoal):\n 1. factorization_m f cfs", "from fact"], ["proof (chain)\npicking this:\n  factorization_m f dfs", "have \"factorization_m f (Mf dfs)\""], ["proof (prove)\nusing this:\n  factorization_m f dfs\n\ngoal (1 subgoal):\n 1. factorization_m f (Mf dfs)", "by simp"], ["proof (state)\nthis:\n  factorization_m f (Mf dfs)\n\ngoal (1 subgoal):\n 1. factorization_m f cfs", "from this[folded id]"], ["proof (chain)\npicking this:\n  factorization_m f (Mf cfs)", "show ?thesis"], ["proof (prove)\nusing this:\n  factorization_m f (Mf cfs)\n\ngoal (1 subgoal):\n 1. factorization_m f cfs", "by simp"], ["proof (state)\nthis:\n  factorization_m f cfs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unique_factorization_m_alt_def: \"unique_factorization_m f cfs = (factorization_m f cfs\n  \\<and> (\\<forall> dgs. factorization_m f dgs \\<longrightarrow> Mf dgs = Mf cfs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_factorization_m f cfs =\n    (factorization_m f cfs \\<and>\n     (\\<forall>dgs.\n         factorization_m f dgs \\<longrightarrow> Mf dgs = Mf cfs))", "using unique_factorization_m_imp_factorization[of f cfs]"], ["proof (prove)\nusing this:\n  unique_factorization_m f cfs \\<Longrightarrow> factorization_m f cfs\n\ngoal (1 subgoal):\n 1. unique_factorization_m f cfs =\n    (factorization_m f cfs \\<and>\n     (\\<forall>dgs.\n         factorization_m f dgs \\<longrightarrow> Mf dgs = Mf cfs))", "unfolding unique_factorization_m_def"], ["proof (prove)\nusing this:\n  Mf ` Collect (factorization_m f) = {Mf cfs} \\<Longrightarrow>\n  factorization_m f cfs\n\ngoal (1 subgoal):\n 1. (Mf ` Collect (factorization_m f) = {Mf cfs}) =\n    (factorization_m f cfs \\<and>\n     (\\<forall>dgs.\n         factorization_m f dgs \\<longrightarrow> Mf dgs = Mf cfs))", "by auto"], ["", "end"], ["", "context poly_mod_2\nbegin"], ["", "lemma factorization_m_lead_coeff: assumes \"factorization_m f (c,fs)\" \n  shows \"lead_coeff (Mp f) = M c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (Mp f) = M c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lead_coeff (Mp f) = M c", "note * = assms[unfolded factorization_m_def split]"], ["proof (state)\nthis:\n  f =m smult c (\\<Prod>\\<^sub># fs) \\<and>\n  (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n\ngoal (1 subgoal):\n 1. lead_coeff (Mp f) = M c", "have \"monic (prod_mset (image_mset Mp fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (\\<Prod>\\<^sub># (image_mset Mp fs))", "by (rule monic_prod_mset, insert *, auto)"], ["proof (state)\nthis:\n  monic (\\<Prod>\\<^sub># (image_mset Mp fs))\n\ngoal (1 subgoal):\n 1. lead_coeff (Mp f) = M c", "hence \"monic (Mp (prod_mset (image_mset Mp fs)))\""], ["proof (prove)\nusing this:\n  monic (\\<Prod>\\<^sub># (image_mset Mp fs))\n\ngoal (1 subgoal):\n 1. monic (Mp (\\<Prod>\\<^sub># (image_mset Mp fs)))", "by (rule monic_Mp)"], ["proof (state)\nthis:\n  monic (Mp (\\<Prod>\\<^sub># (image_mset Mp fs)))\n\ngoal (1 subgoal):\n 1. lead_coeff (Mp f) = M c", "from this[unfolded Mp_prod_mset]"], ["proof (chain)\npicking this:\n  monic (Mp (\\<Prod>\\<^sub># fs))", "have monic: \"monic (Mp (prod_mset fs))\""], ["proof (prove)\nusing this:\n  monic (Mp (\\<Prod>\\<^sub># fs))\n\ngoal (1 subgoal):\n 1. monic (Mp (\\<Prod>\\<^sub># fs))", "by simp"], ["proof (state)\nthis:\n  monic (Mp (\\<Prod>\\<^sub># fs))\n\ngoal (1 subgoal):\n 1. lead_coeff (Mp f) = M c", "from *"], ["proof (chain)\npicking this:\n  f =m smult c (\\<Prod>\\<^sub># fs) \\<and>\n  (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))", "have \"lead_coeff (Mp f) = lead_coeff (Mp (smult c (prod_mset fs)))\""], ["proof (prove)\nusing this:\n  f =m smult c (\\<Prod>\\<^sub># fs) \\<and>\n  (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n\ngoal (1 subgoal):\n 1. lead_coeff (Mp f) = lead_coeff (Mp (smult c (\\<Prod>\\<^sub># fs)))", "by simp"], ["proof (state)\nthis:\n  lead_coeff (Mp f) = lead_coeff (Mp (smult c (\\<Prod>\\<^sub># fs)))\n\ngoal (1 subgoal):\n 1. lead_coeff (Mp f) = M c", "also"], ["proof (state)\nthis:\n  lead_coeff (Mp f) = lead_coeff (Mp (smult c (\\<Prod>\\<^sub># fs)))\n\ngoal (1 subgoal):\n 1. lead_coeff (Mp f) = M c", "have \"Mp (smult c (prod_mset fs)) = Mp (smult (M c) (Mp (prod_mset fs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult c (\\<Prod>\\<^sub># fs) =m smult (M c) (Mp (\\<Prod>\\<^sub># fs))", "by simp"], ["proof (state)\nthis:\n  smult c (\\<Prod>\\<^sub># fs) =m smult (M c) (Mp (\\<Prod>\\<^sub># fs))\n\ngoal (1 subgoal):\n 1. lead_coeff (Mp f) = M c", "finally"], ["proof (chain)\npicking this:\n  lead_coeff (Mp f) =\n  lead_coeff (Mp (smult (M c) (Mp (\\<Prod>\\<^sub># fs))))", "show ?thesis"], ["proof (prove)\nusing this:\n  lead_coeff (Mp f) =\n  lead_coeff (Mp (smult (M c) (Mp (\\<Prod>\\<^sub># fs))))\n\ngoal (1 subgoal):\n 1. lead_coeff (Mp f) = M c", "using monic \\<open>smult c (prod_mset fs) =m smult (M c) (Mp (prod_mset fs))\\<close>"], ["proof (prove)\nusing this:\n  lead_coeff (Mp f) =\n  lead_coeff (Mp (smult (M c) (Mp (\\<Prod>\\<^sub># fs))))\n  monic (Mp (\\<Prod>\\<^sub># fs))\n  smult c (\\<Prod>\\<^sub># fs) =m smult (M c) (Mp (\\<Prod>\\<^sub># fs))\n\ngoal (1 subgoal):\n 1. lead_coeff (Mp f) = M c", "by (metis M_M M_def Mp_0 Mp_coeff lead_coeff_smult m1 mult_cancel_left2 poly_mod.degree_m_eq smult_eq_0_iff)"], ["proof (state)\nthis:\n  lead_coeff (Mp f) = M c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma factorization_m_smult: assumes \"factorization_m f (c,fs)\" \n  shows \"factorization_m (smult d f) (c * d,fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. factorization_m (smult d f) (c * d, fs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. factorization_m (smult d f) (c * d, fs)", "note * = assms[unfolded factorization_m_def split]"], ["proof (state)\nthis:\n  f =m smult c (\\<Prod>\\<^sub># fs) \\<and>\n  (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n\ngoal (1 subgoal):\n 1. factorization_m (smult d f) (c * d, fs)", "from *"], ["proof (chain)\npicking this:\n  f =m smult c (\\<Prod>\\<^sub># fs) \\<and>\n  (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))", "have f: \"Mp f = Mp (smult c (prod_mset fs))\""], ["proof (prove)\nusing this:\n  f =m smult c (\\<Prod>\\<^sub># fs) \\<and>\n  (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n\ngoal (1 subgoal):\n 1. f =m smult c (\\<Prod>\\<^sub># fs)", "by simp"], ["proof (state)\nthis:\n  f =m smult c (\\<Prod>\\<^sub># fs)\n\ngoal (1 subgoal):\n 1. factorization_m (smult d f) (c * d, fs)", "have \"Mp (smult d f) = Mp (smult d (Mp f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult d f =m smult d (Mp f)", "by simp"], ["proof (state)\nthis:\n  smult d f =m smult d (Mp f)\n\ngoal (1 subgoal):\n 1. factorization_m (smult d f) (c * d, fs)", "also"], ["proof (state)\nthis:\n  smult d f =m smult d (Mp f)\n\ngoal (1 subgoal):\n 1. factorization_m (smult d f) (c * d, fs)", "have \"\\<dots> = Mp (smult (c * d) (prod_mset fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult d (Mp f) =m smult (c * d) (\\<Prod>\\<^sub># fs)", "unfolding f"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult d (Mp (smult c (\\<Prod>\\<^sub># fs))) =m\n    smult (c * d) (\\<Prod>\\<^sub># fs)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  smult d (Mp f) =m smult (c * d) (\\<Prod>\\<^sub># fs)\n\ngoal (1 subgoal):\n 1. factorization_m (smult d f) (c * d, fs)", "finally"], ["proof (chain)\npicking this:\n  smult d f =m smult (c * d) (\\<Prod>\\<^sub># fs)", "show ?thesis"], ["proof (prove)\nusing this:\n  smult d f =m smult (c * d) (\\<Prod>\\<^sub># fs)\n\ngoal (1 subgoal):\n 1. factorization_m (smult d f) (c * d, fs)", "using assms"], ["proof (prove)\nusing this:\n  smult d f =m smult (c * d) (\\<Prod>\\<^sub># fs)\n  factorization_m f (c, fs)\n\ngoal (1 subgoal):\n 1. factorization_m (smult d f) (c * d, fs)", "unfolding factorization_m_def split"], ["proof (prove)\nusing this:\n  smult d f =m smult (c * d) (\\<Prod>\\<^sub># fs)\n  f =m smult c (\\<Prod>\\<^sub># fs) \\<and>\n  (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n\ngoal (1 subgoal):\n 1. smult d f =m smult (c * d) (\\<Prod>\\<^sub># fs) \\<and>\n    (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))", "by auto"], ["proof (state)\nthis:\n  factorization_m (smult d f) (c * d, fs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma factorization_m_prod: assumes \"factorization_m f (c,fs)\" \"factorization_m g (d,gs)\" \n  shows \"factorization_m (f * g) (c * d, fs + gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. factorization_m (f * g) (c * d, fs + gs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. factorization_m (f * g) (c * d, fs + gs)", "note * = assms[unfolded factorization_m_def split]"], ["proof (state)\nthis:\n  f =m smult c (\\<Prod>\\<^sub># fs) \\<and>\n  (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n  g =m smult d (\\<Prod>\\<^sub># gs) \\<and>\n  (\\<forall>f\\<in>#gs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n\ngoal (1 subgoal):\n 1. factorization_m (f * g) (c * d, fs + gs)", "have \"Mp (f * g) = Mp (Mp f * Mp g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f * g =m Mp f * Mp g", "by simp"], ["proof (state)\nthis:\n  f * g =m Mp f * Mp g\n\ngoal (1 subgoal):\n 1. factorization_m (f * g) (c * d, fs + gs)", "also"], ["proof (state)\nthis:\n  f * g =m Mp f * Mp g\n\ngoal (1 subgoal):\n 1. factorization_m (f * g) (c * d, fs + gs)", "have \"Mp f = Mp (smult c (prod_mset fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f =m smult c (\\<Prod>\\<^sub># fs)", "using *"], ["proof (prove)\nusing this:\n  f =m smult c (\\<Prod>\\<^sub># fs) \\<and>\n  (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n  g =m smult d (\\<Prod>\\<^sub># gs) \\<and>\n  (\\<forall>f\\<in>#gs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n\ngoal (1 subgoal):\n 1. f =m smult c (\\<Prod>\\<^sub># fs)", "by simp"], ["proof (state)\nthis:\n  f =m smult c (\\<Prod>\\<^sub># fs)\n\ngoal (1 subgoal):\n 1. factorization_m (f * g) (c * d, fs + gs)", "also"], ["proof (state)\nthis:\n  f =m smult c (\\<Prod>\\<^sub># fs)\n\ngoal (1 subgoal):\n 1. factorization_m (f * g) (c * d, fs + gs)", "have \"Mp g = Mp (smult d (prod_mset gs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g =m smult d (\\<Prod>\\<^sub># gs)", "using *"], ["proof (prove)\nusing this:\n  f =m smult c (\\<Prod>\\<^sub># fs) \\<and>\n  (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n  g =m smult d (\\<Prod>\\<^sub># gs) \\<and>\n  (\\<forall>f\\<in>#gs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n\ngoal (1 subgoal):\n 1. g =m smult d (\\<Prod>\\<^sub># gs)", "by simp"], ["proof (state)\nthis:\n  g =m smult d (\\<Prod>\\<^sub># gs)\n\ngoal (1 subgoal):\n 1. factorization_m (f * g) (c * d, fs + gs)", "finally"], ["proof (chain)\npicking this:\n  f * g =m\n  Mp (smult c (\\<Prod>\\<^sub># fs)) * Mp (smult d (\\<Prod>\\<^sub># gs))", "have \"Mp (f * g) = Mp (smult (c * d) (prod_mset (fs + gs)))\""], ["proof (prove)\nusing this:\n  f * g =m\n  Mp (smult c (\\<Prod>\\<^sub># fs)) * Mp (smult d (\\<Prod>\\<^sub># gs))\n\ngoal (1 subgoal):\n 1. f * g =m smult (c * d) (\\<Prod>\\<^sub># (fs + gs))", "unfolding mult_Mp"], ["proof (prove)\nusing this:\n  f * g =m smult c (\\<Prod>\\<^sub># fs) * smult d (\\<Prod>\\<^sub># gs)\n\ngoal (1 subgoal):\n 1. f * g =m smult (c * d) (\\<Prod>\\<^sub># (fs + gs))", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  f * g =m smult (c * d) (\\<Prod>\\<^sub># (fs + gs))\n\ngoal (1 subgoal):\n 1. factorization_m (f * g) (c * d, fs + gs)", "with *"], ["proof (chain)\npicking this:\n  f =m smult c (\\<Prod>\\<^sub># fs) \\<and>\n  (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n  g =m smult d (\\<Prod>\\<^sub># gs) \\<and>\n  (\\<forall>f\\<in>#gs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n  f * g =m smult (c * d) (\\<Prod>\\<^sub># (fs + gs))", "show ?thesis"], ["proof (prove)\nusing this:\n  f =m smult c (\\<Prod>\\<^sub># fs) \\<and>\n  (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n  g =m smult d (\\<Prod>\\<^sub># gs) \\<and>\n  (\\<forall>f\\<in>#gs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n  f * g =m smult (c * d) (\\<Prod>\\<^sub># (fs + gs))\n\ngoal (1 subgoal):\n 1. factorization_m (f * g) (c * d, fs + gs)", "unfolding factorization_m_def split"], ["proof (prove)\nusing this:\n  f =m smult c (\\<Prod>\\<^sub># fs) \\<and>\n  (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n  g =m smult d (\\<Prod>\\<^sub># gs) \\<and>\n  (\\<forall>f\\<in>#gs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n  f * g =m smult (c * d) (\\<Prod>\\<^sub># (fs + gs))\n\ngoal (1 subgoal):\n 1. f * g =m smult (c * d) (\\<Prod>\\<^sub># (fs + gs)) \\<and>\n    (\\<forall>f\\<in>#fs + gs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))", "by auto"], ["proof (state)\nthis:\n  factorization_m (f * g) (c * d, fs + gs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Mp_factorization_m[simp]: \"factorization_m (Mp f) cfs = factorization_m f cfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. factorization_m (Mp f) cfs = factorization_m f cfs", "unfolding factorization_m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case cfs of\n     (c, fs) \\<Rightarrow>\n       Mp f =m smult c (\\<Prod>\\<^sub># fs) \\<and>\n       (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))) =\n    (case cfs of\n     (c, fs) \\<Rightarrow>\n       f =m smult c (\\<Prod>\\<^sub># fs) \\<and>\n       (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f)))", "by simp"], ["", "lemma Mp_unique_factorization_m[simp]: \n  \"unique_factorization_m (Mp f) cfs = unique_factorization_m f cfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_factorization_m (Mp f) cfs = unique_factorization_m f cfs", "unfolding unique_factorization_m_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (factorization_m (Mp f) cfs \\<and>\n     (\\<forall>dgs.\n         factorization_m (Mp f) dgs \\<longrightarrow> Mf dgs = Mf cfs)) =\n    (factorization_m f cfs \\<and>\n     (\\<forall>dgs.\n         factorization_m f dgs \\<longrightarrow> Mf dgs = Mf cfs))", "by simp"], ["", "lemma unique_factorization_m_cong: \"unique_factorization_m f cfs \\<Longrightarrow> Mp f = Mp g \n  \\<Longrightarrow> unique_factorization_m g cfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unique_factorization_m f cfs; f =m g\\<rbrakk>\n    \\<Longrightarrow> unique_factorization_m g cfs", "unfolding Mp_unique_factorization_m[of f, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unique_factorization_m (Mp f) cfs; f =m g\\<rbrakk>\n    \\<Longrightarrow> unique_factorization_m g cfs", "by simp"], ["", "lemma unique_factorization_mI: assumes \"factorization_m f (c,fs)\" \n  and \"\\<And> d gs. factorization_m f (d,gs) \\<Longrightarrow> Mf (d,gs) = Mf (c,fs)\"\n  shows \"unique_factorization_m f (c,fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_factorization_m f (c, fs)", "unfolding unique_factorization_m_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. factorization_m f (c, fs) \\<and>\n    (\\<forall>dgs.\n        factorization_m f dgs \\<longrightarrow> Mf dgs = Mf (c, fs))", "by (intro conjI[OF assms(1)] allI impI, insert assms(2), auto)"], ["", "lemma unique_factorization_m_smult: assumes uf: \"unique_factorization_m f (c,fs)\"\n  and d: \"M (di * d) = 1\"\n  shows \"unique_factorization_m (smult d f) (c * d,fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_factorization_m (smult d f) (c * d, fs)", "proof (rule unique_factorization_mI[OF factorization_m_smult])"], ["proof (state)\ngoal (2 subgoals):\n 1. factorization_m f (c, fs)\n 2. \\<And>da gs.\n       factorization_m (smult d f) (da, gs) \\<Longrightarrow>\n       Mf (da, gs) = Mf (c * d, fs)", "show \"factorization_m f (c, fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. factorization_m f (c, fs)", "using uf[unfolded unique_factorization_m_alt_def]"], ["proof (prove)\nusing this:\n  factorization_m f (c, fs) \\<and>\n  (\\<forall>dgs.\n      factorization_m f dgs \\<longrightarrow> Mf dgs = Mf (c, fs))\n\ngoal (1 subgoal):\n 1. factorization_m f (c, fs)", "by auto"], ["proof (state)\nthis:\n  factorization_m f (c, fs)\n\ngoal (1 subgoal):\n 1. \\<And>da gs.\n       factorization_m (smult d f) (da, gs) \\<Longrightarrow>\n       Mf (da, gs) = Mf (c * d, fs)", "fix e gs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>da gs.\n       factorization_m (smult d f) (da, gs) \\<Longrightarrow>\n       Mf (da, gs) = Mf (c * d, fs)", "assume fact: \"factorization_m (smult d f) (e,gs)\""], ["proof (state)\nthis:\n  factorization_m (smult d f) (e, gs)\n\ngoal (1 subgoal):\n 1. \\<And>da gs.\n       factorization_m (smult d f) (da, gs) \\<Longrightarrow>\n       Mf (da, gs) = Mf (c * d, fs)", "from factorization_m_smult[OF this, of di]"], ["proof (chain)\npicking this:\n  factorization_m (smult di (smult d f)) (e * di, gs)", "have \"factorization_m (Mp (smult di (smult d f))) (e * di, gs)\""], ["proof (prove)\nusing this:\n  factorization_m (smult di (smult d f)) (e * di, gs)\n\ngoal (1 subgoal):\n 1. factorization_m (Mp (smult di (smult d f))) (e * di, gs)", "by simp"], ["proof (state)\nthis:\n  factorization_m (Mp (smult di (smult d f))) (e * di, gs)\n\ngoal (1 subgoal):\n 1. \\<And>da gs.\n       factorization_m (smult d f) (da, gs) \\<Longrightarrow>\n       Mf (da, gs) = Mf (c * d, fs)", "also"], ["proof (state)\nthis:\n  factorization_m (Mp (smult di (smult d f))) (e * di, gs)\n\ngoal (1 subgoal):\n 1. \\<And>da gs.\n       factorization_m (smult d f) (da, gs) \\<Longrightarrow>\n       Mf (da, gs) = Mf (c * d, fs)", "have \"Mp (smult di (smult d f)) = Mp (smult (M (di * d)) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult di (smult d f) =m smult (M (di * d)) f", "by simp"], ["proof (state)\nthis:\n  smult di (smult d f) =m smult (M (di * d)) f\n\ngoal (1 subgoal):\n 1. \\<And>da gs.\n       factorization_m (smult d f) (da, gs) \\<Longrightarrow>\n       Mf (da, gs) = Mf (c * d, fs)", "also"], ["proof (state)\nthis:\n  smult di (smult d f) =m smult (M (di * d)) f\n\ngoal (1 subgoal):\n 1. \\<And>da gs.\n       factorization_m (smult d f) (da, gs) \\<Longrightarrow>\n       Mf (da, gs) = Mf (c * d, fs)", "have \"\\<dots> = Mp f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (M (di * d)) f =m f", "unfolding d"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult 1 f =m f", "by simp"], ["proof (state)\nthis:\n  smult (M (di * d)) f =m f\n\ngoal (1 subgoal):\n 1. \\<And>da gs.\n       factorization_m (smult d f) (da, gs) \\<Longrightarrow>\n       Mf (da, gs) = Mf (c * d, fs)", "finally"], ["proof (chain)\npicking this:\n  factorization_m (Mp f) (e * di, gs)", "have fact: \"factorization_m f (e * di, gs)\""], ["proof (prove)\nusing this:\n  factorization_m (Mp f) (e * di, gs)\n\ngoal (1 subgoal):\n 1. factorization_m f (e * di, gs)", "by simp"], ["proof (state)\nthis:\n  factorization_m f (e * di, gs)\n\ngoal (1 subgoal):\n 1. \\<And>da gs.\n       factorization_m (smult d f) (da, gs) \\<Longrightarrow>\n       Mf (da, gs) = Mf (c * d, fs)", "with uf[unfolded unique_factorization_m_alt_def]"], ["proof (chain)\npicking this:\n  factorization_m f (c, fs) \\<and>\n  (\\<forall>dgs.\n      factorization_m f dgs \\<longrightarrow> Mf dgs = Mf (c, fs))\n  factorization_m f (e * di, gs)", "have eq: \"Mf (e * di, gs) = Mf (c, fs)\""], ["proof (prove)\nusing this:\n  factorization_m f (c, fs) \\<and>\n  (\\<forall>dgs.\n      factorization_m f dgs \\<longrightarrow> Mf dgs = Mf (c, fs))\n  factorization_m f (e * di, gs)\n\ngoal (1 subgoal):\n 1. Mf (e * di, gs) = Mf (c, fs)", "by blast"], ["proof (state)\nthis:\n  Mf (e * di, gs) = Mf (c, fs)\n\ngoal (1 subgoal):\n 1. \\<And>da gs.\n       factorization_m (smult d f) (da, gs) \\<Longrightarrow>\n       Mf (da, gs) = Mf (c * d, fs)", "from eq[unfolded Mf_def]"], ["proof (chain)\npicking this:\n  (case (e * di, gs) of (c, fs) \\<Rightarrow> (M c, image_mset Mp fs)) =\n  (case (c, fs) of (c, fs) \\<Rightarrow> (M c, image_mset Mp fs))", "have \"M (e * di) = M c\""], ["proof (prove)\nusing this:\n  (case (e * di, gs) of (c, fs) \\<Rightarrow> (M c, image_mset Mp fs)) =\n  (case (c, fs) of (c, fs) \\<Rightarrow> (M c, image_mset Mp fs))\n\ngoal (1 subgoal):\n 1. M (e * di) = M c", "by simp"], ["proof (state)\nthis:\n  M (e * di) = M c\n\ngoal (1 subgoal):\n 1. \\<And>da gs.\n       factorization_m (smult d f) (da, gs) \\<Longrightarrow>\n       Mf (da, gs) = Mf (c * d, fs)", "from arg_cong[OF this, of \"\\<lambda> x. M (x * d)\"]"], ["proof (chain)\npicking this:\n  M (M (e * di) * d) = M (M c * d)", "have \"M (e * M (di * d)) = M (c * d)\""], ["proof (prove)\nusing this:\n  M (M (e * di) * d) = M (M c * d)\n\ngoal (1 subgoal):\n 1. M (e * M (di * d)) = M (c * d)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  M (e * M (di * d)) = M (c * d)\n\ngoal (1 subgoal):\n 1. \\<And>da gs.\n       factorization_m (smult d f) (da, gs) \\<Longrightarrow>\n       Mf (da, gs) = Mf (c * d, fs)", "from this[unfolded d]"], ["proof (chain)\npicking this:\n  M (e * 1) = M (c * d)", "have e: \"M e = M (c * d)\""], ["proof (prove)\nusing this:\n  M (e * 1) = M (c * d)\n\ngoal (1 subgoal):\n 1. M e = M (c * d)", "by simp"], ["proof (state)\nthis:\n  M e = M (c * d)\n\ngoal (1 subgoal):\n 1. \\<And>da gs.\n       factorization_m (smult d f) (da, gs) \\<Longrightarrow>\n       Mf (da, gs) = Mf (c * d, fs)", "with eq"], ["proof (chain)\npicking this:\n  Mf (e * di, gs) = Mf (c, fs)\n  M e = M (c * d)", "show \"Mf (e,gs) = Mf (c * d, fs)\""], ["proof (prove)\nusing this:\n  Mf (e * di, gs) = Mf (c, fs)\n  M e = M (c * d)\n\ngoal (1 subgoal):\n 1. Mf (e, gs) = Mf (c * d, fs)", "unfolding Mf_def split"], ["proof (prove)\nusing this:\n  (M (e * di), image_mset Mp gs) = (M c, image_mset Mp fs)\n  M e = M (c * d)\n\ngoal (1 subgoal):\n 1. (M e, image_mset Mp gs) = (M (c * d), image_mset Mp fs)", "by simp"], ["proof (state)\nthis:\n  Mf (e, gs) = Mf (c * d, fs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unique_factorization_m_smultD: assumes uf: \"unique_factorization_m (smult d f) (c,fs)\"\n  and d: \"M (di * d) = 1\"\n  shows \"unique_factorization_m f (c * di,fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_factorization_m f (c * di, fs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unique_factorization_m f (c * di, fs)", "from d"], ["proof (chain)\npicking this:\n  M (di * d) = 1", "have d': \"M (d * di) = 1\""], ["proof (prove)\nusing this:\n  M (di * d) = 1\n\ngoal (1 subgoal):\n 1. M (d * di) = 1", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  M (d * di) = 1\n\ngoal (1 subgoal):\n 1. unique_factorization_m f (c * di, fs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_factorization_m f (c * di, fs)", "proof (rule unique_factorization_m_cong[OF unique_factorization_m_smult[OF uf d']], \n    rule poly_eqI, unfold Mp_coeff coeff_smult)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. M (di * (d * coeff f n)) = M (coeff f n)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. M (di * (d * coeff f n)) = M (coeff f n)", "have \"M (di * (d * coeff f n)) = M (M (di * d) * coeff f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M (di * (d * coeff f n)) = M (M (di * d) * coeff f n)", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  M (di * (d * coeff f n)) = M (M (di * d) * coeff f n)\n\ngoal (1 subgoal):\n 1. \\<And>n. M (di * (d * coeff f n)) = M (coeff f n)", "from this[unfolded d]"], ["proof (chain)\npicking this:\n  M (di * (d * coeff f n)) = M (1 * coeff f n)", "show \"M (di * (d * coeff f n)) = M (coeff f n)\""], ["proof (prove)\nusing this:\n  M (di * (d * coeff f n)) = M (1 * coeff f n)\n\ngoal (1 subgoal):\n 1. M (di * (d * coeff f n)) = M (coeff f n)", "by simp"], ["proof (state)\nthis:\n  M (di * (d * coeff f n)) = M (coeff f n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  unique_factorization_m f (c * di, fs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_m_eq_lead_coeff: \"degree_m f = degree f \\<Longrightarrow> lead_coeff (Mp f) = M (lead_coeff f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m f = degree f \\<Longrightarrow>\n    lead_coeff (Mp f) = M (lead_coeff f)", "by (simp add: Mp_coeff)"], ["", "lemma unique_factorization_m_zero: assumes \"unique_factorization_m f (c,fs)\" \n  shows \"M c \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M c \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "assume c: \"M c = 0\""], ["proof (state)\nthis:\n  M c = 0\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "from unique_factorization_m_imp_factorization[OF assms]"], ["proof (chain)\npicking this:\n  factorization_m f (c, fs)", "have \"Mp f = Mp (smult (M c) (prod_mset fs))\""], ["proof (prove)\nusing this:\n  factorization_m f (c, fs)\n\ngoal (1 subgoal):\n 1. f =m smult (M c) (\\<Prod>\\<^sub># fs)", "unfolding factorization_m_def split"], ["proof (prove)\nusing this:\n  f =m smult c (\\<Prod>\\<^sub># fs) \\<and>\n  (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n\ngoal (1 subgoal):\n 1. f =m smult (M c) (\\<Prod>\\<^sub># fs)", "by simp"], ["proof (state)\nthis:\n  f =m smult (M c) (\\<Prod>\\<^sub># fs)\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "from this[unfolded c]"], ["proof (chain)\npicking this:\n  f =m smult 0 (\\<Prod>\\<^sub># fs)", "have f: \"Mp f = 0\""], ["proof (prove)\nusing this:\n  f =m smult 0 (\\<Prod>\\<^sub># fs)\n\ngoal (1 subgoal):\n 1. Mp f = 0", "by simp"], ["proof (state)\nthis:\n  Mp f = 0\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "have \"factorization_m f (0,{#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. factorization_m f (0, {#})", "unfolding factorization_m_def split f"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = Mp (smult 0 (\\<Prod>\\<^sub># {#})) \\<and>\n    (\\<forall>f\\<in>#{#}. irreducible\\<^sub>d_m f \\<and> monic (Mp f))", "by auto"], ["proof (state)\nthis:\n  factorization_m f (0, {#})\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  factorization_m f (0, {#})\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "have \"Mf (0,{#}) = (0,{#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mf (0, {#}) = (0, {#})", "unfolding Mf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (0, {#}) of (c, fs) \\<Rightarrow> (M c, image_mset Mp fs)) =\n    (0, {#})", "by auto"], ["proof (state)\nthis:\n  Mf (0, {#}) = (0, {#})\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  factorization_m f (0, {#})\n  Mf (0, {#}) = (0, {#})", "have fact1: \"(0, {#}) \\<in> Mf ` Collect (factorization_m f)\""], ["proof (prove)\nusing this:\n  factorization_m f (0, {#})\n  Mf (0, {#}) = (0, {#})\n\ngoal (1 subgoal):\n 1. (0, {#}) \\<in> Mf ` Collect (factorization_m f)", "by force"], ["proof (state)\nthis:\n  (0, {#}) \\<in> Mf ` Collect (factorization_m f)\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "define g :: \"int poly\" where \"g = [:0,1:]\""], ["proof (state)\nthis:\n  g = [:0, 1:]\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "have mpg: \"Mp g = [:0,1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp g = [:0, 1:]", "unfolding Mp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly M g = [:0, 1:]", "by (auto simp: g_def)"], ["proof (state)\nthis:\n  Mp g = [:0, 1:]\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  Mp g = [:0, 1:]\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "fix g h"], ["proof (state)\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "assume *: \"degree (Mp g) = 0\" \"degree (Mp h) = 0\" \"[:0, 1:] = Mp (g * h)\""], ["proof (state)\nthis:\n  degree_m g = 0\n  degree_m h = 0\n  [:0, 1:] = Mp (g * h)\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "from arg_cong[OF *(3), of degree]"], ["proof (chain)\npicking this:\n  degree [:0, 1:] = degree_m (g * h)", "have \"1 = degree_m (Mp g * Mp h)\""], ["proof (prove)\nusing this:\n  degree [:0, 1:] = degree_m (g * h)\n\ngoal (1 subgoal):\n 1. 1 = degree_m (Mp g * Mp h)", "by simp"], ["proof (state)\nthis:\n  1 = degree_m (Mp g * Mp h)\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  1 = degree_m (Mp g * Mp h)\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "have \"\\<dots> \\<le> degree (Mp g * Mp h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m (Mp g * Mp h) \\<le> degree (Mp g * Mp h)", "by (rule degree_m_le)"], ["proof (state)\nthis:\n  degree_m (Mp g * Mp h) \\<le> degree (Mp g * Mp h)\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree_m (Mp g * Mp h) \\<le> degree (Mp g * Mp h)\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "have \"\\<dots> \\<le> degree (Mp g) + degree (Mp h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (Mp g * Mp h) \\<le> degree_m g + degree_m h", "by (rule degree_mult_le)"], ["proof (state)\nthis:\n  degree (Mp g * Mp h) \\<le> degree_m g + degree_m h\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree (Mp g * Mp h) \\<le> degree_m g + degree_m h\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "have \"\\<dots> \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m g + degree_m h \\<le> 0", "using *"], ["proof (prove)\nusing this:\n  degree_m g = 0\n  degree_m h = 0\n  [:0, 1:] = Mp (g * h)\n\ngoal (1 subgoal):\n 1. degree_m g + degree_m h \\<le> 0", "by simp"], ["proof (state)\nthis:\n  degree_m g + degree_m h \\<le> 0\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  1 \\<le> 0", "have False"], ["proof (prove)\nusing this:\n  1 \\<le> 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  \\<lbrakk>degree_m ?ga2 = 0; degree_m ?h2 = 0;\n   [:0, 1:] = Mp (?ga2 * ?h2)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "note irr = this"], ["proof (state)\nthis:\n  \\<lbrakk>degree_m ?ga2 = 0; degree_m ?h2 = 0;\n   [:0, 1:] = Mp (?ga2 * ?h2)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "have \"factorization_m f (0,{# g #})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. factorization_m f (0, {#g#})", "unfolding factorization_m_def split"], ["proof (prove)\ngoal (1 subgoal):\n 1. f =m smult 0 (\\<Prod>\\<^sub># {#g#}) \\<and>\n    (\\<forall>f\\<in>#{#g#}. irreducible\\<^sub>d_m f \\<and> monic (Mp f))", "using irr"], ["proof (prove)\nusing this:\n  \\<lbrakk>degree_m ?ga2 = 0; degree_m ?h2 = 0;\n   [:0, 1:] = Mp (?ga2 * ?h2)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. f =m smult 0 (\\<Prod>\\<^sub># {#g#}) \\<and>\n    (\\<forall>f\\<in>#{#g#}. irreducible\\<^sub>d_m f \\<and> monic (Mp f))", "by (auto simp: irreducible\\<^sub>d_m_def f mpg)"], ["proof (state)\nthis:\n  factorization_m f (0, {#g#})\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  factorization_m f (0, {#g#})\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "have \"Mf (0,{# g #}) = (0,{# g #})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mf (0, {#g#}) = (0, {#g#})", "unfolding Mf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (0, {#g#}) of (c, fs) \\<Rightarrow> (M c, image_mset Mp fs)) =\n    (0, {#g#})", "by (auto simp: mpg, simp add: g_def)"], ["proof (state)\nthis:\n  Mf (0, {#g#}) = (0, {#g#})\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  factorization_m f (0, {#g#})\n  Mf (0, {#g#}) = (0, {#g#})", "have fact2: \"(0, {#g#}) \\<in> Mf ` Collect (factorization_m f)\""], ["proof (prove)\nusing this:\n  factorization_m f (0, {#g#})\n  Mf (0, {#g#}) = (0, {#g#})\n\ngoal (1 subgoal):\n 1. (0, {#g#}) \\<in> Mf ` Collect (factorization_m f)", "by force"], ["proof (state)\nthis:\n  (0, {#g#}) \\<in> Mf ` Collect (factorization_m f)\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "note [simp] = assms[unfolded unique_factorization_m_def]"], ["proof (state)\nthis:\n  Mf ` Collect (factorization_m f) = {Mf (c, fs)}\n\ngoal (1 subgoal):\n 1. M c = 0 \\<Longrightarrow> False", "from fact1[simplified, folded fact2[simplified]]"], ["proof (chain)\npicking this:\n  (0, {#}) = (0, {#g#})", "show False"], ["proof (prove)\nusing this:\n  (0, {#}) = (0, {#g#})\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context poly_mod\nbegin"], ["", "lemma dvdm_smult: assumes \"f dvdm g\" \n  shows \"f dvdm smult c g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f dvdm smult c g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f dvdm smult c g", "from assms[unfolded dvdm_def]"], ["proof (chain)\npicking this:\n  \\<exists>h. g =m f * h", "obtain h where g: \"g =m f * h\""], ["proof (prove)\nusing this:\n  \\<exists>h. g =m f * h\n\ngoal (1 subgoal):\n 1. (\\<And>h. g =m f * h \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  g =m f * h\n\ngoal (1 subgoal):\n 1. f dvdm smult c g", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f dvdm smult c g", "unfolding dvdm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h. smult c g =m f * h", "proof (intro exI[of _ \"smult c h\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. smult c g =m f * smult c h", "have \"Mp (smult c g) = Mp (smult c (Mp g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult c g =m smult c (Mp g)", "by simp"], ["proof (state)\nthis:\n  smult c g =m smult c (Mp g)\n\ngoal (1 subgoal):\n 1. smult c g =m f * smult c h", "also"], ["proof (state)\nthis:\n  smult c g =m smult c (Mp g)\n\ngoal (1 subgoal):\n 1. smult c g =m f * smult c h", "have \"Mp g = Mp (f * h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g =m f * h", "using g"], ["proof (prove)\nusing this:\n  g =m f * h\n\ngoal (1 subgoal):\n 1. g =m f * h", "by simp"], ["proof (state)\nthis:\n  g =m f * h\n\ngoal (1 subgoal):\n 1. smult c g =m f * smult c h", "finally"], ["proof (chain)\npicking this:\n  smult c g =m smult c (Mp (f * h))", "show \"Mp (smult c g) = Mp (f * smult c h)\""], ["proof (prove)\nusing this:\n  smult c g =m smult c (Mp (f * h))\n\ngoal (1 subgoal):\n 1. smult c g =m f * smult c h", "by simp"], ["proof (state)\nthis:\n  smult c g =m f * smult c h\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f dvdm smult c g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dvdm_factor: assumes \"f dvdm g\" \n  shows \"f dvdm g * h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f dvdm g * h", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f dvdm g * h", "from assms[unfolded dvdm_def]"], ["proof (chain)\npicking this:\n  \\<exists>h. g =m f * h", "obtain k where g: \"g =m f * k\""], ["proof (prove)\nusing this:\n  \\<exists>h. g =m f * h\n\ngoal (1 subgoal):\n 1. (\\<And>k. g =m f * k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  g =m f * k\n\ngoal (1 subgoal):\n 1. f dvdm g * h", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f dvdm g * h", "unfolding dvdm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ha. g * h =m f * ha", "proof (intro exI[of _ \"h * k\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. g * h =m f * (h * k)", "have \"Mp (g * h) = Mp (Mp g * h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g * h =m Mp g * h", "by simp"], ["proof (state)\nthis:\n  g * h =m Mp g * h\n\ngoal (1 subgoal):\n 1. g * h =m f * (h * k)", "also"], ["proof (state)\nthis:\n  g * h =m Mp g * h\n\ngoal (1 subgoal):\n 1. g * h =m f * (h * k)", "have \"Mp g = Mp (f * k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g =m f * k", "using g"], ["proof (prove)\nusing this:\n  g =m f * k\n\ngoal (1 subgoal):\n 1. g =m f * k", "by simp"], ["proof (state)\nthis:\n  g =m f * k\n\ngoal (1 subgoal):\n 1. g * h =m f * (h * k)", "finally"], ["proof (chain)\npicking this:\n  g * h =m Mp (f * k) * h", "show \"Mp (g * h) = Mp (f * (h * k))\""], ["proof (prove)\nusing this:\n  g * h =m Mp (f * k) * h\n\ngoal (1 subgoal):\n 1. g * h =m f * (h * k)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  g * h =m f * (h * k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f dvdm g * h\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma square_free_m_smultD: assumes \"square_free_m (smult c f)\" \n  shows \"square_free_m f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free_m f", "unfolding square_free_m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp f \\<noteq> Mp 0 \\<and>\n    (\\<forall>g.\n        degree_m g \\<noteq> 0 \\<longrightarrow> \\<not> g * g dvdm f)", "proof (intro conjI allI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Mp f \\<noteq> Mp 0\n 2. \\<And>g. degree_m g \\<noteq> 0 \\<Longrightarrow> \\<not> g * g dvdm f", "fix g"], ["proof (state)\ngoal (2 subgoals):\n 1. Mp f \\<noteq> Mp 0\n 2. \\<And>g. degree_m g \\<noteq> 0 \\<Longrightarrow> \\<not> g * g dvdm f", "assume \"degree_m g \\<noteq> 0\""], ["proof (state)\nthis:\n  degree_m g \\<noteq> 0\n\ngoal (2 subgoals):\n 1. Mp f \\<noteq> Mp 0\n 2. \\<And>g. degree_m g \\<noteq> 0 \\<Longrightarrow> \\<not> g * g dvdm f", "with assms[unfolded square_free_m_def]"], ["proof (chain)\npicking this:\n  Mp (smult c f) \\<noteq> Mp 0 \\<and>\n  (\\<forall>g.\n      degree_m g \\<noteq> 0 \\<longrightarrow> \\<not> g * g dvdm smult c f)\n  degree_m g \\<noteq> 0", "have \"\\<not> g * g dvdm smult c f\""], ["proof (prove)\nusing this:\n  Mp (smult c f) \\<noteq> Mp 0 \\<and>\n  (\\<forall>g.\n      degree_m g \\<noteq> 0 \\<longrightarrow> \\<not> g * g dvdm smult c f)\n  degree_m g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> g * g dvdm smult c f", "by auto"], ["proof (state)\nthis:\n  \\<not> g * g dvdm smult c f\n\ngoal (2 subgoals):\n 1. Mp f \\<noteq> Mp 0\n 2. \\<And>g. degree_m g \\<noteq> 0 \\<Longrightarrow> \\<not> g * g dvdm f", "thus \"\\<not> g * g dvdm f\""], ["proof (prove)\nusing this:\n  \\<not> g * g dvdm smult c f\n\ngoal (1 subgoal):\n 1. \\<not> g * g dvdm f", "using dvdm_smult[of \"g * g\" f c]"], ["proof (prove)\nusing this:\n  \\<not> g * g dvdm smult c f\n  g * g dvdm f \\<Longrightarrow> g * g dvdm smult c f\n\ngoal (1 subgoal):\n 1. \\<not> g * g dvdm f", "by blast"], ["proof (state)\nthis:\n  \\<not> g * g dvdm f\n\ngoal (1 subgoal):\n 1. Mp f \\<noteq> Mp 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Mp f \\<noteq> Mp 0", "from assms[unfolded square_free_m_def]"], ["proof (chain)\npicking this:\n  Mp (smult c f) \\<noteq> Mp 0 \\<and>\n  (\\<forall>g.\n      degree_m g \\<noteq> 0 \\<longrightarrow> \\<not> g * g dvdm smult c f)", "have \"\\<not> smult c f =m 0\""], ["proof (prove)\nusing this:\n  Mp (smult c f) \\<noteq> Mp 0 \\<and>\n  (\\<forall>g.\n      degree_m g \\<noteq> 0 \\<longrightarrow> \\<not> g * g dvdm smult c f)\n\ngoal (1 subgoal):\n 1. Mp (smult c f) \\<noteq> Mp 0", "by simp"], ["proof (state)\nthis:\n  Mp (smult c f) \\<noteq> Mp 0\n\ngoal (1 subgoal):\n 1. Mp f \\<noteq> Mp 0", "thus \"\\<not> f =m 0\""], ["proof (prove)\nusing this:\n  Mp (smult c f) \\<noteq> Mp 0\n\ngoal (1 subgoal):\n 1. Mp f \\<noteq> Mp 0", "by (metis Mp_smult(2) smult_0_right)"], ["proof (state)\nthis:\n  Mp f \\<noteq> Mp 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma square_free_m_smultI: assumes sf: \"square_free_m f\" \n  and inv: \"M (ci * c) = 1\" \n  shows \"square_free_m (smult c f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free_m (smult c f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. square_free_m (smult c f)", "have \"square_free_m (smult ci (smult c f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free_m (smult ci (smult c f))", "proof (rule square_free_m_cong[OF sf], rule poly_eqI, unfold Mp_coeff coeff_smult)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. M (coeff f n) = M (ci * (c * coeff f n))", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. M (coeff f n) = M (ci * (c * coeff f n))", "have \"M (ci * (c * coeff f n)) = M ( M (ci * c) * coeff f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M (ci * (c * coeff f n)) = M (M (ci * c) * coeff f n)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  M (ci * (c * coeff f n)) = M (M (ci * c) * coeff f n)\n\ngoal (1 subgoal):\n 1. \\<And>n. M (coeff f n) = M (ci * (c * coeff f n))", "from this[unfolded inv]"], ["proof (chain)\npicking this:\n  M (ci * (c * coeff f n)) = M (1 * coeff f n)", "show \"M (coeff f n) = M (ci * (c * coeff f n))\""], ["proof (prove)\nusing this:\n  M (ci * (c * coeff f n)) = M (1 * coeff f n)\n\ngoal (1 subgoal):\n 1. M (coeff f n) = M (ci * (c * coeff f n))", "by simp"], ["proof (state)\nthis:\n  M (coeff f n) = M (ci * (c * coeff f n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  square_free_m (smult ci (smult c f))\n\ngoal (1 subgoal):\n 1. square_free_m (smult c f)", "from square_free_m_smultD[OF this]"], ["proof (chain)\npicking this:\n  square_free_m (smult c f)", "show ?thesis"], ["proof (prove)\nusing this:\n  square_free_m (smult c f)\n\ngoal (1 subgoal):\n 1. square_free_m (smult c f)", "."], ["proof (state)\nthis:\n  square_free_m (smult c f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma square_free_m_factor: assumes \"square_free_m (f * g)\" \n  shows \"square_free_m f\" \"square_free_m g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free_m f &&& square_free_m g", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. square_free_m f\n 2. square_free_m g", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. square_free_m f\n 2. square_free_m g", "fix f g"], ["proof (state)\ngoal (2 subgoals):\n 1. square_free_m f\n 2. square_free_m g", "assume sf: \"square_free_m (f * g)\""], ["proof (state)\nthis:\n  square_free_m (f * g)\n\ngoal (2 subgoals):\n 1. square_free_m f\n 2. square_free_m g", "have \"square_free_m f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free_m f", "unfolding square_free_m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp f \\<noteq> Mp 0 \\<and>\n    (\\<forall>g.\n        degree_m g \\<noteq> 0 \\<longrightarrow> \\<not> g * g dvdm f)", "proof (intro conjI allI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Mp f \\<noteq> Mp 0\n 2. \\<And>g. degree_m g \\<noteq> 0 \\<Longrightarrow> \\<not> g * g dvdm f", "fix h"], ["proof (state)\ngoal (2 subgoals):\n 1. Mp f \\<noteq> Mp 0\n 2. \\<And>g. degree_m g \\<noteq> 0 \\<Longrightarrow> \\<not> g * g dvdm f", "assume \"degree_m h \\<noteq> 0\""], ["proof (state)\nthis:\n  degree_m h \\<noteq> 0\n\ngoal (2 subgoals):\n 1. Mp f \\<noteq> Mp 0\n 2. \\<And>g. degree_m g \\<noteq> 0 \\<Longrightarrow> \\<not> g * g dvdm f", "with sf[unfolded square_free_m_def]"], ["proof (chain)\npicking this:\n  Mp (f * g) \\<noteq> Mp 0 \\<and>\n  (\\<forall>g.\n      degree_m g \\<noteq> 0 \\<longrightarrow> \\<not> g * g dvdm f * g)\n  degree_m h \\<noteq> 0", "have \"\\<not> h * h dvdm f * g\""], ["proof (prove)\nusing this:\n  Mp (f * g) \\<noteq> Mp 0 \\<and>\n  (\\<forall>g.\n      degree_m g \\<noteq> 0 \\<longrightarrow> \\<not> g * g dvdm f * g)\n  degree_m h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> h * h dvdm f * g", "by auto"], ["proof (state)\nthis:\n  \\<not> h * h dvdm f * g\n\ngoal (2 subgoals):\n 1. Mp f \\<noteq> Mp 0\n 2. \\<And>g. degree_m g \\<noteq> 0 \\<Longrightarrow> \\<not> g * g dvdm f", "thus \"\\<not> h * h dvdm f\""], ["proof (prove)\nusing this:\n  \\<not> h * h dvdm f * g\n\ngoal (1 subgoal):\n 1. \\<not> h * h dvdm f", "using dvdm_factor[of \"h * h\" f g]"], ["proof (prove)\nusing this:\n  \\<not> h * h dvdm f * g\n  h * h dvdm f \\<Longrightarrow> h * h dvdm f * g\n\ngoal (1 subgoal):\n 1. \\<not> h * h dvdm f", "by blast"], ["proof (state)\nthis:\n  \\<not> h * h dvdm f\n\ngoal (1 subgoal):\n 1. Mp f \\<noteq> Mp 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Mp f \\<noteq> Mp 0", "from sf[unfolded square_free_m_def]"], ["proof (chain)\npicking this:\n  Mp (f * g) \\<noteq> Mp 0 \\<and>\n  (\\<forall>g.\n      degree_m g \\<noteq> 0 \\<longrightarrow> \\<not> g * g dvdm f * g)", "have \"\\<not> f * g =m 0\""], ["proof (prove)\nusing this:\n  Mp (f * g) \\<noteq> Mp 0 \\<and>\n  (\\<forall>g.\n      degree_m g \\<noteq> 0 \\<longrightarrow> \\<not> g * g dvdm f * g)\n\ngoal (1 subgoal):\n 1. Mp (f * g) \\<noteq> Mp 0", "by simp"], ["proof (state)\nthis:\n  Mp (f * g) \\<noteq> Mp 0\n\ngoal (1 subgoal):\n 1. Mp f \\<noteq> Mp 0", "thus \"\\<not> f =m 0\""], ["proof (prove)\nusing this:\n  Mp (f * g) \\<noteq> Mp 0\n\ngoal (1 subgoal):\n 1. Mp f \\<noteq> Mp 0", "by (metis mult.commute mult_zero_right poly_mod.mult_Mp(2))"], ["proof (state)\nthis:\n  Mp f \\<noteq> Mp 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  square_free_m f\n\ngoal (2 subgoals):\n 1. square_free_m f\n 2. square_free_m g", "}"], ["proof (state)\nthis:\n  square_free_m (?fa2 * ?ga2) \\<Longrightarrow> square_free_m ?fa2\n\ngoal (2 subgoals):\n 1. square_free_m f\n 2. square_free_m g", "from this[of f g] this[of g f] assms"], ["proof (chain)\npicking this:\n  square_free_m (f * g) \\<Longrightarrow> square_free_m f\n  square_free_m (g * f) \\<Longrightarrow> square_free_m g\n  square_free_m (f * g)", "show \"square_free_m f\" \"square_free_m g\""], ["proof (prove)\nusing this:\n  square_free_m (f * g) \\<Longrightarrow> square_free_m f\n  square_free_m (g * f) \\<Longrightarrow> square_free_m g\n  square_free_m (f * g)\n\ngoal (1 subgoal):\n 1. square_free_m f &&& square_free_m g", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  square_free_m f\n  square_free_m g\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context poly_mod_2\nbegin"], ["", "lemma Mp_ident_iff: \"Mp f = f \\<longleftrightarrow> (\\<forall> n. coeff f n \\<in> {0 ..< m})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mp f = f) = (\\<forall>n. coeff f n \\<in> {0..<m})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (Mp f = f) = (\\<forall>n. coeff f n \\<in> {0..<m})", "have m0: \"m > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m", "using m1"], ["proof (prove)\nusing this:\n  1 < m\n\ngoal (1 subgoal):\n 1. 0 < m", "by simp"], ["proof (state)\nthis:\n  0 < m\n\ngoal (1 subgoal):\n 1. (Mp f = f) = (\\<forall>n. coeff f n \\<in> {0..<m})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mp f = f) = (\\<forall>n. coeff f n \\<in> {0..<m})", "unfolding poly_eq_iff Mp_coeff M_def mod_ident_iff[OF m0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>n. coeff f n \\<in> {0..<m}) =\n    (\\<forall>n. coeff f n \\<in> {0..<m})", "by simp"], ["proof (state)\nthis:\n  (Mp f = f) = (\\<forall>n. coeff f n \\<in> {0..<m})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Mp_ident_iff': \"Mp f = f \\<longleftrightarrow> (set (coeffs f) \\<subseteq> {0 ..< m})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mp f = f) = (set (coeffs f) \\<subseteq> {0..<m})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (Mp f = f) = (set (coeffs f) \\<subseteq> {0..<m})", "have 0: \"0 \\<in> {0 ..< m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> {0..<m}", "using m1"], ["proof (prove)\nusing this:\n  1 < m\n\ngoal (1 subgoal):\n 1. 0 \\<in> {0..<m}", "by auto"], ["proof (state)\nthis:\n  0 \\<in> {0..<m}\n\ngoal (1 subgoal):\n 1. (Mp f = f) = (set (coeffs f) \\<subseteq> {0..<m})", "have ran: \"(\\<forall>n. coeff f n \\<in> {0..<m}) \\<longleftrightarrow> range (coeff f) \\<subseteq> {0 ..< m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>n. coeff f n \\<in> {0..<m}) =\n    (range (coeff f) \\<subseteq> {0..<m})", "by blast"], ["proof (state)\nthis:\n  (\\<forall>n. coeff f n \\<in> {0..<m}) =\n  (range (coeff f) \\<subseteq> {0..<m})\n\ngoal (1 subgoal):\n 1. (Mp f = f) = (set (coeffs f) \\<subseteq> {0..<m})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mp f = f) = (set (coeffs f) \\<subseteq> {0..<m})", "unfolding Mp_ident_iff ran"], ["proof (prove)\ngoal (1 subgoal):\n 1. (range (coeff f) \\<subseteq> {0..<m}) =\n    (set (coeffs f) \\<subseteq> {0..<m})", "using range_coeff[of f] 0"], ["proof (prove)\nusing this:\n  range (coeff f) = insert 0 (set (coeffs f))\n  0 \\<in> {0..<m}\n\ngoal (1 subgoal):\n 1. (range (coeff f) \\<subseteq> {0..<m}) =\n    (set (coeffs f) \\<subseteq> {0..<m})", "by auto"], ["proof (state)\nthis:\n  (Mp f = f) = (set (coeffs f) \\<subseteq> {0..<m})\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma Mp_Mp_pow_is_Mp: \"n \\<noteq> 0 \\<Longrightarrow> p > 1 \\<Longrightarrow> poly_mod.Mp p (poly_mod.Mp (p^n) f) \n  = poly_mod.Mp p f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> 0; 1 < p\\<rbrakk>\n    \\<Longrightarrow> poly_mod.Mp p (poly_mod.Mp (p ^ n) f) =\n                      poly_mod.Mp p f", "using  poly_mod_2.Mp_product_modulus poly_mod_2_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>poly_mod_2 ?m; ?m' = ?m * ?k; 0 < ?k\\<rbrakk>\n  \\<Longrightarrow> poly_mod.Mp ?m (poly_mod.Mp ?m' ?f) = poly_mod.Mp ?m ?f\n  poly_mod_2 ?m \\<equiv> 1 < ?m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> 0; 1 < p\\<rbrakk>\n    \\<Longrightarrow> poly_mod.Mp p (poly_mod.Mp (p ^ n) f) =\n                      poly_mod.Mp p f", "by(subst power_eq_if, auto)"], ["", "lemma M_M_pow_is_M: \"n \\<noteq> 0 \\<Longrightarrow> p > 1 \\<Longrightarrow> poly_mod.M p (poly_mod.M (p^n) f) \n  = poly_mod.M p f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> 0; 1 < p\\<rbrakk>\n    \\<Longrightarrow> poly_mod.M p (poly_mod.M (p ^ n) f) = poly_mod.M p f", "using Mp_Mp_pow_is_Mp[of n p \"[:f:]\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<noteq> 0; 1 < p\\<rbrakk>\n  \\<Longrightarrow> poly_mod.Mp p (poly_mod.Mp (p ^ n) [:f:]) =\n                    poly_mod.Mp p [:f:]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> 0; 1 < p\\<rbrakk>\n    \\<Longrightarrow> poly_mod.M p (poly_mod.M (p ^ n) f) = poly_mod.M p f", "by (metis coeff_pCons_0 poly_mod.Mp_coeff)"], ["", "definition inverse_mod :: \"int \\<Rightarrow> int \\<Rightarrow> int\" where\n  \"inverse_mod x m = fst (bezout_coefficients x m)\""], ["", "lemma inverse_mod:\n  \"(inverse_mod x m * x) mod m = 1\"\n  if \"coprime x m\" \"m > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_mod x m * x mod m = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inverse_mod x m * x mod m = 1", "from bezout_coefficients [of x m \"inverse_mod x m\" \"snd (bezout_coefficients x m)\"]"], ["proof (chain)\npicking this:\n  bezout_coefficients x m =\n  (inverse_mod x m, snd (bezout_coefficients x m)) \\<Longrightarrow>\n  inverse_mod x m * x + snd (bezout_coefficients x m) * m = gcd x m", "have \"inverse_mod x m * x + snd (bezout_coefficients x m) * m = gcd x m\""], ["proof (prove)\nusing this:\n  bezout_coefficients x m =\n  (inverse_mod x m, snd (bezout_coefficients x m)) \\<Longrightarrow>\n  inverse_mod x m * x + snd (bezout_coefficients x m) * m = gcd x m\n\ngoal (1 subgoal):\n 1. inverse_mod x m * x + snd (bezout_coefficients x m) * m = gcd x m", "by (simp add: inverse_mod_def)"], ["proof (state)\nthis:\n  inverse_mod x m * x + snd (bezout_coefficients x m) * m = gcd x m\n\ngoal (1 subgoal):\n 1. inverse_mod x m * x mod m = 1", "with that"], ["proof (chain)\npicking this:\n  comm_monoid_mult_class.coprime x m\n  1 < m\n  inverse_mod x m * x + snd (bezout_coefficients x m) * m = gcd x m", "have \"inverse_mod x m * x + snd (bezout_coefficients x m) * m = 1\""], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime x m\n  1 < m\n  inverse_mod x m * x + snd (bezout_coefficients x m) * m = gcd x m\n\ngoal (1 subgoal):\n 1. inverse_mod x m * x + snd (bezout_coefficients x m) * m = 1", "by simp"], ["proof (state)\nthis:\n  inverse_mod x m * x + snd (bezout_coefficients x m) * m = 1\n\ngoal (1 subgoal):\n 1. inverse_mod x m * x mod m = 1", "then"], ["proof (chain)\npicking this:\n  inverse_mod x m * x + snd (bezout_coefficients x m) * m = 1", "have \"(inverse_mod x m * x + snd (bezout_coefficients x m) * m) mod m = 1 mod m\""], ["proof (prove)\nusing this:\n  inverse_mod x m * x + snd (bezout_coefficients x m) * m = 1\n\ngoal (1 subgoal):\n 1. (inverse_mod x m * x + snd (bezout_coefficients x m) * m) mod m =\n    1 mod m", "by simp"], ["proof (state)\nthis:\n  (inverse_mod x m * x + snd (bezout_coefficients x m) * m) mod m = 1 mod m\n\ngoal (1 subgoal):\n 1. inverse_mod x m * x mod m = 1", "with \\<open>m > 1\\<close>"], ["proof (chain)\npicking this:\n  1 < m\n  (inverse_mod x m * x + snd (bezout_coefficients x m) * m) mod m = 1 mod m", "show ?thesis"], ["proof (prove)\nusing this:\n  1 < m\n  (inverse_mod x m * x + snd (bezout_coefficients x m) * m) mod m = 1 mod m\n\ngoal (1 subgoal):\n 1. inverse_mod x m * x mod m = 1", "by simp"], ["proof (state)\nthis:\n  inverse_mod x m * x mod m = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inverse_mod_pow:\n  \"(inverse_mod x (p ^ n) * x) mod (p ^ n) = 1\"\n  if \"coprime x p\" \"p > 1\" \"n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_mod x (p ^ n) * x mod p ^ n = 1", "using that"], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime x p\n  1 < p\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. inverse_mod x (p ^ n) * x mod p ^ n = 1", "by (auto intro: inverse_mod)"], ["", "lemma (in poly_mod) inverse_mod_coprime:\n  assumes p: \"prime m\" \n  and cop: \"coprime x m\" shows \"M (inverse_mod x m * x) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M (inverse_mod x m * x) = 1", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_mod x m * x mod m = 1", "using inverse_mod_pow[OF cop, of 1] p"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 < m; 1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> inverse_mod x (m ^ 1) * x mod m ^ 1 = 1\n  prime m\n\ngoal (1 subgoal):\n 1. inverse_mod x m * x mod m = 1", "by (auto simp: prime_int_iff)"], ["", "lemma (in poly_mod) inverse_mod_coprime_exp:\n  assumes m: \"m = p^n\" and p: \"prime p\" \n  and n: \"n \\<noteq> 0\" and cop: \"coprime x p\"\n  shows \"M (inverse_mod x m * x) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M (inverse_mod x m * x) = 1", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_mod x m * x mod m = 1", "unfolding m"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_mod x (p ^ n) * x mod p ^ n = 1", "using inverse_mod_pow[OF cop _ n] p"], ["proof (prove)\nusing this:\n  1 < p \\<Longrightarrow> inverse_mod x (p ^ n) * x mod p ^ n = 1\n  prime p\n\ngoal (1 subgoal):\n 1. inverse_mod x (p ^ n) * x mod p ^ n = 1", "by (auto simp: prime_int_iff)"], ["", "locale poly_mod_prime = poly_mod p for p :: int +\n  assumes prime: \"prime p\" \nbegin"], ["", "sublocale poly_mod_2 p"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_2 p", "using prime"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. poly_mod_2 p", "unfolding poly_mod_2_def"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. 1 < p", "using prime_gt_1_int"], ["proof (prove)\nusing this:\n  prime p\n  prime ?p \\<Longrightarrow> 1 < ?p\n\ngoal (1 subgoal):\n 1. 1 < p", "by force"], ["", "lemma square_free_m_prod_imp_coprime_m: assumes sf: \"square_free_m (A * B)\" \n  shows \"coprime_m A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime_m A B", "unfolding coprime_m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h.\n       h dvdm A \\<longrightarrow> h dvdm B \\<longrightarrow> h dvdm 1", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "fix h"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "assume dvd: \"h dvdm A\" \"h dvdm B\""], ["proof (state)\nthis:\n  h dvdm A\n  h dvdm B\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "then"], ["proof (chain)\npicking this:\n  h dvdm A\n  h dvdm B", "obtain ha hb where *: \"Mp A = Mp (h * ha)\" \"Mp B = Mp (h * hb)\""], ["proof (prove)\nusing this:\n  h dvdm A\n  h dvdm B\n\ngoal (1 subgoal):\n 1. (\\<And>ha hb.\n        \\<lbrakk>A =m h * ha; B =m h * hb\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvdm_def"], ["proof (prove)\nusing this:\n  \\<exists>ha. A =m h * ha\n  \\<exists>ha. B =m h * ha\n\ngoal (1 subgoal):\n 1. (\\<And>ha hb.\n        \\<lbrakk>A =m h * ha; B =m h * hb\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A =m h * ha\n  B =m h * hb\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "have AB: \"Mp (A * B) = Mp (Mp A * Mp B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * B =m Mp A * Mp B", "by simp"], ["proof (state)\nthis:\n  A * B =m Mp A * Mp B\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "from this[unfolded *, simplified]"], ["proof (chain)\npicking this:\n  A * B =m h * ha * (h * hb)", "have eq: \"Mp (A * B) = Mp (h * h * (ha * hb))\""], ["proof (prove)\nusing this:\n  A * B =m h * ha * (h * hb)\n\ngoal (1 subgoal):\n 1. A * B =m h * h * (ha * hb)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  A * B =m h * h * (ha * hb)\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "hence dvd_hh: \"(h * h) dvdm (A * B)\""], ["proof (prove)\nusing this:\n  A * B =m h * h * (ha * hb)\n\ngoal (1 subgoal):\n 1. h * h dvdm A * B", "unfolding dvdm_def"], ["proof (prove)\nusing this:\n  A * B =m h * h * (ha * hb)\n\ngoal (1 subgoal):\n 1. \\<exists>ha. A * B =m h * h * ha", "by auto"], ["proof (state)\nthis:\n  h * h dvdm A * B\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "{"], ["proof (state)\nthis:\n  h * h dvdm A * B\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "assume \"degree_m h \\<noteq> 0\""], ["proof (state)\nthis:\n  degree_m h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "from sf[unfolded square_free_m_def, THEN conjunct2, rule_format, OF this]"], ["proof (chain)\npicking this:\n  \\<not> h * h dvdm A * B", "have \"\\<not> h * h dvdm A * B\""], ["proof (prove)\nusing this:\n  \\<not> h * h dvdm A * B\n\ngoal (1 subgoal):\n 1. \\<not> h * h dvdm A * B", "."], ["proof (state)\nthis:\n  \\<not> h * h dvdm A * B\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "with dvd_hh"], ["proof (chain)\npicking this:\n  h * h dvdm A * B\n  \\<not> h * h dvdm A * B", "have False"], ["proof (prove)\nusing this:\n  h * h dvdm A * B\n  \\<not> h * h dvdm A * B\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "}"], ["proof (state)\nthis:\n  degree_m h \\<noteq> 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "hence \"degree (Mp h) = 0\""], ["proof (prove)\nusing this:\n  degree_m h \\<noteq> 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. degree_m h = 0", "by auto"], ["proof (state)\nthis:\n  degree_m h = 0\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "then"], ["proof (chain)\npicking this:\n  degree_m h = 0", "obtain c where hc: \"Mp h = [: c :]\""], ["proof (prove)\nusing this:\n  degree_m h = 0\n\ngoal (1 subgoal):\n 1. (\\<And>c. Mp h = [:c:] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule degree_eq_zeroE)"], ["proof (state)\nthis:\n  Mp h = [:c:]\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "{"], ["proof (state)\nthis:\n  Mp h = [:c:]\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "assume \"c = 0\""], ["proof (state)\nthis:\n  c = 0\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "hence \"Mp h = 0\""], ["proof (prove)\nusing this:\n  c = 0\n\ngoal (1 subgoal):\n 1. Mp h = 0", "unfolding hc"], ["proof (prove)\nusing this:\n  c = 0\n\ngoal (1 subgoal):\n 1. [:c:] = 0", "by auto"], ["proof (state)\nthis:\n  Mp h = 0\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "with *(1)"], ["proof (chain)\npicking this:\n  A =m h * ha\n  Mp h = 0", "have \"Mp A = 0\""], ["proof (prove)\nusing this:\n  A =m h * ha\n  Mp h = 0\n\ngoal (1 subgoal):\n 1. Mp A = 0", "by (metis Mp_0 mult_zero_left poly_mod.mult_Mp(1))"], ["proof (state)\nthis:\n  Mp A = 0\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "with sf[unfolded square_free_m_def, THEN conjunct1]"], ["proof (chain)\npicking this:\n  Mp (A * B) \\<noteq> Mp 0\n  Mp A = 0", "have False"], ["proof (prove)\nusing this:\n  Mp (A * B) \\<noteq> Mp 0\n  Mp A = 0\n\ngoal (1 subgoal):\n 1. False", "by (simp add: AB)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "}"], ["proof (state)\nthis:\n  c = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "hence c0: \"c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  c = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "with arg_cong[OF hc[symmetric], of \"\\<lambda> f. coeff f 0\", unfolded Mp_coeff M_def] m1"], ["proof (chain)\npicking this:\n  coeff [:c:] 0 = coeff h 0 mod p\n  1 < p\n  c \\<noteq> 0", "have \"c \\<ge> 0\" \"c < p\""], ["proof (prove)\nusing this:\n  coeff [:c:] 0 = coeff h 0 mod p\n  1 < p\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> c &&& c < p", "by auto"], ["proof (state)\nthis:\n  0 \\<le> c\n  c < p\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "with c0"], ["proof (chain)\npicking this:\n  c \\<noteq> 0\n  0 \\<le> c\n  c < p", "have c_props:\"c > 0\" \"c < p\""], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  0 \\<le> c\n  c < p\n\ngoal (1 subgoal):\n 1. 0 < c &&& c < p", "by auto"], ["proof (state)\nthis:\n  0 < c\n  c < p\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "with prime"], ["proof (chain)\npicking this:\n  prime p\n  0 < c\n  c < p", "have \"prime p\""], ["proof (prove)\nusing this:\n  prime p\n  0 < c\n  c < p\n\ngoal (1 subgoal):\n 1. prime p", "by simp"], ["proof (state)\nthis:\n  prime p\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "with c_props"], ["proof (chain)\npicking this:\n  0 < c\n  c < p\n  prime p", "have \"coprime p c\""], ["proof (prove)\nusing this:\n  0 < c\n  c < p\n  prime p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime p c", "by (auto intro: prime_imp_coprime dest: zdvd_not_zless)"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime p c\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "then"], ["proof (chain)\npicking this:\n  comm_monoid_mult_class.coprime p c", "have \"coprime c p\""], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime p c\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime c p", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime c p\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "from inverse_mod_coprime[OF prime this]"], ["proof (chain)\npicking this:\n  M (inverse_mod c p * c) = 1", "obtain d where d: \"M (c * d) = 1\""], ["proof (prove)\nusing this:\n  M (inverse_mod c p * c) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>d. M (c * d) = 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  M (c * d) = 1\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm A; h dvdm B\\<rbrakk> \\<Longrightarrow> h dvdm 1", "show \"h dvdm 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h dvdm 1", "unfolding dvdm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ha. 1 =m h * ha", "proof (intro exI[of _ \"[:d:]\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 =m h * [:d:]", "have \"Mp (h * [: d :]) = Mp (Mp h * [: d :])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h * [:d:] =m Mp h * [:d:]", "by simp"], ["proof (state)\nthis:\n  h * [:d:] =m Mp h * [:d:]\n\ngoal (1 subgoal):\n 1. 1 =m h * [:d:]", "also"], ["proof (state)\nthis:\n  h * [:d:] =m Mp h * [:d:]\n\ngoal (1 subgoal):\n 1. 1 =m h * [:d:]", "have \"\\<dots> = Mp ([: c * d :])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp h * [:d:] =m [:c * d:]", "unfolding hc"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:c:] * [:d:] =m [:c * d:]", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  Mp h * [:d:] =m [:c * d:]\n\ngoal (1 subgoal):\n 1. 1 =m h * [:d:]", "also"], ["proof (state)\nthis:\n  Mp h * [:d:] =m [:c * d:]\n\ngoal (1 subgoal):\n 1. 1 =m h * [:d:]", "have \"\\<dots> = [: M (c * d) :]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp [:c * d:] = [:M (c * d):]", "unfolding Mp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly M [:c * d:] = [:M (c * d):]", "by (metis (no_types) M_0 map_poly_pCons Mp_0 Mp_def d zero_neq_one)"], ["proof (state)\nthis:\n  Mp [:c * d:] = [:M (c * d):]\n\ngoal (1 subgoal):\n 1. 1 =m h * [:d:]", "also"], ["proof (state)\nthis:\n  Mp [:c * d:] = [:M (c * d):]\n\ngoal (1 subgoal):\n 1. 1 =m h * [:d:]", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:M (c * d):] = 1", "unfolding d"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:1:] = 1", "by simp"], ["proof (state)\nthis:\n  [:M (c * d):] = 1\n\ngoal (1 subgoal):\n 1. 1 =m h * [:d:]", "finally"], ["proof (chain)\npicking this:\n  Mp (h * [:d:]) = 1", "show \"Mp 1 = Mp (h * [:d:])\""], ["proof (prove)\nusing this:\n  Mp (h * [:d:]) = 1\n\ngoal (1 subgoal):\n 1. 1 =m h * [:d:]", "by simp"], ["proof (state)\nthis:\n  1 =m h * [:d:]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h dvdm 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coprime_exp_mod: \"coprime lu p \\<Longrightarrow> n \\<noteq> 0 \\<Longrightarrow> lu mod p ^ n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>comm_monoid_mult_class.coprime lu p; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> lu mod p ^ n \\<noteq> 0", "using prime"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>comm_monoid_mult_class.coprime lu p; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> lu mod p ^ n \\<noteq> 0", "by fastforce"], ["", "end"], ["", "context poly_mod\nbegin"], ["", "definition Dp :: \"int poly \\<Rightarrow> int poly\" where\n  \"Dp f = map_poly (\\<lambda> a. a div m) f\""], ["", "lemma Dp_Mp_eq: \"f = Mp f + smult m (Dp f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = Mp f + smult m (Dp f)", "by (rule poly_eqI, auto simp: Mp_coeff M_def Dp_def coeff_map_poly)"], ["", "lemma dvd_imp_dvdm:\n  assumes \"a dvd b\" shows \"a dvdm b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a dvdm b", "by (metis assms dvd_def dvdm_def)"], ["", "lemma dvdm_add:\n  assumes a: \"u dvdm a\"\n  and b: \"u dvdm b\"\n  shows \"u dvdm (a+b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u dvdm a + b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u dvdm a + b", "obtain a' where a: \"a =m u*a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a'. a =m u * a' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using a"], ["proof (prove)\nusing this:\n  u dvdm a\n\ngoal (1 subgoal):\n 1. (\\<And>a'. a =m u * a' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvdm_def"], ["proof (prove)\nusing this:\n  \\<exists>h. a =m u * h\n\ngoal (1 subgoal):\n 1. (\\<And>a'. a =m u * a' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a =m u * a'\n\ngoal (1 subgoal):\n 1. u dvdm a + b", "obtain b' where b: \"b =m u*b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b'. b =m u * b' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b"], ["proof (prove)\nusing this:\n  u dvdm b\n\ngoal (1 subgoal):\n 1. (\\<And>b'. b =m u * b' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvdm_def"], ["proof (prove)\nusing this:\n  \\<exists>h. b =m u * h\n\ngoal (1 subgoal):\n 1. (\\<And>b'. b =m u * b' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b =m u * b'\n\ngoal (1 subgoal):\n 1. u dvdm a + b", "have \"Mp (a + b) = Mp (u*a'+u*b')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b =m u * a' + u * b'", "using a b"], ["proof (prove)\nusing this:\n  a =m u * a'\n  b =m u * b'\n\ngoal (1 subgoal):\n 1. a + b =m u * a' + u * b'", "by (metis poly_mod.plus_Mp(1) poly_mod.plus_Mp(2))"], ["proof (state)\nthis:\n  a + b =m u * a' + u * b'\n\ngoal (1 subgoal):\n 1. u dvdm a + b", "also"], ["proof (state)\nthis:\n  a + b =m u * a' + u * b'\n\ngoal (1 subgoal):\n 1. u dvdm a + b", "have \"... = Mp (u * (a'+ b'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u * a' + u * b' =m u * (a' + b')", "by (simp add: distrib_left)"], ["proof (state)\nthis:\n  u * a' + u * b' =m u * (a' + b')\n\ngoal (1 subgoal):\n 1. u dvdm a + b", "finally"], ["proof (chain)\npicking this:\n  a + b =m u * (a' + b')", "show ?thesis"], ["proof (prove)\nusing this:\n  a + b =m u * (a' + b')\n\ngoal (1 subgoal):\n 1. u dvdm a + b", "unfolding dvdm_def"], ["proof (prove)\nusing this:\n  a + b =m u * (a' + b')\n\ngoal (1 subgoal):\n 1. \\<exists>h. a + b =m u * h", "by auto"], ["proof (state)\nthis:\n  u dvdm a + b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monic_dvdm_constant:\n  assumes uk: \"u dvdm [:k:]\"\n  and u1: \"monic u\" and u2: \"degree u > 0\" \n  shows \"k mod m = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k mod m = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. k mod m = 0", "have d1: \"degree_m [:k:] = degree [:k:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m [:k:] = degree [:k:]", "by (metis degree_pCons_0 le_zero_eq poly_mod.degree_m_le)"], ["proof (state)\nthis:\n  degree_m [:k:] = degree [:k:]\n\ngoal (1 subgoal):\n 1. k mod m = 0", "obtain h where h: \"Mp [:k:] = Mp (u * h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h. [:k:] =m u * h \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using uk"], ["proof (prove)\nusing this:\n  u dvdm [:k:]\n\ngoal (1 subgoal):\n 1. (\\<And>h. [:k:] =m u * h \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvdm_def"], ["proof (prove)\nusing this:\n  \\<exists>h. [:k:] =m u * h\n\ngoal (1 subgoal):\n 1. (\\<And>h. [:k:] =m u * h \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  [:k:] =m u * h\n\ngoal (1 subgoal):\n 1. k mod m = 0", "have d2: \"degree_m [:k:] = degree_m (u*h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m [:k:] = degree_m (u * h)", "using h"], ["proof (prove)\nusing this:\n  [:k:] =m u * h\n\ngoal (1 subgoal):\n 1. degree_m [:k:] = degree_m (u * h)", "by metis"], ["proof (state)\nthis:\n  degree_m [:k:] = degree_m (u * h)\n\ngoal (1 subgoal):\n 1. k mod m = 0", "have d3: \"degree (map_poly M (u * map_poly M h)) = degree (u * map_poly M h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (map_poly M (u * map_poly M h)) = degree (u * map_poly M h)", "by (rule degree_map_poly)\n       (metis coeff_degree_mult leading_coeff_0_iff mult.right_neutral M_M Mp_coeff Mp_def u1)"], ["proof (state)\nthis:\n  degree (map_poly M (u * map_poly M h)) = degree (u * map_poly M h)\n\ngoal (1 subgoal):\n 1. k mod m = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  degree (map_poly M (u * map_poly M h)) = degree (u * map_poly M h)\n\ngoal (1 subgoal):\n 1. k mod m = 0", "using assms d1 d2 d3"], ["proof (prove)\nusing this:\n  degree (map_poly M (u * map_poly M h)) = degree (u * map_poly M h)\n  u dvdm [:k:]\n  monic u\n  0 < degree u\n  degree_m [:k:] = degree [:k:]\n  degree_m [:k:] = degree_m (u * h)\n  degree (map_poly M (u * map_poly M h)) = degree (u * map_poly M h)\n\ngoal (1 subgoal):\n 1. k mod m = 0", "by (auto, metis M_def map_poly_pCons degree_mult_right_le h leD map_poly_0 \n        mult_poly_0_right pCons_eq_0_iff M_0 Mp_def mult_Mp(2))"], ["proof (state)\nthis:\n  k mod m = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma div_mod_imp_dvdm:\n  assumes \"\\<exists>q r. b = q * a + Polynomial.smult m r\"\n  shows \"a dvdm b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a dvdm b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a dvdm b", "from assms"], ["proof (chain)\npicking this:\n  \\<exists>q r. b = q * a + smult m r", "obtain q r where b:\"b = a * q + smult m r\""], ["proof (prove)\nusing this:\n  \\<exists>q r. b = q * a + smult m r\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        b = a * q + smult m r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis mult.commute)"], ["proof (state)\nthis:\n  b = a * q + smult m r\n\ngoal (1 subgoal):\n 1. a dvdm b", "have a: \"Mp (Polynomial.smult m r) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (smult m r) = 0", "by auto"], ["proof (state)\nthis:\n  Mp (smult m r) = 0\n\ngoal (1 subgoal):\n 1. a dvdm b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. a dvdm b", "proof (unfold dvdm_def, rule exI[of _ q])"], ["proof (state)\ngoal (1 subgoal):\n 1. b =m a * q", "have \"Mp (a * q + smult m r) = Mp (a * q + Mp (smult m r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * q + smult m r =m a * q + Mp (smult m r)", "using plus_Mp(2)[of \"a*q\" \"smult m r\"]"], ["proof (prove)\nusing this:\n  a * q + Mp (smult m r) =m a * q + smult m r\n\ngoal (1 subgoal):\n 1. a * q + smult m r =m a * q + Mp (smult m r)", "by auto"], ["proof (state)\nthis:\n  a * q + smult m r =m a * q + Mp (smult m r)\n\ngoal (1 subgoal):\n 1. b =m a * q", "also"], ["proof (state)\nthis:\n  a * q + smult m r =m a * q + Mp (smult m r)\n\ngoal (1 subgoal):\n 1. b =m a * q", "have \"... = Mp (a*q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * q + Mp (smult m r) =m a * q", "by auto"], ["proof (state)\nthis:\n  a * q + Mp (smult m r) =m a * q\n\ngoal (1 subgoal):\n 1. b =m a * q", "finally"], ["proof (chain)\npicking this:\n  a * q + smult m r =m a * q", "show \"eq_m b (a * q)\""], ["proof (prove)\nusing this:\n  a * q + smult m r =m a * q\n\ngoal (1 subgoal):\n 1. b =m a * q", "using b"], ["proof (prove)\nusing this:\n  a * q + smult m r =m a * q\n  b = a * q + smult m r\n\ngoal (1 subgoal):\n 1. b =m a * q", "by auto"], ["proof (state)\nthis:\n  b =m a * q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a dvdm b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lead_coeff_monic_mult:\n  fixes p :: \"'a :: {comm_semiring_1,semiring_no_zero_divisors} poly\"\n  assumes \"monic p\" shows \"lead_coeff (p * q) = lead_coeff q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (p * q) = lead_coeff q", "using assms"], ["proof (prove)\nusing this:\n  monic p\n\ngoal (1 subgoal):\n 1. lead_coeff (p * q) = lead_coeff q", "by (simp add: lead_coeff_mult)"], ["", "lemma degree_m_mult_eq:\n  assumes p: \"monic p\" and q: \"lead_coeff q mod m \\<noteq> 0\" and m1: \"m > 1\"\n  shows \"degree (Mp (p * q)) = degree p + degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m (p * q) = degree p + degree q", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. degree_m (p * q) = degree p + degree q", "have \"lead_coeff (p * q) mod m \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (p * q) mod m \\<noteq> 0", "using q p"], ["proof (prove)\nusing this:\n  lead_coeff q mod m \\<noteq> 0\n  monic p\n\ngoal (1 subgoal):\n 1. lead_coeff (p * q) mod m \\<noteq> 0", "by (auto simp: lead_coeff_monic_mult)"], ["proof (state)\nthis:\n  lead_coeff (p * q) mod m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree_m (p * q) = degree p + degree q", "with m1"], ["proof (chain)\npicking this:\n  1 < m\n  lead_coeff (p * q) mod m \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  1 < m\n  lead_coeff (p * q) mod m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree_m (p * q) = degree p + degree q", "by (auto simp: degree_m_eq intro!: degree_mult_eq)"], ["proof (state)\nthis:\n  degree_m (p * q) = degree p + degree q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dvdm_imp_degree_le:\n  assumes pq: \"p dvdm q\" and p: \"monic p\" and q0: \"Mp q \\<noteq> 0\" and m1: \"m > 1\"\n  shows \"degree p \\<le> degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p \\<le> degree q", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p \\<le> degree q", "from q0"], ["proof (chain)\npicking this:\n  Mp q \\<noteq> 0", "have q: \"lead_coeff (Mp q) mod m \\<noteq> 0\""], ["proof (prove)\nusing this:\n  Mp q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff (Mp q) mod m \\<noteq> 0", "by (metis Mp_Mp Mp_coeff leading_coeff_neq_0 M_def)"], ["proof (state)\nthis:\n  lead_coeff (Mp q) mod m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p \\<le> degree q", "from pq"], ["proof (chain)\npicking this:\n  p dvdm q", "obtain r where Mpq: \"Mp q = Mp (p * Mp r)\""], ["proof (prove)\nusing this:\n  p dvdm q\n\ngoal (1 subgoal):\n 1. (\\<And>r. q =m p * Mp r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: dvdmE)"], ["proof (state)\nthis:\n  q =m p * Mp r\n\ngoal (1 subgoal):\n 1. degree p \\<le> degree q", "with p q"], ["proof (chain)\npicking this:\n  monic p\n  lead_coeff (Mp q) mod m \\<noteq> 0\n  q =m p * Mp r", "have \"lead_coeff (Mp r) mod m \\<noteq> 0\""], ["proof (prove)\nusing this:\n  monic p\n  lead_coeff (Mp q) mod m \\<noteq> 0\n  q =m p * Mp r\n\ngoal (1 subgoal):\n 1. lead_coeff (Mp r) mod m \\<noteq> 0", "by (metis Mp_Mp Mp_coeff leading_coeff_0_iff mult_poly_0_right M_def)"], ["proof (state)\nthis:\n  lead_coeff (Mp r) mod m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p \\<le> degree q", "from degree_m_mult_eq[OF p this m1] Mpq"], ["proof (chain)\npicking this:\n  degree_m (p * Mp r) = degree p + degree_m r\n  q =m p * Mp r", "have \"degree p \\<le> degree_m q\""], ["proof (prove)\nusing this:\n  degree_m (p * Mp r) = degree p + degree_m r\n  q =m p * Mp r\n\ngoal (1 subgoal):\n 1. degree p \\<le> degree_m q", "by simp"], ["proof (state)\nthis:\n  degree p \\<le> degree_m q\n\ngoal (1 subgoal):\n 1. degree p \\<le> degree q", "thus ?thesis"], ["proof (prove)\nusing this:\n  degree p \\<le> degree_m q\n\ngoal (1 subgoal):\n 1. degree p \\<le> degree q", "using degree_m_le le_trans"], ["proof (prove)\nusing this:\n  degree p \\<le> degree_m q\n  degree_m ?f \\<le> degree ?f\n  \\<lbrakk>?i \\<le> ?j; ?j \\<le> ?k\\<rbrakk> \\<Longrightarrow> ?i \\<le> ?k\n\ngoal (1 subgoal):\n 1. degree p \\<le> degree q", "by blast"], ["proof (state)\nthis:\n  degree p \\<le> degree q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dvdm_uminus [simp]:\n  \"p dvdm -q \\<longleftrightarrow> p dvdm q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p dvdm - q) = (p dvdm q)", "by (metis add.inverse_inverse dvdm_smult smult_1_left smult_minus_left)"], ["", "(*TODO: simp?*)"], ["", "lemma Mp_const_poly: \"Mp [:a:] = [:a mod m:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp [:a:] = [:a mod m:]", "by (simp add: Mp_def M_def Polynomial.map_poly_pCons)"], ["", "lemma dvdm_imp_div_mod:\n  assumes \"u dvdm g\"\n  shows \"\\<exists>q r. g = q*u + smult m r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q r. g = q * u + smult m r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q r. g = q * u + smult m r", "obtain q where q: \"Mp g = Mp (u*q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q. g =m u * q \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  u dvdm g\n\ngoal (1 subgoal):\n 1. (\\<And>q. g =m u * q \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvdm_def"], ["proof (prove)\nusing this:\n  \\<exists>h. g =m u * h\n\ngoal (1 subgoal):\n 1. (\\<And>q. g =m u * q \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by fast"], ["proof (state)\nthis:\n  g =m u * q\n\ngoal (1 subgoal):\n 1. \\<exists>q r. g = q * u + smult m r", "have \"(u*q) = Mp (u*q) + smult m (Dp (u*q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u * q = Mp (u * q) + smult m (Dp (u * q))", "by (simp add: poly_mod.Dp_Mp_eq[of \"u*q\"])"], ["proof (state)\nthis:\n  u * q = Mp (u * q) + smult m (Dp (u * q))\n\ngoal (1 subgoal):\n 1. \\<exists>q r. g = q * u + smult m r", "hence uq: \"Mp (u*q) = (u*q) - smult m (Dp (u*q))\""], ["proof (prove)\nusing this:\n  u * q = Mp (u * q) + smult m (Dp (u * q))\n\ngoal (1 subgoal):\n 1. Mp (u * q) = u * q - smult m (Dp (u * q))", "by auto"], ["proof (state)\nthis:\n  Mp (u * q) = u * q - smult m (Dp (u * q))\n\ngoal (1 subgoal):\n 1. \\<exists>q r. g = q * u + smult m r", "have g: \"g = Mp g + smult m (Dp g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g = Mp g + smult m (Dp g)", "by (simp add: poly_mod.Dp_Mp_eq[of \"g\"])"], ["proof (state)\nthis:\n  g = Mp g + smult m (Dp g)\n\ngoal (1 subgoal):\n 1. \\<exists>q r. g = q * u + smult m r", "also"], ["proof (state)\nthis:\n  g = Mp g + smult m (Dp g)\n\ngoal (1 subgoal):\n 1. \\<exists>q r. g = q * u + smult m r", "have \"... = poly_mod.Mp m (u*q) + smult m (Dp g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp g + smult m (Dp g) = Mp (u * q) + smult m (Dp g)", "using q"], ["proof (prove)\nusing this:\n  g =m u * q\n\ngoal (1 subgoal):\n 1. Mp g + smult m (Dp g) = Mp (u * q) + smult m (Dp g)", "by simp"], ["proof (state)\nthis:\n  Mp g + smult m (Dp g) = Mp (u * q) + smult m (Dp g)\n\ngoal (1 subgoal):\n 1. \\<exists>q r. g = q * u + smult m r", "also"], ["proof (state)\nthis:\n  Mp g + smult m (Dp g) = Mp (u * q) + smult m (Dp g)\n\ngoal (1 subgoal):\n 1. \\<exists>q r. g = q * u + smult m r", "have \"... = u * q - smult m (Dp (u * q)) + smult m (Dp g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (u * q) + smult m (Dp g) =\n    u * q - smult m (Dp (u * q)) + smult m (Dp g)", "unfolding uq"], ["proof (prove)\ngoal (1 subgoal):\n 1. u * q - smult m (Dp (u * q)) + smult m (Dp g) =\n    u * q - smult m (Dp (u * q)) + smult m (Dp g)", "by auto"], ["proof (state)\nthis:\n  Mp (u * q) + smult m (Dp g) =\n  u * q - smult m (Dp (u * q)) + smult m (Dp g)\n\ngoal (1 subgoal):\n 1. \\<exists>q r. g = q * u + smult m r", "also"], ["proof (state)\nthis:\n  Mp (u * q) + smult m (Dp g) =\n  u * q - smult m (Dp (u * q)) + smult m (Dp g)\n\ngoal (1 subgoal):\n 1. \\<exists>q r. g = q * u + smult m r", "have \"... = u * q + smult m (-Dp (u*q)) + smult m (Dp g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u * q - smult m (Dp (u * q)) + smult m (Dp g) =\n    u * q + smult m (- Dp (u * q)) + smult m (Dp g)", "by auto"], ["proof (state)\nthis:\n  u * q - smult m (Dp (u * q)) + smult m (Dp g) =\n  u * q + smult m (- Dp (u * q)) + smult m (Dp g)\n\ngoal (1 subgoal):\n 1. \\<exists>q r. g = q * u + smult m r", "also"], ["proof (state)\nthis:\n  u * q - smult m (Dp (u * q)) + smult m (Dp g) =\n  u * q + smult m (- Dp (u * q)) + smult m (Dp g)\n\ngoal (1 subgoal):\n 1. \\<exists>q r. g = q * u + smult m r", "have \"... = u * q + smult m (-Dp (u*q) + Dp g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u * q + smult m (- Dp (u * q)) + smult m (Dp g) =\n    u * q + smult m (- Dp (u * q) + Dp g)", "unfolding smult_add_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. u * q + smult m (- Dp (u * q)) + smult m (Dp g) =\n    u * q + (smult m (- Dp (u * q)) + smult m (Dp g))", "by auto"], ["proof (state)\nthis:\n  u * q + smult m (- Dp (u * q)) + smult m (Dp g) =\n  u * q + smult m (- Dp (u * q) + Dp g)\n\ngoal (1 subgoal):\n 1. \\<exists>q r. g = q * u + smult m r", "also"], ["proof (state)\nthis:\n  u * q + smult m (- Dp (u * q)) + smult m (Dp g) =\n  u * q + smult m (- Dp (u * q) + Dp g)\n\ngoal (1 subgoal):\n 1. \\<exists>q r. g = q * u + smult m r", "have \"... = q * u + smult m (-Dp (u*q) + Dp g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u * q + smult m (- Dp (u * q) + Dp g) =\n    q * u + smult m (- Dp (u * q) + Dp g)", "by auto"], ["proof (state)\nthis:\n  u * q + smult m (- Dp (u * q) + Dp g) =\n  q * u + smult m (- Dp (u * q) + Dp g)\n\ngoal (1 subgoal):\n 1. \\<exists>q r. g = q * u + smult m r", "finally"], ["proof (chain)\npicking this:\n  g = q * u + smult m (- Dp (u * q) + Dp g)", "show ?thesis"], ["proof (prove)\nusing this:\n  g = q * u + smult m (- Dp (u * q) + Dp g)\n\ngoal (1 subgoal):\n 1. \\<exists>q r. g = q * u + smult m r", "by auto"], ["proof (state)\nthis:\n  \\<exists>q r. g = q * u + smult m r\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary div_mod_iff_dvdm:\n  shows \"a dvdm b = (\\<exists>q r. b = q * a + Polynomial.smult m r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a dvdm b) = (\\<exists>q r. b = q * a + smult m r)", "using div_mod_imp_dvdm dvdm_imp_div_mod"], ["proof (prove)\nusing this:\n  \\<exists>q r. ?b = q * ?a + smult m r \\<Longrightarrow> ?a dvdm ?b\n  ?u dvdm ?g \\<Longrightarrow> \\<exists>q r. ?g = q * ?u + smult m r\n\ngoal (1 subgoal):\n 1. (a dvdm b) = (\\<exists>q r. b = q * a + smult m r)", "by blast"], ["", "lemma dvdmE':\n  assumes \"p dvdm q\" and \"\\<And>r. q =m p * Mp r \\<Longrightarrow> thesis\"\n  shows thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using assms"], ["proof (prove)\nusing this:\n  p dvdm q\n  q =m p * Mp ?r \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (auto simp: dvdm_def)"], ["", "end"], ["", "context poly_mod_2\nbegin"], ["", "lemma factorization_m_mem_dvdm: assumes fact: \"factorization_m f (c,fs)\" \n  and mem: \"Mp g \\<in># image_mset Mp fs\" \nshows \"g dvdm f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g dvdm f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. g dvdm f", "from fact"], ["proof (chain)\npicking this:\n  factorization_m f (c, fs)", "have \"factorization_m f (Mf (c, fs))\""], ["proof (prove)\nusing this:\n  factorization_m f (c, fs)\n\ngoal (1 subgoal):\n 1. factorization_m f (Mf (c, fs))", "by auto"], ["proof (state)\nthis:\n  factorization_m f (Mf (c, fs))\n\ngoal (1 subgoal):\n 1. g dvdm f", "then"], ["proof (chain)\npicking this:\n  factorization_m f (Mf (c, fs))", "obtain l where f: \"factorization_m f (l, image_mset Mp fs)\""], ["proof (prove)\nusing this:\n  factorization_m f (Mf (c, fs))\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        factorization_m f (l, image_mset Mp fs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Mf_def)"], ["proof (state)\nthis:\n  factorization_m f (l, image_mset Mp fs)\n\ngoal (1 subgoal):\n 1. g dvdm f", "from multi_member_split[OF mem]"], ["proof (chain)\npicking this:\n  \\<exists>A. image_mset Mp fs = add_mset (Mp g) A", "obtain ls where \n    fs: \"image_mset Mp fs = {# Mp g #} + ls\""], ["proof (prove)\nusing this:\n  \\<exists>A. image_mset Mp fs = add_mset (Mp g) A\n\ngoal (1 subgoal):\n 1. (\\<And>ls.\n        image_mset Mp fs = {#Mp g#} + ls \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  image_mset Mp fs = {#Mp g#} + ls\n\ngoal (1 subgoal):\n 1. g dvdm f", "from f[unfolded fs split factorization_m_def]"], ["proof (chain)\npicking this:\n  f =m smult l (\\<Prod>\\<^sub># ({#Mp g#} + ls)) \\<and>\n  (\\<forall>f\\<in>#{#Mp g#} + ls.\n      irreducible\\<^sub>d_m f \\<and> monic (Mp f))", "show \"g dvdm f\""], ["proof (prove)\nusing this:\n  f =m smult l (\\<Prod>\\<^sub># ({#Mp g#} + ls)) \\<and>\n  (\\<forall>f\\<in>#{#Mp g#} + ls.\n      irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n\ngoal (1 subgoal):\n 1. g dvdm f", "unfolding dvdm_def"], ["proof (prove)\nusing this:\n  f =m smult l (\\<Prod>\\<^sub># ({#Mp g#} + ls)) \\<and>\n  (\\<forall>f\\<in>#{#Mp g#} + ls.\n      irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n\ngoal (1 subgoal):\n 1. \\<exists>h. f =m g * h", "by (intro exI[of _ \"smult l (prod_mset ls)\"], auto simp del: Mp_smult \n        simp add: Mp_smult(2)[of _ \"Mp g * prod_mset ls\", symmetric], simp)"], ["proof (state)\nthis:\n  g dvdm f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dvdm_degree: \"monic u \\<Longrightarrow> u dvdm f \\<Longrightarrow> Mp f \\<noteq> 0 \\<Longrightarrow> degree u \\<le> degree f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>monic u; u dvdm f; Mp f \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> degree u \\<le> degree f", "using dvdm_imp_degree_le m1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p dvdm ?q; monic ?p; Mp ?q \\<noteq> 0; 1 < m\\<rbrakk>\n  \\<Longrightarrow> degree ?p \\<le> degree ?q\n  1 < m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>monic u; u dvdm f; Mp f \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> degree u \\<le> degree f", "by blast"], ["", "end"], ["", "lemma (in poly_mod_prime) pl_dvdm_imp_p_dvdm:\n  assumes l0: \"l \\<noteq> 0\" \n  and pl_dvdm: \"poly_mod.dvdm (p^l) a b\"\n  shows \"a dvdm b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a dvdm b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a dvdm b", "from l0"], ["proof (chain)\npicking this:\n  l \\<noteq> 0", "have l_gt_0: \"l > 0\""], ["proof (prove)\nusing this:\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < l", "by auto"], ["proof (state)\nthis:\n  0 < l\n\ngoal (1 subgoal):\n 1. a dvdm b", "with m1"], ["proof (chain)\npicking this:\n  1 < p\n  0 < l", "interpret pl: poly_mod_2 \"p^l\""], ["proof (prove)\nusing this:\n  1 < p\n  0 < l\n\ngoal (1 subgoal):\n 1. poly_mod_2 (p ^ l)", "by (unfold_locales, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. a dvdm b", "from l_gt_0"], ["proof (chain)\npicking this:\n  0 < l", "have p_rw: \"p * p ^ (l - 1) = p ^ l\""], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. p * p ^ (l - 1) = p ^ l", "by (cases l) simp_all"], ["proof (state)\nthis:\n  p * p ^ (l - 1) = p ^ l\n\ngoal (1 subgoal):\n 1. a dvdm b", "obtain q r where b: \"b = q * a + smult (p^l) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        b = q * a + smult (p ^ l) r \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using pl.dvdm_imp_div_mod[OF pl_dvdm]"], ["proof (prove)\nusing this:\n  \\<exists>q r. b = q * a + smult (p ^ l) r\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        b = q * a + smult (p ^ l) r \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b = q * a + smult (p ^ l) r\n\ngoal (1 subgoal):\n 1. a dvdm b", "have \"smult (p^l) r = smult p (smult (p ^ (l - 1)) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (p ^ l) r = smult p (smult (p ^ (l - 1)) r)", "unfolding smult_smult p_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (p ^ l) r = smult (p ^ l) r", ".."], ["proof (state)\nthis:\n  smult (p ^ l) r = smult p (smult (p ^ (l - 1)) r)\n\ngoal (1 subgoal):\n 1. a dvdm b", "hence b2: \"b = q * a + smult p (smult (p ^ (l - 1)) r)\""], ["proof (prove)\nusing this:\n  smult (p ^ l) r = smult p (smult (p ^ (l - 1)) r)\n\ngoal (1 subgoal):\n 1. b = q * a + smult p (smult (p ^ (l - 1)) r)", "using b"], ["proof (prove)\nusing this:\n  smult (p ^ l) r = smult p (smult (p ^ (l - 1)) r)\n  b = q * a + smult (p ^ l) r\n\ngoal (1 subgoal):\n 1. b = q * a + smult p (smult (p ^ (l - 1)) r)", "by auto"], ["proof (state)\nthis:\n  b = q * a + smult p (smult (p ^ (l - 1)) r)\n\ngoal (1 subgoal):\n 1. a dvdm b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. a dvdm b", "by (rule div_mod_imp_dvdm, rule exI[of _ q], \n        rule exI[of _ \"(smult (p ^ (l - 1)) r)\"], auto simp add: b2)"], ["proof (state)\nthis:\n  a dvdm b\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}