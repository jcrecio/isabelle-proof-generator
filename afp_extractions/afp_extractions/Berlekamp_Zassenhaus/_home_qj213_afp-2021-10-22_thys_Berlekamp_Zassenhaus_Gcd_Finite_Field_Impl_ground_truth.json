{"file_name": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus/Gcd_Finite_Field_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus", "problem_names": ["lemma (in prime_field_gen) coprime_approx_main: \n  shows \"coprime_approx_main p ff_ops f g \\<Longrightarrow> coprime_m f g\"", "lemmas coprime_approx_main_uint32 = prime_field_gen.coprime_approx_main[OF \n        prime_field.prime_field_finite_field_ops32, unfolded prime_field_def mod_ring_locale_def\n   poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]", "lemmas coprime_approx_main_uint64 = prime_field_gen.coprime_approx_main[OF \n        prime_field.prime_field_finite_field_ops64, unfolded prime_field_def mod_ring_locale_def\n   poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]", "lemma coprime_mod_imp_coprime: assumes \n  p: \"prime p\" and \n  cop_m: \"poly_mod.coprime_m p f g\" and \n  cop: \"coprime (lead_coeff f) p \\<or> coprime (lead_coeff g) p\" and\n  cnt: \"content f = 1 \\<or> content g = 1\" \n  shows \"coprime f g\"", "lemma gcd_primes32: \"p \\<in> set gcd_primes32 \\<Longrightarrow> prime p \\<and> p \\<le> 65535\"", "lemma gcd_primes64: \"p \\<in> set gcd_primes64 \\<Longrightarrow> prime p \\<and> p \\<le> 4294967295\"", "lemma coprime_heuristic: assumes \"coprime_heuristic f g\" \n  and \"content f = 1 \\<or> content g = 1\" \n  shows \"coprime f g\"", "lemma gcd_int_poly_code[code_unfold]: \"gcd = gcd_int_poly\""], "translations": [["", "lemma (in prime_field_gen) coprime_approx_main: \n  shows \"coprime_approx_main p ff_ops f g \\<Longrightarrow> coprime_m f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime_approx_main p ff_ops f g \\<Longrightarrow> coprime_m f g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. coprime_approx_main p ff_ops f g \\<Longrightarrow> coprime_m f g", "define F where F: \"(F :: 'a mod_ring poly) = of_int_poly (Mp f)\""], ["proof (state)\nthis:\n  F = of_int_poly (Mp f)\n\ngoal (1 subgoal):\n 1. coprime_approx_main p ff_ops f g \\<Longrightarrow> coprime_m f g", "define G where G: \"(G :: 'a mod_ring poly) = of_int_poly (Mp g)\""], ["proof (state)\nthis:\n  G = of_int_poly (Mp g)\n\ngoal (1 subgoal):\n 1. coprime_approx_main p ff_ops f g \\<Longrightarrow> coprime_m f g", "let ?f' = \"of_int_poly_i ff_ops (Mp f)\""], ["proof (state)\ngoal (1 subgoal):\n 1. coprime_approx_main p ff_ops f g \\<Longrightarrow> coprime_m f g", "let ?g' = \"of_int_poly_i ff_ops (Mp g)\""], ["proof (state)\ngoal (1 subgoal):\n 1. coprime_approx_main p ff_ops f g \\<Longrightarrow> coprime_m f g", "define f'' where \"f'' \\<equiv> of_int_poly (Mp f) :: 'a mod_ring poly\""], ["proof (state)\nthis:\n  f'' \\<equiv> of_int_poly (Mp f)\n\ngoal (1 subgoal):\n 1. coprime_approx_main p ff_ops f g \\<Longrightarrow> coprime_m f g", "define g'' where \"g'' \\<equiv> of_int_poly (Mp g) :: 'a mod_ring poly\""], ["proof (state)\nthis:\n  g'' \\<equiv> of_int_poly (Mp g)\n\ngoal (1 subgoal):\n 1. coprime_approx_main p ff_ops f g \\<Longrightarrow> coprime_m f g", "have rel_f[transfer_rule]: \"poly_rel ?f' f''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (of_int_poly_i ff_ops (Mp f)) f''", "by (rule poly_rel_of_int_poly[OF refl], simp add: f''_def)"], ["proof (state)\nthis:\n  poly_rel (of_int_poly_i ff_ops (Mp f)) f''\n\ngoal (1 subgoal):\n 1. coprime_approx_main p ff_ops f g \\<Longrightarrow> coprime_m f g", "have rel_f[transfer_rule]: \"poly_rel ?g' g''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (of_int_poly_i ff_ops (Mp g)) g''", "by (rule poly_rel_of_int_poly[OF refl], simp add: g''_def)"], ["proof (state)\nthis:\n  poly_rel (of_int_poly_i ff_ops (Mp g)) g''\n\ngoal (1 subgoal):\n 1. coprime_approx_main p ff_ops f g \\<Longrightarrow> coprime_m f g", "have id: \"(gcd_poly_i ff_ops (of_int_poly_i ff_ops (Mp f)) (of_int_poly_i ff_ops (Mp g)) = one_poly_i ff_ops)\n    = coprime f'' g''\" (is \"?P \\<longleftrightarrow> ?Q\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (gcd_poly_i ff_ops (of_int_poly_i ff_ops (Mp f))\n      (of_int_poly_i ff_ops (Mp g)) =\n     one_poly_i ff_ops) =\n    comm_monoid_mult_class.coprime f'' g''", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (gcd_poly_i ff_ops (of_int_poly_i ff_ops (Mp f))\n      (of_int_poly_i ff_ops (Mp g)) =\n     one_poly_i ff_ops) =\n    comm_monoid_mult_class.coprime f'' g''", "have \"?P \\<longleftrightarrow> gcd f'' g'' = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gcd_poly_i ff_ops (of_int_poly_i ff_ops (Mp f))\n      (of_int_poly_i ff_ops (Mp g)) =\n     one_poly_i ff_ops) =\n    (gcd f'' g'' = 1)", "unfolding separable_i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (gcd_poly_i ff_ops (of_int_poly_i ff_ops (Mp f))\n      (of_int_poly_i ff_ops (Mp g)) =\n     one_poly_i ff_ops) =\n    (gcd f'' g'' = 1)", "by transfer_prover"], ["proof (state)\nthis:\n  (gcd_poly_i ff_ops (of_int_poly_i ff_ops (Mp f))\n    (of_int_poly_i ff_ops (Mp g)) =\n   one_poly_i ff_ops) =\n  (gcd f'' g'' = 1)\n\ngoal (1 subgoal):\n 1. (gcd_poly_i ff_ops (of_int_poly_i ff_ops (Mp f))\n      (of_int_poly_i ff_ops (Mp g)) =\n     one_poly_i ff_ops) =\n    comm_monoid_mult_class.coprime f'' g''", "also"], ["proof (state)\nthis:\n  (gcd_poly_i ff_ops (of_int_poly_i ff_ops (Mp f))\n    (of_int_poly_i ff_ops (Mp g)) =\n   one_poly_i ff_ops) =\n  (gcd f'' g'' = 1)\n\ngoal (1 subgoal):\n 1. (gcd_poly_i ff_ops (of_int_poly_i ff_ops (Mp f))\n      (of_int_poly_i ff_ops (Mp g)) =\n     one_poly_i ff_ops) =\n    comm_monoid_mult_class.coprime f'' g''", "have \"\\<dots> \\<longleftrightarrow> ?Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gcd f'' g'' = 1) = comm_monoid_mult_class.coprime f'' g''", "by (simp add: coprime_iff_gcd_eq_1)"], ["proof (state)\nthis:\n  (gcd f'' g'' = 1) = comm_monoid_mult_class.coprime f'' g''\n\ngoal (1 subgoal):\n 1. (gcd_poly_i ff_ops (of_int_poly_i ff_ops (Mp f))\n      (of_int_poly_i ff_ops (Mp g)) =\n     one_poly_i ff_ops) =\n    comm_monoid_mult_class.coprime f'' g''", "finally"], ["proof (chain)\npicking this:\n  (gcd_poly_i ff_ops (of_int_poly_i ff_ops (Mp f))\n    (of_int_poly_i ff_ops (Mp g)) =\n   one_poly_i ff_ops) =\n  comm_monoid_mult_class.coprime f'' g''", "show ?thesis"], ["proof (prove)\nusing this:\n  (gcd_poly_i ff_ops (of_int_poly_i ff_ops (Mp f))\n    (of_int_poly_i ff_ops (Mp g)) =\n   one_poly_i ff_ops) =\n  comm_monoid_mult_class.coprime f'' g''\n\ngoal (1 subgoal):\n 1. (gcd_poly_i ff_ops (of_int_poly_i ff_ops (Mp f))\n      (of_int_poly_i ff_ops (Mp g)) =\n     one_poly_i ff_ops) =\n    comm_monoid_mult_class.coprime f'' g''", "."], ["proof (state)\nthis:\n  (gcd_poly_i ff_ops (of_int_poly_i ff_ops (Mp f))\n    (of_int_poly_i ff_ops (Mp g)) =\n   one_poly_i ff_ops) =\n  comm_monoid_mult_class.coprime f'' g''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (gcd_poly_i ff_ops (of_int_poly_i ff_ops (Mp f))\n    (of_int_poly_i ff_ops (Mp g)) =\n   one_poly_i ff_ops) =\n  comm_monoid_mult_class.coprime f'' g''\n\ngoal (1 subgoal):\n 1. coprime_approx_main p ff_ops f g \\<Longrightarrow> coprime_m f g", "have fF: \"MP_Rel (Mp f) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel (Mp f) F", "unfolding F MP_Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (Mp f) = to_int_poly (of_int_poly (Mp f))", "by (simp add: Mp_f_representative)"], ["proof (state)\nthis:\n  MP_Rel (Mp f) F\n\ngoal (1 subgoal):\n 1. coprime_approx_main p ff_ops f g \\<Longrightarrow> coprime_m f g", "have gG: \"MP_Rel (Mp g) G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel (Mp g) G", "unfolding G MP_Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (Mp g) = to_int_poly (of_int_poly (Mp g))", "by (simp add: Mp_f_representative)"], ["proof (state)\nthis:\n  MP_Rel (Mp g) G\n\ngoal (1 subgoal):\n 1. coprime_approx_main p ff_ops f g \\<Longrightarrow> coprime_m f g", "have \"coprime f'' g'' = coprime F G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f'' g'' =\n    comm_monoid_mult_class.coprime F G", "unfolding f''_def F g''_def G"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (of_int_poly (Mp f))\n     (of_int_poly (Mp g)) =\n    comm_monoid_mult_class.coprime (of_int_poly (Mp f)) (of_int_poly (Mp g))", "by simp"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime f'' g'' =\n  comm_monoid_mult_class.coprime F G\n\ngoal (1 subgoal):\n 1. coprime_approx_main p ff_ops f g \\<Longrightarrow> coprime_m f g", "also"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime f'' g'' =\n  comm_monoid_mult_class.coprime F G\n\ngoal (1 subgoal):\n 1. coprime_approx_main p ff_ops f g \\<Longrightarrow> coprime_m f g", "have \"\\<dots> = coprime_m (Mp f) (Mp g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime F G = coprime_m (Mp f) (Mp g)", "using coprime_MP_Rel[unfolded rel_fun_def, rule_format, OF fF gG]"], ["proof (prove)\nusing this:\n  coprime_m (Mp f) (Mp g) = comm_monoid_mult_class.coprime F G\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime F G = coprime_m (Mp f) (Mp g)", "by simp"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime F G = coprime_m (Mp f) (Mp g)\n\ngoal (1 subgoal):\n 1. coprime_approx_main p ff_ops f g \\<Longrightarrow> coprime_m f g", "also"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime F G = coprime_m (Mp f) (Mp g)\n\ngoal (1 subgoal):\n 1. coprime_approx_main p ff_ops f g \\<Longrightarrow> coprime_m f g", "have \"\\<dots> = coprime_m f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime_m (Mp f) (Mp g) = coprime_m f g", "unfolding coprime_m_def dvdm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>h.\n        (\\<exists>ha. Mp f =m h * ha) \\<longrightarrow>\n        (\\<exists>ha. Mp g =m h * ha) \\<longrightarrow>\n        (\\<exists>ha. 1 =m h * ha)) =\n    (\\<forall>h.\n        (\\<exists>ha. f =m h * ha) \\<longrightarrow>\n        (\\<exists>ha. g =m h * ha) \\<longrightarrow>\n        (\\<exists>ha. 1 =m h * ha))", "by simp"], ["proof (state)\nthis:\n  coprime_m (Mp f) (Mp g) = coprime_m f g\n\ngoal (1 subgoal):\n 1. coprime_approx_main p ff_ops f g \\<Longrightarrow> coprime_m f g", "finally"], ["proof (chain)\npicking this:\n  comm_monoid_mult_class.coprime f'' g'' = coprime_m f g", "have id2: \"coprime f'' g'' = coprime_m f g\""], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime f'' g'' = coprime_m f g\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f'' g'' = coprime_m f g", "."], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime f'' g'' = coprime_m f g\n\ngoal (1 subgoal):\n 1. coprime_approx_main p ff_ops f g \\<Longrightarrow> coprime_m f g", "show \"coprime_approx_main p ff_ops f g \\<Longrightarrow> coprime_m f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime_approx_main p ff_ops f g \\<Longrightarrow> coprime_m f g", "unfolding coprime_approx_main_def\n    id id2"], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime_m f g \\<Longrightarrow> coprime_m f g", "by auto"], ["proof (state)\nthis:\n  coprime_approx_main p ff_ops f g \\<Longrightarrow> coprime_m f g\n\ngoal:\nNo subgoals!", "qed"], ["", "context poly_mod_prime begin"], ["", "lemmas coprime_approx_main_uint32 = prime_field_gen.coprime_approx_main[OF \n        prime_field.prime_field_finite_field_ops32, unfolded prime_field_def mod_ring_locale_def\n   poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]"], ["", "lemmas coprime_approx_main_uint64 = prime_field_gen.coprime_approx_main[OF \n        prime_field.prime_field_finite_field_ops64, unfolded prime_field_def mod_ring_locale_def\n   poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]"], ["", "end"], ["", "lemma coprime_mod_imp_coprime: assumes \n  p: \"prime p\" and \n  cop_m: \"poly_mod.coprime_m p f g\" and \n  cop: \"coprime (lead_coeff f) p \\<or> coprime (lead_coeff g) p\" and\n  cnt: \"content f = 1 \\<or> content g = 1\" \n  shows \"coprime f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f g", "interpret poly_mod_prime p"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_prime p", "by (standard, rule p)"], ["proof (state)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f g", "from cop_m[unfolded coprime_m_def]"], ["proof (chain)\npicking this:\n  \\<forall>h. h dvdm f \\<longrightarrow> h dvdm g \\<longrightarrow> h dvdm 1", "have cop_m: \"\\<And> h. h dvdm f \\<Longrightarrow> h dvdm g \\<Longrightarrow> h dvdm 1\""], ["proof (prove)\nusing this:\n  \\<forall>h. h dvdm f \\<longrightarrow> h dvdm g \\<longrightarrow> h dvdm 1\n\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>h dvdm f; h dvdm g\\<rbrakk> \\<Longrightarrow> h dvdm 1", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?h dvdm f; ?h dvdm g\\<rbrakk> \\<Longrightarrow> ?h dvdm 1\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f g", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f g", "proof (rule coprimeI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "fix h"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "assume dvd: \"h dvd f\" \"h dvd g\""], ["proof (state)\nthis:\n  h dvd f\n  h dvd g\n\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "hence \"h dvdm f\" \"h dvdm g\""], ["proof (prove)\nusing this:\n  h dvd f\n  h dvd g\n\ngoal (1 subgoal):\n 1. h dvdm f &&& h dvdm g", "unfolding dvdm_def dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. f = h * k\n  \\<exists>k. g = h * k\n\ngoal (1 subgoal):\n 1. \\<exists>ha. f =m h * ha &&& \\<exists>ha. g =m h * ha", "by auto"], ["proof (state)\nthis:\n  h dvdm f\n  h dvdm g\n\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "from cop_m[OF this]"], ["proof (chain)\npicking this:\n  h dvdm 1", "obtain k where unit: \"Mp (h * Mp k) = 1\""], ["proof (prove)\nusing this:\n  h dvdm 1\n\ngoal (1 subgoal):\n 1. (\\<And>k. Mp (h * Mp k) = 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvdm_def"], ["proof (prove)\nusing this:\n  \\<exists>ha. 1 =m h * ha\n\ngoal (1 subgoal):\n 1. (\\<And>k. Mp (h * Mp k) = 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Mp (h * Mp k) = 1\n\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "from content_dvd_contentI[OF dvd(1)] content_dvd_contentI[OF dvd(2)] cnt"], ["proof (chain)\npicking this:\n  content h dvd content f\n  content h dvd content g\n  content f = 1 \\<or> content g = 1", "have cnt: \"content h = 1\""], ["proof (prove)\nusing this:\n  content h dvd content f\n  content h dvd content g\n  content f = 1 \\<or> content g = 1\n\ngoal (1 subgoal):\n 1. content h = 1", "by auto"], ["proof (state)\nthis:\n  content h = 1\n\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "let ?k = \"Mp k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "from unit"], ["proof (chain)\npicking this:\n  Mp (h * Mp k) = 1", "have h0: \"h \\<noteq> 0\""], ["proof (prove)\nusing this:\n  Mp (h * Mp k) = 1\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "from unit"], ["proof (chain)\npicking this:\n  Mp (h * Mp k) = 1", "have k0: \"?k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  Mp (h * Mp k) = 1\n\ngoal (1 subgoal):\n 1. Mp k \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  Mp k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "from p"], ["proof (chain)\npicking this:\n  prime p", "have p0: \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "from dvd"], ["proof (chain)\npicking this:\n  h dvd f\n  h dvd g", "have \"lead_coeff h dvd lead_coeff f\" \"lead_coeff h dvd lead_coeff g\""], ["proof (prove)\nusing this:\n  h dvd f\n  h dvd g\n\ngoal (1 subgoal):\n 1. lead_coeff h dvd lead_coeff f &&& lead_coeff h dvd lead_coeff g", "by (metis dvd_def lead_coeff_mult)+"], ["proof (state)\nthis:\n  lead_coeff h dvd lead_coeff f\n  lead_coeff h dvd lead_coeff g\n\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "with cop"], ["proof (chain)\npicking this:\n  comm_monoid_mult_class.coprime (lead_coeff f) p \\<or>\n  comm_monoid_mult_class.coprime (lead_coeff g) p\n  lead_coeff h dvd lead_coeff f\n  lead_coeff h dvd lead_coeff g", "have coph: \"coprime (lead_coeff h) p\""], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (lead_coeff f) p \\<or>\n  comm_monoid_mult_class.coprime (lead_coeff g) p\n  lead_coeff h dvd lead_coeff f\n  lead_coeff h dvd lead_coeff g\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff h) p", "by (meson dvd_trans not_coprime_iff_common_factor)"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (lead_coeff h) p\n\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "let ?k = \"Mp k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "from arg_cong[OF unit, of degree]"], ["proof (chain)\npicking this:\n  degree_m (h * Mp k) = degree 1", "have degm0: \"degree_m (h * ?k) = 0\""], ["proof (prove)\nusing this:\n  degree_m (h * Mp k) = degree 1\n\ngoal (1 subgoal):\n 1. degree_m (h * Mp k) = 0", "by simp"], ["proof (state)\nthis:\n  degree_m (h * Mp k) = 0\n\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "have \"lead_coeff ?k \\<in> {0 ..< p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (Mp k) \\<in> {0..<p}", "unfolding Mp_coeff M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff k (degree_m k) mod p \\<in> {0..<p}", "using m1"], ["proof (prove)\nusing this:\n  1 < p\n\ngoal (1 subgoal):\n 1. poly.coeff k (degree_m k) mod p \\<in> {0..<p}", "by simp"], ["proof (state)\nthis:\n  lead_coeff (Mp k) \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "with k0"], ["proof (chain)\npicking this:\n  Mp k \\<noteq> 0\n  lead_coeff (Mp k) \\<in> {0..<p}", "have lk: \"lead_coeff ?k \\<ge> 1\" \"lead_coeff ?k < p\""], ["proof (prove)\nusing this:\n  Mp k \\<noteq> 0\n  lead_coeff (Mp k) \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. 1 \\<le> lead_coeff (Mp k) &&& lead_coeff (Mp k) < p", "by (auto simp add: int_one_le_iff_zero_less order.not_eq_order_implies_strict)"], ["proof (state)\nthis:\n  1 \\<le> lead_coeff (Mp k)\n  lead_coeff (Mp k) < p\n\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "have id: \"lead_coeff (h * ?k) = lead_coeff h * lead_coeff ?k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (h * Mp k) = lead_coeff h * lead_coeff (Mp k)", "unfolding lead_coeff_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff h * lead_coeff (Mp k) = lead_coeff h * lead_coeff (Mp k)", ".."], ["proof (state)\nthis:\n  lead_coeff (h * Mp k) = lead_coeff h * lead_coeff (Mp k)\n\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "from coph prime lk"], ["proof (chain)\npicking this:\n  comm_monoid_mult_class.coprime (lead_coeff h) p\n  prime p\n  1 \\<le> lead_coeff (Mp k)\n  lead_coeff (Mp k) < p", "have \"coprime (lead_coeff h * lead_coeff ?k) p\""], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (lead_coeff h) p\n  prime p\n  1 \\<le> lead_coeff (Mp k)\n  lead_coeff (Mp k) < p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff h * lead_coeff (Mp k)) p", "by (simp add: ac_simps prime_imp_coprime zdvd_not_zless)"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (lead_coeff h * lead_coeff (Mp k)) p\n\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "with id"], ["proof (chain)\npicking this:\n  lead_coeff (h * Mp k) = lead_coeff h * lead_coeff (Mp k)\n  comm_monoid_mult_class.coprime (lead_coeff h * lead_coeff (Mp k)) p", "have cop_prod: \"coprime (lead_coeff (h * ?k)) p\""], ["proof (prove)\nusing this:\n  lead_coeff (h * Mp k) = lead_coeff h * lead_coeff (Mp k)\n  comm_monoid_mult_class.coprime (lead_coeff h * lead_coeff (Mp k)) p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff (h * Mp k)) p", "by simp"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (lead_coeff (h * Mp k)) p\n\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "from h0 k0"], ["proof (chain)\npicking this:\n  h \\<noteq> 0\n  Mp k \\<noteq> 0", "have lc0: \"lead_coeff (h * ?k) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  h \\<noteq> 0\n  Mp k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff (h * Mp k) \\<noteq> 0", "unfolding lead_coeff_mult"], ["proof (prove)\nusing this:\n  h \\<noteq> 0\n  Mp k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff h * lead_coeff (Mp k) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  lead_coeff (h * Mp k) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "from p"], ["proof (chain)\npicking this:\n  prime p", "have lcp: \"lead_coeff (h * ?k) mod p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. lead_coeff (h * Mp k) mod p \\<noteq> 0", "using M_1 M_def cop_prod"], ["proof (prove)\nusing this:\n  prime p\n  M 1 = 1\n  M ?x = ?x mod p\n  comm_monoid_mult_class.coprime (lead_coeff (h * Mp k)) p\n\ngoal (1 subgoal):\n 1. lead_coeff (h * Mp k) mod p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  lead_coeff (h * Mp k) mod p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "have deg_eq: \"degree_m (h * ?k) = degree (h * Mp k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m (h * Mp k) = degree (h * Mp k)", "by (rule degree_m_eq[OF _ m1], insert lcp)"], ["proof (state)\nthis:\n  degree_m (h * Mp k) = degree (h * Mp k)\n\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "from this[unfolded degm0]"], ["proof (chain)\npicking this:\n  0 = degree (h * Mp k)", "have \"degree (h * Mp k) = 0\""], ["proof (prove)\nusing this:\n  0 = degree (h * Mp k)\n\ngoal (1 subgoal):\n 1. degree (h * Mp k) = 0", "by simp"], ["proof (state)\nthis:\n  degree (h * Mp k) = 0\n\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "with degree_mult_eq[OF h0 k0]"], ["proof (chain)\npicking this:\n  degree (h * Mp k) = degree h + degree_m k\n  degree (h * Mp k) = 0", "have deg0: \"degree h = 0\""], ["proof (prove)\nusing this:\n  degree (h * Mp k) = degree h + degree_m k\n  degree (h * Mp k) = 0\n\ngoal (1 subgoal):\n 1. degree h = 0", "by auto"], ["proof (state)\nthis:\n  degree h = 0\n\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "from degree0_coeffs[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>a. h = [:a:]", "obtain h0 where h: \"h = [:h0:]\""], ["proof (prove)\nusing this:\n  \\<exists>a. h = [:a:]\n\ngoal (1 subgoal):\n 1. (\\<And>h0. h = [:h0:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  h = [:h0:]\n\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "have \"content h = abs h0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content h = \\<bar>h0\\<bar>", "unfolding content_def h"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd_list (coeffs [:h0:]) = \\<bar>h0\\<bar>", "by (cases \"h0 = 0\", auto)"], ["proof (state)\nthis:\n  content h = \\<bar>h0\\<bar>\n\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "hence \"abs h0 = 1\""], ["proof (prove)\nusing this:\n  content h = \\<bar>h0\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>h0\\<bar> = 1", "using cnt"], ["proof (prove)\nusing this:\n  content h = \\<bar>h0\\<bar>\n  content h = 1\n\ngoal (1 subgoal):\n 1. \\<bar>h0\\<bar> = 1", "by auto"], ["proof (state)\nthis:\n  \\<bar>h0\\<bar> = 1\n\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "hence \"h0 \\<in> {-1,1}\""], ["proof (prove)\nusing this:\n  \\<bar>h0\\<bar> = 1\n\ngoal (1 subgoal):\n 1. h0 \\<in> {- 1, 1}", "by auto"], ["proof (state)\nthis:\n  h0 \\<in> {- 1, 1}\n\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "hence \"h = 1 \\<or> h = -1\""], ["proof (prove)\nusing this:\n  h0 \\<in> {- 1, 1}\n\ngoal (1 subgoal):\n 1. h = 1 \\<or> h = - 1", "unfolding h"], ["proof (prove)\nusing this:\n  h0 \\<in> {- 1, 1}\n\ngoal (1 subgoal):\n 1. [:h0:] = 1 \\<or> [:h0:] = - 1", "by (auto)"], ["proof (state)\nthis:\n  h = 1 \\<or> h = - 1\n\ngoal (1 subgoal):\n 1. \\<And>r. \\<lbrakk>r dvd f; r dvd g\\<rbrakk> \\<Longrightarrow> is_unit r", "thus \"is_unit h\""], ["proof (prove)\nusing this:\n  h = 1 \\<or> h = - 1\n\ngoal (1 subgoal):\n 1. is_unit h", "by auto"], ["proof (state)\nthis:\n  is_unit h\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime f g\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We did not try to optimize the set of chosen primes. They have just been picked \n  randomly from a list of primes.\\<close>"], ["", "definition gcd_primes32 :: \"int list\" where\n  \"gcd_primes32 = [383, 1409, 19213, 22003, 41999]\""], ["", "lemma gcd_primes32: \"p \\<in> set gcd_primes32 \\<Longrightarrow> prime p \\<and> p \\<le> 65535\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> set gcd_primes32 \\<Longrightarrow> prime p \\<and> p \\<le> 65535", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<in> set gcd_primes32 \\<Longrightarrow> prime p \\<and> p \\<le> 65535", "have \"list_all (\\<lambda> p. prime p \\<and> p \\<le> 65535) gcd_primes32\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>p. prime p \\<and> p \\<le> 65535) gcd_primes32", "by eval"], ["proof (state)\nthis:\n  list_all (\\<lambda>p. prime p \\<and> p \\<le> 65535) gcd_primes32\n\ngoal (1 subgoal):\n 1. p \\<in> set gcd_primes32 \\<Longrightarrow> prime p \\<and> p \\<le> 65535", "thus \"p \\<in> set gcd_primes32 \\<Longrightarrow> prime p \\<and> p \\<le> 65535\""], ["proof (prove)\nusing this:\n  list_all (\\<lambda>p. prime p \\<and> p \\<le> 65535) gcd_primes32\n\ngoal (1 subgoal):\n 1. p \\<in> set gcd_primes32 \\<Longrightarrow> prime p \\<and> p \\<le> 65535", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  p \\<in> set gcd_primes32 \\<Longrightarrow> prime p \\<and> p \\<le> 65535\n\ngoal:\nNo subgoals!", "qed"], ["", "definition gcd_primes64 :: \"int list\" where\n  \"gcd_primes64 = [383, 21984191, 50329901, 80329901, 219849193]\""], ["", "lemma gcd_primes64: \"p \\<in> set gcd_primes64 \\<Longrightarrow> prime p \\<and> p \\<le> 4294967295\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> set gcd_primes64 \\<Longrightarrow>\n    prime p \\<and> p \\<le> 4294967295", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<in> set gcd_primes64 \\<Longrightarrow>\n    prime p \\<and> p \\<le> 4294967295", "have \"list_all (\\<lambda> p. prime p \\<and> p \\<le> 4294967295) gcd_primes64\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>p. prime p \\<and> p \\<le> 4294967295) gcd_primes64", "by eval"], ["proof (state)\nthis:\n  list_all (\\<lambda>p. prime p \\<and> p \\<le> 4294967295) gcd_primes64\n\ngoal (1 subgoal):\n 1. p \\<in> set gcd_primes64 \\<Longrightarrow>\n    prime p \\<and> p \\<le> 4294967295", "thus \"p \\<in> set gcd_primes64 \\<Longrightarrow> prime p \\<and> p \\<le> 4294967295\""], ["proof (prove)\nusing this:\n  list_all (\\<lambda>p. prime p \\<and> p \\<le> 4294967295) gcd_primes64\n\ngoal (1 subgoal):\n 1. p \\<in> set gcd_primes64 \\<Longrightarrow>\n    prime p \\<and> p \\<le> 4294967295", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  p \\<in> set gcd_primes64 \\<Longrightarrow>\n  prime p \\<and> p \\<le> 4294967295\n\ngoal:\nNo subgoals!", "qed"], ["", "definition coprime_heuristic :: \"int poly \\<Rightarrow> int poly \\<Rightarrow> bool\" where\n  \"coprime_heuristic f g = (let lcf = lead_coeff f; lcg = lead_coeff g in \n    find (\\<lambda> p. (coprime lcf p \\<or> coprime lcg p) \\<and> coprime_approx_main p (finite_field_ops64 (uint64_of_int p)) f g) \n    gcd_primes64 \\<noteq> None)\""], ["", "lemma coprime_heuristic: assumes \"coprime_heuristic f g\" \n  and \"content f = 1 \\<or> content g = 1\" \n  shows \"coprime f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f g", "proof (cases \"find (\\<lambda>p. (coprime (lead_coeff f) p \\<or> coprime (lead_coeff g) p) \\<and>\n            coprime_approx_main p (finite_field_ops64 (uint64_of_int p)) f g)\n   gcd_primes64\")"], ["proof (state)\ngoal (2 subgoals):\n 1. find\n     (\\<lambda>p.\n         (comm_monoid_mult_class.coprime (lead_coeff f) p \\<or>\n          comm_monoid_mult_class.coprime (lead_coeff g) p) \\<and>\n         coprime_approx_main p (finite_field_ops64 (uint64_of_int p)) f g)\n     gcd_primes64 =\n    None \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g\n 2. \\<And>a.\n       find\n        (\\<lambda>p.\n            (comm_monoid_mult_class.coprime (lead_coeff f) p \\<or>\n             comm_monoid_mult_class.coprime (lead_coeff g) p) \\<and>\n            coprime_approx_main p (finite_field_ops64 (uint64_of_int p)) f\n             g)\n        gcd_primes64 =\n       Some a \\<Longrightarrow>\n       comm_monoid_mult_class.coprime f g", "case (Some p)"], ["proof (state)\nthis:\n  find\n   (\\<lambda>p.\n       (comm_monoid_mult_class.coprime (lead_coeff f) p \\<or>\n        comm_monoid_mult_class.coprime (lead_coeff g) p) \\<and>\n       coprime_approx_main p (finite_field_ops64 (uint64_of_int p)) f g)\n   gcd_primes64 =\n  Some p\n\ngoal (2 subgoals):\n 1. find\n     (\\<lambda>p.\n         (comm_monoid_mult_class.coprime (lead_coeff f) p \\<or>\n          comm_monoid_mult_class.coprime (lead_coeff g) p) \\<and>\n         coprime_approx_main p (finite_field_ops64 (uint64_of_int p)) f g)\n     gcd_primes64 =\n    None \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g\n 2. \\<And>a.\n       find\n        (\\<lambda>p.\n            (comm_monoid_mult_class.coprime (lead_coeff f) p \\<or>\n             comm_monoid_mult_class.coprime (lead_coeff g) p) \\<and>\n            coprime_approx_main p (finite_field_ops64 (uint64_of_int p)) f\n             g)\n        gcd_primes64 =\n       Some a \\<Longrightarrow>\n       comm_monoid_mult_class.coprime f g", "from find_Some_D[OF Some] gcd_primes64"], ["proof (chain)\npicking this:\n  p \\<in> set gcd_primes64 \\<and>\n  (comm_monoid_mult_class.coprime (lead_coeff f) p \\<or>\n   comm_monoid_mult_class.coprime (lead_coeff g) p) \\<and>\n  coprime_approx_main p (finite_field_ops64 (uint64_of_int p)) f g\n  ?p \\<in> set gcd_primes64 \\<Longrightarrow>\n  prime ?p \\<and> ?p \\<le> 4294967295", "have p: \"prime p\" and small: \"p \\<le> 4294967295\" \n    and cop: \"coprime (lead_coeff f) p \\<or> coprime (lead_coeff g) p\" \n    and copp: \"coprime_approx_main p (finite_field_ops64 (uint64_of_int p)) f g\""], ["proof (prove)\nusing this:\n  p \\<in> set gcd_primes64 \\<and>\n  (comm_monoid_mult_class.coprime (lead_coeff f) p \\<or>\n   comm_monoid_mult_class.coprime (lead_coeff g) p) \\<and>\n  coprime_approx_main p (finite_field_ops64 (uint64_of_int p)) f g\n  ?p \\<in> set gcd_primes64 \\<Longrightarrow>\n  prime ?p \\<and> ?p \\<le> 4294967295\n\ngoal (1 subgoal):\n 1. (prime p &&& p \\<le> 4294967295) &&&\n    comm_monoid_mult_class.coprime (lead_coeff f) p \\<or>\n    comm_monoid_mult_class.coprime (lead_coeff g) p &&&\n    coprime_approx_main p (finite_field_ops64 (uint64_of_int p)) f g", "by auto"], ["proof (state)\nthis:\n  prime p\n  p \\<le> 4294967295\n  comm_monoid_mult_class.coprime (lead_coeff f) p \\<or>\n  comm_monoid_mult_class.coprime (lead_coeff g) p\n  coprime_approx_main p (finite_field_ops64 (uint64_of_int p)) f g\n\ngoal (2 subgoals):\n 1. find\n     (\\<lambda>p.\n         (comm_monoid_mult_class.coprime (lead_coeff f) p \\<or>\n          comm_monoid_mult_class.coprime (lead_coeff g) p) \\<and>\n         coprime_approx_main p (finite_field_ops64 (uint64_of_int p)) f g)\n     gcd_primes64 =\n    None \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g\n 2. \\<And>a.\n       find\n        (\\<lambda>p.\n            (comm_monoid_mult_class.coprime (lead_coeff f) p \\<or>\n             comm_monoid_mult_class.coprime (lead_coeff g) p) \\<and>\n            coprime_approx_main p (finite_field_ops64 (uint64_of_int p)) f\n             g)\n        gcd_primes64 =\n       Some a \\<Longrightarrow>\n       comm_monoid_mult_class.coprime f g", "interpret poly_mod_prime p"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_prime p", "using p"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. poly_mod_prime p", "by unfold_locales"], ["proof (state)\ngoal (2 subgoals):\n 1. find\n     (\\<lambda>p.\n         (comm_monoid_mult_class.coprime (lead_coeff f) p \\<or>\n          comm_monoid_mult_class.coprime (lead_coeff g) p) \\<and>\n         coprime_approx_main p (finite_field_ops64 (uint64_of_int p)) f g)\n     gcd_primes64 =\n    None \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g\n 2. \\<And>a.\n       find\n        (\\<lambda>p.\n            (comm_monoid_mult_class.coprime (lead_coeff f) p \\<or>\n             comm_monoid_mult_class.coprime (lead_coeff g) p) \\<and>\n            coprime_approx_main p (finite_field_ops64 (uint64_of_int p)) f\n             g)\n        gcd_primes64 =\n       Some a \\<Longrightarrow>\n       comm_monoid_mult_class.coprime f g", "from coprime_approx_main_uint64[OF small copp]"], ["proof (chain)\npicking this:\n  coprime_m f g", "have \"poly_mod.coprime_m p f g\""], ["proof (prove)\nusing this:\n  coprime_m f g\n\ngoal (1 subgoal):\n 1. coprime_m f g", "by auto"], ["proof (state)\nthis:\n  coprime_m f g\n\ngoal (2 subgoals):\n 1. find\n     (\\<lambda>p.\n         (comm_monoid_mult_class.coprime (lead_coeff f) p \\<or>\n          comm_monoid_mult_class.coprime (lead_coeff g) p) \\<and>\n         coprime_approx_main p (finite_field_ops64 (uint64_of_int p)) f g)\n     gcd_primes64 =\n    None \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g\n 2. \\<And>a.\n       find\n        (\\<lambda>p.\n            (comm_monoid_mult_class.coprime (lead_coeff f) p \\<or>\n             comm_monoid_mult_class.coprime (lead_coeff g) p) \\<and>\n            coprime_approx_main p (finite_field_ops64 (uint64_of_int p)) f\n             g)\n        gcd_primes64 =\n       Some a \\<Longrightarrow>\n       comm_monoid_mult_class.coprime f g", "from coprime_mod_imp_coprime[OF p this cop assms(2)]"], ["proof (chain)\npicking this:\n  comm_monoid_mult_class.coprime f g", "show \"coprime f g\""], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime f g\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f g", "."], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime f g\n\ngoal (1 subgoal):\n 1. find\n     (\\<lambda>p.\n         (comm_monoid_mult_class.coprime (lead_coeff f) p \\<or>\n          comm_monoid_mult_class.coprime (lead_coeff g) p) \\<and>\n         coprime_approx_main p (finite_field_ops64 (uint64_of_int p)) f g)\n     gcd_primes64 =\n    None \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g", "qed (insert assms(1)[unfolded coprime_heuristic_def], auto simp: Let_def)"], ["", "definition gcd_int_poly :: \"int poly \\<Rightarrow> int poly \\<Rightarrow> int poly\" where\n  \"gcd_int_poly f g =\n    (if f = 0 then normalize g\n     else if g = 0 then normalize f\n          else let \n            cf = Polynomial.content f;\n            cg = Polynomial.content g;\n            ct = gcd cf cg;\n            ff = map_poly (\\<lambda> x. x div cf) f; \n            gg = map_poly (\\<lambda> x. x div cg) g\n          in if coprime_heuristic ff gg then [:ct:] else smult ct (gcd_poly_code_aux ff gg))\""], ["", "lemma gcd_int_poly_code[code_unfold]: \"gcd = gcd_int_poly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd = gcd_int_poly", "proof (intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. gcd x xa = gcd_int_poly x xa", "fix f g :: \"int poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. gcd x xa = gcd_int_poly x xa", "let ?ff = \"primitive_part f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. gcd x xa = gcd_int_poly x xa", "let ?gg = \"primitive_part g\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. gcd x xa = gcd_int_poly x xa", "note d = gcd_int_poly_def gcd_poly_code gcd_poly_code_def"], ["proof (state)\nthis:\n  gcd_int_poly ?f ?g =\n  (if ?f = 0 then normalize ?g\n   else if ?g = 0 then normalize ?f\n        else let cf = content ?f; cg = content ?g; ct = gcd cf cg;\n                 ff = map_poly (\\<lambda>x. x div cf) ?f;\n                 gg = map_poly (\\<lambda>x. x div cg) ?g\n             in if coprime_heuristic ff gg then [:ct:]\n                else Polynomial.smult ct (gcd_poly_code_aux ff gg))\n  gcd ?p ?q = gcd_poly_code ?p ?q\n  gcd_poly_code ?p ?q =\n  (if ?p = 0 then normalize ?q\n   else if ?q = 0 then normalize ?p\n        else Polynomial.smult (gcd (content ?p) (content ?q))\n              (gcd_poly_code_aux (primitive_part ?p) (primitive_part ?q)))\n\ngoal (1 subgoal):\n 1. \\<And>x xa. gcd x xa = gcd_int_poly x xa", "show \"gcd f g = gcd_int_poly f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd f g = gcd_int_poly f g", "proof (cases \"f = 0 \\<or> g = 0 \\<or> \\<not> coprime_heuristic ?ff ?gg\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f = 0 \\<or>\n    g = 0 \\<or>\n    \\<not> coprime_heuristic (primitive_part f)\n            (primitive_part g) \\<Longrightarrow>\n    gcd f g = gcd_int_poly f g\n 2. \\<not> (f = 0 \\<or>\n            g = 0 \\<or>\n            \\<not> coprime_heuristic (primitive_part f)\n                    (primitive_part g)) \\<Longrightarrow>\n    gcd f g = gcd_int_poly f g", "case True"], ["proof (state)\nthis:\n  f = 0 \\<or>\n  g = 0 \\<or> \\<not> coprime_heuristic (primitive_part f) (primitive_part g)\n\ngoal (2 subgoals):\n 1. f = 0 \\<or>\n    g = 0 \\<or>\n    \\<not> coprime_heuristic (primitive_part f)\n            (primitive_part g) \\<Longrightarrow>\n    gcd f g = gcd_int_poly f g\n 2. \\<not> (f = 0 \\<or>\n            g = 0 \\<or>\n            \\<not> coprime_heuristic (primitive_part f)\n                    (primitive_part g)) \\<Longrightarrow>\n    gcd f g = gcd_int_poly f g", "thus ?thesis"], ["proof (prove)\nusing this:\n  f = 0 \\<or>\n  g = 0 \\<or> \\<not> coprime_heuristic (primitive_part f) (primitive_part g)\n\ngoal (1 subgoal):\n 1. gcd f g = gcd_int_poly f g", "unfolding d"], ["proof (prove)\nusing this:\n  f = 0 \\<or>\n  g = 0 \\<or> \\<not> coprime_heuristic (primitive_part f) (primitive_part g)\n\ngoal (1 subgoal):\n 1. (if f = 0 then normalize g\n     else if g = 0 then normalize f\n          else Polynomial.smult (gcd (content f) (content g))\n                (gcd_poly_code_aux (primitive_part f) (primitive_part g))) =\n    (if f = 0 then normalize g\n     else if g = 0 then normalize f\n          else let cf = content f; cg = content g; ct = gcd cf cg;\n                   ff = map_poly (\\<lambda>x. x div cf) f;\n                   gg = map_poly (\\<lambda>x. x div cg) g\n               in if coprime_heuristic ff gg then [:ct:]\n                  else Polynomial.smult ct (gcd_poly_code_aux ff gg))", "by (auto simp: Let_def primitive_part_def)"], ["proof (state)\nthis:\n  gcd f g = gcd_int_poly f g\n\ngoal (1 subgoal):\n 1. \\<not> (f = 0 \\<or>\n            g = 0 \\<or>\n            \\<not> coprime_heuristic (primitive_part f)\n                    (primitive_part g)) \\<Longrightarrow>\n    gcd f g = gcd_int_poly f g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (f = 0 \\<or>\n            g = 0 \\<or>\n            \\<not> coprime_heuristic (primitive_part f)\n                    (primitive_part g)) \\<Longrightarrow>\n    gcd f g = gcd_int_poly f g", "case False"], ["proof (state)\nthis:\n  \\<not> (f = 0 \\<or>\n          g = 0 \\<or>\n          \\<not> coprime_heuristic (primitive_part f) (primitive_part g))\n\ngoal (1 subgoal):\n 1. \\<not> (f = 0 \\<or>\n            g = 0 \\<or>\n            \\<not> coprime_heuristic (primitive_part f)\n                    (primitive_part g)) \\<Longrightarrow>\n    gcd f g = gcd_int_poly f g", "hence cop: \"coprime_heuristic ?ff ?gg\""], ["proof (prove)\nusing this:\n  \\<not> (f = 0 \\<or>\n          g = 0 \\<or>\n          \\<not> coprime_heuristic (primitive_part f) (primitive_part g))\n\ngoal (1 subgoal):\n 1. coprime_heuristic (primitive_part f) (primitive_part g)", "by simp"], ["proof (state)\nthis:\n  coprime_heuristic (primitive_part f) (primitive_part g)\n\ngoal (1 subgoal):\n 1. \\<not> (f = 0 \\<or>\n            g = 0 \\<or>\n            \\<not> coprime_heuristic (primitive_part f)\n                    (primitive_part g)) \\<Longrightarrow>\n    gcd f g = gcd_int_poly f g", "from False"], ["proof (chain)\npicking this:\n  \\<not> (f = 0 \\<or>\n          g = 0 \\<or>\n          \\<not> coprime_heuristic (primitive_part f) (primitive_part g))", "have \"f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> (f = 0 \\<or>\n          g = 0 \\<or>\n          \\<not> coprime_heuristic (primitive_part f) (primitive_part g))\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (f = 0 \\<or>\n            g = 0 \\<or>\n            \\<not> coprime_heuristic (primitive_part f)\n                    (primitive_part g)) \\<Longrightarrow>\n    gcd f g = gcd_int_poly f g", "from content_primitive_part[OF this] coprime_heuristic[OF cop]"], ["proof (chain)\npicking this:\n  content (primitive_part f) = 1\n  content (primitive_part f) = 1 \\<or>\n  content (primitive_part g) = 1 \\<Longrightarrow>\n  comm_monoid_mult_class.coprime (primitive_part f) (primitive_part g)", "have id: \"gcd ?ff ?gg = 1\""], ["proof (prove)\nusing this:\n  content (primitive_part f) = 1\n  content (primitive_part f) = 1 \\<or>\n  content (primitive_part g) = 1 \\<Longrightarrow>\n  comm_monoid_mult_class.coprime (primitive_part f) (primitive_part g)\n\ngoal (1 subgoal):\n 1. gcd (primitive_part f) (primitive_part g) = 1", "by auto"], ["proof (state)\nthis:\n  gcd (primitive_part f) (primitive_part g) = 1\n\ngoal (1 subgoal):\n 1. \\<not> (f = 0 \\<or>\n            g = 0 \\<or>\n            \\<not> coprime_heuristic (primitive_part f)\n                    (primitive_part g)) \\<Longrightarrow>\n    gcd f g = gcd_int_poly f g", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd f g = gcd_int_poly f g", "unfolding gcd_poly_decompose[of f g]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (gcd (content f) (content g))\n     (gcd (primitive_part f) (primitive_part g)) =\n    gcd_int_poly f g", "unfolding gcd_int_poly_def Let_def id"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (gcd (content f) (content g)) 1 =\n    (if f = 0 then normalize g\n     else if g = 0 then normalize f\n          else if coprime_heuristic\n                   (map_poly (\\<lambda>x. x div content f) f)\n                   (map_poly (\\<lambda>x. x div content g) g)\n               then [:gcd (content f) (content g):]\n               else Polynomial.smult (gcd (content f) (content g))\n                     (gcd_poly_code_aux\n                       (map_poly (\\<lambda>x. x div content f) f)\n                       (map_poly (\\<lambda>x. x div content g) g)))", "using False"], ["proof (prove)\nusing this:\n  \\<not> (f = 0 \\<or>\n          g = 0 \\<or>\n          \\<not> coprime_heuristic (primitive_part f) (primitive_part g))\n\ngoal (1 subgoal):\n 1. Polynomial.smult (gcd (content f) (content g)) 1 =\n    (if f = 0 then normalize g\n     else if g = 0 then normalize f\n          else if coprime_heuristic\n                   (map_poly (\\<lambda>x. x div content f) f)\n                   (map_poly (\\<lambda>x. x div content g) g)\n               then [:gcd (content f) (content g):]\n               else Polynomial.smult (gcd (content f) (content g))\n                     (gcd_poly_code_aux\n                       (map_poly (\\<lambda>x. x div content f) f)\n                       (map_poly (\\<lambda>x. x div content g) g)))", "by (auto simp: primitive_part_def)"], ["proof (state)\nthis:\n  gcd f g = gcd_int_poly f g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gcd f g = gcd_int_poly f g\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}