{"file_name": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus/Poly_Mod_Finite_Field_Record_Based.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus", "problem_names": ["lemma Mp_rel_i_Mp[simp]: \"Mp_rel_i f (Mp F) = Mp_rel_i f F\"", "lemma Mp_rel_i_Mp_to_int_poly_i: \"Mp_rel_i f F \\<Longrightarrow> Mp (to_int_poly_i ops f) = to_int_poly_i ops f\"", "lemma nat_p: \"nat p = CARD('a)\"", "lemma coeffs_to_int_poly: \"coeffs (to_int_poly (x :: 'a mod_ring poly)) = map to_int_mod_ring (coeffs x)\"", "lemma coeffs_of_int_poly: \"coeffs (of_int_poly (Mp x) :: 'a mod_ring poly) = map of_int (coeffs (Mp x))\"", "lemma to_int_poly_i: assumes \"poly_rel f g\" shows \"to_int_poly_i ff_ops f = to_int_poly g\"", "lemma poly_rel_of_int_poly: assumes id: \"f' = of_int_poly_i ff_ops (Mp f)\" \"f'' = of_int_poly (Mp f)\" \n  shows \"poly_rel f' f''\"", "lemma Mp_rel_iI: \"poly_rel f1 f2 \\<Longrightarrow> MP_Rel f3 f2 \\<Longrightarrow> Mp_rel_i f1 f3\"", "lemma M_rel_iI: \"R f1 f2 \\<Longrightarrow> M_Rel f3 f2 \\<Longrightarrow> M_rel_i f1 f3\"", "lemma M_rel_iI': assumes \"R f1 f2\" \n  shows \"M_rel_i f1 (arith_ops_record.to_int ff_ops f1)\"", "lemma Mp_rel_iI': assumes \"poly_rel f1 f2\" \n  shows \"Mp_rel_i f1 (to_int_poly_i ff_ops f1)\"", "lemma M_rel_iD: assumes \"M_rel_i f1 f3\"\n  shows \n    \"R f1 (of_int (M f3))\"\n    \"M_Rel f3 (of_int (M f3))\"", "lemma Mp_rel_iD: assumes \"Mp_rel_i f1 f3\"\n  shows \n    \"poly_rel f1 (of_int_poly (Mp f3))\"\n    \"MP_Rel f3 (of_int_poly (Mp f3))\"", "lemma (in mod_ring_locale) mod_ring_rel_of_int: \n  \"0 \\<le> x \\<Longrightarrow> x < p \\<Longrightarrow> mod_ring_rel x (of_int x)\"", "lemma prime_field_finite_field_ops_int: \"prime_field_gen (finite_field_ops_int p) mod_ring_rel p\"", "lemma prime_field_finite_field_ops_integer: \"prime_field_gen (finite_field_ops_integer (integer_of_int p)) mod_ring_rel_integer p\"", "lemma prime_field_finite_field_ops32: assumes small: \"p \\<le> 65535\" \n  shows \"prime_field_gen (finite_field_ops32 (uint32_of_int p)) mod_ring_rel32 p\"", "lemma prime_field_finite_field_ops64: assumes small: \"p \\<le> 4294967295\" \n  shows \"prime_field_gen (finite_field_ops64 (uint64_of_int p)) mod_ring_rel64 p\"", "lemma mod_ring_finite_field_ops_int: \"mod_ring_gen (finite_field_ops_int p) mod_ring_rel p\"", "lemma mod_ring_finite_field_ops_integer: \"mod_ring_gen (finite_field_ops_integer (integer_of_int p)) mod_ring_rel_integer p\"", "lemma mod_ring_finite_field_ops32: assumes small: \"p \\<le> 65535\" \n  shows \"mod_ring_gen (finite_field_ops32 (uint32_of_int p)) mod_ring_rel32 p\"", "lemma mod_ring_finite_field_ops64: assumes small: \"p \\<le> 4294967295\" \n  shows \"mod_ring_gen (finite_field_ops64 (uint64_of_int p)) mod_ring_rel64 p\""], "translations": [["", "lemma Mp_rel_i_Mp[simp]: \"Mp_rel_i f (Mp F) = Mp_rel_i f F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp_rel_i f (Mp F) = Mp_rel_i f F", "unfolding Mp_rel_i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (arith_ops_record.to_int ops) f = coeffs (Mp (Mp F))) =\n    (map (arith_ops_record.to_int ops) f = coeffs (Mp F))", "by auto"], ["", "lemma Mp_rel_i_Mp_to_int_poly_i: \"Mp_rel_i f F \\<Longrightarrow> Mp (to_int_poly_i ops f) = to_int_poly_i ops f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp_rel_i f F \\<Longrightarrow>\n    Mp (to_int_poly_i ops f) = to_int_poly_i ops f", "unfolding Mp_rel_i_def to_int_poly_i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (arith_ops_record.to_int ops) f = coeffs (Mp F) \\<Longrightarrow>\n    Mp (poly_of_list (map (arith_ops_record.to_int ops) f)) =\n    poly_of_list (map (arith_ops_record.to_int ops) f)", "by simp"], ["", "end"], ["", "locale mod_ring_gen = ring_ops ff_ops R for ff_ops :: \"'i arith_ops_record\" and\n  R :: \"'i \\<Rightarrow> 'a :: nontriv mod_ring \\<Rightarrow> bool\" +\n  fixes p :: int \n  assumes p: \"p = int CARD('a)\"\n  and of_int: \"0 \\<le> x \\<Longrightarrow> x < p \\<Longrightarrow> R (arith_ops_record.of_int ff_ops x) (of_int x)\" \n  and to_int: \"R y z \\<Longrightarrow> arith_ops_record.to_int ff_ops y = to_int_mod_ring z\" \n  and to_int': \"0 \\<le> arith_ops_record.to_int ff_ops y \\<Longrightarrow> arith_ops_record.to_int ff_ops y < p \\<Longrightarrow> \n    R y (of_int (arith_ops_record.to_int ff_ops y))\" \nbegin"], ["", "lemma nat_p: \"nat p = CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat p = CARD('a)", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (int CARD('a)) = CARD('a)", "by simp"], ["", "sublocale poly_mod_type p \"TYPE('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_type TYPE('a) p", "by (unfold_locales, rule p)"], ["", "lemma coeffs_to_int_poly: \"coeffs (to_int_poly (x :: 'a mod_ring poly)) = map to_int_mod_ring (coeffs x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeffs (to_int_poly x) = map to_int_mod_ring (coeffs x)", "by (rule coeffs_map_poly, auto)"], ["", "lemma coeffs_of_int_poly: \"coeffs (of_int_poly (Mp x) :: 'a mod_ring poly) = map of_int (coeffs (Mp x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeffs (of_int_poly (Mp x)) = map of_int (coeffs (Mp x))", "apply (rule coeffs_map_poly)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_int (lead_coeff (Mp x)) = 0) = (Mp x = 0)", "by (metis M_0 M_M Mp_coeff leading_coeff_0_iff of_int_hom.hom_zero to_int_mod_ring_of_int_M)"], ["", "lemma to_int_poly_i: assumes \"poly_rel f g\" shows \"to_int_poly_i ff_ops f = to_int_poly g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_poly_i ff_ops f = to_int_poly g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. to_int_poly_i ff_ops f = to_int_poly g", "have *: \"map (arith_ops_record.to_int ff_ops) f = coeffs (to_int_poly g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (arith_ops_record.to_int ff_ops) f = coeffs (to_int_poly g)", "unfolding coeffs_to_int_poly"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (arith_ops_record.to_int ff_ops) f = map to_int_mod_ring (coeffs g)", "by (rule nth_equalityI, insert assms, auto simp: list_all2_conv_all_nth poly_rel_def to_int)"], ["proof (state)\nthis:\n  map (arith_ops_record.to_int ff_ops) f = coeffs (to_int_poly g)\n\ngoal (1 subgoal):\n 1. to_int_poly_i ff_ops f = to_int_poly g", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_poly_i ff_ops f = to_int_poly g", "unfolding coeffs_eq_iff to_int_poly_i_def poly_of_list_def coeffs_Poly *\n    strip_while_coeffs"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeffs (to_int_poly g) = coeffs (to_int_poly g)", ".."], ["proof (state)\nthis:\n  to_int_poly_i ff_ops f = to_int_poly g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_rel_of_int_poly: assumes id: \"f' = of_int_poly_i ff_ops (Mp f)\" \"f'' = of_int_poly (Mp f)\" \n  shows \"poly_rel f' f''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel f' f''", "unfolding id poly_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R (of_int_poly_i ff_ops (Mp f)) (coeffs (of_int_poly (Mp f)))", "unfolding list_all2_conv_all_nth coeffs_of_int_poly of_int_poly_i_def length_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (coeffs (Mp f)) = length (coeffs (Mp f)) \\<and>\n    (\\<forall>i<length (coeffs (Mp f)).\n        R (map (arith_ops_record.of_int ff_ops) (coeffs (Mp f)) ! i)\n         (map of_int (coeffs (Mp f)) ! i))", "by (rule conjI[OF refl], intro allI impI, simp add: nth_coeffs_coeff Mp_coeff M_def, rule of_int,\n    insert p, auto)"], ["", "sublocale arith_ops_record ff_ops p"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma Mp_rel_iI: \"poly_rel f1 f2 \\<Longrightarrow> MP_Rel f3 f2 \\<Longrightarrow> Mp_rel_i f1 f3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly_rel f1 f2; MP_Rel f3 f2\\<rbrakk>\n    \\<Longrightarrow> Mp_rel_i f1 f3", "unfolding Mp_rel_i_def MP_Rel_def poly_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all2 R f1 (coeffs f2); Mp f3 = to_int_poly f2\\<rbrakk>\n    \\<Longrightarrow> map (arith_ops_record.to_int ff_ops) f1 =\n                      coeffs (Mp f3)", "by (auto simp add: list_all2_conv_all_nth to_int intro: nth_equalityI)"], ["", "lemma M_rel_iI: \"R f1 f2 \\<Longrightarrow> M_Rel f3 f2 \\<Longrightarrow> M_rel_i f1 f3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R f1 f2; M_Rel f3 f2\\<rbrakk> \\<Longrightarrow> M_rel_i f1 f3", "unfolding M_rel_i_def M_Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R f1 f2; M f3 = to_int_mod_ring f2\\<rbrakk>\n    \\<Longrightarrow> arith_ops_record.to_int ff_ops f1 = M f3", "by (simp add: to_int)"], ["", "lemma M_rel_iI': assumes \"R f1 f2\" \n  shows \"M_rel_i f1 (arith_ops_record.to_int ff_ops f1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_rel_i f1 (arith_ops_record.to_int ff_ops f1)", "by (rule M_rel_iI[OF assms], simp add: to_int[OF assms] M_Rel_def M_to_int_mod_ring)"], ["", "lemma Mp_rel_iI': assumes \"poly_rel f1 f2\" \n  shows \"Mp_rel_i f1 (to_int_poly_i ff_ops f1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp_rel_i f1 (to_int_poly_i ff_ops f1)", "proof (rule Mp_rel_iI[OF assms], unfold to_int_poly_i[OF assms])"], ["proof (state)\ngoal (1 subgoal):\n 1. MP_Rel (to_int_poly f2) f2", "show \"MP_Rel (to_int_poly f2) f2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel (to_int_poly f2) f2", "unfolding MP_Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (to_int_poly f2) = to_int_poly f2", "by (simp add: Mp_to_int_poly)"], ["proof (state)\nthis:\n  MP_Rel (to_int_poly f2) f2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma M_rel_iD: assumes \"M_rel_i f1 f3\"\n  shows \n    \"R f1 (of_int (M f3))\"\n    \"M_Rel f3 (of_int (M f3))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R f1 (of_int (M f3)) &&& M_Rel f3 (of_int (M f3))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. R f1 (of_int (M f3))\n 2. M_Rel f3 (of_int (M f3))", "show \"M_Rel f3 (of_int (M f3))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_Rel f3 (of_int (M f3))", "using M_Rel_def to_int_mod_ring_of_int_M"], ["proof (prove)\nusing this:\n  M_Rel ?x ?x' \\<equiv> M ?x = to_int_mod_ring ?x'\n  to_int_mod_ring (of_int ?x) = M ?x\n\ngoal (1 subgoal):\n 1. M_Rel f3 (of_int (M f3))", "by auto"], ["proof (state)\nthis:\n  M_Rel f3 (of_int (M f3))\n\ngoal (1 subgoal):\n 1. R f1 (of_int (M f3))", "from assms"], ["proof (chain)\npicking this:\n  M_rel_i f1 f3", "show \"R f1 (of_int (M f3))\""], ["proof (prove)\nusing this:\n  M_rel_i f1 f3\n\ngoal (1 subgoal):\n 1. R f1 (of_int (M f3))", "unfolding M_rel_i_def"], ["proof (prove)\nusing this:\n  arith_ops_record.to_int ff_ops f1 = M f3\n\ngoal (1 subgoal):\n 1. R f1 (of_int (M f3))", "by (metis int_one_le_iff_zero_less leD linear m1 poly_mod.M_def pos_mod_conj to_int')"], ["proof (state)\nthis:\n  R f1 (of_int (M f3))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Mp_rel_iD: assumes \"Mp_rel_i f1 f3\"\n  shows \n    \"poly_rel f1 (of_int_poly (Mp f3))\"\n    \"MP_Rel f3 (of_int_poly (Mp f3))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel f1 (of_int_poly (Mp f3)) &&& MP_Rel f3 (of_int_poly (Mp f3))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_rel f1 (of_int_poly (Mp f3))\n 2. MP_Rel f3 (of_int_poly (Mp f3))", "show Rel: \"MP_Rel f3 (of_int_poly (Mp f3))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel f3 (of_int_poly (Mp f3))", "using MP_Rel_def Mp_Mp Mp_f_representative"], ["proof (prove)\nusing this:\n  MP_Rel ?f ?f' \\<equiv> Mp ?f = to_int_poly ?f'\n  Mp ?f =m ?f\n  Mp ?f = to_int_poly (of_int_poly ?f)\n\ngoal (1 subgoal):\n 1. MP_Rel f3 (of_int_poly (Mp f3))", "by auto"], ["proof (state)\nthis:\n  MP_Rel f3 (of_int_poly (Mp f3))\n\ngoal (1 subgoal):\n 1. poly_rel f1 (of_int_poly (Mp f3))", "let ?ti = \"arith_ops_record.to_int ff_ops\""], ["proof (state)\ngoal (1 subgoal):\n 1. poly_rel f1 (of_int_poly (Mp f3))", "from assms[unfolded Mp_rel_i_def]"], ["proof (chain)\npicking this:\n  map (arith_ops_record.to_int ff_ops) f1 = coeffs (Mp f3)", "have\n    *: \"coeffs (Mp f3) = map ?ti f1\""], ["proof (prove)\nusing this:\n  map (arith_ops_record.to_int ff_ops) f1 = coeffs (Mp f3)\n\ngoal (1 subgoal):\n 1. coeffs (Mp f3) = map (arith_ops_record.to_int ff_ops) f1", "by auto"], ["proof (state)\nthis:\n  coeffs (Mp f3) = map (arith_ops_record.to_int ff_ops) f1\n\ngoal (1 subgoal):\n 1. poly_rel f1 (of_int_poly (Mp f3))", "{"], ["proof (state)\nthis:\n  coeffs (Mp f3) = map (arith_ops_record.to_int ff_ops) f1\n\ngoal (1 subgoal):\n 1. poly_rel f1 (of_int_poly (Mp f3))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_rel f1 (of_int_poly (Mp f3))", "assume \"x \\<in> set f1\""], ["proof (state)\nthis:\n  x \\<in> set f1\n\ngoal (1 subgoal):\n 1. poly_rel f1 (of_int_poly (Mp f3))", "hence \"?ti x \\<in> set (map ?ti f1)\""], ["proof (prove)\nusing this:\n  x \\<in> set f1\n\ngoal (1 subgoal):\n 1. arith_ops_record.to_int ff_ops x\n    \\<in> set (map (arith_ops_record.to_int ff_ops) f1)", "by auto"], ["proof (state)\nthis:\n  arith_ops_record.to_int ff_ops x\n  \\<in> set (map (arith_ops_record.to_int ff_ops) f1)\n\ngoal (1 subgoal):\n 1. poly_rel f1 (of_int_poly (Mp f3))", "from this[folded *]"], ["proof (chain)\npicking this:\n  arith_ops_record.to_int ff_ops x \\<in> set (coeffs (Mp f3))", "have \"?ti x \\<in> range M\""], ["proof (prove)\nusing this:\n  arith_ops_record.to_int ff_ops x \\<in> set (coeffs (Mp f3))\n\ngoal (1 subgoal):\n 1. arith_ops_record.to_int ff_ops x \\<in> range M", "by (metis (no_types, lifting) MP_Rel_def M_to_int_mod_ring Rel coeffs_to_int_poly ex_map_conv range_eqI)"], ["proof (state)\nthis:\n  arith_ops_record.to_int ff_ops x \\<in> range M\n\ngoal (1 subgoal):\n 1. poly_rel f1 (of_int_poly (Mp f3))", "hence \"?ti x \\<ge> 0\" \"?ti x < p\""], ["proof (prove)\nusing this:\n  arith_ops_record.to_int ff_ops x \\<in> range M\n\ngoal (1 subgoal):\n 1. 0 \\<le> arith_ops_record.to_int ff_ops x &&&\n    arith_ops_record.to_int ff_ops x < p", "unfolding M_def"], ["proof (prove)\nusing this:\n  arith_ops_record.to_int ff_ops x \\<in> range (\\<lambda>x. x mod p)\n\ngoal (1 subgoal):\n 1. 0 \\<le> arith_ops_record.to_int ff_ops x &&&\n    arith_ops_record.to_int ff_ops x < p", "using m1"], ["proof (prove)\nusing this:\n  arith_ops_record.to_int ff_ops x \\<in> range (\\<lambda>x. x mod p)\n  1 < p\n\ngoal (1 subgoal):\n 1. 0 \\<le> arith_ops_record.to_int ff_ops x &&&\n    arith_ops_record.to_int ff_ops x < p", "by auto"], ["proof (state)\nthis:\n  0 \\<le> arith_ops_record.to_int ff_ops x\n  arith_ops_record.to_int ff_ops x < p\n\ngoal (1 subgoal):\n 1. poly_rel f1 (of_int_poly (Mp f3))", "hence \"R x (of_int (?ti x))\""], ["proof (prove)\nusing this:\n  0 \\<le> arith_ops_record.to_int ff_ops x\n  arith_ops_record.to_int ff_ops x < p\n\ngoal (1 subgoal):\n 1. R x (of_int (arith_ops_record.to_int ff_ops x))", "by (rule to_int')"], ["proof (state)\nthis:\n  R x (of_int (arith_ops_record.to_int ff_ops x))\n\ngoal (1 subgoal):\n 1. poly_rel f1 (of_int_poly (Mp f3))", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> set f1 \\<Longrightarrow>\n  R ?x2 (of_int (arith_ops_record.to_int ff_ops ?x2))\n\ngoal (1 subgoal):\n 1. poly_rel f1 (of_int_poly (Mp f3))", "thus \"poly_rel f1 (of_int_poly (Mp f3))\""], ["proof (prove)\nusing this:\n  ?x2 \\<in> set f1 \\<Longrightarrow>\n  R ?x2 (of_int (arith_ops_record.to_int ff_ops ?x2))\n\ngoal (1 subgoal):\n 1. poly_rel f1 (of_int_poly (Mp f3))", "using *"], ["proof (prove)\nusing this:\n  ?x2 \\<in> set f1 \\<Longrightarrow>\n  R ?x2 (of_int (arith_ops_record.to_int ff_ops ?x2))\n  coeffs (Mp f3) = map (arith_ops_record.to_int ff_ops) f1\n\ngoal (1 subgoal):\n 1. poly_rel f1 (of_int_poly (Mp f3))", "unfolding poly_rel_def coeffs_of_int_poly"], ["proof (prove)\nusing this:\n  ?x2 \\<in> set f1 \\<Longrightarrow>\n  R ?x2 (of_int (arith_ops_record.to_int ff_ops ?x2))\n  coeffs (Mp f3) = map (arith_ops_record.to_int ff_ops) f1\n\ngoal (1 subgoal):\n 1. list_all2 R f1 (map of_int (coeffs (Mp f3)))", "by (auto simp: list_all2_map2 list_all2_same)"], ["proof (state)\nthis:\n  poly_rel f1 (of_int_poly (Mp f3))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale prime_field_gen = field_ops ff_ops R + mod_ring_gen ff_ops R p for ff_ops :: \"'i arith_ops_record\" and\n  R :: \"'i \\<Rightarrow> 'a :: prime_card mod_ring \\<Rightarrow> bool\" and p :: int\nbegin"], ["", "sublocale poly_mod_prime_type p \"TYPE('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_prime_type TYPE('a) p", "by (unfold_locales, rule p)"], ["", "end"], ["", "lemma (in mod_ring_locale) mod_ring_rel_of_int: \n  \"0 \\<le> x \\<Longrightarrow> x < p \\<Longrightarrow> mod_ring_rel x (of_int x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; x < p\\<rbrakk>\n    \\<Longrightarrow> mod_ring_rel x (of_int x)", "unfolding mod_ring_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; x < p\\<rbrakk>\n    \\<Longrightarrow> x = to_int_mod_ring (of_int x)", "by (transfer, auto simp: p)"], ["", "context prime_field\nbegin"], ["", "lemma prime_field_finite_field_ops_int: \"prime_field_gen (finite_field_ops_int p) mod_ring_rel p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops_int p) mod_ring_rel p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops_int p) mod_ring_rel p", "interpret field_ops \"finite_field_ops_int p\" mod_ring_rel"], ["proof (prove)\ngoal (1 subgoal):\n 1. field_ops (finite_field_ops_int p) mod_ring_rel", "by (rule finite_field_ops_int)"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops_int p) mod_ring_rel p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops_int p) mod_ring_rel p", "by (unfold_locales, rule p, \n    auto simp: finite_field_ops_int_def p mod_ring_rel_def of_int_of_int_mod_ring)"], ["proof (state)\nthis:\n  prime_field_gen (finite_field_ops_int p) mod_ring_rel p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prime_field_finite_field_ops_integer: \"prime_field_gen (finite_field_ops_integer (integer_of_int p)) mod_ring_rel_integer p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops_integer (integer_of_int p))\n     mod_ring_rel_integer p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops_integer (integer_of_int p))\n     mod_ring_rel_integer p", "interpret field_ops \"finite_field_ops_integer (integer_of_int p)\" mod_ring_rel_integer"], ["proof (prove)\ngoal (1 subgoal):\n 1. field_ops (finite_field_ops_integer (integer_of_int p))\n     mod_ring_rel_integer", "by (rule finite_field_ops_integer, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops_integer (integer_of_int p))\n     mod_ring_rel_integer p", "have pp: \"p = int_of_integer (integer_of_int p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = int_of_integer (integer_of_int p)", "by auto"], ["proof (state)\nthis:\n  p = int_of_integer (integer_of_int p)\n\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops_integer (integer_of_int p))\n     mod_ring_rel_integer p", "interpret int: prime_field_gen \"finite_field_ops_int p\" mod_ring_rel"], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops_int p) mod_ring_rel p", "by (rule prime_field_finite_field_ops_int)"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops_integer (integer_of_int p))\n     mod_ring_rel_integer p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops_integer (integer_of_int p))\n     mod_ring_rel_integer p", "by (unfold_locales, rule p, auto simp: finite_field_ops_integer_def \n      mod_ring_rel_integer_def[OF pp] urel_integer_def[OF pp] mod_ring_rel_of_int\n      int.to_int[symmetric] finite_field_ops_int_def)"], ["proof (state)\nthis:\n  prime_field_gen (finite_field_ops_integer (integer_of_int p))\n   mod_ring_rel_integer p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prime_field_finite_field_ops32: assumes small: \"p \\<le> 65535\" \n  shows \"prime_field_gen (finite_field_ops32 (uint32_of_int p)) mod_ring_rel32 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops32 (uint32_of_int p)) mod_ring_rel32 p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops32 (uint32_of_int p)) mod_ring_rel32 p", "let ?pp = \"uint32_of_int p\""], ["proof (state)\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops32 (uint32_of_int p)) mod_ring_rel32 p", "have ppp: \"p = int_of_uint32 ?pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = int_of_uint32 (uint32_of_int p)", "by (subst int_of_uint32_inv, insert small p2, auto)"], ["proof (state)\nthis:\n  p = int_of_uint32 (uint32_of_int p)\n\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops32 (uint32_of_int p)) mod_ring_rel32 p", "note * = ppp small"], ["proof (state)\nthis:\n  p = int_of_uint32 (uint32_of_int p)\n  p \\<le> 65535\n\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops32 (uint32_of_int p)) mod_ring_rel32 p", "interpret field_ops \"finite_field_ops32 ?pp\" mod_ring_rel32"], ["proof (prove)\ngoal (1 subgoal):\n 1. field_ops (finite_field_ops32 (uint32_of_int p)) mod_ring_rel32", "by (rule finite_field_ops32, insert *)"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops32 (uint32_of_int p)) mod_ring_rel32 p", "interpret int: prime_field_gen \"finite_field_ops_int p\" mod_ring_rel"], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops_int p) mod_ring_rel p", "by (rule prime_field_finite_field_ops_int)"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops32 (uint32_of_int p)) mod_ring_rel32 p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops32 (uint32_of_int p)) mod_ring_rel32 p", "proof (unfold_locales, rule p, auto simp: finite_field_ops32_def)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 (uint32_of_int x) (of_int x)\n 2. \\<And>y z.\n       mod_ring_rel32 y z \\<Longrightarrow>\n       int_of_uint32 y = to_int_mod_ring z\n 3. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 (uint32_of_int x) (of_int x)\n 2. \\<And>y z.\n       mod_ring_rel32 y z \\<Longrightarrow>\n       int_of_uint32 y = to_int_mod_ring z\n 3. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "assume x: \"0 \\<le> x\" \"x < p\""], ["proof (state)\nthis:\n  0 \\<le> x\n  x < p\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 (uint32_of_int x) (of_int x)\n 2. \\<And>y z.\n       mod_ring_rel32 y z \\<Longrightarrow>\n       int_of_uint32 y = to_int_mod_ring z\n 3. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "from int.of_int[OF this]"], ["proof (chain)\npicking this:\n  mod_ring_rel (arith_ops_record.of_int (finite_field_ops_int p) x)\n   (of_int x)", "have \"mod_ring_rel x (of_int x)\""], ["proof (prove)\nusing this:\n  mod_ring_rel (arith_ops_record.of_int (finite_field_ops_int p) x)\n   (of_int x)\n\ngoal (1 subgoal):\n 1. mod_ring_rel x (of_int x)", "by (simp add: finite_field_ops_int_def)"], ["proof (state)\nthis:\n  mod_ring_rel x (of_int x)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 (uint32_of_int x) (of_int x)\n 2. \\<And>y z.\n       mod_ring_rel32 y z \\<Longrightarrow>\n       int_of_uint32 y = to_int_mod_ring z\n 3. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "thus \"mod_ring_rel32 (uint32_of_int x) (of_int x)\""], ["proof (prove)\nusing this:\n  mod_ring_rel x (of_int x)\n\ngoal (1 subgoal):\n 1. mod_ring_rel32 (uint32_of_int x) (of_int x)", "unfolding mod_ring_rel32_def[OF *]"], ["proof (prove)\nusing this:\n  mod_ring_rel x (of_int x)\n\ngoal (1 subgoal):\n 1. \\<exists>z. urel32 (uint32_of_int x) z \\<and> mod_ring_rel z (of_int x)", "by (intro exI[of _ x], auto simp: urel32_def[OF *], subst int_of_uint32_inv, insert * x, auto)"], ["proof (state)\nthis:\n  mod_ring_rel32 (uint32_of_int x) (of_int x)\n\ngoal (2 subgoals):\n 1. \\<And>y z.\n       mod_ring_rel32 y z \\<Longrightarrow>\n       int_of_uint32 y = to_int_mod_ring z\n 2. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y z.\n       mod_ring_rel32 y z \\<Longrightarrow>\n       int_of_uint32 y = to_int_mod_ring z\n 2. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "fix y z"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y z.\n       mod_ring_rel32 y z \\<Longrightarrow>\n       int_of_uint32 y = to_int_mod_ring z\n 2. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "assume \"mod_ring_rel32 y z\""], ["proof (state)\nthis:\n  mod_ring_rel32 y z\n\ngoal (2 subgoals):\n 1. \\<And>y z.\n       mod_ring_rel32 y z \\<Longrightarrow>\n       int_of_uint32 y = to_int_mod_ring z\n 2. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "from this[unfolded mod_ring_rel32_def[OF *]]"], ["proof (chain)\npicking this:\n  \\<exists>za. urel32 y za \\<and> mod_ring_rel za z", "obtain x where yx: \"urel32 y x\" and xz: \"mod_ring_rel x z\""], ["proof (prove)\nusing this:\n  \\<exists>za. urel32 y za \\<and> mod_ring_rel za z\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>urel32 y x; mod_ring_rel x z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  urel32 y x\n  mod_ring_rel x z\n\ngoal (2 subgoals):\n 1. \\<And>y z.\n       mod_ring_rel32 y z \\<Longrightarrow>\n       int_of_uint32 y = to_int_mod_ring z\n 2. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "from int.to_int[OF xz]"], ["proof (chain)\npicking this:\n  arith_ops_record.to_int (finite_field_ops_int p) x = to_int_mod_ring z", "have zx: \"to_int_mod_ring z = x\""], ["proof (prove)\nusing this:\n  arith_ops_record.to_int (finite_field_ops_int p) x = to_int_mod_ring z\n\ngoal (1 subgoal):\n 1. to_int_mod_ring z = x", "by (simp add: finite_field_ops_int_def)"], ["proof (state)\nthis:\n  to_int_mod_ring z = x\n\ngoal (2 subgoals):\n 1. \\<And>y z.\n       mod_ring_rel32 y z \\<Longrightarrow>\n       int_of_uint32 y = to_int_mod_ring z\n 2. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "show \"int_of_uint32 y = to_int_mod_ring z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint32 y = to_int_mod_ring z", "unfolding zx"], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint32 y = x", "using yx"], ["proof (prove)\nusing this:\n  urel32 y x\n\ngoal (1 subgoal):\n 1. int_of_uint32 y = x", "unfolding urel32_def[OF *]"], ["proof (prove)\nusing this:\n  x = int_of_uint32 y \\<and> x < p\n\ngoal (1 subgoal):\n 1. int_of_uint32 y = x", "by simp"], ["proof (state)\nthis:\n  int_of_uint32 y = to_int_mod_ring z\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "show \"0 \\<le> int_of_uint32 y \\<Longrightarrow> int_of_uint32 y < p \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n    \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "unfolding mod_ring_rel32_def[OF *] urel32_def[OF *]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>z.\n                         (z = int_of_uint32 y \\<and> z < p) \\<and>\n                         mod_ring_rel z (of_int (int_of_uint32 y))", "by (intro exI[of _ \"int_of_uint32 y\"], auto simp: mod_ring_rel_of_int)"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n  \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prime_field_gen (finite_field_ops32 (uint32_of_int p)) mod_ring_rel32 p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prime_field_finite_field_ops64: assumes small: \"p \\<le> 4294967295\" \n  shows \"prime_field_gen (finite_field_ops64 (uint64_of_int p)) mod_ring_rel64 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops64 (uint64_of_int p)) mod_ring_rel64 p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops64 (uint64_of_int p)) mod_ring_rel64 p", "let ?pp = \"uint64_of_int p\""], ["proof (state)\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops64 (uint64_of_int p)) mod_ring_rel64 p", "have ppp: \"p = int_of_uint64 ?pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = int_of_uint64 (uint64_of_int p)", "by (subst int_of_uint64_inv, insert small p2, auto)"], ["proof (state)\nthis:\n  p = int_of_uint64 (uint64_of_int p)\n\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops64 (uint64_of_int p)) mod_ring_rel64 p", "note * = ppp small"], ["proof (state)\nthis:\n  p = int_of_uint64 (uint64_of_int p)\n  p \\<le> 4294967295\n\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops64 (uint64_of_int p)) mod_ring_rel64 p", "interpret field_ops \"finite_field_ops64 ?pp\" mod_ring_rel64"], ["proof (prove)\ngoal (1 subgoal):\n 1. field_ops (finite_field_ops64 (uint64_of_int p)) mod_ring_rel64", "by (rule finite_field_ops64, insert *)"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops64 (uint64_of_int p)) mod_ring_rel64 p", "interpret int: prime_field_gen \"finite_field_ops_int p\" mod_ring_rel"], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops_int p) mod_ring_rel p", "by (rule prime_field_finite_field_ops_int)"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops64 (uint64_of_int p)) mod_ring_rel64 p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_field_gen (finite_field_ops64 (uint64_of_int p)) mod_ring_rel64 p", "proof (unfold_locales, rule p, auto simp: finite_field_ops64_def)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 (uint64_of_int x) (of_int x)\n 2. \\<And>y z.\n       mod_ring_rel64 y z \\<Longrightarrow>\n       int_of_uint64 y = to_int_mod_ring z\n 3. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 (uint64_of_int x) (of_int x)\n 2. \\<And>y z.\n       mod_ring_rel64 y z \\<Longrightarrow>\n       int_of_uint64 y = to_int_mod_ring z\n 3. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "assume x: \"0 \\<le> x\" \"x < p\""], ["proof (state)\nthis:\n  0 \\<le> x\n  x < p\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 (uint64_of_int x) (of_int x)\n 2. \\<And>y z.\n       mod_ring_rel64 y z \\<Longrightarrow>\n       int_of_uint64 y = to_int_mod_ring z\n 3. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "from int.of_int[OF this]"], ["proof (chain)\npicking this:\n  mod_ring_rel (arith_ops_record.of_int (finite_field_ops_int p) x)\n   (of_int x)", "have \"mod_ring_rel x (of_int x)\""], ["proof (prove)\nusing this:\n  mod_ring_rel (arith_ops_record.of_int (finite_field_ops_int p) x)\n   (of_int x)\n\ngoal (1 subgoal):\n 1. mod_ring_rel x (of_int x)", "by (simp add: finite_field_ops_int_def)"], ["proof (state)\nthis:\n  mod_ring_rel x (of_int x)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 (uint64_of_int x) (of_int x)\n 2. \\<And>y z.\n       mod_ring_rel64 y z \\<Longrightarrow>\n       int_of_uint64 y = to_int_mod_ring z\n 3. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "thus \"mod_ring_rel64 (uint64_of_int x) (of_int x)\""], ["proof (prove)\nusing this:\n  mod_ring_rel x (of_int x)\n\ngoal (1 subgoal):\n 1. mod_ring_rel64 (uint64_of_int x) (of_int x)", "unfolding mod_ring_rel64_def[OF *]"], ["proof (prove)\nusing this:\n  mod_ring_rel x (of_int x)\n\ngoal (1 subgoal):\n 1. \\<exists>z. urel64 (uint64_of_int x) z \\<and> mod_ring_rel z (of_int x)", "by (intro exI[of _ x], auto simp: urel64_def[OF *], subst int_of_uint64_inv, insert * x, auto)"], ["proof (state)\nthis:\n  mod_ring_rel64 (uint64_of_int x) (of_int x)\n\ngoal (2 subgoals):\n 1. \\<And>y z.\n       mod_ring_rel64 y z \\<Longrightarrow>\n       int_of_uint64 y = to_int_mod_ring z\n 2. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y z.\n       mod_ring_rel64 y z \\<Longrightarrow>\n       int_of_uint64 y = to_int_mod_ring z\n 2. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "fix y z"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y z.\n       mod_ring_rel64 y z \\<Longrightarrow>\n       int_of_uint64 y = to_int_mod_ring z\n 2. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "assume \"mod_ring_rel64 y z\""], ["proof (state)\nthis:\n  mod_ring_rel64 y z\n\ngoal (2 subgoals):\n 1. \\<And>y z.\n       mod_ring_rel64 y z \\<Longrightarrow>\n       int_of_uint64 y = to_int_mod_ring z\n 2. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "from this[unfolded mod_ring_rel64_def[OF *]]"], ["proof (chain)\npicking this:\n  \\<exists>za. urel64 y za \\<and> mod_ring_rel za z", "obtain x where yx: \"urel64 y x\" and xz: \"mod_ring_rel x z\""], ["proof (prove)\nusing this:\n  \\<exists>za. urel64 y za \\<and> mod_ring_rel za z\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>urel64 y x; mod_ring_rel x z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  urel64 y x\n  mod_ring_rel x z\n\ngoal (2 subgoals):\n 1. \\<And>y z.\n       mod_ring_rel64 y z \\<Longrightarrow>\n       int_of_uint64 y = to_int_mod_ring z\n 2. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "from int.to_int[OF xz]"], ["proof (chain)\npicking this:\n  arith_ops_record.to_int (finite_field_ops_int p) x = to_int_mod_ring z", "have zx: \"to_int_mod_ring z = x\""], ["proof (prove)\nusing this:\n  arith_ops_record.to_int (finite_field_ops_int p) x = to_int_mod_ring z\n\ngoal (1 subgoal):\n 1. to_int_mod_ring z = x", "by (simp add: finite_field_ops_int_def)"], ["proof (state)\nthis:\n  to_int_mod_ring z = x\n\ngoal (2 subgoals):\n 1. \\<And>y z.\n       mod_ring_rel64 y z \\<Longrightarrow>\n       int_of_uint64 y = to_int_mod_ring z\n 2. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "show \"int_of_uint64 y = to_int_mod_ring z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint64 y = to_int_mod_ring z", "unfolding zx"], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint64 y = x", "using yx"], ["proof (prove)\nusing this:\n  urel64 y x\n\ngoal (1 subgoal):\n 1. int_of_uint64 y = x", "unfolding urel64_def[OF *]"], ["proof (prove)\nusing this:\n  x = int_of_uint64 y \\<and> x < p\n\ngoal (1 subgoal):\n 1. int_of_uint64 y = x", "by simp"], ["proof (state)\nthis:\n  int_of_uint64 y = to_int_mod_ring z\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "show \"0 \\<le> int_of_uint64 y \\<Longrightarrow> int_of_uint64 y < p \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n    \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "unfolding mod_ring_rel64_def[OF *] urel64_def[OF *]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>z.\n                         (z = int_of_uint64 y \\<and> z < p) \\<and>\n                         mod_ring_rel z (of_int (int_of_uint64 y))", "by (intro exI[of _ \"int_of_uint64 y\"], auto simp: mod_ring_rel_of_int)"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n  \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prime_field_gen (finite_field_ops64 (uint64_of_int p)) mod_ring_rel64 p\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context mod_ring_locale\nbegin"], ["", "lemma mod_ring_finite_field_ops_int: \"mod_ring_gen (finite_field_ops_int p) mod_ring_rel p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops_int p) mod_ring_rel p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops_int p) mod_ring_rel p", "interpret ring_ops \"finite_field_ops_int p\" mod_ring_rel"], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_ops (finite_field_ops_int p) mod_ring_rel", "by (rule ring_finite_field_ops_int)"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops_int p) mod_ring_rel p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops_int p) mod_ring_rel p", "by (unfold_locales, rule p, \n      auto simp: finite_field_ops_int_def p mod_ring_rel_def of_int_of_int_mod_ring)"], ["proof (state)\nthis:\n  mod_ring_gen (finite_field_ops_int p) mod_ring_rel p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mod_ring_finite_field_ops_integer: \"mod_ring_gen (finite_field_ops_integer (integer_of_int p)) mod_ring_rel_integer p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops_integer (integer_of_int p))\n     mod_ring_rel_integer p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops_integer (integer_of_int p))\n     mod_ring_rel_integer p", "interpret ring_ops \"finite_field_ops_integer (integer_of_int p)\" mod_ring_rel_integer"], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_ops (finite_field_ops_integer (integer_of_int p))\n     mod_ring_rel_integer", "by (rule ring_finite_field_ops_integer, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops_integer (integer_of_int p))\n     mod_ring_rel_integer p", "have pp: \"p = int_of_integer (integer_of_int p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = int_of_integer (integer_of_int p)", "by auto"], ["proof (state)\nthis:\n  p = int_of_integer (integer_of_int p)\n\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops_integer (integer_of_int p))\n     mod_ring_rel_integer p", "interpret int: mod_ring_gen \"finite_field_ops_int p\" mod_ring_rel"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops_int p) mod_ring_rel p", "by (rule mod_ring_finite_field_ops_int)"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops_integer (integer_of_int p))\n     mod_ring_rel_integer p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops_integer (integer_of_int p))\n     mod_ring_rel_integer p", "by (unfold_locales, rule p, auto simp: finite_field_ops_integer_def \n      mod_ring_rel_integer_def[OF pp] urel_integer_def[OF pp] mod_ring_rel_of_int\n      int.to_int[symmetric] finite_field_ops_int_def)"], ["proof (state)\nthis:\n  mod_ring_gen (finite_field_ops_integer (integer_of_int p))\n   mod_ring_rel_integer p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mod_ring_finite_field_ops32: assumes small: \"p \\<le> 65535\" \n  shows \"mod_ring_gen (finite_field_ops32 (uint32_of_int p)) mod_ring_rel32 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops32 (uint32_of_int p)) mod_ring_rel32 p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops32 (uint32_of_int p)) mod_ring_rel32 p", "let ?pp = \"uint32_of_int p\""], ["proof (state)\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops32 (uint32_of_int p)) mod_ring_rel32 p", "have ppp: \"p = int_of_uint32 ?pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = int_of_uint32 (uint32_of_int p)", "by (subst int_of_uint32_inv, insert small p2, auto)"], ["proof (state)\nthis:\n  p = int_of_uint32 (uint32_of_int p)\n\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops32 (uint32_of_int p)) mod_ring_rel32 p", "note * = ppp small"], ["proof (state)\nthis:\n  p = int_of_uint32 (uint32_of_int p)\n  p \\<le> 65535\n\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops32 (uint32_of_int p)) mod_ring_rel32 p", "interpret ring_ops \"finite_field_ops32 ?pp\" mod_ring_rel32"], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_ops (finite_field_ops32 (uint32_of_int p)) mod_ring_rel32", "by (rule ring_finite_field_ops32, insert *)"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops32 (uint32_of_int p)) mod_ring_rel32 p", "interpret int: mod_ring_gen \"finite_field_ops_int p\" mod_ring_rel"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops_int p) mod_ring_rel p", "by (rule mod_ring_finite_field_ops_int)"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops32 (uint32_of_int p)) mod_ring_rel32 p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops32 (uint32_of_int p)) mod_ring_rel32 p", "proof (unfold_locales, rule p, auto simp: finite_field_ops32_def)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 (uint32_of_int x) (of_int x)\n 2. \\<And>y z.\n       mod_ring_rel32 y z \\<Longrightarrow>\n       int_of_uint32 y = to_int_mod_ring z\n 3. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 (uint32_of_int x) (of_int x)\n 2. \\<And>y z.\n       mod_ring_rel32 y z \\<Longrightarrow>\n       int_of_uint32 y = to_int_mod_ring z\n 3. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "assume x: \"0 \\<le> x\" \"x < p\""], ["proof (state)\nthis:\n  0 \\<le> x\n  x < p\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 (uint32_of_int x) (of_int x)\n 2. \\<And>y z.\n       mod_ring_rel32 y z \\<Longrightarrow>\n       int_of_uint32 y = to_int_mod_ring z\n 3. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "from int.of_int[OF this]"], ["proof (chain)\npicking this:\n  mod_ring_rel (arith_ops_record.of_int (finite_field_ops_int p) x)\n   (of_int x)", "have \"mod_ring_rel x (of_int x)\""], ["proof (prove)\nusing this:\n  mod_ring_rel (arith_ops_record.of_int (finite_field_ops_int p) x)\n   (of_int x)\n\ngoal (1 subgoal):\n 1. mod_ring_rel x (of_int x)", "by (simp add: finite_field_ops_int_def)"], ["proof (state)\nthis:\n  mod_ring_rel x (of_int x)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 (uint32_of_int x) (of_int x)\n 2. \\<And>y z.\n       mod_ring_rel32 y z \\<Longrightarrow>\n       int_of_uint32 y = to_int_mod_ring z\n 3. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "thus \"mod_ring_rel32 (uint32_of_int x) (of_int x)\""], ["proof (prove)\nusing this:\n  mod_ring_rel x (of_int x)\n\ngoal (1 subgoal):\n 1. mod_ring_rel32 (uint32_of_int x) (of_int x)", "unfolding mod_ring_rel32_def[OF *]"], ["proof (prove)\nusing this:\n  mod_ring_rel x (of_int x)\n\ngoal (1 subgoal):\n 1. \\<exists>z. urel32 (uint32_of_int x) z \\<and> mod_ring_rel z (of_int x)", "by (intro exI[of _ x], auto simp: urel32_def[OF *], subst int_of_uint32_inv, insert * x, auto)"], ["proof (state)\nthis:\n  mod_ring_rel32 (uint32_of_int x) (of_int x)\n\ngoal (2 subgoals):\n 1. \\<And>y z.\n       mod_ring_rel32 y z \\<Longrightarrow>\n       int_of_uint32 y = to_int_mod_ring z\n 2. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y z.\n       mod_ring_rel32 y z \\<Longrightarrow>\n       int_of_uint32 y = to_int_mod_ring z\n 2. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "fix y z"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y z.\n       mod_ring_rel32 y z \\<Longrightarrow>\n       int_of_uint32 y = to_int_mod_ring z\n 2. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "assume \"mod_ring_rel32 y z\""], ["proof (state)\nthis:\n  mod_ring_rel32 y z\n\ngoal (2 subgoals):\n 1. \\<And>y z.\n       mod_ring_rel32 y z \\<Longrightarrow>\n       int_of_uint32 y = to_int_mod_ring z\n 2. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "from this[unfolded mod_ring_rel32_def[OF *]]"], ["proof (chain)\npicking this:\n  \\<exists>za. urel32 y za \\<and> mod_ring_rel za z", "obtain x where yx: \"urel32 y x\" and xz: \"mod_ring_rel x z\""], ["proof (prove)\nusing this:\n  \\<exists>za. urel32 y za \\<and> mod_ring_rel za z\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>urel32 y x; mod_ring_rel x z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  urel32 y x\n  mod_ring_rel x z\n\ngoal (2 subgoals):\n 1. \\<And>y z.\n       mod_ring_rel32 y z \\<Longrightarrow>\n       int_of_uint32 y = to_int_mod_ring z\n 2. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "from int.to_int[OF xz]"], ["proof (chain)\npicking this:\n  arith_ops_record.to_int (finite_field_ops_int p) x = to_int_mod_ring z", "have zx: \"to_int_mod_ring z = x\""], ["proof (prove)\nusing this:\n  arith_ops_record.to_int (finite_field_ops_int p) x = to_int_mod_ring z\n\ngoal (1 subgoal):\n 1. to_int_mod_ring z = x", "by (simp add: finite_field_ops_int_def)"], ["proof (state)\nthis:\n  to_int_mod_ring z = x\n\ngoal (2 subgoals):\n 1. \\<And>y z.\n       mod_ring_rel32 y z \\<Longrightarrow>\n       int_of_uint32 y = to_int_mod_ring z\n 2. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "show \"int_of_uint32 y = to_int_mod_ring z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint32 y = to_int_mod_ring z", "unfolding zx"], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint32 y = x", "using yx"], ["proof (prove)\nusing this:\n  urel32 y x\n\ngoal (1 subgoal):\n 1. int_of_uint32 y = x", "unfolding urel32_def[OF *]"], ["proof (prove)\nusing this:\n  x = int_of_uint32 y \\<and> x < p\n\ngoal (1 subgoal):\n 1. int_of_uint32 y = x", "by simp"], ["proof (state)\nthis:\n  int_of_uint32 y = to_int_mod_ring z\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "show \"0 \\<le> int_of_uint32 y \\<Longrightarrow> int_of_uint32 y < p \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n    \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))", "unfolding mod_ring_rel32_def[OF *] urel32_def[OF *]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>z.\n                         (z = int_of_uint32 y \\<and> z < p) \\<and>\n                         mod_ring_rel z (of_int (int_of_uint32 y))", "by (intro exI[of _ \"int_of_uint32 y\"], auto simp: mod_ring_rel_of_int)"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> int_of_uint32 y; int_of_uint32 y < p\\<rbrakk>\n  \\<Longrightarrow> mod_ring_rel32 y (of_int (int_of_uint32 y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_ring_gen (finite_field_ops32 (uint32_of_int p)) mod_ring_rel32 p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mod_ring_finite_field_ops64: assumes small: \"p \\<le> 4294967295\" \n  shows \"mod_ring_gen (finite_field_ops64 (uint64_of_int p)) mod_ring_rel64 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops64 (uint64_of_int p)) mod_ring_rel64 p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops64 (uint64_of_int p)) mod_ring_rel64 p", "let ?pp = \"uint64_of_int p\""], ["proof (state)\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops64 (uint64_of_int p)) mod_ring_rel64 p", "have ppp: \"p = int_of_uint64 ?pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = int_of_uint64 (uint64_of_int p)", "by (subst int_of_uint64_inv, insert small p2, auto)"], ["proof (state)\nthis:\n  p = int_of_uint64 (uint64_of_int p)\n\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops64 (uint64_of_int p)) mod_ring_rel64 p", "note * = ppp small"], ["proof (state)\nthis:\n  p = int_of_uint64 (uint64_of_int p)\n  p \\<le> 4294967295\n\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops64 (uint64_of_int p)) mod_ring_rel64 p", "interpret ring_ops \"finite_field_ops64 ?pp\" mod_ring_rel64"], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_ops (finite_field_ops64 (uint64_of_int p)) mod_ring_rel64", "by (rule ring_finite_field_ops64, insert *)"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops64 (uint64_of_int p)) mod_ring_rel64 p", "interpret int: mod_ring_gen \"finite_field_ops_int p\" mod_ring_rel"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops_int p) mod_ring_rel p", "by (rule mod_ring_finite_field_ops_int)"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops64 (uint64_of_int p)) mod_ring_rel64 p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_ring_gen (finite_field_ops64 (uint64_of_int p)) mod_ring_rel64 p", "proof (unfold_locales, rule p, auto simp: finite_field_ops64_def)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 (uint64_of_int x) (of_int x)\n 2. \\<And>y z.\n       mod_ring_rel64 y z \\<Longrightarrow>\n       int_of_uint64 y = to_int_mod_ring z\n 3. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 (uint64_of_int x) (of_int x)\n 2. \\<And>y z.\n       mod_ring_rel64 y z \\<Longrightarrow>\n       int_of_uint64 y = to_int_mod_ring z\n 3. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "assume x: \"0 \\<le> x\" \"x < p\""], ["proof (state)\nthis:\n  0 \\<le> x\n  x < p\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 (uint64_of_int x) (of_int x)\n 2. \\<And>y z.\n       mod_ring_rel64 y z \\<Longrightarrow>\n       int_of_uint64 y = to_int_mod_ring z\n 3. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "from int.of_int[OF this]"], ["proof (chain)\npicking this:\n  mod_ring_rel (arith_ops_record.of_int (finite_field_ops_int p) x)\n   (of_int x)", "have \"mod_ring_rel x (of_int x)\""], ["proof (prove)\nusing this:\n  mod_ring_rel (arith_ops_record.of_int (finite_field_ops_int p) x)\n   (of_int x)\n\ngoal (1 subgoal):\n 1. mod_ring_rel x (of_int x)", "by (simp add: finite_field_ops_int_def)"], ["proof (state)\nthis:\n  mod_ring_rel x (of_int x)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 (uint64_of_int x) (of_int x)\n 2. \\<And>y z.\n       mod_ring_rel64 y z \\<Longrightarrow>\n       int_of_uint64 y = to_int_mod_ring z\n 3. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "thus \"mod_ring_rel64 (uint64_of_int x) (of_int x)\""], ["proof (prove)\nusing this:\n  mod_ring_rel x (of_int x)\n\ngoal (1 subgoal):\n 1. mod_ring_rel64 (uint64_of_int x) (of_int x)", "unfolding mod_ring_rel64_def[OF *]"], ["proof (prove)\nusing this:\n  mod_ring_rel x (of_int x)\n\ngoal (1 subgoal):\n 1. \\<exists>z. urel64 (uint64_of_int x) z \\<and> mod_ring_rel z (of_int x)", "by (intro exI[of _ x], auto simp: urel64_def[OF *], subst int_of_uint64_inv, insert * x, auto)"], ["proof (state)\nthis:\n  mod_ring_rel64 (uint64_of_int x) (of_int x)\n\ngoal (2 subgoals):\n 1. \\<And>y z.\n       mod_ring_rel64 y z \\<Longrightarrow>\n       int_of_uint64 y = to_int_mod_ring z\n 2. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y z.\n       mod_ring_rel64 y z \\<Longrightarrow>\n       int_of_uint64 y = to_int_mod_ring z\n 2. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "fix y z"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y z.\n       mod_ring_rel64 y z \\<Longrightarrow>\n       int_of_uint64 y = to_int_mod_ring z\n 2. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "assume \"mod_ring_rel64 y z\""], ["proof (state)\nthis:\n  mod_ring_rel64 y z\n\ngoal (2 subgoals):\n 1. \\<And>y z.\n       mod_ring_rel64 y z \\<Longrightarrow>\n       int_of_uint64 y = to_int_mod_ring z\n 2. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "from this[unfolded mod_ring_rel64_def[OF *]]"], ["proof (chain)\npicking this:\n  \\<exists>za. urel64 y za \\<and> mod_ring_rel za z", "obtain x where yx: \"urel64 y x\" and xz: \"mod_ring_rel x z\""], ["proof (prove)\nusing this:\n  \\<exists>za. urel64 y za \\<and> mod_ring_rel za z\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>urel64 y x; mod_ring_rel x z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  urel64 y x\n  mod_ring_rel x z\n\ngoal (2 subgoals):\n 1. \\<And>y z.\n       mod_ring_rel64 y z \\<Longrightarrow>\n       int_of_uint64 y = to_int_mod_ring z\n 2. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "from int.to_int[OF xz]"], ["proof (chain)\npicking this:\n  arith_ops_record.to_int (finite_field_ops_int p) x = to_int_mod_ring z", "have zx: \"to_int_mod_ring z = x\""], ["proof (prove)\nusing this:\n  arith_ops_record.to_int (finite_field_ops_int p) x = to_int_mod_ring z\n\ngoal (1 subgoal):\n 1. to_int_mod_ring z = x", "by (simp add: finite_field_ops_int_def)"], ["proof (state)\nthis:\n  to_int_mod_ring z = x\n\ngoal (2 subgoals):\n 1. \\<And>y z.\n       mod_ring_rel64 y z \\<Longrightarrow>\n       int_of_uint64 y = to_int_mod_ring z\n 2. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "show \"int_of_uint64 y = to_int_mod_ring z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint64 y = to_int_mod_ring z", "unfolding zx"], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_uint64 y = x", "using yx"], ["proof (prove)\nusing this:\n  urel64 y x\n\ngoal (1 subgoal):\n 1. int_of_uint64 y = x", "unfolding urel64_def[OF *]"], ["proof (prove)\nusing this:\n  x = int_of_uint64 y \\<and> x < p\n\ngoal (1 subgoal):\n 1. int_of_uint64 y = x", "by simp"], ["proof (state)\nthis:\n  int_of_uint64 y = to_int_mod_ring z\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n       \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "show \"0 \\<le> int_of_uint64 y \\<Longrightarrow> int_of_uint64 y < p \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n    \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))", "unfolding mod_ring_rel64_def[OF *] urel64_def[OF *]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>z.\n                         (z = int_of_uint64 y \\<and> z < p) \\<and>\n                         mod_ring_rel z (of_int (int_of_uint64 y))", "by (intro exI[of _ \"int_of_uint64 y\"], auto simp: mod_ring_rel_of_int)"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> int_of_uint64 y; int_of_uint64 y < p\\<rbrakk>\n  \\<Longrightarrow> mod_ring_rel64 y (of_int (int_of_uint64 y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_ring_gen (finite_field_ops64 (uint64_of_int p)) mod_ring_rel64 p\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}