{"file_name": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus/Poly_Mod_Finite_Field.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus", "problem_names": ["lemma mset_transfer[transfer_rule]: \"(list_all2 rel ===> rel_mset rel) mset mset\"", "lemma irreducible\\<^sub>d_def_0:\n  fixes f :: \"'a :: {comm_semiring_1,semiring_no_zero_divisors} poly\"\n  shows \"irreducible\\<^sub>d f = (degree f \\<noteq> 0 \\<and> \n  (\\<forall> g h. degree g \\<noteq> 0 \\<longrightarrow> degree h \\<noteq> 0 \\<longrightarrow> f \\<noteq> g * h))\"", "lemma m1: \"m > 1\"", "lemma to_int_mod_ring_plus: \"to_int_mod_ring ((x :: 'a mod_ring) + y) = M (to_int_mod_ring x + to_int_mod_ring y)\"", "lemma to_int_mod_ring_times: \"to_int_mod_ring ((x :: 'a mod_ring) * y) = M (to_int_mod_ring x * to_int_mod_ring y)\"", "lemma degree_MP_Rel [transfer_rule]: \"(MP_Rel ===> (=)) degree_m degree\"", "lemma eq_M_Rel[transfer_rule]: \"(M_Rel ===> M_Rel ===> (=)) (\\<lambda> x y. M x = M y) (=)\"", "lemma eq_MP_Rel[transfer_rule]: \"(MP_Rel ===> MP_Rel ===> (=)) (=m) (=)\"", "lemma eq_Mf_Rel[transfer_rule]: \"(MF_Rel ===> MF_Rel ===> (=)) (\\<lambda> x y. Mf x = Mf y) (=)\"", "lemmas coeff_map_poly_of_int = coeff_map_poly[of of_int, OF of_int_0]", "lemma plus_MP_Rel[transfer_rule]: \"(MP_Rel ===> MP_Rel ===> MP_Rel) (+) (+)\"", "lemma times_MP_Rel[transfer_rule]: \"(MP_Rel ===> MP_Rel ===> MP_Rel) ((*)) ((*))\"", "lemma smult_MP_Rel[transfer_rule]: \"(M_Rel ===> MP_Rel ===> MP_Rel) smult smult\"", "lemma one_M_Rel[transfer_rule]: \"M_Rel 1 1\"", "lemma one_MP_Rel[transfer_rule]: \"MP_Rel 1 1\"", "lemma zero_M_Rel[transfer_rule]: \"M_Rel 0 0\"", "lemma zero_MP_Rel[transfer_rule]: \"MP_Rel 0 0\"", "lemma listprod_MP_Rel[transfer_rule]: \"(list_all2 MP_Rel ===> MP_Rel) prod_list prod_list\"", "lemma prod_mset_MP_Rel[transfer_rule]: \"(rel_mset MP_Rel ===> MP_Rel) prod_mset prod_mset\"", "lemma right_unique_MP_Rel[transfer_rule]: \"right_unique MP_Rel\"", "lemma M_to_int_mod_ring: \"M (to_int_mod_ring (x :: 'a mod_ring)) = to_int_mod_ring x\"", "lemma Mp_to_int_poly: \"Mp (to_int_poly (f :: 'a mod_ring poly)) = to_int_poly f\"", "lemma right_total_M_Rel[transfer_rule]: \"right_total M_Rel\"", "lemma left_total_M_Rel[transfer_rule]: \"left_total M_Rel\"", "lemma bi_total_M_Rel[transfer_rule]: \"bi_total M_Rel\"", "lemma right_total_MP_Rel[transfer_rule]: \"right_total MP_Rel\"", "lemma to_int_mod_ring_of_int_M: \"to_int_mod_ring (of_int x :: 'a mod_ring) = M x\"", "lemma Mp_f_representative: \"Mp f = to_int_poly (map_poly of_int f :: 'a mod_ring poly)\"", "lemma left_total_MP_Rel[transfer_rule]: \"left_total MP_Rel\"", "lemma bi_total_MP_Rel[transfer_rule]: \"bi_total MP_Rel\"", "lemma bi_total_MF_Rel[transfer_rule]: \"bi_total MF_Rel\"", "lemma right_total_MF_Rel[transfer_rule]: \"right_total MF_Rel\"", "lemma left_total_MF_Rel[transfer_rule]: \"left_total MF_Rel\"", "lemma domain_RT_rel[transfer_domain_rule]: \"Domainp MP_Rel = (\\<lambda> f. True)\"", "lemma mem_MP_Rel[transfer_rule]: \"(MP_Rel ===> rel_set MP_Rel ===> (=)) (\\<lambda> x Y. \\<exists>y \\<in> Y. eq_m x y) (\\<in>)\"", "lemma conversep_MP_Rel_OO_MP_Rel [simp]: \"MP_Rel\\<inverse>\\<inverse> OO MP_Rel = (=)\"", "lemma MP_Rel_OO_conversep_MP_Rel [simp]: \"MP_Rel OO MP_Rel\\<inverse>\\<inverse> = eq_m\"", "lemma conversep_MP_Rel_OO_eq_m [simp]: \"MP_Rel\\<inverse>\\<inverse> OO eq_m = MP_Rel\\<inverse>\\<inverse>\"", "lemma eq_m_OO_MP_Rel [simp]: \"eq_m OO MP_Rel = MP_Rel\"", "lemma eq_mset_MP_Rel [transfer_rule]: \"(rel_mset MP_Rel ===> rel_mset MP_Rel ===> (=)) (rel_mset eq_m) (=)\"", "lemma dvd_MP_Rel[transfer_rule]: \"(MP_Rel ===> MP_Rel ===> (=)) (dvdm) (dvd)\"", "lemma irreducible_MP_Rel [transfer_rule]: \"(MP_Rel ===> (=)) irreducible_m irreducible\"", "lemma irreducible\\<^sub>d_MP_Rel [transfer_rule]: \"(MP_Rel ===> (=)) irreducible\\<^sub>d_m irreducible\\<^sub>d\"", "lemma UNIV_M_Rel[transfer_rule]: \"rel_set M_Rel {0..<m} UNIV\"", "lemma coeff_MP_Rel [transfer_rule]: \"(MP_Rel ===> (=) ===> M_Rel) coeff coeff\"", "lemma M_1_1: \"M 1 = 1\"", "lemma square_free_MP_Rel [transfer_rule]: \"(MP_Rel ===> (=)) square_free_m square_free\"", "lemma mset_factors_m_MP_Rel [transfer_rule]: \"(rel_mset MP_Rel ===> MP_Rel ===> (=)) mset_factors_m mset_factors\"", "lemma coprime_MP_Rel [transfer_rule]: \"(MP_Rel ===> MP_Rel ===> (=)) coprime_m coprime\"", "lemma prime_elem_MP_Rel [transfer_rule]: \"(MP_Rel ===> (=)) prime_elem_m prime_elem\"", "lemma non_empty: \"{0..<m} \\<noteq> {}\"", "lemma type_to_set:\n  assumes type_def: \"\\<exists>(Rep :: 'b \\<Rightarrow> int) Abs. type_definition Rep Abs {0 ..< m :: int}\"\n  shows \"class.nontriv (TYPE('b))\" (is ?a) and \"m = int CARD('b)\" (is ?b)", "lemma factorization_MP_Rel [transfer_rule]:\n  \"(MP_Rel ===> MF_Rel ===> (=)) factorization_m (factorization Irr_Mon)\"", "lemma unique_factorization_MP_Rel [transfer_rule]: \"(MP_Rel ===> MF_Rel ===> (=))\n  unique_factorization_m (unique_factorization Irr_Mon)\"", "lemma 1: \"poly_mod_type TYPE('a :: nontriv) m = (m = int CARD('a))\"\n  and 2: \"class.nontriv TYPE('a) = (CARD('a) \\<ge> 2)\"", "lemma 3: \"poly_mod_prime_type TYPE('b) m = (m = int CARD('b))\"\n  and 4: \"class.prime_card TYPE('b :: prime_card) = prime CARD('b :: prime_card)\"", "lemmas poly_mod_type_simps = 1 2 3 4", "lemma remove_duplicate_premise: \"(PROP P \\<Longrightarrow> PROP P \\<Longrightarrow> PROP Q) \\<equiv> (PROP P \\<Longrightarrow> PROP Q)\" (is \"?l \\<equiv> ?r\")", "lemma type_to_set:\n  assumes type_def: \"\\<exists>(Rep :: 'b \\<Rightarrow> int) Abs. type_definition Rep Abs {0 ..< p :: int}\"\n  shows \"class.prime_card (TYPE('b))\" (is ?a) and \"p = int CARD('b)\" (is ?b)", "lemmas (in poly_mod_type) prime_elem_m_dvdm_multD = prime_elem_dvd_multD\n  [where 'a = \"'a mod_ring poly\",untransferred]", "lemmas (in poly_mod_2) prime_elem_m_dvdm_multD = poly_mod_type.prime_elem_m_dvdm_multD\n  [unfolded poly_mod_type_simps, internalize_sort \"'a :: nontriv\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]", "lemmas(in poly_mod_prime_type) degree_m_mult_eq = degree_mult_eq\n  [where 'a = \"'a mod_ring\", untransferred]", "lemmas(in poly_mod_prime) degree_m_mult_eq = poly_mod_prime_type.degree_m_mult_eq\n  [unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]", "lemma(in poly_mod_prime) irreducible\\<^sub>d_lifting:\n  assumes n: \"n \\<noteq> 0\"\n    and deg: \"poly_mod.degree_m (p^n) f = degree_m f\"\n    and irr: \"irreducible\\<^sub>d_m f\"\n  shows \"poly_mod.irreducible\\<^sub>d_m (p^n) f\"", "lemmas (in poly_mod_prime_type) mset_factors_exist =\n  mset_factors_exist[where 'a = \"'a mod_ring poly\",untransferred]", "lemmas (in poly_mod_prime) mset_factors_exist = poly_mod_prime_type.mset_factors_exist\n  [unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]", "lemmas (in poly_mod_prime_type) mset_factors_unique =\n  mset_factors_unique[where 'a = \"'a mod_ring poly\",untransferred]", "lemmas (in poly_mod_prime) mset_factors_unique = poly_mod_prime_type.mset_factors_unique\n  [unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]", "lemmas (in poly_mod_prime_type) prime_elem_iff_irreducible =\n  prime_elem_iff_irreducible[where 'a = \"'a mod_ring poly\",untransferred]", "lemmas (in poly_mod_prime) prime_elem_iff_irreducible[simp] = poly_mod_prime_type.prime_elem_iff_irreducible\n  [unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]", "lemmas (in poly_mod_prime_type) irreducible_connect =\n  irreducible_connect_field[where 'a = \"'a mod_ring\", untransferred]", "lemmas (in poly_mod_prime) irreducible_connect[simp] = poly_mod_prime_type.irreducible_connect\n  [unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]", "lemmas (in poly_mod_prime_type) irreducible_degree =\n  irreducible_degree_field[where 'a = \"'a mod_ring\", untransferred]", "lemmas (in poly_mod_prime) irreducible_degree = poly_mod_prime_type.irreducible_degree\n  [unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]"], "translations": [["", "lemma mset_transfer[transfer_rule]: \"(list_all2 rel ===> rel_mset rel) mset mset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_all2 rel ===> rel_mset rel) mset mset", "proof (intro rel_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       list_all2 rel x y \\<Longrightarrow> rel_mset rel (mset x) (mset y)", "show \"list_all2 rel xs ys \\<Longrightarrow> rel_mset rel (mset xs) (mset ys)\" for xs ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 rel xs ys \\<Longrightarrow> rel_mset rel (mset xs) (mset ys)", "proof (induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       list_all2 rel [] ys \\<Longrightarrow>\n       rel_mset rel (mset []) (mset ys)\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   list_all2 rel xs ys \\<Longrightarrow>\n                   rel_mset rel (mset xs) (mset ys);\n        list_all2 rel (a # xs) ys\\<rbrakk>\n       \\<Longrightarrow> rel_mset rel (mset (a # xs)) (mset ys)", "case Nil"], ["proof (state)\nthis:\n  list_all2 rel [] ys\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       list_all2 rel [] ys \\<Longrightarrow>\n       rel_mset rel (mset []) (mset ys)\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   list_all2 rel xs ys \\<Longrightarrow>\n                   rel_mset rel (mset xs) (mset ys);\n        list_all2 rel (a # xs) ys\\<rbrakk>\n       \\<Longrightarrow> rel_mset rel (mset (a # xs)) (mset ys)", "then"], ["proof (chain)\npicking this:\n  list_all2 rel [] ys", "show ?case"], ["proof (prove)\nusing this:\n  list_all2 rel [] ys\n\ngoal (1 subgoal):\n 1. rel_mset rel (mset []) (mset ys)", "by auto"], ["proof (state)\nthis:\n  rel_mset rel (mset []) (mset ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   list_all2 rel xs ys \\<Longrightarrow>\n                   rel_mset rel (mset xs) (mset ys);\n        list_all2 rel (a # xs) ys\\<rbrakk>\n       \\<Longrightarrow> rel_mset rel (mset (a # xs)) (mset ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   list_all2 rel xs ys \\<Longrightarrow>\n                   rel_mset rel (mset xs) (mset ys);\n        list_all2 rel (a # xs) ys\\<rbrakk>\n       \\<Longrightarrow> rel_mset rel (mset (a # xs)) (mset ys)", "case IH: (Cons x xs)"], ["proof (state)\nthis:\n  list_all2 rel xs ?ys \\<Longrightarrow> rel_mset rel (mset xs) (mset ?ys)\n  list_all2 rel (x # xs) ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   list_all2 rel xs ys \\<Longrightarrow>\n                   rel_mset rel (mset xs) (mset ys);\n        list_all2 rel (a # xs) ys\\<rbrakk>\n       \\<Longrightarrow> rel_mset rel (mset (a # xs)) (mset ys)", "then"], ["proof (chain)\npicking this:\n  list_all2 rel xs ?ys \\<Longrightarrow> rel_mset rel (mset xs) (mset ?ys)\n  list_all2 rel (x # xs) ys", "show ?case"], ["proof (prove)\nusing this:\n  list_all2 rel xs ?ys \\<Longrightarrow> rel_mset rel (mset xs) (mset ?ys)\n  list_all2 rel (x # xs) ys\n\ngoal (1 subgoal):\n 1. rel_mset rel (mset (x # xs)) (mset ys)", "by (auto dest!:msed_rel_invL simp: list_all2_Cons1 intro!:rel_mset_Plus)"], ["proof (state)\nthis:\n  rel_mset rel (mset (x # xs)) (mset ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all2 rel ?xs ?ys \\<Longrightarrow> rel_mset rel (mset ?xs) (mset ?ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation to_int_poly :: \"'a :: finite mod_ring poly \\<Rightarrow> int poly\" where\n  \"to_int_poly \\<equiv> map_poly to_int_mod_ring\""], ["", "interpretation to_int_poly_hom: map_poly_inj_zero_hom to_int_mod_ring"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_zero_hom to_int_mod_ring", ".."], ["", "lemma irreducible\\<^sub>d_def_0:\n  fixes f :: \"'a :: {comm_semiring_1,semiring_no_zero_divisors} poly\"\n  shows \"irreducible\\<^sub>d f = (degree f \\<noteq> 0 \\<and> \n  (\\<forall> g h. degree g \\<noteq> 0 \\<longrightarrow> degree h \\<noteq> 0 \\<longrightarrow> f \\<noteq> g * h))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d f =\n    (degree f \\<noteq> 0 \\<and>\n     (\\<forall>g h.\n         degree g \\<noteq> 0 \\<longrightarrow>\n         degree h \\<noteq> 0 \\<longrightarrow> f \\<noteq> g * h))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d f =\n    (degree f \\<noteq> 0 \\<and>\n     (\\<forall>g h.\n         degree g \\<noteq> 0 \\<longrightarrow>\n         degree h \\<noteq> 0 \\<longrightarrow> f \\<noteq> g * h))", "have \"degree g \\<noteq> 0 \\<Longrightarrow> g \\<noteq> 0\" for g :: \"'a poly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree g \\<noteq> 0 \\<Longrightarrow> g \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  degree ?g \\<noteq> 0 \\<Longrightarrow> ?g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d f =\n    (degree f \\<noteq> 0 \\<and>\n     (\\<forall>g h.\n         degree g \\<noteq> 0 \\<longrightarrow>\n         degree h \\<noteq> 0 \\<longrightarrow> f \\<noteq> g * h))", "note 1 = degree_mult_eq[OF this this, simplified]"], ["proof (state)\nthis:\n  \\<lbrakk>0 < degree ?p; 0 < degree ?q\\<rbrakk>\n  \\<Longrightarrow> degree (?p * ?q) = degree ?p + degree ?q\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d f =\n    (degree f \\<noteq> 0 \\<and>\n     (\\<forall>g h.\n         degree g \\<noteq> 0 \\<longrightarrow>\n         degree h \\<noteq> 0 \\<longrightarrow> f \\<noteq> g * h))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < degree ?p; 0 < degree ?q\\<rbrakk>\n  \\<Longrightarrow> degree (?p * ?q) = degree ?p + degree ?q", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < degree ?p; 0 < degree ?q\\<rbrakk>\n  \\<Longrightarrow> degree (?p * ?q) = degree ?p + degree ?q\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d f =\n    (degree f \\<noteq> 0 \\<and>\n     (\\<forall>g h.\n         degree g \\<noteq> 0 \\<longrightarrow>\n         degree h \\<noteq> 0 \\<longrightarrow> f \\<noteq> g * h))", "by (force elim!: irreducible\\<^sub>dE)"], ["proof (state)\nthis:\n  irreducible\\<^sub>d f =\n  (degree f \\<noteq> 0 \\<and>\n   (\\<forall>g h.\n       degree g \\<noteq> 0 \\<longrightarrow>\n       degree h \\<noteq> 0 \\<longrightarrow> f \\<noteq> g * h))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Transferring to class-based mod-ring\\<close>"], ["", "locale poly_mod_type = poly_mod m\n  for m and ty :: \"'a :: nontriv itself\" +\n  assumes m: \"m = CARD('a)\"\nbegin"], ["", "lemma m1: \"m > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < m", "using nontriv[where 'a = 'a]"], ["proof (prove)\nusing this:\n  1 < CARD('a)\n\ngoal (1 subgoal):\n 1. 1 < m", "by (auto simp:m)"], ["", "sublocale poly_mod_2"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_2 m", "using m1"], ["proof (prove)\nusing this:\n  1 < m\n\ngoal (1 subgoal):\n 1. poly_mod_2 m", "by unfold_locales"], ["", "definition MP_Rel :: \"int poly \\<Rightarrow> 'a mod_ring poly \\<Rightarrow> bool\"\n  where \"MP_Rel f f' \\<equiv> (Mp f = to_int_poly f')\""], ["", "definition M_Rel :: \"int \\<Rightarrow> 'a mod_ring \\<Rightarrow> bool\"\n  where \"M_Rel x x' \\<equiv> (M x = to_int_mod_ring x')\""], ["", "definition \"MF_Rel \\<equiv> rel_prod M_Rel (rel_mset MP_Rel)\""], ["", "lemma to_int_mod_ring_plus: \"to_int_mod_ring ((x :: 'a mod_ring) + y) = M (to_int_mod_ring x + to_int_mod_ring y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_mod_ring (x + y) = M (to_int_mod_ring x + to_int_mod_ring y)", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_mod_ring (x + y) = (to_int_mod_ring x + to_int_mod_ring y) mod m", "using m"], ["proof (prove)\nusing this:\n  m = int CARD('a)\n\ngoal (1 subgoal):\n 1. to_int_mod_ring (x + y) = (to_int_mod_ring x + to_int_mod_ring y) mod m", "by (transfer, auto)"], ["", "lemma to_int_mod_ring_times: \"to_int_mod_ring ((x :: 'a mod_ring) * y) = M (to_int_mod_ring x * to_int_mod_ring y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_mod_ring (x * y) = M (to_int_mod_ring x * to_int_mod_ring y)", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_mod_ring (x * y) = to_int_mod_ring x * to_int_mod_ring y mod m", "using m"], ["proof (prove)\nusing this:\n  m = int CARD('a)\n\ngoal (1 subgoal):\n 1. to_int_mod_ring (x * y) = to_int_mod_ring x * to_int_mod_ring y mod m", "by (transfer, auto)"], ["", "lemma degree_MP_Rel [transfer_rule]: \"(MP_Rel ===> (=)) degree_m degree\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MP_Rel ===> (=)) degree_m degree", "unfolding MP_Rel_def rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       Mp x = to_int_poly y \\<longrightarrow> degree_m x = degree y", "by (auto intro!: degree_map_poly)"], ["", "lemma eq_M_Rel[transfer_rule]: \"(M_Rel ===> M_Rel ===> (=)) (\\<lambda> x y. M x = M y) (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M_Rel ===> M_Rel ===> (=)) (\\<lambda>x y. M x = M y) (=)", "unfolding M_Rel_def rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       M x = to_int_mod_ring y \\<longrightarrow>\n       (\\<forall>xa ya.\n           M xa = to_int_mod_ring ya \\<longrightarrow>\n           (M x = M xa) = (y = ya))", "by auto"], ["", "interpretation to_int_mod_ring_hom: map_poly_inj_zero_hom to_int_mod_ring"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_zero_hom to_int_mod_ring", ".."], ["", "lemma eq_MP_Rel[transfer_rule]: \"(MP_Rel ===> MP_Rel ===> (=)) (=m) (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MP_Rel ===> MP_Rel ===> (=)) (=m) (=)", "unfolding MP_Rel_def rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       Mp x = to_int_poly y \\<longrightarrow>\n       (\\<forall>xa ya.\n           Mp xa = to_int_poly ya \\<longrightarrow> (x =m xa) = (y = ya))", "by auto"], ["", "lemma eq_Mf_Rel[transfer_rule]: \"(MF_Rel ===> MF_Rel ===> (=)) (\\<lambda> x y. Mf x = Mf y) (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MF_Rel ===> MF_Rel ===> (=)) (\\<lambda>x y. Mf x = Mf y) (=)", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MF_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> (Mf x = Mf xa) = (y = ya)", "case (1 cfs Cfs dgs Dgs)"], ["proof (state)\nthis:\n  MF_Rel cfs Cfs\n  MF_Rel dgs Dgs\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MF_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> (Mf x = Mf xa) = (y = ya)", "obtain c fs where cfs: \"cfs = (c,fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c fs. cfs = (c, fs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  cfs = (c, fs)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MF_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> (Mf x = Mf xa) = (y = ya)", "obtain C Fs where Cfs: \"Cfs = (C,Fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C Fs. Cfs = (C, Fs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  Cfs = (C, Fs)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MF_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> (Mf x = Mf xa) = (y = ya)", "obtain d gs where dgs: \"dgs = (d,gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d gs. dgs = (d, gs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  dgs = (d, gs)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MF_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> (Mf x = Mf xa) = (y = ya)", "obtain D Gs where Dgs: \"Dgs = (D,Gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D Gs. Dgs = (D, Gs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  Dgs = (D, Gs)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MF_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> (Mf x = Mf xa) = (y = ya)", "note pairs = cfs Cfs dgs Dgs"], ["proof (state)\nthis:\n  cfs = (c, fs)\n  Cfs = (C, Fs)\n  dgs = (d, gs)\n  Dgs = (D, Gs)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MF_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> (Mf x = Mf xa) = (y = ya)", "from 1[unfolded pairs MF_Rel_def rel_prod.simps]"], ["proof (chain)\npicking this:\n  \\<exists>a b ca d.\n     (c, fs) = (a, ca) \\<and>\n     (C, Fs) = (b, d) \\<and> M_Rel a b \\<and> rel_mset MP_Rel ca d\n  \\<exists>a b c da.\n     (d, gs) = (a, c) \\<and>\n     (D, Gs) = (b, da) \\<and> M_Rel a b \\<and> rel_mset MP_Rel c da", "have *[transfer_rule]: \"M_Rel c C\" \"M_Rel d D\" \"rel_mset MP_Rel fs Fs\" \"rel_mset MP_Rel gs Gs\""], ["proof (prove)\nusing this:\n  \\<exists>a b ca d.\n     (c, fs) = (a, ca) \\<and>\n     (C, Fs) = (b, d) \\<and> M_Rel a b \\<and> rel_mset MP_Rel ca d\n  \\<exists>a b c da.\n     (d, gs) = (a, c) \\<and>\n     (D, Gs) = (b, da) \\<and> M_Rel a b \\<and> rel_mset MP_Rel c da\n\ngoal (1 subgoal):\n 1. (M_Rel c C &&& M_Rel d D) &&&\n    rel_mset MP_Rel fs Fs &&& rel_mset MP_Rel gs Gs", "by auto"], ["proof (state)\nthis:\n  M_Rel c C\n  M_Rel d D\n  rel_mset MP_Rel fs Fs\n  rel_mset MP_Rel gs Gs\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MF_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> (Mf x = Mf xa) = (y = ya)", "have eq1: \"(M c = M d) = (C = D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M c = M d) = (C = D)", "by transfer_prover"], ["proof (state)\nthis:\n  (M c = M d) = (C = D)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MF_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> (Mf x = Mf xa) = (y = ya)", "from *(3)[unfolded rel_mset_def]"], ["proof (chain)\npicking this:\n  \\<exists>xs ys.\n     mset xs = fs \\<and> mset ys = Fs \\<and> list_all2 MP_Rel xs ys", "obtain fs' Fs' where fs_eq: \"mset fs' = fs\" \"mset Fs' = Fs\"\n    and rel_f: \"list_all2 MP_Rel fs' Fs'\""], ["proof (prove)\nusing this:\n  \\<exists>xs ys.\n     mset xs = fs \\<and> mset ys = Fs \\<and> list_all2 MP_Rel xs ys\n\ngoal (1 subgoal):\n 1. (\\<And>fs' Fs'.\n        \\<lbrakk>mset fs' = fs; mset Fs' = Fs;\n         list_all2 MP_Rel fs' Fs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mset fs' = fs\n  mset Fs' = Fs\n  list_all2 MP_Rel fs' Fs'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MF_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> (Mf x = Mf xa) = (y = ya)", "from *(4)[unfolded rel_mset_def]"], ["proof (chain)\npicking this:\n  \\<exists>xs ys.\n     mset xs = gs \\<and> mset ys = Gs \\<and> list_all2 MP_Rel xs ys", "obtain gs' Gs' where gs_eq: \"mset gs' = gs\" \"mset Gs' = Gs\"\n    and rel_g: \"list_all2 MP_Rel gs' Gs'\""], ["proof (prove)\nusing this:\n  \\<exists>xs ys.\n     mset xs = gs \\<and> mset ys = Gs \\<and> list_all2 MP_Rel xs ys\n\ngoal (1 subgoal):\n 1. (\\<And>gs' Gs'.\n        \\<lbrakk>mset gs' = gs; mset Gs' = Gs;\n         list_all2 MP_Rel gs' Gs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mset gs' = gs\n  mset Gs' = Gs\n  list_all2 MP_Rel gs' Gs'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MF_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> (Mf x = Mf xa) = (y = ya)", "have eq2: \"(image_mset Mp fs = image_mset Mp gs) = (Fs = Gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (image_mset Mp fs = image_mset Mp gs) = (Fs = Gs)", "using *(3-4)"], ["proof (prove)\nusing this:\n  rel_mset MP_Rel fs Fs\n  rel_mset MP_Rel gs Gs\n\ngoal (1 subgoal):\n 1. (image_mset Mp fs = image_mset Mp gs) = (Fs = Gs)", "proof (induct fs arbitrary: Fs gs Gs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Fs gs Gs.\n       \\<lbrakk>rel_mset MP_Rel {#} Fs; rel_mset MP_Rel gs Gs\\<rbrakk>\n       \\<Longrightarrow> (image_mset Mp {#} = image_mset Mp gs) = (Fs = Gs)\n 2. \\<And>x fs Fs gs Gs.\n       \\<lbrakk>\\<And>Fs gs Gs.\n                   \\<lbrakk>rel_mset MP_Rel fs Fs;\n                    rel_mset MP_Rel gs Gs\\<rbrakk>\n                   \\<Longrightarrow> (image_mset Mp fs = image_mset Mp gs) =\n                                     (Fs = Gs);\n        rel_mset MP_Rel (add_mset x fs) Fs; rel_mset MP_Rel gs Gs\\<rbrakk>\n       \\<Longrightarrow> (image_mset Mp (add_mset x fs) =\n                          image_mset Mp gs) =\n                         (Fs = Gs)", "case (empty Fs gs Gs)"], ["proof (state)\nthis:\n  rel_mset MP_Rel {#} Fs\n  rel_mset MP_Rel gs Gs\n\ngoal (2 subgoals):\n 1. \\<And>Fs gs Gs.\n       \\<lbrakk>rel_mset MP_Rel {#} Fs; rel_mset MP_Rel gs Gs\\<rbrakk>\n       \\<Longrightarrow> (image_mset Mp {#} = image_mset Mp gs) = (Fs = Gs)\n 2. \\<And>x fs Fs gs Gs.\n       \\<lbrakk>\\<And>Fs gs Gs.\n                   \\<lbrakk>rel_mset MP_Rel fs Fs;\n                    rel_mset MP_Rel gs Gs\\<rbrakk>\n                   \\<Longrightarrow> (image_mset Mp fs = image_mset Mp gs) =\n                                     (Fs = Gs);\n        rel_mset MP_Rel (add_mset x fs) Fs; rel_mset MP_Rel gs Gs\\<rbrakk>\n       \\<Longrightarrow> (image_mset Mp (add_mset x fs) =\n                          image_mset Mp gs) =\n                         (Fs = Gs)", "from empty(1)"], ["proof (chain)\npicking this:\n  rel_mset MP_Rel {#} Fs", "have Fs: \"Fs = {#}\""], ["proof (prove)\nusing this:\n  rel_mset MP_Rel {#} Fs\n\ngoal (1 subgoal):\n 1. Fs = {#}", "unfolding rel_mset_def"], ["proof (prove)\nusing this:\n  \\<exists>xs ys.\n     mset xs = {#} \\<and> mset ys = Fs \\<and> list_all2 MP_Rel xs ys\n\ngoal (1 subgoal):\n 1. Fs = {#}", "by auto"], ["proof (state)\nthis:\n  Fs = {#}\n\ngoal (2 subgoals):\n 1. \\<And>Fs gs Gs.\n       \\<lbrakk>rel_mset MP_Rel {#} Fs; rel_mset MP_Rel gs Gs\\<rbrakk>\n       \\<Longrightarrow> (image_mset Mp {#} = image_mset Mp gs) = (Fs = Gs)\n 2. \\<And>x fs Fs gs Gs.\n       \\<lbrakk>\\<And>Fs gs Gs.\n                   \\<lbrakk>rel_mset MP_Rel fs Fs;\n                    rel_mset MP_Rel gs Gs\\<rbrakk>\n                   \\<Longrightarrow> (image_mset Mp fs = image_mset Mp gs) =\n                                     (Fs = Gs);\n        rel_mset MP_Rel (add_mset x fs) Fs; rel_mset MP_Rel gs Gs\\<rbrakk>\n       \\<Longrightarrow> (image_mset Mp (add_mset x fs) =\n                          image_mset Mp gs) =\n                         (Fs = Gs)", "with empty"], ["proof (chain)\npicking this:\n  rel_mset MP_Rel {#} Fs\n  rel_mset MP_Rel gs Gs\n  Fs = {#}", "show ?case"], ["proof (prove)\nusing this:\n  rel_mset MP_Rel {#} Fs\n  rel_mset MP_Rel gs Gs\n  Fs = {#}\n\ngoal (1 subgoal):\n 1. (image_mset Mp {#} = image_mset Mp gs) = (Fs = Gs)", "by (cases gs; cases Gs; auto simp: rel_mset_def)"], ["proof (state)\nthis:\n  (image_mset Mp {#} = image_mset Mp gs) = (Fs = Gs)\n\ngoal (1 subgoal):\n 1. \\<And>x fs Fs gs Gs.\n       \\<lbrakk>\\<And>Fs gs Gs.\n                   \\<lbrakk>rel_mset MP_Rel fs Fs;\n                    rel_mset MP_Rel gs Gs\\<rbrakk>\n                   \\<Longrightarrow> (image_mset Mp fs = image_mset Mp gs) =\n                                     (Fs = Gs);\n        rel_mset MP_Rel (add_mset x fs) Fs; rel_mset MP_Rel gs Gs\\<rbrakk>\n       \\<Longrightarrow> (image_mset Mp (add_mset x fs) =\n                          image_mset Mp gs) =\n                         (Fs = Gs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x fs Fs gs Gs.\n       \\<lbrakk>\\<And>Fs gs Gs.\n                   \\<lbrakk>rel_mset MP_Rel fs Fs;\n                    rel_mset MP_Rel gs Gs\\<rbrakk>\n                   \\<Longrightarrow> (image_mset Mp fs = image_mset Mp gs) =\n                                     (Fs = Gs);\n        rel_mset MP_Rel (add_mset x fs) Fs; rel_mset MP_Rel gs Gs\\<rbrakk>\n       \\<Longrightarrow> (image_mset Mp (add_mset x fs) =\n                          image_mset Mp gs) =\n                         (Fs = Gs)", "case (add f fs Fs' gs' Gs')"], ["proof (state)\nthis:\n  \\<lbrakk>rel_mset MP_Rel fs ?Fs; rel_mset MP_Rel ?gs ?Gs\\<rbrakk>\n  \\<Longrightarrow> (image_mset Mp fs = image_mset Mp ?gs) = (?Fs = ?Gs)\n  rel_mset MP_Rel (add_mset f fs) Fs'\n  rel_mset MP_Rel gs' Gs'\n\ngoal (1 subgoal):\n 1. \\<And>x fs Fs gs Gs.\n       \\<lbrakk>\\<And>Fs gs Gs.\n                   \\<lbrakk>rel_mset MP_Rel fs Fs;\n                    rel_mset MP_Rel gs Gs\\<rbrakk>\n                   \\<Longrightarrow> (image_mset Mp fs = image_mset Mp gs) =\n                                     (Fs = Gs);\n        rel_mset MP_Rel (add_mset x fs) Fs; rel_mset MP_Rel gs Gs\\<rbrakk>\n       \\<Longrightarrow> (image_mset Mp (add_mset x fs) =\n                          image_mset Mp gs) =\n                         (Fs = Gs)", "note [transfer_rule] = add(3)"], ["proof (state)\nthis:\n  rel_mset MP_Rel gs' Gs'\n\ngoal (1 subgoal):\n 1. \\<And>x fs Fs gs Gs.\n       \\<lbrakk>\\<And>Fs gs Gs.\n                   \\<lbrakk>rel_mset MP_Rel fs Fs;\n                    rel_mset MP_Rel gs Gs\\<rbrakk>\n                   \\<Longrightarrow> (image_mset Mp fs = image_mset Mp gs) =\n                                     (Fs = Gs);\n        rel_mset MP_Rel (add_mset x fs) Fs; rel_mset MP_Rel gs Gs\\<rbrakk>\n       \\<Longrightarrow> (image_mset Mp (add_mset x fs) =\n                          image_mset Mp gs) =\n                         (Fs = Gs)", "from msed_rel_invL[OF add(2)]"], ["proof (chain)\npicking this:\n  \\<exists>N1 b.\n     Fs' = add_mset b N1 \\<and> MP_Rel f b \\<and> rel_mset MP_Rel fs N1", "obtain Fs F where Fs': \"Fs' = Fs + {#F#}\" and rel[transfer_rule]: \n      \"MP_Rel f F\" \"rel_mset MP_Rel fs Fs\""], ["proof (prove)\nusing this:\n  \\<exists>N1 b.\n     Fs' = add_mset b N1 \\<and> MP_Rel f b \\<and> rel_mset MP_Rel fs N1\n\ngoal (1 subgoal):\n 1. (\\<And>Fs F.\n        \\<lbrakk>Fs' = Fs + {#F#}; MP_Rel f F;\n         rel_mset MP_Rel fs Fs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Fs' = Fs + {#F#}\n  MP_Rel f F\n  rel_mset MP_Rel fs Fs\n\ngoal (1 subgoal):\n 1. \\<And>x fs Fs gs Gs.\n       \\<lbrakk>\\<And>Fs gs Gs.\n                   \\<lbrakk>rel_mset MP_Rel fs Fs;\n                    rel_mset MP_Rel gs Gs\\<rbrakk>\n                   \\<Longrightarrow> (image_mset Mp fs = image_mset Mp gs) =\n                                     (Fs = Gs);\n        rel_mset MP_Rel (add_mset x fs) Fs; rel_mset MP_Rel gs Gs\\<rbrakk>\n       \\<Longrightarrow> (image_mset Mp (add_mset x fs) =\n                          image_mset Mp gs) =\n                         (Fs = Gs)", "note IH = add(1)[OF rel(2)]"], ["proof (state)\nthis:\n  rel_mset MP_Rel ?gs ?Gs \\<Longrightarrow>\n  (image_mset Mp fs = image_mset Mp ?gs) = (Fs = ?Gs)\n\ngoal (1 subgoal):\n 1. \\<And>x fs Fs gs Gs.\n       \\<lbrakk>\\<And>Fs gs Gs.\n                   \\<lbrakk>rel_mset MP_Rel fs Fs;\n                    rel_mset MP_Rel gs Gs\\<rbrakk>\n                   \\<Longrightarrow> (image_mset Mp fs = image_mset Mp gs) =\n                                     (Fs = Gs);\n        rel_mset MP_Rel (add_mset x fs) Fs; rel_mset MP_Rel gs Gs\\<rbrakk>\n       \\<Longrightarrow> (image_mset Mp (add_mset x fs) =\n                          image_mset Mp gs) =\n                         (Fs = Gs)", "{"], ["proof (state)\nthis:\n  rel_mset MP_Rel ?gs ?Gs \\<Longrightarrow>\n  (image_mset Mp fs = image_mset Mp ?gs) = (Fs = ?Gs)\n\ngoal (1 subgoal):\n 1. \\<And>x fs Fs gs Gs.\n       \\<lbrakk>\\<And>Fs gs Gs.\n                   \\<lbrakk>rel_mset MP_Rel fs Fs;\n                    rel_mset MP_Rel gs Gs\\<rbrakk>\n                   \\<Longrightarrow> (image_mset Mp fs = image_mset Mp gs) =\n                                     (Fs = Gs);\n        rel_mset MP_Rel (add_mset x fs) Fs; rel_mset MP_Rel gs Gs\\<rbrakk>\n       \\<Longrightarrow> (image_mset Mp (add_mset x fs) =\n                          image_mset Mp gs) =\n                         (Fs = Gs)", "from add(3)[unfolded rel_mset_def]"], ["proof (chain)\npicking this:\n  \\<exists>xs ys.\n     mset xs = gs' \\<and> mset ys = Gs' \\<and> list_all2 MP_Rel xs ys", "obtain gs Gs where id: \"mset gs = gs'\" \"mset Gs = Gs'\" \n        and rel: \"list_all2 MP_Rel gs Gs\""], ["proof (prove)\nusing this:\n  \\<exists>xs ys.\n     mset xs = gs' \\<and> mset ys = Gs' \\<and> list_all2 MP_Rel xs ys\n\ngoal (1 subgoal):\n 1. (\\<And>gs Gs.\n        \\<lbrakk>mset gs = gs'; mset Gs = Gs';\n         list_all2 MP_Rel gs Gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mset gs = gs'\n  mset Gs = Gs'\n  list_all2 MP_Rel gs Gs\n\ngoal (1 subgoal):\n 1. \\<And>x fs Fs gs Gs.\n       \\<lbrakk>\\<And>Fs gs Gs.\n                   \\<lbrakk>rel_mset MP_Rel fs Fs;\n                    rel_mset MP_Rel gs Gs\\<rbrakk>\n                   \\<Longrightarrow> (image_mset Mp fs = image_mset Mp gs) =\n                                     (Fs = Gs);\n        rel_mset MP_Rel (add_mset x fs) Fs; rel_mset MP_Rel gs Gs\\<rbrakk>\n       \\<Longrightarrow> (image_mset Mp (add_mset x fs) =\n                          image_mset Mp gs) =\n                         (Fs = Gs)", "have \"Mp f \\<in># image_mset Mp gs' \\<longleftrightarrow> F \\<in># Gs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mp f \\<in># image_mset Mp gs') = (F \\<in># Gs')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (Mp f \\<in># image_mset Mp gs') = (F \\<in># Gs')", "have \"?thesis = ((Mp f \\<in> Mp ` set gs) = (F \\<in> set Gs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Mp f \\<in># image_mset Mp gs') = (F \\<in># Gs')) =\n    ((Mp f \\<in> Mp ` set gs) = (F \\<in> set Gs))", "unfolding id[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Mp f \\<in># image_mset Mp (mset gs)) = (F \\<in># mset Gs)) =\n    ((Mp f \\<in> Mp ` set gs) = (F \\<in> set Gs))", "by simp"], ["proof (state)\nthis:\n  ((Mp f \\<in># image_mset Mp gs') = (F \\<in># Gs')) =\n  ((Mp f \\<in> Mp ` set gs) = (F \\<in> set Gs))\n\ngoal (1 subgoal):\n 1. (Mp f \\<in># image_mset Mp gs') = (F \\<in># Gs')", "also"], ["proof (state)\nthis:\n  ((Mp f \\<in># image_mset Mp gs') = (F \\<in># Gs')) =\n  ((Mp f \\<in> Mp ` set gs) = (F \\<in> set Gs))\n\ngoal (1 subgoal):\n 1. (Mp f \\<in># image_mset Mp gs') = (F \\<in># Gs')", "have \\<dots>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mp f \\<in> Mp ` set gs) = (F \\<in> set Gs)", "using rel"], ["proof (prove)\nusing this:\n  list_all2 MP_Rel gs Gs\n\ngoal (1 subgoal):\n 1. (Mp f \\<in> Mp ` set gs) = (F \\<in> set Gs)", "proof (induct gs Gs rule: list_all2_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. (Mp f \\<in> Mp ` set []) = (F \\<in> set [])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>MP_Rel x y; list_all2 MP_Rel xs ys;\n        (Mp f \\<in> Mp ` set xs) = (F \\<in> set ys)\\<rbrakk>\n       \\<Longrightarrow> (Mp f \\<in> Mp ` set (x # xs)) =\n                         (F \\<in> set (y # ys))", "case (Cons g gs G Gs)"], ["proof (state)\nthis:\n  MP_Rel g G\n  list_all2 MP_Rel gs Gs\n  (Mp f \\<in> Mp ` set gs) = (F \\<in> set Gs)\n\ngoal (2 subgoals):\n 1. (Mp f \\<in> Mp ` set []) = (F \\<in> set [])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>MP_Rel x y; list_all2 MP_Rel xs ys;\n        (Mp f \\<in> Mp ` set xs) = (F \\<in> set ys)\\<rbrakk>\n       \\<Longrightarrow> (Mp f \\<in> Mp ` set (x # xs)) =\n                         (F \\<in> set (y # ys))", "note [transfer_rule] = Cons(1-2)"], ["proof (state)\nthis:\n  MP_Rel g G\n  list_all2 MP_Rel gs Gs\n\ngoal (2 subgoals):\n 1. (Mp f \\<in> Mp ` set []) = (F \\<in> set [])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>MP_Rel x y; list_all2 MP_Rel xs ys;\n        (Mp f \\<in> Mp ` set xs) = (F \\<in> set ys)\\<rbrakk>\n       \\<Longrightarrow> (Mp f \\<in> Mp ` set (x # xs)) =\n                         (F \\<in> set (y # ys))", "have id: \"(Mp g = Mp f) = (F = G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g =m f) = (F = G)", "by (transfer, auto)"], ["proof (state)\nthis:\n  (g =m f) = (F = G)\n\ngoal (2 subgoals):\n 1. (Mp f \\<in> Mp ` set []) = (F \\<in> set [])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>MP_Rel x y; list_all2 MP_Rel xs ys;\n        (Mp f \\<in> Mp ` set xs) = (F \\<in> set ys)\\<rbrakk>\n       \\<Longrightarrow> (Mp f \\<in> Mp ` set (x # xs)) =\n                         (F \\<in> set (y # ys))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mp f \\<in> Mp ` set (g # gs)) = (F \\<in> set (G # Gs))", "using id Cons(3)"], ["proof (prove)\nusing this:\n  (g =m f) = (F = G)\n  (Mp f \\<in> Mp ` set gs) = (F \\<in> set Gs)\n\ngoal (1 subgoal):\n 1. (Mp f \\<in> Mp ` set (g # gs)) = (F \\<in> set (G # Gs))", "by auto"], ["proof (state)\nthis:\n  (Mp f \\<in> Mp ` set (g # gs)) = (F \\<in> set (G # Gs))\n\ngoal (1 subgoal):\n 1. (Mp f \\<in> Mp ` set []) = (F \\<in> set [])", "qed auto"], ["proof (state)\nthis:\n  (Mp f \\<in> Mp ` set gs) = (F \\<in> set Gs)\n\ngoal (1 subgoal):\n 1. (Mp f \\<in># image_mset Mp gs') = (F \\<in># Gs')", "finally"], ["proof (chain)\npicking this:\n  ((Mp f \\<in># image_mset Mp gs') = (F \\<in># Gs')) =\n  ((F \\<in> set Gs) = (F \\<in> set Gs))", "show ?thesis"], ["proof (prove)\nusing this:\n  ((Mp f \\<in># image_mset Mp gs') = (F \\<in># Gs')) =\n  ((F \\<in> set Gs) = (F \\<in> set Gs))\n\ngoal (1 subgoal):\n 1. (Mp f \\<in># image_mset Mp gs') = (F \\<in># Gs')", "by simp"], ["proof (state)\nthis:\n  (Mp f \\<in># image_mset Mp gs') = (F \\<in># Gs')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (Mp f \\<in># image_mset Mp gs') = (F \\<in># Gs')\n\ngoal (1 subgoal):\n 1. \\<And>x fs Fs gs Gs.\n       \\<lbrakk>\\<And>Fs gs Gs.\n                   \\<lbrakk>rel_mset MP_Rel fs Fs;\n                    rel_mset MP_Rel gs Gs\\<rbrakk>\n                   \\<Longrightarrow> (image_mset Mp fs = image_mset Mp gs) =\n                                     (Fs = Gs);\n        rel_mset MP_Rel (add_mset x fs) Fs; rel_mset MP_Rel gs Gs\\<rbrakk>\n       \\<Longrightarrow> (image_mset Mp (add_mset x fs) =\n                          image_mset Mp gs) =\n                         (Fs = Gs)", "}"], ["proof (state)\nthis:\n  (Mp f \\<in># image_mset Mp gs') = (F \\<in># Gs')\n\ngoal (1 subgoal):\n 1. \\<And>x fs Fs gs Gs.\n       \\<lbrakk>\\<And>Fs gs Gs.\n                   \\<lbrakk>rel_mset MP_Rel fs Fs;\n                    rel_mset MP_Rel gs Gs\\<rbrakk>\n                   \\<Longrightarrow> (image_mset Mp fs = image_mset Mp gs) =\n                                     (Fs = Gs);\n        rel_mset MP_Rel (add_mset x fs) Fs; rel_mset MP_Rel gs Gs\\<rbrakk>\n       \\<Longrightarrow> (image_mset Mp (add_mset x fs) =\n                          image_mset Mp gs) =\n                         (Fs = Gs)", "note id = this"], ["proof (state)\nthis:\n  (Mp f \\<in># image_mset Mp gs') = (F \\<in># Gs')\n\ngoal (1 subgoal):\n 1. \\<And>x fs Fs gs Gs.\n       \\<lbrakk>\\<And>Fs gs Gs.\n                   \\<lbrakk>rel_mset MP_Rel fs Fs;\n                    rel_mset MP_Rel gs Gs\\<rbrakk>\n                   \\<Longrightarrow> (image_mset Mp fs = image_mset Mp gs) =\n                                     (Fs = Gs);\n        rel_mset MP_Rel (add_mset x fs) Fs; rel_mset MP_Rel gs Gs\\<rbrakk>\n       \\<Longrightarrow> (image_mset Mp (add_mset x fs) =\n                          image_mset Mp gs) =\n                         (Fs = Gs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (image_mset Mp (add_mset f fs) = image_mset Mp gs') = (Fs' = Gs')", "proof (cases \"Mp f \\<in># image_mset Mp gs'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Mp f \\<in># image_mset Mp gs' \\<Longrightarrow>\n    (image_mset Mp (add_mset f fs) = image_mset Mp gs') = (Fs' = Gs')\n 2. Mp f \\<notin># image_mset Mp gs' \\<Longrightarrow>\n    (image_mset Mp (add_mset f fs) = image_mset Mp gs') = (Fs' = Gs')", "case False"], ["proof (state)\nthis:\n  Mp f \\<notin># image_mset Mp gs'\n\ngoal (2 subgoals):\n 1. Mp f \\<in># image_mset Mp gs' \\<Longrightarrow>\n    (image_mset Mp (add_mset f fs) = image_mset Mp gs') = (Fs' = Gs')\n 2. Mp f \\<notin># image_mset Mp gs' \\<Longrightarrow>\n    (image_mset Mp (add_mset f fs) = image_mset Mp gs') = (Fs' = Gs')", "have \"Mp f \\<in># image_mset Mp (fs + {#f#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp f \\<in># image_mset Mp (fs + {#f#})", "by auto"], ["proof (state)\nthis:\n  Mp f \\<in># image_mset Mp (fs + {#f#})\n\ngoal (2 subgoals):\n 1. Mp f \\<in># image_mset Mp gs' \\<Longrightarrow>\n    (image_mset Mp (add_mset f fs) = image_mset Mp gs') = (Fs' = Gs')\n 2. Mp f \\<notin># image_mset Mp gs' \\<Longrightarrow>\n    (image_mset Mp (add_mset f fs) = image_mset Mp gs') = (Fs' = Gs')", "with False"], ["proof (chain)\npicking this:\n  Mp f \\<notin># image_mset Mp gs'\n  Mp f \\<in># image_mset Mp (fs + {#f#})", "have F: \"image_mset Mp (fs + {#f#}) \\<noteq> image_mset Mp gs'\""], ["proof (prove)\nusing this:\n  Mp f \\<notin># image_mset Mp gs'\n  Mp f \\<in># image_mset Mp (fs + {#f#})\n\ngoal (1 subgoal):\n 1. image_mset Mp (fs + {#f#}) \\<noteq> image_mset Mp gs'", "by metis"], ["proof (state)\nthis:\n  image_mset Mp (fs + {#f#}) \\<noteq> image_mset Mp gs'\n\ngoal (2 subgoals):\n 1. Mp f \\<in># image_mset Mp gs' \\<Longrightarrow>\n    (image_mset Mp (add_mset f fs) = image_mset Mp gs') = (Fs' = Gs')\n 2. Mp f \\<notin># image_mset Mp gs' \\<Longrightarrow>\n    (image_mset Mp (add_mset f fs) = image_mset Mp gs') = (Fs' = Gs')", "with False[unfolded id]"], ["proof (chain)\npicking this:\n  F \\<notin># Gs'\n  image_mset Mp (fs + {#f#}) \\<noteq> image_mset Mp gs'", "show ?thesis"], ["proof (prove)\nusing this:\n  F \\<notin># Gs'\n  image_mset Mp (fs + {#f#}) \\<noteq> image_mset Mp gs'\n\ngoal (1 subgoal):\n 1. (image_mset Mp (add_mset f fs) = image_mset Mp gs') = (Fs' = Gs')", "unfolding Fs'"], ["proof (prove)\nusing this:\n  F \\<notin># Gs'\n  image_mset Mp (fs + {#f#}) \\<noteq> image_mset Mp gs'\n\ngoal (1 subgoal):\n 1. (image_mset Mp (add_mset f fs) = image_mset Mp gs') = (Fs + {#F#} = Gs')", "by auto"], ["proof (state)\nthis:\n  (image_mset Mp (add_mset f fs) = image_mset Mp gs') = (Fs' = Gs')\n\ngoal (1 subgoal):\n 1. Mp f \\<in># image_mset Mp gs' \\<Longrightarrow>\n    (image_mset Mp (add_mset f fs) = image_mset Mp gs') = (Fs' = Gs')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Mp f \\<in># image_mset Mp gs' \\<Longrightarrow>\n    (image_mset Mp (add_mset f fs) = image_mset Mp gs') = (Fs' = Gs')", "case True"], ["proof (state)\nthis:\n  Mp f \\<in># image_mset Mp gs'\n\ngoal (1 subgoal):\n 1. Mp f \\<in># image_mset Mp gs' \\<Longrightarrow>\n    (image_mset Mp (add_mset f fs) = image_mset Mp gs') = (Fs' = Gs')", "then"], ["proof (chain)\npicking this:\n  Mp f \\<in># image_mset Mp gs'", "obtain g where fg: \"Mp f = Mp g\" and g: \"g \\<in># gs'\""], ["proof (prove)\nusing this:\n  Mp f \\<in># image_mset Mp gs'\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>f =m g; g \\<in># gs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f =m g\n  g \\<in># gs'\n\ngoal (1 subgoal):\n 1. Mp f \\<in># image_mset Mp gs' \\<Longrightarrow>\n    (image_mset Mp (add_mset f fs) = image_mset Mp gs') = (Fs' = Gs')", "from g"], ["proof (chain)\npicking this:\n  g \\<in># gs'", "obtain gs where gs': \"gs' = add_mset g gs\""], ["proof (prove)\nusing this:\n  g \\<in># gs'\n\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        gs' = add_mset g gs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule mset_add)"], ["proof (state)\nthis:\n  gs' = add_mset g gs\n\ngoal (1 subgoal):\n 1. Mp f \\<in># image_mset Mp gs' \\<Longrightarrow>\n    (image_mset Mp (add_mset f fs) = image_mset Mp gs') = (Fs' = Gs')", "from msed_rel_invL[OF add(3)[unfolded gs']]"], ["proof (chain)\npicking this:\n  \\<exists>N1 b.\n     Gs' = add_mset b N1 \\<and> MP_Rel g b \\<and> rel_mset MP_Rel gs N1", "obtain Gs G where Gs': \"Gs' = Gs + {# G #}\" and gG[transfer_rule]: \"MP_Rel g G\" and \n        gsGs: \"rel_mset MP_Rel gs Gs\""], ["proof (prove)\nusing this:\n  \\<exists>N1 b.\n     Gs' = add_mset b N1 \\<and> MP_Rel g b \\<and> rel_mset MP_Rel gs N1\n\ngoal (1 subgoal):\n 1. (\\<And>Gs G.\n        \\<lbrakk>Gs' = Gs + {#G#}; MP_Rel g G;\n         rel_mset MP_Rel gs Gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Gs' = Gs + {#G#}\n  MP_Rel g G\n  rel_mset MP_Rel gs Gs\n\ngoal (1 subgoal):\n 1. Mp f \\<in># image_mset Mp gs' \\<Longrightarrow>\n    (image_mset Mp (add_mset f fs) = image_mset Mp gs') = (Fs' = Gs')", "have FG: \"F = G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F = G", "by (transfer, simp add: fg)"], ["proof (state)\nthis:\n  F = G\n\ngoal (1 subgoal):\n 1. Mp f \\<in># image_mset Mp gs' \\<Longrightarrow>\n    (image_mset Mp (add_mset f fs) = image_mset Mp gs') = (Fs' = Gs')", "note IH = IH[OF gsGs]"], ["proof (state)\nthis:\n  (image_mset Mp fs = image_mset Mp gs) = (Fs = Gs)\n\ngoal (1 subgoal):\n 1. Mp f \\<in># image_mset Mp gs' \\<Longrightarrow>\n    (image_mset Mp (add_mset f fs) = image_mset Mp gs') = (Fs' = Gs')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (image_mset Mp (add_mset f fs) = image_mset Mp gs') = (Fs' = Gs')", "unfolding gs' Fs' Gs'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (image_mset Mp (add_mset f fs) = image_mset Mp (add_mset g gs)) =\n    (Fs + {#F#} = Gs + {#G#})", "by (simp add: fg IH FG)"], ["proof (state)\nthis:\n  (image_mset Mp (add_mset f fs) = image_mset Mp gs') = (Fs' = Gs')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (image_mset Mp (add_mset f fs) = image_mset Mp gs') = (Fs' = Gs')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (image_mset Mp fs = image_mset Mp gs) = (Fs = Gs)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MF_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> (Mf x = Mf xa) = (y = ya)", "show \"(Mf cfs = Mf dgs) = (Cfs = Dgs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mf cfs = Mf dgs) = (Cfs = Dgs)", "unfolding pairs Mf_def split"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((M c, image_mset Mp fs) = (M d, image_mset Mp gs)) =\n    ((C, Fs) = (D, Gs))", "by (simp add: eq1 eq2)"], ["proof (state)\nthis:\n  (Mf cfs = Mf dgs) = (Cfs = Dgs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas coeff_map_poly_of_int = coeff_map_poly[of of_int, OF of_int_0]"], ["", "lemma plus_MP_Rel[transfer_rule]: \"(MP_Rel ===> MP_Rel ===> MP_Rel) (+) (+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MP_Rel ===> MP_Rel ===> MP_Rel) (+) (+)", "unfolding MP_Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>f f'. Mp f = to_int_poly f') ===>\n     (\\<lambda>f f'. Mp f = to_int_poly f') ===>\n     (\\<lambda>f f'. Mp f = to_int_poly f'))\n     (+) (+)", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mp x = to_int_poly y; Mp xa = to_int_poly ya\\<rbrakk>\n       \\<Longrightarrow> Mp (x + xa) = to_int_poly (y + ya)", "case (1 x f y g)"], ["proof (state)\nthis:\n  Mp x = to_int_poly f\n  Mp y = to_int_poly g\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mp x = to_int_poly y; Mp xa = to_int_poly ya\\<rbrakk>\n       \\<Longrightarrow> Mp (x + xa) = to_int_poly (y + ya)", "have \"Mp (x + y) = Mp (Mp x + Mp y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y =m Mp x + Mp y", "by simp"], ["proof (state)\nthis:\n  x + y =m Mp x + Mp y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mp x = to_int_poly y; Mp xa = to_int_poly ya\\<rbrakk>\n       \\<Longrightarrow> Mp (x + xa) = to_int_poly (y + ya)", "also"], ["proof (state)\nthis:\n  x + y =m Mp x + Mp y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mp x = to_int_poly y; Mp xa = to_int_poly ya\\<rbrakk>\n       \\<Longrightarrow> Mp (x + xa) = to_int_poly (y + ya)", "have \"\\<dots> = Mp (map_poly to_int_mod_ring f + map_poly to_int_mod_ring g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp x + Mp y =m to_int_poly f + to_int_poly g", "unfolding 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_poly f + to_int_poly g =m to_int_poly f + to_int_poly g", ".."], ["proof (state)\nthis:\n  Mp x + Mp y =m to_int_poly f + to_int_poly g\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mp x = to_int_poly y; Mp xa = to_int_poly ya\\<rbrakk>\n       \\<Longrightarrow> Mp (x + xa) = to_int_poly (y + ya)", "also"], ["proof (state)\nthis:\n  Mp x + Mp y =m to_int_poly f + to_int_poly g\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mp x = to_int_poly y; Mp xa = to_int_poly ya\\<rbrakk>\n       \\<Longrightarrow> Mp (x + xa) = to_int_poly (y + ya)", "have \"\\<dots> = map_poly to_int_mod_ring (f + g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (to_int_poly f + to_int_poly g) = to_int_poly (f + g)", "unfolding poly_eq_iff Mp_coeff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       M (poly.coeff (to_int_poly f + to_int_poly g) n) =\n       poly.coeff (to_int_poly (f + g)) n", "by (auto simp: to_int_mod_ring_plus)"], ["proof (state)\nthis:\n  Mp (to_int_poly f + to_int_poly g) = to_int_poly (f + g)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mp x = to_int_poly y; Mp xa = to_int_poly ya\\<rbrakk>\n       \\<Longrightarrow> Mp (x + xa) = to_int_poly (y + ya)", "finally"], ["proof (chain)\npicking this:\n  Mp (x + y) = to_int_poly (f + g)", "show ?case"], ["proof (prove)\nusing this:\n  Mp (x + y) = to_int_poly (f + g)\n\ngoal (1 subgoal):\n 1. Mp (x + y) = to_int_poly (f + g)", "."], ["proof (state)\nthis:\n  Mp (x + y) = to_int_poly (f + g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma times_MP_Rel[transfer_rule]: \"(MP_Rel ===> MP_Rel ===> MP_Rel) ((*)) ((*))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MP_Rel ===> MP_Rel ===> MP_Rel) (*) (*)", "unfolding MP_Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>f f'. Mp f = to_int_poly f') ===>\n     (\\<lambda>f f'. Mp f = to_int_poly f') ===>\n     (\\<lambda>f f'. Mp f = to_int_poly f'))\n     (*) (*)", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mp x = to_int_poly y; Mp xa = to_int_poly ya\\<rbrakk>\n       \\<Longrightarrow> Mp (x * xa) = to_int_poly (y * ya)", "case (1 x f y g)"], ["proof (state)\nthis:\n  Mp x = to_int_poly f\n  Mp y = to_int_poly g\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mp x = to_int_poly y; Mp xa = to_int_poly ya\\<rbrakk>\n       \\<Longrightarrow> Mp (x * xa) = to_int_poly (y * ya)", "have \"Mp (x * y) = Mp (Mp x * Mp y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y =m Mp x * Mp y", "by simp"], ["proof (state)\nthis:\n  x * y =m Mp x * Mp y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mp x = to_int_poly y; Mp xa = to_int_poly ya\\<rbrakk>\n       \\<Longrightarrow> Mp (x * xa) = to_int_poly (y * ya)", "also"], ["proof (state)\nthis:\n  x * y =m Mp x * Mp y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mp x = to_int_poly y; Mp xa = to_int_poly ya\\<rbrakk>\n       \\<Longrightarrow> Mp (x * xa) = to_int_poly (y * ya)", "have \"\\<dots> = Mp (map_poly to_int_mod_ring f * map_poly to_int_mod_ring g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp x * Mp y =m to_int_poly f * to_int_poly g", "unfolding 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_poly f * to_int_poly g =m to_int_poly f * to_int_poly g", ".."], ["proof (state)\nthis:\n  Mp x * Mp y =m to_int_poly f * to_int_poly g\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mp x = to_int_poly y; Mp xa = to_int_poly ya\\<rbrakk>\n       \\<Longrightarrow> Mp (x * xa) = to_int_poly (y * ya)", "also"], ["proof (state)\nthis:\n  Mp x * Mp y =m to_int_poly f * to_int_poly g\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mp x = to_int_poly y; Mp xa = to_int_poly ya\\<rbrakk>\n       \\<Longrightarrow> Mp (x * xa) = to_int_poly (y * ya)", "have \"\\<dots> = map_poly to_int_mod_ring (f * g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (to_int_poly f * to_int_poly g) = to_int_poly (f * g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Mp (to_int_poly f * to_int_poly g) = to_int_poly (f * g)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. Mp (to_int_poly f * to_int_poly g) = to_int_poly (f * g)", "fix n :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. Mp (to_int_poly f * to_int_poly g) = to_int_poly (f * g)", "define A where \"A = {.. n}\""], ["proof (state)\nthis:\n  A = {..n}\n\ngoal (1 subgoal):\n 1. Mp (to_int_poly f * to_int_poly g) = to_int_poly (f * g)", "have \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {..n}", "by auto"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. Mp (to_int_poly f * to_int_poly g) = to_int_poly (f * g)", "then"], ["proof (chain)\npicking this:\n  finite A", "have \"M (\\<Sum>i\\<le>n. to_int_mod_ring (coeff f i) * to_int_mod_ring (coeff g (n - i))) =\n           to_int_mod_ring (\\<Sum>i\\<le>n. coeff f i * coeff g (n - i))\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. M (\\<Sum>i\\<le>n.\n          to_int_mod_ring (poly.coeff f i) *\n          to_int_mod_ring (poly.coeff g (n - i))) =\n    to_int_mod_ring (\\<Sum>i\\<le>n. poly.coeff f i * poly.coeff g (n - i))", "unfolding A_def[symmetric]"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. M (\\<Sum>i\\<in>A.\n         to_int_mod_ring (poly.coeff f i) *\n         to_int_mod_ring (poly.coeff g (n - i))) =\n    to_int_mod_ring (\\<Sum>i\\<in>A. poly.coeff f i * poly.coeff g (n - i))", "proof (induct A)"], ["proof (state)\ngoal (2 subgoals):\n 1. M (\\<Sum>i\\<in>{}.\n         to_int_mod_ring (poly.coeff f i) *\n         to_int_mod_ring (poly.coeff g (n - i))) =\n    to_int_mod_ring (\\<Sum>i\\<in>{}. poly.coeff f i * poly.coeff g (n - i))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        M (\\<Sum>i\\<in>F.\n             to_int_mod_ring (poly.coeff f i) *\n             to_int_mod_ring (poly.coeff g (n - i))) =\n        to_int_mod_ring\n         (\\<Sum>i\\<in>F. poly.coeff f i * poly.coeff g (n - i))\\<rbrakk>\n       \\<Longrightarrow> M (\\<Sum>i\\<in>insert x F.\n                              to_int_mod_ring (poly.coeff f i) *\n                              to_int_mod_ring (poly.coeff g (n - i))) =\n                         to_int_mod_ring\n                          (\\<Sum>i\\<in>insert x F.\n                             poly.coeff f i * poly.coeff g (n - i))", "case (insert a A)"], ["proof (state)\nthis:\n  finite A\n  a \\<notin> A\n  M (\\<Sum>i\\<in>A.\n       to_int_mod_ring (poly.coeff f i) *\n       to_int_mod_ring (poly.coeff g (n - i))) =\n  to_int_mod_ring (\\<Sum>i\\<in>A. poly.coeff f i * poly.coeff g (n - i))\n\ngoal (2 subgoals):\n 1. M (\\<Sum>i\\<in>{}.\n         to_int_mod_ring (poly.coeff f i) *\n         to_int_mod_ring (poly.coeff g (n - i))) =\n    to_int_mod_ring (\\<Sum>i\\<in>{}. poly.coeff f i * poly.coeff g (n - i))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        M (\\<Sum>i\\<in>F.\n             to_int_mod_ring (poly.coeff f i) *\n             to_int_mod_ring (poly.coeff g (n - i))) =\n        to_int_mod_ring\n         (\\<Sum>i\\<in>F. poly.coeff f i * poly.coeff g (n - i))\\<rbrakk>\n       \\<Longrightarrow> M (\\<Sum>i\\<in>insert x F.\n                              to_int_mod_ring (poly.coeff f i) *\n                              to_int_mod_ring (poly.coeff g (n - i))) =\n                         to_int_mod_ring\n                          (\\<Sum>i\\<in>insert x F.\n                             poly.coeff f i * poly.coeff g (n - i))", "have \"?case = ?case\" (is \"(?l = ?r) = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (M (\\<Sum>i\\<in>insert a A.\n          to_int_mod_ring (poly.coeff f i) *\n          to_int_mod_ring (poly.coeff g (n - i))) =\n     to_int_mod_ring\n      (\\<Sum>i\\<in>insert a A. poly.coeff f i * poly.coeff g (n - i))) =\n    (M (\\<Sum>i\\<in>insert a A.\n          to_int_mod_ring (poly.coeff f i) *\n          to_int_mod_ring (poly.coeff g (n - i))) =\n     to_int_mod_ring\n      (\\<Sum>i\\<in>insert a A. poly.coeff f i * poly.coeff g (n - i)))", "by simp"], ["proof (state)\nthis:\n  (M (\\<Sum>i\\<in>insert a A.\n        to_int_mod_ring (poly.coeff f i) *\n        to_int_mod_ring (poly.coeff g (n - i))) =\n   to_int_mod_ring\n    (\\<Sum>i\\<in>insert a A. poly.coeff f i * poly.coeff g (n - i))) =\n  (M (\\<Sum>i\\<in>insert a A.\n        to_int_mod_ring (poly.coeff f i) *\n        to_int_mod_ring (poly.coeff g (n - i))) =\n   to_int_mod_ring\n    (\\<Sum>i\\<in>insert a A. poly.coeff f i * poly.coeff g (n - i)))\n\ngoal (2 subgoals):\n 1. M (\\<Sum>i\\<in>{}.\n         to_int_mod_ring (poly.coeff f i) *\n         to_int_mod_ring (poly.coeff g (n - i))) =\n    to_int_mod_ring (\\<Sum>i\\<in>{}. poly.coeff f i * poly.coeff g (n - i))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        M (\\<Sum>i\\<in>F.\n             to_int_mod_ring (poly.coeff f i) *\n             to_int_mod_ring (poly.coeff g (n - i))) =\n        to_int_mod_ring\n         (\\<Sum>i\\<in>F. poly.coeff f i * poly.coeff g (n - i))\\<rbrakk>\n       \\<Longrightarrow> M (\\<Sum>i\\<in>insert x F.\n                              to_int_mod_ring (poly.coeff f i) *\n                              to_int_mod_ring (poly.coeff g (n - i))) =\n                         to_int_mod_ring\n                          (\\<Sum>i\\<in>insert x F.\n                             poly.coeff f i * poly.coeff g (n - i))", "have \"?r = to_int_mod_ring (coeff f a * coeff g (n - a) + (\\<Sum>i\\<in> A. coeff f i * coeff g (n - i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_mod_ring\n     (\\<Sum>i\\<in>insert a A. poly.coeff f i * poly.coeff g (n - i)) =\n    to_int_mod_ring\n     (poly.coeff f a * poly.coeff g (n - a) +\n      (\\<Sum>i\\<in>A. poly.coeff f i * poly.coeff g (n - i)))", "using insert(1-2)"], ["proof (prove)\nusing this:\n  finite A\n  a \\<notin> A\n\ngoal (1 subgoal):\n 1. to_int_mod_ring\n     (\\<Sum>i\\<in>insert a A. poly.coeff f i * poly.coeff g (n - i)) =\n    to_int_mod_ring\n     (poly.coeff f a * poly.coeff g (n - a) +\n      (\\<Sum>i\\<in>A. poly.coeff f i * poly.coeff g (n - i)))", "by auto"], ["proof (state)\nthis:\n  to_int_mod_ring\n   (\\<Sum>i\\<in>insert a A. poly.coeff f i * poly.coeff g (n - i)) =\n  to_int_mod_ring\n   (poly.coeff f a * poly.coeff g (n - a) +\n    (\\<Sum>i\\<in>A. poly.coeff f i * poly.coeff g (n - i)))\n\ngoal (2 subgoals):\n 1. M (\\<Sum>i\\<in>{}.\n         to_int_mod_ring (poly.coeff f i) *\n         to_int_mod_ring (poly.coeff g (n - i))) =\n    to_int_mod_ring (\\<Sum>i\\<in>{}. poly.coeff f i * poly.coeff g (n - i))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        M (\\<Sum>i\\<in>F.\n             to_int_mod_ring (poly.coeff f i) *\n             to_int_mod_ring (poly.coeff g (n - i))) =\n        to_int_mod_ring\n         (\\<Sum>i\\<in>F. poly.coeff f i * poly.coeff g (n - i))\\<rbrakk>\n       \\<Longrightarrow> M (\\<Sum>i\\<in>insert x F.\n                              to_int_mod_ring (poly.coeff f i) *\n                              to_int_mod_ring (poly.coeff g (n - i))) =\n                         to_int_mod_ring\n                          (\\<Sum>i\\<in>insert x F.\n                             poly.coeff f i * poly.coeff g (n - i))", "note r = this[unfolded to_int_mod_ring_plus to_int_mod_ring_times]"], ["proof (state)\nthis:\n  to_int_mod_ring\n   (\\<Sum>i\\<in>insert a A. poly.coeff f i * poly.coeff g (n - i)) =\n  M (M (to_int_mod_ring (poly.coeff f a) *\n        to_int_mod_ring (poly.coeff g (n - a))) +\n     to_int_mod_ring (\\<Sum>i\\<in>A. poly.coeff f i * poly.coeff g (n - i)))\n\ngoal (2 subgoals):\n 1. M (\\<Sum>i\\<in>{}.\n         to_int_mod_ring (poly.coeff f i) *\n         to_int_mod_ring (poly.coeff g (n - i))) =\n    to_int_mod_ring (\\<Sum>i\\<in>{}. poly.coeff f i * poly.coeff g (n - i))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        M (\\<Sum>i\\<in>F.\n             to_int_mod_ring (poly.coeff f i) *\n             to_int_mod_ring (poly.coeff g (n - i))) =\n        to_int_mod_ring\n         (\\<Sum>i\\<in>F. poly.coeff f i * poly.coeff g (n - i))\\<rbrakk>\n       \\<Longrightarrow> M (\\<Sum>i\\<in>insert x F.\n                              to_int_mod_ring (poly.coeff f i) *\n                              to_int_mod_ring (poly.coeff g (n - i))) =\n                         to_int_mod_ring\n                          (\\<Sum>i\\<in>insert x F.\n                             poly.coeff f i * poly.coeff g (n - i))", "from insert(1-2)"], ["proof (chain)\npicking this:\n  finite A\n  a \\<notin> A", "have \"?l = M (to_int_mod_ring (coeff f a) * to_int_mod_ring (coeff g (n - a)) \n          + M (\\<Sum>i\\<in>A. to_int_mod_ring (coeff f i) * to_int_mod_ring (coeff g (n - i))))\""], ["proof (prove)\nusing this:\n  finite A\n  a \\<notin> A\n\ngoal (1 subgoal):\n 1. M (\\<Sum>i\\<in>insert a A.\n         to_int_mod_ring (poly.coeff f i) *\n         to_int_mod_ring (poly.coeff g (n - i))) =\n    M (to_int_mod_ring (poly.coeff f a) *\n       to_int_mod_ring (poly.coeff g (n - a)) +\n       M (\\<Sum>i\\<in>A.\n            to_int_mod_ring (poly.coeff f i) *\n            to_int_mod_ring (poly.coeff g (n - i))))", "by simp"], ["proof (state)\nthis:\n  M (\\<Sum>i\\<in>insert a A.\n       to_int_mod_ring (poly.coeff f i) *\n       to_int_mod_ring (poly.coeff g (n - i))) =\n  M (to_int_mod_ring (poly.coeff f a) *\n     to_int_mod_ring (poly.coeff g (n - a)) +\n     M (\\<Sum>i\\<in>A.\n          to_int_mod_ring (poly.coeff f i) *\n          to_int_mod_ring (poly.coeff g (n - i))))\n\ngoal (2 subgoals):\n 1. M (\\<Sum>i\\<in>{}.\n         to_int_mod_ring (poly.coeff f i) *\n         to_int_mod_ring (poly.coeff g (n - i))) =\n    to_int_mod_ring (\\<Sum>i\\<in>{}. poly.coeff f i * poly.coeff g (n - i))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        M (\\<Sum>i\\<in>F.\n             to_int_mod_ring (poly.coeff f i) *\n             to_int_mod_ring (poly.coeff g (n - i))) =\n        to_int_mod_ring\n         (\\<Sum>i\\<in>F. poly.coeff f i * poly.coeff g (n - i))\\<rbrakk>\n       \\<Longrightarrow> M (\\<Sum>i\\<in>insert x F.\n                              to_int_mod_ring (poly.coeff f i) *\n                              to_int_mod_ring (poly.coeff g (n - i))) =\n                         to_int_mod_ring\n                          (\\<Sum>i\\<in>insert x F.\n                             poly.coeff f i * poly.coeff g (n - i))", "also"], ["proof (state)\nthis:\n  M (\\<Sum>i\\<in>insert a A.\n       to_int_mod_ring (poly.coeff f i) *\n       to_int_mod_ring (poly.coeff g (n - i))) =\n  M (to_int_mod_ring (poly.coeff f a) *\n     to_int_mod_ring (poly.coeff g (n - a)) +\n     M (\\<Sum>i\\<in>A.\n          to_int_mod_ring (poly.coeff f i) *\n          to_int_mod_ring (poly.coeff g (n - i))))\n\ngoal (2 subgoals):\n 1. M (\\<Sum>i\\<in>{}.\n         to_int_mod_ring (poly.coeff f i) *\n         to_int_mod_ring (poly.coeff g (n - i))) =\n    to_int_mod_ring (\\<Sum>i\\<in>{}. poly.coeff f i * poly.coeff g (n - i))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        M (\\<Sum>i\\<in>F.\n             to_int_mod_ring (poly.coeff f i) *\n             to_int_mod_ring (poly.coeff g (n - i))) =\n        to_int_mod_ring\n         (\\<Sum>i\\<in>F. poly.coeff f i * poly.coeff g (n - i))\\<rbrakk>\n       \\<Longrightarrow> M (\\<Sum>i\\<in>insert x F.\n                              to_int_mod_ring (poly.coeff f i) *\n                              to_int_mod_ring (poly.coeff g (n - i))) =\n                         to_int_mod_ring\n                          (\\<Sum>i\\<in>insert x F.\n                             poly.coeff f i * poly.coeff g (n - i))", "have \"M (\\<Sum>i\\<in>A. to_int_mod_ring (coeff f i) * to_int_mod_ring (coeff g (n - i))) = to_int_mod_ring (\\<Sum>i\\<in>A. coeff f i * coeff g (n - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M (\\<Sum>i\\<in>A.\n         to_int_mod_ring (poly.coeff f i) *\n         to_int_mod_ring (poly.coeff g (n - i))) =\n    to_int_mod_ring (\\<Sum>i\\<in>A. poly.coeff f i * poly.coeff g (n - i))", "unfolding insert"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_mod_ring (\\<Sum>i\\<in>A. poly.coeff f i * poly.coeff g (n - i)) =\n    to_int_mod_ring (\\<Sum>i\\<in>A. poly.coeff f i * poly.coeff g (n - i))", ".."], ["proof (state)\nthis:\n  M (\\<Sum>i\\<in>A.\n       to_int_mod_ring (poly.coeff f i) *\n       to_int_mod_ring (poly.coeff g (n - i))) =\n  to_int_mod_ring (\\<Sum>i\\<in>A. poly.coeff f i * poly.coeff g (n - i))\n\ngoal (2 subgoals):\n 1. M (\\<Sum>i\\<in>{}.\n         to_int_mod_ring (poly.coeff f i) *\n         to_int_mod_ring (poly.coeff g (n - i))) =\n    to_int_mod_ring (\\<Sum>i\\<in>{}. poly.coeff f i * poly.coeff g (n - i))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        M (\\<Sum>i\\<in>F.\n             to_int_mod_ring (poly.coeff f i) *\n             to_int_mod_ring (poly.coeff g (n - i))) =\n        to_int_mod_ring\n         (\\<Sum>i\\<in>F. poly.coeff f i * poly.coeff g (n - i))\\<rbrakk>\n       \\<Longrightarrow> M (\\<Sum>i\\<in>insert x F.\n                              to_int_mod_ring (poly.coeff f i) *\n                              to_int_mod_ring (poly.coeff g (n - i))) =\n                         to_int_mod_ring\n                          (\\<Sum>i\\<in>insert x F.\n                             poly.coeff f i * poly.coeff g (n - i))", "finally"], ["proof (chain)\npicking this:\n  M (\\<Sum>i\\<in>insert a A.\n       to_int_mod_ring (poly.coeff f i) *\n       to_int_mod_ring (poly.coeff g (n - i))) =\n  M (to_int_mod_ring (poly.coeff f a) *\n     to_int_mod_ring (poly.coeff g (n - a)) +\n     to_int_mod_ring (\\<Sum>i\\<in>A. poly.coeff f i * poly.coeff g (n - i)))", "show ?case"], ["proof (prove)\nusing this:\n  M (\\<Sum>i\\<in>insert a A.\n       to_int_mod_ring (poly.coeff f i) *\n       to_int_mod_ring (poly.coeff g (n - i))) =\n  M (to_int_mod_ring (poly.coeff f a) *\n     to_int_mod_ring (poly.coeff g (n - a)) +\n     to_int_mod_ring (\\<Sum>i\\<in>A. poly.coeff f i * poly.coeff g (n - i)))\n\ngoal (1 subgoal):\n 1. M (\\<Sum>i\\<in>insert a A.\n         to_int_mod_ring (poly.coeff f i) *\n         to_int_mod_ring (poly.coeff g (n - i))) =\n    to_int_mod_ring\n     (\\<Sum>i\\<in>insert a A. poly.coeff f i * poly.coeff g (n - i))", "unfolding r"], ["proof (prove)\nusing this:\n  M (\\<Sum>i\\<in>insert a A.\n       to_int_mod_ring (poly.coeff f i) *\n       to_int_mod_ring (poly.coeff g (n - i))) =\n  M (to_int_mod_ring (poly.coeff f a) *\n     to_int_mod_ring (poly.coeff g (n - a)) +\n     to_int_mod_ring (\\<Sum>i\\<in>A. poly.coeff f i * poly.coeff g (n - i)))\n\ngoal (1 subgoal):\n 1. M (\\<Sum>i\\<in>insert a A.\n         to_int_mod_ring (poly.coeff f i) *\n         to_int_mod_ring (poly.coeff g (n - i))) =\n    M (M (to_int_mod_ring (poly.coeff f a) *\n          to_int_mod_ring (poly.coeff g (n - a))) +\n       to_int_mod_ring\n        (\\<Sum>i\\<in>A. poly.coeff f i * poly.coeff g (n - i)))", "by simp"], ["proof (state)\nthis:\n  M (\\<Sum>i\\<in>insert a A.\n       to_int_mod_ring (poly.coeff f i) *\n       to_int_mod_ring (poly.coeff g (n - i))) =\n  to_int_mod_ring\n   (\\<Sum>i\\<in>insert a A. poly.coeff f i * poly.coeff g (n - i))\n\ngoal (1 subgoal):\n 1. M (\\<Sum>i\\<in>{}.\n         to_int_mod_ring (poly.coeff f i) *\n         to_int_mod_ring (poly.coeff g (n - i))) =\n    to_int_mod_ring (\\<Sum>i\\<in>{}. poly.coeff f i * poly.coeff g (n - i))", "qed auto"], ["proof (state)\nthis:\n  M (\\<Sum>i\\<le>n.\n        to_int_mod_ring (poly.coeff f i) *\n        to_int_mod_ring (poly.coeff g (n - i))) =\n  to_int_mod_ring (\\<Sum>i\\<le>n. poly.coeff f i * poly.coeff g (n - i))\n\ngoal (1 subgoal):\n 1. Mp (to_int_poly f * to_int_poly g) = to_int_poly (f * g)", "}"], ["proof (state)\nthis:\n  M (\\<Sum>i\\<le>?n2.\n        to_int_mod_ring (poly.coeff f i) *\n        to_int_mod_ring (poly.coeff g (?n2 - i))) =\n  to_int_mod_ring (\\<Sum>i\\<le>?n2. poly.coeff f i * poly.coeff g (?n2 - i))\n\ngoal (1 subgoal):\n 1. Mp (to_int_poly f * to_int_poly g) = to_int_poly (f * g)", "then"], ["proof (chain)\npicking this:\n  M (\\<Sum>i\\<le>?n2.\n        to_int_mod_ring (poly.coeff f i) *\n        to_int_mod_ring (poly.coeff g (?n2 - i))) =\n  to_int_mod_ring (\\<Sum>i\\<le>?n2. poly.coeff f i * poly.coeff g (?n2 - i))", "show ?thesis"], ["proof (prove)\nusing this:\n  M (\\<Sum>i\\<le>?n2.\n        to_int_mod_ring (poly.coeff f i) *\n        to_int_mod_ring (poly.coeff g (?n2 - i))) =\n  to_int_mod_ring (\\<Sum>i\\<le>?n2. poly.coeff f i * poly.coeff g (?n2 - i))\n\ngoal (1 subgoal):\n 1. Mp (to_int_poly f * to_int_poly g) = to_int_poly (f * g)", "by (auto intro!:poly_eqI simp: coeff_mult  Mp_coeff)"], ["proof (state)\nthis:\n  Mp (to_int_poly f * to_int_poly g) = to_int_poly (f * g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Mp (to_int_poly f * to_int_poly g) = to_int_poly (f * g)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mp x = to_int_poly y; Mp xa = to_int_poly ya\\<rbrakk>\n       \\<Longrightarrow> Mp (x * xa) = to_int_poly (y * ya)", "finally"], ["proof (chain)\npicking this:\n  Mp (x * y) = to_int_poly (f * g)", "show ?case"], ["proof (prove)\nusing this:\n  Mp (x * y) = to_int_poly (f * g)\n\ngoal (1 subgoal):\n 1. Mp (x * y) = to_int_poly (f * g)", "."], ["proof (state)\nthis:\n  Mp (x * y) = to_int_poly (f * g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma smult_MP_Rel[transfer_rule]: \"(M_Rel ===> MP_Rel ===> MP_Rel) smult smult\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M_Rel ===> MP_Rel ===> MP_Rel) Polynomial.smult Polynomial.smult", "unfolding MP_Rel_def M_Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x x'. M x = to_int_mod_ring x') ===>\n     (\\<lambda>f f'. Mp f = to_int_poly f') ===>\n     (\\<lambda>f f'. Mp f = to_int_poly f'))\n     Polynomial.smult Polynomial.smult", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>M x = to_int_mod_ring y; Mp xa = to_int_poly ya\\<rbrakk>\n       \\<Longrightarrow> Mp (Polynomial.smult x xa) =\n                         to_int_poly (Polynomial.smult y ya)", "case (1 x x' f f')"], ["proof (state)\nthis:\n  M x = to_int_mod_ring x'\n  Mp f = to_int_poly f'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>M x = to_int_mod_ring y; Mp xa = to_int_poly ya\\<rbrakk>\n       \\<Longrightarrow> Mp (Polynomial.smult x xa) =\n                         to_int_poly (Polynomial.smult y ya)", "thus ?case"], ["proof (prove)\nusing this:\n  M x = to_int_mod_ring x'\n  Mp f = to_int_poly f'\n\ngoal (1 subgoal):\n 1. Mp (Polynomial.smult x f) = to_int_poly (Polynomial.smult x' f')", "unfolding poly_eq_iff coeff Mp_coeff\n    coeff_smult M_def"], ["proof (prove)\nusing this:\n  x mod m = to_int_mod_ring x'\n  \\<forall>n. poly.coeff f n mod m = poly.coeff (to_int_poly f') n\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       x * poly.coeff f n mod m =\n       poly.coeff (to_int_poly (Polynomial.smult x' f')) n", "proof (intro allI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>x mod m = to_int_mod_ring x';\n        \\<forall>n.\n           poly.coeff f n mod m = poly.coeff (to_int_poly f') n\\<rbrakk>\n       \\<Longrightarrow> x * poly.coeff f n mod m =\n                         poly.coeff (to_int_poly (Polynomial.smult x' f')) n", "case (1 n)"], ["proof (state)\nthis:\n  x mod m = to_int_mod_ring x'\n  \\<forall>n. poly.coeff f n mod m = poly.coeff (to_int_poly f') n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>x mod m = to_int_mod_ring x';\n        \\<forall>n.\n           poly.coeff f n mod m = poly.coeff (to_int_poly f') n\\<rbrakk>\n       \\<Longrightarrow> x * poly.coeff f n mod m =\n                         poly.coeff (to_int_poly (Polynomial.smult x' f')) n", "have \"x * coeff f n mod m = (x mod m) * (coeff f n mod m) mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * poly.coeff f n mod m = x mod m * (poly.coeff f n mod m) mod m", "by (simp add: mod_simps)"], ["proof (state)\nthis:\n  x * poly.coeff f n mod m = x mod m * (poly.coeff f n mod m) mod m\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>x mod m = to_int_mod_ring x';\n        \\<forall>n.\n           poly.coeff f n mod m = poly.coeff (to_int_poly f') n\\<rbrakk>\n       \\<Longrightarrow> x * poly.coeff f n mod m =\n                         poly.coeff (to_int_poly (Polynomial.smult x' f')) n", "also"], ["proof (state)\nthis:\n  x * poly.coeff f n mod m = x mod m * (poly.coeff f n mod m) mod m\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>x mod m = to_int_mod_ring x';\n        \\<forall>n.\n           poly.coeff f n mod m = poly.coeff (to_int_poly f') n\\<rbrakk>\n       \\<Longrightarrow> x * poly.coeff f n mod m =\n                         poly.coeff (to_int_poly (Polynomial.smult x' f')) n", "have \"\\<dots> = to_int_mod_ring x' * (to_int_mod_ring (coeff f' n)) mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod m * (poly.coeff f n mod m) mod m =\n    to_int_mod_ring x' * to_int_mod_ring (poly.coeff f' n) mod m", "using 1"], ["proof (prove)\nusing this:\n  x mod m = to_int_mod_ring x'\n  \\<forall>n. poly.coeff f n mod m = poly.coeff (to_int_poly f') n\n\ngoal (1 subgoal):\n 1. x mod m * (poly.coeff f n mod m) mod m =\n    to_int_mod_ring x' * to_int_mod_ring (poly.coeff f' n) mod m", "by auto"], ["proof (state)\nthis:\n  x mod m * (poly.coeff f n mod m) mod m =\n  to_int_mod_ring x' * to_int_mod_ring (poly.coeff f' n) mod m\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>x mod m = to_int_mod_ring x';\n        \\<forall>n.\n           poly.coeff f n mod m = poly.coeff (to_int_poly f') n\\<rbrakk>\n       \\<Longrightarrow> x * poly.coeff f n mod m =\n                         poly.coeff (to_int_poly (Polynomial.smult x' f')) n", "also"], ["proof (state)\nthis:\n  x mod m * (poly.coeff f n mod m) mod m =\n  to_int_mod_ring x' * to_int_mod_ring (poly.coeff f' n) mod m\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>x mod m = to_int_mod_ring x';\n        \\<forall>n.\n           poly.coeff f n mod m = poly.coeff (to_int_poly f') n\\<rbrakk>\n       \\<Longrightarrow> x * poly.coeff f n mod m =\n                         poly.coeff (to_int_poly (Polynomial.smult x' f')) n", "have \" \\<dots> = to_int_mod_ring (x' * coeff f' n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_mod_ring x' * to_int_mod_ring (poly.coeff f' n) mod m =\n    to_int_mod_ring (x' * poly.coeff f' n)", "unfolding to_int_mod_ring_times M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_mod_ring x' * to_int_mod_ring (poly.coeff f' n) mod m =\n    to_int_mod_ring x' * to_int_mod_ring (poly.coeff f' n) mod m", "by simp"], ["proof (state)\nthis:\n  to_int_mod_ring x' * to_int_mod_ring (poly.coeff f' n) mod m =\n  to_int_mod_ring (x' * poly.coeff f' n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>x mod m = to_int_mod_ring x';\n        \\<forall>n.\n           poly.coeff f n mod m = poly.coeff (to_int_poly f') n\\<rbrakk>\n       \\<Longrightarrow> x * poly.coeff f n mod m =\n                         poly.coeff (to_int_poly (Polynomial.smult x' f')) n", "finally"], ["proof (chain)\npicking this:\n  x * poly.coeff f n mod m = to_int_mod_ring (x' * poly.coeff f' n)", "show ?case"], ["proof (prove)\nusing this:\n  x * poly.coeff f n mod m = to_int_mod_ring (x' * poly.coeff f' n)\n\ngoal (1 subgoal):\n 1. x * poly.coeff f n mod m =\n    poly.coeff (to_int_poly (Polynomial.smult x' f')) n", "by auto"], ["proof (state)\nthis:\n  x * poly.coeff f n mod m =\n  poly.coeff (to_int_poly (Polynomial.smult x' f')) n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Mp (Polynomial.smult x f) = to_int_poly (Polynomial.smult x' f')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma one_M_Rel[transfer_rule]: \"M_Rel 1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_Rel 1 1", "unfolding M_Rel_def M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 mod m = to_int_mod_ring 1", "unfolding m"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 mod int CARD('a) = to_int_mod_ring 1", "by auto"], ["", "lemma one_MP_Rel[transfer_rule]: \"MP_Rel 1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel 1 1", "unfolding MP_Rel_def poly_eq_iff Mp_coeff M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. poly.coeff 1 n mod m = poly.coeff (to_int_poly 1) n", "unfolding m"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       poly.coeff 1 n mod int CARD('a) = poly.coeff (to_int_poly 1) n", "by auto"], ["", "lemma zero_M_Rel[transfer_rule]: \"M_Rel 0 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_Rel 0 0", "unfolding M_Rel_def M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 mod m = to_int_mod_ring 0", "unfolding m"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 mod int CARD('a) = to_int_mod_ring 0", "by auto"], ["", "lemma zero_MP_Rel[transfer_rule]: \"MP_Rel 0 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel 0 0", "unfolding MP_Rel_def poly_eq_iff Mp_coeff M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. poly.coeff 0 n mod m = poly.coeff (to_int_poly 0) n", "unfolding m"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       poly.coeff 0 n mod int CARD('a) = poly.coeff (to_int_poly 0) n", "by auto"], ["", "lemma listprod_MP_Rel[transfer_rule]: \"(list_all2 MP_Rel ===> MP_Rel) prod_list prod_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_all2 MP_Rel ===> MP_Rel) prod_list prod_list", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       list_all2 MP_Rel x y \\<Longrightarrow>\n       MP_Rel (prod_list x) (prod_list y)", "case (1 xs ys)"], ["proof (state)\nthis:\n  list_all2 MP_Rel xs ys\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       list_all2 MP_Rel x y \\<Longrightarrow>\n       MP_Rel (prod_list x) (prod_list y)", "thus ?case"], ["proof (prove)\nusing this:\n  list_all2 MP_Rel xs ys\n\ngoal (1 subgoal):\n 1. MP_Rel (prod_list xs) (prod_list ys)", "proof (induct xs ys rule: list_all2_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. MP_Rel (prod_list []) (prod_list [])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>MP_Rel x y; list_all2 MP_Rel xs ys;\n        MP_Rel (prod_list xs) (prod_list ys)\\<rbrakk>\n       \\<Longrightarrow> MP_Rel (prod_list (x # xs)) (prod_list (y # ys))", "case (Cons x xs y ys)"], ["proof (state)\nthis:\n  MP_Rel x y\n  list_all2 MP_Rel xs ys\n  MP_Rel (prod_list xs) (prod_list ys)\n\ngoal (2 subgoals):\n 1. MP_Rel (prod_list []) (prod_list [])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>MP_Rel x y; list_all2 MP_Rel xs ys;\n        MP_Rel (prod_list xs) (prod_list ys)\\<rbrakk>\n       \\<Longrightarrow> MP_Rel (prod_list (x # xs)) (prod_list (y # ys))", "note [transfer_rule] = this"], ["proof (state)\nthis:\n  MP_Rel x y\n  list_all2 MP_Rel xs ys\n  MP_Rel (prod_list xs) (prod_list ys)\n\ngoal (2 subgoals):\n 1. MP_Rel (prod_list []) (prod_list [])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>MP_Rel x y; list_all2 MP_Rel xs ys;\n        MP_Rel (prod_list xs) (prod_list ys)\\<rbrakk>\n       \\<Longrightarrow> MP_Rel (prod_list (x # xs)) (prod_list (y # ys))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel (prod_list (x # xs)) (prod_list (y # ys))", "by simp transfer_prover"], ["proof (state)\nthis:\n  MP_Rel (prod_list (x # xs)) (prod_list (y # ys))\n\ngoal (1 subgoal):\n 1. MP_Rel (prod_list []) (prod_list [])", "qed (simp add: one_MP_Rel)"], ["proof (state)\nthis:\n  MP_Rel (prod_list xs) (prod_list ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prod_mset_MP_Rel[transfer_rule]: \"(rel_mset MP_Rel ===> MP_Rel) prod_mset prod_mset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_mset MP_Rel ===> MP_Rel) \\<Prod>\\<^sub># \\<Prod>\\<^sub>#", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rel_mset MP_Rel x y \\<Longrightarrow>\n       MP_Rel (\\<Prod>\\<^sub># x) (\\<Prod>\\<^sub># y)", "case (1 xs ys)"], ["proof (state)\nthis:\n  rel_mset MP_Rel xs ys\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rel_mset MP_Rel x y \\<Longrightarrow>\n       MP_Rel (\\<Prod>\\<^sub># x) (\\<Prod>\\<^sub># y)", "have \"(MP_Rel ===> MP_Rel ===> MP_Rel) ((*)) ((*))\" \"MP_Rel 1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MP_Rel ===> MP_Rel ===> MP_Rel) (*) (*) &&& MP_Rel 1 1", "by transfer_prover+"], ["proof (state)\nthis:\n  (MP_Rel ===> MP_Rel ===> MP_Rel) (*) (*)\n  MP_Rel 1 1\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rel_mset MP_Rel x y \\<Longrightarrow>\n       MP_Rel (\\<Prod>\\<^sub># x) (\\<Prod>\\<^sub># y)", "from 1 this"], ["proof (chain)\npicking this:\n  rel_mset MP_Rel xs ys\n  (MP_Rel ===> MP_Rel ===> MP_Rel) (*) (*)\n  MP_Rel 1 1", "show ?case"], ["proof (prove)\nusing this:\n  rel_mset MP_Rel xs ys\n  (MP_Rel ===> MP_Rel ===> MP_Rel) (*) (*)\n  MP_Rel 1 1\n\ngoal (1 subgoal):\n 1. MP_Rel (\\<Prod>\\<^sub># xs) (\\<Prod>\\<^sub># ys)", "proof (induct xs ys rule: rel_mset_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>R.\n       \\<lbrakk>(R ===> R ===> R) (*) (*); R 1 1\\<rbrakk>\n       \\<Longrightarrow> R (\\<Prod>\\<^sub># {#}) (\\<Prod>\\<^sub># {#})\n 2. \\<And>R a b M N.\n       \\<lbrakk>R a b; rel_mset R M N;\n        \\<lbrakk>(R ===> R ===> R) (*) (*); R 1 1\\<rbrakk>\n        \\<Longrightarrow> R (\\<Prod>\\<^sub># M) (\\<Prod>\\<^sub># N);\n        (R ===> R ===> R) (*) (*); R 1 1\\<rbrakk>\n       \\<Longrightarrow> R (\\<Prod>\\<^sub># (add_mset a M))\n                          (\\<Prod>\\<^sub># (add_mset b N))", "case (add R x xs y ys)"], ["proof (state)\nthis:\n  R x xs\n  rel_mset R y ys\n  \\<lbrakk>(R ===> R ===> R) (*) (*); R 1 1\\<rbrakk>\n  \\<Longrightarrow> R (\\<Prod>\\<^sub># y) (\\<Prod>\\<^sub># ys)\n  (R ===> R ===> R) (*) (*)\n  R 1 1\n\ngoal (2 subgoals):\n 1. \\<And>R.\n       \\<lbrakk>(R ===> R ===> R) (*) (*); R 1 1\\<rbrakk>\n       \\<Longrightarrow> R (\\<Prod>\\<^sub># {#}) (\\<Prod>\\<^sub># {#})\n 2. \\<And>R a b M N.\n       \\<lbrakk>R a b; rel_mset R M N;\n        \\<lbrakk>(R ===> R ===> R) (*) (*); R 1 1\\<rbrakk>\n        \\<Longrightarrow> R (\\<Prod>\\<^sub># M) (\\<Prod>\\<^sub># N);\n        (R ===> R ===> R) (*) (*); R 1 1\\<rbrakk>\n       \\<Longrightarrow> R (\\<Prod>\\<^sub># (add_mset a M))\n                          (\\<Prod>\\<^sub># (add_mset b N))", "note [transfer_rule] = this"], ["proof (state)\nthis:\n  R x xs\n  rel_mset R y ys\n  \\<lbrakk>(R ===> R ===> R) (*) (*); R 1 1\\<rbrakk>\n  \\<Longrightarrow> R (\\<Prod>\\<^sub># y) (\\<Prod>\\<^sub># ys)\n  (R ===> R ===> R) (*) (*)\n  R 1 1\n\ngoal (2 subgoals):\n 1. \\<And>R.\n       \\<lbrakk>(R ===> R ===> R) (*) (*); R 1 1\\<rbrakk>\n       \\<Longrightarrow> R (\\<Prod>\\<^sub># {#}) (\\<Prod>\\<^sub># {#})\n 2. \\<And>R a b M N.\n       \\<lbrakk>R a b; rel_mset R M N;\n        \\<lbrakk>(R ===> R ===> R) (*) (*); R 1 1\\<rbrakk>\n        \\<Longrightarrow> R (\\<Prod>\\<^sub># M) (\\<Prod>\\<^sub># N);\n        (R ===> R ===> R) (*) (*); R 1 1\\<rbrakk>\n       \\<Longrightarrow> R (\\<Prod>\\<^sub># (add_mset a M))\n                          (\\<Prod>\\<^sub># (add_mset b N))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (\\<Prod>\\<^sub># (add_mset x y)) (\\<Prod>\\<^sub># (add_mset xs ys))", "by simp transfer_prover"], ["proof (state)\nthis:\n  R (\\<Prod>\\<^sub># (add_mset x y)) (\\<Prod>\\<^sub># (add_mset xs ys))\n\ngoal (1 subgoal):\n 1. \\<And>R.\n       \\<lbrakk>(R ===> R ===> R) (*) (*); R 1 1\\<rbrakk>\n       \\<Longrightarrow> R (\\<Prod>\\<^sub># {#}) (\\<Prod>\\<^sub># {#})", "qed (simp add: one_MP_Rel)"], ["proof (state)\nthis:\n  MP_Rel (\\<Prod>\\<^sub># xs) (\\<Prod>\\<^sub># ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma right_unique_MP_Rel[transfer_rule]: \"right_unique MP_Rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_unique MP_Rel", "unfolding right_unique_def MP_Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       Mp x = to_int_poly y \\<longrightarrow>\n       Mp x = to_int_poly z \\<longrightarrow> y = z", "by auto"], ["", "lemma M_to_int_mod_ring: \"M (to_int_mod_ring (x :: 'a mod_ring)) = to_int_mod_ring x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M (to_int_mod_ring x) = to_int_mod_ring x", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_mod_ring x mod m = to_int_mod_ring x", "unfolding m"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_mod_ring x mod int CARD('a) = to_int_mod_ring x", "by (transfer, auto)"], ["", "lemma Mp_to_int_poly: \"Mp (to_int_poly (f :: 'a mod_ring poly)) = to_int_poly f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (to_int_poly f) = to_int_poly f", "by (auto simp: poly_eq_iff Mp_coeff M_to_int_mod_ring)"], ["", "lemma right_total_M_Rel[transfer_rule]: \"right_total M_Rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_total M_Rel", "unfolding right_total_def M_Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. M x = to_int_mod_ring y", "using M_to_int_mod_ring"], ["proof (prove)\nusing this:\n  M (to_int_mod_ring ?x) = to_int_mod_ring ?x\n\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. M x = to_int_mod_ring y", "by blast"], ["", "lemma left_total_M_Rel[transfer_rule]: \"left_total M_Rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_total M_Rel", "unfolding left_total_def M_Rel_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. \\<exists>x'. M x = to_int_mod_ring x'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>x'. M x = to_int_mod_ring x'", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>x'. M x = to_int_mod_ring x'", "show \"\\<exists> x' :: 'a mod_ring. M x = to_int_mod_ring x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x'. M x = to_int_mod_ring x'", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x'. x mod m = to_int_mod_ring x'", "unfolding m"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x'. x mod int CARD('a) = to_int_mod_ring x'", "by (rule exI[of _ \"of_int x\"], transfer, simp)"], ["proof (state)\nthis:\n  \\<exists>x'. M x = to_int_mod_ring x'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bi_total_M_Rel[transfer_rule]: \"bi_total M_Rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_total M_Rel", "using right_total_M_Rel left_total_M_Rel"], ["proof (prove)\nusing this:\n  right_total M_Rel\n  left_total M_Rel\n\ngoal (1 subgoal):\n 1. bi_total M_Rel", "by (metis bi_totalI)"], ["", "lemma right_total_MP_Rel[transfer_rule]: \"right_total MP_Rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_total MP_Rel", "unfolding right_total_def MP_Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. Mp x = to_int_poly y", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. \\<exists>x. Mp x = to_int_poly y", "fix f :: \"'a mod_ring poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. \\<exists>x. Mp x = to_int_poly y", "show \"\\<exists>x. Mp x = to_int_poly f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. Mp x = to_int_poly f", "by (intro exI[of _ \"to_int_poly f\"], simp add: Mp_to_int_poly)"], ["proof (state)\nthis:\n  \\<exists>x. Mp x = to_int_poly f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma to_int_mod_ring_of_int_M: \"to_int_mod_ring (of_int x :: 'a mod_ring) = M x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_mod_ring (of_int x) = M x", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_mod_ring (of_int x) = x mod m", "unfolding m"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_int_mod_ring (of_int x) = x mod int CARD('a)", "by transfer auto"], ["", "lemma Mp_f_representative: \"Mp f = to_int_poly (map_poly of_int f :: 'a mod_ring poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp f = to_int_poly (of_int_poly f)", "unfolding Mp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly M f = to_int_poly (of_int_poly f)", "by (auto intro: poly_eqI simp: coeff_map_poly to_int_mod_ring_of_int_M)"], ["", "lemma left_total_MP_Rel[transfer_rule]: \"left_total MP_Rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_total MP_Rel", "unfolding left_total_def MP_Rel_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. \\<exists>f'. Mp x = to_int_poly f'", "using Mp_f_representative"], ["proof (prove)\nusing this:\n  Mp ?f = to_int_poly (of_int_poly ?f)\n\ngoal (1 subgoal):\n 1. \\<forall>x. \\<exists>f'. Mp x = to_int_poly f'", "by blast"], ["", "lemma bi_total_MP_Rel[transfer_rule]: \"bi_total MP_Rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_total MP_Rel", "using right_total_MP_Rel left_total_MP_Rel"], ["proof (prove)\nusing this:\n  right_total MP_Rel\n  left_total MP_Rel\n\ngoal (1 subgoal):\n 1. bi_total MP_Rel", "by (metis bi_totalI)"], ["", "lemma bi_total_MF_Rel[transfer_rule]: \"bi_total MF_Rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_total MF_Rel", "unfolding MF_Rel_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_total (rel_prod M_Rel (rel_mset MP_Rel))", "by (intro prod.bi_total_rel multiset.bi_total_rel bi_total_MP_Rel bi_total_M_Rel)"], ["", "lemma right_total_MF_Rel[transfer_rule]: \"right_total MF_Rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_total MF_Rel", "using bi_total_MF_Rel"], ["proof (prove)\nusing this:\n  bi_total MF_Rel\n\ngoal (1 subgoal):\n 1. right_total MF_Rel", "unfolding bi_total_alt_def"], ["proof (prove)\nusing this:\n  left_total MF_Rel \\<and> right_total MF_Rel\n\ngoal (1 subgoal):\n 1. right_total MF_Rel", "by auto"], ["", "lemma left_total_MF_Rel[transfer_rule]: \"left_total MF_Rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_total MF_Rel", "using bi_total_MF_Rel"], ["proof (prove)\nusing this:\n  bi_total MF_Rel\n\ngoal (1 subgoal):\n 1. left_total MF_Rel", "unfolding bi_total_alt_def"], ["proof (prove)\nusing this:\n  left_total MF_Rel \\<and> right_total MF_Rel\n\ngoal (1 subgoal):\n 1. left_total MF_Rel", "by auto"], ["", "lemma domain_RT_rel[transfer_domain_rule]: \"Domainp MP_Rel = (\\<lambda> f. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp MP_Rel = (\\<lambda>f. True)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. Domainp MP_Rel f = True", "fix f :: \"int poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. Domainp MP_Rel f = True", "show \"Domainp MP_Rel f = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp MP_Rel f = True", "unfolding MP_Rel_def[abs_def] Domainp.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>a b. f = a \\<and> Mp a = to_int_poly b) = True", "by (auto simp: Mp_f_representative)"], ["proof (state)\nthis:\n  Domainp MP_Rel f = True\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mem_MP_Rel[transfer_rule]: \"(MP_Rel ===> rel_set MP_Rel ===> (=)) (\\<lambda> x Y. \\<exists>y \\<in> Y. eq_m x y) (\\<in>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MP_Rel ===> rel_set MP_Rel ===> (=))\n     (\\<lambda>x Y. \\<exists>y\\<in>Y. x =m y) (\\<in>)", "proof (intro rel_funI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; rel_set MP_Rel xa ya;\n        \\<exists>y\\<in>xa. x =m y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; rel_set MP_Rel xa ya; y \\<in> ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>xa. x =m y", "fix x y X Y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; rel_set MP_Rel xa ya;\n        \\<exists>y\\<in>xa. x =m y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; rel_set MP_Rel xa ya; y \\<in> ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>xa. x =m y", "assume xy: \"MP_Rel x y\" and XY: \"rel_set MP_Rel X Y\""], ["proof (state)\nthis:\n  MP_Rel x y\n  rel_set MP_Rel X Y\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; rel_set MP_Rel xa ya;\n        \\<exists>y\\<in>xa. x =m y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; rel_set MP_Rel xa ya; y \\<in> ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>xa. x =m y", "{"], ["proof (state)\nthis:\n  MP_Rel x y\n  rel_set MP_Rel X Y\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; rel_set MP_Rel xa ya;\n        \\<exists>y\\<in>xa. x =m y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; rel_set MP_Rel xa ya; y \\<in> ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>xa. x =m y", "assume \"\\<exists>x' \\<in> X. x =m x'\""], ["proof (state)\nthis:\n  \\<exists>x'\\<in>X. x =m x'\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; rel_set MP_Rel xa ya;\n        \\<exists>y\\<in>xa. x =m y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; rel_set MP_Rel xa ya; y \\<in> ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>xa. x =m y", "then"], ["proof (chain)\npicking this:\n  \\<exists>x'\\<in>X. x =m x'", "obtain x' where x'X: \"x' \\<in> X\" and xx': \"x =m x'\""], ["proof (prove)\nusing this:\n  \\<exists>x'\\<in>X. x =m x'\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x' \\<in> X; x =m x'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x' \\<in> X\n  x =m x'\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; rel_set MP_Rel xa ya;\n        \\<exists>y\\<in>xa. x =m y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; rel_set MP_Rel xa ya; y \\<in> ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>xa. x =m y", "with xy"], ["proof (chain)\npicking this:\n  MP_Rel x y\n  x' \\<in> X\n  x =m x'", "have x'y: \"MP_Rel x' y\""], ["proof (prove)\nusing this:\n  MP_Rel x y\n  x' \\<in> X\n  x =m x'\n\ngoal (1 subgoal):\n 1. MP_Rel x' y", "by (auto simp: MP_Rel_def)"], ["proof (state)\nthis:\n  MP_Rel x' y\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; rel_set MP_Rel xa ya;\n        \\<exists>y\\<in>xa. x =m y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; rel_set MP_Rel xa ya; y \\<in> ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>xa. x =m y", "from rel_setD1[OF XY x'X]"], ["proof (chain)\npicking this:\n  \\<exists>y\\<in>Y. MP_Rel x' y", "obtain y' where \"MP_Rel x' y'\" and \"y' \\<in> Y\""], ["proof (prove)\nusing this:\n  \\<exists>y\\<in>Y. MP_Rel x' y\n\ngoal (1 subgoal):\n 1. (\\<And>y'.\n        \\<lbrakk>MP_Rel x' y'; y' \\<in> Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  MP_Rel x' y'\n  y' \\<in> Y\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; rel_set MP_Rel xa ya;\n        \\<exists>y\\<in>xa. x =m y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; rel_set MP_Rel xa ya; y \\<in> ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>xa. x =m y", "with x'y"], ["proof (chain)\npicking this:\n  MP_Rel x' y\n  MP_Rel x' y'\n  y' \\<in> Y", "show \"y \\<in> Y\""], ["proof (prove)\nusing this:\n  MP_Rel x' y\n  MP_Rel x' y'\n  y' \\<in> Y\n\ngoal (1 subgoal):\n 1. y \\<in> Y", "by (auto simp: MP_Rel_def)"], ["proof (state)\nthis:\n  y \\<in> Y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; rel_set MP_Rel xa ya; y \\<in> ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>xa. x =m y", "}"], ["proof (state)\nthis:\n  \\<exists>x'\\<in>X. x =m x' \\<Longrightarrow> y \\<in> Y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; rel_set MP_Rel xa ya; y \\<in> ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>xa. x =m y", "assume \"y \\<in> Y\""], ["proof (state)\nthis:\n  y \\<in> Y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; rel_set MP_Rel xa ya; y \\<in> ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>xa. x =m y", "from rel_setD2[OF XY this]"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>X. MP_Rel x y", "obtain x' where x'X: \"x' \\<in> X\" and x'y: \"MP_Rel x' y\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>X. MP_Rel x y\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x' \\<in> X; MP_Rel x' y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x' \\<in> X\n  MP_Rel x' y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; rel_set MP_Rel xa ya; y \\<in> ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>xa. x =m y", "from xy x'y"], ["proof (chain)\npicking this:\n  MP_Rel x y\n  MP_Rel x' y", "have \"x =m x'\""], ["proof (prove)\nusing this:\n  MP_Rel x y\n  MP_Rel x' y\n\ngoal (1 subgoal):\n 1. x =m x'", "by (auto simp: MP_Rel_def)"], ["proof (state)\nthis:\n  x =m x'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; rel_set MP_Rel xa ya; y \\<in> ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>xa. x =m y", "with x'X"], ["proof (chain)\npicking this:\n  x' \\<in> X\n  x =m x'", "show \"\\<exists>x' \\<in> X. x =m x'\""], ["proof (prove)\nusing this:\n  x' \\<in> X\n  x =m x'\n\ngoal (1 subgoal):\n 1. \\<exists>x'\\<in>X. x =m x'", "by auto"], ["proof (state)\nthis:\n  \\<exists>x'\\<in>X. x =m x'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma conversep_MP_Rel_OO_MP_Rel [simp]: \"MP_Rel\\<inverse>\\<inverse> OO MP_Rel = (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel\\<inverse>\\<inverse> OO MP_Rel = (=)", "using Mp_to_int_poly"], ["proof (prove)\nusing this:\n  Mp (to_int_poly ?f) = to_int_poly ?f\n\ngoal (1 subgoal):\n 1. MP_Rel\\<inverse>\\<inverse> OO MP_Rel = (=)", "by (intro ext, auto simp: OO_def MP_Rel_def)"], ["", "lemma MP_Rel_OO_conversep_MP_Rel [simp]: \"MP_Rel OO MP_Rel\\<inverse>\\<inverse> = eq_m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel OO MP_Rel\\<inverse>\\<inverse> = (=m)", "by (intro ext, auto simp: OO_def MP_Rel_def Mp_f_representative)"], ["", "lemma conversep_MP_Rel_OO_eq_m [simp]: \"MP_Rel\\<inverse>\\<inverse> OO eq_m = MP_Rel\\<inverse>\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel\\<inverse>\\<inverse> OO (=m) = MP_Rel\\<inverse>\\<inverse>", "by (intro ext, auto simp: OO_def MP_Rel_def)"], ["", "lemma eq_m_OO_MP_Rel [simp]: \"eq_m OO MP_Rel = MP_Rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (=m) OO MP_Rel = MP_Rel", "by (intro ext, auto simp: OO_def MP_Rel_def)"], ["", "lemma eq_mset_MP_Rel [transfer_rule]: \"(rel_mset MP_Rel ===> rel_mset MP_Rel ===> (=)) (rel_mset eq_m) (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_mset MP_Rel ===> rel_mset MP_Rel ===> (=)) (rel_mset (=m)) (=)", "proof (intro rel_funI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset MP_Rel x y; rel_mset MP_Rel xa ya;\n        rel_mset (=m) x xa\\<rbrakk>\n       \\<Longrightarrow> y = ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset MP_Rel x y; rel_mset MP_Rel xa ya; y = ya\\<rbrakk>\n       \\<Longrightarrow> rel_mset (=m) x xa", "fix A B X Y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset MP_Rel x y; rel_mset MP_Rel xa ya;\n        rel_mset (=m) x xa\\<rbrakk>\n       \\<Longrightarrow> y = ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset MP_Rel x y; rel_mset MP_Rel xa ya; y = ya\\<rbrakk>\n       \\<Longrightarrow> rel_mset (=m) x xa", "assume AX: \"rel_mset MP_Rel A X\" and BY: \"rel_mset MP_Rel B Y\""], ["proof (state)\nthis:\n  rel_mset MP_Rel A X\n  rel_mset MP_Rel B Y\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset MP_Rel x y; rel_mset MP_Rel xa ya;\n        rel_mset (=m) x xa\\<rbrakk>\n       \\<Longrightarrow> y = ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset MP_Rel x y; rel_mset MP_Rel xa ya; y = ya\\<rbrakk>\n       \\<Longrightarrow> rel_mset (=m) x xa", "{"], ["proof (state)\nthis:\n  rel_mset MP_Rel A X\n  rel_mset MP_Rel B Y\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset MP_Rel x y; rel_mset MP_Rel xa ya;\n        rel_mset (=m) x xa\\<rbrakk>\n       \\<Longrightarrow> y = ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset MP_Rel x y; rel_mset MP_Rel xa ya; y = ya\\<rbrakk>\n       \\<Longrightarrow> rel_mset (=m) x xa", "assume AB: \"rel_mset eq_m A B\""], ["proof (state)\nthis:\n  rel_mset (=m) A B\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset MP_Rel x y; rel_mset MP_Rel xa ya;\n        rel_mset (=m) x xa\\<rbrakk>\n       \\<Longrightarrow> y = ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset MP_Rel x y; rel_mset MP_Rel xa ya; y = ya\\<rbrakk>\n       \\<Longrightarrow> rel_mset (=m) x xa", "from AX"], ["proof (chain)\npicking this:\n  rel_mset MP_Rel A X", "have \"rel_mset MP_Rel\\<inverse>\\<inverse> X A\""], ["proof (prove)\nusing this:\n  rel_mset MP_Rel A X\n\ngoal (1 subgoal):\n 1. rel_mset MP_Rel\\<inverse>\\<inverse> X A", "by (simp add: multiset.rel_flip)"], ["proof (state)\nthis:\n  rel_mset MP_Rel\\<inverse>\\<inverse> X A\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset MP_Rel x y; rel_mset MP_Rel xa ya;\n        rel_mset (=m) x xa\\<rbrakk>\n       \\<Longrightarrow> y = ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset MP_Rel x y; rel_mset MP_Rel xa ya; y = ya\\<rbrakk>\n       \\<Longrightarrow> rel_mset (=m) x xa", "note rel_mset_OO[OF this AB]"], ["proof (state)\nthis:\n  rel_mset (MP_Rel\\<inverse>\\<inverse> OO (=m)) X B\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset MP_Rel x y; rel_mset MP_Rel xa ya;\n        rel_mset (=m) x xa\\<rbrakk>\n       \\<Longrightarrow> y = ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset MP_Rel x y; rel_mset MP_Rel xa ya; y = ya\\<rbrakk>\n       \\<Longrightarrow> rel_mset (=m) x xa", "note rel_mset_OO[OF this BY]"], ["proof (state)\nthis:\n  rel_mset ((MP_Rel\\<inverse>\\<inverse> OO (=m)) OO MP_Rel) X Y\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset MP_Rel x y; rel_mset MP_Rel xa ya;\n        rel_mset (=m) x xa\\<rbrakk>\n       \\<Longrightarrow> y = ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset MP_Rel x y; rel_mset MP_Rel xa ya; y = ya\\<rbrakk>\n       \\<Longrightarrow> rel_mset (=m) x xa", "then"], ["proof (chain)\npicking this:\n  rel_mset ((MP_Rel\\<inverse>\\<inverse> OO (=m)) OO MP_Rel) X Y", "show \"X = Y\""], ["proof (prove)\nusing this:\n  rel_mset ((MP_Rel\\<inverse>\\<inverse> OO (=m)) OO MP_Rel) X Y\n\ngoal (1 subgoal):\n 1. X = Y", "by (simp add: multiset.rel_eq)"], ["proof (state)\nthis:\n  X = Y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset MP_Rel x y; rel_mset MP_Rel xa ya; y = ya\\<rbrakk>\n       \\<Longrightarrow> rel_mset (=m) x xa", "}"], ["proof (state)\nthis:\n  rel_mset (=m) A B \\<Longrightarrow> X = Y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset MP_Rel x y; rel_mset MP_Rel xa ya; y = ya\\<rbrakk>\n       \\<Longrightarrow> rel_mset (=m) x xa", "assume \"X = Y\""], ["proof (state)\nthis:\n  X = Y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset MP_Rel x y; rel_mset MP_Rel xa ya; y = ya\\<rbrakk>\n       \\<Longrightarrow> rel_mset (=m) x xa", "with BY"], ["proof (chain)\npicking this:\n  rel_mset MP_Rel B Y\n  X = Y", "have \"rel_mset MP_Rel\\<inverse>\\<inverse> X B\""], ["proof (prove)\nusing this:\n  rel_mset MP_Rel B Y\n  X = Y\n\ngoal (1 subgoal):\n 1. rel_mset MP_Rel\\<inverse>\\<inverse> X B", "by (simp add: multiset.rel_flip)"], ["proof (state)\nthis:\n  rel_mset MP_Rel\\<inverse>\\<inverse> X B\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset MP_Rel x y; rel_mset MP_Rel xa ya; y = ya\\<rbrakk>\n       \\<Longrightarrow> rel_mset (=m) x xa", "from rel_mset_OO[OF AX this]"], ["proof (chain)\npicking this:\n  rel_mset (MP_Rel OO MP_Rel\\<inverse>\\<inverse>) A B", "show \"rel_mset eq_m A B\""], ["proof (prove)\nusing this:\n  rel_mset (MP_Rel OO MP_Rel\\<inverse>\\<inverse>) A B\n\ngoal (1 subgoal):\n 1. rel_mset (=m) A B", "by simp"], ["proof (state)\nthis:\n  rel_mset (=m) A B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dvd_MP_Rel[transfer_rule]: \"(MP_Rel ===> MP_Rel ===> (=)) (dvdm) (dvd)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MP_Rel ===> MP_Rel ===> (=)) (dvdm) (dvd)", "unfolding dvdm_def[abs_def] dvd_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (MP_Rel ===> MP_Rel ===> (=)) (\\<lambda>f g. \\<exists>h. g =m f * h)\n     (\\<lambda>b a. \\<exists>k. a = b * k)", "by transfer_prover"], ["", "lemma irreducible_MP_Rel [transfer_rule]: \"(MP_Rel ===> (=)) irreducible_m irreducible\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MP_Rel ===> (=)) irreducible_m irreducible", "unfolding irreducible_m_def irreducible_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (MP_Rel ===> (=))\n     (\\<lambda>f.\n         Mp f \\<noteq> Mp 0 \\<and>\n         \\<not> f dvdm 1 \\<and>\n         (\\<forall>a b.\n             f =m a * b \\<longrightarrow> a dvdm 1 \\<or> b dvdm 1))\n     (\\<lambda>p.\n         p \\<noteq> 0 \\<and>\n         \\<not> p dvd 1 \\<and>\n         (\\<forall>a b. p = a * b \\<longrightarrow> a dvd 1 \\<or> b dvd 1))", "by transfer_prover"], ["", "lemma irreducible\\<^sub>d_MP_Rel [transfer_rule]: \"(MP_Rel ===> (=)) irreducible\\<^sub>d_m irreducible\\<^sub>d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MP_Rel ===> (=)) irreducible\\<^sub>d_m irreducible\\<^sub>d", "unfolding irreducible\\<^sub>d_m_def[abs_def] irreducible\\<^sub>d_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (MP_Rel ===> (=))\n     (\\<lambda>f.\n         0 < degree_m f \\<and>\n         (\\<forall>g h.\n             degree_m g < degree_m f \\<longrightarrow>\n             degree_m h < degree_m f \\<longrightarrow>\n             Mp f \\<noteq> Mp (g * h)))\n     (\\<lambda>p.\n         0 < degree p \\<and>\n         (\\<forall>q r.\n             degree q < degree p \\<longrightarrow>\n             degree r < degree p \\<longrightarrow> p \\<noteq> q * r))", "by transfer_prover"], ["", "lemma UNIV_M_Rel[transfer_rule]: \"rel_set M_Rel {0..<m} UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_set M_Rel {0..<m} UNIV", "unfolding rel_set_def M_Rel_def[abs_def] M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>{0..<m}.\n        \\<exists>x'\\<in>UNIV. x mod m = to_int_mod_ring x') \\<and>\n    (\\<forall>y\\<in>UNIV.\n        \\<exists>x\\<in>{0..<m}. x mod m = to_int_mod_ring y)", "by (auto simp: M_def m, goal_cases, metis to_int_mod_ring_of_int_mod_ring, (transfer, auto)+)"], ["", "lemma coeff_MP_Rel [transfer_rule]: \"(MP_Rel ===> (=) ===> M_Rel) coeff coeff\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MP_Rel ===> (=) ===> M_Rel) poly.coeff poly.coeff", "unfolding rel_fun_def M_Rel_def MP_Rel_def Mp_coeff[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       Mp x = to_int_poly y \\<longrightarrow>\n       (\\<forall>xa ya.\n           xa = ya \\<longrightarrow>\n           poly.coeff (Mp x) xa = to_int_mod_ring (poly.coeff y ya))", "by auto"], ["", "lemma M_1_1: \"M 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M 1 = 1", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 mod m = 1", "unfolding m"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 mod int CARD('a) = 1", "by simp"], ["", "lemma square_free_MP_Rel [transfer_rule]: \"(MP_Rel ===> (=)) square_free_m square_free\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MP_Rel ===> (=)) square_free_m square_free", "unfolding square_free_m_def[abs_def] square_free_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (MP_Rel ===> (=))\n     (\\<lambda>f.\n         Mp f \\<noteq> Mp 0 \\<and>\n         (\\<forall>g.\n             degree_m g \\<noteq> 0 \\<longrightarrow> \\<not> g * g dvdm f))\n     (\\<lambda>p.\n         p \\<noteq> 0 \\<and>\n         (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd p))", "by (transfer_prover_start, transfer_step+, auto)"], ["", "lemma mset_factors_m_MP_Rel [transfer_rule]: \"(rel_mset MP_Rel ===> MP_Rel ===> (=)) mset_factors_m mset_factors\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_mset MP_Rel ===> MP_Rel ===> (=)) mset_factors_m mset_factors", "unfolding mset_factors_def mset_factors_m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_mset MP_Rel ===> MP_Rel ===> (=))\n     (\\<lambda>F p.\n         F \\<noteq> {#} \\<and>\n         (\\<forall>f. f \\<in># F \\<longrightarrow> irreducible_m f) \\<and>\n         p =m \\<Prod>\\<^sub># F)\n     (\\<lambda>F p.\n         F \\<noteq> {#} \\<and>\n         (\\<forall>f. f \\<in># F \\<longrightarrow> irreducible f) \\<and>\n         p = \\<Prod>\\<^sub># F)", "by (transfer_prover_start, transfer_step+, auto dest:eq_m_irreducible_m)"], ["", "lemma coprime_MP_Rel [transfer_rule]: \"(MP_Rel ===> MP_Rel ===> (=)) coprime_m coprime\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MP_Rel ===> MP_Rel ===> (=)) coprime_m comm_monoid_mult_class.coprime", "unfolding coprime_m_def[abs_def] coprime_def' [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (MP_Rel ===> MP_Rel ===> (=))\n     (\\<lambda>f g.\n         \\<forall>h.\n            h dvdm f \\<longrightarrow> h dvdm g \\<longrightarrow> h dvdm 1)\n     (\\<lambda>p q.\n         \\<forall>r.\n            r dvd p \\<longrightarrow> r dvd q \\<longrightarrow> r dvd 1)", "by (transfer_prover_start, transfer_step+, auto)"], ["", "lemma prime_elem_MP_Rel [transfer_rule]: \"(MP_Rel ===> (=)) prime_elem_m prime_elem\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MP_Rel ===> (=)) prime_elem_m prime_elem", "unfolding prime_elem_m_def prime_elem_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (MP_Rel ===> (=))\n     (\\<lambda>f.\n         Mp f \\<noteq> Mp 0 \\<and>\n         \\<not> f dvdm 1 \\<and>\n         (\\<forall>g h.\n             f dvdm g * h \\<longrightarrow> f dvdm g \\<or> f dvdm h))\n     (\\<lambda>p.\n         p \\<noteq> 0 \\<and>\n         \\<not> p dvd 1 \\<and>\n         (\\<forall>a b.\n             p dvd a * b \\<longrightarrow> p dvd a \\<or> p dvd b))", "by transfer_prover"], ["", "end"], ["", "context poly_mod_2 begin"], ["", "lemma non_empty: \"{0..<m} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<m} \\<noteq> {}", "using m1"], ["proof (prove)\nusing this:\n  1 < m\n\ngoal (1 subgoal):\n 1. {0..<m} \\<noteq> {}", "by auto"], ["", "lemma type_to_set:\n  assumes type_def: \"\\<exists>(Rep :: 'b \\<Rightarrow> int) Abs. type_definition Rep Abs {0 ..< m :: int}\"\n  shows \"class.nontriv (TYPE('b))\" (is ?a) and \"m = int CARD('b)\" (is ?b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.nontriv TYPE('b) &&& m = int CARD('b)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. class.nontriv TYPE('b)\n 2. m = int CARD('b)", "from type_def"], ["proof (chain)\npicking this:\n  \\<exists>Rep Abs. type_definition Rep Abs {0..<m}", "obtain rep :: \"'b \\<Rightarrow> int\" and abs :: \"int \\<Rightarrow> 'b\" where t: \"type_definition rep abs {0 ..< m}\""], ["proof (prove)\nusing this:\n  \\<exists>Rep Abs. type_definition Rep Abs {0..<m}\n\ngoal (1 subgoal):\n 1. (\\<And>rep abs.\n        type_definition rep abs {0..<m} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  type_definition rep abs {0..<m}\n\ngoal (2 subgoals):\n 1. class.nontriv TYPE('b)\n 2. m = int CARD('b)", "have \"card (UNIV :: 'b set) = card {0 ..< m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('b) = card {0..<m}", "using t"], ["proof (prove)\nusing this:\n  type_definition rep abs {0..<m}\n\ngoal (1 subgoal):\n 1. CARD('b) = card {0..<m}", "by (rule type_definition.card)"], ["proof (state)\nthis:\n  CARD('b) = card {0..<m}\n\ngoal (2 subgoals):\n 1. class.nontriv TYPE('b)\n 2. m = int CARD('b)", "also"], ["proof (state)\nthis:\n  CARD('b) = card {0..<m}\n\ngoal (2 subgoals):\n 1. class.nontriv TYPE('b)\n 2. m = int CARD('b)", "have \"\\<dots> = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card {0..<m}) = m", "using m1"], ["proof (prove)\nusing this:\n  1 < m\n\ngoal (1 subgoal):\n 1. int (card {0..<m}) = m", "by auto"], ["proof (state)\nthis:\n  int (card {0..<m}) = m\n\ngoal (2 subgoals):\n 1. class.nontriv TYPE('b)\n 2. m = int CARD('b)", "finally"], ["proof (chain)\npicking this:\n  int CARD('b) = m", "show ?b"], ["proof (prove)\nusing this:\n  int CARD('b) = m\n\ngoal (1 subgoal):\n 1. m = int CARD('b)", ".."], ["proof (state)\nthis:\n  m = int CARD('b)\n\ngoal (1 subgoal):\n 1. class.nontriv TYPE('b)", "then"], ["proof (chain)\npicking this:\n  m = int CARD('b)", "show ?a"], ["proof (prove)\nusing this:\n  m = int CARD('b)\n\ngoal (1 subgoal):\n 1. class.nontriv TYPE('b)", "unfolding class.nontriv_def"], ["proof (prove)\nusing this:\n  m = int CARD('b)\n\ngoal (1 subgoal):\n 1. 1 < CARD('b)", "using m1"], ["proof (prove)\nusing this:\n  m = int CARD('b)\n  1 < m\n\ngoal (1 subgoal):\n 1. 1 < CARD('b)", "by auto"], ["proof (state)\nthis:\n  class.nontriv TYPE('b)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale poly_mod_prime_type = poly_mod_type m ty for m :: int and\n  ty :: \"'a :: prime_card itself\"\nbegin"], ["", "lemma factorization_MP_Rel [transfer_rule]:\n  \"(MP_Rel ===> MF_Rel ===> (=)) factorization_m (factorization Irr_Mon)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MP_Rel ===> MF_Rel ===> (=)) factorization_m (factorization Irr_Mon)", "unfolding rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       MP_Rel x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           MF_Rel xa ya \\<longrightarrow>\n           factorization_m x xa = factorization Irr_Mon y ya)", "proof (intro allI impI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> factorization_m x xa = factorization Irr_Mon y ya", "case (1 f F cfs Cfs)"], ["proof (state)\nthis:\n  MP_Rel f F\n  MF_Rel cfs Cfs\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> factorization_m x xa = factorization Irr_Mon y ya", "note [transfer_rule] = 1(1)"], ["proof (state)\nthis:\n  MP_Rel f F\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> factorization_m x xa = factorization Irr_Mon y ya", "obtain c fs where cfs: \"cfs = (c,fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c fs. cfs = (c, fs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  cfs = (c, fs)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> factorization_m x xa = factorization Irr_Mon y ya", "obtain C Fs where Cfs: \"Cfs = (C,Fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C Fs. Cfs = (C, Fs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  Cfs = (C, Fs)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> factorization_m x xa = factorization Irr_Mon y ya", "from 1(2)[unfolded rel_prod.simps cfs Cfs MF_Rel_def]"], ["proof (chain)\npicking this:\n  \\<exists>a b ca d.\n     (c, fs) = (a, ca) \\<and>\n     (C, Fs) = (b, d) \\<and> M_Rel a b \\<and> rel_mset MP_Rel ca d", "have tr[transfer_rule]: \"M_Rel c C\" \"rel_mset MP_Rel fs Fs\""], ["proof (prove)\nusing this:\n  \\<exists>a b ca d.\n     (c, fs) = (a, ca) \\<and>\n     (C, Fs) = (b, d) \\<and> M_Rel a b \\<and> rel_mset MP_Rel ca d\n\ngoal (1 subgoal):\n 1. M_Rel c C &&& rel_mset MP_Rel fs Fs", "by auto"], ["proof (state)\nthis:\n  M_Rel c C\n  rel_mset MP_Rel fs Fs\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> factorization_m x xa = factorization Irr_Mon y ya", "have eq: \"(f =m smult c (prod_mset fs) = (F = smult C (prod_mset Fs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f =m Polynomial.smult c (\\<Prod>\\<^sub># fs)) =\n    (F = Polynomial.smult C (\\<Prod>\\<^sub># Fs))", "by transfer_prover"], ["proof (state)\nthis:\n  (f =m Polynomial.smult c (\\<Prod>\\<^sub># fs)) =\n  (F = Polynomial.smult C (\\<Prod>\\<^sub># Fs))\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> factorization_m x xa = factorization Irr_Mon y ya", "have \"set_mset Fs \\<subseteq> Irr_Mon = (\\<forall> x \\<in># Fs. irreducible\\<^sub>d x \\<and> monic x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set_mset Fs \\<subseteq> Irr_Mon) =\n    (\\<forall>x\\<in>#Fs. irreducible\\<^sub>d x \\<and> monic x)", "unfolding Irr_Mon_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (set_mset Fs \\<subseteq> {x. irreducible x \\<and> monic x}) =\n    (\\<forall>x\\<in>#Fs. irreducible\\<^sub>d x \\<and> monic x)", "by auto"], ["proof (state)\nthis:\n  (set_mset Fs \\<subseteq> Irr_Mon) =\n  (\\<forall>x\\<in>#Fs. irreducible\\<^sub>d x \\<and> monic x)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> factorization_m x xa = factorization Irr_Mon y ya", "also"], ["proof (state)\nthis:\n  (set_mset Fs \\<subseteq> Irr_Mon) =\n  (\\<forall>x\\<in>#Fs. irreducible\\<^sub>d x \\<and> monic x)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> factorization_m x xa = factorization Irr_Mon y ya", "have \"\\<dots> = (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>#Fs. irreducible\\<^sub>d x \\<and> monic x) =\n    (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))", "proof (rule sym, transfer_prover_start, transfer_step+)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f)) =\n    (\\<forall>x\\<in>#fs.\n        irreducible\\<^sub>d_m x \\<and> M (poly.coeff x (degree_m x)) = M 1)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f)) =\n    (\\<forall>x\\<in>#fs.\n        irreducible\\<^sub>d_m x \\<and> M (poly.coeff x (degree_m x)) = M 1)", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f)) =\n    (\\<forall>x\\<in>#fs.\n        irreducible\\<^sub>d_m x \\<and> M (poly.coeff x (degree_m x)) = M 1)", "assume \"f \\<in># fs\""], ["proof (state)\nthis:\n  f \\<in># fs\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f)) =\n    (\\<forall>x\\<in>#fs.\n        irreducible\\<^sub>d_m x \\<and> M (poly.coeff x (degree_m x)) = M 1)", "have \"monic (Mp f) \\<longleftrightarrow> M (coeff f (degree_m f)) = M 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (Mp f) = (M (poly.coeff f (degree_m f)) = M 1)", "unfolding Mp_coeff[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (Mp f) = (lead_coeff (Mp f) = M 1)", "by simp"], ["proof (state)\nthis:\n  monic (Mp f) = (M (poly.coeff f (degree_m f)) = M 1)\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f)) =\n    (\\<forall>x\\<in>#fs.\n        irreducible\\<^sub>d_m x \\<and> M (poly.coeff x (degree_m x)) = M 1)", "}"], ["proof (state)\nthis:\n  ?fa2 \\<in># fs \\<Longrightarrow>\n  monic (Mp ?fa2) = (M (poly.coeff ?fa2 (degree_m ?fa2)) = M 1)\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f)) =\n    (\\<forall>x\\<in>#fs.\n        irreducible\\<^sub>d_m x \\<and> M (poly.coeff x (degree_m x)) = M 1)", "thus \"(\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f)) = \n      (\\<forall>x\\<in>#fs. irreducible\\<^sub>d_m x \\<and> M (coeff x (degree_m x)) = M 1)\""], ["proof (prove)\nusing this:\n  ?fa2 \\<in># fs \\<Longrightarrow>\n  monic (Mp ?fa2) = (M (poly.coeff ?fa2 (degree_m ?fa2)) = M 1)\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f)) =\n    (\\<forall>x\\<in>#fs.\n        irreducible\\<^sub>d_m x \\<and> M (poly.coeff x (degree_m x)) = M 1)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f)) =\n  (\\<forall>x\\<in>#fs.\n      irreducible\\<^sub>d_m x \\<and> M (poly.coeff x (degree_m x)) = M 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>#Fs. irreducible\\<^sub>d x \\<and> monic x) =\n  (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> factorization_m x xa = factorization Irr_Mon y ya", "finally"], ["proof (chain)\npicking this:\n  (set_mset Fs \\<subseteq> Irr_Mon) =\n  (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))", "show \"factorization_m f cfs = factorization Irr_Mon F Cfs\""], ["proof (prove)\nusing this:\n  (set_mset Fs \\<subseteq> Irr_Mon) =\n  (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n\ngoal (1 subgoal):\n 1. factorization_m f cfs = factorization Irr_Mon F Cfs", "unfolding cfs Cfs\n    factorization_m_def factorization_def split eq"], ["proof (prove)\nusing this:\n  (set_mset Fs \\<subseteq> Irr_Mon) =\n  (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n\ngoal (1 subgoal):\n 1. (F = Polynomial.smult C (\\<Prod>\\<^sub># Fs) \\<and>\n     (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))) =\n    (F = Polynomial.smult C (\\<Prod>\\<^sub># Fs) \\<and>\n     set_mset Fs \\<subseteq> Irr_Mon)", "by simp"], ["proof (state)\nthis:\n  factorization_m f cfs = factorization Irr_Mon F Cfs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unique_factorization_MP_Rel [transfer_rule]: \"(MP_Rel ===> MF_Rel ===> (=))\n  unique_factorization_m (unique_factorization Irr_Mon)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MP_Rel ===> MF_Rel ===> (=)) unique_factorization_m\n     (unique_factorization Irr_Mon)", "unfolding rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       MP_Rel x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           MF_Rel xa ya \\<longrightarrow>\n           unique_factorization_m x xa = unique_factorization Irr_Mon y ya)", "proof (intro allI impI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> unique_factorization_m x xa =\n                         unique_factorization Irr_Mon y ya", "case (1 f F cfs Cfs)"], ["proof (state)\nthis:\n  MP_Rel f F\n  MF_Rel cfs Cfs\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> unique_factorization_m x xa =\n                         unique_factorization Irr_Mon y ya", "note [transfer_rule] = 1(1,2)"], ["proof (state)\nthis:\n  MP_Rel f F\n  MF_Rel cfs Cfs\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> unique_factorization_m x xa =\n                         unique_factorization Irr_Mon y ya", "let ?F = \"factorization Irr_Mon F\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> unique_factorization_m x xa =\n                         unique_factorization Irr_Mon y ya", "let ?f = \"factorization_m f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> unique_factorization_m x xa =\n                         unique_factorization Irr_Mon y ya", "let ?R = \"Collect ?F\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> unique_factorization_m x xa =\n                         unique_factorization Irr_Mon y ya", "let ?L = \"Mf ` Collect ?f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> unique_factorization_m x xa =\n                         unique_factorization Irr_Mon y ya", "note X_to_x = right_total_MF_Rel[unfolded right_total_def, rule_format]"], ["proof (state)\nthis:\n  \\<exists>x. MF_Rel x ?y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> unique_factorization_m x xa =\n                         unique_factorization Irr_Mon y ya", "{"], ["proof (state)\nthis:\n  \\<exists>x. MF_Rel x ?y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> unique_factorization_m x xa =\n                         unique_factorization Irr_Mon y ya", "fix X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> unique_factorization_m x xa =\n                         unique_factorization Irr_Mon y ya", "assume \"X \\<in> ?R\""], ["proof (state)\nthis:\n  X \\<in> Collect (factorization Irr_Mon F)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> unique_factorization_m x xa =\n                         unique_factorization Irr_Mon y ya", "hence F: \"?F X\""], ["proof (prove)\nusing this:\n  X \\<in> Collect (factorization Irr_Mon F)\n\ngoal (1 subgoal):\n 1. factorization Irr_Mon F X", "by simp"], ["proof (state)\nthis:\n  factorization Irr_Mon F X\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> unique_factorization_m x xa =\n                         unique_factorization Irr_Mon y ya", "from X_to_x[of X]"], ["proof (chain)\npicking this:\n  \\<exists>x. MF_Rel x X", "obtain x where rel[transfer_rule]: \"MF_Rel x X\""], ["proof (prove)\nusing this:\n  \\<exists>x. MF_Rel x X\n\ngoal (1 subgoal):\n 1. (\\<And>x. MF_Rel x X \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  MF_Rel x X\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> unique_factorization_m x xa =\n                         unique_factorization Irr_Mon y ya", "from F[untransferred]"], ["proof (chain)\npicking this:\n  factorization_m f x", "have \"Mf x \\<in> ?L\""], ["proof (prove)\nusing this:\n  factorization_m f x\n\ngoal (1 subgoal):\n 1. Mf x \\<in> Mf ` Collect (factorization_m f)", "by blast"], ["proof (state)\nthis:\n  Mf x \\<in> Mf ` Collect (factorization_m f)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> unique_factorization_m x xa =\n                         unique_factorization Irr_Mon y ya", "with rel"], ["proof (chain)\npicking this:\n  MF_Rel x X\n  Mf x \\<in> Mf ` Collect (factorization_m f)", "have \"\\<exists> x. Mf x \\<in> ?L \\<and> MF_Rel x X\""], ["proof (prove)\nusing this:\n  MF_Rel x X\n  Mf x \\<in> Mf ` Collect (factorization_m f)\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       Mf x \\<in> Mf ` Collect (factorization_m f) \\<and> MF_Rel x X", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. Mf x \\<in> Mf ` Collect (factorization_m f) \\<and> MF_Rel x X\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> unique_factorization_m x xa =\n                         unique_factorization Irr_Mon y ya", "}"], ["proof (state)\nthis:\n  ?X2 \\<in> Collect (factorization Irr_Mon F) \\<Longrightarrow>\n  \\<exists>x.\n     Mf x \\<in> Mf ` Collect (factorization_m f) \\<and> MF_Rel x ?X2\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> unique_factorization_m x xa =\n                         unique_factorization Irr_Mon y ya", "note R_to_L = this"], ["proof (state)\nthis:\n  ?X2 \\<in> Collect (factorization Irr_Mon F) \\<Longrightarrow>\n  \\<exists>x.\n     Mf x \\<in> Mf ` Collect (factorization_m f) \\<and> MF_Rel x ?X2\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>MP_Rel x y; MF_Rel xa ya\\<rbrakk>\n       \\<Longrightarrow> unique_factorization_m x xa =\n                         unique_factorization Irr_Mon y ya", "show \"unique_factorization_m f cfs = unique_factorization Irr_Mon F Cfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_factorization_m f cfs = unique_factorization Irr_Mon F Cfs", "unfolding \n    unique_factorization_m_def unique_factorization_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mf ` Collect (factorization_m f) = {Mf cfs}) =\n    (Collect (factorization Irr_Mon F) = {Cfs})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (Mf ` Collect (factorization_m f) = {Mf cfs}) =\n    (Collect (factorization Irr_Mon F) = {Cfs})", "have fF: \"?F Cfs = ?f cfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. factorization Irr_Mon F Cfs = factorization_m f cfs", "by transfer simp"], ["proof (state)\nthis:\n  factorization Irr_Mon F Cfs = factorization_m f cfs\n\ngoal (1 subgoal):\n 1. (Mf ` Collect (factorization_m f) = {Mf cfs}) =\n    (Collect (factorization Irr_Mon F) = {Cfs})", "have \"(?L = {Mf cfs}) = (?L \\<subseteq> {Mf cfs} \\<and> Mf cfs \\<in> ?L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mf ` Collect (factorization_m f) = {Mf cfs}) =\n    (Mf ` Collect (factorization_m f) \\<subseteq> {Mf cfs} \\<and>\n     Mf cfs \\<in> Mf ` Collect (factorization_m f))", "by blast"], ["proof (state)\nthis:\n  (Mf ` Collect (factorization_m f) = {Mf cfs}) =\n  (Mf ` Collect (factorization_m f) \\<subseteq> {Mf cfs} \\<and>\n   Mf cfs \\<in> Mf ` Collect (factorization_m f))\n\ngoal (1 subgoal):\n 1. (Mf ` Collect (factorization_m f) = {Mf cfs}) =\n    (Collect (factorization Irr_Mon F) = {Cfs})", "also"], ["proof (state)\nthis:\n  (Mf ` Collect (factorization_m f) = {Mf cfs}) =\n  (Mf ` Collect (factorization_m f) \\<subseteq> {Mf cfs} \\<and>\n   Mf cfs \\<in> Mf ` Collect (factorization_m f))\n\ngoal (1 subgoal):\n 1. (Mf ` Collect (factorization_m f) = {Mf cfs}) =\n    (Collect (factorization Irr_Mon F) = {Cfs})", "have \"?L \\<subseteq> {Mf cfs} = (\\<forall> dfs. ?f dfs \\<longrightarrow> Mf dfs = Mf cfs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mf ` Collect (factorization_m f) \\<subseteq> {Mf cfs}) =\n    (\\<forall>dfs. factorization_m f dfs \\<longrightarrow> Mf dfs = Mf cfs)", "by blast"], ["proof (state)\nthis:\n  (Mf ` Collect (factorization_m f) \\<subseteq> {Mf cfs}) =\n  (\\<forall>dfs. factorization_m f dfs \\<longrightarrow> Mf dfs = Mf cfs)\n\ngoal (1 subgoal):\n 1. (Mf ` Collect (factorization_m f) = {Mf cfs}) =\n    (Collect (factorization Irr_Mon F) = {Cfs})", "also"], ["proof (state)\nthis:\n  (Mf ` Collect (factorization_m f) \\<subseteq> {Mf cfs}) =\n  (\\<forall>dfs. factorization_m f dfs \\<longrightarrow> Mf dfs = Mf cfs)\n\ngoal (1 subgoal):\n 1. (Mf ` Collect (factorization_m f) = {Mf cfs}) =\n    (Collect (factorization Irr_Mon F) = {Cfs})", "have \"\\<dots> = (\\<forall> y. ?F y \\<longrightarrow> y = Cfs)\" (is \"?left = ?right\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>dfs.\n        factorization_m f dfs \\<longrightarrow> Mf dfs = Mf cfs) =\n    (\\<forall>y. factorization Irr_Mon F y \\<longrightarrow> y = Cfs)", "proof (rule; intro allI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>\\<forall>dfs.\n                   factorization_m f dfs \\<longrightarrow> Mf dfs = Mf cfs;\n        factorization Irr_Mon F y\\<rbrakk>\n       \\<Longrightarrow> y = Cfs\n 2. \\<And>dfs.\n       \\<lbrakk>\\<forall>y.\n                   factorization Irr_Mon F y \\<longrightarrow> y = Cfs;\n        factorization_m f dfs\\<rbrakk>\n       \\<Longrightarrow> Mf dfs = Mf cfs", "fix Dfs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>\\<forall>dfs.\n                   factorization_m f dfs \\<longrightarrow> Mf dfs = Mf cfs;\n        factorization Irr_Mon F y\\<rbrakk>\n       \\<Longrightarrow> y = Cfs\n 2. \\<And>dfs.\n       \\<lbrakk>\\<forall>y.\n                   factorization Irr_Mon F y \\<longrightarrow> y = Cfs;\n        factorization_m f dfs\\<rbrakk>\n       \\<Longrightarrow> Mf dfs = Mf cfs", "assume *: ?left and F: \"?F Dfs\""], ["proof (state)\nthis:\n  \\<forall>dfs. factorization_m f dfs \\<longrightarrow> Mf dfs = Mf cfs\n  factorization Irr_Mon F Dfs\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>\\<forall>dfs.\n                   factorization_m f dfs \\<longrightarrow> Mf dfs = Mf cfs;\n        factorization Irr_Mon F y\\<rbrakk>\n       \\<Longrightarrow> y = Cfs\n 2. \\<And>dfs.\n       \\<lbrakk>\\<forall>y.\n                   factorization Irr_Mon F y \\<longrightarrow> y = Cfs;\n        factorization_m f dfs\\<rbrakk>\n       \\<Longrightarrow> Mf dfs = Mf cfs", "from X_to_x[of Dfs]"], ["proof (chain)\npicking this:\n  \\<exists>x. MF_Rel x Dfs", "obtain dfs where [transfer_rule]: \"MF_Rel dfs Dfs\""], ["proof (prove)\nusing this:\n  \\<exists>x. MF_Rel x Dfs\n\ngoal (1 subgoal):\n 1. (\\<And>dfs. MF_Rel dfs Dfs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  MF_Rel dfs Dfs\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>\\<forall>dfs.\n                   factorization_m f dfs \\<longrightarrow> Mf dfs = Mf cfs;\n        factorization Irr_Mon F y\\<rbrakk>\n       \\<Longrightarrow> y = Cfs\n 2. \\<And>dfs.\n       \\<lbrakk>\\<forall>y.\n                   factorization Irr_Mon F y \\<longrightarrow> y = Cfs;\n        factorization_m f dfs\\<rbrakk>\n       \\<Longrightarrow> Mf dfs = Mf cfs", "from F[untransferred]"], ["proof (chain)\npicking this:\n  factorization_m f dfs", "have f: \"?f dfs\""], ["proof (prove)\nusing this:\n  factorization_m f dfs\n\ngoal (1 subgoal):\n 1. factorization_m f dfs", "."], ["proof (state)\nthis:\n  factorization_m f dfs\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>\\<forall>dfs.\n                   factorization_m f dfs \\<longrightarrow> Mf dfs = Mf cfs;\n        factorization Irr_Mon F y\\<rbrakk>\n       \\<Longrightarrow> y = Cfs\n 2. \\<And>dfs.\n       \\<lbrakk>\\<forall>y.\n                   factorization Irr_Mon F y \\<longrightarrow> y = Cfs;\n        factorization_m f dfs\\<rbrakk>\n       \\<Longrightarrow> Mf dfs = Mf cfs", "from *[rule_format, OF f]"], ["proof (chain)\npicking this:\n  Mf dfs = Mf cfs", "have eq: \"Mf dfs = Mf cfs\""], ["proof (prove)\nusing this:\n  Mf dfs = Mf cfs\n\ngoal (1 subgoal):\n 1. Mf dfs = Mf cfs", "by simp"], ["proof (state)\nthis:\n  Mf dfs = Mf cfs\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>\\<forall>dfs.\n                   factorization_m f dfs \\<longrightarrow> Mf dfs = Mf cfs;\n        factorization Irr_Mon F y\\<rbrakk>\n       \\<Longrightarrow> y = Cfs\n 2. \\<And>dfs.\n       \\<lbrakk>\\<forall>y.\n                   factorization Irr_Mon F y \\<longrightarrow> y = Cfs;\n        factorization_m f dfs\\<rbrakk>\n       \\<Longrightarrow> Mf dfs = Mf cfs", "have \"(Mf dfs = Mf cfs) = (Dfs = Cfs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mf dfs = Mf cfs) = (Dfs = Cfs)", "by (transfer_prover_start, transfer_step+, simp)"], ["proof (state)\nthis:\n  (Mf dfs = Mf cfs) = (Dfs = Cfs)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>\\<forall>dfs.\n                   factorization_m f dfs \\<longrightarrow> Mf dfs = Mf cfs;\n        factorization Irr_Mon F y\\<rbrakk>\n       \\<Longrightarrow> y = Cfs\n 2. \\<And>dfs.\n       \\<lbrakk>\\<forall>y.\n                   factorization Irr_Mon F y \\<longrightarrow> y = Cfs;\n        factorization_m f dfs\\<rbrakk>\n       \\<Longrightarrow> Mf dfs = Mf cfs", "thus \"Dfs = Cfs\""], ["proof (prove)\nusing this:\n  (Mf dfs = Mf cfs) = (Dfs = Cfs)\n\ngoal (1 subgoal):\n 1. Dfs = Cfs", "using eq"], ["proof (prove)\nusing this:\n  (Mf dfs = Mf cfs) = (Dfs = Cfs)\n  Mf dfs = Mf cfs\n\ngoal (1 subgoal):\n 1. Dfs = Cfs", "by simp"], ["proof (state)\nthis:\n  Dfs = Cfs\n\ngoal (1 subgoal):\n 1. \\<And>dfs.\n       \\<lbrakk>\\<forall>y.\n                   factorization Irr_Mon F y \\<longrightarrow> y = Cfs;\n        factorization_m f dfs\\<rbrakk>\n       \\<Longrightarrow> Mf dfs = Mf cfs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>dfs.\n       \\<lbrakk>\\<forall>y.\n                   factorization Irr_Mon F y \\<longrightarrow> y = Cfs;\n        factorization_m f dfs\\<rbrakk>\n       \\<Longrightarrow> Mf dfs = Mf cfs", "fix dfs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>dfs.\n       \\<lbrakk>\\<forall>y.\n                   factorization Irr_Mon F y \\<longrightarrow> y = Cfs;\n        factorization_m f dfs\\<rbrakk>\n       \\<Longrightarrow> Mf dfs = Mf cfs", "assume *: ?right and f: \"?f dfs\""], ["proof (state)\nthis:\n  \\<forall>y. factorization Irr_Mon F y \\<longrightarrow> y = Cfs\n  factorization_m f dfs\n\ngoal (1 subgoal):\n 1. \\<And>dfs.\n       \\<lbrakk>\\<forall>y.\n                   factorization Irr_Mon F y \\<longrightarrow> y = Cfs;\n        factorization_m f dfs\\<rbrakk>\n       \\<Longrightarrow> Mf dfs = Mf cfs", "from left_total_MF_Rel"], ["proof (chain)\npicking this:\n  left_total MF_Rel", "obtain Dfs where \n        rel[transfer_rule]: \"MF_Rel dfs Dfs\""], ["proof (prove)\nusing this:\n  left_total MF_Rel\n\ngoal (1 subgoal):\n 1. (\\<And>Dfs. MF_Rel dfs Dfs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding left_total_def"], ["proof (prove)\nusing this:\n  \\<forall>x. Ex (MF_Rel x)\n\ngoal (1 subgoal):\n 1. (\\<And>Dfs. MF_Rel dfs Dfs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  MF_Rel dfs Dfs\n\ngoal (1 subgoal):\n 1. \\<And>dfs.\n       \\<lbrakk>\\<forall>y.\n                   factorization Irr_Mon F y \\<longrightarrow> y = Cfs;\n        factorization_m f dfs\\<rbrakk>\n       \\<Longrightarrow> Mf dfs = Mf cfs", "have \"?F Dfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. factorization Irr_Mon F Dfs", "by (transfer, rule f)"], ["proof (state)\nthis:\n  factorization Irr_Mon F Dfs\n\ngoal (1 subgoal):\n 1. \\<And>dfs.\n       \\<lbrakk>\\<forall>y.\n                   factorization Irr_Mon F y \\<longrightarrow> y = Cfs;\n        factorization_m f dfs\\<rbrakk>\n       \\<Longrightarrow> Mf dfs = Mf cfs", "from *[rule_format, OF this]"], ["proof (chain)\npicking this:\n  Dfs = Cfs", "have eq: \"Dfs = Cfs\""], ["proof (prove)\nusing this:\n  Dfs = Cfs\n\ngoal (1 subgoal):\n 1. Dfs = Cfs", "."], ["proof (state)\nthis:\n  Dfs = Cfs\n\ngoal (1 subgoal):\n 1. \\<And>dfs.\n       \\<lbrakk>\\<forall>y.\n                   factorization Irr_Mon F y \\<longrightarrow> y = Cfs;\n        factorization_m f dfs\\<rbrakk>\n       \\<Longrightarrow> Mf dfs = Mf cfs", "have \"(Mf dfs = Mf cfs) = (Dfs = Cfs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mf dfs = Mf cfs) = (Dfs = Cfs)", "by (transfer_prover_start, transfer_step+, simp)"], ["proof (state)\nthis:\n  (Mf dfs = Mf cfs) = (Dfs = Cfs)\n\ngoal (1 subgoal):\n 1. \\<And>dfs.\n       \\<lbrakk>\\<forall>y.\n                   factorization Irr_Mon F y \\<longrightarrow> y = Cfs;\n        factorization_m f dfs\\<rbrakk>\n       \\<Longrightarrow> Mf dfs = Mf cfs", "thus \"Mf dfs = Mf cfs\""], ["proof (prove)\nusing this:\n  (Mf dfs = Mf cfs) = (Dfs = Cfs)\n\ngoal (1 subgoal):\n 1. Mf dfs = Mf cfs", "using eq"], ["proof (prove)\nusing this:\n  (Mf dfs = Mf cfs) = (Dfs = Cfs)\n  Dfs = Cfs\n\ngoal (1 subgoal):\n 1. Mf dfs = Mf cfs", "by simp"], ["proof (state)\nthis:\n  Mf dfs = Mf cfs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>dfs. factorization_m f dfs \\<longrightarrow> Mf dfs = Mf cfs) =\n  (\\<forall>y. factorization Irr_Mon F y \\<longrightarrow> y = Cfs)\n\ngoal (1 subgoal):\n 1. (Mf ` Collect (factorization_m f) = {Mf cfs}) =\n    (Collect (factorization Irr_Mon F) = {Cfs})", "also"], ["proof (state)\nthis:\n  (\\<forall>dfs. factorization_m f dfs \\<longrightarrow> Mf dfs = Mf cfs) =\n  (\\<forall>y. factorization Irr_Mon F y \\<longrightarrow> y = Cfs)\n\ngoal (1 subgoal):\n 1. (Mf ` Collect (factorization_m f) = {Mf cfs}) =\n    (Collect (factorization Irr_Mon F) = {Cfs})", "have \"Mf cfs \\<in> ?L = (\\<exists> dfs. ?f dfs \\<and> Mf cfs = Mf dfs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mf cfs \\<in> Mf ` Collect (factorization_m f)) =\n    (\\<exists>dfs. factorization_m f dfs \\<and> Mf cfs = Mf dfs)", "by auto"], ["proof (state)\nthis:\n  (Mf cfs \\<in> Mf ` Collect (factorization_m f)) =\n  (\\<exists>dfs. factorization_m f dfs \\<and> Mf cfs = Mf dfs)\n\ngoal (1 subgoal):\n 1. (Mf ` Collect (factorization_m f) = {Mf cfs}) =\n    (Collect (factorization Irr_Mon F) = {Cfs})", "also"], ["proof (state)\nthis:\n  (Mf cfs \\<in> Mf ` Collect (factorization_m f)) =\n  (\\<exists>dfs. factorization_m f dfs \\<and> Mf cfs = Mf dfs)\n\ngoal (1 subgoal):\n 1. (Mf ` Collect (factorization_m f) = {Mf cfs}) =\n    (Collect (factorization Irr_Mon F) = {Cfs})", "have \"\\<dots> = ?F Cfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>dfs. factorization_m f dfs \\<and> Mf cfs = Mf dfs) =\n    factorization Irr_Mon F Cfs", "unfolding fF"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>dfs. factorization_m f dfs \\<and> Mf cfs = Mf dfs) =\n    factorization_m f cfs", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>dfs.\n       factorization_m f dfs \\<and> Mf cfs = Mf dfs \\<Longrightarrow>\n    factorization_m f cfs\n 2. factorization_m f cfs \\<Longrightarrow>\n    \\<exists>dfs. factorization_m f dfs \\<and> Mf cfs = Mf dfs", "assume \"\\<exists> dfs. ?f dfs \\<and> Mf cfs  = Mf dfs\""], ["proof (state)\nthis:\n  \\<exists>dfs. factorization_m f dfs \\<and> Mf cfs = Mf dfs\n\ngoal (2 subgoals):\n 1. \\<exists>dfs.\n       factorization_m f dfs \\<and> Mf cfs = Mf dfs \\<Longrightarrow>\n    factorization_m f cfs\n 2. factorization_m f cfs \\<Longrightarrow>\n    \\<exists>dfs. factorization_m f dfs \\<and> Mf cfs = Mf dfs", "then"], ["proof (chain)\npicking this:\n  \\<exists>dfs. factorization_m f dfs \\<and> Mf cfs = Mf dfs", "obtain dfs where f: \"?f dfs\" and id: \"Mf dfs = Mf cfs\""], ["proof (prove)\nusing this:\n  \\<exists>dfs. factorization_m f dfs \\<and> Mf cfs = Mf dfs\n\ngoal (1 subgoal):\n 1. (\\<And>dfs.\n        \\<lbrakk>factorization_m f dfs; Mf dfs = Mf cfs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  factorization_m f dfs\n  Mf dfs = Mf cfs\n\ngoal (2 subgoals):\n 1. \\<exists>dfs.\n       factorization_m f dfs \\<and> Mf cfs = Mf dfs \\<Longrightarrow>\n    factorization_m f cfs\n 2. factorization_m f cfs \\<Longrightarrow>\n    \\<exists>dfs. factorization_m f dfs \\<and> Mf cfs = Mf dfs", "from f"], ["proof (chain)\npicking this:\n  factorization_m f dfs", "have \"?f (Mf dfs)\""], ["proof (prove)\nusing this:\n  factorization_m f dfs\n\ngoal (1 subgoal):\n 1. factorization_m f (Mf dfs)", "by simp"], ["proof (state)\nthis:\n  factorization_m f (Mf dfs)\n\ngoal (2 subgoals):\n 1. \\<exists>dfs.\n       factorization_m f dfs \\<and> Mf cfs = Mf dfs \\<Longrightarrow>\n    factorization_m f cfs\n 2. factorization_m f cfs \\<Longrightarrow>\n    \\<exists>dfs. factorization_m f dfs \\<and> Mf cfs = Mf dfs", "from this[unfolded id]"], ["proof (chain)\npicking this:\n  factorization_m f (Mf cfs)", "show \"?f cfs\""], ["proof (prove)\nusing this:\n  factorization_m f (Mf cfs)\n\ngoal (1 subgoal):\n 1. factorization_m f cfs", "by simp"], ["proof (state)\nthis:\n  factorization_m f cfs\n\ngoal (1 subgoal):\n 1. factorization_m f cfs \\<Longrightarrow>\n    \\<exists>dfs. factorization_m f dfs \\<and> Mf cfs = Mf dfs", "qed blast"], ["proof (state)\nthis:\n  (\\<exists>dfs. factorization_m f dfs \\<and> Mf cfs = Mf dfs) =\n  factorization Irr_Mon F Cfs\n\ngoal (1 subgoal):\n 1. (Mf ` Collect (factorization_m f) = {Mf cfs}) =\n    (Collect (factorization Irr_Mon F) = {Cfs})", "finally"], ["proof (chain)\npicking this:\n  (Mf ` {a. factorization_m f a} = {Mf cfs}) =\n  ((\\<forall>y. factorization Irr_Mon F y \\<longrightarrow> y = Cfs) \\<and>\n   factorization Irr_Mon F Cfs)", "show \"(?L = {Mf cfs}) = (?R = {Cfs})\""], ["proof (prove)\nusing this:\n  (Mf ` {a. factorization_m f a} = {Mf cfs}) =\n  ((\\<forall>y. factorization Irr_Mon F y \\<longrightarrow> y = Cfs) \\<and>\n   factorization Irr_Mon F Cfs)\n\ngoal (1 subgoal):\n 1. (Mf ` Collect (factorization_m f) = {Mf cfs}) =\n    (Collect (factorization Irr_Mon F) = {Cfs})", "by auto"], ["proof (state)\nthis:\n  (Mf ` Collect (factorization_m f) = {Mf cfs}) =\n  (Collect (factorization Irr_Mon F) = {Cfs})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  unique_factorization_m f cfs = unique_factorization Irr_Mon F Cfs\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context begin"], ["", "private"], ["", "lemma 1: \"poly_mod_type TYPE('a :: nontriv) m = (m = int CARD('a))\"\n  and 2: \"class.nontriv TYPE('a) = (CARD('a) \\<ge> 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_type TYPE('a) m = (m = int CARD('a)) &&&\n    class.nontriv TYPE('a) = (2 \\<le> CARD('a))", "unfolding poly_mod_type_def class.prime_card_def class.nontriv_def poly_mod_prime_type_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (m = int CARD('a)) = (m = int CARD('a)) &&&\n    (1 < CARD('a)) = (2 \\<le> CARD('a))", "by auto"], ["", "private"], ["", "lemma 3: \"poly_mod_prime_type TYPE('b) m = (m = int CARD('b))\"\n  and 4: \"class.prime_card TYPE('b :: prime_card) = prime CARD('b :: prime_card)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_prime_type TYPE('b) m = (m = int CARD('b)) &&&\n    class.prime_card TYPE('b) = prime CARD('b)", "unfolding poly_mod_type_def class.prime_card_def class.nontriv_def poly_mod_prime_type_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (m = int CARD('b)) = (m = int CARD('b)) &&&\n    prime CARD('b) = prime CARD('b)", "by auto"], ["", "lemmas poly_mod_type_simps = 1 2 3 4"], ["", "end"], ["", "lemma remove_duplicate_premise: \"(PROP P \\<Longrightarrow> PROP P \\<Longrightarrow> PROP Q) \\<equiv> (PROP P \\<Longrightarrow> PROP Q)\" (is \"?l \\<equiv> ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>PROP P; PROP P\\<rbrakk> \\<Longrightarrow> PROP Q) \\<equiv>\n    (PROP P \\<Longrightarrow> PROP Q)", "proof (intro Pure.equal_intr_rule)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>PROP P; PROP P\\<rbrakk> \\<Longrightarrow> PROP Q;\n     PROP P\\<rbrakk>\n    \\<Longrightarrow> PROP Q\n 2. \\<lbrakk>PROP P \\<Longrightarrow> PROP Q; PROP P; PROP P\\<rbrakk>\n    \\<Longrightarrow> PROP Q", "assume p: \"PROP P\" and ppq: \"PROP ?l\""], ["proof (state)\nthis:\n  PROP P\n  \\<lbrakk>PROP P; PROP P\\<rbrakk> \\<Longrightarrow> PROP Q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>PROP P; PROP P\\<rbrakk> \\<Longrightarrow> PROP Q;\n     PROP P\\<rbrakk>\n    \\<Longrightarrow> PROP Q\n 2. \\<lbrakk>PROP P \\<Longrightarrow> PROP Q; PROP P; PROP P\\<rbrakk>\n    \\<Longrightarrow> PROP Q", "from ppq[OF p p]"], ["proof (chain)\npicking this:\n  PROP Q", "show \"PROP Q\""], ["proof (prove)\nusing this:\n  PROP Q\n\ngoal (1 subgoal):\n 1. PROP Q", "."], ["proof (state)\nthis:\n  PROP Q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>PROP P \\<Longrightarrow> PROP Q; PROP P; PROP P\\<rbrakk>\n    \\<Longrightarrow> PROP Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>PROP P \\<Longrightarrow> PROP Q; PROP P; PROP P\\<rbrakk>\n    \\<Longrightarrow> PROP Q", "assume p: \"PROP P\" and pq: \"PROP ?r\""], ["proof (state)\nthis:\n  PROP P\n  PROP P \\<Longrightarrow> PROP Q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>PROP P \\<Longrightarrow> PROP Q; PROP P; PROP P\\<rbrakk>\n    \\<Longrightarrow> PROP Q", "from pq[OF p]"], ["proof (chain)\npicking this:\n  PROP Q", "show \"PROP Q\""], ["proof (prove)\nusing this:\n  PROP Q\n\ngoal (1 subgoal):\n 1. PROP Q", "."], ["proof (state)\nthis:\n  PROP Q\n\ngoal:\nNo subgoals!", "qed"], ["", "context poly_mod_prime begin"], ["", "lemma type_to_set:\n  assumes type_def: \"\\<exists>(Rep :: 'b \\<Rightarrow> int) Abs. type_definition Rep Abs {0 ..< p :: int}\"\n  shows \"class.prime_card (TYPE('b))\" (is ?a) and \"p = int CARD('b)\" (is ?b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.prime_card TYPE('b) &&& p = int CARD('b)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. class.prime_card TYPE('b)\n 2. p = int CARD('b)", "from prime"], ["proof (chain)\npicking this:\n  prime p", "have p2: \"p \\<ge> 2\""], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. 2 \\<le> p", "by (rule prime_ge_2_int)"], ["proof (state)\nthis:\n  2 \\<le> p\n\ngoal (2 subgoals):\n 1. class.prime_card TYPE('b)\n 2. p = int CARD('b)", "from type_def"], ["proof (chain)\npicking this:\n  \\<exists>Rep Abs. type_definition Rep Abs {0..<p}", "obtain rep :: \"'b \\<Rightarrow> int\" and abs :: \"int \\<Rightarrow> 'b\" where t: \"type_definition rep abs {0 ..< p}\""], ["proof (prove)\nusing this:\n  \\<exists>Rep Abs. type_definition Rep Abs {0..<p}\n\ngoal (1 subgoal):\n 1. (\\<And>rep abs.\n        type_definition rep abs {0..<p} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  type_definition rep abs {0..<p}\n\ngoal (2 subgoals):\n 1. class.prime_card TYPE('b)\n 2. p = int CARD('b)", "have \"card (UNIV :: 'b set) = card {0 ..< p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('b) = card {0..<p}", "using t"], ["proof (prove)\nusing this:\n  type_definition rep abs {0..<p}\n\ngoal (1 subgoal):\n 1. CARD('b) = card {0..<p}", "by (rule type_definition.card)"], ["proof (state)\nthis:\n  CARD('b) = card {0..<p}\n\ngoal (2 subgoals):\n 1. class.prime_card TYPE('b)\n 2. p = int CARD('b)", "also"], ["proof (state)\nthis:\n  CARD('b) = card {0..<p}\n\ngoal (2 subgoals):\n 1. class.prime_card TYPE('b)\n 2. p = int CARD('b)", "have \"\\<dots> = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card {0..<p}) = p", "using p2"], ["proof (prove)\nusing this:\n  2 \\<le> p\n\ngoal (1 subgoal):\n 1. int (card {0..<p}) = p", "by auto"], ["proof (state)\nthis:\n  int (card {0..<p}) = p\n\ngoal (2 subgoals):\n 1. class.prime_card TYPE('b)\n 2. p = int CARD('b)", "finally"], ["proof (chain)\npicking this:\n  int CARD('b) = p", "show ?b"], ["proof (prove)\nusing this:\n  int CARD('b) = p\n\ngoal (1 subgoal):\n 1. p = int CARD('b)", ".."], ["proof (state)\nthis:\n  p = int CARD('b)\n\ngoal (1 subgoal):\n 1. class.prime_card TYPE('b)", "then"], ["proof (chain)\npicking this:\n  p = int CARD('b)", "show ?a"], ["proof (prove)\nusing this:\n  p = int CARD('b)\n\ngoal (1 subgoal):\n 1. class.prime_card TYPE('b)", "unfolding class.prime_card_def"], ["proof (prove)\nusing this:\n  p = int CARD('b)\n\ngoal (1 subgoal):\n 1. prime CARD('b)", "using prime p2"], ["proof (prove)\nusing this:\n  p = int CARD('b)\n  prime p\n  2 \\<le> p\n\ngoal (1 subgoal):\n 1. prime CARD('b)", "by auto"], ["proof (state)\nthis:\n  class.prime_card TYPE('b)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* it will be nice to be able to automate this *)"], ["", "lemmas (in poly_mod_type) prime_elem_m_dvdm_multD = prime_elem_dvd_multD\n  [where 'a = \"'a mod_ring poly\",untransferred]"], ["", "lemmas (in poly_mod_2) prime_elem_m_dvdm_multD = poly_mod_type.prime_elem_m_dvdm_multD\n  [unfolded poly_mod_type_simps, internalize_sort \"'a :: nontriv\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]"], ["", "lemmas(in poly_mod_prime_type) degree_m_mult_eq = degree_mult_eq\n  [where 'a = \"'a mod_ring\", untransferred]"], ["", "lemmas(in poly_mod_prime) degree_m_mult_eq = poly_mod_prime_type.degree_m_mult_eq\n  [unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]"], ["", "lemma(in poly_mod_prime) irreducible\\<^sub>d_lifting:\n  assumes n: \"n \\<noteq> 0\"\n    and deg: \"poly_mod.degree_m (p^n) f = degree_m f\"\n    and irr: \"irreducible\\<^sub>d_m f\"\n  shows \"poly_mod.irreducible\\<^sub>d_m (p^n) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.irreducible\\<^sub>d_m (p ^ n) f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_mod.irreducible\\<^sub>d_m (p ^ n) f", "interpret q: poly_mod_2 \"p^n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_2 (p ^ n)", "unfolding poly_mod_2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < p ^ n", "using n m1"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  1 < p\n\ngoal (1 subgoal):\n 1. 1 < p ^ n", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. q.irreducible\\<^sub>d_m f", "show \"q.irreducible\\<^sub>d_m f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q.irreducible\\<^sub>d_m f", "proof (rule q.irreducible\\<^sub>d_mI)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < q.degree_m f\n 2. \\<And>g h.\n       \\<lbrakk>q.Mp g = g; q.Mp h = h; 0 < degree g;\n        degree g < q.degree_m f; 0 < degree h; degree h < q.degree_m f;\n        q.eq_m f (g * h)\\<rbrakk>\n       \\<Longrightarrow> False", "from deg irr"], ["proof (chain)\npicking this:\n  q.degree_m f = degree_m f\n  irreducible\\<^sub>d_m f", "show \"q.degree_m f > 0\""], ["proof (prove)\nusing this:\n  q.degree_m f = degree_m f\n  irreducible\\<^sub>d_m f\n\ngoal (1 subgoal):\n 1. 0 < q.degree_m f", "by (auto elim: irreducible\\<^sub>d_mE)"], ["proof (state)\nthis:\n  0 < q.degree_m f\n\ngoal (1 subgoal):\n 1. \\<And>g h.\n       \\<lbrakk>q.Mp g = g; q.Mp h = h; 0 < degree g;\n        degree g < q.degree_m f; 0 < degree h; degree h < q.degree_m f;\n        q.eq_m f (g * h)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  0 < q.degree_m f", "have pdeg_f: \"degree_m f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < q.degree_m f\n\ngoal (1 subgoal):\n 1. degree_m f \\<noteq> 0", "by (simp add: deg)"], ["proof (state)\nthis:\n  degree_m f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>g h.\n       \\<lbrakk>q.Mp g = g; q.Mp h = h; 0 < degree g;\n        degree g < q.degree_m f; 0 < degree h; degree h < q.degree_m f;\n        q.eq_m f (g * h)\\<rbrakk>\n       \\<Longrightarrow> False", "note pMp_Mp = Mp_Mp_pow_is_Mp[OF n m1]"], ["proof (state)\nthis:\n  q.Mp ?f =m ?f\n\ngoal (1 subgoal):\n 1. \\<And>g h.\n       \\<lbrakk>q.Mp g = g; q.Mp h = h; 0 < degree g;\n        degree g < q.degree_m f; 0 < degree h; degree h < q.degree_m f;\n        q.eq_m f (g * h)\\<rbrakk>\n       \\<Longrightarrow> False", "fix g h"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g h.\n       \\<lbrakk>q.Mp g = g; q.Mp h = h; 0 < degree g;\n        degree g < q.degree_m f; 0 < degree h; degree h < q.degree_m f;\n        q.eq_m f (g * h)\\<rbrakk>\n       \\<Longrightarrow> False", "assume deg_g: \"degree g < q.degree_m f\" and deg_h: \"degree h < q.degree_m f\"\n      and eq: \"q.eq_m f (g * h)\""], ["proof (state)\nthis:\n  degree g < q.degree_m f\n  degree h < q.degree_m f\n  q.eq_m f (g * h)\n\ngoal (1 subgoal):\n 1. \\<And>g h.\n       \\<lbrakk>q.Mp g = g; q.Mp h = h; 0 < degree g;\n        degree g < q.degree_m f; 0 < degree h; degree h < q.degree_m f;\n        q.eq_m f (g * h)\\<rbrakk>\n       \\<Longrightarrow> False", "from eq"], ["proof (chain)\npicking this:\n  q.eq_m f (g * h)", "have p_f: \"f =m (g * h)\""], ["proof (prove)\nusing this:\n  q.eq_m f (g * h)\n\ngoal (1 subgoal):\n 1. f =m g * h", "using pMp_Mp"], ["proof (prove)\nusing this:\n  q.eq_m f (g * h)\n  q.Mp ?f =m ?f\n\ngoal (1 subgoal):\n 1. f =m g * h", "by metis"], ["proof (state)\nthis:\n  f =m g * h\n\ngoal (1 subgoal):\n 1. \\<And>g h.\n       \\<lbrakk>q.Mp g = g; q.Mp h = h; 0 < degree g;\n        degree g < q.degree_m f; 0 < degree h; degree h < q.degree_m f;\n        q.eq_m f (g * h)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<not>g =m 0\" and \"\\<not>h =m 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp g \\<noteq> Mp 0 &&& Mp h \\<noteq> Mp 0", "apply (metis degree_0 mult_zero_left Mp_0 p_f pdeg_f poly_mod.mult_Mp(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp h \\<noteq> Mp 0", "by (metis degree_0 mult_eq_0_iff Mp_0 mult_Mp(2) p_f pdeg_f)"], ["proof (state)\nthis:\n  Mp g \\<noteq> Mp 0\n  Mp h \\<noteq> Mp 0\n\ngoal (1 subgoal):\n 1. \\<And>g h.\n       \\<lbrakk>q.Mp g = g; q.Mp h = h; 0 < degree g;\n        degree g < q.degree_m f; 0 < degree h; degree h < q.degree_m f;\n        q.eq_m f (g * h)\\<rbrakk>\n       \\<Longrightarrow> False", "note [simp] = degree_m_mult_eq[OF this]"], ["proof (state)\nthis:\n  degree_m (g * h) = degree_m g + degree_m h\n\ngoal (1 subgoal):\n 1. \\<And>g h.\n       \\<lbrakk>q.Mp g = g; q.Mp h = h; 0 < degree g;\n        degree g < q.degree_m f; 0 < degree h; degree h < q.degree_m f;\n        q.eq_m f (g * h)\\<rbrakk>\n       \\<Longrightarrow> False", "from degree_m_le[of g] deg_g"], ["proof (chain)\npicking this:\n  degree_m g \\<le> degree g\n  degree g < q.degree_m f", "have 2: \"degree_m g < degree_m f\""], ["proof (prove)\nusing this:\n  degree_m g \\<le> degree g\n  degree g < q.degree_m f\n\ngoal (1 subgoal):\n 1. degree_m g < degree_m f", "by (fold deg, auto)"], ["proof (state)\nthis:\n  degree_m g < degree_m f\n\ngoal (1 subgoal):\n 1. \\<And>g h.\n       \\<lbrakk>q.Mp g = g; q.Mp h = h; 0 < degree g;\n        degree g < q.degree_m f; 0 < degree h; degree h < q.degree_m f;\n        q.eq_m f (g * h)\\<rbrakk>\n       \\<Longrightarrow> False", "from degree_m_le[of h] deg_h"], ["proof (chain)\npicking this:\n  degree_m h \\<le> degree h\n  degree h < q.degree_m f", "have 3: \"degree_m h < degree_m f\""], ["proof (prove)\nusing this:\n  degree_m h \\<le> degree h\n  degree h < q.degree_m f\n\ngoal (1 subgoal):\n 1. degree_m h < degree_m f", "by (fold deg, auto)"], ["proof (state)\nthis:\n  degree_m h < degree_m f\n\ngoal (1 subgoal):\n 1. \\<And>g h.\n       \\<lbrakk>q.Mp g = g; q.Mp h = h; 0 < degree g;\n        degree g < q.degree_m f; 0 < degree h; degree h < q.degree_m f;\n        q.eq_m f (g * h)\\<rbrakk>\n       \\<Longrightarrow> False", "from irreducible\\<^sub>d_mD(2)[OF irr 2 3] p_f"], ["proof (chain)\npicking this:\n  Mp f \\<noteq> Mp (g * h)\n  f =m g * h", "show False"], ["proof (prove)\nusing this:\n  Mp f \\<noteq> Mp (g * h)\n  f =m g * h\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q.irreducible\\<^sub>d_m f\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Lifting UFD properties *)"], ["", "lemmas (in poly_mod_prime_type) mset_factors_exist =\n  mset_factors_exist[where 'a = \"'a mod_ring poly\",untransferred]"], ["", "lemmas (in poly_mod_prime) mset_factors_exist = poly_mod_prime_type.mset_factors_exist\n  [unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]"], ["", "lemmas (in poly_mod_prime_type) mset_factors_unique =\n  mset_factors_unique[where 'a = \"'a mod_ring poly\",untransferred]"], ["", "lemmas (in poly_mod_prime) mset_factors_unique = poly_mod_prime_type.mset_factors_unique\n  [unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]"], ["", "lemmas (in poly_mod_prime_type) prime_elem_iff_irreducible =\n  prime_elem_iff_irreducible[where 'a = \"'a mod_ring poly\",untransferred]"], ["", "lemmas (in poly_mod_prime) prime_elem_iff_irreducible[simp] = poly_mod_prime_type.prime_elem_iff_irreducible\n  [unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]"], ["", "lemmas (in poly_mod_prime_type) irreducible_connect =\n  irreducible_connect_field[where 'a = \"'a mod_ring\", untransferred]"], ["", "lemmas (in poly_mod_prime) irreducible_connect[simp] = poly_mod_prime_type.irreducible_connect\n  [unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]"], ["", "lemmas (in poly_mod_prime_type) irreducible_degree =\n  irreducible_degree_field[where 'a = \"'a mod_ring\", untransferred]"], ["", "lemmas (in poly_mod_prime) irreducible_degree = poly_mod_prime_type.irreducible_degree\n  [unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]"], ["", "end"]]}