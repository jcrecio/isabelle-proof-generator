{"file_name": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus/Hensel_Lifting.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus", "problem_names": ["lemma uniqueness_poly_equality:\n  fixes f g :: \"'a :: {factorial_ring_gcd,semiring_gcd_mult_normalize} poly\"\n  assumes cop: \"coprime f g\"\n  and deg: \"B = 0 \\<or> degree B < degree f\" \"B' = 0 \\<or> degree B' < degree f\"\n  and f: \"f \\<noteq> 0\" and eq: \"A * f + B * g = A' * f + B' * g\" \n  shows \"A = A'\" \"B = B'\"", "lemmas (in poly_mod_prime_type) uniqueness_poly_equality =\n  uniqueness_poly_equality[where 'a=\"'a mod_ring\", untransferred]", "lemmas (in poly_mod_prime) uniqueness_poly_equality = poly_mod_prime_type.uniqueness_poly_equality\n  [unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]", "lemma pseudo_divmod_main_list_1_is_divmod_poly_one_main_list: \n  \"pseudo_divmod_main_list (1 :: 'a :: comm_ring_1) q f g n = divmod_poly_one_main_list q f g n\"", "lemma pdivmod_monic_pseudo_divmod: assumes g: \"monic g\" shows \"pdivmod_monic f g = pseudo_divmod f g\"", "lemma pdivmod_monic: assumes g: \"monic g\" and res: \"pdivmod_monic f g = (q, r)\"\n  shows \"f = g * q + r\" \"r = 0 \\<or> degree r < degree g\"", "lemma dupe_monic: assumes 1: \"D*S + H*T = 1\" \n  and mon: \"monic D\" \n  and dupe: \"dupe_monic D H S T U = (A,B)\" \nshows \"A * D + B * H = U\" \"B = 0 \\<or> degree B < degree D\"", "lemma dupe_monic_unique: fixes D :: \"'a ::  {factorial_ring_gcd,semiring_gcd_mult_normalize} poly\" \n  assumes 1: \"D*S + H*T = 1\" \n  and mon: \"monic D\" \n  and dupe: \"dupe_monic D H S T U = (A,B)\" \n  and cop: \"coprime D H\"\n  and other: \"A' * D + B' * H = U\" \"B' = 0 \\<or> degree B' < degree D\"\nshows \"A' = A\" \"B' = B\"", "lemma poly_rel_dupe_monic_i: assumes mon: \"monic D\" \n  and rel: \"poly_rel d D\" \"poly_rel h H\" \"poly_rel s S\" \"poly_rel t T\" \"poly_rel u U\" \nshows \"rel_prod poly_rel poly_rel (dupe_monic_i ops d h s t u) (dupe_monic D H S T U)\"", "lemma monic_of_int_poly: \"monic D \\<Longrightarrow> monic (of_int_poly (Mp D) :: 'a mod_ring poly)\"", "lemma dupe_monic_i: assumes dupe_i: \"dupe_monic_i ff_ops d h s t u = (a,b)\" \n  and 1: \"D*S + H*T =m 1\" \n  and mon: \"monic D\" \n  and A: \"A = to_int_poly_i ff_ops a\" \n  and B: \"B = to_int_poly_i ff_ops b\" \n  and d: \"Mp_rel_i d D\" \n  and h: \"Mp_rel_i h H\" \n  and s: \"Mp_rel_i s S\" \n  and t: \"Mp_rel_i t T\" \n  and u: \"Mp_rel_i u U\" \nshows \n  \"A * D + B * H =m U\" \n  \"B = 0 \\<or> degree B < degree D\" \n  \"Mp_rel_i a A\" \n  \"Mp_rel_i b B\"", "lemma Mp_rel_i_of_int_poly_i: assumes \"Mp F = F\"\n  shows \"Mp_rel_i (of_int_poly_i ff_ops F) F\"", "lemma dupe_monic_i_int: assumes dupe_i: \"dupe_monic_i_int ff_ops D H S T U = (A,B)\" \n  and 1: \"D*S + H*T =m 1\" \n  and mon: \"monic D\" \n  and norm: \"Mp D = D\" \"Mp H = H\" \"Mp S = S\" \"Mp T = T\" \"Mp U = U\" \nshows \n  \"A * D + B * H =m U\" \n  \"B = 0 \\<or> degree B < degree D\" \n  \"Mp A = A\" \n  \"Mp B = B\"", "lemma dupe_monic_i_int_finite_field_ops_integer: assumes \n      dupe_i: \"dupe_monic_i_int (finite_field_ops_integer (integer_of_int m)) D H S T U = (A,B)\" \n  and 1: \"D*S + H*T =m 1\" \n  and mon: \"monic D\" \n  and norm: \"Mp D = D\" \"Mp H = H\" \"Mp S = S\" \"Mp T = T\" \"Mp U = U\" \nshows \n  \"A * D + B * H =m U\" \n  \"B = 0 \\<or> degree B < degree D\" \n  \"Mp A = A\" \n  \"Mp B = B\"", "lemma dupe_monic_i_int_finite_field_ops32: assumes \n      m: \"m \\<le> 65535\"\n  and dupe_i: \"dupe_monic_i_int (finite_field_ops32 (uint32_of_int m)) D H S T U = (A,B)\" \n  and 1: \"D*S + H*T =m 1\" \n  and mon: \"monic D\" \n  and norm: \"Mp D = D\" \"Mp H = H\" \"Mp S = S\" \"Mp T = T\" \"Mp U = U\" \nshows \n  \"A * D + B * H =m U\" \n  \"B = 0 \\<or> degree B < degree D\" \n  \"Mp A = A\" \n  \"Mp B = B\"", "lemma dupe_monic_i_int_finite_field_ops64: assumes \n      m: \"m \\<le> 4294967295\"\n  and dupe_i: \"dupe_monic_i_int (finite_field_ops64 (uint64_of_int m)) D H S T U = (A,B)\" \n  and 1: \"D*S + H*T =m 1\" \n  and mon: \"monic D\" \n  and norm: \"Mp D = D\" \"Mp H = H\" \"Mp S = S\" \"Mp T = T\" \"Mp U = U\" \nshows \n  \"A * D + B * H =m U\" \n  \"B = 0 \\<or> degree B < degree D\" \n  \"Mp A = A\" \n  \"Mp B = B\"", "lemma dupe_monic_dynamic: assumes dupe: \"dupe_monic_dynamic m D H S T U = (A,B)\" \n  and 1: \"D*S + H*T =m 1\" \n  and mon: \"monic D\" \n  and norm: \"Mp D = D\" \"Mp H = H\" \"Mp S = S\" \"Mp T = T\" \"Mp U = U\" \nshows \n  \"A * D + B * H =m U\" \n  \"B = 0 \\<or> degree B < degree D\" \n  \"Mp A = A\" \n  \"Mp B = B\"", "lemma (in poly_mod_2) dupe_monic_int: assumes 1: \"D*S + H*T =m 1\" \n  and mon: \"monic D\" \n  and dupe: \"dupe_monic_int D H S T U = (A,B)\" \n  shows \"A * D + B * H =m U\" \"B = 0 \\<or> degree B < degree D\" \"Mp A = A\" \"Mp B = B\" \n    \"coprime_m D H \\<Longrightarrow> A' * D + B' * H =m U \\<Longrightarrow> B' = 0 \\<or> degree B' < degree D \\<Longrightarrow> Mp D = D \n    \\<Longrightarrow> Mp A' = A' \\<Longrightarrow> Mp B' = B' \\<Longrightarrow> prime m\n    \\<Longrightarrow> A' = A \\<and> B' = B\"", "lemma coprime_bezout_coefficients:\n  assumes cop: \"coprime f g\"\n    and ext: \"bezout_coefficients f g = (a, b)\" \n  shows \"a * f + b * g = 1\"", "lemma (in poly_mod_prime_type) bezout_coefficients_mod_int: assumes f: \"(F :: 'a mod_ring poly) = of_int_poly f\"\n  and g: \"(G :: 'a mod_ring poly) = of_int_poly g\" \n  and cop: \"coprime_m f g\" \n  and fact: \"bezout_coefficients F G = (A,B)\" \n  and a: \"a = to_int_poly A\"\n  and b: \"b = to_int_poly B\"\n  shows \"f * a + g * b =m 1\"", "lemma bezout_coefficients_i[transfer_rule]: \n  \"(poly_rel ===> poly_rel ===> rel_prod poly_rel poly_rel)\n     (bezout_coefficients_i ff_ops) bezout_coefficients\"", "lemma bezout_coefficients_i_sound: assumes f: \"f' = of_int_poly_i ff_ops f\" \"Mp f = f\"\n  and g: \"g' = of_int_poly_i ff_ops g\" \"Mp g = g\"  \n  and cop: \"coprime_m f g\" \n  and res: \"bezout_coefficients_i ff_ops f' g' = (a',b')\" \n  and a: \"a = to_int_poly_i ff_ops a'\"\n  and b: \"b = to_int_poly_i ff_ops b'\"\nshows \"f * a + g * b =m 1\"\n  \"Mp a = a\" \"Mp b = b\"", "lemma euclid_ext_poly_mod_main: assumes cop: \"coprime_m f g\" \n  and f: \"Mp f = f\" and g: \"Mp g = g\" \n  and res: \"euclid_ext_poly_mod_main m ff_ops f g = (a,b)\" \nshows \"f * a + g * b =m 1\" \n  \"Mp a = a\" \"Mp b = b\"", "lemmas euclid_ext_poly_mod_integer = prime_field_gen.euclid_ext_poly_mod_main\n  [OF prime_field.prime_field_finite_field_ops_integer,\n  unfolded prime_field_def mod_ring_locale_def poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]", "lemmas euclid_ext_poly_mod_uint32 = prime_field_gen.euclid_ext_poly_mod_main\n  [OF prime_field.prime_field_finite_field_ops32,\n  unfolded prime_field_def mod_ring_locale_def poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]", "lemmas euclid_ext_poly_mod_uint64 = prime_field_gen.euclid_ext_poly_mod_main[OF prime_field.prime_field_finite_field_ops64,\n  unfolded prime_field_def mod_ring_locale_def poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]", "lemma euclid_ext_poly_dynamic:\n  assumes cop: \"coprime_m f g\" and f: \"Mp f = f\" and g: \"Mp g = g\"\n    and res: \"euclid_ext_poly_dynamic p f g = (a,b)\" \n  shows \"f * a + g * b =m 1\" \n    \"Mp a = a\" \"Mp b = b\"", "lemma range_sum_prod: assumes xy: \"x \\<in> {0..<q}\" \"(y :: int) \\<in> {0..<p}\" \n  shows \"x + q * y \\<in> {0..<p * q}\"", "lemma linear_hensel_main: assumes 1: \"poly_mod.eq_m p (D1 * S + H1 * T) 1\" \n  and equiv: \"poly_mod.eq_m p (D1 * H1) C\"\n  and monD1: \"monic D1\" \n  and normDH1: \"poly_mod.Mp p D1 = D1\" \"poly_mod.Mp p H1 = H1\"\n  and res: \"linear_hensel_main n = (D,H)\" \n  and n: \"n \\<noteq> 0\" \n  and prime: \"prime p\" \\<comment> \\<open>\\<open>p > 1\\<close> suffices if one does not need uniqueness\\<close>\n  and cop: \"poly_mod.coprime_m p D1 H1\"\n  shows \"poly_mod.eq_m (p^n) (D * H) C\n    \\<and> monic D\n    \\<and> poly_mod.eq_m p D D1 \\<and> poly_mod.eq_m p H H1\n    \\<and> poly_mod.Mp (p^n) D = D\n    \\<and> poly_mod.Mp (p^n) H = H \\<and> \n    (poly_mod.eq_m (p^n) (D' * H') C \\<longrightarrow>\n     poly_mod.eq_m p D' D1 \\<longrightarrow> \n     poly_mod.eq_m p H' H1 \\<longrightarrow>\n     poly_mod.Mp (p^n) D' = D' \\<longrightarrow>\n     poly_mod.Mp (p^n) H' = H' \\<longrightarrow> monic D' \\<longrightarrow> D' = D \\<and> H' = H)\n     \"", "lemma (in poly_mod_prime) unique_hensel_binary: \n  assumes prime: \"prime p\"\n  and cop: \"coprime_m D H\" and eq: \"eq_m (D * H) C\"\n  and normalized_input: \"Mp D = D\" \"Mp H = H\"\n  and monic_input: \"monic D\" \n  and n: \"n \\<noteq> 0\" \nshows \"\\<exists>! (D',H'). \\<comment> \\<open>\\<open>D'\\<close>, \\<open>H'\\<close> are computed via \\<open>linear_hensel_binary\\<close>\\<close>\n      poly_mod.eq_m (p^n) (D' * H') C \\<comment> \\<open>the main result: equivalence mod \\<open>p^n\\<close>\\<close>\n    \\<and> monic D' \\<comment> \\<open>monic output\\<close>\n    \\<and> eq_m D D' \\<and> eq_m H H' \\<comment> \\<open>apply \\<open>`mod p`\\<close> on \\<open>D'\\<close> and \\<open>H'\\<close> yields \\<open>D\\<close> and \\<open>H\\<close> again\\<close>\n    \\<and> poly_mod.Mp (p^n) D' = D' \\<and> poly_mod.Mp (p^n) H' = H' \\<comment> \\<open>output is normalized\\<close>\"", "lemma hensel_step_main: assumes \n      one_q: \"poly_mod.eq_m q (D * S + H * T) 1\"\n  and one_p: \"poly_mod.eq_m p (D1 * S1 + H1 * T1) 1\"\n  and CDHq: \"poly_mod.eq_m q C (D * H)\"\n  and D1D: \"poly_mod.eq_m p D1 D\" \n  and H1H: \"poly_mod.eq_m p H1 H\" \n  and S1S: \"poly_mod.eq_m p S1 S\" \n  and T1T: \"poly_mod.eq_m p T1 T\" \n  and mon: \"monic D\" \n  and mon1: \"monic D1\" \n  and q: \"q > 1\" \n  and p: \"p > 1\" \n  and D1: \"poly_mod.Mp p D1 = D1\" \n  and H1: \"poly_mod.Mp p H1 = H1\"\n  and S1: \"poly_mod.Mp p S1 = S1\" \n  and T1: \"poly_mod.Mp p T1 = T1\"\n  and D: \"poly_mod.Mp q D = D\" \n  and H: \"poly_mod.Mp q H = H\"\n  and S: \"poly_mod.Mp q S = S\" \n  and T: \"poly_mod.Mp q T = T\"\n  and U1: \"U1 = poly_mod.Mp p (sdiv_poly (C - D * H) q)\"\n  and dupe1: \"dupe_monic_dynamic p D1 H1 S1 T1 U1 = (A,B)\" \n  and D': \"D' = D + smult q B\"\n  and H': \"H' = H + smult q A\" \n  and U2: \"U2 = poly_mod.Mp q (sdiv_poly (S*D' + T*H' - 1) p)\" \n  and dupe2: \"dupe_monic_dynamic q D H S T U2 = (A',B')\" \n  and rq: \"r = p * q\" \n  and pq: \"p dvd q\"  \n  and S': \"S' = poly_mod.Mp r (S - smult p A')\"\n  and T': \"T' = poly_mod.Mp r (T - smult p B')\" \nshows \"poly_mod.eq_m r C (D' * H')\" \n  \"poly_mod.Mp r D' = D'\" \n  \"poly_mod.Mp r H' = H'\" \n  \"poly_mod.Mp r S' = S'\" \n  \"poly_mod.Mp r T' = T'\" \n  \"poly_mod.eq_m r (D' * S' + H' * T') 1\" \n  \"monic D'\"", "lemma quadratic_hensel_step_code[code]:\n  \"quadratic_hensel_step q S T D H =\n    (let dupe = dupe_monic_dynamic q D H S T; \\<comment> \\<open>this will share the conversions of \\<open>D H S T\\<close>\\<close>\n         U = poly_mod.Mp q (sdiv_poly (C - D * H) q); \n         (A, B) = dupe U; \n         D' = D + Polynomial.smult q B;\n         H' = H + Polynomial.smult q A; \n         U' = poly_mod.Mp q (sdiv_poly (S * D' + T * H' - 1) q); \n         (A', B') = dupe U';\n         q' = q * q; \n         S' = poly_mod.Mp q' (S - Polynomial.smult q A'); \n         T' = poly_mod.Mp q' (T - Polynomial.smult q B')\n           in (S', T', D', H'))\"", "lemma hensel_step: assumes step: \"hensel_step p q S1 T1 D1 H1 S T D H = (S', T', D', H')\"\n  and one_p: \"poly_mod.eq_m p (D1 * S1 + H1 * T1) 1\"\n  and mon1: \"monic D1\" \n  and p: \"p > 1\" \n  and CDHq: \"poly_mod.eq_m q C (D * H)\"\n  and one_q: \"poly_mod.eq_m q (D * S + H * T) 1\"\n  and D1D: \"poly_mod.eq_m p D1 D\"\n  and H1H: \"poly_mod.eq_m p H1 H\"\n  and S1S: \"poly_mod.eq_m p S1 S\"\n  and T1T: \"poly_mod.eq_m p T1 T\"\n  and mon: \"monic D\" \n  and q: \"q > 1\" \n  and D1: \"poly_mod.Mp p D1 = D1\" \n  and H1: \"poly_mod.Mp p H1 = H1\"\n  and S1: \"poly_mod.Mp p S1 = S1\" \n  and T1: \"poly_mod.Mp p T1 = T1\"\n  and D: \"poly_mod.Mp q D = D\" \n  and H: \"poly_mod.Mp q H = H\"\n  and S: \"poly_mod.Mp q S = S\" \n  and T: \"poly_mod.Mp q T = T\"\n  and rq: \"r = p * q\" \n  and pq: \"p dvd q\"  \nshows \n  \"poly_mod.eq_m r C (D' * H')\" \n  \"poly_mod.eq_m r (D' * S' + H' * T') 1\"\n  \"poly_mod.Mp r D' = D'\" \n  \"poly_mod.Mp r H' = H'\" \n  \"poly_mod.Mp r S' = S'\" \n  \"poly_mod.Mp r T' = T'\" \n  \"poly_mod.Mp p D1 = poly_mod.Mp p D'\" \n  \"poly_mod.Mp p H1 = poly_mod.Mp p H'\" \n  \"poly_mod.Mp p S1 = poly_mod.Mp p S'\" \n  \"poly_mod.Mp p T1 = poly_mod.Mp p T'\" \n  \"monic D'\"", "lemma quadratic_hensel_step: assumes step: \"quadratic_hensel_step q S T D H = (S', T', D', H')\"\n  and CDH: \"poly_mod.eq_m q C (D * H)\"\n  and one: \"poly_mod.eq_m q (D * S + H * T) 1\"\n  and D: \"poly_mod.Mp q D = D\" \n  and H: \"poly_mod.Mp q H = H\"\n  and S: \"poly_mod.Mp q S = S\" \n  and T: \"poly_mod.Mp q T = T\"\n  and mon: \"monic D\" \n  and q: \"q > 1\" \n  and rq: \"r = q * q\" \nshows \n  \"poly_mod.eq_m r C (D' * H')\" \n  \"poly_mod.eq_m r (D' * S' + H' * T') 1\"\n  \"poly_mod.Mp r D' = D'\" \n  \"poly_mod.Mp r H' = H'\" \n  \"poly_mod.Mp r S' = S'\" \n  \"poly_mod.Mp r T' = T'\" \n  \"poly_mod.Mp q D = poly_mod.Mp q D'\" \n  \"poly_mod.Mp q H = poly_mod.Mp q H'\" \n  \"poly_mod.Mp q S = poly_mod.Mp q S'\" \n  \"poly_mod.Mp q T = poly_mod.Mp q T'\" \n  \"monic D'\"", "lemma decrease[termination_simp]: \"\\<not> j \\<le> 1 \\<Longrightarrow> odd j \\<Longrightarrow> Suc (j div 2) < j\"", "lemma quadratic_hensel_main_code[code]: \"quadratic_hensel_main j = (\n   if j \\<le> 1 then (D1, H1)\n      else if even j\n      then (case quadratic_hensel_loop (j div 2) of\n            (q, S, T, D, H) \\<Rightarrow>\n               simple_quadratic_hensel_step q S T D H)            \n       else (case quadratic_hensel_loop (j div 2 + 1) of\n            (q, S, T, D, H) \\<Rightarrow>\n              (case simple_quadratic_hensel_step q S T D H of \n                (D', H') \\<Rightarrow> let down = poly_mod.Mp (q * q div p) in (down D', down H'))))\"", "lemma quadratic_hensel_loop:\n  assumes \"quadratic_hensel_loop j = (q, S, T, D, H)\"\n  shows \"(poly_mod.eq_m q C (D * H) \\<and> monic D\n    \\<and> poly_mod.eq_m p D1 D \\<and> poly_mod.eq_m p H1 H\n    \\<and> poly_mod.eq_m q (D * S + H * T) 1\n    \\<and> poly_mod.Mp q D = D \\<and> poly_mod.Mp q H = H\n    \\<and> poly_mod.Mp q S = S \\<and> poly_mod.Mp q T = T\n    \\<and> q = p^j)\"", "lemma quadratic_hensel_main: assumes res: \"quadratic_hensel_main j = (D,H)\" \n  shows \"poly_mod.eq_m (p^j) C (D * H)\"\n  \"monic D\" \n  \"poly_mod.eq_m p D1 D\" \n  \"poly_mod.eq_m p H1 H\" \n  \"poly_mod.Mp (p^j) D = D\" \n  \"poly_mod.Mp (p^j) H = H\"", "lemma sub_trees_refl[simp]: \"t \\<in> sub_trees t\"", "lemma product_factor_tree: assumes \"\\<And> x. x \\<in># factors_of_factor_tree t \\<Longrightarrow> poly_mod.Mp p x = x\" \n  shows \"u \\<in> sub_trees (product_factor_tree p t) \\<Longrightarrow> factor_node_info u = f \\<Longrightarrow> \n  poly_mod.Mp p f = f \\<and> f = poly_mod.Mp p (prod_mset (factors_of_factor_tree u)) \\<and> \n  factors_of_factor_tree (product_factor_tree p t) = factors_of_factor_tree t\"", "lemma create_factor_tree_simple: \"xs \\<noteq> [] \\<Longrightarrow> factors_of_factor_tree (create_factor_tree_simple xs) = mset xs\"", "lemma partition_factors_main: \"partition_factors_main s xs = (a,b) \\<Longrightarrow> mset xs = mset a + mset b\"", "lemma partition_factors: \"partition_factors xs = (a,b) \\<Longrightarrow> mset xs = mset a + mset b\"", "lemma partition_factors_length: assumes \"\\<not> length xs \\<le> 1\" \"(a,b) = partition_factors xs\"\n  shows [termination_simp]: \"length a < length xs\" \"length b < length xs\" and \"a \\<noteq> []\" \"b \\<noteq> []\"", "lemma create_factor_tree_balanced: \"xs \\<noteq> [] \\<Longrightarrow> factors_of_factor_tree (create_factor_tree_balanced xs) = mset (map fst xs)\"", "lemma create_factor_tree: assumes \"xs \\<noteq> []\"\n  shows \"factors_of_factor_tree (create_factor_tree xs) = mset xs\"", "lemma hensel_binary: \n  assumes cop: \"coprime_m D H\" and eq: \"eq_m C (D * H)\"\n  and normalized_input: \"Mp D = D\" \"Mp H = H\"\n  and monic_input: \"monic D\" \n  and hensel_result: \"hensel_binary C D H = (D',H')\" \n  shows \"poly_mod.eq_m (p^n) C (D' * H') \\<comment> \\<open>the main result: equivalence mod \\<open>p^n\\<close>\\<close>\n    \\<and> monic D' \\<comment> \\<open>monic output\\<close>\n    \\<and> eq_m D D' \\<and> eq_m H H' \\<comment> \\<open>apply \\<open>`mod p`\\<close> on \\<open>D'\\<close> and \\<open>H'\\<close> yields \\<open>D\\<close> and \\<open>H\\<close> again\\<close>\n    \\<and> poly_mod.Mp (p^n) D' = D' \\<and> poly_mod.Mp (p^n) H' = H' \\<comment> \\<open>output is normalized\\<close>\"", "lemma hensel_main: \n  assumes eq: \"eq_m C (prod_mset (factors_of_factor_tree Fs))\"\n  and \"\\<And> F. F \\<in># factors_of_factor_tree Fs \\<Longrightarrow> Mp F = F \\<and> monic F\"  \n  and hensel_result: \"hensel_main C Fs = Gs\" \n  and C: \"monic C\" \"poly_mod.Mp (p^n) C = C\" \n  and sf: \"square_free_m C\" \n  and \"\\<And> f t. t \\<in> sub_trees Fs \\<Longrightarrow> factor_node_info t = f \\<Longrightarrow> f = Mp (prod_mset (factors_of_factor_tree t))\"\n  shows \"poly_mod.eq_m (p^n) C (prod_list Gs) \\<comment> \\<open>the main result: equivalence mod \\<open>p^n\\<close>\\<close>\n    \\<and> factors_of_factor_tree Fs = mset (map Mp Gs)\n    \\<and> (\\<forall> G. G \\<in> set Gs \\<longrightarrow> monic G \\<and> poly_mod.Mp (p^n) G = G)\"", "lemma hensel_lifting_monic: \n  assumes eq: \"poly_mod.eq_m p C (prod_list Fs)\"\n  and Fs: \"\\<And> F. F \\<in> set Fs \\<Longrightarrow> poly_mod.Mp p F = F \\<and> monic F\"  \n  and res: \"hensel_lifting_monic p n C Fs = Gs\" \n  and mon: \"monic (poly_mod.Mp (p^n) C)\" \n  and sf: \"poly_mod.square_free_m p C\"\n  shows \"poly_mod.eq_m (p^n) C (prod_list Gs)\"\n    \"mset (map (poly_mod.Mp p) Gs) = mset Fs\" \n    \"G \\<in> set Gs \\<Longrightarrow> monic G \\<and> poly_mod.Mp (p^n) G = G\"", "lemma hensel_lifting:\n  assumes res: \"hensel_lifting p n f fs = gs\"                      \\<comment> \\<open>result of hensel is fact. \\<open>gs\\<close>\\<close>\n    and cop: \"coprime (lead_coeff f) p\"\n    and sf: \"poly_mod.square_free_m p f\"\n    and fact: \"poly_mod.factorization_m p f (c, mset fs)\"          \\<comment> \\<open>input is fact. \\<open>fs mod p\\<close>\\<close>\n    and c: \"c \\<in> {0..<p}\"\n    and norm: \"(\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})\"\n  shows \"poly_mod.factorization_m (p^n) f (lead_coeff f, mset gs) \\<comment> \\<open>factorization mod \\<open>p^n\\<close>\\<close>\"\n      \"sort (map degree fs) = sort (map degree gs)                \\<comment> \\<open>degrees stay the same\\<close>\"\n      \"\\<And> g. g \\<in> set gs \\<Longrightarrow> monic g \\<and> poly_mod.Mp (p^n) g = g \\<and>   \\<comment> \\<open>monic and normalized\\<close>\n        irreducible_m g \\<and>                               \\<comment> \\<open>irreducibility even mod \\<open>p\\<close>\\<close>\n        degree_m g = degree g   \\<comment> \\<open>mod \\<open>p\\<close> does not change degree of \\<open>g\\<close>\\<close>\""], "translations": [["", "lemma uniqueness_poly_equality:\n  fixes f g :: \"'a :: {factorial_ring_gcd,semiring_gcd_mult_normalize} poly\"\n  assumes cop: \"coprime f g\"\n  and deg: \"B = 0 \\<or> degree B < degree f\" \"B' = 0 \\<or> degree B' < degree f\"\n  and f: \"f \\<noteq> 0\" and eq: \"A * f + B * g = A' * f + B' * g\" \n  shows \"A = A'\" \"B = B'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = A' &&& B = B'", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. A = A'\n 2. B = B'", "from eq"], ["proof (chain)\npicking this:\n  A * f + B * g = A' * f + B' * g", "have *: \"(A - A') * f = (B' - B) * g\""], ["proof (prove)\nusing this:\n  A * f + B * g = A' * f + B' * g\n\ngoal (1 subgoal):\n 1. (A - A') * f = (B' - B) * g", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (A - A') * f = (B' - B) * g\n\ngoal (2 subgoals):\n 1. A = A'\n 2. B = B'", "hence \"f dvd (B' - B) * g\""], ["proof (prove)\nusing this:\n  (A - A') * f = (B' - B) * g\n\ngoal (1 subgoal):\n 1. f dvd (B' - B) * g", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  (A - A') * f = (B' - B) * g\n\ngoal (1 subgoal):\n 1. \\<exists>k. (B' - B) * g = f * k", "by (intro exI[of _ \"A - A'\"], auto simp: field_simps)"], ["proof (state)\nthis:\n  f dvd (B' - B) * g\n\ngoal (2 subgoals):\n 1. A = A'\n 2. B = B'", "with cop[simplified]"], ["proof (chain)\npicking this:\n  algebraic_semidom_class.coprime f g\n  f dvd (B' - B) * g", "have dvd: \"f dvd (B' - B)\""], ["proof (prove)\nusing this:\n  algebraic_semidom_class.coprime f g\n  f dvd (B' - B) * g\n\ngoal (1 subgoal):\n 1. f dvd B' - B", "by (simp add: coprime_dvd_mult_right_iff ac_simps)"], ["proof (state)\nthis:\n  f dvd B' - B\n\ngoal (2 subgoals):\n 1. A = A'\n 2. B = B'", "from divides_degree[OF this]"], ["proof (chain)\npicking this:\n  degree f \\<le> degree (B' - B) \\<or> B' - B = 0", "have \"degree f \\<le> degree (B' - B) \\<or> B = B'\""], ["proof (prove)\nusing this:\n  degree f \\<le> degree (B' - B) \\<or> B' - B = 0\n\ngoal (1 subgoal):\n 1. degree f \\<le> degree (B' - B) \\<or> B = B'", "by auto"], ["proof (state)\nthis:\n  degree f \\<le> degree (B' - B) \\<or> B = B'\n\ngoal (2 subgoals):\n 1. A = A'\n 2. B = B'", "with degree_diff_le_max[of B' B] deg"], ["proof (chain)\npicking this:\n  degree (B' - B) \\<le> max (degree B') (degree B)\n  B = 0 \\<or> degree B < degree f\n  B' = 0 \\<or> degree B' < degree f\n  degree f \\<le> degree (B' - B) \\<or> B = B'", "show \"B = B'\""], ["proof (prove)\nusing this:\n  degree (B' - B) \\<le> max (degree B') (degree B)\n  B = 0 \\<or> degree B < degree f\n  B' = 0 \\<or> degree B' < degree f\n  degree f \\<le> degree (B' - B) \\<or> B = B'\n\ngoal (1 subgoal):\n 1. B = B'", "by auto"], ["proof (state)\nthis:\n  B = B'\n\ngoal (1 subgoal):\n 1. A = A'", "with * f"], ["proof (chain)\npicking this:\n  (A - A') * f = (B' - B) * g\n  f \\<noteq> 0\n  B = B'", "show \"A = A'\""], ["proof (prove)\nusing this:\n  (A - A') * f = (B' - B) * g\n  f \\<noteq> 0\n  B = B'\n\ngoal (1 subgoal):\n 1. A = A'", "by auto"], ["proof (state)\nthis:\n  A = A'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas (in poly_mod_prime_type) uniqueness_poly_equality =\n  uniqueness_poly_equality[where 'a=\"'a mod_ring\", untransferred]"], ["", "lemmas (in poly_mod_prime) uniqueness_poly_equality = poly_mod_prime_type.uniqueness_poly_equality\n  [unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]"], ["", "lemma pseudo_divmod_main_list_1_is_divmod_poly_one_main_list: \n  \"pseudo_divmod_main_list (1 :: 'a :: comm_ring_1) q f g n = divmod_poly_one_main_list q f g n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudo_divmod_main_list (1::'a) q f g n =\n    divmod_poly_one_main_list q f g n", "by (induct n arbitrary: q f g, auto simp: Let_def)"], ["", "lemma pdivmod_monic_pseudo_divmod: assumes g: \"monic g\" shows \"pdivmod_monic f g = pseudo_divmod f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdivmod_monic f g = pseudo_divmod f g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pdivmod_monic f g = pseudo_divmod f g", "from g"], ["proof (chain)\npicking this:\n  monic g", "have id: \"(coeffs g = []) = False\""], ["proof (prove)\nusing this:\n  monic g\n\ngoal (1 subgoal):\n 1. (coeffs g = []) = False", "by auto"], ["proof (state)\nthis:\n  (coeffs g = []) = False\n\ngoal (1 subgoal):\n 1. pdivmod_monic f g = pseudo_divmod f g", "from g"], ["proof (chain)\npicking this:\n  monic g", "have mon: \"hd (rev (coeffs g)) = 1\""], ["proof (prove)\nusing this:\n  monic g\n\ngoal (1 subgoal):\n 1. hd (rev (coeffs g)) = (1::'a)", "by (metis coeffs_eq_Nil hd_rev id last_coeffs_eq_coeff_degree)"], ["proof (state)\nthis:\n  hd (rev (coeffs g)) = (1::'a)\n\ngoal (1 subgoal):\n 1. pdivmod_monic f g = pseudo_divmod f g", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. pdivmod_monic f g = pseudo_divmod f g", "unfolding pseudo_divmod_impl pseudo_divmod_list_def id if_False pdivmod_monic_def Let_def mon\n      pseudo_divmod_main_list_1_is_divmod_poly_one_main_list"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case divmod_poly_one_main_list [] (rev (coeffs f)) (rev (coeffs g))\n           (1 + length (coeffs f) - length (coeffs g)) of\n     (q, r) \\<Rightarrow> (poly_of_list q, poly_of_list (rev r))) =\n    map_prod poly_of_list poly_of_list\n     (case divmod_poly_one_main_list [] (rev (coeffs f)) (rev (coeffs g))\n            (1 + length (coeffs f) - length (coeffs g)) of\n      (qu, re) \\<Rightarrow> (qu, rev re))", "by (auto split: prod.splits)"], ["proof (state)\nthis:\n  pdivmod_monic f g = pseudo_divmod f g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pdivmod_monic: assumes g: \"monic g\" and res: \"pdivmod_monic f g = (q, r)\"\n  shows \"f = g * q + r\" \"r = 0 \\<or> degree r < degree g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = g * q + r &&& r = 0 \\<or> degree r < degree g", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. f = g * q + r\n 2. r = 0 \\<or> degree r < degree g", "from g"], ["proof (chain)\npicking this:\n  monic g", "have g0: \"g \\<noteq> 0\""], ["proof (prove)\nusing this:\n  monic g\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  g \\<noteq> 0\n\ngoal (2 subgoals):\n 1. f = g * q + r\n 2. r = 0 \\<or> degree r < degree g", "from pseudo_divmod[OF g0 res[unfolded pdivmod_monic_pseudo_divmod[OF g]], unfolded g]"], ["proof (chain)\npicking this:\n  Polynomial.smult ((1::'a) ^ (Suc (degree f) - degree g)) f = g * q + r\n  r = 0 \\<or> degree r < degree g", "show \"f = g * q + r\" \"r = 0 \\<or> degree r < degree g\""], ["proof (prove)\nusing this:\n  Polynomial.smult ((1::'a) ^ (Suc (degree f) - degree g)) f = g * q + r\n  r = 0 \\<or> degree r < degree g\n\ngoal (1 subgoal):\n 1. f = g * q + r &&& r = 0 \\<or> degree r < degree g", "by auto"], ["proof (state)\nthis:\n  f = g * q + r\n  r = 0 \\<or> degree r < degree g\n\ngoal:\nNo subgoals!", "qed"], ["", "definition dupe_monic :: \"'a :: comm_ring_1  poly \\<Rightarrow> 'a poly \\<Rightarrow> 'a poly \\<Rightarrow> 'a poly \\<Rightarrow> 'a poly \\<Rightarrow>\n  'a poly * 'a poly\" where\n  \"dupe_monic D H S T U = (case pdivmod_monic (T * U) D of (q,r) \\<Rightarrow>\n     (S * U + H * q, r))\""], ["", "lemma dupe_monic: assumes 1: \"D*S + H*T = 1\" \n  and mon: \"monic D\" \n  and dupe: \"dupe_monic D H S T U = (A,B)\" \nshows \"A * D + B * H = U\" \"B = 0 \\<or> degree B < degree D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * D + B * H = U &&& B = 0 \\<or> degree B < degree D", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. A * D + B * H = U\n 2. B = 0 \\<or> degree B < degree D", "obtain Q R where div: \"pdivmod_monic ((T * U)) D = (Q,R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q R.\n        pdivmod_monic (T * U) D = (Q, R) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  pdivmod_monic (T * U) D = (Q, R)\n\ngoal (2 subgoals):\n 1. A * D + B * H = U\n 2. B = 0 \\<or> degree B < degree D", "from dupe[unfolded dupe_monic_def div split]"], ["proof (chain)\npicking this:\n  (S * U + H * Q, R) = (A, B)", "have A: \"A = (S * U + H * Q)\" and B: \"B = R\""], ["proof (prove)\nusing this:\n  (S * U + H * Q, R) = (A, B)\n\ngoal (1 subgoal):\n 1. A = S * U + H * Q &&& B = R", "by auto"], ["proof (state)\nthis:\n  A = S * U + H * Q\n  B = R\n\ngoal (2 subgoals):\n 1. A * D + B * H = U\n 2. B = 0 \\<or> degree B < degree D", "from pdivmod_monic[OF mon div]"], ["proof (chain)\npicking this:\n  T * U = D * Q + R\n  R = 0 \\<or> degree R < degree D", "have TU: \"T * U = D * Q + R\" and \n    deg: \"R = 0 \\<or> degree R < degree D\""], ["proof (prove)\nusing this:\n  T * U = D * Q + R\n  R = 0 \\<or> degree R < degree D\n\ngoal (1 subgoal):\n 1. T * U = D * Q + R &&& R = 0 \\<or> degree R < degree D", "by auto"], ["proof (state)\nthis:\n  T * U = D * Q + R\n  R = 0 \\<or> degree R < degree D\n\ngoal (2 subgoals):\n 1. A * D + B * H = U\n 2. B = 0 \\<or> degree B < degree D", "hence R: \"R = T * U - D * Q\""], ["proof (prove)\nusing this:\n  T * U = D * Q + R\n  R = 0 \\<or> degree R < degree D\n\ngoal (1 subgoal):\n 1. R = T * U - D * Q", "by simp"], ["proof (state)\nthis:\n  R = T * U - D * Q\n\ngoal (2 subgoals):\n 1. A * D + B * H = U\n 2. B = 0 \\<or> degree B < degree D", "have \"A * D + B * H = (D * S + H * T) * U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * D + B * H = (D * S + H * T) * U", "unfolding A B R"], ["proof (prove)\ngoal (1 subgoal):\n 1. (S * U + H * Q) * D + (T * U - D * Q) * H = (D * S + H * T) * U", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  A * D + B * H = (D * S + H * T) * U\n\ngoal (2 subgoals):\n 1. A * D + B * H = U\n 2. B = 0 \\<or> degree B < degree D", "also"], ["proof (state)\nthis:\n  A * D + B * H = (D * S + H * T) * U\n\ngoal (2 subgoals):\n 1. A * D + B * H = U\n 2. B = 0 \\<or> degree B < degree D", "have \"\\<dots> = U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (D * S + H * T) * U = U", "unfolding 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * U = U", "by simp"], ["proof (state)\nthis:\n  (D * S + H * T) * U = U\n\ngoal (2 subgoals):\n 1. A * D + B * H = U\n 2. B = 0 \\<or> degree B < degree D", "finally"], ["proof (chain)\npicking this:\n  A * D + B * H = U", "show eq: \"A * D + B * H = U\""], ["proof (prove)\nusing this:\n  A * D + B * H = U\n\ngoal (1 subgoal):\n 1. A * D + B * H = U", "."], ["proof (state)\nthis:\n  A * D + B * H = U\n\ngoal (1 subgoal):\n 1. B = 0 \\<or> degree B < degree D", "show \"B = 0 \\<or> degree B < degree D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = 0 \\<or> degree B < degree D", "using deg"], ["proof (prove)\nusing this:\n  R = 0 \\<or> degree R < degree D\n\ngoal (1 subgoal):\n 1. B = 0 \\<or> degree B < degree D", "unfolding B"], ["proof (prove)\nusing this:\n  R = 0 \\<or> degree R < degree D\n\ngoal (1 subgoal):\n 1. R = 0 \\<or> degree R < degree D", "."], ["proof (state)\nthis:\n  B = 0 \\<or> degree B < degree D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dupe_monic_unique: fixes D :: \"'a ::  {factorial_ring_gcd,semiring_gcd_mult_normalize} poly\" \n  assumes 1: \"D*S + H*T = 1\" \n  and mon: \"monic D\" \n  and dupe: \"dupe_monic D H S T U = (A,B)\" \n  and cop: \"coprime D H\"\n  and other: \"A' * D + B' * H = U\" \"B' = 0 \\<or> degree B' < degree D\"\nshows \"A' = A\" \"B' = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' = A &&& B' = B", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. A' = A\n 2. B' = B", "from dupe_monic[OF 1 mon dupe]"], ["proof (chain)\npicking this:\n  A * D + B * H = U\n  B = 0 \\<or> degree B < degree D", "have one: \"A * D + B * H = U\" \"B = 0 \\<or> degree B < degree D\""], ["proof (prove)\nusing this:\n  A * D + B * H = U\n  B = 0 \\<or> degree B < degree D\n\ngoal (1 subgoal):\n 1. A * D + B * H = U &&& B = 0 \\<or> degree B < degree D", "by auto"], ["proof (state)\nthis:\n  A * D + B * H = U\n  B = 0 \\<or> degree B < degree D\n\ngoal (2 subgoals):\n 1. A' = A\n 2. B' = B", "from mon"], ["proof (chain)\npicking this:\n  monic D", "have D0: \"D \\<noteq> 0\""], ["proof (prove)\nusing this:\n  monic D\n\ngoal (1 subgoal):\n 1. D \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  D \\<noteq> 0\n\ngoal (2 subgoals):\n 1. A' = A\n 2. B' = B", "from uniqueness_poly_equality[OF cop one(2) other(2) D0, of A A', unfolded other, OF one(1)]"], ["proof (chain)\npicking this:\n  A = A'\n  B = B'", "show \"A' = A\" \"B' = B\""], ["proof (prove)\nusing this:\n  A = A'\n  B = B'\n\ngoal (1 subgoal):\n 1. A' = A &&& B' = B", "by auto"], ["proof (state)\nthis:\n  A' = A\n  B' = B\n\ngoal:\nNo subgoals!", "qed"], ["", "context ring_ops\nbegin"], ["", "lemma poly_rel_dupe_monic_i: assumes mon: \"monic D\" \n  and rel: \"poly_rel d D\" \"poly_rel h H\" \"poly_rel s S\" \"poly_rel t T\" \"poly_rel u U\" \nshows \"rel_prod poly_rel poly_rel (dupe_monic_i ops d h s t u) (dupe_monic D H S T U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod poly_rel poly_rel (dupe_monic_i ops d h s t u)\n     (dupe_monic D H S T U)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_prod poly_rel poly_rel (dupe_monic_i ops d h s t u)\n     (dupe_monic D H S T U)", "note defs = dupe_monic_i_def dupe_monic_def"], ["proof (state)\nthis:\n  dupe_monic_i ?ops ?D ?H ?S ?T ?U =\n  (case pdivmod_monic_i ?ops (times_poly_i ?ops ?T ?U) ?D of\n   (Q, R) \\<Rightarrow>\n     (plus_poly_i ?ops (times_poly_i ?ops ?S ?U) (times_poly_i ?ops ?H Q),\n      R))\n  dupe_monic ?D ?H ?S ?T ?U =\n  (case pdivmod_monic (?T * ?U) ?D of\n   (q, r) \\<Rightarrow> (?S * ?U + ?H * q, r))\n\ngoal (1 subgoal):\n 1. rel_prod poly_rel poly_rel (dupe_monic_i ops d h s t u)\n     (dupe_monic D H S T U)", "note [transfer_rule] = rel"], ["proof (state)\nthis:\n  poly_rel d D\n  poly_rel h H\n  poly_rel s S\n  poly_rel t T\n  poly_rel u U\n\ngoal (1 subgoal):\n 1. rel_prod poly_rel poly_rel (dupe_monic_i ops d h s t u)\n     (dupe_monic D H S T U)", "have [transfer_rule]: \"rel_prod poly_rel poly_rel \n    (pdivmod_monic_i ops (times_poly_i ops t u) d) \n    (pdivmod_monic (T * U) D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod poly_rel poly_rel\n     (pdivmod_monic_i ops (times_poly_i ops t u) d)\n     (pdivmod_monic (T * U) D)", "by (rule poly_rel_pdivmod_monic[OF mon], transfer_prover+)"], ["proof (state)\nthis:\n  rel_prod poly_rel poly_rel (pdivmod_monic_i ops (times_poly_i ops t u) d)\n   (pdivmod_monic (T * U) D)\n\ngoal (1 subgoal):\n 1. rel_prod poly_rel poly_rel (dupe_monic_i ops d h s t u)\n     (dupe_monic D H S T U)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod poly_rel poly_rel (dupe_monic_i ops d h s t u)\n     (dupe_monic D H S T U)", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod poly_rel poly_rel\n     (case pdivmod_monic_i ops (times_poly_i ops t u) d of\n      (Q, x) \\<Rightarrow>\n        (plus_poly_i ops (times_poly_i ops s u) (times_poly_i ops h Q), x))\n     (case pdivmod_monic (T * U) D of\n      (q, x) \\<Rightarrow> (S * U + H * q, x))", "by transfer_prover"], ["proof (state)\nthis:\n  rel_prod poly_rel poly_rel (dupe_monic_i ops d h s t u)\n   (dupe_monic D H S T U)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context mod_ring_gen\nbegin"], ["", "lemma monic_of_int_poly: \"monic D \\<Longrightarrow> monic (of_int_poly (Mp D) :: 'a mod_ring poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic D \\<Longrightarrow> monic (of_int_poly (Mp D))", "using Mp_f_representative Mp_to_int_poly monic_Mp"], ["proof (prove)\nusing this:\n  Mp ?f = to_int_poly (of_int_poly ?f)\n  Mp (to_int_poly ?f) = to_int_poly ?f\n  monic ?f \\<Longrightarrow> monic (Mp ?f)\n\ngoal (1 subgoal):\n 1. monic D \\<Longrightarrow> monic (of_int_poly (Mp D))", "by auto"], ["", "lemma dupe_monic_i: assumes dupe_i: \"dupe_monic_i ff_ops d h s t u = (a,b)\" \n  and 1: \"D*S + H*T =m 1\" \n  and mon: \"monic D\" \n  and A: \"A = to_int_poly_i ff_ops a\" \n  and B: \"B = to_int_poly_i ff_ops b\" \n  and d: \"Mp_rel_i d D\" \n  and h: \"Mp_rel_i h H\" \n  and s: \"Mp_rel_i s S\" \n  and t: \"Mp_rel_i t T\" \n  and u: \"Mp_rel_i u U\" \nshows \n  \"A * D + B * H =m U\" \n  \"B = 0 \\<or> degree B < degree D\" \n  \"Mp_rel_i a A\" \n  \"Mp_rel_i b B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A * D + B * H =m U &&& B = 0 \\<or> degree B < degree D) &&&\n    Mp_rel_i a A &&& Mp_rel_i b B", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp_rel_i a A\n 4. Mp_rel_i b B", "let ?I = \"\\<lambda> f. of_int_poly (Mp f) :: 'a mod_ring poly\""], ["proof (state)\ngoal (4 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp_rel_i a A\n 4. Mp_rel_i b B", "let ?i = \"to_int_poly_i ff_ops\""], ["proof (state)\ngoal (4 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp_rel_i a A\n 4. Mp_rel_i b B", "note dd = Mp_rel_iD[OF d]"], ["proof (state)\nthis:\n  poly_rel d (of_int_poly (Mp D))\n  MP_Rel D (of_int_poly (Mp D))\n\ngoal (4 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp_rel_i a A\n 4. Mp_rel_i b B", "note hh = Mp_rel_iD[OF h]"], ["proof (state)\nthis:\n  poly_rel h (of_int_poly (Mp H))\n  MP_Rel H (of_int_poly (Mp H))\n\ngoal (4 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp_rel_i a A\n 4. Mp_rel_i b B", "note ss = Mp_rel_iD[OF s]"], ["proof (state)\nthis:\n  poly_rel s (of_int_poly (Mp S))\n  MP_Rel S (of_int_poly (Mp S))\n\ngoal (4 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp_rel_i a A\n 4. Mp_rel_i b B", "note tt = Mp_rel_iD[OF t]"], ["proof (state)\nthis:\n  poly_rel t (of_int_poly (Mp T))\n  MP_Rel T (of_int_poly (Mp T))\n\ngoal (4 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp_rel_i a A\n 4. Mp_rel_i b B", "note uu = Mp_rel_iD[OF u]"], ["proof (state)\nthis:\n  poly_rel u (of_int_poly (Mp U))\n  MP_Rel U (of_int_poly (Mp U))\n\ngoal (4 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp_rel_i a A\n 4. Mp_rel_i b B", "obtain A' B' where dupe: \"dupe_monic (?I D) (?I H) (?I S) (?I T) (?I U) = (A',B')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A' B'.\n        dupe_monic (of_int_poly (Mp D)) (of_int_poly (Mp H))\n         (of_int_poly (Mp S)) (of_int_poly (Mp T)) (of_int_poly (Mp U)) =\n        (A', B') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  dupe_monic (of_int_poly (Mp D)) (of_int_poly (Mp H)) (of_int_poly (Mp S))\n   (of_int_poly (Mp T)) (of_int_poly (Mp U)) =\n  (A', B')\n\ngoal (4 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp_rel_i a A\n 4. Mp_rel_i b B", "from poly_rel_dupe_monic_i[OF monic_of_int_poly[OF mon] dd(1) hh(1) ss(1) tt(1) uu(1), unfolded dupe_i dupe]"], ["proof (chain)\npicking this:\n  rel_prod poly_rel poly_rel (a, b) (A', B')", "have a: \"poly_rel a A'\" and b: \"poly_rel b B'\""], ["proof (prove)\nusing this:\n  rel_prod poly_rel poly_rel (a, b) (A', B')\n\ngoal (1 subgoal):\n 1. poly_rel a A' &&& poly_rel b B'", "by auto"], ["proof (state)\nthis:\n  poly_rel a A'\n  poly_rel b B'\n\ngoal (4 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp_rel_i a A\n 4. Mp_rel_i b B", "show aa: \"Mp_rel_i a A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp_rel_i a A", "by (rule Mp_rel_iI'[OF a, folded A])"], ["proof (state)\nthis:\n  Mp_rel_i a A\n\ngoal (3 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp_rel_i b B", "show bb: \"Mp_rel_i b B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp_rel_i b B", "by (rule Mp_rel_iI'[OF b, folded B])"], ["proof (state)\nthis:\n  Mp_rel_i b B\n\ngoal (2 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D", "note Aa = Mp_rel_iD[OF aa]"], ["proof (state)\nthis:\n  poly_rel a (of_int_poly (Mp A))\n  MP_Rel A (of_int_poly (Mp A))\n\ngoal (2 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D", "note Bb = Mp_rel_iD[OF bb]"], ["proof (state)\nthis:\n  poly_rel b (of_int_poly (Mp B))\n  MP_Rel B (of_int_poly (Mp B))\n\ngoal (2 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D", "from poly_rel_inj[OF a Aa(1)] A"], ["proof (chain)\npicking this:\n  A' = of_int_poly (Mp A)\n  A = to_int_poly_i ff_ops a", "have A: \"A' = ?I A\""], ["proof (prove)\nusing this:\n  A' = of_int_poly (Mp A)\n  A = to_int_poly_i ff_ops a\n\ngoal (1 subgoal):\n 1. A' = of_int_poly (Mp A)", "by simp"], ["proof (state)\nthis:\n  A' = of_int_poly (Mp A)\n\ngoal (2 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D", "from poly_rel_inj[OF b Bb(1)] B"], ["proof (chain)\npicking this:\n  B' = of_int_poly (Mp B)\n  B = to_int_poly_i ff_ops b", "have B: \"B' = ?I B\""], ["proof (prove)\nusing this:\n  B' = of_int_poly (Mp B)\n  B = to_int_poly_i ff_ops b\n\ngoal (1 subgoal):\n 1. B' = of_int_poly (Mp B)", "by simp"], ["proof (state)\nthis:\n  B' = of_int_poly (Mp B)\n\ngoal (2 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D", "note Mp = dd(2) hh(2) ss(2) tt(2) uu(2)"], ["proof (state)\nthis:\n  MP_Rel D (of_int_poly (Mp D))\n  MP_Rel H (of_int_poly (Mp H))\n  MP_Rel S (of_int_poly (Mp S))\n  MP_Rel T (of_int_poly (Mp T))\n  MP_Rel U (of_int_poly (Mp U))\n\ngoal (2 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D", "note [transfer_rule] = Mp"], ["proof (state)\nthis:\n  MP_Rel D (of_int_poly (Mp D))\n  MP_Rel H (of_int_poly (Mp H))\n  MP_Rel S (of_int_poly (Mp S))\n  MP_Rel T (of_int_poly (Mp T))\n  MP_Rel U (of_int_poly (Mp U))\n\ngoal (2 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D", "have \"(=) (D * S + H * T =m 1) (?I D * ?I S + ?I H * ?I T = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (D * S + H * T =m 1) =\n    (of_int_poly (Mp D) * of_int_poly (Mp S) +\n     of_int_poly (Mp H) * of_int_poly (Mp T) =\n     1)", "by transfer_prover"], ["proof (state)\nthis:\n  (D * S + H * T =m 1) =\n  (of_int_poly (Mp D) * of_int_poly (Mp S) +\n   of_int_poly (Mp H) * of_int_poly (Mp T) =\n   1)\n\ngoal (2 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D", "with 1"], ["proof (chain)\npicking this:\n  D * S + H * T =m 1\n  (D * S + H * T =m 1) =\n  (of_int_poly (Mp D) * of_int_poly (Mp S) +\n   of_int_poly (Mp H) * of_int_poly (Mp T) =\n   1)", "have 11: \"?I D * ?I S + ?I H * ?I T = 1\""], ["proof (prove)\nusing this:\n  D * S + H * T =m 1\n  (D * S + H * T =m 1) =\n  (of_int_poly (Mp D) * of_int_poly (Mp S) +\n   of_int_poly (Mp H) * of_int_poly (Mp T) =\n   1)\n\ngoal (1 subgoal):\n 1. of_int_poly (Mp D) * of_int_poly (Mp S) +\n    of_int_poly (Mp H) * of_int_poly (Mp T) =\n    1", "by simp"], ["proof (state)\nthis:\n  of_int_poly (Mp D) * of_int_poly (Mp S) +\n  of_int_poly (Mp H) * of_int_poly (Mp T) =\n  1\n\ngoal (2 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D", "from dupe_monic[OF 11 monic_of_int_poly[OF mon] dupe, unfolded A B]"], ["proof (chain)\npicking this:\n  of_int_poly (Mp A) * of_int_poly (Mp D) +\n  of_int_poly (Mp B) * of_int_poly (Mp H) =\n  of_int_poly (Mp U)\n  of_int_poly (Mp B) = 0 \\<or>\n  degree (of_int_poly (Mp B)) < degree (of_int_poly (Mp D))", "have res: \"?I A * ?I D + ?I B * ?I H = ?I U\" \"?I B = 0 \\<or> degree (?I B) < degree (?I D)\""], ["proof (prove)\nusing this:\n  of_int_poly (Mp A) * of_int_poly (Mp D) +\n  of_int_poly (Mp B) * of_int_poly (Mp H) =\n  of_int_poly (Mp U)\n  of_int_poly (Mp B) = 0 \\<or>\n  degree (of_int_poly (Mp B)) < degree (of_int_poly (Mp D))\n\ngoal (1 subgoal):\n 1. of_int_poly (Mp A) * of_int_poly (Mp D) +\n    of_int_poly (Mp B) * of_int_poly (Mp H) =\n    of_int_poly (Mp U) &&&\n    of_int_poly (Mp B) = 0 \\<or>\n    degree (of_int_poly (Mp B)) < degree (of_int_poly (Mp D))", "by auto"], ["proof (state)\nthis:\n  of_int_poly (Mp A) * of_int_poly (Mp D) +\n  of_int_poly (Mp B) * of_int_poly (Mp H) =\n  of_int_poly (Mp U)\n  of_int_poly (Mp B) = 0 \\<or>\n  degree (of_int_poly (Mp B)) < degree (of_int_poly (Mp D))\n\ngoal (2 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D", "note [transfer_rule] = Aa(2) Bb(2)"], ["proof (state)\nthis:\n  MP_Rel A (of_int_poly (Mp A))\n  MP_Rel B (of_int_poly (Mp B))\n\ngoal (2 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D", "have \"(=) (A * D + B * H =m U) (?I A * ?I D + ?I B * ?I H = ?I U)\"\n       \"(=) (B =m 0 \\<or> degree_m B < degree_m D) (?I B = 0 \\<or> degree (?I B) < degree (?I D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A * D + B * H =m U) =\n    (of_int_poly (Mp A) * of_int_poly (Mp D) +\n     of_int_poly (Mp B) * of_int_poly (Mp H) =\n     of_int_poly (Mp U)) &&&\n    (B =m 0 \\<or> degree_m B < degree_m D) =\n    (of_int_poly (Mp B) = 0 \\<or>\n     degree (of_int_poly (Mp B)) < degree (of_int_poly (Mp D)))", "by transfer_prover+"], ["proof (state)\nthis:\n  (A * D + B * H =m U) =\n  (of_int_poly (Mp A) * of_int_poly (Mp D) +\n   of_int_poly (Mp B) * of_int_poly (Mp H) =\n   of_int_poly (Mp U))\n  (B =m 0 \\<or> degree_m B < degree_m D) =\n  (of_int_poly (Mp B) = 0 \\<or>\n   degree (of_int_poly (Mp B)) < degree (of_int_poly (Mp D)))\n\ngoal (2 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D", "with res"], ["proof (chain)\npicking this:\n  of_int_poly (Mp A) * of_int_poly (Mp D) +\n  of_int_poly (Mp B) * of_int_poly (Mp H) =\n  of_int_poly (Mp U)\n  of_int_poly (Mp B) = 0 \\<or>\n  degree (of_int_poly (Mp B)) < degree (of_int_poly (Mp D))\n  (A * D + B * H =m U) =\n  (of_int_poly (Mp A) * of_int_poly (Mp D) +\n   of_int_poly (Mp B) * of_int_poly (Mp H) =\n   of_int_poly (Mp U))\n  (B =m 0 \\<or> degree_m B < degree_m D) =\n  (of_int_poly (Mp B) = 0 \\<or>\n   degree (of_int_poly (Mp B)) < degree (of_int_poly (Mp D)))", "have *: \"A * D + B * H =m U\" \"B =m 0 \\<or> degree_m B < degree_m D\""], ["proof (prove)\nusing this:\n  of_int_poly (Mp A) * of_int_poly (Mp D) +\n  of_int_poly (Mp B) * of_int_poly (Mp H) =\n  of_int_poly (Mp U)\n  of_int_poly (Mp B) = 0 \\<or>\n  degree (of_int_poly (Mp B)) < degree (of_int_poly (Mp D))\n  (A * D + B * H =m U) =\n  (of_int_poly (Mp A) * of_int_poly (Mp D) +\n   of_int_poly (Mp B) * of_int_poly (Mp H) =\n   of_int_poly (Mp U))\n  (B =m 0 \\<or> degree_m B < degree_m D) =\n  (of_int_poly (Mp B) = 0 \\<or>\n   degree (of_int_poly (Mp B)) < degree (of_int_poly (Mp D)))\n\ngoal (1 subgoal):\n 1. A * D + B * H =m U &&& B =m 0 \\<or> degree_m B < degree_m D", "by auto"], ["proof (state)\nthis:\n  A * D + B * H =m U\n  B =m 0 \\<or> degree_m B < degree_m D\n\ngoal (2 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D", "show \"A * D + B * H =m U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * D + B * H =m U", "by fact"], ["proof (state)\nthis:\n  A * D + B * H =m U\n\ngoal (1 subgoal):\n 1. B = 0 \\<or> degree B < degree D", "have B: \"Mp B = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp B = B", "using Mp_rel_i_Mp_to_int_poly_i assms(5) bb"], ["proof (prove)\nusing this:\n  Mp_rel_i ?f ?F \\<Longrightarrow>\n  Mp (to_int_poly_i ff_ops ?f) = to_int_poly_i ff_ops ?f\n  B = to_int_poly_i ff_ops b\n  Mp_rel_i b B\n\ngoal (1 subgoal):\n 1. Mp B = B", "by blast"], ["proof (state)\nthis:\n  Mp B = B\n\ngoal (1 subgoal):\n 1. B = 0 \\<or> degree B < degree D", "from *(2)"], ["proof (chain)\npicking this:\n  B =m 0 \\<or> degree_m B < degree_m D", "show \"B = 0 \\<or> degree B < degree D\""], ["proof (prove)\nusing this:\n  B =m 0 \\<or> degree_m B < degree_m D\n\ngoal (1 subgoal):\n 1. B = 0 \\<or> degree B < degree D", "unfolding B"], ["proof (prove)\nusing this:\n  B = Mp 0 \\<or> degree B < degree_m D\n\ngoal (1 subgoal):\n 1. B = 0 \\<or> degree B < degree D", "using degree_m_le[of D]"], ["proof (prove)\nusing this:\n  B = Mp 0 \\<or> degree B < degree_m D\n  degree_m D \\<le> degree D\n\ngoal (1 subgoal):\n 1. B = 0 \\<or> degree B < degree D", "by auto"], ["proof (state)\nthis:\n  B = 0 \\<or> degree B < degree D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Mp_rel_i_of_int_poly_i: assumes \"Mp F = F\"\n  shows \"Mp_rel_i (of_int_poly_i ff_ops F) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp_rel_i (of_int_poly_i ff_ops F) F", "by (metis Mp_f_representative Mp_rel_iI' assms poly_rel_of_int_poly to_int_poly_i)"], ["", "lemma dupe_monic_i_int: assumes dupe_i: \"dupe_monic_i_int ff_ops D H S T U = (A,B)\" \n  and 1: \"D*S + H*T =m 1\" \n  and mon: \"monic D\" \n  and norm: \"Mp D = D\" \"Mp H = H\" \"Mp S = S\" \"Mp T = T\" \"Mp U = U\" \nshows \n  \"A * D + B * H =m U\" \n  \"B = 0 \\<or> degree B < degree D\" \n  \"Mp A = A\" \n  \"Mp B = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A * D + B * H =m U &&& B = 0 \\<or> degree B < degree D) &&&\n    Mp A = A &&& Mp B = B", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B", "let ?oi = \"of_int_poly_i ff_ops\""], ["proof (state)\ngoal (4 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B", "let ?ti = \"to_int_poly_i ff_ops\""], ["proof (state)\ngoal (4 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B", "note rel = norm[THEN Mp_rel_i_of_int_poly_i]"], ["proof (state)\nthis:\n  Mp_rel_i (of_int_poly_i ff_ops D) D\n  Mp_rel_i (of_int_poly_i ff_ops H) H\n  Mp_rel_i (of_int_poly_i ff_ops S) S\n  Mp_rel_i (of_int_poly_i ff_ops T) T\n  Mp_rel_i (of_int_poly_i ff_ops U) U\n\ngoal (4 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B", "obtain a b where dupe: \"dupe_monic_i ff_ops (?oi D) (?oi H) (?oi S) (?oi T) (?oi U) = (a,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        dupe_monic_i ff_ops (of_int_poly_i ff_ops D)\n         (of_int_poly_i ff_ops H) (of_int_poly_i ff_ops S)\n         (of_int_poly_i ff_ops T) (of_int_poly_i ff_ops U) =\n        (a, b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  dupe_monic_i ff_ops (of_int_poly_i ff_ops D) (of_int_poly_i ff_ops H)\n   (of_int_poly_i ff_ops S) (of_int_poly_i ff_ops T)\n   (of_int_poly_i ff_ops U) =\n  (a, b)\n\ngoal (4 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B", "from dupe_i[unfolded dupe_monic_i_int_def this Let_def]"], ["proof (chain)\npicking this:\n  (case (a, b) of\n   (D', H') \\<Rightarrow>\n     (to_int_poly_i ff_ops D', to_int_poly_i ff_ops H')) =\n  (A, B)", "have AB: \"A = ?ti a\" \"B = ?ti b\""], ["proof (prove)\nusing this:\n  (case (a, b) of\n   (D', H') \\<Rightarrow>\n     (to_int_poly_i ff_ops D', to_int_poly_i ff_ops H')) =\n  (A, B)\n\ngoal (1 subgoal):\n 1. A = to_int_poly_i ff_ops a &&& B = to_int_poly_i ff_ops b", "by auto"], ["proof (state)\nthis:\n  A = to_int_poly_i ff_ops a\n  B = to_int_poly_i ff_ops b\n\ngoal (4 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B", "from dupe_monic_i[OF dupe 1 mon AB rel] Mp_rel_i_Mp_to_int_poly_i"], ["proof (chain)\npicking this:\n  A * D + B * H =m U\n  B = 0 \\<or> degree B < degree D\n  Mp_rel_i a A\n  Mp_rel_i b B\n  Mp_rel_i ?f ?F \\<Longrightarrow>\n  Mp (to_int_poly_i ff_ops ?f) = to_int_poly_i ff_ops ?f", "show \"A * D + B * H =m U\" \n    \"B = 0 \\<or> degree B < degree D\" \n    \"Mp A = A\" \n    \"Mp B = B\""], ["proof (prove)\nusing this:\n  A * D + B * H =m U\n  B = 0 \\<or> degree B < degree D\n  Mp_rel_i a A\n  Mp_rel_i b B\n  Mp_rel_i ?f ?F \\<Longrightarrow>\n  Mp (to_int_poly_i ff_ops ?f) = to_int_poly_i ff_ops ?f\n\ngoal (1 subgoal):\n 1. (A * D + B * H =m U &&& B = 0 \\<or> degree B < degree D) &&&\n    Mp A = A &&& Mp B = B", "unfolding AB"], ["proof (prove)\nusing this:\n  to_int_poly_i ff_ops a * D + to_int_poly_i ff_ops b * H =m U\n  to_int_poly_i ff_ops b = 0 \\<or>\n  degree (to_int_poly_i ff_ops b) < degree D\n  Mp_rel_i a (to_int_poly_i ff_ops a)\n  Mp_rel_i b (to_int_poly_i ff_ops b)\n  Mp_rel_i ?f ?F \\<Longrightarrow>\n  Mp (to_int_poly_i ff_ops ?f) = to_int_poly_i ff_ops ?f\n\ngoal (1 subgoal):\n 1. (to_int_poly_i ff_ops a * D + to_int_poly_i ff_ops b * H =m U &&&\n     to_int_poly_i ff_ops b = 0 \\<or>\n     degree (to_int_poly_i ff_ops b) < degree D) &&&\n    Mp (to_int_poly_i ff_ops a) = to_int_poly_i ff_ops a &&&\n    Mp (to_int_poly_i ff_ops b) = to_int_poly_i ff_ops b", "by auto"], ["proof (state)\nthis:\n  A * D + B * H =m U\n  B = 0 \\<or> degree B < degree D\n  Mp A = A\n  Mp B = B\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "definition dupe_monic_dynamic \n  :: \"int \\<Rightarrow> int poly \\<Rightarrow> int poly \\<Rightarrow> int poly \\<Rightarrow> int poly \\<Rightarrow> int poly \\<Rightarrow> int poly \\<times> int poly\" where\n  \"dupe_monic_dynamic p = ( \n    if p \\<le> 65535 \n    then dupe_monic_i_int (finite_field_ops32 (uint32_of_int p))\n    else if p \\<le> 4294967295\n    then dupe_monic_i_int (finite_field_ops64 (uint64_of_int p))\n    else dupe_monic_i_int (finite_field_ops_integer (integer_of_int p)))\""], ["", "context poly_mod_2\nbegin"], ["", "lemma dupe_monic_i_int_finite_field_ops_integer: assumes \n      dupe_i: \"dupe_monic_i_int (finite_field_ops_integer (integer_of_int m)) D H S T U = (A,B)\" \n  and 1: \"D*S + H*T =m 1\" \n  and mon: \"monic D\" \n  and norm: \"Mp D = D\" \"Mp H = H\" \"Mp S = S\" \"Mp T = T\" \"Mp U = U\" \nshows \n  \"A * D + B * H =m U\" \n  \"B = 0 \\<or> degree B < degree D\" \n  \"Mp A = A\" \n  \"Mp B = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A * D + B * H =m U &&& B = 0 \\<or> degree B < degree D) &&&\n    Mp A = A &&& Mp B = B", "using m1 mod_ring_gen.dupe_monic_i_int[OF \n        mod_ring_locale.mod_ring_finite_field_ops_integer[unfolded mod_ring_locale_def], \n        internalize_sort \"'a :: nontriv\", OF type_to_set, unfolded remove_duplicate_premise, \n        cancel_type_definition, OF _ assms]"], ["proof (prove)\nusing this:\n  1 < m\n  {0..<m} \\<noteq> {} \\<Longrightarrow> A * D + B * H =m U\n  {0..<m} \\<noteq> {} \\<Longrightarrow> B = 0 \\<or> degree B < degree D\n  {0..<m} \\<noteq> {} \\<Longrightarrow> Mp A = A\n  {0..<m} \\<noteq> {} \\<Longrightarrow> Mp B = B\n\ngoal (1 subgoal):\n 1. (A * D + B * H =m U &&& B = 0 \\<or> degree B < degree D) &&&\n    Mp A = A &&& Mp B = B", "by auto"], ["", "lemma dupe_monic_i_int_finite_field_ops32: assumes \n      m: \"m \\<le> 65535\"\n  and dupe_i: \"dupe_monic_i_int (finite_field_ops32 (uint32_of_int m)) D H S T U = (A,B)\" \n  and 1: \"D*S + H*T =m 1\" \n  and mon: \"monic D\" \n  and norm: \"Mp D = D\" \"Mp H = H\" \"Mp S = S\" \"Mp T = T\" \"Mp U = U\" \nshows \n  \"A * D + B * H =m U\" \n  \"B = 0 \\<or> degree B < degree D\" \n  \"Mp A = A\" \n  \"Mp B = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A * D + B * H =m U &&& B = 0 \\<or> degree B < degree D) &&&\n    Mp A = A &&& Mp B = B", "using m1 mod_ring_gen.dupe_monic_i_int[OF \n        mod_ring_locale.mod_ring_finite_field_ops32[unfolded mod_ring_locale_def], \n        internalize_sort \"'a :: nontriv\", OF type_to_set, unfolded remove_duplicate_premise, \n        cancel_type_definition, OF _ assms]"], ["proof (prove)\nusing this:\n  1 < m\n  {0..<m} \\<noteq> {} \\<Longrightarrow> A * D + B * H =m U\n  {0..<m} \\<noteq> {} \\<Longrightarrow> B = 0 \\<or> degree B < degree D\n  {0..<m} \\<noteq> {} \\<Longrightarrow> Mp A = A\n  {0..<m} \\<noteq> {} \\<Longrightarrow> Mp B = B\n\ngoal (1 subgoal):\n 1. (A * D + B * H =m U &&& B = 0 \\<or> degree B < degree D) &&&\n    Mp A = A &&& Mp B = B", "by auto"], ["", "lemma dupe_monic_i_int_finite_field_ops64: assumes \n      m: \"m \\<le> 4294967295\"\n  and dupe_i: \"dupe_monic_i_int (finite_field_ops64 (uint64_of_int m)) D H S T U = (A,B)\" \n  and 1: \"D*S + H*T =m 1\" \n  and mon: \"monic D\" \n  and norm: \"Mp D = D\" \"Mp H = H\" \"Mp S = S\" \"Mp T = T\" \"Mp U = U\" \nshows \n  \"A * D + B * H =m U\" \n  \"B = 0 \\<or> degree B < degree D\" \n  \"Mp A = A\" \n  \"Mp B = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A * D + B * H =m U &&& B = 0 \\<or> degree B < degree D) &&&\n    Mp A = A &&& Mp B = B", "using m1 mod_ring_gen.dupe_monic_i_int[OF \n        mod_ring_locale.mod_ring_finite_field_ops64[unfolded mod_ring_locale_def], \n        internalize_sort \"'a :: nontriv\", OF type_to_set, unfolded remove_duplicate_premise, \n        cancel_type_definition, OF _ assms]"], ["proof (prove)\nusing this:\n  1 < m\n  {0..<m} \\<noteq> {} \\<Longrightarrow> A * D + B * H =m U\n  {0..<m} \\<noteq> {} \\<Longrightarrow> B = 0 \\<or> degree B < degree D\n  {0..<m} \\<noteq> {} \\<Longrightarrow> Mp A = A\n  {0..<m} \\<noteq> {} \\<Longrightarrow> Mp B = B\n\ngoal (1 subgoal):\n 1. (A * D + B * H =m U &&& B = 0 \\<or> degree B < degree D) &&&\n    Mp A = A &&& Mp B = B", "by auto"], ["", "lemma dupe_monic_dynamic: assumes dupe: \"dupe_monic_dynamic m D H S T U = (A,B)\" \n  and 1: \"D*S + H*T =m 1\" \n  and mon: \"monic D\" \n  and norm: \"Mp D = D\" \"Mp H = H\" \"Mp S = S\" \"Mp T = T\" \"Mp U = U\" \nshows \n  \"A * D + B * H =m U\" \n  \"B = 0 \\<or> degree B < degree D\" \n  \"Mp A = A\" \n  \"Mp B = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A * D + B * H =m U &&& B = 0 \\<or> degree B < degree D) &&&\n    Mp A = A &&& Mp B = B", "using dupe\n    dupe_monic_i_int_finite_field_ops32[OF _ _ 1 mon norm, of A B]\n    dupe_monic_i_int_finite_field_ops64[OF _ _ 1 mon norm, of A B]\n    dupe_monic_i_int_finite_field_ops_integer[OF _ 1 mon norm, of A B]"], ["proof (prove)\nusing this:\n  dupe_monic_dynamic m D H S T U = (A, B)\n  \\<lbrakk>m \\<le> 65535;\n   dupe_monic_i_int (finite_field_ops32 (uint32_of_int m)) D H S T U =\n   (A, B)\\<rbrakk>\n  \\<Longrightarrow> A * D + B * H =m U\n  \\<lbrakk>m \\<le> 65535;\n   dupe_monic_i_int (finite_field_ops32 (uint32_of_int m)) D H S T U =\n   (A, B)\\<rbrakk>\n  \\<Longrightarrow> B = 0 \\<or> degree B < degree D\n  \\<lbrakk>m \\<le> 65535;\n   dupe_monic_i_int (finite_field_ops32 (uint32_of_int m)) D H S T U =\n   (A, B)\\<rbrakk>\n  \\<Longrightarrow> Mp A = A\n  \\<lbrakk>m \\<le> 65535;\n   dupe_monic_i_int (finite_field_ops32 (uint32_of_int m)) D H S T U =\n   (A, B)\\<rbrakk>\n  \\<Longrightarrow> Mp B = B\n  \\<lbrakk>m \\<le> 4294967295;\n   dupe_monic_i_int (finite_field_ops64 (uint64_of_int m)) D H S T U =\n   (A, B)\\<rbrakk>\n  \\<Longrightarrow> A * D + B * H =m U\n  \\<lbrakk>m \\<le> 4294967295;\n   dupe_monic_i_int (finite_field_ops64 (uint64_of_int m)) D H S T U =\n   (A, B)\\<rbrakk>\n  \\<Longrightarrow> B = 0 \\<or> degree B < degree D\n  \\<lbrakk>m \\<le> 4294967295;\n   dupe_monic_i_int (finite_field_ops64 (uint64_of_int m)) D H S T U =\n   (A, B)\\<rbrakk>\n  \\<Longrightarrow> Mp A = A\n  \\<lbrakk>m \\<le> 4294967295;\n   dupe_monic_i_int (finite_field_ops64 (uint64_of_int m)) D H S T U =\n   (A, B)\\<rbrakk>\n  \\<Longrightarrow> Mp B = B\n  dupe_monic_i_int (finite_field_ops_integer (integer_of_int m)) D H S T U =\n  (A, B) \\<Longrightarrow>\n  A * D + B * H =m U\n  dupe_monic_i_int (finite_field_ops_integer (integer_of_int m)) D H S T U =\n  (A, B) \\<Longrightarrow>\n  B = 0 \\<or> degree B < degree D\n  dupe_monic_i_int (finite_field_ops_integer (integer_of_int m)) D H S T U =\n  (A, B) \\<Longrightarrow>\n  Mp A = A\n  dupe_monic_i_int (finite_field_ops_integer (integer_of_int m)) D H S T U =\n  (A, B) \\<Longrightarrow>\n  Mp B = B\n\ngoal (1 subgoal):\n 1. (A * D + B * H =m U &&& B = 0 \\<or> degree B < degree D) &&&\n    Mp A = A &&& Mp B = B", "unfolding dupe_monic_dynamic_def"], ["proof (prove)\nusing this:\n  (if m \\<le> 65535\n   then dupe_monic_i_int (finite_field_ops32 (uint32_of_int m))\n   else if m \\<le> 4294967295\n        then dupe_monic_i_int (finite_field_ops64 (uint64_of_int m))\n        else dupe_monic_i_int (finite_field_ops_integer (integer_of_int m)))\n   D H S T U =\n  (A, B)\n  \\<lbrakk>m \\<le> 65535;\n   dupe_monic_i_int (finite_field_ops32 (uint32_of_int m)) D H S T U =\n   (A, B)\\<rbrakk>\n  \\<Longrightarrow> A * D + B * H =m U\n  \\<lbrakk>m \\<le> 65535;\n   dupe_monic_i_int (finite_field_ops32 (uint32_of_int m)) D H S T U =\n   (A, B)\\<rbrakk>\n  \\<Longrightarrow> B = 0 \\<or> degree B < degree D\n  \\<lbrakk>m \\<le> 65535;\n   dupe_monic_i_int (finite_field_ops32 (uint32_of_int m)) D H S T U =\n   (A, B)\\<rbrakk>\n  \\<Longrightarrow> Mp A = A\n  \\<lbrakk>m \\<le> 65535;\n   dupe_monic_i_int (finite_field_ops32 (uint32_of_int m)) D H S T U =\n   (A, B)\\<rbrakk>\n  \\<Longrightarrow> Mp B = B\n  \\<lbrakk>m \\<le> 4294967295;\n   dupe_monic_i_int (finite_field_ops64 (uint64_of_int m)) D H S T U =\n   (A, B)\\<rbrakk>\n  \\<Longrightarrow> A * D + B * H =m U\n  \\<lbrakk>m \\<le> 4294967295;\n   dupe_monic_i_int (finite_field_ops64 (uint64_of_int m)) D H S T U =\n   (A, B)\\<rbrakk>\n  \\<Longrightarrow> B = 0 \\<or> degree B < degree D\n  \\<lbrakk>m \\<le> 4294967295;\n   dupe_monic_i_int (finite_field_ops64 (uint64_of_int m)) D H S T U =\n   (A, B)\\<rbrakk>\n  \\<Longrightarrow> Mp A = A\n  \\<lbrakk>m \\<le> 4294967295;\n   dupe_monic_i_int (finite_field_ops64 (uint64_of_int m)) D H S T U =\n   (A, B)\\<rbrakk>\n  \\<Longrightarrow> Mp B = B\n  dupe_monic_i_int (finite_field_ops_integer (integer_of_int m)) D H S T U =\n  (A, B) \\<Longrightarrow>\n  A * D + B * H =m U\n  dupe_monic_i_int (finite_field_ops_integer (integer_of_int m)) D H S T U =\n  (A, B) \\<Longrightarrow>\n  B = 0 \\<or> degree B < degree D\n  dupe_monic_i_int (finite_field_ops_integer (integer_of_int m)) D H S T U =\n  (A, B) \\<Longrightarrow>\n  Mp A = A\n  dupe_monic_i_int (finite_field_ops_integer (integer_of_int m)) D H S T U =\n  (A, B) \\<Longrightarrow>\n  Mp B = B\n\ngoal (1 subgoal):\n 1. (A * D + B * H =m U &&& B = 0 \\<or> degree B < degree D) &&&\n    Mp A = A &&& Mp B = B", "by (auto split: if_splits)"], ["", "end"], ["", "context poly_mod\nbegin"], ["", "definition dupe_monic_int :: \"int poly \\<Rightarrow> int poly \\<Rightarrow> int poly \\<Rightarrow> int poly \\<Rightarrow> int poly \\<Rightarrow> \n  int poly * int poly\" where\n  \"dupe_monic_int D H S T U = (case pdivmod_monic (Mp (T * U)) D of (q,r) \\<Rightarrow>\n     (Mp (S * U + H * q), Mp r))\""], ["", "end"], ["", "declare poly_mod.dupe_monic_int_def[code]"], ["", "text \\<open>Old direct proof on int poly. \n  It does not permit to change implementation.\n  This proof is still present, since we did not export the uniqueness part\n  from the type-based uniqueness result @{thm dupe_monic_unique} via the various relations.\\<close>"], ["", "lemma (in poly_mod_2) dupe_monic_int: assumes 1: \"D*S + H*T =m 1\" \n  and mon: \"monic D\" \n  and dupe: \"dupe_monic_int D H S T U = (A,B)\" \n  shows \"A * D + B * H =m U\" \"B = 0 \\<or> degree B < degree D\" \"Mp A = A\" \"Mp B = B\" \n    \"coprime_m D H \\<Longrightarrow> A' * D + B' * H =m U \\<Longrightarrow> B' = 0 \\<or> degree B' < degree D \\<Longrightarrow> Mp D = D \n    \\<Longrightarrow> Mp A' = A' \\<Longrightarrow> Mp B' = B' \\<Longrightarrow> prime m\n    \\<Longrightarrow> A' = A \\<and> B' = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A * D + B * H =m U &&& B = 0 \\<or> degree B < degree D) &&&\n    Mp A = A &&&\n    Mp B = B &&&\n    (\\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n      B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n      prime m\\<rbrakk>\n     \\<Longrightarrow> A' = A \\<and> B' = B)", "proof -"], ["proof (state)\ngoal (5 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B\n 5. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "obtain Q R where div: \"pdivmod_monic (Mp (T * U)) D = (Q,R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q R.\n        pdivmod_monic (Mp (T * U)) D = (Q, R) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  pdivmod_monic (Mp (T * U)) D = (Q, R)\n\ngoal (5 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B\n 5. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "from dupe[unfolded dupe_monic_int_def div split]"], ["proof (chain)\npicking this:\n  (Mp (S * U + H * Q), Mp R) = (A, B)", "have A: \"A = Mp (S * U + H * Q)\" and B: \"B = Mp R\""], ["proof (prove)\nusing this:\n  (Mp (S * U + H * Q), Mp R) = (A, B)\n\ngoal (1 subgoal):\n 1. A = Mp (S * U + H * Q) &&& B = Mp R", "by auto"], ["proof (state)\nthis:\n  A = Mp (S * U + H * Q)\n  B = Mp R\n\ngoal (5 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B\n 5. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "from pdivmod_monic[OF mon div]"], ["proof (chain)\npicking this:\n  Mp (T * U) = D * Q + R\n  R = 0 \\<or> degree R < degree D", "have TU: \"Mp (T * U) = D * Q + R\" and \n    deg: \"R = 0 \\<or> degree R < degree D\""], ["proof (prove)\nusing this:\n  Mp (T * U) = D * Q + R\n  R = 0 \\<or> degree R < degree D\n\ngoal (1 subgoal):\n 1. Mp (T * U) = D * Q + R &&& R = 0 \\<or> degree R < degree D", "by auto"], ["proof (state)\nthis:\n  Mp (T * U) = D * Q + R\n  R = 0 \\<or> degree R < degree D\n\ngoal (5 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B\n 5. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "hence \"Mp R = Mp (Mp (T * U) - D * Q)\""], ["proof (prove)\nusing this:\n  Mp (T * U) = D * Q + R\n  R = 0 \\<or> degree R < degree D\n\ngoal (1 subgoal):\n 1. R =m Mp (T * U) - D * Q", "by simp"], ["proof (state)\nthis:\n  R =m Mp (T * U) - D * Q\n\ngoal (5 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B\n 5. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "also"], ["proof (state)\nthis:\n  R =m Mp (T * U) - D * Q\n\ngoal (5 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B\n 5. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "have \"\\<dots> = Mp (T * U - Mp (Mp (Mp D * Q)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (T * U) - D * Q =m T * U - Mp (Mp (Mp D * Q))", "unfolding Mp_Mp"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (T * U) - D * Q =m T * U - Mp (Mp D * Q)", "unfolding minus_Mp"], ["proof (prove)\ngoal (1 subgoal):\n 1. T * U - D * Q =m T * U - Mp D * Q", "using minus_Mp mult_Mp"], ["proof (prove)\nusing this:\n  Mp ?f - ?g =m ?f - ?g\n  ?f - Mp ?g =m ?f - ?g\n  Mp ?f * ?g =m ?f * ?g\n  ?f * Mp ?g =m ?f * ?g\n\ngoal (1 subgoal):\n 1. T * U - D * Q =m T * U - Mp D * Q", "by metis"], ["proof (state)\nthis:\n  Mp (T * U) - D * Q =m T * U - Mp (Mp (Mp D * Q))\n\ngoal (5 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B\n 5. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "also"], ["proof (state)\nthis:\n  Mp (T * U) - D * Q =m T * U - Mp (Mp (Mp D * Q))\n\ngoal (5 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B\n 5. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "have \"\\<dots> = Mp (T * U - D * Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T * U - Mp (Mp (Mp D * Q)) =m T * U - D * Q", "by simp"], ["proof (state)\nthis:\n  T * U - Mp (Mp (Mp D * Q)) =m T * U - D * Q\n\ngoal (5 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B\n 5. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "finally"], ["proof (chain)\npicking this:\n  R =m T * U - D * Q", "have r: \"Mp R = Mp (T * U - D * Q)\""], ["proof (prove)\nusing this:\n  R =m T * U - D * Q\n\ngoal (1 subgoal):\n 1. R =m T * U - D * Q", "by simp"], ["proof (state)\nthis:\n  R =m T * U - D * Q\n\ngoal (5 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B\n 5. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "have \"Mp (A * D + B * H) = Mp (Mp (A * D) + Mp (B * H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * D + B * H =m Mp (A * D) + Mp (B * H)", "by simp"], ["proof (state)\nthis:\n  A * D + B * H =m Mp (A * D) + Mp (B * H)\n\ngoal (5 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B\n 5. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "also"], ["proof (state)\nthis:\n  A * D + B * H =m Mp (A * D) + Mp (B * H)\n\ngoal (5 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B\n 5. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "have \"Mp (A * D) = Mp ((S * U + H * Q) * D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * D =m (S * U + H * Q) * D", "unfolding A"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (S * U + H * Q) * D =m (S * U + H * Q) * D", "by simp"], ["proof (state)\nthis:\n  A * D =m (S * U + H * Q) * D\n\ngoal (5 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B\n 5. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "also"], ["proof (state)\nthis:\n  A * D =m (S * U + H * Q) * D\n\ngoal (5 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B\n 5. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "have \"Mp (B * H) = Mp (Mp R * Mp H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B * H =m Mp R * Mp H", "unfolding B"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp R * H =m Mp R * Mp H", "by simp"], ["proof (state)\nthis:\n  B * H =m Mp R * Mp H\n\ngoal (5 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B\n 5. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "also"], ["proof (state)\nthis:\n  B * H =m Mp R * Mp H\n\ngoal (5 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B\n 5. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "have \"\\<dots> = Mp ((T * U - D * Q) * H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp R * Mp H =m (T * U - D * Q) * H", "unfolding r"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (T * U - D * Q) * Mp H =m (T * U - D * Q) * H", "by simp"], ["proof (state)\nthis:\n  Mp R * Mp H =m (T * U - D * Q) * H\n\ngoal (5 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B\n 5. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "also"], ["proof (state)\nthis:\n  Mp R * Mp H =m (T * U - D * Q) * H\n\ngoal (5 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B\n 5. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "have \"Mp (Mp ((S * U + H * Q) * D) + Mp ((T * U - D * Q) * H)) = \n    Mp ((S * U + H * Q) * D + (T * U - D * Q) * H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp ((S * U + H * Q) * D) + Mp ((T * U - D * Q) * H) =m\n    (S * U + H * Q) * D + (T * U - D * Q) * H", "by simp"], ["proof (state)\nthis:\n  Mp ((S * U + H * Q) * D) + Mp ((T * U - D * Q) * H) =m\n  (S * U + H * Q) * D + (T * U - D * Q) * H\n\ngoal (5 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B\n 5. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "also"], ["proof (state)\nthis:\n  Mp ((S * U + H * Q) * D) + Mp ((T * U - D * Q) * H) =m\n  (S * U + H * Q) * D + (T * U - D * Q) * H\n\ngoal (5 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B\n 5. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "have \"(S * U + H * Q) * D + (T * U - D * Q) * H = (D * S + H * T) * U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S * U + H * Q) * D + (T * U - D * Q) * H = (D * S + H * T) * U", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (S * U + H * Q) * D + (T * U - D * Q) * H = (D * S + H * T) * U\n\ngoal (5 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B\n 5. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "also"], ["proof (state)\nthis:\n  (S * U + H * Q) * D + (T * U - D * Q) * H = (D * S + H * T) * U\n\ngoal (5 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B\n 5. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "have \"Mp \\<dots> = Mp (Mp (D * S + H * T) * U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (D * S + H * T) * U =m Mp (D * S + H * T) * U", "by simp"], ["proof (state)\nthis:\n  (D * S + H * T) * U =m Mp (D * S + H * T) * U\n\ngoal (5 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B\n 5. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "also"], ["proof (state)\nthis:\n  (D * S + H * T) * U =m Mp (D * S + H * T) * U\n\ngoal (5 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B\n 5. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "have \"Mp (D * S + H * T) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (D * S + H * T) = 1", "using 1"], ["proof (prove)\nusing this:\n  D * S + H * T =m 1\n\ngoal (1 subgoal):\n 1. Mp (D * S + H * T) = 1", "by simp"], ["proof (state)\nthis:\n  Mp (D * S + H * T) = 1\n\ngoal (5 subgoals):\n 1. A * D + B * H =m U\n 2. B = 0 \\<or> degree B < degree D\n 3. Mp A = A\n 4. Mp B = B\n 5. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "finally"], ["proof (chain)\npicking this:\n  A * D + B * H =m 1 * U", "show eq: \"A * D + B * H =m U\""], ["proof (prove)\nusing this:\n  A * D + B * H =m 1 * U\n\ngoal (1 subgoal):\n 1. A * D + B * H =m U", "by simp"], ["proof (state)\nthis:\n  A * D + B * H =m U\n\ngoal (4 subgoals):\n 1. B = 0 \\<or> degree B < degree D\n 2. Mp A = A\n 3. Mp B = B\n 4. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "have id: \"degree_m (Mp R) = degree_m R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m (Mp R) = degree_m R", "by simp"], ["proof (state)\nthis:\n  degree_m (Mp R) = degree_m R\n\ngoal (4 subgoals):\n 1. B = 0 \\<or> degree B < degree D\n 2. Mp A = A\n 3. Mp B = B\n 4. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "have id': \"degree D = degree_m D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree D = degree_m D", "using mon"], ["proof (prove)\nusing this:\n  monic D\n\ngoal (1 subgoal):\n 1. degree D = degree_m D", "by simp"], ["proof (state)\nthis:\n  degree D = degree_m D\n\ngoal (4 subgoals):\n 1. B = 0 \\<or> degree B < degree D\n 2. Mp A = A\n 3. Mp B = B\n 4. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "show degB: \"B = 0 \\<or> degree B < degree D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = 0 \\<or> degree B < degree D", "using deg"], ["proof (prove)\nusing this:\n  R = 0 \\<or> degree R < degree D\n\ngoal (1 subgoal):\n 1. B = 0 \\<or> degree B < degree D", "unfolding B id id'"], ["proof (prove)\nusing this:\n  R = 0 \\<or> degree R < degree_m D\n\ngoal (1 subgoal):\n 1. Mp R = 0 \\<or> degree_m R < degree_m D", "using degree_m_le[of R]"], ["proof (prove)\nusing this:\n  R = 0 \\<or> degree R < degree_m D\n  degree_m R \\<le> degree R\n\ngoal (1 subgoal):\n 1. Mp R = 0 \\<or> degree_m R < degree_m D", "by (cases \"R = 0\", auto)"], ["proof (state)\nthis:\n  B = 0 \\<or> degree B < degree D\n\ngoal (3 subgoals):\n 1. Mp A = A\n 2. Mp B = B\n 3. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "show Mp: \"Mp A = A\" \"Mp B = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp A = A &&& Mp B = B", "unfolding A B"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (S * U + H * Q) =m S * U + H * Q &&& Mp R =m R", "by auto"], ["proof (state)\nthis:\n  Mp A = A\n  Mp B = B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "assume another: \"A' * D + B' * H =m U\" and degB': \"B' = 0 \\<or> degree B' < degree D\" \n    and norm: \"Mp A' = A'\" \"Mp B' = B'\" and cop: \"coprime_m D H\" and D: \"Mp D = D\" \n    and prime: \"prime m\""], ["proof (state)\nthis:\n  A' * D + B' * H =m U\n  B' = 0 \\<or> degree B' < degree D\n  Mp A' = A'\n  Mp B' = B'\n  coprime_m D H\n  Mp D = D\n  prime m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "from degB Mp D"], ["proof (chain)\npicking this:\n  B = 0 \\<or> degree B < degree D\n  Mp A = A\n  Mp B = B\n  Mp D = D", "have degB: \"B =m 0 \\<or> degree_m B < degree_m D\""], ["proof (prove)\nusing this:\n  B = 0 \\<or> degree B < degree D\n  Mp A = A\n  Mp B = B\n  Mp D = D\n\ngoal (1 subgoal):\n 1. B =m 0 \\<or> degree_m B < degree_m D", "by auto"], ["proof (state)\nthis:\n  B =m 0 \\<or> degree_m B < degree_m D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "from degB' Mp D norm"], ["proof (chain)\npicking this:\n  B' = 0 \\<or> degree B' < degree D\n  Mp A = A\n  Mp B = B\n  Mp D = D\n  Mp A' = A'\n  Mp B' = B'", "have degB': \"B' =m 0 \\<or> degree_m B' < degree_m D\""], ["proof (prove)\nusing this:\n  B' = 0 \\<or> degree B' < degree D\n  Mp A = A\n  Mp B = B\n  Mp D = D\n  Mp A' = A'\n  Mp B' = B'\n\ngoal (1 subgoal):\n 1. B' =m 0 \\<or> degree_m B' < degree_m D", "by auto"], ["proof (state)\nthis:\n  B' =m 0 \\<or> degree_m B' < degree_m D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "from mon D"], ["proof (chain)\npicking this:\n  monic D\n  Mp D = D", "have D0: \"\\<not> (D =m 0)\""], ["proof (prove)\nusing this:\n  monic D\n  Mp D = D\n\ngoal (1 subgoal):\n 1. Mp D \\<noteq> Mp 0", "by auto"], ["proof (state)\nthis:\n  Mp D \\<noteq> Mp 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "from prime"], ["proof (chain)\npicking this:\n  prime m", "interpret poly_mod_prime m"], ["proof (prove)\nusing this:\n  prime m\n\ngoal (1 subgoal):\n 1. poly_mod_prime m", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "from another eq"], ["proof (chain)\npicking this:\n  A' * D + B' * H =m U\n  A * D + B * H =m U", "have \"A' * D + B' * H =m A * D + B * H\""], ["proof (prove)\nusing this:\n  A' * D + B' * H =m U\n  A * D + B * H =m U\n\ngoal (1 subgoal):\n 1. A' * D + B' * H =m A * D + B * H", "by simp"], ["proof (state)\nthis:\n  A' * D + B' * H =m A * D + B * H\n\ngoal (1 subgoal):\n 1. \\<lbrakk>coprime_m D H; A' * D + B' * H =m U;\n     B' = 0 \\<or> degree B' < degree D; Mp D = D; Mp A' = A'; Mp B' = B';\n     prime m\\<rbrakk>\n    \\<Longrightarrow> A' = A \\<and> B' = B", "from uniqueness_poly_equality[OF cop degB' degB D0 this]"], ["proof (chain)\npicking this:\n  A' =m A\n  B' =m B", "show \"A' = A \\<and> B' = B\""], ["proof (prove)\nusing this:\n  A' =m A\n  B' =m B\n\ngoal (1 subgoal):\n 1. A' = A \\<and> B' = B", "unfolding norm Mp"], ["proof (prove)\nusing this:\n  A' = A\n  B' = B\n\ngoal (1 subgoal):\n 1. A' = A \\<and> B' = B", "by auto"], ["proof (state)\nthis:\n  A' = A \\<and> B' = B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coprime_bezout_coefficients:\n  assumes cop: \"coprime f g\"\n    and ext: \"bezout_coefficients f g = (a, b)\" \n  shows \"a * f + b * g = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * f + b * g = (1::'a)", "using assms bezout_coefficients [of f g a b]"], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime f g\n  bezout_coefficients f g = (a, b)\n  bezout_coefficients f g = (a, b) \\<Longrightarrow> a * f + b * g = gcd f g\n\ngoal (1 subgoal):\n 1. a * f + b * g = (1::'a)", "by simp"], ["", "lemma (in poly_mod_prime_type) bezout_coefficients_mod_int: assumes f: \"(F :: 'a mod_ring poly) = of_int_poly f\"\n  and g: \"(G :: 'a mod_ring poly) = of_int_poly g\" \n  and cop: \"coprime_m f g\" \n  and fact: \"bezout_coefficients F G = (A,B)\" \n  and a: \"a = to_int_poly A\"\n  and b: \"b = to_int_poly B\"\n  shows \"f * a + g * b =m 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f * a + g * b =m 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f * a + g * b =m 1", "have f[transfer_rule]: \"MP_Rel f F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel f F", "unfolding f MP_Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp f = to_int_poly (of_int_poly f)", "by (simp add: Mp_f_representative)"], ["proof (state)\nthis:\n  MP_Rel f F\n\ngoal (1 subgoal):\n 1. f * a + g * b =m 1", "have g[transfer_rule]: \"MP_Rel g G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel g G", "unfolding g MP_Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp g = to_int_poly (of_int_poly g)", "by (simp add: Mp_f_representative)"], ["proof (state)\nthis:\n  MP_Rel g G\n\ngoal (1 subgoal):\n 1. f * a + g * b =m 1", "have [transfer_rule]: \"MP_Rel a A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel a A", "unfolding a MP_Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (to_int_poly A) = to_int_poly A", "by (rule Mp_to_int_poly)"], ["proof (state)\nthis:\n  MP_Rel a A\n\ngoal (1 subgoal):\n 1. f * a + g * b =m 1", "have [transfer_rule]: \"MP_Rel b B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel b B", "unfolding b MP_Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (to_int_poly B) = to_int_poly B", "by (rule Mp_to_int_poly)"], ["proof (state)\nthis:\n  MP_Rel b B\n\ngoal (1 subgoal):\n 1. f * a + g * b =m 1", "from cop"], ["proof (chain)\npicking this:\n  coprime_m f g", "have \"coprime F G\""], ["proof (prove)\nusing this:\n  coprime_m f g\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime F G", "using coprime_MP_Rel[unfolded rel_fun_def] f g"], ["proof (prove)\nusing this:\n  coprime_m f g\n  \\<forall>x y.\n     MP_Rel x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         MP_Rel xa ya \\<longrightarrow>\n         coprime_m x xa = comm_monoid_mult_class.coprime y ya)\n  MP_Rel f F\n  MP_Rel g G\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime F G", "by auto"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime F G\n\ngoal (1 subgoal):\n 1. f * a + g * b =m 1", "from coprime_bezout_coefficients [OF this fact]"], ["proof (chain)\npicking this:\n  A * F + B * G = 1", "have \"A * F + B * G = 1\""], ["proof (prove)\nusing this:\n  A * F + B * G = 1\n\ngoal (1 subgoal):\n 1. A * F + B * G = 1", "."], ["proof (state)\nthis:\n  A * F + B * G = 1\n\ngoal (1 subgoal):\n 1. f * a + g * b =m 1", "from this [untransferred]"], ["proof (chain)\npicking this:\n  a * f + b * g =m 1", "show ?thesis"], ["proof (prove)\nusing this:\n  a * f + b * g =m 1\n\ngoal (1 subgoal):\n 1. f * a + g * b =m 1", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  f * a + g * b =m 1\n\ngoal:\nNo subgoals!", "qed"], ["", "definition bezout_coefficients_i :: \"'i arith_ops_record \\<Rightarrow> 'i list \\<Rightarrow> 'i list \\<Rightarrow> 'i list \\<times> 'i list\" where\n  \"bezout_coefficients_i ff_ops f g = fst (euclid_ext_poly_i ff_ops f g)\""], ["", "definition euclid_ext_poly_mod_main :: \"int \\<Rightarrow> 'a arith_ops_record \\<Rightarrow> int poly \\<Rightarrow> int poly \\<Rightarrow> int poly \\<times> int poly\" where\n  \"euclid_ext_poly_mod_main p ff_ops f g = (case bezout_coefficients_i ff_ops (of_int_poly_i ff_ops f) (of_int_poly_i ff_ops g) of \n      (a,b) \\<Rightarrow> (to_int_poly_i ff_ops a, to_int_poly_i ff_ops b))\""], ["", "definition euclid_ext_poly_dynamic :: \"int \\<Rightarrow> int poly \\<Rightarrow> int poly \\<Rightarrow> int poly \\<times> int poly\" where\n  \"euclid_ext_poly_dynamic p = ( \n    if p \\<le> 65535 \n    then euclid_ext_poly_mod_main p (finite_field_ops32 (uint32_of_int p))\n    else if p \\<le> 4294967295\n    then euclid_ext_poly_mod_main p (finite_field_ops64 (uint64_of_int p))\n    else euclid_ext_poly_mod_main p (finite_field_ops_integer (integer_of_int p)))\""], ["", "context prime_field_gen\nbegin"], ["", "lemma bezout_coefficients_i[transfer_rule]: \n  \"(poly_rel ===> poly_rel ===> rel_prod poly_rel poly_rel)\n     (bezout_coefficients_i ff_ops) bezout_coefficients\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> poly_rel ===> rel_prod poly_rel poly_rel)\n     (bezout_coefficients_i ff_ops) bezout_coefficients", "unfolding bezout_coefficients_i_def bezout_coefficients_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> poly_rel ===> rel_prod poly_rel poly_rel)\n     (\\<lambda>f g. fst (euclid_ext_poly_i ff_ops f g))\n     (\\<lambda>a b. fst (euclid_ext_aux 1 0 0 1 a b))", "by transfer_prover"], ["", "lemma bezout_coefficients_i_sound: assumes f: \"f' = of_int_poly_i ff_ops f\" \"Mp f = f\"\n  and g: \"g' = of_int_poly_i ff_ops g\" \"Mp g = g\"  \n  and cop: \"coprime_m f g\" \n  and res: \"bezout_coefficients_i ff_ops f' g' = (a',b')\" \n  and a: \"a = to_int_poly_i ff_ops a'\"\n  and b: \"b = to_int_poly_i ff_ops b'\"\nshows \"f * a + g * b =m 1\"\n  \"Mp a = a\" \"Mp b = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f * a + g * b =m 1 &&& Mp a = a &&& Mp b = b", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. f * a + g * b =m 1\n 2. Mp a = a\n 3. Mp b = b", "from f"], ["proof (chain)\npicking this:\n  f' = of_int_poly_i ff_ops f\n  Mp f = f", "have f': \"f' = of_int_poly_i ff_ops (Mp f)\""], ["proof (prove)\nusing this:\n  f' = of_int_poly_i ff_ops f\n  Mp f = f\n\ngoal (1 subgoal):\n 1. f' = of_int_poly_i ff_ops (Mp f)", "by simp"], ["proof (state)\nthis:\n  f' = of_int_poly_i ff_ops (Mp f)\n\ngoal (3 subgoals):\n 1. f * a + g * b =m 1\n 2. Mp a = a\n 3. Mp b = b", "define f'' where \"f'' \\<equiv> of_int_poly (Mp f) :: 'a mod_ring poly\""], ["proof (state)\nthis:\n  f'' \\<equiv> of_int_poly (Mp f)\n\ngoal (3 subgoals):\n 1. f * a + g * b =m 1\n 2. Mp a = a\n 3. Mp b = b", "have f'': \"f'' = of_int_poly f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f'' = of_int_poly f", "unfolding f''_def f"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly f = of_int_poly f", "by simp"], ["proof (state)\nthis:\n  f'' = of_int_poly f\n\ngoal (3 subgoals):\n 1. f * a + g * b =m 1\n 2. Mp a = a\n 3. Mp b = b", "have rel_f[transfer_rule]: \"poly_rel f' f''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel f' f''", "by (rule poly_rel_of_int_poly[OF f'], simp add: f'' f)"], ["proof (state)\nthis:\n  poly_rel f' f''\n\ngoal (3 subgoals):\n 1. f * a + g * b =m 1\n 2. Mp a = a\n 3. Mp b = b", "from g"], ["proof (chain)\npicking this:\n  g' = of_int_poly_i ff_ops g\n  Mp g = g", "have g': \"g' = of_int_poly_i ff_ops (Mp g)\""], ["proof (prove)\nusing this:\n  g' = of_int_poly_i ff_ops g\n  Mp g = g\n\ngoal (1 subgoal):\n 1. g' = of_int_poly_i ff_ops (Mp g)", "by simp"], ["proof (state)\nthis:\n  g' = of_int_poly_i ff_ops (Mp g)\n\ngoal (3 subgoals):\n 1. f * a + g * b =m 1\n 2. Mp a = a\n 3. Mp b = b", "define g'' where \"g'' \\<equiv> of_int_poly (Mp g) :: 'a mod_ring poly\""], ["proof (state)\nthis:\n  g'' \\<equiv> of_int_poly (Mp g)\n\ngoal (3 subgoals):\n 1. f * a + g * b =m 1\n 2. Mp a = a\n 3. Mp b = b", "have g'': \"g'' = of_int_poly g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g'' = of_int_poly g", "unfolding g''_def g"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly g = of_int_poly g", "by simp"], ["proof (state)\nthis:\n  g'' = of_int_poly g\n\ngoal (3 subgoals):\n 1. f * a + g * b =m 1\n 2. Mp a = a\n 3. Mp b = b", "have rel_g[transfer_rule]: \"poly_rel g' g''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel g' g''", "by (rule poly_rel_of_int_poly[OF g'], simp add: g'' g)"], ["proof (state)\nthis:\n  poly_rel g' g''\n\ngoal (3 subgoals):\n 1. f * a + g * b =m 1\n 2. Mp a = a\n 3. Mp b = b", "obtain a'' b'' where eucl: \"bezout_coefficients f'' g'' = (a'',b'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a'' b''.\n        bezout_coefficients f'' g'' = (a'', b'') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  bezout_coefficients f'' g'' = (a'', b'')\n\ngoal (3 subgoals):\n 1. f * a + g * b =m 1\n 2. Mp a = a\n 3. Mp b = b", "from bezout_coefficients_i[unfolded rel_fun_def rel_prod_conv, rule_format, OF rel_f rel_g,\n    unfolded res split eucl]"], ["proof (chain)\npicking this:\n  poly_rel a' a'' \\<and> poly_rel b' b''", "have rel[transfer_rule]: \"poly_rel a' a''\" \"poly_rel b' b''\""], ["proof (prove)\nusing this:\n  poly_rel a' a'' \\<and> poly_rel b' b''\n\ngoal (1 subgoal):\n 1. poly_rel a' a'' &&& poly_rel b' b''", "by auto"], ["proof (state)\nthis:\n  poly_rel a' a''\n  poly_rel b' b''\n\ngoal (3 subgoals):\n 1. f * a + g * b =m 1\n 2. Mp a = a\n 3. Mp b = b", "with to_int_poly_i"], ["proof (chain)\npicking this:\n  poly_rel ?f ?g \\<Longrightarrow> to_int_poly_i ff_ops ?f = to_int_poly ?g\n  poly_rel a' a''\n  poly_rel b' b''", "have a: \"a = to_int_poly a''\" \n    and b: \"b = to_int_poly b''\""], ["proof (prove)\nusing this:\n  poly_rel ?f ?g \\<Longrightarrow> to_int_poly_i ff_ops ?f = to_int_poly ?g\n  poly_rel a' a''\n  poly_rel b' b''\n\ngoal (1 subgoal):\n 1. a = to_int_poly a'' &&& b = to_int_poly b''", "unfolding a b"], ["proof (prove)\nusing this:\n  poly_rel ?f ?g \\<Longrightarrow> to_int_poly_i ff_ops ?f = to_int_poly ?g\n  poly_rel a' a''\n  poly_rel b' b''\n\ngoal (1 subgoal):\n 1. to_int_poly_i ff_ops a' = to_int_poly a'' &&&\n    to_int_poly_i ff_ops b' = to_int_poly b''", "by auto"], ["proof (state)\nthis:\n  a = to_int_poly a''\n  b = to_int_poly b''\n\ngoal (3 subgoals):\n 1. f * a + g * b =m 1\n 2. Mp a = a\n 3. Mp b = b", "from bezout_coefficients_mod_int [OF f'' g'' cop eucl a b]"], ["proof (chain)\npicking this:\n  f * a + g * b =m 1", "show \"f * a + g * b =m 1\""], ["proof (prove)\nusing this:\n  f * a + g * b =m 1\n\ngoal (1 subgoal):\n 1. f * a + g * b =m 1", "."], ["proof (state)\nthis:\n  f * a + g * b =m 1\n\ngoal (2 subgoals):\n 1. Mp a = a\n 2. Mp b = b", "show \"Mp a = a\" \"Mp b = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp a = a &&& Mp b = b", "unfolding a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (to_int_poly a'') = to_int_poly a'' &&&\n    Mp (to_int_poly b'') = to_int_poly b''", "by (auto simp: Mp_to_int_poly)"], ["proof (state)\nthis:\n  Mp a = a\n  Mp b = b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma euclid_ext_poly_mod_main: assumes cop: \"coprime_m f g\" \n  and f: \"Mp f = f\" and g: \"Mp g = g\" \n  and res: \"euclid_ext_poly_mod_main m ff_ops f g = (a,b)\" \nshows \"f * a + g * b =m 1\" \n  \"Mp a = a\" \"Mp b = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f * a + g * b =m 1 &&& Mp a = a &&& Mp b = b", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. f * a + g * b =m 1\n 2. Mp a = a\n 3. Mp b = b", "obtain a' b' where res': \"bezout_coefficients_i ff_ops (of_int_poly_i ff_ops f) \n    (of_int_poly_i ff_ops g) = (a', b')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a' b'.\n        bezout_coefficients_i ff_ops (of_int_poly_i ff_ops f)\n         (of_int_poly_i ff_ops g) =\n        (a', b') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  bezout_coefficients_i ff_ops (of_int_poly_i ff_ops f)\n   (of_int_poly_i ff_ops g) =\n  (a', b')\n\ngoal (3 subgoals):\n 1. f * a + g * b =m 1\n 2. Mp a = a\n 3. Mp b = b", "show \"f * a + g * b =m 1\" \n  \"Mp a = a\" \"Mp b = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f * a + g * b =m 1 &&& Mp a = a &&& Mp b = b", "by (insert bezout_coefficients_i_sound[OF refl f refl g cop res']\n    res [unfolded euclid_ext_poly_mod_main_def res'], auto)"], ["proof (state)\nthis:\n  f * a + g * b =m 1\n  Mp a = a\n  Mp b = b\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context poly_mod_prime begin"], ["", "lemmas euclid_ext_poly_mod_integer = prime_field_gen.euclid_ext_poly_mod_main\n  [OF prime_field.prime_field_finite_field_ops_integer,\n  unfolded prime_field_def mod_ring_locale_def poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]"], ["", "lemmas euclid_ext_poly_mod_uint32 = prime_field_gen.euclid_ext_poly_mod_main\n  [OF prime_field.prime_field_finite_field_ops32,\n  unfolded prime_field_def mod_ring_locale_def poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]"], ["", "lemmas euclid_ext_poly_mod_uint64 = prime_field_gen.euclid_ext_poly_mod_main[OF prime_field.prime_field_finite_field_ops64,\n  unfolded prime_field_def mod_ring_locale_def poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise, cancel_type_definition, OF non_empty]"], ["", "lemma euclid_ext_poly_dynamic:\n  assumes cop: \"coprime_m f g\" and f: \"Mp f = f\" and g: \"Mp g = g\"\n    and res: \"euclid_ext_poly_dynamic p f g = (a,b)\" \n  shows \"f * a + g * b =m 1\" \n    \"Mp a = a\" \"Mp b = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f * a + g * b =m 1 &&& Mp a = a &&& Mp b = b", "using euclid_ext_poly_mod_integer[OF cop f g, of p a b]\n    euclid_ext_poly_mod_uint32[OF _ cop f g, of p a b]\n    euclid_ext_poly_mod_uint64[OF _ cop f g, of p a b]\n    res[unfolded euclid_ext_poly_dynamic_def]"], ["proof (prove)\nusing this:\n  euclid_ext_poly_mod_main p (finite_field_ops_integer (integer_of_int p)) f\n   g =\n  (a, b) \\<Longrightarrow>\n  f * a + g * b =m 1\n  euclid_ext_poly_mod_main p (finite_field_ops_integer (integer_of_int p)) f\n   g =\n  (a, b) \\<Longrightarrow>\n  Mp a = a\n  euclid_ext_poly_mod_main p (finite_field_ops_integer (integer_of_int p)) f\n   g =\n  (a, b) \\<Longrightarrow>\n  Mp b = b\n  \\<lbrakk>p \\<le> 65535;\n   euclid_ext_poly_mod_main p (finite_field_ops32 (uint32_of_int p)) f g =\n   (a, b)\\<rbrakk>\n  \\<Longrightarrow> f * a + g * b =m 1\n  \\<lbrakk>p \\<le> 65535;\n   euclid_ext_poly_mod_main p (finite_field_ops32 (uint32_of_int p)) f g =\n   (a, b)\\<rbrakk>\n  \\<Longrightarrow> Mp a = a\n  \\<lbrakk>p \\<le> 65535;\n   euclid_ext_poly_mod_main p (finite_field_ops32 (uint32_of_int p)) f g =\n   (a, b)\\<rbrakk>\n  \\<Longrightarrow> Mp b = b\n  \\<lbrakk>p \\<le> 4294967295;\n   euclid_ext_poly_mod_main p (finite_field_ops64 (uint64_of_int p)) f g =\n   (a, b)\\<rbrakk>\n  \\<Longrightarrow> f * a + g * b =m 1\n  \\<lbrakk>p \\<le> 4294967295;\n   euclid_ext_poly_mod_main p (finite_field_ops64 (uint64_of_int p)) f g =\n   (a, b)\\<rbrakk>\n  \\<Longrightarrow> Mp a = a\n  \\<lbrakk>p \\<le> 4294967295;\n   euclid_ext_poly_mod_main p (finite_field_ops64 (uint64_of_int p)) f g =\n   (a, b)\\<rbrakk>\n  \\<Longrightarrow> Mp b = b\n  (if p \\<le> 65535\n   then euclid_ext_poly_mod_main p (finite_field_ops32 (uint32_of_int p))\n   else if p \\<le> 4294967295\n        then euclid_ext_poly_mod_main p\n              (finite_field_ops64 (uint64_of_int p))\n        else euclid_ext_poly_mod_main p\n              (finite_field_ops_integer (integer_of_int p)))\n   f g =\n  (a, b)\n\ngoal (1 subgoal):\n 1. f * a + g * b =m 1 &&& Mp a = a &&& Mp b = b", "by (auto split: if_splits)"], ["", "end"], ["", "lemma range_sum_prod: assumes xy: \"x \\<in> {0..<q}\" \"(y :: int) \\<in> {0..<p}\" \n  shows \"x + q * y \\<in> {0..<p * q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + q * y \\<in> {0..<p * q}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x + q * y \\<in> {0..<p * q}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. x + q * y \\<in> {0..<p * q}", "fix x q :: int"], ["proof (state)\ngoal (1 subgoal):\n 1. x + q * y \\<in> {0..<p * q}", "have \"x \\<in> {0 ..< q} \\<longleftrightarrow> 0 \\<le> x \\<and> x < q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> {0..<q}) = (0 \\<le> x \\<and> x < q)", "by auto"], ["proof (state)\nthis:\n  (x \\<in> {0..<q}) = (0 \\<le> x \\<and> x < q)\n\ngoal (1 subgoal):\n 1. x + q * y \\<in> {0..<p * q}", "}"], ["proof (state)\nthis:\n  (?xa2 \\<in> {0..<?qa2}) = (0 \\<le> ?xa2 \\<and> ?xa2 < ?qa2)\n\ngoal (1 subgoal):\n 1. x + q * y \\<in> {0..<p * q}", "note id = this"], ["proof (state)\nthis:\n  (?xa2 \\<in> {0..<?qa2}) = (0 \\<le> ?xa2 \\<and> ?xa2 < ?qa2)\n\ngoal (1 subgoal):\n 1. x + q * y \\<in> {0..<p * q}", "from xy"], ["proof (chain)\npicking this:\n  x \\<in> {0..<q}\n  y \\<in> {0..<p}", "have 0: \"0 \\<le> x + q * y\""], ["proof (prove)\nusing this:\n  x \\<in> {0..<q}\n  y \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. 0 \\<le> x + q * y", "by auto"], ["proof (state)\nthis:\n  0 \\<le> x + q * y\n\ngoal (1 subgoal):\n 1. x + q * y \\<in> {0..<p * q}", "have \"x + q * y \\<le> q - 1 + q * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + q * y \\<le> q - 1 + q * y", "using xy"], ["proof (prove)\nusing this:\n  x \\<in> {0..<q}\n  y \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. x + q * y \\<le> q - 1 + q * y", "by simp"], ["proof (state)\nthis:\n  x + q * y \\<le> q - 1 + q * y\n\ngoal (1 subgoal):\n 1. x + q * y \\<in> {0..<p * q}", "also"], ["proof (state)\nthis:\n  x + q * y \\<le> q - 1 + q * y\n\ngoal (1 subgoal):\n 1. x + q * y \\<in> {0..<p * q}", "have \"q * y \\<le> q * (p - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q * y \\<le> q * (p - 1)", "using xy"], ["proof (prove)\nusing this:\n  x \\<in> {0..<q}\n  y \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. q * y \\<le> q * (p - 1)", "by auto"], ["proof (state)\nthis:\n  q * y \\<le> q * (p - 1)\n\ngoal (1 subgoal):\n 1. x + q * y \\<in> {0..<p * q}", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      q - 1 + x \\<le> q - 1 + y) \\<Longrightarrow>\n  x + q * y \\<le> q - 1 + q * (p - 1)", "have \"x + q * y \\<le> q - 1 + q * (p - 1)\""], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      q - 1 + x \\<le> q - 1 + y) \\<Longrightarrow>\n  x + q * y \\<le> q - 1 + q * (p - 1)\n\ngoal (1 subgoal):\n 1. x + q * y \\<le> q - 1 + q * (p - 1)", "by auto"], ["proof (state)\nthis:\n  x + q * y \\<le> q - 1 + q * (p - 1)\n\ngoal (1 subgoal):\n 1. x + q * y \\<in> {0..<p * q}", "also"], ["proof (state)\nthis:\n  x + q * y \\<le> q - 1 + q * (p - 1)\n\ngoal (1 subgoal):\n 1. x + q * y \\<in> {0..<p * q}", "have \"\\<dots> = p * q - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q - 1 + q * (p - 1) = p * q - 1", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  q - 1 + q * (p - 1) = p * q - 1\n\ngoal (1 subgoal):\n 1. x + q * y \\<in> {0..<p * q}", "finally"], ["proof (chain)\npicking this:\n  x + q * y \\<le> p * q - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  x + q * y \\<le> p * q - 1\n\ngoal (1 subgoal):\n 1. x + q * y \\<in> {0..<p * q}", "using 0"], ["proof (prove)\nusing this:\n  x + q * y \\<le> p * q - 1\n  0 \\<le> x + q * y\n\ngoal (1 subgoal):\n 1. x + q * y \\<in> {0..<p * q}", "by auto"], ["proof (state)\nthis:\n  x + q * y \\<in> {0..<p * q}\n\ngoal:\nNo subgoals!", "qed"], ["", "context \n  fixes C :: \"int poly\" \nbegin"], ["", "context\n  fixes p :: int and S T D1 H1 :: \"int poly\" \nbegin"], ["", "(* The linear lifting is implemented for ease of provability.\n   Aim: show uniqueness of factorization *)"], ["", "fun linear_hensel_main where \n  \"linear_hensel_main (Suc 0) = (D1,H1)\" \n| \"linear_hensel_main (Suc n) = (\n      let (D,H) = linear_hensel_main n;\n        q = p ^ n;\n        U = poly_mod.Mp p (sdiv_poly (C - D * H) q);   \\<comment> \\<open>\\<open>H2 + H3\\<close>\\<close>\n        (A,B) = poly_mod.dupe_monic_int p D1 H1 S T U\n      in (D + smult q B, H + smult q A)) \\<comment> \\<open>\\<open>H4\\<close>\\<close>\"\n    | \"linear_hensel_main 0 = (D1,H1)\""], ["", "lemma linear_hensel_main: assumes 1: \"poly_mod.eq_m p (D1 * S + H1 * T) 1\" \n  and equiv: \"poly_mod.eq_m p (D1 * H1) C\"\n  and monD1: \"monic D1\" \n  and normDH1: \"poly_mod.Mp p D1 = D1\" \"poly_mod.Mp p H1 = H1\"\n  and res: \"linear_hensel_main n = (D,H)\" \n  and n: \"n \\<noteq> 0\" \n  and prime: \"prime p\" \\<comment> \\<open>\\<open>p > 1\\<close> suffices if one does not need uniqueness\\<close>\n  and cop: \"poly_mod.coprime_m p D1 H1\"\n  shows \"poly_mod.eq_m (p^n) (D * H) C\n    \\<and> monic D\n    \\<and> poly_mod.eq_m p D D1 \\<and> poly_mod.eq_m p H H1\n    \\<and> poly_mod.Mp (p^n) D = D\n    \\<and> poly_mod.Mp (p^n) H = H \\<and> \n    (poly_mod.eq_m (p^n) (D' * H') C \\<longrightarrow>\n     poly_mod.eq_m p D' D1 \\<longrightarrow> \n     poly_mod.eq_m p H' H1 \\<longrightarrow>\n     poly_mod.Mp (p^n) D' = D' \\<longrightarrow>\n     poly_mod.Mp (p^n) H' = H' \\<longrightarrow> monic D' \\<longrightarrow> D' = D \\<and> H' = H)\n     \""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.Mp (p ^ n) (D * H) = poly_mod.Mp (p ^ n) C \\<and>\n    monic D \\<and>\n    poly_mod.Mp p D = poly_mod.Mp p D1 \\<and>\n    poly_mod.Mp p H = poly_mod.Mp p H1 \\<and>\n    poly_mod.Mp (p ^ n) D = D \\<and>\n    poly_mod.Mp (p ^ n) H = H \\<and>\n    (poly_mod.Mp (p ^ n) (D' * H') = poly_mod.Mp (p ^ n) C \\<longrightarrow>\n     poly_mod.Mp p D' = poly_mod.Mp p D1 \\<longrightarrow>\n     poly_mod.Mp p H' = poly_mod.Mp p H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ n) D' = D' \\<longrightarrow>\n     poly_mod.Mp (p ^ n) H' = H' \\<longrightarrow>\n     monic D' \\<longrightarrow> D' = D \\<and> H' = H)", "using res n"], ["proof (prove)\nusing this:\n  local.linear_hensel_main n = (D, H)\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_mod.Mp (p ^ n) (D * H) = poly_mod.Mp (p ^ n) C \\<and>\n    monic D \\<and>\n    poly_mod.Mp p D = poly_mod.Mp p D1 \\<and>\n    poly_mod.Mp p H = poly_mod.Mp p H1 \\<and>\n    poly_mod.Mp (p ^ n) D = D \\<and>\n    poly_mod.Mp (p ^ n) H = H \\<and>\n    (poly_mod.Mp (p ^ n) (D' * H') = poly_mod.Mp (p ^ n) C \\<longrightarrow>\n     poly_mod.Mp p D' = poly_mod.Mp p D1 \\<longrightarrow>\n     poly_mod.Mp p H' = poly_mod.Mp p H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ n) D' = D' \\<longrightarrow>\n     poly_mod.Mp (p ^ n) H' = H' \\<longrightarrow>\n     monic D' \\<longrightarrow> D' = D \\<and> H' = H)", "proof (induct n arbitrary: D H D' H')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>D H D' H'.\n       \\<lbrakk>local.linear_hensel_main 0 = (D, H); 0 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp (p ^ 0) (D * H) =\n                         poly_mod.Mp (p ^ 0) C \\<and>\n                         monic D \\<and>\n                         poly_mod.Mp p D = poly_mod.Mp p D1 \\<and>\n                         poly_mod.Mp p H = poly_mod.Mp p H1 \\<and>\n                         poly_mod.Mp (p ^ 0) D = D \\<and>\n                         poly_mod.Mp (p ^ 0) H = H \\<and>\n                         (poly_mod.Mp (p ^ 0) (D' * H') =\n                          poly_mod.Mp (p ^ 0) C \\<longrightarrow>\n                          poly_mod.Mp p D' =\n                          poly_mod.Mp p D1 \\<longrightarrow>\n                          poly_mod.Mp p H' =\n                          poly_mod.Mp p H1 \\<longrightarrow>\n                          poly_mod.Mp (p ^ 0) D' = D' \\<longrightarrow>\n                          poly_mod.Mp (p ^ 0) H' = H' \\<longrightarrow>\n                          monic D' \\<longrightarrow> D' = D \\<and> H' = H)\n 2. \\<And>n D H D' H'.\n       \\<lbrakk>\\<And>D H D' H'.\n                   \\<lbrakk>local.linear_hensel_main n = (D, H);\n                    n \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> poly_mod.Mp (p ^ n) (D * H) =\n                                     poly_mod.Mp (p ^ n) C \\<and>\n                                     monic D \\<and>\n                                     poly_mod.Mp p D =\n                                     poly_mod.Mp p D1 \\<and>\n                                     poly_mod.Mp p H =\n                                     poly_mod.Mp p H1 \\<and>\n                                     poly_mod.Mp (p ^ n) D = D \\<and>\n                                     poly_mod.Mp (p ^ n) H = H \\<and>\n                                     (poly_mod.Mp (p ^ n) (D' * H') =\npoly_mod.Mp (p ^ n) C \\<longrightarrow>\npoly_mod.Mp p D' = poly_mod.Mp p D1 \\<longrightarrow>\npoly_mod.Mp p H' = poly_mod.Mp p H1 \\<longrightarrow>\npoly_mod.Mp (p ^ n) D' = D' \\<longrightarrow>\npoly_mod.Mp (p ^ n) H' = H' \\<longrightarrow>\nmonic D' \\<longrightarrow> D' = D \\<and> H' = H);\n        local.linear_hensel_main (Suc n) = (D, H); Suc n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp (p ^ Suc n) (D * H) =\n                         poly_mod.Mp (p ^ Suc n) C \\<and>\n                         monic D \\<and>\n                         poly_mod.Mp p D = poly_mod.Mp p D1 \\<and>\n                         poly_mod.Mp p H = poly_mod.Mp p H1 \\<and>\n                         poly_mod.Mp (p ^ Suc n) D = D \\<and>\n                         poly_mod.Mp (p ^ Suc n) H = H \\<and>\n                         (poly_mod.Mp (p ^ Suc n) (D' * H') =\n                          poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n                          poly_mod.Mp p D' =\n                          poly_mod.Mp p D1 \\<longrightarrow>\n                          poly_mod.Mp p H' =\n                          poly_mod.Mp p H1 \\<longrightarrow>\n                          poly_mod.Mp (p ^ Suc n) D' = D' \\<longrightarrow>\n                          poly_mod.Mp (p ^ Suc n) H' = H' \\<longrightarrow>\n                          monic D' \\<longrightarrow> D' = D \\<and> H' = H)", "case (Suc n D' H' D'' H'')"], ["proof (state)\nthis:\n  \\<lbrakk>local.linear_hensel_main n = (?D, ?H); n \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> poly_mod.Mp (p ^ n) (?D * ?H) =\n                    poly_mod.Mp (p ^ n) C \\<and>\n                    monic ?D \\<and>\n                    poly_mod.Mp p ?D = poly_mod.Mp p D1 \\<and>\n                    poly_mod.Mp p ?H = poly_mod.Mp p H1 \\<and>\n                    poly_mod.Mp (p ^ n) ?D = ?D \\<and>\n                    poly_mod.Mp (p ^ n) ?H = ?H \\<and>\n                    (poly_mod.Mp (p ^ n) (?D' * ?H') =\n                     poly_mod.Mp (p ^ n) C \\<longrightarrow>\n                     poly_mod.Mp p ?D' = poly_mod.Mp p D1 \\<longrightarrow>\n                     poly_mod.Mp p ?H' = poly_mod.Mp p H1 \\<longrightarrow>\n                     poly_mod.Mp (p ^ n) ?D' = ?D' \\<longrightarrow>\n                     poly_mod.Mp (p ^ n) ?H' = ?H' \\<longrightarrow>\n                     monic ?D' \\<longrightarrow> ?D' = ?D \\<and> ?H' = ?H)\n  local.linear_hensel_main (Suc n) = (D', H')\n  Suc n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>D H D' H'.\n       \\<lbrakk>local.linear_hensel_main 0 = (D, H); 0 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp (p ^ 0) (D * H) =\n                         poly_mod.Mp (p ^ 0) C \\<and>\n                         monic D \\<and>\n                         poly_mod.Mp p D = poly_mod.Mp p D1 \\<and>\n                         poly_mod.Mp p H = poly_mod.Mp p H1 \\<and>\n                         poly_mod.Mp (p ^ 0) D = D \\<and>\n                         poly_mod.Mp (p ^ 0) H = H \\<and>\n                         (poly_mod.Mp (p ^ 0) (D' * H') =\n                          poly_mod.Mp (p ^ 0) C \\<longrightarrow>\n                          poly_mod.Mp p D' =\n                          poly_mod.Mp p D1 \\<longrightarrow>\n                          poly_mod.Mp p H' =\n                          poly_mod.Mp p H1 \\<longrightarrow>\n                          poly_mod.Mp (p ^ 0) D' = D' \\<longrightarrow>\n                          poly_mod.Mp (p ^ 0) H' = H' \\<longrightarrow>\n                          monic D' \\<longrightarrow> D' = D \\<and> H' = H)\n 2. \\<And>n D H D' H'.\n       \\<lbrakk>\\<And>D H D' H'.\n                   \\<lbrakk>local.linear_hensel_main n = (D, H);\n                    n \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> poly_mod.Mp (p ^ n) (D * H) =\n                                     poly_mod.Mp (p ^ n) C \\<and>\n                                     monic D \\<and>\n                                     poly_mod.Mp p D =\n                                     poly_mod.Mp p D1 \\<and>\n                                     poly_mod.Mp p H =\n                                     poly_mod.Mp p H1 \\<and>\n                                     poly_mod.Mp (p ^ n) D = D \\<and>\n                                     poly_mod.Mp (p ^ n) H = H \\<and>\n                                     (poly_mod.Mp (p ^ n) (D' * H') =\npoly_mod.Mp (p ^ n) C \\<longrightarrow>\npoly_mod.Mp p D' = poly_mod.Mp p D1 \\<longrightarrow>\npoly_mod.Mp p H' = poly_mod.Mp p H1 \\<longrightarrow>\npoly_mod.Mp (p ^ n) D' = D' \\<longrightarrow>\npoly_mod.Mp (p ^ n) H' = H' \\<longrightarrow>\nmonic D' \\<longrightarrow> D' = D \\<and> H' = H);\n        local.linear_hensel_main (Suc n) = (D, H); Suc n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp (p ^ Suc n) (D * H) =\n                         poly_mod.Mp (p ^ Suc n) C \\<and>\n                         monic D \\<and>\n                         poly_mod.Mp p D = poly_mod.Mp p D1 \\<and>\n                         poly_mod.Mp p H = poly_mod.Mp p H1 \\<and>\n                         poly_mod.Mp (p ^ Suc n) D = D \\<and>\n                         poly_mod.Mp (p ^ Suc n) H = H \\<and>\n                         (poly_mod.Mp (p ^ Suc n) (D' * H') =\n                          poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n                          poly_mod.Mp p D' =\n                          poly_mod.Mp p D1 \\<longrightarrow>\n                          poly_mod.Mp p H' =\n                          poly_mod.Mp p H1 \\<longrightarrow>\n                          poly_mod.Mp (p ^ Suc n) D' = D' \\<longrightarrow>\n                          poly_mod.Mp (p ^ Suc n) H' = H' \\<longrightarrow>\n                          monic D' \\<longrightarrow> D' = D \\<and> H' = H)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    poly_mod.Mp p D' = poly_mod.Mp p D1 \\<and>\n    poly_mod.Mp p H' = poly_mod.Mp p H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     poly_mod.Mp p D'' = poly_mod.Mp p D1 \\<longrightarrow>\n     poly_mod.Mp p H'' = poly_mod.Mp p H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    poly_mod.Mp p D' = poly_mod.Mp p D1 \\<and>\n    poly_mod.Mp p H' = poly_mod.Mp p H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     poly_mod.Mp p D'' = poly_mod.Mp p D1 \\<longrightarrow>\n     poly_mod.Mp p H'' = poly_mod.Mp p H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    poly_mod.Mp p D' = poly_mod.Mp p D1 \\<and>\n    poly_mod.Mp p H' = poly_mod.Mp p H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     poly_mod.Mp p D'' = poly_mod.Mp p D1 \\<longrightarrow>\n     poly_mod.Mp p H'' = poly_mod.Mp p H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    poly_mod.Mp p D' = poly_mod.Mp p D1 \\<and>\n    poly_mod.Mp p H' = poly_mod.Mp p H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     poly_mod.Mp p D'' = poly_mod.Mp p D1 \\<longrightarrow>\n     poly_mod.Mp p H'' = poly_mod.Mp p H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    poly_mod.Mp p D' = poly_mod.Mp p D1 \\<and>\n    poly_mod.Mp p H' = poly_mod.Mp p H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     poly_mod.Mp p D'' = poly_mod.Mp p D1 \\<longrightarrow>\n     poly_mod.Mp p H'' = poly_mod.Mp p H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "with Suc equiv monD1 normDH1"], ["proof (chain)\npicking this:\n  \\<lbrakk>local.linear_hensel_main n = (?D, ?H); n \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> poly_mod.Mp (p ^ n) (?D * ?H) =\n                    poly_mod.Mp (p ^ n) C \\<and>\n                    monic ?D \\<and>\n                    poly_mod.Mp p ?D = poly_mod.Mp p D1 \\<and>\n                    poly_mod.Mp p ?H = poly_mod.Mp p H1 \\<and>\n                    poly_mod.Mp (p ^ n) ?D = ?D \\<and>\n                    poly_mod.Mp (p ^ n) ?H = ?H \\<and>\n                    (poly_mod.Mp (p ^ n) (?D' * ?H') =\n                     poly_mod.Mp (p ^ n) C \\<longrightarrow>\n                     poly_mod.Mp p ?D' = poly_mod.Mp p D1 \\<longrightarrow>\n                     poly_mod.Mp p ?H' = poly_mod.Mp p H1 \\<longrightarrow>\n                     poly_mod.Mp (p ^ n) ?D' = ?D' \\<longrightarrow>\n                     poly_mod.Mp (p ^ n) ?H' = ?H' \\<longrightarrow>\n                     monic ?D' \\<longrightarrow> ?D' = ?D \\<and> ?H' = ?H)\n  local.linear_hensel_main (Suc n) = (D', H')\n  Suc n \\<noteq> 0\n  poly_mod.Mp p (D1 * H1) = poly_mod.Mp p C\n  monic D1\n  poly_mod.Mp p D1 = D1\n  poly_mod.Mp p H1 = H1\n  n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>local.linear_hensel_main n = (?D, ?H); n \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> poly_mod.Mp (p ^ n) (?D * ?H) =\n                    poly_mod.Mp (p ^ n) C \\<and>\n                    monic ?D \\<and>\n                    poly_mod.Mp p ?D = poly_mod.Mp p D1 \\<and>\n                    poly_mod.Mp p ?H = poly_mod.Mp p H1 \\<and>\n                    poly_mod.Mp (p ^ n) ?D = ?D \\<and>\n                    poly_mod.Mp (p ^ n) ?H = ?H \\<and>\n                    (poly_mod.Mp (p ^ n) (?D' * ?H') =\n                     poly_mod.Mp (p ^ n) C \\<longrightarrow>\n                     poly_mod.Mp p ?D' = poly_mod.Mp p D1 \\<longrightarrow>\n                     poly_mod.Mp p ?H' = poly_mod.Mp p H1 \\<longrightarrow>\n                     poly_mod.Mp (p ^ n) ?D' = ?D' \\<longrightarrow>\n                     poly_mod.Mp (p ^ n) ?H' = ?H' \\<longrightarrow>\n                     monic ?D' \\<longrightarrow> ?D' = ?D \\<and> ?H' = ?H)\n  local.linear_hensel_main (Suc n) = (D', H')\n  Suc n \\<noteq> 0\n  poly_mod.Mp p (D1 * H1) = poly_mod.Mp p C\n  monic D1\n  poly_mod.Mp p D1 = D1\n  poly_mod.Mp p H1 = H1\n  n = 0\n\ngoal (1 subgoal):\n 1. poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    poly_mod.Mp p D' = poly_mod.Mp p D1 \\<and>\n    poly_mod.Mp p H' = poly_mod.Mp p H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     poly_mod.Mp p D'' = poly_mod.Mp p D1 \\<longrightarrow>\n     poly_mod.Mp p H'' = poly_mod.Mp p H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "by auto"], ["proof (state)\nthis:\n  poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n  monic D' \\<and>\n  poly_mod.Mp p D' = poly_mod.Mp p D1 \\<and>\n  poly_mod.Mp p H' = poly_mod.Mp p H1 \\<and>\n  poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n  poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n  (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n   poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n   poly_mod.Mp p D'' = poly_mod.Mp p D1 \\<longrightarrow>\n   poly_mod.Mp p H'' = poly_mod.Mp p H1 \\<longrightarrow>\n   poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n   poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n   monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    poly_mod.Mp p D' = poly_mod.Mp p D1 \\<and>\n    poly_mod.Mp p H' = poly_mod.Mp p H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     poly_mod.Mp p D'' = poly_mod.Mp p D1 \\<longrightarrow>\n     poly_mod.Mp p H'' = poly_mod.Mp p H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    poly_mod.Mp p D' = poly_mod.Mp p D1 \\<and>\n    poly_mod.Mp p H' = poly_mod.Mp p H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     poly_mod.Mp p D'' = poly_mod.Mp p D1 \\<longrightarrow>\n     poly_mod.Mp p H'' = poly_mod.Mp p H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    poly_mod.Mp p D' = poly_mod.Mp p D1 \\<and>\n    poly_mod.Mp p H' = poly_mod.Mp p H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     poly_mod.Mp p D'' = poly_mod.Mp p D1 \\<longrightarrow>\n     poly_mod.Mp p H'' = poly_mod.Mp p H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "hence n: \"n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    poly_mod.Mp p D' = poly_mod.Mp p D1 \\<and>\n    poly_mod.Mp p H' = poly_mod.Mp p H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     poly_mod.Mp p D'' = poly_mod.Mp p D1 \\<longrightarrow>\n     poly_mod.Mp p H'' = poly_mod.Mp p H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "let ?q = \"p^n\""], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    poly_mod.Mp p D' = poly_mod.Mp p D1 \\<and>\n    poly_mod.Mp p H' = poly_mod.Mp p H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     poly_mod.Mp p D'' = poly_mod.Mp p D1 \\<longrightarrow>\n     poly_mod.Mp p H'' = poly_mod.Mp p H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "let ?pq = \"p * p^n\""], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    poly_mod.Mp p D' = poly_mod.Mp p D1 \\<and>\n    poly_mod.Mp p H' = poly_mod.Mp p H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     poly_mod.Mp p D'' = poly_mod.Mp p D1 \\<longrightarrow>\n     poly_mod.Mp p H'' = poly_mod.Mp p H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "from prime"], ["proof (chain)\npicking this:\n  prime p", "have p: \"p > 1\""], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. 1 < p", "using prime_gt_1_int"], ["proof (prove)\nusing this:\n  prime p\n  prime ?p \\<Longrightarrow> 1 < ?p\n\ngoal (1 subgoal):\n 1. 1 < p", "by force"], ["proof (state)\nthis:\n  1 < p\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    poly_mod.Mp p D' = poly_mod.Mp p D1 \\<and>\n    poly_mod.Mp p H' = poly_mod.Mp p H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     poly_mod.Mp p D'' = poly_mod.Mp p D1 \\<longrightarrow>\n     poly_mod.Mp p H'' = poly_mod.Mp p H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "from n p"], ["proof (chain)\npicking this:\n  n \\<noteq> 0\n  1 < p", "have q: \"?q > 1\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  1 < p\n\ngoal (1 subgoal):\n 1. 1 < p ^ n", "by auto"], ["proof (state)\nthis:\n  1 < p ^ n\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    poly_mod.Mp p D' = poly_mod.Mp p D1 \\<and>\n    poly_mod.Mp p H' = poly_mod.Mp p H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     poly_mod.Mp p D'' = poly_mod.Mp p D1 \\<longrightarrow>\n     poly_mod.Mp p H'' = poly_mod.Mp p H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "from n p"], ["proof (chain)\npicking this:\n  n \\<noteq> 0\n  1 < p", "have pq: \"?pq > 1\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  1 < p\n\ngoal (1 subgoal):\n 1. 1 < p * p ^ n", "by (metis power_gt1_lemma)"], ["proof (state)\nthis:\n  1 < p * p ^ n\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    poly_mod.Mp p D' = poly_mod.Mp p D1 \\<and>\n    poly_mod.Mp p H' = poly_mod.Mp p H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     poly_mod.Mp p D'' = poly_mod.Mp p D1 \\<longrightarrow>\n     poly_mod.Mp p H'' = poly_mod.Mp p H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "interpret p: poly_mod_2 p"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_2 p", "using p"], ["proof (prove)\nusing this:\n  1 < p\n\ngoal (1 subgoal):\n 1. poly_mod_2 p", "unfolding poly_mod_2_def"], ["proof (prove)\nusing this:\n  1 < p\n\ngoal (1 subgoal):\n 1. 1 < p", "."], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "interpret q: poly_mod_2 ?q"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_2 (p ^ n)", "using q"], ["proof (prove)\nusing this:\n  1 < p ^ n\n\ngoal (1 subgoal):\n 1. poly_mod_2 (p ^ n)", "unfolding poly_mod_2_def"], ["proof (prove)\nusing this:\n  1 < p ^ n\n\ngoal (1 subgoal):\n 1. 1 < p ^ n", "."], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "interpret pq: poly_mod_2 ?pq"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_2 (p * p ^ n)", "using pq"], ["proof (prove)\nusing this:\n  1 < p * p ^ n\n\ngoal (1 subgoal):\n 1. poly_mod_2 (p * p ^ n)", "unfolding poly_mod_2_def"], ["proof (prove)\nusing this:\n  1 < p * p ^ n\n\ngoal (1 subgoal):\n 1. 1 < p * p ^ n", "."], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "obtain D H where rec: \"linear_hensel_main n = (D,H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D H.\n        local.linear_hensel_main n = (D, H) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  local.linear_hensel_main n = (D, H)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "obtain V where V: \"sdiv_poly (C - D * H) ?q = V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>V.\n        sdiv_poly (C - D * H) (p ^ n) = V \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  sdiv_poly (C - D * H) (p ^ n) = V\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "obtain U where U: \"p.Mp (sdiv_poly (C - D * H) ?q) = U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>U.\n        p.Mp (sdiv_poly (C - D * H) (p ^ n)) = U \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p.Mp (sdiv_poly (C - D * H) (p ^ n)) = U\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "obtain A B where dupe: \"p.dupe_monic_int D1 H1 S T U = (A,B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        p.dupe_monic_int D1 H1 S T U = (A, B) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  p.dupe_monic_int D1 H1 S T U = (A, B)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "note IH = Suc(1)[OF rec n]"], ["proof (state)\nthis:\n  q.eq_m (D * H) C \\<and>\n  monic D \\<and>\n  p.eq_m D D1 \\<and>\n  p.eq_m H H1 \\<and>\n  q.Mp D = D \\<and>\n  q.Mp H = H \\<and>\n  (q.eq_m (?D' * ?H') C \\<longrightarrow>\n   p.eq_m ?D' D1 \\<longrightarrow>\n   p.eq_m ?H' H1 \\<longrightarrow>\n   q.Mp ?D' = ?D' \\<longrightarrow>\n   q.Mp ?H' = ?H' \\<longrightarrow>\n   monic ?D' \\<longrightarrow> ?D' = D \\<and> ?H' = H)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "from IH"], ["proof (chain)\npicking this:\n  q.eq_m (D * H) C \\<and>\n  monic D \\<and>\n  p.eq_m D D1 \\<and>\n  p.eq_m H H1 \\<and>\n  q.Mp D = D \\<and>\n  q.Mp H = H \\<and>\n  (q.eq_m (?D' * ?H') C \\<longrightarrow>\n   p.eq_m ?D' D1 \\<longrightarrow>\n   p.eq_m ?H' H1 \\<longrightarrow>\n   q.Mp ?D' = ?D' \\<longrightarrow>\n   q.Mp ?H' = ?H' \\<longrightarrow>\n   monic ?D' \\<longrightarrow> ?D' = D \\<and> ?H' = H)", "have CDH: \"q.eq_m (D * H) C\"\n      and monD: \"monic D\"\n      and p_eq: \"p.eq_m D D1\" \"p.eq_m H H1\"\n      and norm: \"q.Mp D = D\" \"q.Mp H = H\""], ["proof (prove)\nusing this:\n  q.eq_m (D * H) C \\<and>\n  monic D \\<and>\n  p.eq_m D D1 \\<and>\n  p.eq_m H H1 \\<and>\n  q.Mp D = D \\<and>\n  q.Mp H = H \\<and>\n  (q.eq_m (?D' * ?H') C \\<longrightarrow>\n   p.eq_m ?D' D1 \\<longrightarrow>\n   p.eq_m ?H' H1 \\<longrightarrow>\n   q.Mp ?D' = ?D' \\<longrightarrow>\n   q.Mp ?H' = ?H' \\<longrightarrow>\n   monic ?D' \\<longrightarrow> ?D' = D \\<and> ?H' = H)\n\ngoal (1 subgoal):\n 1. (q.eq_m (D * H) C &&& monic D) &&&\n    (p.eq_m D D1 &&& p.eq_m H H1) &&& q.Mp D = D &&& q.Mp H = H", "by auto"], ["proof (state)\nthis:\n  q.eq_m (D * H) C\n  monic D\n  p.eq_m D D1\n  p.eq_m H H1\n  q.Mp D = D\n  q.Mp H = H\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "from n"], ["proof (chain)\npicking this:\n  n \\<noteq> 0", "obtain k where n: \"n = Suc k\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>k. n = Suc k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases n, auto)"], ["proof (state)\nthis:\n  n = Suc k\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have qq: \"?q * ?q = ?pq * p^k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ^ n * p ^ n = p * p ^ n * p ^ k", "unfolding n"], ["proof (prove)\ngoal (1 subgoal):\n 1. p ^ Suc k * p ^ Suc k = p * p ^ Suc k * p ^ k", "by simp"], ["proof (state)\nthis:\n  p ^ n * p ^ n = p * p ^ n * p ^ k\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "from Suc(2)[unfolded n linear_hensel_main.simps, folded n, unfolded rec split Let_def U dupe]"], ["proof (chain)\npicking this:\n  (D + Polynomial.smult (p ^ n) B, H + Polynomial.smult (p ^ n) A) =\n  (D', H')", "have D': \"D' = D + smult ?q B\" and H': \"H' = H + smult ?q A\""], ["proof (prove)\nusing this:\n  (D + Polynomial.smult (p ^ n) B, H + Polynomial.smult (p ^ n) A) =\n  (D', H')\n\ngoal (1 subgoal):\n 1. D' = D + Polynomial.smult (p ^ n) B &&&\n    H' = H + Polynomial.smult (p ^ n) A", "by auto"], ["proof (state)\nthis:\n  D' = D + Polynomial.smult (p ^ n) B\n  H' = H + Polynomial.smult (p ^ n) A\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "note dupe = p.dupe_monic_int[OF 1 monD1 dupe]"], ["proof (state)\nthis:\n  p.eq_m (A * D1 + B * H1) U\n  B = 0 \\<or> degree B < degree D1\n  p.Mp A = A\n  p.Mp B = B\n  \\<lbrakk>p.coprime_m D1 H1; p.eq_m (?A' * D1 + ?B' * H1) U;\n   ?B' = 0 \\<or> degree ?B' < degree D1; p.Mp D1 = D1; p.Mp ?A' = ?A';\n   p.Mp ?B' = ?B'; prime p\\<rbrakk>\n  \\<Longrightarrow> ?A' = A \\<and> ?B' = B\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "from CDH"], ["proof (chain)\npicking this:\n  q.eq_m (D * H) C", "have \"q.Mp C - q.Mp (D * H) = 0\""], ["proof (prove)\nusing this:\n  q.eq_m (D * H) C\n\ngoal (1 subgoal):\n 1. q.Mp C - q.Mp (D * H) = 0", "by simp"], ["proof (state)\nthis:\n  q.Mp C - q.Mp (D * H) = 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "hence \"q.Mp (q.Mp C - q.Mp (D * H)) = 0\""], ["proof (prove)\nusing this:\n  q.Mp C - q.Mp (D * H) = 0\n\ngoal (1 subgoal):\n 1. q.Mp (q.Mp C - q.Mp (D * H)) = 0", "by simp"], ["proof (state)\nthis:\n  q.Mp (q.Mp C - q.Mp (D * H)) = 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "hence \"q.Mp (C - D*H) = 0\""], ["proof (prove)\nusing this:\n  q.Mp (q.Mp C - q.Mp (D * H)) = 0\n\ngoal (1 subgoal):\n 1. q.Mp (C - D * H) = 0", "by simp"], ["proof (state)\nthis:\n  q.Mp (C - D * H) = 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "from q.Mp_0_smult_sdiv_poly[OF this]"], ["proof (chain)\npicking this:\n  Polynomial.smult (p ^ n) (sdiv_poly (C - D * H) (p ^ n)) = C - D * H", "have CDHq: \"smult ?q (sdiv_poly (C - D * H) ?q) = C - D * H\""], ["proof (prove)\nusing this:\n  Polynomial.smult (p ^ n) (sdiv_poly (C - D * H) (p ^ n)) = C - D * H\n\ngoal (1 subgoal):\n 1. Polynomial.smult (p ^ n) (sdiv_poly (C - D * H) (p ^ n)) = C - D * H", "."], ["proof (state)\nthis:\n  Polynomial.smult (p ^ n) (sdiv_poly (C - D * H) (p ^ n)) = C - D * H\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have ADBHU: \"p.eq_m (A * D + B * H) U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p.eq_m (A * D + B * H) U", "using p_eq dupe(1)"], ["proof (prove)\nusing this:\n  p.eq_m D D1\n  p.eq_m H H1\n  p.eq_m (A * D1 + B * H1) U\n\ngoal (1 subgoal):\n 1. p.eq_m (A * D + B * H) U", "by (metis (mono_tags, lifting) p.mult_Mp(2) poly_mod.plus_Mp)"], ["proof (state)\nthis:\n  p.eq_m (A * D + B * H) U\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have \"pq.Mp (D' * H') = pq.Mp ((D + smult ?q B) * (H + smult ?q A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pq.eq_m (D' * H')\n     ((D + Polynomial.smult (p ^ n) B) * (H + Polynomial.smult (p ^ n) A))", "unfolding D' H'"], ["proof (prove)\ngoal (1 subgoal):\n 1. pq.eq_m\n     ((D + Polynomial.smult (p ^ n) B) * (H + Polynomial.smult (p ^ n) A))\n     ((D + Polynomial.smult (p ^ n) B) * (H + Polynomial.smult (p ^ n) A))", "by simp"], ["proof (state)\nthis:\n  pq.eq_m (D' * H')\n   ((D + Polynomial.smult (p ^ n) B) * (H + Polynomial.smult (p ^ n) A))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "also"], ["proof (state)\nthis:\n  pq.eq_m (D' * H')\n   ((D + Polynomial.smult (p ^ n) B) * (H + Polynomial.smult (p ^ n) A))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have \"(D + smult ?q B) * (H + smult ?q A) = (D * H + smult ?q (A * D + B * H)) + smult (?q * ?q) (A * B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (D + Polynomial.smult (p ^ n) B) * (H + Polynomial.smult (p ^ n) A) =\n    D * H + Polynomial.smult (p ^ n) (A * D + B * H) +\n    Polynomial.smult (p ^ n * p ^ n) (A * B)", "by (simp add: field_simps smult_distribs)"], ["proof (state)\nthis:\n  (D + Polynomial.smult (p ^ n) B) * (H + Polynomial.smult (p ^ n) A) =\n  D * H + Polynomial.smult (p ^ n) (A * D + B * H) +\n  Polynomial.smult (p ^ n * p ^ n) (A * B)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "also"], ["proof (state)\nthis:\n  (D + Polynomial.smult (p ^ n) B) * (H + Polynomial.smult (p ^ n) A) =\n  D * H + Polynomial.smult (p ^ n) (A * D + B * H) +\n  Polynomial.smult (p ^ n * p ^ n) (A * B)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have \"pq.Mp \\<dots> = pq.Mp (D * H + pq.Mp (smult ?q (A * D + B * H)) + pq.Mp (smult (?q * ?q) (A * B)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pq.eq_m\n     (D * H + Polynomial.smult (p ^ n) (A * D + B * H) +\n      Polynomial.smult (p ^ n * p ^ n) (A * B))\n     (D * H + pq.Mp (Polynomial.smult (p ^ n) (A * D + B * H)) +\n      pq.Mp (Polynomial.smult (p ^ n * p ^ n) (A * B)))", "using pq.plus_Mp"], ["proof (prove)\nusing this:\n  pq.eq_m (pq.Mp ?f + ?g) (?f + ?g)\n  pq.eq_m (?f + pq.Mp ?g) (?f + ?g)\n\ngoal (1 subgoal):\n 1. pq.eq_m\n     (D * H + Polynomial.smult (p ^ n) (A * D + B * H) +\n      Polynomial.smult (p ^ n * p ^ n) (A * B))\n     (D * H + pq.Mp (Polynomial.smult (p ^ n) (A * D + B * H)) +\n      pq.Mp (Polynomial.smult (p ^ n * p ^ n) (A * B)))", "by metis"], ["proof (state)\nthis:\n  pq.eq_m\n   (D * H + Polynomial.smult (p ^ n) (A * D + B * H) +\n    Polynomial.smult (p ^ n * p ^ n) (A * B))\n   (D * H + pq.Mp (Polynomial.smult (p ^ n) (A * D + B * H)) +\n    pq.Mp (Polynomial.smult (p ^ n * p ^ n) (A * B)))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "also"], ["proof (state)\nthis:\n  pq.eq_m\n   (D * H + Polynomial.smult (p ^ n) (A * D + B * H) +\n    Polynomial.smult (p ^ n * p ^ n) (A * B))\n   (D * H + pq.Mp (Polynomial.smult (p ^ n) (A * D + B * H)) +\n    pq.Mp (Polynomial.smult (p ^ n * p ^ n) (A * B)))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have \"pq.Mp (smult (?q * ?q) (A * B)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pq.Mp (Polynomial.smult (p ^ n * p ^ n) (A * B)) = 0", "unfolding qq"], ["proof (prove)\ngoal (1 subgoal):\n 1. pq.Mp (Polynomial.smult (p * p ^ n * p ^ k) (A * B)) = 0", "by (metis pq.Mp_smult_m_0 smult_smult)"], ["proof (state)\nthis:\n  pq.Mp (Polynomial.smult (p ^ n * p ^ n) (A * B)) = 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "finally"], ["proof (chain)\npicking this:\n  pq.eq_m (D' * H')\n   (D * H + pq.Mp (Polynomial.smult (p ^ n) (A * D + B * H)) + 0)", "have DH': \"pq.Mp (D' * H') = pq.Mp (D * H + pq.Mp (smult ?q (A * D + B * H)))\""], ["proof (prove)\nusing this:\n  pq.eq_m (D' * H')\n   (D * H + pq.Mp (Polynomial.smult (p ^ n) (A * D + B * H)) + 0)\n\ngoal (1 subgoal):\n 1. pq.eq_m (D' * H')\n     (D * H + pq.Mp (Polynomial.smult (p ^ n) (A * D + B * H)))", "by simp"], ["proof (state)\nthis:\n  pq.eq_m (D' * H')\n   (D * H + pq.Mp (Polynomial.smult (p ^ n) (A * D + B * H)))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "also"], ["proof (state)\nthis:\n  pq.eq_m (D' * H')\n   (D * H + pq.Mp (Polynomial.smult (p ^ n) (A * D + B * H)))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have \"pq.Mp (smult ?q (A * D + B * H)) = pq.Mp (smult ?q U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pq.eq_m (Polynomial.smult (p ^ n) (A * D + B * H))\n     (Polynomial.smult (p ^ n) U)", "using p.Mp_lift_modulus[OF ADBHU, of ?q]"], ["proof (prove)\nusing this:\n  pq.eq_m (Polynomial.smult (p ^ n) (A * D + B * H))\n   (Polynomial.smult (p ^ n) U)\n\ngoal (1 subgoal):\n 1. pq.eq_m (Polynomial.smult (p ^ n) (A * D + B * H))\n     (Polynomial.smult (p ^ n) U)", "by simp"], ["proof (state)\nthis:\n  pq.eq_m (Polynomial.smult (p ^ n) (A * D + B * H))\n   (Polynomial.smult (p ^ n) U)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "also"], ["proof (state)\nthis:\n  pq.eq_m (Polynomial.smult (p ^ n) (A * D + B * H))\n   (Polynomial.smult (p ^ n) U)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have \"\\<dots> = pq.Mp (C - D * H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pq.eq_m (Polynomial.smult (p ^ n) U) (C - D * H)", "unfolding arg_cong[OF CDHq, of pq.Mp, symmetric] U[symmetric] V"], ["proof (prove)\ngoal (1 subgoal):\n 1. pq.eq_m (Polynomial.smult (p ^ n) (p.Mp V)) (Polynomial.smult (p ^ n) V)", "by (rule p.Mp_lift_modulus[of _ _ ?q], auto)"], ["proof (state)\nthis:\n  pq.eq_m (Polynomial.smult (p ^ n) U) (C - D * H)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "also"], ["proof (state)\nthis:\n  pq.eq_m (Polynomial.smult (p ^ n) U) (C - D * H)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have \"pq.Mp (D * H + pq.Mp (C - D * H)) = pq.Mp C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pq.eq_m (D * H + pq.Mp (C - D * H)) C", "by simp"], ["proof (state)\nthis:\n  pq.eq_m (D * H + pq.Mp (C - D * H)) C\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "finally"], ["proof (chain)\npicking this:\n  pq.eq_m (D' * H') C", "have CDH: \"pq.eq_m C (D' * H')\""], ["proof (prove)\nusing this:\n  pq.eq_m (D' * H') C\n\ngoal (1 subgoal):\n 1. pq.eq_m C (D' * H')", "by simp"], ["proof (state)\nthis:\n  pq.eq_m C (D' * H')\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have deg: \"degree D1 = degree D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree D1 = degree D", "using p_eq(1) monD1 monD"], ["proof (prove)\nusing this:\n  p.eq_m D D1\n  monic D1\n  monic D\n\ngoal (1 subgoal):\n 1. degree D1 = degree D", "by (metis p.monic_degree_m)"], ["proof (state)\nthis:\n  degree D1 = degree D\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have mon: \"monic D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic D'", "unfolding D'"], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (D + Polynomial.smult (p ^ n) B)", "using dupe(2) monD"], ["proof (prove)\nusing this:\n  B = 0 \\<or> degree B < degree D1\n  monic D\n\ngoal (1 subgoal):\n 1. monic (D + Polynomial.smult (p ^ n) B)", "unfolding deg"], ["proof (prove)\nusing this:\n  B = 0 \\<or> degree B < degree D\n  monic D\n\ngoal (1 subgoal):\n 1. monic (D + Polynomial.smult (p ^ n) B)", "by (rule monic_smult_add_small)"], ["proof (state)\nthis:\n  monic D'\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have normD': \"pq.Mp D' = D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pq.Mp D' = D'", "unfolding D' pq.Mp_ident_iff poly_mod.Mp_coeff plus_poly.rep_eq coeff_smult"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       poly.coeff D n + p ^ n * poly.coeff B n \\<in> {0..<p * p ^ n}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff D n + p ^ n * poly.coeff B n \\<in> {0..<p * p ^ n}", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff D n + p ^ n * poly.coeff B n \\<in> {0..<p * p ^ n}", "from norm(1) dupe(4)"], ["proof (chain)\npicking this:\n  q.Mp D = D\n  p.Mp B = B", "have \"coeff D i \\<in> {0..<?q}\" \"coeff B i \\<in> {0..<p}\""], ["proof (prove)\nusing this:\n  q.Mp D = D\n  p.Mp B = B\n\ngoal (1 subgoal):\n 1. poly.coeff D i \\<in> {0..<p ^ n} &&& poly.coeff B i \\<in> {0..<p}", "unfolding p.Mp_ident_iff q.Mp_ident_iff"], ["proof (prove)\nusing this:\n  \\<forall>n. poly.coeff D n \\<in> {0..<p ^ n}\n  \\<forall>n. poly.coeff B n \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. poly.coeff D i \\<in> {0..<p ^ n} &&& poly.coeff B i \\<in> {0..<p}", "by auto"], ["proof (state)\nthis:\n  poly.coeff D i \\<in> {0..<p ^ n}\n  poly.coeff B i \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff D n + p ^ n * poly.coeff B n \\<in> {0..<p * p ^ n}", "thus \"coeff D i + ?q * coeff B i \\<in> {0..< ?pq}\""], ["proof (prove)\nusing this:\n  poly.coeff D i \\<in> {0..<p ^ n}\n  poly.coeff B i \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. poly.coeff D i + p ^ n * poly.coeff B i \\<in> {0..<p * p ^ n}", "by (rule range_sum_prod)"], ["proof (state)\nthis:\n  poly.coeff D i + p ^ n * poly.coeff B i \\<in> {0..<p * p ^ n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pq.Mp D' = D'\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have normH': \"pq.Mp H' = H'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pq.Mp H' = H'", "unfolding H' pq.Mp_ident_iff poly_mod.Mp_coeff plus_poly.rep_eq coeff_smult"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       poly.coeff H n + p ^ n * poly.coeff A n \\<in> {0..<p * p ^ n}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff H n + p ^ n * poly.coeff A n \\<in> {0..<p * p ^ n}", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff H n + p ^ n * poly.coeff A n \\<in> {0..<p * p ^ n}", "from norm(2) dupe(3)"], ["proof (chain)\npicking this:\n  q.Mp H = H\n  p.Mp A = A", "have \"coeff H i \\<in> {0..<?q}\" \"coeff A i \\<in> {0..<p}\""], ["proof (prove)\nusing this:\n  q.Mp H = H\n  p.Mp A = A\n\ngoal (1 subgoal):\n 1. poly.coeff H i \\<in> {0..<p ^ n} &&& poly.coeff A i \\<in> {0..<p}", "unfolding p.Mp_ident_iff q.Mp_ident_iff"], ["proof (prove)\nusing this:\n  \\<forall>n. poly.coeff H n \\<in> {0..<p ^ n}\n  \\<forall>n. poly.coeff A n \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. poly.coeff H i \\<in> {0..<p ^ n} &&& poly.coeff A i \\<in> {0..<p}", "by auto"], ["proof (state)\nthis:\n  poly.coeff H i \\<in> {0..<p ^ n}\n  poly.coeff A i \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff H n + p ^ n * poly.coeff A n \\<in> {0..<p * p ^ n}", "thus \"coeff H i + ?q * coeff A i \\<in> {0..< ?pq}\""], ["proof (prove)\nusing this:\n  poly.coeff H i \\<in> {0..<p ^ n}\n  poly.coeff A i \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. poly.coeff H i + p ^ n * poly.coeff A i \\<in> {0..<p * p ^ n}", "by (rule range_sum_prod)"], ["proof (state)\nthis:\n  poly.coeff H i + p ^ n * poly.coeff A i \\<in> {0..<p * p ^ n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pq.Mp H' = H'\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have eq: \"p.eq_m D D'\" \"p.eq_m H H'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p.eq_m D D' &&& p.eq_m H H'", "unfolding D' H' n \n        poly_eq_iff p.Mp_coeff p.M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       poly.coeff D n mod p =\n       poly.coeff (D + Polynomial.smult (p ^ Suc k) B) n mod p &&&\n    \\<forall>n.\n       poly.coeff H n mod p =\n       poly.coeff (H + Polynomial.smult (p ^ Suc k) A) n mod p", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  p.eq_m D D'\n  p.eq_m H H'\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "with p_eq"], ["proof (chain)\npicking this:\n  p.eq_m D D1\n  p.eq_m H H1\n  p.eq_m D D'\n  p.eq_m H H'", "have eq: \"p.eq_m D' D1\" \"p.eq_m H' H1\""], ["proof (prove)\nusing this:\n  p.eq_m D D1\n  p.eq_m H H1\n  p.eq_m D D'\n  p.eq_m H H'\n\ngoal (1 subgoal):\n 1. p.eq_m D' D1 &&& p.eq_m H' H1", "by auto"], ["proof (state)\nthis:\n  p.eq_m D' D1\n  p.eq_m H' H1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "{"], ["proof (state)\nthis:\n  p.eq_m D' D1\n  p.eq_m H' H1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "assume CDH'': \"pq.eq_m C (D'' * H'')\" \n        and DH1'': \"p.eq_m D1 D''\" \"p.eq_m H1 H''\"\n        and norm'': \"pq.Mp D'' = D''\" \"pq.Mp H'' = H''\" \n        and monD'': \"monic D''\""], ["proof (state)\nthis:\n  pq.eq_m C (D'' * H'')\n  p.eq_m D1 D''\n  p.eq_m H1 H''\n  pq.Mp D'' = D''\n  pq.Mp H'' = H''\n  monic D''\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "from q.Dp_Mp_eq[of D'']"], ["proof (chain)\npicking this:\n  D'' = q.Mp D'' + Polynomial.smult (p ^ n) (q.Dp D'')", "obtain d B' where D'': \"D'' = q.Mp d + smult ?q B'\""], ["proof (prove)\nusing this:\n  D'' = q.Mp D'' + Polynomial.smult (p ^ n) (q.Dp D'')\n\ngoal (1 subgoal):\n 1. (\\<And>d B'.\n        D'' = q.Mp d + Polynomial.smult (p ^ n) B' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  D'' = q.Mp d + Polynomial.smult (p ^ n) B'\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "from q.Dp_Mp_eq[of H'']"], ["proof (chain)\npicking this:\n  H'' = q.Mp H'' + Polynomial.smult (p ^ n) (q.Dp H'')", "obtain h A' where H'': \"H'' = q.Mp h + smult ?q A'\""], ["proof (prove)\nusing this:\n  H'' = q.Mp H'' + Polynomial.smult (p ^ n) (q.Dp H'')\n\ngoal (1 subgoal):\n 1. (\\<And>h A'.\n        H'' = q.Mp h + Polynomial.smult (p ^ n) A' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  H'' = q.Mp h + Polynomial.smult (p ^ n) A'\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "{"], ["proof (state)\nthis:\n  H'' = q.Mp h + Polynomial.smult (p ^ n) A'\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "fix A B"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "assume *: \"pq.Mp (q.Mp A + smult ?q B) = q.Mp A + smult ?q B\""], ["proof (state)\nthis:\n  pq.Mp (q.Mp A + Polynomial.smult (p ^ n) B) =\n  q.Mp A + Polynomial.smult (p ^ n) B\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have \"p.Mp B = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p.Mp B = B", "unfolding p.Mp_ident_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. poly.coeff B n \\<in> {0..<p}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff B n \\<in> {0..<p}", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff B n \\<in> {0..<p}", "from arg_cong[OF *, of \"\\<lambda> f. coeff f i\", unfolded pq.Mp_coeff pq.M_def]"], ["proof (chain)\npicking this:\n  poly.coeff (q.Mp A + Polynomial.smult (p ^ n) B) i mod (p * p ^ n) =\n  poly.coeff (q.Mp A + Polynomial.smult (p ^ n) B) i", "have \"coeff (q.Mp A + smult ?q B) i \\<in> {0 ..< ?pq}\""], ["proof (prove)\nusing this:\n  poly.coeff (q.Mp A + Polynomial.smult (p ^ n) B) i mod (p * p ^ n) =\n  poly.coeff (q.Mp A + Polynomial.smult (p ^ n) B) i\n\ngoal (1 subgoal):\n 1. poly.coeff (q.Mp A + Polynomial.smult (p ^ n) B) i \\<in> {0..<p * p ^ n}", "using \"*\" pq.Mp_ident_iff"], ["proof (prove)\nusing this:\n  poly.coeff (q.Mp A + Polynomial.smult (p ^ n) B) i mod (p * p ^ n) =\n  poly.coeff (q.Mp A + Polynomial.smult (p ^ n) B) i\n  pq.Mp (q.Mp A + Polynomial.smult (p ^ n) B) =\n  q.Mp A + Polynomial.smult (p ^ n) B\n  (pq.Mp ?f = ?f) = (\\<forall>n. poly.coeff ?f n \\<in> {0..<p * p ^ n})\n\ngoal (1 subgoal):\n 1. poly.coeff (q.Mp A + Polynomial.smult (p ^ n) B) i \\<in> {0..<p * p ^ n}", "by blast"], ["proof (state)\nthis:\n  poly.coeff (q.Mp A + Polynomial.smult (p ^ n) B) i \\<in> {0..<p * p ^ n}\n\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff B n \\<in> {0..<p}", "hence sum: \"coeff (q.Mp A) i + ?q * coeff B i \\<in> {0 ..< ?pq}\""], ["proof (prove)\nusing this:\n  poly.coeff (q.Mp A + Polynomial.smult (p ^ n) B) i \\<in> {0..<p * p ^ n}\n\ngoal (1 subgoal):\n 1. poly.coeff (q.Mp A) i + p ^ n * poly.coeff B i \\<in> {0..<p * p ^ n}", "by auto"], ["proof (state)\nthis:\n  poly.coeff (q.Mp A) i + p ^ n * poly.coeff B i \\<in> {0..<p * p ^ n}\n\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff B n \\<in> {0..<p}", "have \"q.Mp (q.Mp A) = q.Mp A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q.eq_m (q.Mp A) A", "by auto"], ["proof (state)\nthis:\n  q.eq_m (q.Mp A) A\n\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff B n \\<in> {0..<p}", "from this[unfolded q.Mp_ident_iff]"], ["proof (chain)\npicking this:\n  \\<forall>n. poly.coeff (q.Mp A) n \\<in> {0..<p ^ n}", "have A: \"coeff (q.Mp A) i \\<in> {0 ..< p^n}\""], ["proof (prove)\nusing this:\n  \\<forall>n. poly.coeff (q.Mp A) n \\<in> {0..<p ^ n}\n\ngoal (1 subgoal):\n 1. poly.coeff (q.Mp A) i \\<in> {0..<p ^ n}", "by auto"], ["proof (state)\nthis:\n  poly.coeff (q.Mp A) i \\<in> {0..<p ^ n}\n\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff B n \\<in> {0..<p}", "{"], ["proof (state)\nthis:\n  poly.coeff (q.Mp A) i \\<in> {0..<p ^ n}\n\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff B n \\<in> {0..<p}", "assume \"coeff B i < 0\""], ["proof (state)\nthis:\n  poly.coeff B i < 0\n\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff B n \\<in> {0..<p}", "hence \"coeff B i \\<le> -1\""], ["proof (prove)\nusing this:\n  poly.coeff B i < 0\n\ngoal (1 subgoal):\n 1. poly.coeff B i \\<le> - 1", "by auto"], ["proof (state)\nthis:\n  poly.coeff B i \\<le> - 1\n\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff B n \\<in> {0..<p}", "from mult_left_mono[OF this, of ?q] q.m1"], ["proof (chain)\npicking this:\n  0 \\<le> p ^ n \\<Longrightarrow> p ^ n * poly.coeff B i \\<le> p ^ n * - 1\n  1 < p ^ n", "have \"?q * coeff B i \\<le> -?q\""], ["proof (prove)\nusing this:\n  0 \\<le> p ^ n \\<Longrightarrow> p ^ n * poly.coeff B i \\<le> p ^ n * - 1\n  1 < p ^ n\n\ngoal (1 subgoal):\n 1. p ^ n * poly.coeff B i \\<le> - (p ^ n)", "by simp"], ["proof (state)\nthis:\n  p ^ n * poly.coeff B i \\<le> - (p ^ n)\n\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff B n \\<in> {0..<p}", "with A sum"], ["proof (chain)\npicking this:\n  poly.coeff (q.Mp A) i \\<in> {0..<p ^ n}\n  poly.coeff (q.Mp A) i + p ^ n * poly.coeff B i \\<in> {0..<p * p ^ n}\n  p ^ n * poly.coeff B i \\<le> - (p ^ n)", "have False"], ["proof (prove)\nusing this:\n  poly.coeff (q.Mp A) i \\<in> {0..<p ^ n}\n  poly.coeff (q.Mp A) i + p ^ n * poly.coeff B i \\<in> {0..<p * p ^ n}\n  p ^ n * poly.coeff B i \\<le> - (p ^ n)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff B n \\<in> {0..<p}", "}"], ["proof (state)\nthis:\n  poly.coeff B i < 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff B n \\<in> {0..<p}", "hence \"coeff B i \\<ge> 0\""], ["proof (prove)\nusing this:\n  poly.coeff B i < 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. 0 \\<le> poly.coeff B i", "by force"], ["proof (state)\nthis:\n  0 \\<le> poly.coeff B i\n\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff B n \\<in> {0..<p}", "moreover"], ["proof (state)\nthis:\n  0 \\<le> poly.coeff B i\n\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff B n \\<in> {0..<p}", "{"], ["proof (state)\nthis:\n  0 \\<le> poly.coeff B i\n\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff B n \\<in> {0..<p}", "assume \"coeff B i \\<ge> p\""], ["proof (state)\nthis:\n  p \\<le> poly.coeff B i\n\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff B n \\<in> {0..<p}", "from mult_left_mono[OF this, of ?q] q.m1"], ["proof (chain)\npicking this:\n  0 \\<le> p ^ n \\<Longrightarrow> p ^ n * p \\<le> p ^ n * poly.coeff B i\n  1 < p ^ n", "have \"?q * coeff B i \\<ge> ?pq\""], ["proof (prove)\nusing this:\n  0 \\<le> p ^ n \\<Longrightarrow> p ^ n * p \\<le> p ^ n * poly.coeff B i\n  1 < p ^ n\n\ngoal (1 subgoal):\n 1. p * p ^ n \\<le> p ^ n * poly.coeff B i", "by simp"], ["proof (state)\nthis:\n  p * p ^ n \\<le> p ^ n * poly.coeff B i\n\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff B n \\<in> {0..<p}", "with A sum"], ["proof (chain)\npicking this:\n  poly.coeff (q.Mp A) i \\<in> {0..<p ^ n}\n  poly.coeff (q.Mp A) i + p ^ n * poly.coeff B i \\<in> {0..<p * p ^ n}\n  p * p ^ n \\<le> p ^ n * poly.coeff B i", "have False"], ["proof (prove)\nusing this:\n  poly.coeff (q.Mp A) i \\<in> {0..<p ^ n}\n  poly.coeff (q.Mp A) i + p ^ n * poly.coeff B i \\<in> {0..<p * p ^ n}\n  p * p ^ n \\<le> p ^ n * poly.coeff B i\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff B n \\<in> {0..<p}", "}"], ["proof (state)\nthis:\n  p \\<le> poly.coeff B i \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff B n \\<in> {0..<p}", "hence \"coeff B i < p\""], ["proof (prove)\nusing this:\n  p \\<le> poly.coeff B i \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. poly.coeff B i < p", "by force"], ["proof (state)\nthis:\n  poly.coeff B i < p\n\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff B n \\<in> {0..<p}", "ultimately"], ["proof (chain)\npicking this:\n  0 \\<le> poly.coeff B i\n  poly.coeff B i < p", "show \"coeff B i \\<in> {0 ..< p}\""], ["proof (prove)\nusing this:\n  0 \\<le> poly.coeff B i\n  poly.coeff B i < p\n\ngoal (1 subgoal):\n 1. poly.coeff B i \\<in> {0..<p}", "by auto"], ["proof (state)\nthis:\n  poly.coeff B i \\<in> {0..<p}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p.Mp B = B\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "}"], ["proof (state)\nthis:\n  pq.Mp (q.Mp ?Aa2 + Polynomial.smult (p ^ n) ?Ba2) =\n  q.Mp ?Aa2 + Polynomial.smult (p ^ n) ?Ba2 \\<Longrightarrow>\n  p.Mp ?Ba2 = ?Ba2\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "note norm_convert = this"], ["proof (state)\nthis:\n  pq.Mp (q.Mp ?Aa2 + Polynomial.smult (p ^ n) ?Ba2) =\n  q.Mp ?Aa2 + Polynomial.smult (p ^ n) ?Ba2 \\<Longrightarrow>\n  p.Mp ?Ba2 = ?Ba2\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "from norm_convert[OF norm''(1)[unfolded D'']]"], ["proof (chain)\npicking this:\n  p.Mp B' = B'", "have normB': \"p.Mp B' = B'\""], ["proof (prove)\nusing this:\n  p.Mp B' = B'\n\ngoal (1 subgoal):\n 1. p.Mp B' = B'", "."], ["proof (state)\nthis:\n  p.Mp B' = B'\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "from norm_convert[OF norm''(2)[unfolded H'']]"], ["proof (chain)\npicking this:\n  p.Mp A' = A'", "have normA': \"p.Mp A' = A'\""], ["proof (prove)\nusing this:\n  p.Mp A' = A'\n\ngoal (1 subgoal):\n 1. p.Mp A' = A'", "."], ["proof (state)\nthis:\n  p.Mp A' = A'\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "let ?d = \"q.Mp d\""], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "let ?h = \"q.Mp h\""], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "assume lt: \"degree ?d < degree B'\""], ["proof (state)\nthis:\n  q.degree_m d < degree B'\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "hence eq: \"degree D'' = degree B'\""], ["proof (prove)\nusing this:\n  q.degree_m d < degree B'\n\ngoal (1 subgoal):\n 1. degree D'' = degree B'", "unfolding D''"], ["proof (prove)\nusing this:\n  q.degree_m d < degree B'\n\ngoal (1 subgoal):\n 1. degree (q.Mp d + Polynomial.smult (p ^ n) B') = degree B'", "using q.m1 p.m1"], ["proof (prove)\nusing this:\n  q.degree_m d < degree B'\n  1 < p ^ n\n  1 < p\n\ngoal (1 subgoal):\n 1. degree (q.Mp d + Polynomial.smult (p ^ n) B') = degree B'", "by (subst degree_add_eq_right, auto)"], ["proof (state)\nthis:\n  degree D'' = degree B'\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "from lt"], ["proof (chain)\npicking this:\n  q.degree_m d < degree B'", "have [simp]: \"coeff ?d (degree B') = 0\""], ["proof (prove)\nusing this:\n  q.degree_m d < degree B'\n\ngoal (1 subgoal):\n 1. poly.coeff (q.Mp d) (degree B') = 0", "by (rule coeff_eq_0)"], ["proof (state)\nthis:\n  poly.coeff (q.Mp d) (degree B') = 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "from monD''[unfolded eq, unfolded D'', simplified] False q.m1 lt"], ["proof (chain)\npicking this:\n  p ^ n * lead_coeff B' = 1\n  n \\<noteq> 0\n  1 < p ^ n\n  q.degree_m d < degree B'", "have False"], ["proof (prove)\nusing this:\n  p ^ n * lead_coeff B' = 1\n  n \\<noteq> 0\n  1 < p ^ n\n  q.degree_m d < degree B'\n\ngoal (1 subgoal):\n 1. False", "by (metis mod_mult_self1_is_0 poly_mod.M_def q.M_1 zero_neq_one)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "}"], ["proof (state)\nthis:\n  q.degree_m d < degree B' \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "hence deg_dB': \"degree ?d \\<ge> degree B'\""], ["proof (prove)\nusing this:\n  q.degree_m d < degree B' \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. degree B' \\<le> q.degree_m d", "by presburger"], ["proof (state)\nthis:\n  degree B' \\<le> q.degree_m d\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "{"], ["proof (state)\nthis:\n  degree B' \\<le> q.degree_m d\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "assume eq: \"degree ?d = degree B'\" and B': \"B' \\<noteq> 0\""], ["proof (state)\nthis:\n  q.degree_m d = degree B'\n  B' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "let ?B = \"coeff B' (degree B')\""], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "from normB'[unfolded p.Mp_ident_iff, rule_format, of \"degree B'\"] B'"], ["proof (chain)\npicking this:\n  lead_coeff B' \\<in> {0..<p}\n  B' \\<noteq> 0", "have \"?B \\<in> {0..<p} - {0}\""], ["proof (prove)\nusing this:\n  lead_coeff B' \\<in> {0..<p}\n  B' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff B' \\<in> {0..<p} - {0}", "by simp"], ["proof (state)\nthis:\n  lead_coeff B' \\<in> {0..<p} - {0}\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "hence bnds: \"?B > 0\" \"?B < p\""], ["proof (prove)\nusing this:\n  lead_coeff B' \\<in> {0..<p} - {0}\n\ngoal (1 subgoal):\n 1. 0 < lead_coeff B' &&& lead_coeff B' < p", "by auto"], ["proof (state)\nthis:\n  0 < lead_coeff B'\n  lead_coeff B' < p\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have degD'': \"degree D'' \\<le> degree ?d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree D'' \\<le> q.degree_m d", "unfolding D''"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (q.Mp d + Polynomial.smult (p ^ n) B') \\<le> q.degree_m d", "using eq"], ["proof (prove)\nusing this:\n  q.degree_m d = degree B'\n\ngoal (1 subgoal):\n 1. degree (q.Mp d + Polynomial.smult (p ^ n) B') \\<le> q.degree_m d", "by (simp add: degree_add_le)"], ["proof (state)\nthis:\n  degree D'' \\<le> q.degree_m d\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have \"?q * ?B \\<ge> 1 * 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * 1 \\<le> p ^ n * lead_coeff B'", "by (rule mult_mono, insert q.m1 bnds, auto)"], ["proof (state)\nthis:\n  1 * 1 \\<le> p ^ n * lead_coeff B'\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "moreover"], ["proof (state)\nthis:\n  1 * 1 \\<le> p ^ n * lead_coeff B'\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have \"coeff D'' (degree ?d) = 1 + ?q * ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff D'' (q.degree_m d) = 1 + p ^ n * lead_coeff B'", "using monD''"], ["proof (prove)\nusing this:\n  monic D''\n\ngoal (1 subgoal):\n 1. poly.coeff D'' (q.degree_m d) = 1 + p ^ n * lead_coeff B'", "unfolding D''"], ["proof (prove)\nusing this:\n  monic (q.Mp d + Polynomial.smult (p ^ n) B')\n\ngoal (1 subgoal):\n 1. poly.coeff (q.Mp d + Polynomial.smult (p ^ n) B') (q.degree_m d) =\n    1 + p ^ n * lead_coeff B'", "using eq"], ["proof (prove)\nusing this:\n  monic (q.Mp d + Polynomial.smult (p ^ n) B')\n  q.degree_m d = degree B'\n\ngoal (1 subgoal):\n 1. poly.coeff (q.Mp d + Polynomial.smult (p ^ n) B') (q.degree_m d) =\n    1 + p ^ n * lead_coeff B'", "by (metis D'' coeff_smult monD'' plus_poly.rep_eq poly_mod.Dp_Mp_eq \n              poly_mod.degree_m_eq_monic poly_mod.plus_Mp(1) \n              q.Mp_smult_m_0 q.m1 q.monic_Mp q.plus_Mp(2))"], ["proof (state)\nthis:\n  poly.coeff D'' (q.degree_m d) = 1 + p ^ n * lead_coeff B'\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "ultimately"], ["proof (chain)\npicking this:\n  1 * 1 \\<le> p ^ n * lead_coeff B'\n  poly.coeff D'' (q.degree_m d) = 1 + p ^ n * lead_coeff B'", "have gt: \"coeff D'' (degree ?d) > 1\""], ["proof (prove)\nusing this:\n  1 * 1 \\<le> p ^ n * lead_coeff B'\n  poly.coeff D'' (q.degree_m d) = 1 + p ^ n * lead_coeff B'\n\ngoal (1 subgoal):\n 1. 1 < poly.coeff D'' (q.degree_m d)", "by auto"], ["proof (state)\nthis:\n  1 < poly.coeff D'' (q.degree_m d)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "hence \"coeff D'' (degree ?d) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  1 < poly.coeff D'' (q.degree_m d)\n\ngoal (1 subgoal):\n 1. poly.coeff D'' (q.degree_m d) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly.coeff D'' (q.degree_m d) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "hence \"degree D'' \\<ge> degree ?d\""], ["proof (prove)\nusing this:\n  poly.coeff D'' (q.degree_m d) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q.degree_m d \\<le> degree D''", "by (rule le_degree)"], ["proof (state)\nthis:\n  q.degree_m d \\<le> degree D''\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "with degree_add_le_max[of ?d \"smult ?q B'\", folded D''] eq"], ["proof (chain)\npicking this:\n  degree D'' \\<le> max (q.degree_m d) (degree (Polynomial.smult (p ^ n) B'))\n  q.degree_m d = degree B'\n  q.degree_m d \\<le> degree D''", "have deg: \"degree D'' = degree ?d\""], ["proof (prove)\nusing this:\n  degree D'' \\<le> max (q.degree_m d) (degree (Polynomial.smult (p ^ n) B'))\n  q.degree_m d = degree B'\n  q.degree_m d \\<le> degree D''\n\ngoal (1 subgoal):\n 1. degree D'' = q.degree_m d", "using degD''"], ["proof (prove)\nusing this:\n  degree D'' \\<le> max (q.degree_m d) (degree (Polynomial.smult (p ^ n) B'))\n  q.degree_m d = degree B'\n  q.degree_m d \\<le> degree D''\n  degree D'' \\<le> q.degree_m d\n\ngoal (1 subgoal):\n 1. degree D'' = q.degree_m d", "by linarith"], ["proof (state)\nthis:\n  degree D'' = q.degree_m d\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "from gt[folded this]"], ["proof (chain)\npicking this:\n  1 < lead_coeff D''", "have \"\\<not> monic D''\""], ["proof (prove)\nusing this:\n  1 < lead_coeff D''\n\ngoal (1 subgoal):\n 1. lead_coeff D'' \\<noteq> 1", "by auto"], ["proof (state)\nthis:\n  lead_coeff D'' \\<noteq> 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "with monD''"], ["proof (chain)\npicking this:\n  monic D''\n  lead_coeff D'' \\<noteq> 1", "have False"], ["proof (prove)\nusing this:\n  monic D''\n  lead_coeff D'' \\<noteq> 1\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "}"], ["proof (state)\nthis:\n  \\<lbrakk>q.degree_m d = degree B'; B' \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "with deg_dB'"], ["proof (chain)\npicking this:\n  degree B' \\<le> q.degree_m d\n  \\<lbrakk>q.degree_m d = degree B'; B' \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> False", "have deg_dB2: \"B' = 0 \\<or> degree B' < degree ?d\""], ["proof (prove)\nusing this:\n  degree B' \\<le> q.degree_m d\n  \\<lbrakk>q.degree_m d = degree B'; B' \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. B' = 0 \\<or> degree B' < q.degree_m d", "by fastforce"], ["proof (state)\nthis:\n  B' = 0 \\<or> degree B' < q.degree_m d\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have d: \"q.Mp D'' = ?d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q.eq_m D'' d", "unfolding D''"], ["proof (prove)\ngoal (1 subgoal):\n 1. q.eq_m (q.Mp d + Polynomial.smult (p ^ n) B') d", "by (metis add.right_neutral poly_mod.Mp_smult_m_0 poly_mod.plus_Mp)"], ["proof (state)\nthis:\n  q.eq_m D'' d\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have h: \"q.Mp H'' = ?h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q.eq_m H'' h", "unfolding H''"], ["proof (prove)\ngoal (1 subgoal):\n 1. q.eq_m (q.Mp h + Polynomial.smult (p ^ n) A') h", "by (metis add.right_neutral poly_mod.Mp_smult_m_0 poly_mod.plus_Mp)"], ["proof (state)\nthis:\n  q.eq_m H'' h\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "from CDH''"], ["proof (chain)\npicking this:\n  pq.eq_m C (D'' * H'')", "have \"pq.Mp C = pq.Mp (D'' * H'')\""], ["proof (prove)\nusing this:\n  pq.eq_m C (D'' * H'')\n\ngoal (1 subgoal):\n 1. pq.eq_m C (D'' * H'')", "by simp"], ["proof (state)\nthis:\n  pq.eq_m C (D'' * H'')\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "from arg_cong[OF this, of q.Mp]"], ["proof (chain)\npicking this:\n  q.eq_m (pq.Mp C) (pq.Mp (D'' * H''))", "have \"q.Mp C = q.Mp (D'' * H'')\""], ["proof (prove)\nusing this:\n  q.eq_m (pq.Mp C) (pq.Mp (D'' * H''))\n\ngoal (1 subgoal):\n 1. q.eq_m C (D'' * H'')", "using p.m1 q.Mp_product_modulus"], ["proof (prove)\nusing this:\n  q.eq_m (pq.Mp C) (pq.Mp (D'' * H''))\n  1 < p\n  \\<lbrakk>?m' = p ^ n * ?k; 0 < ?k\\<rbrakk>\n  \\<Longrightarrow> q.eq_m (poly_mod.Mp ?m' ?f) ?f\n\ngoal (1 subgoal):\n 1. q.eq_m C (D'' * H'')", "by auto"], ["proof (state)\nthis:\n  q.eq_m C (D'' * H'')\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "also"], ["proof (state)\nthis:\n  q.eq_m C (D'' * H'')\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have \"\\<dots> = q.Mp (q.Mp D'' * q.Mp H'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q.eq_m (D'' * H'') (q.Mp D'' * q.Mp H'')", "by simp"], ["proof (state)\nthis:\n  q.eq_m (D'' * H'') (q.Mp D'' * q.Mp H'')\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "also"], ["proof (state)\nthis:\n  q.eq_m (D'' * H'') (q.Mp D'' * q.Mp H'')\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have \"\\<dots> = q.Mp (?d * ?h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q.eq_m (q.Mp D'' * q.Mp H'') (q.Mp d * q.Mp h)", "unfolding d h"], ["proof (prove)\ngoal (1 subgoal):\n 1. q.eq_m (q.Mp d * q.Mp h) (q.Mp d * q.Mp h)", "by simp"], ["proof (state)\nthis:\n  q.eq_m (q.Mp D'' * q.Mp H'') (q.Mp d * q.Mp h)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "finally"], ["proof (chain)\npicking this:\n  q.eq_m C (q.Mp d * q.Mp h)", "have eqC: \"q.eq_m (?d * ?h) C\""], ["proof (prove)\nusing this:\n  q.eq_m C (q.Mp d * q.Mp h)\n\ngoal (1 subgoal):\n 1. q.eq_m (q.Mp d * q.Mp h) C", "by auto"], ["proof (state)\nthis:\n  q.eq_m (q.Mp d * q.Mp h) C\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have d1: \"p.eq_m ?d D1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p.eq_m (q.Mp d) D1", "unfolding d[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. p.eq_m (q.Mp D'') D1", "using DH1''"], ["proof (prove)\nusing this:\n  p.eq_m D1 D''\n  p.eq_m H1 H''\n\ngoal (1 subgoal):\n 1. p.eq_m (q.Mp D'') D1", "using assms(4) n p.Mp_product_modulus p.m1"], ["proof (prove)\nusing this:\n  p.eq_m D1 D''\n  p.eq_m H1 H''\n  p.Mp D1 = D1\n  n = Suc k\n  \\<lbrakk>?m' = p * ?k; 0 < ?k\\<rbrakk>\n  \\<Longrightarrow> p.eq_m (poly_mod.Mp ?m' ?f) ?f\n  1 < p\n\ngoal (1 subgoal):\n 1. p.eq_m (q.Mp D'') D1", "by auto"], ["proof (state)\nthis:\n  p.eq_m (q.Mp d) D1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have h1: \"p.eq_m ?h H1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p.eq_m (q.Mp h) H1", "unfolding h[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. p.eq_m (q.Mp H'') H1", "using DH1''"], ["proof (prove)\nusing this:\n  p.eq_m D1 D''\n  p.eq_m H1 H''\n\ngoal (1 subgoal):\n 1. p.eq_m (q.Mp H'') H1", "using assms(5) n p.Mp_product_modulus p.m1"], ["proof (prove)\nusing this:\n  p.eq_m D1 D''\n  p.eq_m H1 H''\n  p.Mp H1 = H1\n  n = Suc k\n  \\<lbrakk>?m' = p * ?k; 0 < ?k\\<rbrakk>\n  \\<Longrightarrow> p.eq_m (poly_mod.Mp ?m' ?f) ?f\n  1 < p\n\ngoal (1 subgoal):\n 1. p.eq_m (q.Mp H'') H1", "by auto"], ["proof (state)\nthis:\n  p.eq_m (q.Mp h) H1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have mond: \"monic (q.Mp d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (q.Mp d)", "using monD'' deg_dB2"], ["proof (prove)\nusing this:\n  monic D''\n  B' = 0 \\<or> degree B' < q.degree_m d\n\ngoal (1 subgoal):\n 1. monic (q.Mp d)", "unfolding D''"], ["proof (prove)\nusing this:\n  monic (q.Mp d + Polynomial.smult (p ^ n) B')\n  B' = 0 \\<or> degree B' < q.degree_m d\n\ngoal (1 subgoal):\n 1. monic (q.Mp d)", "using d q.monic_Mp[OF monD'']"], ["proof (prove)\nusing this:\n  monic (q.Mp d + Polynomial.smult (p ^ n) B')\n  B' = 0 \\<or> degree B' < q.degree_m d\n  q.eq_m D'' d\n  monic (q.Mp D'')\n\ngoal (1 subgoal):\n 1. monic (q.Mp d)", "by simp"], ["proof (state)\nthis:\n  monic (q.Mp d)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "from eqC d1 h1 mond IH[of \"q.Mp d\" \"q.Mp h\"]"], ["proof (chain)\npicking this:\n  q.eq_m (q.Mp d * q.Mp h) C\n  p.eq_m (q.Mp d) D1\n  p.eq_m (q.Mp h) H1\n  monic (q.Mp d)\n  q.eq_m (D * H) C \\<and>\n  monic D \\<and>\n  p.eq_m D D1 \\<and>\n  p.eq_m H H1 \\<and>\n  q.Mp D = D \\<and>\n  q.Mp H = H \\<and>\n  (q.eq_m (q.Mp d * q.Mp h) C \\<longrightarrow>\n   p.eq_m (q.Mp d) D1 \\<longrightarrow>\n   p.eq_m (q.Mp h) H1 \\<longrightarrow>\n   q.eq_m (q.Mp d) d \\<longrightarrow>\n   q.eq_m (q.Mp h) h \\<longrightarrow>\n   monic (q.Mp d) \\<longrightarrow> q.Mp d = D \\<and> q.Mp h = H)", "have IH: \"?d = D\" \"?h = H\""], ["proof (prove)\nusing this:\n  q.eq_m (q.Mp d * q.Mp h) C\n  p.eq_m (q.Mp d) D1\n  p.eq_m (q.Mp h) H1\n  monic (q.Mp d)\n  q.eq_m (D * H) C \\<and>\n  monic D \\<and>\n  p.eq_m D D1 \\<and>\n  p.eq_m H H1 \\<and>\n  q.Mp D = D \\<and>\n  q.Mp H = H \\<and>\n  (q.eq_m (q.Mp d * q.Mp h) C \\<longrightarrow>\n   p.eq_m (q.Mp d) D1 \\<longrightarrow>\n   p.eq_m (q.Mp h) H1 \\<longrightarrow>\n   q.eq_m (q.Mp d) d \\<longrightarrow>\n   q.eq_m (q.Mp h) h \\<longrightarrow>\n   monic (q.Mp d) \\<longrightarrow> q.Mp d = D \\<and> q.Mp h = H)\n\ngoal (1 subgoal):\n 1. q.Mp d = D &&& q.Mp h = H", "by auto"], ["proof (state)\nthis:\n  q.Mp d = D\n  q.Mp h = H\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "from deg_dB2[unfolded IH]"], ["proof (chain)\npicking this:\n  B' = 0 \\<or> degree B' < degree D", "have degB': \"B' = 0 \\<or> degree B' < degree D\""], ["proof (prove)\nusing this:\n  B' = 0 \\<or> degree B' < degree D\n\ngoal (1 subgoal):\n 1. B' = 0 \\<or> degree B' < degree D", "by auto"], ["proof (state)\nthis:\n  B' = 0 \\<or> degree B' < degree D\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "from IH"], ["proof (chain)\npicking this:\n  q.Mp d = D\n  q.Mp h = H", "have D'': \"D'' = D + smult ?q B'\" and H'': \"H'' = H + smult ?q A'\""], ["proof (prove)\nusing this:\n  q.Mp d = D\n  q.Mp h = H\n\ngoal (1 subgoal):\n 1. D'' = D + Polynomial.smult (p ^ n) B' &&&\n    H'' = H + Polynomial.smult (p ^ n) A'", "unfolding D'' H''"], ["proof (prove)\nusing this:\n  q.Mp d = D\n  q.Mp h = H\n\ngoal (1 subgoal):\n 1. q.Mp d + Polynomial.smult (p ^ n) B' =\n    D + Polynomial.smult (p ^ n) B' &&&\n    q.Mp h + Polynomial.smult (p ^ n) A' = H + Polynomial.smult (p ^ n) A'", "by auto"], ["proof (state)\nthis:\n  D'' = D + Polynomial.smult (p ^ n) B'\n  H'' = H + Polynomial.smult (p ^ n) A'\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have \"pq.Mp (D'' * H'') = pq.Mp (D' * H')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pq.eq_m (D'' * H'') (D' * H')", "using CDH'' CDH"], ["proof (prove)\nusing this:\n  pq.eq_m C (D'' * H'')\n  pq.eq_m C (D' * H')\n\ngoal (1 subgoal):\n 1. pq.eq_m (D'' * H'') (D' * H')", "by simp"], ["proof (state)\nthis:\n  pq.eq_m (D'' * H'') (D' * H')\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "also"], ["proof (state)\nthis:\n  pq.eq_m (D'' * H'') (D' * H')\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have \"pq.Mp (D'' * H'') = pq.Mp ((D + smult ?q B') * (H + smult ?q A'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pq.eq_m (D'' * H'')\n     ((D + Polynomial.smult (p ^ n) B') * (H + Polynomial.smult (p ^ n) A'))", "unfolding D'' H''"], ["proof (prove)\ngoal (1 subgoal):\n 1. pq.eq_m\n     ((D + Polynomial.smult (p ^ n) B') * (H + Polynomial.smult (p ^ n) A'))\n     ((D + Polynomial.smult (p ^ n) B') * (H + Polynomial.smult (p ^ n) A'))", "by simp"], ["proof (state)\nthis:\n  pq.eq_m (D'' * H'')\n   ((D + Polynomial.smult (p ^ n) B') * (H + Polynomial.smult (p ^ n) A'))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "also"], ["proof (state)\nthis:\n  pq.eq_m (D'' * H'')\n   ((D + Polynomial.smult (p ^ n) B') * (H + Polynomial.smult (p ^ n) A'))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have \"(D + smult ?q B') * (H + smult ?q A') = (D * H + smult ?q (A' * D + B' * H)) + smult (?q * ?q) (A' * B')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (D + Polynomial.smult (p ^ n) B') * (H + Polynomial.smult (p ^ n) A') =\n    D * H + Polynomial.smult (p ^ n) (A' * D + B' * H) +\n    Polynomial.smult (p ^ n * p ^ n) (A' * B')", "by (simp add: field_simps smult_distribs)"], ["proof (state)\nthis:\n  (D + Polynomial.smult (p ^ n) B') * (H + Polynomial.smult (p ^ n) A') =\n  D * H + Polynomial.smult (p ^ n) (A' * D + B' * H) +\n  Polynomial.smult (p ^ n * p ^ n) (A' * B')\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "also"], ["proof (state)\nthis:\n  (D + Polynomial.smult (p ^ n) B') * (H + Polynomial.smult (p ^ n) A') =\n  D * H + Polynomial.smult (p ^ n) (A' * D + B' * H) +\n  Polynomial.smult (p ^ n * p ^ n) (A' * B')\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have \"pq.Mp \\<dots> = pq.Mp (D * H + pq.Mp (smult ?q (A' * D + B' * H)) + pq.Mp (smult (?q * ?q) (A' * B')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pq.eq_m\n     (D * H + Polynomial.smult (p ^ n) (A' * D + B' * H) +\n      Polynomial.smult (p ^ n * p ^ n) (A' * B'))\n     (D * H + pq.Mp (Polynomial.smult (p ^ n) (A' * D + B' * H)) +\n      pq.Mp (Polynomial.smult (p ^ n * p ^ n) (A' * B')))", "using pq.plus_Mp"], ["proof (prove)\nusing this:\n  pq.eq_m (pq.Mp ?f + ?g) (?f + ?g)\n  pq.eq_m (?f + pq.Mp ?g) (?f + ?g)\n\ngoal (1 subgoal):\n 1. pq.eq_m\n     (D * H + Polynomial.smult (p ^ n) (A' * D + B' * H) +\n      Polynomial.smult (p ^ n * p ^ n) (A' * B'))\n     (D * H + pq.Mp (Polynomial.smult (p ^ n) (A' * D + B' * H)) +\n      pq.Mp (Polynomial.smult (p ^ n * p ^ n) (A' * B')))", "by metis"], ["proof (state)\nthis:\n  pq.eq_m\n   (D * H + Polynomial.smult (p ^ n) (A' * D + B' * H) +\n    Polynomial.smult (p ^ n * p ^ n) (A' * B'))\n   (D * H + pq.Mp (Polynomial.smult (p ^ n) (A' * D + B' * H)) +\n    pq.Mp (Polynomial.smult (p ^ n * p ^ n) (A' * B')))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "also"], ["proof (state)\nthis:\n  pq.eq_m\n   (D * H + Polynomial.smult (p ^ n) (A' * D + B' * H) +\n    Polynomial.smult (p ^ n * p ^ n) (A' * B'))\n   (D * H + pq.Mp (Polynomial.smult (p ^ n) (A' * D + B' * H)) +\n    pq.Mp (Polynomial.smult (p ^ n * p ^ n) (A' * B')))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have \"pq.Mp (smult (?q * ?q) (A' * B')) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pq.Mp (Polynomial.smult (p ^ n * p ^ n) (A' * B')) = 0", "unfolding qq"], ["proof (prove)\ngoal (1 subgoal):\n 1. pq.Mp (Polynomial.smult (p * p ^ n * p ^ k) (A' * B')) = 0", "by (metis pq.Mp_smult_m_0 smult_smult)"], ["proof (state)\nthis:\n  pq.Mp (Polynomial.smult (p ^ n * p ^ n) (A' * B')) = 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "finally"], ["proof (chain)\npicking this:\n  pq.eq_m (D * H + pq.Mp (Polynomial.smult (p ^ n) (A' * D + B' * H)) + 0)\n   (D' * H')", "have \"pq.Mp (D * H + pq.Mp (smult ?q (A' * D + B' * H))) \n        = pq.Mp (D * H + pq.Mp (smult ?q (A * D + B * H)))\""], ["proof (prove)\nusing this:\n  pq.eq_m (D * H + pq.Mp (Polynomial.smult (p ^ n) (A' * D + B' * H)) + 0)\n   (D' * H')\n\ngoal (1 subgoal):\n 1. pq.eq_m (D * H + pq.Mp (Polynomial.smult (p ^ n) (A' * D + B' * H)))\n     (D * H + pq.Mp (Polynomial.smult (p ^ n) (A * D + B * H)))", "unfolding DH'"], ["proof (prove)\nusing this:\n  pq.eq_m (D * H + pq.Mp (Polynomial.smult (p ^ n) (A' * D + B' * H)) + 0)\n   (D * H + pq.Mp (Polynomial.smult (p ^ n) (A * D + B * H)))\n\ngoal (1 subgoal):\n 1. pq.eq_m (D * H + pq.Mp (Polynomial.smult (p ^ n) (A' * D + B' * H)))\n     (D * H + pq.Mp (Polynomial.smult (p ^ n) (A * D + B * H)))", "by simp"], ["proof (state)\nthis:\n  pq.eq_m (D * H + pq.Mp (Polynomial.smult (p ^ n) (A' * D + B' * H)))\n   (D * H + pq.Mp (Polynomial.smult (p ^ n) (A * D + B * H)))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "hence \"pq.Mp (smult ?q (A' * D + B' * H)) = pq.Mp (smult ?q (A * D + B * H))\""], ["proof (prove)\nusing this:\n  pq.eq_m (D * H + pq.Mp (Polynomial.smult (p ^ n) (A' * D + B' * H)))\n   (D * H + pq.Mp (Polynomial.smult (p ^ n) (A * D + B * H)))\n\ngoal (1 subgoal):\n 1. pq.eq_m (Polynomial.smult (p ^ n) (A' * D + B' * H))\n     (Polynomial.smult (p ^ n) (A * D + B * H))", "by (metis (no_types, lifting) add_diff_cancel_left' poly_mod.minus_Mp(1) poly_mod.plus_Mp(2))"], ["proof (state)\nthis:\n  pq.eq_m (Polynomial.smult (p ^ n) (A' * D + B' * H))\n   (Polynomial.smult (p ^ n) (A * D + B * H))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "hence \"p.Mp (A' * D + B' * H) = p.Mp (A * D + B * H)\""], ["proof (prove)\nusing this:\n  pq.eq_m (Polynomial.smult (p ^ n) (A' * D + B' * H))\n   (Polynomial.smult (p ^ n) (A * D + B * H))\n\ngoal (1 subgoal):\n 1. p.eq_m (A' * D + B' * H) (A * D + B * H)", "unfolding poly_eq_iff p.Mp_coeff pq.Mp_coeff coeff_smult"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     pq.M (p ^ n * poly.coeff (A' * D + B' * H) n) =\n     pq.M (p ^ n * poly.coeff (A * D + B * H) n)\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       p.M (poly.coeff (A' * D + B' * H) n) =\n       p.M (poly.coeff (A * D + B * H) n)", "by (insert p, auto simp: p.M_def pq.M_def)"], ["proof (state)\nthis:\n  p.eq_m (A' * D + B' * H) (A * D + B * H)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "hence \"p.Mp (A' * D1 + B' * H1) = p.Mp (A * D1 + B * H1)\""], ["proof (prove)\nusing this:\n  p.eq_m (A' * D + B' * H) (A * D + B * H)\n\ngoal (1 subgoal):\n 1. p.eq_m (A' * D1 + B' * H1) (A * D1 + B * H1)", "using p_eq"], ["proof (prove)\nusing this:\n  p.eq_m (A' * D + B' * H) (A * D + B * H)\n  p.eq_m D D1\n  p.eq_m H H1\n\ngoal (1 subgoal):\n 1. p.eq_m (A' * D1 + B' * H1) (A * D1 + B * H1)", "by (metis p.mult_Mp(2) poly_mod.plus_Mp)"], ["proof (state)\nthis:\n  p.eq_m (A' * D1 + B' * H1) (A * D1 + B * H1)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "hence eq: \"p.eq_m (A' * D1 + B' * H1) U\""], ["proof (prove)\nusing this:\n  p.eq_m (A' * D1 + B' * H1) (A * D1 + B * H1)\n\ngoal (1 subgoal):\n 1. p.eq_m (A' * D1 + B' * H1) U", "using dupe(1)"], ["proof (prove)\nusing this:\n  p.eq_m (A' * D1 + B' * H1) (A * D1 + B * H1)\n  p.eq_m (A * D1 + B * H1) U\n\ngoal (1 subgoal):\n 1. p.eq_m (A' * D1 + B' * H1) U", "by auto"], ["proof (state)\nthis:\n  p.eq_m (A' * D1 + B' * H1) U\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "have \"degree D = degree D1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree D = degree D1", "using monD monD1 \n          arg_cong[OF p_eq(1), of degree] \n          p.degree_m_eq_monic[OF _ p.m1]"], ["proof (prove)\nusing this:\n  monic D\n  monic D1\n  p.degree_m D = p.degree_m D1\n  monic ?f \\<Longrightarrow> p.degree_m ?f = degree ?f\n\ngoal (1 subgoal):\n 1. degree D = degree D1", "by auto"], ["proof (state)\nthis:\n  degree D = degree D1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "hence \"B' = 0 \\<or> degree B' < degree D1\""], ["proof (prove)\nusing this:\n  degree D = degree D1\n\ngoal (1 subgoal):\n 1. B' = 0 \\<or> degree B' < degree D1", "using degB'"], ["proof (prove)\nusing this:\n  degree D = degree D1\n  B' = 0 \\<or> degree B' < degree D\n\ngoal (1 subgoal):\n 1. B' = 0 \\<or> degree B' < degree D1", "by simp"], ["proof (state)\nthis:\n  B' = 0 \\<or> degree B' < degree D1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "from dupe(5)[OF cop eq this normDH1(1) normA' normB' prime]"], ["proof (chain)\npicking this:\n  A' = A \\<and> B' = B", "have \"A' = A\" \"B' = B\""], ["proof (prove)\nusing this:\n  A' = A \\<and> B' = B\n\ngoal (1 subgoal):\n 1. A' = A &&& B' = B", "by auto"], ["proof (state)\nthis:\n  A' = A\n  B' = B\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "hence \"D'' = D'\" \"H'' = H'\""], ["proof (prove)\nusing this:\n  A' = A\n  B' = B\n\ngoal (1 subgoal):\n 1. D'' = D' &&& H'' = H'", "unfolding D'' H'' D' H'"], ["proof (prove)\nusing this:\n  A' = A\n  B' = B\n\ngoal (1 subgoal):\n 1. D + Polynomial.smult (p ^ n) B' = D + Polynomial.smult (p ^ n) B &&&\n    H + Polynomial.smult (p ^ n) A' = H + Polynomial.smult (p ^ n) A", "by auto"], ["proof (state)\nthis:\n  D'' = D'\n  H'' = H'\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "}"], ["proof (state)\nthis:\n  \\<lbrakk>pq.eq_m C (D'' * H''); p.eq_m D1 D''; p.eq_m H1 H'';\n   pq.Mp D'' = D''; pq.Mp H'' = H''; monic D''\\<rbrakk>\n  \\<Longrightarrow> D'' = D'\n  \\<lbrakk>pq.eq_m C (D'' * H''); p.eq_m D1 D''; p.eq_m H1 H'';\n   pq.Mp D'' = D''; pq.Mp H'' = H''; monic D''\\<rbrakk>\n  \\<Longrightarrow> H'' = H'\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>pq.eq_m C (D'' * H''); p.eq_m D1 D''; p.eq_m H1 H'';\n   pq.Mp D'' = D''; pq.Mp H'' = H''; monic D''\\<rbrakk>\n  \\<Longrightarrow> D'' = D'\n  \\<lbrakk>pq.eq_m C (D'' * H''); p.eq_m D1 D''; p.eq_m H1 H'';\n   pq.Mp D'' = D''; pq.Mp H'' = H''; monic D''\\<rbrakk>\n  \\<Longrightarrow> H'' = H'\n\ngoal (1 subgoal):\n 1. poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "using normD' normH' CDH mon eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>pq.eq_m C (D'' * H''); p.eq_m D1 D''; p.eq_m H1 H'';\n   pq.Mp D'' = D''; pq.Mp H'' = H''; monic D''\\<rbrakk>\n  \\<Longrightarrow> D'' = D'\n  \\<lbrakk>pq.eq_m C (D'' * H''); p.eq_m D1 D''; p.eq_m H1 H'';\n   pq.Mp D'' = D''; pq.Mp H'' = H''; monic D''\\<rbrakk>\n  \\<Longrightarrow> H'' = H'\n  pq.Mp D' = D'\n  pq.Mp H' = H'\n  pq.eq_m C (D' * H')\n  monic D'\n  p.eq_m D' D1\n  p.eq_m H' H1\n\ngoal (1 subgoal):\n 1. poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n    monic D' \\<and>\n    p.eq_m D' D1 \\<and>\n    p.eq_m H' H1 \\<and>\n    poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n    poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n    (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n     poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n     p.eq_m D'' D1 \\<longrightarrow>\n     p.eq_m H'' H1 \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n     poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n     monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')", "by simp"], ["proof (state)\nthis:\n  poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n  monic D' \\<and>\n  p.eq_m D' D1 \\<and>\n  p.eq_m H' H1 \\<and>\n  poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n  poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n  (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n   poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n   p.eq_m D'' D1 \\<longrightarrow>\n   p.eq_m H'' H1 \\<longrightarrow>\n   poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n   poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n   monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_mod.Mp (p ^ Suc n) (D' * H') = poly_mod.Mp (p ^ Suc n) C \\<and>\n  monic D' \\<and>\n  poly_mod.Mp p D' = poly_mod.Mp p D1 \\<and>\n  poly_mod.Mp p H' = poly_mod.Mp p H1 \\<and>\n  poly_mod.Mp (p ^ Suc n) D' = D' \\<and>\n  poly_mod.Mp (p ^ Suc n) H' = H' \\<and>\n  (poly_mod.Mp (p ^ Suc n) (D'' * H'') =\n   poly_mod.Mp (p ^ Suc n) C \\<longrightarrow>\n   poly_mod.Mp p D'' = poly_mod.Mp p D1 \\<longrightarrow>\n   poly_mod.Mp p H'' = poly_mod.Mp p H1 \\<longrightarrow>\n   poly_mod.Mp (p ^ Suc n) D'' = D'' \\<longrightarrow>\n   poly_mod.Mp (p ^ Suc n) H'' = H'' \\<longrightarrow>\n   monic D'' \\<longrightarrow> D'' = D' \\<and> H'' = H')\n\ngoal (1 subgoal):\n 1. \\<And>D H D' H'.\n       \\<lbrakk>local.linear_hensel_main 0 = (D, H); 0 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp (p ^ 0) (D * H) =\n                         poly_mod.Mp (p ^ 0) C \\<and>\n                         monic D \\<and>\n                         poly_mod.Mp p D = poly_mod.Mp p D1 \\<and>\n                         poly_mod.Mp p H = poly_mod.Mp p H1 \\<and>\n                         poly_mod.Mp (p ^ 0) D = D \\<and>\n                         poly_mod.Mp (p ^ 0) H = H \\<and>\n                         (poly_mod.Mp (p ^ 0) (D' * H') =\n                          poly_mod.Mp (p ^ 0) C \\<longrightarrow>\n                          poly_mod.Mp p D' =\n                          poly_mod.Mp p D1 \\<longrightarrow>\n                          poly_mod.Mp p H' =\n                          poly_mod.Mp p H1 \\<longrightarrow>\n                          poly_mod.Mp (p ^ 0) D' = D' \\<longrightarrow>\n                          poly_mod.Mp (p ^ 0) H' = H' \\<longrightarrow>\n                          monic D' \\<longrightarrow> D' = D \\<and> H' = H)", "qed simp"], ["", "end"], ["", "end"], ["", "definition linear_hensel_binary :: \"int \\<Rightarrow> nat \\<Rightarrow> int poly \\<Rightarrow> int poly \\<Rightarrow> int poly \\<Rightarrow> int poly \\<times> int poly\" where\n  \"linear_hensel_binary p n C D H = (let\n     (S,T) = euclid_ext_poly_dynamic p D H\n     in linear_hensel_main C p S T D H n)\""], ["", "lemma (in poly_mod_prime) unique_hensel_binary: \n  assumes prime: \"prime p\"\n  and cop: \"coprime_m D H\" and eq: \"eq_m (D * H) C\"\n  and normalized_input: \"Mp D = D\" \"Mp H = H\"\n  and monic_input: \"monic D\" \n  and n: \"n \\<noteq> 0\" \nshows \"\\<exists>! (D',H'). \\<comment> \\<open>\\<open>D'\\<close>, \\<open>H'\\<close> are computed via \\<open>linear_hensel_binary\\<close>\\<close>\n      poly_mod.eq_m (p^n) (D' * H') C \\<comment> \\<open>the main result: equivalence mod \\<open>p^n\\<close>\\<close>\n    \\<and> monic D' \\<comment> \\<open>monic output\\<close>\n    \\<and> eq_m D D' \\<and> eq_m H H' \\<comment> \\<open>apply \\<open>`mod p`\\<close> on \\<open>D'\\<close> and \\<open>H'\\<close> yields \\<open>D\\<close> and \\<open>H\\<close> again\\<close>\n    \\<and> poly_mod.Mp (p^n) D' = D' \\<and> poly_mod.Mp (p^n) H' = H' \\<comment> \\<open>output is normalized\\<close>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!(D', H').\n       poly_mod.Mp (p ^ n) (D' * H') = poly_mod.Mp (p ^ n) C \\<and>\n       monic D' \\<and>\n       D =m D' \\<and>\n       H =m H' \\<and>\n       poly_mod.Mp (p ^ n) D' = D' \\<and> poly_mod.Mp (p ^ n) H' = H'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!(D', H').\n       poly_mod.Mp (p ^ n) (D' * H') = poly_mod.Mp (p ^ n) C \\<and>\n       monic D' \\<and>\n       D =m D' \\<and>\n       H =m H' \\<and>\n       poly_mod.Mp (p ^ n) D' = D' \\<and> poly_mod.Mp (p ^ n) H' = H'", "obtain D' H' where hensel_result: \"linear_hensel_binary p n C D H = (D',H')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D' H'.\n        linear_hensel_binary p n C D H = (D', H') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  linear_hensel_binary p n C D H = (D', H')\n\ngoal (1 subgoal):\n 1. \\<exists>!(D', H').\n       poly_mod.Mp (p ^ n) (D' * H') = poly_mod.Mp (p ^ n) C \\<and>\n       monic D' \\<and>\n       D =m D' \\<and>\n       H =m H' \\<and>\n       poly_mod.Mp (p ^ n) D' = D' \\<and> poly_mod.Mp (p ^ n) H' = H'", "from m1"], ["proof (chain)\npicking this:\n  1 < p", "have p: \"p > 1\""], ["proof (prove)\nusing this:\n  1 < p\n\ngoal (1 subgoal):\n 1. 1 < p", "."], ["proof (state)\nthis:\n  1 < p\n\ngoal (1 subgoal):\n 1. \\<exists>!(D', H').\n       poly_mod.Mp (p ^ n) (D' * H') = poly_mod.Mp (p ^ n) C \\<and>\n       monic D' \\<and>\n       D =m D' \\<and>\n       H =m H' \\<and>\n       poly_mod.Mp (p ^ n) D' = D' \\<and> poly_mod.Mp (p ^ n) H' = H'", "obtain S T where ext: \"euclid_ext_poly_dynamic p D H = (S,T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>S T.\n        euclid_ext_poly_dynamic p D H = (S, T) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  euclid_ext_poly_dynamic p D H = (S, T)\n\ngoal (1 subgoal):\n 1. \\<exists>!(D', H').\n       poly_mod.Mp (p ^ n) (D' * H') = poly_mod.Mp (p ^ n) C \\<and>\n       monic D' \\<and>\n       D =m D' \\<and>\n       H =m H' \\<and>\n       poly_mod.Mp (p ^ n) D' = D' \\<and> poly_mod.Mp (p ^ n) H' = H'", "obtain D1 H1 where main: \"linear_hensel_main C p S T D H n = (D1,H1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D1 H1.\n        linear_hensel_main C p S T D H n = (D1, H1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  linear_hensel_main C p S T D H n = (D1, H1)\n\ngoal (1 subgoal):\n 1. \\<exists>!(D', H').\n       poly_mod.Mp (p ^ n) (D' * H') = poly_mod.Mp (p ^ n) C \\<and>\n       monic D' \\<and>\n       D =m D' \\<and>\n       H =m H' \\<and>\n       poly_mod.Mp (p ^ n) D' = D' \\<and> poly_mod.Mp (p ^ n) H' = H'", "from hensel_result[unfolded linear_hensel_binary_def ext split Let_def main]"], ["proof (chain)\npicking this:\n  (D1, H1) = (D', H')", "have id: \"D1 = D'\" \"H1 = H'\""], ["proof (prove)\nusing this:\n  (D1, H1) = (D', H')\n\ngoal (1 subgoal):\n 1. D1 = D' &&& H1 = H'", "by auto"], ["proof (state)\nthis:\n  D1 = D'\n  H1 = H'\n\ngoal (1 subgoal):\n 1. \\<exists>!(D', H').\n       poly_mod.Mp (p ^ n) (D' * H') = poly_mod.Mp (p ^ n) C \\<and>\n       monic D' \\<and>\n       D =m D' \\<and>\n       H =m H' \\<and>\n       poly_mod.Mp (p ^ n) D' = D' \\<and> poly_mod.Mp (p ^ n) H' = H'", "note eucl = euclid_ext_poly_dynamic [OF cop normalized_input ext]"], ["proof (state)\nthis:\n  D * S + H * T =m 1\n  Mp S = S\n  Mp T = T\n\ngoal (1 subgoal):\n 1. \\<exists>!(D', H').\n       poly_mod.Mp (p ^ n) (D' * H') = poly_mod.Mp (p ^ n) C \\<and>\n       monic D' \\<and>\n       D =m D' \\<and>\n       H =m H' \\<and>\n       poly_mod.Mp (p ^ n) D' = D' \\<and> poly_mod.Mp (p ^ n) H' = H'", "from linear_hensel_main [OF eucl(1)\n    eq monic_input normalized_input main [unfolded id] n prime cop]"], ["proof (chain)\npicking this:\n  poly_mod.Mp (p ^ n) (D' * H') = poly_mod.Mp (p ^ n) C \\<and>\n  monic D' \\<and>\n  D' =m D \\<and>\n  H' =m H \\<and>\n  poly_mod.Mp (p ^ n) D' = D' \\<and>\n  poly_mod.Mp (p ^ n) H' = H' \\<and>\n  (poly_mod.Mp (p ^ n) (?D' * ?H') = poly_mod.Mp (p ^ n) C \\<longrightarrow>\n   ?D' =m D \\<longrightarrow>\n   ?H' =m H \\<longrightarrow>\n   poly_mod.Mp (p ^ n) ?D' = ?D' \\<longrightarrow>\n   poly_mod.Mp (p ^ n) ?H' = ?H' \\<longrightarrow>\n   monic ?D' \\<longrightarrow> ?D' = D' \\<and> ?H' = H')", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_mod.Mp (p ^ n) (D' * H') = poly_mod.Mp (p ^ n) C \\<and>\n  monic D' \\<and>\n  D' =m D \\<and>\n  H' =m H \\<and>\n  poly_mod.Mp (p ^ n) D' = D' \\<and>\n  poly_mod.Mp (p ^ n) H' = H' \\<and>\n  (poly_mod.Mp (p ^ n) (?D' * ?H') = poly_mod.Mp (p ^ n) C \\<longrightarrow>\n   ?D' =m D \\<longrightarrow>\n   ?H' =m H \\<longrightarrow>\n   poly_mod.Mp (p ^ n) ?D' = ?D' \\<longrightarrow>\n   poly_mod.Mp (p ^ n) ?H' = ?H' \\<longrightarrow>\n   monic ?D' \\<longrightarrow> ?D' = D' \\<and> ?H' = H')\n\ngoal (1 subgoal):\n 1. \\<exists>!(D', H').\n       poly_mod.Mp (p ^ n) (D' * H') = poly_mod.Mp (p ^ n) C \\<and>\n       monic D' \\<and>\n       D =m D' \\<and>\n       H =m H' \\<and>\n       poly_mod.Mp (p ^ n) D' = D' \\<and> poly_mod.Mp (p ^ n) H' = H'", "by (intro ex1I, auto)"], ["proof (state)\nthis:\n  \\<exists>!(D', H').\n     poly_mod.Mp (p ^ n) (D' * H') = poly_mod.Mp (p ^ n) C \\<and>\n     monic D' \\<and>\n     D =m D' \\<and>\n     H =m H' \\<and>\n     poly_mod.Mp (p ^ n) D' = D' \\<and> poly_mod.Mp (p ^ n) H' = H'\n\ngoal:\nNo subgoals!", "qed"], ["", "(* The quadratic lifting is implemented more efficienty.\n   Aim: compute factorization *)"], ["", "context\n  fixes C :: \"int poly\"\nbegin"], ["", "lemma hensel_step_main: assumes \n      one_q: \"poly_mod.eq_m q (D * S + H * T) 1\"\n  and one_p: \"poly_mod.eq_m p (D1 * S1 + H1 * T1) 1\"\n  and CDHq: \"poly_mod.eq_m q C (D * H)\"\n  and D1D: \"poly_mod.eq_m p D1 D\" \n  and H1H: \"poly_mod.eq_m p H1 H\" \n  and S1S: \"poly_mod.eq_m p S1 S\" \n  and T1T: \"poly_mod.eq_m p T1 T\" \n  and mon: \"monic D\" \n  and mon1: \"monic D1\" \n  and q: \"q > 1\" \n  and p: \"p > 1\" \n  and D1: \"poly_mod.Mp p D1 = D1\" \n  and H1: \"poly_mod.Mp p H1 = H1\"\n  and S1: \"poly_mod.Mp p S1 = S1\" \n  and T1: \"poly_mod.Mp p T1 = T1\"\n  and D: \"poly_mod.Mp q D = D\" \n  and H: \"poly_mod.Mp q H = H\"\n  and S: \"poly_mod.Mp q S = S\" \n  and T: \"poly_mod.Mp q T = T\"\n  and U1: \"U1 = poly_mod.Mp p (sdiv_poly (C - D * H) q)\"\n  and dupe1: \"dupe_monic_dynamic p D1 H1 S1 T1 U1 = (A,B)\" \n  and D': \"D' = D + smult q B\"\n  and H': \"H' = H + smult q A\" \n  and U2: \"U2 = poly_mod.Mp q (sdiv_poly (S*D' + T*H' - 1) p)\" \n  and dupe2: \"dupe_monic_dynamic q D H S T U2 = (A',B')\" \n  and rq: \"r = p * q\" \n  and pq: \"p dvd q\"  \n  and S': \"S' = poly_mod.Mp r (S - smult p A')\"\n  and T': \"T' = poly_mod.Mp r (T - smult p B')\" \nshows \"poly_mod.eq_m r C (D' * H')\" \n  \"poly_mod.Mp r D' = D'\" \n  \"poly_mod.Mp r H' = H'\" \n  \"poly_mod.Mp r S' = S'\" \n  \"poly_mod.Mp r T' = T'\" \n  \"poly_mod.eq_m r (D' * S' + H' * T') 1\" \n  \"monic D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_mod.Mp r C = poly_mod.Mp r (D' * H') &&&\n     poly_mod.Mp r D' = D' &&& poly_mod.Mp r H' = H') &&&\n    (poly_mod.Mp r S' = S' &&& poly_mod.Mp r T' = T') &&&\n    poly_mod.Mp r (D' * S' + H' * T') = poly_mod.Mp r 1 &&& monic D'", "unfolding rq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_mod.Mp (p * q) C = poly_mod.Mp (p * q) (D' * H') &&&\n     poly_mod.Mp (p * q) D' = D' &&& poly_mod.Mp (p * q) H' = H') &&&\n    (poly_mod.Mp (p * q) S' = S' &&& poly_mod.Mp (p * q) T' = T') &&&\n    poly_mod.Mp (p * q) (D' * S' + H' * T') = poly_mod.Mp (p * q) 1 &&&\n    monic D'", "proof -"], ["proof (state)\ngoal (7 subgoals):\n 1. poly_mod.Mp (p * q) C = poly_mod.Mp (p * q) (D' * H')\n 2. poly_mod.Mp (p * q) D' = D'\n 3. poly_mod.Mp (p * q) H' = H'\n 4. poly_mod.Mp (p * q) S' = S'\n 5. poly_mod.Mp (p * q) T' = T'\n 6. poly_mod.Mp (p * q) (D' * S' + H' * T') = poly_mod.Mp (p * q) 1\n 7. monic D'", "from pq"], ["proof (chain)\npicking this:\n  p dvd q", "obtain k where qp: \"q = p * k\""], ["proof (prove)\nusing this:\n  p dvd q\n\ngoal (1 subgoal):\n 1. (\\<And>k. q = p * k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. q = p * k\n\ngoal (1 subgoal):\n 1. (\\<And>k. q = p * k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  q = p * k\n\ngoal (7 subgoals):\n 1. poly_mod.Mp (p * q) C = poly_mod.Mp (p * q) (D' * H')\n 2. poly_mod.Mp (p * q) D' = D'\n 3. poly_mod.Mp (p * q) H' = H'\n 4. poly_mod.Mp (p * q) S' = S'\n 5. poly_mod.Mp (p * q) T' = T'\n 6. poly_mod.Mp (p * q) (D' * S' + H' * T') = poly_mod.Mp (p * q) 1\n 7. monic D'", "from arg_cong[OF qp, of sgn] q p"], ["proof (chain)\npicking this:\n  sgn q = sgn (p * k)\n  1 < q\n  1 < p", "have k0: \"k > 0\""], ["proof (prove)\nusing this:\n  sgn q = sgn (p * k)\n  1 < q\n  1 < p\n\ngoal (1 subgoal):\n 1. 0 < k", "unfolding sgn_mult"], ["proof (prove)\nusing this:\n  sgn q = sgn p * sgn k\n  1 < q\n  1 < p\n\ngoal (1 subgoal):\n 1. 0 < k", "by (auto simp: sgn_1_pos)"], ["proof (state)\nthis:\n  0 < k\n\ngoal (7 subgoals):\n 1. poly_mod.Mp (p * q) C = poly_mod.Mp (p * q) (D' * H')\n 2. poly_mod.Mp (p * q) D' = D'\n 3. poly_mod.Mp (p * q) H' = H'\n 4. poly_mod.Mp (p * q) S' = S'\n 5. poly_mod.Mp (p * q) T' = T'\n 6. poly_mod.Mp (p * q) (D' * S' + H' * T') = poly_mod.Mp (p * q) 1\n 7. monic D'", "from qp"], ["proof (chain)\npicking this:\n  q = p * k", "have qq: \"q * q = p * q * k\""], ["proof (prove)\nusing this:\n  q = p * k\n\ngoal (1 subgoal):\n 1. q * q = p * q * k", "by auto"], ["proof (state)\nthis:\n  q * q = p * q * k\n\ngoal (7 subgoals):\n 1. poly_mod.Mp (p * q) C = poly_mod.Mp (p * q) (D' * H')\n 2. poly_mod.Mp (p * q) D' = D'\n 3. poly_mod.Mp (p * q) H' = H'\n 4. poly_mod.Mp (p * q) S' = S'\n 5. poly_mod.Mp (p * q) T' = T'\n 6. poly_mod.Mp (p * q) (D' * S' + H' * T') = poly_mod.Mp (p * q) 1\n 7. monic D'", "let ?r = \"p * q\""], ["proof (state)\ngoal (7 subgoals):\n 1. poly_mod.Mp (p * q) C = poly_mod.Mp (p * q) (D' * H')\n 2. poly_mod.Mp (p * q) D' = D'\n 3. poly_mod.Mp (p * q) H' = H'\n 4. poly_mod.Mp (p * q) S' = S'\n 5. poly_mod.Mp (p * q) T' = T'\n 6. poly_mod.Mp (p * q) (D' * S' + H' * T') = poly_mod.Mp (p * q) 1\n 7. monic D'", "interpret poly_mod_2 p"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_2 p", "by (standard, insert p, auto)"], ["proof (state)\ngoal (7 subgoals):\n 1. poly_mod.Mp (p * q) C = poly_mod.Mp (p * q) (D' * H')\n 2. poly_mod.Mp (p * q) D' = D'\n 3. poly_mod.Mp (p * q) H' = H'\n 4. poly_mod.Mp (p * q) S' = S'\n 5. poly_mod.Mp (p * q) T' = T'\n 6. poly_mod.Mp (p * q) (D' * S' + H' * T') = poly_mod.Mp (p * q) 1\n 7. monic D'", "interpret q: poly_mod_2 q"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_2 q", "by (standard, insert q, auto)"], ["proof (state)\ngoal (7 subgoals):\n 1. poly_mod.Mp (p * q) C = poly_mod.Mp (p * q) (D' * H')\n 2. poly_mod.Mp (p * q) D' = D'\n 3. poly_mod.Mp (p * q) H' = H'\n 4. poly_mod.Mp (p * q) S' = S'\n 5. poly_mod.Mp (p * q) T' = T'\n 6. poly_mod.Mp (p * q) (D' * S' + H' * T') = poly_mod.Mp (p * q) 1\n 7. monic D'", "from p q"], ["proof (chain)\npicking this:\n  1 < p\n  1 < q", "have r: \"?r > 1\""], ["proof (prove)\nusing this:\n  1 < p\n  1 < q\n\ngoal (1 subgoal):\n 1. 1 < p * q", "by (simp add: less_1_mult)"], ["proof (state)\nthis:\n  1 < p * q\n\ngoal (7 subgoals):\n 1. poly_mod.Mp (p * q) C = poly_mod.Mp (p * q) (D' * H')\n 2. poly_mod.Mp (p * q) D' = D'\n 3. poly_mod.Mp (p * q) H' = H'\n 4. poly_mod.Mp (p * q) S' = S'\n 5. poly_mod.Mp (p * q) T' = T'\n 6. poly_mod.Mp (p * q) (D' * S' + H' * T') = poly_mod.Mp (p * q) 1\n 7. monic D'", "interpret r: poly_mod_2 ?r"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_2 (p * q)", "using r"], ["proof (prove)\nusing this:\n  1 < p * q\n\ngoal (1 subgoal):\n 1. poly_mod_2 (p * q)", "unfolding poly_mod_2_def"], ["proof (prove)\nusing this:\n  1 < p * q\n\ngoal (1 subgoal):\n 1. 1 < p * q", "."], ["proof (state)\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "have Mp_conv: \"Mp (q.Mp x) = Mp x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. q.Mp x =m x", "unfolding qp"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.Mp (p * k) x =m x", "by (rule Mp_product_modulus[OF refl k0])"], ["proof (state)\nthis:\n  q.Mp ?x =m ?x\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "from arg_cong[OF CDHq, of Mp, unfolded Mp_conv]"], ["proof (chain)\npicking this:\n  C =m D * H", "have \"Mp C = Mp (Mp D * Mp H)\""], ["proof (prove)\nusing this:\n  C =m D * H\n\ngoal (1 subgoal):\n 1. C =m Mp D * Mp H", "by simp"], ["proof (state)\nthis:\n  C =m Mp D * Mp H\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "also"], ["proof (state)\nthis:\n  C =m Mp D * Mp H\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "have \"Mp D = Mp D1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D =m D1", "using D1D"], ["proof (prove)\nusing this:\n  D1 =m D\n\ngoal (1 subgoal):\n 1. D =m D1", "by simp"], ["proof (state)\nthis:\n  D =m D1\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "also"], ["proof (state)\nthis:\n  D =m D1\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "have \"Mp H = Mp H1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H =m H1", "using H1H"], ["proof (prove)\nusing this:\n  H1 =m H\n\ngoal (1 subgoal):\n 1. H =m H1", "by simp"], ["proof (state)\nthis:\n  H =m H1\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "finally"], ["proof (chain)\npicking this:\n  C =m Mp D1 * Mp H1", "have CDHp: \"eq_m C (D1 * H1)\""], ["proof (prove)\nusing this:\n  C =m Mp D1 * Mp H1\n\ngoal (1 subgoal):\n 1. C =m D1 * H1", "by simp"], ["proof (state)\nthis:\n  C =m D1 * H1\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "have \"Mp U1 = U1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp U1 = U1", "unfolding U1"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (sdiv_poly (C - D * H) q) =m sdiv_poly (C - D * H) q", "by simp"], ["proof (state)\nthis:\n  Mp U1 = U1\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "note dupe1 = dupe_monic_dynamic[OF dupe1 one_p mon1 D1 H1 S1 T1 this]"], ["proof (state)\nthis:\n  A * D1 + B * H1 =m U1\n  B = 0 \\<or> degree B < degree D1\n  Mp A = A\n  Mp B = B\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "have \"q.Mp U2 = U2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q.Mp U2 = U2", "unfolding U2"], ["proof (prove)\ngoal (1 subgoal):\n 1. q.eq_m (q.Mp (sdiv_poly (S * D' + T * H' - 1) p))\n     (sdiv_poly (S * D' + T * H' - 1) p)", "by simp"], ["proof (state)\nthis:\n  q.Mp U2 = U2\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "note dupe2 = q.dupe_monic_dynamic[OF dupe2 one_q mon D H S T this]"], ["proof (state)\nthis:\n  q.eq_m (A' * D + B' * H) U2\n  B' = 0 \\<or> degree B' < degree D\n  q.Mp A' = A'\n  q.Mp B' = B'\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "from CDHq"], ["proof (chain)\npicking this:\n  q.eq_m C (D * H)", "have \"q.Mp C - q.Mp (D * H) = 0\""], ["proof (prove)\nusing this:\n  q.eq_m C (D * H)\n\ngoal (1 subgoal):\n 1. q.Mp C - q.Mp (D * H) = 0", "by simp"], ["proof (state)\nthis:\n  q.Mp C - q.Mp (D * H) = 0\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "hence \"q.Mp (q.Mp C - q.Mp (D * H)) = 0\""], ["proof (prove)\nusing this:\n  q.Mp C - q.Mp (D * H) = 0\n\ngoal (1 subgoal):\n 1. q.Mp (q.Mp C - q.Mp (D * H)) = 0", "by simp"], ["proof (state)\nthis:\n  q.Mp (q.Mp C - q.Mp (D * H)) = 0\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "hence \"q.Mp (C - D*H) = 0\""], ["proof (prove)\nusing this:\n  q.Mp (q.Mp C - q.Mp (D * H)) = 0\n\ngoal (1 subgoal):\n 1. q.Mp (C - D * H) = 0", "by simp"], ["proof (state)\nthis:\n  q.Mp (C - D * H) = 0\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "from q.Mp_0_smult_sdiv_poly[OF this]"], ["proof (chain)\npicking this:\n  Polynomial.smult q (sdiv_poly (C - D * H) q) = C - D * H", "have CDHq: \"smult q (sdiv_poly (C - D * H) q) = C - D * H\""], ["proof (prove)\nusing this:\n  Polynomial.smult q (sdiv_poly (C - D * H) q) = C - D * H\n\ngoal (1 subgoal):\n 1. Polynomial.smult q (sdiv_poly (C - D * H) q) = C - D * H", "."], ["proof (state)\nthis:\n  Polynomial.smult q (sdiv_poly (C - D * H) q) = C - D * H\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "{"], ["proof (state)\nthis:\n  Polynomial.smult q (sdiv_poly (C - D * H) q) = C - D * H\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "fix A B"], ["proof (state)\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "have \"Mp (A * D1 + B * H1) = Mp (Mp (A * D1) + Mp (B * H1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * D1 + B * H1 =m Mp (A * D1) + Mp (B * H1)", "by simp"], ["proof (state)\nthis:\n  A * D1 + B * H1 =m Mp (A * D1) + Mp (B * H1)\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "also"], ["proof (state)\nthis:\n  A * D1 + B * H1 =m Mp (A * D1) + Mp (B * H1)\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "have \"Mp (A * D1) = Mp (A * Mp D1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * D1 =m A * Mp D1", "by simp"], ["proof (state)\nthis:\n  A * D1 =m A * Mp D1\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "also"], ["proof (state)\nthis:\n  A * D1 =m A * Mp D1\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "have \"\\<dots> = Mp (A * D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * Mp D1 =m A * D", "unfolding D1D"], ["proof (prove)\ngoal (1 subgoal):\n 1. A * Mp D =m A * D", "by simp"], ["proof (state)\nthis:\n  A * Mp D1 =m A * D\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "also"], ["proof (state)\nthis:\n  A * Mp D1 =m A * D\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "have \"Mp (B * H1) = Mp (B * Mp H1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B * H1 =m B * Mp H1", "by simp"], ["proof (state)\nthis:\n  B * H1 =m B * Mp H1\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "also"], ["proof (state)\nthis:\n  B * H1 =m B * Mp H1\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "have \"\\<dots> = Mp (B * H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B * Mp H1 =m B * H", "unfolding H1H"], ["proof (prove)\ngoal (1 subgoal):\n 1. B * Mp H =m B * H", "by simp"], ["proof (state)\nthis:\n  B * Mp H1 =m B * H\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "finally"], ["proof (chain)\npicking this:\n  A * D1 + B * H1 =m Mp (A * D) + Mp (B * H)", "have \"Mp (A * D1 + B * H1) = Mp (A * D + B * H)\""], ["proof (prove)\nusing this:\n  A * D1 + B * H1 =m Mp (A * D) + Mp (B * H)\n\ngoal (1 subgoal):\n 1. A * D1 + B * H1 =m A * D + B * H", "by simp"], ["proof (state)\nthis:\n  A * D1 + B * H1 =m A * D + B * H\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "}"], ["proof (state)\nthis:\n  ?Aa2 * D1 + ?Ba2 * H1 =m ?Aa2 * D + ?Ba2 * H\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "note D1H1 = this"], ["proof (state)\nthis:\n  ?Aa2 * D1 + ?Ba2 * H1 =m ?Aa2 * D + ?Ba2 * H\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "have \"r.Mp (D' * H') = r.Mp ((D + smult q B) * (H + smult q A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r.eq_m (D' * H')\n     ((D + Polynomial.smult q B) * (H + Polynomial.smult q A))", "unfolding D' H'"], ["proof (prove)\ngoal (1 subgoal):\n 1. r.eq_m ((D + Polynomial.smult q B) * (H + Polynomial.smult q A))\n     ((D + Polynomial.smult q B) * (H + Polynomial.smult q A))", "by simp"], ["proof (state)\nthis:\n  r.eq_m (D' * H') ((D + Polynomial.smult q B) * (H + Polynomial.smult q A))\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "also"], ["proof (state)\nthis:\n  r.eq_m (D' * H') ((D + Polynomial.smult q B) * (H + Polynomial.smult q A))\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "have \"(D + smult q B) * (H + smult q A) = (D * H + smult q (A * D + B * H)) + smult (q * q) (A * B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (D + Polynomial.smult q B) * (H + Polynomial.smult q A) =\n    D * H + Polynomial.smult q (A * D + B * H) +\n    Polynomial.smult (q * q) (A * B)", "by (simp add: field_simps smult_distribs)"], ["proof (state)\nthis:\n  (D + Polynomial.smult q B) * (H + Polynomial.smult q A) =\n  D * H + Polynomial.smult q (A * D + B * H) +\n  Polynomial.smult (q * q) (A * B)\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "also"], ["proof (state)\nthis:\n  (D + Polynomial.smult q B) * (H + Polynomial.smult q A) =\n  D * H + Polynomial.smult q (A * D + B * H) +\n  Polynomial.smult (q * q) (A * B)\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "have \"r.Mp \\<dots> = r.Mp (D * H + r.Mp (smult q (A * D + B * H)) + r.Mp (smult (q * q) (A * B)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r.eq_m\n     (D * H + Polynomial.smult q (A * D + B * H) +\n      Polynomial.smult (q * q) (A * B))\n     (D * H + r.Mp (Polynomial.smult q (A * D + B * H)) +\n      r.Mp (Polynomial.smult (q * q) (A * B)))", "using r.plus_Mp"], ["proof (prove)\nusing this:\n  r.eq_m (r.Mp ?f + ?g) (?f + ?g)\n  r.eq_m (?f + r.Mp ?g) (?f + ?g)\n\ngoal (1 subgoal):\n 1. r.eq_m\n     (D * H + Polynomial.smult q (A * D + B * H) +\n      Polynomial.smult (q * q) (A * B))\n     (D * H + r.Mp (Polynomial.smult q (A * D + B * H)) +\n      r.Mp (Polynomial.smult (q * q) (A * B)))", "by metis"], ["proof (state)\nthis:\n  r.eq_m\n   (D * H + Polynomial.smult q (A * D + B * H) +\n    Polynomial.smult (q * q) (A * B))\n   (D * H + r.Mp (Polynomial.smult q (A * D + B * H)) +\n    r.Mp (Polynomial.smult (q * q) (A * B)))\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "also"], ["proof (state)\nthis:\n  r.eq_m\n   (D * H + Polynomial.smult q (A * D + B * H) +\n    Polynomial.smult (q * q) (A * B))\n   (D * H + r.Mp (Polynomial.smult q (A * D + B * H)) +\n    r.Mp (Polynomial.smult (q * q) (A * B)))\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "have \"r.Mp (smult (q * q) (A * B)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r.Mp (Polynomial.smult (q * q) (A * B)) = 0", "unfolding qq"], ["proof (prove)\ngoal (1 subgoal):\n 1. r.Mp (Polynomial.smult (p * q * k) (A * B)) = 0", "by (metis r.Mp_smult_m_0 smult_smult)"], ["proof (state)\nthis:\n  r.Mp (Polynomial.smult (q * q) (A * B)) = 0\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "also"], ["proof (state)\nthis:\n  r.Mp (Polynomial.smult (q * q) (A * B)) = 0\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "have \"r.Mp (smult q (A * D + B * H)) = r.Mp (smult q U1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r.eq_m (Polynomial.smult q (A * D + B * H)) (Polynomial.smult q U1)", "proof (rule Mp_lift_modulus[of _ _ q])"], ["proof (state)\ngoal (1 subgoal):\n 1. A * D + B * H =m U1", "show \"Mp (A * D + B * H) = Mp U1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * D + B * H =m U1", "using dupe1(1)"], ["proof (prove)\nusing this:\n  A * D1 + B * H1 =m U1\n\ngoal (1 subgoal):\n 1. A * D + B * H =m U1", "unfolding D1H1"], ["proof (prove)\nusing this:\n  A * D + B * H =m U1\n\ngoal (1 subgoal):\n 1. A * D + B * H =m U1", "by simp"], ["proof (state)\nthis:\n  A * D + B * H =m U1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r.eq_m (Polynomial.smult q (A * D + B * H)) (Polynomial.smult q U1)\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "also"], ["proof (state)\nthis:\n  r.eq_m (Polynomial.smult q (A * D + B * H)) (Polynomial.smult q U1)\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "have \"\\<dots> = r.Mp (C - D * H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r.eq_m (Polynomial.smult q U1) (C - D * H)", "unfolding arg_cong[OF CDHq, of r.Mp, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. r.eq_m (Polynomial.smult q U1)\n     (Polynomial.smult q (sdiv_poly (C - D * H) q))", "using Mp_lift_modulus[of U1 \"sdiv_poly (C - D * H) q\" q]"], ["proof (prove)\nusing this:\n  U1 =m sdiv_poly (C - D * H) q \\<Longrightarrow>\n  r.eq_m (Polynomial.smult q U1)\n   (Polynomial.smult q (sdiv_poly (C - D * H) q))\n\ngoal (1 subgoal):\n 1. r.eq_m (Polynomial.smult q U1)\n     (Polynomial.smult q (sdiv_poly (C - D * H) q))", "unfolding U1"], ["proof (prove)\nusing this:\n  Mp (sdiv_poly (C - D * H) q) =m sdiv_poly (C - D * H) q \\<Longrightarrow>\n  r.eq_m (Polynomial.smult q (Mp (sdiv_poly (C - D * H) q)))\n   (Polynomial.smult q (sdiv_poly (C - D * H) q))\n\ngoal (1 subgoal):\n 1. r.eq_m (Polynomial.smult q (Mp (sdiv_poly (C - D * H) q)))\n     (Polynomial.smult q (sdiv_poly (C - D * H) q))", "by simp"], ["proof (state)\nthis:\n  r.eq_m (Polynomial.smult q U1) (C - D * H)\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "also"], ["proof (state)\nthis:\n  r.eq_m (Polynomial.smult q U1) (C - D * H)\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "have \"r.Mp (D * H + r.Mp (C - D * H) + 0) = r.Mp C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r.eq_m (D * H + r.Mp (C - D * H) + 0) C", "by simp"], ["proof (state)\nthis:\n  r.eq_m (D * H + r.Mp (C - D * H) + 0) C\n\ngoal (7 subgoals):\n 1. r.eq_m C (D' * H')\n 2. r.Mp D' = D'\n 3. r.Mp H' = H'\n 4. r.Mp S' = S'\n 5. r.Mp T' = T'\n 6. r.eq_m (D' * S' + H' * T') 1\n 7. monic D'", "finally"], ["proof (chain)\npicking this:\n  r.eq_m (D' * H') C", "show CDH: \"r.eq_m C (D' * H')\""], ["proof (prove)\nusing this:\n  r.eq_m (D' * H') C\n\ngoal (1 subgoal):\n 1. r.eq_m C (D' * H')", "by simp"], ["proof (state)\nthis:\n  r.eq_m C (D' * H')\n\ngoal (6 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1\n 6. monic D'", "have \"degree D1 = degree (Mp D1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree D1 = degree_m D1", "using mon1"], ["proof (prove)\nusing this:\n  monic D1\n\ngoal (1 subgoal):\n 1. degree D1 = degree_m D1", "by simp"], ["proof (state)\nthis:\n  degree D1 = degree_m D1\n\ngoal (6 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1\n 6. monic D'", "also"], ["proof (state)\nthis:\n  degree D1 = degree_m D1\n\ngoal (6 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1\n 6. monic D'", "have \"\\<dots> = degree D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m D1 = degree D", "unfolding D1D"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m D = degree D", "using mon"], ["proof (prove)\nusing this:\n  monic D\n\ngoal (1 subgoal):\n 1. degree_m D = degree D", "by simp"], ["proof (state)\nthis:\n  degree_m D1 = degree D\n\ngoal (6 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1\n 6. monic D'", "finally"], ["proof (chain)\npicking this:\n  degree D1 = degree D", "have deg_eq: \"degree D1 = degree D\""], ["proof (prove)\nusing this:\n  degree D1 = degree D\n\ngoal (1 subgoal):\n 1. degree D1 = degree D", "by simp"], ["proof (state)\nthis:\n  degree D1 = degree D\n\ngoal (6 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1\n 6. monic D'", "show mon: \"monic D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic D'", "unfolding D'"], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (D + Polynomial.smult q B)", "using dupe1(2) mon"], ["proof (prove)\nusing this:\n  B = 0 \\<or> degree B < degree D1\n  monic D\n\ngoal (1 subgoal):\n 1. monic (D + Polynomial.smult q B)", "unfolding deg_eq"], ["proof (prove)\nusing this:\n  B = 0 \\<or> degree B < degree D\n  monic D\n\ngoal (1 subgoal):\n 1. monic (D + Polynomial.smult q B)", "by (rule monic_smult_add_small)"], ["proof (state)\nthis:\n  monic D'\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "have \"Mp (S * D' + T * H' - 1) = Mp (Mp (D * S + H * T) + (smult q (S * B + T * A) - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S * D' + T * H' - 1 =m\n    Mp (D * S + H * T) + (Polynomial.smult q (S * B + T * A) - 1)", "unfolding D' H' plus_Mp"], ["proof (prove)\ngoal (1 subgoal):\n 1. S * (D + Polynomial.smult q B) + T * (H + Polynomial.smult q A) - 1 =m\n    D * S + H * T + (Polynomial.smult q (S * B + T * A) - 1)", "by (simp add: field_simps smult_distribs)"], ["proof (state)\nthis:\n  S * D' + T * H' - 1 =m\n  Mp (D * S + H * T) + (Polynomial.smult q (S * B + T * A) - 1)\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "also"], ["proof (state)\nthis:\n  S * D' + T * H' - 1 =m\n  Mp (D * S + H * T) + (Polynomial.smult q (S * B + T * A) - 1)\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "have \"Mp (D * S + H * T) = Mp (Mp (D1 * Mp S) + Mp (H1 * Mp T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D * S + H * T =m Mp (D1 * Mp S) + Mp (H1 * Mp T)", "using  D1H1[of S T]"], ["proof (prove)\nusing this:\n  S * D1 + T * H1 =m S * D + T * H\n\ngoal (1 subgoal):\n 1. D * S + H * T =m Mp (D1 * Mp S) + Mp (H1 * Mp T)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  D * S + H * T =m Mp (D1 * Mp S) + Mp (H1 * Mp T)\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "also"], ["proof (state)\nthis:\n  D * S + H * T =m Mp (D1 * Mp S) + Mp (H1 * Mp T)\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (Mp (D1 * Mp S) + Mp (H1 * Mp T)) = 1", "using one_p"], ["proof (prove)\nusing this:\n  D1 * S1 + H1 * T1 =m 1\n\ngoal (1 subgoal):\n 1. Mp (Mp (D1 * Mp S) + Mp (H1 * Mp T)) = 1", "unfolding S1S[symmetric] T1T[symmetric]"], ["proof (prove)\nusing this:\n  D1 * S1 + H1 * T1 =m 1\n\ngoal (1 subgoal):\n 1. Mp (Mp (D1 * Mp S1) + Mp (H1 * Mp T1)) = 1", "by simp"], ["proof (state)\nthis:\n  Mp (Mp (D1 * Mp S) + Mp (H1 * Mp T)) = 1\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "also"], ["proof (state)\nthis:\n  Mp (Mp (D1 * Mp S) + Mp (H1 * Mp T)) = 1\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "have \"Mp (1 + (smult q (S * B + T * A) - 1)) = Mp (smult q (S * B + T * A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + (Polynomial.smult q (S * B + T * A) - 1) =m\n    Polynomial.smult q (S * B + T * A)", "by simp"], ["proof (state)\nthis:\n  1 + (Polynomial.smult q (S * B + T * A) - 1) =m\n  Polynomial.smult q (S * B + T * A)\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "also"], ["proof (state)\nthis:\n  1 + (Polynomial.smult q (S * B + T * A) - 1) =m\n  Polynomial.smult q (S * B + T * A)\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (Polynomial.smult q (S * B + T * A)) = 0", "unfolding qp"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (Polynomial.smult (p * k) (S * B + T * A)) = 0", "by (metis Mp_smult_m_0 smult_smult)"], ["proof (state)\nthis:\n  Mp (Polynomial.smult q (S * B + T * A)) = 0\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "finally"], ["proof (chain)\npicking this:\n  Mp (S * D' + T * H' - 1) = 0", "have \"Mp (S * D' + T * H' - 1) = 0\""], ["proof (prove)\nusing this:\n  Mp (S * D' + T * H' - 1) = 0\n\ngoal (1 subgoal):\n 1. Mp (S * D' + T * H' - 1) = 0", "."], ["proof (state)\nthis:\n  Mp (S * D' + T * H' - 1) = 0\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "from Mp_0_smult_sdiv_poly[OF this]"], ["proof (chain)\npicking this:\n  Polynomial.smult p (sdiv_poly (S * D' + T * H' - 1) p) =\n  S * D' + T * H' - 1", "have SDTH: \"smult p (sdiv_poly (S * D' + T * H' - 1) p) = S * D' + T * H' - 1\""], ["proof (prove)\nusing this:\n  Polynomial.smult p (sdiv_poly (S * D' + T * H' - 1) p) =\n  S * D' + T * H' - 1\n\ngoal (1 subgoal):\n 1. Polynomial.smult p (sdiv_poly (S * D' + T * H' - 1) p) =\n    S * D' + T * H' - 1", "."], ["proof (state)\nthis:\n  Polynomial.smult p (sdiv_poly (S * D' + T * H' - 1) p) =\n  S * D' + T * H' - 1\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "have swap: \"q * p = p * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q * p = p * q", "by simp"], ["proof (state)\nthis:\n  q * p = p * q\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "have \"r.Mp (D' * S' + H' * T') = \n    r.Mp ((D + smult q B) * (S - smult p A') + (H + smult q A) * (T - smult p B'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r.eq_m (D' * S' + H' * T')\n     ((D + Polynomial.smult q B) * (S - Polynomial.smult p A') +\n      (H + Polynomial.smult q A) * (T - Polynomial.smult p B'))", "unfolding D' S' H' T' rq"], ["proof (prove)\ngoal (1 subgoal):\n 1. r.eq_m\n     ((D + Polynomial.smult q B) * r.Mp (S - Polynomial.smult p A') +\n      (H + Polynomial.smult q A) * r.Mp (T - Polynomial.smult p B'))\n     ((D + Polynomial.smult q B) * (S - Polynomial.smult p A') +\n      (H + Polynomial.smult q A) * (T - Polynomial.smult p B'))", "using r.plus_Mp r.mult_Mp"], ["proof (prove)\nusing this:\n  r.eq_m (r.Mp ?f + ?g) (?f + ?g)\n  r.eq_m (?f + r.Mp ?g) (?f + ?g)\n  r.eq_m (r.Mp ?f * ?g) (?f * ?g)\n  r.eq_m (?f * r.Mp ?g) (?f * ?g)\n\ngoal (1 subgoal):\n 1. r.eq_m\n     ((D + Polynomial.smult q B) * r.Mp (S - Polynomial.smult p A') +\n      (H + Polynomial.smult q A) * r.Mp (T - Polynomial.smult p B'))\n     ((D + Polynomial.smult q B) * (S - Polynomial.smult p A') +\n      (H + Polynomial.smult q A) * (T - Polynomial.smult p B'))", "by metis"], ["proof (state)\nthis:\n  r.eq_m (D' * S' + H' * T')\n   ((D + Polynomial.smult q B) * (S - Polynomial.smult p A') +\n    (H + Polynomial.smult q A) * (T - Polynomial.smult p B'))\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "also"], ["proof (state)\nthis:\n  r.eq_m (D' * S' + H' * T')\n   ((D + Polynomial.smult q B) * (S - Polynomial.smult p A') +\n    (H + Polynomial.smult q A) * (T - Polynomial.smult p B'))\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "have \"\\<dots> = r.Mp ((D * S + H * T +\n    smult q (B * S + A * T)) - smult p (A' * D + B' * H) - smult ?r (A * B' + B * A'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r.eq_m\n     ((D + Polynomial.smult q B) * (S - Polynomial.smult p A') +\n      (H + Polynomial.smult q A) * (T - Polynomial.smult p B'))\n     (D * S + H * T + Polynomial.smult q (B * S + A * T) -\n      Polynomial.smult p (A' * D + B' * H) -\n      Polynomial.smult (p * q) (A * B' + B * A'))", "by (simp add: field_simps smult_distribs)"], ["proof (state)\nthis:\n  r.eq_m\n   ((D + Polynomial.smult q B) * (S - Polynomial.smult p A') +\n    (H + Polynomial.smult q A) * (T - Polynomial.smult p B'))\n   (D * S + H * T + Polynomial.smult q (B * S + A * T) -\n    Polynomial.smult p (A' * D + B' * H) -\n    Polynomial.smult (p * q) (A * B' + B * A'))\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "also"], ["proof (state)\nthis:\n  r.eq_m\n   ((D + Polynomial.smult q B) * (S - Polynomial.smult p A') +\n    (H + Polynomial.smult q A) * (T - Polynomial.smult p B'))\n   (D * S + H * T + Polynomial.smult q (B * S + A * T) -\n    Polynomial.smult p (A' * D + B' * H) -\n    Polynomial.smult (p * q) (A * B' + B * A'))\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "have \"\\<dots> = r.Mp ((D * S + H * T +\n    smult q (B * S + A * T)) - r.Mp (smult p (A' * D + B' * H)) - r.Mp (smult ?r (A * B' + B * A')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r.eq_m\n     (D * S + H * T + Polynomial.smult q (B * S + A * T) -\n      Polynomial.smult p (A' * D + B' * H) -\n      Polynomial.smult (p * q) (A * B' + B * A'))\n     (D * S + H * T + Polynomial.smult q (B * S + A * T) -\n      r.Mp (Polynomial.smult p (A' * D + B' * H)) -\n      r.Mp (Polynomial.smult (p * q) (A * B' + B * A')))", "using r.plus_Mp r.minus_Mp"], ["proof (prove)\nusing this:\n  r.eq_m (r.Mp ?f + ?g) (?f + ?g)\n  r.eq_m (?f + r.Mp ?g) (?f + ?g)\n  r.eq_m (r.Mp ?f - ?g) (?f - ?g)\n  r.eq_m (?f - r.Mp ?g) (?f - ?g)\n\ngoal (1 subgoal):\n 1. r.eq_m\n     (D * S + H * T + Polynomial.smult q (B * S + A * T) -\n      Polynomial.smult p (A' * D + B' * H) -\n      Polynomial.smult (p * q) (A * B' + B * A'))\n     (D * S + H * T + Polynomial.smult q (B * S + A * T) -\n      r.Mp (Polynomial.smult p (A' * D + B' * H)) -\n      r.Mp (Polynomial.smult (p * q) (A * B' + B * A')))", "by metis"], ["proof (state)\nthis:\n  r.eq_m\n   (D * S + H * T + Polynomial.smult q (B * S + A * T) -\n    Polynomial.smult p (A' * D + B' * H) -\n    Polynomial.smult (p * q) (A * B' + B * A'))\n   (D * S + H * T + Polynomial.smult q (B * S + A * T) -\n    r.Mp (Polynomial.smult p (A' * D + B' * H)) -\n    r.Mp (Polynomial.smult (p * q) (A * B' + B * A')))\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "also"], ["proof (state)\nthis:\n  r.eq_m\n   (D * S + H * T + Polynomial.smult q (B * S + A * T) -\n    Polynomial.smult p (A' * D + B' * H) -\n    Polynomial.smult (p * q) (A * B' + B * A'))\n   (D * S + H * T + Polynomial.smult q (B * S + A * T) -\n    r.Mp (Polynomial.smult p (A' * D + B' * H)) -\n    r.Mp (Polynomial.smult (p * q) (A * B' + B * A')))\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "have \"r.Mp (smult ?r (A * B' + B * A')) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r.Mp (Polynomial.smult (p * q) (A * B' + B * A')) = 0", "by simp"], ["proof (state)\nthis:\n  r.Mp (Polynomial.smult (p * q) (A * B' + B * A')) = 0\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "also"], ["proof (state)\nthis:\n  r.Mp (Polynomial.smult (p * q) (A * B' + B * A')) = 0\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "have \"r.Mp (smult p (A' * D + B' * H)) = r.Mp (smult p U2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r.eq_m (Polynomial.smult p (A' * D + B' * H)) (Polynomial.smult p U2)", "using q.Mp_lift_modulus[OF dupe2(1), of p]"], ["proof (prove)\nusing this:\n  poly_mod.Mp (q * p) (Polynomial.smult p (A' * D + B' * H)) =\n  poly_mod.Mp (q * p) (Polynomial.smult p U2)\n\ngoal (1 subgoal):\n 1. r.eq_m (Polynomial.smult p (A' * D + B' * H)) (Polynomial.smult p U2)", "unfolding swap"], ["proof (prove)\nusing this:\n  r.eq_m (Polynomial.smult p (A' * D + B' * H)) (Polynomial.smult p U2)\n\ngoal (1 subgoal):\n 1. r.eq_m (Polynomial.smult p (A' * D + B' * H)) (Polynomial.smult p U2)", "."], ["proof (state)\nthis:\n  r.eq_m (Polynomial.smult p (A' * D + B' * H)) (Polynomial.smult p U2)\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "also"], ["proof (state)\nthis:\n  r.eq_m (Polynomial.smult p (A' * D + B' * H)) (Polynomial.smult p U2)\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "have \"\\<dots> = r.Mp (S * D' + T * H' - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r.eq_m (Polynomial.smult p U2) (S * D' + T * H' - 1)", "unfolding arg_cong[OF SDTH, of r.Mp, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. r.eq_m (Polynomial.smult p U2)\n     (Polynomial.smult p (sdiv_poly (S * D' + T * H' - 1) p))", "using q.Mp_lift_modulus[of U2 \"sdiv_poly (S * D' + T * H' - 1) p\" p]"], ["proof (prove)\nusing this:\n  q.eq_m U2 (sdiv_poly (S * D' + T * H' - 1) p) \\<Longrightarrow>\n  poly_mod.Mp (q * p) (Polynomial.smult p U2) =\n  poly_mod.Mp (q * p)\n   (Polynomial.smult p (sdiv_poly (S * D' + T * H' - 1) p))\n\ngoal (1 subgoal):\n 1. r.eq_m (Polynomial.smult p U2)\n     (Polynomial.smult p (sdiv_poly (S * D' + T * H' - 1) p))", "unfolding U2 swap"], ["proof (prove)\nusing this:\n  q.eq_m (q.Mp (sdiv_poly (S * D' + T * H' - 1) p))\n   (sdiv_poly (S * D' + T * H' - 1) p) \\<Longrightarrow>\n  r.eq_m (Polynomial.smult p (q.Mp (sdiv_poly (S * D' + T * H' - 1) p)))\n   (Polynomial.smult p (sdiv_poly (S * D' + T * H' - 1) p))\n\ngoal (1 subgoal):\n 1. r.eq_m (Polynomial.smult p (q.Mp (sdiv_poly (S * D' + T * H' - 1) p)))\n     (Polynomial.smult p (sdiv_poly (S * D' + T * H' - 1) p))", "by simp"], ["proof (state)\nthis:\n  r.eq_m (Polynomial.smult p U2) (S * D' + T * H' - 1)\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "also"], ["proof (state)\nthis:\n  r.eq_m (Polynomial.smult p U2) (S * D' + T * H' - 1)\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "have \"S * D' + T * H' - 1 = S * D + T * H + smult q (B * S + A * T) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S * D' + T * H' - 1 =\n    S * D + T * H + Polynomial.smult q (B * S + A * T) - 1", "unfolding D' H'"], ["proof (prove)\ngoal (1 subgoal):\n 1. S * (D + Polynomial.smult q B) + T * (H + Polynomial.smult q A) - 1 =\n    S * D + T * H + Polynomial.smult q (B * S + A * T) - 1", "by (simp add: field_simps smult_distribs)"], ["proof (state)\nthis:\n  S * D' + T * H' - 1 =\n  S * D + T * H + Polynomial.smult q (B * S + A * T) - 1\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "also"], ["proof (state)\nthis:\n  S * D' + T * H' - 1 =\n  S * D + T * H + Polynomial.smult q (B * S + A * T) - 1\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "have \"r.Mp (D * S + H * T + smult q (B * S + A * T) -\n     r.Mp (S * D + T * H + smult q (B * S + A * T) - 1) - 0) \n       = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r.Mp\n     (D * S + H * T + Polynomial.smult q (B * S + A * T) -\n      r.Mp (S * D + T * H + Polynomial.smult q (B * S + A * T) - 1) -\n      0) =\n    1", "by simp"], ["proof (state)\nthis:\n  r.Mp\n   (D * S + H * T + Polynomial.smult q (B * S + A * T) -\n    r.Mp (S * D + T * H + Polynomial.smult q (B * S + A * T) - 1) -\n    0) =\n  1\n\ngoal (5 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'\n 5. r.eq_m (D' * S' + H' * T') 1", "finally"], ["proof (chain)\npicking this:\n  r.Mp (D' * S' + H' * T') = 1", "show 1: \"r.eq_m (D' * S' + H' * T') 1\""], ["proof (prove)\nusing this:\n  r.Mp (D' * S' + H' * T') = 1\n\ngoal (1 subgoal):\n 1. r.eq_m (D' * S' + H' * T') 1", "by simp"], ["proof (state)\nthis:\n  r.eq_m (D' * S' + H' * T') 1\n\ngoal (4 subgoals):\n 1. r.Mp D' = D'\n 2. r.Mp H' = H'\n 3. r.Mp S' = S'\n 4. r.Mp T' = T'", "show D': \"r.Mp D' = D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r.Mp D' = D'", "unfolding D' r.Mp_ident_iff poly_mod.Mp_coeff plus_poly.rep_eq\n    coeff_smult"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. poly.coeff D n + q * poly.coeff B n \\<in> {0..<p * q}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff D n + q * poly.coeff B n \\<in> {0..<p * q}", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff D n + q * poly.coeff B n \\<in> {0..<p * q}", "from D dupe1(4)"], ["proof (chain)\npicking this:\n  q.Mp D = D\n  Mp B = B", "have \"coeff D n \\<in> {0..<q}\" \"coeff B n \\<in> {0..<p}\""], ["proof (prove)\nusing this:\n  q.Mp D = D\n  Mp B = B\n\ngoal (1 subgoal):\n 1. poly.coeff D n \\<in> {0..<q} &&& poly.coeff B n \\<in> {0..<p}", "unfolding q.Mp_ident_iff Mp_ident_iff"], ["proof (prove)\nusing this:\n  \\<forall>n. poly.coeff D n \\<in> {0..<q}\n  \\<forall>n. poly.coeff B n \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. poly.coeff D n \\<in> {0..<q} &&& poly.coeff B n \\<in> {0..<p}", "by auto"], ["proof (state)\nthis:\n  poly.coeff D n \\<in> {0..<q}\n  poly.coeff B n \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff D n + q * poly.coeff B n \\<in> {0..<p * q}", "thus \"coeff D n + q * coeff B n \\<in> {0..<?r}\""], ["proof (prove)\nusing this:\n  poly.coeff D n \\<in> {0..<q}\n  poly.coeff B n \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. poly.coeff D n + q * poly.coeff B n \\<in> {0..<p * q}", "by (metis range_sum_prod)"], ["proof (state)\nthis:\n  poly.coeff D n + q * poly.coeff B n \\<in> {0..<p * q}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r.Mp D' = D'\n\ngoal (3 subgoals):\n 1. r.Mp H' = H'\n 2. r.Mp S' = S'\n 3. r.Mp T' = T'", "show H': \"r.Mp H' = H'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r.Mp H' = H'", "unfolding H' r.Mp_ident_iff poly_mod.Mp_coeff plus_poly.rep_eq\n    coeff_smult"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. poly.coeff H n + q * poly.coeff A n \\<in> {0..<p * q}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff H n + q * poly.coeff A n \\<in> {0..<p * q}", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff H n + q * poly.coeff A n \\<in> {0..<p * q}", "from H dupe1(3)"], ["proof (chain)\npicking this:\n  q.Mp H = H\n  Mp A = A", "have \"coeff H n \\<in> {0..<q}\" \"coeff A n \\<in> {0..<p}\""], ["proof (prove)\nusing this:\n  q.Mp H = H\n  Mp A = A\n\ngoal (1 subgoal):\n 1. poly.coeff H n \\<in> {0..<q} &&& poly.coeff A n \\<in> {0..<p}", "unfolding q.Mp_ident_iff Mp_ident_iff"], ["proof (prove)\nusing this:\n  \\<forall>n. poly.coeff H n \\<in> {0..<q}\n  \\<forall>n. poly.coeff A n \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. poly.coeff H n \\<in> {0..<q} &&& poly.coeff A n \\<in> {0..<p}", "by auto"], ["proof (state)\nthis:\n  poly.coeff H n \\<in> {0..<q}\n  poly.coeff A n \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. \\<And>n. poly.coeff H n + q * poly.coeff A n \\<in> {0..<p * q}", "thus \"coeff H n + q * coeff A n \\<in> {0..<?r}\""], ["proof (prove)\nusing this:\n  poly.coeff H n \\<in> {0..<q}\n  poly.coeff A n \\<in> {0..<p}\n\ngoal (1 subgoal):\n 1. poly.coeff H n + q * poly.coeff A n \\<in> {0..<p * q}", "by (metis range_sum_prod)"], ["proof (state)\nthis:\n  poly.coeff H n + q * poly.coeff A n \\<in> {0..<p * q}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r.Mp H' = H'\n\ngoal (2 subgoals):\n 1. r.Mp S' = S'\n 2. r.Mp T' = T'", "show \"poly_mod.Mp ?r S' = S'\" \"poly_mod.Mp ?r T' = T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r.Mp S' = S' &&& r.Mp T' = T'", "unfolding S' T' rq"], ["proof (prove)\ngoal (1 subgoal):\n 1. r.eq_m (r.Mp (S - Polynomial.smult p A'))\n     (S - Polynomial.smult p A') &&&\n    r.eq_m (r.Mp (T - Polynomial.smult p B')) (T - Polynomial.smult p B')", "by auto"], ["proof (state)\nthis:\n  r.Mp S' = S'\n  r.Mp T' = T'\n\ngoal:\nNo subgoals!", "qed"], ["", "definition hensel_step where \n  \"hensel_step p q S1 T1 D1 H1 S T D H = (\n      let U = poly_mod.Mp p (sdiv_poly (C - D * H) q); \\<comment> \\<open>\\<open>Z2 and Z3\\<close>\\<close>        \n        (A,B) = dupe_monic_dynamic p D1 H1 S1 T1 U;\n        D' = D + smult q B; \\<comment> \\<open>\\<open>Z4\\<close>\\<close>\n        H' = H + smult q A;\n        U' = poly_mod.Mp q (sdiv_poly (S*D' + T*H' - 1) p); \\<comment> \\<open>\\<open>Z5 + Z6\\<close>\\<close>\n        (A',B') = dupe_monic_dynamic q D H S T U';\n        q' = p * q;\n        S' = poly_mod.Mp q' (S - smult p A'); \\<comment> \\<open>\\<open>Z7\\<close>\\<close>\n        T' = poly_mod.Mp q' (T - smult p B')\n     in (S',T',D',H'))\""], ["", "definition \"quadratic_hensel_step q S T D H = hensel_step q q S T D H S T D H\""], ["", "lemma quadratic_hensel_step_code[code]:\n  \"quadratic_hensel_step q S T D H =\n    (let dupe = dupe_monic_dynamic q D H S T; \\<comment> \\<open>this will share the conversions of \\<open>D H S T\\<close>\\<close>\n         U = poly_mod.Mp q (sdiv_poly (C - D * H) q); \n         (A, B) = dupe U; \n         D' = D + Polynomial.smult q B;\n         H' = H + Polynomial.smult q A; \n         U' = poly_mod.Mp q (sdiv_poly (S * D' + T * H' - 1) q); \n         (A', B') = dupe U';\n         q' = q * q; \n         S' = poly_mod.Mp q' (S - Polynomial.smult q A'); \n         T' = poly_mod.Mp q' (T - Polynomial.smult q B')\n           in (S', T', D', H'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.quadratic_hensel_step q S T D H =\n    (let dupe = dupe_monic_dynamic q D H S T;\n         U = poly_mod.Mp q (sdiv_poly (C - D * H) q); (A, B) = dupe U;\n         D' = D + Polynomial.smult q B; H' = H + Polynomial.smult q A;\n         U' = poly_mod.Mp q (sdiv_poly (S * D' + T * H' - 1) q);\n         (A', B') = dupe U'; q' = q * q;\n         S' = poly_mod.Mp q' (S - Polynomial.smult q A');\n         T' = poly_mod.Mp q' (T - Polynomial.smult q B')\n     in (S', T', D', H'))", "unfolding quadratic_hensel_step_def[unfolded hensel_step_def] Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case dupe_monic_dynamic q D H S T\n           (poly_mod.Mp q (sdiv_poly (C - D * H) q)) of\n     (A, B) \\<Rightarrow>\n       case dupe_monic_dynamic q D H S T\n             (poly_mod.Mp q\n               (sdiv_poly\n                 (S * (D + Polynomial.smult q B) +\n                  T * (H + Polynomial.smult q A) -\n                  1)\n                 q)) of\n       (A', B') \\<Rightarrow>\n         (poly_mod.Mp (q * q) (S - Polynomial.smult q A'),\n          poly_mod.Mp (q * q) (T - Polynomial.smult q B'),\n          D + Polynomial.smult q B, H + Polynomial.smult q A)) =\n    (case dupe_monic_dynamic q D H S T\n           (poly_mod.Mp q (sdiv_poly (C - D * H) q)) of\n     (A, B) \\<Rightarrow>\n       case dupe_monic_dynamic q D H S T\n             (poly_mod.Mp q\n               (sdiv_poly\n                 (S * (D + Polynomial.smult q B) +\n                  T * (H + Polynomial.smult q A) -\n                  1)\n                 q)) of\n       (A', B') \\<Rightarrow>\n         (poly_mod.Mp (q * q) (S - Polynomial.smult q A'),\n          poly_mod.Mp (q * q) (T - Polynomial.smult q B'),\n          D + Polynomial.smult q B, H + Polynomial.smult q A))", ".."], ["", "definition simple_quadratic_hensel_step where \\<comment> \\<open>do not compute new values \\<open>S'\\<close> and \\<open>T'\\<close>\\<close>\n  \"simple_quadratic_hensel_step q S T D H = (\n      let U = poly_mod.Mp q (sdiv_poly (C - D * H) q); \\<comment> \\<open>\\<open>Z2 + Z3\\<close>\\<close>\n        (A,B) = dupe_monic_dynamic q D H S T U;\n        D' = D + smult q B; \\<comment> \\<open>\\<open>Z4\\<close>\\<close>\n        H' = H + smult q A\n     in (D',H'))\""], ["", "lemma hensel_step: assumes step: \"hensel_step p q S1 T1 D1 H1 S T D H = (S', T', D', H')\"\n  and one_p: \"poly_mod.eq_m p (D1 * S1 + H1 * T1) 1\"\n  and mon1: \"monic D1\" \n  and p: \"p > 1\" \n  and CDHq: \"poly_mod.eq_m q C (D * H)\"\n  and one_q: \"poly_mod.eq_m q (D * S + H * T) 1\"\n  and D1D: \"poly_mod.eq_m p D1 D\"\n  and H1H: \"poly_mod.eq_m p H1 H\"\n  and S1S: \"poly_mod.eq_m p S1 S\"\n  and T1T: \"poly_mod.eq_m p T1 T\"\n  and mon: \"monic D\" \n  and q: \"q > 1\" \n  and D1: \"poly_mod.Mp p D1 = D1\" \n  and H1: \"poly_mod.Mp p H1 = H1\"\n  and S1: \"poly_mod.Mp p S1 = S1\" \n  and T1: \"poly_mod.Mp p T1 = T1\"\n  and D: \"poly_mod.Mp q D = D\" \n  and H: \"poly_mod.Mp q H = H\"\n  and S: \"poly_mod.Mp q S = S\" \n  and T: \"poly_mod.Mp q T = T\"\n  and rq: \"r = p * q\" \n  and pq: \"p dvd q\"  \nshows \n  \"poly_mod.eq_m r C (D' * H')\" \n  \"poly_mod.eq_m r (D' * S' + H' * T') 1\"\n  \"poly_mod.Mp r D' = D'\" \n  \"poly_mod.Mp r H' = H'\" \n  \"poly_mod.Mp r S' = S'\" \n  \"poly_mod.Mp r T' = T'\" \n  \"poly_mod.Mp p D1 = poly_mod.Mp p D'\" \n  \"poly_mod.Mp p H1 = poly_mod.Mp p H'\" \n  \"poly_mod.Mp p S1 = poly_mod.Mp p S'\" \n  \"poly_mod.Mp p T1 = poly_mod.Mp p T'\" \n  \"monic D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((poly_mod.Mp r C = poly_mod.Mp r (D' * H') &&&\n      poly_mod.Mp r (D' * S' + H' * T') = poly_mod.Mp r 1) &&&\n     poly_mod.Mp r D' = D' &&&\n     poly_mod.Mp r H' = H' &&& poly_mod.Mp r S' = S') &&&\n    (poly_mod.Mp r T' = T' &&&\n     poly_mod.Mp p D1 = poly_mod.Mp p D' &&&\n     poly_mod.Mp p H1 = poly_mod.Mp p H') &&&\n    poly_mod.Mp p S1 = poly_mod.Mp p S' &&&\n    poly_mod.Mp p T1 = poly_mod.Mp p T' &&& monic D'", "proof -"], ["proof (state)\ngoal (11 subgoals):\n 1. poly_mod.Mp r C = poly_mod.Mp r (D' * H')\n 2. poly_mod.Mp r (D' * S' + H' * T') = poly_mod.Mp r 1\n 3. poly_mod.Mp r D' = D'\n 4. poly_mod.Mp r H' = H'\n 5. poly_mod.Mp r S' = S'\n 6. poly_mod.Mp r T' = T'\n 7. poly_mod.Mp p D1 = poly_mod.Mp p D'\n 8. poly_mod.Mp p H1 = poly_mod.Mp p H'\n 9. poly_mod.Mp p S1 = poly_mod.Mp p S'\n 10. poly_mod.Mp p T1 = poly_mod.Mp p T'\nA total of 11 subgoals...", "define U where U: \"U = poly_mod.Mp p (sdiv_poly (C - D * H) q)\""], ["proof (state)\nthis:\n  U = poly_mod.Mp p (sdiv_poly (C - D * H) q)\n\ngoal (11 subgoals):\n 1. poly_mod.Mp r C = poly_mod.Mp r (D' * H')\n 2. poly_mod.Mp r (D' * S' + H' * T') = poly_mod.Mp r 1\n 3. poly_mod.Mp r D' = D'\n 4. poly_mod.Mp r H' = H'\n 5. poly_mod.Mp r S' = S'\n 6. poly_mod.Mp r T' = T'\n 7. poly_mod.Mp p D1 = poly_mod.Mp p D'\n 8. poly_mod.Mp p H1 = poly_mod.Mp p H'\n 9. poly_mod.Mp p S1 = poly_mod.Mp p S'\n 10. poly_mod.Mp p T1 = poly_mod.Mp p T'\nA total of 11 subgoals...", "note step = step[unfolded hensel_step_def Let_def, folded U]"], ["proof (state)\nthis:\n  (case dupe_monic_dynamic p D1 H1 S1 T1 U of\n   (A, B) \\<Rightarrow>\n     case dupe_monic_dynamic q D H S T\n           (poly_mod.Mp q\n             (sdiv_poly\n               (S * (D + Polynomial.smult q B) +\n                T * (H + Polynomial.smult q A) -\n                1)\n               p)) of\n     (A', B') \\<Rightarrow>\n       (poly_mod.Mp (p * q) (S - Polynomial.smult p A'),\n        poly_mod.Mp (p * q) (T - Polynomial.smult p B'),\n        D + Polynomial.smult q B, H + Polynomial.smult q A)) =\n  (S', T', D', H')\n\ngoal (11 subgoals):\n 1. poly_mod.Mp r C = poly_mod.Mp r (D' * H')\n 2. poly_mod.Mp r (D' * S' + H' * T') = poly_mod.Mp r 1\n 3. poly_mod.Mp r D' = D'\n 4. poly_mod.Mp r H' = H'\n 5. poly_mod.Mp r S' = S'\n 6. poly_mod.Mp r T' = T'\n 7. poly_mod.Mp p D1 = poly_mod.Mp p D'\n 8. poly_mod.Mp p H1 = poly_mod.Mp p H'\n 9. poly_mod.Mp p S1 = poly_mod.Mp p S'\n 10. poly_mod.Mp p T1 = poly_mod.Mp p T'\nA total of 11 subgoals...", "obtain A B where dupe1: \"dupe_monic_dynamic p D1 H1 S1 T1 U = (A,B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        dupe_monic_dynamic p D1 H1 S1 T1 U = (A, B) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  dupe_monic_dynamic p D1 H1 S1 T1 U = (A, B)\n\ngoal (11 subgoals):\n 1. poly_mod.Mp r C = poly_mod.Mp r (D' * H')\n 2. poly_mod.Mp r (D' * S' + H' * T') = poly_mod.Mp r 1\n 3. poly_mod.Mp r D' = D'\n 4. poly_mod.Mp r H' = H'\n 5. poly_mod.Mp r S' = S'\n 6. poly_mod.Mp r T' = T'\n 7. poly_mod.Mp p D1 = poly_mod.Mp p D'\n 8. poly_mod.Mp p H1 = poly_mod.Mp p H'\n 9. poly_mod.Mp p S1 = poly_mod.Mp p S'\n 10. poly_mod.Mp p T1 = poly_mod.Mp p T'\nA total of 11 subgoals...", "note step = step[unfolded dupe1 split]"], ["proof (state)\nthis:\n  (case dupe_monic_dynamic q D H S T\n         (poly_mod.Mp q\n           (sdiv_poly\n             (S * (D + Polynomial.smult q B) +\n              T * (H + Polynomial.smult q A) -\n              1)\n             p)) of\n   (A', B') \\<Rightarrow>\n     (poly_mod.Mp (p * q) (S - Polynomial.smult p A'),\n      poly_mod.Mp (p * q) (T - Polynomial.smult p B'),\n      D + Polynomial.smult q B, H + Polynomial.smult q A)) =\n  (S', T', D', H')\n\ngoal (11 subgoals):\n 1. poly_mod.Mp r C = poly_mod.Mp r (D' * H')\n 2. poly_mod.Mp r (D' * S' + H' * T') = poly_mod.Mp r 1\n 3. poly_mod.Mp r D' = D'\n 4. poly_mod.Mp r H' = H'\n 5. poly_mod.Mp r S' = S'\n 6. poly_mod.Mp r T' = T'\n 7. poly_mod.Mp p D1 = poly_mod.Mp p D'\n 8. poly_mod.Mp p H1 = poly_mod.Mp p H'\n 9. poly_mod.Mp p S1 = poly_mod.Mp p S'\n 10. poly_mod.Mp p T1 = poly_mod.Mp p T'\nA total of 11 subgoals...", "from step"], ["proof (chain)\npicking this:\n  (case dupe_monic_dynamic q D H S T\n         (poly_mod.Mp q\n           (sdiv_poly\n             (S * (D + Polynomial.smult q B) +\n              T * (H + Polynomial.smult q A) -\n              1)\n             p)) of\n   (A', B') \\<Rightarrow>\n     (poly_mod.Mp (p * q) (S - Polynomial.smult p A'),\n      poly_mod.Mp (p * q) (T - Polynomial.smult p B'),\n      D + Polynomial.smult q B, H + Polynomial.smult q A)) =\n  (S', T', D', H')", "have D': \"D' = D + smult q B\" and H': \"H' = H + smult q A\""], ["proof (prove)\nusing this:\n  (case dupe_monic_dynamic q D H S T\n         (poly_mod.Mp q\n           (sdiv_poly\n             (S * (D + Polynomial.smult q B) +\n              T * (H + Polynomial.smult q A) -\n              1)\n             p)) of\n   (A', B') \\<Rightarrow>\n     (poly_mod.Mp (p * q) (S - Polynomial.smult p A'),\n      poly_mod.Mp (p * q) (T - Polynomial.smult p B'),\n      D + Polynomial.smult q B, H + Polynomial.smult q A)) =\n  (S', T', D', H')\n\ngoal (1 subgoal):\n 1. D' = D + Polynomial.smult q B &&& H' = H + Polynomial.smult q A", "by (auto split: prod.splits)"], ["proof (state)\nthis:\n  D' = D + Polynomial.smult q B\n  H' = H + Polynomial.smult q A\n\ngoal (11 subgoals):\n 1. poly_mod.Mp r C = poly_mod.Mp r (D' * H')\n 2. poly_mod.Mp r (D' * S' + H' * T') = poly_mod.Mp r 1\n 3. poly_mod.Mp r D' = D'\n 4. poly_mod.Mp r H' = H'\n 5. poly_mod.Mp r S' = S'\n 6. poly_mod.Mp r T' = T'\n 7. poly_mod.Mp p D1 = poly_mod.Mp p D'\n 8. poly_mod.Mp p H1 = poly_mod.Mp p H'\n 9. poly_mod.Mp p S1 = poly_mod.Mp p S'\n 10. poly_mod.Mp p T1 = poly_mod.Mp p T'\nA total of 11 subgoals...", "define U' where U': \"U' = poly_mod.Mp q (sdiv_poly (S * D' + T * H' - 1) p)\""], ["proof (state)\nthis:\n  U' = poly_mod.Mp q (sdiv_poly (S * D' + T * H' - 1) p)\n\ngoal (11 subgoals):\n 1. poly_mod.Mp r C = poly_mod.Mp r (D' * H')\n 2. poly_mod.Mp r (D' * S' + H' * T') = poly_mod.Mp r 1\n 3. poly_mod.Mp r D' = D'\n 4. poly_mod.Mp r H' = H'\n 5. poly_mod.Mp r S' = S'\n 6. poly_mod.Mp r T' = T'\n 7. poly_mod.Mp p D1 = poly_mod.Mp p D'\n 8. poly_mod.Mp p H1 = poly_mod.Mp p H'\n 9. poly_mod.Mp p S1 = poly_mod.Mp p S'\n 10. poly_mod.Mp p T1 = poly_mod.Mp p T'\nA total of 11 subgoals...", "obtain A' B' where dupe2: \"dupe_monic_dynamic q D H S T U' = (A',B')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A' B'.\n        dupe_monic_dynamic q D H S T U' = (A', B') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  dupe_monic_dynamic q D H S T U' = (A', B')\n\ngoal (11 subgoals):\n 1. poly_mod.Mp r C = poly_mod.Mp r (D' * H')\n 2. poly_mod.Mp r (D' * S' + H' * T') = poly_mod.Mp r 1\n 3. poly_mod.Mp r D' = D'\n 4. poly_mod.Mp r H' = H'\n 5. poly_mod.Mp r S' = S'\n 6. poly_mod.Mp r T' = T'\n 7. poly_mod.Mp p D1 = poly_mod.Mp p D'\n 8. poly_mod.Mp p H1 = poly_mod.Mp p H'\n 9. poly_mod.Mp p S1 = poly_mod.Mp p S'\n 10. poly_mod.Mp p T1 = poly_mod.Mp p T'\nA total of 11 subgoals...", "from step[folded D' H', folded U', unfolded dupe2 split, folded rq]"], ["proof (chain)\npicking this:\n  (poly_mod.Mp r (S - Polynomial.smult p A'),\n   poly_mod.Mp r (T - Polynomial.smult p B'), D', H') =\n  (S', T', D', H')", "have S': \"S' = poly_mod.Mp r (S - Polynomial.smult p A')\" and\n    T': \"T' = poly_mod.Mp r (T - Polynomial.smult p B')\""], ["proof (prove)\nusing this:\n  (poly_mod.Mp r (S - Polynomial.smult p A'),\n   poly_mod.Mp r (T - Polynomial.smult p B'), D', H') =\n  (S', T', D', H')\n\ngoal (1 subgoal):\n 1. S' = poly_mod.Mp r (S - Polynomial.smult p A') &&&\n    T' = poly_mod.Mp r (T - Polynomial.smult p B')", "by auto"], ["proof (state)\nthis:\n  S' = poly_mod.Mp r (S - Polynomial.smult p A')\n  T' = poly_mod.Mp r (T - Polynomial.smult p B')\n\ngoal (11 subgoals):\n 1. poly_mod.Mp r C = poly_mod.Mp r (D' * H')\n 2. poly_mod.Mp r (D' * S' + H' * T') = poly_mod.Mp r 1\n 3. poly_mod.Mp r D' = D'\n 4. poly_mod.Mp r H' = H'\n 5. poly_mod.Mp r S' = S'\n 6. poly_mod.Mp r T' = T'\n 7. poly_mod.Mp p D1 = poly_mod.Mp p D'\n 8. poly_mod.Mp p H1 = poly_mod.Mp p H'\n 9. poly_mod.Mp p S1 = poly_mod.Mp p S'\n 10. poly_mod.Mp p T1 = poly_mod.Mp p T'\nA total of 11 subgoals...", "from hensel_step_main[OF one_q one_p CDHq D1D H1H S1S T1T mon mon1 q p D1 H1 S1 T1 D H S T U \n    dupe1 D' H' U' dupe2 rq pq S' T']"], ["proof (chain)\npicking this:\n  poly_mod.Mp r C = poly_mod.Mp r (D' * H')\n  poly_mod.Mp r D' = D'\n  poly_mod.Mp r H' = H'\n  poly_mod.Mp r S' = S'\n  poly_mod.Mp r T' = T'\n  poly_mod.Mp r (D' * S' + H' * T') = poly_mod.Mp r 1\n  monic D'", "show \"poly_mod.eq_m r (D' * S' + H' * T') 1\"\n    \"poly_mod.eq_m r C (D' * H')\" \n    \"poly_mod.Mp r D' = D'\" \n    \"poly_mod.Mp r H' = H'\" \n    \"poly_mod.Mp r S' = S'\" \n    \"poly_mod.Mp r T' = T'\"\n    \"monic D'\""], ["proof (prove)\nusing this:\n  poly_mod.Mp r C = poly_mod.Mp r (D' * H')\n  poly_mod.Mp r D' = D'\n  poly_mod.Mp r H' = H'\n  poly_mod.Mp r S' = S'\n  poly_mod.Mp r T' = T'\n  poly_mod.Mp r (D' * S' + H' * T') = poly_mod.Mp r 1\n  monic D'\n\ngoal (1 subgoal):\n 1. (poly_mod.Mp r (D' * S' + H' * T') = poly_mod.Mp r 1 &&&\n     poly_mod.Mp r C = poly_mod.Mp r (D' * H') &&&\n     poly_mod.Mp r D' = D') &&&\n    (poly_mod.Mp r H' = H' &&& poly_mod.Mp r S' = S') &&&\n    poly_mod.Mp r T' = T' &&& monic D'", "by auto"], ["proof (state)\nthis:\n  poly_mod.Mp r (D' * S' + H' * T') = poly_mod.Mp r 1\n  poly_mod.Mp r C = poly_mod.Mp r (D' * H')\n  poly_mod.Mp r D' = D'\n  poly_mod.Mp r H' = H'\n  poly_mod.Mp r S' = S'\n  poly_mod.Mp r T' = T'\n  monic D'\n\ngoal (4 subgoals):\n 1. poly_mod.Mp p D1 = poly_mod.Mp p D'\n 2. poly_mod.Mp p H1 = poly_mod.Mp p H'\n 3. poly_mod.Mp p S1 = poly_mod.Mp p S'\n 4. poly_mod.Mp p T1 = poly_mod.Mp p T'", "from pq"], ["proof (chain)\npicking this:\n  p dvd q", "obtain s where q: \"q = p * s\""], ["proof (prove)\nusing this:\n  p dvd q\n\ngoal (1 subgoal):\n 1. (\\<And>s. q = p * s \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (metis dvdE)"], ["proof (state)\nthis:\n  q = p * s\n\ngoal (4 subgoals):\n 1. poly_mod.Mp p D1 = poly_mod.Mp p D'\n 2. poly_mod.Mp p H1 = poly_mod.Mp p H'\n 3. poly_mod.Mp p S1 = poly_mod.Mp p S'\n 4. poly_mod.Mp p T1 = poly_mod.Mp p T'", "show \"poly_mod.Mp p D1 = poly_mod.Mp p D'\" \n    \"poly_mod.Mp p H1 = poly_mod.Mp p H'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.Mp p D1 = poly_mod.Mp p D' &&&\n    poly_mod.Mp p H1 = poly_mod.Mp p H'", "unfolding q D' D1D H' H1H"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.Mp p D = poly_mod.Mp p (D + Polynomial.smult (p * s) B) &&&\n    poly_mod.Mp p H = poly_mod.Mp p (H + Polynomial.smult (p * s) A)", "by (metis add.right_neutral poly_mod.Mp_smult_m_0 poly_mod.plus_Mp(2) smult_smult)+"], ["proof (state)\nthis:\n  poly_mod.Mp p D1 = poly_mod.Mp p D'\n  poly_mod.Mp p H1 = poly_mod.Mp p H'\n\ngoal (2 subgoals):\n 1. poly_mod.Mp p S1 = poly_mod.Mp p S'\n 2. poly_mod.Mp p T1 = poly_mod.Mp p T'", "from \\<open>q > 1\\<close>"], ["proof (chain)\npicking this:\n  1 < q", "have q0: \"q > 0\""], ["proof (prove)\nusing this:\n  1 < q\n\ngoal (1 subgoal):\n 1. 0 < q", "by auto"], ["proof (state)\nthis:\n  0 < q\n\ngoal (2 subgoals):\n 1. poly_mod.Mp p S1 = poly_mod.Mp p S'\n 2. poly_mod.Mp p T1 = poly_mod.Mp p T'", "show \"poly_mod.Mp p S1 = poly_mod.Mp p S'\" \n    \"poly_mod.Mp p T1 = poly_mod.Mp p T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.Mp p S1 = poly_mod.Mp p S' &&&\n    poly_mod.Mp p T1 = poly_mod.Mp p T'", "unfolding S' S1S T' T1T poly_mod_2.Mp_product_modulus[OF poly_mod_2.intro[OF \\<open>p > 1\\<close>] rq q0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.Mp p S = poly_mod.Mp p (S - Polynomial.smult p A') &&&\n    poly_mod.Mp p T = poly_mod.Mp p (T - Polynomial.smult p B')", "by (metis group_add_class.diff_0_right poly_mod.Mp_smult_m_0 poly_mod.minus_Mp(2))+"], ["proof (state)\nthis:\n  poly_mod.Mp p S1 = poly_mod.Mp p S'\n  poly_mod.Mp p T1 = poly_mod.Mp p T'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma quadratic_hensel_step: assumes step: \"quadratic_hensel_step q S T D H = (S', T', D', H')\"\n  and CDH: \"poly_mod.eq_m q C (D * H)\"\n  and one: \"poly_mod.eq_m q (D * S + H * T) 1\"\n  and D: \"poly_mod.Mp q D = D\" \n  and H: \"poly_mod.Mp q H = H\"\n  and S: \"poly_mod.Mp q S = S\" \n  and T: \"poly_mod.Mp q T = T\"\n  and mon: \"monic D\" \n  and q: \"q > 1\" \n  and rq: \"r = q * q\" \nshows \n  \"poly_mod.eq_m r C (D' * H')\" \n  \"poly_mod.eq_m r (D' * S' + H' * T') 1\"\n  \"poly_mod.Mp r D' = D'\" \n  \"poly_mod.Mp r H' = H'\" \n  \"poly_mod.Mp r S' = S'\" \n  \"poly_mod.Mp r T' = T'\" \n  \"poly_mod.Mp q D = poly_mod.Mp q D'\" \n  \"poly_mod.Mp q H = poly_mod.Mp q H'\" \n  \"poly_mod.Mp q S = poly_mod.Mp q S'\" \n  \"poly_mod.Mp q T = poly_mod.Mp q T'\" \n  \"monic D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((poly_mod.Mp r C = poly_mod.Mp r (D' * H') &&&\n      poly_mod.Mp r (D' * S' + H' * T') = poly_mod.Mp r 1) &&&\n     poly_mod.Mp r D' = D' &&&\n     poly_mod.Mp r H' = H' &&& poly_mod.Mp r S' = S') &&&\n    (poly_mod.Mp r T' = T' &&&\n     poly_mod.Mp q D = poly_mod.Mp q D' &&&\n     poly_mod.Mp q H = poly_mod.Mp q H') &&&\n    poly_mod.Mp q S = poly_mod.Mp q S' &&&\n    poly_mod.Mp q T = poly_mod.Mp q T' &&& monic D'", "proof (atomize(full), goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. ((poly_mod.Mp r C = poly_mod.Mp r (D' * H') \\<and>\n      poly_mod.Mp r (D' * S' + H' * T') = poly_mod.Mp r 1) \\<and>\n     poly_mod.Mp r D' = D' \\<and>\n     poly_mod.Mp r H' = H' \\<and> poly_mod.Mp r S' = S') \\<and>\n    (poly_mod.Mp r T' = T' \\<and>\n     poly_mod.Mp q D = poly_mod.Mp q D' \\<and>\n     poly_mod.Mp q H = poly_mod.Mp q H') \\<and>\n    poly_mod.Mp q S = poly_mod.Mp q S' \\<and>\n    poly_mod.Mp q T = poly_mod.Mp q T' \\<and> monic D'", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. ((poly_mod.Mp r C = poly_mod.Mp r (D' * H') \\<and>\n      poly_mod.Mp r (D' * S' + H' * T') = poly_mod.Mp r 1) \\<and>\n     poly_mod.Mp r D' = D' \\<and>\n     poly_mod.Mp r H' = H' \\<and> poly_mod.Mp r S' = S') \\<and>\n    (poly_mod.Mp r T' = T' \\<and>\n     poly_mod.Mp q D = poly_mod.Mp q D' \\<and>\n     poly_mod.Mp q H = poly_mod.Mp q H') \\<and>\n    poly_mod.Mp q S = poly_mod.Mp q S' \\<and>\n    poly_mod.Mp q T = poly_mod.Mp q T' \\<and> monic D'", "from hensel_step[OF step[unfolded quadratic_hensel_step_def] one mon q CDH one refl refl refl refl mon q D H S T D H S T rq]"], ["proof (chain)\npicking this:\n  q dvd q \\<Longrightarrow> poly_mod.Mp r C = poly_mod.Mp r (D' * H')\n  q dvd q \\<Longrightarrow>\n  poly_mod.Mp r (D' * S' + H' * T') = poly_mod.Mp r 1\n  q dvd q \\<Longrightarrow> poly_mod.Mp r D' = D'\n  q dvd q \\<Longrightarrow> poly_mod.Mp r H' = H'\n  q dvd q \\<Longrightarrow> poly_mod.Mp r S' = S'\n  q dvd q \\<Longrightarrow> poly_mod.Mp r T' = T'\n  q dvd q \\<Longrightarrow> poly_mod.Mp q D = poly_mod.Mp q D'\n  q dvd q \\<Longrightarrow> poly_mod.Mp q H = poly_mod.Mp q H'\n  q dvd q \\<Longrightarrow> poly_mod.Mp q S = poly_mod.Mp q S'\n  q dvd q \\<Longrightarrow> poly_mod.Mp q T = poly_mod.Mp q T'\n  q dvd q \\<Longrightarrow> monic D'", "show ?case"], ["proof (prove)\nusing this:\n  q dvd q \\<Longrightarrow> poly_mod.Mp r C = poly_mod.Mp r (D' * H')\n  q dvd q \\<Longrightarrow>\n  poly_mod.Mp r (D' * S' + H' * T') = poly_mod.Mp r 1\n  q dvd q \\<Longrightarrow> poly_mod.Mp r D' = D'\n  q dvd q \\<Longrightarrow> poly_mod.Mp r H' = H'\n  q dvd q \\<Longrightarrow> poly_mod.Mp r S' = S'\n  q dvd q \\<Longrightarrow> poly_mod.Mp r T' = T'\n  q dvd q \\<Longrightarrow> poly_mod.Mp q D = poly_mod.Mp q D'\n  q dvd q \\<Longrightarrow> poly_mod.Mp q H = poly_mod.Mp q H'\n  q dvd q \\<Longrightarrow> poly_mod.Mp q S = poly_mod.Mp q S'\n  q dvd q \\<Longrightarrow> poly_mod.Mp q T = poly_mod.Mp q T'\n  q dvd q \\<Longrightarrow> monic D'\n\ngoal (1 subgoal):\n 1. ((poly_mod.Mp r C = poly_mod.Mp r (D' * H') \\<and>\n      poly_mod.Mp r (D' * S' + H' * T') = poly_mod.Mp r 1) \\<and>\n     poly_mod.Mp r D' = D' \\<and>\n     poly_mod.Mp r H' = H' \\<and> poly_mod.Mp r S' = S') \\<and>\n    (poly_mod.Mp r T' = T' \\<and>\n     poly_mod.Mp q D = poly_mod.Mp q D' \\<and>\n     poly_mod.Mp q H = poly_mod.Mp q H') \\<and>\n    poly_mod.Mp q S = poly_mod.Mp q S' \\<and>\n    poly_mod.Mp q T = poly_mod.Mp q T' \\<and> monic D'", "by auto"], ["proof (state)\nthis:\n  ((poly_mod.Mp r C = poly_mod.Mp r (D' * H') \\<and>\n    poly_mod.Mp r (D' * S' + H' * T') = poly_mod.Mp r 1) \\<and>\n   poly_mod.Mp r D' = D' \\<and>\n   poly_mod.Mp r H' = H' \\<and> poly_mod.Mp r S' = S') \\<and>\n  (poly_mod.Mp r T' = T' \\<and>\n   poly_mod.Mp q D = poly_mod.Mp q D' \\<and>\n   poly_mod.Mp q H = poly_mod.Mp q H') \\<and>\n  poly_mod.Mp q S = poly_mod.Mp q S' \\<and>\n  poly_mod.Mp q T = poly_mod.Mp q T' \\<and> monic D'\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  fixes p :: int and S1 T1 D1 H1 :: \"int poly\" \nbegin"], ["", "private"], ["", "lemma decrease[termination_simp]: \"\\<not> j \\<le> 1 \\<Longrightarrow> odd j \\<Longrightarrow> Suc (j div 2) < j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> j \\<le> 1; odd j\\<rbrakk>\n    \\<Longrightarrow> Suc (j div 2) < j", "by presburger"], ["", "fun quadratic_hensel_loop where \n  \"quadratic_hensel_loop (j :: nat) = (\n      if j \\<le> 1 then (p, S1, T1, D1, H1) else\n      if even j then \n          (case quadratic_hensel_loop (j div 2) of\n             (q, S, T, D, H) \\<Rightarrow>\n          let qq = q * q in \n          (case quadratic_hensel_step q S T D H of \\<comment> \\<open>quadratic step\\<close>\n            (S', T', D', H') \\<Rightarrow> (qq, S', T', D', H')))\n     else \\<comment> \\<open>odd \\<open>j\\<close>\\<close>\n        (case quadratic_hensel_loop (j div 2 + 1) of\n           (q, S, T, D, H) \\<Rightarrow>       \n          (case quadratic_hensel_step q S T D H of \\<comment> \\<open>quadratic step\\<close>\n            (S', T', D', H') \\<Rightarrow> \n                let qq = q * q; pj = qq div p; down = poly_mod.Mp pj in\n                  (pj, down S', down T', down D', down H'))))\""], ["", "definition \"quadratic_hensel_main j = (case quadratic_hensel_loop j of \n    (qq, S, T, D, H) \\<Rightarrow> (D, H))\""], ["", "declare quadratic_hensel_loop.simps[simp del]\n\n\\<comment> \\<open>unroll the definition of \\<open>hensel_loop\\<close> so that in outermost iteration we can use \\<open>simple_hensel_step\\<close>\\<close>"], ["", "lemma quadratic_hensel_main_code[code]: \"quadratic_hensel_main j = (\n   if j \\<le> 1 then (D1, H1)\n      else if even j\n      then (case quadratic_hensel_loop (j div 2) of\n            (q, S, T, D, H) \\<Rightarrow>\n               simple_quadratic_hensel_step q S T D H)            \n       else (case quadratic_hensel_loop (j div 2 + 1) of\n            (q, S, T, D, H) \\<Rightarrow>\n              (case simple_quadratic_hensel_step q S T D H of \n                (D', H') \\<Rightarrow> let down = poly_mod.Mp (q * q div p) in (down D', down H'))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.quadratic_hensel_main j =\n    (if j \\<le> 1 then (D1, H1)\n     else if even j\n          then case local.quadratic_hensel_loop (j div 2) of\n               (q, S, T, D, H) \\<Rightarrow>\n                 local.simple_quadratic_hensel_step q S T D H\n          else case local.quadratic_hensel_loop (j div 2 + 1) of\n               (q, S, T, D, H) \\<Rightarrow>\n                 case local.simple_quadratic_hensel_step q S T D H of\n                 (D', H') \\<Rightarrow>\n                   let down = poly_mod.Mp (q * q div p)\n                   in (down D', down H'))", "unfolding quadratic_hensel_loop.simps[of j] quadratic_hensel_main_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case if j \\<le> 1 then (p, S1, T1, D1, H1)\n          else if even j\n               then case local.quadratic_hensel_loop (j div 2) of\n                    (q, S, T, D, H) \\<Rightarrow>\n                      case local.quadratic_hensel_step q S T D H of\n                      (S', T', D', H') \\<Rightarrow> (q * q, S', T', D', H')\n               else case local.quadratic_hensel_loop (j div 2 + 1) of\n                    (q, S, T, D, H) \\<Rightarrow>\n                      case local.quadratic_hensel_step q S T D H of\n                      (S', T', D', H') \\<Rightarrow>\n                        (q * q div p, poly_mod.Mp (q * q div p) S',\n                         poly_mod.Mp (q * q div p) T',\n                         poly_mod.Mp (q * q div p) D',\n                         poly_mod.Mp (q * q div p) H') of\n     (qq, S, T, xa, xb) \\<Rightarrow> (xa, xb)) =\n    (if j \\<le> 1 then (D1, H1)\n     else if even j\n          then case local.quadratic_hensel_loop (j div 2) of\n               (q, S, T, D, H) \\<Rightarrow>\n                 local.simple_quadratic_hensel_step q S T D H\n          else case local.quadratic_hensel_loop (j div 2 + 1) of\n               (q, S, T, D, H) \\<Rightarrow>\n                 case local.simple_quadratic_hensel_step q S T D H of\n                 (D', H') \\<Rightarrow>\n                   (poly_mod.Mp (q * q div p) D',\n                    poly_mod.Mp (q * q div p) H'))", "by (simp split: if_splits prod.splits option.splits sum.splits \n      add: quadratic_hensel_step_code simple_quadratic_hensel_step_def Let_def)"], ["", "context\n  fixes j :: nat \n  assumes 1: \"poly_mod.eq_m p (D1 * S1 + H1 * T1) 1\"\n  and CDH1: \"poly_mod.eq_m p C (D1 * H1)\" \n  and mon1: \"monic D1\" \n  and p: \"p > 1\" \n  and D1: \"poly_mod.Mp p D1 = D1\" \n  and H1: \"poly_mod.Mp p H1 = H1\"  \n  and S1: \"poly_mod.Mp p S1 = S1\" \n  and T1: \"poly_mod.Mp p T1 = T1\"  \n  and j: \"j \\<ge> 1\" \nbegin"], ["", "lemma quadratic_hensel_loop:\n  assumes \"quadratic_hensel_loop j = (q, S, T, D, H)\"\n  shows \"(poly_mod.eq_m q C (D * H) \\<and> monic D\n    \\<and> poly_mod.eq_m p D1 D \\<and> poly_mod.eq_m p H1 H\n    \\<and> poly_mod.eq_m q (D * S + H * T) 1\n    \\<and> poly_mod.Mp q D = D \\<and> poly_mod.Mp q H = H\n    \\<and> poly_mod.Mp q S = S \\<and> poly_mod.Mp q T = T\n    \\<and> q = p^j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.Mp q C = poly_mod.Mp q (D * H) \\<and>\n    monic D \\<and>\n    poly_mod.Mp p D1 = poly_mod.Mp p D \\<and>\n    poly_mod.Mp p H1 = poly_mod.Mp p H \\<and>\n    poly_mod.Mp q (D * S + H * T) = poly_mod.Mp q 1 \\<and>\n    poly_mod.Mp q D = D \\<and>\n    poly_mod.Mp q H = H \\<and>\n    poly_mod.Mp q S = S \\<and> poly_mod.Mp q T = T \\<and> q = p ^ j", "using j assms"], ["proof (prove)\nusing this:\n  1 \\<le> j\n  local.quadratic_hensel_loop j = (q, S, T, D, H)\n\ngoal (1 subgoal):\n 1. poly_mod.Mp q C = poly_mod.Mp q (D * H) \\<and>\n    monic D \\<and>\n    poly_mod.Mp p D1 = poly_mod.Mp p D \\<and>\n    poly_mod.Mp p H1 = poly_mod.Mp p H \\<and>\n    poly_mod.Mp q (D * S + H * T) = poly_mod.Mp q 1 \\<and>\n    poly_mod.Mp q D = D \\<and>\n    poly_mod.Mp q H = H \\<and>\n    poly_mod.Mp q S = S \\<and> poly_mod.Mp q T = T \\<and> q = p ^ j", "proof (induct j arbitrary: q S T D H rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x q S T D H.\n       \\<lbrakk>\\<And>y q S T D H.\n                   \\<lbrakk>y < x; 1 \\<le> y;\n                    local.quadratic_hensel_loop y = (q, S, T, D, H)\\<rbrakk>\n                   \\<Longrightarrow> poly_mod.Mp q C =\n                                     poly_mod.Mp q (D * H) \\<and>\n                                     monic D \\<and>\n                                     poly_mod.Mp p D1 =\n                                     poly_mod.Mp p D \\<and>\n                                     poly_mod.Mp p H1 =\n                                     poly_mod.Mp p H \\<and>\n                                     poly_mod.Mp q (D * S + H * T) =\n                                     poly_mod.Mp q 1 \\<and>\n                                     poly_mod.Mp q D = D \\<and>\n                                     poly_mod.Mp q H = H \\<and>\n                                     poly_mod.Mp q S = S \\<and>\n                                     poly_mod.Mp q T = T \\<and> q = p ^ y;\n        1 \\<le> x; local.quadratic_hensel_loop x = (q, S, T, D, H)\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp q C = poly_mod.Mp q (D * H) \\<and>\n                         monic D \\<and>\n                         poly_mod.Mp p D1 = poly_mod.Mp p D \\<and>\n                         poly_mod.Mp p H1 = poly_mod.Mp p H \\<and>\n                         poly_mod.Mp q (D * S + H * T) =\n                         poly_mod.Mp q 1 \\<and>\n                         poly_mod.Mp q D = D \\<and>\n                         poly_mod.Mp q H = H \\<and>\n                         poly_mod.Mp q S = S \\<and>\n                         poly_mod.Mp q T = T \\<and> q = p ^ x", "case (less j q' S' T' D' H')"], ["proof (state)\nthis:\n  \\<lbrakk>?y < j; 1 \\<le> ?y;\n   local.quadratic_hensel_loop ?y = (?q, ?S, ?T, ?D, ?H)\\<rbrakk>\n  \\<Longrightarrow> poly_mod.Mp ?q C = poly_mod.Mp ?q (?D * ?H) \\<and>\n                    monic ?D \\<and>\n                    poly_mod.Mp p D1 = poly_mod.Mp p ?D \\<and>\n                    poly_mod.Mp p H1 = poly_mod.Mp p ?H \\<and>\n                    poly_mod.Mp ?q (?D * ?S + ?H * ?T) =\n                    poly_mod.Mp ?q 1 \\<and>\n                    poly_mod.Mp ?q ?D = ?D \\<and>\n                    poly_mod.Mp ?q ?H = ?H \\<and>\n                    poly_mod.Mp ?q ?S = ?S \\<and>\n                    poly_mod.Mp ?q ?T = ?T \\<and> ?q = p ^ ?y\n  1 \\<le> j\n  local.quadratic_hensel_loop j = (q', S', T', D', H')\n\ngoal (1 subgoal):\n 1. \\<And>x q S T D H.\n       \\<lbrakk>\\<And>y q S T D H.\n                   \\<lbrakk>y < x; 1 \\<le> y;\n                    local.quadratic_hensel_loop y = (q, S, T, D, H)\\<rbrakk>\n                   \\<Longrightarrow> poly_mod.Mp q C =\n                                     poly_mod.Mp q (D * H) \\<and>\n                                     monic D \\<and>\n                                     poly_mod.Mp p D1 =\n                                     poly_mod.Mp p D \\<and>\n                                     poly_mod.Mp p H1 =\n                                     poly_mod.Mp p H \\<and>\n                                     poly_mod.Mp q (D * S + H * T) =\n                                     poly_mod.Mp q 1 \\<and>\n                                     poly_mod.Mp q D = D \\<and>\n                                     poly_mod.Mp q H = H \\<and>\n                                     poly_mod.Mp q S = S \\<and>\n                                     poly_mod.Mp q T = T \\<and> q = p ^ y;\n        1 \\<le> x; local.quadratic_hensel_loop x = (q, S, T, D, H)\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp q C = poly_mod.Mp q (D * H) \\<and>\n                         monic D \\<and>\n                         poly_mod.Mp p D1 = poly_mod.Mp p D \\<and>\n                         poly_mod.Mp p H1 = poly_mod.Mp p H \\<and>\n                         poly_mod.Mp q (D * S + H * T) =\n                         poly_mod.Mp q 1 \\<and>\n                         poly_mod.Mp q D = D \\<and>\n                         poly_mod.Mp q H = H \\<and>\n                         poly_mod.Mp q S = S \\<and>\n                         poly_mod.Mp q T = T \\<and> q = p ^ x", "note res = less(3)"], ["proof (state)\nthis:\n  local.quadratic_hensel_loop j = (q', S', T', D', H')\n\ngoal (1 subgoal):\n 1. \\<And>x q S T D H.\n       \\<lbrakk>\\<And>y q S T D H.\n                   \\<lbrakk>y < x; 1 \\<le> y;\n                    local.quadratic_hensel_loop y = (q, S, T, D, H)\\<rbrakk>\n                   \\<Longrightarrow> poly_mod.Mp q C =\n                                     poly_mod.Mp q (D * H) \\<and>\n                                     monic D \\<and>\n                                     poly_mod.Mp p D1 =\n                                     poly_mod.Mp p D \\<and>\n                                     poly_mod.Mp p H1 =\n                                     poly_mod.Mp p H \\<and>\n                                     poly_mod.Mp q (D * S + H * T) =\n                                     poly_mod.Mp q 1 \\<and>\n                                     poly_mod.Mp q D = D \\<and>\n                                     poly_mod.Mp q H = H \\<and>\n                                     poly_mod.Mp q S = S \\<and>\n                                     poly_mod.Mp q T = T \\<and> q = p ^ y;\n        1 \\<le> x; local.quadratic_hensel_loop x = (q, S, T, D, H)\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp q C = poly_mod.Mp q (D * H) \\<and>\n                         monic D \\<and>\n                         poly_mod.Mp p D1 = poly_mod.Mp p D \\<and>\n                         poly_mod.Mp p H1 = poly_mod.Mp p H \\<and>\n                         poly_mod.Mp q (D * S + H * T) =\n                         poly_mod.Mp q 1 \\<and>\n                         poly_mod.Mp q D = D \\<and>\n                         poly_mod.Mp q H = H \\<and>\n                         poly_mod.Mp q S = S \\<and>\n                         poly_mod.Mp q T = T \\<and> q = p ^ x", "interpret poly_mod_2 p"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_2 p", "using p"], ["proof (prove)\nusing this:\n  1 < p\n\ngoal (1 subgoal):\n 1. poly_mod_2 p", "by (rule poly_mod_2.intro)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x q S T D H.\n       \\<lbrakk>\\<And>y q S T D H.\n                   \\<lbrakk>y < x; 1 \\<le> y;\n                    local.quadratic_hensel_loop y = (q, S, T, D, H)\\<rbrakk>\n                   \\<Longrightarrow> poly_mod.Mp q C =\n                                     poly_mod.Mp q (D * H) \\<and>\n                                     monic D \\<and>\n                                     D1 =m D \\<and>\n                                     H1 =m H \\<and>\n                                     poly_mod.Mp q (D * S + H * T) =\n                                     poly_mod.Mp q 1 \\<and>\n                                     poly_mod.Mp q D = D \\<and>\n                                     poly_mod.Mp q H = H \\<and>\n                                     poly_mod.Mp q S = S \\<and>\n                                     poly_mod.Mp q T = T \\<and> q = p ^ y;\n        1 \\<le> x; local.quadratic_hensel_loop x = (q, S, T, D, H)\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp q C = poly_mod.Mp q (D * H) \\<and>\n                         monic D \\<and>\n                         D1 =m D \\<and>\n                         H1 =m H \\<and>\n                         poly_mod.Mp q (D * S + H * T) =\n                         poly_mod.Mp q 1 \\<and>\n                         poly_mod.Mp q D = D \\<and>\n                         poly_mod.Mp q H = H \\<and>\n                         poly_mod.Mp q S = S \\<and>\n                         poly_mod.Mp q T = T \\<and> q = p ^ x", "let ?hens = \"quadratic_hensel_loop\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x q S T D H.\n       \\<lbrakk>\\<And>y q S T D H.\n                   \\<lbrakk>y < x; 1 \\<le> y;\n                    local.quadratic_hensel_loop y = (q, S, T, D, H)\\<rbrakk>\n                   \\<Longrightarrow> poly_mod.Mp q C =\n                                     poly_mod.Mp q (D * H) \\<and>\n                                     monic D \\<and>\n                                     D1 =m D \\<and>\n                                     H1 =m H \\<and>\n                                     poly_mod.Mp q (D * S + H * T) =\n                                     poly_mod.Mp q 1 \\<and>\n                                     poly_mod.Mp q D = D \\<and>\n                                     poly_mod.Mp q H = H \\<and>\n                                     poly_mod.Mp q S = S \\<and>\n                                     poly_mod.Mp q T = T \\<and> q = p ^ y;\n        1 \\<le> x; local.quadratic_hensel_loop x = (q, S, T, D, H)\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp q C = poly_mod.Mp q (D * H) \\<and>\n                         monic D \\<and>\n                         D1 =m D \\<and>\n                         H1 =m H \\<and>\n                         poly_mod.Mp q (D * S + H * T) =\n                         poly_mod.Mp q 1 \\<and>\n                         poly_mod.Mp q D = D \\<and>\n                         poly_mod.Mp q H = H \\<and>\n                         poly_mod.Mp q S = S \\<and>\n                         poly_mod.Mp q T = T \\<and> q = p ^ x", "note simp[simp] = quadratic_hensel_loop.simps[of j]"], ["proof (state)\nthis:\n  local.quadratic_hensel_loop j =\n  (if j \\<le> 1 then (p, S1, T1, D1, H1)\n   else if even j\n        then case local.quadratic_hensel_loop (j div 2) of\n             (q, S, T, D, H) \\<Rightarrow>\n               let qq = q * q\n               in case local.quadratic_hensel_step q S T D H of\n                  (S', T', D', H') \\<Rightarrow> (qq, S', T', D', H')\n        else case local.quadratic_hensel_loop (j div 2 + 1) of\n             (q, S, T, D, H) \\<Rightarrow>\n               case local.quadratic_hensel_step q S T D H of\n               (S', T', D', H') \\<Rightarrow>\n                 let qq = q * q; pj = qq div p; down = poly_mod.Mp pj\n                 in (pj, down S', down T', down D', down H'))\n\ngoal (1 subgoal):\n 1. \\<And>x q S T D H.\n       \\<lbrakk>\\<And>y q S T D H.\n                   \\<lbrakk>y < x; 1 \\<le> y;\n                    local.quadratic_hensel_loop y = (q, S, T, D, H)\\<rbrakk>\n                   \\<Longrightarrow> poly_mod.Mp q C =\n                                     poly_mod.Mp q (D * H) \\<and>\n                                     monic D \\<and>\n                                     D1 =m D \\<and>\n                                     H1 =m H \\<and>\n                                     poly_mod.Mp q (D * S + H * T) =\n                                     poly_mod.Mp q 1 \\<and>\n                                     poly_mod.Mp q D = D \\<and>\n                                     poly_mod.Mp q H = H \\<and>\n                                     poly_mod.Mp q S = S \\<and>\n                                     poly_mod.Mp q T = T \\<and> q = p ^ y;\n        1 \\<le> x; local.quadratic_hensel_loop x = (q, S, T, D, H)\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp q C = poly_mod.Mp q (D * H) \\<and>\n                         monic D \\<and>\n                         D1 =m D \\<and>\n                         H1 =m H \\<and>\n                         poly_mod.Mp q (D * S + H * T) =\n                         poly_mod.Mp q 1 \\<and>\n                         poly_mod.Mp q D = D \\<and>\n                         poly_mod.Mp q H = H \\<and>\n                         poly_mod.Mp q S = S \\<and>\n                         poly_mod.Mp q T = T \\<and> q = p ^ x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "proof (cases \"j = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j = 1 \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. j \\<noteq> 1 \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "case True"], ["proof (state)\nthis:\n  j = 1\n\ngoal (2 subgoals):\n 1. j = 1 \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. j \\<noteq> 1 \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "using res simp"], ["proof (prove)\nusing this:\n  local.quadratic_hensel_loop j = (q', S', T', D', H')\n  local.quadratic_hensel_loop j =\n  (if j \\<le> 1 then (p, S1, T1, D1, H1)\n   else if even j\n        then case local.quadratic_hensel_loop (j div 2) of\n             (q, S, T, D, H) \\<Rightarrow>\n               let qq = q * q\n               in case local.quadratic_hensel_step q S T D H of\n                  (S', T', D', H') \\<Rightarrow> (qq, S', T', D', H')\n        else case local.quadratic_hensel_loop (j div 2 + 1) of\n             (q, S, T, D, H) \\<Rightarrow>\n               case local.quadratic_hensel_step q S T D H of\n               (S', T', D', H') \\<Rightarrow>\n                 let qq = q * q; pj = qq div p; down = poly_mod.Mp pj\n                 in (pj, down S', down T', down D', down H'))\n\ngoal (1 subgoal):\n 1. poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "unfolding True"], ["proof (prove)\nusing this:\n  local.quadratic_hensel_loop 1 = (q', S', T', D', H')\n  local.quadratic_hensel_loop 1 =\n  (if 1 \\<le> 1 then (p, S1, T1, D1, H1)\n   else if is_unit 2\n        then case local.quadratic_hensel_loop (1 div 2) of\n             (q, S, T, D, H) \\<Rightarrow>\n               let qq = q * q\n               in case local.quadratic_hensel_step q S T D H of\n                  (S', T', D', H') \\<Rightarrow> (qq, S', T', D', H')\n        else case local.quadratic_hensel_loop (1 div 2 + 1) of\n             (q, S, T, D, H) \\<Rightarrow>\n               case local.quadratic_hensel_step q S T D H of\n               (S', T', D', H') \\<Rightarrow>\n                 let qq = q * q; pj = qq div p; down = poly_mod.Mp pj\n                 in (pj, down S', down T', down D', down H'))\n\ngoal (1 subgoal):\n 1. poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ 1", "using CDH1 1 mon1 D1 H1 S1 T1"], ["proof (prove)\nusing this:\n  local.quadratic_hensel_loop 1 = (q', S', T', D', H')\n  local.quadratic_hensel_loop 1 =\n  (if 1 \\<le> 1 then (p, S1, T1, D1, H1)\n   else if is_unit 2\n        then case local.quadratic_hensel_loop (1 div 2) of\n             (q, S, T, D, H) \\<Rightarrow>\n               let qq = q * q\n               in case local.quadratic_hensel_step q S T D H of\n                  (S', T', D', H') \\<Rightarrow> (qq, S', T', D', H')\n        else case local.quadratic_hensel_loop (1 div 2 + 1) of\n             (q, S, T, D, H) \\<Rightarrow>\n               case local.quadratic_hensel_step q S T D H of\n               (S', T', D', H') \\<Rightarrow>\n                 let qq = q * q; pj = qq div p; down = poly_mod.Mp pj\n                 in (pj, down S', down T', down D', down H'))\n  C =m D1 * H1\n  D1 * S1 + H1 * T1 =m 1\n  monic D1\n  Mp D1 = D1\n  Mp H1 = H1\n  Mp S1 = S1\n  Mp T1 = T1\n\ngoal (1 subgoal):\n 1. poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ 1", "by auto"], ["proof (state)\nthis:\n  poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n  monic D' \\<and>\n  D1 =m D' \\<and>\n  H1 =m H' \\<and>\n  poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n  poly_mod.Mp q' D' = D' \\<and>\n  poly_mod.Mp q' H' = H' \\<and>\n  poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n\ngoal (1 subgoal):\n 1. j \\<noteq> 1 \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<noteq> 1 \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "case False"], ["proof (state)\nthis:\n  j \\<noteq> 1\n\ngoal (1 subgoal):\n 1. j \\<noteq> 1 \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "with less(2)"], ["proof (chain)\npicking this:\n  1 \\<le> j\n  j \\<noteq> 1", "have False: \"(j \\<le> 1) = False\""], ["proof (prove)\nusing this:\n  1 \\<le> j\n  j \\<noteq> 1\n\ngoal (1 subgoal):\n 1. (j \\<le> 1) = False", "by auto"], ["proof (state)\nthis:\n  (j \\<le> 1) = False\n\ngoal (1 subgoal):\n 1. j \\<noteq> 1 \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "have mod_2: \"k \\<ge> 1 \\<Longrightarrow> poly_mod_2 (p^k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> k \\<Longrightarrow> poly_mod_2 (p ^ k)", "by (intro poly_mod_2.intro, insert p, auto)"], ["proof (state)\nthis:\n  1 \\<le> ?k \\<Longrightarrow> poly_mod_2 (p ^ ?k)\n\ngoal (1 subgoal):\n 1. j \\<noteq> 1 \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "{"], ["proof (state)\nthis:\n  1 \\<le> ?k \\<Longrightarrow> poly_mod_2 (p ^ ?k)\n\ngoal (1 subgoal):\n 1. j \\<noteq> 1 \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "fix k D"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<noteq> 1 \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "assume *: \"k \\<ge> 1\" \"k \\<le> j\" \"poly_mod.Mp (p ^ k) D = D\""], ["proof (state)\nthis:\n  1 \\<le> k\n  k \\<le> j\n  poly_mod.Mp (p ^ k) D = D\n\ngoal (1 subgoal):\n 1. j \\<noteq> 1 \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "from *(2)"], ["proof (chain)\npicking this:\n  k \\<le> j", "have \"{0..<p ^ k} \\<subseteq> {0..<p ^ j}\""], ["proof (prove)\nusing this:\n  k \\<le> j\n\ngoal (1 subgoal):\n 1. {0..<p ^ k} \\<subseteq> {0..<p ^ j}", "using p"], ["proof (prove)\nusing this:\n  k \\<le> j\n  1 < p\n\ngoal (1 subgoal):\n 1. {0..<p ^ k} \\<subseteq> {0..<p ^ j}", "by auto"], ["proof (state)\nthis:\n  {0..<p ^ k} \\<subseteq> {0..<p ^ j}\n\ngoal (1 subgoal):\n 1. j \\<noteq> 1 \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "hence \"poly_mod.Mp (p ^ j) D = D\""], ["proof (prove)\nusing this:\n  {0..<p ^ k} \\<subseteq> {0..<p ^ j}\n\ngoal (1 subgoal):\n 1. poly_mod.Mp (p ^ j) D = D", "unfolding poly_mod_2.Mp_ident_iff[OF mod_2[OF less(2)]]"], ["proof (prove)\nusing this:\n  {0..<p ^ k} \\<subseteq> {0..<p ^ j}\n\ngoal (1 subgoal):\n 1. \\<forall>n. poly.coeff D n \\<in> {0..<p ^ j}", "using *(3)[unfolded poly_mod_2.Mp_ident_iff[OF mod_2[OF *(1)]]]"], ["proof (prove)\nusing this:\n  {0..<p ^ k} \\<subseteq> {0..<p ^ j}\n  \\<forall>n. poly.coeff D n \\<in> {0..<p ^ k}\n\ngoal (1 subgoal):\n 1. \\<forall>n. poly.coeff D n \\<in> {0..<p ^ j}", "by blast"], ["proof (state)\nthis:\n  poly_mod.Mp (p ^ j) D = D\n\ngoal (1 subgoal):\n 1. j \\<noteq> 1 \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "}"], ["proof (state)\nthis:\n  \\<lbrakk>1 \\<le> ?k2; ?k2 \\<le> j;\n   poly_mod.Mp (p ^ ?k2) ?Da2 = ?Da2\\<rbrakk>\n  \\<Longrightarrow> poly_mod.Mp (p ^ j) ?Da2 = ?Da2\n\ngoal (1 subgoal):\n 1. j \\<noteq> 1 \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "note lift_norm = this"], ["proof (state)\nthis:\n  \\<lbrakk>1 \\<le> ?k2; ?k2 \\<le> j;\n   poly_mod.Mp (p ^ ?k2) ?Da2 = ?Da2\\<rbrakk>\n  \\<Longrightarrow> poly_mod.Mp (p ^ j) ?Da2 = ?Da2\n\ngoal (1 subgoal):\n 1. j \\<noteq> 1 \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "proof (cases \"even j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. even j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "case True"], ["proof (state)\nthis:\n  even j\n\ngoal (2 subgoals):\n 1. even j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "let ?j2 = \"j div 2\""], ["proof (state)\ngoal (2 subgoals):\n 1. even j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "from False"], ["proof (chain)\npicking this:\n  (j \\<le> 1) = False", "have lt: \"?j2 < j\" \"1 \\<le> ?j2\""], ["proof (prove)\nusing this:\n  (j \\<le> 1) = False\n\ngoal (1 subgoal):\n 1. j div 2 < j &&& 1 \\<le> j div 2", "by auto"], ["proof (state)\nthis:\n  j div 2 < j\n  1 \\<le> j div 2\n\ngoal (2 subgoals):\n 1. even j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "obtain q S T D H where rec: \"?hens ?j2 = (q, S, T, D, H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q S T D H.\n        local.quadratic_hensel_loop (j div 2) =\n        (q, S, T, D, H) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"?hens ?j2\", auto)"], ["proof (state)\nthis:\n  local.quadratic_hensel_loop (j div 2) = (q, S, T, D, H)\n\ngoal (2 subgoals):\n 1. even j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "note IH = less(1)[OF lt rec]"], ["proof (state)\nthis:\n  poly_mod.Mp q C = poly_mod.Mp q (D * H) \\<and>\n  monic D \\<and>\n  D1 =m D \\<and>\n  H1 =m H \\<and>\n  poly_mod.Mp q (D * S + H * T) = poly_mod.Mp q 1 \\<and>\n  poly_mod.Mp q D = D \\<and>\n  poly_mod.Mp q H = H \\<and>\n  poly_mod.Mp q S = S \\<and> poly_mod.Mp q T = T \\<and> q = p ^ (j div 2)\n\ngoal (2 subgoals):\n 1. even j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "from IH"], ["proof (chain)\npicking this:\n  poly_mod.Mp q C = poly_mod.Mp q (D * H) \\<and>\n  monic D \\<and>\n  D1 =m D \\<and>\n  H1 =m H \\<and>\n  poly_mod.Mp q (D * S + H * T) = poly_mod.Mp q 1 \\<and>\n  poly_mod.Mp q D = D \\<and>\n  poly_mod.Mp q H = H \\<and>\n  poly_mod.Mp q S = S \\<and> poly_mod.Mp q T = T \\<and> q = p ^ (j div 2)", "have *: \"poly_mod.eq_m q C (D * H)\" \n        \"poly_mod.eq_m q (D * S + H * T) 1\"\n        \"monic D\" \n        \"eq_m D1 D\" \n        \"eq_m H1 H\"\n        \"poly_mod.Mp q D = D\"\n        \"poly_mod.Mp q H = H\"\n        \"poly_mod.Mp q S = S\"\n        \"poly_mod.Mp q T = T\"\n        \"q = p ^ ?j2\""], ["proof (prove)\nusing this:\n  poly_mod.Mp q C = poly_mod.Mp q (D * H) \\<and>\n  monic D \\<and>\n  D1 =m D \\<and>\n  H1 =m H \\<and>\n  poly_mod.Mp q (D * S + H * T) = poly_mod.Mp q 1 \\<and>\n  poly_mod.Mp q D = D \\<and>\n  poly_mod.Mp q H = H \\<and>\n  poly_mod.Mp q S = S \\<and> poly_mod.Mp q T = T \\<and> q = p ^ (j div 2)\n\ngoal (1 subgoal):\n 1. ((poly_mod.Mp q C = poly_mod.Mp q (D * H) &&&\n      poly_mod.Mp q (D * S + H * T) = poly_mod.Mp q 1) &&&\n     monic D &&& D1 =m D &&& H1 =m H) &&&\n    (poly_mod.Mp q D = D &&& poly_mod.Mp q H = H) &&&\n    poly_mod.Mp q S = S &&& poly_mod.Mp q T = T &&& q = p ^ (j div 2)", "by auto"], ["proof (state)\nthis:\n  poly_mod.Mp q C = poly_mod.Mp q (D * H)\n  poly_mod.Mp q (D * S + H * T) = poly_mod.Mp q 1\n  monic D\n  D1 =m D\n  H1 =m H\n  poly_mod.Mp q D = D\n  poly_mod.Mp q H = H\n  poly_mod.Mp q S = S\n  poly_mod.Mp q T = T\n  q = p ^ (j div 2)\n\ngoal (2 subgoals):\n 1. even j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "hence norm: \"poly_mod.Mp (p ^ j) D = D\" \"poly_mod.Mp (p ^ j) H = H\"\n        \"poly_mod.Mp (p ^ j) S = S\" \"poly_mod.Mp (p ^ j) T = T\""], ["proof (prove)\nusing this:\n  poly_mod.Mp q C = poly_mod.Mp q (D * H)\n  poly_mod.Mp q (D * S + H * T) = poly_mod.Mp q 1\n  monic D\n  D1 =m D\n  H1 =m H\n  poly_mod.Mp q D = D\n  poly_mod.Mp q H = H\n  poly_mod.Mp q S = S\n  poly_mod.Mp q T = T\n  q = p ^ (j div 2)\n\ngoal (1 subgoal):\n 1. (poly_mod.Mp (p ^ j) D = D &&& poly_mod.Mp (p ^ j) H = H) &&&\n    poly_mod.Mp (p ^ j) S = S &&& poly_mod.Mp (p ^ j) T = T", "using lift_norm[OF lt(2)]"], ["proof (prove)\nusing this:\n  poly_mod.Mp q C = poly_mod.Mp q (D * H)\n  poly_mod.Mp q (D * S + H * T) = poly_mod.Mp q 1\n  monic D\n  D1 =m D\n  H1 =m H\n  poly_mod.Mp q D = D\n  poly_mod.Mp q H = H\n  poly_mod.Mp q S = S\n  poly_mod.Mp q T = T\n  q = p ^ (j div 2)\n  \\<lbrakk>j div 2 \\<le> j; poly_mod.Mp (p ^ (j div 2)) ?Da2 = ?Da2\\<rbrakk>\n  \\<Longrightarrow> poly_mod.Mp (p ^ j) ?Da2 = ?Da2\n\ngoal (1 subgoal):\n 1. (poly_mod.Mp (p ^ j) D = D &&& poly_mod.Mp (p ^ j) H = H) &&&\n    poly_mod.Mp (p ^ j) S = S &&& poly_mod.Mp (p ^ j) T = T", "by auto"], ["proof (state)\nthis:\n  poly_mod.Mp (p ^ j) D = D\n  poly_mod.Mp (p ^ j) H = H\n  poly_mod.Mp (p ^ j) S = S\n  poly_mod.Mp (p ^ j) T = T\n\ngoal (2 subgoals):\n 1. even j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "from lt p"], ["proof (chain)\npicking this:\n  j div 2 < j\n  1 \\<le> j div 2\n  1 < p", "have q: \"q > 1\""], ["proof (prove)\nusing this:\n  j div 2 < j\n  1 \\<le> j div 2\n  1 < p\n\ngoal (1 subgoal):\n 1. 1 < q", "unfolding *"], ["proof (prove)\nusing this:\n  j div 2 < j\n  1 \\<le> j div 2\n  1 < p\n\ngoal (1 subgoal):\n 1. 1 < p ^ (j div 2)", "by simp"], ["proof (state)\nthis:\n  1 < q\n\ngoal (2 subgoals):\n 1. even j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "let ?step = \"quadratic_hensel_step q S T D H\""], ["proof (state)\ngoal (2 subgoals):\n 1. even j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "obtain S2 T2 D2 H2 where step_res: \"?step = (S2, T2, D2, H2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>S2 T2 D2 H2.\n        local.quadratic_hensel_step q S T D H =\n        (S2, T2, D2, H2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?step, auto)"], ["proof (state)\nthis:\n  local.quadratic_hensel_step q S T D H = (S2, T2, D2, H2)\n\ngoal (2 subgoals):\n 1. even j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "note step = quadratic_hensel_step[OF step_res *(1,2,6-9,3) q refl]"], ["proof (state)\nthis:\n  poly_mod.Mp (q * q) C = poly_mod.Mp (q * q) (D2 * H2)\n  poly_mod.Mp (q * q) (D2 * S2 + H2 * T2) = poly_mod.Mp (q * q) 1\n  poly_mod.Mp (q * q) D2 = D2\n  poly_mod.Mp (q * q) H2 = H2\n  poly_mod.Mp (q * q) S2 = S2\n  poly_mod.Mp (q * q) T2 = T2\n  poly_mod.Mp q D = poly_mod.Mp q D2\n  poly_mod.Mp q H = poly_mod.Mp q H2\n  poly_mod.Mp q S = poly_mod.Mp q S2\n  poly_mod.Mp q T = poly_mod.Mp q T2\n  monic D2\n\ngoal (2 subgoals):\n 1. even j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "let ?qq = \"q * q\""], ["proof (state)\ngoal (2 subgoals):\n 1. even j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. even j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "fix D D2"], ["proof (state)\ngoal (2 subgoals):\n 1. even j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "assume \"poly_mod.Mp q D = poly_mod.Mp q D2\""], ["proof (state)\nthis:\n  poly_mod.Mp q D = poly_mod.Mp q D2\n\ngoal (2 subgoals):\n 1. even j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "from arg_cong[OF this, of Mp] Mp_Mp_pow_is_Mp[of ?j2, OF _ p, folded *(10)] lt"], ["proof (chain)\npicking this:\n  poly_mod.Mp q D =m poly_mod.Mp q D2\n  j div 2 \\<noteq> 0 \\<Longrightarrow> poly_mod.Mp q ?f =m ?f\n  j div 2 < j\n  1 \\<le> j div 2", "have \"Mp D = Mp D2\""], ["proof (prove)\nusing this:\n  poly_mod.Mp q D =m poly_mod.Mp q D2\n  j div 2 \\<noteq> 0 \\<Longrightarrow> poly_mod.Mp q ?f =m ?f\n  j div 2 < j\n  1 \\<le> j div 2\n\ngoal (1 subgoal):\n 1. D =m D2", "by simp"], ["proof (state)\nthis:\n  D =m D2\n\ngoal (2 subgoals):\n 1. even j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "}"], ["proof (state)\nthis:\n  poly_mod.Mp q ?Db2 = poly_mod.Mp q ?D2a2 \\<Longrightarrow> ?Db2 =m ?D2a2\n\ngoal (2 subgoals):\n 1. even j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "note shrink = this"], ["proof (state)\nthis:\n  poly_mod.Mp q ?Db2 = poly_mod.Mp q ?D2a2 \\<Longrightarrow> ?Db2 =m ?D2a2\n\ngoal (2 subgoals):\n 1. even j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "have **: \"poly_mod.eq_m ?qq C (D2 * H2)\" \n        \"poly_mod.eq_m ?qq (D2 * S2 + H2 * T2) 1\" \n        \"monic D2\" \n        \"eq_m D1 D2\"\n        \"eq_m H1 H2\" \n        \"poly_mod.Mp ?qq D2 = D2\" \n        \"poly_mod.Mp ?qq H2 = H2\" \n        \"poly_mod.Mp ?qq S2 = S2\" \n        \"poly_mod.Mp ?qq T2 = T2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((poly_mod.Mp (q * q) C = poly_mod.Mp (q * q) (D2 * H2) &&&\n      poly_mod.Mp (q * q) (D2 * S2 + H2 * T2) = poly_mod.Mp (q * q) 1) &&&\n     monic D2 &&& D1 =m D2) &&&\n    (H1 =m H2 &&& poly_mod.Mp (q * q) D2 = D2) &&&\n    poly_mod.Mp (q * q) H2 = H2 &&&\n    poly_mod.Mp (q * q) S2 = S2 &&& poly_mod.Mp (q * q) T2 = T2", "using step shrink[of H H2] shrink[of D D2] *(4-7)"], ["proof (prove)\nusing this:\n  poly_mod.Mp (q * q) C = poly_mod.Mp (q * q) (D2 * H2)\n  poly_mod.Mp (q * q) (D2 * S2 + H2 * T2) = poly_mod.Mp (q * q) 1\n  poly_mod.Mp (q * q) D2 = D2\n  poly_mod.Mp (q * q) H2 = H2\n  poly_mod.Mp (q * q) S2 = S2\n  poly_mod.Mp (q * q) T2 = T2\n  poly_mod.Mp q D = poly_mod.Mp q D2\n  poly_mod.Mp q H = poly_mod.Mp q H2\n  poly_mod.Mp q S = poly_mod.Mp q S2\n  poly_mod.Mp q T = poly_mod.Mp q T2\n  monic D2\n  poly_mod.Mp q H = poly_mod.Mp q H2 \\<Longrightarrow> H =m H2\n  poly_mod.Mp q D = poly_mod.Mp q D2 \\<Longrightarrow> D =m D2\n  D1 =m D\n  H1 =m H\n  poly_mod.Mp q D = D\n  poly_mod.Mp q H = H\n\ngoal (1 subgoal):\n 1. ((poly_mod.Mp (q * q) C = poly_mod.Mp (q * q) (D2 * H2) &&&\n      poly_mod.Mp (q * q) (D2 * S2 + H2 * T2) = poly_mod.Mp (q * q) 1) &&&\n     monic D2 &&& D1 =m D2) &&&\n    (H1 =m H2 &&& poly_mod.Mp (q * q) D2 = D2) &&&\n    poly_mod.Mp (q * q) H2 = H2 &&&\n    poly_mod.Mp (q * q) S2 = S2 &&& poly_mod.Mp (q * q) T2 = T2", "by auto"], ["proof (state)\nthis:\n  poly_mod.Mp (q * q) C = poly_mod.Mp (q * q) (D2 * H2)\n  poly_mod.Mp (q * q) (D2 * S2 + H2 * T2) = poly_mod.Mp (q * q) 1\n  monic D2\n  D1 =m D2\n  H1 =m H2\n  poly_mod.Mp (q * q) D2 = D2\n  poly_mod.Mp (q * q) H2 = H2\n  poly_mod.Mp (q * q) S2 = S2\n  poly_mod.Mp (q * q) T2 = T2\n\ngoal (2 subgoals):\n 1. even j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "note simp = simp False if_False rec split Let_def step_res option.simps"], ["proof (state)\nthis:\n  local.quadratic_hensel_loop j =\n  (if j \\<le> 1 then (p, S1, T1, D1, H1)\n   else if even j\n        then case local.quadratic_hensel_loop (j div 2) of\n             (q, S, T, D, H) \\<Rightarrow>\n               let qq = q * q\n               in case local.quadratic_hensel_step q S T D H of\n                  (S', T', D', H') \\<Rightarrow> (qq, S', T', D', H')\n        else case local.quadratic_hensel_loop (j div 2 + 1) of\n             (q, S, T, D, H) \\<Rightarrow>\n               case local.quadratic_hensel_step q S T D H of\n               (S', T', D', H') \\<Rightarrow>\n                 let qq = q * q; pj = qq div p; down = poly_mod.Mp pj\n                 in (pj, down S', down T', down D', down H'))\n  (j \\<le> 1) = False\n  (if False then ?x else ?y) = ?y\n  local.quadratic_hensel_loop (j div 2) = (q, S, T, D, H)\n  (case (?a, ?b) of (c, d) \\<Rightarrow> ?f c d) = ?f ?a ?b\n  Let ?s ?f \\<equiv> ?f ?s\n  local.quadratic_hensel_step q S T D H = (S2, T2, D2, H2)\n  (Some ?x2.0 = Some ?y2.0) = (?x2.0 = ?y2.0)\n  None \\<noteq> Some ?x2.0\n  Some ?x2.0 \\<noteq> None\n  (case None of None \\<Rightarrow> ?f1.0 | Some x \\<Rightarrow> ?f2.0 x) =\n  ?f1.0\n  (case Some ?x2.0 of None \\<Rightarrow> ?f1.0\n   | Some x \\<Rightarrow> ?f2.0 x) =\n  ?f2.0 ?x2.0\n  rec_option ?f1.0 ?f2.0 None = ?f1.0\n  rec_option ?f1.0 ?f2.0 (Some ?x2.0) = ?f2.0 ?x2.0\n  map_option ?f None = None\n  map_option ?f (Some ?x2.0) = Some (?f ?x2.0)\n  rel_option ?R None None\n  rel_option ?R (Some ?x2.0) (Some ?y2.0) = ?R ?x2.0 ?y2.0\n  \\<not> rel_option ?R None (Some ?y2.0)\n  \\<not> rel_option ?R (Some ?y2.0) None\n  set_option None = {}\n  set_option (Some ?x2.0) = {?x2.0}\n\ngoal (2 subgoals):\n 1. even j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "from True"], ["proof (chain)\npicking this:\n  even j", "have j: \"p ^ j = p ^ (2 * ?j2)\""], ["proof (prove)\nusing this:\n  even j\n\ngoal (1 subgoal):\n 1. p ^ j = p ^ (2 * (j div 2))", "by auto"], ["proof (state)\nthis:\n  p ^ j = p ^ (2 * (j div 2))\n\ngoal (2 subgoals):\n 1. even j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "with *(10)"], ["proof (chain)\npicking this:\n  q = p ^ (j div 2)\n  p ^ j = p ^ (2 * (j div 2))", "have qq: \"q * q = p ^ j\""], ["proof (prove)\nusing this:\n  q = p ^ (j div 2)\n  p ^ j = p ^ (2 * (j div 2))\n\ngoal (1 subgoal):\n 1. q * q = p ^ j", "by (simp add: power_mult_distrib semiring_normalization_rules(30-))"], ["proof (state)\nthis:\n  q * q = p ^ j\n\ngoal (2 subgoals):\n 1. even j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "from res[unfolded simp] True"], ["proof (chain)\npicking this:\n  (if even j then (q * q, S2, T2, D2, H2)\n   else case local.quadratic_hensel_loop (j div 2 + 1) of\n        (q, S, T, D, H) \\<Rightarrow>\n          case local.quadratic_hensel_step q S T D H of\n          (S', T', D', H') \\<Rightarrow>\n            (q * q div p, poly_mod.Mp (q * q div p) S',\n             poly_mod.Mp (q * q div p) T', poly_mod.Mp (q * q div p) D',\n             poly_mod.Mp (q * q div p) H')) =\n  (q', S', T', D', H')\n  even j", "have id': \"q' = ?qq\" \"S' = S2\" \"T' = T2\" \"D' = D2\" \"H' = H2\""], ["proof (prove)\nusing this:\n  (if even j then (q * q, S2, T2, D2, H2)\n   else case local.quadratic_hensel_loop (j div 2 + 1) of\n        (q, S, T, D, H) \\<Rightarrow>\n          case local.quadratic_hensel_step q S T D H of\n          (S', T', D', H') \\<Rightarrow>\n            (q * q div p, poly_mod.Mp (q * q div p) S',\n             poly_mod.Mp (q * q div p) T', poly_mod.Mp (q * q div p) D',\n             poly_mod.Mp (q * q div p) H')) =\n  (q', S', T', D', H')\n  even j\n\ngoal (1 subgoal):\n 1. (q' = q * q &&& S' = S2) &&& T' = T2 &&& D' = D2 &&& H' = H2", "by auto"], ["proof (state)\nthis:\n  q' = q * q\n  S' = S2\n  T' = T2\n  D' = D2\n  H' = H2\n\ngoal (2 subgoals):\n 1. even j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n 2. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "unfolding id'"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.Mp (q * q) C = poly_mod.Mp (q * q) (D2 * H2) \\<and>\n    monic D2 \\<and>\n    D1 =m D2 \\<and>\n    H1 =m H2 \\<and>\n    poly_mod.Mp (q * q) (D2 * S2 + H2 * T2) = poly_mod.Mp (q * q) 1 \\<and>\n    poly_mod.Mp (q * q) D2 = D2 \\<and>\n    poly_mod.Mp (q * q) H2 = H2 \\<and>\n    poly_mod.Mp (q * q) S2 = S2 \\<and>\n    poly_mod.Mp (q * q) T2 = T2 \\<and> q * q = p ^ j", "using **"], ["proof (prove)\nusing this:\n  poly_mod.Mp (q * q) C = poly_mod.Mp (q * q) (D2 * H2)\n  poly_mod.Mp (q * q) (D2 * S2 + H2 * T2) = poly_mod.Mp (q * q) 1\n  monic D2\n  D1 =m D2\n  H1 =m H2\n  poly_mod.Mp (q * q) D2 = D2\n  poly_mod.Mp (q * q) H2 = H2\n  poly_mod.Mp (q * q) S2 = S2\n  poly_mod.Mp (q * q) T2 = T2\n\ngoal (1 subgoal):\n 1. poly_mod.Mp (q * q) C = poly_mod.Mp (q * q) (D2 * H2) \\<and>\n    monic D2 \\<and>\n    D1 =m D2 \\<and>\n    H1 =m H2 \\<and>\n    poly_mod.Mp (q * q) (D2 * S2 + H2 * T2) = poly_mod.Mp (q * q) 1 \\<and>\n    poly_mod.Mp (q * q) D2 = D2 \\<and>\n    poly_mod.Mp (q * q) H2 = H2 \\<and>\n    poly_mod.Mp (q * q) S2 = S2 \\<and>\n    poly_mod.Mp (q * q) T2 = T2 \\<and> q * q = p ^ j", "by (auto simp: qq)"], ["proof (state)\nthis:\n  poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n  monic D' \\<and>\n  D1 =m D' \\<and>\n  H1 =m H' \\<and>\n  poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n  poly_mod.Mp q' D' = D' \\<and>\n  poly_mod.Mp q' H' = H' \\<and>\n  poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "case odd: False"], ["proof (state)\nthis:\n  odd j\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "hence False': \"(even j) = False\""], ["proof (prove)\nusing this:\n  odd j\n\ngoal (1 subgoal):\n 1. even j = False", "by auto"], ["proof (state)\nthis:\n  even j = False\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "let ?j2 = \"j div 2 + 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "from False odd"], ["proof (chain)\npicking this:\n  (j \\<le> 1) = False\n  odd j", "have lt: \"?j2 < j\" \"1 \\<le> ?j2\""], ["proof (prove)\nusing this:\n  (j \\<le> 1) = False\n  odd j\n\ngoal (1 subgoal):\n 1. j div 2 + 1 < j &&& 1 \\<le> j div 2 + 1", "by presburger+"], ["proof (state)\nthis:\n  j div 2 + 1 < j\n  1 \\<le> j div 2 + 1\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "obtain q S T D H where rec: \"?hens ?j2 = (q, S, T, D, H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q S T D H.\n        local.quadratic_hensel_loop (j div 2 + 1) =\n        (q, S, T, D, H) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"?hens ?j2\", auto)"], ["proof (state)\nthis:\n  local.quadratic_hensel_loop (j div 2 + 1) = (q, S, T, D, H)\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "note IH = less(1)[OF lt rec]"], ["proof (state)\nthis:\n  poly_mod.Mp q C = poly_mod.Mp q (D * H) \\<and>\n  monic D \\<and>\n  D1 =m D \\<and>\n  H1 =m H \\<and>\n  poly_mod.Mp q (D * S + H * T) = poly_mod.Mp q 1 \\<and>\n  poly_mod.Mp q D = D \\<and>\n  poly_mod.Mp q H = H \\<and>\n  poly_mod.Mp q S = S \\<and>\n  poly_mod.Mp q T = T \\<and> q = p ^ (j div 2 + 1)\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "note simp = simp False if_False rec sum.simps split Let_def False' option.simps"], ["proof (state)\nthis:\n  local.quadratic_hensel_loop j =\n  (if j \\<le> 1 then (p, S1, T1, D1, H1)\n   else if even j\n        then case local.quadratic_hensel_loop (j div 2) of\n             (q, S, T, D, H) \\<Rightarrow>\n               let qq = q * q\n               in case local.quadratic_hensel_step q S T D H of\n                  (S', T', D', H') \\<Rightarrow> (qq, S', T', D', H')\n        else case local.quadratic_hensel_loop (j div 2 + 1) of\n             (q, S, T, D, H) \\<Rightarrow>\n               case local.quadratic_hensel_step q S T D H of\n               (S', T', D', H') \\<Rightarrow>\n                 let qq = q * q; pj = qq div p; down = poly_mod.Mp pj\n                 in (pj, down S', down T', down D', down H'))\n  (j \\<le> 1) = False\n  (if False then ?x else ?y) = ?y\n  local.quadratic_hensel_loop (j div 2 + 1) = (q, S, T, D, H)\n  (Inl ?x1.0 = Inl ?y1.0) = (?x1.0 = ?y1.0)\n  (Inr ?x2.0 = Inr ?y2.0) = (?x2.0 = ?y2.0)\n  Inl ?x1.0 \\<noteq> Inr ?x2.0\n  Inr ?x2.0 \\<noteq> Inl ?x1.0\n  (case Inl ?x1.0 of Inl x \\<Rightarrow> ?f1.0 x\n   | Inr x \\<Rightarrow> ?f2.0 x) =\n  ?f1.0 ?x1.0\n  (case Inr ?x2.0 of Inl x \\<Rightarrow> ?f1.0 x\n   | Inr x \\<Rightarrow> ?f2.0 x) =\n  ?f2.0 ?x2.0\n  old.rec_sum ?f1.0 ?f2.0 (Inl ?a) = ?f1.0 ?a\n  old.rec_sum ?f1.0 ?f2.0 (Inr ?b) = ?f2.0 ?b\n  (case (?a, ?b) of (c, d) \\<Rightarrow> ?f c d) = ?f ?a ?b\n  Let ?s ?f \\<equiv> ?f ?s\n  even j = False\n  (Some ?x2.0 = Some ?y2.0) = (?x2.0 = ?y2.0)\n  None \\<noteq> Some ?x2.0\n  Some ?x2.0 \\<noteq> None\n  (case None of None \\<Rightarrow> ?f1.0 | Some x \\<Rightarrow> ?f2.0 x) =\n  ?f1.0\n  (case Some ?x2.0 of None \\<Rightarrow> ?f1.0\n   | Some x \\<Rightarrow> ?f2.0 x) =\n  ?f2.0 ?x2.0\n  rec_option ?f1.0 ?f2.0 None = ?f1.0\n  rec_option ?f1.0 ?f2.0 (Some ?x2.0) = ?f2.0 ?x2.0\n  map_option ?f None = None\n  map_option ?f (Some ?x2.0) = Some (?f ?x2.0)\n  rel_option ?R None None\n  rel_option ?R (Some ?x2.0) (Some ?y2.0) = ?R ?x2.0 ?y2.0\n  \\<not> rel_option ?R None (Some ?y2.0)\n  \\<not> rel_option ?R (Some ?y2.0) None\n  set_option None = {}\n  set_option (Some ?x2.0) = {?x2.0}\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "from IH"], ["proof (chain)\npicking this:\n  poly_mod.Mp q C = poly_mod.Mp q (D * H) \\<and>\n  monic D \\<and>\n  D1 =m D \\<and>\n  H1 =m H \\<and>\n  poly_mod.Mp q (D * S + H * T) = poly_mod.Mp q 1 \\<and>\n  poly_mod.Mp q D = D \\<and>\n  poly_mod.Mp q H = H \\<and>\n  poly_mod.Mp q S = S \\<and>\n  poly_mod.Mp q T = T \\<and> q = p ^ (j div 2 + 1)", "have *: \"poly_mod.eq_m q C (D * H)\" \n          \"poly_mod.eq_m q (D * S + H * T) 1\"\n          \"monic D\" \n          \"eq_m D1 D\" \n          \"eq_m H1 H\"\n          \"poly_mod.Mp q D = D\"\n          \"poly_mod.Mp q H = H\"\n          \"poly_mod.Mp q S = S\"\n          \"poly_mod.Mp q T = T\"\n          \"q = p ^ ?j2\""], ["proof (prove)\nusing this:\n  poly_mod.Mp q C = poly_mod.Mp q (D * H) \\<and>\n  monic D \\<and>\n  D1 =m D \\<and>\n  H1 =m H \\<and>\n  poly_mod.Mp q (D * S + H * T) = poly_mod.Mp q 1 \\<and>\n  poly_mod.Mp q D = D \\<and>\n  poly_mod.Mp q H = H \\<and>\n  poly_mod.Mp q S = S \\<and>\n  poly_mod.Mp q T = T \\<and> q = p ^ (j div 2 + 1)\n\ngoal (1 subgoal):\n 1. ((poly_mod.Mp q C = poly_mod.Mp q (D * H) &&&\n      poly_mod.Mp q (D * S + H * T) = poly_mod.Mp q 1) &&&\n     monic D &&& D1 =m D &&& H1 =m H) &&&\n    (poly_mod.Mp q D = D &&& poly_mod.Mp q H = H) &&&\n    poly_mod.Mp q S = S &&& poly_mod.Mp q T = T &&& q = p ^ (j div 2 + 1)", "by auto"], ["proof (state)\nthis:\n  poly_mod.Mp q C = poly_mod.Mp q (D * H)\n  poly_mod.Mp q (D * S + H * T) = poly_mod.Mp q 1\n  monic D\n  D1 =m D\n  H1 =m H\n  poly_mod.Mp q D = D\n  poly_mod.Mp q H = H\n  poly_mod.Mp q S = S\n  poly_mod.Mp q T = T\n  q = p ^ (j div 2 + 1)\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "hence norm: \"poly_mod.Mp (p ^ j) D = D\" \"poly_mod.Mp (p ^ j) H = H\""], ["proof (prove)\nusing this:\n  poly_mod.Mp q C = poly_mod.Mp q (D * H)\n  poly_mod.Mp q (D * S + H * T) = poly_mod.Mp q 1\n  monic D\n  D1 =m D\n  H1 =m H\n  poly_mod.Mp q D = D\n  poly_mod.Mp q H = H\n  poly_mod.Mp q S = S\n  poly_mod.Mp q T = T\n  q = p ^ (j div 2 + 1)\n\ngoal (1 subgoal):\n 1. poly_mod.Mp (p ^ j) D = D &&& poly_mod.Mp (p ^ j) H = H", "using lift_norm[OF lt(2)] lt"], ["proof (prove)\nusing this:\n  poly_mod.Mp q C = poly_mod.Mp q (D * H)\n  poly_mod.Mp q (D * S + H * T) = poly_mod.Mp q 1\n  monic D\n  D1 =m D\n  H1 =m H\n  poly_mod.Mp q D = D\n  poly_mod.Mp q H = H\n  poly_mod.Mp q S = S\n  poly_mod.Mp q T = T\n  q = p ^ (j div 2 + 1)\n  \\<lbrakk>j div 2 + 1 \\<le> j;\n   poly_mod.Mp (p ^ (j div 2 + 1)) ?Da2 = ?Da2\\<rbrakk>\n  \\<Longrightarrow> poly_mod.Mp (p ^ j) ?Da2 = ?Da2\n  j div 2 + 1 < j\n  1 \\<le> j div 2 + 1\n\ngoal (1 subgoal):\n 1. poly_mod.Mp (p ^ j) D = D &&& poly_mod.Mp (p ^ j) H = H", "by auto"], ["proof (state)\nthis:\n  poly_mod.Mp (p ^ j) D = D\n  poly_mod.Mp (p ^ j) H = H\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "from lt p"], ["proof (chain)\npicking this:\n  j div 2 + 1 < j\n  1 \\<le> j div 2 + 1\n  1 < p", "have q: \"q > 1\""], ["proof (prove)\nusing this:\n  j div 2 + 1 < j\n  1 \\<le> j div 2 + 1\n  1 < p\n\ngoal (1 subgoal):\n 1. 1 < q", "unfolding *"], ["proof (prove)\nusing this:\n  j div 2 + 1 < j\n  1 \\<le> j div 2 + 1\n  1 < p\n\ngoal (1 subgoal):\n 1. 1 < p ^ (j div 2 + 1)", "using mod_2 poly_mod_2.m1"], ["proof (prove)\nusing this:\n  j div 2 + 1 < j\n  1 \\<le> j div 2 + 1\n  1 < p\n  1 \\<le> ?k \\<Longrightarrow> poly_mod_2 (p ^ ?k)\n  poly_mod_2 ?m \\<Longrightarrow> 1 < ?m\n\ngoal (1 subgoal):\n 1. 1 < p ^ (j div 2 + 1)", "by blast"], ["proof (state)\nthis:\n  1 < q\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "let ?step = \"quadratic_hensel_step q S T D H\""], ["proof (state)\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "obtain S2 T2 D2 H2 where step_res: \"?step = (S2, T2, D2, H2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>S2 T2 D2 H2.\n        local.quadratic_hensel_step q S T D H =\n        (S2, T2, D2, H2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?step, auto)"], ["proof (state)\nthis:\n  local.quadratic_hensel_step q S T D H = (S2, T2, D2, H2)\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "have dvd: \"q dvd q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q dvd q", "by auto"], ["proof (state)\nthis:\n  q dvd q\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "note step = quadratic_hensel_step[OF step_res *(1,2,6-9,3) q refl]"], ["proof (state)\nthis:\n  poly_mod.Mp (q * q) C = poly_mod.Mp (q * q) (D2 * H2)\n  poly_mod.Mp (q * q) (D2 * S2 + H2 * T2) = poly_mod.Mp (q * q) 1\n  poly_mod.Mp (q * q) D2 = D2\n  poly_mod.Mp (q * q) H2 = H2\n  poly_mod.Mp (q * q) S2 = S2\n  poly_mod.Mp (q * q) T2 = T2\n  poly_mod.Mp q D = poly_mod.Mp q D2\n  poly_mod.Mp q H = poly_mod.Mp q H2\n  poly_mod.Mp q S = poly_mod.Mp q S2\n  poly_mod.Mp q T = poly_mod.Mp q T2\n  monic D2\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "let ?qq = \"q * q\""], ["proof (state)\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "fix D D2"], ["proof (state)\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "assume \"poly_mod.Mp q D = poly_mod.Mp q D2\""], ["proof (state)\nthis:\n  poly_mod.Mp q D = poly_mod.Mp q D2\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "from arg_cong[OF this, of Mp] Mp_Mp_pow_is_Mp[of ?j2, OF _ p, folded *(10)] lt"], ["proof (chain)\npicking this:\n  poly_mod.Mp q D =m poly_mod.Mp q D2\n  j div 2 + 1 \\<noteq> 0 \\<Longrightarrow> poly_mod.Mp q ?f =m ?f\n  j div 2 + 1 < j\n  1 \\<le> j div 2 + 1", "have \"Mp D = Mp D2\""], ["proof (prove)\nusing this:\n  poly_mod.Mp q D =m poly_mod.Mp q D2\n  j div 2 + 1 \\<noteq> 0 \\<Longrightarrow> poly_mod.Mp q ?f =m ?f\n  j div 2 + 1 < j\n  1 \\<le> j div 2 + 1\n\ngoal (1 subgoal):\n 1. D =m D2", "by simp"], ["proof (state)\nthis:\n  D =m D2\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "}"], ["proof (state)\nthis:\n  poly_mod.Mp q ?Db2 = poly_mod.Mp q ?D2a2 \\<Longrightarrow> ?Db2 =m ?D2a2\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "note shrink = this"], ["proof (state)\nthis:\n  poly_mod.Mp q ?Db2 = poly_mod.Mp q ?D2a2 \\<Longrightarrow> ?Db2 =m ?D2a2\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "have **: \"poly_mod.eq_m ?qq C (D2 * H2)\" \n        \"poly_mod.eq_m ?qq (D2 * S2 + H2 * T2) 1\" \n        \"monic D2\" \n        \"eq_m D1 D2\"\n        \"eq_m H1 H2\" \n        \"poly_mod.Mp ?qq D2 = D2\" \n        \"poly_mod.Mp ?qq H2 = H2\" \n        \"poly_mod.Mp ?qq S2 = S2\"\n        \"poly_mod.Mp ?qq T2 = T2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((poly_mod.Mp (q * q) C = poly_mod.Mp (q * q) (D2 * H2) &&&\n      poly_mod.Mp (q * q) (D2 * S2 + H2 * T2) = poly_mod.Mp (q * q) 1) &&&\n     monic D2 &&& D1 =m D2) &&&\n    (H1 =m H2 &&& poly_mod.Mp (q * q) D2 = D2) &&&\n    poly_mod.Mp (q * q) H2 = H2 &&&\n    poly_mod.Mp (q * q) S2 = S2 &&& poly_mod.Mp (q * q) T2 = T2", "using step shrink[of H H2] shrink[of D D2] *(4-7)"], ["proof (prove)\nusing this:\n  poly_mod.Mp (q * q) C = poly_mod.Mp (q * q) (D2 * H2)\n  poly_mod.Mp (q * q) (D2 * S2 + H2 * T2) = poly_mod.Mp (q * q) 1\n  poly_mod.Mp (q * q) D2 = D2\n  poly_mod.Mp (q * q) H2 = H2\n  poly_mod.Mp (q * q) S2 = S2\n  poly_mod.Mp (q * q) T2 = T2\n  poly_mod.Mp q D = poly_mod.Mp q D2\n  poly_mod.Mp q H = poly_mod.Mp q H2\n  poly_mod.Mp q S = poly_mod.Mp q S2\n  poly_mod.Mp q T = poly_mod.Mp q T2\n  monic D2\n  poly_mod.Mp q H = poly_mod.Mp q H2 \\<Longrightarrow> H =m H2\n  poly_mod.Mp q D = poly_mod.Mp q D2 \\<Longrightarrow> D =m D2\n  D1 =m D\n  H1 =m H\n  poly_mod.Mp q D = D\n  poly_mod.Mp q H = H\n\ngoal (1 subgoal):\n 1. ((poly_mod.Mp (q * q) C = poly_mod.Mp (q * q) (D2 * H2) &&&\n      poly_mod.Mp (q * q) (D2 * S2 + H2 * T2) = poly_mod.Mp (q * q) 1) &&&\n     monic D2 &&& D1 =m D2) &&&\n    (H1 =m H2 &&& poly_mod.Mp (q * q) D2 = D2) &&&\n    poly_mod.Mp (q * q) H2 = H2 &&&\n    poly_mod.Mp (q * q) S2 = S2 &&& poly_mod.Mp (q * q) T2 = T2", "by auto"], ["proof (state)\nthis:\n  poly_mod.Mp (q * q) C = poly_mod.Mp (q * q) (D2 * H2)\n  poly_mod.Mp (q * q) (D2 * S2 + H2 * T2) = poly_mod.Mp (q * q) 1\n  monic D2\n  D1 =m D2\n  H1 =m H2\n  poly_mod.Mp (q * q) D2 = D2\n  poly_mod.Mp (q * q) H2 = H2\n  poly_mod.Mp (q * q) S2 = S2\n  poly_mod.Mp (q * q) T2 = T2\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "note simp = simp False if_False rec split Let_def step_res option.simps"], ["proof (state)\nthis:\n  local.quadratic_hensel_loop j =\n  (if j \\<le> 1 then (p, S1, T1, D1, H1)\n   else if even j\n        then case local.quadratic_hensel_loop (j div 2) of\n             (q, S, T, D, H) \\<Rightarrow>\n               let qq = q * q\n               in case local.quadratic_hensel_step q S T D H of\n                  (S', T', D', H') \\<Rightarrow> (qq, S', T', D', H')\n        else case local.quadratic_hensel_loop (j div 2 + 1) of\n             (q, S, T, D, H) \\<Rightarrow>\n               case local.quadratic_hensel_step q S T D H of\n               (S', T', D', H') \\<Rightarrow>\n                 let qq = q * q; pj = qq div p; down = poly_mod.Mp pj\n                 in (pj, down S', down T', down D', down H'))\n  (j \\<le> 1) = False\n  (if False then ?x else ?y) = ?y\n  local.quadratic_hensel_loop (j div 2 + 1) = (q, S, T, D, H)\n  (Inl ?x1.0 = Inl ?y1.0) = (?x1.0 = ?y1.0)\n  (Inr ?x2.0 = Inr ?y2.0) = (?x2.0 = ?y2.0)\n  Inl ?x1.0 \\<noteq> Inr ?x2.0\n  Inr ?x2.0 \\<noteq> Inl ?x1.0\n  (case Inl ?x1.0 of Inl x \\<Rightarrow> ?f1.0 x\n   | Inr x \\<Rightarrow> ?f2.0 x) =\n  ?f1.0 ?x1.0\n  (case Inr ?x2.0 of Inl x \\<Rightarrow> ?f1.0 x\n   | Inr x \\<Rightarrow> ?f2.0 x) =\n  ?f2.0 ?x2.0\n  old.rec_sum ?f1.0 ?f2.0 (Inl ?a) = ?f1.0 ?a\n  old.rec_sum ?f1.0 ?f2.0 (Inr ?b) = ?f2.0 ?b\n  (case (?a, ?b) of (c, d) \\<Rightarrow> ?f c d) = ?f ?a ?b\n  Let ?s ?f \\<equiv> ?f ?s\n  even j = False\n  (Some ?x2.0 = Some ?y2.0) = (?x2.0 = ?y2.0)\n  None \\<noteq> Some ?x2.0\n  Some ?x2.0 \\<noteq> None\n  (case None of None \\<Rightarrow> ?f1.0 | Some x \\<Rightarrow> ?f2.0 x) =\n  ?f1.0\n  (case Some ?x2.0 of None \\<Rightarrow> ?f1.0\n   | Some x \\<Rightarrow> ?f2.0 x) =\n  ?f2.0 ?x2.0\n  rec_option ?f1.0 ?f2.0 None = ?f1.0\n  rec_option ?f1.0 ?f2.0 (Some ?x2.0) = ?f2.0 ?x2.0\n  map_option ?f None = None\n  map_option ?f (Some ?x2.0) = Some (?f ?x2.0)\n  rel_option ?R None None\n  rel_option ?R (Some ?x2.0) (Some ?y2.0) = ?R ?x2.0 ?y2.0\n  \\<not> rel_option ?R None (Some ?y2.0)\n  \\<not> rel_option ?R (Some ?y2.0) None\n  set_option None = {}\n  set_option (Some ?x2.0) = {?x2.0}\n  (j \\<le> 1) = False\n  (if False then ?x else ?y) = ?y\n  local.quadratic_hensel_loop (j div 2 + 1) = (q, S, T, D, H)\n  (case (?a, ?b) of (c, d) \\<Rightarrow> ?f c d) = ?f ?a ?b\n  Let ?s ?f \\<equiv> ?f ?s\n  local.quadratic_hensel_step q S T D H = (S2, T2, D2, H2)\n  (Some ?x2.0 = Some ?y2.0) = (?x2.0 = ?y2.0)\n  None \\<noteq> Some ?x2.0\n  Some ?x2.0 \\<noteq> None\n  (case None of None \\<Rightarrow> ?f1.0 | Some x \\<Rightarrow> ?f2.0 x) =\n  ?f1.0\n  (case Some ?x2.0 of None \\<Rightarrow> ?f1.0\n   | Some x \\<Rightarrow> ?f2.0 x) =\n  ?f2.0 ?x2.0\n  rec_option ?f1.0 ?f2.0 None = ?f1.0\n  rec_option ?f1.0 ?f2.0 (Some ?x2.0) = ?f2.0 ?x2.0\n  map_option ?f None = None\n  map_option ?f (Some ?x2.0) = Some (?f ?x2.0)\n  rel_option ?R None None\n  rel_option ?R (Some ?x2.0) (Some ?y2.0) = ?R ?x2.0 ?y2.0\n  \\<not> rel_option ?R None (Some ?y2.0)\n  \\<not> rel_option ?R (Some ?y2.0) None\n  set_option None = {}\n  set_option (Some ?x2.0) = {?x2.0}\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "from odd"], ["proof (chain)\npicking this:\n  odd j", "have j: \"Suc j = 2 * ?j2\""], ["proof (prove)\nusing this:\n  odd j\n\ngoal (1 subgoal):\n 1. Suc j = 2 * (j div 2 + 1)", "by auto"], ["proof (state)\nthis:\n  Suc j = 2 * (j div 2 + 1)\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "from arg_cong[OF this, of \"\\<lambda> j. p ^ j div p\"]"], ["proof (chain)\npicking this:\n  p ^ Suc j div p = p ^ (2 * (j div 2 + 1)) div p", "have pj: \"p ^ j = q * q div p\" and qq: \"q * q = p ^ j * p\""], ["proof (prove)\nusing this:\n  p ^ Suc j div p = p ^ (2 * (j div 2 + 1)) div p\n\ngoal (1 subgoal):\n 1. p ^ j = q * q div p &&& q * q = p ^ j * p", "unfolding *(10)"], ["proof (prove)\nusing this:\n  p ^ Suc j div p = p ^ (2 * (j div 2 + 1)) div p\n\ngoal (1 subgoal):\n 1. p ^ j = p ^ (j div 2 + 1) * p ^ (j div 2 + 1) div p &&&\n    p ^ (j div 2 + 1) * p ^ (j div 2 + 1) = p ^ j * p", "using p"], ["proof (prove)\nusing this:\n  p ^ Suc j div p = p ^ (2 * (j div 2 + 1)) div p\n  1 < p\n\ngoal (1 subgoal):\n 1. p ^ j = p ^ (j div 2 + 1) * p ^ (j div 2 + 1) div p &&&\n    p ^ (j div 2 + 1) * p ^ (j div 2 + 1) = p ^ j * p", "by (simp add: power_mult_distrib semiring_normalization_rules(30-))+"], ["proof (state)\nthis:\n  p ^ j = q * q div p\n  q * q = p ^ j * p\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "let ?pj = \"p ^ j\""], ["proof (state)\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "from res[unfolded simp] pj"], ["proof (chain)\npicking this:\n  (q * q div p, poly_mod.Mp (q * q div p) S2, poly_mod.Mp (q * q div p) T2,\n   poly_mod.Mp (q * q div p) D2, poly_mod.Mp (q * q div p) H2) =\n  (q', S', T', D', H')\n  p ^ j = q * q div p", "have id: \n        \"q' = p^j\" \n        \"S' = poly_mod.Mp ?pj S2\" \n        \"T' = poly_mod.Mp ?pj T2\" \n        \"D' = poly_mod.Mp ?pj D2\" \n        \"H' = poly_mod.Mp ?pj H2\""], ["proof (prove)\nusing this:\n  (q * q div p, poly_mod.Mp (q * q div p) S2, poly_mod.Mp (q * q div p) T2,\n   poly_mod.Mp (q * q div p) D2, poly_mod.Mp (q * q div p) H2) =\n  (q', S', T', D', H')\n  p ^ j = q * q div p\n\ngoal (1 subgoal):\n 1. (q' = p ^ j &&& S' = poly_mod.Mp (p ^ j) S2) &&&\n    T' = poly_mod.Mp (p ^ j) T2 &&&\n    D' = poly_mod.Mp (p ^ j) D2 &&& H' = poly_mod.Mp (p ^ j) H2", "by auto"], ["proof (state)\nthis:\n  q' = p ^ j\n  S' = poly_mod.Mp (p ^ j) S2\n  T' = poly_mod.Mp (p ^ j) T2\n  D' = poly_mod.Mp (p ^ j) D2\n  H' = poly_mod.Mp (p ^ j) H2\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "interpret pj: poly_mod_2 ?pj"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_2 (p ^ j)", "by (rule mod_2[OF \\<open>1 \\<le> j\\<close>])"], ["proof (state)\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "have norm: \"pj.Mp D' = D'\" \"pj.Mp H' = H'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pj.Mp D' = D' &&& pj.Mp H' = H'", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. pj.eq_m (pj.Mp D2) D2 &&& pj.eq_m (pj.Mp H2) H2", "by (auto simp: poly_mod.Mp_Mp)"], ["proof (state)\nthis:\n  pj.Mp D' = D'\n  pj.Mp H' = H'\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "have mon: \"monic D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic D'", "using pj.monic_Mp[OF step(11)]"], ["proof (prove)\nusing this:\n  monic (pj.Mp D2)\n\ngoal (1 subgoal):\n 1. monic D'", "unfolding id"], ["proof (prove)\nusing this:\n  monic (pj.Mp D2)\n\ngoal (1 subgoal):\n 1. monic (pj.Mp D2)", "."], ["proof (state)\nthis:\n  monic D'\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "have id': \"Mp (pj.Mp D) = Mp D\" for D"], ["proof (prove)\ngoal (1 subgoal):\n 1. pj.Mp D =m D", "using \\<open>1 \\<le> j\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> j\n\ngoal (1 subgoal):\n 1. pj.Mp D =m D", "by (simp add: Mp_Mp_pow_is_Mp p)"], ["proof (state)\nthis:\n  pj.Mp ?D =m ?D\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "have eq: \"eq_m D1 D2 \\<Longrightarrow> eq_m D1 (pj.Mp D2)\" for D1 D2"], ["proof (prove)\ngoal (1 subgoal):\n 1. D1 =m D2 \\<Longrightarrow> D1 =m pj.Mp D2", "unfolding id'"], ["proof (prove)\ngoal (1 subgoal):\n 1. D1 =m D2 \\<Longrightarrow> D1 =m D2", "by auto"], ["proof (state)\nthis:\n  ?D1.0 =m ?D2.0 \\<Longrightarrow> ?D1.0 =m pj.Mp ?D2.0\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "have id'': \"pj.Mp (poly_mod.Mp (q * q) D) = pj.Mp D\" for D"], ["proof (prove)\ngoal (1 subgoal):\n 1. pj.eq_m (poly_mod.Mp (q * q) D) D", "unfolding qq"], ["proof (prove)\ngoal (1 subgoal):\n 1. pj.eq_m (poly_mod.Mp (p ^ j * p) D) D", "by (rule pj.Mp_product_modulus[OF refl], insert p, auto)"], ["proof (state)\nthis:\n  pj.eq_m (poly_mod.Mp (q * q) ?D) ?D\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "{"], ["proof (state)\nthis:\n  pj.eq_m (poly_mod.Mp (q * q) ?D) ?D\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "fix D1 D2"], ["proof (state)\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "assume \"poly_mod.eq_m (q * q) D1 D2\""], ["proof (state)\nthis:\n  poly_mod.Mp (q * q) D1 = poly_mod.Mp (q * q) D2\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "hence \"poly_mod.Mp (q * q) D1 = poly_mod.Mp (q * q) D2\""], ["proof (prove)\nusing this:\n  poly_mod.Mp (q * q) D1 = poly_mod.Mp (q * q) D2\n\ngoal (1 subgoal):\n 1. poly_mod.Mp (q * q) D1 = poly_mod.Mp (q * q) D2", "by simp"], ["proof (state)\nthis:\n  poly_mod.Mp (q * q) D1 = poly_mod.Mp (q * q) D2\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "from arg_cong[OF this, of pj.Mp]"], ["proof (chain)\npicking this:\n  pj.eq_m (poly_mod.Mp (q * q) D1) (poly_mod.Mp (q * q) D2)", "have \"pj.Mp D1 = pj.Mp D2\""], ["proof (prove)\nusing this:\n  pj.eq_m (poly_mod.Mp (q * q) D1) (poly_mod.Mp (q * q) D2)\n\ngoal (1 subgoal):\n 1. pj.eq_m D1 D2", "unfolding id''"], ["proof (prove)\nusing this:\n  pj.eq_m D1 D2\n\ngoal (1 subgoal):\n 1. pj.eq_m D1 D2", "."], ["proof (state)\nthis:\n  pj.eq_m D1 D2\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "}"], ["proof (state)\nthis:\n  poly_mod.Mp (q * q) ?D1a2 = poly_mod.Mp (q * q) ?D2a2 \\<Longrightarrow>\n  pj.eq_m ?D1a2 ?D2a2\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "note eq' = this"], ["proof (state)\nthis:\n  poly_mod.Mp (q * q) ?D1a2 = poly_mod.Mp (q * q) ?D2a2 \\<Longrightarrow>\n  pj.eq_m ?D1a2 ?D2a2\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "from eq'[OF step(1)]"], ["proof (chain)\npicking this:\n  pj.eq_m C (D2 * H2)", "have eq1: \"pj.eq_m C (D' * H')\""], ["proof (prove)\nusing this:\n  pj.eq_m C (D2 * H2)\n\ngoal (1 subgoal):\n 1. pj.eq_m C (D' * H')", "unfolding id"], ["proof (prove)\nusing this:\n  pj.eq_m C (D2 * H2)\n\ngoal (1 subgoal):\n 1. pj.eq_m C (pj.Mp D2 * pj.Mp H2)", "by simp"], ["proof (state)\nthis:\n  pj.eq_m C (D' * H')\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "from eq'[OF step(2)]"], ["proof (chain)\npicking this:\n  pj.eq_m (D2 * S2 + H2 * T2) 1", "have eq2: \"pj.eq_m (D' * S' + H' * T') 1\""], ["proof (prove)\nusing this:\n  pj.eq_m (D2 * S2 + H2 * T2) 1\n\ngoal (1 subgoal):\n 1. pj.eq_m (D' * S' + H' * T') 1", "unfolding id"], ["proof (prove)\nusing this:\n  pj.eq_m (D2 * S2 + H2 * T2) 1\n\ngoal (1 subgoal):\n 1. pj.eq_m (pj.Mp D2 * pj.Mp S2 + pj.Mp H2 * pj.Mp T2) 1", "by (metis pj.mult_Mp pj.plus_Mp)"], ["proof (state)\nthis:\n  pj.eq_m (D' * S' + H' * T') 1\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "from **(4-5)"], ["proof (chain)\npicking this:\n  D1 =m D2\n  H1 =m H2", "have eq3: \"eq_m D1 D'\" \"eq_m H1 H'\""], ["proof (prove)\nusing this:\n  D1 =m D2\n  H1 =m H2\n\ngoal (1 subgoal):\n 1. D1 =m D' &&& H1 =m H'", "unfolding id"], ["proof (prove)\nusing this:\n  D1 =m D2\n  H1 =m H2\n\ngoal (1 subgoal):\n 1. D1 =m pj.Mp D2 &&& H1 =m pj.Mp H2", "by (auto intro: eq)"], ["proof (state)\nthis:\n  D1 =m D'\n  H1 =m H'\n\ngoal (1 subgoal):\n 1. odd j \\<Longrightarrow>\n    poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "from norm mon eq1 eq2 eq3"], ["proof (chain)\npicking this:\n  pj.Mp D' = D'\n  pj.Mp H' = H'\n  monic D'\n  pj.eq_m C (D' * H')\n  pj.eq_m (D' * S' + H' * T') 1\n  D1 =m D'\n  H1 =m H'", "show ?thesis"], ["proof (prove)\nusing this:\n  pj.Mp D' = D'\n  pj.Mp H' = H'\n  monic D'\n  pj.eq_m C (D' * H')\n  pj.eq_m (D' * S' + H' * T') 1\n  D1 =m D'\n  H1 =m H'\n\ngoal (1 subgoal):\n 1. poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n    monic D' \\<and>\n    D1 =m D' \\<and>\n    H1 =m H' \\<and>\n    poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n    poly_mod.Mp q' D' = D' \\<and>\n    poly_mod.Mp q' H' = H' \\<and>\n    poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j", "unfolding id"], ["proof (prove)\nusing this:\n  pj.eq_m (pj.Mp D2) D2\n  pj.eq_m (pj.Mp H2) H2\n  monic (pj.Mp D2)\n  pj.eq_m C (pj.Mp D2 * pj.Mp H2)\n  pj.eq_m (pj.Mp D2 * pj.Mp S2 + pj.Mp H2 * pj.Mp T2) 1\n  D1 =m pj.Mp D2\n  H1 =m pj.Mp H2\n\ngoal (1 subgoal):\n 1. pj.eq_m C (pj.Mp D2 * pj.Mp H2) \\<and>\n    monic (pj.Mp D2) \\<and>\n    D1 =m pj.Mp D2 \\<and>\n    H1 =m pj.Mp H2 \\<and>\n    pj.eq_m (pj.Mp D2 * pj.Mp S2 + pj.Mp H2 * pj.Mp T2) 1 \\<and>\n    pj.eq_m (pj.Mp D2) D2 \\<and>\n    pj.eq_m (pj.Mp H2) H2 \\<and>\n    pj.eq_m (pj.Mp S2) S2 \\<and> pj.eq_m (pj.Mp T2) T2 \\<and> p ^ j = p ^ j", "by simp"], ["proof (state)\nthis:\n  poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n  monic D' \\<and>\n  D1 =m D' \\<and>\n  H1 =m H' \\<and>\n  poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n  poly_mod.Mp q' D' = D' \\<and>\n  poly_mod.Mp q' H' = H' \\<and>\n  poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n  monic D' \\<and>\n  D1 =m D' \\<and>\n  H1 =m H' \\<and>\n  poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n  poly_mod.Mp q' D' = D' \\<and>\n  poly_mod.Mp q' H' = H' \\<and>\n  poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_mod.Mp q' C = poly_mod.Mp q' (D' * H') \\<and>\n  monic D' \\<and>\n  D1 =m D' \\<and>\n  H1 =m H' \\<and>\n  poly_mod.Mp q' (D' * S' + H' * T') = poly_mod.Mp q' 1 \\<and>\n  poly_mod.Mp q' D' = D' \\<and>\n  poly_mod.Mp q' H' = H' \\<and>\n  poly_mod.Mp q' S' = S' \\<and> poly_mod.Mp q' T' = T' \\<and> q' = p ^ j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma quadratic_hensel_main: assumes res: \"quadratic_hensel_main j = (D,H)\" \n  shows \"poly_mod.eq_m (p^j) C (D * H)\"\n  \"monic D\" \n  \"poly_mod.eq_m p D1 D\" \n  \"poly_mod.eq_m p H1 H\" \n  \"poly_mod.Mp (p^j) D = D\" \n  \"poly_mod.Mp (p^j) H = H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_mod.Mp (p ^ j) C = poly_mod.Mp (p ^ j) (D * H) &&&\n     monic D &&& poly_mod.Mp p D1 = poly_mod.Mp p D) &&&\n    poly_mod.Mp p H1 = poly_mod.Mp p H &&&\n    poly_mod.Mp (p ^ j) D = D &&& poly_mod.Mp (p ^ j) H = H", "proof (atomize(full), goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. (poly_mod.Mp (p ^ j) C = poly_mod.Mp (p ^ j) (D * H) \\<and>\n     monic D \\<and> poly_mod.Mp p D1 = poly_mod.Mp p D) \\<and>\n    poly_mod.Mp p H1 = poly_mod.Mp p H \\<and>\n    poly_mod.Mp (p ^ j) D = D \\<and> poly_mod.Mp (p ^ j) H = H", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. (poly_mod.Mp (p ^ j) C = poly_mod.Mp (p ^ j) (D * H) \\<and>\n     monic D \\<and> poly_mod.Mp p D1 = poly_mod.Mp p D) \\<and>\n    poly_mod.Mp p H1 = poly_mod.Mp p H \\<and>\n    poly_mod.Mp (p ^ j) D = D \\<and> poly_mod.Mp (p ^ j) H = H", "let ?hen = \"quadratic_hensel_loop j\""], ["proof (state)\ngoal (1 subgoal):\n 1. (poly_mod.Mp (p ^ j) C = poly_mod.Mp (p ^ j) (D * H) \\<and>\n     monic D \\<and> poly_mod.Mp p D1 = poly_mod.Mp p D) \\<and>\n    poly_mod.Mp p H1 = poly_mod.Mp p H \\<and>\n    poly_mod.Mp (p ^ j) D = D \\<and> poly_mod.Mp (p ^ j) H = H", "from res"], ["proof (chain)\npicking this:\n  local.quadratic_hensel_main j = (D, H)", "obtain q S T where hen: \"?hen = (q, S, T, D, H)\""], ["proof (prove)\nusing this:\n  local.quadratic_hensel_main j = (D, H)\n\ngoal (1 subgoal):\n 1. (\\<And>q S T.\n        local.quadratic_hensel_loop j = (q, S, T, D, H) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?hen, auto simp: quadratic_hensel_main_def)"], ["proof (state)\nthis:\n  local.quadratic_hensel_loop j = (q, S, T, D, H)\n\ngoal (1 subgoal):\n 1. (poly_mod.Mp (p ^ j) C = poly_mod.Mp (p ^ j) (D * H) \\<and>\n     monic D \\<and> poly_mod.Mp p D1 = poly_mod.Mp p D) \\<and>\n    poly_mod.Mp p H1 = poly_mod.Mp p H \\<and>\n    poly_mod.Mp (p ^ j) D = D \\<and> poly_mod.Mp (p ^ j) H = H", "from quadratic_hensel_loop[OF hen]"], ["proof (chain)\npicking this:\n  poly_mod.Mp q C = poly_mod.Mp q (D * H) \\<and>\n  monic D \\<and>\n  poly_mod.Mp p D1 = poly_mod.Mp p D \\<and>\n  poly_mod.Mp p H1 = poly_mod.Mp p H \\<and>\n  poly_mod.Mp q (D * S + H * T) = poly_mod.Mp q 1 \\<and>\n  poly_mod.Mp q D = D \\<and>\n  poly_mod.Mp q H = H \\<and>\n  poly_mod.Mp q S = S \\<and> poly_mod.Mp q T = T \\<and> q = p ^ j", "show ?case"], ["proof (prove)\nusing this:\n  poly_mod.Mp q C = poly_mod.Mp q (D * H) \\<and>\n  monic D \\<and>\n  poly_mod.Mp p D1 = poly_mod.Mp p D \\<and>\n  poly_mod.Mp p H1 = poly_mod.Mp p H \\<and>\n  poly_mod.Mp q (D * S + H * T) = poly_mod.Mp q 1 \\<and>\n  poly_mod.Mp q D = D \\<and>\n  poly_mod.Mp q H = H \\<and>\n  poly_mod.Mp q S = S \\<and> poly_mod.Mp q T = T \\<and> q = p ^ j\n\ngoal (1 subgoal):\n 1. (poly_mod.Mp (p ^ j) C = poly_mod.Mp (p ^ j) (D * H) \\<and>\n     monic D \\<and> poly_mod.Mp p D1 = poly_mod.Mp p D) \\<and>\n    poly_mod.Mp p H1 = poly_mod.Mp p H \\<and>\n    poly_mod.Mp (p ^ j) D = D \\<and> poly_mod.Mp (p ^ j) H = H", "by auto"], ["proof (state)\nthis:\n  (poly_mod.Mp (p ^ j) C = poly_mod.Mp (p ^ j) (D * H) \\<and>\n   monic D \\<and> poly_mod.Mp p D1 = poly_mod.Mp p D) \\<and>\n  poly_mod.Mp p H1 = poly_mod.Mp p H \\<and>\n  poly_mod.Mp (p ^ j) D = D \\<and> poly_mod.Mp (p ^ j) H = H\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "end"], ["", "datatype 'a factor_tree = Factor_Leaf 'a \"int poly\" | Factor_Node 'a \"'a factor_tree\" \"'a factor_tree\""], ["", "fun factor_node_info :: \"'a factor_tree \\<Rightarrow> 'a\" where\n  \"factor_node_info (Factor_Leaf i x) = i\" \n| \"factor_node_info (Factor_Node i l r) = i\""], ["", "fun factors_of_factor_tree :: \"'a factor_tree \\<Rightarrow> int poly multiset\" where\n  \"factors_of_factor_tree (Factor_Leaf i x) = {#x#}\" \n| \"factors_of_factor_tree (Factor_Node i l r) = factors_of_factor_tree l + factors_of_factor_tree r\""], ["", "fun product_factor_tree :: \"int \\<Rightarrow> 'a factor_tree \\<Rightarrow> int poly factor_tree\" where\n  \"product_factor_tree p (Factor_Leaf i x) = (Factor_Leaf x x)\" \n| \"product_factor_tree p (Factor_Node i l r) = (let \n    L = product_factor_tree p l;\n    R = product_factor_tree p r;\n    f = factor_node_info L;\n    g = factor_node_info R;\n    fg = poly_mod.Mp p (f * g) \n   in Factor_Node fg L R)\""], ["", "fun sub_trees :: \"'a factor_tree \\<Rightarrow> 'a factor_tree set\" where\n  \"sub_trees (Factor_Leaf i x) = {Factor_Leaf i x}\" \n| \"sub_trees (Factor_Node i l r) = insert (Factor_Node i l r) (sub_trees l \\<union> sub_trees r)\""], ["", "lemma sub_trees_refl[simp]: \"t \\<in> sub_trees t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> sub_trees t", "by (cases t, auto)"], ["", "lemma product_factor_tree: assumes \"\\<And> x. x \\<in># factors_of_factor_tree t \\<Longrightarrow> poly_mod.Mp p x = x\" \n  shows \"u \\<in> sub_trees (product_factor_tree p t) \\<Longrightarrow> factor_node_info u = f \\<Longrightarrow> \n  poly_mod.Mp p f = f \\<and> f = poly_mod.Mp p (prod_mset (factors_of_factor_tree u)) \\<and> \n  factors_of_factor_tree (product_factor_tree p t) = factors_of_factor_tree t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t);\n     factor_node_info u = f\\<rbrakk>\n    \\<Longrightarrow> poly_mod.Mp p f = f \\<and>\n                      f =\n                      poly_mod.Mp p\n                       (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n                      factors_of_factor_tree (product_factor_tree p t) =\n                      factors_of_factor_tree t", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in># factors_of_factor_tree t \\<Longrightarrow> poly_mod.Mp p ?x = ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t);\n     factor_node_info u = f\\<rbrakk>\n    \\<Longrightarrow> poly_mod.Mp p f = f \\<and>\n                      f =\n                      poly_mod.Mp p\n                       (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n                      factors_of_factor_tree (product_factor_tree p t) =\n                      factors_of_factor_tree t", "proof (induct t arbitrary: u f)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 u f.\n       \\<lbrakk>u \\<in> sub_trees\n                         (product_factor_tree p (Factor_Leaf x1 x2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Leaf x1 x2) \\<Longrightarrow>\n           poly_mod.Mp p x = x\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp p f = f \\<and>\n                         f =\n                         poly_mod.Mp p\n                          (\\<Prod>\\<^sub>#\n                            (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Leaf x1 x2)) =\n                         factors_of_factor_tree (Factor_Leaf x1 x2)\n 2. \\<And>x1 t1 t2 u f.\n       \\<lbrakk>\\<And>u f.\n                   \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t1);\n                    factor_node_info u = f;\n                    \\<And>x.\n                       x \\<in># factors_of_factor_tree t1 \\<Longrightarrow>\n                       poly_mod.Mp p x = x\\<rbrakk>\n                   \\<Longrightarrow> poly_mod.Mp p f = f \\<and>\n                                     f =\n                                     poly_mod.Mp p\n(\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n                                     factors_of_factor_tree\n(product_factor_tree p t1) =\n                                     factors_of_factor_tree t1;\n        \\<And>u f.\n           \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t2);\n            factor_node_info u = f;\n            \\<And>x.\n               x \\<in># factors_of_factor_tree t2 \\<Longrightarrow>\n               poly_mod.Mp p x = x\\<rbrakk>\n           \\<Longrightarrow> poly_mod.Mp p f = f \\<and>\n                             f =\n                             poly_mod.Mp p\n                              (\\<Prod>\\<^sub>#\n                                (factors_of_factor_tree u)) \\<and>\n                             factors_of_factor_tree\n                              (product_factor_tree p t2) =\n                             factors_of_factor_tree t2;\n        u \\<in> sub_trees (product_factor_tree p (Factor_Node x1 t1 t2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Node x1 t1 t2) \\<Longrightarrow>\n           poly_mod.Mp p x = x\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp p f = f \\<and>\n                         f =\n                         poly_mod.Mp p\n                          (\\<Prod>\\<^sub>#\n                            (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Node x1 t1 t2)) =\n                         factors_of_factor_tree (Factor_Node x1 t1 t2)", "case (Factor_Node i l r u f)"], ["proof (state)\nthis:\n  \\<lbrakk>?u \\<in> sub_trees (product_factor_tree p l);\n   factor_node_info ?u = ?f;\n   \\<And>x.\n      x \\<in># factors_of_factor_tree l \\<Longrightarrow>\n      poly_mod.Mp p x = x\\<rbrakk>\n  \\<Longrightarrow> poly_mod.Mp p ?f = ?f \\<and>\n                    ?f =\n                    poly_mod.Mp p\n                     (\\<Prod>\\<^sub># (factors_of_factor_tree ?u)) \\<and>\n                    factors_of_factor_tree (product_factor_tree p l) =\n                    factors_of_factor_tree l\n  \\<lbrakk>?u \\<in> sub_trees (product_factor_tree p r);\n   factor_node_info ?u = ?f;\n   \\<And>x.\n      x \\<in># factors_of_factor_tree r \\<Longrightarrow>\n      poly_mod.Mp p x = x\\<rbrakk>\n  \\<Longrightarrow> poly_mod.Mp p ?f = ?f \\<and>\n                    ?f =\n                    poly_mod.Mp p\n                     (\\<Prod>\\<^sub># (factors_of_factor_tree ?u)) \\<and>\n                    factors_of_factor_tree (product_factor_tree p r) =\n                    factors_of_factor_tree r\n  u \\<in> sub_trees (product_factor_tree p (Factor_Node i l r))\n  factor_node_info u = f\n  ?x \\<in># factors_of_factor_tree (Factor_Node i l r) \\<Longrightarrow>\n  poly_mod.Mp p ?x = ?x\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 u f.\n       \\<lbrakk>u \\<in> sub_trees\n                         (product_factor_tree p (Factor_Leaf x1 x2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Leaf x1 x2) \\<Longrightarrow>\n           poly_mod.Mp p x = x\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp p f = f \\<and>\n                         f =\n                         poly_mod.Mp p\n                          (\\<Prod>\\<^sub>#\n                            (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Leaf x1 x2)) =\n                         factors_of_factor_tree (Factor_Leaf x1 x2)\n 2. \\<And>x1 t1 t2 u f.\n       \\<lbrakk>\\<And>u f.\n                   \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t1);\n                    factor_node_info u = f;\n                    \\<And>x.\n                       x \\<in># factors_of_factor_tree t1 \\<Longrightarrow>\n                       poly_mod.Mp p x = x\\<rbrakk>\n                   \\<Longrightarrow> poly_mod.Mp p f = f \\<and>\n                                     f =\n                                     poly_mod.Mp p\n(\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n                                     factors_of_factor_tree\n(product_factor_tree p t1) =\n                                     factors_of_factor_tree t1;\n        \\<And>u f.\n           \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t2);\n            factor_node_info u = f;\n            \\<And>x.\n               x \\<in># factors_of_factor_tree t2 \\<Longrightarrow>\n               poly_mod.Mp p x = x\\<rbrakk>\n           \\<Longrightarrow> poly_mod.Mp p f = f \\<and>\n                             f =\n                             poly_mod.Mp p\n                              (\\<Prod>\\<^sub>#\n                                (factors_of_factor_tree u)) \\<and>\n                             factors_of_factor_tree\n                              (product_factor_tree p t2) =\n                             factors_of_factor_tree t2;\n        u \\<in> sub_trees (product_factor_tree p (Factor_Node x1 t1 t2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Node x1 t1 t2) \\<Longrightarrow>\n           poly_mod.Mp p x = x\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp p f = f \\<and>\n                         f =\n                         poly_mod.Mp p\n                          (\\<Prod>\\<^sub>#\n                            (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Node x1 t1 t2)) =\n                         factors_of_factor_tree (Factor_Node x1 t1 t2)", "interpret poly_mod p"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 u f.\n       \\<lbrakk>u \\<in> sub_trees\n                         (product_factor_tree p (Factor_Leaf x1 x2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Leaf x1 x2) \\<Longrightarrow>\n           Mp x = x\\<rbrakk>\n       \\<Longrightarrow> Mp f = f \\<and>\n                         f =\n                         Mp (\\<Prod>\\<^sub>#\n                              (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Leaf x1 x2)) =\n                         factors_of_factor_tree (Factor_Leaf x1 x2)\n 2. \\<And>x1 t1 t2 u f.\n       \\<lbrakk>\\<And>u f.\n                   \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t1);\n                    factor_node_info u = f;\n                    \\<And>x.\n                       x \\<in># factors_of_factor_tree t1 \\<Longrightarrow>\n                       Mp x = x\\<rbrakk>\n                   \\<Longrightarrow> Mp f = f \\<and>\n                                     f =\n                                     Mp\n(\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n                                     factors_of_factor_tree\n(product_factor_tree p t1) =\n                                     factors_of_factor_tree t1;\n        \\<And>u f.\n           \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t2);\n            factor_node_info u = f;\n            \\<And>x.\n               x \\<in># factors_of_factor_tree t2 \\<Longrightarrow>\n               Mp x = x\\<rbrakk>\n           \\<Longrightarrow> Mp f = f \\<and>\n                             f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree u)) \\<and>\n                             factors_of_factor_tree\n                              (product_factor_tree p t2) =\n                             factors_of_factor_tree t2;\n        u \\<in> sub_trees (product_factor_tree p (Factor_Node x1 t1 t2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Node x1 t1 t2) \\<Longrightarrow>\n           Mp x = x\\<rbrakk>\n       \\<Longrightarrow> Mp f = f \\<and>\n                         f =\n                         Mp (\\<Prod>\\<^sub>#\n                              (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Node x1 t1 t2)) =\n                         factors_of_factor_tree (Factor_Node x1 t1 t2)", "let ?L = \"product_factor_tree p l\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 u f.\n       \\<lbrakk>u \\<in> sub_trees\n                         (product_factor_tree p (Factor_Leaf x1 x2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Leaf x1 x2) \\<Longrightarrow>\n           Mp x = x\\<rbrakk>\n       \\<Longrightarrow> Mp f = f \\<and>\n                         f =\n                         Mp (\\<Prod>\\<^sub>#\n                              (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Leaf x1 x2)) =\n                         factors_of_factor_tree (Factor_Leaf x1 x2)\n 2. \\<And>x1 t1 t2 u f.\n       \\<lbrakk>\\<And>u f.\n                   \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t1);\n                    factor_node_info u = f;\n                    \\<And>x.\n                       x \\<in># factors_of_factor_tree t1 \\<Longrightarrow>\n                       Mp x = x\\<rbrakk>\n                   \\<Longrightarrow> Mp f = f \\<and>\n                                     f =\n                                     Mp\n(\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n                                     factors_of_factor_tree\n(product_factor_tree p t1) =\n                                     factors_of_factor_tree t1;\n        \\<And>u f.\n           \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t2);\n            factor_node_info u = f;\n            \\<And>x.\n               x \\<in># factors_of_factor_tree t2 \\<Longrightarrow>\n               Mp x = x\\<rbrakk>\n           \\<Longrightarrow> Mp f = f \\<and>\n                             f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree u)) \\<and>\n                             factors_of_factor_tree\n                              (product_factor_tree p t2) =\n                             factors_of_factor_tree t2;\n        u \\<in> sub_trees (product_factor_tree p (Factor_Node x1 t1 t2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Node x1 t1 t2) \\<Longrightarrow>\n           Mp x = x\\<rbrakk>\n       \\<Longrightarrow> Mp f = f \\<and>\n                         f =\n                         Mp (\\<Prod>\\<^sub>#\n                              (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Node x1 t1 t2)) =\n                         factors_of_factor_tree (Factor_Node x1 t1 t2)", "let ?R = \"product_factor_tree p r\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 u f.\n       \\<lbrakk>u \\<in> sub_trees\n                         (product_factor_tree p (Factor_Leaf x1 x2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Leaf x1 x2) \\<Longrightarrow>\n           Mp x = x\\<rbrakk>\n       \\<Longrightarrow> Mp f = f \\<and>\n                         f =\n                         Mp (\\<Prod>\\<^sub>#\n                              (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Leaf x1 x2)) =\n                         factors_of_factor_tree (Factor_Leaf x1 x2)\n 2. \\<And>x1 t1 t2 u f.\n       \\<lbrakk>\\<And>u f.\n                   \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t1);\n                    factor_node_info u = f;\n                    \\<And>x.\n                       x \\<in># factors_of_factor_tree t1 \\<Longrightarrow>\n                       Mp x = x\\<rbrakk>\n                   \\<Longrightarrow> Mp f = f \\<and>\n                                     f =\n                                     Mp\n(\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n                                     factors_of_factor_tree\n(product_factor_tree p t1) =\n                                     factors_of_factor_tree t1;\n        \\<And>u f.\n           \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t2);\n            factor_node_info u = f;\n            \\<And>x.\n               x \\<in># factors_of_factor_tree t2 \\<Longrightarrow>\n               Mp x = x\\<rbrakk>\n           \\<Longrightarrow> Mp f = f \\<and>\n                             f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree u)) \\<and>\n                             factors_of_factor_tree\n                              (product_factor_tree p t2) =\n                             factors_of_factor_tree t2;\n        u \\<in> sub_trees (product_factor_tree p (Factor_Node x1 t1 t2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Node x1 t1 t2) \\<Longrightarrow>\n           Mp x = x\\<rbrakk>\n       \\<Longrightarrow> Mp f = f \\<and>\n                         f =\n                         Mp (\\<Prod>\\<^sub>#\n                              (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Node x1 t1 t2)) =\n                         factors_of_factor_tree (Factor_Node x1 t1 t2)", "let ?f = \"factor_node_info ?L\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 u f.\n       \\<lbrakk>u \\<in> sub_trees\n                         (product_factor_tree p (Factor_Leaf x1 x2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Leaf x1 x2) \\<Longrightarrow>\n           Mp x = x\\<rbrakk>\n       \\<Longrightarrow> Mp f = f \\<and>\n                         f =\n                         Mp (\\<Prod>\\<^sub>#\n                              (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Leaf x1 x2)) =\n                         factors_of_factor_tree (Factor_Leaf x1 x2)\n 2. \\<And>x1 t1 t2 u f.\n       \\<lbrakk>\\<And>u f.\n                   \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t1);\n                    factor_node_info u = f;\n                    \\<And>x.\n                       x \\<in># factors_of_factor_tree t1 \\<Longrightarrow>\n                       Mp x = x\\<rbrakk>\n                   \\<Longrightarrow> Mp f = f \\<and>\n                                     f =\n                                     Mp\n(\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n                                     factors_of_factor_tree\n(product_factor_tree p t1) =\n                                     factors_of_factor_tree t1;\n        \\<And>u f.\n           \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t2);\n            factor_node_info u = f;\n            \\<And>x.\n               x \\<in># factors_of_factor_tree t2 \\<Longrightarrow>\n               Mp x = x\\<rbrakk>\n           \\<Longrightarrow> Mp f = f \\<and>\n                             f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree u)) \\<and>\n                             factors_of_factor_tree\n                              (product_factor_tree p t2) =\n                             factors_of_factor_tree t2;\n        u \\<in> sub_trees (product_factor_tree p (Factor_Node x1 t1 t2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Node x1 t1 t2) \\<Longrightarrow>\n           Mp x = x\\<rbrakk>\n       \\<Longrightarrow> Mp f = f \\<and>\n                         f =\n                         Mp (\\<Prod>\\<^sub>#\n                              (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Node x1 t1 t2)) =\n                         factors_of_factor_tree (Factor_Node x1 t1 t2)", "let ?g = \"factor_node_info ?R\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 u f.\n       \\<lbrakk>u \\<in> sub_trees\n                         (product_factor_tree p (Factor_Leaf x1 x2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Leaf x1 x2) \\<Longrightarrow>\n           Mp x = x\\<rbrakk>\n       \\<Longrightarrow> Mp f = f \\<and>\n                         f =\n                         Mp (\\<Prod>\\<^sub>#\n                              (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Leaf x1 x2)) =\n                         factors_of_factor_tree (Factor_Leaf x1 x2)\n 2. \\<And>x1 t1 t2 u f.\n       \\<lbrakk>\\<And>u f.\n                   \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t1);\n                    factor_node_info u = f;\n                    \\<And>x.\n                       x \\<in># factors_of_factor_tree t1 \\<Longrightarrow>\n                       Mp x = x\\<rbrakk>\n                   \\<Longrightarrow> Mp f = f \\<and>\n                                     f =\n                                     Mp\n(\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n                                     factors_of_factor_tree\n(product_factor_tree p t1) =\n                                     factors_of_factor_tree t1;\n        \\<And>u f.\n           \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t2);\n            factor_node_info u = f;\n            \\<And>x.\n               x \\<in># factors_of_factor_tree t2 \\<Longrightarrow>\n               Mp x = x\\<rbrakk>\n           \\<Longrightarrow> Mp f = f \\<and>\n                             f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree u)) \\<and>\n                             factors_of_factor_tree\n                              (product_factor_tree p t2) =\n                             factors_of_factor_tree t2;\n        u \\<in> sub_trees (product_factor_tree p (Factor_Node x1 t1 t2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Node x1 t1 t2) \\<Longrightarrow>\n           Mp x = x\\<rbrakk>\n       \\<Longrightarrow> Mp f = f \\<and>\n                         f =\n                         Mp (\\<Prod>\\<^sub>#\n                              (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Node x1 t1 t2)) =\n                         factors_of_factor_tree (Factor_Node x1 t1 t2)", "let ?fg = \"Mp (?f * ?g)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 u f.\n       \\<lbrakk>u \\<in> sub_trees\n                         (product_factor_tree p (Factor_Leaf x1 x2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Leaf x1 x2) \\<Longrightarrow>\n           Mp x = x\\<rbrakk>\n       \\<Longrightarrow> Mp f = f \\<and>\n                         f =\n                         Mp (\\<Prod>\\<^sub>#\n                              (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Leaf x1 x2)) =\n                         factors_of_factor_tree (Factor_Leaf x1 x2)\n 2. \\<And>x1 t1 t2 u f.\n       \\<lbrakk>\\<And>u f.\n                   \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t1);\n                    factor_node_info u = f;\n                    \\<And>x.\n                       x \\<in># factors_of_factor_tree t1 \\<Longrightarrow>\n                       Mp x = x\\<rbrakk>\n                   \\<Longrightarrow> Mp f = f \\<and>\n                                     f =\n                                     Mp\n(\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n                                     factors_of_factor_tree\n(product_factor_tree p t1) =\n                                     factors_of_factor_tree t1;\n        \\<And>u f.\n           \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t2);\n            factor_node_info u = f;\n            \\<And>x.\n               x \\<in># factors_of_factor_tree t2 \\<Longrightarrow>\n               Mp x = x\\<rbrakk>\n           \\<Longrightarrow> Mp f = f \\<and>\n                             f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree u)) \\<and>\n                             factors_of_factor_tree\n                              (product_factor_tree p t2) =\n                             factors_of_factor_tree t2;\n        u \\<in> sub_trees (product_factor_tree p (Factor_Node x1 t1 t2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Node x1 t1 t2) \\<Longrightarrow>\n           Mp x = x\\<rbrakk>\n       \\<Longrightarrow> Mp f = f \\<and>\n                         f =\n                         Mp (\\<Prod>\\<^sub>#\n                              (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Node x1 t1 t2)) =\n                         factors_of_factor_tree (Factor_Node x1 t1 t2)", "have \"Mp ?f = ?f \\<and> ?f = Mp (prod_mset (factors_of_factor_tree ?L)) \\<and>\n      (factors_of_factor_tree ?L) = (factors_of_factor_tree l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (factor_node_info (product_factor_tree p l)) =\n    factor_node_info (product_factor_tree p l) \\<and>\n    factor_node_info (product_factor_tree p l) =\n    Mp (\\<Prod>\\<^sub>#\n         (factors_of_factor_tree (product_factor_tree p l))) \\<and>\n    factors_of_factor_tree (product_factor_tree p l) =\n    factors_of_factor_tree l", "by (rule Factor_Node(1)[OF sub_trees_refl refl], insert Factor_Node(5), auto)"], ["proof (state)\nthis:\n  Mp (factor_node_info (product_factor_tree p l)) =\n  factor_node_info (product_factor_tree p l) \\<and>\n  factor_node_info (product_factor_tree p l) =\n  Mp (\\<Prod>\\<^sub>#\n       (factors_of_factor_tree (product_factor_tree p l))) \\<and>\n  factors_of_factor_tree (product_factor_tree p l) =\n  factors_of_factor_tree l\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 u f.\n       \\<lbrakk>u \\<in> sub_trees\n                         (product_factor_tree p (Factor_Leaf x1 x2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Leaf x1 x2) \\<Longrightarrow>\n           Mp x = x\\<rbrakk>\n       \\<Longrightarrow> Mp f = f \\<and>\n                         f =\n                         Mp (\\<Prod>\\<^sub>#\n                              (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Leaf x1 x2)) =\n                         factors_of_factor_tree (Factor_Leaf x1 x2)\n 2. \\<And>x1 t1 t2 u f.\n       \\<lbrakk>\\<And>u f.\n                   \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t1);\n                    factor_node_info u = f;\n                    \\<And>x.\n                       x \\<in># factors_of_factor_tree t1 \\<Longrightarrow>\n                       Mp x = x\\<rbrakk>\n                   \\<Longrightarrow> Mp f = f \\<and>\n                                     f =\n                                     Mp\n(\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n                                     factors_of_factor_tree\n(product_factor_tree p t1) =\n                                     factors_of_factor_tree t1;\n        \\<And>u f.\n           \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t2);\n            factor_node_info u = f;\n            \\<And>x.\n               x \\<in># factors_of_factor_tree t2 \\<Longrightarrow>\n               Mp x = x\\<rbrakk>\n           \\<Longrightarrow> Mp f = f \\<and>\n                             f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree u)) \\<and>\n                             factors_of_factor_tree\n                              (product_factor_tree p t2) =\n                             factors_of_factor_tree t2;\n        u \\<in> sub_trees (product_factor_tree p (Factor_Node x1 t1 t2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Node x1 t1 t2) \\<Longrightarrow>\n           Mp x = x\\<rbrakk>\n       \\<Longrightarrow> Mp f = f \\<and>\n                         f =\n                         Mp (\\<Prod>\\<^sub>#\n                              (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Node x1 t1 t2)) =\n                         factors_of_factor_tree (Factor_Node x1 t1 t2)", "hence IH1: \"?f = Mp (prod_mset (factors_of_factor_tree ?L))\" \n      \"(factors_of_factor_tree ?L) = (factors_of_factor_tree l)\""], ["proof (prove)\nusing this:\n  Mp (factor_node_info (product_factor_tree p l)) =\n  factor_node_info (product_factor_tree p l) \\<and>\n  factor_node_info (product_factor_tree p l) =\n  Mp (\\<Prod>\\<^sub>#\n       (factors_of_factor_tree (product_factor_tree p l))) \\<and>\n  factors_of_factor_tree (product_factor_tree p l) =\n  factors_of_factor_tree l\n\ngoal (1 subgoal):\n 1. factor_node_info (product_factor_tree p l) =\n    Mp (\\<Prod>\\<^sub>#\n         (factors_of_factor_tree (product_factor_tree p l))) &&&\n    factors_of_factor_tree (product_factor_tree p l) =\n    factors_of_factor_tree l", "by blast+"], ["proof (state)\nthis:\n  factor_node_info (product_factor_tree p l) =\n  Mp (\\<Prod>\\<^sub># (factors_of_factor_tree (product_factor_tree p l)))\n  factors_of_factor_tree (product_factor_tree p l) =\n  factors_of_factor_tree l\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 u f.\n       \\<lbrakk>u \\<in> sub_trees\n                         (product_factor_tree p (Factor_Leaf x1 x2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Leaf x1 x2) \\<Longrightarrow>\n           Mp x = x\\<rbrakk>\n       \\<Longrightarrow> Mp f = f \\<and>\n                         f =\n                         Mp (\\<Prod>\\<^sub>#\n                              (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Leaf x1 x2)) =\n                         factors_of_factor_tree (Factor_Leaf x1 x2)\n 2. \\<And>x1 t1 t2 u f.\n       \\<lbrakk>\\<And>u f.\n                   \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t1);\n                    factor_node_info u = f;\n                    \\<And>x.\n                       x \\<in># factors_of_factor_tree t1 \\<Longrightarrow>\n                       Mp x = x\\<rbrakk>\n                   \\<Longrightarrow> Mp f = f \\<and>\n                                     f =\n                                     Mp\n(\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n                                     factors_of_factor_tree\n(product_factor_tree p t1) =\n                                     factors_of_factor_tree t1;\n        \\<And>u f.\n           \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t2);\n            factor_node_info u = f;\n            \\<And>x.\n               x \\<in># factors_of_factor_tree t2 \\<Longrightarrow>\n               Mp x = x\\<rbrakk>\n           \\<Longrightarrow> Mp f = f \\<and>\n                             f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree u)) \\<and>\n                             factors_of_factor_tree\n                              (product_factor_tree p t2) =\n                             factors_of_factor_tree t2;\n        u \\<in> sub_trees (product_factor_tree p (Factor_Node x1 t1 t2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Node x1 t1 t2) \\<Longrightarrow>\n           Mp x = x\\<rbrakk>\n       \\<Longrightarrow> Mp f = f \\<and>\n                         f =\n                         Mp (\\<Prod>\\<^sub>#\n                              (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Node x1 t1 t2)) =\n                         factors_of_factor_tree (Factor_Node x1 t1 t2)", "have \"Mp ?g = ?g \\<and> ?g = Mp (prod_mset (factors_of_factor_tree ?R)) \\<and>\n      (factors_of_factor_tree ?R) = (factors_of_factor_tree r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (factor_node_info (product_factor_tree p r)) =\n    factor_node_info (product_factor_tree p r) \\<and>\n    factor_node_info (product_factor_tree p r) =\n    Mp (\\<Prod>\\<^sub>#\n         (factors_of_factor_tree (product_factor_tree p r))) \\<and>\n    factors_of_factor_tree (product_factor_tree p r) =\n    factors_of_factor_tree r", "by (rule Factor_Node(2)[OF sub_trees_refl refl], insert Factor_Node(5), auto)"], ["proof (state)\nthis:\n  Mp (factor_node_info (product_factor_tree p r)) =\n  factor_node_info (product_factor_tree p r) \\<and>\n  factor_node_info (product_factor_tree p r) =\n  Mp (\\<Prod>\\<^sub>#\n       (factors_of_factor_tree (product_factor_tree p r))) \\<and>\n  factors_of_factor_tree (product_factor_tree p r) =\n  factors_of_factor_tree r\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 u f.\n       \\<lbrakk>u \\<in> sub_trees\n                         (product_factor_tree p (Factor_Leaf x1 x2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Leaf x1 x2) \\<Longrightarrow>\n           Mp x = x\\<rbrakk>\n       \\<Longrightarrow> Mp f = f \\<and>\n                         f =\n                         Mp (\\<Prod>\\<^sub>#\n                              (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Leaf x1 x2)) =\n                         factors_of_factor_tree (Factor_Leaf x1 x2)\n 2. \\<And>x1 t1 t2 u f.\n       \\<lbrakk>\\<And>u f.\n                   \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t1);\n                    factor_node_info u = f;\n                    \\<And>x.\n                       x \\<in># factors_of_factor_tree t1 \\<Longrightarrow>\n                       Mp x = x\\<rbrakk>\n                   \\<Longrightarrow> Mp f = f \\<and>\n                                     f =\n                                     Mp\n(\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n                                     factors_of_factor_tree\n(product_factor_tree p t1) =\n                                     factors_of_factor_tree t1;\n        \\<And>u f.\n           \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t2);\n            factor_node_info u = f;\n            \\<And>x.\n               x \\<in># factors_of_factor_tree t2 \\<Longrightarrow>\n               Mp x = x\\<rbrakk>\n           \\<Longrightarrow> Mp f = f \\<and>\n                             f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree u)) \\<and>\n                             factors_of_factor_tree\n                              (product_factor_tree p t2) =\n                             factors_of_factor_tree t2;\n        u \\<in> sub_trees (product_factor_tree p (Factor_Node x1 t1 t2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Node x1 t1 t2) \\<Longrightarrow>\n           Mp x = x\\<rbrakk>\n       \\<Longrightarrow> Mp f = f \\<and>\n                         f =\n                         Mp (\\<Prod>\\<^sub>#\n                              (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Node x1 t1 t2)) =\n                         factors_of_factor_tree (Factor_Node x1 t1 t2)", "hence IH2: \"?g = Mp (prod_mset (factors_of_factor_tree ?R))\" \n      \"(factors_of_factor_tree ?R) = (factors_of_factor_tree r)\""], ["proof (prove)\nusing this:\n  Mp (factor_node_info (product_factor_tree p r)) =\n  factor_node_info (product_factor_tree p r) \\<and>\n  factor_node_info (product_factor_tree p r) =\n  Mp (\\<Prod>\\<^sub>#\n       (factors_of_factor_tree (product_factor_tree p r))) \\<and>\n  factors_of_factor_tree (product_factor_tree p r) =\n  factors_of_factor_tree r\n\ngoal (1 subgoal):\n 1. factor_node_info (product_factor_tree p r) =\n    Mp (\\<Prod>\\<^sub>#\n         (factors_of_factor_tree (product_factor_tree p r))) &&&\n    factors_of_factor_tree (product_factor_tree p r) =\n    factors_of_factor_tree r", "by blast+"], ["proof (state)\nthis:\n  factor_node_info (product_factor_tree p r) =\n  Mp (\\<Prod>\\<^sub># (factors_of_factor_tree (product_factor_tree p r)))\n  factors_of_factor_tree (product_factor_tree p r) =\n  factors_of_factor_tree r\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 u f.\n       \\<lbrakk>u \\<in> sub_trees\n                         (product_factor_tree p (Factor_Leaf x1 x2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Leaf x1 x2) \\<Longrightarrow>\n           Mp x = x\\<rbrakk>\n       \\<Longrightarrow> Mp f = f \\<and>\n                         f =\n                         Mp (\\<Prod>\\<^sub>#\n                              (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Leaf x1 x2)) =\n                         factors_of_factor_tree (Factor_Leaf x1 x2)\n 2. \\<And>x1 t1 t2 u f.\n       \\<lbrakk>\\<And>u f.\n                   \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t1);\n                    factor_node_info u = f;\n                    \\<And>x.\n                       x \\<in># factors_of_factor_tree t1 \\<Longrightarrow>\n                       Mp x = x\\<rbrakk>\n                   \\<Longrightarrow> Mp f = f \\<and>\n                                     f =\n                                     Mp\n(\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n                                     factors_of_factor_tree\n(product_factor_tree p t1) =\n                                     factors_of_factor_tree t1;\n        \\<And>u f.\n           \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t2);\n            factor_node_info u = f;\n            \\<And>x.\n               x \\<in># factors_of_factor_tree t2 \\<Longrightarrow>\n               Mp x = x\\<rbrakk>\n           \\<Longrightarrow> Mp f = f \\<and>\n                             f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree u)) \\<and>\n                             factors_of_factor_tree\n                              (product_factor_tree p t2) =\n                             factors_of_factor_tree t2;\n        u \\<in> sub_trees (product_factor_tree p (Factor_Node x1 t1 t2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Node x1 t1 t2) \\<Longrightarrow>\n           Mp x = x\\<rbrakk>\n       \\<Longrightarrow> Mp f = f \\<and>\n                         f =\n                         Mp (\\<Prod>\\<^sub>#\n                              (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Node x1 t1 t2)) =\n                         factors_of_factor_tree (Factor_Node x1 t1 t2)", "have id: \"(factors_of_factor_tree (product_factor_tree p (Factor_Node i l r))) =\n    (factors_of_factor_tree (Factor_Node i l r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)", "by (simp add: Let_def IH1 IH2)"], ["proof (state)\nthis:\n  factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n  factors_of_factor_tree (Factor_Node i l r)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 u f.\n       \\<lbrakk>u \\<in> sub_trees\n                         (product_factor_tree p (Factor_Leaf x1 x2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Leaf x1 x2) \\<Longrightarrow>\n           Mp x = x\\<rbrakk>\n       \\<Longrightarrow> Mp f = f \\<and>\n                         f =\n                         Mp (\\<Prod>\\<^sub>#\n                              (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Leaf x1 x2)) =\n                         factors_of_factor_tree (Factor_Leaf x1 x2)\n 2. \\<And>x1 t1 t2 u f.\n       \\<lbrakk>\\<And>u f.\n                   \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t1);\n                    factor_node_info u = f;\n                    \\<And>x.\n                       x \\<in># factors_of_factor_tree t1 \\<Longrightarrow>\n                       Mp x = x\\<rbrakk>\n                   \\<Longrightarrow> Mp f = f \\<and>\n                                     f =\n                                     Mp\n(\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n                                     factors_of_factor_tree\n(product_factor_tree p t1) =\n                                     factors_of_factor_tree t1;\n        \\<And>u f.\n           \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t2);\n            factor_node_info u = f;\n            \\<And>x.\n               x \\<in># factors_of_factor_tree t2 \\<Longrightarrow>\n               Mp x = x\\<rbrakk>\n           \\<Longrightarrow> Mp f = f \\<and>\n                             f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree u)) \\<and>\n                             factors_of_factor_tree\n                              (product_factor_tree p t2) =\n                             factors_of_factor_tree t2;\n        u \\<in> sub_trees (product_factor_tree p (Factor_Node x1 t1 t2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Node x1 t1 t2) \\<Longrightarrow>\n           Mp x = x\\<rbrakk>\n       \\<Longrightarrow> Mp f = f \\<and>\n                         f =\n                         Mp (\\<Prod>\\<^sub>#\n                              (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Node x1 t1 t2)) =\n                         factors_of_factor_tree (Factor_Node x1 t1 t2)", "from Factor_Node(3)"], ["proof (chain)\npicking this:\n  u \\<in> sub_trees (product_factor_tree p (Factor_Node i l r))", "consider (root) \"u = Factor_Node ?fg ?L ?R\" \n    | (l) \"u \\<in> sub_trees ?L\" | (r) \"u \\<in> sub_trees ?R\""], ["proof (prove)\nusing this:\n  u \\<in> sub_trees (product_factor_tree p (Factor_Node i l r))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u =\n             Factor_Node\n              (Mp (factor_node_info (product_factor_tree p l) *\n                   factor_node_info (product_factor_tree p r)))\n              (product_factor_tree p l)\n              (product_factor_tree p r) \\<Longrightarrow>\n             thesis;\n     u \\<in> sub_trees (product_factor_tree p l) \\<Longrightarrow> thesis;\n     u \\<in> sub_trees (product_factor_tree p r) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  \\<lbrakk>u =\n           Factor_Node\n            (Mp (factor_node_info (product_factor_tree p l) *\n                 factor_node_info (product_factor_tree p r)))\n            (product_factor_tree p l)\n            (product_factor_tree p r) \\<Longrightarrow>\n           ?thesis;\n   u \\<in> sub_trees (product_factor_tree p l) \\<Longrightarrow> ?thesis;\n   u \\<in> sub_trees (product_factor_tree p r) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 u f.\n       \\<lbrakk>u \\<in> sub_trees\n                         (product_factor_tree p (Factor_Leaf x1 x2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Leaf x1 x2) \\<Longrightarrow>\n           Mp x = x\\<rbrakk>\n       \\<Longrightarrow> Mp f = f \\<and>\n                         f =\n                         Mp (\\<Prod>\\<^sub>#\n                              (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Leaf x1 x2)) =\n                         factors_of_factor_tree (Factor_Leaf x1 x2)\n 2. \\<And>x1 t1 t2 u f.\n       \\<lbrakk>\\<And>u f.\n                   \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t1);\n                    factor_node_info u = f;\n                    \\<And>x.\n                       x \\<in># factors_of_factor_tree t1 \\<Longrightarrow>\n                       Mp x = x\\<rbrakk>\n                   \\<Longrightarrow> Mp f = f \\<and>\n                                     f =\n                                     Mp\n(\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n                                     factors_of_factor_tree\n(product_factor_tree p t1) =\n                                     factors_of_factor_tree t1;\n        \\<And>u f.\n           \\<lbrakk>u \\<in> sub_trees (product_factor_tree p t2);\n            factor_node_info u = f;\n            \\<And>x.\n               x \\<in># factors_of_factor_tree t2 \\<Longrightarrow>\n               Mp x = x\\<rbrakk>\n           \\<Longrightarrow> Mp f = f \\<and>\n                             f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree u)) \\<and>\n                             factors_of_factor_tree\n                              (product_factor_tree p t2) =\n                             factors_of_factor_tree t2;\n        u \\<in> sub_trees (product_factor_tree p (Factor_Node x1 t1 t2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Node x1 t1 t2) \\<Longrightarrow>\n           Mp x = x\\<rbrakk>\n       \\<Longrightarrow> Mp f = f \\<and>\n                         f =\n                         Mp (\\<Prod>\\<^sub>#\n                              (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Node x1 t1 t2)) =\n                         factors_of_factor_tree (Factor_Node x1 t1 t2)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>u =\n           Factor_Node\n            (Mp (factor_node_info (product_factor_tree p l) *\n                 factor_node_info (product_factor_tree p r)))\n            (product_factor_tree p l)\n            (product_factor_tree p r) \\<Longrightarrow>\n           ?thesis;\n   u \\<in> sub_trees (product_factor_tree p l) \\<Longrightarrow> ?thesis;\n   u \\<in> sub_trees (product_factor_tree p r) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. u =\n    Factor_Node\n     (Mp (factor_node_info (product_factor_tree p l) *\n          factor_node_info (product_factor_tree p r)))\n     (product_factor_tree p l) (product_factor_tree p r) \\<Longrightarrow>\n    Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)\n 2. u \\<in> sub_trees (product_factor_tree p l) \\<Longrightarrow>\n    Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)\n 3. u \\<in> sub_trees (product_factor_tree p r) \\<Longrightarrow>\n    Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)", "case root"], ["proof (state)\nthis:\n  u =\n  Factor_Node\n   (Mp (factor_node_info (product_factor_tree p l) *\n        factor_node_info (product_factor_tree p r)))\n   (product_factor_tree p l) (product_factor_tree p r)\n\ngoal (3 subgoals):\n 1. u =\n    Factor_Node\n     (Mp (factor_node_info (product_factor_tree p l) *\n          factor_node_info (product_factor_tree p r)))\n     (product_factor_tree p l) (product_factor_tree p r) \\<Longrightarrow>\n    Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)\n 2. u \\<in> sub_trees (product_factor_tree p l) \\<Longrightarrow>\n    Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)\n 3. u \\<in> sub_trees (product_factor_tree p r) \\<Longrightarrow>\n    Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)", "with Factor_Node"], ["proof (chain)\npicking this:\n  \\<lbrakk>?u \\<in> sub_trees (product_factor_tree p l);\n   factor_node_info ?u = ?f;\n   \\<And>x.\n      x \\<in># factors_of_factor_tree l \\<Longrightarrow> Mp x = x\\<rbrakk>\n  \\<Longrightarrow> Mp ?f = ?f \\<and>\n                    ?f =\n                    Mp (\\<Prod>\\<^sub># (factors_of_factor_tree ?u)) \\<and>\n                    factors_of_factor_tree (product_factor_tree p l) =\n                    factors_of_factor_tree l\n  \\<lbrakk>?u \\<in> sub_trees (product_factor_tree p r);\n   factor_node_info ?u = ?f;\n   \\<And>x.\n      x \\<in># factors_of_factor_tree r \\<Longrightarrow> Mp x = x\\<rbrakk>\n  \\<Longrightarrow> Mp ?f = ?f \\<and>\n                    ?f =\n                    Mp (\\<Prod>\\<^sub># (factors_of_factor_tree ?u)) \\<and>\n                    factors_of_factor_tree (product_factor_tree p r) =\n                    factors_of_factor_tree r\n  u \\<in> sub_trees (product_factor_tree p (Factor_Node i l r))\n  factor_node_info u = f\n  ?x \\<in># factors_of_factor_tree (Factor_Node i l r) \\<Longrightarrow>\n  Mp ?x = ?x\n  u =\n  Factor_Node\n   (Mp (factor_node_info (product_factor_tree p l) *\n        factor_node_info (product_factor_tree p r)))\n   (product_factor_tree p l) (product_factor_tree p r)", "have f: \"f = ?fg\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<in> sub_trees (product_factor_tree p l);\n   factor_node_info ?u = ?f;\n   \\<And>x.\n      x \\<in># factors_of_factor_tree l \\<Longrightarrow> Mp x = x\\<rbrakk>\n  \\<Longrightarrow> Mp ?f = ?f \\<and>\n                    ?f =\n                    Mp (\\<Prod>\\<^sub># (factors_of_factor_tree ?u)) \\<and>\n                    factors_of_factor_tree (product_factor_tree p l) =\n                    factors_of_factor_tree l\n  \\<lbrakk>?u \\<in> sub_trees (product_factor_tree p r);\n   factor_node_info ?u = ?f;\n   \\<And>x.\n      x \\<in># factors_of_factor_tree r \\<Longrightarrow> Mp x = x\\<rbrakk>\n  \\<Longrightarrow> Mp ?f = ?f \\<and>\n                    ?f =\n                    Mp (\\<Prod>\\<^sub># (factors_of_factor_tree ?u)) \\<and>\n                    factors_of_factor_tree (product_factor_tree p r) =\n                    factors_of_factor_tree r\n  u \\<in> sub_trees (product_factor_tree p (Factor_Node i l r))\n  factor_node_info u = f\n  ?x \\<in># factors_of_factor_tree (Factor_Node i l r) \\<Longrightarrow>\n  Mp ?x = ?x\n  u =\n  Factor_Node\n   (Mp (factor_node_info (product_factor_tree p l) *\n        factor_node_info (product_factor_tree p r)))\n   (product_factor_tree p l) (product_factor_tree p r)\n\ngoal (1 subgoal):\n 1. f =\n    Mp (factor_node_info (product_factor_tree p l) *\n        factor_node_info (product_factor_tree p r))", "by auto"], ["proof (state)\nthis:\n  f =\n  Mp (factor_node_info (product_factor_tree p l) *\n      factor_node_info (product_factor_tree p r))\n\ngoal (3 subgoals):\n 1. u =\n    Factor_Node\n     (Mp (factor_node_info (product_factor_tree p l) *\n          factor_node_info (product_factor_tree p r)))\n     (product_factor_tree p l) (product_factor_tree p r) \\<Longrightarrow>\n    Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)\n 2. u \\<in> sub_trees (product_factor_tree p l) \\<Longrightarrow>\n    Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)\n 3. u \\<in> sub_trees (product_factor_tree p r) \\<Longrightarrow>\n    Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)", "unfolding f root id"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (factor_node_info (product_factor_tree p l) *\n        factor_node_info (product_factor_tree p r)) =m\n    factor_node_info (product_factor_tree p l) *\n    factor_node_info (product_factor_tree p r) \\<and>\n    factor_node_info (product_factor_tree p l) *\n    factor_node_info (product_factor_tree p r) =m\n    \\<Prod>\\<^sub>#\n     (factors_of_factor_tree\n       (Factor_Node\n         (Mp (factor_node_info (product_factor_tree p l) *\n              factor_node_info (product_factor_tree p r)))\n         (product_factor_tree p l) (product_factor_tree p r))) \\<and>\n    factors_of_factor_tree (Factor_Node i l r) =\n    factors_of_factor_tree (Factor_Node i l r)", "by (simp add: Let_def ac_simps IH1 IH2)"], ["proof (state)\nthis:\n  Mp f = f \\<and>\n  f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n  factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n  factors_of_factor_tree (Factor_Node i l r)\n\ngoal (2 subgoals):\n 1. u \\<in> sub_trees (product_factor_tree p l) \\<Longrightarrow>\n    Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)\n 2. u \\<in> sub_trees (product_factor_tree p r) \\<Longrightarrow>\n    Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<in> sub_trees (product_factor_tree p l) \\<Longrightarrow>\n    Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)\n 2. u \\<in> sub_trees (product_factor_tree p r) \\<Longrightarrow>\n    Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)", "case l"], ["proof (state)\nthis:\n  u \\<in> sub_trees (product_factor_tree p l)\n\ngoal (2 subgoals):\n 1. u \\<in> sub_trees (product_factor_tree p l) \\<Longrightarrow>\n    Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)\n 2. u \\<in> sub_trees (product_factor_tree p r) \\<Longrightarrow>\n    Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)", "have \"Mp f = f \\<and> f = Mp (prod_mset (factors_of_factor_tree u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp f = f \\<and> f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u))", "using Factor_Node(1)[OF l Factor_Node(4)] Factor_Node(5)"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in># factors_of_factor_tree l \\<Longrightarrow>\n      Mp x = x) \\<Longrightarrow>\n  Mp f = f \\<and>\n  f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n  factors_of_factor_tree (product_factor_tree p l) =\n  factors_of_factor_tree l\n  ?x \\<in># factors_of_factor_tree (Factor_Node i l r) \\<Longrightarrow>\n  Mp ?x = ?x\n\ngoal (1 subgoal):\n 1. Mp f = f \\<and> f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u))", "by auto"], ["proof (state)\nthis:\n  Mp f = f \\<and> f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u))\n\ngoal (2 subgoals):\n 1. u \\<in> sub_trees (product_factor_tree p l) \\<Longrightarrow>\n    Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)\n 2. u \\<in> sub_trees (product_factor_tree p r) \\<Longrightarrow>\n    Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Mp f = f \\<and> f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u))\n\ngoal (1 subgoal):\n 1. Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)", "unfolding id"], ["proof (prove)\nusing this:\n  Mp f = f \\<and> f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u))\n\ngoal (1 subgoal):\n 1. Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (Factor_Node i l r) =\n    factors_of_factor_tree (Factor_Node i l r)", "by blast"], ["proof (state)\nthis:\n  Mp f = f \\<and>\n  f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n  factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n  factors_of_factor_tree (Factor_Node i l r)\n\ngoal (1 subgoal):\n 1. u \\<in> sub_trees (product_factor_tree p r) \\<Longrightarrow>\n    Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<in> sub_trees (product_factor_tree p r) \\<Longrightarrow>\n    Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)", "case r"], ["proof (state)\nthis:\n  u \\<in> sub_trees (product_factor_tree p r)\n\ngoal (1 subgoal):\n 1. u \\<in> sub_trees (product_factor_tree p r) \\<Longrightarrow>\n    Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)", "have \"Mp f = f \\<and> f = Mp (prod_mset (factors_of_factor_tree u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp f = f \\<and> f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u))", "using Factor_Node(2)[OF r Factor_Node(4)] Factor_Node(5)"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in># factors_of_factor_tree r \\<Longrightarrow>\n      Mp x = x) \\<Longrightarrow>\n  Mp f = f \\<and>\n  f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n  factors_of_factor_tree (product_factor_tree p r) =\n  factors_of_factor_tree r\n  ?x \\<in># factors_of_factor_tree (Factor_Node i l r) \\<Longrightarrow>\n  Mp ?x = ?x\n\ngoal (1 subgoal):\n 1. Mp f = f \\<and> f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u))", "by auto"], ["proof (state)\nthis:\n  Mp f = f \\<and> f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u))\n\ngoal (1 subgoal):\n 1. u \\<in> sub_trees (product_factor_tree p r) \\<Longrightarrow>\n    Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Mp f = f \\<and> f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u))\n\ngoal (1 subgoal):\n 1. Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n    factors_of_factor_tree (Factor_Node i l r)", "unfolding id"], ["proof (prove)\nusing this:\n  Mp f = f \\<and> f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u))\n\ngoal (1 subgoal):\n 1. Mp f = f \\<and>\n    f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n    factors_of_factor_tree (Factor_Node i l r) =\n    factors_of_factor_tree (Factor_Node i l r)", "by blast"], ["proof (state)\nthis:\n  Mp f = f \\<and>\n  f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n  factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n  factors_of_factor_tree (Factor_Node i l r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Mp f = f \\<and>\n  f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree u)) \\<and>\n  factors_of_factor_tree (product_factor_tree p (Factor_Node i l r)) =\n  factors_of_factor_tree (Factor_Node i l r)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 u f.\n       \\<lbrakk>u \\<in> sub_trees\n                         (product_factor_tree p (Factor_Leaf x1 x2));\n        factor_node_info u = f;\n        \\<And>x.\n           x \\<in># factors_of_factor_tree\n                     (Factor_Leaf x1 x2) \\<Longrightarrow>\n           Mp x = x\\<rbrakk>\n       \\<Longrightarrow> Mp f = f \\<and>\n                         f =\n                         Mp (\\<Prod>\\<^sub>#\n                              (factors_of_factor_tree u)) \\<and>\n                         factors_of_factor_tree\n                          (product_factor_tree p (Factor_Leaf x1 x2)) =\n                         factors_of_factor_tree (Factor_Leaf x1 x2)", "qed auto"], ["", "fun create_factor_tree_simple :: \"int poly list \\<Rightarrow> unit factor_tree\" where\n  \"create_factor_tree_simple xs = (let n = length xs in if n \\<le> 1 then Factor_Leaf () (hd xs)\n    else let i = n div 2;\n      xs1 = take i xs;\n      xs2 = drop i xs\n      in Factor_Node () (create_factor_tree_simple xs1) (create_factor_tree_simple xs2)\n      )\""], ["", "declare create_factor_tree_simple.simps[simp del]"], ["", "lemma create_factor_tree_simple: \"xs \\<noteq> [] \\<Longrightarrow> factors_of_factor_tree (create_factor_tree_simple xs) = mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_simple xs) = mset xs", "proof (induct xs rule: wf_induct[OF wf_measure[of length]])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measure length \\<longrightarrow>\n                   y \\<noteq> [] \\<longrightarrow>\n                   factors_of_factor_tree (create_factor_tree_simple y) =\n                   mset y;\n        x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> factors_of_factor_tree\n                          (create_factor_tree_simple x) =\n                         mset x", "case (1 xs)"], ["proof (state)\nthis:\n  \\<forall>y.\n     (y, xs) \\<in> measure length \\<longrightarrow>\n     y \\<noteq> [] \\<longrightarrow>\n     factors_of_factor_tree (create_factor_tree_simple y) = mset y\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measure length \\<longrightarrow>\n                   y \\<noteq> [] \\<longrightarrow>\n                   factors_of_factor_tree (create_factor_tree_simple y) =\n                   mset y;\n        x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> factors_of_factor_tree\n                          (create_factor_tree_simple x) =\n                         mset x", "from 1(2)"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "have xs: \"length xs \\<noteq> 0\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. length xs \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  length xs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measure length \\<longrightarrow>\n                   y \\<noteq> [] \\<longrightarrow>\n                   factors_of_factor_tree (create_factor_tree_simple y) =\n                   mset y;\n        x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> factors_of_factor_tree\n                          (create_factor_tree_simple x) =\n                         mset x", "then"], ["proof (chain)\npicking this:\n  length xs \\<noteq> 0", "consider (base) \"length xs = 1\" | (step) \"length xs > 1\""], ["proof (prove)\nusing this:\n  length xs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = 1 \\<Longrightarrow> thesis;\n     1 < length xs \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>length xs = 1 \\<Longrightarrow> ?thesis;\n   1 < length xs \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measure length \\<longrightarrow>\n                   y \\<noteq> [] \\<longrightarrow>\n                   factors_of_factor_tree (create_factor_tree_simple y) =\n                   mset y;\n        x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> factors_of_factor_tree\n                          (create_factor_tree_simple x) =\n                         mset x", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>length xs = 1 \\<Longrightarrow> ?thesis;\n   1 < length xs \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. factors_of_factor_tree (create_factor_tree_simple xs) = mset xs", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. length xs = 1 \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_simple xs) = mset xs\n 2. 1 < length xs \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_simple xs) = mset xs", "case base"], ["proof (state)\nthis:\n  length xs = 1\n\ngoal (2 subgoals):\n 1. length xs = 1 \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_simple xs) = mset xs\n 2. 1 < length xs \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_simple xs) = mset xs", "then"], ["proof (chain)\npicking this:\n  length xs = 1", "obtain x where xs: \"xs = [x]\""], ["proof (prove)\nusing this:\n  length xs = 1\n\ngoal (1 subgoal):\n 1. (\\<And>x. xs = [x] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases xs; cases \"tl xs\"; auto)"], ["proof (state)\nthis:\n  xs = [x]\n\ngoal (2 subgoals):\n 1. length xs = 1 \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_simple xs) = mset xs\n 2. 1 < length xs \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_simple xs) = mset xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = [x]\n\ngoal (1 subgoal):\n 1. factors_of_factor_tree (create_factor_tree_simple xs) = mset xs", "by (auto simp: create_factor_tree_simple.simps)"], ["proof (state)\nthis:\n  factors_of_factor_tree (create_factor_tree_simple xs) = mset xs\n\ngoal (1 subgoal):\n 1. 1 < length xs \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_simple xs) = mset xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < length xs \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_simple xs) = mset xs", "case step"], ["proof (state)\nthis:\n  1 < length xs\n\ngoal (1 subgoal):\n 1. 1 < length xs \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_simple xs) = mset xs", "let ?i = \"length xs div 2\""], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < length xs \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_simple xs) = mset xs", "let ?xs1 = \"take ?i xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < length xs \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_simple xs) = mset xs", "let ?xs2 = \"drop ?i xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < length xs \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_simple xs) = mset xs", "from step"], ["proof (chain)\npicking this:\n  1 < length xs", "have xs1: \"(?xs1, xs) \\<in> measure length\" \"?xs1 \\<noteq> []\""], ["proof (prove)\nusing this:\n  1 < length xs\n\ngoal (1 subgoal):\n 1. (take (length xs div 2) xs, xs) \\<in> measure length &&&\n    take (length xs div 2) xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  (take (length xs div 2) xs, xs) \\<in> measure length\n  take (length xs div 2) xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. 1 < length xs \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_simple xs) = mset xs", "from step"], ["proof (chain)\npicking this:\n  1 < length xs", "have xs2: \"(?xs2, xs) \\<in> measure length\" \"?xs2 \\<noteq> []\""], ["proof (prove)\nusing this:\n  1 < length xs\n\ngoal (1 subgoal):\n 1. (drop (length xs div 2) xs, xs) \\<in> measure length &&&\n    drop (length xs div 2) xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  (drop (length xs div 2) xs, xs) \\<in> measure length\n  drop (length xs div 2) xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. 1 < length xs \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_simple xs) = mset xs", "from step"], ["proof (chain)\npicking this:\n  1 < length xs", "have id: \"create_factor_tree_simple xs = Factor_Node () (create_factor_tree_simple (take ?i xs))\n            (create_factor_tree_simple (drop ?i xs))\""], ["proof (prove)\nusing this:\n  1 < length xs\n\ngoal (1 subgoal):\n 1. create_factor_tree_simple xs =\n    Factor_Node () (create_factor_tree_simple (take (length xs div 2) xs))\n     (create_factor_tree_simple (drop (length xs div 2) xs))", "unfolding create_factor_tree_simple.simps[of xs] Let_def"], ["proof (prove)\nusing this:\n  1 < length xs\n\ngoal (1 subgoal):\n 1. (if length xs \\<le> 1 then Factor_Leaf () (hd xs)\n     else Factor_Node ()\n           (create_factor_tree_simple (take (length xs div 2) xs))\n           (create_factor_tree_simple (drop (length xs div 2) xs))) =\n    Factor_Node () (create_factor_tree_simple (take (length xs div 2) xs))\n     (create_factor_tree_simple (drop (length xs div 2) xs))", "by auto"], ["proof (state)\nthis:\n  create_factor_tree_simple xs =\n  Factor_Node () (create_factor_tree_simple (take (length xs div 2) xs))\n   (create_factor_tree_simple (drop (length xs div 2) xs))\n\ngoal (1 subgoal):\n 1. 1 < length xs \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_simple xs) = mset xs", "have xs: \"xs = ?xs1 @ ?xs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = take (length xs div 2) xs @ drop (length xs div 2) xs", "by auto"], ["proof (state)\nthis:\n  xs = take (length xs div 2) xs @ drop (length xs div 2) xs\n\ngoal (1 subgoal):\n 1. 1 < length xs \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_simple xs) = mset xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. factors_of_factor_tree (create_factor_tree_simple xs) = mset xs", "unfolding id arg_cong[OF xs, of mset] mset_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. factors_of_factor_tree\n     (Factor_Node () (create_factor_tree_simple (take (length xs div 2) xs))\n       (create_factor_tree_simple (drop (length xs div 2) xs))) =\n    mset (take (length xs div 2) xs) + mset (drop (length xs div 2) xs)", "using 1(1)[rule_format, OF xs1] 1(1)[rule_format, OF xs2]"], ["proof (prove)\nusing this:\n  factors_of_factor_tree\n   (create_factor_tree_simple (take (length xs div 2) xs)) =\n  mset (take (length xs div 2) xs)\n  factors_of_factor_tree\n   (create_factor_tree_simple (drop (length xs div 2) xs)) =\n  mset (drop (length xs div 2) xs)\n\ngoal (1 subgoal):\n 1. factors_of_factor_tree\n     (Factor_Node () (create_factor_tree_simple (take (length xs div 2) xs))\n       (create_factor_tree_simple (drop (length xs div 2) xs))) =\n    mset (take (length xs div 2) xs) + mset (drop (length xs div 2) xs)", "by auto"], ["proof (state)\nthis:\n  factors_of_factor_tree (create_factor_tree_simple xs) = mset xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  factors_of_factor_tree (create_factor_tree_simple xs) = mset xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We define a better factorization tree which balances the trees according to their degree.,\n  cf. Modern Computer Algebra, Chapter 15.5 on Multifactor Hensel lifting.\\<close>"], ["", "fun partition_factors_main :: \"nat \\<Rightarrow> ('a \\<times> nat) list \\<Rightarrow> ('a \\<times> nat) list \\<times> ('a \\<times> nat) list\" where\n  \"partition_factors_main s [] = ([], [])\" \n| \"partition_factors_main s ((f,d) # xs) = (if d \\<le> s then case partition_factors_main (s - d) xs of\n     (l,r) \\<Rightarrow> ((f,d) # l, r) else case partition_factors_main d xs of \n     (l,r) \\<Rightarrow> (l, (f,d) # r))\""], ["", "lemma partition_factors_main: \"partition_factors_main s xs = (a,b) \\<Longrightarrow> mset xs = mset a + mset b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_factors_main s xs = (a, b) \\<Longrightarrow>\n    mset xs = mset a + mset b", "by (induct s xs arbitrary: a b rule: partition_factors_main.induct, auto split: if_splits prod.splits)"], ["", "definition partition_factors :: \"('a \\<times> nat) list \\<Rightarrow> ('a \\<times> nat) list \\<times> ('a \\<times> nat) list\" where\n  \"partition_factors xs = (let n = sum_list (map snd xs) div 2 in\n     case partition_factors_main n xs of\n     ([], x # y # ys) \\<Rightarrow> ([x], y # ys)\n   | (x # y # ys, []) \\<Rightarrow> ([x], y # ys)\n   | pair \\<Rightarrow> pair)\""], ["", "lemma partition_factors: \"partition_factors xs = (a,b) \\<Longrightarrow> mset xs = mset a + mset b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_factors xs = (a, b) \\<Longrightarrow>\n    mset xs = mset a + mset b", "unfolding partition_factors_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case partition_factors_main (sum_list (map snd xs) div 2) xs of\n     ([], []) \\<Rightarrow> ([], []) | ([], [x]) \\<Rightarrow> ([], [x])\n     | ([], x # y # ys) \\<Rightarrow> ([x], y # ys)\n     | ([x], b) \\<Rightarrow> ([x], b)\n     | (x # y # ys, []) \\<Rightarrow> ([x], y # ys)\n     | (x # y # ys, ad # listb) \\<Rightarrow> (x # y # ys, ad # listb)) =\n    (a, b) \\<Longrightarrow>\n    mset xs = mset a + mset b", "by (cases \"partition_factors_main (sum_list (map snd xs) div 2) xs\", auto split: list.splits\n    simp: partition_factors_main)"], ["", "lemma partition_factors_length: assumes \"\\<not> length xs \\<le> 1\" \"(a,b) = partition_factors xs\"\n  shows [termination_simp]: \"length a < length xs\" \"length b < length xs\" and \"a \\<noteq> []\" \"b \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length a < length xs &&& length b < length xs) &&&\n    a \\<noteq> [] &&& b \\<noteq> []", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. length a < length xs\n 2. length b < length xs\n 3. a \\<noteq> []\n 4. b \\<noteq> []", "obtain ys zs where main: \"partition_factors_main (sum_list (map snd xs) div 2) xs = (ys,zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        partition_factors_main (sum_list (map snd xs) div 2) xs =\n        (ys, zs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  partition_factors_main (sum_list (map snd xs) div 2) xs = (ys, zs)\n\ngoal (4 subgoals):\n 1. length a < length xs\n 2. length b < length xs\n 3. a \\<noteq> []\n 4. b \\<noteq> []", "note res = assms(2)[unfolded partition_factors_def Let_def main split]"], ["proof (state)\nthis:\n  (a, b) =\n  (case ys of\n   [] \\<Rightarrow>\n     case zs of [] \\<Rightarrow> ([], []) | [x] \\<Rightarrow> ([], [x])\n     | x # y # ys \\<Rightarrow> ([x], y # ys)\n   | [x] \\<Rightarrow> ([x], zs)\n   | x # y # ys \\<Rightarrow>\n       case zs of [] \\<Rightarrow> ([x], y # ys)\n       | ad # listb \\<Rightarrow> (x # y # ys, ad # listb))\n\ngoal (4 subgoals):\n 1. length a < length xs\n 2. length b < length xs\n 3. a \\<noteq> []\n 4. b \\<noteq> []", "from arg_cong[OF partition_factors_main[OF main], of size]"], ["proof (chain)\npicking this:\n  size (mset xs) = size (mset ys + mset zs)", "have len: \"length xs = length ys + length zs\""], ["proof (prove)\nusing this:\n  size (mset xs) = size (mset ys + mset zs)\n\ngoal (1 subgoal):\n 1. length xs = length ys + length zs", "by auto"], ["proof (state)\nthis:\n  length xs = length ys + length zs\n\ngoal (4 subgoals):\n 1. length a < length xs\n 2. length b < length xs\n 3. a \\<noteq> []\n 4. b \\<noteq> []", "with assms(1)"], ["proof (chain)\npicking this:\n  \\<not> length xs \\<le> 1\n  length xs = length ys + length zs", "have len2: \"length ys + length zs \\<ge> 2\""], ["proof (prove)\nusing this:\n  \\<not> length xs \\<le> 1\n  length xs = length ys + length zs\n\ngoal (1 subgoal):\n 1. 2 \\<le> length ys + length zs", "by auto"], ["proof (state)\nthis:\n  2 \\<le> length ys + length zs\n\ngoal (4 subgoals):\n 1. length a < length xs\n 2. length b < length xs\n 3. a \\<noteq> []\n 4. b \\<noteq> []", "from res len2"], ["proof (chain)\npicking this:\n  (a, b) =\n  (case ys of\n   [] \\<Rightarrow>\n     case zs of [] \\<Rightarrow> ([], []) | [x] \\<Rightarrow> ([], [x])\n     | x # y # ys \\<Rightarrow> ([x], y # ys)\n   | [x] \\<Rightarrow> ([x], zs)\n   | x # y # ys \\<Rightarrow>\n       case zs of [] \\<Rightarrow> ([x], y # ys)\n       | ad # listb \\<Rightarrow> (x # y # ys, ad # listb))\n  2 \\<le> length ys + length zs", "have \"length a < length xs \\<and> length b < length xs \\<and> a \\<noteq> [] \\<and> b \\<noteq> []\""], ["proof (prove)\nusing this:\n  (a, b) =\n  (case ys of\n   [] \\<Rightarrow>\n     case zs of [] \\<Rightarrow> ([], []) | [x] \\<Rightarrow> ([], [x])\n     | x # y # ys \\<Rightarrow> ([x], y # ys)\n   | [x] \\<Rightarrow> ([x], zs)\n   | x # y # ys \\<Rightarrow>\n       case zs of [] \\<Rightarrow> ([x], y # ys)\n       | ad # listb \\<Rightarrow> (x # y # ys, ad # listb))\n  2 \\<le> length ys + length zs\n\ngoal (1 subgoal):\n 1. length a < length xs \\<and>\n    length b < length xs \\<and> a \\<noteq> [] \\<and> b \\<noteq> []", "unfolding len"], ["proof (prove)\nusing this:\n  (a, b) =\n  (case ys of\n   [] \\<Rightarrow>\n     case zs of [] \\<Rightarrow> ([], []) | [x] \\<Rightarrow> ([], [x])\n     | x # y # ys \\<Rightarrow> ([x], y # ys)\n   | [x] \\<Rightarrow> ([x], zs)\n   | x # y # ys \\<Rightarrow>\n       case zs of [] \\<Rightarrow> ([x], y # ys)\n       | ad # listb \\<Rightarrow> (x # y # ys, ad # listb))\n  2 \\<le> length ys + length zs\n\ngoal (1 subgoal):\n 1. length a < length ys + length zs \\<and>\n    length b < length ys + length zs \\<and>\n    a \\<noteq> [] \\<and> b \\<noteq> []", "by (cases ys; cases zs; cases \"tl ys\"; cases \"tl zs\"; auto)"], ["proof (state)\nthis:\n  length a < length xs \\<and>\n  length b < length xs \\<and> a \\<noteq> [] \\<and> b \\<noteq> []\n\ngoal (4 subgoals):\n 1. length a < length xs\n 2. length b < length xs\n 3. a \\<noteq> []\n 4. b \\<noteq> []", "thus \"length a < length xs\" \"length b < length xs\" \"a \\<noteq> []\" \"b \\<noteq> []\""], ["proof (prove)\nusing this:\n  length a < length xs \\<and>\n  length b < length xs \\<and> a \\<noteq> [] \\<and> b \\<noteq> []\n\ngoal (1 subgoal):\n 1. (length a < length xs &&& length b < length xs) &&&\n    a \\<noteq> [] &&& b \\<noteq> []", "by blast+"], ["proof (state)\nthis:\n  length a < length xs\n  length b < length xs\n  a \\<noteq> []\n  b \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["", "fun create_factor_tree_balanced :: \"(int poly \\<times> nat)list \\<Rightarrow> unit factor_tree\" where\n  \"create_factor_tree_balanced xs = (if length xs \\<le> 1 then Factor_Leaf () (fst (hd xs)) else\n     case partition_factors xs of (l,r) \\<Rightarrow> Factor_Node () \n      (create_factor_tree_balanced l)\n      (create_factor_tree_balanced r))\""], ["", "definition create_factor_tree :: \"int poly list \\<Rightarrow> unit factor_tree\" where\n  \"create_factor_tree xs = (let ys = map (\\<lambda> f. (f, degree f)) xs;\n     zs = rev (sort_key snd ys)\n     in create_factor_tree_balanced zs)\""], ["", "lemma create_factor_tree_balanced: \"xs \\<noteq> [] \\<Longrightarrow> factors_of_factor_tree (create_factor_tree_balanced xs) = mset (map fst xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_balanced xs) =\n    mset (map fst xs)", "proof (induct xs rule: create_factor_tree_balanced.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>x y.\n                   \\<lbrakk>\\<not> length xs \\<le> 1;\n                    (x, y) = partition_factors xs; x \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> factors_of_factor_tree\n(create_factor_tree_balanced x) =\n                                     mset (map fst x);\n        \\<And>x y.\n           \\<lbrakk>\\<not> length xs \\<le> 1; (x, y) = partition_factors xs;\n            y \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> factors_of_factor_tree\n                              (create_factor_tree_balanced y) =\n                             mset (map fst y);\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> factors_of_factor_tree\n                          (create_factor_tree_balanced xs) =\n                         mset (map fst xs)", "case (1 xs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> length xs \\<le> 1; (?x, ?y) = partition_factors xs;\n   ?x \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> factors_of_factor_tree\n                     (create_factor_tree_balanced ?x) =\n                    mset (map fst ?x)\n  \\<lbrakk>\\<not> length xs \\<le> 1; (?x, ?y) = partition_factors xs;\n   ?y \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> factors_of_factor_tree\n                     (create_factor_tree_balanced ?y) =\n                    mset (map fst ?y)\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>x y.\n                   \\<lbrakk>\\<not> length xs \\<le> 1;\n                    (x, y) = partition_factors xs; x \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> factors_of_factor_tree\n(create_factor_tree_balanced x) =\n                                     mset (map fst x);\n        \\<And>x y.\n           \\<lbrakk>\\<not> length xs \\<le> 1; (x, y) = partition_factors xs;\n            y \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> factors_of_factor_tree\n                              (create_factor_tree_balanced y) =\n                             mset (map fst y);\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> factors_of_factor_tree\n                          (create_factor_tree_balanced xs) =\n                         mset (map fst xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. factors_of_factor_tree (create_factor_tree_balanced xs) =\n    mset (map fst xs)", "proof (cases \"length xs \\<le> 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length xs \\<le> 1 \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_balanced xs) =\n    mset (map fst xs)\n 2. \\<not> length xs \\<le> 1 \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_balanced xs) =\n    mset (map fst xs)", "case True"], ["proof (state)\nthis:\n  length xs \\<le> 1\n\ngoal (2 subgoals):\n 1. length xs \\<le> 1 \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_balanced xs) =\n    mset (map fst xs)\n 2. \\<not> length xs \\<le> 1 \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_balanced xs) =\n    mset (map fst xs)", "with 1(3)"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  length xs \\<le> 1", "obtain x where xs: \"xs = [x]\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  length xs \\<le> 1\n\ngoal (1 subgoal):\n 1. (\\<And>x. xs = [x] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases xs; cases \"tl xs\", auto)"], ["proof (state)\nthis:\n  xs = [x]\n\ngoal (2 subgoals):\n 1. length xs \\<le> 1 \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_balanced xs) =\n    mset (map fst xs)\n 2. \\<not> length xs \\<le> 1 \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_balanced xs) =\n    mset (map fst xs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. factors_of_factor_tree (create_factor_tree_balanced xs) =\n    mset (map fst xs)", "unfolding xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. factors_of_factor_tree (create_factor_tree_balanced [x]) =\n    mset (map fst [x])", "by auto"], ["proof (state)\nthis:\n  factors_of_factor_tree (create_factor_tree_balanced xs) =\n  mset (map fst xs)\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> 1 \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_balanced xs) =\n    mset (map fst xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> 1 \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_balanced xs) =\n    mset (map fst xs)", "case False"], ["proof (state)\nthis:\n  \\<not> length xs \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> 1 \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_balanced xs) =\n    mset (map fst xs)", "obtain a b where part: \"partition_factors xs = (a,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        partition_factors xs = (a, b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  partition_factors xs = (a, b)\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> 1 \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_balanced xs) =\n    mset (map fst xs)", "note abp = this[symmetric]"], ["proof (state)\nthis:\n  (a, b) = partition_factors xs\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> 1 \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_balanced xs) =\n    mset (map fst xs)", "note nonempty = partition_factors_length(3-4)[OF False abp]"], ["proof (state)\nthis:\n  a \\<noteq> []\n  b \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> 1 \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_balanced xs) =\n    mset (map fst xs)", "note IH = 1(1)[OF False abp nonempty(1)] 1(2)[OF False abp nonempty(2)]"], ["proof (state)\nthis:\n  factors_of_factor_tree (create_factor_tree_balanced a) = mset (map fst a)\n  factors_of_factor_tree (create_factor_tree_balanced b) = mset (map fst b)\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> 1 \\<Longrightarrow>\n    factors_of_factor_tree (create_factor_tree_balanced xs) =\n    mset (map fst xs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. factors_of_factor_tree (create_factor_tree_balanced xs) =\n    mset (map fst xs)", "unfolding create_factor_tree_balanced.simps[of xs] part split"], ["proof (prove)\ngoal (1 subgoal):\n 1. factors_of_factor_tree\n     (if length xs \\<le> 1 then Factor_Leaf () (fst (hd xs))\n      else Factor_Node () (create_factor_tree_balanced a)\n            (create_factor_tree_balanced b)) =\n    mset (map fst xs)", "using \n      False IH partition_factors[OF part]"], ["proof (prove)\nusing this:\n  \\<not> length xs \\<le> 1\n  factors_of_factor_tree (create_factor_tree_balanced a) = mset (map fst a)\n  factors_of_factor_tree (create_factor_tree_balanced b) = mset (map fst b)\n  mset xs = mset a + mset b\n\ngoal (1 subgoal):\n 1. factors_of_factor_tree\n     (if length xs \\<le> 1 then Factor_Leaf () (fst (hd xs))\n      else Factor_Node () (create_factor_tree_balanced a)\n            (create_factor_tree_balanced b)) =\n    mset (map fst xs)", "by auto"], ["proof (state)\nthis:\n  factors_of_factor_tree (create_factor_tree_balanced xs) =\n  mset (map fst xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  factors_of_factor_tree (create_factor_tree_balanced xs) =\n  mset (map fst xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma create_factor_tree: assumes \"xs \\<noteq> []\"\n  shows \"factors_of_factor_tree (create_factor_tree xs) = mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. factors_of_factor_tree (create_factor_tree xs) = mset xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. factors_of_factor_tree (create_factor_tree xs) = mset xs", "let ?xs = \"rev (sort_key snd (map (\\<lambda>f. (f, degree f)) xs))\""], ["proof (state)\ngoal (1 subgoal):\n 1. factors_of_factor_tree (create_factor_tree xs) = mset xs", "from assms"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "have \"set xs \\<noteq> {}\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. set xs \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  set xs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. factors_of_factor_tree (create_factor_tree xs) = mset xs", "hence \"set ?xs \\<noteq> {}\""], ["proof (prove)\nusing this:\n  set xs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. set (rev (sort_key snd (map (\\<lambda>f. (f, degree f)) xs))) \\<noteq>\n    {}", "by auto"], ["proof (state)\nthis:\n  set (rev (sort_key snd (map (\\<lambda>f. (f, degree f)) xs))) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. factors_of_factor_tree (create_factor_tree xs) = mset xs", "hence xs: \"?xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  set (rev (sort_key snd (map (\\<lambda>f. (f, degree f)) xs))) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. rev (sort_key snd (map (\\<lambda>f. (f, degree f)) xs)) \\<noteq> []", "by blast"], ["proof (state)\nthis:\n  rev (sort_key snd (map (\\<lambda>f. (f, degree f)) xs)) \\<noteq> []\n\ngoal (1 subgoal):\n 1. factors_of_factor_tree (create_factor_tree xs) = mset xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. factors_of_factor_tree (create_factor_tree xs) = mset xs", "unfolding create_factor_tree_def Let_def create_factor_tree_balanced[OF xs]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset\n     (map fst (rev (sort_key snd (map (\\<lambda>f. (f, degree f)) xs)))) =\n    mset xs", "by (auto, induct xs, auto)"], ["proof (state)\nthis:\n  factors_of_factor_tree (create_factor_tree xs) = mset xs\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  fixes p :: int and n :: nat\nbegin"], ["", "definition quadratic_hensel_binary :: \"int poly \\<Rightarrow> int poly \\<Rightarrow> int poly \\<Rightarrow> int poly \\<times> int poly\" where\n  \"quadratic_hensel_binary C D H = (\n     case euclid_ext_poly_dynamic p D H of \n      (S,T) \\<Rightarrow> quadratic_hensel_main C p S T D H n)\""], ["", "fun hensel_lifting_main :: \"int poly \\<Rightarrow> int poly factor_tree \\<Rightarrow> int poly list\" where\n  \"hensel_lifting_main U (Factor_Leaf _ _) = [U]\"\n| \"hensel_lifting_main U (Factor_Node _ l r) = (let \n    v = factor_node_info l;\n    w = factor_node_info r;\n    (V,W) = quadratic_hensel_binary U v w\n    in hensel_lifting_main V l @ hensel_lifting_main W r)\""], ["", "definition hensel_lifting_monic :: \"int poly \\<Rightarrow> int poly list \\<Rightarrow> int poly list\" where\n  \"hensel_lifting_monic u vs = (if vs = [] then [] else let \n     pn = p^n; \n     C = poly_mod.Mp pn u;\n     tree = product_factor_tree p (create_factor_tree vs)\n     in hensel_lifting_main C tree)\""], ["", "definition hensel_lifting :: \"int poly \\<Rightarrow> int poly list \\<Rightarrow> int poly list\" where \n  \"hensel_lifting f gs = (let lc = lead_coeff f; \n     ilc = inverse_mod lc (p^n);\n     g = smult ilc f\n     in hensel_lifting_monic g gs)\""], ["", "end"], ["", "context poly_mod_prime begin"], ["", "context\n  fixes n :: nat\n  assumes n: \"n \\<noteq> 0\" \nbegin"], ["", "abbreviation \"hensel_binary \\<equiv> quadratic_hensel_binary p n\""], ["", "abbreviation \"hensel_main \\<equiv> hensel_lifting_main p n\""], ["", "lemma hensel_binary: \n  assumes cop: \"coprime_m D H\" and eq: \"eq_m C (D * H)\"\n  and normalized_input: \"Mp D = D\" \"Mp H = H\"\n  and monic_input: \"monic D\" \n  and hensel_result: \"hensel_binary C D H = (D',H')\" \n  shows \"poly_mod.eq_m (p^n) C (D' * H') \\<comment> \\<open>the main result: equivalence mod \\<open>p^n\\<close>\\<close>\n    \\<and> monic D' \\<comment> \\<open>monic output\\<close>\n    \\<and> eq_m D D' \\<and> eq_m H H' \\<comment> \\<open>apply \\<open>`mod p`\\<close> on \\<open>D'\\<close> and \\<open>H'\\<close> yields \\<open>D\\<close> and \\<open>H\\<close> again\\<close>\n    \\<and> poly_mod.Mp (p^n) D' = D' \\<and> poly_mod.Mp (p^n) H' = H' \\<comment> \\<open>output is normalized\\<close>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.Mp (p ^ n) C = poly_mod.Mp (p ^ n) (D' * H') \\<and>\n    monic D' \\<and>\n    D =m D' \\<and>\n    H =m H' \\<and>\n    poly_mod.Mp (p ^ n) D' = D' \\<and> poly_mod.Mp (p ^ n) H' = H'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_mod.Mp (p ^ n) C = poly_mod.Mp (p ^ n) (D' * H') \\<and>\n    monic D' \\<and>\n    D =m D' \\<and>\n    H =m H' \\<and>\n    poly_mod.Mp (p ^ n) D' = D' \\<and> poly_mod.Mp (p ^ n) H' = H'", "from m1"], ["proof (chain)\npicking this:\n  1 < p", "have p: \"p > 1\""], ["proof (prove)\nusing this:\n  1 < p\n\ngoal (1 subgoal):\n 1. 1 < p", "."], ["proof (state)\nthis:\n  1 < p\n\ngoal (1 subgoal):\n 1. poly_mod.Mp (p ^ n) C = poly_mod.Mp (p ^ n) (D' * H') \\<and>\n    monic D' \\<and>\n    D =m D' \\<and>\n    H =m H' \\<and>\n    poly_mod.Mp (p ^ n) D' = D' \\<and> poly_mod.Mp (p ^ n) H' = H'", "obtain S T where ext: \"euclid_ext_poly_dynamic p D H = (S,T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>S T.\n        euclid_ext_poly_dynamic p D H = (S, T) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  euclid_ext_poly_dynamic p D H = (S, T)\n\ngoal (1 subgoal):\n 1. poly_mod.Mp (p ^ n) C = poly_mod.Mp (p ^ n) (D' * H') \\<and>\n    monic D' \\<and>\n    D =m D' \\<and>\n    H =m H' \\<and>\n    poly_mod.Mp (p ^ n) D' = D' \\<and> poly_mod.Mp (p ^ n) H' = H'", "obtain D1 H1 where main: \"quadratic_hensel_main C p S T D H n = (D1,H1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D1 H1.\n        quadratic_hensel_main C p S T D H n = (D1, H1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  quadratic_hensel_main C p S T D H n = (D1, H1)\n\ngoal (1 subgoal):\n 1. poly_mod.Mp (p ^ n) C = poly_mod.Mp (p ^ n) (D' * H') \\<and>\n    monic D' \\<and>\n    D =m D' \\<and>\n    H =m H' \\<and>\n    poly_mod.Mp (p ^ n) D' = D' \\<and> poly_mod.Mp (p ^ n) H' = H'", "note hen = hensel_result[unfolded quadratic_hensel_binary_def ext split Let_def main]"], ["proof (state)\nthis:\n  (D1, H1) = (D', H')\n\ngoal (1 subgoal):\n 1. poly_mod.Mp (p ^ n) C = poly_mod.Mp (p ^ n) (D' * H') \\<and>\n    monic D' \\<and>\n    D =m D' \\<and>\n    H =m H' \\<and>\n    poly_mod.Mp (p ^ n) D' = D' \\<and> poly_mod.Mp (p ^ n) H' = H'", "from n"], ["proof (chain)\npicking this:\n  n \\<noteq> 0", "have n: \"n \\<ge> 1\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> n", "by simp"], ["proof (state)\nthis:\n  1 \\<le> n\n\ngoal (1 subgoal):\n 1. poly_mod.Mp (p ^ n) C = poly_mod.Mp (p ^ n) (D' * H') \\<and>\n    monic D' \\<and>\n    D =m D' \\<and>\n    H =m H' \\<and>\n    poly_mod.Mp (p ^ n) D' = D' \\<and> poly_mod.Mp (p ^ n) H' = H'", "note eucl = euclid_ext_poly_dynamic[OF cop normalized_input ext]"], ["proof (state)\nthis:\n  D * S + H * T =m 1\n  Mp S = S\n  Mp T = T\n\ngoal (1 subgoal):\n 1. poly_mod.Mp (p ^ n) C = poly_mod.Mp (p ^ n) (D' * H') \\<and>\n    monic D' \\<and>\n    D =m D' \\<and>\n    H =m H' \\<and>\n    poly_mod.Mp (p ^ n) D' = D' \\<and> poly_mod.Mp (p ^ n) H' = H'", "note main = quadratic_hensel_main[OF eucl(1) eq monic_input p normalized_input eucl(2-) n main]"], ["proof (state)\nthis:\n  poly_mod.Mp (p ^ n) C = poly_mod.Mp (p ^ n) (D1 * H1)\n  monic D1\n  D =m D1\n  H =m H1\n  poly_mod.Mp (p ^ n) D1 = D1\n  poly_mod.Mp (p ^ n) H1 = H1\n\ngoal (1 subgoal):\n 1. poly_mod.Mp (p ^ n) C = poly_mod.Mp (p ^ n) (D' * H') \\<and>\n    monic D' \\<and>\n    D =m D' \\<and>\n    H =m H' \\<and>\n    poly_mod.Mp (p ^ n) D' = D' \\<and> poly_mod.Mp (p ^ n) H' = H'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.Mp (p ^ n) C = poly_mod.Mp (p ^ n) (D' * H') \\<and>\n    monic D' \\<and>\n    D =m D' \\<and>\n    H =m H' \\<and>\n    poly_mod.Mp (p ^ n) D' = D' \\<and> poly_mod.Mp (p ^ n) H' = H'", "using hen main"], ["proof (prove)\nusing this:\n  (D1, H1) = (D', H')\n  poly_mod.Mp (p ^ n) C = poly_mod.Mp (p ^ n) (D1 * H1)\n  monic D1\n  D =m D1\n  H =m H1\n  poly_mod.Mp (p ^ n) D1 = D1\n  poly_mod.Mp (p ^ n) H1 = H1\n\ngoal (1 subgoal):\n 1. poly_mod.Mp (p ^ n) C = poly_mod.Mp (p ^ n) (D' * H') \\<and>\n    monic D' \\<and>\n    D =m D' \\<and>\n    H =m H' \\<and>\n    poly_mod.Mp (p ^ n) D' = D' \\<and> poly_mod.Mp (p ^ n) H' = H'", "by auto"], ["proof (state)\nthis:\n  poly_mod.Mp (p ^ n) C = poly_mod.Mp (p ^ n) (D' * H') \\<and>\n  monic D' \\<and>\n  D =m D' \\<and>\n  H =m H' \\<and>\n  poly_mod.Mp (p ^ n) D' = D' \\<and> poly_mod.Mp (p ^ n) H' = H'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hensel_main: \n  assumes eq: \"eq_m C (prod_mset (factors_of_factor_tree Fs))\"\n  and \"\\<And> F. F \\<in># factors_of_factor_tree Fs \\<Longrightarrow> Mp F = F \\<and> monic F\"  \n  and hensel_result: \"hensel_main C Fs = Gs\" \n  and C: \"monic C\" \"poly_mod.Mp (p^n) C = C\" \n  and sf: \"square_free_m C\" \n  and \"\\<And> f t. t \\<in> sub_trees Fs \\<Longrightarrow> factor_node_info t = f \\<Longrightarrow> f = Mp (prod_mset (factors_of_factor_tree t))\"\n  shows \"poly_mod.eq_m (p^n) C (prod_list Gs) \\<comment> \\<open>the main result: equivalence mod \\<open>p^n\\<close>\\<close>\n    \\<and> factors_of_factor_tree Fs = mset (map Mp Gs)\n    \\<and> (\\<forall> G. G \\<in> set Gs \\<longrightarrow> monic G \\<and> poly_mod.Mp (p^n) G = G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.Mp (p ^ n) C = poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n    factors_of_factor_tree Fs = mset (map Mp Gs) \\<and>\n    (\\<forall>G.\n        G \\<in> set Gs \\<longrightarrow>\n        monic G \\<and> poly_mod.Mp (p ^ n) G = G)", "using assms"], ["proof (prove)\nusing this:\n  C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs)\n  ?F \\<in># factors_of_factor_tree Fs \\<Longrightarrow>\n  Mp ?F = ?F \\<and> monic ?F\n  hensel_main C Fs = Gs\n  monic C\n  poly_mod.Mp (p ^ n) C = C\n  square_free_m C\n  \\<lbrakk>?t \\<in> sub_trees Fs; factor_node_info ?t = ?f\\<rbrakk>\n  \\<Longrightarrow> ?f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree ?t))\n\ngoal (1 subgoal):\n 1. poly_mod.Mp (p ^ n) C = poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n    factors_of_factor_tree Fs = mset (map Mp Gs) \\<and>\n    (\\<forall>G.\n        G \\<in> set Gs \\<longrightarrow>\n        monic G \\<and> poly_mod.Mp (p ^ n) G = G)", "proof (induct Fs arbitrary: C Gs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 C Gs.\n       \\<lbrakk>C =m\n                \\<Prod>\\<^sub>#\n                 (factors_of_factor_tree (Factor_Leaf x1 x2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Leaf x1 x2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Leaf x1 x2) = Gs; monic C;\n        poly_mod.Mp (p ^ n) C = C; square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Leaf x1 x2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                         poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Leaf x1 x2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> poly_mod.Mp (p ^ n) G = G)\n 2. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C;\n                    poly_mod.Mp (p ^ n) C = C; square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                                     poly_mod.Mp (p ^ n)\n(prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow>\n   monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; poly_mod.Mp (p ^ n) C = C;\n            square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                             poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C;\n        poly_mod.Mp (p ^ n) C = C; square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                         poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> poly_mod.Mp (p ^ n) G = G)", "case (Factor_Leaf f fs C Gs)"], ["proof (state)\nthis:\n  C =m \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Leaf f fs))\n  ?F \\<in># factors_of_factor_tree (Factor_Leaf f fs) \\<Longrightarrow>\n  Mp ?F = ?F \\<and> monic ?F\n  hensel_main C (Factor_Leaf f fs) = Gs\n  monic C\n  poly_mod.Mp (p ^ n) C = C\n  square_free_m C\n  \\<lbrakk>?t \\<in> sub_trees (Factor_Leaf f fs);\n   factor_node_info ?t = ?f\\<rbrakk>\n  \\<Longrightarrow> ?f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree ?t))\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 C Gs.\n       \\<lbrakk>C =m\n                \\<Prod>\\<^sub>#\n                 (factors_of_factor_tree (Factor_Leaf x1 x2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Leaf x1 x2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Leaf x1 x2) = Gs; monic C;\n        poly_mod.Mp (p ^ n) C = C; square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Leaf x1 x2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                         poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Leaf x1 x2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> poly_mod.Mp (p ^ n) G = G)\n 2. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C;\n                    poly_mod.Mp (p ^ n) C = C; square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                                     poly_mod.Mp (p ^ n)\n(prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow>\n   monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; poly_mod.Mp (p ^ n) C = C;\n            square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                             poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C;\n        poly_mod.Mp (p ^ n) C = C; square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                         poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> poly_mod.Mp (p ^ n) G = G)", "thus ?case"], ["proof (prove)\nusing this:\n  C =m \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Leaf f fs))\n  ?F \\<in># factors_of_factor_tree (Factor_Leaf f fs) \\<Longrightarrow>\n  Mp ?F = ?F \\<and> monic ?F\n  hensel_main C (Factor_Leaf f fs) = Gs\n  monic C\n  poly_mod.Mp (p ^ n) C = C\n  square_free_m C\n  \\<lbrakk>?t \\<in> sub_trees (Factor_Leaf f fs);\n   factor_node_info ?t = ?f\\<rbrakk>\n  \\<Longrightarrow> ?f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree ?t))\n\ngoal (1 subgoal):\n 1. poly_mod.Mp (p ^ n) C = poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n    factors_of_factor_tree (Factor_Leaf f fs) = mset (map Mp Gs) \\<and>\n    (\\<forall>G.\n        G \\<in> set Gs \\<longrightarrow>\n        monic G \\<and> poly_mod.Mp (p ^ n) G = G)", "by auto"], ["proof (state)\nthis:\n  poly_mod.Mp (p ^ n) C = poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n  factors_of_factor_tree (Factor_Leaf f fs) = mset (map Mp Gs) \\<and>\n  (\\<forall>G.\n      G \\<in> set Gs \\<longrightarrow>\n      monic G \\<and> poly_mod.Mp (p ^ n) G = G)\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C;\n                    poly_mod.Mp (p ^ n) C = C; square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                                     poly_mod.Mp (p ^ n)\n(prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow>\n   monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; poly_mod.Mp (p ^ n) C = C;\n            square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                             poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C;\n        poly_mod.Mp (p ^ n) C = C; square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                         poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> poly_mod.Mp (p ^ n) G = G)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C;\n                    poly_mod.Mp (p ^ n) C = C; square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                                     poly_mod.Mp (p ^ n)\n(prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow>\n   monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; poly_mod.Mp (p ^ n) C = C;\n            square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                             poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C;\n        poly_mod.Mp (p ^ n) C = C; square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                         poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> poly_mod.Mp (p ^ n) G = G)", "case (Factor_Node f l r C Gs)"], ["proof (state)\nthis:\n  \\<lbrakk>?C =m \\<Prod>\\<^sub># (factors_of_factor_tree l);\n   \\<And>F.\n      F \\<in># factors_of_factor_tree l \\<Longrightarrow>\n      Mp F = F \\<and> monic F;\n   hensel_main ?C l = ?Gs; monic ?C; poly_mod.Mp (p ^ n) ?C = ?C;\n   square_free_m ?C;\n   \\<And>t f.\n      \\<lbrakk>t \\<in> sub_trees l; factor_node_info t = f\\<rbrakk>\n      \\<Longrightarrow> f =\n                        Mp (\\<Prod>\\<^sub>#\n                             (factors_of_factor_tree t))\\<rbrakk>\n  \\<Longrightarrow> poly_mod.Mp (p ^ n) ?C =\n                    poly_mod.Mp (p ^ n) (prod_list ?Gs) \\<and>\n                    factors_of_factor_tree l = mset (map Mp ?Gs) \\<and>\n                    (\\<forall>G.\n                        G \\<in> set ?Gs \\<longrightarrow>\n                        monic G \\<and> poly_mod.Mp (p ^ n) G = G)\n  \\<lbrakk>?C =m \\<Prod>\\<^sub># (factors_of_factor_tree r);\n   \\<And>F.\n      F \\<in># factors_of_factor_tree r \\<Longrightarrow>\n      Mp F = F \\<and> monic F;\n   hensel_main ?C r = ?Gs; monic ?C; poly_mod.Mp (p ^ n) ?C = ?C;\n   square_free_m ?C;\n   \\<And>t f.\n      \\<lbrakk>t \\<in> sub_trees r; factor_node_info t = f\\<rbrakk>\n      \\<Longrightarrow> f =\n                        Mp (\\<Prod>\\<^sub>#\n                             (factors_of_factor_tree t))\\<rbrakk>\n  \\<Longrightarrow> poly_mod.Mp (p ^ n) ?C =\n                    poly_mod.Mp (p ^ n) (prod_list ?Gs) \\<and>\n                    factors_of_factor_tree r = mset (map Mp ?Gs) \\<and>\n                    (\\<forall>G.\n                        G \\<in> set ?Gs \\<longrightarrow>\n                        monic G \\<and> poly_mod.Mp (p ^ n) G = G)\n  C =m \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node f l r))\n  ?F \\<in># factors_of_factor_tree (Factor_Node f l r) \\<Longrightarrow>\n  Mp ?F = ?F \\<and> monic ?F\n  hensel_main C (Factor_Node f l r) = Gs\n  monic C\n  poly_mod.Mp (p ^ n) C = C\n  square_free_m C\n  \\<lbrakk>?t \\<in> sub_trees (Factor_Node f l r);\n   factor_node_info ?t = ?f\\<rbrakk>\n  \\<Longrightarrow> ?f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree ?t))\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C;\n                    poly_mod.Mp (p ^ n) C = C; square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                                     poly_mod.Mp (p ^ n)\n(prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow>\n   monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; poly_mod.Mp (p ^ n) C = C;\n            square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                             poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C;\n        poly_mod.Mp (p ^ n) C = C; square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                         poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> poly_mod.Mp (p ^ n) G = G)", "note * = this"], ["proof (state)\nthis:\n  \\<lbrakk>?C =m \\<Prod>\\<^sub># (factors_of_factor_tree l);\n   \\<And>F.\n      F \\<in># factors_of_factor_tree l \\<Longrightarrow>\n      Mp F = F \\<and> monic F;\n   hensel_main ?C l = ?Gs; monic ?C; poly_mod.Mp (p ^ n) ?C = ?C;\n   square_free_m ?C;\n   \\<And>t f.\n      \\<lbrakk>t \\<in> sub_trees l; factor_node_info t = f\\<rbrakk>\n      \\<Longrightarrow> f =\n                        Mp (\\<Prod>\\<^sub>#\n                             (factors_of_factor_tree t))\\<rbrakk>\n  \\<Longrightarrow> poly_mod.Mp (p ^ n) ?C =\n                    poly_mod.Mp (p ^ n) (prod_list ?Gs) \\<and>\n                    factors_of_factor_tree l = mset (map Mp ?Gs) \\<and>\n                    (\\<forall>G.\n                        G \\<in> set ?Gs \\<longrightarrow>\n                        monic G \\<and> poly_mod.Mp (p ^ n) G = G)\n  \\<lbrakk>?C =m \\<Prod>\\<^sub># (factors_of_factor_tree r);\n   \\<And>F.\n      F \\<in># factors_of_factor_tree r \\<Longrightarrow>\n      Mp F = F \\<and> monic F;\n   hensel_main ?C r = ?Gs; monic ?C; poly_mod.Mp (p ^ n) ?C = ?C;\n   square_free_m ?C;\n   \\<And>t f.\n      \\<lbrakk>t \\<in> sub_trees r; factor_node_info t = f\\<rbrakk>\n      \\<Longrightarrow> f =\n                        Mp (\\<Prod>\\<^sub>#\n                             (factors_of_factor_tree t))\\<rbrakk>\n  \\<Longrightarrow> poly_mod.Mp (p ^ n) ?C =\n                    poly_mod.Mp (p ^ n) (prod_list ?Gs) \\<and>\n                    factors_of_factor_tree r = mset (map Mp ?Gs) \\<and>\n                    (\\<forall>G.\n                        G \\<in> set ?Gs \\<longrightarrow>\n                        monic G \\<and> poly_mod.Mp (p ^ n) G = G)\n  C =m \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node f l r))\n  ?F \\<in># factors_of_factor_tree (Factor_Node f l r) \\<Longrightarrow>\n  Mp ?F = ?F \\<and> monic ?F\n  hensel_main C (Factor_Node f l r) = Gs\n  monic C\n  poly_mod.Mp (p ^ n) C = C\n  square_free_m C\n  \\<lbrakk>?t \\<in> sub_trees (Factor_Node f l r);\n   factor_node_info ?t = ?f\\<rbrakk>\n  \\<Longrightarrow> ?f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree ?t))\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C;\n                    poly_mod.Mp (p ^ n) C = C; square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                                     poly_mod.Mp (p ^ n)\n(prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow>\n   monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; poly_mod.Mp (p ^ n) C = C;\n            square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                             poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C;\n        poly_mod.Mp (p ^ n) C = C; square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                         poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> poly_mod.Mp (p ^ n) G = G)", "note simps = hensel_lifting_main.simps"], ["proof (state)\nthis:\n  hensel_lifting_main ?p ?n ?U (Factor_Leaf ?uu ?uv) = [?U]\n  hensel_lifting_main ?p ?n ?U (Factor_Node ?uw ?l ?r) =\n  (let v = factor_node_info ?l; w = factor_node_info ?r;\n       (V, W) = quadratic_hensel_binary ?p ?n ?U v w\n   in hensel_lifting_main ?p ?n V ?l @ hensel_lifting_main ?p ?n W ?r)\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C;\n                    poly_mod.Mp (p ^ n) C = C; square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                                     poly_mod.Mp (p ^ n)\n(prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow>\n   monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; poly_mod.Mp (p ^ n) C = C;\n            square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                             poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C;\n        poly_mod.Mp (p ^ n) C = C; square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                         poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> poly_mod.Mp (p ^ n) G = G)", "note IH1 = *(1)[rule_format]"], ["proof (state)\nthis:\n  \\<lbrakk>?C =m \\<Prod>\\<^sub># (factors_of_factor_tree l);\n   \\<And>F.\n      F \\<in># factors_of_factor_tree l \\<Longrightarrow>\n      Mp F = F \\<and> monic F;\n   hensel_main ?C l = ?Gs; monic ?C; poly_mod.Mp (p ^ n) ?C = ?C;\n   square_free_m ?C;\n   \\<And>t f.\n      \\<lbrakk>t \\<in> sub_trees l; factor_node_info t = f\\<rbrakk>\n      \\<Longrightarrow> f =\n                        Mp (\\<Prod>\\<^sub>#\n                             (factors_of_factor_tree t))\\<rbrakk>\n  \\<Longrightarrow> poly_mod.Mp (p ^ n) ?C =\n                    poly_mod.Mp (p ^ n) (prod_list ?Gs) \\<and>\n                    factors_of_factor_tree l = mset (map Mp ?Gs) \\<and>\n                    (\\<forall>G.\n                        G \\<in> set ?Gs \\<longrightarrow>\n                        monic G \\<and> poly_mod.Mp (p ^ n) G = G)\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C;\n                    poly_mod.Mp (p ^ n) C = C; square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                                     poly_mod.Mp (p ^ n)\n(prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow>\n   monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; poly_mod.Mp (p ^ n) C = C;\n            square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                             poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C;\n        poly_mod.Mp (p ^ n) C = C; square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                         poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> poly_mod.Mp (p ^ n) G = G)", "note IH2 = *(2)[rule_format]"], ["proof (state)\nthis:\n  \\<lbrakk>?C =m \\<Prod>\\<^sub># (factors_of_factor_tree r);\n   \\<And>F.\n      F \\<in># factors_of_factor_tree r \\<Longrightarrow>\n      Mp F = F \\<and> monic F;\n   hensel_main ?C r = ?Gs; monic ?C; poly_mod.Mp (p ^ n) ?C = ?C;\n   square_free_m ?C;\n   \\<And>t f.\n      \\<lbrakk>t \\<in> sub_trees r; factor_node_info t = f\\<rbrakk>\n      \\<Longrightarrow> f =\n                        Mp (\\<Prod>\\<^sub>#\n                             (factors_of_factor_tree t))\\<rbrakk>\n  \\<Longrightarrow> poly_mod.Mp (p ^ n) ?C =\n                    poly_mod.Mp (p ^ n) (prod_list ?Gs) \\<and>\n                    factors_of_factor_tree r = mset (map Mp ?Gs) \\<and>\n                    (\\<forall>G.\n                        G \\<in> set ?Gs \\<longrightarrow>\n                        monic G \\<and> poly_mod.Mp (p ^ n) G = G)\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C;\n                    poly_mod.Mp (p ^ n) C = C; square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                                     poly_mod.Mp (p ^ n)\n(prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow>\n   monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; poly_mod.Mp (p ^ n) C = C;\n            square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                             poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C;\n        poly_mod.Mp (p ^ n) C = C; square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                         poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> poly_mod.Mp (p ^ n) G = G)", "note res = *(5)[unfolded simps Let_def]"], ["proof (state)\nthis:\n  (case hensel_binary C (factor_node_info l) (factor_node_info r) of\n   (V, W) \\<Rightarrow> hensel_main V l @ hensel_main W r) =\n  Gs\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C;\n                    poly_mod.Mp (p ^ n) C = C; square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                                     poly_mod.Mp (p ^ n)\n(prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow>\n   monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; poly_mod.Mp (p ^ n) C = C;\n            square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                             poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C;\n        poly_mod.Mp (p ^ n) C = C; square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                         poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> poly_mod.Mp (p ^ n) G = G)", "note eq = *(3)"], ["proof (state)\nthis:\n  C =m \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node f l r))\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C;\n                    poly_mod.Mp (p ^ n) C = C; square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                                     poly_mod.Mp (p ^ n)\n(prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow>\n   monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; poly_mod.Mp (p ^ n) C = C;\n            square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                             poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C;\n        poly_mod.Mp (p ^ n) C = C; square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                         poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> poly_mod.Mp (p ^ n) G = G)", "note Fs = *(4)"], ["proof (state)\nthis:\n  ?F \\<in># factors_of_factor_tree (Factor_Node f l r) \\<Longrightarrow>\n  Mp ?F = ?F \\<and> monic ?F\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C;\n                    poly_mod.Mp (p ^ n) C = C; square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                                     poly_mod.Mp (p ^ n)\n(prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow>\n   monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; poly_mod.Mp (p ^ n) C = C;\n            square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                             poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C;\n        poly_mod.Mp (p ^ n) C = C; square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                         poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> poly_mod.Mp (p ^ n) G = G)", "note C = *(6,7)"], ["proof (state)\nthis:\n  monic C\n  poly_mod.Mp (p ^ n) C = C\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C;\n                    poly_mod.Mp (p ^ n) C = C; square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                                     poly_mod.Mp (p ^ n)\n(prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow>\n   monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; poly_mod.Mp (p ^ n) C = C;\n            square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                             poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C;\n        poly_mod.Mp (p ^ n) C = C; square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                         poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> poly_mod.Mp (p ^ n) G = G)", "note sf = *(8)"], ["proof (state)\nthis:\n  square_free_m C\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C;\n                    poly_mod.Mp (p ^ n) C = C; square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                                     poly_mod.Mp (p ^ n)\n(prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow>\n   monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; poly_mod.Mp (p ^ n) C = C;\n            square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                             poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C;\n        poly_mod.Mp (p ^ n) C = C; square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                         poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> poly_mod.Mp (p ^ n) G = G)", "note inv = *(9)"], ["proof (state)\nthis:\n  \\<lbrakk>?t \\<in> sub_trees (Factor_Node f l r);\n   factor_node_info ?t = ?f\\<rbrakk>\n  \\<Longrightarrow> ?f = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree ?t))\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C;\n                    poly_mod.Mp (p ^ n) C = C; square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                                     poly_mod.Mp (p ^ n)\n(prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow>\n   monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; poly_mod.Mp (p ^ n) C = C;\n            square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                             poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> poly_mod.Mp (p ^ n) G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C;\n        poly_mod.Mp (p ^ n) C = C; square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> poly_mod.Mp (p ^ n) C =\n                         poly_mod.Mp (p ^ n) (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> poly_mod.Mp (p ^ n) G = G)", "interpret pn: poly_mod_2 \"p^n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_2 (p ^ n)", "apply (unfold_locales)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < p ^ n", "using m1 n"], ["proof (prove)\nusing this:\n  1 < p\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 < p ^ n", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "let ?Mp = \"pn.Mp\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "define D where \"D \\<equiv> prod_mset (factors_of_factor_tree l)\""], ["proof (state)\nthis:\n  D \\<equiv> \\<Prod>\\<^sub># (factors_of_factor_tree l)\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "define H where \"H \\<equiv> prod_mset (factors_of_factor_tree r)\""], ["proof (state)\nthis:\n  H \\<equiv> \\<Prod>\\<^sub># (factors_of_factor_tree r)\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "let ?D = \"Mp D\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "let ?H = \"Mp H\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "let ?D' = \"factor_node_info l\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "let ?H' = \"factor_node_info r\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "obtain A B where hen: \"hensel_binary C ?D' ?H' = (A,B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        hensel_binary C (factor_node_info l) (factor_node_info r) =\n        (A, B) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  hensel_binary C (factor_node_info l) (factor_node_info r) = (A, B)\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "note res = res[unfolded hen split]"], ["proof (state)\nthis:\n  hensel_main A l @ hensel_main B r = Gs\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "obtain AD where AD': \"AD = hensel_main A l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>AD.\n        AD = hensel_main A l \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  AD = hensel_main A l\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "obtain BH where BH': \"BH = hensel_main B r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>BH.\n        BH = hensel_main B r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  BH = hensel_main B r\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "from inv[of l, OF _ refl]"], ["proof (chain)\npicking this:\n  l \\<in> sub_trees (Factor_Node f l r) \\<Longrightarrow>\n  factor_node_info l = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree l))", "have D': \"?D' = ?D\""], ["proof (prove)\nusing this:\n  l \\<in> sub_trees (Factor_Node f l r) \\<Longrightarrow>\n  factor_node_info l = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree l))\n\ngoal (1 subgoal):\n 1. factor_node_info l = Mp D", "unfolding D_def"], ["proof (prove)\nusing this:\n  l \\<in> sub_trees (Factor_Node f l r) \\<Longrightarrow>\n  factor_node_info l = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree l))\n\ngoal (1 subgoal):\n 1. factor_node_info l = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree l))", "by auto"], ["proof (state)\nthis:\n  factor_node_info l = Mp D\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "from inv[of r, OF _ refl]"], ["proof (chain)\npicking this:\n  r \\<in> sub_trees (Factor_Node f l r) \\<Longrightarrow>\n  factor_node_info r = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree r))", "have H': \"?H' = ?H\""], ["proof (prove)\nusing this:\n  r \\<in> sub_trees (Factor_Node f l r) \\<Longrightarrow>\n  factor_node_info r = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree r))\n\ngoal (1 subgoal):\n 1. factor_node_info r = Mp H", "unfolding H_def"], ["proof (prove)\nusing this:\n  r \\<in> sub_trees (Factor_Node f l r) \\<Longrightarrow>\n  factor_node_info r = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree r))\n\ngoal (1 subgoal):\n 1. factor_node_info r = Mp (\\<Prod>\\<^sub># (factors_of_factor_tree r))", "by auto"], ["proof (state)\nthis:\n  factor_node_info r = Mp H\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "from eq[simplified]"], ["proof (chain)\npicking this:\n  C =m\n  \\<Prod>\\<^sub># (factors_of_factor_tree l) *\n  \\<Prod>\\<^sub># (factors_of_factor_tree r)", "have eq': \"Mp C = Mp (?D * ?H)\""], ["proof (prove)\nusing this:\n  C =m\n  \\<Prod>\\<^sub># (factors_of_factor_tree l) *\n  \\<Prod>\\<^sub># (factors_of_factor_tree r)\n\ngoal (1 subgoal):\n 1. C =m Mp D * Mp H", "unfolding D_def H_def"], ["proof (prove)\nusing this:\n  C =m\n  \\<Prod>\\<^sub># (factors_of_factor_tree l) *\n  \\<Prod>\\<^sub># (factors_of_factor_tree r)\n\ngoal (1 subgoal):\n 1. C =m\n    Mp (\\<Prod>\\<^sub># (factors_of_factor_tree l)) *\n    Mp (\\<Prod>\\<^sub># (factors_of_factor_tree r))", "by simp"], ["proof (state)\nthis:\n  C =m Mp D * Mp H\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "from square_free_m_cong[OF sf, of \"?D * ?H\", OF eq']"], ["proof (chain)\npicking this:\n  square_free_m (Mp D * Mp H)", "have sf': \"square_free_m (?D * ?H)\""], ["proof (prove)\nusing this:\n  square_free_m (Mp D * Mp H)\n\ngoal (1 subgoal):\n 1. square_free_m (Mp D * Mp H)", "."], ["proof (state)\nthis:\n  square_free_m (Mp D * Mp H)\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "from poly_mod_prime.square_free_m_prod_imp_coprime_m[OF _ this]"], ["proof (chain)\npicking this:\n  poly_mod_prime p \\<Longrightarrow> coprime_m (Mp D) (Mp H)", "have cop': \"coprime_m ?D ?H\""], ["proof (prove)\nusing this:\n  poly_mod_prime p \\<Longrightarrow> coprime_m (Mp D) (Mp H)\n\ngoal (1 subgoal):\n 1. coprime_m (Mp D) (Mp H)", "unfolding poly_mod_prime_def"], ["proof (prove)\nusing this:\n  prime p \\<Longrightarrow> coprime_m (Mp D) (Mp H)\n\ngoal (1 subgoal):\n 1. coprime_m (Mp D) (Mp H)", "using prime"], ["proof (prove)\nusing this:\n  prime p \\<Longrightarrow> coprime_m (Mp D) (Mp H)\n  prime p\n\ngoal (1 subgoal):\n 1. coprime_m (Mp D) (Mp H)", "."], ["proof (state)\nthis:\n  coprime_m (Mp D) (Mp H)\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "from eq'"], ["proof (chain)\npicking this:\n  C =m Mp D * Mp H", "have eq': \"eq_m C (?D * ?H)\""], ["proof (prove)\nusing this:\n  C =m Mp D * Mp H\n\ngoal (1 subgoal):\n 1. C =m Mp D * Mp H", "by simp"], ["proof (state)\nthis:\n  C =m Mp D * Mp H\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "have monD: \"monic D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic D", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (\\<Prod>\\<^sub># (factors_of_factor_tree l))", "by (rule monic_prod_mset, insert Fs, auto)"], ["proof (state)\nthis:\n  monic D\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "from hensel_binary[OF _ _ _ _ _ hen, unfolded D' H', OF cop' eq' Mp_Mp Mp_Mp monic_Mp[OF monD]]"], ["proof (chain)\npicking this:\n  pn.eq_m C (A * B) \\<and>\n  monic A \\<and>\n  Mp D =m A \\<and> Mp H =m B \\<and> pn.Mp A = A \\<and> pn.Mp B = B", "have step: \"poly_mod.eq_m (p ^ n) C (A * B) \\<and> monic A \\<and> eq_m ?D A \\<and>\n     eq_m ?H B \\<and> ?Mp A = A \\<and> ?Mp B = B\""], ["proof (prove)\nusing this:\n  pn.eq_m C (A * B) \\<and>\n  monic A \\<and>\n  Mp D =m A \\<and> Mp H =m B \\<and> pn.Mp A = A \\<and> pn.Mp B = B\n\ngoal (1 subgoal):\n 1. pn.eq_m C (A * B) \\<and>\n    monic A \\<and>\n    Mp D =m A \\<and> Mp H =m B \\<and> pn.Mp A = A \\<and> pn.Mp B = B", "."], ["proof (state)\nthis:\n  pn.eq_m C (A * B) \\<and>\n  monic A \\<and>\n  Mp D =m A \\<and> Mp H =m B \\<and> pn.Mp A = A \\<and> pn.Mp B = B\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "from res"], ["proof (chain)\npicking this:\n  hensel_main A l @ hensel_main B r = Gs", "have Gs: \"Gs = AD @ BH\""], ["proof (prove)\nusing this:\n  hensel_main A l @ hensel_main B r = Gs\n\ngoal (1 subgoal):\n 1. Gs = AD @ BH", "by (simp add: AD' BH')"], ["proof (state)\nthis:\n  Gs = AD @ BH\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "have AD: \"eq_m A ?D\" \"?Mp A = A\" \"eq_m A (prod_mset (factors_of_factor_tree l))\"  \n    and monA: \"monic A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A =m Mp D &&&\n     pn.Mp A = A &&& A =m \\<Prod>\\<^sub># (factors_of_factor_tree l)) &&&\n    monic A", "using step"], ["proof (prove)\nusing this:\n  pn.eq_m C (A * B) \\<and>\n  monic A \\<and>\n  Mp D =m A \\<and> Mp H =m B \\<and> pn.Mp A = A \\<and> pn.Mp B = B\n\ngoal (1 subgoal):\n 1. (A =m Mp D &&&\n     pn.Mp A = A &&& A =m \\<Prod>\\<^sub># (factors_of_factor_tree l)) &&&\n    monic A", "by (auto simp: D_def)"], ["proof (state)\nthis:\n  A =m Mp D\n  pn.Mp A = A\n  A =m \\<Prod>\\<^sub># (factors_of_factor_tree l)\n  monic A\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "note sf_fact = square_free_m_factor[OF sf']"], ["proof (state)\nthis:\n  square_free_m (Mp D)\n  square_free_m (Mp H)\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "from square_free_m_cong[OF sf_fact(1)] AD"], ["proof (chain)\npicking this:\n  Mp D =m ?g \\<Longrightarrow> square_free_m ?g\n  A =m Mp D\n  pn.Mp A = A\n  A =m \\<Prod>\\<^sub># (factors_of_factor_tree l)", "have sfA: \"square_free_m A\""], ["proof (prove)\nusing this:\n  Mp D =m ?g \\<Longrightarrow> square_free_m ?g\n  A =m Mp D\n  pn.Mp A = A\n  A =m \\<Prod>\\<^sub># (factors_of_factor_tree l)\n\ngoal (1 subgoal):\n 1. square_free_m A", "by auto"], ["proof (state)\nthis:\n  square_free_m A\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "have IH1: \"poly_mod.eq_m (p ^ n) A (prod_list AD) \\<and>\n    factors_of_factor_tree l = mset (map Mp AD) \\<and>\n    (\\<forall>G. G \\<in> set AD \\<longrightarrow> monic G \\<and> ?Mp G = G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pn.eq_m A (prod_list AD) \\<and>\n    factors_of_factor_tree l = mset (map Mp AD) \\<and>\n    (\\<forall>G.\n        G \\<in> set AD \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "by (rule IH1[OF AD(3) Fs AD'[symmetric] monA AD(2) sfA inv], auto)"], ["proof (state)\nthis:\n  pn.eq_m A (prod_list AD) \\<and>\n  factors_of_factor_tree l = mset (map Mp AD) \\<and>\n  (\\<forall>G. G \\<in> set AD \\<longrightarrow> monic G \\<and> pn.Mp G = G)\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "have BH: \"eq_m B ?H\" \"pn.Mp B = B\" \"eq_m B (prod_mset (factors_of_factor_tree r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B =m Mp H &&&\n    pn.Mp B = B &&& B =m \\<Prod>\\<^sub># (factors_of_factor_tree r)", "using step"], ["proof (prove)\nusing this:\n  pn.eq_m C (A * B) \\<and>\n  monic A \\<and>\n  Mp D =m A \\<and> Mp H =m B \\<and> pn.Mp A = A \\<and> pn.Mp B = B\n\ngoal (1 subgoal):\n 1. B =m Mp H &&&\n    pn.Mp B = B &&& B =m \\<Prod>\\<^sub># (factors_of_factor_tree r)", "by (auto simp: H_def)"], ["proof (state)\nthis:\n  B =m Mp H\n  pn.Mp B = B\n  B =m \\<Prod>\\<^sub># (factors_of_factor_tree r)\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "from step"], ["proof (chain)\npicking this:\n  pn.eq_m C (A * B) \\<and>\n  monic A \\<and>\n  Mp D =m A \\<and> Mp H =m B \\<and> pn.Mp A = A \\<and> pn.Mp B = B", "have \"pn.eq_m C (A * B)\""], ["proof (prove)\nusing this:\n  pn.eq_m C (A * B) \\<and>\n  monic A \\<and>\n  Mp D =m A \\<and> Mp H =m B \\<and> pn.Mp A = A \\<and> pn.Mp B = B\n\ngoal (1 subgoal):\n 1. pn.eq_m C (A * B)", "by simp"], ["proof (state)\nthis:\n  pn.eq_m C (A * B)\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "hence \"?Mp C = ?Mp (A * B)\""], ["proof (prove)\nusing this:\n  pn.eq_m C (A * B)\n\ngoal (1 subgoal):\n 1. pn.eq_m C (A * B)", "by simp"], ["proof (state)\nthis:\n  pn.eq_m C (A * B)\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "with C AD(2)"], ["proof (chain)\npicking this:\n  monic C\n  pn.Mp C = C\n  pn.Mp A = A\n  pn.eq_m C (A * B)", "have \"pn.Mp C = pn.Mp (A * pn.Mp B)\""], ["proof (prove)\nusing this:\n  monic C\n  pn.Mp C = C\n  pn.Mp A = A\n  pn.eq_m C (A * B)\n\ngoal (1 subgoal):\n 1. pn.eq_m C (A * pn.Mp B)", "by simp"], ["proof (state)\nthis:\n  pn.eq_m C (A * pn.Mp B)\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "from arg_cong[OF this, of lead_coeff] C"], ["proof (chain)\npicking this:\n  lead_coeff (pn.Mp C) = lead_coeff (pn.Mp (A * pn.Mp B))\n  monic C\n  pn.Mp C = C", "have \"monic (pn.Mp (A * B))\""], ["proof (prove)\nusing this:\n  lead_coeff (pn.Mp C) = lead_coeff (pn.Mp (A * pn.Mp B))\n  monic C\n  pn.Mp C = C\n\ngoal (1 subgoal):\n 1. monic (pn.Mp (A * B))", "by simp"], ["proof (state)\nthis:\n  monic (pn.Mp (A * B))\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "then"], ["proof (chain)\npicking this:\n  monic (pn.Mp (A * B))", "have \"lead_coeff (pn.Mp A) * lead_coeff (pn.Mp B) = 1\""], ["proof (prove)\nusing this:\n  monic (pn.Mp (A * B))\n\ngoal (1 subgoal):\n 1. lead_coeff (pn.Mp A) * lead_coeff (pn.Mp B) = 1", "by (metis lead_coeff_mult leading_coeff_neq_0 local.step mult_cancel_right2 pn.degree_m_eq pn.m1 poly_mod.M_def poly_mod.Mp_coeff)"], ["proof (state)\nthis:\n  lead_coeff (pn.Mp A) * lead_coeff (pn.Mp B) = 1\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "with monA AD(2) BH(2)"], ["proof (chain)\npicking this:\n  monic A\n  pn.Mp A = A\n  pn.Mp B = B\n  lead_coeff (pn.Mp A) * lead_coeff (pn.Mp B) = 1", "have monB: \"monic B\""], ["proof (prove)\nusing this:\n  monic A\n  pn.Mp A = A\n  pn.Mp B = B\n  lead_coeff (pn.Mp A) * lead_coeff (pn.Mp B) = 1\n\ngoal (1 subgoal):\n 1. monic B", "by simp"], ["proof (state)\nthis:\n  monic B\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "from square_free_m_cong[OF sf_fact(2)] BH"], ["proof (chain)\npicking this:\n  Mp H =m ?g \\<Longrightarrow> square_free_m ?g\n  B =m Mp H\n  pn.Mp B = B\n  B =m \\<Prod>\\<^sub># (factors_of_factor_tree r)", "have sfB: \"square_free_m B\""], ["proof (prove)\nusing this:\n  Mp H =m ?g \\<Longrightarrow> square_free_m ?g\n  B =m Mp H\n  pn.Mp B = B\n  B =m \\<Prod>\\<^sub># (factors_of_factor_tree r)\n\ngoal (1 subgoal):\n 1. square_free_m B", "by auto"], ["proof (state)\nthis:\n  square_free_m B\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "have IH2: \"poly_mod.eq_m (p ^ n) B (prod_list BH) \\<and>\n      factors_of_factor_tree r = mset (map Mp BH) \\<and>\n      (\\<forall>G. G \\<in> set BH \\<longrightarrow> monic G \\<and> ?Mp G = G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pn.eq_m B (prod_list BH) \\<and>\n    factors_of_factor_tree r = mset (map Mp BH) \\<and>\n    (\\<forall>G.\n        G \\<in> set BH \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "by (rule IH2[OF BH(3) Fs BH'[symmetric] monB BH(2) sfB inv], auto)"], ["proof (state)\nthis:\n  pn.eq_m B (prod_list BH) \\<and>\n  factors_of_factor_tree r = mset (map Mp BH) \\<and>\n  (\\<forall>G. G \\<in> set BH \\<longrightarrow> monic G \\<and> pn.Mp G = G)\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "from step"], ["proof (chain)\npicking this:\n  pn.eq_m C (A * B) \\<and>\n  monic A \\<and>\n  Mp D =m A \\<and> Mp H =m B \\<and> pn.Mp A = A \\<and> pn.Mp B = B", "have \"?Mp C = ?Mp (?Mp A * ?Mp B)\""], ["proof (prove)\nusing this:\n  pn.eq_m C (A * B) \\<and>\n  monic A \\<and>\n  Mp D =m A \\<and> Mp H =m B \\<and> pn.Mp A = A \\<and> pn.Mp B = B\n\ngoal (1 subgoal):\n 1. pn.eq_m C (pn.Mp A * pn.Mp B)", "by auto"], ["proof (state)\nthis:\n  pn.eq_m C (pn.Mp A * pn.Mp B)\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "also"], ["proof (state)\nthis:\n  pn.eq_m C (pn.Mp A * pn.Mp B)\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "have \"?Mp A = ?Mp (prod_list AD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pn.eq_m A (prod_list AD)", "using IH1"], ["proof (prove)\nusing this:\n  pn.eq_m A (prod_list AD) \\<and>\n  factors_of_factor_tree l = mset (map Mp AD) \\<and>\n  (\\<forall>G. G \\<in> set AD \\<longrightarrow> monic G \\<and> pn.Mp G = G)\n\ngoal (1 subgoal):\n 1. pn.eq_m A (prod_list AD)", "by auto"], ["proof (state)\nthis:\n  pn.eq_m A (prod_list AD)\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "also"], ["proof (state)\nthis:\n  pn.eq_m A (prod_list AD)\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "have \"?Mp B = ?Mp (prod_list BH)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pn.eq_m B (prod_list BH)", "using IH2"], ["proof (prove)\nusing this:\n  pn.eq_m B (prod_list BH) \\<and>\n  factors_of_factor_tree r = mset (map Mp BH) \\<and>\n  (\\<forall>G. G \\<in> set BH \\<longrightarrow> monic G \\<and> pn.Mp G = G)\n\ngoal (1 subgoal):\n 1. pn.eq_m B (prod_list BH)", "by auto"], ["proof (state)\nthis:\n  pn.eq_m B (prod_list BH)\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "finally"], ["proof (chain)\npicking this:\n  pn.eq_m C (pn.Mp (prod_list AD) * pn.Mp (prod_list BH))", "have \"poly_mod.eq_m (p ^ n) C (prod_list AD * prod_list BH)\""], ["proof (prove)\nusing this:\n  pn.eq_m C (pn.Mp (prod_list AD) * pn.Mp (prod_list BH))\n\ngoal (1 subgoal):\n 1. pn.eq_m C (prod_list AD * prod_list BH)", "by (auto simp: poly_mod.mult_Mp)"], ["proof (state)\nthis:\n  pn.eq_m C (prod_list AD * prod_list BH)\n\ngoal (1 subgoal):\n 1. \\<And>x1 Fs1 Fs2 C Gs.\n       \\<lbrakk>\\<And>C Gs.\n                   \\<lbrakk>C =m\n                            \\<Prod>\\<^sub># (factors_of_factor_tree Fs1);\n                    \\<And>F.\n                       F \\<in># factors_of_factor_tree Fs1 \\<Longrightarrow>\n                       Mp F = F \\<and> monic F;\n                    hensel_main C Fs1 = Gs; monic C; pn.Mp C = C;\n                    square_free_m C;\n                    \\<And>t f.\n                       \\<lbrakk>t \\<in> sub_trees Fs1;\n                        factor_node_info t = f\\<rbrakk>\n                       \\<Longrightarrow> f =\n   Mp (\\<Prod>\\<^sub># (factors_of_factor_tree t))\\<rbrakk>\n                   \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                                     factors_of_factor_tree Fs1 =\n                                     mset (map Mp Gs) \\<and>\n                                     (\\<forall>G.\n   G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G);\n        \\<And>C Gs.\n           \\<lbrakk>C =m \\<Prod>\\<^sub># (factors_of_factor_tree Fs2);\n            \\<And>F.\n               F \\<in># factors_of_factor_tree Fs2 \\<Longrightarrow>\n               Mp F = F \\<and> monic F;\n            hensel_main C Fs2 = Gs; monic C; pn.Mp C = C; square_free_m C;\n            \\<And>t f.\n               \\<lbrakk>t \\<in> sub_trees Fs2;\n                factor_node_info t = f\\<rbrakk>\n               \\<Longrightarrow> f =\n                                 Mp (\\<Prod>\\<^sub>#\n(factors_of_factor_tree t))\\<rbrakk>\n           \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                             factors_of_factor_tree Fs2 =\n                             mset (map Mp Gs) \\<and>\n                             (\\<forall>G.\n                                 G \\<in> set Gs \\<longrightarrow>\n                                 monic G \\<and> pn.Mp G = G);\n        C =m\n        \\<Prod>\\<^sub># (factors_of_factor_tree (Factor_Node x1 Fs1 Fs2));\n        \\<And>F.\n           F \\<in># factors_of_factor_tree\n                     (Factor_Node x1 Fs1 Fs2) \\<Longrightarrow>\n           Mp F = F \\<and> monic F;\n        hensel_main C (Factor_Node x1 Fs1 Fs2) = Gs; monic C; pn.Mp C = C;\n        square_free_m C;\n        \\<And>t f.\n           \\<lbrakk>t \\<in> sub_trees (Factor_Node x1 Fs1 Fs2);\n            factor_node_info t = f\\<rbrakk>\n           \\<Longrightarrow> f =\n                             Mp (\\<Prod>\\<^sub>#\n                                  (factors_of_factor_tree t))\\<rbrakk>\n       \\<Longrightarrow> pn.eq_m C (prod_list Gs) \\<and>\n                         factors_of_factor_tree (Factor_Node x1 Fs1 Fs2) =\n                         mset (map Mp Gs) \\<and>\n                         (\\<forall>G.\n                             G \\<in> set Gs \\<longrightarrow>\n                             monic G \\<and> pn.Mp G = G)", "thus ?case"], ["proof (prove)\nusing this:\n  pn.eq_m C (prod_list AD * prod_list BH)\n\ngoal (1 subgoal):\n 1. pn.eq_m C (prod_list Gs) \\<and>\n    factors_of_factor_tree (Factor_Node f l r) = mset (map Mp Gs) \\<and>\n    (\\<forall>G.\n        G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "unfolding Gs"], ["proof (prove)\nusing this:\n  pn.eq_m C (prod_list AD * prod_list BH)\n\ngoal (1 subgoal):\n 1. pn.eq_m C (prod_list (AD @ BH)) \\<and>\n    factors_of_factor_tree (Factor_Node f l r) =\n    mset (map Mp (AD @ BH)) \\<and>\n    (\\<forall>G.\n        G \\<in> set (AD @ BH) \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "using IH1 IH2"], ["proof (prove)\nusing this:\n  pn.eq_m C (prod_list AD * prod_list BH)\n  pn.eq_m A (prod_list AD) \\<and>\n  factors_of_factor_tree l = mset (map Mp AD) \\<and>\n  (\\<forall>G. G \\<in> set AD \\<longrightarrow> monic G \\<and> pn.Mp G = G)\n  pn.eq_m B (prod_list BH) \\<and>\n  factors_of_factor_tree r = mset (map Mp BH) \\<and>\n  (\\<forall>G. G \\<in> set BH \\<longrightarrow> monic G \\<and> pn.Mp G = G)\n\ngoal (1 subgoal):\n 1. pn.eq_m C (prod_list (AD @ BH)) \\<and>\n    factors_of_factor_tree (Factor_Node f l r) =\n    mset (map Mp (AD @ BH)) \\<and>\n    (\\<forall>G.\n        G \\<in> set (AD @ BH) \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "by auto"], ["proof (state)\nthis:\n  pn.eq_m C (prod_list Gs) \\<and>\n  factors_of_factor_tree (Factor_Node f l r) = mset (map Mp Gs) \\<and>\n  (\\<forall>G. G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hensel_lifting_monic: \n  assumes eq: \"poly_mod.eq_m p C (prod_list Fs)\"\n  and Fs: \"\\<And> F. F \\<in> set Fs \\<Longrightarrow> poly_mod.Mp p F = F \\<and> monic F\"  \n  and res: \"hensel_lifting_monic p n C Fs = Gs\" \n  and mon: \"monic (poly_mod.Mp (p^n) C)\" \n  and sf: \"poly_mod.square_free_m p C\"\n  shows \"poly_mod.eq_m (p^n) C (prod_list Gs)\"\n    \"mset (map (poly_mod.Mp p) Gs) = mset Fs\" \n    \"G \\<in> set Gs \\<Longrightarrow> monic G \\<and> poly_mod.Mp (p^n) G = G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.Mp (p ^ n) C = poly_mod.Mp (p ^ n) (prod_list Gs) &&&\n    mset (map Mp Gs) = mset Fs &&&\n    (G \\<in> set Gs \\<Longrightarrow>\n     monic G \\<and> poly_mod.Mp (p ^ n) G = G)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. poly_mod.Mp (p ^ n) C = poly_mod.Mp (p ^ n) (prod_list Gs)\n 2. mset (map Mp Gs) = mset Fs\n 3. G \\<in> set Gs \\<Longrightarrow>\n    monic G \\<and> poly_mod.Mp (p ^ n) G = G", "note res = res[unfolded hensel_lifting_monic_def Let_def]"], ["proof (state)\nthis:\n  (if Fs = [] then []\n   else hensel_main (poly_mod.Mp (p ^ n) C)\n         (product_factor_tree p (create_factor_tree Fs))) =\n  Gs\n\ngoal (3 subgoals):\n 1. poly_mod.Mp (p ^ n) C = poly_mod.Mp (p ^ n) (prod_list Gs)\n 2. mset (map Mp Gs) = mset Fs\n 3. G \\<in> set Gs \\<Longrightarrow>\n    monic G \\<and> poly_mod.Mp (p ^ n) G = G", "let ?Mp = \"poly_mod.Mp (p ^ n)\""], ["proof (state)\ngoal (3 subgoals):\n 1. poly_mod.Mp (p ^ n) C = poly_mod.Mp (p ^ n) (prod_list Gs)\n 2. mset (map Mp Gs) = mset Fs\n 3. G \\<in> set Gs \\<Longrightarrow>\n    monic G \\<and> poly_mod.Mp (p ^ n) G = G", "let ?C = \"?Mp C\""], ["proof (state)\ngoal (3 subgoals):\n 1. poly_mod.Mp (p ^ n) C = poly_mod.Mp (p ^ n) (prod_list Gs)\n 2. mset (map Mp Gs) = mset Fs\n 3. G \\<in> set Gs \\<Longrightarrow>\n    monic G \\<and> poly_mod.Mp (p ^ n) G = G", "interpret poly_mod_prime p"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_prime p", "by (unfold_locales, insert n prime, auto)"], ["proof (state)\ngoal (3 subgoals):\n 1. poly_mod.Mp (p ^ n) C = poly_mod.Mp (p ^ n) (prod_list Gs)\n 2. mset (map Mp Gs) = mset Fs\n 3. G \\<in> set Gs \\<Longrightarrow>\n    monic G \\<and> poly_mod.Mp (p ^ n) G = G", "interpret pn: poly_mod_2 \"p^n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_2 (p ^ n)", "using m1 n poly_mod_2.intro"], ["proof (prove)\nusing this:\n  1 < p\n  n \\<noteq> 0\n  1 < ?m \\<Longrightarrow> poly_mod_2 ?m\n\ngoal (1 subgoal):\n 1. poly_mod_2 (p ^ n)", "by auto"], ["proof (state)\ngoal (3 subgoals):\n 1. pn.eq_m C (prod_list Gs)\n 2. mset (map Mp Gs) = mset Fs\n 3. G \\<in> set Gs \\<Longrightarrow> monic G \\<and> pn.Mp G = G", "from eq n"], ["proof (chain)\npicking this:\n  C =m prod_list Fs\n  n \\<noteq> 0", "have eq: \"eq_m (?Mp C) (prod_list Fs)\""], ["proof (prove)\nusing this:\n  C =m prod_list Fs\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pn.Mp C =m prod_list Fs", "using Mp_Mp_pow_is_Mp eq m1 n"], ["proof (prove)\nusing this:\n  C =m prod_list Fs\n  n \\<noteq> 0\n  \\<lbrakk>?n \\<noteq> 0; 1 < ?p\\<rbrakk>\n  \\<Longrightarrow> poly_mod.Mp ?p (poly_mod.Mp (?p ^ ?n) ?f) =\n                    poly_mod.Mp ?p ?f\n  C =m prod_list Fs\n  1 < p\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pn.Mp C =m prod_list Fs", "by force"], ["proof (state)\nthis:\n  pn.Mp C =m prod_list Fs\n\ngoal (3 subgoals):\n 1. pn.eq_m C (prod_list Gs)\n 2. mset (map Mp Gs) = mset Fs\n 3. G \\<in> set Gs \\<Longrightarrow> monic G \\<and> pn.Mp G = G", "have \"poly_mod.eq_m (p^n) C (prod_list Gs) \\<and> mset (map (poly_mod.Mp p) Gs) = mset Fs\n    \\<and> (G \\<in> set Gs \\<longrightarrow> monic G \\<and> poly_mod.Mp (p^n) G = G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "proof (cases \"Fs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Fs = [] \\<Longrightarrow>\n    pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)\n 2. Fs \\<noteq> [] \\<Longrightarrow>\n    pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "case True"], ["proof (state)\nthis:\n  Fs = []\n\ngoal (2 subgoals):\n 1. Fs = [] \\<Longrightarrow>\n    pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)\n 2. Fs \\<noteq> [] \\<Longrightarrow>\n    pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "with res"], ["proof (chain)\npicking this:\n  (if Fs = [] then []\n   else hensel_main (pn.Mp C)\n         (product_factor_tree p (create_factor_tree Fs))) =\n  Gs\n  Fs = []", "have Gs: \"Gs = []\""], ["proof (prove)\nusing this:\n  (if Fs = [] then []\n   else hensel_main (pn.Mp C)\n         (product_factor_tree p (create_factor_tree Fs))) =\n  Gs\n  Fs = []\n\ngoal (1 subgoal):\n 1. Gs = []", "by auto"], ["proof (state)\nthis:\n  Gs = []\n\ngoal (2 subgoals):\n 1. Fs = [] \\<Longrightarrow>\n    pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)\n 2. Fs \\<noteq> [] \\<Longrightarrow>\n    pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "from eq"], ["proof (chain)\npicking this:\n  pn.Mp C =m prod_list Fs", "have \"Mp ?C = 1\""], ["proof (prove)\nusing this:\n  pn.Mp C =m prod_list Fs\n\ngoal (1 subgoal):\n 1. Mp (pn.Mp C) = 1", "unfolding True"], ["proof (prove)\nusing this:\n  pn.Mp C =m prod_list []\n\ngoal (1 subgoal):\n 1. Mp (pn.Mp C) = 1", "by simp"], ["proof (state)\nthis:\n  Mp (pn.Mp C) = 1\n\ngoal (2 subgoals):\n 1. Fs = [] \\<Longrightarrow>\n    pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)\n 2. Fs \\<noteq> [] \\<Longrightarrow>\n    pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "hence \"degree (Mp ?C) = 0\""], ["proof (prove)\nusing this:\n  Mp (pn.Mp C) = 1\n\ngoal (1 subgoal):\n 1. degree_m (pn.Mp C) = 0", "by simp"], ["proof (state)\nthis:\n  degree_m (pn.Mp C) = 0\n\ngoal (2 subgoals):\n 1. Fs = [] \\<Longrightarrow>\n    pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)\n 2. Fs \\<noteq> [] \\<Longrightarrow>\n    pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "with degree_m_eq_monic[OF mon m1]"], ["proof (chain)\npicking this:\n  degree_m (pn.Mp C) = pn.degree_m C\n  degree_m (pn.Mp C) = 0", "have \"degree ?C = 0\""], ["proof (prove)\nusing this:\n  degree_m (pn.Mp C) = pn.degree_m C\n  degree_m (pn.Mp C) = 0\n\ngoal (1 subgoal):\n 1. pn.degree_m C = 0", "by simp"], ["proof (state)\nthis:\n  pn.degree_m C = 0\n\ngoal (2 subgoals):\n 1. Fs = [] \\<Longrightarrow>\n    pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)\n 2. Fs \\<noteq> [] \\<Longrightarrow>\n    pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "with mon"], ["proof (chain)\npicking this:\n  monic (pn.Mp C)\n  pn.degree_m C = 0", "have \"?C = 1\""], ["proof (prove)\nusing this:\n  monic (pn.Mp C)\n  pn.degree_m C = 0\n\ngoal (1 subgoal):\n 1. pn.Mp C = 1", "using monic_degree_0"], ["proof (prove)\nusing this:\n  monic (pn.Mp C)\n  pn.degree_m C = 0\n  monic ?p \\<Longrightarrow> (degree ?p = 0) = (?p = 1)\n\ngoal (1 subgoal):\n 1. pn.Mp C = 1", "by blast"], ["proof (state)\nthis:\n  pn.Mp C = 1\n\ngoal (2 subgoals):\n 1. Fs = [] \\<Longrightarrow>\n    pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)\n 2. Fs \\<noteq> [] \\<Longrightarrow>\n    pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "thus ?thesis"], ["proof (prove)\nusing this:\n  pn.Mp C = 1\n\ngoal (1 subgoal):\n 1. pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "unfolding True Gs"], ["proof (prove)\nusing this:\n  pn.Mp C = 1\n\ngoal (1 subgoal):\n 1. pn.eq_m C (prod_list []) \\<and>\n    mset (map Mp []) = mset [] \\<and>\n    (G \\<in> set [] \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "by auto"], ["proof (state)\nthis:\n  pn.eq_m C (prod_list Gs) \\<and>\n  mset (map Mp Gs) = mset Fs \\<and>\n  (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)\n\ngoal (1 subgoal):\n 1. Fs \\<noteq> [] \\<Longrightarrow>\n    pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Fs \\<noteq> [] \\<Longrightarrow>\n    pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "case False"], ["proof (state)\nthis:\n  Fs \\<noteq> []\n\ngoal (1 subgoal):\n 1. Fs \\<noteq> [] \\<Longrightarrow>\n    pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "let ?t = \"create_factor_tree Fs\""], ["proof (state)\ngoal (1 subgoal):\n 1. Fs \\<noteq> [] \\<Longrightarrow>\n    pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "note tree = create_factor_tree[OF False]"], ["proof (state)\nthis:\n  factors_of_factor_tree (create_factor_tree Fs) = mset Fs\n\ngoal (1 subgoal):\n 1. Fs \\<noteq> [] \\<Longrightarrow>\n    pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "from False res"], ["proof (chain)\npicking this:\n  Fs \\<noteq> []\n  (if Fs = [] then []\n   else hensel_main (pn.Mp C)\n         (product_factor_tree p (create_factor_tree Fs))) =\n  Gs", "have hen: \"hensel_main ?C (product_factor_tree p ?t) = Gs\""], ["proof (prove)\nusing this:\n  Fs \\<noteq> []\n  (if Fs = [] then []\n   else hensel_main (pn.Mp C)\n         (product_factor_tree p (create_factor_tree Fs))) =\n  Gs\n\ngoal (1 subgoal):\n 1. hensel_main (pn.Mp C) (product_factor_tree p (create_factor_tree Fs)) =\n    Gs", "by auto"], ["proof (state)\nthis:\n  hensel_main (pn.Mp C) (product_factor_tree p (create_factor_tree Fs)) = Gs\n\ngoal (1 subgoal):\n 1. Fs \\<noteq> [] \\<Longrightarrow>\n    pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "have tree1: \"x \\<in># factors_of_factor_tree ?t \\<Longrightarrow> Mp x = x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in># factors_of_factor_tree\n              (create_factor_tree Fs) \\<Longrightarrow>\n    Mp x = x", "unfolding tree"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in># mset Fs \\<Longrightarrow> Mp x = x", "using Fs"], ["proof (prove)\nusing this:\n  ?F \\<in> set Fs \\<Longrightarrow> Mp ?F = ?F \\<and> monic ?F\n\ngoal (1 subgoal):\n 1. x \\<in># mset Fs \\<Longrightarrow> Mp x = x", "by auto"], ["proof (state)\nthis:\n  ?x \\<in># factors_of_factor_tree (create_factor_tree Fs) \\<Longrightarrow>\n  Mp ?x = ?x\n\ngoal (1 subgoal):\n 1. Fs \\<noteq> [] \\<Longrightarrow>\n    pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "from product_factor_tree[OF tree1 sub_trees_refl refl, of ?t]"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      x \\<in># factors_of_factor_tree\n                (create_factor_tree Fs) \\<Longrightarrow>\n      x \\<in># factors_of_factor_tree\n                (create_factor_tree Fs)) \\<Longrightarrow>\n  Mp (factor_node_info (product_factor_tree p (create_factor_tree Fs))) =\n  factor_node_info (product_factor_tree p (create_factor_tree Fs)) \\<and>\n  factor_node_info (product_factor_tree p (create_factor_tree Fs)) =\n  Mp (\\<Prod>\\<^sub>#\n       (factors_of_factor_tree\n         (product_factor_tree p (create_factor_tree Fs)))) \\<and>\n  factors_of_factor_tree (product_factor_tree p (create_factor_tree Fs)) =\n  factors_of_factor_tree (create_factor_tree Fs)", "have id: \"(factors_of_factor_tree (product_factor_tree p ?t)) =\n        (factors_of_factor_tree ?t)\""], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in># factors_of_factor_tree\n                (create_factor_tree Fs) \\<Longrightarrow>\n      x \\<in># factors_of_factor_tree\n                (create_factor_tree Fs)) \\<Longrightarrow>\n  Mp (factor_node_info (product_factor_tree p (create_factor_tree Fs))) =\n  factor_node_info (product_factor_tree p (create_factor_tree Fs)) \\<and>\n  factor_node_info (product_factor_tree p (create_factor_tree Fs)) =\n  Mp (\\<Prod>\\<^sub>#\n       (factors_of_factor_tree\n         (product_factor_tree p (create_factor_tree Fs)))) \\<and>\n  factors_of_factor_tree (product_factor_tree p (create_factor_tree Fs)) =\n  factors_of_factor_tree (create_factor_tree Fs)\n\ngoal (1 subgoal):\n 1. factors_of_factor_tree (product_factor_tree p (create_factor_tree Fs)) =\n    factors_of_factor_tree (create_factor_tree Fs)", "by auto"], ["proof (state)\nthis:\n  factors_of_factor_tree (product_factor_tree p (create_factor_tree Fs)) =\n  factors_of_factor_tree (create_factor_tree Fs)\n\ngoal (1 subgoal):\n 1. Fs \\<noteq> [] \\<Longrightarrow>\n    pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "have eq: \"eq_m ?C (prod_mset (factors_of_factor_tree (product_factor_tree p ?t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pn.Mp C =m\n    \\<Prod>\\<^sub>#\n     (factors_of_factor_tree\n       (product_factor_tree p (create_factor_tree Fs)))", "unfolding id tree"], ["proof (prove)\ngoal (1 subgoal):\n 1. pn.Mp C =m \\<Prod>\\<^sub># (mset Fs)", "using eq"], ["proof (prove)\nusing this:\n  pn.Mp C =m prod_list Fs\n\ngoal (1 subgoal):\n 1. pn.Mp C =m \\<Prod>\\<^sub># (mset Fs)", "by auto"], ["proof (state)\nthis:\n  pn.Mp C =m\n  \\<Prod>\\<^sub>#\n   (factors_of_factor_tree (product_factor_tree p (create_factor_tree Fs)))\n\ngoal (1 subgoal):\n 1. Fs \\<noteq> [] \\<Longrightarrow>\n    pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "have id': \"Mp C = Mp ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C =m pn.Mp C", "using n"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. C =m pn.Mp C", "by (simp add: Mp_Mp_pow_is_Mp m1)"], ["proof (state)\nthis:\n  C =m pn.Mp C\n\ngoal (1 subgoal):\n 1. Fs \\<noteq> [] \\<Longrightarrow>\n    pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "have \"pn.eq_m ?C (prod_list Gs) \\<and> mset Fs = mset (map Mp Gs) \\<and> (\\<forall>G. G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pn.eq_m (pn.Mp C) (prod_list Gs) \\<and>\n    mset Fs = mset (map Mp Gs) \\<and>\n    (\\<forall>G.\n        G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "by (rule hensel_main[OF eq Fs hen mon pn.Mp_Mp square_free_m_cong[OF sf id'], unfolded id tree],\n      insert product_factor_tree[OF tree1], auto)"], ["proof (state)\nthis:\n  pn.eq_m (pn.Mp C) (prod_list Gs) \\<and>\n  mset Fs = mset (map Mp Gs) \\<and>\n  (\\<forall>G. G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)\n\ngoal (1 subgoal):\n 1. Fs \\<noteq> [] \\<Longrightarrow>\n    pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "thus ?thesis"], ["proof (prove)\nusing this:\n  pn.eq_m (pn.Mp C) (prod_list Gs) \\<and>\n  mset Fs = mset (map Mp Gs) \\<and>\n  (\\<forall>G. G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)\n\ngoal (1 subgoal):\n 1. pn.eq_m C (prod_list Gs) \\<and>\n    mset (map Mp Gs) = mset Fs \\<and>\n    (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)", "by auto"], ["proof (state)\nthis:\n  pn.eq_m C (prod_list Gs) \\<and>\n  mset (map Mp Gs) = mset Fs \\<and>\n  (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pn.eq_m C (prod_list Gs) \\<and>\n  mset (map Mp Gs) = mset Fs \\<and>\n  (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)\n\ngoal (3 subgoals):\n 1. pn.eq_m C (prod_list Gs)\n 2. mset (map Mp Gs) = mset Fs\n 3. G \\<in> set Gs \\<Longrightarrow> monic G \\<and> pn.Mp G = G", "thus \"poly_mod.eq_m (p^n) C (prod_list Gs)\"\n    \"mset (map (poly_mod.Mp p) Gs) = mset Fs\" \n    \"G \\<in> set Gs \\<Longrightarrow> monic G \\<and> poly_mod.Mp (p^n) G = G\""], ["proof (prove)\nusing this:\n  pn.eq_m C (prod_list Gs) \\<and>\n  mset (map Mp Gs) = mset Fs \\<and>\n  (G \\<in> set Gs \\<longrightarrow> monic G \\<and> pn.Mp G = G)\n\ngoal (1 subgoal):\n 1. pn.eq_m C (prod_list Gs) &&&\n    mset (map Mp Gs) = mset Fs &&&\n    (G \\<in> set Gs \\<Longrightarrow> monic G \\<and> pn.Mp G = G)", "by blast+"], ["proof (state)\nthis:\n  pn.eq_m C (prod_list Gs)\n  mset (map Mp Gs) = mset Fs\n  G \\<in> set Gs \\<Longrightarrow> monic G \\<and> pn.Mp G = G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hensel_lifting:\n  assumes res: \"hensel_lifting p n f fs = gs\"                      \\<comment> \\<open>result of hensel is fact. \\<open>gs\\<close>\\<close>\n    and cop: \"coprime (lead_coeff f) p\"\n    and sf: \"poly_mod.square_free_m p f\"\n    and fact: \"poly_mod.factorization_m p f (c, mset fs)\"          \\<comment> \\<open>input is fact. \\<open>fs mod p\\<close>\\<close>\n    and c: \"c \\<in> {0..<p}\"\n    and norm: \"(\\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p})\"\n  shows \"poly_mod.factorization_m (p^n) f (lead_coeff f, mset gs) \\<comment> \\<open>factorization mod \\<open>p^n\\<close>\\<close>\"\n      \"sort (map degree fs) = sort (map degree gs)                \\<comment> \\<open>degrees stay the same\\<close>\"\n      \"\\<And> g. g \\<in> set gs \\<Longrightarrow> monic g \\<and> poly_mod.Mp (p^n) g = g \\<and>   \\<comment> \\<open>monic and normalized\\<close>\n        irreducible_m g \\<and>                               \\<comment> \\<open>irreducibility even mod \\<open>p\\<close>\\<close>\n        degree_m g = degree g   \\<comment> \\<open>mod \\<open>p\\<close> does not change degree of \\<open>g\\<close>\\<close>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.factorization_m (p ^ n) f (lead_coeff f, mset gs) &&&\n    sort (map degree fs) = sort (map degree gs) &&&\n    (\\<And>g.\n        g \\<in> set gs \\<Longrightarrow>\n        monic g \\<and>\n        poly_mod.Mp (p ^ n) g = g \\<and>\n        irreducible_m g \\<and> degree_m g = degree g)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. poly_mod.factorization_m (p ^ n) f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       poly_mod.Mp (p ^ n) g = g \\<and>\n       irreducible_m g \\<and> degree_m g = degree g", "interpret poly_mod_prime p"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_prime p", "using prime"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. poly_mod_prime p", "by unfold_locales"], ["proof (state)\ngoal (3 subgoals):\n 1. poly_mod.factorization_m (p ^ n) f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       poly_mod.Mp (p ^ n) g = g \\<and>\n       irreducible_m g \\<and> degree_m g = degree g", "interpret q: poly_mod_2 \"p^n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod_2 (p ^ n)", "using m1 n"], ["proof (prove)\nusing this:\n  1 < p\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_mod_2 (p ^ n)", "unfolding poly_mod_2_def"], ["proof (prove)\nusing this:\n  1 < p\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 < p ^ n", "by auto"], ["proof (state)\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "from fact"], ["proof (chain)\npicking this:\n  factorization_m f (c, mset fs)", "have eq: \"eq_m f (smult c (prod_list fs))\"  \n    and mon_fs: \"(\\<forall>fi\\<in>set fs. monic (Mp fi) \\<and> irreducible\\<^sub>d_m fi)\""], ["proof (prove)\nusing this:\n  factorization_m f (c, mset fs)\n\ngoal (1 subgoal):\n 1. f =m Polynomial.smult c (prod_list fs) &&&\n    \\<forall>fi\\<in>set fs. monic (Mp fi) \\<and> irreducible\\<^sub>d_m fi", "unfolding factorization_m_def"], ["proof (prove)\nusing this:\n  case (c, mset fs) of\n  (c, fs) \\<Rightarrow>\n    f =m Polynomial.smult c (\\<Prod>\\<^sub># fs) \\<and>\n    (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n\ngoal (1 subgoal):\n 1. f =m Polynomial.smult c (prod_list fs) &&&\n    \\<forall>fi\\<in>set fs. monic (Mp fi) \\<and> irreducible\\<^sub>d_m fi", "by auto"], ["proof (state)\nthis:\n  f =m Polynomial.smult c (prod_list fs)\n  \\<forall>fi\\<in>set fs. monic (Mp fi) \\<and> irreducible\\<^sub>d_m fi\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "{"], ["proof (state)\nthis:\n  f =m Polynomial.smult c (prod_list fs)\n  \\<forall>fi\\<in>set fs. monic (Mp fi) \\<and> irreducible\\<^sub>d_m fi\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "fix f"], ["proof (state)\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "assume \"f \\<in> set fs\""], ["proof (state)\nthis:\n  f \\<in> set fs\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "with mon_fs norm"], ["proof (chain)\npicking this:\n  \\<forall>fi\\<in>set fs. monic (Mp fi) \\<and> irreducible\\<^sub>d_m fi\n  \\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p}\n  f \\<in> set fs", "have \"set (coeffs f) \\<subseteq> {0..<p}\" and \"monic (Mp f)\""], ["proof (prove)\nusing this:\n  \\<forall>fi\\<in>set fs. monic (Mp fi) \\<and> irreducible\\<^sub>d_m fi\n  \\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p}\n  f \\<in> set fs\n\ngoal (1 subgoal):\n 1. set (coeffs f) \\<subseteq> {0..<p} &&& monic (Mp f)", "by auto"], ["proof (state)\nthis:\n  set (coeffs f) \\<subseteq> {0..<p}\n  monic (Mp f)\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "hence \"monic f\""], ["proof (prove)\nusing this:\n  set (coeffs f) \\<subseteq> {0..<p}\n  monic (Mp f)\n\ngoal (1 subgoal):\n 1. monic f", "using Mp_ident_iff'"], ["proof (prove)\nusing this:\n  set (coeffs f) \\<subseteq> {0..<p}\n  monic (Mp f)\n  (Mp ?f = ?f) = (set (coeffs ?f) \\<subseteq> {0..<p})\n\ngoal (1 subgoal):\n 1. monic f", "by force"], ["proof (state)\nthis:\n  monic f\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "}"], ["proof (state)\nthis:\n  ?fa2 \\<in> set fs \\<Longrightarrow> monic ?fa2\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "note mon_fs' = this"], ["proof (state)\nthis:\n  ?fa2 \\<in> set fs \\<Longrightarrow> monic ?fa2\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "have Mp_id: \"\\<And> f. Mp (q.Mp f) = Mp f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. q.Mp f =m f", "by (simp add: Mp_Mp_pow_is_Mp m1 n)"], ["proof (state)\nthis:\n  q.Mp ?f =m ?f\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "let ?lc = \"lead_coeff f\""], ["proof (state)\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "let ?q = \"p ^ n\""], ["proof (state)\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "define ilc where \"ilc \\<equiv> inverse_mod ?lc ?q\""], ["proof (state)\nthis:\n  ilc \\<equiv> inverse_mod (lead_coeff f) (p ^ n)\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "define F where \"F \\<equiv> smult ilc f\""], ["proof (state)\nthis:\n  F \\<equiv> Polynomial.smult ilc f\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "from res[unfolded hensel_lifting_def Let_def]"], ["proof (chain)\npicking this:\n  hensel_lifting_monic p n\n   (Polynomial.smult (inverse_mod (lead_coeff f) (p ^ n)) f) fs =\n  gs", "have hen: \"hensel_lifting_monic p n F fs = gs\""], ["proof (prove)\nusing this:\n  hensel_lifting_monic p n\n   (Polynomial.smult (inverse_mod (lead_coeff f) (p ^ n)) f) fs =\n  gs\n\ngoal (1 subgoal):\n 1. hensel_lifting_monic p n F fs = gs", "unfolding ilc_def F_def"], ["proof (prove)\nusing this:\n  hensel_lifting_monic p n\n   (Polynomial.smult (inverse_mod (lead_coeff f) (p ^ n)) f) fs =\n  gs\n\ngoal (1 subgoal):\n 1. hensel_lifting_monic p n\n     (Polynomial.smult (inverse_mod (lead_coeff f) (p ^ n)) f) fs =\n    gs", "."], ["proof (state)\nthis:\n  hensel_lifting_monic p n F fs = gs\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "from m1 n cop"], ["proof (chain)\npicking this:\n  1 < p\n  n \\<noteq> 0\n  comm_monoid_mult_class.coprime (lead_coeff f) p", "have inv: \"q.M (ilc * ?lc) = 1\""], ["proof (prove)\nusing this:\n  1 < p\n  n \\<noteq> 0\n  comm_monoid_mult_class.coprime (lead_coeff f) p\n\ngoal (1 subgoal):\n 1. q.M (ilc * lead_coeff f) = 1", "by (auto simp add: q.M_def inverse_mod_pow ilc_def)"], ["proof (state)\nthis:\n  q.M (ilc * lead_coeff f) = 1\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "hence ilc0: \"ilc \\<noteq> 0\""], ["proof (prove)\nusing this:\n  q.M (ilc * lead_coeff f) = 1\n\ngoal (1 subgoal):\n 1. ilc \\<noteq> 0", "by (cases \"ilc = 0\", auto)"], ["proof (state)\nthis:\n  ilc \\<noteq> 0\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "{"], ["proof (state)\nthis:\n  ilc \\<noteq> 0\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "fix q"], ["proof (state)\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "assume \"ilc * ?lc = ?q * q\""], ["proof (state)\nthis:\n  ilc * lead_coeff f = p ^ n * q\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "from arg_cong[OF this, of q.M]"], ["proof (chain)\npicking this:\n  q.M (ilc * lead_coeff f) = q.M (p ^ n * q)", "have \"q.M (ilc * ?lc) = 0\""], ["proof (prove)\nusing this:\n  q.M (ilc * lead_coeff f) = q.M (p ^ n * q)\n\ngoal (1 subgoal):\n 1. q.M (ilc * lead_coeff f) = 0", "unfolding q.M_def"], ["proof (prove)\nusing this:\n  ilc * lead_coeff f mod p ^ n = p ^ n * q mod p ^ n\n\ngoal (1 subgoal):\n 1. ilc * lead_coeff f mod p ^ n = 0", "by auto"], ["proof (state)\nthis:\n  q.M (ilc * lead_coeff f) = 0\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "with inv"], ["proof (chain)\npicking this:\n  q.M (ilc * lead_coeff f) = 1\n  q.M (ilc * lead_coeff f) = 0", "have False"], ["proof (prove)\nusing this:\n  q.M (ilc * lead_coeff f) = 1\n  q.M (ilc * lead_coeff f) = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "}"], ["proof (state)\nthis:\n  ilc * lead_coeff f = p ^ n * ?q2 \\<Longrightarrow> False\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "note not_dvd = this"], ["proof (state)\nthis:\n  ilc * lead_coeff f = p ^ n * ?q2 \\<Longrightarrow> False\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "have mon: \"monic (q.Mp F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (q.Mp F)", "unfolding F_def q.Mp_coeff coeff_smult"], ["proof (prove)\ngoal (1 subgoal):\n 1. q.M (ilc * poly.coeff f (q.degree_m (Polynomial.smult ilc f))) = 1", "by (subst q.degree_m_eq [OF _ q.m1]) (auto simp: inv ilc0 [symmetric] intro: not_dvd)"], ["proof (state)\nthis:\n  monic (q.Mp F)\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "have \"q.Mp f = q.Mp (smult (q.M (?lc * ilc)) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q.eq_m f (Polynomial.smult (q.M (lead_coeff f * ilc)) f)", "using inv"], ["proof (prove)\nusing this:\n  q.M (ilc * lead_coeff f) = 1\n\ngoal (1 subgoal):\n 1. q.eq_m f (Polynomial.smult (q.M (lead_coeff f * ilc)) f)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  q.eq_m f (Polynomial.smult (q.M (lead_coeff f * ilc)) f)\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "also"], ["proof (state)\nthis:\n  q.eq_m f (Polynomial.smult (q.M (lead_coeff f * ilc)) f)\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "have \"\\<dots> = q.Mp (smult ?lc F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q.eq_m (Polynomial.smult (q.M (lead_coeff f * ilc)) f)\n     (Polynomial.smult (lead_coeff f) F)", "by (simp add: F_def)"], ["proof (state)\nthis:\n  q.eq_m (Polynomial.smult (q.M (lead_coeff f * ilc)) f)\n   (Polynomial.smult (lead_coeff f) F)\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "finally"], ["proof (chain)\npicking this:\n  q.eq_m f (Polynomial.smult (lead_coeff f) F)", "have f: \"q.Mp f = q.Mp (smult ?lc F)\""], ["proof (prove)\nusing this:\n  q.eq_m f (Polynomial.smult (lead_coeff f) F)\n\ngoal (1 subgoal):\n 1. q.eq_m f (Polynomial.smult (lead_coeff f) F)", "."], ["proof (state)\nthis:\n  q.eq_m f (Polynomial.smult (lead_coeff f) F)\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "from arg_cong[OF f, of Mp]"], ["proof (chain)\npicking this:\n  q.Mp f =m q.Mp (Polynomial.smult (lead_coeff f) F)", "have f_p: \"Mp f = Mp (smult ?lc F)\""], ["proof (prove)\nusing this:\n  q.Mp f =m q.Mp (Polynomial.smult (lead_coeff f) F)\n\ngoal (1 subgoal):\n 1. f =m Polynomial.smult (lead_coeff f) F", "by (simp add: Mp_Mp_pow_is_Mp n m1)"], ["proof (state)\nthis:\n  f =m Polynomial.smult (lead_coeff f) F\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "from arg_cong[OF this, of square_free_m, unfolded Mp_square_free_m] sf"], ["proof (chain)\npicking this:\n  square_free_m f = square_free_m (Polynomial.smult (lead_coeff f) F)\n  square_free_m f", "have \"square_free_m (smult ?lc F)\""], ["proof (prove)\nusing this:\n  square_free_m f = square_free_m (Polynomial.smult (lead_coeff f) F)\n  square_free_m f\n\ngoal (1 subgoal):\n 1. square_free_m (Polynomial.smult (lead_coeff f) F)", "by simp"], ["proof (state)\nthis:\n  square_free_m (Polynomial.smult (lead_coeff f) F)\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "from square_free_m_smultD[OF this]"], ["proof (chain)\npicking this:\n  square_free_m F", "have sf: \"square_free_m F\""], ["proof (prove)\nusing this:\n  square_free_m F\n\ngoal (1 subgoal):\n 1. square_free_m F", "."], ["proof (state)\nthis:\n  square_free_m F\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "define c' where \"c' \\<equiv> M (c * ilc)\""], ["proof (state)\nthis:\n  c' \\<equiv> M (c * ilc)\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "from factorization_m_smult[OF fact, of ilc, folded F_def]"], ["proof (chain)\npicking this:\n  factorization_m F (c * ilc, mset fs)", "have fact: \"factorization_m F (c', mset fs)\""], ["proof (prove)\nusing this:\n  factorization_m F (c * ilc, mset fs)\n\ngoal (1 subgoal):\n 1. factorization_m F (c', mset fs)", "unfolding c'_def factorization_m_def"], ["proof (prove)\nusing this:\n  case (c * ilc, mset fs) of\n  (c, fs) \\<Rightarrow>\n    F =m Polynomial.smult c (\\<Prod>\\<^sub># fs) \\<and>\n    (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n\ngoal (1 subgoal):\n 1. case (M (c * ilc), mset fs) of\n    (c, fs) \\<Rightarrow>\n      F =m Polynomial.smult c (\\<Prod>\\<^sub># fs) \\<and>\n      (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))", "by auto"], ["proof (state)\nthis:\n  factorization_m F (c', mset fs)\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "hence eq: \"eq_m F (smult c' (prod_list fs))\""], ["proof (prove)\nusing this:\n  factorization_m F (c', mset fs)\n\ngoal (1 subgoal):\n 1. F =m Polynomial.smult c' (prod_list fs)", "unfolding factorization_m_def"], ["proof (prove)\nusing this:\n  case (c', mset fs) of\n  (c, fs) \\<Rightarrow>\n    F =m Polynomial.smult c (\\<Prod>\\<^sub># fs) \\<and>\n    (\\<forall>f\\<in>#fs. irreducible\\<^sub>d_m f \\<and> monic (Mp f))\n\ngoal (1 subgoal):\n 1. F =m Polynomial.smult c' (prod_list fs)", "by auto"], ["proof (state)\nthis:\n  F =m Polynomial.smult c' (prod_list fs)\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "from factorization_m_lead_coeff[OF fact] monic_Mp[OF mon, unfolded Mp_id]"], ["proof (chain)\npicking this:\n  lead_coeff (Mp F) = M c'\n  monic (Mp F)", "have \"M c' = 1\""], ["proof (prove)\nusing this:\n  lead_coeff (Mp F) = M c'\n  monic (Mp F)\n\ngoal (1 subgoal):\n 1. M c' = 1", "by auto"], ["proof (state)\nthis:\n  M c' = 1\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "hence c': \"c' = 1\""], ["proof (prove)\nusing this:\n  M c' = 1\n\ngoal (1 subgoal):\n 1. c' = 1", "unfolding c'_def"], ["proof (prove)\nusing this:\n  M (M (c * ilc)) = 1\n\ngoal (1 subgoal):\n 1. M (c * ilc) = 1", "by auto"], ["proof (state)\nthis:\n  c' = 1\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "with eq"], ["proof (chain)\npicking this:\n  F =m Polynomial.smult c' (prod_list fs)\n  c' = 1", "have eq: \"eq_m F (prod_list fs)\""], ["proof (prove)\nusing this:\n  F =m Polynomial.smult c' (prod_list fs)\n  c' = 1\n\ngoal (1 subgoal):\n 1. F =m prod_list fs", "by auto"], ["proof (state)\nthis:\n  F =m prod_list fs\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "{"], ["proof (state)\nthis:\n  F =m prod_list fs\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "fix f"], ["proof (state)\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "assume \"f \\<in> set fs\""], ["proof (state)\nthis:\n  f \\<in> set fs\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "with mon_fs' norm"], ["proof (chain)\npicking this:\n  ?fa2 \\<in> set fs \\<Longrightarrow> monic ?fa2\n  \\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p}\n  f \\<in> set fs", "have \"Mp f = f \\<and> monic f\""], ["proof (prove)\nusing this:\n  ?fa2 \\<in> set fs \\<Longrightarrow> monic ?fa2\n  \\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p}\n  f \\<in> set fs\n\ngoal (1 subgoal):\n 1. Mp f = f \\<and> monic f", "unfolding Mp_ident_iff'"], ["proof (prove)\nusing this:\n  ?fa2 \\<in> set fs \\<Longrightarrow> monic ?fa2\n  \\<forall>fi\\<in>set fs. set (coeffs fi) \\<subseteq> {0..<p}\n  f \\<in> set fs\n\ngoal (1 subgoal):\n 1. set (coeffs f) \\<subseteq> {0..<p} \\<and> monic f", "by auto"], ["proof (state)\nthis:\n  Mp f = f \\<and> monic f\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "}"], ["proof (state)\nthis:\n  ?fa2 \\<in> set fs \\<Longrightarrow> Mp ?fa2 = ?fa2 \\<and> monic ?fa2\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "note fs = this"], ["proof (state)\nthis:\n  ?fa2 \\<in> set fs \\<Longrightarrow> Mp ?fa2 = ?fa2 \\<and> monic ?fa2\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "note hen = hensel_lifting_monic[OF eq fs hen mon sf]"], ["proof (state)\nthis:\n  (\\<And>F.\n      F \\<in> set fs \\<Longrightarrow> F \\<in> set fs) \\<Longrightarrow>\n  q.eq_m F (prod_list gs)\n  (\\<And>F.\n      F \\<in> set fs \\<Longrightarrow> F \\<in> set fs) \\<Longrightarrow>\n  mset (map Mp gs) = mset fs\n  \\<lbrakk>\\<And>F. F \\<in> set fs \\<Longrightarrow> F \\<in> set fs;\n   ?G \\<in> set gs\\<rbrakk>\n  \\<Longrightarrow> monic ?G \\<and> q.Mp ?G = ?G\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "from hen(2)"], ["proof (chain)\npicking this:\n  (\\<And>F.\n      F \\<in> set fs \\<Longrightarrow> F \\<in> set fs) \\<Longrightarrow>\n  mset (map Mp gs) = mset fs", "have gs_fs: \"mset (map Mp gs) = mset fs\""], ["proof (prove)\nusing this:\n  (\\<And>F.\n      F \\<in> set fs \\<Longrightarrow> F \\<in> set fs) \\<Longrightarrow>\n  mset (map Mp gs) = mset fs\n\ngoal (1 subgoal):\n 1. mset (map Mp gs) = mset fs", "by auto"], ["proof (state)\nthis:\n  mset (map Mp gs) = mset fs\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "have eq: \"q.eq_m f (smult ?lc (prod_list gs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q.eq_m f (Polynomial.smult (lead_coeff f) (prod_list gs))", "unfolding f"], ["proof (prove)\ngoal (1 subgoal):\n 1. q.eq_m (Polynomial.smult (lead_coeff f) F)\n     (Polynomial.smult (lead_coeff f) (prod_list gs))", "using arg_cong[OF hen(1), of \"\\<lambda> f. q.Mp (smult ?lc f)\"]"], ["proof (prove)\nusing this:\n  (\\<And>F.\n      F \\<in> set fs \\<Longrightarrow> F \\<in> set fs) \\<Longrightarrow>\n  q.eq_m (Polynomial.smult (lead_coeff f) (q.Mp F))\n   (Polynomial.smult (lead_coeff f) (q.Mp (prod_list gs)))\n\ngoal (1 subgoal):\n 1. q.eq_m (Polynomial.smult (lead_coeff f) F)\n     (Polynomial.smult (lead_coeff f) (prod_list gs))", "by simp"], ["proof (state)\nthis:\n  q.eq_m f (Polynomial.smult (lead_coeff f) (prod_list gs))\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "{"], ["proof (state)\nthis:\n  q.eq_m f (Polynomial.smult (lead_coeff f) (prod_list gs))\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "fix g"], ["proof (state)\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "assume g: \"g \\<in> set gs\""], ["proof (state)\nthis:\n  g \\<in> set gs\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "from hen(3)[OF _ g]"], ["proof (chain)\npicking this:\n  (\\<And>F.\n      F \\<in> set fs \\<Longrightarrow> F \\<in> set fs) \\<Longrightarrow>\n  monic g \\<and> q.Mp g = g", "have mon_g: \"monic g\" and Mp_g: \"q.Mp g = g\""], ["proof (prove)\nusing this:\n  (\\<And>F.\n      F \\<in> set fs \\<Longrightarrow> F \\<in> set fs) \\<Longrightarrow>\n  monic g \\<and> q.Mp g = g\n\ngoal (1 subgoal):\n 1. monic g &&& q.Mp g = g", "by auto"], ["proof (state)\nthis:\n  monic g\n  q.Mp g = g\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "from g"], ["proof (chain)\npicking this:\n  g \\<in> set gs", "have \"Mp g \\<in># mset (map Mp gs)\""], ["proof (prove)\nusing this:\n  g \\<in> set gs\n\ngoal (1 subgoal):\n 1. Mp g \\<in># mset (map Mp gs)", "by auto"], ["proof (state)\nthis:\n  Mp g \\<in># mset (map Mp gs)\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "from this[unfolded gs_fs]"], ["proof (chain)\npicking this:\n  Mp g \\<in># mset fs", "obtain f where f: \"f \\<in> set fs\" and fg: \"eq_m f g\""], ["proof (prove)\nusing this:\n  Mp g \\<in># mset fs\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> set fs; f =m g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f \\<in> set fs\n  f =m g\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "from mon_fs f fs"], ["proof (chain)\npicking this:\n  \\<forall>fi\\<in>set fs. monic (Mp fi) \\<and> irreducible\\<^sub>d_m fi\n  f \\<in> set fs\n  ?fa2 \\<in> set fs \\<Longrightarrow> Mp ?fa2 = ?fa2 \\<and> monic ?fa2", "have irr_f: \"irreducible\\<^sub>d_m f\" and mon_f: \"monic f\" and Mp_f: \"Mp f = f\""], ["proof (prove)\nusing this:\n  \\<forall>fi\\<in>set fs. monic (Mp fi) \\<and> irreducible\\<^sub>d_m fi\n  f \\<in> set fs\n  ?fa2 \\<in> set fs \\<Longrightarrow> Mp ?fa2 = ?fa2 \\<and> monic ?fa2\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d_m f &&& monic f &&& Mp f = f", "by auto"], ["proof (state)\nthis:\n  irreducible\\<^sub>d_m f\n  monic f\n  Mp f = f\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "have deg: \"degree_m g = degree g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree_m g = degree g", "by (rule degree_m_eq_monic[OF mon_g m1])"], ["proof (state)\nthis:\n  degree_m g = degree g\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "from irr_f fg"], ["proof (chain)\npicking this:\n  irreducible\\<^sub>d_m f\n  f =m g", "have irr_g: \"irreducible\\<^sub>d_m g\""], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d_m f\n  f =m g\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d_m g", "unfolding irreducible\\<^sub>d_m_def dvdm_def"], ["proof (prove)\nusing this:\n  0 < degree_m f \\<and>\n  (\\<forall>g h.\n      degree_m g < degree_m f \\<longrightarrow>\n      degree_m h < degree_m f \\<longrightarrow> Mp f \\<noteq> Mp (g * h))\n  f =m g\n\ngoal (1 subgoal):\n 1. 0 < degree_m g \\<and>\n    (\\<forall>ga h.\n        degree_m ga < degree_m g \\<longrightarrow>\n        degree_m h < degree_m g \\<longrightarrow> Mp g \\<noteq> Mp (ga * h))", "by simp"], ["proof (state)\nthis:\n  irreducible\\<^sub>d_m g\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "have \"q.irreducible\\<^sub>d_m g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q.irreducible\\<^sub>d_m g", "by (rule irreducible\\<^sub>d_lifting[OF n _ irr_g], unfold deg, rule q.degree_m_eq_monic[OF mon_g q.m1])"], ["proof (state)\nthis:\n  q.irreducible\\<^sub>d_m g\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "note mon_g Mp_g deg irr_g this"], ["proof (state)\nthis:\n  monic g\n  q.Mp g = g\n  degree_m g = degree g\n  irreducible\\<^sub>d_m g\n  q.irreducible\\<^sub>d_m g\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "}"], ["proof (state)\nthis:\n  ?g2 \\<in> set gs \\<Longrightarrow> monic ?g2\n  ?g2 \\<in> set gs \\<Longrightarrow> q.Mp ?g2 = ?g2\n  ?g2 \\<in> set gs \\<Longrightarrow> degree_m ?g2 = degree ?g2\n  ?g2 \\<in> set gs \\<Longrightarrow> irreducible\\<^sub>d_m ?g2\n  ?g2 \\<in> set gs \\<Longrightarrow> q.irreducible\\<^sub>d_m ?g2\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "note g = this"], ["proof (state)\nthis:\n  ?g2 \\<in> set gs \\<Longrightarrow> monic ?g2\n  ?g2 \\<in> set gs \\<Longrightarrow> q.Mp ?g2 = ?g2\n  ?g2 \\<in> set gs \\<Longrightarrow> degree_m ?g2 = degree ?g2\n  ?g2 \\<in> set gs \\<Longrightarrow> irreducible\\<^sub>d_m ?g2\n  ?g2 \\<in> set gs \\<Longrightarrow> q.irreducible\\<^sub>d_m ?g2\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "{"], ["proof (state)\nthis:\n  ?g2 \\<in> set gs \\<Longrightarrow> monic ?g2\n  ?g2 \\<in> set gs \\<Longrightarrow> q.Mp ?g2 = ?g2\n  ?g2 \\<in> set gs \\<Longrightarrow> degree_m ?g2 = degree ?g2\n  ?g2 \\<in> set gs \\<Longrightarrow> irreducible\\<^sub>d_m ?g2\n  ?g2 \\<in> set gs \\<Longrightarrow> q.irreducible\\<^sub>d_m ?g2\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "fix g"], ["proof (state)\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "assume \"g \\<in> set gs\""], ["proof (state)\nthis:\n  g \\<in> set gs\n\ngoal (3 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)\n 3. \\<And>g.\n       g \\<in> set gs \\<Longrightarrow>\n       monic g \\<and>\n       q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "from g[OF this]"], ["proof (chain)\npicking this:\n  monic g\n  q.Mp g = g\n  degree_m g = degree g\n  irreducible\\<^sub>d_m g\n  q.irreducible\\<^sub>d_m g", "show \"monic g \\<and> q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g\""], ["proof (prove)\nusing this:\n  monic g\n  q.Mp g = g\n  degree_m g = degree g\n  irreducible\\<^sub>d_m g\n  q.irreducible\\<^sub>d_m g\n\ngoal (1 subgoal):\n 1. monic g \\<and>\n    q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g", "by auto"], ["proof (state)\nthis:\n  monic g \\<and>\n  q.Mp g = g \\<and> irreducible_m g \\<and> degree_m g = degree g\n\ngoal (2 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)", "}"], ["proof (state)\nthis:\n  ?g2 \\<in> set gs \\<Longrightarrow>\n  monic ?g2 \\<and>\n  q.Mp ?g2 = ?g2 \\<and> irreducible_m ?g2 \\<and> degree_m ?g2 = degree ?g2\n\ngoal (2 subgoals):\n 1. q.factorization_m f (lead_coeff f, mset gs)\n 2. sort (map degree fs) = sort (map degree gs)", "show \"sort (map degree fs) = sort (map degree gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort (map degree fs) = sort (map degree gs)", "proof (rule sort_key_eq_sort_key)"], ["proof (state)\ngoal (2 subgoals):\n 1. mset (map degree fs) = mset (map degree gs)\n 2. inj_on (\\<lambda>x. x) (set (map degree fs))", "have \"mset (map degree fs) = image_mset degree (mset fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (map degree fs) = image_mset degree (mset fs)", "by auto"], ["proof (state)\nthis:\n  mset (map degree fs) = image_mset degree (mset fs)\n\ngoal (2 subgoals):\n 1. mset (map degree fs) = mset (map degree gs)\n 2. inj_on (\\<lambda>x. x) (set (map degree fs))", "also"], ["proof (state)\nthis:\n  mset (map degree fs) = image_mset degree (mset fs)\n\ngoal (2 subgoals):\n 1. mset (map degree fs) = mset (map degree gs)\n 2. inj_on (\\<lambda>x. x) (set (map degree fs))", "have \"\\<dots> = image_mset degree (mset (map Mp gs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset degree (mset fs) = image_mset degree (mset (map Mp gs))", "unfolding gs_fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset degree (mset fs) = image_mset degree (mset fs)", ".."], ["proof (state)\nthis:\n  image_mset degree (mset fs) = image_mset degree (mset (map Mp gs))\n\ngoal (2 subgoals):\n 1. mset (map degree fs) = mset (map degree gs)\n 2. inj_on (\\<lambda>x. x) (set (map degree fs))", "also"], ["proof (state)\nthis:\n  image_mset degree (mset fs) = image_mset degree (mset (map Mp gs))\n\ngoal (2 subgoals):\n 1. mset (map degree fs) = mset (map degree gs)\n 2. inj_on (\\<lambda>x. x) (set (map degree fs))", "have \"\\<dots> = mset (map degree (map Mp gs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset degree (mset (map Mp gs)) = mset (map degree (map Mp gs))", "unfolding mset_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset degree (image_mset Mp (mset gs)) =\n    image_mset degree (image_mset Mp (mset gs))", ".."], ["proof (state)\nthis:\n  image_mset degree (mset (map Mp gs)) = mset (map degree (map Mp gs))\n\ngoal (2 subgoals):\n 1. mset (map degree fs) = mset (map degree gs)\n 2. inj_on (\\<lambda>x. x) (set (map degree fs))", "also"], ["proof (state)\nthis:\n  image_mset degree (mset (map Mp gs)) = mset (map degree (map Mp gs))\n\ngoal (2 subgoals):\n 1. mset (map degree fs) = mset (map degree gs)\n 2. inj_on (\\<lambda>x. x) (set (map degree fs))", "have \"map degree (map Mp gs) = map degree_m gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map degree (map Mp gs) = map degree_m gs", "by auto"], ["proof (state)\nthis:\n  map degree (map Mp gs) = map degree_m gs\n\ngoal (2 subgoals):\n 1. mset (map degree fs) = mset (map degree gs)\n 2. inj_on (\\<lambda>x. x) (set (map degree fs))", "also"], ["proof (state)\nthis:\n  map degree (map Mp gs) = map degree_m gs\n\ngoal (2 subgoals):\n 1. mset (map degree fs) = mset (map degree gs)\n 2. inj_on (\\<lambda>x. x) (set (map degree fs))", "have \"\\<dots> = map degree gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map degree_m gs = map degree gs", "using g(3)"], ["proof (prove)\nusing this:\n  ?g2 \\<in> set gs \\<Longrightarrow> degree_m ?g2 = degree ?g2\n\ngoal (1 subgoal):\n 1. map degree_m gs = map degree gs", "by auto"], ["proof (state)\nthis:\n  map degree_m gs = map degree gs\n\ngoal (2 subgoals):\n 1. mset (map degree fs) = mset (map degree gs)\n 2. inj_on (\\<lambda>x. x) (set (map degree fs))", "finally"], ["proof (chain)\npicking this:\n  mset (map degree fs) = mset (map degree gs)", "show \"mset (map degree fs) = mset (map degree gs)\""], ["proof (prove)\nusing this:\n  mset (map degree fs) = mset (map degree gs)\n\ngoal (1 subgoal):\n 1. mset (map degree fs) = mset (map degree gs)", "."], ["proof (state)\nthis:\n  mset (map degree fs) = mset (map degree gs)\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. x) (set (map degree fs))", "qed auto"], ["proof (state)\nthis:\n  sort (map degree fs) = sort (map degree gs)\n\ngoal (1 subgoal):\n 1. q.factorization_m f (lead_coeff f, mset gs)", "show \"q.factorization_m f (lead_coeff f, mset gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q.factorization_m f (lead_coeff f, mset gs)", "using eq g"], ["proof (prove)\nusing this:\n  q.eq_m f (Polynomial.smult (lead_coeff f) (prod_list gs))\n  ?g2 \\<in> set gs \\<Longrightarrow> monic ?g2\n  ?g2 \\<in> set gs \\<Longrightarrow> q.Mp ?g2 = ?g2\n  ?g2 \\<in> set gs \\<Longrightarrow> degree_m ?g2 = degree ?g2\n  ?g2 \\<in> set gs \\<Longrightarrow> irreducible\\<^sub>d_m ?g2\n  ?g2 \\<in> set gs \\<Longrightarrow> q.irreducible\\<^sub>d_m ?g2\n\ngoal (1 subgoal):\n 1. q.factorization_m f (lead_coeff f, mset gs)", "unfolding q.factorization_m_def"], ["proof (prove)\nusing this:\n  q.eq_m f (Polynomial.smult (lead_coeff f) (prod_list gs))\n  ?g2 \\<in> set gs \\<Longrightarrow> monic ?g2\n  ?g2 \\<in> set gs \\<Longrightarrow> q.Mp ?g2 = ?g2\n  ?g2 \\<in> set gs \\<Longrightarrow> degree_m ?g2 = degree ?g2\n  ?g2 \\<in> set gs \\<Longrightarrow> irreducible\\<^sub>d_m ?g2\n  ?g2 \\<in> set gs \\<Longrightarrow> q.irreducible\\<^sub>d_m ?g2\n\ngoal (1 subgoal):\n 1. case (lead_coeff f, mset gs) of\n    (c, fs) \\<Rightarrow>\n      q.eq_m f (Polynomial.smult c (\\<Prod>\\<^sub># fs)) \\<and>\n      (\\<forall>f\\<in>#fs. q.irreducible\\<^sub>d_m f \\<and> monic (q.Mp f))", "by auto"], ["proof (state)\nthis:\n  q.factorization_m f (lead_coeff f, mset gs)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "end"]]}