{"file_name": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus/Suitable_Prime.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus", "problem_names": ["lemma square_free_separable_GFp: fixes f :: \"'a :: prime_card mod_ring poly\"\n  assumes card: \"CARD('a) > degree f\"\n  and sf: \"square_free f\" \n  shows \"separable f\"", "lemma square_free_iff_separable_GFp: assumes \"degree f < CARD('a)\" \n  shows \"square_free (f :: 'a :: prime_card mod_ring poly) = separable f\"", "lemma (in prime_field_gen) separable_impl: \n  shows \"separable_impl_main p ff_ops f \\<Longrightarrow> square_free_m f\" \n  \"p > degree_m f \\<Longrightarrow> p > separable_bound f \\<Longrightarrow> square_free f \n   \\<Longrightarrow> separable_impl_main p ff_ops f\"", "lemmas separable_impl_integer = prime_field_gen.separable_impl\n  [OF prime_field.prime_field_finite_field_ops_integer, unfolded prime_field_def mod_ring_locale_def,\n  unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise,cancel_type_definition, OF non_empty]", "lemmas separable_impl_uint32 = prime_field_gen.separable_impl\n  [OF prime_field.prime_field_finite_field_ops32, unfolded prime_field_def mod_ring_locale_def,\n  unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise,cancel_type_definition, OF non_empty]", "lemmas separable_impl_uint64 = prime_field_gen.separable_impl\n  [OF prime_field.prime_field_finite_field_ops64, unfolded prime_field_def mod_ring_locale_def,\n  unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise,cancel_type_definition, OF non_empty]", "lemma square_free_mod_imp_square_free: assumes \n  p: \"prime p\" and sf: \"poly_mod.square_free_m p f\"\n  and cop: \"coprime (lead_coeff f) p\" \n  shows \"square_free f\"", "lemma(in poly_mod_prime) separable_impl: \n  shows \"separable_impl p f \\<Longrightarrow> square_free_m f\"\n    \"nat p > degree_m f \\<Longrightarrow> nat p > separable_bound f \\<Longrightarrow> square_free f \n    \\<Longrightarrow> separable_impl p f\"", "lemma coprime_lead_coeff_large_prime: assumes prime: \"prime (p :: int)\" \n  and large: \"p > abs (lead_coeff f)\" \n  and f: \"f \\<noteq> 0\" \n  shows \"coprime (lead_coeff f) p\"", "lemma prime_for_berlekamp_zassenhaus_exists: assumes sf: \"square_free f\" \n  shows \"\\<exists> p. prime p \\<and> (coprime (lead_coeff f) p \\<and> separable_impl p f)\"", "lemma next_primes: assumes res: \"next_primes n = (m,ps)\"\n  and n: \"candidate_invariant n\"\n  shows \"candidate_invariant m\" \"sorted ps\" \"distinct ps\" \"n < m\" \n  \"set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}\"", "lemma find_prime: assumes \"\\<exists> n. prime n \\<and> f n\"\n  shows \"prime (find_prime f) \\<and> f (find_prime f)\"", "lemma suitable_prime_bz: assumes sf: \"square_free f\" and p: \"p = suitable_prime_bz f\" \n  shows \"prime p\" \"coprime (lead_coeff f) p\" \"poly_mod.square_free_m p f\"", "lemma find_Some_D: \"find f xs = Some y \\<Longrightarrow> y \\<in> set xs \\<and> f y\"", "lemma square_free_heuristic: assumes \"square_free_heuristic f = Some p\" \n  shows \"coprime (lead_coeff f) p \\<and> separable_impl p f \\<and> prime p\""], "translations": [["", "lemma square_free_separable_GFp: fixes f :: \"'a :: prime_card mod_ring poly\"\n  assumes card: \"CARD('a) > degree f\"\n  and sf: \"square_free f\" \n  shows \"separable f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separable f", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> separable f \\<Longrightarrow> False", "assume \"\\<not> separable f\""], ["proof (state)\nthis:\n  \\<not> separable f\n\ngoal (1 subgoal):\n 1. \\<not> separable f \\<Longrightarrow> False", "with square_free_separable_main[OF sf]"], ["proof (chain)\npicking this:\n  \\<not> separable f \\<Longrightarrow>\n  \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0\n  \\<not> separable f", "obtain g k where *: \"f = g * k\" \"degree g \\<noteq> 0\" and g0: \"pderiv g = 0\""], ["proof (prove)\nusing this:\n  \\<not> separable f \\<Longrightarrow>\n  \\<exists>g k. f = g * k \\<and> degree g \\<noteq> 0 \\<and> pderiv g = 0\n  \\<not> separable f\n\ngoal (1 subgoal):\n 1. (\\<And>g k.\n        \\<lbrakk>f = g * k; degree g \\<noteq> 0; pderiv g = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f = g * k\n  degree g \\<noteq> 0\n  pderiv g = 0\n\ngoal (1 subgoal):\n 1. \\<not> separable f \\<Longrightarrow> False", "from assms"], ["proof (chain)\npicking this:\n  degree f < CARD('a)\n  square_free f", "have f: \"f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree f < CARD('a)\n  square_free f\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "unfolding square_free_def"], ["proof (prove)\nusing this:\n  degree f < CARD('a)\n  f \\<noteq> 0 \\<and>\n  (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd f)\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> separable f \\<Longrightarrow> False", "have \"degree f = degree g + degree k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree f = degree g + degree k", "using f"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree f = degree g + degree k", "unfolding *(1)"], ["proof (prove)\nusing this:\n  g * k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (g * k) = degree g + degree k", "by (subst degree_mult_eq, auto)"], ["proof (state)\nthis:\n  degree f = degree g + degree k\n\ngoal (1 subgoal):\n 1. \\<not> separable f \\<Longrightarrow> False", "with card"], ["proof (chain)\npicking this:\n  degree f < CARD('a)\n  degree f = degree g + degree k", "have card: \"degree g < CARD('a)\""], ["proof (prove)\nusing this:\n  degree f < CARD('a)\n  degree f = degree g + degree k\n\ngoal (1 subgoal):\n 1. degree g < CARD('a)", "by auto"], ["proof (state)\nthis:\n  degree g < CARD('a)\n\ngoal (1 subgoal):\n 1. \\<not> separable f \\<Longrightarrow> False", "from *(2)"], ["proof (chain)\npicking this:\n  degree g \\<noteq> 0", "obtain n where deg: \"degree g = Suc n\""], ["proof (prove)\nusing this:\n  degree g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>n. degree g = Suc n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"degree g\", auto)"], ["proof (state)\nthis:\n  degree g = Suc n\n\ngoal (1 subgoal):\n 1. \\<not> separable f \\<Longrightarrow> False", "from *(2)"], ["proof (chain)\npicking this:\n  degree g \\<noteq> 0", "have cg: \"coeff g (degree g) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff g \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  lead_coeff g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> separable f \\<Longrightarrow> False", "from g0"], ["proof (chain)\npicking this:\n  pderiv g = 0", "have \"coeff (pderiv g) n = 0\""], ["proof (prove)\nusing this:\n  pderiv g = 0\n\ngoal (1 subgoal):\n 1. poly.coeff (pderiv g) n = 0", "by auto"], ["proof (state)\nthis:\n  poly.coeff (pderiv g) n = 0\n\ngoal (1 subgoal):\n 1. \\<not> separable f \\<Longrightarrow> False", "from this[unfolded coeff_pderiv, folded deg] cg"], ["proof (chain)\npicking this:\n  of_nat (degree g) * lead_coeff g = 0\n  lead_coeff g \\<noteq> 0", "have \"of_nat (degree g) = (0 :: 'a mod_ring)\""], ["proof (prove)\nusing this:\n  of_nat (degree g) * lead_coeff g = 0\n  lead_coeff g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. of_nat (degree g) = 0", "by auto"], ["proof (state)\nthis:\n  of_nat (degree g) = 0\n\ngoal (1 subgoal):\n 1. \\<not> separable f \\<Longrightarrow> False", "from of_nat_0_mod_ring_dvd[OF this]"], ["proof (chain)\npicking this:\n  CARD('a) dvd degree g", "have \"CARD('a) dvd degree g\""], ["proof (prove)\nusing this:\n  CARD('a) dvd degree g\n\ngoal (1 subgoal):\n 1. CARD('a) dvd degree g", "."], ["proof (state)\nthis:\n  CARD('a) dvd degree g\n\ngoal (1 subgoal):\n 1. \\<not> separable f \\<Longrightarrow> False", "with card"], ["proof (chain)\npicking this:\n  degree g < CARD('a)\n  CARD('a) dvd degree g", "show False"], ["proof (prove)\nusing this:\n  degree g < CARD('a)\n  CARD('a) dvd degree g\n\ngoal (1 subgoal):\n 1. False", "by (simp add: deg nat_dvd_not_less)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma square_free_iff_separable_GFp: assumes \"degree f < CARD('a)\" \n  shows \"square_free (f :: 'a :: prime_card mod_ring poly) = separable f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free f = separable f", "using separable_imp_square_free[of f] square_free_separable_GFp[OF assms]"], ["proof (prove)\nusing this:\n  separable f \\<Longrightarrow> square_free f\n  square_free f \\<Longrightarrow> separable f\n\ngoal (1 subgoal):\n 1. square_free f = separable f", "by auto"], ["", "definition separable_impl_main :: \"int \\<Rightarrow> 'i arith_ops_record \\<Rightarrow> int poly \\<Rightarrow> bool\" where\n  \"separable_impl_main p ff_ops f = separable_i ff_ops (of_int_poly_i ff_ops (poly_mod.Mp p f))\""], ["", "lemma (in prime_field_gen) separable_impl: \n  shows \"separable_impl_main p ff_ops f \\<Longrightarrow> square_free_m f\" \n  \"p > degree_m f \\<Longrightarrow> p > separable_bound f \\<Longrightarrow> square_free f \n   \\<Longrightarrow> separable_impl_main p ff_ops f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (separable_impl_main p ff_ops f \\<Longrightarrow> square_free_m f) &&&\n    (\\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n      square_free f\\<rbrakk>\n     \\<Longrightarrow> separable_impl_main p ff_ops f)", "unfolding separable_impl_main_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) \\<Longrightarrow>\n     square_free_m f) &&&\n    (\\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n      square_free f\\<rbrakk>\n     \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f)))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) \\<Longrightarrow>\n    square_free_m f\n 2. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "define F where F: \"(F :: 'a mod_ring poly) = of_int_poly (Mp f)\""], ["proof (state)\nthis:\n  F = of_int_poly (Mp f)\n\ngoal (2 subgoals):\n 1. separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) \\<Longrightarrow>\n    square_free_m f\n 2. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "let ?f' = \"of_int_poly_i ff_ops (Mp f)\""], ["proof (state)\ngoal (2 subgoals):\n 1. separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) \\<Longrightarrow>\n    square_free_m f\n 2. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "define f'' where \"f'' \\<equiv> of_int_poly (Mp f) :: 'a mod_ring poly\""], ["proof (state)\nthis:\n  f'' \\<equiv> of_int_poly (Mp f)\n\ngoal (2 subgoals):\n 1. separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) \\<Longrightarrow>\n    square_free_m f\n 2. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "have rel_f[transfer_rule]: \"poly_rel ?f' f''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (of_int_poly_i ff_ops (Mp f)) f''", "by (rule poly_rel_of_int_poly[OF refl], simp add: f''_def)"], ["proof (state)\nthis:\n  poly_rel (of_int_poly_i ff_ops (Mp f)) f''\n\ngoal (2 subgoals):\n 1. separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) \\<Longrightarrow>\n    square_free_m f\n 2. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "have \"separable_i ff_ops ?f' \\<longleftrightarrow> gcd f'' (pderiv f'') = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) =\n    (gcd f'' (pderiv f'') = 1)", "unfolding separable_i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (gcd_poly_i ff_ops (of_int_poly_i ff_ops (Mp f))\n      (pderiv_i ff_ops (of_int_poly_i ff_ops (Mp f))) =\n     one_poly_i ff_ops) =\n    (gcd f'' (pderiv f'') = 1)", "by transfer_prover"], ["proof (state)\nthis:\n  separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) =\n  (gcd f'' (pderiv f'') = 1)\n\ngoal (2 subgoals):\n 1. separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) \\<Longrightarrow>\n    square_free_m f\n 2. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "also"], ["proof (state)\nthis:\n  separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) =\n  (gcd f'' (pderiv f'') = 1)\n\ngoal (2 subgoals):\n 1. separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) \\<Longrightarrow>\n    square_free_m f\n 2. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "have \"\\<dots> \\<longleftrightarrow> coprime f'' (pderiv f'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gcd f'' (pderiv f'') = 1) =\n    comm_monoid_mult_class.coprime f'' (pderiv f'')", "by (auto simp add: gcd_eq_1_imp_coprime)"], ["proof (state)\nthis:\n  (gcd f'' (pderiv f'') = 1) =\n  comm_monoid_mult_class.coprime f'' (pderiv f'')\n\ngoal (2 subgoals):\n 1. separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) \\<Longrightarrow>\n    square_free_m f\n 2. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "finally"], ["proof (chain)\npicking this:\n  separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) =\n  comm_monoid_mult_class.coprime f'' (pderiv f'')", "have id: \"separable_i ff_ops ?f' \\<longleftrightarrow> separable f''\""], ["proof (prove)\nusing this:\n  separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) =\n  comm_monoid_mult_class.coprime f'' (pderiv f'')\n\ngoal (1 subgoal):\n 1. separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) = separable f''", "unfolding separable_def coprime_iff_coprime"], ["proof (prove)\nusing this:\n  separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) =\n  algebraic_semidom_class.coprime f'' (pderiv f'')\n\ngoal (1 subgoal):\n 1. separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) =\n    algebraic_semidom_class.coprime f'' (pderiv f'')", "."], ["proof (state)\nthis:\n  separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) = separable f''\n\ngoal (2 subgoals):\n 1. separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) \\<Longrightarrow>\n    square_free_m f\n 2. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "have Mprel [transfer_rule]: \"MP_Rel (Mp f) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MP_Rel (Mp f) F", "unfolding F MP_Rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mp (Mp f) = to_int_poly (of_int_poly (Mp f))", "by (simp add: Mp_f_representative)"], ["proof (state)\nthis:\n  MP_Rel (Mp f) F\n\ngoal (2 subgoals):\n 1. separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) \\<Longrightarrow>\n    square_free_m f\n 2. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "have \"square_free f'' = square_free F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free f'' = square_free F", "unfolding f''_def F"], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free (of_int_poly (Mp f)) = square_free (of_int_poly (Mp f))", "by simp"], ["proof (state)\nthis:\n  square_free f'' = square_free F\n\ngoal (2 subgoals):\n 1. separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) \\<Longrightarrow>\n    square_free_m f\n 2. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "also"], ["proof (state)\nthis:\n  square_free f'' = square_free F\n\ngoal (2 subgoals):\n 1. separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) \\<Longrightarrow>\n    square_free_m f\n 2. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "have \"\\<dots> = square_free_m (Mp f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free F = square_free_m (Mp f)", "by (transfer, simp)"], ["proof (state)\nthis:\n  square_free F = square_free_m (Mp f)\n\ngoal (2 subgoals):\n 1. separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) \\<Longrightarrow>\n    square_free_m f\n 2. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "also"], ["proof (state)\nthis:\n  square_free F = square_free_m (Mp f)\n\ngoal (2 subgoals):\n 1. separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) \\<Longrightarrow>\n    square_free_m f\n 2. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "have \"\\<dots> = square_free_m f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free_m (Mp f) = square_free_m f", "by simp"], ["proof (state)\nthis:\n  square_free_m (Mp f) = square_free_m f\n\ngoal (2 subgoals):\n 1. separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) \\<Longrightarrow>\n    square_free_m f\n 2. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "finally"], ["proof (chain)\npicking this:\n  square_free f'' = square_free_m f", "have id2: \"square_free f'' = square_free_m f\""], ["proof (prove)\nusing this:\n  square_free f'' = square_free_m f\n\ngoal (1 subgoal):\n 1. square_free f'' = square_free_m f", "."], ["proof (state)\nthis:\n  square_free f'' = square_free_m f\n\ngoal (2 subgoals):\n 1. separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) \\<Longrightarrow>\n    square_free_m f\n 2. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "from separable_imp_square_free[of f'']"], ["proof (chain)\npicking this:\n  separable f'' \\<Longrightarrow> square_free f''", "show \"separable_i ff_ops ?f' \\<Longrightarrow> square_free_m f\""], ["proof (prove)\nusing this:\n  separable f'' \\<Longrightarrow> square_free f''\n\ngoal (1 subgoal):\n 1. separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) \\<Longrightarrow>\n    square_free_m f", "unfolding id id2"], ["proof (prove)\nusing this:\n  separable f'' \\<Longrightarrow> square_free_m f\n\ngoal (1 subgoal):\n 1. separable f'' \\<Longrightarrow> square_free_m f", "by auto"], ["proof (state)\nthis:\n  separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) \\<Longrightarrow>\n  square_free_m f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "let ?m = \"map_poly (of_int :: int \\<Rightarrow> 'a mod_ring)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "let ?f = \"?m f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "assume \"p > degree_m f\" and bnd: \"p > separable_bound f\" and sf: \"square_free f\""], ["proof (state)\nthis:\n  int (degree_m f) < p\n  separable_bound f < p\n  square_free f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "with rel_funD[OF degree_MP_Rel Mprel, folded p]"], ["proof (chain)\npicking this:\n  degree_m (Mp f) = degree F\n  int (degree_m f) < p\n  separable_bound f < p\n  square_free f", "have \"p > degree F\""], ["proof (prove)\nusing this:\n  degree_m (Mp f) = degree F\n  int (degree_m f) < p\n  separable_bound f < p\n  square_free f\n\ngoal (1 subgoal):\n 1. int (degree F) < p", "by simp"], ["proof (state)\nthis:\n  int (degree F) < p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "hence \"CARD('a) > degree f''\""], ["proof (prove)\nusing this:\n  int (degree F) < p\n\ngoal (1 subgoal):\n 1. degree f'' < CARD('a)", "unfolding f''_def F p"], ["proof (prove)\nusing this:\n  int (degree (of_int_poly (poly_mod.Mp (int CARD('a)) f))) < int CARD('a)\n\ngoal (1 subgoal):\n 1. degree (of_int_poly (poly_mod.Mp (int CARD('a)) f)) < CARD('a)", "by simp"], ["proof (state)\nthis:\n  degree f'' < CARD('a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "from square_free_iff_separable_GFp[OF this]"], ["proof (chain)\npicking this:\n  square_free f'' = separable f''", "have \"separable_i ff_ops ?f' = square_free f''\""], ["proof (prove)\nusing this:\n  square_free f'' = separable f''\n\ngoal (1 subgoal):\n 1. separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) = square_free f''", "unfolding id id2"], ["proof (prove)\nusing this:\n  square_free_m f = separable f''\n\ngoal (1 subgoal):\n 1. separable f'' = square_free_m f", "by simp"], ["proof (state)\nthis:\n  separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) = square_free f''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "also"], ["proof (state)\nthis:\n  separable_i ff_ops (of_int_poly_i ff_ops (Mp f)) = square_free f''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "have \"\\<dots> = square_free F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free f'' = square_free F", "unfolding f''_def F"], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free (of_int_poly (Mp f)) = square_free (of_int_poly (Mp f))", "by simp"], ["proof (state)\nthis:\n  square_free f'' = square_free F\n\ngoal (1 subgoal):\n 1. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "also"], ["proof (state)\nthis:\n  square_free f'' = square_free F\n\ngoal (1 subgoal):\n 1. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "have \"F = ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F = of_int_poly f", "unfolding F"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly (Mp f) = of_int_poly f", "by (rule poly_eqI, (subst coeff_map_poly, force)+, unfold Mp_coeff, \n    auto simp: M_def, transfer, auto simp: p)"], ["proof (state)\nthis:\n  F = of_int_poly f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "also"], ["proof (state)\nthis:\n  F = of_int_poly f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "have \"square_free ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free (of_int_poly f)", "using square_free_int_imp_square_free_mod_ring[where 'a = 'a, OF sf] bnd m"], ["proof (prove)\nusing this:\n  separable_bound f < int CARD('a) \\<Longrightarrow>\n  square_free (of_int_poly f)\n  separable_bound f < p\n  p = int CARD('a)\n\ngoal (1 subgoal):\n 1. square_free (of_int_poly f)", "by auto"], ["proof (state)\nthis:\n  square_free (of_int_poly f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n     square_free f\\<rbrakk>\n    \\<Longrightarrow> separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "finally"], ["proof (chain)\npicking this:\n  separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "show \"separable_i ff_ops ?f'\""], ["proof (prove)\nusing this:\n  separable_i ff_ops (of_int_poly_i ff_ops (Mp f))\n\ngoal (1 subgoal):\n 1. separable_i ff_ops (of_int_poly_i ff_ops (Mp f))", "."], ["proof (state)\nthis:\n  separable_i ff_ops (of_int_poly_i ff_ops (Mp f))\n\ngoal:\nNo subgoals!", "qed"], ["", "context poly_mod_prime begin"], ["", "lemmas separable_impl_integer = prime_field_gen.separable_impl\n  [OF prime_field.prime_field_finite_field_ops_integer, unfolded prime_field_def mod_ring_locale_def,\n  unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise,cancel_type_definition, OF non_empty]"], ["", "lemmas separable_impl_uint32 = prime_field_gen.separable_impl\n  [OF prime_field.prime_field_finite_field_ops32, unfolded prime_field_def mod_ring_locale_def,\n  unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise,cancel_type_definition, OF non_empty]"], ["", "lemmas separable_impl_uint64 = prime_field_gen.separable_impl\n  [OF prime_field.prime_field_finite_field_ops64, unfolded prime_field_def mod_ring_locale_def,\n  unfolded poly_mod_type_simps, internalize_sort \"'a :: prime_card\", OF type_to_set, unfolded remove_duplicate_premise,cancel_type_definition, OF non_empty]"], ["", "end"], ["", "definition separable_impl :: \"int \\<Rightarrow> int poly \\<Rightarrow> bool\" where\n  \"separable_impl p = ( \n    if p \\<le> 65535 \n    then separable_impl_main p (finite_field_ops32 (uint32_of_int p))\n    else if p \\<le> 4294967295\n    then separable_impl_main p (finite_field_ops64 (uint64_of_int p))\n    else separable_impl_main p (finite_field_ops_integer (integer_of_int p)))\""], ["", "lemma square_free_mod_imp_square_free: assumes \n  p: \"prime p\" and sf: \"poly_mod.square_free_m p f\"\n  and cop: \"coprime (lead_coeff f) p\" \n  shows \"square_free f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. square_free f", "interpret poly_mod p"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. square_free f", "from sf[unfolded square_free_m_def]"], ["proof (chain)\npicking this:\n  Mp f \\<noteq> Mp 0 \\<and>\n  (\\<forall>g. degree_m g \\<noteq> 0 \\<longrightarrow> \\<not> g * g dvdm f)", "have f0: \"Mp f \\<noteq> 0\" and ndvd: \"\\<And> g. degree_m g > 0 \\<Longrightarrow> \\<not> (g * g) dvdm f\""], ["proof (prove)\nusing this:\n  Mp f \\<noteq> Mp 0 \\<and>\n  (\\<forall>g. degree_m g \\<noteq> 0 \\<longrightarrow> \\<not> g * g dvdm f)\n\ngoal (1 subgoal):\n 1. Mp f \\<noteq> 0 &&&\n    (\\<And>g. 0 < degree_m g \\<Longrightarrow> \\<not> g * g dvdm f)", "by auto"], ["proof (state)\nthis:\n  Mp f \\<noteq> 0\n  0 < degree_m ?g \\<Longrightarrow> \\<not> ?g * ?g dvdm f\n\ngoal (1 subgoal):\n 1. square_free f", "from f0"], ["proof (chain)\npicking this:\n  Mp f \\<noteq> 0", "have ff0: \"f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  Mp f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. square_free f", "show \"square_free f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free f", "unfolding square_free_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<and>\n    (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd f)", "proof (intro conjI[OF ff0] allI impI notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q * q dvd f\\<rbrakk> \\<Longrightarrow> False", "fix g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q * q dvd f\\<rbrakk> \\<Longrightarrow> False", "assume deg: \"degree g > 0\" and dvd: \"g * g dvd f\""], ["proof (state)\nthis:\n  0 < degree g\n  g * g dvd f\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q * q dvd f\\<rbrakk> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  0 < degree g\n  g * g dvd f", "obtain h where f: \"f = g * g * h\""], ["proof (prove)\nusing this:\n  0 < degree g\n  g * g dvd f\n\ngoal (1 subgoal):\n 1. (\\<And>h. f = g * g * h \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  0 < degree g\n  \\<exists>k. f = g * g * k\n\ngoal (1 subgoal):\n 1. (\\<And>h. f = g * g * h \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f = g * g * h\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q * q dvd f\\<rbrakk> \\<Longrightarrow> False", "from arg_cong[OF this, of Mp]"], ["proof (chain)\npicking this:\n  f =m g * g * h", "have \"(g * g) dvdm f\""], ["proof (prove)\nusing this:\n  f =m g * g * h\n\ngoal (1 subgoal):\n 1. g * g dvdm f", "unfolding dvdm_def"], ["proof (prove)\nusing this:\n  f =m g * g * h\n\ngoal (1 subgoal):\n 1. \\<exists>h. f =m g * g * h", "by auto"], ["proof (state)\nthis:\n  g * g dvdm f\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q * q dvd f\\<rbrakk> \\<Longrightarrow> False", "with ndvd[of g]"], ["proof (chain)\npicking this:\n  0 < degree_m g \\<Longrightarrow> \\<not> g * g dvdm f\n  g * g dvdm f", "have deg0: \"degree_m g = 0\""], ["proof (prove)\nusing this:\n  0 < degree_m g \\<Longrightarrow> \\<not> g * g dvdm f\n  g * g dvdm f\n\ngoal (1 subgoal):\n 1. degree_m g = 0", "by auto"], ["proof (state)\nthis:\n  degree_m g = 0\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q * q dvd f\\<rbrakk> \\<Longrightarrow> False", "hence g0: \"M (lead_coeff g) = 0\""], ["proof (prove)\nusing this:\n  degree_m g = 0\n\ngoal (1 subgoal):\n 1. M (lead_coeff g) = 0", "unfolding Mp_def"], ["proof (prove)\nusing this:\n  degree (map_poly M g) = 0\n\ngoal (1 subgoal):\n 1. M (lead_coeff g) = 0", "using deg"], ["proof (prove)\nusing this:\n  degree (map_poly M g) = 0\n  0 < degree g\n\ngoal (1 subgoal):\n 1. M (lead_coeff g) = 0", "by (metis M_def deg0 p poly_mod.degree_m_eq prime_gt_1_int neq0_conv)"], ["proof (state)\nthis:\n  M (lead_coeff g) = 0\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q * q dvd f\\<rbrakk> \\<Longrightarrow> False", "from p"], ["proof (chain)\npicking this:\n  prime p", "have p0: \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q * q dvd f\\<rbrakk> \\<Longrightarrow> False", "from arg_cong[OF f, of lead_coeff]"], ["proof (chain)\npicking this:\n  lead_coeff f = lead_coeff (g * g * h)", "have \"lead_coeff f = lead_coeff g * lead_coeff g * lead_coeff h\""], ["proof (prove)\nusing this:\n  lead_coeff f = lead_coeff (g * g * h)\n\ngoal (1 subgoal):\n 1. lead_coeff f = lead_coeff g * lead_coeff g * lead_coeff h", "by (auto simp: lead_coeff_mult)"], ["proof (state)\nthis:\n  lead_coeff f = lead_coeff g * lead_coeff g * lead_coeff h\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q * q dvd f\\<rbrakk> \\<Longrightarrow> False", "hence \"lead_coeff g dvd lead_coeff f\""], ["proof (prove)\nusing this:\n  lead_coeff f = lead_coeff g * lead_coeff g * lead_coeff h\n\ngoal (1 subgoal):\n 1. lead_coeff g dvd lead_coeff f", "by auto"], ["proof (state)\nthis:\n  lead_coeff g dvd lead_coeff f\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q * q dvd f\\<rbrakk> \\<Longrightarrow> False", "with cop"], ["proof (chain)\npicking this:\n  comm_monoid_mult_class.coprime (lead_coeff f) p\n  lead_coeff g dvd lead_coeff f", "have cop: \"coprime (lead_coeff g) p\""], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (lead_coeff f) p\n  lead_coeff g dvd lead_coeff f\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff g) p", "by (auto elim: coprime_imp_coprime intro: dvd_trans)"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (lead_coeff g) p\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q * q dvd f\\<rbrakk> \\<Longrightarrow> False", "with p0"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  comm_monoid_mult_class.coprime (lead_coeff g) p", "have \"coprime (lead_coeff g mod p) p\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  comm_monoid_mult_class.coprime (lead_coeff g) p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff g mod p) p", "by simp"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (lead_coeff g mod p) p\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q * q dvd f\\<rbrakk> \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (lead_coeff g mod p) p\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q * q dvd f\\<rbrakk> \\<Longrightarrow> False", "have \"lead_coeff g mod p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff g mod p = 0", "using M_def g0"], ["proof (prove)\nusing this:\n  M ?x = ?x mod p\n  M (lead_coeff g) = 0\n\ngoal (1 subgoal):\n 1. lead_coeff g mod p = 0", "by simp"], ["proof (state)\nthis:\n  lead_coeff g mod p = 0\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q * q dvd f\\<rbrakk> \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  comm_monoid_mult_class.coprime 0 p", "show False"], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime 0 p\n\ngoal (1 subgoal):\n 1. False", "using p"], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime 0 p\n  prime p\n\ngoal (1 subgoal):\n 1. False", "unfolding prime_int_iff"], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime 0 p\n  1 < p \\<and>\n  (\\<forall>m. 0 \\<le> m \\<and> m dvd p \\<longrightarrow> m = 1 \\<or> m = p)\n\ngoal (1 subgoal):\n 1. False", "by (simp add: prime_int_iff)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  square_free f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma(in poly_mod_prime) separable_impl: \n  shows \"separable_impl p f \\<Longrightarrow> square_free_m f\"\n    \"nat p > degree_m f \\<Longrightarrow> nat p > separable_bound f \\<Longrightarrow> square_free f \n    \\<Longrightarrow> separable_impl p f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (separable_impl p f \\<Longrightarrow> square_free_m f) &&&\n    (\\<lbrakk>degree_m f < nat p; separable_bound f < int (nat p);\n      square_free f\\<rbrakk>\n     \\<Longrightarrow> separable_impl p f)", "using\n    separable_impl_integer[of f] \n    separable_impl_uint32[of f]\n    separable_impl_uint64[of f]"], ["proof (prove)\nusing this:\n  separable_impl_main p (finite_field_ops_integer (integer_of_int p))\n   f \\<Longrightarrow>\n  square_free_m f\n  \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n   square_free f\\<rbrakk>\n  \\<Longrightarrow> separable_impl_main p\n                     (finite_field_ops_integer (integer_of_int p)) f\n  \\<lbrakk>p \\<le> 65535;\n   separable_impl_main p (finite_field_ops32 (uint32_of_int p)) f\\<rbrakk>\n  \\<Longrightarrow> square_free_m f\n  \\<lbrakk>p \\<le> 65535; int (degree_m f) < p; separable_bound f < p;\n   square_free f\\<rbrakk>\n  \\<Longrightarrow> separable_impl_main p\n                     (finite_field_ops32 (uint32_of_int p)) f\n  \\<lbrakk>p \\<le> 4294967295;\n   separable_impl_main p (finite_field_ops64 (uint64_of_int p)) f\\<rbrakk>\n  \\<Longrightarrow> square_free_m f\n  \\<lbrakk>p \\<le> 4294967295; int (degree_m f) < p; separable_bound f < p;\n   square_free f\\<rbrakk>\n  \\<Longrightarrow> separable_impl_main p\n                     (finite_field_ops64 (uint64_of_int p)) f\n\ngoal (1 subgoal):\n 1. (separable_impl p f \\<Longrightarrow> square_free_m f) &&&\n    (\\<lbrakk>degree_m f < nat p; separable_bound f < int (nat p);\n      square_free f\\<rbrakk>\n     \\<Longrightarrow> separable_impl p f)", "unfolding separable_impl_def"], ["proof (prove)\nusing this:\n  separable_impl_main p (finite_field_ops_integer (integer_of_int p))\n   f \\<Longrightarrow>\n  square_free_m f\n  \\<lbrakk>int (degree_m f) < p; separable_bound f < p;\n   square_free f\\<rbrakk>\n  \\<Longrightarrow> separable_impl_main p\n                     (finite_field_ops_integer (integer_of_int p)) f\n  \\<lbrakk>p \\<le> 65535;\n   separable_impl_main p (finite_field_ops32 (uint32_of_int p)) f\\<rbrakk>\n  \\<Longrightarrow> square_free_m f\n  \\<lbrakk>p \\<le> 65535; int (degree_m f) < p; separable_bound f < p;\n   square_free f\\<rbrakk>\n  \\<Longrightarrow> separable_impl_main p\n                     (finite_field_ops32 (uint32_of_int p)) f\n  \\<lbrakk>p \\<le> 4294967295;\n   separable_impl_main p (finite_field_ops64 (uint64_of_int p)) f\\<rbrakk>\n  \\<Longrightarrow> square_free_m f\n  \\<lbrakk>p \\<le> 4294967295; int (degree_m f) < p; separable_bound f < p;\n   square_free f\\<rbrakk>\n  \\<Longrightarrow> separable_impl_main p\n                     (finite_field_ops64 (uint64_of_int p)) f\n\ngoal (1 subgoal):\n 1. ((if p \\<le> 65535\n      then separable_impl_main p (finite_field_ops32 (uint32_of_int p))\n      else if p \\<le> 4294967295\n           then separable_impl_main p (finite_field_ops64 (uint64_of_int p))\n           else separable_impl_main p\n                 (finite_field_ops_integer (integer_of_int p)))\n      f \\<Longrightarrow>\n     square_free_m f) &&&\n    (\\<lbrakk>degree_m f < nat p; separable_bound f < int (nat p);\n      square_free f\\<rbrakk>\n     \\<Longrightarrow> (if p \\<le> 65535\n                        then separable_impl_main p\n                              (finite_field_ops32 (uint32_of_int p))\n                        else if p \\<le> 4294967295\n                             then separable_impl_main p\n                                   (finite_field_ops64 (uint64_of_int p))\n                             else separable_impl_main p\n                                   (finite_field_ops_integer\n                                     (integer_of_int p)))\n                        f)", "by (auto split: if_splits)"], ["", "lemma coprime_lead_coeff_large_prime: assumes prime: \"prime (p :: int)\" \n  and large: \"p > abs (lead_coeff f)\" \n  and f: \"f \\<noteq> 0\" \n  shows \"coprime (lead_coeff f) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff f) p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff f) p", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff f) p", "fix lc"], ["proof (state)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff f) p", "assume \"0 < lc\" \"lc < p\""], ["proof (state)\nthis:\n  0 < lc\n  lc < p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff f) p", "then"], ["proof (chain)\npicking this:\n  0 < lc\n  lc < p", "have \"\\<not> p dvd lc\""], ["proof (prove)\nusing this:\n  0 < lc\n  lc < p\n\ngoal (1 subgoal):\n 1. \\<not> p dvd lc", "by (simp add: zdvd_not_zless)"], ["proof (state)\nthis:\n  \\<not> p dvd lc\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff f) p", "with \\<open>prime p\\<close>"], ["proof (chain)\npicking this:\n  prime p\n  \\<not> p dvd lc", "have \"coprime p lc\""], ["proof (prove)\nusing this:\n  prime p\n  \\<not> p dvd lc\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime p lc", "by (auto intro: prime_imp_coprime)"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime p lc\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff f) p", "then"], ["proof (chain)\npicking this:\n  comm_monoid_mult_class.coprime p lc", "have \"coprime lc p\""], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime p lc\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime lc p", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime lc p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff f) p", "}"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?lc2; ?lc2 < p\\<rbrakk>\n  \\<Longrightarrow> comm_monoid_mult_class.coprime ?lc2 p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff f) p", "note main = this"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?lc2; ?lc2 < p\\<rbrakk>\n  \\<Longrightarrow> comm_monoid_mult_class.coprime ?lc2 p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff f) p", "define lc where \"lc = lead_coeff f\""], ["proof (state)\nthis:\n  lc = lead_coeff f\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff f) p", "from f"], ["proof (chain)\npicking this:\n  f \\<noteq> 0", "have lc0: \"lc \\<noteq> 0\""], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lc \\<noteq> 0", "unfolding lc_def"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  lc \\<noteq> 0\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff f) p", "from large"], ["proof (chain)\npicking this:\n  \\<bar>lead_coeff f\\<bar> < p", "have large: \"p > abs lc\""], ["proof (prove)\nusing this:\n  \\<bar>lead_coeff f\\<bar> < p\n\ngoal (1 subgoal):\n 1. \\<bar>lc\\<bar> < p", "unfolding lc_def"], ["proof (prove)\nusing this:\n  \\<bar>lead_coeff f\\<bar> < p\n\ngoal (1 subgoal):\n 1. \\<bar>lead_coeff f\\<bar> < p", "by auto"], ["proof (state)\nthis:\n  \\<bar>lc\\<bar> < p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff f) p", "have \"coprime lc p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime lc p", "proof (cases \"lc > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < lc \\<Longrightarrow> comm_monoid_mult_class.coprime lc p\n 2. \\<not> 0 < lc \\<Longrightarrow> comm_monoid_mult_class.coprime lc p", "case True"], ["proof (state)\nthis:\n  0 < lc\n\ngoal (2 subgoals):\n 1. 0 < lc \\<Longrightarrow> comm_monoid_mult_class.coprime lc p\n 2. \\<not> 0 < lc \\<Longrightarrow> comm_monoid_mult_class.coprime lc p", "from large"], ["proof (chain)\npicking this:\n  \\<bar>lc\\<bar> < p", "have \"p > lc\""], ["proof (prove)\nusing this:\n  \\<bar>lc\\<bar> < p\n\ngoal (1 subgoal):\n 1. lc < p", "by auto"], ["proof (state)\nthis:\n  lc < p\n\ngoal (2 subgoals):\n 1. 0 < lc \\<Longrightarrow> comm_monoid_mult_class.coprime lc p\n 2. \\<not> 0 < lc \\<Longrightarrow> comm_monoid_mult_class.coprime lc p", "from main[OF True this]"], ["proof (chain)\npicking this:\n  comm_monoid_mult_class.coprime lc p", "show ?thesis"], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime lc p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime lc p", "."], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime lc p\n\ngoal (1 subgoal):\n 1. \\<not> 0 < lc \\<Longrightarrow> comm_monoid_mult_class.coprime lc p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < lc \\<Longrightarrow> comm_monoid_mult_class.coprime lc p", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < lc\n\ngoal (1 subgoal):\n 1. \\<not> 0 < lc \\<Longrightarrow> comm_monoid_mult_class.coprime lc p", "let ?mlc = \"- lc\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < lc \\<Longrightarrow> comm_monoid_mult_class.coprime lc p", "from large False lc0"], ["proof (chain)\npicking this:\n  \\<bar>lc\\<bar> < p\n  \\<not> 0 < lc\n  lc \\<noteq> 0", "have \"?mlc > 0\" \"p > ?mlc\""], ["proof (prove)\nusing this:\n  \\<bar>lc\\<bar> < p\n  \\<not> 0 < lc\n  lc \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < - lc &&& - lc < p", "by auto"], ["proof (state)\nthis:\n  0 < - lc\n  - lc < p\n\ngoal (1 subgoal):\n 1. \\<not> 0 < lc \\<Longrightarrow> comm_monoid_mult_class.coprime lc p", "from main[OF this]"], ["proof (chain)\npicking this:\n  comm_monoid_mult_class.coprime (- lc) p", "show ?thesis"], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (- lc) p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime lc p", "by simp"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime lc p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime lc p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff f) p", "thus ?thesis"], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime lc p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff f) p", "unfolding lc_def"], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (lead_coeff f) p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff f) p", "by auto"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (lead_coeff f) p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prime_for_berlekamp_zassenhaus_exists: assumes sf: \"square_free f\" \n  shows \"\\<exists> p. prime p \\<and> (coprime (lead_coeff f) p \\<and> separable_impl p f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       prime p \\<and>\n       comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n       separable_impl p f", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>p.\n       prime p \\<and>\n       comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n       separable_impl p f \\<Longrightarrow>\n    False", "from assms"], ["proof (chain)\npicking this:\n  square_free f", "have f0: \"f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  square_free f\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "unfolding square_free_def"], ["proof (prove)\nusing this:\n  f \\<noteq> 0 \\<and>\n  (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd f)\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<nexists>p.\n       prime p \\<and>\n       comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n       separable_impl p f \\<Longrightarrow>\n    False", "define n where \"n = max (max (abs (lead_coeff f)) (degree f)) (separable_bound f)\""], ["proof (state)\nthis:\n  n =\n  max (max \\<bar>lead_coeff f\\<bar> (int (degree f))) (separable_bound f)\n\ngoal (1 subgoal):\n 1. \\<nexists>p.\n       prime p \\<and>\n       comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n       separable_impl p f \\<Longrightarrow>\n    False", "assume contr: \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<nexists>p.\n     prime p \\<and>\n     comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n     separable_impl p f\n\ngoal (1 subgoal):\n 1. \\<nexists>p.\n       prime p \\<and>\n       comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n       separable_impl p f \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  \\<nexists>p.\n     prime p \\<and>\n     comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n     separable_impl p f\n\ngoal (1 subgoal):\n 1. \\<nexists>p.\n       prime p \\<and>\n       comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n       separable_impl p f \\<Longrightarrow>\n    False", "fix p :: int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>p.\n       prime p \\<and>\n       comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n       separable_impl p f \\<Longrightarrow>\n    False", "assume prime: \"prime p\" and n: \"p > n\""], ["proof (state)\nthis:\n  prime p\n  n < p\n\ngoal (1 subgoal):\n 1. \\<nexists>p.\n       prime p \\<and>\n       comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n       separable_impl p f \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  prime p\n  n < p", "interpret poly_mod_prime p"], ["proof (prove)\nusing this:\n  prime p\n  n < p\n\ngoal (1 subgoal):\n 1. poly_mod_prime p", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>p.\n       prime p \\<and>\n       comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n       separable_impl p f \\<Longrightarrow>\n    False", "from n"], ["proof (chain)\npicking this:\n  n < p", "have large: \"p > abs (lead_coeff f)\" \"nat p > degree f\" \"nat p > separable_bound f\""], ["proof (prove)\nusing this:\n  n < p\n\ngoal (1 subgoal):\n 1. \\<bar>lead_coeff f\\<bar> < p &&&\n    degree f < nat p &&& separable_bound f < int (nat p)", "unfolding n_def"], ["proof (prove)\nusing this:\n  max (max \\<bar>lead_coeff f\\<bar> (int (degree f))) (separable_bound f)\n  < p\n\ngoal (1 subgoal):\n 1. \\<bar>lead_coeff f\\<bar> < p &&&\n    degree f < nat p &&& separable_bound f < int (nat p)", "by auto"], ["proof (state)\nthis:\n  \\<bar>lead_coeff f\\<bar> < p\n  degree f < nat p\n  separable_bound f < int (nat p)\n\ngoal (1 subgoal):\n 1. \\<nexists>p.\n       prime p \\<and>\n       comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n       separable_impl p f \\<Longrightarrow>\n    False", "from coprime_lead_coeff_large_prime[OF prime large(1) f0]"], ["proof (chain)\npicking this:\n  comm_monoid_mult_class.coprime (lead_coeff f) p", "have cop: \"coprime (lead_coeff f) p\""], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime (lead_coeff f) p\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff f) p", "by auto"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (lead_coeff f) p\n\ngoal (1 subgoal):\n 1. \\<nexists>p.\n       prime p \\<and>\n       comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n       separable_impl p f \\<Longrightarrow>\n    False", "with prime contr"], ["proof (chain)\npicking this:\n  prime p\n  \\<nexists>p.\n     prime p \\<and>\n     comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n     separable_impl p f\n  comm_monoid_mult_class.coprime (lead_coeff f) p", "have nsf: \"\\<not> separable_impl p f\""], ["proof (prove)\nusing this:\n  prime p\n  \\<nexists>p.\n     prime p \\<and>\n     comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n     separable_impl p f\n  comm_monoid_mult_class.coprime (lead_coeff f) p\n\ngoal (1 subgoal):\n 1. \\<not> separable_impl p f", "by auto"], ["proof (state)\nthis:\n  \\<not> separable_impl p f\n\ngoal (1 subgoal):\n 1. \\<nexists>p.\n       prime p \\<and>\n       comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n       separable_impl p f \\<Longrightarrow>\n    False", "from large(2)"], ["proof (chain)\npicking this:\n  degree f < nat p", "have \"nat p > degree_m f\""], ["proof (prove)\nusing this:\n  degree f < nat p\n\ngoal (1 subgoal):\n 1. degree_m f < nat p", "using degree_m_le[of f]"], ["proof (prove)\nusing this:\n  degree f < nat p\n  degree_m f \\<le> degree f\n\ngoal (1 subgoal):\n 1. degree_m f < nat p", "by auto"], ["proof (state)\nthis:\n  degree_m f < nat p\n\ngoal (1 subgoal):\n 1. \\<nexists>p.\n       prime p \\<and>\n       comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n       separable_impl p f \\<Longrightarrow>\n    False", "from separable_impl(2)[OF this large(3) sf] nsf"], ["proof (chain)\npicking this:\n  separable_impl p f\n  \\<not> separable_impl p f", "have False"], ["proof (prove)\nusing this:\n  separable_impl p f\n  \\<not> separable_impl p f\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<nexists>p.\n       prime p \\<and>\n       comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n       separable_impl p f \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  \\<lbrakk>prime ?p2; n < ?p2\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<nexists>p.\n       prime p \\<and>\n       comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n       separable_impl p f \\<Longrightarrow>\n    False", "hence no_large_prime: \"\\<And> p. prime p \\<Longrightarrow> p > n \\<Longrightarrow> False\""], ["proof (prove)\nusing this:\n  \\<lbrakk>prime ?p2; n < ?p2\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>p. \\<lbrakk>prime p; n < p\\<rbrakk> \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>prime ?p; n < ?p\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<nexists>p.\n       prime p \\<and>\n       comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n       separable_impl p f \\<Longrightarrow>\n    False", "from bigger_prime[of \"nat n\"]"], ["proof (chain)\npicking this:\n  \\<exists>p. prime p \\<and> nat n < p", "obtain p where *: \"prime p\" \"p > nat n\""], ["proof (prove)\nusing this:\n  \\<exists>p. prime p \\<and> nat n < p\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>prime p; nat n < p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  prime p\n  nat n < p\n\ngoal (1 subgoal):\n 1. \\<nexists>p.\n       prime p \\<and>\n       comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n       separable_impl p f \\<Longrightarrow>\n    False", "define q where \"q \\<equiv> int p\""], ["proof (state)\nthis:\n  q \\<equiv> int p\n\ngoal (1 subgoal):\n 1. \\<nexists>p.\n       prime p \\<and>\n       comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n       separable_impl p f \\<Longrightarrow>\n    False", "from *"], ["proof (chain)\npicking this:\n  prime p\n  nat n < p", "have \"prime q\" \"q > n\""], ["proof (prove)\nusing this:\n  prime p\n  nat n < p\n\ngoal (1 subgoal):\n 1. prime q &&& n < q", "unfolding q_def"], ["proof (prove)\nusing this:\n  prime p\n  nat n < p\n\ngoal (1 subgoal):\n 1. prime (int p) &&& n < int p", "by auto"], ["proof (state)\nthis:\n  prime q\n  n < q\n\ngoal (1 subgoal):\n 1. \\<nexists>p.\n       prime p \\<and>\n       comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n       separable_impl p f \\<Longrightarrow>\n    False", "from no_large_prime[OF this]"], ["proof (chain)\npicking this:\n  False", "show False"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "definition next_primes :: \"nat \\<Rightarrow> nat \\<times> nat list\" where\n  \"next_primes n = (if n = 0 then next_candidates 0 else \n    let (m,ps) = next_candidates n in (m,filter prime ps))\""], ["", "partial_function (tailrec) find_prime_main :: \n  \"(nat \\<Rightarrow> bool) \\<Rightarrow> nat \\<Rightarrow> nat list \\<Rightarrow> nat\" where\n  [code]: \"find_prime_main f np ps = (case ps of [] \\<Rightarrow> \n    let (np',ps') = next_primes np\n      in find_prime_main f np' ps'\n    | (p # ps) \\<Rightarrow> if f p then p else find_prime_main f np ps)\""], ["", "definition find_prime :: \"(nat \\<Rightarrow> bool) \\<Rightarrow> nat\" where\n  \"find_prime f = find_prime_main f 0 []\""], ["", "lemma next_primes: assumes res: \"next_primes n = (m,ps)\"\n  and n: \"candidate_invariant n\"\n  shows \"candidate_invariant m\" \"sorted ps\" \"distinct ps\" \"n < m\" \n  \"set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (candidate_invariant m &&& sorted ps) &&&\n    distinct ps &&&\n    n < m &&& set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}", "proof -"], ["proof (state)\ngoal (5 subgoals):\n 1. candidate_invariant m\n 2. sorted ps\n 3. distinct ps\n 4. n < m\n 5. set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}", "have \"candidate_invariant m \\<and> sorted ps \\<and> distinct ps \\<and> n < m \\<and>\n    set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. candidate_invariant m \\<and>\n    sorted ps \\<and>\n    distinct ps \\<and>\n    n < m \\<and> set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    candidate_invariant m \\<and>\n    sorted ps \\<and>\n    distinct ps \\<and>\n    n < m \\<and> set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    candidate_invariant m \\<and>\n    sorted ps \\<and>\n    distinct ps \\<and>\n    n < m \\<and> set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    candidate_invariant m \\<and>\n    sorted ps \\<and>\n    distinct ps \\<and>\n    n < m \\<and> set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    candidate_invariant m \\<and>\n    sorted ps \\<and>\n    distinct ps \\<and>\n    n < m \\<and> set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}", "with res[unfolded next_primes_def]"], ["proof (chain)\npicking this:\n  (if n = 0 then next_candidates 0\n   else let (m, ps) = next_candidates n in (m, filter prime ps)) =\n  (m, ps)\n  n = 0", "have nc: \"next_candidates 0 = (m,ps)\""], ["proof (prove)\nusing this:\n  (if n = 0 then next_candidates 0\n   else let (m, ps) = next_candidates n in (m, filter prime ps)) =\n  (m, ps)\n  n = 0\n\ngoal (1 subgoal):\n 1. next_candidates 0 = (m, ps)", "by auto"], ["proof (state)\nthis:\n  next_candidates 0 = (m, ps)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    candidate_invariant m \\<and>\n    sorted ps \\<and>\n    distinct ps \\<and>\n    n < m \\<and> set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    candidate_invariant m \\<and>\n    sorted ps \\<and>\n    distinct ps \\<and>\n    n < m \\<and> set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}", "from this[unfolded next_candidates_def]"], ["proof (chain)\npicking this:\n  (if 0 = 0 then (1001, primes_1000)\n   else (0 + 30,\n         [0, 0 + 2, 0 + 6, 0 + 8, 0 + 12, 0 + 18, 0 + 20, 0 + 26])) =\n  (m, ps)", "have ps: \"ps = primes_1000\" and m: \"m = 1001\""], ["proof (prove)\nusing this:\n  (if 0 = 0 then (1001, primes_1000)\n   else (0 + 30,\n         [0, 0 + 2, 0 + 6, 0 + 8, 0 + 12, 0 + 18, 0 + 20, 0 + 26])) =\n  (m, ps)\n\ngoal (1 subgoal):\n 1. ps = primes_1000 &&& m = 1001", "by auto"], ["proof (state)\nthis:\n  ps = primes_1000\n  m = 1001\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    candidate_invariant m \\<and>\n    sorted ps \\<and>\n    distinct ps \\<and>\n    n < m \\<and> set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    candidate_invariant m \\<and>\n    sorted ps \\<and>\n    distinct ps \\<and>\n    n < m \\<and> set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}", "have ps: \"set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}", "unfolding m True ps"], ["proof (prove)\ngoal (1 subgoal):\n 1. set primes_1000 = {i. prime i \\<and> 0 \\<le> i \\<and> i < 1001}", "by (auto simp: primes_1000)"], ["proof (state)\nthis:\n  set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    candidate_invariant m \\<and>\n    sorted ps \\<and>\n    distinct ps \\<and>\n    n < m \\<and> set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    candidate_invariant m \\<and>\n    sorted ps \\<and>\n    distinct ps \\<and>\n    n < m \\<and> set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}", "with next_candidates[OF nc n[unfolded True]] True"], ["proof (chain)\npicking this:\n  candidate_invariant m\n  sorted ps\n  {i. prime i \\<and> 0 \\<le> i \\<and> i < m} \\<subseteq> set ps\n  set ps \\<subseteq> {2..} \\<inter> {0..<m}\n  distinct ps\n  ps \\<noteq> []\n  0 < m\n  n = 0\n  set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}", "show ?thesis"], ["proof (prove)\nusing this:\n  candidate_invariant m\n  sorted ps\n  {i. prime i \\<and> 0 \\<le> i \\<and> i < m} \\<subseteq> set ps\n  set ps \\<subseteq> {2..} \\<inter> {0..<m}\n  distinct ps\n  ps \\<noteq> []\n  0 < m\n  n = 0\n  set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}\n\ngoal (1 subgoal):\n 1. candidate_invariant m \\<and>\n    sorted ps \\<and>\n    distinct ps \\<and>\n    n < m \\<and> set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}", "by simp"], ["proof (state)\nthis:\n  candidate_invariant m \\<and>\n  sorted ps \\<and>\n  distinct ps \\<and>\n  n < m \\<and> set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    candidate_invariant m \\<and>\n    sorted ps \\<and>\n    distinct ps \\<and>\n    n < m \\<and> set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    candidate_invariant m \\<and>\n    sorted ps \\<and>\n    distinct ps \\<and>\n    n < m \\<and> set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    candidate_invariant m \\<and>\n    sorted ps \\<and>\n    distinct ps \\<and>\n    n < m \\<and> set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}", "with res[unfolded next_primes_def Let_def]"], ["proof (chain)\npicking this:\n  (if n = 0 then next_candidates 0\n   else case next_candidates n of\n        (m, ps) \\<Rightarrow> (m, filter prime ps)) =\n  (m, ps)\n  n \\<noteq> 0", "obtain qs where nc: \"next_candidates n = (m, qs)\"\n      and ps: \"ps = filter prime qs\""], ["proof (prove)\nusing this:\n  (if n = 0 then next_candidates 0\n   else case next_candidates n of\n        (m, ps) \\<Rightarrow> (m, filter prime ps)) =\n  (m, ps)\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>next_candidates n = (m, qs); ps = filter prime qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"next_candidates n\", auto)"], ["proof (state)\nthis:\n  next_candidates n = (m, qs)\n  ps = filter prime qs\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    candidate_invariant m \\<and>\n    sorted ps \\<and>\n    distinct ps \\<and>\n    n < m \\<and> set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}", "have \"sorted qs \\<Longrightarrow> sorted ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted qs \\<Longrightarrow> sorted ps", "unfolding ps"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted qs \\<Longrightarrow> sorted (filter prime qs)", "using sorted_filter[of id qs prime]"], ["proof (prove)\nusing this:\n  sorted (map id qs) \\<Longrightarrow> sorted (map id (filter prime qs))\n\ngoal (1 subgoal):\n 1. sorted qs \\<Longrightarrow> sorted (filter prime qs)", "by auto"], ["proof (state)\nthis:\n  sorted qs \\<Longrightarrow> sorted ps\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    candidate_invariant m \\<and>\n    sorted ps \\<and>\n    distinct ps \\<and>\n    n < m \\<and> set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}", "with next_candidates[OF nc n]"], ["proof (chain)\npicking this:\n  candidate_invariant m\n  sorted qs\n  {i. prime i \\<and> n \\<le> i \\<and> i < m} \\<subseteq> set qs\n  set qs \\<subseteq> {2..} \\<inter> {n..<m}\n  distinct qs\n  qs \\<noteq> []\n  n < m\n  sorted qs \\<Longrightarrow> sorted ps", "show ?thesis"], ["proof (prove)\nusing this:\n  candidate_invariant m\n  sorted qs\n  {i. prime i \\<and> n \\<le> i \\<and> i < m} \\<subseteq> set qs\n  set qs \\<subseteq> {2..} \\<inter> {n..<m}\n  distinct qs\n  qs \\<noteq> []\n  n < m\n  sorted qs \\<Longrightarrow> sorted ps\n\ngoal (1 subgoal):\n 1. candidate_invariant m \\<and>\n    sorted ps \\<and>\n    distinct ps \\<and>\n    n < m \\<and> set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}", "unfolding ps"], ["proof (prove)\nusing this:\n  candidate_invariant m\n  sorted qs\n  {i. prime i \\<and> n \\<le> i \\<and> i < m} \\<subseteq> set qs\n  set qs \\<subseteq> {2..} \\<inter> {n..<m}\n  distinct qs\n  qs \\<noteq> []\n  n < m\n  sorted qs \\<Longrightarrow> sorted (filter prime qs)\n\ngoal (1 subgoal):\n 1. candidate_invariant m \\<and>\n    sorted (filter prime qs) \\<and>\n    distinct (filter prime qs) \\<and>\n    n < m \\<and>\n    set (filter prime qs) = {i. prime i \\<and> n \\<le> i \\<and> i < m}", "by auto"], ["proof (state)\nthis:\n  candidate_invariant m \\<and>\n  sorted ps \\<and>\n  distinct ps \\<and>\n  n < m \\<and> set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  candidate_invariant m \\<and>\n  sorted ps \\<and>\n  distinct ps \\<and>\n  n < m \\<and> set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}\n\ngoal (5 subgoals):\n 1. candidate_invariant m\n 2. sorted ps\n 3. distinct ps\n 4. n < m\n 5. set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}", "thus \"candidate_invariant m\" \"sorted ps\" \"distinct ps\" \"n < m\" \n    \"set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}\""], ["proof (prove)\nusing this:\n  candidate_invariant m \\<and>\n  sorted ps \\<and>\n  distinct ps \\<and>\n  n < m \\<and> set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}\n\ngoal (1 subgoal):\n 1. (candidate_invariant m &&& sorted ps) &&&\n    distinct ps &&&\n    n < m &&& set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}", "by auto"], ["proof (state)\nthis:\n  candidate_invariant m\n  sorted ps\n  distinct ps\n  n < m\n  set ps = {i. prime i \\<and> n \\<le> i \\<and> i < m}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_prime: assumes \"\\<exists> n. prime n \\<and> f n\"\n  shows \"prime (find_prime f) \\<and> f (find_prime f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime (find_prime f) \\<and> f (find_prime f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prime (find_prime f) \\<and> f (find_prime f)", "from assms"], ["proof (chain)\npicking this:\n  \\<exists>n. prime n \\<and> f n", "obtain n where fn: \"prime n\" \"f n\""], ["proof (prove)\nusing this:\n  \\<exists>n. prime n \\<and> f n\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>prime n; f n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  prime n\n  f n\n\ngoal (1 subgoal):\n 1. prime (find_prime f) \\<and> f (find_prime f)", "{"], ["proof (state)\nthis:\n  prime n\n  f n\n\ngoal (1 subgoal):\n 1. prime (find_prime f) \\<and> f (find_prime f)", "fix i ps m"], ["proof (state)\ngoal (1 subgoal):\n 1. prime (find_prime f) \\<and> f (find_prime f)", "assume \"candidate_invariant i\" \n      and \"n \\<in> set ps \\<or> n \\<ge> i\"\n      and \"m = (Suc n - i, length ps)\"\n      and \"\\<And> p. p \\<in> set ps \\<Longrightarrow> prime p\""], ["proof (state)\nthis:\n  candidate_invariant i\n  n \\<in> set ps \\<or> i \\<le> n\n  m = (Suc n - i, length ps)\n  ?p \\<in> set ps \\<Longrightarrow> prime ?p\n\ngoal (1 subgoal):\n 1. prime (find_prime f) \\<and> f (find_prime f)", "hence \"prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)\""], ["proof (prove)\nusing this:\n  candidate_invariant i\n  n \\<in> set ps \\<or> i \\<le> n\n  m = (Suc n - i, length ps)\n  ?p \\<in> set ps \\<Longrightarrow> prime ?p\n\ngoal (1 subgoal):\n 1. prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)", "proof (induct m arbitrary: i ps rule: wf_induct[OF wf_measures[of \"[fst, snd]\"]])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x i ps.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measures [fst, snd] \\<longrightarrow>\n                   (\\<forall>x.\n                       candidate_invariant x \\<longrightarrow>\n                       (\\<forall>xa.\n                           n \\<in> set xa \\<or> x \\<le> n \\<longrightarrow>\n                           y = (Suc n - x, length xa) \\<longrightarrow>\n                           (\\<forall>x.\n                               x \\<in> set xa \\<longrightarrow>\n                               prime x) \\<longrightarrow>\n                           prime (find_prime_main f x xa) \\<and>\n                           f (find_prime_main f x xa)));\n        candidate_invariant i; n \\<in> set ps \\<or> i \\<le> n;\n        x = (Suc n - i, length ps);\n        \\<And>p. p \\<in> set ps \\<Longrightarrow> prime p\\<rbrakk>\n       \\<Longrightarrow> prime (find_prime_main f i ps) \\<and>\n                         f (find_prime_main f i ps)", "case (1 m i ps)"], ["proof (state)\nthis:\n  \\<forall>y.\n     (y, m) \\<in> measures [fst, snd] \\<longrightarrow>\n     (\\<forall>x.\n         candidate_invariant x \\<longrightarrow>\n         (\\<forall>xa.\n             n \\<in> set xa \\<or> x \\<le> n \\<longrightarrow>\n             y = (Suc n - x, length xa) \\<longrightarrow>\n             (\\<forall>x.\n                 x \\<in> set xa \\<longrightarrow> prime x) \\<longrightarrow>\n             prime (find_prime_main f x xa) \\<and>\n             f (find_prime_main f x xa)))\n  candidate_invariant i\n  n \\<in> set ps \\<or> i \\<le> n\n  m = (Suc n - i, length ps)\n  ?p \\<in> set ps \\<Longrightarrow> prime ?p\n\ngoal (1 subgoal):\n 1. \\<And>x i ps.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measures [fst, snd] \\<longrightarrow>\n                   (\\<forall>x.\n                       candidate_invariant x \\<longrightarrow>\n                       (\\<forall>xa.\n                           n \\<in> set xa \\<or> x \\<le> n \\<longrightarrow>\n                           y = (Suc n - x, length xa) \\<longrightarrow>\n                           (\\<forall>x.\n                               x \\<in> set xa \\<longrightarrow>\n                               prime x) \\<longrightarrow>\n                           prime (find_prime_main f x xa) \\<and>\n                           f (find_prime_main f x xa)));\n        candidate_invariant i; n \\<in> set ps \\<or> i \\<le> n;\n        x = (Suc n - i, length ps);\n        \\<And>p. p \\<in> set ps \\<Longrightarrow> prime p\\<rbrakk>\n       \\<Longrightarrow> prime (find_prime_main f i ps) \\<and>\n                         f (find_prime_main f i ps)", "note IH = 1(1)[rule_format]"], ["proof (state)\nthis:\n  \\<lbrakk>(?y, m) \\<in> measures [fst, snd]; candidate_invariant ?x;\n   n \\<in> set ?xa \\<or> ?x \\<le> n; ?y = (Suc n - ?x, length ?xa);\n   \\<And>x. x \\<in> set ?xa \\<Longrightarrow> prime x\\<rbrakk>\n  \\<Longrightarrow> prime (find_prime_main f ?x ?xa) \\<and>\n                    f (find_prime_main f ?x ?xa)\n\ngoal (1 subgoal):\n 1. \\<And>x i ps.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measures [fst, snd] \\<longrightarrow>\n                   (\\<forall>x.\n                       candidate_invariant x \\<longrightarrow>\n                       (\\<forall>xa.\n                           n \\<in> set xa \\<or> x \\<le> n \\<longrightarrow>\n                           y = (Suc n - x, length xa) \\<longrightarrow>\n                           (\\<forall>x.\n                               x \\<in> set xa \\<longrightarrow>\n                               prime x) \\<longrightarrow>\n                           prime (find_prime_main f x xa) \\<and>\n                           f (find_prime_main f x xa)));\n        candidate_invariant i; n \\<in> set ps \\<or> i \\<le> n;\n        x = (Suc n - i, length ps);\n        \\<And>p. p \\<in> set ps \\<Longrightarrow> prime p\\<rbrakk>\n       \\<Longrightarrow> prime (find_prime_main f i ps) \\<and>\n                         f (find_prime_main f i ps)", "note can = 1(2)"], ["proof (state)\nthis:\n  candidate_invariant i\n\ngoal (1 subgoal):\n 1. \\<And>x i ps.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measures [fst, snd] \\<longrightarrow>\n                   (\\<forall>x.\n                       candidate_invariant x \\<longrightarrow>\n                       (\\<forall>xa.\n                           n \\<in> set xa \\<or> x \\<le> n \\<longrightarrow>\n                           y = (Suc n - x, length xa) \\<longrightarrow>\n                           (\\<forall>x.\n                               x \\<in> set xa \\<longrightarrow>\n                               prime x) \\<longrightarrow>\n                           prime (find_prime_main f x xa) \\<and>\n                           f (find_prime_main f x xa)));\n        candidate_invariant i; n \\<in> set ps \\<or> i \\<le> n;\n        x = (Suc n - i, length ps);\n        \\<And>p. p \\<in> set ps \\<Longrightarrow> prime p\\<rbrakk>\n       \\<Longrightarrow> prime (find_prime_main f i ps) \\<and>\n                         f (find_prime_main f i ps)", "note n = 1(3)"], ["proof (state)\nthis:\n  n \\<in> set ps \\<or> i \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>x i ps.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measures [fst, snd] \\<longrightarrow>\n                   (\\<forall>x.\n                       candidate_invariant x \\<longrightarrow>\n                       (\\<forall>xa.\n                           n \\<in> set xa \\<or> x \\<le> n \\<longrightarrow>\n                           y = (Suc n - x, length xa) \\<longrightarrow>\n                           (\\<forall>x.\n                               x \\<in> set xa \\<longrightarrow>\n                               prime x) \\<longrightarrow>\n                           prime (find_prime_main f x xa) \\<and>\n                           f (find_prime_main f x xa)));\n        candidate_invariant i; n \\<in> set ps \\<or> i \\<le> n;\n        x = (Suc n - i, length ps);\n        \\<And>p. p \\<in> set ps \\<Longrightarrow> prime p\\<rbrakk>\n       \\<Longrightarrow> prime (find_prime_main f i ps) \\<and>\n                         f (find_prime_main f i ps)", "note m = 1(4)"], ["proof (state)\nthis:\n  m = (Suc n - i, length ps)\n\ngoal (1 subgoal):\n 1. \\<And>x i ps.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measures [fst, snd] \\<longrightarrow>\n                   (\\<forall>x.\n                       candidate_invariant x \\<longrightarrow>\n                       (\\<forall>xa.\n                           n \\<in> set xa \\<or> x \\<le> n \\<longrightarrow>\n                           y = (Suc n - x, length xa) \\<longrightarrow>\n                           (\\<forall>x.\n                               x \\<in> set xa \\<longrightarrow>\n                               prime x) \\<longrightarrow>\n                           prime (find_prime_main f x xa) \\<and>\n                           f (find_prime_main f x xa)));\n        candidate_invariant i; n \\<in> set ps \\<or> i \\<le> n;\n        x = (Suc n - i, length ps);\n        \\<And>p. p \\<in> set ps \\<Longrightarrow> prime p\\<rbrakk>\n       \\<Longrightarrow> prime (find_prime_main f i ps) \\<and>\n                         f (find_prime_main f i ps)", "note ps = 1(5)"], ["proof (state)\nthis:\n  ?p \\<in> set ps \\<Longrightarrow> prime ?p\n\ngoal (1 subgoal):\n 1. \\<And>x i ps.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measures [fst, snd] \\<longrightarrow>\n                   (\\<forall>x.\n                       candidate_invariant x \\<longrightarrow>\n                       (\\<forall>xa.\n                           n \\<in> set xa \\<or> x \\<le> n \\<longrightarrow>\n                           y = (Suc n - x, length xa) \\<longrightarrow>\n                           (\\<forall>x.\n                               x \\<in> set xa \\<longrightarrow>\n                               prime x) \\<longrightarrow>\n                           prime (find_prime_main f x xa) \\<and>\n                           f (find_prime_main f x xa)));\n        candidate_invariant i; n \\<in> set ps \\<or> i \\<le> n;\n        x = (Suc n - i, length ps);\n        \\<And>p. p \\<in> set ps \\<Longrightarrow> prime p\\<rbrakk>\n       \\<Longrightarrow> prime (find_prime_main f i ps) \\<and>\n                         f (find_prime_main f i ps)", "note simps [simp] = find_prime_main.simps[of f i ps]"], ["proof (state)\nthis:\n  find_prime_main f i ps =\n  (case ps of\n   [] \\<Rightarrow>\n     let (np', ps') = next_primes i in find_prime_main f np' ps'\n   | p # ps \\<Rightarrow> if f p then p else find_prime_main f i ps)\n\ngoal (1 subgoal):\n 1. \\<And>x i ps.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measures [fst, snd] \\<longrightarrow>\n                   (\\<forall>x.\n                       candidate_invariant x \\<longrightarrow>\n                       (\\<forall>xa.\n                           n \\<in> set xa \\<or> x \\<le> n \\<longrightarrow>\n                           y = (Suc n - x, length xa) \\<longrightarrow>\n                           (\\<forall>x.\n                               x \\<in> set xa \\<longrightarrow>\n                               prime x) \\<longrightarrow>\n                           prime (find_prime_main f x xa) \\<and>\n                           f (find_prime_main f x xa)));\n        candidate_invariant i; n \\<in> set ps \\<or> i \\<le> n;\n        x = (Suc n - i, length ps);\n        \\<And>p. p \\<in> set ps \\<Longrightarrow> prime p\\<rbrakk>\n       \\<Longrightarrow> prime (find_prime_main f i ps) \\<and>\n                         f (find_prime_main f i ps)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)", "proof (cases ps)"], ["proof (state)\ngoal (2 subgoals):\n 1. ps = [] \\<Longrightarrow>\n    prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)\n 2. \\<And>a list.\n       ps = a # list \\<Longrightarrow>\n       prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)", "case Nil"], ["proof (state)\nthis:\n  ps = []\n\ngoal (2 subgoals):\n 1. ps = [] \\<Longrightarrow>\n    prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)\n 2. \\<And>a list.\n       ps = a # list \\<Longrightarrow>\n       prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)", "with n"], ["proof (chain)\npicking this:\n  n \\<in> set ps \\<or> i \\<le> n\n  ps = []", "have i_n: \"i \\<le> n\""], ["proof (prove)\nusing this:\n  n \\<in> set ps \\<or> i \\<le> n\n  ps = []\n\ngoal (1 subgoal):\n 1. i \\<le> n", "by auto"], ["proof (state)\nthis:\n  i \\<le> n\n\ngoal (2 subgoals):\n 1. ps = [] \\<Longrightarrow>\n    prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)\n 2. \\<And>a list.\n       ps = a # list \\<Longrightarrow>\n       prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)", "obtain j qs where np: \"next_primes i = (j,qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j qs.\n        next_primes i = (j, qs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  next_primes i = (j, qs)\n\ngoal (2 subgoals):\n 1. ps = [] \\<Longrightarrow>\n    prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)\n 2. \\<And>a list.\n       ps = a # list \\<Longrightarrow>\n       prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)", "note j = next_primes[OF np can]"], ["proof (state)\nthis:\n  candidate_invariant j\n  sorted qs\n  distinct qs\n  i < j\n  set qs = {i. prime i \\<and> i \\<le> i \\<and> i < j}\n\ngoal (2 subgoals):\n 1. ps = [] \\<Longrightarrow>\n    prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)\n 2. \\<And>a list.\n       ps = a # list \\<Longrightarrow>\n       prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)", "from j(4) i_n m"], ["proof (chain)\npicking this:\n  i < j\n  i \\<le> n\n  m = (Suc n - i, length ps)", "have meas: \"((Suc n - j, length qs), m) \\<in> measures [fst, snd]\""], ["proof (prove)\nusing this:\n  i < j\n  i \\<le> n\n  m = (Suc n - i, length ps)\n\ngoal (1 subgoal):\n 1. ((Suc n - j, length qs), m) \\<in> measures [fst, snd]", "by auto"], ["proof (state)\nthis:\n  ((Suc n - j, length qs), m) \\<in> measures [fst, snd]\n\ngoal (2 subgoals):\n 1. ps = [] \\<Longrightarrow>\n    prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)\n 2. \\<And>a list.\n       ps = a # list \\<Longrightarrow>\n       prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)", "have n: \"n \\<in> set qs \\<or> j \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> set qs \\<or> j \\<le> n", "unfolding j(5)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> {i. prime i \\<and> i \\<le> i \\<and> i < j} \\<or> j \\<le> n", "using i_n fn"], ["proof (prove)\nusing this:\n  i \\<le> n\n  prime n\n  f n\n\ngoal (1 subgoal):\n 1. n \\<in> {i. prime i \\<and> i \\<le> i \\<and> i < j} \\<or> j \\<le> n", "by auto"], ["proof (state)\nthis:\n  n \\<in> set qs \\<or> j \\<le> n\n\ngoal (2 subgoals):\n 1. ps = [] \\<Longrightarrow>\n    prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)\n 2. \\<And>a list.\n       ps = a # list \\<Longrightarrow>\n       prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)", "unfolding simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. prime\n     (case ps of\n      [] \\<Rightarrow> let (x, y) = next_primes i in find_prime_main f x y\n      | p # ps \\<Rightarrow>\n          if f p then p else find_prime_main f i ps) \\<and>\n    f (case ps of\n       [] \\<Rightarrow> let (x, y) = next_primes i in find_prime_main f x y\n       | p # ps \\<Rightarrow> if f p then p else find_prime_main f i ps)", "using IH[OF meas j(1) n refl] j(5)"], ["proof (prove)\nusing this:\n  (\\<And>x. x \\<in> set qs \\<Longrightarrow> prime x) \\<Longrightarrow>\n  prime (find_prime_main f j qs) \\<and> f (find_prime_main f j qs)\n  set qs = {i. prime i \\<and> i \\<le> i \\<and> i < j}\n\ngoal (1 subgoal):\n 1. prime\n     (case ps of\n      [] \\<Rightarrow> let (x, y) = next_primes i in find_prime_main f x y\n      | p # ps \\<Rightarrow>\n          if f p then p else find_prime_main f i ps) \\<and>\n    f (case ps of\n       [] \\<Rightarrow> let (x, y) = next_primes i in find_prime_main f x y\n       | p # ps \\<Rightarrow> if f p then p else find_prime_main f i ps)", "by (simp add: Nil np)"], ["proof (state)\nthis:\n  prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps = a # list \\<Longrightarrow>\n       prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps = a # list \\<Longrightarrow>\n       prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)", "case (Cons p qs)"], ["proof (state)\nthis:\n  ps = p # qs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps = a # list \\<Longrightarrow>\n       prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)", "proof (cases \"f p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f p \\<Longrightarrow>\n    prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)\n 2. \\<not> f p \\<Longrightarrow>\n    prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)", "case True"], ["proof (state)\nthis:\n  f p\n\ngoal (2 subgoals):\n 1. f p \\<Longrightarrow>\n    prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)\n 2. \\<not> f p \\<Longrightarrow>\n    prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)", "thus ?thesis"], ["proof (prove)\nusing this:\n  f p\n\ngoal (1 subgoal):\n 1. prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)", "unfolding simps"], ["proof (prove)\nusing this:\n  f p\n\ngoal (1 subgoal):\n 1. prime\n     (case ps of\n      [] \\<Rightarrow> let (x, y) = next_primes i in find_prime_main f x y\n      | p # ps \\<Rightarrow>\n          if f p then p else find_prime_main f i ps) \\<and>\n    f (case ps of\n       [] \\<Rightarrow> let (x, y) = next_primes i in find_prime_main f x y\n       | p # ps \\<Rightarrow> if f p then p else find_prime_main f i ps)", "using ps"], ["proof (prove)\nusing this:\n  f p\n  ?p \\<in> set ps \\<Longrightarrow> prime ?p\n\ngoal (1 subgoal):\n 1. prime\n     (case ps of\n      [] \\<Rightarrow> let (x, y) = next_primes i in find_prime_main f x y\n      | p # ps \\<Rightarrow>\n          if f p then p else find_prime_main f i ps) \\<and>\n    f (case ps of\n       [] \\<Rightarrow> let (x, y) = next_primes i in find_prime_main f x y\n       | p # ps \\<Rightarrow> if f p then p else find_prime_main f i ps)", "unfolding Cons"], ["proof (prove)\nusing this:\n  f p\n  ?p \\<in> set (p # qs) \\<Longrightarrow> prime ?p\n\ngoal (1 subgoal):\n 1. prime\n     (case p # qs of\n      [] \\<Rightarrow> let (x, y) = next_primes i in find_prime_main f x y\n      | p # ps \\<Rightarrow>\n          if f p then p else find_prime_main f i ps) \\<and>\n    f (case p # qs of\n       [] \\<Rightarrow> let (x, y) = next_primes i in find_prime_main f x y\n       | p # ps \\<Rightarrow> if f p then p else find_prime_main f i ps)", "by simp"], ["proof (state)\nthis:\n  prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)\n\ngoal (1 subgoal):\n 1. \\<not> f p \\<Longrightarrow>\n    prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> f p \\<Longrightarrow>\n    prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)", "case False"], ["proof (state)\nthis:\n  \\<not> f p\n\ngoal (1 subgoal):\n 1. \\<not> f p \\<Longrightarrow>\n    prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)", "have m: \"((Suc n - i, length qs), m) \\<in> measures [fst, snd]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Suc n - i, length qs), m) \\<in> measures [fst, snd]", "using m"], ["proof (prove)\nusing this:\n  m = (Suc n - i, length ps)\n\ngoal (1 subgoal):\n 1. ((Suc n - i, length qs), m) \\<in> measures [fst, snd]", "unfolding Cons"], ["proof (prove)\nusing this:\n  m = (Suc n - i, length (p # qs))\n\ngoal (1 subgoal):\n 1. ((Suc n - i, length qs), m) \\<in> measures [fst, snd]", "by simp"], ["proof (state)\nthis:\n  ((Suc n - i, length qs), m) \\<in> measures [fst, snd]\n\ngoal (1 subgoal):\n 1. \\<not> f p \\<Longrightarrow>\n    prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)", "have n: \"n \\<in> set qs \\<or> i \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> set qs \\<or> i \\<le> n", "using False n fn"], ["proof (prove)\nusing this:\n  \\<not> f p\n  n \\<in> set ps \\<or> i \\<le> n\n  prime n\n  f n\n\ngoal (1 subgoal):\n 1. n \\<in> set qs \\<or> i \\<le> n", "by (auto simp: Cons)"], ["proof (state)\nthis:\n  n \\<in> set qs \\<or> i \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> f p \\<Longrightarrow>\n    prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)", "from IH[OF m can n refl ps]"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      x \\<in> set qs \\<Longrightarrow> x \\<in> set ps) \\<Longrightarrow>\n  prime (find_prime_main f i qs) \\<and> f (find_prime_main f i qs)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> set qs \\<Longrightarrow> x \\<in> set ps) \\<Longrightarrow>\n  prime (find_prime_main f i qs) \\<and> f (find_prime_main f i qs)\n\ngoal (1 subgoal):\n 1. prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)", "unfolding simps"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> set qs \\<Longrightarrow> x \\<in> set ps) \\<Longrightarrow>\n  prime (find_prime_main f i qs) \\<and> f (find_prime_main f i qs)\n\ngoal (1 subgoal):\n 1. prime\n     (case ps of\n      [] \\<Rightarrow> let (x, y) = next_primes i in find_prime_main f x y\n      | p # ps \\<Rightarrow>\n          if f p then p else find_prime_main f i ps) \\<and>\n    f (case ps of\n       [] \\<Rightarrow> let (x, y) = next_primes i in find_prime_main f x y\n       | p # ps \\<Rightarrow> if f p then p else find_prime_main f i ps)", "using Cons False"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> set qs \\<Longrightarrow> x \\<in> set ps) \\<Longrightarrow>\n  prime (find_prime_main f i qs) \\<and> f (find_prime_main f i qs)\n  ps = p # qs\n  \\<not> f p\n\ngoal (1 subgoal):\n 1. prime\n     (case ps of\n      [] \\<Rightarrow> let (x, y) = next_primes i in find_prime_main f x y\n      | p # ps \\<Rightarrow>\n          if f p then p else find_prime_main f i ps) \\<and>\n    f (case ps of\n       [] \\<Rightarrow> let (x, y) = next_primes i in find_prime_main f x y\n       | p # ps \\<Rightarrow> if f p then p else find_prime_main f i ps)", "by simp"], ["proof (state)\nthis:\n  prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prime (find_prime_main f i ps) \\<and> f (find_prime_main f i ps)\n\ngoal (1 subgoal):\n 1. prime (find_prime f) \\<and> f (find_prime f)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>candidate_invariant ?i2; n \\<in> set ?ps2 \\<or> ?i2 \\<le> n;\n   ?m2 = (Suc n - ?i2, length ?ps2);\n   \\<And>p. p \\<in> set ?ps2 \\<Longrightarrow> prime p\\<rbrakk>\n  \\<Longrightarrow> prime (find_prime_main f ?i2 ?ps2) \\<and>\n                    f (find_prime_main f ?i2 ?ps2)\n\ngoal (1 subgoal):\n 1. prime (find_prime f) \\<and> f (find_prime f)", "note main = this"], ["proof (state)\nthis:\n  \\<lbrakk>candidate_invariant ?i2; n \\<in> set ?ps2 \\<or> ?i2 \\<le> n;\n   ?m2 = (Suc n - ?i2, length ?ps2);\n   \\<And>p. p \\<in> set ?ps2 \\<Longrightarrow> prime p\\<rbrakk>\n  \\<Longrightarrow> prime (find_prime_main f ?i2 ?ps2) \\<and>\n                    f (find_prime_main f ?i2 ?ps2)\n\ngoal (1 subgoal):\n 1. prime (find_prime f) \\<and> f (find_prime f)", "have \"candidate_invariant 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. candidate_invariant 0", "by (simp add: candidate_invariant_def)"], ["proof (state)\nthis:\n  candidate_invariant 0\n\ngoal (1 subgoal):\n 1. prime (find_prime f) \\<and> f (find_prime f)", "from main[OF this _ refl, of Nil]"], ["proof (chain)\npicking this:\n  \\<lbrakk>n \\<in> set [] \\<or> 0 \\<le> n;\n   \\<And>p. p \\<in> set [] \\<Longrightarrow> prime p\\<rbrakk>\n  \\<Longrightarrow> prime (find_prime_main f 0 []) \\<and>\n                    f (find_prime_main f 0 [])", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<in> set [] \\<or> 0 \\<le> n;\n   \\<And>p. p \\<in> set [] \\<Longrightarrow> prime p\\<rbrakk>\n  \\<Longrightarrow> prime (find_prime_main f 0 []) \\<and>\n                    f (find_prime_main f 0 [])\n\ngoal (1 subgoal):\n 1. prime (find_prime f) \\<and> f (find_prime f)", "unfolding find_prime_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<in> set [] \\<or> 0 \\<le> n;\n   \\<And>p. p \\<in> set [] \\<Longrightarrow> prime p\\<rbrakk>\n  \\<Longrightarrow> prime (find_prime_main f 0 []) \\<and>\n                    f (find_prime_main f 0 [])\n\ngoal (1 subgoal):\n 1. prime (find_prime_main f 0 []) \\<and> f (find_prime_main f 0 [])", "by auto"], ["proof (state)\nthis:\n  prime (find_prime f) \\<and> f (find_prime f)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition suitable_prime_bz :: \"int poly \\<Rightarrow> int\" where\n  \"suitable_prime_bz f \\<equiv> let lc = lead_coeff f in int (find_prime (\\<lambda> n. let p = int n in \n       coprime lc p \\<and> separable_impl p f))\""], ["", "lemma suitable_prime_bz: assumes sf: \"square_free f\" and p: \"p = suitable_prime_bz f\" \n  shows \"prime p\" \"coprime (lead_coeff f) p\" \"poly_mod.square_free_m p f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime p &&&\n    comm_monoid_mult_class.coprime (lead_coeff f) p &&&\n    poly_mod.square_free_m p f", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. prime p\n 2. comm_monoid_mult_class.coprime (lead_coeff f) p\n 3. poly_mod.square_free_m p f", "let ?lc = \"lead_coeff f\""], ["proof (state)\ngoal (3 subgoals):\n 1. prime p\n 2. comm_monoid_mult_class.coprime (lead_coeff f) p\n 3. poly_mod.square_free_m p f", "from prime_for_berlekamp_zassenhaus_exists[OF sf, unfolded Let_def]"], ["proof (chain)\npicking this:\n  \\<exists>p.\n     prime p \\<and>\n     comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n     separable_impl p f", "obtain P where *: \"prime P \\<and> coprime ?lc P \\<and> separable_impl P f\""], ["proof (prove)\nusing this:\n  \\<exists>p.\n     prime p \\<and>\n     comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n     separable_impl p f\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        prime P \\<and>\n        comm_monoid_mult_class.coprime (lead_coeff f) P \\<and>\n        separable_impl P f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  prime P \\<and>\n  comm_monoid_mult_class.coprime (lead_coeff f) P \\<and> separable_impl P f\n\ngoal (3 subgoals):\n 1. prime p\n 2. comm_monoid_mult_class.coprime (lead_coeff f) p\n 3. poly_mod.square_free_m p f", "hence \"prime (nat P)\""], ["proof (prove)\nusing this:\n  prime P \\<and>\n  comm_monoid_mult_class.coprime (lead_coeff f) P \\<and> separable_impl P f\n\ngoal (1 subgoal):\n 1. prime (nat P)", "using prime_int_nat_transfer"], ["proof (prove)\nusing this:\n  prime P \\<and>\n  comm_monoid_mult_class.coprime (lead_coeff f) P \\<and> separable_impl P f\n  prime ?k = (0 \\<le> ?k \\<and> prime (nat ?k))\n\ngoal (1 subgoal):\n 1. prime (nat P)", "by blast"], ["proof (state)\nthis:\n  prime (nat P)\n\ngoal (3 subgoals):\n 1. prime p\n 2. comm_monoid_mult_class.coprime (lead_coeff f) p\n 3. poly_mod.square_free_m p f", "with *"], ["proof (chain)\npicking this:\n  prime P \\<and>\n  comm_monoid_mult_class.coprime (lead_coeff f) P \\<and> separable_impl P f\n  prime (nat P)", "have \"\\<exists> p. prime p \\<and> coprime ?lc (int p) \\<and> separable_impl p f\""], ["proof (prove)\nusing this:\n  prime P \\<and>\n  comm_monoid_mult_class.coprime (lead_coeff f) P \\<and> separable_impl P f\n  prime (nat P)\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       prime p \\<and>\n       comm_monoid_mult_class.coprime (lead_coeff f) (int p) \\<and>\n       separable_impl (int p) f", "by (intro exI [of _ \"nat P\"]) (auto dest: prime_gt_0_int)"], ["proof (state)\nthis:\n  \\<exists>p.\n     prime p \\<and>\n     comm_monoid_mult_class.coprime (lead_coeff f) (int p) \\<and>\n     separable_impl (int p) f\n\ngoal (3 subgoals):\n 1. prime p\n 2. comm_monoid_mult_class.coprime (lead_coeff f) p\n 3. poly_mod.square_free_m p f", "from find_prime[OF this]"], ["proof (chain)\npicking this:\n  prime\n   (find_prime\n     (\\<lambda>p.\n         comm_monoid_mult_class.coprime (lead_coeff f) (int p) \\<and>\n         separable_impl (int p) f)) \\<and>\n  comm_monoid_mult_class.coprime (lead_coeff f)\n   (int (find_prime\n          (\\<lambda>p.\n              comm_monoid_mult_class.coprime (lead_coeff f) (int p) \\<and>\n              separable_impl (int p) f))) \\<and>\n  separable_impl\n   (int (find_prime\n          (\\<lambda>p.\n              comm_monoid_mult_class.coprime (lead_coeff f) (int p) \\<and>\n              separable_impl (int p) f)))\n   f", "have prime: \"prime p\" and cop: \"coprime ?lc p\" and sf: \"separable_impl p f\""], ["proof (prove)\nusing this:\n  prime\n   (find_prime\n     (\\<lambda>p.\n         comm_monoid_mult_class.coprime (lead_coeff f) (int p) \\<and>\n         separable_impl (int p) f)) \\<and>\n  comm_monoid_mult_class.coprime (lead_coeff f)\n   (int (find_prime\n          (\\<lambda>p.\n              comm_monoid_mult_class.coprime (lead_coeff f) (int p) \\<and>\n              separable_impl (int p) f))) \\<and>\n  separable_impl\n   (int (find_prime\n          (\\<lambda>p.\n              comm_monoid_mult_class.coprime (lead_coeff f) (int p) \\<and>\n              separable_impl (int p) f)))\n   f\n\ngoal (1 subgoal):\n 1. prime p &&&\n    comm_monoid_mult_class.coprime (lead_coeff f) p &&& separable_impl p f", "unfolding p suitable_prime_bz_def Let_def"], ["proof (prove)\nusing this:\n  prime\n   (find_prime\n     (\\<lambda>p.\n         comm_monoid_mult_class.coprime (lead_coeff f) (int p) \\<and>\n         separable_impl (int p) f)) \\<and>\n  comm_monoid_mult_class.coprime (lead_coeff f)\n   (int (find_prime\n          (\\<lambda>p.\n              comm_monoid_mult_class.coprime (lead_coeff f) (int p) \\<and>\n              separable_impl (int p) f))) \\<and>\n  separable_impl\n   (int (find_prime\n          (\\<lambda>p.\n              comm_monoid_mult_class.coprime (lead_coeff f) (int p) \\<and>\n              separable_impl (int p) f)))\n   f\n\ngoal (1 subgoal):\n 1. prime\n     (int (find_prime\n            (\\<lambda>n.\n                comm_monoid_mult_class.coprime (lead_coeff f) (int n) \\<and>\n                separable_impl (int n) f))) &&&\n    comm_monoid_mult_class.coprime (lead_coeff f)\n     (int (find_prime\n            (\\<lambda>n.\n                comm_monoid_mult_class.coprime (lead_coeff f) (int n) \\<and>\n                separable_impl (int n) f))) &&&\n    separable_impl\n     (int (find_prime\n            (\\<lambda>n.\n                comm_monoid_mult_class.coprime (lead_coeff f) (int n) \\<and>\n                separable_impl (int n) f)))\n     f", "by auto"], ["proof (state)\nthis:\n  prime p\n  comm_monoid_mult_class.coprime (lead_coeff f) p\n  separable_impl p f\n\ngoal (3 subgoals):\n 1. prime p\n 2. comm_monoid_mult_class.coprime (lead_coeff f) p\n 3. poly_mod.square_free_m p f", "then"], ["proof (chain)\npicking this:\n  prime p\n  comm_monoid_mult_class.coprime (lead_coeff f) p\n  separable_impl p f", "interpret poly_mod_prime p"], ["proof (prove)\nusing this:\n  prime p\n  comm_monoid_mult_class.coprime (lead_coeff f) p\n  separable_impl p f\n\ngoal (1 subgoal):\n 1. poly_mod_prime p", "by unfold_locales"], ["proof (state)\ngoal (3 subgoals):\n 1. prime p\n 2. comm_monoid_mult_class.coprime (lead_coeff f) p\n 3. square_free_m f", "from prime cop separable_impl(1)[OF sf]"], ["proof (chain)\npicking this:\n  prime p\n  comm_monoid_mult_class.coprime (lead_coeff f) p\n  square_free_m f", "show \"prime p\" \"coprime ?lc p\" \"square_free_m f\""], ["proof (prove)\nusing this:\n  prime p\n  comm_monoid_mult_class.coprime (lead_coeff f) p\n  square_free_m f\n\ngoal (1 subgoal):\n 1. prime p &&&\n    comm_monoid_mult_class.coprime (lead_coeff f) p &&& square_free_m f", "by auto"], ["proof (state)\nthis:\n  prime p\n  comm_monoid_mult_class.coprime (lead_coeff f) p\n  square_free_m f\n\ngoal:\nNo subgoals!", "qed"], ["", "definition square_free_heuristic :: \"int poly \\<Rightarrow> int option\" where\n  \"square_free_heuristic f = (let lc = lead_coeff f in \n    find (\\<lambda> p. coprime lc p \\<and> separable_impl p f) [2, 3, 5, 7, 11, 13, 17, 19, 23])\""], ["", "lemma find_Some_D: \"find f xs = Some y \\<Longrightarrow> y \\<in> set xs \\<and> f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find f xs = Some y \\<Longrightarrow> y \\<in> set xs \\<and> f y", "unfolding find_Some_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i<length xs.\n       f (xs ! i) \\<and>\n       y = xs ! i \\<and> (\\<forall>j<i. \\<not> f (xs ! j)) \\<Longrightarrow>\n    y \\<in> set xs \\<and> f y", "by auto"], ["", "lemma square_free_heuristic: assumes \"square_free_heuristic f = Some p\" \n  shows \"coprime (lead_coeff f) p \\<and> separable_impl p f \\<and> prime p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n    separable_impl p f \\<and> prime p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n    separable_impl p f \\<and> prime p", "from find_Some_D[OF assms[unfolded square_free_heuristic_def Let_def]]"], ["proof (chain)\npicking this:\n  p \\<in> set [2, 3, 5, 7, 11, 13, 17, 19, 23] \\<and>\n  comm_monoid_mult_class.coprime (lead_coeff f) p \\<and> separable_impl p f", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<in> set [2, 3, 5, 7, 11, 13, 17, 19, 23] \\<and>\n  comm_monoid_mult_class.coprime (lead_coeff f) p \\<and> separable_impl p f\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n    separable_impl p f \\<and> prime p", "by auto"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (lead_coeff f) p \\<and>\n  separable_impl p f \\<and> prime p\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}