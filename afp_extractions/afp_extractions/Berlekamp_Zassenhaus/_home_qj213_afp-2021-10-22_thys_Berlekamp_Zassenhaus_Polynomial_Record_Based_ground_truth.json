{"file_name": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus/Polynomial_Record_Based.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Berlekamp_Zassenhaus", "problem_names": ["lemma coeffs_smult': \"coeffs (smult a p) = (if a = 0 then [] else strip_while ((=) 0) (map (Groups.times a) (coeffs p)))\"", "lemma coeffs_sdiv: \"coeffs (sdiv_poly p a) = (strip_while ((=) 0) (map (\\<lambda> x. x div a) (coeffs p)))\"", "lemma right_total_poly_rel[transfer_rule]: \n  \"right_total poly_rel\"", "lemma poly_rel_inj: \"poly_rel x y \\<Longrightarrow> poly_rel x z \\<Longrightarrow> y = z\"", "lemma bi_unique_poly_rel[transfer_rule]: \"bi_unique poly_rel\"", "lemma Domainp_is_poly [transfer_domain_rule]: \n  \"Domainp poly_rel = is_poly ops\"", "lemma poly_rel_zero[transfer_rule]: \"poly_rel zero_poly_i 0\"", "lemma poly_rel_one[transfer_rule]: \"poly_rel (one_poly_i ops) 1\"", "lemma poly_rel_cCons[transfer_rule]: \"(R ===> list_all2 R ===> list_all2 R) (cCons_i ops) cCons\"", "lemma poly_rel_pCons[transfer_rule]: \"(R ===> poly_rel ===> poly_rel) (cCons_i ops) pCons\"", "lemma poly_rel_eq[transfer_rule]: \"(poly_rel ===> poly_rel ===> (=)) (=) (=)\"", "lemma poly_rel_plus[transfer_rule]: \"(poly_rel ===> poly_rel ===> poly_rel) (plus_poly_i ops) (+)\"", "lemma poly_rel_uminus[transfer_rule]: \"(poly_rel ===> poly_rel) (uminus_poly_i ops) Groups.uminus\"", "lemma poly_rel_minus[transfer_rule]: \"(poly_rel ===> poly_rel ===> poly_rel) (minus_poly_i ops) (-)\"", "lemma poly_rel_smult[transfer_rule]: \"(R ===> poly_rel ===> poly_rel) (smult_i ops) smult\"", "lemma poly_rel_coeffs[transfer_rule]: \"(poly_rel ===> list_all2 R) (\\<lambda> x. x) coeffs\"", "lemma poly_rel_poly_of_list[transfer_rule]: \"(list_all2 R ===> poly_rel) (poly_of_list_i ops) poly_of_list\"", "lemma poly_rel_monom_mult[transfer_rule]: \n  \"((=) ===> poly_rel ===> poly_rel) (monom_mult_i ops) monom_mult\"", "lemma list_rel_coeffs_minus_i: assumes \"list_all2 R x1 x2\" \"list_all2 R y1 y2\" \n  shows \"list_all2 R (coeffs_minus_i ops x1 y1) (coeffs_minus x2 y2)\"", "lemma poly_rel_karatsuba_main: \"list_all2 R x1 x2 \\<Longrightarrow> list_all2 R y1 y2 \\<Longrightarrow>\n  poly_rel (karatsuba_main_i ops x1 n y1 m) (karatsuba_main x2 n y2 m)\"", "lemma poly_rel_times[transfer_rule]: \"(poly_rel ===> poly_rel ===> poly_rel) (times_poly_i ops) ((*))\"", "lemma poly_rel_coeff[transfer_rule]: \"(poly_rel ===> (=) ===> R) (coeff_i ops) coeff\"", "lemma poly_rel_degree[transfer_rule]: \"(poly_rel ===> (=)) degree_i degree\"", "lemma lead_coeff_i_def': \"lead_coeff_i ops x = (coeff_i ops) x (degree_i x)\"", "lemma poly_rel_lead_coeff[transfer_rule]: \"(poly_rel ===> R) (lead_coeff_i ops) lead_coeff\"", "lemma poly_rel_minus_poly_rev_list[transfer_rule]: \n  \"(list_all2 R ===> list_all2 R ===> list_all2 R) (minus_poly_rev_list_i ops) minus_poly_rev_list\"", "lemma divmod_poly_one_main_i: assumes len: \"n \\<le> length Y\" and rel: \"list_all2 R x X\" \"list_all2 R y Y\"\n    \"list_all2 R z Z\" and n: \"n = N\"\n shows \"rel_prod (list_all2 R) (list_all2 R) (divmod_poly_one_main_i ops x y z n)\n    (divmod_poly_one_main_list X Y Z N)\"", "lemma mod_poly_one_main_i: assumes len: \"n \\<le> length X\" and rel: \"list_all2 R x X\" \"list_all2 R y Y\"\n    and n: \"n = N\"\n shows \"list_all2 R (mod_poly_one_main_i ops x y n)\n    (mod_poly_one_main_list X Y N)\"", "lemma poly_rel_dvd[transfer_rule]: \"(poly_rel ===> poly_rel ===> (=)) (dvd_poly_i ops) (dvd)\"", "lemma poly_rel_monic[transfer_rule]: \"(poly_rel ===> (=)) (monic_i ops) monic\"", "lemma poly_rel_pdivmod_monic: assumes mon: \"monic Y\" \n  and x: \"poly_rel x X\" and y: \"poly_rel y Y\"\n  shows \"rel_prod poly_rel poly_rel (pdivmod_monic_i ops x y) (pdivmod_monic X Y)\"", "lemma ring_ops_poly: \"ring_ops (poly_ops ops) poly_rel\"", "lemma poly_rel_pderiv [transfer_rule]: \"(poly_rel ===> poly_rel) (pderiv_i ops) pderiv\"", "lemma poly_rel_irreducible[transfer_rule]: \"(poly_rel ===> (=)) (irreducible_i ops) irreducible\\<^sub>d\"", "lemma idom_ops_poly: \"idom_ops (poly_ops ops) poly_rel\"", "lemma poly_rel_sdiv[transfer_rule]: \"(poly_rel ===> R ===> poly_rel) (sdiv_i ops) sdiv_poly\"", "lemma poly_rel_div[transfer_rule]: \"(poly_rel ===> poly_rel ===> poly_rel) \n  (div_field_poly_i ops) (div)\"", "lemma poly_rel_mod[transfer_rule]: \"(poly_rel ===> poly_rel ===> poly_rel) \n  (mod_field_poly_i ops) (mod)\"", "lemma poly_rel_normalize [transfer_rule]: \"(poly_rel ===> poly_rel) \n  (normalize_poly_i ops) Rings.normalize\"", "lemma poly_rel_unit_factor [transfer_rule]: \"(poly_rel ===> poly_rel) \n  (unit_factor_poly_i ops) Rings.unit_factor\"", "lemma idom_divide_ops_poly: \"idom_divide_ops (poly_ops ops) poly_rel\"", "lemma euclidean_ring_ops_poly: \"euclidean_ring_ops (poly_ops ops) poly_rel\"", "lemma poly_rel_gcd [transfer_rule]: \"(poly_rel ===> poly_rel ===> poly_rel) (gcd_poly_i ops) gcd\"", "lemma poly_rel_euclid_ext [transfer_rule]: \"(poly_rel ===> poly_rel ===> \n  rel_prod (rel_prod poly_rel poly_rel) poly_rel) (euclid_ext_poly_i ops) euclid_ext\""], "translations": [["", "lemma coeffs_smult': \"coeffs (smult a p) = (if a = 0 then [] else strip_while ((=) 0) (map (Groups.times a) (coeffs p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeffs (smult a p) =\n    (if a = (0::'a) then []\n     else strip_while ((=) (0::'a)) (map ((*) a) (coeffs p)))", "by (simp add: coeffs_map_poly smult_conv_map_poly)"], ["", "lemma coeffs_sdiv: \"coeffs (sdiv_poly p a) = (strip_while ((=) 0) (map (\\<lambda> x. x div a) (coeffs p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeffs (sdiv_poly p a) =\n    strip_while ((=) (0::'a)) (map (\\<lambda>x. x div a) (coeffs p))", "unfolding sdiv_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeffs (map_poly (\\<lambda>c. c div a) p) =\n    strip_while ((=) (0::'a)) (map (\\<lambda>x. x div a) (coeffs p))", "by (rule coeffs_map_poly)"], ["", "lifting_forget poly.lifting"], ["", "context ring_ops\nbegin"], ["", "definition poly_rel :: \"'i list \\<Rightarrow> 'a poly \\<Rightarrow> bool\" where\n  \"poly_rel x x' \\<longleftrightarrow> list_all2 R x (coeffs x')\""], ["", "lemma right_total_poly_rel[transfer_rule]: \n  \"right_total poly_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_total poly_rel", "using list.right_total_rel[of R] right_total"], ["proof (prove)\nusing this:\n  right_total R \\<Longrightarrow> right_total (list_all2 R)\n  right_total R\n\ngoal (1 subgoal):\n 1. right_total poly_rel", "unfolding poly_rel_def right_total_def"], ["proof (prove)\nusing this:\n  \\<forall>y. \\<exists>x. R x y \\<Longrightarrow>\n  \\<forall>y. \\<exists>x. list_all2 R x y\n  \\<forall>y. \\<exists>x. R x y\n\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. list_all2 R x (coeffs y)", "by auto"], ["", "lemma poly_rel_inj: \"poly_rel x y \\<Longrightarrow> poly_rel x z \\<Longrightarrow> y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly_rel x y; poly_rel x z\\<rbrakk> \\<Longrightarrow> y = z", "using list.bi_unique_rel[OF bi_unique]"], ["proof (prove)\nusing this:\n  bi_unique (list_all2 R)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>poly_rel x y; poly_rel x z\\<rbrakk> \\<Longrightarrow> y = z", "unfolding poly_rel_def coeffs_eq_iff bi_unique_def"], ["proof (prove)\nusing this:\n  (\\<forall>x y z.\n      list_all2 R x y \\<longrightarrow>\n      list_all2 R x z \\<longrightarrow> y = z) \\<and>\n  (\\<forall>x y z.\n      list_all2 R x z \\<longrightarrow>\n      list_all2 R y z \\<longrightarrow> x = y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all2 R x (coeffs y); list_all2 R x (coeffs z)\\<rbrakk>\n    \\<Longrightarrow> coeffs y = coeffs z", "by auto"], ["", "lemma bi_unique_poly_rel[transfer_rule]: \"bi_unique poly_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique poly_rel", "using list.bi_unique_rel[OF bi_unique]"], ["proof (prove)\nusing this:\n  bi_unique (list_all2 R)\n\ngoal (1 subgoal):\n 1. bi_unique poly_rel", "unfolding poly_rel_def bi_unique_def coeffs_eq_iff"], ["proof (prove)\nusing this:\n  (\\<forall>x y z.\n      list_all2 R x y \\<longrightarrow>\n      list_all2 R x z \\<longrightarrow> y = z) \\<and>\n  (\\<forall>x y z.\n      list_all2 R x z \\<longrightarrow>\n      list_all2 R y z \\<longrightarrow> x = y)\n\ngoal (1 subgoal):\n 1. (\\<forall>x y z.\n        list_all2 R x (coeffs y) \\<longrightarrow>\n        list_all2 R x (coeffs z) \\<longrightarrow>\n        coeffs y = coeffs z) \\<and>\n    (\\<forall>x y z.\n        list_all2 R x (coeffs z) \\<longrightarrow>\n        list_all2 R y (coeffs z) \\<longrightarrow> x = y)", "by auto"], ["", "lemma Domainp_is_poly [transfer_domain_rule]: \n  \"Domainp poly_rel = is_poly ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp poly_rel = is_poly ops", "unfolding poly_rel_def [abs_def] is_poly_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp (\\<lambda>x x'. list_all2 R x (coeffs x')) =\n    (\\<lambda>xs.\n        list_all (arith_ops_record.DP ops) xs \\<and>\n        no_trailing ((=) (arith_ops_record.zero ops)) xs)", "proof (intro ext iffI, unfold Domainp_iff)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<exists>x'. list_all2 R xs (coeffs x') \\<Longrightarrow>\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs\n 2. \\<And>xs.\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs \\<Longrightarrow>\n       \\<exists>x'. list_all2 R xs (coeffs x')", "note DPR = fun_cong [OF list.Domainp_rel [of R, unfolded DPR],\n    unfolded Domainp_iff]"], ["proof (state)\nthis:\n  Ex (list_all2 R ?x) = list_all (arith_ops_record.DP ops) ?x\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<exists>x'. list_all2 R xs (coeffs x') \\<Longrightarrow>\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs\n 2. \\<And>xs.\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs \\<Longrightarrow>\n       \\<exists>x'. list_all2 R xs (coeffs x')", "let ?no_trailing = \"no_trailing (HOL.eq zero)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<exists>x'. list_all2 R xs (coeffs x') \\<Longrightarrow>\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs\n 2. \\<And>xs.\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs \\<Longrightarrow>\n       \\<exists>x'. list_all2 R xs (coeffs x')", "fix xs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<exists>x'. list_all2 R xs (coeffs x') \\<Longrightarrow>\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs\n 2. \\<And>xs.\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs \\<Longrightarrow>\n       \\<exists>x'. list_all2 R xs (coeffs x')", "have no_trailing: \"no_trailing (HOL.eq 0) xs' \\<longleftrightarrow> ?no_trailing xs\"\n    if \"list_all2 R xs xs'\" for xs'"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_trailing ((=) (0::'a)) xs' =\n    no_trailing ((=) (arith_ops_record.zero ops)) xs", "proof (cases xs rule: rev_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    no_trailing ((=) (0::'a)) xs' =\n    no_trailing ((=) (arith_ops_record.zero ops)) xs\n 2. \\<And>ys y.\n       xs = ys @ [y] \\<Longrightarrow>\n       no_trailing ((=) (0::'a)) xs' =\n       no_trailing ((=) (arith_ops_record.zero ops)) xs", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    no_trailing ((=) (0::'a)) xs' =\n    no_trailing ((=) (arith_ops_record.zero ops)) xs\n 2. \\<And>ys y.\n       xs = ys @ [y] \\<Longrightarrow>\n       no_trailing ((=) (0::'a)) xs' =\n       no_trailing ((=) (arith_ops_record.zero ops)) xs", "with that"], ["proof (chain)\npicking this:\n  list_all2 R xs xs'\n  xs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  list_all2 R xs xs'\n  xs = []\n\ngoal (1 subgoal):\n 1. no_trailing ((=) (0::'a)) xs' =\n    no_trailing ((=) (arith_ops_record.zero ops)) xs", "by simp"], ["proof (state)\nthis:\n  no_trailing ((=) (0::'a)) xs' =\n  no_trailing ((=) (arith_ops_record.zero ops)) xs\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       xs = ys @ [y] \\<Longrightarrow>\n       no_trailing ((=) (0::'a)) xs' =\n       no_trailing ((=) (arith_ops_record.zero ops)) xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       xs = ys @ [y] \\<Longrightarrow>\n       no_trailing ((=) (0::'a)) xs' =\n       no_trailing ((=) (arith_ops_record.zero ops)) xs", "case (snoc ys y)"], ["proof (state)\nthis:\n  xs = ys @ [y]\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       xs = ys @ [y] \\<Longrightarrow>\n       no_trailing ((=) (0::'a)) xs' =\n       no_trailing ((=) (arith_ops_record.zero ops)) xs", "with that"], ["proof (chain)\npicking this:\n  list_all2 R xs xs'\n  xs = ys @ [y]", "have \"xs' \\<noteq> []\""], ["proof (prove)\nusing this:\n  list_all2 R xs xs'\n  xs = ys @ [y]\n\ngoal (1 subgoal):\n 1. xs' \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       xs = ys @ [y] \\<Longrightarrow>\n       no_trailing ((=) (0::'a)) xs' =\n       no_trailing ((=) (arith_ops_record.zero ops)) xs", "then"], ["proof (chain)\npicking this:\n  xs' \\<noteq> []", "obtain ys' y' where \"xs' = ys' @ [y']\""], ["proof (prove)\nusing this:\n  xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>ys' y'.\n        xs' = ys' @ [y'] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases xs' rule: rev_cases) simp_all"], ["proof (state)\nthis:\n  xs' = ys' @ [y']\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       xs = ys @ [y] \\<Longrightarrow>\n       no_trailing ((=) (0::'a)) xs' =\n       no_trailing ((=) (arith_ops_record.zero ops)) xs", "with that snoc"], ["proof (chain)\npicking this:\n  list_all2 R xs xs'\n  xs = ys @ [y]\n  xs' = ys' @ [y']", "show ?thesis"], ["proof (prove)\nusing this:\n  list_all2 R xs xs'\n  xs = ys @ [y]\n  xs' = ys' @ [y']\n\ngoal (1 subgoal):\n 1. no_trailing ((=) (0::'a)) xs' =\n    no_trailing ((=) (arith_ops_record.zero ops)) xs", "by simp (meson bi_unique bi_unique_def zero)"], ["proof (state)\nthis:\n  no_trailing ((=) (0::'a)) xs' =\n  no_trailing ((=) (arith_ops_record.zero ops)) xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all2 R xs ?xs' \\<Longrightarrow>\n  no_trailing ((=) (0::'a)) ?xs' =\n  no_trailing ((=) (arith_ops_record.zero ops)) xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<exists>x'. list_all2 R xs (coeffs x') \\<Longrightarrow>\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs\n 2. \\<And>xs.\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs \\<Longrightarrow>\n       \\<exists>x'. list_all2 R xs (coeffs x')", "let ?DPR = \"arith_ops_record.DP ops\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<exists>x'. list_all2 R xs (coeffs x') \\<Longrightarrow>\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs\n 2. \\<And>xs.\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs \\<Longrightarrow>\n       \\<exists>x'. list_all2 R xs (coeffs x')", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<exists>x'. list_all2 R xs (coeffs x') \\<Longrightarrow>\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs\n 2. \\<And>xs.\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs \\<Longrightarrow>\n       \\<exists>x'. list_all2 R xs (coeffs x')", "assume \"\\<exists>x'. list_all2 R xs (coeffs x')\""], ["proof (state)\nthis:\n  \\<exists>x'. list_all2 R xs (coeffs x')\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<exists>x'. list_all2 R xs (coeffs x') \\<Longrightarrow>\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs\n 2. \\<And>xs.\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs \\<Longrightarrow>\n       \\<exists>x'. list_all2 R xs (coeffs x')", "then"], ["proof (chain)\npicking this:\n  \\<exists>x'. list_all2 R xs (coeffs x')", "obtain xs' where *: \"list_all2 R xs (coeffs xs')\""], ["proof (prove)\nusing this:\n  \\<exists>x'. list_all2 R xs (coeffs x')\n\ngoal (1 subgoal):\n 1. (\\<And>xs'.\n        list_all2 R xs (coeffs xs') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  list_all2 R xs (coeffs xs')\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<exists>x'. list_all2 R xs (coeffs x') \\<Longrightarrow>\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs\n 2. \\<And>xs.\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs \\<Longrightarrow>\n       \\<exists>x'. list_all2 R xs (coeffs x')", "with DPR [of xs]"], ["proof (chain)\npicking this:\n  Ex (list_all2 R xs) = list_all (arith_ops_record.DP ops) xs\n  list_all2 R xs (coeffs xs')", "have \"list_all ?DPR xs\""], ["proof (prove)\nusing this:\n  Ex (list_all2 R xs) = list_all (arith_ops_record.DP ops) xs\n  list_all2 R xs (coeffs xs')\n\ngoal (1 subgoal):\n 1. list_all (arith_ops_record.DP ops) xs", "by auto"], ["proof (state)\nthis:\n  list_all (arith_ops_record.DP ops) xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<exists>x'. list_all2 R xs (coeffs x') \\<Longrightarrow>\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs\n 2. \\<And>xs.\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs \\<Longrightarrow>\n       \\<exists>x'. list_all2 R xs (coeffs x')", "then"], ["proof (chain)\npicking this:\n  list_all (arith_ops_record.DP ops) xs", "show \"list_all ?DPR xs \\<and> ?no_trailing xs\""], ["proof (prove)\nusing this:\n  list_all (arith_ops_record.DP ops) xs\n\ngoal (1 subgoal):\n 1. list_all (arith_ops_record.DP ops) xs \\<and>\n    no_trailing ((=) (arith_ops_record.zero ops)) xs", "using no_trailing [OF *]"], ["proof (prove)\nusing this:\n  list_all (arith_ops_record.DP ops) xs\n  no_trailing ((=) (0::'a)) (coeffs xs') =\n  no_trailing ((=) (arith_ops_record.zero ops)) xs\n\ngoal (1 subgoal):\n 1. list_all (arith_ops_record.DP ops) xs \\<and>\n    no_trailing ((=) (arith_ops_record.zero ops)) xs", "by simp"], ["proof (state)\nthis:\n  list_all (arith_ops_record.DP ops) xs \\<and>\n  no_trailing ((=) (arith_ops_record.zero ops)) xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs \\<Longrightarrow>\n       \\<exists>x'. list_all2 R xs (coeffs x')", "}"], ["proof (state)\nthis:\n  \\<exists>x'. list_all2 R xs (coeffs x') \\<Longrightarrow>\n  list_all (arith_ops_record.DP ops) xs \\<and>\n  no_trailing ((=) (arith_ops_record.zero ops)) xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs \\<Longrightarrow>\n       \\<exists>x'. list_all2 R xs (coeffs x')", "{"], ["proof (state)\nthis:\n  \\<exists>x'. list_all2 R xs (coeffs x') \\<Longrightarrow>\n  list_all (arith_ops_record.DP ops) xs \\<and>\n  no_trailing ((=) (arith_ops_record.zero ops)) xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs \\<Longrightarrow>\n       \\<exists>x'. list_all2 R xs (coeffs x')", "assume \"list_all ?DPR xs \\<and> ?no_trailing xs\""], ["proof (state)\nthis:\n  list_all (arith_ops_record.DP ops) xs \\<and>\n  no_trailing ((=) (arith_ops_record.zero ops)) xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs \\<Longrightarrow>\n       \\<exists>x'. list_all2 R xs (coeffs x')", "with DPR [of xs]"], ["proof (chain)\npicking this:\n  Ex (list_all2 R xs) = list_all (arith_ops_record.DP ops) xs\n  list_all (arith_ops_record.DP ops) xs \\<and>\n  no_trailing ((=) (arith_ops_record.zero ops)) xs", "obtain xs' where *: \"list_all2 R xs xs'\" and \"?no_trailing xs\""], ["proof (prove)\nusing this:\n  Ex (list_all2 R xs) = list_all (arith_ops_record.DP ops) xs\n  list_all (arith_ops_record.DP ops) xs \\<and>\n  no_trailing ((=) (arith_ops_record.zero ops)) xs\n\ngoal (1 subgoal):\n 1. (\\<And>xs'.\n        \\<lbrakk>list_all2 R xs xs';\n         no_trailing ((=) (arith_ops_record.zero ops)) xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  list_all2 R xs xs'\n  no_trailing ((=) (arith_ops_record.zero ops)) xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs \\<Longrightarrow>\n       \\<exists>x'. list_all2 R xs (coeffs x')", "from no_trailing [OF *] this(2)"], ["proof (chain)\npicking this:\n  no_trailing ((=) (0::'a)) xs' =\n  no_trailing ((=) (arith_ops_record.zero ops)) xs\n  no_trailing ((=) (arith_ops_record.zero ops)) xs", "have \"no_trailing (HOL.eq 0) xs'\""], ["proof (prove)\nusing this:\n  no_trailing ((=) (0::'a)) xs' =\n  no_trailing ((=) (arith_ops_record.zero ops)) xs\n  no_trailing ((=) (arith_ops_record.zero ops)) xs\n\ngoal (1 subgoal):\n 1. no_trailing ((=) (0::'a)) xs'", "by simp"], ["proof (state)\nthis:\n  no_trailing ((=) (0::'a)) xs'\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs \\<Longrightarrow>\n       \\<exists>x'. list_all2 R xs (coeffs x')", "hence \"coeffs (poly_of_list xs') = xs'\""], ["proof (prove)\nusing this:\n  no_trailing ((=) (0::'a)) xs'\n\ngoal (1 subgoal):\n 1. coeffs (poly_of_list xs') = xs'", "unfolding poly_of_list_impl"], ["proof (prove)\nusing this:\n  no_trailing ((=) (0::'a)) xs'\n\ngoal (1 subgoal):\n 1. strip_while ((=) (0::'a)) xs' = xs'", "by auto"], ["proof (state)\nthis:\n  coeffs (poly_of_list xs') = xs'\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       list_all (arith_ops_record.DP ops) xs \\<and>\n       no_trailing ((=) (arith_ops_record.zero ops)) xs \\<Longrightarrow>\n       \\<exists>x'. list_all2 R xs (coeffs x')", "with *"], ["proof (chain)\npicking this:\n  list_all2 R xs xs'\n  coeffs (poly_of_list xs') = xs'", "show \"\\<exists>x'. list_all2 R xs (coeffs x')\""], ["proof (prove)\nusing this:\n  list_all2 R xs xs'\n  coeffs (poly_of_list xs') = xs'\n\ngoal (1 subgoal):\n 1. \\<exists>x'. list_all2 R xs (coeffs x')", "by metis"], ["proof (state)\nthis:\n  \\<exists>x'. list_all2 R xs (coeffs x')\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  list_all (arith_ops_record.DP ops) xs \\<and>\n  no_trailing ((=) (arith_ops_record.zero ops)) xs \\<Longrightarrow>\n  \\<exists>x'. list_all2 R xs (coeffs x')\n\ngoal:\nNo subgoals!", "qed"], ["", "(* zero *)"], ["", "lemma poly_rel_zero[transfer_rule]: \"poly_rel zero_poly_i 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel [] 0", "unfolding poly_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R [] (coeffs 0)", "by auto"], ["", "(* one *)"], ["", "lemma poly_rel_one[transfer_rule]: \"poly_rel (one_poly_i ops) 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (one_poly_i ops) 1", "unfolding poly_rel_def one_poly_i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R [arith_ops_record.one ops] (coeffs 1)", "by (simp add: one)"], ["", "(* cCons *)"], ["", "lemma poly_rel_cCons[transfer_rule]: \"(R ===> list_all2 R ===> list_all2 R) (cCons_i ops) cCons\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (R ===> list_all2 R ===> list_all2 R) (cCons_i ops) cCons", "unfolding cCons_i_def[abs_def] cCons_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (R ===> list_all2 R ===> list_all2 R)\n     (\\<lambda>x xs.\n         if xs = [] \\<and> x = arith_ops_record.zero ops then []\n         else x # xs)\n     (\\<lambda>x xs. if xs = [] \\<and> x = (0::'a) then [] else x # xs)", "by transfer_prover"], ["", "(* pCons *)"], ["", "lemma poly_rel_pCons[transfer_rule]: \"(R ===> poly_rel ===> poly_rel) (cCons_i ops) pCons\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (R ===> poly_rel ===> poly_rel) (cCons_i ops) pCons", "unfolding rel_fun_def poly_rel_def coeffs_pCons_eq_cCons cCons_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       R x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           list_all2 R xa (coeffs ya) \\<longrightarrow>\n           list_all2 R (cCons_i ops x xa) (cCons y (coeffs ya)))", "using poly_rel_cCons[unfolded rel_fun_def]"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     R x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         list_all2 R xa ya \\<longrightarrow>\n         list_all2 R (cCons_i ops x xa) (cCons y ya))\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       R x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           list_all2 R xa (coeffs ya) \\<longrightarrow>\n           list_all2 R (cCons_i ops x xa) (cCons y (coeffs ya)))", "by auto"], ["", "(* equality *)"], ["", "lemma poly_rel_eq[transfer_rule]: \"(poly_rel ===> poly_rel ===> (=)) (=) (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> poly_rel ===> (=)) (=) (=)", "unfolding poly_rel_def[abs_def] coeffs_eq_iff[abs_def] rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       list_all2 R x (coeffs y) \\<longrightarrow>\n       (\\<forall>xa ya.\n           list_all2 R xa (coeffs ya) \\<longrightarrow>\n           (x = xa) = (coeffs y = coeffs ya))", "by (metis bi_unique bi_uniqueDl bi_uniqueDr list.bi_unique_rel)"], ["", "(* addition *)"], ["", "lemma poly_rel_plus[transfer_rule]: \"(poly_rel ===> poly_rel ===> poly_rel) (plus_poly_i ops) (+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> poly_rel ===> poly_rel) (plus_poly_i ops) (+)", "proof (intro rel_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>poly_rel x y; poly_rel xa ya\\<rbrakk>\n       \\<Longrightarrow> poly_rel (plus_poly_i ops x xa) (y + ya)", "fix x1 y1 x2 y2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>poly_rel x y; poly_rel xa ya\\<rbrakk>\n       \\<Longrightarrow> poly_rel (plus_poly_i ops x xa) (y + ya)", "assume \"poly_rel x1 x2\" and \"poly_rel y1 y2\""], ["proof (state)\nthis:\n  poly_rel x1 x2\n  poly_rel y1 y2\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>poly_rel x y; poly_rel xa ya\\<rbrakk>\n       \\<Longrightarrow> poly_rel (plus_poly_i ops x xa) (y + ya)", "thus \"poly_rel (plus_poly_i ops x1 y1) (x2 + y2)\""], ["proof (prove)\nusing this:\n  poly_rel x1 x2\n  poly_rel y1 y2\n\ngoal (1 subgoal):\n 1. poly_rel (plus_poly_i ops x1 y1) (x2 + y2)", "unfolding poly_rel_def coeffs_eq_iff coeffs_plus_eq_plus_coeffs"], ["proof (prove)\nusing this:\n  list_all2 R x1 (coeffs x2)\n  list_all2 R y1 (coeffs y2)\n\ngoal (1 subgoal):\n 1. list_all2 R (plus_poly_i ops x1 y1)\n     (plus_coeffs (coeffs x2) (coeffs y2))", "proof (induct x1 y1 arbitrary: x2 y2 rule: plus_poly_i.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xs y ys x2 y2.\n       \\<lbrakk>\\<And>x2 y2.\n                   \\<lbrakk>list_all2 R xs (coeffs x2);\n                    list_all2 R ys (coeffs y2)\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R (plus_poly_i ops xs ys)\n(plus_coeffs (coeffs x2) (coeffs y2));\n        list_all2 R (x # xs) (coeffs x2);\n        list_all2 R (y # ys) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops (x # xs) (y # ys))\n                          (plus_coeffs (coeffs x2) (coeffs y2))\n 2. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs (coeffs x2);\n        list_all2 R [] (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops xs [])\n                          (plus_coeffs (coeffs x2) (coeffs y2))\n 3. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2) (coeffs y2))", "case (1 x1 xs1 y1 ys1 X2 Y2)"], ["proof (state)\nthis:\n  \\<lbrakk>list_all2 R xs1 (coeffs ?x2.0);\n   list_all2 R ys1 (coeffs ?y2.0)\\<rbrakk>\n  \\<Longrightarrow> list_all2 R (plus_poly_i ops xs1 ys1)\n                     (plus_coeffs (coeffs ?x2.0) (coeffs ?y2.0))\n  list_all2 R (x1 # xs1) (coeffs X2)\n  list_all2 R (y1 # ys1) (coeffs Y2)\n\ngoal (3 subgoals):\n 1. \\<And>x xs y ys x2 y2.\n       \\<lbrakk>\\<And>x2 y2.\n                   \\<lbrakk>list_all2 R xs (coeffs x2);\n                    list_all2 R ys (coeffs y2)\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R (plus_poly_i ops xs ys)\n(plus_coeffs (coeffs x2) (coeffs y2));\n        list_all2 R (x # xs) (coeffs x2);\n        list_all2 R (y # ys) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops (x # xs) (y # ys))\n                          (plus_coeffs (coeffs x2) (coeffs y2))\n 2. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs (coeffs x2);\n        list_all2 R [] (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops xs [])\n                          (plus_coeffs (coeffs x2) (coeffs y2))\n 3. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2) (coeffs y2))", "from 1(2)"], ["proof (chain)\npicking this:\n  list_all2 R (x1 # xs1) (coeffs X2)", "obtain x2 xs2 where X2: \"coeffs X2 = x2 # coeffs xs2\""], ["proof (prove)\nusing this:\n  list_all2 R (x1 # xs1) (coeffs X2)\n\ngoal (1 subgoal):\n 1. (\\<And>x2 xs2.\n        coeffs X2 = x2 # coeffs xs2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases X2, auto simp: cCons_def split: if_splits)"], ["proof (state)\nthis:\n  coeffs X2 = x2 # coeffs xs2\n\ngoal (3 subgoals):\n 1. \\<And>x xs y ys x2 y2.\n       \\<lbrakk>\\<And>x2 y2.\n                   \\<lbrakk>list_all2 R xs (coeffs x2);\n                    list_all2 R ys (coeffs y2)\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R (plus_poly_i ops xs ys)\n(plus_coeffs (coeffs x2) (coeffs y2));\n        list_all2 R (x # xs) (coeffs x2);\n        list_all2 R (y # ys) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops (x # xs) (y # ys))\n                          (plus_coeffs (coeffs x2) (coeffs y2))\n 2. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs (coeffs x2);\n        list_all2 R [] (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops xs [])\n                          (plus_coeffs (coeffs x2) (coeffs y2))\n 3. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2) (coeffs y2))", "from 1(3)"], ["proof (chain)\npicking this:\n  list_all2 R (y1 # ys1) (coeffs Y2)", "obtain y2 ys2 where Y2: \"coeffs Y2 = y2 # coeffs ys2\""], ["proof (prove)\nusing this:\n  list_all2 R (y1 # ys1) (coeffs Y2)\n\ngoal (1 subgoal):\n 1. (\\<And>y2 ys2.\n        coeffs Y2 = y2 # coeffs ys2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases Y2, auto simp: cCons_def split: if_splits)"], ["proof (state)\nthis:\n  coeffs Y2 = y2 # coeffs ys2\n\ngoal (3 subgoals):\n 1. \\<And>x xs y ys x2 y2.\n       \\<lbrakk>\\<And>x2 y2.\n                   \\<lbrakk>list_all2 R xs (coeffs x2);\n                    list_all2 R ys (coeffs y2)\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R (plus_poly_i ops xs ys)\n(plus_coeffs (coeffs x2) (coeffs y2));\n        list_all2 R (x # xs) (coeffs x2);\n        list_all2 R (y # ys) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops (x # xs) (y # ys))\n                          (plus_coeffs (coeffs x2) (coeffs y2))\n 2. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs (coeffs x2);\n        list_all2 R [] (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops xs [])\n                          (plus_coeffs (coeffs x2) (coeffs y2))\n 3. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2) (coeffs y2))", "from 1(2) 1(3)"], ["proof (chain)\npicking this:\n  list_all2 R (x1 # xs1) (coeffs X2)\n  list_all2 R (y1 # ys1) (coeffs Y2)", "have [transfer_rule]: \"R x1 x2\" \"R y1 y2\" \n      and *: \"list_all2 R xs1 (coeffs xs2)\" \"list_all2 R ys1 (coeffs ys2)\""], ["proof (prove)\nusing this:\n  list_all2 R (x1 # xs1) (coeffs X2)\n  list_all2 R (y1 # ys1) (coeffs Y2)\n\ngoal (1 subgoal):\n 1. (R x1 x2 &&& R y1 y2) &&&\n    list_all2 R xs1 (coeffs xs2) &&& list_all2 R ys1 (coeffs ys2)", "unfolding X2 Y2"], ["proof (prove)\nusing this:\n  list_all2 R (x1 # xs1) (x2 # coeffs xs2)\n  list_all2 R (y1 # ys1) (y2 # coeffs ys2)\n\ngoal (1 subgoal):\n 1. (R x1 x2 &&& R y1 y2) &&&\n    list_all2 R xs1 (coeffs xs2) &&& list_all2 R ys1 (coeffs ys2)", "by auto"], ["proof (state)\nthis:\n  R x1 x2\n  R y1 y2\n  list_all2 R xs1 (coeffs xs2)\n  list_all2 R ys1 (coeffs ys2)\n\ngoal (3 subgoals):\n 1. \\<And>x xs y ys x2 y2.\n       \\<lbrakk>\\<And>x2 y2.\n                   \\<lbrakk>list_all2 R xs (coeffs x2);\n                    list_all2 R ys (coeffs y2)\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R (plus_poly_i ops xs ys)\n(plus_coeffs (coeffs x2) (coeffs y2));\n        list_all2 R (x # xs) (coeffs x2);\n        list_all2 R (y # ys) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops (x # xs) (y # ys))\n                          (plus_coeffs (coeffs x2) (coeffs y2))\n 2. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs (coeffs x2);\n        list_all2 R [] (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops xs [])\n                          (plus_coeffs (coeffs x2) (coeffs y2))\n 3. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2) (coeffs y2))", "note [transfer_rule] = 1(1)[OF *]"], ["proof (state)\nthis:\n  list_all2 R (plus_poly_i ops xs1 ys1)\n   (plus_coeffs (coeffs xs2) (coeffs ys2))\n\ngoal (3 subgoals):\n 1. \\<And>x xs y ys x2 y2.\n       \\<lbrakk>\\<And>x2 y2.\n                   \\<lbrakk>list_all2 R xs (coeffs x2);\n                    list_all2 R ys (coeffs y2)\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R (plus_poly_i ops xs ys)\n(plus_coeffs (coeffs x2) (coeffs y2));\n        list_all2 R (x # xs) (coeffs x2);\n        list_all2 R (y # ys) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops (x # xs) (y # ys))\n                          (plus_coeffs (coeffs x2) (coeffs y2))\n 2. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs (coeffs x2);\n        list_all2 R [] (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops xs [])\n                          (plus_coeffs (coeffs x2) (coeffs y2))\n 3. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2) (coeffs y2))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R (plus_poly_i ops (x1 # xs1) (y1 # ys1))\n     (plus_coeffs (coeffs X2) (coeffs Y2))", "unfolding X2 Y2"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R (plus_poly_i ops (x1 # xs1) (y1 # ys1))\n     (plus_coeffs (x2 # coeffs xs2) (y2 # coeffs ys2))", "by simp transfer_prover"], ["proof (state)\nthis:\n  list_all2 R (plus_poly_i ops (x1 # xs1) (y1 # ys1))\n   (plus_coeffs (coeffs X2) (coeffs Y2))\n\ngoal (2 subgoals):\n 1. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs (coeffs x2);\n        list_all2 R [] (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops xs [])\n                          (plus_coeffs (coeffs x2) (coeffs y2))\n 2. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2) (coeffs y2))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs (coeffs x2);\n        list_all2 R [] (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops xs [])\n                          (plus_coeffs (coeffs x2) (coeffs y2))\n 2. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2) (coeffs y2))", "case (2 xs1 xs2 ys2)"], ["proof (state)\nthis:\n  list_all2 R xs1 (coeffs xs2)\n  list_all2 R [] (coeffs ys2)\n\ngoal (2 subgoals):\n 1. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs (coeffs x2);\n        list_all2 R [] (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops xs [])\n                          (plus_coeffs (coeffs x2) (coeffs y2))\n 2. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2) (coeffs y2))", "thus ?case"], ["proof (prove)\nusing this:\n  list_all2 R xs1 (coeffs xs2)\n  list_all2 R [] (coeffs ys2)\n\ngoal (1 subgoal):\n 1. list_all2 R (plus_poly_i ops xs1 [])\n     (plus_coeffs (coeffs xs2) (coeffs ys2))", "by (cases \"coeffs xs2\", auto)"], ["proof (state)\nthis:\n  list_all2 R (plus_poly_i ops xs1 [])\n   (plus_coeffs (coeffs xs2) (coeffs ys2))\n\ngoal (1 subgoal):\n 1. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2) (coeffs y2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2) (coeffs y2))", "case (3 xs2 y1 ys1 Y2)"], ["proof (state)\nthis:\n  list_all2 R [] (coeffs ys1)\n  list_all2 R (xs2 # y1) (coeffs Y2)\n\ngoal (1 subgoal):\n 1. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (plus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2) (coeffs y2))", "thus ?case"], ["proof (prove)\nusing this:\n  list_all2 R [] (coeffs ys1)\n  list_all2 R (xs2 # y1) (coeffs Y2)\n\ngoal (1 subgoal):\n 1. list_all2 R (plus_poly_i ops [] (xs2 # y1))\n     (plus_coeffs (coeffs ys1) (coeffs Y2))", "by (cases Y2, auto simp: cCons_def)"], ["proof (state)\nthis:\n  list_all2 R (plus_poly_i ops [] (xs2 # y1))\n   (plus_coeffs (coeffs ys1) (coeffs Y2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_rel (plus_poly_i ops x1 y1) (x2 + y2)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* unary minus *)"], ["", "lemma poly_rel_uminus[transfer_rule]: \"(poly_rel ===> poly_rel) (uminus_poly_i ops) Groups.uminus\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> poly_rel) (uminus_poly_i ops) uminus_class.uminus", "proof (intro rel_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow> poly_rel (uminus_poly_i ops x) (- y)", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow> poly_rel (uminus_poly_i ops x) (- y)", "assume \"poly_rel x y\""], ["proof (state)\nthis:\n  poly_rel x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow> poly_rel (uminus_poly_i ops x) (- y)", "hence [transfer_rule]: \"list_all2 R x (coeffs y)\""], ["proof (prove)\nusing this:\n  poly_rel x y\n\ngoal (1 subgoal):\n 1. list_all2 R x (coeffs y)", "unfolding poly_rel_def"], ["proof (prove)\nusing this:\n  list_all2 R x (coeffs y)\n\ngoal (1 subgoal):\n 1. list_all2 R x (coeffs y)", "."], ["proof (state)\nthis:\n  list_all2 R x (coeffs y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       poly_rel x y \\<Longrightarrow> poly_rel (uminus_poly_i ops x) (- y)", "show \"poly_rel (uminus_poly_i ops x) (-y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (uminus_poly_i ops x) (- y)", "unfolding poly_rel_def coeffs_uminus uminus_poly_i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R (map (arith_ops_record.uminus ops) x)\n     (map uminus_class.uminus (coeffs y))", "by transfer_prover"], ["proof (state)\nthis:\n  poly_rel (uminus_poly_i ops x) (- y)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* subtraction *)"], ["", "lemma poly_rel_minus[transfer_rule]: \"(poly_rel ===> poly_rel ===> poly_rel) (minus_poly_i ops) (-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> poly_rel ===> poly_rel) (minus_poly_i ops) (-)", "proof (intro rel_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>poly_rel x y; poly_rel xa ya\\<rbrakk>\n       \\<Longrightarrow> poly_rel (minus_poly_i ops x xa) (y - ya)", "fix x1 y1 x2 y2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>poly_rel x y; poly_rel xa ya\\<rbrakk>\n       \\<Longrightarrow> poly_rel (minus_poly_i ops x xa) (y - ya)", "assume \"poly_rel x1 x2\" and \"poly_rel y1 y2\""], ["proof (state)\nthis:\n  poly_rel x1 x2\n  poly_rel y1 y2\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>poly_rel x y; poly_rel xa ya\\<rbrakk>\n       \\<Longrightarrow> poly_rel (minus_poly_i ops x xa) (y - ya)", "thus \"poly_rel (minus_poly_i ops x1 y1) (x2 - y2)\""], ["proof (prove)\nusing this:\n  poly_rel x1 x2\n  poly_rel y1 y2\n\ngoal (1 subgoal):\n 1. poly_rel (minus_poly_i ops x1 y1) (x2 - y2)", "unfolding diff_conv_add_uminus"], ["proof (prove)\nusing this:\n  poly_rel x1 x2\n  poly_rel y1 y2\n\ngoal (1 subgoal):\n 1. poly_rel (minus_poly_i ops x1 y1) (x2 + - y2)", "unfolding poly_rel_def coeffs_eq_iff coeffs_plus_eq_plus_coeffs coeffs_uminus"], ["proof (prove)\nusing this:\n  list_all2 R x1 (coeffs x2)\n  list_all2 R y1 (coeffs y2)\n\ngoal (1 subgoal):\n 1. list_all2 R (minus_poly_i ops x1 y1)\n     (plus_coeffs (coeffs x2) (map uminus_class.uminus (coeffs y2)))", "proof (induct x1 y1 arbitrary: x2 y2 rule: minus_poly_i.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xs y ys x2 y2.\n       \\<lbrakk>\\<And>x2 y2.\n                   \\<lbrakk>list_all2 R xs (coeffs x2);\n                    list_all2 R ys (coeffs y2)\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R (minus_poly_i ops xs ys)\n(plus_coeffs (coeffs x2) (map uminus_class.uminus (coeffs y2)));\n        list_all2 R (x # xs) (coeffs x2);\n        list_all2 R (y # ys) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops (x # xs) (y # ys))\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))\n 2. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs (coeffs x2);\n        list_all2 R [] (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops xs [])\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))\n 3. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))", "case (1 x1 xs1 y1 ys1 X2 Y2)"], ["proof (state)\nthis:\n  \\<lbrakk>list_all2 R xs1 (coeffs ?x2.0);\n   list_all2 R ys1 (coeffs ?y2.0)\\<rbrakk>\n  \\<Longrightarrow> list_all2 R (minus_poly_i ops xs1 ys1)\n                     (plus_coeffs (coeffs ?x2.0)\n                       (map uminus_class.uminus (coeffs ?y2.0)))\n  list_all2 R (x1 # xs1) (coeffs X2)\n  list_all2 R (y1 # ys1) (coeffs Y2)\n\ngoal (3 subgoals):\n 1. \\<And>x xs y ys x2 y2.\n       \\<lbrakk>\\<And>x2 y2.\n                   \\<lbrakk>list_all2 R xs (coeffs x2);\n                    list_all2 R ys (coeffs y2)\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R (minus_poly_i ops xs ys)\n(plus_coeffs (coeffs x2) (map uminus_class.uminus (coeffs y2)));\n        list_all2 R (x # xs) (coeffs x2);\n        list_all2 R (y # ys) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops (x # xs) (y # ys))\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))\n 2. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs (coeffs x2);\n        list_all2 R [] (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops xs [])\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))\n 3. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))", "from 1(2)"], ["proof (chain)\npicking this:\n  list_all2 R (x1 # xs1) (coeffs X2)", "obtain x2 xs2 where X2: \"coeffs X2 = x2 # coeffs xs2\""], ["proof (prove)\nusing this:\n  list_all2 R (x1 # xs1) (coeffs X2)\n\ngoal (1 subgoal):\n 1. (\\<And>x2 xs2.\n        coeffs X2 = x2 # coeffs xs2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases X2, auto simp: cCons_def split: if_splits)"], ["proof (state)\nthis:\n  coeffs X2 = x2 # coeffs xs2\n\ngoal (3 subgoals):\n 1. \\<And>x xs y ys x2 y2.\n       \\<lbrakk>\\<And>x2 y2.\n                   \\<lbrakk>list_all2 R xs (coeffs x2);\n                    list_all2 R ys (coeffs y2)\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R (minus_poly_i ops xs ys)\n(plus_coeffs (coeffs x2) (map uminus_class.uminus (coeffs y2)));\n        list_all2 R (x # xs) (coeffs x2);\n        list_all2 R (y # ys) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops (x # xs) (y # ys))\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))\n 2. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs (coeffs x2);\n        list_all2 R [] (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops xs [])\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))\n 3. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))", "from 1(3)"], ["proof (chain)\npicking this:\n  list_all2 R (y1 # ys1) (coeffs Y2)", "obtain y2 ys2 where Y2: \"coeffs Y2 = y2 # coeffs ys2\""], ["proof (prove)\nusing this:\n  list_all2 R (y1 # ys1) (coeffs Y2)\n\ngoal (1 subgoal):\n 1. (\\<And>y2 ys2.\n        coeffs Y2 = y2 # coeffs ys2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases Y2, auto simp: cCons_def split: if_splits)"], ["proof (state)\nthis:\n  coeffs Y2 = y2 # coeffs ys2\n\ngoal (3 subgoals):\n 1. \\<And>x xs y ys x2 y2.\n       \\<lbrakk>\\<And>x2 y2.\n                   \\<lbrakk>list_all2 R xs (coeffs x2);\n                    list_all2 R ys (coeffs y2)\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R (minus_poly_i ops xs ys)\n(plus_coeffs (coeffs x2) (map uminus_class.uminus (coeffs y2)));\n        list_all2 R (x # xs) (coeffs x2);\n        list_all2 R (y # ys) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops (x # xs) (y # ys))\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))\n 2. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs (coeffs x2);\n        list_all2 R [] (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops xs [])\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))\n 3. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))", "from 1(2) 1(3)"], ["proof (chain)\npicking this:\n  list_all2 R (x1 # xs1) (coeffs X2)\n  list_all2 R (y1 # ys1) (coeffs Y2)", "have [transfer_rule]: \"R x1 x2\" \"R y1 y2\" \n      and *: \"list_all2 R xs1 (coeffs xs2)\" \"list_all2 R ys1 (coeffs ys2)\""], ["proof (prove)\nusing this:\n  list_all2 R (x1 # xs1) (coeffs X2)\n  list_all2 R (y1 # ys1) (coeffs Y2)\n\ngoal (1 subgoal):\n 1. (R x1 x2 &&& R y1 y2) &&&\n    list_all2 R xs1 (coeffs xs2) &&& list_all2 R ys1 (coeffs ys2)", "unfolding X2 Y2"], ["proof (prove)\nusing this:\n  list_all2 R (x1 # xs1) (x2 # coeffs xs2)\n  list_all2 R (y1 # ys1) (y2 # coeffs ys2)\n\ngoal (1 subgoal):\n 1. (R x1 x2 &&& R y1 y2) &&&\n    list_all2 R xs1 (coeffs xs2) &&& list_all2 R ys1 (coeffs ys2)", "by auto"], ["proof (state)\nthis:\n  R x1 x2\n  R y1 y2\n  list_all2 R xs1 (coeffs xs2)\n  list_all2 R ys1 (coeffs ys2)\n\ngoal (3 subgoals):\n 1. \\<And>x xs y ys x2 y2.\n       \\<lbrakk>\\<And>x2 y2.\n                   \\<lbrakk>list_all2 R xs (coeffs x2);\n                    list_all2 R ys (coeffs y2)\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R (minus_poly_i ops xs ys)\n(plus_coeffs (coeffs x2) (map uminus_class.uminus (coeffs y2)));\n        list_all2 R (x # xs) (coeffs x2);\n        list_all2 R (y # ys) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops (x # xs) (y # ys))\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))\n 2. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs (coeffs x2);\n        list_all2 R [] (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops xs [])\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))\n 3. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))", "note [transfer_rule] = 1(1)[OF *]"], ["proof (state)\nthis:\n  list_all2 R (minus_poly_i ops xs1 ys1)\n   (plus_coeffs (coeffs xs2) (map uminus_class.uminus (coeffs ys2)))\n\ngoal (3 subgoals):\n 1. \\<And>x xs y ys x2 y2.\n       \\<lbrakk>\\<And>x2 y2.\n                   \\<lbrakk>list_all2 R xs (coeffs x2);\n                    list_all2 R ys (coeffs y2)\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R (minus_poly_i ops xs ys)\n(plus_coeffs (coeffs x2) (map uminus_class.uminus (coeffs y2)));\n        list_all2 R (x # xs) (coeffs x2);\n        list_all2 R (y # ys) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops (x # xs) (y # ys))\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))\n 2. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs (coeffs x2);\n        list_all2 R [] (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops xs [])\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))\n 3. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R (minus_poly_i ops (x1 # xs1) (y1 # ys1))\n     (plus_coeffs (coeffs X2) (map uminus_class.uminus (coeffs Y2)))", "unfolding X2 Y2"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R (minus_poly_i ops (x1 # xs1) (y1 # ys1))\n     (plus_coeffs (x2 # coeffs xs2)\n       (map uminus_class.uminus (y2 # coeffs ys2)))", "by simp transfer_prover"], ["proof (state)\nthis:\n  list_all2 R (minus_poly_i ops (x1 # xs1) (y1 # ys1))\n   (plus_coeffs (coeffs X2) (map uminus_class.uminus (coeffs Y2)))\n\ngoal (2 subgoals):\n 1. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs (coeffs x2);\n        list_all2 R [] (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops xs [])\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))\n 2. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs (coeffs x2);\n        list_all2 R [] (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops xs [])\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))\n 2. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))", "case (2 xs1 xs2 ys2)"], ["proof (state)\nthis:\n  list_all2 R xs1 (coeffs xs2)\n  list_all2 R [] (coeffs ys2)\n\ngoal (2 subgoals):\n 1. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs (coeffs x2);\n        list_all2 R [] (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops xs [])\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))\n 2. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))", "thus ?case"], ["proof (prove)\nusing this:\n  list_all2 R xs1 (coeffs xs2)\n  list_all2 R [] (coeffs ys2)\n\ngoal (1 subgoal):\n 1. list_all2 R (minus_poly_i ops xs1 [])\n     (plus_coeffs (coeffs xs2) (map uminus_class.uminus (coeffs ys2)))", "by (cases \"coeffs xs2\", auto)"], ["proof (state)\nthis:\n  list_all2 R (minus_poly_i ops xs1 [])\n   (plus_coeffs (coeffs xs2) (map uminus_class.uminus (coeffs ys2)))\n\ngoal (1 subgoal):\n 1. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))", "case (3 xs2 y1 ys1 Y2)"], ["proof (state)\nthis:\n  list_all2 R [] (coeffs ys1)\n  list_all2 R (xs2 # y1) (coeffs Y2)\n\ngoal (1 subgoal):\n 1. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))", "from 3(1)"], ["proof (chain)\npicking this:\n  list_all2 R [] (coeffs ys1)", "have id0: \"coeffs ys1 = coeffs 0\""], ["proof (prove)\nusing this:\n  list_all2 R [] (coeffs ys1)\n\ngoal (1 subgoal):\n 1. coeffs ys1 = coeffs 0", "by (cases ys1, auto)"], ["proof (state)\nthis:\n  coeffs ys1 = coeffs 0\n\ngoal (1 subgoal):\n 1. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))", "have id1: \"minus_poly_i ops [] (xs2 # y1) = uminus_poly_i ops (xs2 # y1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minus_poly_i ops [] (xs2 # y1) = uminus_poly_i ops (xs2 # y1)", "by simp"], ["proof (state)\nthis:\n  minus_poly_i ops [] (xs2 # y1) = uminus_poly_i ops (xs2 # y1)\n\ngoal (1 subgoal):\n 1. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))", "from 3(2)"], ["proof (chain)\npicking this:\n  list_all2 R (xs2 # y1) (coeffs Y2)", "have [transfer_rule]: \"poly_rel (xs2 # y1) Y2\""], ["proof (prove)\nusing this:\n  list_all2 R (xs2 # y1) (coeffs Y2)\n\ngoal (1 subgoal):\n 1. poly_rel (xs2 # y1) Y2", "unfolding poly_rel_def"], ["proof (prove)\nusing this:\n  list_all2 R (xs2 # y1) (coeffs Y2)\n\ngoal (1 subgoal):\n 1. list_all2 R (xs2 # y1) (coeffs Y2)", "by simp"], ["proof (state)\nthis:\n  poly_rel (xs2 # y1) Y2\n\ngoal (1 subgoal):\n 1. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] (coeffs x2);\n        list_all2 R (v # va) (coeffs y2)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_i ops [] (v # va))\n                          (plus_coeffs (coeffs x2)\n                            (map uminus_class.uminus (coeffs y2)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R (minus_poly_i ops [] (xs2 # y1))\n     (plus_coeffs (coeffs ys1) (map uminus_class.uminus (coeffs Y2)))", "unfolding id0 id1 coeffs_uminus[symmetric] coeffs_plus_eq_plus_coeffs[symmetric]\n      poly_rel_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (uminus_poly_i ops (xs2 # y1)) (0 + - Y2)", "by simp transfer_prover"], ["proof (state)\nthis:\n  list_all2 R (minus_poly_i ops [] (xs2 # y1))\n   (plus_coeffs (coeffs ys1) (map uminus_class.uminus (coeffs Y2)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_rel (minus_poly_i ops x1 y1) (x2 - y2)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* smult *)"], ["", "lemma poly_rel_smult[transfer_rule]: \"(R ===> poly_rel ===> poly_rel) (smult_i ops) smult\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (R ===> poly_rel ===> poly_rel) (smult_i ops) smult", "unfolding rel_fun_def poly_rel_def coeffs_smult' smult_i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       R x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           list_all2 R xa (coeffs ya) \\<longrightarrow>\n           list_all2 R\n            (if x = arith_ops_record.zero ops then []\n             else strip_while ((=) (arith_ops_record.zero ops))\n                   (map (arith_ops_record.times ops x) xa))\n            (if y = (0::'a) then []\n             else strip_while ((=) (0::'a)) (map ((*) y) (coeffs ya))))", "proof (intro allI impI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>R x y; list_all2 R xa (coeffs ya)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R\n                          (if x = arith_ops_record.zero ops then []\n                           else strip_while\n                                 ((=) (arith_ops_record.zero ops))\n                                 (map (arith_ops_record.times ops x) xa))\n                          (if y = (0::'a) then []\n                           else strip_while ((=) (0::'a))\n                                 (map ((*) y) (coeffs ya)))", "case (1 x y xs ys)"], ["proof (state)\nthis:\n  R x y\n  list_all2 R xs (coeffs ys)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>R x y; list_all2 R xa (coeffs ya)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R\n                          (if x = arith_ops_record.zero ops then []\n                           else strip_while\n                                 ((=) (arith_ops_record.zero ops))\n                                 (map (arith_ops_record.times ops x) xa))\n                          (if y = (0::'a) then []\n                           else strip_while ((=) (0::'a))\n                                 (map ((*) y) (coeffs ya)))", "note [transfer_rule] = 1"], ["proof (state)\nthis:\n  R x y\n  list_all2 R xs (coeffs ys)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>R x y; list_all2 R xa (coeffs ya)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R\n                          (if x = arith_ops_record.zero ops then []\n                           else strip_while\n                                 ((=) (arith_ops_record.zero ops))\n                                 (map (arith_ops_record.times ops x) xa))\n                          (if y = (0::'a) then []\n                           else strip_while ((=) (0::'a))\n                                 (map ((*) y) (coeffs ya)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R\n     (if x = arith_ops_record.zero ops then []\n      else strip_while ((=) (arith_ops_record.zero ops))\n            (map (arith_ops_record.times ops x) xs))\n     (if y = (0::'a) then []\n      else strip_while ((=) (0::'a)) (map ((*) y) (coeffs ys)))", "by transfer_prover"], ["proof (state)\nthis:\n  list_all2 R\n   (if x = arith_ops_record.zero ops then []\n    else strip_while ((=) (arith_ops_record.zero ops))\n          (map (arith_ops_record.times ops x) xs))\n   (if y = (0::'a) then []\n    else strip_while ((=) (0::'a)) (map ((*) y) (coeffs ys)))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* coeffs *)"], ["", "lemma poly_rel_coeffs[transfer_rule]: \"(poly_rel ===> list_all2 R) (\\<lambda> x. x) coeffs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> list_all2 R) (\\<lambda>x. x) coeffs", "unfolding rel_fun_def poly_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       list_all2 R x (coeffs y) \\<longrightarrow> list_all2 R x (coeffs y)", "by auto"], ["", "(* poly_of_list *)"], ["", "lemma poly_rel_poly_of_list[transfer_rule]: \"(list_all2 R ===> poly_rel) (poly_of_list_i ops) poly_of_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_all2 R ===> poly_rel) (poly_of_list_i ops) poly_of_list", "unfolding rel_fun_def poly_of_list_i_def poly_rel_def poly_of_list_impl"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       list_all2 R x y \\<longrightarrow>\n       list_all2 R (strip_while ((=) (arith_ops_record.zero ops)) x)\n        (strip_while ((=) (0::'a)) y)", "proof (intro allI impI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       list_all2 R x y \\<Longrightarrow>\n       list_all2 R (strip_while ((=) (arith_ops_record.zero ops)) x)\n        (strip_while ((=) (0::'a)) y)", "case (1 x y)"], ["proof (state)\nthis:\n  list_all2 R x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       list_all2 R x y \\<Longrightarrow>\n       list_all2 R (strip_while ((=) (arith_ops_record.zero ops)) x)\n        (strip_while ((=) (0::'a)) y)", "note [transfer_rule] = this"], ["proof (state)\nthis:\n  list_all2 R x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       list_all2 R x y \\<Longrightarrow>\n       list_all2 R (strip_while ((=) (arith_ops_record.zero ops)) x)\n        (strip_while ((=) (0::'a)) y)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R (strip_while ((=) (arith_ops_record.zero ops)) x)\n     (strip_while ((=) (0::'a)) y)", "by transfer_prover"], ["proof (state)\nthis:\n  list_all2 R (strip_while ((=) (arith_ops_record.zero ops)) x)\n   (strip_while ((=) (0::'a)) y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_rel_monom_mult[transfer_rule]: \n  \"((=) ===> poly_rel ===> poly_rel) (monom_mult_i ops) monom_mult\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> poly_rel ===> poly_rel) (monom_mult_i ops) monom_mult", "unfolding rel_fun_def monom_mult_i_def poly_rel_def monom_mult_code Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x = y \\<longrightarrow>\n       (\\<forall>xa ya.\n           list_all2 R xa (coeffs ya) \\<longrightarrow>\n           list_all2 R\n            (if xa = [] then xa\n             else replicate x (arith_ops_record.zero ops) @ xa)\n            (if coeffs ya = [] then coeffs ya\n             else replicate y (0::'a) @ coeffs ya))", "proof (auto, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa y.\n       \\<lbrakk>xa \\<noteq> []; y \\<noteq> 0;\n        list_all2 R xa (coeffs y)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R\n                          (replicate x (arith_ops_record.zero ops) @ xa)\n                          (replicate x (0::'a) @ coeffs y)", "case (1 x xs y)"], ["proof (state)\nthis:\n  xs \\<noteq> []\n  y \\<noteq> 0\n  list_all2 R xs (coeffs y)\n\ngoal (1 subgoal):\n 1. \\<And>x xa y.\n       \\<lbrakk>xa \\<noteq> []; y \\<noteq> 0;\n        list_all2 R xa (coeffs y)\\<rbrakk>\n       \\<Longrightarrow> list_all2 R\n                          (replicate x (arith_ops_record.zero ops) @ xa)\n                          (replicate x (0::'a) @ coeffs y)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R (replicate x (arith_ops_record.zero ops) @ xs)\n     (replicate x (0::'a) @ coeffs y)", "by (induct x, auto simp: 1(3) zero)"], ["proof (state)\nthis:\n  list_all2 R (replicate x (arith_ops_record.zero ops) @ xs)\n   (replicate x (0::'a) @ coeffs y)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare karatsuba_main_i.simps[simp del]"], ["", "lemma list_rel_coeffs_minus_i: assumes \"list_all2 R x1 x2\" \"list_all2 R y1 y2\" \n  shows \"list_all2 R (coeffs_minus_i ops x1 y1) (coeffs_minus x2 y2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R (coeffs_minus_i ops x1 y1) (coeffs_minus x2 y2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all2 R (coeffs_minus_i ops x1 y1) (coeffs_minus x2 y2)", "note simps = coeffs_minus_i.simps coeffs_minus.simps"], ["proof (state)\nthis:\n  coeffs_minus_i ?ops (?x # ?xs) (?y # ?ys) =\n  arith_ops_record.minus ?ops ?x ?y # coeffs_minus_i ?ops ?xs ?ys\n  coeffs_minus_i ?ops ?xs [] = ?xs\n  coeffs_minus_i ?ops [] (?v # ?va) =\n  map (arith_ops_record.uminus ?ops) (?v # ?va)\n  coeffs_minus (?x # ?xs) (?y # ?ys) = (?x - ?y) # coeffs_minus ?xs ?ys\n  coeffs_minus ?xs [] = ?xs\n  coeffs_minus [] (?v # ?va) = map uminus_class.uminus (?v # ?va)\n\ngoal (1 subgoal):\n 1. list_all2 R (coeffs_minus_i ops x1 y1) (coeffs_minus x2 y2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R (coeffs_minus_i ops x1 y1) (coeffs_minus x2 y2)", "using assms"], ["proof (prove)\nusing this:\n  list_all2 R x1 x2\n  list_all2 R y1 y2\n\ngoal (1 subgoal):\n 1. list_all2 R (coeffs_minus_i ops x1 y1) (coeffs_minus x2 y2)", "proof (induct x1 y1 arbitrary: x2 y2 rule: coeffs_minus_i.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xs y ys x2 y2.\n       \\<lbrakk>\\<And>x2 y2.\n                   \\<lbrakk>list_all2 R xs x2; list_all2 R ys y2\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R (coeffs_minus_i ops xs ys)\n(coeffs_minus x2 y2);\n        list_all2 R (x # xs) x2; list_all2 R (y # ys) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops (x # xs) (y # ys))\n                          (coeffs_minus x2 y2)\n 2. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs x2; list_all2 R [] y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops xs [])\n                          (coeffs_minus x2 y2)\n 3. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] x2; list_all2 R (v # va) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops [] (v # va))\n                          (coeffs_minus x2 y2)", "case (1 x xs y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>list_all2 R xs ?x2.0; list_all2 R ys ?y2.0\\<rbrakk>\n  \\<Longrightarrow> list_all2 R (coeffs_minus_i ops xs ys)\n                     (coeffs_minus ?x2.0 ?y2.0)\n  list_all2 R (x # xs) x2\n  list_all2 R (y # ys) y2\n\ngoal (3 subgoals):\n 1. \\<And>x xs y ys x2 y2.\n       \\<lbrakk>\\<And>x2 y2.\n                   \\<lbrakk>list_all2 R xs x2; list_all2 R ys y2\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R (coeffs_minus_i ops xs ys)\n(coeffs_minus x2 y2);\n        list_all2 R (x # xs) x2; list_all2 R (y # ys) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops (x # xs) (y # ys))\n                          (coeffs_minus x2 y2)\n 2. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs x2; list_all2 R [] y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops xs [])\n                          (coeffs_minus x2 y2)\n 3. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] x2; list_all2 R (v # va) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops [] (v # va))\n                          (coeffs_minus x2 y2)", "from 1(2-)"], ["proof (chain)\npicking this:\n  list_all2 R (x # xs) x2\n  list_all2 R (y # ys) y2", "obtain Y Ys where y2: \"y2 = Y # Ys\""], ["proof (prove)\nusing this:\n  list_all2 R (x # xs) x2\n  list_all2 R (y # ys) y2\n\ngoal (1 subgoal):\n 1. (\\<And>Y Ys. y2 = Y # Ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding list_all2_conv_all_nth"], ["proof (prove)\nusing this:\n  length (x # xs) = length x2 \\<and>\n  (\\<forall>i<length (x # xs). R ((x # xs) ! i) (x2 ! i))\n  length (y # ys) = length y2 \\<and>\n  (\\<forall>i<length (y # ys). R ((y # ys) ! i) (y2 ! i))\n\ngoal (1 subgoal):\n 1. (\\<And>Y Ys. y2 = Y # Ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases y2, auto)"], ["proof (state)\nthis:\n  y2 = Y # Ys\n\ngoal (3 subgoals):\n 1. \\<And>x xs y ys x2 y2.\n       \\<lbrakk>\\<And>x2 y2.\n                   \\<lbrakk>list_all2 R xs x2; list_all2 R ys y2\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R (coeffs_minus_i ops xs ys)\n(coeffs_minus x2 y2);\n        list_all2 R (x # xs) x2; list_all2 R (y # ys) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops (x # xs) (y # ys))\n                          (coeffs_minus x2 y2)\n 2. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs x2; list_all2 R [] y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops xs [])\n                          (coeffs_minus x2 y2)\n 3. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] x2; list_all2 R (v # va) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops [] (v # va))\n                          (coeffs_minus x2 y2)", "with 1(2-)"], ["proof (chain)\npicking this:\n  list_all2 R (x # xs) x2\n  list_all2 R (y # ys) y2\n  y2 = Y # Ys", "have y: \"R y Y\" \"list_all2 R ys Ys\""], ["proof (prove)\nusing this:\n  list_all2 R (x # xs) x2\n  list_all2 R (y # ys) y2\n  y2 = Y # Ys\n\ngoal (1 subgoal):\n 1. R y Y &&& list_all2 R ys Ys", "by auto"], ["proof (state)\nthis:\n  R y Y\n  list_all2 R ys Ys\n\ngoal (3 subgoals):\n 1. \\<And>x xs y ys x2 y2.\n       \\<lbrakk>\\<And>x2 y2.\n                   \\<lbrakk>list_all2 R xs x2; list_all2 R ys y2\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R (coeffs_minus_i ops xs ys)\n(coeffs_minus x2 y2);\n        list_all2 R (x # xs) x2; list_all2 R (y # ys) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops (x # xs) (y # ys))\n                          (coeffs_minus x2 y2)\n 2. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs x2; list_all2 R [] y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops xs [])\n                          (coeffs_minus x2 y2)\n 3. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] x2; list_all2 R (v # va) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops [] (v # va))\n                          (coeffs_minus x2 y2)", "from 1(2-)"], ["proof (chain)\npicking this:\n  list_all2 R (x # xs) x2\n  list_all2 R (y # ys) y2", "obtain X Xs where x2: \"x2 = X # Xs\""], ["proof (prove)\nusing this:\n  list_all2 R (x # xs) x2\n  list_all2 R (y # ys) y2\n\ngoal (1 subgoal):\n 1. (\\<And>X Xs. x2 = X # Xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding list_all2_conv_all_nth"], ["proof (prove)\nusing this:\n  length (x # xs) = length x2 \\<and>\n  (\\<forall>i<length (x # xs). R ((x # xs) ! i) (x2 ! i))\n  length (y # ys) = length y2 \\<and>\n  (\\<forall>i<length (y # ys). R ((y # ys) ! i) (y2 ! i))\n\ngoal (1 subgoal):\n 1. (\\<And>X Xs. x2 = X # Xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases x2, auto)"], ["proof (state)\nthis:\n  x2 = X # Xs\n\ngoal (3 subgoals):\n 1. \\<And>x xs y ys x2 y2.\n       \\<lbrakk>\\<And>x2 y2.\n                   \\<lbrakk>list_all2 R xs x2; list_all2 R ys y2\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R (coeffs_minus_i ops xs ys)\n(coeffs_minus x2 y2);\n        list_all2 R (x # xs) x2; list_all2 R (y # ys) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops (x # xs) (y # ys))\n                          (coeffs_minus x2 y2)\n 2. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs x2; list_all2 R [] y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops xs [])\n                          (coeffs_minus x2 y2)\n 3. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] x2; list_all2 R (v # va) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops [] (v # va))\n                          (coeffs_minus x2 y2)", "with 1(2-)"], ["proof (chain)\npicking this:\n  list_all2 R (x # xs) x2\n  list_all2 R (y # ys) y2\n  x2 = X # Xs", "have x: \"R x X\" \"list_all2 R xs Xs\""], ["proof (prove)\nusing this:\n  list_all2 R (x # xs) x2\n  list_all2 R (y # ys) y2\n  x2 = X # Xs\n\ngoal (1 subgoal):\n 1. R x X &&& list_all2 R xs Xs", "by auto"], ["proof (state)\nthis:\n  R x X\n  list_all2 R xs Xs\n\ngoal (3 subgoals):\n 1. \\<And>x xs y ys x2 y2.\n       \\<lbrakk>\\<And>x2 y2.\n                   \\<lbrakk>list_all2 R xs x2; list_all2 R ys y2\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R (coeffs_minus_i ops xs ys)\n(coeffs_minus x2 y2);\n        list_all2 R (x # xs) x2; list_all2 R (y # ys) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops (x # xs) (y # ys))\n                          (coeffs_minus x2 y2)\n 2. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs x2; list_all2 R [] y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops xs [])\n                          (coeffs_minus x2 y2)\n 3. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] x2; list_all2 R (v # va) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops [] (v # va))\n                          (coeffs_minus x2 y2)", "from 1(1)[OF x(2) y(2)] x(1) y(1)"], ["proof (chain)\npicking this:\n  list_all2 R (coeffs_minus_i ops xs ys) (coeffs_minus Xs Ys)\n  R x X\n  R y Y", "show ?case"], ["proof (prove)\nusing this:\n  list_all2 R (coeffs_minus_i ops xs ys) (coeffs_minus Xs Ys)\n  R x X\n  R y Y\n\ngoal (1 subgoal):\n 1. list_all2 R (coeffs_minus_i ops (x # xs) (y # ys)) (coeffs_minus x2 y2)", "unfolding x2 y2 simps"], ["proof (prove)\nusing this:\n  list_all2 R (coeffs_minus_i ops xs ys) (coeffs_minus Xs Ys)\n  R x X\n  R y Y\n\ngoal (1 subgoal):\n 1. list_all2 R (arith_ops_record.minus ops x y # coeffs_minus_i ops xs ys)\n     ((X - Y) # coeffs_minus Xs Ys)", "using minus[unfolded rel_fun_def]"], ["proof (prove)\nusing this:\n  list_all2 R (coeffs_minus_i ops xs ys) (coeffs_minus Xs Ys)\n  R x X\n  R y Y\n  \\<forall>x y.\n     R x y \\<longrightarrow>\n     (\\<forall>xa ya.\n         R xa ya \\<longrightarrow>\n         R (arith_ops_record.minus ops x xa) (y - ya))\n\ngoal (1 subgoal):\n 1. list_all2 R (arith_ops_record.minus ops x y # coeffs_minus_i ops xs ys)\n     ((X - Y) # coeffs_minus Xs Ys)", "by auto"], ["proof (state)\nthis:\n  list_all2 R (coeffs_minus_i ops (x # xs) (y # ys)) (coeffs_minus x2 y2)\n\ngoal (2 subgoals):\n 1. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs x2; list_all2 R [] y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops xs [])\n                          (coeffs_minus x2 y2)\n 2. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] x2; list_all2 R (v # va) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops [] (v # va))\n                          (coeffs_minus x2 y2)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs x2; list_all2 R [] y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops xs [])\n                          (coeffs_minus x2 y2)\n 2. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] x2; list_all2 R (v # va) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops [] (v # va))\n                          (coeffs_minus x2 y2)", "case (3 y ys)"], ["proof (state)\nthis:\n  list_all2 R [] x2\n  list_all2 R (y # ys) y2\n\ngoal (2 subgoals):\n 1. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs x2; list_all2 R [] y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops xs [])\n                          (coeffs_minus x2 y2)\n 2. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] x2; list_all2 R (v # va) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops [] (v # va))\n                          (coeffs_minus x2 y2)", "from 3"], ["proof (chain)\npicking this:\n  list_all2 R [] x2\n  list_all2 R (y # ys) y2", "have x2: \"x2 = []\""], ["proof (prove)\nusing this:\n  list_all2 R [] x2\n  list_all2 R (y # ys) y2\n\ngoal (1 subgoal):\n 1. x2 = []", "by auto"], ["proof (state)\nthis:\n  x2 = []\n\ngoal (2 subgoals):\n 1. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs x2; list_all2 R [] y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops xs [])\n                          (coeffs_minus x2 y2)\n 2. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] x2; list_all2 R (v # va) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops [] (v # va))\n                          (coeffs_minus x2 y2)", "from 3"], ["proof (chain)\npicking this:\n  list_all2 R [] x2\n  list_all2 R (y # ys) y2", "obtain Y Ys where y2: \"y2 = Y # Ys\""], ["proof (prove)\nusing this:\n  list_all2 R [] x2\n  list_all2 R (y # ys) y2\n\ngoal (1 subgoal):\n 1. (\\<And>Y Ys. y2 = Y # Ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding list_all2_conv_all_nth"], ["proof (prove)\nusing this:\n  length [] = length x2 \\<and> (\\<forall>i<length []. R ([] ! i) (x2 ! i))\n  length (y # ys) = length y2 \\<and>\n  (\\<forall>i<length (y # ys). R ((y # ys) ! i) (y2 ! i))\n\ngoal (1 subgoal):\n 1. (\\<And>Y Ys. y2 = Y # Ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases y2, auto)"], ["proof (state)\nthis:\n  y2 = Y # Ys\n\ngoal (2 subgoals):\n 1. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs x2; list_all2 R [] y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops xs [])\n                          (coeffs_minus x2 y2)\n 2. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] x2; list_all2 R (v # va) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops [] (v # va))\n                          (coeffs_minus x2 y2)", "obtain y1 where y1: \"y # ys = y1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y1. y # ys = y1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y # ys = y1\n\ngoal (2 subgoals):\n 1. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs x2; list_all2 R [] y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops xs [])\n                          (coeffs_minus x2 y2)\n 2. \\<And>v va x2 y2.\n       \\<lbrakk>list_all2 R [] x2; list_all2 R (v # va) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops [] (v # va))\n                          (coeffs_minus x2 y2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R (coeffs_minus_i ops [] (y # ys)) (coeffs_minus x2 y2)", "unfolding y2 simps x2"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R (map (arith_ops_record.uminus ops) (y # ys))\n     (map uminus_class.uminus (Y # Ys))", "unfolding y2[symmetric] list_all2_map2 list_all2_map1"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>x y. R (arith_ops_record.uminus ops x) (- y))\n     (y # ys) y2", "using 3(2)"], ["proof (prove)\nusing this:\n  list_all2 R (y # ys) y2\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>x y. R (arith_ops_record.uminus ops x) (- y))\n     (y # ys) y2", "unfolding y1"], ["proof (prove)\nusing this:\n  list_all2 R y1 y2\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>x y. R (arith_ops_record.uminus ops x) (- y)) y1 y2", "using uminus[unfolded rel_fun_def]"], ["proof (prove)\nusing this:\n  list_all2 R y1 y2\n  \\<forall>x y.\n     R x y \\<longrightarrow> R (arith_ops_record.uminus ops x) (- y)\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>x y. R (arith_ops_record.uminus ops x) (- y)) y1 y2", "unfolding list_all2_conv_all_nth"], ["proof (prove)\nusing this:\n  length y1 = length y2 \\<and> (\\<forall>i<length y1. R (y1 ! i) (y2 ! i))\n  \\<forall>x y.\n     R x y \\<longrightarrow> R (arith_ops_record.uminus ops x) (- y)\n\ngoal (1 subgoal):\n 1. length y1 = length y2 \\<and>\n    (\\<forall>i<length y1.\n        R (arith_ops_record.uminus ops (y1 ! i)) (- y2 ! i))", "by auto"], ["proof (state)\nthis:\n  list_all2 R (coeffs_minus_i ops [] (y # ys)) (coeffs_minus x2 y2)\n\ngoal (1 subgoal):\n 1. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs x2; list_all2 R [] y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (coeffs_minus_i ops xs [])\n                          (coeffs_minus x2 y2)", "qed auto"], ["proof (state)\nthis:\n  list_all2 R (coeffs_minus_i ops x1 y1) (coeffs_minus x2 y2)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* multiplication *)"], ["", "lemma poly_rel_karatsuba_main: \"list_all2 R x1 x2 \\<Longrightarrow> list_all2 R y1 y2 \\<Longrightarrow>\n  poly_rel (karatsuba_main_i ops x1 n y1 m) (karatsuba_main x2 n y2 m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all2 R x1 x2; list_all2 R y1 y2\\<rbrakk>\n    \\<Longrightarrow> poly_rel (karatsuba_main_i ops x1 n y1 m)\n                       (karatsuba_main x2 n y2 m)", "proof (induct n arbitrary: x1 y1 x2 y2 m rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x1 y1 x2 y2 m.\n       \\<lbrakk>\\<And>y x1 y1 x2 y2 m.\n                   \\<lbrakk>y < x; list_all2 R x1 x2;\n                    list_all2 R y1 y2\\<rbrakk>\n                   \\<Longrightarrow> poly_rel\n(karatsuba_main_i ops x1 y y1 m) (karatsuba_main x2 y y2 m);\n        list_all2 R x1 x2; list_all2 R y1 y2\\<rbrakk>\n       \\<Longrightarrow> poly_rel (karatsuba_main_i ops x1 x y1 m)\n                          (karatsuba_main x2 x y2 m)", "case (less n f g F G m)"], ["proof (state)\nthis:\n  \\<lbrakk>?y < n; list_all2 R ?x1.0 ?x2.0; list_all2 R ?y1.0 ?y2.0\\<rbrakk>\n  \\<Longrightarrow> poly_rel (karatsuba_main_i ops ?x1.0 ?y ?y1.0 ?m)\n                     (karatsuba_main ?x2.0 ?y ?y2.0 ?m)\n  list_all2 R f F\n  list_all2 R g G\n\ngoal (1 subgoal):\n 1. \\<And>x x1 y1 x2 y2 m.\n       \\<lbrakk>\\<And>y x1 y1 x2 y2 m.\n                   \\<lbrakk>y < x; list_all2 R x1 x2;\n                    list_all2 R y1 y2\\<rbrakk>\n                   \\<Longrightarrow> poly_rel\n(karatsuba_main_i ops x1 y y1 m) (karatsuba_main x2 y y2 m);\n        list_all2 R x1 x2; list_all2 R y1 y2\\<rbrakk>\n       \\<Longrightarrow> poly_rel (karatsuba_main_i ops x1 x y1 m)\n                          (karatsuba_main x2 x y2 m)", "note simp[simp] = karatsuba_main.simps[of F n G m] karatsuba_main_i.simps[of ops f n g m]"], ["proof (state)\nthis:\n  karatsuba_main F n G m =\n  (if n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound\n   then let ff = poly_of_list F\n        in foldr (\\<lambda>a p. smult a ff + pCons (0::'a) p) G 0\n   else let n2 = n div 2\n        in if n2 < m\n           then case split_at n2 F of\n                (f0, f1) \\<Rightarrow>\n                  case split_at n2 G of\n                  (g0, g1) \\<Rightarrow>\n                    let p1 = karatsuba_main f1 (n - n2) g1 (m - n2);\n                        p2 = karatsuba_main (coeffs_minus f1 f0) n2\n                              (coeffs_minus g1 g0) n2;\n                        p3 = karatsuba_main f0 n2 g0 n2\n                    in monom_mult (n2 + n2) p1 +\n                       (monom_mult n2 (p1 - p2 + p3) + p3)\n           else case split_at n2 F of\n                (f0, f1) \\<Rightarrow>\n                  let p1 = karatsuba_main f1 (n - n2) G m\n                  in Let (karatsuba_main f0 n2 G m)\n                      ((+) (monom_mult n2 p1)))\n  karatsuba_main_i ops f n g m =\n  (if n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound\n   then let ff = poly_of_list_i ops f\n        in foldr\n            (\\<lambda>a p.\n                plus_poly_i ops (smult_i ops a ff)\n                 (cCons_i ops (arith_ops_record.zero ops) p))\n            g []\n   else let n2 = n div 2\n        in if n2 < m\n           then case split_at n2 f of\n                (f0, f1) \\<Rightarrow>\n                  case split_at n2 g of\n                  (g0, g1) \\<Rightarrow>\n                    let p1 = karatsuba_main_i ops f1 (n - n2) g1 (m - n2);\n                        p2 = karatsuba_main_i ops (coeffs_minus_i ops f1 f0)\n                              n2 (coeffs_minus_i ops g1 g0) n2;\n                        p3 = karatsuba_main_i ops f0 n2 g0 n2\n                    in plus_poly_i ops (monom_mult_i ops (n2 + n2) p1)\n                        (plus_poly_i ops\n                          (monom_mult_i ops n2\n                            (plus_poly_i ops (minus_poly_i ops p1 p2) p3))\n                          p3)\n           else case split_at n2 f of\n                (f0, f1) \\<Rightarrow>\n                  let p1 = karatsuba_main_i ops f1 (n - n2) g m\n                  in Let (karatsuba_main_i ops f0 n2 g m)\n                      (plus_poly_i ops (monom_mult_i ops n2 p1)))\n\ngoal (1 subgoal):\n 1. \\<And>x x1 y1 x2 y2 m.\n       \\<lbrakk>\\<And>y x1 y1 x2 y2 m.\n                   \\<lbrakk>y < x; list_all2 R x1 x2;\n                    list_all2 R y1 y2\\<rbrakk>\n                   \\<Longrightarrow> poly_rel\n(karatsuba_main_i ops x1 y y1 m) (karatsuba_main x2 y y2 m);\n        list_all2 R x1 x2; list_all2 R y1 y2\\<rbrakk>\n       \\<Longrightarrow> poly_rel (karatsuba_main_i ops x1 x y1 m)\n                          (karatsuba_main x2 x y2 m)", "note IH = less(1)"], ["proof (state)\nthis:\n  \\<lbrakk>?y < n; list_all2 R ?x1.0 ?x2.0; list_all2 R ?y1.0 ?y2.0\\<rbrakk>\n  \\<Longrightarrow> poly_rel (karatsuba_main_i ops ?x1.0 ?y ?y1.0 ?m)\n                     (karatsuba_main ?x2.0 ?y ?y2.0 ?m)\n\ngoal (1 subgoal):\n 1. \\<And>x x1 y1 x2 y2 m.\n       \\<lbrakk>\\<And>y x1 y1 x2 y2 m.\n                   \\<lbrakk>y < x; list_all2 R x1 x2;\n                    list_all2 R y1 y2\\<rbrakk>\n                   \\<Longrightarrow> poly_rel\n(karatsuba_main_i ops x1 y y1 m) (karatsuba_main x2 y y2 m);\n        list_all2 R x1 x2; list_all2 R y1 y2\\<rbrakk>\n       \\<Longrightarrow> poly_rel (karatsuba_main_i ops x1 x y1 m)\n                          (karatsuba_main x2 x y2 m)", "note rel[transfer_rule] = less(2-3)"], ["proof (state)\nthis:\n  list_all2 R f F\n  list_all2 R g G\n\ngoal (1 subgoal):\n 1. \\<And>x x1 y1 x2 y2 m.\n       \\<lbrakk>\\<And>y x1 y1 x2 y2 m.\n                   \\<lbrakk>y < x; list_all2 R x1 x2;\n                    list_all2 R y1 y2\\<rbrakk>\n                   \\<Longrightarrow> poly_rel\n(karatsuba_main_i ops x1 y y1 m) (karatsuba_main x2 y y2 m);\n        list_all2 R x1 x2; list_all2 R y1 y2\\<rbrakk>\n       \\<Longrightarrow> poly_rel (karatsuba_main_i ops x1 x y1 m)\n                          (karatsuba_main x2 x y2 m)", "show ?case (is \"poly_rel ?lhs ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "proof (cases \"(n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) = False\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)\n 2. (n \\<le> karatsuba_lower_bound \\<or>\n     m \\<le> karatsuba_lower_bound) \\<noteq>\n    False \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "case False"], ["proof (state)\nthis:\n  (n \\<le> karatsuba_lower_bound \\<or>\n   m \\<le> karatsuba_lower_bound) \\<noteq>\n  False\n\ngoal (2 subgoals):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)\n 2. (n \\<le> karatsuba_lower_bound \\<or>\n     m \\<le> karatsuba_lower_bound) \\<noteq>\n    False \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "from False"], ["proof (chain)\npicking this:\n  (n \\<le> karatsuba_lower_bound \\<or>\n   m \\<le> karatsuba_lower_bound) \\<noteq>\n  False", "have lhs: \"?lhs = foldr (\\<lambda>a p. plus_poly_i ops (smult_i ops a (poly_of_list_i ops f))\n         (cCons_i ops zero p)) g []\""], ["proof (prove)\nusing this:\n  (n \\<le> karatsuba_lower_bound \\<or>\n   m \\<le> karatsuba_lower_bound) \\<noteq>\n  False\n\ngoal (1 subgoal):\n 1. karatsuba_main_i ops f n g m =\n    foldr\n     (\\<lambda>a p.\n         plus_poly_i ops (smult_i ops a (poly_of_list_i ops f))\n          (cCons_i ops (arith_ops_record.zero ops) p))\n     g []", "by simp"], ["proof (state)\nthis:\n  karatsuba_main_i ops f n g m =\n  foldr\n   (\\<lambda>a p.\n       plus_poly_i ops (smult_i ops a (poly_of_list_i ops f))\n        (cCons_i ops (arith_ops_record.zero ops) p))\n   g []\n\ngoal (2 subgoals):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)\n 2. (n \\<le> karatsuba_lower_bound \\<or>\n     m \\<le> karatsuba_lower_bound) \\<noteq>\n    False \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "from False"], ["proof (chain)\npicking this:\n  (n \\<le> karatsuba_lower_bound \\<or>\n   m \\<le> karatsuba_lower_bound) \\<noteq>\n  False", "have rhs: \"?rhs = foldr (\\<lambda>a p. smult a (poly_of_list F) + pCons 0 p) G 0\""], ["proof (prove)\nusing this:\n  (n \\<le> karatsuba_lower_bound \\<or>\n   m \\<le> karatsuba_lower_bound) \\<noteq>\n  False\n\ngoal (1 subgoal):\n 1. karatsuba_main F n G m =\n    foldr (\\<lambda>a p. smult a (poly_of_list F) + pCons (0::'a) p) G 0", "by simp"], ["proof (state)\nthis:\n  karatsuba_main F n G m =\n  foldr (\\<lambda>a p. smult a (poly_of_list F) + pCons (0::'a) p) G 0\n\ngoal (2 subgoals):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)\n 2. (n \\<le> karatsuba_lower_bound \\<or>\n     m \\<le> karatsuba_lower_bound) \\<noteq>\n    False \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "unfolding lhs rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel\n     (foldr\n       (\\<lambda>a p.\n           plus_poly_i ops (smult_i ops a (poly_of_list_i ops f))\n            (cCons_i ops (arith_ops_record.zero ops) p))\n       g [])\n     (foldr (\\<lambda>a p. smult a (poly_of_list F) + pCons (0::'a) p) G 0)", "by transfer_prover"], ["proof (state)\nthis:\n  poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)\n\ngoal (1 subgoal):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "case True"], ["proof (state)\nthis:\n  (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n  False\n\ngoal (1 subgoal):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "note * = this"], ["proof (state)\nthis:\n  (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n  False\n\ngoal (1 subgoal):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "let ?n2 = \"n div 2\""], ["proof (state)\ngoal (1 subgoal):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "have \"?n2 < n\" \"n - ?n2 < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n div 2 < n &&& n - n div 2 < n", "using True"], ["proof (prove)\nusing this:\n  (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n  False\n\ngoal (1 subgoal):\n 1. n div 2 < n &&& n - n div 2 < n", "unfolding karatsuba_lower_bound_def"], ["proof (prove)\nusing this:\n  (n \\<le> 7 \\<or> m \\<le> 7) = False\n\ngoal (1 subgoal):\n 1. n div 2 < n &&& n - n div 2 < n", "by auto"], ["proof (state)\nthis:\n  n div 2 < n\n  n - n div 2 < n\n\ngoal (1 subgoal):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "note IH = IH[OF this(1)] IH[OF this(2)]"], ["proof (state)\nthis:\n  \\<lbrakk>list_all2 R ?x1.0 ?x2.0; list_all2 R ?y1.0 ?y2.0\\<rbrakk>\n  \\<Longrightarrow> poly_rel (karatsuba_main_i ops ?x1.0 (n div 2) ?y1.0 ?m)\n                     (karatsuba_main ?x2.0 (n div 2) ?y2.0 ?m)\n  \\<lbrakk>list_all2 R ?x1.0 ?x2.0; list_all2 R ?y1.0 ?y2.0\\<rbrakk>\n  \\<Longrightarrow> poly_rel\n                     (karatsuba_main_i ops ?x1.0 (n - n div 2) ?y1.0 ?m)\n                     (karatsuba_main ?x2.0 (n - n div 2) ?y2.0 ?m)\n\ngoal (1 subgoal):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "obtain f1 f0 where f: \"split_at ?n2 f = (f0,f1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f0 f1.\n        split_at (n div 2) f = (f0, f1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  split_at (n div 2) f = (f0, f1)\n\ngoal (1 subgoal):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "obtain g1 g0 where g: \"split_at ?n2 g = (g0,g1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g0 g1.\n        split_at (n div 2) g = (g0, g1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  split_at (n div 2) g = (g0, g1)\n\ngoal (1 subgoal):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "obtain F1 F0 where F: \"split_at ?n2 F = (F0,F1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>F0 F1.\n        split_at (n div 2) F = (F0, F1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  split_at (n div 2) F = (F0, F1)\n\ngoal (1 subgoal):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "obtain G1 G0 where G: \"split_at ?n2 G = (G0,G1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>G0 G1.\n        split_at (n div 2) G = (G0, G1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  split_at (n div 2) G = (G0, G1)\n\ngoal (1 subgoal):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "from rel f F"], ["proof (chain)\npicking this:\n  list_all2 R f F\n  list_all2 R g G\n  split_at (n div 2) f = (f0, f1)\n  split_at (n div 2) F = (F0, F1)", "have relf[transfer_rule]: \"list_all2 R f0 F0\" \"list_all2 R f1 F1\""], ["proof (prove)\nusing this:\n  list_all2 R f F\n  list_all2 R g G\n  split_at (n div 2) f = (f0, f1)\n  split_at (n div 2) F = (F0, F1)\n\ngoal (1 subgoal):\n 1. list_all2 R f0 F0 &&& list_all2 R f1 F1", "unfolding split_at_def"], ["proof (prove)\nusing this:\n  list_all2 R f F\n  list_all2 R g G\n  (take (n div 2) f, drop (n div 2) f) = (f0, f1)\n  (take (n div 2) F, drop (n div 2) F) = (F0, F1)\n\ngoal (1 subgoal):\n 1. list_all2 R f0 F0 &&& list_all2 R f1 F1", "by auto"], ["proof (state)\nthis:\n  list_all2 R f0 F0\n  list_all2 R f1 F1\n\ngoal (1 subgoal):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "from rel g G"], ["proof (chain)\npicking this:\n  list_all2 R f F\n  list_all2 R g G\n  split_at (n div 2) g = (g0, g1)\n  split_at (n div 2) G = (G0, G1)", "have relg[transfer_rule]: \"list_all2 R g0 G0\" \"list_all2 R g1 G1\""], ["proof (prove)\nusing this:\n  list_all2 R f F\n  list_all2 R g G\n  split_at (n div 2) g = (g0, g1)\n  split_at (n div 2) G = (G0, G1)\n\ngoal (1 subgoal):\n 1. list_all2 R g0 G0 &&& list_all2 R g1 G1", "unfolding split_at_def"], ["proof (prove)\nusing this:\n  list_all2 R f F\n  list_all2 R g G\n  (take (n div 2) g, drop (n div 2) g) = (g0, g1)\n  (take (n div 2) G, drop (n div 2) G) = (G0, G1)\n\ngoal (1 subgoal):\n 1. list_all2 R g0 G0 &&& list_all2 R g1 G1", "by auto"], ["proof (state)\nthis:\n  list_all2 R g0 G0\n  list_all2 R g1 G1\n\ngoal (1 subgoal):\n 1. (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n    False \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "proof (cases \"?n2 < m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)\n 2. \\<not> n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "case True"], ["proof (state)\nthis:\n  n div 2 < m\n\ngoal (2 subgoals):\n 1. n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)\n 2. \\<not> n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "obtain p1 P1 where p1: \"p1 = karatsuba_main_i ops f1 (n - n div 2) g1 (m - n div 2)\" \n          \"P1 = karatsuba_main F1 (n - n div 2) G1 (m - n div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1 P1.\n        \\<lbrakk>p1 =\n                 karatsuba_main_i ops f1 (n - n div 2) g1 (m - n div 2);\n         P1 = karatsuba_main F1 (n - n div 2) G1 (m - n div 2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p1 = karatsuba_main_i ops f1 (n - n div 2) g1 (m - n div 2)\n  P1 = karatsuba_main F1 (n - n div 2) G1 (m - n div 2)\n\ngoal (2 subgoals):\n 1. n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)\n 2. \\<not> n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "obtain p2 P2 where p2: \"p2 = karatsuba_main_i ops (coeffs_minus_i ops f1 f0) (n div 2)\n                          (coeffs_minus_i ops g1 g0) (n div 2)\" \n          \"P2 = karatsuba_main (coeffs_minus F1 F0) (n div 2)\n                          (coeffs_minus G1 G0) (n div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p2 P2.\n        \\<lbrakk>p2 =\n                 karatsuba_main_i ops (coeffs_minus_i ops f1 f0) (n div 2)\n                  (coeffs_minus_i ops g1 g0) (n div 2);\n         P2 =\n         karatsuba_main (coeffs_minus F1 F0) (n div 2) (coeffs_minus G1 G0)\n          (n div 2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p2 =\n  karatsuba_main_i ops (coeffs_minus_i ops f1 f0) (n div 2)\n   (coeffs_minus_i ops g1 g0) (n div 2)\n  P2 =\n  karatsuba_main (coeffs_minus F1 F0) (n div 2) (coeffs_minus G1 G0)\n   (n div 2)\n\ngoal (2 subgoals):\n 1. n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)\n 2. \\<not> n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "obtain p3 P3 where p3: \"p3 = karatsuba_main_i ops f0 (n div 2) g0 (n div 2)\"\n          \"P3 = karatsuba_main F0 (n div 2) G0 (n div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p3 P3.\n        \\<lbrakk>p3 = karatsuba_main_i ops f0 (n div 2) g0 (n div 2);\n         P3 = karatsuba_main F0 (n div 2) G0 (n div 2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p3 = karatsuba_main_i ops f0 (n div 2) g0 (n div 2)\n  P3 = karatsuba_main F0 (n div 2) G0 (n div 2)\n\ngoal (2 subgoals):\n 1. n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)\n 2. \\<not> n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "from * True"], ["proof (chain)\npicking this:\n  (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n  False\n  n div 2 < m", "have lhs: \"?lhs = plus_poly_i ops (monom_mult_i ops (n div 2 + n div 2) p1)\n                (plus_poly_i ops\n                  (monom_mult_i ops (n div 2)\n                    (plus_poly_i ops (minus_poly_i ops p1 p2) p3)) p3)\""], ["proof (prove)\nusing this:\n  (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n  False\n  n div 2 < m\n\ngoal (1 subgoal):\n 1. karatsuba_main_i ops f n g m =\n    plus_poly_i ops (monom_mult_i ops (n div 2 + n div 2) p1)\n     (plus_poly_i ops\n       (monom_mult_i ops (n div 2)\n         (plus_poly_i ops (minus_poly_i ops p1 p2) p3))\n       p3)", "unfolding simp Let_def f g split p1 p2 p3"], ["proof (prove)\nusing this:\n  (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n  False\n  n div 2 < m\n\ngoal (1 subgoal):\n 1. (if n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound\n     then foldr\n           (\\<lambda>a p.\n               plus_poly_i ops (smult_i ops a (poly_of_list_i ops f))\n                (cCons_i ops (arith_ops_record.zero ops) p))\n           g []\n     else if n div 2 < m\n          then plus_poly_i ops\n                (monom_mult_i ops (n div 2 + n div 2)\n                  (karatsuba_main_i ops f1 (n - n div 2) g1 (m - n div 2)))\n                (plus_poly_i ops\n                  (monom_mult_i ops (n div 2)\n                    (plus_poly_i ops\n                      (minus_poly_i ops\n                        (karatsuba_main_i ops f1 (n - n div 2) g1\n                          (m - n div 2))\n                        (karatsuba_main_i ops (coeffs_minus_i ops f1 f0)\n                          (n div 2) (coeffs_minus_i ops g1 g0) (n div 2)))\n                      (karatsuba_main_i ops f0 (n div 2) g0 (n div 2))))\n                  (karatsuba_main_i ops f0 (n div 2) g0 (n div 2)))\n          else plus_poly_i ops\n                (monom_mult_i ops (n div 2)\n                  (karatsuba_main_i ops f1 (n - n div 2) g m))\n                (karatsuba_main_i ops f0 (n div 2) g m)) =\n    plus_poly_i ops\n     (monom_mult_i ops (n div 2 + n div 2)\n       (karatsuba_main_i ops f1 (n - n div 2) g1 (m - n div 2)))\n     (plus_poly_i ops\n       (monom_mult_i ops (n div 2)\n         (plus_poly_i ops\n           (minus_poly_i ops\n             (karatsuba_main_i ops f1 (n - n div 2) g1 (m - n div 2))\n             (karatsuba_main_i ops (coeffs_minus_i ops f1 f0) (n div 2)\n               (coeffs_minus_i ops g1 g0) (n div 2)))\n           (karatsuba_main_i ops f0 (n div 2) g0 (n div 2))))\n       (karatsuba_main_i ops f0 (n div 2) g0 (n div 2)))", "by auto"], ["proof (state)\nthis:\n  karatsuba_main_i ops f n g m =\n  plus_poly_i ops (monom_mult_i ops (n div 2 + n div 2) p1)\n   (plus_poly_i ops\n     (monom_mult_i ops (n div 2)\n       (plus_poly_i ops (minus_poly_i ops p1 p2) p3))\n     p3)\n\ngoal (2 subgoals):\n 1. n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)\n 2. \\<not> n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "have [transfer_rule]: \"poly_rel p1 P1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel p1 P1", "using IH(2)[OF relf(2) relg(2)]"], ["proof (prove)\nusing this:\n  poly_rel (karatsuba_main_i ops f1 (n - n div 2) g1 ?m)\n   (karatsuba_main F1 (n - n div 2) G1 ?m)\n\ngoal (1 subgoal):\n 1. poly_rel p1 P1", "unfolding p1"], ["proof (prove)\nusing this:\n  poly_rel (karatsuba_main_i ops f1 (n - n div 2) g1 ?m)\n   (karatsuba_main F1 (n - n div 2) G1 ?m)\n\ngoal (1 subgoal):\n 1. poly_rel (karatsuba_main_i ops f1 (n - n div 2) g1 (m - n div 2))\n     (karatsuba_main F1 (n - n div 2) G1 (m - n div 2))", "."], ["proof (state)\nthis:\n  poly_rel p1 P1\n\ngoal (2 subgoals):\n 1. n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)\n 2. \\<not> n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "have [transfer_rule]: \"poly_rel p3 P3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel p3 P3", "using IH(1)[OF relf(1) relg(1)]"], ["proof (prove)\nusing this:\n  poly_rel (karatsuba_main_i ops f0 (n div 2) g0 ?m)\n   (karatsuba_main F0 (n div 2) G0 ?m)\n\ngoal (1 subgoal):\n 1. poly_rel p3 P3", "unfolding p3"], ["proof (prove)\nusing this:\n  poly_rel (karatsuba_main_i ops f0 (n div 2) g0 ?m)\n   (karatsuba_main F0 (n div 2) G0 ?m)\n\ngoal (1 subgoal):\n 1. poly_rel (karatsuba_main_i ops f0 (n div 2) g0 (n div 2))\n     (karatsuba_main F0 (n div 2) G0 (n div 2))", "."], ["proof (state)\nthis:\n  poly_rel p3 P3\n\ngoal (2 subgoals):\n 1. n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)\n 2. \\<not> n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "have [transfer_rule]: \"poly_rel p2 P2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel p2 P2", "unfolding p2"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel\n     (karatsuba_main_i ops (coeffs_minus_i ops f1 f0) (n div 2)\n       (coeffs_minus_i ops g1 g0) (n div 2))\n     (karatsuba_main (coeffs_minus F1 F0) (n div 2) (coeffs_minus G1 G0)\n       (n div 2))", "by (rule IH(1)[OF list_rel_coeffs_minus_i list_rel_coeffs_minus_i], insert relf relg)"], ["proof (state)\nthis:\n  poly_rel p2 P2\n\ngoal (2 subgoals):\n 1. n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)\n 2. \\<not> n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "from True *"], ["proof (chain)\npicking this:\n  n div 2 < m\n  (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n  False", "have rhs: \"?rhs = monom_mult (n div 2 + n div 2) P1 +\n               (monom_mult (n div 2) (P1 - P2 + P3) + P3)\""], ["proof (prove)\nusing this:\n  n div 2 < m\n  (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n  False\n\ngoal (1 subgoal):\n 1. karatsuba_main F n G m =\n    monom_mult (n div 2 + n div 2) P1 +\n    (monom_mult (n div 2) (P1 - P2 + P3) + P3)", "unfolding simp Let_def F G split p1 p2 p3"], ["proof (prove)\nusing this:\n  n div 2 < m\n  (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n  False\n\ngoal (1 subgoal):\n 1. (if n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound\n     then foldr (\\<lambda>a p. smult a (poly_of_list F) + pCons (0::'a) p) G\n           0\n     else if n div 2 < m\n          then monom_mult (n div 2 + n div 2)\n                (karatsuba_main F1 (n - n div 2) G1 (m - n div 2)) +\n               (monom_mult (n div 2)\n                 (karatsuba_main F1 (n - n div 2) G1 (m - n div 2) -\n                  karatsuba_main (coeffs_minus F1 F0) (n div 2)\n                   (coeffs_minus G1 G0) (n div 2) +\n                  karatsuba_main F0 (n div 2) G0 (n div 2)) +\n                karatsuba_main F0 (n div 2) G0 (n div 2))\n          else monom_mult (n div 2) (karatsuba_main F1 (n - n div 2) G m) +\n               karatsuba_main F0 (n div 2) G m) =\n    monom_mult (n div 2 + n div 2)\n     (karatsuba_main F1 (n - n div 2) G1 (m - n div 2)) +\n    (monom_mult (n div 2)\n      (karatsuba_main F1 (n - n div 2) G1 (m - n div 2) -\n       karatsuba_main (coeffs_minus F1 F0) (n div 2) (coeffs_minus G1 G0)\n        (n div 2) +\n       karatsuba_main F0 (n div 2) G0 (n div 2)) +\n     karatsuba_main F0 (n div 2) G0 (n div 2))", "by auto"], ["proof (state)\nthis:\n  karatsuba_main F n G m =\n  monom_mult (n div 2 + n div 2) P1 +\n  (monom_mult (n div 2) (P1 - P2 + P3) + P3)\n\ngoal (2 subgoals):\n 1. n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)\n 2. \\<not> n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "unfolding lhs rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel\n     (plus_poly_i ops (monom_mult_i ops (n div 2 + n div 2) p1)\n       (plus_poly_i ops\n         (monom_mult_i ops (n div 2)\n           (plus_poly_i ops (minus_poly_i ops p1 p2) p3))\n         p3))\n     (monom_mult (n div 2 + n div 2) P1 +\n      (monom_mult (n div 2) (P1 - P2 + P3) + P3))", "by transfer_prover"], ["proof (state)\nthis:\n  poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)\n\ngoal (1 subgoal):\n 1. \\<not> n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "case False"], ["proof (state)\nthis:\n  \\<not> n div 2 < m\n\ngoal (1 subgoal):\n 1. \\<not> n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "obtain p1 P1 where p1: \"p1 = karatsuba_main_i ops f1 (n - n div 2) g m\" \n          \"P1 = karatsuba_main F1 (n - n div 2) G m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1 P1.\n        \\<lbrakk>p1 = karatsuba_main_i ops f1 (n - n div 2) g m;\n         P1 = karatsuba_main F1 (n - n div 2) G m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p1 = karatsuba_main_i ops f1 (n - n div 2) g m\n  P1 = karatsuba_main F1 (n - n div 2) G m\n\ngoal (1 subgoal):\n 1. \\<not> n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "obtain p2 P2 where p2: \"p2 = karatsuba_main_i ops f0 (n div 2) g m\" \n          \"P2 = karatsuba_main F0 (n div 2) G m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p2 P2.\n        \\<lbrakk>p2 = karatsuba_main_i ops f0 (n div 2) g m;\n         P2 = karatsuba_main F0 (n div 2) G m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p2 = karatsuba_main_i ops f0 (n div 2) g m\n  P2 = karatsuba_main F0 (n div 2) G m\n\ngoal (1 subgoal):\n 1. \\<not> n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "from * False"], ["proof (chain)\npicking this:\n  (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n  False\n  \\<not> n div 2 < m", "have lhs: \"?lhs = plus_poly_i ops (monom_mult_i ops (n div 2) p1) p2\""], ["proof (prove)\nusing this:\n  (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n  False\n  \\<not> n div 2 < m\n\ngoal (1 subgoal):\n 1. karatsuba_main_i ops f n g m =\n    plus_poly_i ops (monom_mult_i ops (n div 2) p1) p2", "unfolding simp Let_def f split p1 p2"], ["proof (prove)\nusing this:\n  (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n  False\n  \\<not> n div 2 < m\n\ngoal (1 subgoal):\n 1. (if n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound\n     then foldr\n           (\\<lambda>a p.\n               plus_poly_i ops (smult_i ops a (poly_of_list_i ops f))\n                (cCons_i ops (arith_ops_record.zero ops) p))\n           g []\n     else if n div 2 < m\n          then case split_at (n div 2) g of\n               (g0, g1) \\<Rightarrow>\n                 plus_poly_i ops\n                  (monom_mult_i ops (n div 2 + n div 2)\n                    (karatsuba_main_i ops f1 (n - n div 2) g1\n                      (m - n div 2)))\n                  (plus_poly_i ops\n                    (monom_mult_i ops (n div 2)\n                      (plus_poly_i ops\n                        (minus_poly_i ops\n                          (karatsuba_main_i ops f1 (n - n div 2) g1\n                            (m - n div 2))\n                          (karatsuba_main_i ops (coeffs_minus_i ops f1 f0)\n                            (n div 2) (coeffs_minus_i ops g1 g0) (n div 2)))\n                        (karatsuba_main_i ops f0 (n div 2) g0 (n div 2))))\n                    (karatsuba_main_i ops f0 (n div 2) g0 (n div 2)))\n          else plus_poly_i ops\n                (monom_mult_i ops (n div 2)\n                  (karatsuba_main_i ops f1 (n - n div 2) g m))\n                (karatsuba_main_i ops f0 (n div 2) g m)) =\n    plus_poly_i ops\n     (monom_mult_i ops (n div 2)\n       (karatsuba_main_i ops f1 (n - n div 2) g m))\n     (karatsuba_main_i ops f0 (n div 2) g m)", "by auto"], ["proof (state)\nthis:\n  karatsuba_main_i ops f n g m =\n  plus_poly_i ops (monom_mult_i ops (n div 2) p1) p2\n\ngoal (1 subgoal):\n 1. \\<not> n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "from * False"], ["proof (chain)\npicking this:\n  (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n  False\n  \\<not> n div 2 < m", "have rhs: \"?rhs = monom_mult (n div 2) P1 + P2\""], ["proof (prove)\nusing this:\n  (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n  False\n  \\<not> n div 2 < m\n\ngoal (1 subgoal):\n 1. karatsuba_main F n G m = monom_mult (n div 2) P1 + P2", "unfolding simp Let_def F split p1 p2"], ["proof (prove)\nusing this:\n  (n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound) =\n  False\n  \\<not> n div 2 < m\n\ngoal (1 subgoal):\n 1. (if n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound\n     then foldr (\\<lambda>a p. smult a (poly_of_list F) + pCons (0::'a) p) G\n           0\n     else if n div 2 < m\n          then case split_at (n div 2) G of\n               (g0, g1) \\<Rightarrow>\n                 monom_mult (n div 2 + n div 2)\n                  (karatsuba_main F1 (n - n div 2) g1 (m - n div 2)) +\n                 (monom_mult (n div 2)\n                   (karatsuba_main F1 (n - n div 2) g1 (m - n div 2) -\n                    karatsuba_main (coeffs_minus F1 F0) (n div 2)\n                     (coeffs_minus g1 g0) (n div 2) +\n                    karatsuba_main F0 (n div 2) g0 (n div 2)) +\n                  karatsuba_main F0 (n div 2) g0 (n div 2))\n          else monom_mult (n div 2) (karatsuba_main F1 (n - n div 2) G m) +\n               karatsuba_main F0 (n div 2) G m) =\n    monom_mult (n div 2) (karatsuba_main F1 (n - n div 2) G m) +\n    karatsuba_main F0 (n div 2) G m", "by auto"], ["proof (state)\nthis:\n  karatsuba_main F n G m = monom_mult (n div 2) P1 + P2\n\ngoal (1 subgoal):\n 1. \\<not> n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "have [transfer_rule]: \"poly_rel p1 P1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel p1 P1", "using IH(2)[OF relf(2) rel(2)]"], ["proof (prove)\nusing this:\n  poly_rel (karatsuba_main_i ops f1 (n - n div 2) g ?m)\n   (karatsuba_main F1 (n - n div 2) G ?m)\n\ngoal (1 subgoal):\n 1. poly_rel p1 P1", "unfolding p1"], ["proof (prove)\nusing this:\n  poly_rel (karatsuba_main_i ops f1 (n - n div 2) g ?m)\n   (karatsuba_main F1 (n - n div 2) G ?m)\n\ngoal (1 subgoal):\n 1. poly_rel (karatsuba_main_i ops f1 (n - n div 2) g m)\n     (karatsuba_main F1 (n - n div 2) G m)", "."], ["proof (state)\nthis:\n  poly_rel p1 P1\n\ngoal (1 subgoal):\n 1. \\<not> n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "have [transfer_rule]: \"poly_rel p2 P2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel p2 P2", "using IH(1)[OF relf(1) rel(2)]"], ["proof (prove)\nusing this:\n  poly_rel (karatsuba_main_i ops f0 (n div 2) g ?m)\n   (karatsuba_main F0 (n div 2) G ?m)\n\ngoal (1 subgoal):\n 1. poly_rel p2 P2", "unfolding p2"], ["proof (prove)\nusing this:\n  poly_rel (karatsuba_main_i ops f0 (n div 2) g ?m)\n   (karatsuba_main F0 (n div 2) G ?m)\n\ngoal (1 subgoal):\n 1. poly_rel (karatsuba_main_i ops f0 (n div 2) g m)\n     (karatsuba_main F0 (n div 2) G m)", "."], ["proof (state)\nthis:\n  poly_rel p2 P2\n\ngoal (1 subgoal):\n 1. \\<not> n div 2 < m \\<Longrightarrow>\n    poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)", "unfolding lhs rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (plus_poly_i ops (monom_mult_i ops (n div 2) p1) p2)\n     (monom_mult (n div 2) P1 + P2)", "by transfer_prover"], ["proof (state)\nthis:\n  poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_rel (karatsuba_main_i ops f n g m) (karatsuba_main F n G m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_rel_times[transfer_rule]: \"(poly_rel ===> poly_rel ===> poly_rel) (times_poly_i ops) ((*))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> poly_rel ===> poly_rel) (times_poly_i ops) (*)", "proof (intro rel_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>poly_rel x y; poly_rel xa ya\\<rbrakk>\n       \\<Longrightarrow> poly_rel (times_poly_i ops x xa) (y * ya)", "fix x1 y1 x2 y2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>poly_rel x y; poly_rel xa ya\\<rbrakk>\n       \\<Longrightarrow> poly_rel (times_poly_i ops x xa) (y * ya)", "assume x12[transfer_rule]: \"poly_rel x1 x2\" and y12 [transfer_rule]: \"poly_rel y1 y2\""], ["proof (state)\nthis:\n  poly_rel x1 x2\n  poly_rel y1 y2\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>poly_rel x y; poly_rel xa ya\\<rbrakk>\n       \\<Longrightarrow> poly_rel (times_poly_i ops x xa) (y * ya)", "hence X12[transfer_rule]: \"list_all2 R x1 (coeffs x2)\" and Y12[transfer_rule]: \"list_all2 R y1 (coeffs y2)\""], ["proof (prove)\nusing this:\n  poly_rel x1 x2\n  poly_rel y1 y2\n\ngoal (1 subgoal):\n 1. list_all2 R x1 (coeffs x2) &&& list_all2 R y1 (coeffs y2)", "unfolding poly_rel_def"], ["proof (prove)\nusing this:\n  list_all2 R x1 (coeffs x2)\n  list_all2 R y1 (coeffs y2)\n\ngoal (1 subgoal):\n 1. list_all2 R x1 (coeffs x2) &&& list_all2 R y1 (coeffs y2)", "by auto"], ["proof (state)\nthis:\n  list_all2 R x1 (coeffs x2)\n  list_all2 R y1 (coeffs y2)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>poly_rel x y; poly_rel xa ya\\<rbrakk>\n       \\<Longrightarrow> poly_rel (times_poly_i ops x xa) (y * ya)", "hence len: \"length (coeffs x2) = length x1\" \"length (coeffs y2) = length y1\""], ["proof (prove)\nusing this:\n  list_all2 R x1 (coeffs x2)\n  list_all2 R y1 (coeffs y2)\n\ngoal (1 subgoal):\n 1. length (coeffs x2) = length x1 &&& length (coeffs y2) = length y1", "unfolding list_all2_conv_all_nth"], ["proof (prove)\nusing this:\n  length x1 = length (coeffs x2) \\<and>\n  (\\<forall>i<length x1. R (x1 ! i) (coeffs x2 ! i))\n  length y1 = length (coeffs y2) \\<and>\n  (\\<forall>i<length y1. R (y1 ! i) (coeffs y2 ! i))\n\ngoal (1 subgoal):\n 1. length (coeffs x2) = length x1 &&& length (coeffs y2) = length y1", "by auto"], ["proof (state)\nthis:\n  length (coeffs x2) = length x1\n  length (coeffs y2) = length y1\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>poly_rel x y; poly_rel xa ya\\<rbrakk>\n       \\<Longrightarrow> poly_rel (times_poly_i ops x xa) (y * ya)", "let ?cond1 = \"length x1 \\<le> karatsuba_lower_bound \\<or> length y1 \\<le> karatsuba_lower_bound\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>poly_rel x y; poly_rel xa ya\\<rbrakk>\n       \\<Longrightarrow> poly_rel (times_poly_i ops x xa) (y * ya)", "let ?cond2 = \"length x1 \\<le> length y1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>poly_rel x y; poly_rel xa ya\\<rbrakk>\n       \\<Longrightarrow> poly_rel (times_poly_i ops x xa) (y * ya)", "note d = karatsuba_mult_poly[symmetric] karatsuba_mult_poly_def Let_def\n      times_poly_i_def len if_True if_False"], ["proof (state)\nthis:\n  ?f * ?g = karatsuba_mult_poly ?f ?g\n  karatsuba_mult_poly ?f ?g =\n  (let ff = coeffs ?f; gg = coeffs ?g; n = length ff; m = length gg\n   in if n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound\n      then if n \\<le> m\n           then foldr (\\<lambda>a p. smult a ?g + pCons (0::?'a) p) ff 0\n           else foldr (\\<lambda>a p. smult a ?f + pCons (0::?'a) p) gg 0\n      else if n \\<le> m then karatsuba_main gg m ff n\n           else karatsuba_main ff n gg m)\n  Let ?s ?f \\<equiv> ?f ?s\n  times_poly_i ?ops ?f ?g \\<equiv>\n  let n = length ?f; m = length ?g\n  in if n \\<le> karatsuba_lower_bound \\<or> m \\<le> karatsuba_lower_bound\n     then if n \\<le> m\n          then foldr\n                (\\<lambda>a p.\n                    plus_poly_i ?ops (smult_i ?ops a ?g)\n                     (cCons_i ?ops (arith_ops_record.zero ?ops) p))\n                ?f []\n          else foldr\n                (\\<lambda>a p.\n                    plus_poly_i ?ops (smult_i ?ops a ?f)\n                     (cCons_i ?ops (arith_ops_record.zero ?ops) p))\n                ?g []\n     else if n \\<le> m then karatsuba_main_i ?ops ?g m ?f n\n          else karatsuba_main_i ?ops ?f n ?g m\n  length (coeffs x2) = length x1\n  length (coeffs y2) = length y1\n  (if True then ?x else ?y) = ?x\n  (if False then ?x else ?y) = ?y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>poly_rel x y; poly_rel xa ya\\<rbrakk>\n       \\<Longrightarrow> poly_rel (times_poly_i ops x xa) (y * ya)", "consider (TT) \"?cond1 = True\" \"?cond2 = True\" | (TF) \"?cond1 = True\" \"?cond2 = False\" \n      | (FT) \"?cond1 = False\" \"?cond2 = True\" | (FF) \"?cond1 = False\" \"?cond2 = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n                       length y1 \\<le> karatsuba_lower_bound) =\n                      True;\n              (length x1 \\<le> length y1) = True\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n               length y1 \\<le> karatsuba_lower_bound) =\n              True;\n      (length x1 \\<le> length y1) = False\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n               length y1 \\<le> karatsuba_lower_bound) =\n              False;\n      (length x1 \\<le> length y1) = True\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n               length y1 \\<le> karatsuba_lower_bound) =\n              False;\n      (length x1 \\<le> length y1) = False\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n                     length y1 \\<le> karatsuba_lower_bound) =\n                    True;\n            (length x1 \\<le> length y1) = True\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n             length y1 \\<le> karatsuba_lower_bound) =\n            True;\n    (length x1 \\<le> length y1) = False\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n             length y1 \\<le> karatsuba_lower_bound) =\n            False;\n    (length x1 \\<le> length y1) = True\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n             length y1 \\<le> karatsuba_lower_bound) =\n            False;\n    (length x1 \\<le> length y1) = False\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>poly_rel x y; poly_rel xa ya\\<rbrakk>\n       \\<Longrightarrow> poly_rel (times_poly_i ops x xa) (y * ya)", "thus \"poly_rel (times_poly_i ops x1 y1) (x2 * y2)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n                     length y1 \\<le> karatsuba_lower_bound) =\n                    True;\n            (length x1 \\<le> length y1) = True\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n             length y1 \\<le> karatsuba_lower_bound) =\n            True;\n    (length x1 \\<le> length y1) = False\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n             length y1 \\<le> karatsuba_lower_bound) =\n            False;\n    (length x1 \\<le> length y1) = True\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n             length y1 \\<le> karatsuba_lower_bound) =\n            False;\n    (length x1 \\<le> length y1) = False\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. poly_rel (times_poly_i ops x1 y1) (x2 * y2)", "proof (cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             True;\n     (length x1 \\<le> length y1) = True\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)\n 2. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             True;\n     (length x1 \\<le> length y1) = False\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)\n 3. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             False;\n     (length x1 \\<le> length y1) = True\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)\n 4. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             False;\n     (length x1 \\<le> length y1) = False\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)", "case TT"], ["proof (state)\nthis:\n  (length x1 \\<le> karatsuba_lower_bound \\<or>\n   length y1 \\<le> karatsuba_lower_bound) =\n  True\n  (length x1 \\<le> length y1) = True\n\ngoal (4 subgoals):\n 1. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             True;\n     (length x1 \\<le> length y1) = True\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)\n 2. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             True;\n     (length x1 \\<le> length y1) = False\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)\n 3. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             False;\n     (length x1 \\<le> length y1) = True\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)\n 4. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             False;\n     (length x1 \\<le> length y1) = False\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (times_poly_i ops x1 y1) (x2 * y2)", "unfolding d TT"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel\n     (foldr\n       (\\<lambda>a p.\n           plus_poly_i ops (smult_i ops a y1)\n            (cCons_i ops (arith_ops_record.zero ops) p))\n       x1 [])\n     (foldr (\\<lambda>a p. smult a y2 + pCons (0::'a) p) (coeffs x2) 0)", "unfolding poly_rel_def coeffs_eq_iff times_poly_def times_poly_i_def fold_coeffs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R\n     (foldr\n       (\\<lambda>a p.\n           plus_poly_i ops (smult_i ops a y1)\n            (cCons_i ops (arith_ops_record.zero ops) p))\n       x1 [])\n     (coeffs\n       (foldr (\\<lambda>a p. smult a y2 + pCons (0::'a) p) (coeffs x2) 0))", "by transfer_prover"], ["proof (state)\nthis:\n  poly_rel (times_poly_i ops x1 y1) (x2 * y2)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             True;\n     (length x1 \\<le> length y1) = False\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)\n 2. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             False;\n     (length x1 \\<le> length y1) = True\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)\n 3. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             False;\n     (length x1 \\<le> length y1) = False\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             True;\n     (length x1 \\<le> length y1) = False\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)\n 2. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             False;\n     (length x1 \\<le> length y1) = True\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)\n 3. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             False;\n     (length x1 \\<le> length y1) = False\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)", "case TF"], ["proof (state)\nthis:\n  (length x1 \\<le> karatsuba_lower_bound \\<or>\n   length y1 \\<le> karatsuba_lower_bound) =\n  True\n  (length x1 \\<le> length y1) = False\n\ngoal (3 subgoals):\n 1. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             True;\n     (length x1 \\<le> length y1) = False\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)\n 2. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             False;\n     (length x1 \\<le> length y1) = True\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)\n 3. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             False;\n     (length x1 \\<le> length y1) = False\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (times_poly_i ops x1 y1) (x2 * y2)", "unfolding d TF"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel\n     (foldr\n       (\\<lambda>a p.\n           plus_poly_i ops (smult_i ops a x1)\n            (cCons_i ops (arith_ops_record.zero ops) p))\n       y1 [])\n     (foldr (\\<lambda>a p. smult a x2 + pCons (0::'a) p) (coeffs y2) 0)", "unfolding poly_rel_def coeffs_eq_iff times_poly_def times_poly_i_def fold_coeffs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R\n     (foldr\n       (\\<lambda>a p.\n           plus_poly_i ops (smult_i ops a x1)\n            (cCons_i ops (arith_ops_record.zero ops) p))\n       y1 [])\n     (coeffs\n       (foldr (\\<lambda>a p. smult a x2 + pCons (0::'a) p) (coeffs y2) 0))", "by transfer_prover"], ["proof (state)\nthis:\n  poly_rel (times_poly_i ops x1 y1) (x2 * y2)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             False;\n     (length x1 \\<le> length y1) = True\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)\n 2. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             False;\n     (length x1 \\<le> length y1) = False\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             False;\n     (length x1 \\<le> length y1) = True\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)\n 2. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             False;\n     (length x1 \\<le> length y1) = False\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)", "case FT"], ["proof (state)\nthis:\n  (length x1 \\<le> karatsuba_lower_bound \\<or>\n   length y1 \\<le> karatsuba_lower_bound) =\n  False\n  (length x1 \\<le> length y1) = True\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             False;\n     (length x1 \\<le> length y1) = True\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)\n 2. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             False;\n     (length x1 \\<le> length y1) = False\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (times_poly_i ops x1 y1) (x2 * y2)", "unfolding d FT"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (karatsuba_main_i ops y1 (length y1) x1 (length x1))\n     (karatsuba_main (coeffs y2) (length y1) (coeffs x2) (length x1))", "by (rule poly_rel_karatsuba_main[OF Y12 X12])"], ["proof (state)\nthis:\n  poly_rel (times_poly_i ops x1 y1) (x2 * y2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             False;\n     (length x1 \\<le> length y1) = False\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             False;\n     (length x1 \\<le> length y1) = False\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)", "case FF"], ["proof (state)\nthis:\n  (length x1 \\<le> karatsuba_lower_bound \\<or>\n   length y1 \\<le> karatsuba_lower_bound) =\n  False\n  (length x1 \\<le> length y1) = False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(length x1 \\<le> karatsuba_lower_bound \\<or>\n              length y1 \\<le> karatsuba_lower_bound) =\n             False;\n     (length x1 \\<le> length y1) = False\\<rbrakk>\n    \\<Longrightarrow> poly_rel (times_poly_i ops x1 y1) (x2 * y2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (times_poly_i ops x1 y1) (x2 * y2)", "unfolding d FF"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (karatsuba_main_i ops x1 (length x1) y1 (length y1))\n     (karatsuba_main (coeffs x2) (length x1) (coeffs y2) (length y1))", "by (rule poly_rel_karatsuba_main[OF X12 Y12])"], ["proof (state)\nthis:\n  poly_rel (times_poly_i ops x1 y1) (x2 * y2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_rel (times_poly_i ops x1 y1) (x2 * y2)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* coeff *)"], ["", "lemma poly_rel_coeff[transfer_rule]: \"(poly_rel ===> (=) ===> R) (coeff_i ops) coeff\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> (=) ===> R) (coeff_i ops) coeff", "unfolding poly_rel_def rel_fun_def coeff_i_def nth_default_coeffs_eq[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       list_all2 R x (coeffs y) \\<longrightarrow>\n       (\\<forall>xa ya.\n           xa = ya \\<longrightarrow>\n           R (nth_default (arith_ops_record.zero ops) x xa)\n            (nth_default (0::'a) (coeffs y) ya))", "proof (intro allI impI, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       list_all2 R x (coeffs y) \\<Longrightarrow>\n       R (nth_default (arith_ops_record.zero ops) x ya)\n        (nth_default (0::'a) (coeffs y) ya)", "fix x y n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       list_all2 R x (coeffs y) \\<Longrightarrow>\n       R (nth_default (arith_ops_record.zero ops) x ya)\n        (nth_default (0::'a) (coeffs y) ya)", "assume [transfer_rule]: \"list_all2 R x (coeffs y)\""], ["proof (state)\nthis:\n  list_all2 R x (coeffs y)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       list_all2 R x (coeffs y) \\<Longrightarrow>\n       R (nth_default (arith_ops_record.zero ops) x ya)\n        (nth_default (0::'a) (coeffs y) ya)", "show \"R (nth_default zero x n) (nth_default 0 (coeffs y) n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (nth_default (arith_ops_record.zero ops) x n)\n     (nth_default (0::'a) (coeffs y) n)", "by transfer_prover"], ["proof (state)\nthis:\n  R (nth_default (arith_ops_record.zero ops) x n)\n   (nth_default (0::'a) (coeffs y) n)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* degree *)"], ["", "lemma poly_rel_degree[transfer_rule]: \"(poly_rel ===> (=)) degree_i degree\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> (=)) degree_i degree", "unfolding poly_rel_def rel_fun_def degree_i_def degree_eq_length_coeffs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       list_all2 R x (coeffs y) \\<longrightarrow>\n       length x - 1 = length (coeffs y) - 1", "by (simp add: list_all2_lengthD)"], ["", "(* lead_coeff *)"], ["", "lemma lead_coeff_i_def': \"lead_coeff_i ops x = (coeff_i ops) x (degree_i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff_i ops x = coeff_i ops x (degree_i x)", "unfolding lead_coeff_i_def degree_i_def coeff_i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case x of [] \\<Rightarrow> arith_ops_record.zero ops\n     | a # list \\<Rightarrow> last x) =\n    nth_default (arith_ops_record.zero ops) x (length x - 1)", "proof (cases x, auto, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>x = a # list; list \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last list =\n                         nth_default (arith_ops_record.zero ops) (a # list)\n                          (length list)", "case (1 a xs)"], ["proof (state)\nthis:\n  x = a # xs\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>x = a # list; list \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last list =\n                         nth_default (arith_ops_record.zero ops) (a # list)\n                          (length list)", "hence id: \"last xs = last (a # xs)\""], ["proof (prove)\nusing this:\n  x = a # xs\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. last xs = last (a # xs)", "by auto"], ["proof (state)\nthis:\n  last xs = last (a # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>x = a # list; list \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last list =\n                         nth_default (arith_ops_record.zero ops) (a # list)\n                          (length list)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. last xs = nth_default (arith_ops_record.zero ops) (a # xs) (length xs)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. last (a # xs) =\n    nth_default (arith_ops_record.zero ops) (a # xs) (length xs)", "by (subst last_conv_nth_default, auto)"], ["proof (state)\nthis:\n  last xs = nth_default (arith_ops_record.zero ops) (a # xs) (length xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_rel_lead_coeff[transfer_rule]: \"(poly_rel ===> R) (lead_coeff_i ops) lead_coeff\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> R) (lead_coeff_i ops) lead_coeff", "unfolding lead_coeff_i_def' [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> R) (\\<lambda>x. coeff_i ops x (degree_i x)) lead_coeff", "by transfer_prover"], ["", "(* minus_poly_rev_list *)"], ["", "lemma poly_rel_minus_poly_rev_list[transfer_rule]: \n  \"(list_all2 R ===> list_all2 R ===> list_all2 R) (minus_poly_rev_list_i ops) minus_poly_rev_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_all2 R ===> list_all2 R ===> list_all2 R)\n     (minus_poly_rev_list_i ops) minus_poly_rev_list", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>list_all2 R x y; list_all2 R xa ya\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_rev_list_i ops x xa)\n                          (minus_poly_rev_list y ya)", "case (1 x1 x2 y1 y2)"], ["proof (state)\nthis:\n  list_all2 R x1 x2\n  list_all2 R y1 y2\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>list_all2 R x y; list_all2 R xa ya\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_rev_list_i ops x xa)\n                          (minus_poly_rev_list y ya)", "thus ?case"], ["proof (prove)\nusing this:\n  list_all2 R x1 x2\n  list_all2 R y1 y2\n\ngoal (1 subgoal):\n 1. list_all2 R (minus_poly_rev_list_i ops x1 y1)\n     (minus_poly_rev_list x2 y2)", "proof (induct x1 y1 arbitrary: x2 y2 rule: minus_poly_rev_list_i.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xs y ys x2 y2.\n       \\<lbrakk>\\<And>x2 y2.\n                   \\<lbrakk>list_all2 R xs x2; list_all2 R ys y2\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R\n(minus_poly_rev_list_i ops xs ys) (minus_poly_rev_list x2 y2);\n        list_all2 R (x # xs) x2; list_all2 R (y # ys) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R\n                          (minus_poly_rev_list_i ops (x # xs) (y # ys))\n                          (minus_poly_rev_list x2 y2)\n 2. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs x2; list_all2 R [] y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_rev_list_i ops xs [])\n                          (minus_poly_rev_list x2 y2)\n 3. \\<And>y ys x2 y2.\n       \\<lbrakk>list_all2 R [] x2; list_all2 R (y # ys) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_rev_list_i ops [] (y # ys))\n                          (minus_poly_rev_list x2 y2)", "case (1 x1 xs1 y1 ys1 X2 Y2)"], ["proof (state)\nthis:\n  \\<lbrakk>list_all2 R xs1 ?x2.0; list_all2 R ys1 ?y2.0\\<rbrakk>\n  \\<Longrightarrow> list_all2 R (minus_poly_rev_list_i ops xs1 ys1)\n                     (minus_poly_rev_list ?x2.0 ?y2.0)\n  list_all2 R (x1 # xs1) X2\n  list_all2 R (y1 # ys1) Y2\n\ngoal (3 subgoals):\n 1. \\<And>x xs y ys x2 y2.\n       \\<lbrakk>\\<And>x2 y2.\n                   \\<lbrakk>list_all2 R xs x2; list_all2 R ys y2\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R\n(minus_poly_rev_list_i ops xs ys) (minus_poly_rev_list x2 y2);\n        list_all2 R (x # xs) x2; list_all2 R (y # ys) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R\n                          (minus_poly_rev_list_i ops (x # xs) (y # ys))\n                          (minus_poly_rev_list x2 y2)\n 2. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs x2; list_all2 R [] y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_rev_list_i ops xs [])\n                          (minus_poly_rev_list x2 y2)\n 3. \\<And>y ys x2 y2.\n       \\<lbrakk>list_all2 R [] x2; list_all2 R (y # ys) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_rev_list_i ops [] (y # ys))\n                          (minus_poly_rev_list x2 y2)", "from 1(2)"], ["proof (chain)\npicking this:\n  list_all2 R (x1 # xs1) X2", "obtain x2 xs2 where X2: \"X2 = x2 # xs2\""], ["proof (prove)\nusing this:\n  list_all2 R (x1 # xs1) X2\n\ngoal (1 subgoal):\n 1. (\\<And>x2 xs2. X2 = x2 # xs2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases X2, auto)"], ["proof (state)\nthis:\n  X2 = x2 # xs2\n\ngoal (3 subgoals):\n 1. \\<And>x xs y ys x2 y2.\n       \\<lbrakk>\\<And>x2 y2.\n                   \\<lbrakk>list_all2 R xs x2; list_all2 R ys y2\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R\n(minus_poly_rev_list_i ops xs ys) (minus_poly_rev_list x2 y2);\n        list_all2 R (x # xs) x2; list_all2 R (y # ys) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R\n                          (minus_poly_rev_list_i ops (x # xs) (y # ys))\n                          (minus_poly_rev_list x2 y2)\n 2. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs x2; list_all2 R [] y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_rev_list_i ops xs [])\n                          (minus_poly_rev_list x2 y2)\n 3. \\<And>y ys x2 y2.\n       \\<lbrakk>list_all2 R [] x2; list_all2 R (y # ys) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_rev_list_i ops [] (y # ys))\n                          (minus_poly_rev_list x2 y2)", "from 1(3)"], ["proof (chain)\npicking this:\n  list_all2 R (y1 # ys1) Y2", "obtain y2 ys2 where Y2: \"Y2 = y2 # ys2\""], ["proof (prove)\nusing this:\n  list_all2 R (y1 # ys1) Y2\n\ngoal (1 subgoal):\n 1. (\\<And>y2 ys2. Y2 = y2 # ys2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases Y2, auto)"], ["proof (state)\nthis:\n  Y2 = y2 # ys2\n\ngoal (3 subgoals):\n 1. \\<And>x xs y ys x2 y2.\n       \\<lbrakk>\\<And>x2 y2.\n                   \\<lbrakk>list_all2 R xs x2; list_all2 R ys y2\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R\n(minus_poly_rev_list_i ops xs ys) (minus_poly_rev_list x2 y2);\n        list_all2 R (x # xs) x2; list_all2 R (y # ys) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R\n                          (minus_poly_rev_list_i ops (x # xs) (y # ys))\n                          (minus_poly_rev_list x2 y2)\n 2. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs x2; list_all2 R [] y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_rev_list_i ops xs [])\n                          (minus_poly_rev_list x2 y2)\n 3. \\<And>y ys x2 y2.\n       \\<lbrakk>list_all2 R [] x2; list_all2 R (y # ys) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_rev_list_i ops [] (y # ys))\n                          (minus_poly_rev_list x2 y2)", "from 1(2) 1(3)"], ["proof (chain)\npicking this:\n  list_all2 R (x1 # xs1) X2\n  list_all2 R (y1 # ys1) Y2", "have [transfer_rule]: \"R x1 x2\" \"R y1 y2\" \n      and *: \"list_all2 R xs1 xs2\" \"list_all2 R ys1 ys2\""], ["proof (prove)\nusing this:\n  list_all2 R (x1 # xs1) X2\n  list_all2 R (y1 # ys1) Y2\n\ngoal (1 subgoal):\n 1. (R x1 x2 &&& R y1 y2) &&& list_all2 R xs1 xs2 &&& list_all2 R ys1 ys2", "unfolding X2 Y2"], ["proof (prove)\nusing this:\n  list_all2 R (x1 # xs1) (x2 # xs2)\n  list_all2 R (y1 # ys1) (y2 # ys2)\n\ngoal (1 subgoal):\n 1. (R x1 x2 &&& R y1 y2) &&& list_all2 R xs1 xs2 &&& list_all2 R ys1 ys2", "by auto"], ["proof (state)\nthis:\n  R x1 x2\n  R y1 y2\n  list_all2 R xs1 xs2\n  list_all2 R ys1 ys2\n\ngoal (3 subgoals):\n 1. \\<And>x xs y ys x2 y2.\n       \\<lbrakk>\\<And>x2 y2.\n                   \\<lbrakk>list_all2 R xs x2; list_all2 R ys y2\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R\n(minus_poly_rev_list_i ops xs ys) (minus_poly_rev_list x2 y2);\n        list_all2 R (x # xs) x2; list_all2 R (y # ys) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R\n                          (minus_poly_rev_list_i ops (x # xs) (y # ys))\n                          (minus_poly_rev_list x2 y2)\n 2. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs x2; list_all2 R [] y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_rev_list_i ops xs [])\n                          (minus_poly_rev_list x2 y2)\n 3. \\<And>y ys x2 y2.\n       \\<lbrakk>list_all2 R [] x2; list_all2 R (y # ys) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_rev_list_i ops [] (y # ys))\n                          (minus_poly_rev_list x2 y2)", "note [transfer_rule] = 1(1)[OF *]"], ["proof (state)\nthis:\n  list_all2 R (minus_poly_rev_list_i ops xs1 ys1)\n   (minus_poly_rev_list xs2 ys2)\n\ngoal (3 subgoals):\n 1. \\<And>x xs y ys x2 y2.\n       \\<lbrakk>\\<And>x2 y2.\n                   \\<lbrakk>list_all2 R xs x2; list_all2 R ys y2\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R\n(minus_poly_rev_list_i ops xs ys) (minus_poly_rev_list x2 y2);\n        list_all2 R (x # xs) x2; list_all2 R (y # ys) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R\n                          (minus_poly_rev_list_i ops (x # xs) (y # ys))\n                          (minus_poly_rev_list x2 y2)\n 2. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs x2; list_all2 R [] y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_rev_list_i ops xs [])\n                          (minus_poly_rev_list x2 y2)\n 3. \\<And>y ys x2 y2.\n       \\<lbrakk>list_all2 R [] x2; list_all2 R (y # ys) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_rev_list_i ops [] (y # ys))\n                          (minus_poly_rev_list x2 y2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R (minus_poly_rev_list_i ops (x1 # xs1) (y1 # ys1))\n     (minus_poly_rev_list X2 Y2)", "unfolding X2 Y2"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R (minus_poly_rev_list_i ops (x1 # xs1) (y1 # ys1))\n     (minus_poly_rev_list (x2 # xs2) (y2 # ys2))", "by (simp, intro conjI, transfer_prover+)"], ["proof (state)\nthis:\n  list_all2 R (minus_poly_rev_list_i ops (x1 # xs1) (y1 # ys1))\n   (minus_poly_rev_list X2 Y2)\n\ngoal (2 subgoals):\n 1. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs x2; list_all2 R [] y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_rev_list_i ops xs [])\n                          (minus_poly_rev_list x2 y2)\n 2. \\<And>y ys x2 y2.\n       \\<lbrakk>list_all2 R [] x2; list_all2 R (y # ys) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_rev_list_i ops [] (y # ys))\n                          (minus_poly_rev_list x2 y2)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs x2; list_all2 R [] y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_rev_list_i ops xs [])\n                          (minus_poly_rev_list x2 y2)\n 2. \\<And>y ys x2 y2.\n       \\<lbrakk>list_all2 R [] x2; list_all2 R (y # ys) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_rev_list_i ops [] (y # ys))\n                          (minus_poly_rev_list x2 y2)", "case (2 xs1 xs2 ys2)"], ["proof (state)\nthis:\n  list_all2 R xs1 xs2\n  list_all2 R [] ys2\n\ngoal (2 subgoals):\n 1. \\<And>xs x2 y2.\n       \\<lbrakk>list_all2 R xs x2; list_all2 R [] y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_rev_list_i ops xs [])\n                          (minus_poly_rev_list x2 y2)\n 2. \\<And>y ys x2 y2.\n       \\<lbrakk>list_all2 R [] x2; list_all2 R (y # ys) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_rev_list_i ops [] (y # ys))\n                          (minus_poly_rev_list x2 y2)", "thus ?case"], ["proof (prove)\nusing this:\n  list_all2 R xs1 xs2\n  list_all2 R [] ys2\n\ngoal (1 subgoal):\n 1. list_all2 R (minus_poly_rev_list_i ops xs1 [])\n     (minus_poly_rev_list xs2 ys2)", "by (cases xs2, auto)"], ["proof (state)\nthis:\n  list_all2 R (minus_poly_rev_list_i ops xs1 [])\n   (minus_poly_rev_list xs2 ys2)\n\ngoal (1 subgoal):\n 1. \\<And>y ys x2 y2.\n       \\<lbrakk>list_all2 R [] x2; list_all2 R (y # ys) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_rev_list_i ops [] (y # ys))\n                          (minus_poly_rev_list x2 y2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y ys x2 y2.\n       \\<lbrakk>list_all2 R [] x2; list_all2 R (y # ys) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_rev_list_i ops [] (y # ys))\n                          (minus_poly_rev_list x2 y2)", "case (3 xs2 y1 ys1 Y2)"], ["proof (state)\nthis:\n  list_all2 R [] ys1\n  list_all2 R (xs2 # y1) Y2\n\ngoal (1 subgoal):\n 1. \\<And>y ys x2 y2.\n       \\<lbrakk>list_all2 R [] x2; list_all2 R (y # ys) y2\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (minus_poly_rev_list_i ops [] (y # ys))\n                          (minus_poly_rev_list x2 y2)", "thus ?case"], ["proof (prove)\nusing this:\n  list_all2 R [] ys1\n  list_all2 R (xs2 # y1) Y2\n\ngoal (1 subgoal):\n 1. list_all2 R (minus_poly_rev_list_i ops [] (xs2 # y1))\n     (minus_poly_rev_list ys1 Y2)", "by (cases Y2, auto)"], ["proof (state)\nthis:\n  list_all2 R (minus_poly_rev_list_i ops [] (xs2 # y1))\n   (minus_poly_rev_list ys1 Y2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all2 R (minus_poly_rev_list_i ops x1 y1) (minus_poly_rev_list x2 y2)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* division *)"], ["", "lemma divmod_poly_one_main_i: assumes len: \"n \\<le> length Y\" and rel: \"list_all2 R x X\" \"list_all2 R y Y\"\n    \"list_all2 R z Z\" and n: \"n = N\"\n shows \"rel_prod (list_all2 R) (list_all2 R) (divmod_poly_one_main_i ops x y z n)\n    (divmod_poly_one_main_list X Y Z N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod (list_all2 R) (list_all2 R)\n     (divmod_poly_one_main_i ops x y z n)\n     (divmod_poly_one_main_list X Y Z N)", "using len rel"], ["proof (prove)\nusing this:\n  n \\<le> length Y\n  list_all2 R x X\n  list_all2 R y Y\n  list_all2 R z Z\n\ngoal (1 subgoal):\n 1. rel_prod (list_all2 R) (list_all2 R)\n     (divmod_poly_one_main_i ops x y z n)\n     (divmod_poly_one_main_list X Y Z N)", "unfolding n"], ["proof (prove)\nusing this:\n  N \\<le> length Y\n  list_all2 R x X\n  list_all2 R y Y\n  list_all2 R z Z\n\ngoal (1 subgoal):\n 1. rel_prod (list_all2 R) (list_all2 R)\n     (divmod_poly_one_main_i ops x y z N)\n     (divmod_poly_one_main_list X Y Z N)", "proof (induct N arbitrary: x X y Y z Z)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x X y Y z Z.\n       \\<lbrakk>0 \\<le> length Y; list_all2 R x X; list_all2 R y Y;\n        list_all2 R z Z\\<rbrakk>\n       \\<Longrightarrow> rel_prod (list_all2 R) (list_all2 R)\n                          (divmod_poly_one_main_i ops x y z 0)\n                          (divmod_poly_one_main_list X Y Z 0)\n 2. \\<And>N x X y Y z Z.\n       \\<lbrakk>\\<And>x X y Y z Z.\n                   \\<lbrakk>N \\<le> length Y; list_all2 R x X;\n                    list_all2 R y Y; list_all2 R z Z\\<rbrakk>\n                   \\<Longrightarrow> rel_prod (list_all2 R) (list_all2 R)\n(divmod_poly_one_main_i ops x y z N) (divmod_poly_one_main_list X Y Z N);\n        Suc N \\<le> length Y; list_all2 R x X; list_all2 R y Y;\n        list_all2 R z Z\\<rbrakk>\n       \\<Longrightarrow> rel_prod (list_all2 R) (list_all2 R)\n                          (divmod_poly_one_main_i ops x y z (Suc N))\n                          (divmod_poly_one_main_list X Y Z (Suc N))", "case (Suc n x X y Y z Z)"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<le> length ?Y; list_all2 R ?x ?X; list_all2 R ?y ?Y;\n   list_all2 R ?z ?Z\\<rbrakk>\n  \\<Longrightarrow> rel_prod (list_all2 R) (list_all2 R)\n                     (divmod_poly_one_main_i ops ?x ?y ?z n)\n                     (divmod_poly_one_main_list ?X ?Y ?Z n)\n  Suc n \\<le> length Y\n  list_all2 R x X\n  list_all2 R y Y\n  list_all2 R z Z\n\ngoal (2 subgoals):\n 1. \\<And>x X y Y z Z.\n       \\<lbrakk>0 \\<le> length Y; list_all2 R x X; list_all2 R y Y;\n        list_all2 R z Z\\<rbrakk>\n       \\<Longrightarrow> rel_prod (list_all2 R) (list_all2 R)\n                          (divmod_poly_one_main_i ops x y z 0)\n                          (divmod_poly_one_main_list X Y Z 0)\n 2. \\<And>N x X y Y z Z.\n       \\<lbrakk>\\<And>x X y Y z Z.\n                   \\<lbrakk>N \\<le> length Y; list_all2 R x X;\n                    list_all2 R y Y; list_all2 R z Z\\<rbrakk>\n                   \\<Longrightarrow> rel_prod (list_all2 R) (list_all2 R)\n(divmod_poly_one_main_i ops x y z N) (divmod_poly_one_main_list X Y Z N);\n        Suc N \\<le> length Y; list_all2 R x X; list_all2 R y Y;\n        list_all2 R z Z\\<rbrakk>\n       \\<Longrightarrow> rel_prod (list_all2 R) (list_all2 R)\n                          (divmod_poly_one_main_i ops x y z (Suc N))\n                          (divmod_poly_one_main_list X Y Z (Suc N))", "from Suc(2,4)"], ["proof (chain)\npicking this:\n  Suc n \\<le> length Y\n  list_all2 R y Y", "have [transfer_rule]: \"R (hd y) (hd Y)\""], ["proof (prove)\nusing this:\n  Suc n \\<le> length Y\n  list_all2 R y Y\n\ngoal (1 subgoal):\n 1. R (hd y) (hd Y)", "by (cases y; cases Y, auto)"], ["proof (state)\nthis:\n  R (hd y) (hd Y)\n\ngoal (2 subgoals):\n 1. \\<And>x X y Y z Z.\n       \\<lbrakk>0 \\<le> length Y; list_all2 R x X; list_all2 R y Y;\n        list_all2 R z Z\\<rbrakk>\n       \\<Longrightarrow> rel_prod (list_all2 R) (list_all2 R)\n                          (divmod_poly_one_main_i ops x y z 0)\n                          (divmod_poly_one_main_list X Y Z 0)\n 2. \\<And>N x X y Y z Z.\n       \\<lbrakk>\\<And>x X y Y z Z.\n                   \\<lbrakk>N \\<le> length Y; list_all2 R x X;\n                    list_all2 R y Y; list_all2 R z Z\\<rbrakk>\n                   \\<Longrightarrow> rel_prod (list_all2 R) (list_all2 R)\n(divmod_poly_one_main_i ops x y z N) (divmod_poly_one_main_list X Y Z N);\n        Suc N \\<le> length Y; list_all2 R x X; list_all2 R y Y;\n        list_all2 R z Z\\<rbrakk>\n       \\<Longrightarrow> rel_prod (list_all2 R) (list_all2 R)\n                          (divmod_poly_one_main_i ops x y z (Suc N))\n                          (divmod_poly_one_main_list X Y Z (Suc N))", "note [transfer_rule] = Suc(3-5)"], ["proof (state)\nthis:\n  list_all2 R x X\n  list_all2 R y Y\n  list_all2 R z Z\n\ngoal (2 subgoals):\n 1. \\<And>x X y Y z Z.\n       \\<lbrakk>0 \\<le> length Y; list_all2 R x X; list_all2 R y Y;\n        list_all2 R z Z\\<rbrakk>\n       \\<Longrightarrow> rel_prod (list_all2 R) (list_all2 R)\n                          (divmod_poly_one_main_i ops x y z 0)\n                          (divmod_poly_one_main_list X Y Z 0)\n 2. \\<And>N x X y Y z Z.\n       \\<lbrakk>\\<And>x X y Y z Z.\n                   \\<lbrakk>N \\<le> length Y; list_all2 R x X;\n                    list_all2 R y Y; list_all2 R z Z\\<rbrakk>\n                   \\<Longrightarrow> rel_prod (list_all2 R) (list_all2 R)\n(divmod_poly_one_main_i ops x y z N) (divmod_poly_one_main_list X Y Z N);\n        Suc N \\<le> length Y; list_all2 R x X; list_all2 R y Y;\n        list_all2 R z Z\\<rbrakk>\n       \\<Longrightarrow> rel_prod (list_all2 R) (list_all2 R)\n                          (divmod_poly_one_main_i ops x y z (Suc N))\n                          (divmod_poly_one_main_list X Y Z (Suc N))", "have id: \"?case = (rel_prod (list_all2 R) (list_all2 R)\n     (divmod_poly_one_main_i ops (cCons_i ops (hd y) x)\n       (tl (if hd y = zero then y else minus_poly_rev_list_i ops y (map (times (hd y)) z))) z n)\n     (divmod_poly_one_main_list (cCons (hd Y) X)\n       (tl (if hd Y = 0 then Y else minus_poly_rev_list Y (map ((*) (hd Y)) Z))) Z n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod (list_all2 R) (list_all2 R)\n     (divmod_poly_one_main_i ops x y z (Suc n))\n     (divmod_poly_one_main_list X Y Z (Suc n)) =\n    rel_prod (list_all2 R) (list_all2 R)\n     (divmod_poly_one_main_i ops (cCons_i ops (hd y) x)\n       (tl (if hd y = arith_ops_record.zero ops then y\n            else minus_poly_rev_list_i ops y\n                  (map (arith_ops_record.times ops (hd y)) z)))\n       z n)\n     (divmod_poly_one_main_list (cCons (hd Y) X)\n       (tl (if hd Y = (0::'a) then Y\n            else minus_poly_rev_list Y (map ((*) (hd Y)) Z)))\n       Z n)", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  rel_prod (list_all2 R) (list_all2 R)\n   (divmod_poly_one_main_i ops x y z (Suc n))\n   (divmod_poly_one_main_list X Y Z (Suc n)) =\n  rel_prod (list_all2 R) (list_all2 R)\n   (divmod_poly_one_main_i ops (cCons_i ops (hd y) x)\n     (tl (if hd y = arith_ops_record.zero ops then y\n          else minus_poly_rev_list_i ops y\n                (map (arith_ops_record.times ops (hd y)) z)))\n     z n)\n   (divmod_poly_one_main_list (cCons (hd Y) X)\n     (tl (if hd Y = (0::'a) then Y\n          else minus_poly_rev_list Y (map ((*) (hd Y)) Z)))\n     Z n)\n\ngoal (2 subgoals):\n 1. \\<And>x X y Y z Z.\n       \\<lbrakk>0 \\<le> length Y; list_all2 R x X; list_all2 R y Y;\n        list_all2 R z Z\\<rbrakk>\n       \\<Longrightarrow> rel_prod (list_all2 R) (list_all2 R)\n                          (divmod_poly_one_main_i ops x y z 0)\n                          (divmod_poly_one_main_list X Y Z 0)\n 2. \\<And>N x X y Y z Z.\n       \\<lbrakk>\\<And>x X y Y z Z.\n                   \\<lbrakk>N \\<le> length Y; list_all2 R x X;\n                    list_all2 R y Y; list_all2 R z Z\\<rbrakk>\n                   \\<Longrightarrow> rel_prod (list_all2 R) (list_all2 R)\n(divmod_poly_one_main_i ops x y z N) (divmod_poly_one_main_list X Y Z N);\n        Suc N \\<le> length Y; list_all2 R x X; list_all2 R y Y;\n        list_all2 R z Z\\<rbrakk>\n       \\<Longrightarrow> rel_prod (list_all2 R) (list_all2 R)\n                          (divmod_poly_one_main_i ops x y z (Suc N))\n                          (divmod_poly_one_main_list X Y Z (Suc N))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod (list_all2 R) (list_all2 R)\n     (divmod_poly_one_main_i ops x y z (Suc n))\n     (divmod_poly_one_main_list X Y Z (Suc n))", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod (list_all2 R) (list_all2 R)\n     (divmod_poly_one_main_i ops (cCons_i ops (hd y) x)\n       (tl (if hd y = arith_ops_record.zero ops then y\n            else minus_poly_rev_list_i ops y\n                  (map (arith_ops_record.times ops (hd y)) z)))\n       z n)\n     (divmod_poly_one_main_list (cCons (hd Y) X)\n       (tl (if hd Y = (0::'a) then Y\n            else minus_poly_rev_list Y (map ((*) (hd Y)) Z)))\n       Z n)", "proof (rule Suc(1), goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. n \\<le> length\n             (tl (if hd Y = (0::'a) then Y\n                  else minus_poly_rev_list Y (map ((*) (hd Y)) Z)))\n 2. list_all2 R (cCons_i ops (hd y) x) (cCons (hd Y) X)\n 3. list_all2 R\n     (tl (if hd y = arith_ops_record.zero ops then y\n          else minus_poly_rev_list_i ops y\n                (map (arith_ops_record.times ops (hd y)) z)))\n     (tl (if hd Y = (0::'a) then Y\n          else minus_poly_rev_list Y (map ((*) (hd Y)) Z)))\n 4. list_all2 R z Z", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. n \\<le> length\n             (tl (if hd Y = (0::'a) then Y\n                  else minus_poly_rev_list Y (map ((*) (hd Y)) Z)))\n 2. list_all2 R (cCons_i ops (hd y) x) (cCons (hd Y) X)\n 3. list_all2 R\n     (tl (if hd y = arith_ops_record.zero ops then y\n          else minus_poly_rev_list_i ops y\n                (map (arith_ops_record.times ops (hd y)) z)))\n     (tl (if hd Y = (0::'a) then Y\n          else minus_poly_rev_list Y (map ((*) (hd Y)) Z)))\n 4. list_all2 R z Z", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length\n             (tl (if hd Y = (0::'a) then Y\n                  else minus_poly_rev_list Y (map ((*) (hd Y)) Z)))", "using Suc(2)"], ["proof (prove)\nusing this:\n  Suc n \\<le> length Y\n\ngoal (1 subgoal):\n 1. n \\<le> length\n             (tl (if hd Y = (0::'a) then Y\n                  else minus_poly_rev_list Y (map ((*) (hd Y)) Z)))", "by simp"], ["proof (state)\nthis:\n  n \\<le> length\n           (tl (if hd Y = (0::'a) then Y\n                else minus_poly_rev_list Y (map ((*) (hd Y)) Z)))\n\ngoal (3 subgoals):\n 1. list_all2 R (cCons_i ops (hd y) x) (cCons (hd Y) X)\n 2. list_all2 R\n     (tl (if hd y = arith_ops_record.zero ops then y\n          else minus_poly_rev_list_i ops y\n                (map (arith_ops_record.times ops (hd y)) z)))\n     (tl (if hd Y = (0::'a) then Y\n          else minus_poly_rev_list Y (map ((*) (hd Y)) Z)))\n 3. list_all2 R z Z", "qed (transfer_prover+)"], ["proof (state)\nthis:\n  rel_prod (list_all2 R) (list_all2 R)\n   (divmod_poly_one_main_i ops x y z (Suc n))\n   (divmod_poly_one_main_list X Y Z (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>x X y Y z Z.\n       \\<lbrakk>0 \\<le> length Y; list_all2 R x X; list_all2 R y Y;\n        list_all2 R z Z\\<rbrakk>\n       \\<Longrightarrow> rel_prod (list_all2 R) (list_all2 R)\n                          (divmod_poly_one_main_i ops x y z 0)\n                          (divmod_poly_one_main_list X Y Z 0)", "qed simp"], ["", "(* modulo *)"], ["", "lemma mod_poly_one_main_i: assumes len: \"n \\<le> length X\" and rel: \"list_all2 R x X\" \"list_all2 R y Y\"\n    and n: \"n = N\"\n shows \"list_all2 R (mod_poly_one_main_i ops x y n)\n    (mod_poly_one_main_list X Y N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R (mod_poly_one_main_i ops x y n)\n     (mod_poly_one_main_list X Y N)", "using len rel"], ["proof (prove)\nusing this:\n  n \\<le> length X\n  list_all2 R x X\n  list_all2 R y Y\n\ngoal (1 subgoal):\n 1. list_all2 R (mod_poly_one_main_i ops x y n)\n     (mod_poly_one_main_list X Y N)", "unfolding n"], ["proof (prove)\nusing this:\n  N \\<le> length X\n  list_all2 R x X\n  list_all2 R y Y\n\ngoal (1 subgoal):\n 1. list_all2 R (mod_poly_one_main_i ops x y N)\n     (mod_poly_one_main_list X Y N)", "proof (induct N arbitrary: x X y Y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x X y Y.\n       \\<lbrakk>0 \\<le> length X; list_all2 R x X; list_all2 R y Y\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (mod_poly_one_main_i ops x y 0)\n                          (mod_poly_one_main_list X Y 0)\n 2. \\<And>N x X y Y.\n       \\<lbrakk>\\<And>x X y Y.\n                   \\<lbrakk>N \\<le> length X; list_all2 R x X;\n                    list_all2 R y Y\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R\n(mod_poly_one_main_i ops x y N) (mod_poly_one_main_list X Y N);\n        Suc N \\<le> length X; list_all2 R x X; list_all2 R y Y\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (mod_poly_one_main_i ops x y (Suc N))\n                          (mod_poly_one_main_list X Y (Suc N))", "case (Suc n y Y z Z)"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<le> length ?X; list_all2 R ?x ?X; list_all2 R ?y ?Y\\<rbrakk>\n  \\<Longrightarrow> list_all2 R (mod_poly_one_main_i ops ?x ?y n)\n                     (mod_poly_one_main_list ?X ?Y n)\n  Suc n \\<le> length Y\n  list_all2 R y Y\n  list_all2 R z Z\n\ngoal (2 subgoals):\n 1. \\<And>x X y Y.\n       \\<lbrakk>0 \\<le> length X; list_all2 R x X; list_all2 R y Y\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (mod_poly_one_main_i ops x y 0)\n                          (mod_poly_one_main_list X Y 0)\n 2. \\<And>N x X y Y.\n       \\<lbrakk>\\<And>x X y Y.\n                   \\<lbrakk>N \\<le> length X; list_all2 R x X;\n                    list_all2 R y Y\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R\n(mod_poly_one_main_i ops x y N) (mod_poly_one_main_list X Y N);\n        Suc N \\<le> length X; list_all2 R x X; list_all2 R y Y\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (mod_poly_one_main_i ops x y (Suc N))\n                          (mod_poly_one_main_list X Y (Suc N))", "from Suc(2,3)"], ["proof (chain)\npicking this:\n  Suc n \\<le> length Y\n  list_all2 R y Y", "have [transfer_rule]: \"R (hd y) (hd Y)\""], ["proof (prove)\nusing this:\n  Suc n \\<le> length Y\n  list_all2 R y Y\n\ngoal (1 subgoal):\n 1. R (hd y) (hd Y)", "by (cases y; cases Y, auto)"], ["proof (state)\nthis:\n  R (hd y) (hd Y)\n\ngoal (2 subgoals):\n 1. \\<And>x X y Y.\n       \\<lbrakk>0 \\<le> length X; list_all2 R x X; list_all2 R y Y\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (mod_poly_one_main_i ops x y 0)\n                          (mod_poly_one_main_list X Y 0)\n 2. \\<And>N x X y Y.\n       \\<lbrakk>\\<And>x X y Y.\n                   \\<lbrakk>N \\<le> length X; list_all2 R x X;\n                    list_all2 R y Y\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R\n(mod_poly_one_main_i ops x y N) (mod_poly_one_main_list X Y N);\n        Suc N \\<le> length X; list_all2 R x X; list_all2 R y Y\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (mod_poly_one_main_i ops x y (Suc N))\n                          (mod_poly_one_main_list X Y (Suc N))", "note [transfer_rule] = Suc(3-4)"], ["proof (state)\nthis:\n  list_all2 R y Y\n  list_all2 R z Z\n\ngoal (2 subgoals):\n 1. \\<And>x X y Y.\n       \\<lbrakk>0 \\<le> length X; list_all2 R x X; list_all2 R y Y\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (mod_poly_one_main_i ops x y 0)\n                          (mod_poly_one_main_list X Y 0)\n 2. \\<And>N x X y Y.\n       \\<lbrakk>\\<And>x X y Y.\n                   \\<lbrakk>N \\<le> length X; list_all2 R x X;\n                    list_all2 R y Y\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R\n(mod_poly_one_main_i ops x y N) (mod_poly_one_main_list X Y N);\n        Suc N \\<le> length X; list_all2 R x X; list_all2 R y Y\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (mod_poly_one_main_i ops x y (Suc N))\n                          (mod_poly_one_main_list X Y (Suc N))", "have id: \"?case = (list_all2 R\n     (mod_poly_one_main_i ops\n       (tl (if hd y = zero then y else minus_poly_rev_list_i ops y (map (times (hd y)) z))) z n)\n     (mod_poly_one_main_list \n       (tl (if hd Y = 0 then Y else minus_poly_rev_list Y (map ((*) (hd Y)) Z))) Z n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R (mod_poly_one_main_i ops y z (Suc n))\n     (mod_poly_one_main_list Y Z (Suc n)) =\n    list_all2 R\n     (mod_poly_one_main_i ops\n       (tl (if hd y = arith_ops_record.zero ops then y\n            else minus_poly_rev_list_i ops y\n                  (map (arith_ops_record.times ops (hd y)) z)))\n       z n)\n     (mod_poly_one_main_list\n       (tl (if hd Y = (0::'a) then Y\n            else minus_poly_rev_list Y (map ((*) (hd Y)) Z)))\n       Z n)", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  list_all2 R (mod_poly_one_main_i ops y z (Suc n))\n   (mod_poly_one_main_list Y Z (Suc n)) =\n  list_all2 R\n   (mod_poly_one_main_i ops\n     (tl (if hd y = arith_ops_record.zero ops then y\n          else minus_poly_rev_list_i ops y\n                (map (arith_ops_record.times ops (hd y)) z)))\n     z n)\n   (mod_poly_one_main_list\n     (tl (if hd Y = (0::'a) then Y\n          else minus_poly_rev_list Y (map ((*) (hd Y)) Z)))\n     Z n)\n\ngoal (2 subgoals):\n 1. \\<And>x X y Y.\n       \\<lbrakk>0 \\<le> length X; list_all2 R x X; list_all2 R y Y\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (mod_poly_one_main_i ops x y 0)\n                          (mod_poly_one_main_list X Y 0)\n 2. \\<And>N x X y Y.\n       \\<lbrakk>\\<And>x X y Y.\n                   \\<lbrakk>N \\<le> length X; list_all2 R x X;\n                    list_all2 R y Y\\<rbrakk>\n                   \\<Longrightarrow> list_all2 R\n(mod_poly_one_main_i ops x y N) (mod_poly_one_main_list X Y N);\n        Suc N \\<le> length X; list_all2 R x X; list_all2 R y Y\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (mod_poly_one_main_i ops x y (Suc N))\n                          (mod_poly_one_main_list X Y (Suc N))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R (mod_poly_one_main_i ops y z (Suc n))\n     (mod_poly_one_main_list Y Z (Suc n))", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R\n     (mod_poly_one_main_i ops\n       (tl (if hd y = arith_ops_record.zero ops then y\n            else minus_poly_rev_list_i ops y\n                  (map (arith_ops_record.times ops (hd y)) z)))\n       z n)\n     (mod_poly_one_main_list\n       (tl (if hd Y = (0::'a) then Y\n            else minus_poly_rev_list Y (map ((*) (hd Y)) Z)))\n       Z n)", "proof (rule Suc(1), goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. n \\<le> length\n             (tl (if hd Y = (0::'a) then Y\n                  else minus_poly_rev_list Y (map ((*) (hd Y)) Z)))\n 2. list_all2 R\n     (tl (if hd y = arith_ops_record.zero ops then y\n          else minus_poly_rev_list_i ops y\n                (map (arith_ops_record.times ops (hd y)) z)))\n     (tl (if hd Y = (0::'a) then Y\n          else minus_poly_rev_list Y (map ((*) (hd Y)) Z)))\n 3. list_all2 R z Z", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. n \\<le> length\n             (tl (if hd Y = (0::'a) then Y\n                  else minus_poly_rev_list Y (map ((*) (hd Y)) Z)))\n 2. list_all2 R\n     (tl (if hd y = arith_ops_record.zero ops then y\n          else minus_poly_rev_list_i ops y\n                (map (arith_ops_record.times ops (hd y)) z)))\n     (tl (if hd Y = (0::'a) then Y\n          else minus_poly_rev_list Y (map ((*) (hd Y)) Z)))\n 3. list_all2 R z Z", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length\n             (tl (if hd Y = (0::'a) then Y\n                  else minus_poly_rev_list Y (map ((*) (hd Y)) Z)))", "using Suc(2)"], ["proof (prove)\nusing this:\n  Suc n \\<le> length Y\n\ngoal (1 subgoal):\n 1. n \\<le> length\n             (tl (if hd Y = (0::'a) then Y\n                  else minus_poly_rev_list Y (map ((*) (hd Y)) Z)))", "by simp"], ["proof (state)\nthis:\n  n \\<le> length\n           (tl (if hd Y = (0::'a) then Y\n                else minus_poly_rev_list Y (map ((*) (hd Y)) Z)))\n\ngoal (2 subgoals):\n 1. list_all2 R\n     (tl (if hd y = arith_ops_record.zero ops then y\n          else minus_poly_rev_list_i ops y\n                (map (arith_ops_record.times ops (hd y)) z)))\n     (tl (if hd Y = (0::'a) then Y\n          else minus_poly_rev_list Y (map ((*) (hd Y)) Z)))\n 2. list_all2 R z Z", "qed (transfer_prover+)"], ["proof (state)\nthis:\n  list_all2 R (mod_poly_one_main_i ops y z (Suc n))\n   (mod_poly_one_main_list Y Z (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>x X y Y.\n       \\<lbrakk>0 \\<le> length X; list_all2 R x X; list_all2 R y Y\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (mod_poly_one_main_i ops x y 0)\n                          (mod_poly_one_main_list X Y 0)", "qed simp"], ["", "lemma poly_rel_dvd[transfer_rule]: \"(poly_rel ===> poly_rel ===> (=)) (dvd_poly_i ops) (dvd)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> poly_rel ===> (=)) (dvd_poly_i ops) (dvd)", "unfolding dvd_poly_i_def[abs_def] dvd_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> poly_rel ===> (=))\n     (\\<lambda>xs ys.\n         \\<exists>zs. is_poly ops zs \\<and> ys = times_poly_i ops xs zs)\n     (\\<lambda>b a. \\<exists>k. a = b * k)", "by (transfer_prover_start, transfer_step+, auto)"], ["", "lemma poly_rel_monic[transfer_rule]: \"(poly_rel ===> (=)) (monic_i ops) monic\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> (=)) (monic_i ops) monic", "unfolding monic_i_def lead_coeff_i_def'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> (=))\n     (\\<lambda>pp. coeff_i ops pp (degree_i pp) = arith_ops_record.one ops)\n     monic", "by transfer_prover"], ["", "lemma poly_rel_pdivmod_monic: assumes mon: \"monic Y\" \n  and x: \"poly_rel x X\" and y: \"poly_rel y Y\"\n  shows \"rel_prod poly_rel poly_rel (pdivmod_monic_i ops x y) (pdivmod_monic X Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod poly_rel poly_rel (pdivmod_monic_i ops x y) (pdivmod_monic X Y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_prod poly_rel poly_rel (pdivmod_monic_i ops x y) (pdivmod_monic X Y)", "note [transfer_rule] = x y"], ["proof (state)\nthis:\n  poly_rel x X\n  poly_rel y Y\n\ngoal (1 subgoal):\n 1. rel_prod poly_rel poly_rel (pdivmod_monic_i ops x y) (pdivmod_monic X Y)", "note listall = this[unfolded poly_rel_def]"], ["proof (state)\nthis:\n  list_all2 R x (coeffs X)\n  list_all2 R y (coeffs Y)\n\ngoal (1 subgoal):\n 1. rel_prod poly_rel poly_rel (pdivmod_monic_i ops x y) (pdivmod_monic X Y)", "note defs = pdivmod_monic_def pdivmod_monic_i_def Let_def"], ["proof (state)\nthis:\n  pdivmod_monic ?f ?g \\<equiv>\n  let cg = coeffs ?g; cf = coeffs ?f;\n      (q, r) =\n        divmod_poly_one_main_list [] (rev cf) (rev cg)\n         (1 + length cf - length cg)\n  in (poly_of_list q, poly_of_list (rev r))\n  pdivmod_monic_i ?ops ?cf ?cg \\<equiv>\n  case divmod_poly_one_main_i ?ops [] (rev ?cf) (rev ?cg)\n        (1 + length ?cf - length ?cg) of\n  (q, r) \\<Rightarrow> (poly_of_list_i ?ops q, poly_of_list_i ?ops (rev r))\n  Let ?s ?f \\<equiv> ?f ?s\n\ngoal (1 subgoal):\n 1. rel_prod poly_rel poly_rel (pdivmod_monic_i ops x y) (pdivmod_monic X Y)", "from mon"], ["proof (chain)\npicking this:\n  monic Y", "obtain k where len: \"length (coeffs Y) = Suc k\""], ["proof (prove)\nusing this:\n  monic Y\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        length (coeffs Y) = Suc k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding poly_rel_def list_all2_iff"], ["proof (prove)\nusing this:\n  monic Y\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        length (coeffs Y) = Suc k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"coeffs Y\", auto)"], ["proof (state)\nthis:\n  length (coeffs Y) = Suc k\n\ngoal (1 subgoal):\n 1. rel_prod poly_rel poly_rel (pdivmod_monic_i ops x y) (pdivmod_monic X Y)", "have [transfer_rule]: \n    \"rel_prod (list_all2 R) (list_all2 R)\n       (divmod_poly_one_main_i ops [] (rev x) (rev y) (1 + length x - length y))\n       (divmod_poly_one_main_list [] (rev (coeffs X)) (rev (coeffs Y)) (1 + length (coeffs X) - length (coeffs Y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod (list_all2 R) (list_all2 R)\n     (divmod_poly_one_main_i ops [] (rev x) (rev y)\n       (1 + length x - length y))\n     (divmod_poly_one_main_list [] (rev (coeffs X)) (rev (coeffs Y))\n       (1 + length (coeffs X) - length (coeffs Y)))", "by (rule divmod_poly_one_main_i, insert x y listall, auto, auto simp: poly_rel_def list_all2_iff len)"], ["proof (state)\nthis:\n  rel_prod (list_all2 R) (list_all2 R)\n   (divmod_poly_one_main_i ops [] (rev x) (rev y) (1 + length x - length y))\n   (divmod_poly_one_main_list [] (rev (coeffs X)) (rev (coeffs Y))\n     (1 + length (coeffs X) - length (coeffs Y)))\n\ngoal (1 subgoal):\n 1. rel_prod poly_rel poly_rel (pdivmod_monic_i ops x y) (pdivmod_monic X Y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod poly_rel poly_rel (pdivmod_monic_i ops x y) (pdivmod_monic X Y)", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod poly_rel poly_rel\n     (case divmod_poly_one_main_i ops [] (rev x) (rev y)\n            (1 + length x - length y) of\n      (q, r) \\<Rightarrow>\n        (poly_of_list_i ops q, poly_of_list_i ops (rev r)))\n     (case divmod_poly_one_main_list [] (rev (coeffs X)) (rev (coeffs Y))\n            (1 + length (coeffs X) - length (coeffs Y)) of\n      (q, r) \\<Rightarrow> (poly_of_list q, poly_of_list (rev r)))", "by transfer_prover"], ["proof (state)\nthis:\n  rel_prod poly_rel poly_rel (pdivmod_monic_i ops x y) (pdivmod_monic X Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ring_ops_poly: \"ring_ops (poly_ops ops) poly_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_ops (poly_ops ops) poly_rel", "by (unfold_locales, auto simp: poly_ops_def  \n  bi_unique_poly_rel \n  right_total_poly_rel\n  poly_rel_times\n  poly_rel_zero \n  poly_rel_one\n  poly_rel_minus\n  poly_rel_uminus\n  poly_rel_plus\n  poly_rel_eq\n  Domainp_is_poly)"], ["", "end"], ["", "context idom_ops\nbegin"], ["", "(* pderiv *)"], ["", "lemma poly_rel_pderiv [transfer_rule]: \"(poly_rel ===> poly_rel) (pderiv_i ops) pderiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> poly_rel) (pderiv_i ops) pderiv", "proof (intro rel_funI, unfold poly_rel_def coeffs_pderiv_code pderiv_i_def pderiv_coeffs_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       list_all2 R x (coeffs y) \\<Longrightarrow>\n       list_all2 R (pderiv_main_i ops (arith_ops_record.one ops) (tl x))\n        (pderiv_coeffs_code (1::'a) (tl (coeffs y)))", "fix xs xs'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       list_all2 R x (coeffs y) \\<Longrightarrow>\n       list_all2 R (pderiv_main_i ops (arith_ops_record.one ops) (tl x))\n        (pderiv_coeffs_code (1::'a) (tl (coeffs y)))", "assume \"list_all2 R xs (coeffs xs')\""], ["proof (state)\nthis:\n  list_all2 R xs (coeffs xs')\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       list_all2 R x (coeffs y) \\<Longrightarrow>\n       list_all2 R (pderiv_main_i ops (arith_ops_record.one ops) (tl x))\n        (pderiv_coeffs_code (1::'a) (tl (coeffs y)))", "then"], ["proof (chain)\npicking this:\n  list_all2 R xs (coeffs xs')", "obtain ys ys' y y' where id: \"tl xs = ys\" \"tl (coeffs xs') = ys'\" \"one = y\" \"1 = y'\" and \n    R: \"list_all2 R ys ys'\" \"R y y'\""], ["proof (prove)\nusing this:\n  list_all2 R xs (coeffs xs')\n\ngoal (1 subgoal):\n 1. (\\<And>ys ys' y y'.\n        \\<lbrakk>tl xs = ys; tl (coeffs xs') = ys';\n         arith_ops_record.one ops = y; (1::'a) = y'; list_all2 R ys ys';\n         R y y'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases xs; cases \"coeffs xs'\"; auto simp: one)"], ["proof (state)\nthis:\n  tl xs = ys\n  tl (coeffs xs') = ys'\n  arith_ops_record.one ops = y\n  (1::'a) = y'\n  list_all2 R ys ys'\n  R y y'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       list_all2 R x (coeffs y) \\<Longrightarrow>\n       list_all2 R (pderiv_main_i ops (arith_ops_record.one ops) (tl x))\n        (pderiv_coeffs_code (1::'a) (tl (coeffs y)))", "show \"list_all2 R (pderiv_main_i ops one (tl xs))\n            (pderiv_coeffs_code 1 (tl (coeffs xs')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R (pderiv_main_i ops (arith_ops_record.one ops) (tl xs))\n     (pderiv_coeffs_code (1::'a) (tl (coeffs xs')))", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R (pderiv_main_i ops y ys) (pderiv_coeffs_code y' ys')", "using R"], ["proof (prove)\nusing this:\n  list_all2 R ys ys'\n  R y y'\n\ngoal (1 subgoal):\n 1. list_all2 R (pderiv_main_i ops y ys) (pderiv_coeffs_code y' ys')", "proof (induct ys ys' arbitrary: y y' rule: list_all2_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y y'.\n       R y y' \\<Longrightarrow>\n       list_all2 R (pderiv_main_i ops y []) (pderiv_coeffs_code y' [])\n 2. \\<And>x xs y ys ya y'.\n       \\<lbrakk>R x y; list_all2 R xs ys;\n        \\<And>y y'.\n           R y y' \\<Longrightarrow>\n           list_all2 R (pderiv_main_i ops y xs) (pderiv_coeffs_code y' ys);\n        R ya y'\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (pderiv_main_i ops ya (x # xs))\n                          (pderiv_coeffs_code y' (y # ys))", "case (Cons x xs x' xs' y y')"], ["proof (state)\nthis:\n  R x x'\n  list_all2 R xs xs'\n  R ?y ?y' \\<Longrightarrow>\n  list_all2 R (pderiv_main_i ops ?y xs) (pderiv_coeffs_code ?y' xs')\n  R y y'\n\ngoal (2 subgoals):\n 1. \\<And>y y'.\n       R y y' \\<Longrightarrow>\n       list_all2 R (pderiv_main_i ops y []) (pderiv_coeffs_code y' [])\n 2. \\<And>x xs y ys ya y'.\n       \\<lbrakk>R x y; list_all2 R xs ys;\n        \\<And>y y'.\n           R y y' \\<Longrightarrow>\n           list_all2 R (pderiv_main_i ops y xs) (pderiv_coeffs_code y' ys);\n        R ya y'\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (pderiv_main_i ops ya (x # xs))\n                          (pderiv_coeffs_code y' (y # ys))", "note [transfer_rule] = Cons(1,2,4)"], ["proof (state)\nthis:\n  R x x'\n  list_all2 R xs xs'\n  R y y'\n\ngoal (2 subgoals):\n 1. \\<And>y y'.\n       R y y' \\<Longrightarrow>\n       list_all2 R (pderiv_main_i ops y []) (pderiv_coeffs_code y' [])\n 2. \\<And>x xs y ys ya y'.\n       \\<lbrakk>R x y; list_all2 R xs ys;\n        \\<And>y y'.\n           R y y' \\<Longrightarrow>\n           list_all2 R (pderiv_main_i ops y xs) (pderiv_coeffs_code y' ys);\n        R ya y'\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (pderiv_main_i ops ya (x # xs))\n                          (pderiv_coeffs_code y' (y # ys))", "have \"R (plus y one) (y' + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (arith_ops_record.plus ops y (arith_ops_record.one ops))\n     (y' + (1::'a))", "by transfer_prover"], ["proof (state)\nthis:\n  R (arith_ops_record.plus ops y (arith_ops_record.one ops)) (y' + (1::'a))\n\ngoal (2 subgoals):\n 1. \\<And>y y'.\n       R y y' \\<Longrightarrow>\n       list_all2 R (pderiv_main_i ops y []) (pderiv_coeffs_code y' [])\n 2. \\<And>x xs y ys ya y'.\n       \\<lbrakk>R x y; list_all2 R xs ys;\n        \\<And>y y'.\n           R y y' \\<Longrightarrow>\n           list_all2 R (pderiv_main_i ops y xs) (pderiv_coeffs_code y' ys);\n        R ya y'\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (pderiv_main_i ops ya (x # xs))\n                          (pderiv_coeffs_code y' (y # ys))", "note [transfer_rule] = Cons(3)[OF this]"], ["proof (state)\nthis:\n  list_all2 R\n   (pderiv_main_i ops\n     (arith_ops_record.plus ops y (arith_ops_record.one ops)) xs)\n   (pderiv_coeffs_code (y' + (1::'a)) xs')\n\ngoal (2 subgoals):\n 1. \\<And>y y'.\n       R y y' \\<Longrightarrow>\n       list_all2 R (pderiv_main_i ops y []) (pderiv_coeffs_code y' [])\n 2. \\<And>x xs y ys ya y'.\n       \\<lbrakk>R x y; list_all2 R xs ys;\n        \\<And>y y'.\n           R y y' \\<Longrightarrow>\n           list_all2 R (pderiv_main_i ops y xs) (pderiv_coeffs_code y' ys);\n        R ya y'\\<rbrakk>\n       \\<Longrightarrow> list_all2 R (pderiv_main_i ops ya (x # xs))\n                          (pderiv_coeffs_code y' (y # ys))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R (pderiv_main_i ops y (x # xs))\n     (pderiv_coeffs_code y' (x' # xs'))", "by (simp, transfer_prover)"], ["proof (state)\nthis:\n  list_all2 R (pderiv_main_i ops y (x # xs))\n   (pderiv_coeffs_code y' (x' # xs'))\n\ngoal (1 subgoal):\n 1. \\<And>y y'.\n       R y y' \\<Longrightarrow>\n       list_all2 R (pderiv_main_i ops y []) (pderiv_coeffs_code y' [])", "qed simp"], ["proof (state)\nthis:\n  list_all2 R (pderiv_main_i ops (arith_ops_record.one ops) (tl xs))\n   (pderiv_coeffs_code (1::'a) (tl (coeffs xs')))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_rel_irreducible[transfer_rule]: \"(poly_rel ===> (=)) (irreducible_i ops) irreducible\\<^sub>d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> (=)) (irreducible_i ops) irreducible\\<^sub>d", "unfolding irreducible_i_def[abs_def] irreducible\\<^sub>d_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> (=))\n     (\\<lambda>xs.\n         degree_i xs \\<noteq> 0 \\<and>\n         (\\<forall>q r.\n             is_poly ops q \\<longrightarrow>\n             is_poly ops r \\<longrightarrow>\n             degree_i q < degree_i xs \\<longrightarrow>\n             degree_i r < degree_i xs \\<longrightarrow>\n             xs \\<noteq> times_poly_i ops q r))\n     (\\<lambda>p.\n         0 < degree p \\<and>\n         (\\<forall>q r.\n             degree q < degree p \\<longrightarrow>\n             degree r < degree p \\<longrightarrow> p \\<noteq> q * r))", "by (transfer_prover_start, transfer_step+, auto)"], ["", "lemma idom_ops_poly: \"idom_ops (poly_ops ops) poly_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idom_ops (poly_ops ops) poly_rel", "using ring_ops_poly"], ["proof (prove)\nusing this:\n  ring_ops (poly_ops ops) poly_rel\n\ngoal (1 subgoal):\n 1. idom_ops (poly_ops ops) poly_rel", "unfolding ring_ops_def idom_ops_def"], ["proof (prove)\nusing this:\n  ((bi_unique poly_rel \\<and> right_total poly_rel) \\<and>\n   poly_rel (arith_ops_record.zero (poly_ops ops)) 0 \\<and>\n   poly_rel (arith_ops_record.one (poly_ops ops)) 1 \\<and>\n   (poly_rel ===> poly_rel ===> poly_rel)\n    (arith_ops_record.plus (poly_ops ops)) (+)) \\<and>\n  ((poly_rel ===> poly_rel ===> poly_rel)\n    (arith_ops_record.minus (poly_ops ops)) (-) \\<and>\n   (poly_rel ===> poly_rel) (arith_ops_record.uminus (poly_ops ops))\n    uminus_class.uminus) \\<and>\n  (poly_rel ===> poly_rel ===> poly_rel)\n   (arith_ops_record.times (poly_ops ops)) (*) \\<and>\n  (poly_rel ===> poly_rel ===> (=)) (=) (=) \\<and>\n  Domainp poly_rel = arith_ops_record.DP (poly_ops ops)\n\ngoal (1 subgoal):\n 1. ((bi_unique poly_rel \\<and> right_total poly_rel) \\<and>\n     poly_rel (arith_ops_record.zero (poly_ops ops)) 0 \\<and>\n     poly_rel (arith_ops_record.one (poly_ops ops)) 1 \\<and>\n     (poly_rel ===> poly_rel ===> poly_rel)\n      (arith_ops_record.plus (poly_ops ops)) (+)) \\<and>\n    ((poly_rel ===> poly_rel ===> poly_rel)\n      (arith_ops_record.minus (poly_ops ops)) (-) \\<and>\n     (poly_rel ===> poly_rel) (arith_ops_record.uminus (poly_ops ops))\n      uminus_class.uminus) \\<and>\n    (poly_rel ===> poly_rel ===> poly_rel)\n     (arith_ops_record.times (poly_ops ops)) (*) \\<and>\n    (poly_rel ===> poly_rel ===> (=)) (=) (=) \\<and>\n    Domainp poly_rel = arith_ops_record.DP (poly_ops ops)", "by auto"], ["", "end"], ["", "context idom_divide_ops\nbegin"], ["", "(* sdiv *)"], ["", "lemma poly_rel_sdiv[transfer_rule]: \"(poly_rel ===> R ===> poly_rel) (sdiv_i ops) sdiv_poly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> R ===> poly_rel) (sdiv_i ops) sdiv_poly", "unfolding rel_fun_def poly_rel_def coeffs_sdiv sdiv_i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       list_all2 R x (coeffs y) \\<longrightarrow>\n       (\\<forall>xa ya.\n           R xa ya \\<longrightarrow>\n           list_all2 R\n            (strip_while ((=) (arith_ops_record.zero ops))\n              (map (\\<lambda>c. arith_ops_record.divide ops c xa) x))\n            (strip_while ((=) (0::'a))\n              (map (\\<lambda>x. x div ya) (coeffs y))))", "proof (intro allI impI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>list_all2 R x (coeffs y); R xa ya\\<rbrakk>\n       \\<Longrightarrow> list_all2 R\n                          (strip_while ((=) (arith_ops_record.zero ops))\n                            (map (\\<lambda>c.\n                                     arith_ops_record.divide ops c xa)\n                              x))\n                          (strip_while ((=) (0::'a))\n                            (map (\\<lambda>x. x div ya) (coeffs y)))", "case (1 x y xs ys)"], ["proof (state)\nthis:\n  list_all2 R x (coeffs y)\n  R xs ys\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>list_all2 R x (coeffs y); R xa ya\\<rbrakk>\n       \\<Longrightarrow> list_all2 R\n                          (strip_while ((=) (arith_ops_record.zero ops))\n                            (map (\\<lambda>c.\n                                     arith_ops_record.divide ops c xa)\n                              x))\n                          (strip_while ((=) (0::'a))\n                            (map (\\<lambda>x. x div ya) (coeffs y)))", "note [transfer_rule] = 1"], ["proof (state)\nthis:\n  list_all2 R x (coeffs y)\n  R xs ys\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>list_all2 R x (coeffs y); R xa ya\\<rbrakk>\n       \\<Longrightarrow> list_all2 R\n                          (strip_while ((=) (arith_ops_record.zero ops))\n                            (map (\\<lambda>c.\n                                     arith_ops_record.divide ops c xa)\n                              x))\n                          (strip_while ((=) (0::'a))\n                            (map (\\<lambda>x. x div ya) (coeffs y)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R\n     (strip_while ((=) (arith_ops_record.zero ops))\n       (map (\\<lambda>c. arith_ops_record.divide ops c xs) x))\n     (strip_while ((=) (0::'a)) (map (\\<lambda>x. x div ys) (coeffs y)))", "by transfer_prover"], ["proof (state)\nthis:\n  list_all2 R\n   (strip_while ((=) (arith_ops_record.zero ops))\n     (map (\\<lambda>c. arith_ops_record.divide ops c xs) x))\n   (strip_while ((=) (0::'a)) (map (\\<lambda>x. x div ys) (coeffs y)))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context field_ops\nbegin"], ["", "(* division *)"], ["", "lemma poly_rel_div[transfer_rule]: \"(poly_rel ===> poly_rel ===> poly_rel) \n  (div_field_poly_i ops) (div)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> poly_rel ===> poly_rel) (div_field_poly_i ops) (div)", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>poly_rel x y; poly_rel xa ya\\<rbrakk>\n       \\<Longrightarrow> poly_rel (div_field_poly_i ops x xa) (y div ya)", "case (1 x X y Y)"], ["proof (state)\nthis:\n  poly_rel x X\n  poly_rel y Y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>poly_rel x y; poly_rel xa ya\\<rbrakk>\n       \\<Longrightarrow> poly_rel (div_field_poly_i ops x xa) (y div ya)", "note [transfer_rule] = this"], ["proof (state)\nthis:\n  poly_rel x X\n  poly_rel y Y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>poly_rel x y; poly_rel xa ya\\<rbrakk>\n       \\<Longrightarrow> poly_rel (div_field_poly_i ops x xa) (y div ya)", "note listall = this[unfolded poly_rel_def]"], ["proof (state)\nthis:\n  list_all2 R x (coeffs X)\n  list_all2 R y (coeffs Y)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>poly_rel x y; poly_rel xa ya\\<rbrakk>\n       \\<Longrightarrow> poly_rel (div_field_poly_i ops x xa) (y div ya)", "note defs = div_field_poly_impl div_field_poly_impl_def div_field_poly_i_def Let_def"], ["proof (state)\nthis:\n  (div) = div_field_poly_impl\n  div_field_poly_impl ?f ?g =\n  (let cg = coeffs ?g\n   in if cg = [] then 0\n      else let cf = coeffs ?f; ilc = inverse_class.inverse (last cg);\n               ch = map ((*) ilc) cg;\n               q = fst (divmod_poly_one_main_list [] (rev cf) (rev ch)\n                         (1 + length cf - length cg))\n           in poly_of_list (map ((*) ilc) q))\n  div_field_poly_i ?ops ?cf ?cg =\n  (if ?cg = [] then []\n   else let ilc = arith_ops_record.inverse ?ops (last ?cg);\n            ch = map (arith_ops_record.times ?ops ilc) ?cg;\n            q = fst (divmod_poly_one_main_i ?ops [] (rev ?cf) (rev ch)\n                      (1 + length ?cf - length ?cg))\n        in poly_of_list_i ?ops (map (arith_ops_record.times ?ops ilc) q))\n  Let ?s ?f \\<equiv> ?f ?s\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>poly_rel x y; poly_rel xa ya\\<rbrakk>\n       \\<Longrightarrow> poly_rel (div_field_poly_i ops x xa) (y div ya)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (div_field_poly_i ops x y) (X div Y)", "proof (cases \"y = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = [] \\<Longrightarrow> poly_rel (div_field_poly_i ops x y) (X div Y)\n 2. y \\<noteq> [] \\<Longrightarrow>\n    poly_rel (div_field_poly_i ops x y) (X div Y)", "case True"], ["proof (state)\nthis:\n  y = []\n\ngoal (2 subgoals):\n 1. y = [] \\<Longrightarrow> poly_rel (div_field_poly_i ops x y) (X div Y)\n 2. y \\<noteq> [] \\<Longrightarrow>\n    poly_rel (div_field_poly_i ops x y) (X div Y)", "with 1(2)"], ["proof (chain)\npicking this:\n  poly_rel y Y\n  y = []", "have nil: \"coeffs Y = []\""], ["proof (prove)\nusing this:\n  poly_rel y Y\n  y = []\n\ngoal (1 subgoal):\n 1. coeffs Y = []", "unfolding poly_rel_def"], ["proof (prove)\nusing this:\n  list_all2 R y (coeffs Y)\n  y = []\n\ngoal (1 subgoal):\n 1. coeffs Y = []", "by auto"], ["proof (state)\nthis:\n  coeffs Y = []\n\ngoal (2 subgoals):\n 1. y = [] \\<Longrightarrow> poly_rel (div_field_poly_i ops x y) (X div Y)\n 2. y \\<noteq> [] \\<Longrightarrow>\n    poly_rel (div_field_poly_i ops x y) (X div Y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (div_field_poly_i ops x y) (X div Y)", "unfolding defs True nil poly_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R\n     (if [] = [] then []\n      else poly_of_list_i ops\n            (map (arith_ops_record.times ops\n                   (arith_ops_record.inverse ops (last [])))\n              (fst (divmod_poly_one_main_i ops [] (rev x)\n                     (rev (map (arith_ops_record.times ops\n                                 (arith_ops_record.inverse ops (last [])))\n                            []))\n                     (1 + length x - length [])))))\n     (coeffs\n       (if [] = [] then 0\n        else poly_of_list\n              (map ((*) (inverse_class.inverse (last [])))\n                (fst (divmod_poly_one_main_list [] (rev (coeffs X))\n                       (rev (map ((*) (inverse_class.inverse (last [])))\n                              []))\n                       (1 + length (coeffs X) - length []))))))", "by auto"], ["proof (state)\nthis:\n  poly_rel (div_field_poly_i ops x y) (X div Y)\n\ngoal (1 subgoal):\n 1. y \\<noteq> [] \\<Longrightarrow>\n    poly_rel (div_field_poly_i ops x y) (X div Y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<noteq> [] \\<Longrightarrow>\n    poly_rel (div_field_poly_i ops x y) (X div Y)", "case False"], ["proof (state)\nthis:\n  y \\<noteq> []\n\ngoal (1 subgoal):\n 1. y \\<noteq> [] \\<Longrightarrow>\n    poly_rel (div_field_poly_i ops x y) (X div Y)", "from append_butlast_last_id[OF False]"], ["proof (chain)\npicking this:\n  butlast y @ [last y] = y", "obtain ys yl where y: \"y = ys @ [yl]\""], ["proof (prove)\nusing this:\n  butlast y @ [last y] = y\n\ngoal (1 subgoal):\n 1. (\\<And>ys yl. y = ys @ [yl] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  y = ys @ [yl]\n\ngoal (1 subgoal):\n 1. y \\<noteq> [] \\<Longrightarrow>\n    poly_rel (div_field_poly_i ops x y) (X div Y)", "from False listall"], ["proof (chain)\npicking this:\n  y \\<noteq> []\n  list_all2 R x (coeffs X)\n  list_all2 R y (coeffs Y)", "have \"coeffs Y \\<noteq> []\""], ["proof (prove)\nusing this:\n  y \\<noteq> []\n  list_all2 R x (coeffs X)\n  list_all2 R y (coeffs Y)\n\ngoal (1 subgoal):\n 1. coeffs Y \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  coeffs Y \\<noteq> []\n\ngoal (1 subgoal):\n 1. y \\<noteq> [] \\<Longrightarrow>\n    poly_rel (div_field_poly_i ops x y) (X div Y)", "from append_butlast_last_id[OF this]"], ["proof (chain)\npicking this:\n  butlast (coeffs Y) @ [last (coeffs Y)] = coeffs Y", "obtain Ys Yl where Y: \"coeffs Y = Ys @ [Yl]\""], ["proof (prove)\nusing this:\n  butlast (coeffs Y) @ [last (coeffs Y)] = coeffs Y\n\ngoal (1 subgoal):\n 1. (\\<And>Ys Yl.\n        coeffs Y = Ys @ [Yl] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  coeffs Y = Ys @ [Yl]\n\ngoal (1 subgoal):\n 1. y \\<noteq> [] \\<Longrightarrow>\n    poly_rel (div_field_poly_i ops x y) (X div Y)", "from listall"], ["proof (chain)\npicking this:\n  list_all2 R x (coeffs X)\n  list_all2 R y (coeffs Y)", "have [transfer_rule]: \"R yl Yl\""], ["proof (prove)\nusing this:\n  list_all2 R x (coeffs X)\n  list_all2 R y (coeffs Y)\n\ngoal (1 subgoal):\n 1. R yl Yl", "by (simp add: y Y)"], ["proof (state)\nthis:\n  R yl Yl\n\ngoal (1 subgoal):\n 1. y \\<noteq> [] \\<Longrightarrow>\n    poly_rel (div_field_poly_i ops x y) (X div Y)", "have id: \"last (coeffs Y) = Yl\" \"last (y) = yl\" \n      \"\\<And> t e. (if y = [] then t else e) = e\"\n      \"\\<And> t e. (if coeffs Y = [] then t else e) = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (last (coeffs Y) = Yl &&& last y = yl) &&&\n    (\\<And>t e. (if y = [] then t else e) = e) &&&\n    (\\<And>t e. (if coeffs Y = [] then t else e) = e)", "unfolding y Y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (last (Ys @ [Yl]) = Yl &&& last (ys @ [yl]) = yl) &&&\n    (\\<And>t e. (if ys @ [yl] = [] then t else e) = e) &&&\n    (\\<And>t e. (if Ys @ [Yl] = [] then t else e) = e)", "by auto"], ["proof (state)\nthis:\n  last (coeffs Y) = Yl\n  last y = yl\n  (if y = [] then ?t else ?e) = ?e\n  (if coeffs Y = [] then ?t else ?e) = ?e\n\ngoal (1 subgoal):\n 1. y \\<noteq> [] \\<Longrightarrow>\n    poly_rel (div_field_poly_i ops x y) (X div Y)", "have [transfer_rule]: \"(rel_prod (list_all2 R) (list_all2 R)) \n      (divmod_poly_one_main_i ops [] (rev x) (rev (map (times (inverse yl)) y))\n        (1 + length x - length y))\n      (divmod_poly_one_main_list [] (rev (coeffs X))\n                (rev (map ((*) (Fields.inverse Yl)) (coeffs Y)))\n                (1 + length (coeffs X) - length (coeffs Y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod (list_all2 R) (list_all2 R)\n     (divmod_poly_one_main_i ops [] (rev x)\n       (rev (map (arith_ops_record.times ops\n                   (arith_ops_record.inverse ops yl))\n              y))\n       (1 + length x - length y))\n     (divmod_poly_one_main_list [] (rev (coeffs X))\n       (rev (map ((*) (inverse_class.inverse Yl)) (coeffs Y)))\n       (1 + length (coeffs X) - length (coeffs Y)))", "proof (rule divmod_poly_one_main_i, goal_cases)"], ["proof (state)\ngoal (5 subgoals):\n 1. 1 + length x - length y \\<le> length (rev (coeffs X))\n 2. list_all2 R [] []\n 3. list_all2 R (rev x) (rev (coeffs X))\n 4. list_all2 R\n     (rev (map (arith_ops_record.times ops\n                 (arith_ops_record.inverse ops yl))\n            y))\n     (rev (map ((*) (inverse_class.inverse Yl)) (coeffs Y)))\n 5. 1 + length x - length y = 1 + length (coeffs X) - length (coeffs Y)", "case 5"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. 1 + length x - length y \\<le> length (rev (coeffs X))\n 2. list_all2 R [] []\n 3. list_all2 R (rev x) (rev (coeffs X))\n 4. list_all2 R\n     (rev (map (arith_ops_record.times ops\n                 (arith_ops_record.inverse ops yl))\n            y))\n     (rev (map ((*) (inverse_class.inverse Yl)) (coeffs Y)))\n 5. 1 + length x - length y = 1 + length (coeffs X) - length (coeffs Y)", "from listall"], ["proof (chain)\npicking this:\n  list_all2 R x (coeffs X)\n  list_all2 R y (coeffs Y)", "show ?case"], ["proof (prove)\nusing this:\n  list_all2 R x (coeffs X)\n  list_all2 R y (coeffs Y)\n\ngoal (1 subgoal):\n 1. 1 + length x - length y = 1 + length (coeffs X) - length (coeffs Y)", "by (simp add: list_all2_lengthD)"], ["proof (state)\nthis:\n  1 + length x - length y = 1 + length (coeffs X) - length (coeffs Y)\n\ngoal (4 subgoals):\n 1. 1 + length x - length y \\<le> length (rev (coeffs X))\n 2. list_all2 R [] []\n 3. list_all2 R (rev x) (rev (coeffs X))\n 4. list_all2 R\n     (rev (map (arith_ops_record.times ops\n                 (arith_ops_record.inverse ops yl))\n            y))\n     (rev (map ((*) (inverse_class.inverse Yl)) (coeffs Y)))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. 1 + length x - length y \\<le> length (rev (coeffs X))\n 2. list_all2 R [] []\n 3. list_all2 R (rev x) (rev (coeffs X))\n 4. list_all2 R\n     (rev (map (arith_ops_record.times ops\n                 (arith_ops_record.inverse ops yl))\n            y))\n     (rev (map ((*) (inverse_class.inverse Yl)) (coeffs Y)))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. 1 + length x - length y \\<le> length (rev (coeffs X))\n 2. list_all2 R [] []\n 3. list_all2 R (rev x) (rev (coeffs X))\n 4. list_all2 R\n     (rev (map (arith_ops_record.times ops\n                 (arith_ops_record.inverse ops yl))\n            y))\n     (rev (map ((*) (inverse_class.inverse Yl)) (coeffs Y)))", "from listall"], ["proof (chain)\npicking this:\n  list_all2 R x (coeffs X)\n  list_all2 R y (coeffs Y)", "show ?case"], ["proof (prove)\nusing this:\n  list_all2 R x (coeffs X)\n  list_all2 R y (coeffs Y)\n\ngoal (1 subgoal):\n 1. 1 + length x - length y \\<le> length (rev (coeffs X))", "by (simp add: list_all2_lengthD Y)"], ["proof (state)\nthis:\n  1 + length x - length y \\<le> length (rev (coeffs X))\n\ngoal (3 subgoals):\n 1. list_all2 R [] []\n 2. list_all2 R (rev x) (rev (coeffs X))\n 3. list_all2 R\n     (rev (map (arith_ops_record.times ops\n                 (arith_ops_record.inverse ops yl))\n            y))\n     (rev (map ((*) (inverse_class.inverse Yl)) (coeffs Y)))", "qed transfer_prover+"], ["proof (state)\nthis:\n  rel_prod (list_all2 R) (list_all2 R)\n   (divmod_poly_one_main_i ops [] (rev x)\n     (rev (map (arith_ops_record.times ops\n                 (arith_ops_record.inverse ops yl))\n            y))\n     (1 + length x - length y))\n   (divmod_poly_one_main_list [] (rev (coeffs X))\n     (rev (map ((*) (inverse_class.inverse Yl)) (coeffs Y)))\n     (1 + length (coeffs X) - length (coeffs Y)))\n\ngoal (1 subgoal):\n 1. y \\<noteq> [] \\<Longrightarrow>\n    poly_rel (div_field_poly_i ops x y) (X div Y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (div_field_poly_i ops x y) (X div Y)", "unfolding defs id"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel\n     (poly_of_list_i ops\n       (map (arith_ops_record.times ops (arith_ops_record.inverse ops yl))\n         (fst (divmod_poly_one_main_i ops [] (rev x)\n                (rev (map (arith_ops_record.times ops\n                            (arith_ops_record.inverse ops yl))\n                       y))\n                (1 + length x - length y)))))\n     (poly_of_list\n       (map ((*) (inverse_class.inverse Yl))\n         (fst (divmod_poly_one_main_list [] (rev (coeffs X))\n                (rev (map ((*) (inverse_class.inverse Yl)) (coeffs Y)))\n                (1 + length (coeffs X) - length (coeffs Y))))))", "by transfer_prover"], ["proof (state)\nthis:\n  poly_rel (div_field_poly_i ops x y) (X div Y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_rel (div_field_poly_i ops x y) (X div Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* modulo *)"], ["", "lemma poly_rel_mod[transfer_rule]: \"(poly_rel ===> poly_rel ===> poly_rel) \n  (mod_field_poly_i ops) (mod)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> poly_rel ===> poly_rel) (mod_field_poly_i ops) (mod)", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>poly_rel x y; poly_rel xa ya\\<rbrakk>\n       \\<Longrightarrow> poly_rel (mod_field_poly_i ops x xa) (y mod ya)", "case (1 x X y Y)"], ["proof (state)\nthis:\n  poly_rel x X\n  poly_rel y Y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>poly_rel x y; poly_rel xa ya\\<rbrakk>\n       \\<Longrightarrow> poly_rel (mod_field_poly_i ops x xa) (y mod ya)", "note [transfer_rule] = this"], ["proof (state)\nthis:\n  poly_rel x X\n  poly_rel y Y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>poly_rel x y; poly_rel xa ya\\<rbrakk>\n       \\<Longrightarrow> poly_rel (mod_field_poly_i ops x xa) (y mod ya)", "note listall = this[unfolded poly_rel_def]"], ["proof (state)\nthis:\n  list_all2 R x (coeffs X)\n  list_all2 R y (coeffs Y)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>poly_rel x y; poly_rel xa ya\\<rbrakk>\n       \\<Longrightarrow> poly_rel (mod_field_poly_i ops x xa) (y mod ya)", "note defs = mod_poly_code mod_field_poly_i_def Let_def"], ["proof (state)\nthis:\n  ?f mod ?g =\n  (let cg = coeffs ?g\n   in if cg = [] then ?f\n      else let cf = coeffs ?f; ilc = inverse_class.inverse (last cg);\n               ch = map ((*) ilc) cg;\n               r = mod_poly_one_main_list (rev cf) (rev ch)\n                    (1 + length cf - length cg)\n           in poly_of_list (rev r))\n  mod_field_poly_i ?ops ?cf ?cg =\n  (if ?cg = [] then ?cf\n   else let ilc = arith_ops_record.inverse ?ops (last ?cg);\n            ch = map (arith_ops_record.times ?ops ilc) ?cg;\n            r = mod_poly_one_main_i ?ops (rev ?cf) (rev ch)\n                 (1 + length ?cf - length ?cg)\n        in poly_of_list_i ?ops (rev r))\n  Let ?s ?f \\<equiv> ?f ?s\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>poly_rel x y; poly_rel xa ya\\<rbrakk>\n       \\<Longrightarrow> poly_rel (mod_field_poly_i ops x xa) (y mod ya)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (mod_field_poly_i ops x y) (X mod Y)", "proof (cases \"y = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = [] \\<Longrightarrow> poly_rel (mod_field_poly_i ops x y) (X mod Y)\n 2. y \\<noteq> [] \\<Longrightarrow>\n    poly_rel (mod_field_poly_i ops x y) (X mod Y)", "case True"], ["proof (state)\nthis:\n  y = []\n\ngoal (2 subgoals):\n 1. y = [] \\<Longrightarrow> poly_rel (mod_field_poly_i ops x y) (X mod Y)\n 2. y \\<noteq> [] \\<Longrightarrow>\n    poly_rel (mod_field_poly_i ops x y) (X mod Y)", "with 1(2)"], ["proof (chain)\npicking this:\n  poly_rel y Y\n  y = []", "have nil: \"coeffs Y = []\""], ["proof (prove)\nusing this:\n  poly_rel y Y\n  y = []\n\ngoal (1 subgoal):\n 1. coeffs Y = []", "unfolding poly_rel_def"], ["proof (prove)\nusing this:\n  list_all2 R y (coeffs Y)\n  y = []\n\ngoal (1 subgoal):\n 1. coeffs Y = []", "by auto"], ["proof (state)\nthis:\n  coeffs Y = []\n\ngoal (2 subgoals):\n 1. y = [] \\<Longrightarrow> poly_rel (mod_field_poly_i ops x y) (X mod Y)\n 2. y \\<noteq> [] \\<Longrightarrow>\n    poly_rel (mod_field_poly_i ops x y) (X mod Y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (mod_field_poly_i ops x y) (X mod Y)", "unfolding defs True nil poly_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R\n     (if [] = [] then x\n      else poly_of_list_i ops\n            (rev (mod_poly_one_main_i ops (rev x)\n                   (rev (map (arith_ops_record.times ops\n                               (arith_ops_record.inverse ops (last [])))\n                          []))\n                   (1 + length x - length []))))\n     (coeffs\n       (if [] = [] then X\n        else poly_of_list\n              (rev (mod_poly_one_main_list (rev (coeffs X))\n                     (rev (map ((*) (inverse_class.inverse (last []))) []))\n                     (1 + length (coeffs X) - length [])))))", "by (simp add: listall)"], ["proof (state)\nthis:\n  poly_rel (mod_field_poly_i ops x y) (X mod Y)\n\ngoal (1 subgoal):\n 1. y \\<noteq> [] \\<Longrightarrow>\n    poly_rel (mod_field_poly_i ops x y) (X mod Y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<noteq> [] \\<Longrightarrow>\n    poly_rel (mod_field_poly_i ops x y) (X mod Y)", "case False"], ["proof (state)\nthis:\n  y \\<noteq> []\n\ngoal (1 subgoal):\n 1. y \\<noteq> [] \\<Longrightarrow>\n    poly_rel (mod_field_poly_i ops x y) (X mod Y)", "from append_butlast_last_id[OF False]"], ["proof (chain)\npicking this:\n  butlast y @ [last y] = y", "obtain ys yl where y: \"y = ys @ [yl]\""], ["proof (prove)\nusing this:\n  butlast y @ [last y] = y\n\ngoal (1 subgoal):\n 1. (\\<And>ys yl. y = ys @ [yl] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  y = ys @ [yl]\n\ngoal (1 subgoal):\n 1. y \\<noteq> [] \\<Longrightarrow>\n    poly_rel (mod_field_poly_i ops x y) (X mod Y)", "from False listall"], ["proof (chain)\npicking this:\n  y \\<noteq> []\n  list_all2 R x (coeffs X)\n  list_all2 R y (coeffs Y)", "have \"coeffs Y \\<noteq> []\""], ["proof (prove)\nusing this:\n  y \\<noteq> []\n  list_all2 R x (coeffs X)\n  list_all2 R y (coeffs Y)\n\ngoal (1 subgoal):\n 1. coeffs Y \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  coeffs Y \\<noteq> []\n\ngoal (1 subgoal):\n 1. y \\<noteq> [] \\<Longrightarrow>\n    poly_rel (mod_field_poly_i ops x y) (X mod Y)", "from append_butlast_last_id[OF this]"], ["proof (chain)\npicking this:\n  butlast (coeffs Y) @ [last (coeffs Y)] = coeffs Y", "obtain Ys Yl where Y: \"coeffs Y = Ys @ [Yl]\""], ["proof (prove)\nusing this:\n  butlast (coeffs Y) @ [last (coeffs Y)] = coeffs Y\n\ngoal (1 subgoal):\n 1. (\\<And>Ys Yl.\n        coeffs Y = Ys @ [Yl] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  coeffs Y = Ys @ [Yl]\n\ngoal (1 subgoal):\n 1. y \\<noteq> [] \\<Longrightarrow>\n    poly_rel (mod_field_poly_i ops x y) (X mod Y)", "from listall"], ["proof (chain)\npicking this:\n  list_all2 R x (coeffs X)\n  list_all2 R y (coeffs Y)", "have [transfer_rule]: \"R yl Yl\""], ["proof (prove)\nusing this:\n  list_all2 R x (coeffs X)\n  list_all2 R y (coeffs Y)\n\ngoal (1 subgoal):\n 1. R yl Yl", "by (simp add: y Y)"], ["proof (state)\nthis:\n  R yl Yl\n\ngoal (1 subgoal):\n 1. y \\<noteq> [] \\<Longrightarrow>\n    poly_rel (mod_field_poly_i ops x y) (X mod Y)", "have id: \"last (coeffs Y) = Yl\" \"last (y) = yl\" \n      \"\\<And> t e. (if y = [] then t else e) = e\"\n      \"\\<And> t e. (if coeffs Y = [] then t else e) = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (last (coeffs Y) = Yl &&& last y = yl) &&&\n    (\\<And>t e. (if y = [] then t else e) = e) &&&\n    (\\<And>t e. (if coeffs Y = [] then t else e) = e)", "unfolding y Y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (last (Ys @ [Yl]) = Yl &&& last (ys @ [yl]) = yl) &&&\n    (\\<And>t e. (if ys @ [yl] = [] then t else e) = e) &&&\n    (\\<And>t e. (if Ys @ [Yl] = [] then t else e) = e)", "by auto"], ["proof (state)\nthis:\n  last (coeffs Y) = Yl\n  last y = yl\n  (if y = [] then ?t else ?e) = ?e\n  (if coeffs Y = [] then ?t else ?e) = ?e\n\ngoal (1 subgoal):\n 1. y \\<noteq> [] \\<Longrightarrow>\n    poly_rel (mod_field_poly_i ops x y) (X mod Y)", "have [transfer_rule]: \"list_all2 R\n      (mod_poly_one_main_i ops (rev x) (rev (map (times (inverse yl)) y))\n        (1 + length x - length y))\n      (mod_poly_one_main_list (rev (coeffs X))\n                (rev (map ((*) (Fields.inverse Yl)) (coeffs Y)))\n                (1 + length (coeffs X) - length (coeffs Y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R\n     (mod_poly_one_main_i ops (rev x)\n       (rev (map (arith_ops_record.times ops\n                   (arith_ops_record.inverse ops yl))\n              y))\n       (1 + length x - length y))\n     (mod_poly_one_main_list (rev (coeffs X))\n       (rev (map ((*) (inverse_class.inverse Yl)) (coeffs Y)))\n       (1 + length (coeffs X) - length (coeffs Y)))", "proof (rule mod_poly_one_main_i, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. 1 + length x - length y \\<le> length (rev (coeffs X))\n 2. list_all2 R (rev x) (rev (coeffs X))\n 3. list_all2 R\n     (rev (map (arith_ops_record.times ops\n                 (arith_ops_record.inverse ops yl))\n            y))\n     (rev (map ((*) (inverse_class.inverse Yl)) (coeffs Y)))\n 4. 1 + length x - length y = 1 + length (coeffs X) - length (coeffs Y)", "case 4"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. 1 + length x - length y \\<le> length (rev (coeffs X))\n 2. list_all2 R (rev x) (rev (coeffs X))\n 3. list_all2 R\n     (rev (map (arith_ops_record.times ops\n                 (arith_ops_record.inverse ops yl))\n            y))\n     (rev (map ((*) (inverse_class.inverse Yl)) (coeffs Y)))\n 4. 1 + length x - length y = 1 + length (coeffs X) - length (coeffs Y)", "from listall"], ["proof (chain)\npicking this:\n  list_all2 R x (coeffs X)\n  list_all2 R y (coeffs Y)", "show ?case"], ["proof (prove)\nusing this:\n  list_all2 R x (coeffs X)\n  list_all2 R y (coeffs Y)\n\ngoal (1 subgoal):\n 1. 1 + length x - length y = 1 + length (coeffs X) - length (coeffs Y)", "by (simp add: list_all2_lengthD)"], ["proof (state)\nthis:\n  1 + length x - length y = 1 + length (coeffs X) - length (coeffs Y)\n\ngoal (3 subgoals):\n 1. 1 + length x - length y \\<le> length (rev (coeffs X))\n 2. list_all2 R (rev x) (rev (coeffs X))\n 3. list_all2 R\n     (rev (map (arith_ops_record.times ops\n                 (arith_ops_record.inverse ops yl))\n            y))\n     (rev (map ((*) (inverse_class.inverse Yl)) (coeffs Y)))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. 1 + length x - length y \\<le> length (rev (coeffs X))\n 2. list_all2 R (rev x) (rev (coeffs X))\n 3. list_all2 R\n     (rev (map (arith_ops_record.times ops\n                 (arith_ops_record.inverse ops yl))\n            y))\n     (rev (map ((*) (inverse_class.inverse Yl)) (coeffs Y)))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. 1 + length x - length y \\<le> length (rev (coeffs X))\n 2. list_all2 R (rev x) (rev (coeffs X))\n 3. list_all2 R\n     (rev (map (arith_ops_record.times ops\n                 (arith_ops_record.inverse ops yl))\n            y))\n     (rev (map ((*) (inverse_class.inverse Yl)) (coeffs Y)))", "from listall"], ["proof (chain)\npicking this:\n  list_all2 R x (coeffs X)\n  list_all2 R y (coeffs Y)", "show ?case"], ["proof (prove)\nusing this:\n  list_all2 R x (coeffs X)\n  list_all2 R y (coeffs Y)\n\ngoal (1 subgoal):\n 1. 1 + length x - length y \\<le> length (rev (coeffs X))", "by (simp add: list_all2_lengthD Y)"], ["proof (state)\nthis:\n  1 + length x - length y \\<le> length (rev (coeffs X))\n\ngoal (2 subgoals):\n 1. list_all2 R (rev x) (rev (coeffs X))\n 2. list_all2 R\n     (rev (map (arith_ops_record.times ops\n                 (arith_ops_record.inverse ops yl))\n            y))\n     (rev (map ((*) (inverse_class.inverse Yl)) (coeffs Y)))", "qed transfer_prover+"], ["proof (state)\nthis:\n  list_all2 R\n   (mod_poly_one_main_i ops (rev x)\n     (rev (map (arith_ops_record.times ops\n                 (arith_ops_record.inverse ops yl))\n            y))\n     (1 + length x - length y))\n   (mod_poly_one_main_list (rev (coeffs X))\n     (rev (map ((*) (inverse_class.inverse Yl)) (coeffs Y)))\n     (1 + length (coeffs X) - length (coeffs Y)))\n\ngoal (1 subgoal):\n 1. y \\<noteq> [] \\<Longrightarrow>\n    poly_rel (mod_field_poly_i ops x y) (X mod Y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel (mod_field_poly_i ops x y) (X mod Y)", "unfolding defs id"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel\n     (poly_of_list_i ops\n       (rev (mod_poly_one_main_i ops (rev x)\n              (rev (map (arith_ops_record.times ops\n                          (arith_ops_record.inverse ops yl))\n                     y))\n              (1 + length x - length y))))\n     (poly_of_list\n       (rev (mod_poly_one_main_list (rev (coeffs X))\n              (rev (map ((*) (inverse_class.inverse Yl)) (coeffs Y)))\n              (1 + length (coeffs X) - length (coeffs Y)))))", "by transfer_prover"], ["proof (state)\nthis:\n  poly_rel (mod_field_poly_i ops x y) (X mod Y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_rel (mod_field_poly_i ops x y) (X mod Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* normalize *)"], ["", "lemma poly_rel_normalize [transfer_rule]: \"(poly_rel ===> poly_rel) \n  (normalize_poly_i ops) Rings.normalize\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> poly_rel) (normalize_poly_i ops)\n     normalization_semidom_class.normalize", "unfolding normalize_poly_old_def normalize_poly_i_def lead_coeff_i_def'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> poly_rel)\n     (\\<lambda>xs.\n         smult_i ops\n          (arith_ops_record.inverse ops\n            (arith_ops_record.unit_factor ops\n              (coeff_i ops xs (degree_i xs))))\n          xs)\n     (\\<lambda>f.\n         smult\n          (inverse_class.inverse\n            (unit_factor_class.unit_factor (lead_coeff f)))\n          f)", "by transfer_prover"], ["", "(* unit_factor *)"], ["", "lemma poly_rel_unit_factor [transfer_rule]: \"(poly_rel ===> poly_rel) \n  (unit_factor_poly_i ops) Rings.unit_factor\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> poly_rel) (unit_factor_poly_i ops)\n     unit_factor_class.unit_factor", "unfolding unit_factor_poly_def unit_factor_poly_i_def lead_coeff_i_def'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> poly_rel)\n     (\\<lambda>xs.\n         cCons_i ops\n          (arith_ops_record.unit_factor ops (coeff_i ops xs (degree_i xs)))\n          [])\n     (\\<lambda>p. [:unit_factor_class.unit_factor (lead_coeff p):])", "unfolding monom_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> poly_rel)\n     (\\<lambda>xs.\n         cCons_i ops\n          (arith_ops_record.unit_factor ops (coeff_i ops xs (degree_i xs)))\n          [])\n     (\\<lambda>p. [:unit_factor_class.unit_factor (lead_coeff p):])", "by transfer_prover"], ["", "lemma idom_divide_ops_poly: \"idom_divide_ops (poly_ops ops) poly_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idom_divide_ops (poly_ops ops) poly_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. idom_divide_ops (poly_ops ops) poly_rel", "interpret poly: idom_ops \"poly_ops ops\" poly_rel"], ["proof (prove)\ngoal (1 subgoal):\n 1. idom_ops (poly_ops ops) poly_rel", "by (rule idom_ops_poly)"], ["proof (state)\ngoal (1 subgoal):\n 1. idom_divide_ops (poly_ops ops) poly_rel", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. idom_divide_ops (poly_ops ops) poly_rel", "by (unfold_locales, simp add: poly_rel_div poly_ops_def)"], ["proof (state)\nthis:\n  idom_divide_ops (poly_ops ops) poly_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma euclidean_ring_ops_poly: \"euclidean_ring_ops (poly_ops ops) poly_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. euclidean_ring_ops (poly_ops ops) poly_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. euclidean_ring_ops (poly_ops ops) poly_rel", "interpret poly: idom_ops \"poly_ops ops\" poly_rel"], ["proof (prove)\ngoal (1 subgoal):\n 1. idom_ops (poly_ops ops) poly_rel", "by (rule idom_ops_poly)"], ["proof (state)\ngoal (1 subgoal):\n 1. euclidean_ring_ops (poly_ops ops) poly_rel", "have id: \"arith_ops_record.normalize (poly_ops ops) = normalize_poly_i ops\"\n    \"arith_ops_record.unit_factor (poly_ops ops) = unit_factor_poly_i ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_ops_record.normalize (poly_ops ops) = normalize_poly_i ops &&&\n    arith_ops_record.unit_factor (poly_ops ops) = unit_factor_poly_i ops", "unfolding poly_ops_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_ops_record.normalize\n     (Arith_Ops_Record [] (one_poly_i ops) (plus_poly_i ops)\n       (times_poly_i ops) (minus_poly_i ops) (uminus_poly_i ops)\n       (div_field_poly_i ops) (\\<lambda>_. []) (mod_field_poly_i ops)\n       (normalize_poly_i ops) (unit_factor_poly_i ops)\n       (\\<lambda>i. if i = 0 then [] else [arith_ops_record.of_int ops i])\n       (\\<lambda>_. 0) (is_poly ops)) =\n    normalize_poly_i ops &&&\n    arith_ops_record.unit_factor\n     (Arith_Ops_Record [] (one_poly_i ops) (plus_poly_i ops)\n       (times_poly_i ops) (minus_poly_i ops) (uminus_poly_i ops)\n       (div_field_poly_i ops) (\\<lambda>_. []) (mod_field_poly_i ops)\n       (normalize_poly_i ops) (unit_factor_poly_i ops)\n       (\\<lambda>i. if i = 0 then [] else [arith_ops_record.of_int ops i])\n       (\\<lambda>_. 0) (is_poly ops)) =\n    unit_factor_poly_i ops", "by simp_all"], ["proof (state)\nthis:\n  arith_ops_record.normalize (poly_ops ops) = normalize_poly_i ops\n  arith_ops_record.unit_factor (poly_ops ops) = unit_factor_poly_i ops\n\ngoal (1 subgoal):\n 1. euclidean_ring_ops (poly_ops ops) poly_rel", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. euclidean_ring_ops (poly_ops ops) poly_rel", "by (unfold_locales, simp add: poly_rel_mod poly_ops_def, unfold id, \n      simp add: poly_rel_normalize, insert poly_rel_div poly_rel_unit_factor, \n      auto simp: poly_ops_def)"], ["proof (state)\nthis:\n  euclidean_ring_ops (poly_ops ops) poly_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "(* gcd poly *)"], ["", "lemma poly_rel_gcd [transfer_rule]: \"(poly_rel ===> poly_rel ===> poly_rel) (gcd_poly_i ops) gcd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> poly_rel ===> poly_rel) (gcd_poly_i ops) gcd", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (poly_rel ===> poly_rel ===> poly_rel) (gcd_poly_i ops) gcd", "interpret poly: euclidean_ring_ops \"poly_ops ops\" poly_rel"], ["proof (prove)\ngoal (1 subgoal):\n 1. euclidean_ring_ops (poly_ops ops) poly_rel", "by (rule euclidean_ring_ops_poly)"], ["proof (state)\ngoal (1 subgoal):\n 1. (poly_rel ===> poly_rel ===> poly_rel) (gcd_poly_i ops) gcd", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===> poly_rel ===> poly_rel) (gcd_poly_i ops) gcd", "using poly.gcd_eucl_i"], ["proof (prove)\nusing this:\n  (poly_rel ===> poly_rel ===> poly_rel) poly.gcd_eucl_i\n   normalization_euclidean_semiring_class.gcd\n\ngoal (1 subgoal):\n 1. (poly_rel ===> poly_rel ===> poly_rel) (gcd_poly_i ops) gcd", "unfolding gcd_poly_i_def gcd_eucl"], ["proof (prove)\nusing this:\n  (poly_rel ===> poly_rel ===> poly_rel) poly.gcd_eucl_i gcd\n\ngoal (1 subgoal):\n 1. (poly_rel ===> poly_rel ===> poly_rel) poly.gcd_eucl_i gcd", "."], ["proof (state)\nthis:\n  (poly_rel ===> poly_rel ===> poly_rel) (gcd_poly_i ops) gcd\n\ngoal:\nNo subgoals!", "qed"], ["", "(* euclid_ext poly *)"], ["", "lemma poly_rel_euclid_ext [transfer_rule]: \"(poly_rel ===> poly_rel ===> \n  rel_prod (rel_prod poly_rel poly_rel) poly_rel) (euclid_ext_poly_i ops) euclid_ext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===>\n     poly_rel ===> rel_prod (rel_prod poly_rel poly_rel) poly_rel)\n     (euclid_ext_poly_i ops) (euclid_ext_aux 1 0 0 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (poly_rel ===>\n     poly_rel ===> rel_prod (rel_prod poly_rel poly_rel) poly_rel)\n     (euclid_ext_poly_i ops) (euclid_ext_aux 1 0 0 1)", "interpret poly: euclidean_ring_ops \"poly_ops ops\" poly_rel"], ["proof (prove)\ngoal (1 subgoal):\n 1. euclidean_ring_ops (poly_ops ops) poly_rel", "by (rule euclidean_ring_ops_poly)"], ["proof (state)\ngoal (1 subgoal):\n 1. (poly_rel ===>\n     poly_rel ===> rel_prod (rel_prod poly_rel poly_rel) poly_rel)\n     (euclid_ext_poly_i ops) (euclid_ext_aux 1 0 0 1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_rel ===>\n     poly_rel ===> rel_prod (rel_prod poly_rel poly_rel) poly_rel)\n     (euclid_ext_poly_i ops) (euclid_ext_aux 1 0 0 1)", "using poly.euclid_ext_i"], ["proof (prove)\nusing this:\n  (poly_rel ===>\n   poly_rel ===> rel_prod (rel_prod poly_rel poly_rel) poly_rel)\n   (poly.euclid_ext_aux_i (arith_ops_record.one (poly_ops ops))\n     (arith_ops_record.zero (poly_ops ops))\n     (arith_ops_record.zero (poly_ops ops))\n     (arith_ops_record.one (poly_ops ops)))\n   (euclid_ext_aux 1 0 0 1)\n\ngoal (1 subgoal):\n 1. (poly_rel ===>\n     poly_rel ===> rel_prod (rel_prod poly_rel poly_rel) poly_rel)\n     (euclid_ext_poly_i ops) (euclid_ext_aux 1 0 0 1)", "unfolding euclid_ext_poly_i_def"], ["proof (prove)\nusing this:\n  (poly_rel ===>\n   poly_rel ===> rel_prod (rel_prod poly_rel poly_rel) poly_rel)\n   (poly.euclid_ext_aux_i (arith_ops_record.one (poly_ops ops))\n     (arith_ops_record.zero (poly_ops ops))\n     (arith_ops_record.zero (poly_ops ops))\n     (arith_ops_record.one (poly_ops ops)))\n   (euclid_ext_aux 1 0 0 1)\n\ngoal (1 subgoal):\n 1. (poly_rel ===>\n     poly_rel ===> rel_prod (rel_prod poly_rel poly_rel) poly_rel)\n     (poly.euclid_ext_aux_i (arith_ops_record.one (poly_ops ops))\n       (arith_ops_record.zero (poly_ops ops))\n       (arith_ops_record.zero (poly_ops ops))\n       (arith_ops_record.one (poly_ops ops)))\n     (euclid_ext_aux 1 0 0 1)", "."], ["proof (state)\nthis:\n  (poly_rel ===>\n   poly_rel ===> rel_prod (rel_prod poly_rel poly_rel) poly_rel)\n   (euclid_ext_poly_i ops) (euclid_ext_aux 1 0 0 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* ********************************************************** *)"], ["", "context ring_ops\nbegin"], ["", "notepad (* checking transfer rules *)\nbegin"], ["proof (state)", "fix xs x ys y"], ["proof (state)", "assume [transfer_rule]: \"poly_rel xs x\" \"poly_rel ys y\""], ["proof (state)\nthis:\n  poly_rel xs x\n  poly_rel ys y", "have \"x * y = y * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y = y * x", "by simp"], ["proof (state)\nthis:\n  x * y = y * x", "from this[untransferred]"], ["proof (chain)\npicking this:\n  times_poly_i ops xs ys = times_poly_i ops ys xs", "have \"times_poly_i ops xs ys = times_poly_i ops ys xs\""], ["proof (prove)\nusing this:\n  times_poly_i ops xs ys = times_poly_i ops ys xs\n\ngoal (1 subgoal):\n 1. times_poly_i ops xs ys = times_poly_i ops ys xs", "."], ["proof (state)\nthis:\n  times_poly_i ops xs ys = times_poly_i ops ys xs", "end"], ["", "end"], ["", "end"]]}